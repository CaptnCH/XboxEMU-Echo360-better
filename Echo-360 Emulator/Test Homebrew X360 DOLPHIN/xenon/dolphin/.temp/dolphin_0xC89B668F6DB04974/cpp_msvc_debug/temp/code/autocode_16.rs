#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 821001C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821001C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821001C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821001C8);
		  /* 821001C8h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 821001C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 821001C8h case    0:*/		return 0x821001CC;
		  /* 821001CCh */ case    1:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 821001CCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 821001CCh case    1:*/		return 0x821001D0;
		  /* 821001D0h */ case    2:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821001D0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821001D0h case    2:*/		return 0x821001D4;
		  /* 821001D4h */ case    3:  		/* lwz R9, <#[R11 + 60]> */
		/* 821001D4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000003C) );
		/* 821001D4h case    3:*/		return 0x821001D8;
		  /* 821001D8h */ case    4:  		/* oris R9, R9, 8 */
		/* 821001D8h case    4:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x8);
		/* 821001D8h case    4:*/		return 0x821001DC;
		  /* 821001DCh */ case    5:  		/* stw R9, <#[R11 + 60]> */
		/* 821001DCh case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000003C) );
		/* 821001DCh case    5:*/		return 0x821001E0;
		  /* 821001E0h */ case    6:  		/* lwz R11, <#[R31 + 20]> */
		/* 821001E0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 821001E0h case    6:*/		return 0x821001E4;
		  /* 821001E4h */ case    7:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821001E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821001E4h case    7:*/		return 0x821001E8;
		  /* 821001E8h */ case    8:  		/* stw R30, <#[R11 + 56]> */
		/* 821001E8h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000038) );
		/* 821001E8h case    8:*/		return 0x821001EC;
	}
	return 0x821001EC;
} // Block from 821001C8h-821001ECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821001ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821001EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821001EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821001EC);
		  /* 821001ECh */ case    0:  		/* addi R1, R1, 112 */
		/* 821001ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821001ECh case    0:*/		return 0x821001F0;
		  /* 821001F0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821001F0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821001F0h case    1:*/		return 0x821001F4;
		  /* 821001F4h */ case    2:  		/* mtspr LR, R12 */
		/* 821001F4h case    2:*/		regs.LR = regs.R12;
		/* 821001F4h case    2:*/		return 0x821001F8;
		  /* 821001F8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821001F8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821001F8h case    3:*/		return 0x821001FC;
		  /* 821001FCh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821001FCh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821001FCh case    4:*/		return 0x82100200;
		  /* 82100200h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82100200h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82100200h case    5:*/		return 0x82100204;
	}
	return 0x82100204;
} // Block from 821001ECh-82100204h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82100204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100204);
		  /* 82100204h */ case    0:  		/* nop */
		/* 82100204h case    0:*/		cpu::op::nop();
		/* 82100204h case    0:*/		return 0x82100208;
	}
	return 0x82100208;
} // Block from 82100204h-82100208h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82100208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100208);
		  /* 82100208h */ case    0:  		/* mfspr R12, LR */
		/* 82100208h case    0:*/		regs.R12 = regs.LR;
		/* 82100208h case    0:*/		return 0x8210020C;
		  /* 8210020Ch */ case    1:  		/* bl -454584 */
		/* 8210020Ch case    1:*/		regs.LR = 0x82100210; return 0x82091254;
		/* 8210020Ch case    1:*/		return 0x82100210;
		  /* 82100210h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82100210h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82100210h case    2:*/		return 0x82100214;
		  /* 82100214h */ case    3:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 82100214h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 82100214h case    3:*/		return 0x82100218;
		  /* 82100218h */ case    4:  		/* mr R30, R4 */
		/* 82100218h case    4:*/		regs.R30 = regs.R4;
		/* 82100218h case    4:*/		return 0x8210021C;
		  /* 8210021Ch */ case    5:  		/* add R11, R11, R6 */
		/* 8210021Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 8210021Ch case    5:*/		return 0x82100220;
		  /* 82100220h */ case    6:  		/* mr R31, R3 */
		/* 82100220h case    6:*/		regs.R31 = regs.R3;
		/* 82100220h case    6:*/		return 0x82100224;
		  /* 82100224h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82100224h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82100224h case    7:*/		return 0x82100228;
		  /* 82100228h */ case    8:  		/* mr R29, R5 */
		/* 82100228h case    8:*/		regs.R29 = regs.R5;
		/* 82100228h case    8:*/		return 0x8210022C;
		  /* 8210022Ch */ case    9:  		/* mr R28, R6 */
		/* 8210022Ch case    9:*/		regs.R28 = regs.R6;
		/* 8210022Ch case    9:*/		return 0x82100230;
		  /* 82100230h */ case   10:  		/* lwzux R11, <#[R30 + R11]> */
		/* 82100230h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		regs.R30 = (uint32)(regs.R30 + regs.R11 + 0x00000000);
		/* 82100230h case   10:*/		return 0x82100234;
		  /* 82100234h */ case   11:  		/* cmpwi CR6, R11, -1 */
		/* 82100234h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82100234h case   11:*/		return 0x82100238;
		  /* 82100238h */ case   12:  		/* bc 4, CR6_EQ, 224 */
		/* 82100238h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82100318;  }
		/* 82100238h case   12:*/		return 0x8210023C;
		  /* 8210023Ch */ case   13:  		/* cmpwi CR6, R8, 0 */
		/* 8210023Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 8210023Ch case   13:*/		return 0x82100240;
	}
	return 0x82100240;
} // Block from 82100208h-82100240h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82100240h
// Function '?PropagateSwizzles_Unswizzle@CProgram@D3DXShader@@AAAJIPAII0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100240);
		  /* 82100240h */ case    0:  		/* bc 12, CR6_EQ, 132 */
		/* 82100240h case    0:*/		if ( regs.CR[6].eq ) { return 0x821002C4;  }
		/* 82100240h case    0:*/		return 0x82100244;
		  /* 82100244h */ case    1:  		/* lwz R11, <#[R3 + 20]> */
		/* 82100244h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82100244h case    1:*/		return 0x82100248;
		  /* 82100248h */ case    2:  		/* rlwinm R27, R7, 2, 0, 29 */
		/* 82100248h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R7);
		/* 82100248h case    2:*/		return 0x8210024C;
		  /* 8210024Ch */ case    3:  		/* lwz R4, <#[R3 + 120]> */
		/* 8210024Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 8210024Ch case    3:*/		return 0x82100250;
		  /* 82100250h */ case    4:  		/* lwzx R11, <#[R27 + R11]> */
		/* 82100250h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 82100250h case    4:*/		return 0x82100254;
		  /* 82100254h */ case    5:  		/* lfd FR0, <#[R11 + 32]> */
		/* 82100254h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 82100254h case    5:*/		return 0x82100258;
		  /* 82100258h */ case    6:  		/* fneg FR1, FR0 */
		/* 82100258h case    6:*/		cpu::op::fneg<0>(regs,&regs.FR1,regs.FR0);
		/* 82100258h case    6:*/		return 0x8210025C;
		  /* 8210025Ch */ case    7:  		/* bl -12340 */
		/* 8210025Ch case    7:*/		regs.LR = 0x82100260; return 0x820FD228;
		/* 8210025Ch case    7:*/		return 0x82100260;
		  /* 82100260h */ case    8:  		/* stw R3, <#[R30]> */
		/* 82100260h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 82100260h case    8:*/		return 0x82100264;
		  /* 82100264h */ case    9:  		/* mr R6, R28 */
		/* 82100264h case    9:*/		regs.R6 = regs.R28;
		/* 82100264h case    9:*/		return 0x82100268;
		  /* 82100268h */ case   10:  		/* lwz R11, <#[R31 + 20]> */
		/* 82100268h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82100268h case   10:*/		return 0x8210026C;
		  /* 8210026Ch */ case   11:  		/* mr R5, R29 */
		/* 8210026Ch case   11:*/		regs.R5 = regs.R29;
		/* 8210026Ch case   11:*/		return 0x82100270;
		  /* 82100270h */ case   12:  		/* lwz R4, <#[R31 + 120]> */
		/* 82100270h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000078) );
		/* 82100270h case   12:*/		return 0x82100274;
		  /* 82100274h */ case   13:  		/* mr R3, R31 */
		/* 82100274h case   13:*/		regs.R3 = regs.R31;
		/* 82100274h case   13:*/		return 0x82100278;
		  /* 82100278h */ case   14:  		/* lwzx R11, <#[R27 + R11]> */
		/* 82100278h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 82100278h case   14:*/		return 0x8210027C;
		  /* 8210027Ch */ case   15:  		/* lfd FR0, <#[R11 + 32]> */
		/* 8210027Ch case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 8210027Ch case   15:*/		return 0x82100280;
		  /* 82100280h */ case   16:  		/* fneg FR1, FR0 */
		/* 82100280h case   16:*/		cpu::op::fneg<0>(regs,&regs.FR1,regs.FR0);
		/* 82100280h case   16:*/		return 0x82100284;
		  /* 82100284h */ case   17:  		/* bl -12380 */
		/* 82100284h case   17:*/		regs.LR = 0x82100288; return 0x820FD228;
		/* 82100284h case   17:*/		return 0x82100288;
		  /* 82100288h */ case   18:  		/* cmpwi CR6, R3, -1 */
		/* 82100288h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82100288h case   18:*/		return 0x8210028C;
		  /* 8210028Ch */ case   19:  		/* bc 4, CR6_EQ, 12 */
		/* 8210028Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x82100298;  }
		/* 8210028Ch case   19:*/		return 0x82100290;
		  /* 82100290h */ case   20:  		/* li R3, -1 */
		/* 82100290h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82100290h case   20:*/		return 0x82100294;
		  /* 82100294h */ case   21:  		/* b 136 */
		/* 82100294h case   21:*/		return 0x8210031C;
		/* 82100294h case   21:*/		return 0x82100298;
	}
	return 0x82100298;
} // Block from 82100240h-82100298h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82100298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100298);
		  /* 82100298h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 82100298h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82100298h case    0:*/		return 0x8210029C;
		  /* 8210029Ch */ case    1:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 8210029Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 8210029Ch case    1:*/		return 0x821002A0;
		  /* 821002A0h */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821002A0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821002A0h case    2:*/		return 0x821002A4;
		  /* 821002A4h */ case    3:  		/* lwz R9, <#[R11 + 60]> */
		/* 821002A4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000003C) );
		/* 821002A4h case    3:*/		return 0x821002A8;
		  /* 821002A8h */ case    4:  		/* oris R9, R9, 8 */
		/* 821002A8h case    4:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x8);
		/* 821002A8h case    4:*/		return 0x821002AC;
		  /* 821002ACh */ case    5:  		/* stw R9, <#[R11 + 60]> */
		/* 821002ACh case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000003C) );
		/* 821002ACh case    5:*/		return 0x821002B0;
		  /* 821002B0h */ case    6:  		/* lwz R11, <#[R31 + 20]> */
		/* 821002B0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 821002B0h case    6:*/		return 0x821002B4;
		  /* 821002B4h */ case    7:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821002B4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821002B4h case    7:*/		return 0x821002B8;
		  /* 821002B8h */ case    8:  		/* lwz R10, <#[R30]> */
		/* 821002B8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821002B8h case    8:*/		return 0x821002BC;
		  /* 821002BCh */ case    9:  		/* stw R10, <#[R11 + 56]> */
		/* 821002BCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 821002BCh case    9:*/		return 0x821002C0;
		  /* 821002C0h */ case   10:  		/* b 92 */
		/* 821002C0h case   10:*/		return 0x8210031C;
		/* 821002C0h case   10:*/		return 0x821002C4;
	}
	return 0x821002C4;
} // Block from 82100298h-821002C4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821002C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821002C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821002C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821002C4);
		  /* 821002C4h */ case    0:  		/* lwz R10, <#[R31 + 20]> */
		/* 821002C4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821002C4h case    0:*/		return 0x821002C8;
		  /* 821002C8h */ case    1:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 821002C8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 821002C8h case    1:*/		return 0x821002CC;
		  /* 821002CCh */ case    2:  		/* lwzx R10, <#[R11 + R10]> */
		/* 821002CCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821002CCh case    2:*/		return 0x821002D0;
		  /* 821002D0h */ case    3:  		/* lwz R9, <#[R10 + 12]> */
		/* 821002D0h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 821002D0h case    3:*/		return 0x821002D4;
		  /* 821002D4h */ case    4:  		/* cmpwi CR6, R9, -1 */
		/* 821002D4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 821002D4h case    4:*/		return 0x821002D8;
		  /* 821002D8h */ case    5:  		/* bc 4, CR6_EQ, 36 */
		/* 821002D8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821002FC;  }
		/* 821002D8h case    5:*/		return 0x821002DC;
		  /* 821002DCh */ case    6:  		/* lwz R10, <#[R31 + 20]> */
		/* 821002DCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821002DCh case    6:*/		return 0x821002E0;
		  /* 821002E0h */ case    7:  		/* lwzx R10, <#[R11 + R10]> */
		/* 821002E0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821002E0h case    7:*/		return 0x821002E4;
		  /* 821002E4h */ case    8:  		/* stw R29, <#[R10 + 12]> */
		/* 821002E4h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + 0x0000000C) );
		/* 821002E4h case    8:*/		return 0x821002E8;
		  /* 821002E8h */ case    9:  		/* lwz R10, <#[R31 + 20]> */
		/* 821002E8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821002E8h case    9:*/		return 0x821002EC;
		  /* 821002ECh */ case   10:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821002ECh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821002ECh case   10:*/		return 0x821002F0;
		  /* 821002F0h */ case   11:  		/* stw R28, <#[R11 + 16]> */
		/* 821002F0h case   11:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000010) );
		/* 821002F0h case   11:*/		return 0x821002F4;
		  /* 821002F4h */ case   12:  		/* stw R7, <#[R30]> */
		/* 821002F4h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x00000000) );
		/* 821002F4h case   12:*/		return 0x821002F8;
		  /* 821002F8h */ case   13:  		/* b 32 */
		/* 821002F8h case   13:*/		return 0x82100318;
		/* 821002F8h case   13:*/		return 0x821002FC;
	}
	return 0x821002FC;
} // Block from 821002C4h-821002FCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 821002FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821002FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821002FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821002FC);
		  /* 821002FCh */ case    0:  		/* mr R6, R28 */
		/* 821002FCh case    0:*/		regs.R6 = regs.R28;
		/* 821002FCh case    0:*/		return 0x82100300;
		  /* 82100300h */ case    1:  		/* lfd FR1, <#[R10 + 32]> */
		/* 82100300h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00000020) );
		/* 82100300h case    1:*/		return 0x82100304;
		  /* 82100304h */ case    2:  		/* mr R5, R29 */
		/* 82100304h case    2:*/		regs.R5 = regs.R29;
		/* 82100304h case    2:*/		return 0x82100308;
		  /* 82100308h */ case    3:  		/* lwz R4, <#[R31 + 120]> */
		/* 82100308h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000078) );
		/* 82100308h case    3:*/		return 0x8210030C;
		  /* 8210030Ch */ case    4:  		/* mr R3, R31 */
		/* 8210030Ch case    4:*/		regs.R3 = regs.R31;
		/* 8210030Ch case    4:*/		return 0x82100310;
		  /* 82100310h */ case    5:  		/* bl -12520 */
		/* 82100310h case    5:*/		regs.LR = 0x82100314; return 0x820FD228;
		/* 82100310h case    5:*/		return 0x82100314;
		  /* 82100314h */ case    6:  		/* stw R3, <#[R30]> */
		/* 82100314h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 82100314h case    6:*/		return 0x82100318;
	}
	return 0x82100318;
} // Block from 821002FCh-82100318h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82100318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100318);
		  /* 82100318h */ case    0:  		/* lwz R3, <#[R30]> */
		/* 82100318h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 82100318h case    0:*/		return 0x8210031C;
	}
	return 0x8210031C;
} // Block from 82100318h-8210031Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210031Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210031C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210031C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210031C);
		  /* 8210031Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8210031Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8210031Ch case    0:*/		return 0x82100320;
		  /* 82100320h */ case    1:  		/* b -454780 */
		/* 82100320h case    1:*/		return 0x820912A4;
		/* 82100320h case    1:*/		return 0x82100324;
		  /* 82100324h */ case    2:  		/* nop */
		/* 82100324h case    2:*/		cpu::op::nop();
		/* 82100324h case    2:*/		return 0x82100328;
	}
	return 0x82100328;
} // Block from 8210031Ch-82100328h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82100328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100328);
		  /* 82100328h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 82100328h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82100328h case    0:*/		return 0x8210032C;
		  /* 8210032Ch */ case    1:  		/* li R8, 1 */
		/* 8210032Ch case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8210032Ch case    1:*/		return 0x82100330;
		  /* 82100330h */ case    2:  		/* cmplwi CR6, R6, 1 */
		/* 82100330h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000001);
		/* 82100330h case    2:*/		return 0x82100334;
		  /* 82100334h */ case    3:  		/* bc 4, CR6_GT, 108 */
		/* 82100334h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821003A0;  }
		/* 82100334h case    3:*/		return 0x82100338;
		  /* 82100338h */ case    4:  		/* lwz R10, <#[R5]> */
		/* 82100338h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 82100338h case    4:*/		return 0x8210033C;
		  /* 8210033Ch */ case    5:  		/* addi R11, R5, 4 */
		/* 8210033Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x4);
		/* 8210033Ch case    5:*/		return 0x82100340;
		  /* 82100340h */ case    6:  		/* lwz R9, <#[R3 + 20]> */
		/* 82100340h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82100340h case    6:*/		return 0x82100344;
		  /* 82100344h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82100344h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82100344h case    7:*/		return 0x82100348;
		  /* 82100348h */ case    8:  		/* lwzx R7, <#[R10 + R9]> */
		/* 82100348h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82100348h case    8:*/		return 0x8210034C;
		  /* 8210034Ch */ case    9:  		/* lwz R10, <#[R11]> */
		/* 8210034Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210034Ch case    9:*/		return 0x82100350;
		  /* 82100350h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82100350h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82100350h case   10:*/		return 0x82100354;
		  /* 82100354h */ case   11:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82100354h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82100354h case   11:*/		return 0x82100358;
		  /* 82100358h */ case   12:  		/* lwz R31, <#[R10 + 60]> */
		/* 82100358h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x0000003C) );
		/* 82100358h case   12:*/		return 0x8210035C;
		  /* 8210035Ch */ case   13:  		/* rlwinm. R31, R31, 0, 12, 12 */
		/* 8210035Ch case   13:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R31,regs.R31);
		/* 8210035Ch case   13:*/		return 0x82100360;
		  /* 82100360h */ case   14:  		/* bc 12, CR0_EQ, 16 */
		/* 82100360h case   14:*/		if ( regs.CR[0].eq ) { return 0x82100370;  }
		/* 82100360h case   14:*/		return 0x82100364;
		  /* 82100364h */ case   15:  		/* lfd FR0, <#[R10 + 32]> */
		/* 82100364h case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 82100364h case   15:*/		return 0x82100368;
		  /* 82100368h */ case   16:  		/* fneg FR13, FR0 */
		/* 82100368h case   16:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 82100368h case   16:*/		return 0x8210036C;
		  /* 8210036Ch */ case   17:  		/* b 8 */
		/* 8210036Ch case   17:*/		return 0x82100374;
		/* 8210036Ch case   17:*/		return 0x82100370;
	}
	return 0x82100370;
} // Block from 82100328h-82100370h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82100370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100370);
		  /* 82100370h */ case    0:  		/* lfd FR13, <#[R10 + 32]> */
		/* 82100370h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000020) );
		/* 82100370h case    0:*/		return 0x82100374;
	}
	return 0x82100374;
} // Block from 82100370h-82100374h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82100374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100374);
		  /* 82100374h */ case    0:  		/* lwz R10, <#[R7 + 60]> */
		/* 82100374h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x0000003C) );
		/* 82100374h case    0:*/		return 0x82100378;
		  /* 82100378h */ case    1:  		/* lfd FR0, <#[R7 + 32]> */
		/* 82100378h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R7 + 0x00000020) );
		/* 82100378h case    1:*/		return 0x8210037C;
		  /* 8210037Ch */ case    2:  		/* rlwinm. R10, R10, 0, 12, 12 */
		/* 8210037Ch case    2:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R10,regs.R10);
		/* 8210037Ch case    2:*/		return 0x82100380;
		  /* 82100380h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 82100380h case    3:*/		if ( regs.CR[0].eq ) { return 0x82100388;  }
		/* 82100380h case    3:*/		return 0x82100384;
		  /* 82100384h */ case    4:  		/* fneg FR0, FR0 */
		/* 82100384h case    4:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 82100384h case    4:*/		return 0x82100388;
	}
	return 0x82100388;
} // Block from 82100374h-82100388h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82100388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100388);
		  /* 82100388h */ case    0:  		/* fcmpu CR6, FR13, FR0 */
		/* 82100388h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82100388h case    0:*/		return 0x8210038C;
		  /* 8210038Ch */ case    1:  		/* bc 4, CR6_EQ, 172 */
		/* 8210038Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82100438;  }
		/* 8210038Ch case    1:*/		return 0x82100390;
		  /* 82100390h */ case    2:  		/* addi R8, R8, 1 */
		/* 82100390h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82100390h case    2:*/		return 0x82100394;
		  /* 82100394h */ case    3:  		/* addi R11, R11, 4 */
		/* 82100394h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82100394h case    3:*/		return 0x82100398;
		  /* 82100398h */ case    4:  		/* cmplw CR6, R8, R6 */
		/* 82100398h case    4:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R6);
		/* 82100398h case    4:*/		return 0x8210039C;
		  /* 8210039Ch */ case    5:  		/* bc 12, CR6_LT, -80 */
		/* 8210039Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8210034C;  }
		/* 8210039Ch case    5:*/		return 0x821003A0;
	}
	return 0x821003A0;
} // Block from 82100388h-821003A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821003A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821003A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821003A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821003A0);
		  /* 821003A0h */ case    0:  		/* li R8, 0 */
		/* 821003A0h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821003A0h case    0:*/		return 0x821003A4;
		  /* 821003A4h */ case    1:  		/* addi R11, R8, -1 */
		/* 821003A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFF);
		/* 821003A4h case    1:*/		return 0x821003A8;
		  /* 821003A8h */ case    2:  		/* rlwinm R7, R11, 2, 28, 29 */
		/* 821003A8h case    2:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R7,regs.R11);
		/* 821003A8h case    2:*/		return 0x821003AC;
		  /* 821003ACh */ case    3:  		/* lwzx R9, <#[R7 + R4]> */
		/* 821003ACh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R4 + 0x00000000) );
		/* 821003ACh case    3:*/		return 0x821003B0;
		  /* 821003B0h */ case    4:  		/* cmpwi CR6, R9, -1 */
		/* 821003B0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 821003B0h case    4:*/		return 0x821003B4;
		  /* 821003B4h */ case    5:  		/* bc 12, CR6_EQ, 84 */
		/* 821003B4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82100408;  }
		/* 821003B4h case    5:*/		return 0x821003B8;
		  /* 821003B8h */ case    6:  		/* lwz R11, <#[R5]> */
		/* 821003B8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 821003B8h case    6:*/		return 0x821003BC;
		  /* 821003BCh */ case    7:  		/* lwz R10, <#[R3 + 20]> */
		/* 821003BCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 821003BCh case    7:*/		return 0x821003C0;
		  /* 821003C0h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821003C0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821003C0h case    8:*/		return 0x821003C4;
		  /* 821003C4h */ case    9:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821003C4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821003C4h case    9:*/		return 0x821003C8;
		  /* 821003C8h */ case   10:  		/* lwz R31, <#[R11 + 60]> */
		/* 821003C8h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x0000003C) );
		/* 821003C8h case   10:*/		return 0x821003CC;
		  /* 821003CCh */ case   11:  		/* rlwinm. R31, R31, 0, 12, 12 */
		/* 821003CCh case   11:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R31,regs.R31);
		/* 821003CCh case   11:*/		return 0x821003D0;
		  /* 821003D0h */ case   12:  		/* bc 12, CR0_EQ, 16 */
		/* 821003D0h case   12:*/		if ( regs.CR[0].eq ) { return 0x821003E0;  }
		/* 821003D0h case   12:*/		return 0x821003D4;
		  /* 821003D4h */ case   13:  		/* lfd FR0, <#[R11 + 32]> */
		/* 821003D4h case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 821003D4h case   13:*/		return 0x821003D8;
		  /* 821003D8h */ case   14:  		/* fneg FR13, FR0 */
		/* 821003D8h case   14:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 821003D8h case   14:*/		return 0x821003DC;
		  /* 821003DCh */ case   15:  		/* b 8 */
		/* 821003DCh case   15:*/		return 0x821003E4;
		/* 821003DCh case   15:*/		return 0x821003E0;
	}
	return 0x821003E0;
} // Block from 821003A0h-821003E0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821003E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821003E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821003E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821003E0);
		  /* 821003E0h */ case    0:  		/* lfd FR13, <#[R11 + 32]> */
		/* 821003E0h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 821003E0h case    0:*/		return 0x821003E4;
	}
	return 0x821003E4;
} // Block from 821003E0h-821003E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821003E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821003E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821003E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821003E4);
		  /* 821003E4h */ case    0:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 821003E4h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 821003E4h case    0:*/		return 0x821003E8;
		  /* 821003E8h */ case    1:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821003E8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821003E8h case    1:*/		return 0x821003EC;
		  /* 821003ECh */ case    2:  		/* lwz R10, <#[R11 + 60]> */
		/* 821003ECh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 821003ECh case    2:*/		return 0x821003F0;
		  /* 821003F0h */ case    3:  		/* lfd FR0, <#[R11 + 32]> */
		/* 821003F0h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 821003F0h case    3:*/		return 0x821003F4;
		  /* 821003F4h */ case    4:  		/* rlwinm. R10, R10, 0, 12, 12 */
		/* 821003F4h case    4:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R10,regs.R10);
		/* 821003F4h case    4:*/		return 0x821003F8;
		  /* 821003F8h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 821003F8h case    5:*/		if ( regs.CR[0].eq ) { return 0x82100400;  }
		/* 821003F8h case    5:*/		return 0x821003FC;
		  /* 821003FCh */ case    6:  		/* fneg FR0, FR0 */
		/* 821003FCh case    6:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 821003FCh case    6:*/		return 0x82100400;
	}
	return 0x82100400;
} // Block from 821003E4h-82100400h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82100400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100400);
		  /* 82100400h */ case    0:  		/* fcmpu CR6, FR13, FR0 */
		/* 82100400h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82100400h case    0:*/		return 0x82100404;
		  /* 82100404h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82100404h case    1:*/		if ( regs.CR[6].eq ) { return 0x82100418;  }
		/* 82100404h case    1:*/		return 0x82100408;
	}
	return 0x82100408;
} // Block from 82100400h-82100408h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82100408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100408);
		  /* 82100408h */ case    0:  		/* addi R8, R8, 1 */
		/* 82100408h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82100408h case    0:*/		return 0x8210040C;
		  /* 8210040Ch */ case    1:  		/* cmplwi CR6, R8, 4 */
		/* 8210040Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000004);
		/* 8210040Ch case    1:*/		return 0x82100410;
		  /* 82100410h */ case    2:  		/* bc 12, CR6_LT, -108 */
		/* 82100410h case    2:*/		if ( regs.CR[6].lt ) { return 0x821003A4;  }
		/* 82100410h case    2:*/		return 0x82100414;
		  /* 82100414h */ case    3:  		/* b 192 */
		/* 82100414h case    3:*/		return 0x821004D4;
		/* 82100414h case    3:*/		return 0x82100418;
	}
	return 0x82100418;
} // Block from 82100408h-82100418h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82100418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100418);
		  /* 82100418h */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 82100418h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82100418h case    0:*/		return 0x8210041C;
		  /* 8210041Ch */ case    1:  		/* bc 12, CR6_EQ, 184 */
		/* 8210041Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821004D4;  }
		/* 8210041Ch case    1:*/		return 0x82100420;
		  /* 82100420h */ case    2:  		/* addi R11, R5, -4 */
		/* 82100420h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xFFFFFFFC);
		/* 82100420h case    2:*/		return 0x82100424;
		  /* 82100424h */ case    3:  		/* mtspr CTR, R6 */
		/* 82100424h case    3:*/		regs.CTR = regs.R6;
		/* 82100424h case    3:*/		return 0x82100428;
		  /* 82100428h */ case    4:  		/* lwzx R10, <#[R7 + R4]> */
		/* 82100428h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R4 + 0x00000000) );
		/* 82100428h case    4:*/		return 0x8210042C;
		  /* 8210042Ch */ case    5:  		/* stwu R10, <#[R11 + 4]> */
		/* 8210042Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8210042Ch case    5:*/		return 0x82100430;
		  /* 82100430h */ case    6:  		/* bc 16, CR0_LT, -8 */
		/* 82100430h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82100428;  }
		/* 82100430h case    6:*/		return 0x82100434;
		  /* 82100434h */ case    7:  		/* b 160 */
		/* 82100434h case    7:*/		return 0x821004D4;
		/* 82100434h case    7:*/		return 0x82100438;
	}
	return 0x82100438;
} // Block from 82100418h-82100438h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82100438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100438);
		  /* 82100438h */ case    0:  		/* li R7, 0 */
		/* 82100438h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82100438h case    0:*/		return 0x8210043C;
		  /* 8210043Ch */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 8210043Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8210043Ch case    1:*/		return 0x82100440;
		  /* 82100440h */ case    2:  		/* bc 12, CR6_EQ, 148 */
		/* 82100440h case    2:*/		if ( regs.CR[6].eq ) { return 0x821004D4;  }
		/* 82100440h case    2:*/		return 0x82100444;
		  /* 82100444h */ case    3:  		/* mr R8, R5 */
		/* 82100444h case    3:*/		regs.R8 = regs.R5;
		/* 82100444h case    3:*/		return 0x82100448;
		  /* 82100448h */ case    4:  		/* li R5, 0 */
		/* 82100448h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82100448h case    4:*/		return 0x8210044C;
		  /* 8210044Ch */ case    5:  		/* add R11, R5, R7 */
		/* 8210044Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R5,regs.R7);
		/* 8210044Ch case    5:*/		return 0x82100450;
		  /* 82100450h */ case    6:  		/* rlwinm R11, R11, 2, 28, 29 */
		/* 82100450h case    6:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R11,regs.R11);
		/* 82100450h case    6:*/		return 0x82100454;
		  /* 82100454h */ case    7:  		/* lwzx R9, <#[R11 + R4]> */
		/* 82100454h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 82100454h case    7:*/		return 0x82100458;
		  /* 82100458h */ case    8:  		/* cmpwi CR6, R9, -1 */
		/* 82100458h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82100458h case    8:*/		return 0x8210045C;
		  /* 8210045Ch */ case    9:  		/* bc 12, CR6_EQ, 84 */
		/* 8210045Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x821004B0;  }
		/* 8210045Ch case    9:*/		return 0x82100460;
		  /* 82100460h */ case   10:  		/* lwz R11, <#[R8]> */
		/* 82100460h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82100460h case   10:*/		return 0x82100464;
		  /* 82100464h */ case   11:  		/* lwz R10, <#[R3 + 20]> */
		/* 82100464h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82100464h case   11:*/		return 0x82100468;
		  /* 82100468h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82100468h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82100468h case   12:*/		return 0x8210046C;
		  /* 8210046Ch */ case   13:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210046Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210046Ch case   13:*/		return 0x82100470;
		  /* 82100470h */ case   14:  		/* lwz R31, <#[R11 + 60]> */
		/* 82100470h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x0000003C) );
		/* 82100470h case   14:*/		return 0x82100474;
		  /* 82100474h */ case   15:  		/* rlwinm. R31, R31, 0, 12, 12 */
		/* 82100474h case   15:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R31,regs.R31);
		/* 82100474h case   15:*/		return 0x82100478;
		  /* 82100478h */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 82100478h case   16:*/		if ( regs.CR[0].eq ) { return 0x82100488;  }
		/* 82100478h case   16:*/		return 0x8210047C;
		  /* 8210047Ch */ case   17:  		/* lfd FR0, <#[R11 + 32]> */
		/* 8210047Ch case   17:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 8210047Ch case   17:*/		return 0x82100480;
		  /* 82100480h */ case   18:  		/* fneg FR13, FR0 */
		/* 82100480h case   18:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 82100480h case   18:*/		return 0x82100484;
		  /* 82100484h */ case   19:  		/* b 8 */
		/* 82100484h case   19:*/		return 0x8210048C;
		/* 82100484h case   19:*/		return 0x82100488;
	}
	return 0x82100488;
} // Block from 82100438h-82100488h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82100488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100488);
		  /* 82100488h */ case    0:  		/* lfd FR13, <#[R11 + 32]> */
		/* 82100488h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 82100488h case    0:*/		return 0x8210048C;
	}
	return 0x8210048C;
} // Block from 82100488h-8210048Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210048Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210048C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210048C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210048C);
		  /* 8210048Ch */ case    0:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 8210048Ch case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 8210048Ch case    0:*/		return 0x82100490;
		  /* 82100490h */ case    1:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82100490h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82100490h case    1:*/		return 0x82100494;
		  /* 82100494h */ case    2:  		/* lwz R10, <#[R11 + 60]> */
		/* 82100494h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 82100494h case    2:*/		return 0x82100498;
		  /* 82100498h */ case    3:  		/* lfd FR0, <#[R11 + 32]> */
		/* 82100498h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 82100498h case    3:*/		return 0x8210049C;
		  /* 8210049Ch */ case    4:  		/* rlwinm. R10, R10, 0, 12, 12 */
		/* 8210049Ch case    4:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R10,regs.R10);
		/* 8210049Ch case    4:*/		return 0x821004A0;
		  /* 821004A0h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 821004A0h case    5:*/		if ( regs.CR[0].eq ) { return 0x821004A8;  }
		/* 821004A0h case    5:*/		return 0x821004A4;
		  /* 821004A4h */ case    6:  		/* fneg FR0, FR0 */
		/* 821004A4h case    6:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 821004A4h case    6:*/		return 0x821004A8;
	}
	return 0x821004A8;
} // Block from 8210048Ch-821004A8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821004A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821004A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821004A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821004A8);
		  /* 821004A8h */ case    0:  		/* fcmpu CR6, FR13, FR0 */
		/* 821004A8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821004A8h case    0:*/		return 0x821004AC;
		  /* 821004ACh */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 821004ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x821004C0;  }
		/* 821004ACh case    1:*/		return 0x821004B0;
	}
	return 0x821004B0;
} // Block from 821004A8h-821004B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821004B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821004B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821004B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821004B0);
		  /* 821004B0h */ case    0:  		/* addi R5, R5, 1 */
		/* 821004B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 821004B0h case    0:*/		return 0x821004B4;
		  /* 821004B4h */ case    1:  		/* cmplwi CR6, R5, 4 */
		/* 821004B4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000004);
		/* 821004B4h case    1:*/		return 0x821004B8;
		  /* 821004B8h */ case    2:  		/* bc 12, CR6_LT, -108 */
		/* 821004B8h case    2:*/		if ( regs.CR[6].lt ) { return 0x8210044C;  }
		/* 821004B8h case    2:*/		return 0x821004BC;
		  /* 821004BCh */ case    3:  		/* b 8 */
		/* 821004BCh case    3:*/		return 0x821004C4;
		/* 821004BCh case    3:*/		return 0x821004C0;
	}
	return 0x821004C0;
} // Block from 821004B0h-821004C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821004C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821004C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821004C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821004C0);
		  /* 821004C0h */ case    0:  		/* stw R9, <#[R8]> */
		/* 821004C0h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 821004C0h case    0:*/		return 0x821004C4;
	}
	return 0x821004C4;
} // Block from 821004C0h-821004C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821004C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821004C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821004C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821004C4);
		  /* 821004C4h */ case    0:  		/* addi R7, R7, 1 */
		/* 821004C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821004C4h case    0:*/		return 0x821004C8;
		  /* 821004C8h */ case    1:  		/* addi R8, R8, 4 */
		/* 821004C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 821004C8h case    1:*/		return 0x821004CC;
		  /* 821004CCh */ case    2:  		/* cmplw CR6, R7, R6 */
		/* 821004CCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 821004CCh case    2:*/		return 0x821004D0;
		  /* 821004D0h */ case    3:  		/* bc 12, CR6_LT, -136 */
		/* 821004D0h case    3:*/		if ( regs.CR[6].lt ) { return 0x82100448;  }
		/* 821004D0h case    3:*/		return 0x821004D4;
	}
	return 0x821004D4;
} // Block from 821004C4h-821004D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821004D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821004D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821004D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821004D4);
		  /* 821004D4h */ case    0:  		/* li R3, 0 */
		/* 821004D4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821004D4h case    0:*/		return 0x821004D8;
		  /* 821004D8h */ case    1:  		/* ld R31, <#[R1 - 8]> */
		/* 821004D8h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821004D8h case    1:*/		return 0x821004DC;
		  /* 821004DCh */ case    2:  		/* bclr 20, CR0_LT */
		/* 821004DCh case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821004DCh case    2:*/		return 0x821004E0;
	}
	return 0x821004E0;
} // Block from 821004D4h-821004E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821004E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821004E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821004E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821004E0);
		  /* 821004E0h */ case    0:  		/* mfspr R12, LR */
		/* 821004E0h case    0:*/		regs.R12 = regs.LR;
		/* 821004E0h case    0:*/		return 0x821004E4;
		  /* 821004E4h */ case    1:  		/* bl -455340 */
		/* 821004E4h case    1:*/		regs.LR = 0x821004E8; return 0x82091238;
		/* 821004E4h case    1:*/		return 0x821004E8;
		  /* 821004E8h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 821004E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 821004E8h case    2:*/		return 0x821004EC;
		  /* 821004ECh */ case    3:  		/* mr R24, R3 */
		/* 821004ECh case    3:*/		regs.R24 = regs.R3;
		/* 821004ECh case    3:*/		return 0x821004F0;
		  /* 821004F0h */ case    4:  		/* mr R22, R4 */
		/* 821004F0h case    4:*/		regs.R22 = regs.R4;
		/* 821004F0h case    4:*/		return 0x821004F4;
		  /* 821004F4h */ case    5:  		/* li R29, 0 */
		/* 821004F4h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821004F4h case    5:*/		return 0x821004F8;
		  /* 821004F8h */ case    6:  		/* li R11, 0 */
		/* 821004F8h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821004F8h case    6:*/		return 0x821004FC;
		  /* 821004FCh */ case    7:  		/* mr R10, R5 */
		/* 821004FCh case    7:*/		regs.R10 = regs.R5;
		/* 821004FCh case    7:*/		return 0x82100500;
		  /* 82100500h */ case    8:  		/* lwz R9, <#[R10]> */
		/* 82100500h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82100500h case    8:*/		return 0x82100504;
		  /* 82100504h */ case    9:  		/* cmpwi CR6, R9, -1 */
		/* 82100504h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82100504h case    9:*/		return 0x82100508;
		  /* 82100508h */ case   10:  		/* bc 12, CR6_EQ, 24 */
		/* 82100508h case   10:*/		if ( regs.CR[6].eq ) { return 0x82100520;  }
		/* 82100508h case   10:*/		return 0x8210050C;
		  /* 8210050Ch */ case   11:  		/* addi R11, R11, 1 */
		/* 8210050Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210050Ch case   11:*/		return 0x82100510;
		  /* 82100510h */ case   12:  		/* addi R29, R29, 1 */
		/* 82100510h case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82100510h case   12:*/		return 0x82100514;
		  /* 82100514h */ case   13:  		/* addi R10, R10, 4 */
		/* 82100514h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82100514h case   13:*/		return 0x82100518;
		  /* 82100518h */ case   14:  		/* cmplwi CR6, R11, 4 */
		/* 82100518h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 82100518h case   14:*/		return 0x8210051C;
		  /* 8210051Ch */ case   15:  		/* bc 12, CR6_LT, -28 */
		/* 8210051Ch case   15:*/		if ( regs.CR[6].lt ) { return 0x82100500;  }
		/* 8210051Ch case   15:*/		return 0x82100520;
	}
	return 0x82100520;
} // Block from 821004E0h-82100520h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82100520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100520);
		  /* 82100520h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82100520h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82100520h case    0:*/		return 0x82100524;
		  /* 82100524h */ case    1:  		/* bc 12, CR6_EQ, 1220 */
		/* 82100524h case    1:*/		if ( regs.CR[6].eq ) { return 0x821009E8;  }
		/* 82100524h case    1:*/		return 0x82100528;
		  /* 82100528h */ case    2:  		/* lwz R11, <#[R24 + 108]> */
		/* 82100528h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000006C) );
		/* 82100528h case    2:*/		return 0x8210052C;
		  /* 8210052Ch */ case    3:  		/* li R23, 1 */
		/* 8210052Ch case    3:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 8210052Ch case    3:*/		return 0x82100530;
		  /* 82100530h */ case    4:  		/* li R4, 0 */
		/* 82100530h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82100530h case    4:*/		return 0x82100534;
		  /* 82100534h */ case    5:  		/* rlwinm. R10, R11, 0, 2, 2 */
		/* 82100534h case    5:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R10,regs.R11);
		/* 82100534h case    5:*/		return 0x82100538;
		  /* 82100538h */ case    6:  		/* bc 4, CR0_EQ, 52 */
		/* 82100538h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8210056C;  }
		/* 82100538h case    6:*/		return 0x8210053C;
		  /* 8210053Ch */ case    7:  		/* rlwinm. R11, R11, 0, 3, 3 */
		/* 8210053Ch case    7:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R11);
		/* 8210053Ch case    7:*/		return 0x82100540;
		  /* 82100540h */ case    8:  		/* bc 4, CR0_EQ, 44 */
		/* 82100540h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8210056C;  }
		/* 82100540h case    8:*/		return 0x82100544;
		  /* 82100544h */ case    9:  		/* cmplwi CR6, R29, 0 */
		/* 82100544h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82100544h case    9:*/		return 0x82100548;
		  /* 82100548h */ case   10:  		/* bc 12, CR6_EQ, 416 */
		/* 82100548h case   10:*/		if ( regs.CR[6].eq ) { return 0x821006E8;  }
		/* 82100548h case   10:*/		return 0x8210054C;
		  /* 8210054Ch */ case   11:  		/* addi R11, R6, -4 */
		/* 8210054Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0xFFFFFFFC);
		/* 8210054Ch case   11:*/		return 0x82100550;
		  /* 82100550h */ case   12:  		/* li R10, 0 */
		/* 82100550h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82100550h case   12:*/		return 0x82100554;
		  /* 82100554h */ case   13:  		/* cmplwi CR0, R29, 0 */
		/* 82100554h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R29,0x00000000);
		/* 82100554h case   13:*/		return 0x82100558;
		  /* 82100558h */ case   14:  		/* bc 12, CR0_EQ, 400 */
		/* 82100558h case   14:*/		if ( regs.CR[0].eq ) { return 0x821006E8;  }
		/* 82100558h case   14:*/		return 0x8210055C;
		  /* 8210055Ch */ case   15:  		/* mtspr CTR, R29 */
		/* 8210055Ch case   15:*/		regs.CTR = regs.R29;
		/* 8210055Ch case   15:*/		return 0x82100560;
		  /* 82100560h */ case   16:  		/* stwu R10, <#[R11 + 4]> */
		/* 82100560h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82100560h case   16:*/		return 0x82100564;
		  /* 82100564h */ case   17:  		/* bc 16, CR0_LT, -4 */
		/* 82100564h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82100560;  }
		/* 82100564h case   17:*/		return 0x82100568;
		  /* 82100568h */ case   18:  		/* b 384 */
		/* 82100568h case   18:*/		return 0x821006E8;
		/* 82100568h case   18:*/		return 0x8210056C;
	}
	return 0x8210056C;
} // Block from 82100520h-8210056Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8210056Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210056C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210056C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210056C);
		  /* 8210056Ch */ case    0:  		/* mr R8, R23 */
		/* 8210056Ch case    0:*/		regs.R8 = regs.R23;
		/* 8210056Ch case    0:*/		return 0x82100570;
		  /* 82100570h */ case    1:  		/* cmplwi CR6, R29, 1 */
		/* 82100570h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000001);
		/* 82100570h case    1:*/		return 0x82100574;
		  /* 82100574h */ case    2:  		/* bc 4, CR6_GT, 108 */
		/* 82100574h case    2:*/		if ( !regs.CR[6].gt ) { return 0x821005E0;  }
		/* 82100574h case    2:*/		return 0x82100578;
		  /* 82100578h */ case    3:  		/* lwz R11, <#[R5]> */
		/* 82100578h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82100578h case    3:*/		return 0x8210057C;
		  /* 8210057Ch */ case    4:  		/* addi R10, R5, 4 */
		/* 8210057Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x4);
		/* 8210057Ch case    4:*/		return 0x82100580;
		  /* 82100580h */ case    5:  		/* lwz R9, <#[R24 + 20]> */
		/* 82100580h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000014) );
		/* 82100580h case    5:*/		return 0x82100584;
		  /* 82100584h */ case    6:  		/* rlwinm R7, R11, 2, 0, 29 */
		/* 82100584h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R11);
		/* 82100584h case    6:*/		return 0x82100588;
		  /* 82100588h */ case    7:  		/* lwzx R11, <#[R9 + R7]> */
		/* 82100588h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82100588h case    7:*/		return 0x8210058C;
		  /* 8210058Ch */ case    8:  		/* lwz R3, <#[R11 + 60]> */
		/* 8210058Ch case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000003C) );
		/* 8210058Ch case    8:*/		return 0x82100590;
		  /* 82100590h */ case    9:  		/* rlwinm. R3, R3, 0, 12, 12 */
		/* 82100590h case    9:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R3,regs.R3);
		/* 82100590h case    9:*/		return 0x82100594;
		  /* 82100594h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 82100594h case   10:*/		if ( regs.CR[0].eq ) { return 0x821005A4;  }
		/* 82100594h case   10:*/		return 0x82100598;
		  /* 82100598h */ case   11:  		/* lfd FR0, <#[R11 + 32]> */
		/* 82100598h case   11:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 82100598h case   11:*/		return 0x8210059C;
		  /* 8210059Ch */ case   12:  		/* fneg FR13, FR0 */
		/* 8210059Ch case   12:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 8210059Ch case   12:*/		return 0x821005A0;
		  /* 821005A0h */ case   13:  		/* b 8 */
		/* 821005A0h case   13:*/		return 0x821005A8;
		/* 821005A0h case   13:*/		return 0x821005A4;
	}
	return 0x821005A4;
} // Block from 8210056Ch-821005A4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821005A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821005A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821005A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821005A4);
		  /* 821005A4h */ case    0:  		/* lfd FR13, <#[R11 + 32]> */
		/* 821005A4h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 821005A4h case    0:*/		return 0x821005A8;
	}
	return 0x821005A8;
} // Block from 821005A4h-821005A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821005A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821005A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821005A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821005A8);
		  /* 821005A8h */ case    0:  		/* lwz R11, <#[R10]> */
		/* 821005A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821005A8h case    0:*/		return 0x821005AC;
		  /* 821005ACh */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821005ACh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821005ACh case    1:*/		return 0x821005B0;
		  /* 821005B0h */ case    2:  		/* lwzx R11, <#[R11 + R9]> */
		/* 821005B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821005B0h case    2:*/		return 0x821005B4;
		  /* 821005B4h */ case    3:  		/* lwz R3, <#[R11 + 60]> */
		/* 821005B4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000003C) );
		/* 821005B4h case    3:*/		return 0x821005B8;
		  /* 821005B8h */ case    4:  		/* lfd FR0, <#[R11 + 32]> */
		/* 821005B8h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 821005B8h case    4:*/		return 0x821005BC;
		  /* 821005BCh */ case    5:  		/* rlwinm. R3, R3, 0, 12, 12 */
		/* 821005BCh case    5:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R3,regs.R3);
		/* 821005BCh case    5:*/		return 0x821005C0;
		  /* 821005C0h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 821005C0h case    6:*/		if ( regs.CR[0].eq ) { return 0x821005C8;  }
		/* 821005C0h case    6:*/		return 0x821005C4;
		  /* 821005C4h */ case    7:  		/* fneg FR0, FR0 */
		/* 821005C4h case    7:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 821005C4h case    7:*/		return 0x821005C8;
	}
	return 0x821005C8;
} // Block from 821005A8h-821005C8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821005C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821005C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821005C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821005C8);
		  /* 821005C8h */ case    0:  		/* fcmpu CR6, FR13, FR0 */
		/* 821005C8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821005C8h case    0:*/		return 0x821005CC;
		  /* 821005CCh */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 821005CCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821005E0;  }
		/* 821005CCh case    1:*/		return 0x821005D0;
		  /* 821005D0h */ case    2:  		/* addi R8, R8, 1 */
		/* 821005D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821005D0h case    2:*/		return 0x821005D4;
		  /* 821005D4h */ case    3:  		/* addi R10, R10, 4 */
		/* 821005D4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821005D4h case    3:*/		return 0x821005D8;
		  /* 821005D8h */ case    4:  		/* cmplw CR6, R8, R29 */
		/* 821005D8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R29);
		/* 821005D8h case    4:*/		return 0x821005DC;
		  /* 821005DCh */ case    5:  		/* bc 12, CR6_LT, -84 */
		/* 821005DCh case    5:*/		if ( regs.CR[6].lt ) { return 0x82100588;  }
		/* 821005DCh case    5:*/		return 0x821005E0;
	}
	return 0x821005E0;
} // Block from 821005C8h-821005E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821005E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821005E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821005E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821005E0);
		  /* 821005E0h */ case    0:  		/* cmplw CR6, R8, R29 */
		/* 821005E0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R29);
		/* 821005E0h case    0:*/		return 0x821005E4;
		  /* 821005E4h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 821005E4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821005F4;  }
		/* 821005E4h case    1:*/		return 0x821005E8;
		  /* 821005E8h */ case    2:  		/* li R11, 0 */
		/* 821005E8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821005E8h case    2:*/		return 0x821005EC;
		  /* 821005ECh */ case    3:  		/* mr R29, R23 */
		/* 821005ECh case    3:*/		regs.R29 = regs.R23;
		/* 821005ECh case    3:*/		return 0x821005F0;
		  /* 821005F0h */ case    4:  		/* stw R11, <#[R6]> */
		/* 821005F0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 821005F0h case    4:*/		return 0x821005F4;
	}
	return 0x821005F4;
} // Block from 821005E0h-821005F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821005F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821005F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821005F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821005F4);
		  /* 821005F4h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 821005F4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821005F4h case    0:*/		return 0x821005F8;
		  /* 821005F8h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 821005F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82100618;  }
		/* 821005F8h case    1:*/		return 0x821005FC;
		  /* 821005FCh */ case    2:  		/* addi R11, R6, -4 */
		/* 821005FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0xFFFFFFFC);
		/* 821005FCh case    2:*/		return 0x82100600;
		  /* 82100600h */ case    3:  		/* mtspr CTR, R29 */
		/* 82100600h case    3:*/		regs.CTR = regs.R29;
		/* 82100600h case    3:*/		return 0x82100604;
		  /* 82100604h */ case    4:  		/* lwzu R10, <#[R11 + 4]> */
		/* 82100604h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82100604h case    4:*/		return 0x82100608;
		  /* 82100608h */ case    5:  		/* cntlzw R10, R10 */
		/* 82100608h case    5:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 82100608h case    5:*/		return 0x8210060C;
		  /* 8210060Ch */ case    6:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 8210060Ch case    6:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 8210060Ch case    6:*/		return 0x82100610;
		  /* 82100610h */ case    7:  		/* add R4, R10, R4 */
		/* 82100610h case    7:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R4);
		/* 82100610h case    7:*/		return 0x82100614;
		  /* 82100614h */ case    8:  		/* bc 16, CR0_LT, -16 */
		/* 82100614h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82100604;  }
		/* 82100614h case    8:*/		return 0x82100618;
	}
	return 0x82100618;
} // Block from 821005F4h-82100618h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82100618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100618);
		  /* 82100618h */ case    0:  		/* lwz R11, <#[R24 + 108]> */
		/* 82100618h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000006C) );
		/* 82100618h case    0:*/		return 0x8210061C;
		  /* 8210061Ch */ case    1:  		/* rlwinm. R11, R11, 0, 3, 3 */
		/* 8210061Ch case    1:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R11,regs.R11);
		/* 8210061Ch case    1:*/		return 0x82100620;
		  /* 82100620h */ case    2:  		/* bc 12, CR0_EQ, 96 */
		/* 82100620h case    2:*/		if ( regs.CR[0].eq ) { return 0x82100680;  }
		/* 82100620h case    2:*/		return 0x82100624;
		  /* 82100624h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 82100624h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82100624h case    3:*/		return 0x82100628;
		  /* 82100628h */ case    4:  		/* bc 12, CR6_EQ, 88 */
		/* 82100628h case    4:*/		if ( regs.CR[6].eq ) { return 0x82100680;  }
		/* 82100628h case    4:*/		return 0x8210062C;
		  /* 8210062Ch */ case    5:  		/* cmplwi CR6, R4, 1 */
		/* 8210062Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 8210062Ch case    5:*/		return 0x82100630;
		  /* 82100630h */ case    6:  		/* bc 4, CR6_GT, 16 */
		/* 82100630h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82100640;  }
		/* 82100630h case    6:*/		return 0x82100634;
		  /* 82100634h */ case    7:  		/* lis R3, -32768 */
		/* 82100634h case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82100634h case    7:*/		return 0x82100638;
		  /* 82100638h */ case    8:  		/* ori R3, R3, 16389 */
		/* 82100638h case    8:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 82100638h case    8:*/		return 0x8210063C;
		  /* 8210063Ch */ case    9:  		/* b 944 */
		/* 8210063Ch case    9:*/		return 0x821009EC;
		/* 8210063Ch case    9:*/		return 0x82100640;
	}
	return 0x82100640;
} // Block from 82100618h-82100640h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82100640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100640);
		  /* 82100640h */ case    0:  		/* li R10, 0 */
		/* 82100640h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82100640h case    0:*/		return 0x82100644;
		  /* 82100644h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 82100644h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82100644h case    1:*/		return 0x82100648;
		  /* 82100648h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 82100648h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210067C;  }
		/* 82100648h case    2:*/		return 0x8210064C;
		  /* 8210064Ch */ case    3:  		/* mr R11, R6 */
		/* 8210064Ch case    3:*/		regs.R11 = regs.R6;
		/* 8210064Ch case    3:*/		return 0x82100650;
		  /* 82100650h */ case    4:  		/* lwz R9, <#[R11]> */
		/* 82100650h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82100650h case    4:*/		return 0x82100654;
		  /* 82100654h */ case    5:  		/* rlwinm. R8, R9, 0, 28, 28 */
		/* 82100654h case    5:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R8,regs.R9);
		/* 82100654h case    5:*/		return 0x82100658;
		  /* 82100658h */ case    6:  		/* bc 4, CR0_EQ, -36 */
		/* 82100658h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82100634;  }
		/* 82100658h case    6:*/		return 0x8210065C;
		  /* 8210065Ch */ case    7:  		/* cmplwi CR6, R9, 0 */
		/* 8210065Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8210065Ch case    7:*/		return 0x82100660;
	}
	return 0x82100660;
} // Block from 82100640h-82100660h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82100660h
// Function '?SeparatePhases_Phases@CProgram@D3DXShader@@AAAIXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100660);
		  /* 82100660h */ case    0:  		/* bc 4, CR6_EQ, 12 */
		/* 82100660h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8210066C;  }
		/* 82100660h case    0:*/		return 0x82100664;
		  /* 82100664h */ case    1:  		/* li R9, 8 */
		/* 82100664h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 82100664h case    1:*/		return 0x82100668;
		  /* 82100668h */ case    2:  		/* stw R9, <#[R11]> */
		/* 82100668h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82100668h case    2:*/		return 0x8210066C;
	}
	return 0x8210066C;
} // Block from 82100660h-8210066Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210066Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210066C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210066C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210066C);
		  /* 8210066Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 8210066Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210066Ch case    0:*/		return 0x82100670;
		  /* 82100670h */ case    1:  		/* addi R11, R11, 4 */
		/* 82100670h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82100670h case    1:*/		return 0x82100674;
		  /* 82100674h */ case    2:  		/* cmplw CR6, R10, R29 */
		/* 82100674h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 82100674h case    2:*/		return 0x82100678;
		  /* 82100678h */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 82100678h case    3:*/		if ( regs.CR[6].lt ) { return 0x82100650;  }
		/* 82100678h case    3:*/		return 0x8210067C;
	}
	return 0x8210067C;
} // Block from 8210066Ch-8210067Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210067Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210067C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210067C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210067C);
		  /* 8210067Ch */ case    0:  		/* li R4, 0 */
		/* 8210067Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210067Ch case    0:*/		return 0x82100680;
	}
	return 0x82100680;
} // Block from 8210067Ch-82100680h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82100680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100680);
		  /* 82100680h */ case    0:  		/* li R9, 0 */
		/* 82100680h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82100680h case    0:*/		return 0x82100684;
		  /* 82100684h */ case    1:  		/* li R10, 0 */
		/* 82100684h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82100684h case    1:*/		return 0x82100688;
		  /* 82100688h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 82100688h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82100688h case    2:*/		return 0x8210068C;
		  /* 8210068Ch */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 8210068Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x821006B4;  }
		/* 8210068Ch case    3:*/		return 0x82100690;
		  /* 82100690h */ case    4:  		/* mr R11, R6 */
		/* 82100690h case    4:*/		regs.R11 = regs.R6;
		/* 82100690h case    4:*/		return 0x82100694;
		  /* 82100694h */ case    5:  		/* lwz R8, <#[R11]> */
		/* 82100694h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82100694h case    5:*/		return 0x82100698;
		  /* 82100698h */ case    6:  		/* and. R7, R8, R9 */
		/* 82100698h case    6:*/		cpu::op::and<1>(regs,&regs.R7,regs.R8,regs.R9);
		/* 82100698h case    6:*/		return 0x8210069C;
		  /* 8210069Ch */ case    7:  		/* bc 4, CR0_EQ, -104 */
		/* 8210069Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82100634;  }
		/* 8210069Ch case    7:*/		return 0x821006A0;
		  /* 821006A0h */ case    8:  		/* addi R10, R10, 1 */
		/* 821006A0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821006A0h case    8:*/		return 0x821006A4;
		  /* 821006A4h */ case    9:  		/* or R9, R8, R9 */
		/* 821006A4h case    9:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821006A4h case    9:*/		return 0x821006A8;
		  /* 821006A8h */ case   10:  		/* addi R11, R11, 4 */
		/* 821006A8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821006A8h case   10:*/		return 0x821006AC;
		  /* 821006ACh */ case   11:  		/* cmplw CR6, R10, R29 */
		/* 821006ACh case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 821006ACh case   11:*/		return 0x821006B0;
		  /* 821006B0h */ case   12:  		/* bc 12, CR6_LT, -28 */
		/* 821006B0h case   12:*/		if ( regs.CR[6].lt ) { return 0x82100694;  }
		/* 821006B0h case   12:*/		return 0x821006B4;
	}
	return 0x821006B4;
} // Block from 82100680h-821006B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821006B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821006B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821006B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821006B4);
		  /* 821006B4h */ case    0:  		/* li R10, 4 */
		/* 821006B4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 821006B4h case    0:*/		return 0x821006B8;
		  /* 821006B8h */ case    1:  		/* li R8, 0 */
		/* 821006B8h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821006B8h case    1:*/		return 0x821006BC;
		  /* 821006BCh */ case    2:  		/* li R11, 0 */
		/* 821006BCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821006BCh case    2:*/		return 0x821006C0;
		  /* 821006C0h */ case    3:  		/* mtspr CTR, R10 */
		/* 821006C0h case    3:*/		regs.CTR = regs.R10;
		/* 821006C0h case    3:*/		return 0x821006C4;
		  /* 821006C4h */ case    4:  		/* slw R10, R23, R11 */
		/* 821006C4h case    4:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R23,regs.R11);
		/* 821006C4h case    4:*/		return 0x821006C8;
		  /* 821006C8h */ case    5:  		/* and. R10, R10, R9 */
		/* 821006C8h case    5:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821006C8h case    5:*/		return 0x821006CC;
		  /* 821006CCh */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 821006CCh case    6:*/		if ( regs.CR[0].eq ) { return 0x821006D4;  }
		/* 821006CCh case    6:*/		return 0x821006D0;
		  /* 821006D0h */ case    7:  		/* addi R8, R8, 1 */
		/* 821006D0h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821006D0h case    7:*/		return 0x821006D4;
	}
	return 0x821006D4;
} // Block from 821006B4h-821006D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821006D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821006D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821006D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821006D4);
		  /* 821006D4h */ case    0:  		/* addi R11, R11, 1 */
		/* 821006D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821006D4h case    0:*/		return 0x821006D8;
		  /* 821006D8h */ case    1:  		/* bc 16, CR0_LT, -20 */
		/* 821006D8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821006C4;  }
		/* 821006D8h case    1:*/		return 0x821006DC;
		  /* 821006DCh */ case    2:  		/* add R11, R8, R4 */
		/* 821006DCh case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R4);
		/* 821006DCh case    2:*/		return 0x821006E0;
		  /* 821006E0h */ case    3:  		/* cmplwi CR6, R11, 4 */
		/* 821006E0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821006E0h case    3:*/		return 0x821006E4;
		  /* 821006E4h */ case    4:  		/* bc 12, CR6_GT, -176 */
		/* 821006E4h case    4:*/		if ( regs.CR[6].gt ) { return 0x82100634;  }
		/* 821006E4h case    4:*/		return 0x821006E8;
	}
	return 0x821006E8;
} // Block from 821006D4h-821006E8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821006E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821006E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821006E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821006E8);
		  /* 821006E8h */ case    0:  		/* lwz R11, <#[R24 + 108]> */
		/* 821006E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000006C) );
		/* 821006E8h case    0:*/		return 0x821006EC;
		  /* 821006ECh */ case    1:  		/* li R26, 0 */
		/* 821006ECh case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821006ECh case    1:*/		return 0x821006F0;
		  /* 821006F0h */ case    2:  		/* mr R28, R22 */
		/* 821006F0h case    2:*/		regs.R28 = regs.R22;
		/* 821006F0h case    2:*/		return 0x821006F4;
		  /* 821006F4h */ case    3:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821006F4h case    3:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821006F4h case    3:*/		return 0x821006F8;
		  /* 821006F8h */ case    4:  		/* srawi R27, R11, 31 */
		/* 821006F8h case    4:*/		cpu::op::srawi<0,31>(regs,&regs.R27,regs.R11);
		/* 821006F8h case    4:*/		return 0x821006FC;
		  /* 821006FCh */ case    5:  		/* mr R25, R23 */
		/* 821006FCh case    5:*/		regs.R25 = regs.R23;
		/* 821006FCh case    5:*/		return 0x82100700;
		  /* 82100700h */ case    6:  		/* cmpwi CR6, R27, 0 */
		/* 82100700h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82100700h case    6:*/		return 0x82100704;
		  /* 82100704h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 82100704h case    7:*/		if ( regs.CR[6].eq ) { return 0x82100710;  }
		/* 82100704h case    7:*/		return 0x82100708;
		  /* 82100708h */ case    8:  		/* cmpwi CR6, R25, 1 */
		/* 82100708h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000001);
		/* 82100708h case    8:*/		return 0x8210070C;
		  /* 8210070Ch */ case    9:  		/* bc 4, CR6_EQ, 544 */
		/* 8210070Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8210092C;  }
		/* 8210070Ch case    9:*/		return 0x82100710;
	}
	return 0x82100710;
} // Block from 821006E8h-82100710h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82100710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100710);
		  /* 82100710h */ case    0:  		/* addi R10, R1, 96 */
		/* 82100710h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 82100710h case    0:*/		return 0x82100714;
		  /* 82100714h */ case    1:  		/* li R11, -1 */
		/* 82100714h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82100714h case    1:*/		return 0x82100718;
		  /* 82100718h */ case    2:  		/* li R7, 0 */
		/* 82100718h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82100718h case    2:*/		return 0x8210071C;
		  /* 8210071Ch */ case    3:  		/* cmplwi CR6, R29, 0 */
		/* 8210071Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8210071Ch case    3:*/		return 0x82100720;
		  /* 82100720h */ case    4:  		/* stw R11, <#[R10]> */
		/* 82100720h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82100720h case    4:*/		return 0x82100724;
		  /* 82100724h */ case    5:  		/* stw R11, <#[R10 + 4]> */
		/* 82100724h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82100724h case    5:*/		return 0x82100728;
		  /* 82100728h */ case    6:  		/* stw R11, <#[R10 + 8]> */
		/* 82100728h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82100728h case    6:*/		return 0x8210072C;
		  /* 8210072Ch */ case    7:  		/* stw R11, <#[R10 + 12]> */
		/* 8210072Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210072Ch case    7:*/		return 0x82100730;
		  /* 82100730h */ case    8:  		/* bc 12, CR6_EQ, 168 */
		/* 82100730h case    8:*/		if ( regs.CR[6].eq ) { return 0x821007D8;  }
		/* 82100730h case    8:*/		return 0x82100734;
		  /* 82100734h */ case    9:  		/* addi R11, R1, 96 */
		/* 82100734h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82100734h case    9:*/		return 0x82100738;
		  /* 82100738h */ case   10:  		/* subf R4, R28, R11 */
		/* 82100738h case   10:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R28,regs.R11);
		/* 82100738h case   10:*/		return 0x8210073C;
		  /* 8210073Ch */ case   11:  		/* li R8, 0 */
		/* 8210073Ch case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210073Ch case   11:*/		return 0x82100740;
		  /* 82100740h */ case   12:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 82100740h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 82100740h case   12:*/		return 0x82100744;
		  /* 82100744h */ case   13:  		/* mr R9, R28 */
		/* 82100744h case   13:*/		regs.R9 = regs.R28;
		/* 82100744h case   13:*/		return 0x82100748;
		  /* 82100748h */ case   14:  		/* lwzx R10, <#[R11 + R6]> */
		/* 82100748h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82100748h case   14:*/		return 0x8210074C;
		  /* 8210074Ch */ case   15:  		/* slw R3, R23, R8 */
		/* 8210074Ch case   15:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R23,regs.R8);
		/* 8210074Ch case   15:*/		return 0x82100750;
		  /* 82100750h */ case   16:  		/* and. R10, R10, R3 */
		/* 82100750h case   16:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R3);
		/* 82100750h case   16:*/		return 0x82100754;
		  /* 82100754h */ case   17:  		/* bc 12, CR0_EQ, 88 */
		/* 82100754h case   17:*/		if ( regs.CR[0].eq ) { return 0x821007AC;  }
		/* 82100754h case   17:*/		return 0x82100758;
		  /* 82100758h */ case   18:  		/* lwz R10, <#[R9]> */
		/* 82100758h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82100758h case   18:*/		return 0x8210075C;
		  /* 8210075Ch */ case   19:  		/* cmpwi CR6, R10, -1 */
		/* 8210075Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210075Ch case   19:*/		return 0x82100760;
		  /* 82100760h */ case   20:  		/* bc 4, CR6_EQ, 16 */
		/* 82100760h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82100770;  }
		/* 82100760h case   20:*/		return 0x82100764;
		  /* 82100764h */ case   21:  		/* lwzx R10, <#[R11 + R5]> */
		/* 82100764h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 82100764h case   21:*/		return 0x82100768;
		  /* 82100768h */ case   22:  		/* stwx R10, <#[R4 + R9]> */
		/* 82100768h case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + regs.R9 + 0x00000000) );
		/* 82100768h case   22:*/		return 0x8210076C;
		  /* 8210076Ch */ case   23:  		/* b 64 */
		/* 8210076Ch case   23:*/		return 0x821007AC;
		/* 8210076Ch case   23:*/		return 0x82100770;
	}
	return 0x82100770;
} // Block from 82100710h-82100770h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82100770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100770);
		  /* 82100770h */ case    0:  		/* lwzx R3, <#[R11 + R5]> */
		/* 82100770h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 82100770h case    0:*/		return 0x82100774;
		  /* 82100774h */ case    1:  		/* extsw R31, R25 */
		/* 82100774h case    1:*/		cpu::op::extsw<0>(regs,&regs.R31,regs.R25);
		/* 82100774h case    1:*/		return 0x82100778;
	}
	return 0x82100778;
} // Block from 82100770h-82100778h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82100778h
// Function '?SeparatePhases_MoveTex@CProgram@D3DXShader@@AAAHI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100778);
		  /* 82100778h */ case    0:  		/* lwz R30, <#[R24 + 20]> */
		/* 82100778h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R24 + 0x00000014) );
		/* 82100778h case    0:*/		return 0x8210077C;
		  /* 8210077Ch */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210077Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210077Ch case    1:*/		return 0x82100780;
		  /* 82100780h */ case    2:  		/* rlwinm R3, R3, 2, 0, 29 */
		/* 82100780h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R3);
		/* 82100780h case    2:*/		return 0x82100784;
		  /* 82100784h */ case    3:  		/* std R31, <#[R1 + 80]> */
		/* 82100784h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 82100784h case    3:*/		return 0x82100788;
		  /* 82100788h */ case    4:  		/* lfd FR0, <#[R1 + 80]> */
		/* 82100788h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82100788h case    4:*/		return 0x8210078C;
		  /* 8210078Ch */ case    5:  		/* fcfid FR0, FR0 */
		/* 8210078Ch case    5:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8210078Ch case    5:*/		return 0x82100790;
		  /* 82100790h */ case    6:  		/* lwzx R3, <#[R3 + R30]> */
		/* 82100790h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + regs.R30 + 0x00000000) );
		/* 82100790h case    6:*/		return 0x82100794;
		  /* 82100794h */ case    7:  		/* lwzx R10, <#[R10 + R30]> */
		/* 82100794h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 82100794h case    7:*/		return 0x82100798;
		  /* 82100798h */ case    8:  		/* lfd FR13, <#[R3 + 32]> */
		/* 82100798h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R3 + 0x00000020) );
		/* 82100798h case    8:*/		return 0x8210079C;
		  /* 8210079Ch */ case    9:  		/* fmul FR0, FR13, FR0 */
		/* 8210079Ch case    9:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 8210079Ch case    9:*/		return 0x821007A0;
		  /* 821007A0h */ case   10:  		/* lfd FR13, <#[R10 + 32]> */
		/* 821007A0h case   10:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000020) );
		/* 821007A0h case   10:*/		return 0x821007A4;
		  /* 821007A4h */ case   11:  		/* fcmpu CR6, FR13, FR0 */
		/* 821007A4h case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821007A4h case   11:*/		return 0x821007A8;
		  /* 821007A8h */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 821007A8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821007BC;  }
		/* 821007A8h case   12:*/		return 0x821007AC;
	}
	return 0x821007AC;
} // Block from 82100778h-821007ACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821007ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821007AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821007AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821007AC);
		  /* 821007ACh */ case    0:  		/* addi R8, R8, 1 */
		/* 821007ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821007ACh case    0:*/		return 0x821007B0;
		  /* 821007B0h */ case    1:  		/* addi R9, R9, 4 */
		/* 821007B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821007B0h case    1:*/		return 0x821007B4;
		  /* 821007B4h */ case    2:  		/* cmplwi CR6, R8, 4 */
		/* 821007B4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000004);
		/* 821007B4h case    2:*/		return 0x821007B8;
		  /* 821007B8h */ case    3:  		/* bc 12, CR6_LT, -112 */
		/* 821007B8h case    3:*/		if ( regs.CR[6].lt ) { return 0x82100748;  }
		/* 821007B8h case    3:*/		return 0x821007BC;
	}
	return 0x821007BC;
} // Block from 821007ACh-821007BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821007BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821007BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821007BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821007BC);
		  /* 821007BCh */ case    0:  		/* cmplwi CR6, R8, 4 */
		/* 821007BCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000004);
		/* 821007BCh case    0:*/		return 0x821007C0;
		  /* 821007C0h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 821007C0h case    1:*/		if ( regs.CR[6].lt ) { return 0x821007D0;  }
		/* 821007C0h case    1:*/		return 0x821007C4;
		  /* 821007C4h */ case    2:  		/* addi R7, R7, 1 */
		/* 821007C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821007C4h case    2:*/		return 0x821007C8;
		  /* 821007C8h */ case    3:  		/* cmplw CR6, R7, R29 */
		/* 821007C8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R29);
		/* 821007C8h case    3:*/		return 0x821007CC;
		  /* 821007CCh */ case    4:  		/* bc 12, CR6_LT, -144 */
		/* 821007CCh case    4:*/		if ( regs.CR[6].lt ) { return 0x8210073C;  }
		/* 821007CCh case    4:*/		return 0x821007D0;
	}
	return 0x821007D0;
} // Block from 821007BCh-821007D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821007D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821007D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821007D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821007D0);
		  /* 821007D0h */ case    0:  		/* cmplw CR6, R7, R29 */
		/* 821007D0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R29);
		/* 821007D0h case    0:*/		return 0x821007D4;
		  /* 821007D4h */ case    1:  		/* bc 12, CR6_LT, 344 */
		/* 821007D4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8210092C;  }
		/* 821007D4h case    1:*/		return 0x821007D8;
	}
	return 0x821007D8;
} // Block from 821007D0h-821007D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821007D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821007D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821007D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821007D8);
		  /* 821007D8h */ case    0:  		/* li R3, 0 */
		/* 821007D8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821007D8h case    0:*/		return 0x821007DC;
		  /* 821007DCh */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 821007DCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821007DCh case    1:*/		return 0x821007E0;
		  /* 821007E0h */ case    2:  		/* bc 12, CR6_EQ, 356 */
		/* 821007E0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82100944;  }
		/* 821007E0h case    2:*/		return 0x821007E4;
		  /* 821007E4h */ case    3:  		/* mr R31, R5 */
		/* 821007E4h case    3:*/		regs.R31 = regs.R5;
		/* 821007E4h case    3:*/		return 0x821007E8;
		  /* 821007E8h */ case    4:  		/* subf R30, R5, R6 */
		/* 821007E8h case    4:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R5,regs.R6);
		/* 821007E8h case    4:*/		return 0x821007EC;
		  /* 821007ECh */ case    5:  		/* lwzx R11, <#[R30 + R31]> */
		/* 821007ECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 821007ECh case    5:*/		return 0x821007F0;
		  /* 821007F0h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821007F0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821007F0h case    6:*/		return 0x821007F4;
		  /* 821007F4h */ case    7:  		/* bc 4, CR6_EQ, 288 */
		/* 821007F4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82100914;  }
		/* 821007F4h case    7:*/		return 0x821007F8;
		  /* 821007F8h */ case    8:  		/* addi R11, R1, 96 */
		/* 821007F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 821007F8h case    8:*/		return 0x821007FC;
		  /* 821007FCh */ case    9:  		/* li R7, 0 */
		/* 821007FCh case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821007FCh case    9:*/		return 0x82100800;
		  /* 82100800h */ case   10:  		/* rlwinm R9, R3, 2, 0, 29 */
		/* 82100800h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R3);
		/* 82100800h case   10:*/		return 0x82100804;
		  /* 82100804h */ case   11:  		/* addi R8, R1, 96 */
		/* 82100804h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 82100804h case   11:*/		return 0x82100808;
		  /* 82100808h */ case   12:  		/* subf R4, R11, R28 */
		/* 82100808h case   12:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R11,regs.R28);
		/* 82100808h case   12:*/		return 0x8210080C;
		  /* 8210080Ch */ case   13:  		/* lwzx R11, <#[R4 + R8]> */
		/* 8210080Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + regs.R8 + 0x00000000) );
		/* 8210080Ch case   13:*/		return 0x82100810;
		  /* 82100810h */ case   14:  		/* cmpwi CR6, R11, -1 */
		/* 82100810h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82100810h case   14:*/		return 0x82100814;
		  /* 82100814h */ case   15:  		/* bc 12, CR6_EQ, 64 */
		/* 82100814h case   15:*/		if ( regs.CR[6].eq ) { return 0x82100854;  }
		/* 82100814h case   15:*/		return 0x82100818;
		  /* 82100818h */ case   16:  		/* lwzx R10, <#[R9 + R5]> */
		/* 82100818h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 82100818h case   16:*/		return 0x8210081C;
		  /* 8210081Ch */ case   17:  		/* extsw R21, R25 */
		/* 8210081Ch case   17:*/		cpu::op::extsw<0>(regs,&regs.R21,regs.R25);
		/* 8210081Ch case   17:*/		return 0x82100820;
		  /* 82100820h */ case   18:  		/* lwz R20, <#[R24 + 20]> */
		/* 82100820h case   18:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R24 + 0x00000014) );
		/* 82100820h case   18:*/		return 0x82100824;
		  /* 82100824h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82100824h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82100824h case   19:*/		return 0x82100828;
		  /* 82100828h */ case   20:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82100828h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82100828h case   20:*/		return 0x8210082C;
		  /* 8210082Ch */ case   21:  		/* std R21, <#[R1 + 88]> */
		/* 8210082Ch case   21:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R1 + 0x00000058) );
		/* 8210082Ch case   21:*/		return 0x82100830;
		  /* 82100830h */ case   22:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82100830h case   22:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82100830h case   22:*/		return 0x82100834;
		  /* 82100834h */ case   23:  		/* fcfid FR0, FR0 */
		/* 82100834h case   23:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82100834h case   23:*/		return 0x82100838;
		  /* 82100838h */ case   24:  		/* lwzx R10, <#[R10 + R20]> */
		/* 82100838h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R20 + 0x00000000) );
		/* 82100838h case   24:*/		return 0x8210083C;
		  /* 8210083Ch */ case   25:  		/* lwzx R11, <#[R11 + R20]> */
		/* 8210083Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 8210083Ch case   25:*/		return 0x82100840;
		  /* 82100840h */ case   26:  		/* lfd FR13, <#[R10 + 32]> */
		/* 82100840h case   26:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000020) );
		/* 82100840h case   26:*/		return 0x82100844;
		  /* 82100844h */ case   27:  		/* fmul FR0, FR13, FR0 */
		/* 82100844h case   27:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82100844h case   27:*/		return 0x82100848;
		  /* 82100848h */ case   28:  		/* lfd FR13, <#[R11 + 32]> */
		/* 82100848h case   28:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 82100848h case   28:*/		return 0x8210084C;
		  /* 8210084Ch */ case   29:  		/* fcmpu CR6, FR13, FR0 */
		/* 8210084Ch case   29:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 8210084Ch case   29:*/		return 0x82100850;
		  /* 82100850h */ case   30:  		/* bc 12, CR6_EQ, 112 */
		/* 82100850h case   30:*/		if ( regs.CR[6].eq ) { return 0x821008C0;  }
		/* 82100850h case   30:*/		return 0x82100854;
	}
	return 0x82100854;
} // Block from 821007D8h-82100854h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82100854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100854);
		  /* 82100854h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 82100854h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 82100854h case    0:*/		return 0x82100858;
		  /* 82100858h */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 82100858h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82100858h case    1:*/		return 0x8210085C;
		  /* 8210085Ch */ case    2:  		/* bc 12, CR6_EQ, 84 */
		/* 8210085Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821008B0;  }
		/* 8210085Ch case    2:*/		return 0x82100860;
		  /* 82100860h */ case    3:  		/* lwz R11, <#[R24 + 20]> */
		/* 82100860h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 82100860h case    3:*/		return 0x82100864;
		  /* 82100864h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82100864h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82100864h case    4:*/		return 0x82100868;
		  /* 82100868h */ case    5:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82100868h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82100868h case    5:*/		return 0x8210086C;
		  /* 8210086Ch */ case    6:  		/* lwz R21, <#[R10 + 60]> */
		/* 8210086Ch case    6:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R10 + 0x0000003C) );
		/* 8210086Ch case    6:*/		return 0x82100870;
		  /* 82100870h */ case    7:  		/* rlwinm. R21, R21, 0, 12, 12 */
		/* 82100870h case    7:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R21,regs.R21);
		/* 82100870h case    7:*/		return 0x82100874;
		  /* 82100874h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 82100874h case    8:*/		if ( regs.CR[0].eq ) { return 0x82100884;  }
		/* 82100874h case    8:*/		return 0x82100878;
		  /* 82100878h */ case    9:  		/* lfd FR0, <#[R10 + 32]> */
		/* 82100878h case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 82100878h case    9:*/		return 0x8210087C;
		  /* 8210087Ch */ case   10:  		/* fneg FR13, FR0 */
		/* 8210087Ch case   10:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 8210087Ch case   10:*/		return 0x82100880;
		  /* 82100880h */ case   11:  		/* b 8 */
		/* 82100880h case   11:*/		return 0x82100888;
		/* 82100880h case   11:*/		return 0x82100884;
	}
	return 0x82100884;
} // Block from 82100854h-82100884h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82100884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100884);
		  /* 82100884h */ case    0:  		/* lfd FR13, <#[R10 + 32]> */
		/* 82100884h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000020) );
		/* 82100884h case    0:*/		return 0x82100888;
	}
	return 0x82100888;
} // Block from 82100884h-82100888h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82100888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100888);
		  /* 82100888h */ case    0:  		/* lwzx R10, <#[R9 + R5]> */
		/* 82100888h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 82100888h case    0:*/		return 0x8210088C;
		  /* 8210088Ch */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210088Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210088Ch case    1:*/		return 0x82100890;
		  /* 82100890h */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82100890h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82100890h case    2:*/		return 0x82100894;
		  /* 82100894h */ case    3:  		/* lwz R10, <#[R11 + 60]> */
		/* 82100894h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000003C) );
		/* 82100894h case    3:*/		return 0x82100898;
		  /* 82100898h */ case    4:  		/* lfd FR0, <#[R11 + 32]> */
		/* 82100898h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 82100898h case    4:*/		return 0x8210089C;
		  /* 8210089Ch */ case    5:  		/* rlwinm. R10, R10, 0, 12, 12 */
		/* 8210089Ch case    5:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R10,regs.R10);
		/* 8210089Ch case    5:*/		return 0x821008A0;
		  /* 821008A0h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 821008A0h case    6:*/		if ( regs.CR[0].eq ) { return 0x821008A8;  }
		/* 821008A0h case    6:*/		return 0x821008A4;
		  /* 821008A4h */ case    7:  		/* fneg FR0, FR0 */
		/* 821008A4h case    7:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 821008A4h case    7:*/		return 0x821008A8;
	}
	return 0x821008A8;
} // Block from 82100888h-821008A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821008A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821008A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821008A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821008A8);
		  /* 821008A8h */ case    0:  		/* fcmpu CR6, FR13, FR0 */
		/* 821008A8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821008A8h case    0:*/		return 0x821008AC;
		  /* 821008ACh */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 821008ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x821008C0;  }
		/* 821008ACh case    1:*/		return 0x821008B0;
	}
	return 0x821008B0;
} // Block from 821008A8h-821008B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821008B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821008B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821008B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821008B0);
		  /* 821008B0h */ case    0:  		/* addi R7, R7, 1 */
		/* 821008B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821008B0h case    0:*/		return 0x821008B4;
		  /* 821008B4h */ case    1:  		/* addi R8, R8, 4 */
		/* 821008B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 821008B4h case    1:*/		return 0x821008B8;
		  /* 821008B8h */ case    2:  		/* cmplwi CR6, R7, 4 */
		/* 821008B8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000004);
		/* 821008B8h case    2:*/		return 0x821008BC;
		  /* 821008BCh */ case    3:  		/* bc 12, CR6_LT, -176 */
		/* 821008BCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8210080C;  }
		/* 821008BCh case    3:*/		return 0x821008C0;
	}
	return 0x821008C0;
} // Block from 821008B0h-821008C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821008C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821008C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821008C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821008C0);
		  /* 821008C0h */ case    0:  		/* cmplwi CR6, R7, 4 */
		/* 821008C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000004);
		/* 821008C0h case    0:*/		return 0x821008C4;
		  /* 821008C4h */ case    1:  		/* bc 12, CR6_LT, 80 */
		/* 821008C4h case    1:*/		if ( regs.CR[6].lt ) { return 0x82100914;  }
		/* 821008C4h case    1:*/		return 0x821008C8;
		  /* 821008C8h */ case    2:  		/* li R10, 0 */
		/* 821008C8h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821008C8h case    2:*/		return 0x821008CC;
		  /* 821008CCh */ case    3:  		/* addi R11, R1, 96 */
		/* 821008CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 821008CCh case    3:*/		return 0x821008D0;
		  /* 821008D0h */ case    4:  		/* lwzx R9, <#[R4 + R11]> */
		/* 821008D0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 821008D0h case    4:*/		return 0x821008D4;
		  /* 821008D4h */ case    5:  		/* cmpwi CR6, R9, -1 */
		/* 821008D4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 821008D4h case    5:*/		return 0x821008D8;
		  /* 821008D8h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 821008D8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821008E8;  }
		/* 821008D8h case    6:*/		return 0x821008DC;
		  /* 821008DCh */ case    7:  		/* lwz R9, <#[R11]> */
		/* 821008DCh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821008DCh case    7:*/		return 0x821008E0;
		  /* 821008E0h */ case    8:  		/* cmpwi CR6, R9, -1 */
		/* 821008E0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 821008E0h case    8:*/		return 0x821008E4;
		  /* 821008E4h */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 821008E4h case    9:*/		if ( regs.CR[6].eq ) { return 0x821008FC;  }
		/* 821008E4h case    9:*/		return 0x821008E8;
	}
	return 0x821008E8;
} // Block from 821008C0h-821008E8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821008E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821008E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821008E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821008E8);
		  /* 821008E8h */ case    0:  		/* addi R10, R10, 1 */
		/* 821008E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821008E8h case    0:*/		return 0x821008EC;
		  /* 821008ECh */ case    1:  		/* addi R11, R11, 4 */
		/* 821008ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821008ECh case    1:*/		return 0x821008F0;
		  /* 821008F0h */ case    2:  		/* cmplwi CR6, R10, 4 */
		/* 821008F0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 821008F0h case    2:*/		return 0x821008F4;
		  /* 821008F4h */ case    3:  		/* bc 12, CR6_LT, -36 */
		/* 821008F4h case    3:*/		if ( regs.CR[6].lt ) { return 0x821008D0;  }
		/* 821008F4h case    3:*/		return 0x821008F8;
		  /* 821008F8h */ case    4:  		/* b 20 */
		/* 821008F8h case    4:*/		return 0x8210090C;
		/* 821008F8h case    4:*/		return 0x821008FC;
	}
	return 0x821008FC;
} // Block from 821008E8h-821008FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821008FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821008FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821008FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821008FC);
		  /* 821008FCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821008FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821008FCh case    0:*/		return 0x82100900;
		  /* 82100900h */ case    1:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 82100900h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 82100900h case    1:*/		return 0x82100904;
		  /* 82100904h */ case    2:  		/* addi R8, R1, 96 */
		/* 82100904h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 82100904h case    2:*/		return 0x82100908;
		  /* 82100908h */ case    3:  		/* stwx R11, <#[R9 + R8]> */
		/* 82100908h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82100908h case    3:*/		return 0x8210090C;
	}
	return 0x8210090C;
} // Block from 821008FCh-8210090Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210090Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210090C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210090C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210090C);
		  /* 8210090Ch */ case    0:  		/* cmplwi CR6, R10, 4 */
		/* 8210090Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 8210090Ch case    0:*/		return 0x82100910;
		  /* 82100910h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82100910h case    1:*/		if ( regs.CR[6].eq ) { return 0x82100924;  }
		/* 82100910h case    1:*/		return 0x82100914;
	}
	return 0x82100914;
} // Block from 8210090Ch-82100914h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82100914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100914);
		  /* 82100914h */ case    0:  		/* addi R3, R3, 1 */
		/* 82100914h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82100914h case    0:*/		return 0x82100918;
		  /* 82100918h */ case    1:  		/* addi R31, R31, 4 */
		/* 82100918h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82100918h case    1:*/		return 0x8210091C;
		  /* 8210091Ch */ case    2:  		/* cmplw CR6, R3, R29 */
		/* 8210091Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R29);
		/* 8210091Ch case    2:*/		return 0x82100920;
	}
	return 0x82100920;
} // Block from 82100914h-82100920h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82100920h
// Function '?ReorderInstructions_MarkParents@CProgram@D3DXShader@@AAAXPAVCInstruction@2@PAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100920);
		  /* 82100920h */ case    0:  		/* bc 12, CR6_LT, -308 */
		/* 82100920h case    0:*/		if ( regs.CR[6].lt ) { return 0x821007EC;  }
		/* 82100920h case    0:*/		return 0x82100924;
	}
	return 0x82100924;
} // Block from 82100920h-82100924h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82100924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100924);
		  /* 82100924h */ case    0:  		/* cmplw CR6, R3, R29 */
		/* 82100924h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R29);
		/* 82100924h case    0:*/		return 0x82100928;
		  /* 82100928h */ case    1:  		/* bc 4, CR6_LT, 28 */
		/* 82100928h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82100944;  }
		/* 82100928h case    1:*/		return 0x8210092C;
	}
	return 0x8210092C;
} // Block from 82100924h-8210092Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210092Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210092C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210092C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210092C);
		  /* 8210092Ch */ case    0:  		/* addi R25, R25, -2 */
		/* 8210092Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xFFFFFFFE);
		/* 8210092Ch case    0:*/		return 0x82100930;
		  /* 82100930h */ case    1:  		/* cmpwi CR6, R25, -1 */
		/* 82100930h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0xFFFFFFFF);
		/* 82100930h case    1:*/		return 0x82100934;
		  /* 82100934h */ case    2:  		/* bc 4, CR6_LT, -564 */
		/* 82100934h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82100700;  }
		/* 82100934h case    2:*/		return 0x82100938;
		  /* 82100938h */ case    3:  		/* addi R26, R26, 1 */
		/* 82100938h case    3:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82100938h case    3:*/		return 0x8210093C;
		  /* 8210093Ch */ case    4:  		/* addi R28, R28, 16 */
		/* 8210093Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x10);
		/* 8210093Ch case    4:*/		return 0x82100940;
		  /* 82100940h */ case    5:  		/* b -580 */
		/* 82100940h case    5:*/		return 0x821006FC;
		/* 82100940h case    5:*/		return 0x82100944;
	}
	return 0x82100944;
} // Block from 8210092Ch-82100944h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82100944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100944);
		  /* 82100944h */ case    0:  		/* addi R11, R1, 96 */
		/* 82100944h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82100944h case    0:*/		return 0x82100948;
		  /* 82100948h */ case    1:  		/* addi R10, R1, 96 */
		/* 82100948h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 82100948h case    1:*/		return 0x8210094C;
		  /* 8210094Ch */ case    2:  		/* li R29, 0 */
		/* 8210094Ch case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210094Ch case    2:*/		return 0x82100950;
		  /* 82100950h */ case    3:  		/* addi R31, R1, 96 */
		/* 82100950h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x60);
		/* 82100950h case    3:*/		return 0x82100954;
		  /* 82100954h */ case    4:  		/* subf R28, R11, R28 */
		/* 82100954h case    4:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R11,regs.R28);
		/* 82100954h case    4:*/		return 0x82100958;
		  /* 82100958h */ case    5:  		/* subf R30, R10, R5 */
		/* 82100958h case    5:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R10,regs.R5);
		/* 82100958h case    5:*/		return 0x8210095C;
		  /* 8210095Ch */ case    6:  		/* lwz R7, <#[R31]> */
		/* 8210095Ch case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 8210095Ch case    6:*/		return 0x82100960;
		  /* 82100960h */ case    7:  		/* cmpwi CR6, R25, 0 */
		/* 82100960h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82100960h case    7:*/		return 0x82100964;
		  /* 82100964h */ case    8:  		/* bc 4, CR6_LT, 52 */
		/* 82100964h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82100998;  }
		/* 82100964h case    8:*/		return 0x82100968;
		  /* 82100968h */ case    9:  		/* lwzx R6, <#[R28 + R31]> */
		/* 82100968h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R28 + regs.R31 + 0x00000000) );
		/* 82100968h case    9:*/		return 0x8210096C;
		  /* 8210096Ch */ case   10:  		/* cmplw CR6, R6, R7 */
		/* 8210096Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 8210096Ch case   10:*/		return 0x82100970;
		  /* 82100970h */ case   11:  		/* bc 12, CR6_EQ, 52 */
		/* 82100970h case   11:*/		if ( regs.CR[6].eq ) { return 0x821009A4;  }
		/* 82100970h case   11:*/		return 0x82100974;
		  /* 82100974h */ case   12:  		/* cmpwi CR6, R6, -1 */
		/* 82100974h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 82100974h case   12:*/		return 0x82100978;
		  /* 82100978h */ case   13:  		/* mr R3, R24 */
		/* 82100978h case   13:*/		regs.R3 = regs.R24;
		/* 82100978h case   13:*/		return 0x8210097C;
		  /* 8210097Ch */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 8210097Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x82100990;  }
		/* 8210097Ch case   14:*/		return 0x82100980;
		  /* 82100980h */ case   15:  		/* mr R5, R29 */
		/* 82100980h case   15:*/		regs.R5 = regs.R29;
		/* 82100980h case   15:*/		return 0x82100984;
		  /* 82100984h */ case   16:  		/* mr R4, R26 */
		/* 82100984h case   16:*/		regs.R4 = regs.R26;
		/* 82100984h case   16:*/		return 0x82100988;
		  /* 82100988h */ case   17:  		/* bl -2064 */
		/* 82100988h case   17:*/		regs.LR = 0x8210098C; return 0x82100178;
		/* 82100988h case   17:*/		return 0x8210098C;
		  /* 8210098Ch */ case   18:  		/* b 72 */
		/* 8210098Ch case   18:*/		return 0x821009D4;
		/* 8210098Ch case   18:*/		return 0x82100990;
	}
	return 0x82100990;
} // Block from 82100944h-82100990h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82100990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100990);
		  /* 82100990h */ case    0:  		/* li R8, 1 */
		/* 82100990h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82100990h case    0:*/		return 0x82100994;
		  /* 82100994h */ case    1:  		/* b 48 */
		/* 82100994h case    1:*/		return 0x821009C4;
		/* 82100994h case    1:*/		return 0x82100998;
	}
	return 0x82100998;
} // Block from 82100990h-82100998h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82100998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100998);
		  /* 82100998h */ case    0:  		/* lwzx R11, <#[R28 + R31]> */
		/* 82100998h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R31 + 0x00000000) );
		/* 82100998h case    0:*/		return 0x8210099C;
		  /* 8210099Ch */ case    1:  		/* cmplw CR6, R11, R7 */
		/* 8210099Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8210099Ch case    1:*/		return 0x821009A0;
		  /* 821009A0h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 821009A0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821009AC;  }
		/* 821009A0h case    2:*/		return 0x821009A4;
	}
	return 0x821009A4;
} // Block from 82100998h-821009A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821009A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821009A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821009A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821009A4);
		  /* 821009A4h */ case    0:  		/* stwx R7, <#[R30 + R31]> */
		/* 821009A4h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 821009A4h case    0:*/		return 0x821009A8;
		  /* 821009A8h */ case    1:  		/* b 48 */
		/* 821009A8h case    1:*/		return 0x821009D8;
		/* 821009A8h case    1:*/		return 0x821009AC;
	}
	return 0x821009AC;
} // Block from 821009A4h-821009ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821009ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821009AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821009AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821009AC);
		  /* 821009ACh */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 821009ACh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821009ACh case    0:*/		return 0x821009B0;
	}
	return 0x821009B0;
} // Block from 821009ACh-821009B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821009B0h
// Function '?ReorderInstructions_ComputeDependency@CProgram@D3DXShader@@AAAXPAVCInstruction@2@PAIPAHI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821009B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821009B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821009B0);
		  /* 821009B0h */ case    0:  		/* bc 12, CR6_EQ, 12 */
		/* 821009B0h case    0:*/		if ( regs.CR[6].eq ) { return 0x821009BC;  }
		/* 821009B0h case    0:*/		return 0x821009B4;
		  /* 821009B4h */ case    1:  		/* stwx R11, <#[R30 + R31]> */
		/* 821009B4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 821009B4h case    1:*/		return 0x821009B8;
		  /* 821009B8h */ case    2:  		/* b 32 */
		/* 821009B8h case    2:*/		return 0x821009D8;
		/* 821009B8h case    2:*/		return 0x821009BC;
	}
	return 0x821009BC;
} // Block from 821009B0h-821009BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821009BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821009BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821009BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821009BC);
		  /* 821009BCh */ case    0:  		/* li R8, 0 */
		/* 821009BCh case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821009BCh case    0:*/		return 0x821009C0;
		  /* 821009C0h */ case    1:  		/* mr R3, R24 */
		/* 821009C0h case    1:*/		regs.R3 = regs.R24;
		/* 821009C0h case    1:*/		return 0x821009C4;
	}
	return 0x821009C4;
} // Block from 821009BCh-821009C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821009C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821009C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821009C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821009C4);
		  /* 821009C4h */ case    0:  		/* mr R6, R29 */
		/* 821009C4h case    0:*/		regs.R6 = regs.R29;
		/* 821009C4h case    0:*/		return 0x821009C8;
		  /* 821009C8h */ case    1:  		/* mr R5, R26 */
		/* 821009C8h case    1:*/		regs.R5 = regs.R26;
		/* 821009C8h case    1:*/		return 0x821009CC;
		  /* 821009CCh */ case    2:  		/* mr R4, R22 */
		/* 821009CCh case    2:*/		regs.R4 = regs.R22;
		/* 821009CCh case    2:*/		return 0x821009D0;
		  /* 821009D0h */ case    3:  		/* bl -1992 */
		/* 821009D0h case    3:*/		regs.LR = 0x821009D4; return 0x82100208;
		/* 821009D0h case    3:*/		return 0x821009D4;
	}
	return 0x821009D4;
} // Block from 821009C4h-821009D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821009D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821009D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821009D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821009D4);
		  /* 821009D4h */ case    0:  		/* stwx R3, <#[R30 + R31]> */
		/* 821009D4h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 821009D4h case    0:*/		return 0x821009D8;
	}
	return 0x821009D8;
} // Block from 821009D4h-821009D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821009D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821009D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821009D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821009D8);
		  /* 821009D8h */ case    0:  		/* addi R29, R29, 1 */
		/* 821009D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821009D8h case    0:*/		return 0x821009DC;
		  /* 821009DCh */ case    1:  		/* addi R31, R31, 4 */
		/* 821009DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821009DCh case    1:*/		return 0x821009E0;
		  /* 821009E0h */ case    2:  		/* cmplwi CR6, R29, 4 */
		/* 821009E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000004);
		/* 821009E0h case    2:*/		return 0x821009E4;
		  /* 821009E4h */ case    3:  		/* bc 12, CR6_LT, -136 */
		/* 821009E4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210095C;  }
		/* 821009E4h case    3:*/		return 0x821009E8;
	}
	return 0x821009E8;
} // Block from 821009D8h-821009E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821009E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821009E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821009E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821009E8);
		  /* 821009E8h */ case    0:  		/* li R3, 0 */
		/* 821009E8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821009E8h case    0:*/		return 0x821009EC;
	}
	return 0x821009EC;
} // Block from 821009E8h-821009ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821009ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821009EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821009EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821009EC);
		  /* 821009ECh */ case    0:  		/* addi R1, R1, 224 */
		/* 821009ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 821009ECh case    0:*/		return 0x821009F0;
		  /* 821009F0h */ case    1:  		/* b -456552 */
		/* 821009F0h case    1:*/		return 0x82091288;
		/* 821009F0h case    1:*/		return 0x821009F4;
		  /* 821009F4h */ case    2:  		/* nop */
		/* 821009F4h case    2:*/		cpu::op::nop();
		/* 821009F4h case    2:*/		return 0x821009F8;
		  /* 821009F8h */ case    3:  		/* lwz R10, <#[R3 + 20]> */
		/* 821009F8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 821009F8h case    3:*/		return 0x821009FC;
		  /* 821009FCh */ case    4:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 821009FCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 821009FCh case    4:*/		return 0x82100A00;
		  /* 82100A00h */ case    5:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82100A00h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82100A00h case    5:*/		return 0x82100A04;
		  /* 82100A04h */ case    6:  		/* lwz R11, <#[R10 + 72]> */
		/* 82100A04h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000048) );
		/* 82100A04h case    6:*/		return 0x82100A08;
		  /* 82100A08h */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 82100A08h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82100A08h case    7:*/		return 0x82100A0C;
		  /* 82100A0Ch */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 82100A0Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82100A18;  }
		/* 82100A0Ch case    8:*/		return 0x82100A10;
		  /* 82100A10h */ case    9:  		/* li R3, 1 */
		/* 82100A10h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82100A10h case    9:*/		return 0x82100A14;
		  /* 82100A14h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82100A14h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82100A14h case   10:*/		return 0x82100A18;
	}
	return 0x82100A18;
} // Block from 821009ECh-82100A18h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82100A18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100A18);
		  /* 82100A18h */ case    0:  		/* cmplw CR6, R11, R6 */
		/* 82100A18h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 82100A18h case    0:*/		return 0x82100A1C;
		  /* 82100A1Ch */ case    1:  		/* bc 12, CR6_LT, 116 */
		/* 82100A1Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x82100A90;  }
		/* 82100A1Ch case    1:*/		return 0x82100A20;
		  /* 82100A20h */ case    2:  		/* cmplw CR6, R11, R7 */
		/* 82100A20h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 82100A20h case    2:*/		return 0x82100A24;
		  /* 82100A24h */ case    3:  		/* bc 4, CR6_LT, 108 */
		/* 82100A24h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82100A90;  }
		/* 82100A24h case    3:*/		return 0x82100A28;
		  /* 82100A28h */ case    4:  		/* lwz R11, <#[R5 + 16]> */
		/* 82100A28h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000010) );
		/* 82100A28h case    4:*/		return 0x82100A2C;
		  /* 82100A2Ch */ case    5:  		/* lwz R9, <#[R3 + 20]> */
		/* 82100A2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82100A2Ch case    5:*/		return 0x82100A30;
		  /* 82100A30h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 82100A30h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82100A30h case    6:*/		return 0x82100A34;
		  /* 82100A34h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82100A34h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82100A34h case    7:*/		return 0x82100A38;
		  /* 82100A38h */ case    8:  		/* lwzx R9, <#[R11 + R9]> */
		/* 82100A38h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82100A38h case    8:*/		return 0x82100A3C;
		  /* 82100A3Ch */ case    9:  		/* lwz R11, <#[R9 + 20]> */
		/* 82100A3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 82100A3Ch case    9:*/		return 0x82100A40;
		  /* 82100A40h */ case   10:  		/* lwz R9, <#[R9 + 24]> */
		/* 82100A40h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 82100A40h case   10:*/		return 0x82100A44;
		  /* 82100A44h */ case   11:  		/* cmpwi CR6, R11, -1 */
		/* 82100A44h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82100A44h case   11:*/		return 0x82100A48;
		  /* 82100A48h */ case   12:  		/* bc 12, CR6_EQ, 44 */
		/* 82100A48h case   12:*/		if ( regs.CR[6].eq ) { return 0x82100A74;  }
		/* 82100A48h case   12:*/		return 0x82100A4C;
		  /* 82100A4Ch */ case   13:  		/* lwz R8, <#[R10 + 20]> */
		/* 82100A4Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000014) );
		/* 82100A4Ch case   13:*/		return 0x82100A50;
		  /* 82100A50h */ case   14:  		/* cmplw CR6, R11, R8 */
		/* 82100A50h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82100A50h case   14:*/		return 0x82100A54;
		  /* 82100A54h */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 82100A54h case   15:*/		if ( regs.CR[6].eq ) { return 0x82100A74;  }
		/* 82100A54h case   15:*/		return 0x82100A58;
		  /* 82100A58h */ case   16:  		/* lwz R9, <#[R3 + 20]> */
		/* 82100A58h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82100A58h case   16:*/		return 0x82100A5C;
		  /* 82100A5Ch */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82100A5Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82100A5Ch case   17:*/		return 0x82100A60;
		  /* 82100A60h */ case   18:  		/* lwzx R9, <#[R11 + R9]> */
		/* 82100A60h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82100A60h case   18:*/		return 0x82100A64;
		  /* 82100A64h */ case   19:  		/* lwz R11, <#[R9 + 20]> */
		/* 82100A64h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 82100A64h case   19:*/		return 0x82100A68;
		  /* 82100A68h */ case   20:  		/* lwz R9, <#[R9 + 24]> */
		/* 82100A68h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 82100A68h case   20:*/		return 0x82100A6C;
		  /* 82100A6Ch */ case   21:  		/* cmpwi CR6, R11, -1 */
		/* 82100A6Ch case   21:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82100A6Ch case   21:*/		return 0x82100A70;
		  /* 82100A70h */ case   22:  		/* bc 4, CR6_EQ, -32 */
		/* 82100A70h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82100A50;  }
		/* 82100A70h case   22:*/		return 0x82100A74;
	}
	return 0x82100A74;
} // Block from 82100A18h-82100A74h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82100A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100A74);
		  /* 82100A74h */ case    0:  		/* lwz R8, <#[R10 + 20]> */
		/* 82100A74h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000014) );
		/* 82100A74h case    0:*/		return 0x82100A78;
		  /* 82100A78h */ case    1:  		/* cmplw CR6, R11, R8 */
		/* 82100A78h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82100A78h case    1:*/		return 0x82100A7C;
		  /* 82100A7Ch */ case    2:  		/* bc 4, CR6_EQ, 20 */
		/* 82100A7Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82100A90;  }
		/* 82100A7Ch case    2:*/		return 0x82100A80;
		  /* 82100A80h */ case    3:  		/* lwz R11, <#[R10 + 24]> */
		/* 82100A80h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 82100A80h case    3:*/		return 0x82100A84;
		  /* 82100A84h */ case    4:  		/* li R3, 1 */
		/* 82100A84h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82100A84h case    4:*/		return 0x82100A88;
		  /* 82100A88h */ case    5:  		/* cmpw CR6, R9, R11 */
		/* 82100A88h case    5:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R11);
		/* 82100A88h case    5:*/		return 0x82100A8C;
		  /* 82100A8Ch */ case    6:  		/* bclr 12, CR6_EQ */
		/* 82100A8Ch case    6:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82100A8Ch case    6:*/		return 0x82100A90;
	}
	return 0x82100A90;
} // Block from 82100A74h-82100A90h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82100A90h
// Function '?ReorderInstructions@CProgram@D3DXShader@@AAAJIPAI0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100A90);
		  /* 82100A90h */ case    0:  		/* li R3, 0 */
		/* 82100A90h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82100A90h case    0:*/		return 0x82100A94;
		  /* 82100A94h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82100A94h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82100A94h case    1:*/		return 0x82100A98;
	}
	return 0x82100A98;
} // Block from 82100A90h-82100A98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82100A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100A98);
		  /* 82100A98h */ case    0:  		/* lwz R9, <#[R3 + 20]> */
		/* 82100A98h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82100A98h case    0:*/		return 0x82100A9C;
		  /* 82100A9Ch */ case    1:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 82100A9Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 82100A9Ch case    1:*/		return 0x82100AA0;
		  /* 82100AA0h */ case    2:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82100AA0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82100AA0h case    2:*/		return 0x82100AA4;
		  /* 82100AA4h */ case    3:  		/* lwzx R8, <#[R10 + R9]> */
		/* 82100AA4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82100AA4h case    3:*/		return 0x82100AA8;
		  /* 82100AA8h */ case    4:  		/* lwzx R9, <#[R9 + R11]> */
		/* 82100AA8h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82100AA8h case    4:*/		return 0x82100AAC;
		  /* 82100AACh */ case    5:  		/* lwz R8, <#[R8 + 4]> */
		/* 82100AACh case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 82100AACh case    5:*/		return 0x82100AB0;
		  /* 82100AB0h */ case    6:  		/* lwz R9, <#[R9 + 4]> */
		/* 82100AB0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82100AB0h case    6:*/		return 0x82100AB4;
		  /* 82100AB4h */ case    7:  		/* cmplw CR6, R9, R8 */
		/* 82100AB4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82100AB4h case    7:*/		return 0x82100AB8;
		  /* 82100AB8h */ case    8:  		/* bc 4, CR6_EQ, 64 */
		/* 82100AB8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82100AF8;  }
		/* 82100AB8h case    8:*/		return 0x82100ABC;
		  /* 82100ABCh */ case    9:  		/* lwz R9, <#[R3 + 20]> */
		/* 82100ABCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82100ABCh case    9:*/		return 0x82100AC0;
		  /* 82100AC0h */ case   10:  		/* lwzx R8, <#[R9 + R10]> */
		/* 82100AC0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82100AC0h case   10:*/		return 0x82100AC4;
		  /* 82100AC4h */ case   11:  		/* lwzx R9, <#[R9 + R11]> */
		/* 82100AC4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82100AC4h case   11:*/		return 0x82100AC8;
		  /* 82100AC8h */ case   12:  		/* lwz R8, <#[R8 + 8]> */
		/* 82100AC8h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 82100AC8h case   12:*/		return 0x82100ACC;
		  /* 82100ACCh */ case   13:  		/* lwz R9, <#[R9 + 8]> */
		/* 82100ACCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82100ACCh case   13:*/		return 0x82100AD0;
		  /* 82100AD0h */ case   14:  		/* cmplw CR6, R9, R8 */
		/* 82100AD0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82100AD0h case   14:*/		return 0x82100AD4;
		  /* 82100AD4h */ case   15:  		/* bc 4, CR6_EQ, 36 */
		/* 82100AD4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82100AF8;  }
		/* 82100AD4h case   15:*/		return 0x82100AD8;
		  /* 82100AD8h */ case   16:  		/* lwz R9, <#[R3 + 20]> */
		/* 82100AD8h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82100AD8h case   16:*/		return 0x82100ADC;
		  /* 82100ADCh */ case   17:  		/* li R3, 1 */
		/* 82100ADCh case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82100ADCh case   17:*/		return 0x82100AE0;
		  /* 82100AE0h */ case   18:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82100AE0h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82100AE0h case   18:*/		return 0x82100AE4;
		  /* 82100AE4h */ case   19:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82100AE4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82100AE4h case   19:*/		return 0x82100AE8;
		  /* 82100AE8h */ case   20:  		/* lwz R10, <#[R10 + 12]> */
		/* 82100AE8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 82100AE8h case   20:*/		return 0x82100AEC;
		  /* 82100AECh */ case   21:  		/* lwz R11, <#[R11 + 12]> */
		/* 82100AECh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82100AECh case   21:*/		return 0x82100AF0;
		  /* 82100AF0h */ case   22:  		/* cmplw CR6, R11, R10 */
		/* 82100AF0h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82100AF0h case   22:*/		return 0x82100AF4;
		  /* 82100AF4h */ case   23:  		/* bclr 12, CR6_EQ */
		/* 82100AF4h case   23:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82100AF4h case   23:*/		return 0x82100AF8;
	}
	return 0x82100AF8;
} // Block from 82100A98h-82100AF8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82100AF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100AF8);
		  /* 82100AF8h */ case    0:  		/* li R3, 0 */
		/* 82100AF8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82100AF8h case    0:*/		return 0x82100AFC;
		  /* 82100AFCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 82100AFCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82100AFCh case    1:*/		return 0x82100B00;
	}
	return 0x82100B00;
} // Block from 82100AF8h-82100B00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82100B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100B00);
		  /* 82100B00h */ case    0:  		/* mfspr R12, LR */
		/* 82100B00h case    0:*/		regs.R12 = regs.LR;
		/* 82100B00h case    0:*/		return 0x82100B04;
		  /* 82100B04h */ case    1:  		/* bl -456892 */
		/* 82100B04h case    1:*/		regs.LR = 0x82100B08; return 0x82091248;
		/* 82100B04h case    1:*/		return 0x82100B08;
		  /* 82100B08h */ case    2:  		/* lwz R29, <#[R3 + 20]> */
		/* 82100B08h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000014) );
		/* 82100B08h case    2:*/		return 0x82100B0C;
		  /* 82100B0Ch */ case    3:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82100B0Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82100B0Ch case    3:*/		return 0x82100B10;
		  /* 82100B10h */ case    4:  		/* lwzx R10, <#[R11 + R29]> */
		/* 82100B10h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82100B10h case    4:*/		return 0x82100B14;
		  /* 82100B14h */ case    5:  		/* lwz R11, <#[R10 + 72]> */
		/* 82100B14h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000048) );
		/* 82100B14h case    5:*/		return 0x82100B18;
		  /* 82100B18h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 82100B18h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82100B18h case    6:*/		return 0x82100B1C;
		  /* 82100B1Ch */ case    7:  		/* bc 12, CR6_EQ, 456 */
		/* 82100B1Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82100CE4;  }
		/* 82100B1Ch case    7:*/		return 0x82100B20;
		  /* 82100B20h */ case    8:  		/* lwz R10, <#[R10 + 8]> */
		/* 82100B20h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82100B20h case    8:*/		return 0x82100B24;
		  /* 82100B24h */ case    9:  		/* cmpwi CR6, R10, -1 */
		/* 82100B24h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82100B24h case    9:*/		return 0x82100B28;
		  /* 82100B28h */ case   10:  		/* bc 4, CR6_EQ, 444 */
		/* 82100B28h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82100CE4;  }
		/* 82100B28h case   10:*/		return 0x82100B2C;
		  /* 82100B2Ch */ case   11:  		/* lwz R10, <#[R3 + 24]> */
		/* 82100B2Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 82100B2Ch case   11:*/		return 0x82100B30;
		  /* 82100B30h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82100B30h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82100B30h case   12:*/		return 0x82100B34;
		  /* 82100B34h */ case   13:  		/* lis R9, 4112 */
		/* 82100B34h case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0x1010);
		/* 82100B34h case   13:*/		return 0x82100B38;
		  /* 82100B38h */ case   14:  		/* lwzx R30, <#[R11 + R10]> */
		/* 82100B38h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82100B38h case   14:*/		return 0x82100B3C;
		  /* 82100B3Ch */ case   15:  		/* lwz R11, <#[R30]> */
		/* 82100B3Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82100B3Ch case   15:*/		return 0x82100B40;
		  /* 82100B40h */ case   16:  		/* rlwinm R27, R11, 0, 0, 11 */
		/* 82100B40h case   16:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R27,regs.R11);
		/* 82100B40h case   16:*/		return 0x82100B44;
		  /* 82100B44h */ case   17:  		/* cmplw CR6, R27, R9 */
		/* 82100B44h case   17:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R9);
		/* 82100B44h case   17:*/		return 0x82100B48;
		  /* 82100B48h */ case   18:  		/* bc 4, CR6_EQ, 92 */
		/* 82100B48h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82100BA4;  }
		/* 82100B48h case   18:*/		return 0x82100B4C;
		  /* 82100B4Ch */ case   19:  		/* lwz R8, <#[R30 + 12]> */
		/* 82100B4Ch case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000000C) );
		/* 82100B4Ch case   19:*/		return 0x82100B50;
		  /* 82100B50h */ case   20:  		/* li R10, 0 */
		/* 82100B50h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82100B50h case   20:*/		return 0x82100B54;
		  /* 82100B54h */ case   21:  		/* cmplwi CR6, R8, 0 */
		/* 82100B54h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82100B54h case   21:*/		return 0x82100B58;
		  /* 82100B58h */ case   22:  		/* bc 12, CR6_EQ, 40 */
		/* 82100B58h case   22:*/		if ( regs.CR[6].eq ) { return 0x82100B80;  }
		/* 82100B58h case   22:*/		return 0x82100B5C;
		  /* 82100B5Ch */ case   23:  		/* lwz R9, <#[R30 + 16]> */
		/* 82100B5Ch case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 82100B5Ch case   23:*/		return 0x82100B60;
		  /* 82100B60h */ case   24:  		/* li R11, 0 */
		/* 82100B60h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82100B60h case   24:*/		return 0x82100B64;
		  /* 82100B64h */ case   25:  		/* lwzx R7, <#[R11 + R9]> */
		/* 82100B64h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82100B64h case   25:*/		return 0x82100B68;
		  /* 82100B68h */ case   26:  		/* cmplw CR6, R7, R4 */
		/* 82100B68h case   26:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 82100B68h case   26:*/		return 0x82100B6C;
		  /* 82100B6Ch */ case   27:  		/* bc 12, CR6_EQ, 20 */
		/* 82100B6Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x82100B80;  }
		/* 82100B6Ch case   27:*/		return 0x82100B70;
		  /* 82100B70h */ case   28:  		/* addi R10, R10, 1 */
		/* 82100B70h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82100B70h case   28:*/		return 0x82100B74;
		  /* 82100B74h */ case   29:  		/* addi R11, R11, 4 */
		/* 82100B74h case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82100B74h case   29:*/		return 0x82100B78;
		  /* 82100B78h */ case   30:  		/* cmplw CR6, R10, R8 */
		/* 82100B78h case   30:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82100B78h case   30:*/		return 0x82100B7C;
		  /* 82100B7Ch */ case   31:  		/* bc 12, CR6_LT, -24 */
		/* 82100B7Ch case   31:*/		if ( regs.CR[6].lt ) { return 0x82100B64;  }
		/* 82100B7Ch case   31:*/		return 0x82100B80;
	}
	return 0x82100B80;
} // Block from 82100B00h-82100B80h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82100B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100B80);
		  /* 82100B80h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82100B80h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82100B80h case    0:*/		return 0x82100B84;
		  /* 82100B84h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 82100B84h case    1:*/		if ( regs.CR[6].eq ) { return 0x82100B94;  }
		/* 82100B84h case    1:*/		return 0x82100B88;
		  /* 82100B88h */ case    2:  		/* lfd FR0, <#[R5]> */
		/* 82100B88h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R5 + 0x00000000) );
		/* 82100B88h case    2:*/		return 0x82100B8C;
		  /* 82100B8Ch */ case    3:  		/* fneg FR0, FR0 */
		/* 82100B8Ch case    3:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 82100B8Ch case    3:*/		return 0x82100B90;
		  /* 82100B90h */ case    4:  		/* stfd FR0, <#[R5]> */
		/* 82100B90h case    4:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R5 + 0x00000000) );
		/* 82100B90h case    4:*/		return 0x82100B94;
	}
	return 0x82100B94;
} // Block from 82100B80h-82100B94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82100B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100B94);
		  /* 82100B94h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82100B94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82100B94h case    0:*/		return 0x82100B98;
		  /* 82100B98h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82100B98h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82100B98h case    1:*/		return 0x82100B9C;
		  /* 82100B9Ch */ case    2:  		/* lwzx R3, <#[R10 + R11]> */
		/* 82100B9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82100B9Ch case    2:*/		return 0x82100BA0;
		  /* 82100BA0h */ case    3:  		/* b 328 */
		/* 82100BA0h case    3:*/		return 0x82100CE8;
		/* 82100BA0h case    3:*/		return 0x82100BA4;
	}
	return 0x82100BA4;
} // Block from 82100B94h-82100BA4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82100BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100BA4);
		  /* 82100BA4h */ case    0:  		/* lis R25, 8272 */
		/* 82100BA4h case    0:*/		cpu::op::lis<0>(regs,&regs.R25,0x2050);
		/* 82100BA4h case    0:*/		return 0x82100BA8;
		  /* 82100BA8h */ case    1:  		/* lis R26, 8256 */
		/* 82100BA8h case    1:*/		cpu::op::lis<0>(regs,&regs.R26,0x2040);
		/* 82100BA8h case    1:*/		return 0x82100BAC;
		  /* 82100BACh */ case    2:  		/* cmplw CR6, R27, R25 */
		/* 82100BACh case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R25);
		/* 82100BACh case    2:*/		return 0x82100BB0;
		  /* 82100BB0h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82100BB0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82100BBC;  }
		/* 82100BB0h case    3:*/		return 0x82100BB4;
		  /* 82100BB4h */ case    4:  		/* cmplw CR6, R27, R26 */
		/* 82100BB4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R26);
		/* 82100BB4h case    4:*/		return 0x82100BB8;
		  /* 82100BB8h */ case    5:  		/* bc 4, CR6_EQ, 300 */
		/* 82100BB8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82100CE4;  }
		/* 82100BB8h case    5:*/		return 0x82100BBC;
	}
	return 0x82100BBC;
} // Block from 82100BA4h-82100BBCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82100BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100BBC);
		  /* 82100BBCh */ case    0:  		/* lwz R28, <#[R30 + 12]> */
		/* 82100BBCh case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x0000000C) );
		/* 82100BBCh case    0:*/		return 0x82100BC0;
		  /* 82100BC0h */ case    1:  		/* li R7, 0 */
		/* 82100BC0h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82100BC0h case    1:*/		return 0x82100BC4;
		  /* 82100BC4h */ case    2:  		/* cmplwi CR6, R28, 0 */
		/* 82100BC4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82100BC4h case    2:*/		return 0x82100BC8;
		  /* 82100BC8h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 82100BC8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82100BF0;  }
		/* 82100BC8h case    3:*/		return 0x82100BCC;
		  /* 82100BCCh */ case    4:  		/* lwz R10, <#[R30 + 16]> */
		/* 82100BCCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 82100BCCh case    4:*/		return 0x82100BD0;
		  /* 82100BD0h */ case    5:  		/* li R11, 0 */
		/* 82100BD0h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82100BD0h case    5:*/		return 0x82100BD4;
		  /* 82100BD4h */ case    6:  		/* lwzx R9, <#[R11 + R10]> */
		/* 82100BD4h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82100BD4h case    6:*/		return 0x82100BD8;
		  /* 82100BD8h */ case    7:  		/* cmplw CR6, R9, R4 */
		/* 82100BD8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 82100BD8h case    7:*/		return 0x82100BDC;
		  /* 82100BDCh */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82100BDCh case    8:*/		if ( regs.CR[6].eq ) { return 0x82100BF0;  }
		/* 82100BDCh case    8:*/		return 0x82100BE0;
		  /* 82100BE0h */ case    9:  		/* addi R7, R7, 1 */
		/* 82100BE0h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82100BE0h case    9:*/		return 0x82100BE4;
		  /* 82100BE4h */ case   10:  		/* addi R11, R11, 4 */
		/* 82100BE4h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82100BE4h case   10:*/		return 0x82100BE8;
		  /* 82100BE8h */ case   11:  		/* cmplw CR6, R7, R28 */
		/* 82100BE8h case   11:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R28);
		/* 82100BE8h case   11:*/		return 0x82100BEC;
		  /* 82100BECh */ case   12:  		/* bc 12, CR6_LT, -24 */
		/* 82100BECh case   12:*/		if ( regs.CR[6].lt ) { return 0x82100BD4;  }
		/* 82100BECh case   12:*/		return 0x82100BF0;
	}
	return 0x82100BF0;
} // Block from 82100BBCh-82100BF0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82100BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100BF0);
		  /* 82100BF0h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82100BF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82100BF0h case    0:*/		return 0x82100BF4;
		  /* 82100BF4h */ case    1:  		/* li R8, 0 */
		/* 82100BF4h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82100BF4h case    1:*/		return 0x82100BF8;
		  /* 82100BF8h */ case    2:  		/* lwz R31, <#[R3 + 16]> */
		/* 82100BF8h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000010) );
		/* 82100BF8h case    2:*/		return 0x82100BFC;
		  /* 82100BFCh */ case    3:  		/* li R4, 1 */
		/* 82100BFCh case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82100BFCh case    3:*/		return 0x82100C00;
		  /* 82100C00h */ case    4:  		/* lwz R10, <#[R30 + 8]> */
		/* 82100C00h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82100C00h case    4:*/		return 0x82100C04;
		  /* 82100C04h */ case    5:  		/* mullw R9, R4, R11 */
		/* 82100C04h case    5:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R4,regs.R11);
		/* 82100C04h case    5:*/		return 0x82100C08;
		  /* 82100C08h */ case    6:  		/* add R3, R9, R7 */
		/* 82100C08h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R9,regs.R7);
		/* 82100C08h case    6:*/		return 0x82100C0C;
		  /* 82100C0Ch */ case    7:  		/* mullw R9, R11, R8 */
		/* 82100C0Ch case    7:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R11,regs.R8);
		/* 82100C0Ch case    7:*/		return 0x82100C10;
		  /* 82100C10h */ case    8:  		/* rlwinm R3, R3, 2, 0, 29 */
		/* 82100C10h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R3);
		/* 82100C10h case    8:*/		return 0x82100C14;
		  /* 82100C14h */ case    9:  		/* add R9, R9, R7 */
		/* 82100C14h case    9:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82100C14h case    9:*/		return 0x82100C18;
		  /* 82100C18h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82100C18h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82100C18h case   10:*/		return 0x82100C1C;
		  /* 82100C1Ch */ case   11:  		/* lwzx R3, <#[R3 + R10]> */
		/* 82100C1Ch case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 82100C1Ch case   11:*/		return 0x82100C20;
		  /* 82100C20h */ case   12:  		/* rlwinm R24, R3, 2, 0, 29 */
		/* 82100C20h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R3);
		/* 82100C20h case   12:*/		return 0x82100C24;
		  /* 82100C24h */ case   13:  		/* lwzx R3, <#[R9 + R10]> */
		/* 82100C24h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82100C24h case   13:*/		return 0x82100C28;
		  /* 82100C28h */ case   14:  		/* lwzx R9, <#[R24 + R29]> */
		/* 82100C28h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + regs.R29 + 0x00000000) );
		/* 82100C28h case   14:*/		return 0x82100C2C;
		  /* 82100C2Ch */ case   15:  		/* lwz R24, <#[R9 + 4]> */
		/* 82100C2Ch case   15:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R9 + 0x00000004) );
		/* 82100C2Ch case   15:*/		return 0x82100C30;
		  /* 82100C30h */ case   16:  		/* rlwinm R24, R24, 2, 0, 29 */
		/* 82100C30h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R24);
		/* 82100C30h case   16:*/		return 0x82100C34;
		  /* 82100C34h */ case   17:  		/* lwzx R24, <#[R24 + R31]> */
		/* 82100C34h case   17:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R24 + regs.R31 + 0x00000000) );
		/* 82100C34h case   17:*/		return 0x82100C38;
		  /* 82100C38h */ case   18:  		/* lwz R24, <#[R24 + 4]> */
		/* 82100C38h case   18:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R24 + 0x00000004) );
		/* 82100C38h case   18:*/		return 0x82100C3C;
		  /* 82100C3Ch */ case   19:  		/* rlwinm. R24, R24, 0, 23, 23 */
		/* 82100C3Ch case   19:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R24,regs.R24);
		/* 82100C3Ch case   19:*/		return 0x82100C40;
		  /* 82100C40h */ case   20:  		/* bc 12, CR0_EQ, 16 */
		/* 82100C40h case   20:*/		if ( regs.CR[0].eq ) { return 0x82100C50;  }
		/* 82100C40h case   20:*/		return 0x82100C44;
		  /* 82100C44h */ case   21:  		/* lwz R24, <#[R9 + 8]> */
		/* 82100C44h case   21:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R9 + 0x00000008) );
		/* 82100C44h case   21:*/		return 0x82100C48;
		  /* 82100C48h */ case   22:  		/* cmpwi CR6, R24, -1 */
		/* 82100C48h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R24,0xFFFFFFFF);
		/* 82100C48h case   22:*/		return 0x82100C4C;
		  /* 82100C4Ch */ case   23:  		/* bc 12, CR6_EQ, 100 */
		/* 82100C4Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x82100CB0;  }
		/* 82100C4Ch case   23:*/		return 0x82100C50;
	}
	return 0x82100C50;
} // Block from 82100BF0h-82100C50h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82100C50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100C50);
		  /* 82100C50h */ case    0:  		/* addi R8, R8, 1 */
		/* 82100C50h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82100C50h case    0:*/		return 0x82100C54;
		  /* 82100C54h */ case    1:  		/* addi R4, R4, -1 */
		/* 82100C54h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFFFF);
		/* 82100C54h case    1:*/		return 0x82100C58;
		  /* 82100C58h */ case    2:  		/* cmplwi CR6, R8, 2 */
		/* 82100C58h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000002);
		/* 82100C58h case    2:*/		return 0x82100C5C;
		  /* 82100C5Ch */ case    3:  		/* bc 12, CR6_LT, -88 */
		/* 82100C5Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82100C04;  }
		/* 82100C5Ch case    3:*/		return 0x82100C60;
		  /* 82100C60h */ case    4:  		/* cmplw CR6, R27, R26 */
		/* 82100C60h case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R26);
		/* 82100C60h case    4:*/		return 0x82100C64;
		  /* 82100C64h */ case    5:  		/* bc 4, CR6_EQ, 128 */
		/* 82100C64h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82100CE4;  }
		/* 82100C64h case    5:*/		return 0x82100C68;
		  /* 82100C68h */ case    6:  		/* add R10, R28, R7 */
		/* 82100C68h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R28,regs.R7);
		/* 82100C68h case    6:*/		return 0x82100C6C;
		  /* 82100C6Ch */ case    7:  		/* lwz R9, <#[R30 + 8]> */
		/* 82100C6Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 82100C6Ch case    7:*/		return 0x82100C70;
		  /* 82100C70h */ case    8:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 82100C70h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 82100C70h case    8:*/		return 0x82100C74;
		  /* 82100C74h */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82100C74h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82100C74h case    9:*/		return 0x82100C78;
		  /* 82100C78h */ case   10:  		/* lwzx R8, <#[R9 + R11]> */
		/* 82100C78h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82100C78h case   10:*/		return 0x82100C7C;
		  /* 82100C7Ch */ case   11:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82100C7Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82100C7Ch case   11:*/		return 0x82100C80;
		  /* 82100C80h */ case   12:  		/* cmplw CR6, R8, R10 */
		/* 82100C80h case   12:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 82100C80h case   12:*/		return 0x82100C84;
		  /* 82100C84h */ case   13:  		/* bc 4, CR6_EQ, 96 */
		/* 82100C84h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82100CE4;  }
		/* 82100C84h case   13:*/		return 0x82100C88;
		  /* 82100C88h */ case   14:  		/* cmplwi CR6, R5, 0 */
		/* 82100C88h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82100C88h case   14:*/		return 0x82100C8C;
		  /* 82100C8Ch */ case   15:  		/* bc 12, CR6_EQ, 24 */
		/* 82100C8Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82100CA4;  }
		/* 82100C8Ch case   15:*/		return 0x82100C90;
		  /* 82100C90h */ case   16:  		/* lis R10, -32255 */
		/* 82100C90h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82100C90h case   16:*/		return 0x82100C94;
		  /* 82100C94h */ case   17:  		/* lfd FR13, <#[R5]> */
		/* 82100C94h case   17:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R5 + 0x00000000) );
		/* 82100C94h case   17:*/		return 0x82100C98;
		  /* 82100C98h */ case   18:  		/* lfd FR0, <#[R10 - 24504]> */
		/* 82100C98h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0xFFFFA048) );
		/* 82100C98h case   18:*/		return 0x82100C9C;
		  /* 82100C9Ch */ case   19:  		/* fmul FR0, FR13, FR0 */
		/* 82100C9Ch case   19:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82100C9Ch case   19:*/		return 0x82100CA0;
		  /* 82100CA0h */ case   20:  		/* stfd FR0, <#[R5]> */
		/* 82100CA0h case   20:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R5 + 0x00000000) );
		/* 82100CA0h case   20:*/		return 0x82100CA4;
	}
	return 0x82100CA4;
} // Block from 82100C50h-82100CA4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82100CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100CA4);
		  /* 82100CA4h */ case    0:  		/* lwz R10, <#[R30 + 8]> */
		/* 82100CA4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82100CA4h case    0:*/		return 0x82100CA8;
		  /* 82100CA8h */ case    1:  		/* lwzx R3, <#[R11 + R10]> */
		/* 82100CA8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82100CA8h case    1:*/		return 0x82100CAC;
		  /* 82100CACh */ case    2:  		/* b 60 */
		/* 82100CACh case    2:*/		return 0x82100CE8;
		/* 82100CACh case    2:*/		return 0x82100CB0;
	}
	return 0x82100CB0;
} // Block from 82100CA4h-82100CB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82100CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100CB0);
		  /* 82100CB0h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82100CB0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82100CB0h case    0:*/		return 0x82100CB4;
		  /* 82100CB4h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 82100CB4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82100CE8;  }
		/* 82100CB4h case    1:*/		return 0x82100CB8;
		  /* 82100CB8h */ case    2:  		/* lfd FR0, <#[R9 + 32]> */
		/* 82100CB8h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000020) );
		/* 82100CB8h case    2:*/		return 0x82100CBC;
		  /* 82100CBCh */ case    3:  		/* cmplw CR6, R27, R25 */
		/* 82100CBCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R25);
		/* 82100CBCh case    3:*/		return 0x82100CC0;
		  /* 82100CC0h */ case    4:  		/* lfd FR13, <#[R5]> */
		/* 82100CC0h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R5 + 0x00000000) );
		/* 82100CC0h case    4:*/		return 0x82100CC4;
		  /* 82100CC4h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 82100CC4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82100CD4;  }
		/* 82100CC4h case    5:*/		return 0x82100CC8;
		  /* 82100CC8h */ case    6:  		/* fmul FR0, FR0, FR13 */
		/* 82100CC8h case    6:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 82100CC8h case    6:*/		return 0x82100CCC;
		  /* 82100CCCh */ case    7:  		/* stfd FR0, <#[R5]> */
		/* 82100CCCh case    7:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R5 + 0x00000000) );
		/* 82100CCCh case    7:*/		return 0x82100CD0;
		  /* 82100CD0h */ case    8:  		/* b 24 */
		/* 82100CD0h case    8:*/		return 0x82100CE8;
		/* 82100CD0h case    8:*/		return 0x82100CD4;
	}
	return 0x82100CD4;
} // Block from 82100CB0h-82100CD4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82100CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100CD4);
		  /* 82100CD4h */ case    0:  		/* lfd FR12, <#[R6]> */
		/* 82100CD4h case    0:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R6 + 0x00000000) );
		/* 82100CD4h case    0:*/		return 0x82100CD8;
		  /* 82100CD8h */ case    1:  		/* fmadd FR0, FR0, FR13, FR12 */
		/* 82100CD8h case    1:*/		cpu::op::fmadd<0>(regs,&regs.FR0,regs.FR0,regs.FR13,regs.FR12);
		/* 82100CD8h case    1:*/		return 0x82100CDC;
		  /* 82100CDCh */ case    2:  		/* stfd FR0, <#[R6]> */
		/* 82100CDCh case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R6 + 0x00000000) );
		/* 82100CDCh case    2:*/		return 0x82100CE0;
		  /* 82100CE0h */ case    3:  		/* b 8 */
		/* 82100CE0h case    3:*/		return 0x82100CE8;
		/* 82100CE0h case    3:*/		return 0x82100CE4;
	}
	return 0x82100CE4;
} // Block from 82100CD4h-82100CE4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82100CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100CE4);
		  /* 82100CE4h */ case    0:  		/* li R3, -1 */
		/* 82100CE4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82100CE4h case    0:*/		return 0x82100CE8;
	}
	return 0x82100CE8;
} // Block from 82100CE4h-82100CE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82100CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100CE8);
		  /* 82100CE8h */ case    0:  		/* b -457296 */
		/* 82100CE8h case    0:*/		return 0x82091298;
		/* 82100CE8h case    0:*/		return 0x82100CEC;
		  /* 82100CECh */ case    1:  		/* nop */
		/* 82100CECh case    1:*/		cpu::op::nop();
		/* 82100CECh case    1:*/		return 0x82100CF0;
	}
	return 0x82100CF0;
} // Block from 82100CE8h-82100CF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82100CF0h
// Function '?CompactLiterals_Negate@CProgram@D3DXShader@@AAAIIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100CF0);
		  /* 82100CF0h */ case    0:  		/* mfspr R12, LR */
		/* 82100CF0h case    0:*/		regs.R12 = regs.LR;
		/* 82100CF0h case    0:*/		return 0x82100CF4;
		  /* 82100CF4h */ case    1:  		/* bl -457368 */
		/* 82100CF4h case    1:*/		regs.LR = 0x82100CF8; return 0x8209125C;
		/* 82100CF4h case    1:*/		return 0x82100CF8;
		  /* 82100CF8h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 82100CF8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82100CF8h case    2:*/		return 0x82100CFC;
		  /* 82100CFCh */ case    3:  		/* li R8, 0 */
		/* 82100CFCh case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82100CFCh case    3:*/		return 0x82100D00;
		  /* 82100D00h */ case    4:  		/* mr R7, R8 */
		/* 82100D00h case    4:*/		regs.R7 = regs.R8;
		/* 82100D00h case    4:*/		return 0x82100D04;
		  /* 82100D04h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82100D04h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82100D04h case    5:*/		return 0x82100D08;
		  /* 82100D08h */ case    6:  		/* bc 4, CR6_GT, 64 */
		/* 82100D08h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82100D48;  }
		/* 82100D08h case    6:*/		return 0x82100D0C;
		  /* 82100D0Ch */ case    7:  		/* mr R9, R8 */
		/* 82100D0Ch case    7:*/		regs.R9 = regs.R8;
		/* 82100D0Ch case    7:*/		return 0x82100D10;
		  /* 82100D10h */ case    8:  		/* lwz R11, <#[R3 + 16]> */
		/* 82100D10h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82100D10h case    8:*/		return 0x82100D14;
		  /* 82100D14h */ case    9:  		/* lwzx R10, <#[R9 + R11]> */
		/* 82100D14h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82100D14h case    9:*/		return 0x82100D18;
		  /* 82100D18h */ case   10:  		/* lwz R11, <#[R10 + 4]> */
		/* 82100D18h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82100D18h case   10:*/		return 0x82100D1C;
		  /* 82100D1Ch */ case   11:  		/* and R31, R11, R5 */
		/* 82100D1Ch case   11:*/		cpu::op::and<0>(regs,&regs.R31,regs.R11,regs.R5);
		/* 82100D1Ch case   11:*/		return 0x82100D20;
		  /* 82100D20h */ case   12:  		/* cmplw CR6, R31, R5 */
		/* 82100D20h case   12:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R5);
		/* 82100D20h case   12:*/		return 0x82100D24;
		  /* 82100D24h */ case   13:  		/* bc 4, CR6_EQ, 16 */
		/* 82100D24h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82100D34;  }
		/* 82100D24h case   13:*/		return 0x82100D28;
		  /* 82100D28h */ case   14:  		/* and. R11, R11, R6 */
		/* 82100D28h case   14:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82100D28h case   14:*/		return 0x82100D2C;
		  /* 82100D2Ch */ case   15:  		/* bc 4, CR0_EQ, 8 */
		/* 82100D2Ch case   15:*/		if ( !regs.CR[0].eq ) { return 0x82100D34;  }
		/* 82100D2Ch case   15:*/		return 0x82100D30;
		  /* 82100D30h */ case   16:  		/* stw R8, <#[R10 + 8]> */
		/* 82100D30h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 82100D30h case   16:*/		return 0x82100D34;
	}
	return 0x82100D34;
} // Block from 82100CF0h-82100D34h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82100D34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100D34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100D34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100D34);
		  /* 82100D34h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82100D34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82100D34h case    0:*/		return 0x82100D38;
		  /* 82100D38h */ case    1:  		/* addi R7, R7, 1 */
		/* 82100D38h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82100D38h case    1:*/		return 0x82100D3C;
		  /* 82100D3Ch */ case    2:  		/* addi R9, R9, 4 */
		/* 82100D3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82100D3Ch case    2:*/		return 0x82100D40;
		  /* 82100D40h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 82100D40h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82100D40h case    3:*/		return 0x82100D44;
		  /* 82100D44h */ case    4:  		/* bc 12, CR6_LT, -52 */
		/* 82100D44h case    4:*/		if ( regs.CR[6].lt ) { return 0x82100D10;  }
		/* 82100D44h case    4:*/		return 0x82100D48;
	}
	return 0x82100D48;
} // Block from 82100D34h-82100D48h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82100D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100D48);
		  /* 82100D48h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82100D48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82100D48h case    0:*/		return 0x82100D4C;
		  /* 82100D4Ch */ case    1:  		/* mr R31, R8 */
		/* 82100D4Ch case    1:*/		regs.R31 = regs.R8;
		/* 82100D4Ch case    1:*/		return 0x82100D50;
		  /* 82100D50h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82100D50h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82100D50h case    2:*/		return 0x82100D54;
		  /* 82100D54h */ case    3:  		/* bc 4, CR6_GT, 100 */
		/* 82100D54h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82100DB8;  }
		/* 82100D54h case    3:*/		return 0x82100D58;
		  /* 82100D58h */ case    4:  		/* mr R7, R8 */
		/* 82100D58h case    4:*/		regs.R7 = regs.R8;
		/* 82100D58h case    4:*/		return 0x82100D5C;
		  /* 82100D5Ch */ case    5:  		/* lwz R11, <#[R3 + 20]> */
		/* 82100D5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82100D5Ch case    5:*/		return 0x82100D60;
		  /* 82100D60h */ case    6:  		/* lwz R9, <#[R3 + 16]> */
		/* 82100D60h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 82100D60h case    6:*/		return 0x82100D64;
		  /* 82100D64h */ case    7:  		/* lwzx R10, <#[R11 + R7]> */
		/* 82100D64h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82100D64h case    7:*/		return 0x82100D68;
		  /* 82100D68h */ case    8:  		/* lwz R11, <#[R10 + 4]> */
		/* 82100D68h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82100D68h case    8:*/		return 0x82100D6C;
		  /* 82100D6Ch */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82100D6Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82100D6Ch case    9:*/		return 0x82100D70;
		  /* 82100D70h */ case   10:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82100D70h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82100D70h case   10:*/		return 0x82100D74;
		  /* 82100D74h */ case   11:  		/* lwz R9, <#[R11 + 4]> */
		/* 82100D74h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82100D74h case   11:*/		return 0x82100D78;
		  /* 82100D78h */ case   12:  		/* and R30, R9, R5 */
		/* 82100D78h case   12:*/		cpu::op::and<0>(regs,&regs.R30,regs.R9,regs.R5);
		/* 82100D78h case   12:*/		return 0x82100D7C;
		  /* 82100D7Ch */ case   13:  		/* cmplw CR6, R30, R5 */
		/* 82100D7Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R5);
		/* 82100D7Ch case   13:*/		return 0x82100D80;
	}
	return 0x82100D80;
} // Block from 82100D48h-82100D80h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82100D80h
// Function '?CompactLiterals_Allocate@CProgram@D3DXShader@@AAAIPAIIIIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100D80);
		  /* 82100D80h */ case    0:  		/* bc 4, CR6_EQ, 36 */
		/* 82100D80h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82100DA4;  }
		/* 82100D80h case    0:*/		return 0x82100D84;
		  /* 82100D84h */ case    1:  		/* and. R9, R9, R6 */
		/* 82100D84h case    1:*/		cpu::op::and<1>(regs,&regs.R9,regs.R9,regs.R6);
		/* 82100D84h case    1:*/		return 0x82100D88;
		  /* 82100D88h */ case    2:  		/* bc 4, CR0_EQ, 28 */
		/* 82100D88h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82100DA4;  }
		/* 82100D88h case    2:*/		return 0x82100D8C;
		  /* 82100D8Ch */ case    3:  		/* lwz R10, <#[R10 + 12]> */
		/* 82100D8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 82100D8Ch case    3:*/		return 0x82100D90;
		  /* 82100D90h */ case    4:  		/* lwz R9, <#[R11 + 8]> */
		/* 82100D90h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82100D90h case    4:*/		return 0x82100D94;
		  /* 82100D94h */ case    5:  		/* addi R10, R10, 1 */
		/* 82100D94h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82100D94h case    5:*/		return 0x82100D98;
		  /* 82100D98h */ case    6:  		/* cmplw CR6, R9, R10 */
		/* 82100D98h case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82100D98h case    6:*/		return 0x82100D9C;
		  /* 82100D9Ch */ case    7:  		/* bc 12, CR6_GT, 8 */
		/* 82100D9Ch case    7:*/		if ( regs.CR[6].gt ) { return 0x82100DA4;  }
		/* 82100D9Ch case    7:*/		return 0x82100DA0;
		  /* 82100DA0h */ case    8:  		/* stw R10, <#[R11 + 8]> */
		/* 82100DA0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82100DA0h case    8:*/		return 0x82100DA4;
	}
	return 0x82100DA4;
} // Block from 82100D80h-82100DA4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82100DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100DA4);
		  /* 82100DA4h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82100DA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82100DA4h case    0:*/		return 0x82100DA8;
		  /* 82100DA8h */ case    1:  		/* addi R31, R31, 1 */
		/* 82100DA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82100DA8h case    1:*/		return 0x82100DAC;
		  /* 82100DACh */ case    2:  		/* addi R7, R7, 4 */
		/* 82100DACh case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82100DACh case    2:*/		return 0x82100DB0;
		  /* 82100DB0h */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 82100DB0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82100DB0h case    3:*/		return 0x82100DB4;
		  /* 82100DB4h */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 82100DB4h case    4:*/		if ( regs.CR[6].lt ) { return 0x82100D5C;  }
		/* 82100DB4h case    4:*/		return 0x82100DB8;
	}
	return 0x82100DB8;
} // Block from 82100DA4h-82100DB8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82100DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100DB8);
		  /* 82100DB8h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82100DB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82100DB8h case    0:*/		return 0x82100DBC;
		  /* 82100DBCh */ case    1:  		/* mr R31, R8 */
		/* 82100DBCh case    1:*/		regs.R31 = regs.R8;
		/* 82100DBCh case    1:*/		return 0x82100DC0;
		  /* 82100DC0h */ case    2:  		/* mr R30, R8 */
		/* 82100DC0h case    2:*/		regs.R30 = regs.R8;
		/* 82100DC0h case    2:*/		return 0x82100DC4;
		  /* 82100DC4h */ case    3:  		/* mr R7, R8 */
		/* 82100DC4h case    3:*/		regs.R7 = regs.R8;
		/* 82100DC4h case    3:*/		return 0x82100DC8;
		  /* 82100DC8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82100DC8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82100DC8h case    4:*/		return 0x82100DCC;
		  /* 82100DCCh */ case    5:  		/* bc 4, CR6_GT, 92 */
		/* 82100DCCh case    5:*/		if ( !regs.CR[6].gt ) { return 0x82100E28;  }
		/* 82100DCCh case    5:*/		return 0x82100DD0;
		  /* 82100DD0h */ case    6:  		/* mr R9, R8 */
		/* 82100DD0h case    6:*/		regs.R9 = regs.R8;
		/* 82100DD0h case    6:*/		return 0x82100DD4;
		  /* 82100DD4h */ case    7:  		/* lwz R11, <#[R3 + 16]> */
		/* 82100DD4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82100DD4h case    7:*/		return 0x82100DD8;
		  /* 82100DD8h */ case    8:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82100DD8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82100DD8h case    8:*/		return 0x82100DDC;
		  /* 82100DDCh */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 82100DDCh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82100DDCh case    9:*/		return 0x82100DE0;
		  /* 82100DE0h */ case   10:  		/* and R29, R10, R5 */
		/* 82100DE0h case   10:*/		cpu::op::and<0>(regs,&regs.R29,regs.R10,regs.R5);
		/* 82100DE0h case   10:*/		return 0x82100DE4;
		  /* 82100DE4h */ case   11:  		/* cmplw CR6, R29, R5 */
		/* 82100DE4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R5);
		/* 82100DE4h case   11:*/		return 0x82100DE8;
		  /* 82100DE8h */ case   12:  		/* bc 4, CR6_EQ, 44 */
		/* 82100DE8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82100E14;  }
		/* 82100DE8h case   12:*/		return 0x82100DEC;
		  /* 82100DECh */ case   13:  		/* and. R29, R10, R6 */
		/* 82100DECh case   13:*/		cpu::op::and<1>(regs,&regs.R29,regs.R10,regs.R6);
		/* 82100DECh case   13:*/		return 0x82100DF0;
		  /* 82100DF0h */ case   14:  		/* bc 4, CR0_EQ, 36 */
		/* 82100DF0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82100E14;  }
		/* 82100DF0h case   14:*/		return 0x82100DF4;
		  /* 82100DF4h */ case   15:  		/* rlwinm. R10, R10, 0, 21, 21 */
		/* 82100DF4h case   15:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R10);
		/* 82100DF4h case   15:*/		return 0x82100DF8;
		  /* 82100DF8h */ case   16:  		/* stw R31, <#[R11 + 16]> */
		/* 82100DF8h case   16:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000010) );
		/* 82100DF8h case   16:*/		return 0x82100DFC;
		  /* 82100DFCh */ case   17:  		/* stw R4, <#[R11 + 24]> */
		/* 82100DFCh case   17:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000018) );
		/* 82100DFCh case   17:*/		return 0x82100E00;
		  /* 82100E00h */ case   18:  		/* bc 12, CR0_EQ, 8 */
		/* 82100E00h case   18:*/		if ( regs.CR[0].eq ) { return 0x82100E08;  }
		/* 82100E00h case   18:*/		return 0x82100E04;
		  /* 82100E04h */ case   19:  		/* li R30, 1 */
		/* 82100E04h case   19:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82100E04h case   19:*/		return 0x82100E08;
	}
	return 0x82100E08;
} // Block from 82100DB8h-82100E08h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82100E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100E08);
		  /* 82100E08h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82100E08h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82100E08h case    0:*/		return 0x82100E0C;
		  /* 82100E0Ch */ case    1:  		/* stw R8, <#[R11 + 8]> */
		/* 82100E0Ch case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82100E0Ch case    1:*/		return 0x82100E10;
		  /* 82100E10h */ case    2:  		/* add R31, R10, R31 */
		/* 82100E10h case    2:*/		cpu::op::add<0>(regs,&regs.R31,regs.R10,regs.R31);
		/* 82100E10h case    2:*/		return 0x82100E14;
	}
	return 0x82100E14;
} // Block from 82100E08h-82100E14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82100E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100E14);
		  /* 82100E14h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82100E14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82100E14h case    0:*/		return 0x82100E18;
		  /* 82100E18h */ case    1:  		/* addi R7, R7, 1 */
		/* 82100E18h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82100E18h case    1:*/		return 0x82100E1C;
		  /* 82100E1Ch */ case    2:  		/* addi R9, R9, 4 */
		/* 82100E1Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82100E1Ch case    2:*/		return 0x82100E20;
		  /* 82100E20h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 82100E20h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82100E20h case    3:*/		return 0x82100E24;
		  /* 82100E24h */ case    4:  		/* bc 12, CR6_LT, -80 */
		/* 82100E24h case    4:*/		if ( regs.CR[6].lt ) { return 0x82100DD4;  }
		/* 82100E24h case    4:*/		return 0x82100E28;
	}
	return 0x82100E28;
} // Block from 82100E14h-82100E28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82100E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100E28);
		  /* 82100E28h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82100E28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82100E28h case    0:*/		return 0x82100E2C;
		  /* 82100E2Ch */ case    1:  		/* mr R7, R8 */
		/* 82100E2Ch case    1:*/		regs.R7 = regs.R8;
		/* 82100E2Ch case    1:*/		return 0x82100E30;
		  /* 82100E30h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82100E30h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82100E30h case    2:*/		return 0x82100E34;
		  /* 82100E34h */ case    3:  		/* bc 4, CR6_GT, 96 */
		/* 82100E34h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82100E94;  }
		/* 82100E34h case    3:*/		return 0x82100E38;
		  /* 82100E38h */ case    4:  		/* lwz R11, <#[R3 + 20]> */
		/* 82100E38h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82100E38h case    4:*/		return 0x82100E3C;
		  /* 82100E3Ch */ case    5:  		/* lwz R10, <#[R3 + 16]> */
		/* 82100E3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82100E3Ch case    5:*/		return 0x82100E40;
		  /* 82100E40h */ case    6:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82100E40h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82100E40h case    6:*/		return 0x82100E44;
		  /* 82100E44h */ case    7:  		/* lwz R9, <#[R11 + 4]> */
		/* 82100E44h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82100E44h case    7:*/		return 0x82100E48;
		  /* 82100E48h */ case    8:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82100E48h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82100E48h case    8:*/		return 0x82100E4C;
		  /* 82100E4Ch */ case    9:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82100E4Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82100E4Ch case    9:*/		return 0x82100E50;
		  /* 82100E50h */ case   10:  		/* lwz R9, <#[R10 + 4]> */
		/* 82100E50h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82100E50h case   10:*/		return 0x82100E54;
		  /* 82100E54h */ case   11:  		/* and R29, R9, R5 */
		/* 82100E54h case   11:*/		cpu::op::and<0>(regs,&regs.R29,regs.R9,regs.R5);
		/* 82100E54h case   11:*/		return 0x82100E58;
		  /* 82100E58h */ case   12:  		/* cmplw CR6, R29, R5 */
		/* 82100E58h case   12:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R5);
		/* 82100E58h case   12:*/		return 0x82100E5C;
		  /* 82100E5Ch */ case   13:  		/* bc 4, CR6_EQ, 36 */
		/* 82100E5Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x82100E80;  }
		/* 82100E5Ch case   13:*/		return 0x82100E60;
		  /* 82100E60h */ case   14:  		/* and. R9, R9, R6 */
		/* 82100E60h case   14:*/		cpu::op::and<1>(regs,&regs.R9,regs.R9,regs.R6);
		/* 82100E60h case   14:*/		return 0x82100E64;
		  /* 82100E64h */ case   15:  		/* bc 4, CR0_EQ, 28 */
		/* 82100E64h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82100E80;  }
		/* 82100E64h case   15:*/		return 0x82100E68;
		  /* 82100E68h */ case   16:  		/* lwz R29, <#[R10 + 24]> */
		/* 82100E68h case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000018) );
		/* 82100E68h case   16:*/		return 0x82100E6C;
		  /* 82100E6Ch */ case   17:  		/* lwz R9, <#[R11 + 12]> */
		/* 82100E6Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82100E6Ch case   17:*/		return 0x82100E70;
		  /* 82100E70h */ case   18:  		/* stw R29, <#[R11 + 4]> */
		/* 82100E70h case   18:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 82100E70h case   18:*/		return 0x82100E74;
		  /* 82100E74h */ case   19:  		/* lwz R10, <#[R10 + 16]> */
		/* 82100E74h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 82100E74h case   19:*/		return 0x82100E78;
		  /* 82100E78h */ case   20:  		/* add R10, R10, R9 */
		/* 82100E78h case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82100E78h case   20:*/		return 0x82100E7C;
		  /* 82100E7Ch */ case   21:  		/* stw R10, <#[R11 + 12]> */
		/* 82100E7Ch case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82100E7Ch case   21:*/		return 0x82100E80;
	}
	return 0x82100E80;
} // Block from 82100E28h-82100E80h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82100E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100E80);
		  /* 82100E80h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82100E80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82100E80h case    0:*/		return 0x82100E84;
		  /* 82100E84h */ case    1:  		/* addi R7, R7, 1 */
		/* 82100E84h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82100E84h case    1:*/		return 0x82100E88;
		  /* 82100E88h */ case    2:  		/* addi R8, R8, 4 */
		/* 82100E88h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82100E88h case    2:*/		return 0x82100E8C;
		  /* 82100E8Ch */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 82100E8Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82100E8Ch case    3:*/		return 0x82100E90;
		  /* 82100E90h */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 82100E90h case    4:*/		if ( regs.CR[6].lt ) { return 0x82100E38;  }
		/* 82100E90h case    4:*/		return 0x82100E94;
	}
	return 0x82100E94;
} // Block from 82100E80h-82100E94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82100E94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100E94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100E94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100E94);
		  /* 82100E94h */ case    0:  		/* lwz R10, <#[R3 + 16]> */
		/* 82100E94h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82100E94h case    0:*/		return 0x82100E98;
		  /* 82100E98h */ case    1:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82100E98h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82100E98h case    1:*/		return 0x82100E9C;
		  /* 82100E9Ch */ case    2:  		/* cmpwi CR6, R30, 0 */
		/* 82100E9Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82100E9Ch case    2:*/		return 0x82100EA0;
	}
	return 0x82100EA0;
} // Block from 82100E94h-82100EA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82100EA0h
// Function '?CompactLiterals_Remap@CProgram@D3DXShader@@AAAJPAI0I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100EA0);
		  /* 82100EA0h */ case    0:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82100EA0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82100EA0h case    0:*/		return 0x82100EA4;
		  /* 82100EA4h */ case    1:  		/* stw R31, <#[R10 + 8]> */
		/* 82100EA4h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + 0x00000008) );
		/* 82100EA4h case    1:*/		return 0x82100EA8;
		  /* 82100EA8h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82100EA8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82100EC0;  }
		/* 82100EA8h case    2:*/		return 0x82100EAC;
		  /* 82100EACh */ case    3:  		/* lwz R10, <#[R3 + 16]> */
		/* 82100EACh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82100EACh case    3:*/		return 0x82100EB0;
		  /* 82100EB0h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82100EB0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82100EB0h case    4:*/		return 0x82100EB4;
		  /* 82100EB4h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 82100EB4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82100EB4h case    5:*/		return 0x82100EB8;
		  /* 82100EB8h */ case    6:  		/* ori R10, R10, 1024 */
		/* 82100EB8h case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x400);
		/* 82100EB8h case    6:*/		return 0x82100EBC;
		  /* 82100EBCh */ case    7:  		/* stw R10, <#[R11 + 4]> */
		/* 82100EBCh case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82100EBCh case    7:*/		return 0x82100EC0;
	}
	return 0x82100EC0;
} // Block from 82100EA0h-82100EC0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82100EC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100EC0);
		  /* 82100EC0h */ case    0:  		/* li R3, 0 */
		/* 82100EC0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82100EC0h case    0:*/		return 0x82100EC4;
		  /* 82100EC4h */ case    1:  		/* b -457752 */
		/* 82100EC4h case    1:*/		return 0x820912AC;
		/* 82100EC4h case    1:*/		return 0x82100EC8;
		  /* 82100EC8h */ case    2:  		/* li R11, 0 */
		/* 82100EC8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82100EC8h case    2:*/		return 0x82100ECC;
		  /* 82100ECCh */ case    3:  		/* li R9, 0 */
		/* 82100ECCh case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82100ECCh case    3:*/		return 0x82100ED0;
		  /* 82100ED0h */ case    4:  		/* mr R10, R4 */
		/* 82100ED0h case    4:*/		regs.R10 = regs.R4;
		/* 82100ED0h case    4:*/		return 0x82100ED4;
		  /* 82100ED4h */ case    5:  		/* cmpwi CR6, R4, -1 */
		/* 82100ED4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 82100ED4h case    5:*/		return 0x82100ED8;
		  /* 82100ED8h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 82100ED8h case    6:*/		if ( regs.CR[6].eq ) { return 0x82100EF8;  }
		/* 82100ED8h case    6:*/		return 0x82100EDC;
		  /* 82100EDCh */ case    7:  		/* lwz R8, <#[R3 + 20]> */
		/* 82100EDCh case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 82100EDCh case    7:*/		return 0x82100EE0;
		  /* 82100EE0h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82100EE0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82100EE0h case    8:*/		return 0x82100EE4;
		  /* 82100EE4h */ case    9:  		/* addi R11, R11, 1 */
		/* 82100EE4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82100EE4h case    9:*/		return 0x82100EE8;
		  /* 82100EE8h */ case   10:  		/* lwzx R10, <#[R10 + R8]> */
		/* 82100EE8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82100EE8h case   10:*/		return 0x82100EEC;
		  /* 82100EECh */ case   11:  		/* lwz R10, <#[R10 + 20]> */
		/* 82100EECh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 82100EECh case   11:*/		return 0x82100EF0;
		  /* 82100EF0h */ case   12:  		/* cmpwi CR6, R10, -1 */
		/* 82100EF0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82100EF0h case   12:*/		return 0x82100EF4;
		  /* 82100EF4h */ case   13:  		/* bc 4, CR6_EQ, -20 */
		/* 82100EF4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82100EE0;  }
		/* 82100EF4h case   13:*/		return 0x82100EF8;
	}
	return 0x82100EF8;
} // Block from 82100EC0h-82100EF8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82100EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100EF8);
		  /* 82100EF8h */ case    0:  		/* mr R10, R6 */
		/* 82100EF8h case    0:*/		regs.R10 = regs.R6;
		/* 82100EF8h case    0:*/		return 0x82100EFC;
		  /* 82100EFCh */ case    1:  		/* cmpwi CR6, R6, -1 */
		/* 82100EFCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 82100EFCh case    1:*/		return 0x82100F00;
		  /* 82100F00h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 82100F00h case    2:*/		if ( regs.CR[6].eq ) { return 0x82100F20;  }
		/* 82100F00h case    2:*/		return 0x82100F04;
		  /* 82100F04h */ case    3:  		/* lwz R8, <#[R3 + 20]> */
		/* 82100F04h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 82100F04h case    3:*/		return 0x82100F08;
		  /* 82100F08h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82100F08h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82100F08h case    4:*/		return 0x82100F0C;
		  /* 82100F0Ch */ case    5:  		/* addi R9, R9, 1 */
		/* 82100F0Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82100F0Ch case    5:*/		return 0x82100F10;
		  /* 82100F10h */ case    6:  		/* lwzx R10, <#[R10 + R8]> */
		/* 82100F10h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82100F10h case    6:*/		return 0x82100F14;
		  /* 82100F14h */ case    7:  		/* lwz R10, <#[R10 + 20]> */
		/* 82100F14h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 82100F14h case    7:*/		return 0x82100F18;
		  /* 82100F18h */ case    8:  		/* cmpwi CR6, R10, -1 */
		/* 82100F18h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82100F18h case    8:*/		return 0x82100F1C;
		  /* 82100F1Ch */ case    9:  		/* bc 4, CR6_EQ, -20 */
		/* 82100F1Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82100F08;  }
		/* 82100F1Ch case    9:*/		return 0x82100F20;
	}
	return 0x82100F20;
} // Block from 82100EF8h-82100F20h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82100F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100F20);
		  /* 82100F20h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82100F20h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82100F20h case    0:*/		return 0x82100F24;
		  /* 82100F24h */ case    1:  		/* bc 4, CR6_LT, 44 */
		/* 82100F24h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82100F50;  }
		/* 82100F24h case    1:*/		return 0x82100F28;
		  /* 82100F28h */ case    2:  		/* subf R8, R9, R11 */
		/* 82100F28h case    2:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R9,regs.R11);
		/* 82100F28h case    2:*/		return 0x82100F2C;
		  /* 82100F2Ch */ case    3:  		/* lwz R10, <#[R3 + 20]> */
		/* 82100F2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82100F2Ch case    3:*/		return 0x82100F30;
		  /* 82100F30h */ case    4:  		/* mtspr CTR, R8 */
		/* 82100F30h case    4:*/		regs.CTR = regs.R8;
		/* 82100F30h case    4:*/		return 0x82100F34;
		  /* 82100F34h */ case    5:  		/* rlwinm R8, R4, 2, 0, 29 */
		/* 82100F34h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R4);
		/* 82100F34h case    5:*/		return 0x82100F38;
		  /* 82100F38h */ case    6:  		/* addi R11, R11, -1 */
		/* 82100F38h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82100F38h case    6:*/		return 0x82100F3C;
		  /* 82100F3Ch */ case    7:  		/* lwzx R8, <#[R8 + R10]> */
		/* 82100F3Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82100F3Ch case    7:*/		return 0x82100F40;
		  /* 82100F40h */ case    8:  		/* lwz R5, <#[R8 + 24]> */
		/* 82100F40h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000018) );
		/* 82100F40h case    8:*/		return 0x82100F44;
		  /* 82100F44h */ case    9:  		/* lwz R4, <#[R8 + 20]> */
		/* 82100F44h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + 0x00000014) );
		/* 82100F44h case    9:*/		return 0x82100F48;
		  /* 82100F48h */ case   10:  		/* bc 16, CR0_LT, -20 */
		/* 82100F48h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82100F34;  }
		/* 82100F48h case   10:*/		return 0x82100F4C;
		  /* 82100F4Ch */ case   11:  		/* cmplw CR6, R9, R11 */
		/* 82100F4Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82100F4Ch case   11:*/		return 0x82100F50;
	}
	return 0x82100F50;
} // Block from 82100F20h-82100F50h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82100F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100F50);
		  /* 82100F50h */ case    0:  		/* bc 4, CR6_GT, 36 */
		/* 82100F50h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82100F74;  }
		/* 82100F50h case    0:*/		return 0x82100F54;
		  /* 82100F54h */ case    1:  		/* subf R10, R11, R9 */
		/* 82100F54h case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 82100F54h case    1:*/		return 0x82100F58;
		  /* 82100F58h */ case    2:  		/* lwz R11, <#[R3 + 20]> */
		/* 82100F58h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82100F58h case    2:*/		return 0x82100F5C;
		  /* 82100F5Ch */ case    3:  		/* mtspr CTR, R10 */
		/* 82100F5Ch case    3:*/		regs.CTR = regs.R10;
		/* 82100F5Ch case    3:*/		return 0x82100F60;
		  /* 82100F60h */ case    4:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 82100F60h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 82100F60h case    4:*/		return 0x82100F64;
		  /* 82100F64h */ case    5:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82100F64h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82100F64h case    5:*/		return 0x82100F68;
		  /* 82100F68h */ case    6:  		/* lwz R7, <#[R10 + 24]> */
		/* 82100F68h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000018) );
		/* 82100F68h case    6:*/		return 0x82100F6C;
		  /* 82100F6Ch */ case    7:  		/* lwz R6, <#[R10 + 20]> */
		/* 82100F6Ch case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000014) );
		/* 82100F6Ch case    7:*/		return 0x82100F70;
		  /* 82100F70h */ case    8:  		/* bc 16, CR0_LT, -16 */
		/* 82100F70h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82100F60;  }
		/* 82100F70h case    8:*/		return 0x82100F74;
	}
	return 0x82100F74;
} // Block from 82100F50h-82100F74h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82100F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100F74);
		  /* 82100F74h */ case    0:  		/* cmplw CR6, R4, R6 */
		/* 82100F74h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R6);
		/* 82100F74h case    0:*/		return 0x82100F78;
		  /* 82100F78h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 82100F78h case    1:*/		if ( regs.CR[6].eq ) { return 0x82100FA8;  }
		/* 82100F78h case    1:*/		return 0x82100F7C;
		  /* 82100F7Ch */ case    2:  		/* lwz R11, <#[R3 + 20]> */
		/* 82100F7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82100F7Ch case    2:*/		return 0x82100F80;
		  /* 82100F80h */ case    3:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 82100F80h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 82100F80h case    3:*/		return 0x82100F84;
		  /* 82100F84h */ case    4:  		/* rlwinm R9, R6, 2, 0, 29 */
		/* 82100F84h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R6);
		/* 82100F84h case    4:*/		return 0x82100F88;
		  /* 82100F88h */ case    5:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82100F88h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82100F88h case    5:*/		return 0x82100F8C;
		  /* 82100F8Ch */ case    6:  		/* lwzx R9, <#[R9 + R11]> */
		/* 82100F8Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82100F8Ch case    6:*/		return 0x82100F90;
		  /* 82100F90h */ case    7:  		/* lwz R4, <#[R10 + 20]> */
		/* 82100F90h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000014) );
		/* 82100F90h case    7:*/		return 0x82100F94;
		  /* 82100F94h */ case    8:  		/* lwz R6, <#[R9 + 20]> */
		/* 82100F94h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000014) );
		/* 82100F94h case    8:*/		return 0x82100F98;
		  /* 82100F98h */ case    9:  		/* lwz R5, <#[R10 + 24]> */
		/* 82100F98h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000018) );
		/* 82100F98h case    9:*/		return 0x82100F9C;
		  /* 82100F9Ch */ case   10:  		/* lwz R7, <#[R9 + 24]> */
		/* 82100F9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000018) );
		/* 82100F9Ch case   10:*/		return 0x82100FA0;
		  /* 82100FA0h */ case   11:  		/* cmplw CR6, R4, R6 */
		/* 82100FA0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R6);
		/* 82100FA0h case   11:*/		return 0x82100FA4;
		  /* 82100FA4h */ case   12:  		/* bc 4, CR6_EQ, -36 */
		/* 82100FA4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82100F80;  }
		/* 82100FA4h case   12:*/		return 0x82100FA8;
	}
	return 0x82100FA8;
} // Block from 82100F74h-82100FA8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82100FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100FA8);
		  /* 82100FA8h */ case    0:  		/* subf R11, R5, R7 */
		/* 82100FA8h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R5,regs.R7);
		/* 82100FA8h case    0:*/		return 0x82100FAC;
		  /* 82100FACh */ case    1:  		/* addic R10, R11, -1 */
		/* 82100FACh case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82100FACh case    1:*/		return 0x82100FB0;
		  /* 82100FB0h */ case    2:  		/* subfe R3, R10, R11 */
		/* 82100FB0h case    2:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82100FB0h case    2:*/		return 0x82100FB4;
		  /* 82100FB4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82100FB4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82100FB4h case    3:*/		return 0x82100FB8;
	}
	return 0x82100FB8;
} // Block from 82100FA8h-82100FB8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82100FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82100FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82100FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82100FB8);
		  /* 82100FB8h */ case    0:  		/* mfspr R12, LR */
		/* 82100FB8h case    0:*/		regs.R12 = regs.LR;
		/* 82100FB8h case    0:*/		return 0x82100FBC;
		  /* 82100FBCh */ case    1:  		/* bl -458120 */
		/* 82100FBCh case    1:*/		regs.LR = 0x82100FC0; return 0x82091234;
		/* 82100FBCh case    1:*/		return 0x82100FC0;
		  /* 82100FC0h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82100FC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82100FC0h case    2:*/		return 0x82100FC4;
		  /* 82100FC4h */ case    3:  		/* rlwinm R11, R6, 2, 0, 29 */
		/* 82100FC4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R6);
		/* 82100FC4h case    3:*/		return 0x82100FC8;
		  /* 82100FC8h */ case    4:  		/* lwz R10, <#[R4 + 28]> */
		/* 82100FC8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001C) );
		/* 82100FC8h case    4:*/		return 0x82100FCC;
		  /* 82100FCCh */ case    5:  		/* lwz R21, <#[R3 + 20]> */
		/* 82100FCCh case    5:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R3 + 0x00000014) );
		/* 82100FCCh case    5:*/		return 0x82100FD0;
		  /* 82100FD0h */ case    6:  		/* rlwinm R9, R5, 2, 0, 29 */
		/* 82100FD0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R5);
		/* 82100FD0h case    6:*/		return 0x82100FD4;
		  /* 82100FD4h */ case    7:  		/* add R11, R11, R7 */
		/* 82100FD4h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82100FD4h case    7:*/		return 0x82100FD8;
		  /* 82100FD8h */ case    8:  		/* mr R20, R3 */
		/* 82100FD8h case    8:*/		regs.R20 = regs.R3;
		/* 82100FD8h case    8:*/		return 0x82100FDC;
		  /* 82100FDCh */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82100FDCh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82100FDCh case    9:*/		return 0x82100FE0;
		  /* 82100FE0h */ case   10:  		/* mr R26, R4 */
		/* 82100FE0h case   10:*/		regs.R26 = regs.R4;
		/* 82100FE0h case   10:*/		return 0x82100FE4;
		  /* 82100FE4h */ case   11:  		/* lwzx R23, <#[R9 + R21]> */
		/* 82100FE4h case   11:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R9 + regs.R21 + 0x00000000) );
		/* 82100FE4h case   11:*/		return 0x82100FE8;
		  /* 82100FE8h */ case   12:  		/* lwzx R22, <#[R11 + R10]> */
		/* 82100FE8h case   12:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82100FE8h case   12:*/		return 0x82100FEC;
		  /* 82100FECh */ case   13:  		/* cmpwi CR6, R22, -1 */
		/* 82100FECh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R22,0xFFFFFFFF);
		/* 82100FECh case   13:*/		return 0x82100FF0;
		  /* 82100FF0h */ case   14:  		/* bc 12, CR6_EQ, 240 */
		/* 82100FF0h case   14:*/		if ( regs.CR[6].eq ) { return 0x821010E0;  }
		/* 82100FF0h case   14:*/		return 0x82100FF4;
		  /* 82100FF4h */ case   15:  		/* lwz R19, <#[R23 + 88]> */
		/* 82100FF4h case   15:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R23 + 0x00000058) );
		/* 82100FF4h case   15:*/		return 0x82100FF8;
		  /* 82100FF8h */ case   16:  		/* rlwinm R11, R22, 2, 0, 29 */
		/* 82100FF8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R22);
		/* 82100FF8h case   16:*/		return 0x82100FFC;
		  /* 82100FFCh */ case   17:  		/* lwzx R24, <#[R11 + R21]> */
		/* 82100FFCh case   17:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R11 + regs.R21 + 0x00000000) );
		/* 82100FFCh case   17:*/		return 0x82101000;
		  /* 82101000h */ case   18:  		/* lwz R10, <#[R24 + 72]> */
		/* 82101000h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000048) );
		/* 82101000h case   18:*/		return 0x82101004;
		  /* 82101004h */ case   19:  		/* cmplw CR6, R10, R19 */
		/* 82101004h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R19);
		/* 82101004h case   19:*/		return 0x82101008;
		  /* 82101008h */ case   20:  		/* bc 4, CR6_LT, 204 */
		/* 82101008h case   20:*/		if ( !regs.CR[6].lt ) { return 0x821010D4;  }
		/* 82101008h case   20:*/		return 0x8210100C;
		  /* 8210100Ch */ case   21:  		/* lwz R9, <#[R23 + 72]> */
		/* 8210100Ch case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000048) );
		/* 8210100Ch case   21:*/		return 0x82101010;
		  /* 82101010h */ case   22:  		/* lwz R11, <#[R24 + 88]> */
		/* 82101010h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000058) );
		/* 82101010h case   22:*/		return 0x82101014;
		  /* 82101014h */ case   23:  		/* cmplw CR6, R9, R11 */
		/* 82101014h case   23:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82101014h case   23:*/		return 0x82101018;
		  /* 82101018h */ case   24:  		/* bc 4, CR6_LT, 200 */
		/* 82101018h case   24:*/		if ( !regs.CR[6].lt ) { return 0x821010E0;  }
		/* 82101018h case   24:*/		return 0x8210101C;
		  /* 8210101Ch */ case   25:  		/* lwz R11, <#[R24 + 20]> */
		/* 8210101Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 8210101Ch case   25:*/		return 0x82101020;
		  /* 82101020h */ case   26:  		/* lwz R8, <#[R23 + 20]> */
		/* 82101020h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000014) );
		/* 82101020h case   26:*/		return 0x82101024;
		  /* 82101024h */ case   27:  		/* cmplw CR6, R8, R11 */
		/* 82101024h case   27:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82101024h case   27:*/		return 0x82101028;
		  /* 82101028h */ case   28:  		/* bc 4, CR6_EQ, 16 */
		/* 82101028h case   28:*/		if ( !regs.CR[6].eq ) { return 0x82101038;  }
		/* 82101028h case   28:*/		return 0x8210102C;
		  /* 8210102Ch */ case   29:  		/* lwz R8, <#[R23 + 24]> */
		/* 8210102Ch case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000018) );
		/* 8210102Ch case   29:*/		return 0x82101030;
		  /* 82101030h */ case   30:  		/* cmplw CR6, R8, R11 */
		/* 82101030h case   30:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82101030h case   30:*/		return 0x82101034;
		  /* 82101034h */ case   31:  		/* bc 12, CR6_EQ, 184 */
		/* 82101034h case   31:*/		if ( regs.CR[6].eq ) { return 0x821010EC;  }
		/* 82101034h case   31:*/		return 0x82101038;
	}
	return 0x82101038;
} // Block from 82100FB8h-82101038h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82101038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101038);
		  /* 82101038h */ case    0:  		/* cmplw CR6, R9, R10 */
		/* 82101038h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82101038h case    0:*/		return 0x8210103C;
		  /* 8210103Ch */ case    1:  		/* bc 4, CR6_LT, 16 */
		/* 8210103Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x8210104C;  }
		/* 8210103Ch case    1:*/		return 0x82101040;
		  /* 82101040h */ case    2:  		/* mr R11, R23 */
		/* 82101040h case    2:*/		regs.R11 = regs.R23;
		/* 82101040h case    2:*/		return 0x82101044;
		  /* 82101044h */ case    3:  		/* mr R28, R24 */
		/* 82101044h case    3:*/		regs.R28 = regs.R24;
		/* 82101044h case    3:*/		return 0x82101048;
		  /* 82101048h */ case    4:  		/* b 12 */
		/* 82101048h case    4:*/		return 0x82101054;
		/* 82101048h case    4:*/		return 0x8210104C;
	}
	return 0x8210104C;
} // Block from 82101038h-8210104Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210104Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210104C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210104C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210104C);
		  /* 8210104Ch */ case    0:  		/* mr R11, R24 */
		/* 8210104Ch case    0:*/		regs.R11 = regs.R24;
		/* 8210104Ch case    0:*/		return 0x82101050;
		  /* 82101050h */ case    1:  		/* mr R28, R23 */
		/* 82101050h case    1:*/		regs.R28 = regs.R23;
		/* 82101050h case    1:*/		return 0x82101054;
	}
	return 0x82101054;
} // Block from 8210104Ch-82101054h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82101054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101054);
		  /* 82101054h */ case    0:  		/* lwz R11, <#[R11 + 116]> */
		/* 82101054h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000074) );
		/* 82101054h case    0:*/		return 0x82101058;
	}
	return 0x82101058;
} // Block from 82101054h-82101058h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82101058h
// Function '?CompactLiterals@CProgram@D3DXShader@@AAAJPAI00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101058);
		  /* 82101058h */ case    0:  		/* li R25, 0 */
		/* 82101058h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82101058h case    0:*/		return 0x8210105C;
		  /* 8210105Ch */ case    1:  		/* lwz R10, <#[R26 + 80]> */
		/* 8210105Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000050) );
		/* 8210105Ch case    1:*/		return 0x82101060;
		  /* 82101060h */ case    2:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82101060h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82101060h case    2:*/		return 0x82101064;
		  /* 82101064h */ case    3:  		/* lwz R8, <#[R26 + 76]> */
		/* 82101064h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x0000004C) );
		/* 82101064h case    3:*/		return 0x82101068;
		  /* 82101068h */ case    4:  		/* lwz R11, <#[R26 + 84]> */
		/* 82101068h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000054) );
		/* 82101068h case    4:*/		return 0x8210106C;
		  /* 8210106Ch */ case    5:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210106Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210106Ch case    5:*/		return 0x82101070;
		  /* 82101070h */ case    6:  		/* lwzx R27, <#[R8 + R9]> */
		/* 82101070h case    6:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82101070h case    6:*/		return 0x82101074;
		  /* 82101074h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82101074h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82101074h case    7:*/		return 0x82101078;
		  /* 82101078h */ case    8:  		/* cmplwi CR6, R27, 0 */
		/* 82101078h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82101078h case    8:*/		return 0x8210107C;
		  /* 8210107Ch */ case    9:  		/* add R31, R10, R11 */
		/* 8210107Ch case    9:*/		cpu::op::add<0>(regs,&regs.R31,regs.R10,regs.R11);
		/* 8210107Ch case    9:*/		return 0x82101080;
		  /* 82101080h */ case   10:  		/* bc 12, CR6_EQ, 84 */
		/* 82101080h case   10:*/		if ( regs.CR[6].eq ) { return 0x821010D4;  }
		/* 82101080h case   10:*/		return 0x82101084;
		  /* 82101084h */ case   11:  		/* lwz R30, <#[R26 + 88]> */
		/* 82101084h case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000058) );
		/* 82101084h case   11:*/		return 0x82101088;
		  /* 82101088h */ case   12:  		/* lwz R29, <#[R28 + 72]> */
		/* 82101088h case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x00000048) );
		/* 82101088h case   12:*/		return 0x8210108C;
		  /* 8210108Ch */ case   13:  		/* lwz R11, <#[R31]> */
		/* 8210108Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8210108Ch case   13:*/		return 0x82101090;
		  /* 82101090h */ case   14:  		/* mulli R11, R11, 12 */
		/* 82101090h case   14:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82101090h case   14:*/		return 0x82101094;
		  /* 82101094h */ case   15:  		/* add R11, R11, R30 */
		/* 82101094h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82101094h case   15:*/		return 0x82101098;
		  /* 82101098h */ case   16:  		/* lwz R10, <#[R11]> */
		/* 82101098h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82101098h case   16:*/		return 0x8210109C;
		  /* 8210109Ch */ case   17:  		/* cmplw CR6, R10, R29 */
		/* 8210109Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 8210109Ch case   17:*/		return 0x821010A0;
		  /* 821010A0h */ case   18:  		/* bc 4, CR6_GT, 52 */
		/* 821010A0h case   18:*/		if ( !regs.CR[6].gt ) { return 0x821010D4;  }
		/* 821010A0h case   18:*/		return 0x821010A4;
		  /* 821010A4h */ case   19:  		/* mr R3, R20 */
		/* 821010A4h case   19:*/		regs.R3 = regs.R20;
		/* 821010A4h case   19:*/		return 0x821010A8;
		  /* 821010A8h */ case   20:  		/* lwz R7, <#[R11 + 8]> */
		/* 821010A8h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 821010A8h case   20:*/		return 0x821010AC;
		  /* 821010ACh */ case   21:  		/* lwz R6, <#[R11 + 4]> */
		/* 821010ACh case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821010ACh case   21:*/		return 0x821010B0;
		  /* 821010B0h */ case   22:  		/* lwz R5, <#[R28 + 24]> */
		/* 821010B0h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x00000018) );
		/* 821010B0h case   22:*/		return 0x821010B4;
		  /* 821010B4h */ case   23:  		/* lwz R4, <#[R28 + 20]> */
		/* 821010B4h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000014) );
		/* 821010B4h case   23:*/		return 0x821010B8;
		  /* 821010B8h */ case   24:  		/* bl -496 */
		/* 821010B8h case   24:*/		regs.LR = 0x821010BC; return 0x82100EC8;
		/* 821010B8h case   24:*/		return 0x821010BC;
		  /* 821010BCh */ case   25:  		/* cmpwi CR0, R3, 0 */
		/* 821010BCh case   25:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821010BCh case   25:*/		return 0x821010C0;
		  /* 821010C0h */ case   26:  		/* bc 12, CR0_EQ, 44 */
		/* 821010C0h case   26:*/		if ( regs.CR[0].eq ) { return 0x821010EC;  }
		/* 821010C0h case   26:*/		return 0x821010C4;
		  /* 821010C4h */ case   27:  		/* addi R25, R25, 1 */
		/* 821010C4h case   27:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 821010C4h case   27:*/		return 0x821010C8;
		  /* 821010C8h */ case   28:  		/* addi R31, R31, 4 */
		/* 821010C8h case   28:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821010C8h case   28:*/		return 0x821010CC;
		  /* 821010CCh */ case   29:  		/* cmplw CR6, R25, R27 */
		/* 821010CCh case   29:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R27);
		/* 821010CCh case   29:*/		return 0x821010D0;
		  /* 821010D0h */ case   30:  		/* bc 12, CR6_LT, -68 */
		/* 821010D0h case   30:*/		if ( regs.CR[6].lt ) { return 0x8210108C;  }
		/* 821010D0h case   30:*/		return 0x821010D4;
	}
	return 0x821010D4;
} // Block from 82101058h-821010D4h (31 instructions)

//////////////////////////////////////////////////////
// Block at 821010D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821010D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821010D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821010D4);
		  /* 821010D4h */ case    0:  		/* lwz R22, <#[R24 + 48]> */
		/* 821010D4h case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R24 + 0x00000030) );
		/* 821010D4h case    0:*/		return 0x821010D8;
		  /* 821010D8h */ case    1:  		/* cmpwi CR6, R22, -1 */
		/* 821010D8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R22,0xFFFFFFFF);
		/* 821010D8h case    1:*/		return 0x821010DC;
		  /* 821010DCh */ case    2:  		/* bc 4, CR6_EQ, -228 */
		/* 821010DCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x82100FF8;  }
		/* 821010DCh case    2:*/		return 0x821010E0;
	}
	return 0x821010E0;
} // Block from 821010D4h-821010E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821010E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821010E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821010E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821010E0);
		  /* 821010E0h */ case    0:  		/* li R3, -1 */
		/* 821010E0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 821010E0h case    0:*/		return 0x821010E4;
		  /* 821010E4h */ case    1:  		/* addi R1, R1, 192 */
		/* 821010E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821010E4h case    1:*/		return 0x821010E8;
		  /* 821010E8h */ case    2:  		/* b -458340 */
		/* 821010E8h case    2:*/		return 0x82091284;
		/* 821010E8h case    2:*/		return 0x821010EC;
	}
	return 0x821010EC;
} // Block from 821010E0h-821010ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821010ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821010EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821010EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821010EC);
		  /* 821010ECh */ case    0:  		/* mr R3, R22 */
		/* 821010ECh case    0:*/		regs.R3 = regs.R22;
		/* 821010ECh case    0:*/		return 0x821010F0;
		  /* 821010F0h */ case    1:  		/* b -12 */
		/* 821010F0h case    1:*/		return 0x821010E4;
		/* 821010F0h case    1:*/		return 0x821010F4;
		  /* 821010F4h */ case    2:  		/* nop */
		/* 821010F4h case    2:*/		cpu::op::nop();
		/* 821010F4h case    2:*/		return 0x821010F8;
	}
	return 0x821010F8;
} // Block from 821010ECh-821010F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821010F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821010F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821010F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821010F8);
		  /* 821010F8h */ case    0:  		/* mfspr R12, LR */
		/* 821010F8h case    0:*/		regs.R12 = regs.LR;
		/* 821010F8h case    0:*/		return 0x821010FC;
		  /* 821010FCh */ case    1:  		/* bl -458404 */
		/* 821010FCh case    1:*/		regs.LR = 0x82101100; return 0x82091258;
		/* 821010FCh case    1:*/		return 0x82101100;
		  /* 82101100h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82101100h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82101100h case    2:*/		return 0x82101104;
		  /* 82101104h */ case    3:  		/* mr R28, R3 */
		/* 82101104h case    3:*/		regs.R28 = regs.R3;
		/* 82101104h case    3:*/		return 0x82101108;
		  /* 82101108h */ case    4:  		/* mr R3, R4 */
		/* 82101108h case    4:*/		regs.R3 = regs.R4;
		/* 82101108h case    4:*/		return 0x8210110C;
		  /* 8210110Ch */ case    5:  		/* cmpwi CR6, R7, 0 */
		/* 8210110Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 8210110Ch case    5:*/		return 0x82101110;
		  /* 82101110h */ case    6:  		/* bc 12, CR6_EQ, 208 */
		/* 82101110h case    6:*/		if ( regs.CR[6].eq ) { return 0x821011E0;  }
		/* 82101110h case    6:*/		return 0x82101114;
		  /* 82101114h */ case    7:  		/* li R10, 0 */
		/* 82101114h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82101114h case    7:*/		return 0x82101118;
		  /* 82101118h */ case    8:  		/* cmplwi CR6, R6, 0 */
		/* 82101118h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82101118h case    8:*/		return 0x8210111C;
		  /* 8210111Ch */ case    9:  		/* bc 12, CR6_EQ, 264 */
		/* 8210111Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82101224;  }
		/* 8210111Ch case    9:*/		return 0x82101120;
		  /* 82101120h */ case   10:  		/* addi R11, R5, -4 */
		/* 82101120h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xFFFFFFFC);
		/* 82101120h case   10:*/		return 0x82101124;
		  /* 82101124h */ case   11:  		/* mtspr CTR, R6 */
		/* 82101124h case   11:*/		regs.CTR = regs.R6;
		/* 82101124h case   11:*/		return 0x82101128;
		  /* 82101128h */ case   12:  		/* stwu R10, <#[R11 + 4]> */
		/* 82101128h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82101128h case   12:*/		return 0x8210112C;
		  /* 8210112Ch */ case   13:  		/* addi R10, R10, 1 */
		/* 8210112Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210112Ch case   13:*/		return 0x82101130;
		  /* 82101130h */ case   14:  		/* bc 16, CR0_LT, -8 */
		/* 82101130h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82101128;  }
		/* 82101130h case   14:*/		return 0x82101134;
		  /* 82101134h */ case   15:  		/* cmplwi CR6, R6, 0 */
		/* 82101134h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82101134h case   15:*/		return 0x82101138;
		  /* 82101138h */ case   16:  		/* bc 12, CR6_EQ, 236 */
		/* 82101138h case   16:*/		if ( regs.CR[6].eq ) { return 0x82101224;  }
		/* 82101138h case   16:*/		return 0x8210113C;
		  /* 8210113Ch */ case   17:  		/* li R11, 1 */
		/* 8210113Ch case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8210113Ch case   17:*/		return 0x82101140;
		  /* 82101140h */ case   18:  		/* mr R10, R5 */
		/* 82101140h case   18:*/		regs.R10 = regs.R5;
		/* 82101140h case   18:*/		return 0x82101144;
		  /* 82101144h */ case   19:  		/* lwz R8, <#[R10]> */
		/* 82101144h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82101144h case   19:*/		return 0x82101148;
		  /* 82101148h */ case   20:  		/* addi R31, R11, -1 */
		/* 82101148h case   20:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFFF);
		/* 82101148h case   20:*/		return 0x8210114C;
		  /* 8210114Ch */ case   21:  		/* lwz R4, <#[R28 + 20]> */
		/* 8210114Ch case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000014) );
		/* 8210114Ch case   21:*/		return 0x82101150;
		  /* 82101150h */ case   22:  		/* mr R30, R11 */
		/* 82101150h case   22:*/		regs.R30 = regs.R11;
		/* 82101150h case   22:*/		return 0x82101154;
		  /* 82101154h */ case   23:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 82101154h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 82101154h case   23:*/		return 0x82101158;
		  /* 82101158h */ case   24:  		/* cmplw CR6, R11, R6 */
		/* 82101158h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 82101158h case   24:*/		return 0x8210115C;
		  /* 8210115Ch */ case   25:  		/* lwzx R9, <#[R9 + R3]> */
		/* 8210115Ch case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8210115Ch case   25:*/		return 0x82101160;
		  /* 82101160h */ case   26:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82101160h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82101160h case   26:*/		return 0x82101164;
		  /* 82101164h */ case   27:  		/* lwzx R9, <#[R9 + R4]> */
		/* 82101164h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R4 + 0x00000000) );
		/* 82101164h case   27:*/		return 0x82101168;
		  /* 82101168h */ case   28:  		/* lwz R7, <#[R9 + 16]> */
		/* 82101168h case   28:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000010) );
		/* 82101168h case   28:*/		return 0x8210116C;
		  /* 8210116Ch */ case   29:  		/* bc 4, CR6_LT, 80 */
		/* 8210116Ch case   29:*/		if ( !regs.CR[6].lt ) { return 0x821011BC;  }
		/* 8210116Ch case   29:*/		return 0x82101170;
		  /* 82101170h */ case   30:  		/* subf R9, R11, R6 */
		/* 82101170h case   30:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R6);
		/* 82101170h case   30:*/		return 0x82101174;
		  /* 82101174h */ case   31:  		/* addi R29, R10, 4 */
		/* 82101174h case   31:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0x4);
		/* 82101174h case   31:*/		return 0x82101178;
		  /* 82101178h */ case   32:  		/* mtspr CTR, R9 */
		/* 82101178h case   32:*/		regs.CTR = regs.R9;
		/* 82101178h case   32:*/		return 0x8210117C;
		  /* 8210117Ch */ case   33:  		/* lwz R9, <#[R29]> */
		/* 8210117Ch case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 8210117Ch case   33:*/		return 0x82101180;
		  /* 82101180h */ case   34:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82101180h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82101180h case   34:*/		return 0x82101184;
		  /* 82101184h */ case   35:  		/* lwzx R9, <#[R9 + R3]> */
		/* 82101184h case   35:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82101184h case   35:*/		return 0x82101188;
		  /* 82101188h */ case   36:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82101188h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82101188h case   36:*/		return 0x8210118C;
		  /* 8210118Ch */ case   37:  		/* lwzx R9, <#[R9 + R4]> */
		/* 8210118Ch case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R4 + 0x00000000) );
		/* 8210118Ch case   37:*/		return 0x82101190;
		  /* 82101190h */ case   38:  		/* lwz R9, <#[R9 + 16]> */
		/* 82101190h case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000010) );
		/* 82101190h case   38:*/		return 0x82101194;
		  /* 82101194h */ case   39:  		/* cmplw CR6, R9, R7 */
		/* 82101194h case   39:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82101194h case   39:*/		return 0x82101198;
		  /* 82101198h */ case   40:  		/* bc 12, CR6_LT, 16 */
		/* 82101198h case   40:*/		if ( regs.CR[6].lt ) { return 0x821011A8;  }
		/* 82101198h case   40:*/		return 0x8210119C;
		  /* 8210119Ch */ case   41:  		/* bc 4, CR6_EQ, 20 */
		/* 8210119Ch case   41:*/		if ( !regs.CR[6].eq ) { return 0x821011B0;  }
		/* 8210119Ch case   41:*/		return 0x821011A0;
		  /* 821011A0h */ case   42:  		/* cmplw CR6, R30, R31 */
		/* 821011A0h case   42:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R31);
		/* 821011A0h case   42:*/		return 0x821011A4;
		  /* 821011A4h */ case   43:  		/* bc 4, CR6_LT, 12 */
		/* 821011A4h case   43:*/		if ( !regs.CR[6].lt ) { return 0x821011B0;  }
		/* 821011A4h case   43:*/		return 0x821011A8;
	}
	return 0x821011A8;
} // Block from 821010F8h-821011A8h (44 instructions)

//////////////////////////////////////////////////////
// Block at 821011A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821011A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821011A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821011A8);
		  /* 821011A8h */ case    0:  		/* mr R31, R30 */
		/* 821011A8h case    0:*/		regs.R31 = regs.R30;
		/* 821011A8h case    0:*/		return 0x821011AC;
		  /* 821011ACh */ case    1:  		/* mr R7, R9 */
		/* 821011ACh case    1:*/		regs.R7 = regs.R9;
		/* 821011ACh case    1:*/		return 0x821011B0;
	}
	return 0x821011B0;
} // Block from 821011A8h-821011B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821011B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821011B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821011B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821011B0);
		  /* 821011B0h */ case    0:  		/* addi R30, R30, 1 */
		/* 821011B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 821011B0h case    0:*/		return 0x821011B4;
		  /* 821011B4h */ case    1:  		/* addi R29, R29, 4 */
		/* 821011B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 821011B4h case    1:*/		return 0x821011B8;
		  /* 821011B8h */ case    2:  		/* bc 16, CR0_LT, -60 */
		/* 821011B8h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210117C;  }
		/* 821011B8h case    2:*/		return 0x821011BC;
	}
	return 0x821011BC;
} // Block from 821011B0h-821011BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821011BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821011BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821011BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821011BC);
		  /* 821011BCh */ case    0:  		/* rlwinm R9, R31, 2, 0, 29 */
		/* 821011BCh case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R31);
		/* 821011BCh case    0:*/		return 0x821011C0;
		  /* 821011C0h */ case    1:  		/* addi R11, R11, 1 */
		/* 821011C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821011C0h case    1:*/		return 0x821011C4;
		  /* 821011C4h */ case    2:  		/* addi R7, R11, -1 */
		/* 821011C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFFF);
		/* 821011C4h case    2:*/		return 0x821011C8;
		  /* 821011C8h */ case    3:  		/* lwzx R4, <#[R9 + R5]> */
		/* 821011C8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 821011C8h case    3:*/		return 0x821011CC;
		  /* 821011CCh */ case    4:  		/* cmplw CR6, R7, R6 */
		/* 821011CCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 821011CCh case    4:*/		return 0x821011D0;
		  /* 821011D0h */ case    5:  		/* stw R4, <#[R10]> */
		/* 821011D0h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R10 + 0x00000000) );
		/* 821011D0h case    5:*/		return 0x821011D4;
		  /* 821011D4h */ case    6:  		/* addi R10, R10, 4 */
		/* 821011D4h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821011D4h case    6:*/		return 0x821011D8;
		  /* 821011D8h */ case    7:  		/* stwx R8, <#[R9 + R5]> */
		/* 821011D8h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 821011D8h case    7:*/		return 0x821011DC;
		  /* 821011DCh */ case    8:  		/* bc 12, CR6_LT, -152 */
		/* 821011DCh case    8:*/		if ( regs.CR[6].lt ) { return 0x82101144;  }
		/* 821011DCh case    8:*/		return 0x821011E0;
	}
	return 0x821011E0;
} // Block from 821011BCh-821011E0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821011E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821011E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821011E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821011E0);
		  /* 821011E0h */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 821011E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821011E0h case    0:*/		return 0x821011E4;
		  /* 821011E4h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 821011E4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82101224;  }
		/* 821011E4h case    1:*/		return 0x821011E8;
		  /* 821011E8h */ case    2:  		/* addi R10, R1, 80 */
		/* 821011E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 821011E8h case    2:*/		return 0x821011EC;
		  /* 821011ECh */ case    3:  		/* mtspr CTR, R6 */
		/* 821011ECh case    3:*/		regs.CTR = regs.R6;
		/* 821011ECh case    3:*/		return 0x821011F0;
		  /* 821011F0h */ case    4:  		/* addi R11, R1, 80 */
		/* 821011F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 821011F0h case    4:*/		return 0x821011F4;
		  /* 821011F4h */ case    5:  		/* subf R10, R10, R5 */
		/* 821011F4h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 821011F4h case    5:*/		return 0x821011F8;
		  /* 821011F8h */ case    6:  		/* lwzx R9, <#[R10 + R11]> */
		/* 821011F8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821011F8h case    6:*/		return 0x821011FC;
		  /* 821011FCh */ case    7:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821011FCh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821011FCh case    7:*/		return 0x82101200;
		  /* 82101200h */ case    8:  		/* lwzx R9, <#[R9 + R3]> */
		/* 82101200h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82101200h case    8:*/		return 0x82101204;
		  /* 82101204h */ case    9:  		/* stw R9, <#[R11]> */
		/* 82101204h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82101204h case    9:*/		return 0x82101208;
		  /* 82101208h */ case   10:  		/* addi R11, R11, 4 */
		/* 82101208h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82101208h case   10:*/		return 0x8210120C;
		  /* 8210120Ch */ case   11:  		/* bc 16, CR0_LT, -20 */
		/* 8210120Ch case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821011F8;  }
		/* 8210120Ch case   11:*/		return 0x82101210;
		  /* 82101210h */ case   12:  		/* cmplwi CR6, R6, 0 */
		/* 82101210h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82101210h case   12:*/		return 0x82101214;
		  /* 82101214h */ case   13:  		/* bc 12, CR6_EQ, 16 */
		/* 82101214h case   13:*/		if ( regs.CR[6].eq ) { return 0x82101224;  }
		/* 82101214h case   13:*/		return 0x82101218;
		  /* 82101218h */ case   14:  		/* addi R4, R1, 80 */
		/* 82101218h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82101218h case   14:*/		return 0x8210121C;
		  /* 8210121Ch */ case   15:  		/* rlwinm R5, R6, 2, 0, 29 */
		/* 8210121Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R6);
		/* 8210121Ch case   15:*/		return 0x82101220;
		  /* 82101220h */ case   16:  		/* bl -455656 */
		/* 82101220h case   16:*/		regs.LR = 0x82101224; return 0x82091E38;
		/* 82101220h case   16:*/		return 0x82101224;
	}
	return 0x82101224;
} // Block from 821011E0h-82101224h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82101224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101224);
		  /* 82101224h */ case    0:  		/* li R3, 0 */
		/* 82101224h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82101224h case    0:*/		return 0x82101228;
		  /* 82101228h */ case    1:  		/* addi R1, R1, 144 */
		/* 82101228h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82101228h case    1:*/		return 0x8210122C;
		  /* 8210122Ch */ case    2:  		/* b -458628 */
		/* 8210122Ch case    2:*/		return 0x820912A8;
		/* 8210122Ch case    2:*/		return 0x82101230;
		  /* 82101230h */ case    3:  		/* lwz R10, <#[R3 + 20]> */
		/* 82101230h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82101230h case    3:*/		return 0x82101234;
		  /* 82101234h */ case    4:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82101234h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82101234h case    4:*/		return 0x82101238;
		  /* 82101238h */ case    5:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82101238h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82101238h case    5:*/		return 0x8210123C;
		  /* 8210123Ch */ case    6:  		/* lwz R9, <#[R11 + 56]> */
		/* 8210123Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000038) );
		/* 8210123Ch case    6:*/		return 0x82101240;
		  /* 82101240h */ case    7:  		/* cmpwi CR6, R9, -1 */
		/* 82101240h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82101240h case    7:*/		return 0x82101244;
		  /* 82101244h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82101244h case    8:*/		if ( regs.CR[6].eq ) { return 0x82101250;  }
		/* 82101244h case    8:*/		return 0x82101248;
		  /* 82101248h */ case    9:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 82101248h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 82101248h case    9:*/		return 0x8210124C;
		  /* 8210124Ch */ case   10:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210124Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210124Ch case   10:*/		return 0x82101250;
	}
	return 0x82101250;
} // Block from 82101224h-82101250h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82101250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101250);
		  /* 82101250h */ case    0:  		/* lwz R10, <#[R11 + 4]> */
		/* 82101250h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82101250h case    0:*/		return 0x82101254;
		  /* 82101254h */ case    1:  		/* lwz R9, <#[R3 + 16]> */
		/* 82101254h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 82101254h case    1:*/		return 0x82101258;
		  /* 82101258h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82101258h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82101258h case    2:*/		return 0x8210125C;
		  /* 8210125Ch */ case    3:  		/* lwz R8, <#[R11 + 84]> */
		/* 8210125Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000054) );
		/* 8210125Ch case    3:*/		return 0x82101260;
		  /* 82101260h */ case    4:  		/* cmplw CR6, R8, R5 */
		/* 82101260h case    4:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R5);
		/* 82101260h case    4:*/		return 0x82101264;
		  /* 82101264h */ case    5:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82101264h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82101264h case    5:*/		return 0x82101268;
		  /* 82101268h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82101268h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82101270;  }
		/* 82101268h case    6:*/		return 0x8210126C;
		  /* 8210126Ch */ case    7:  		/* stw R5, <#[R11 + 84]> */
		/* 8210126Ch case    7:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000054) );
		/* 8210126Ch case    7:*/		return 0x82101270;
	}
	return 0x82101270;
} // Block from 82101250h-82101270h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82101270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101270);
		  /* 82101270h */ case    0:  		/* lwz R9, <#[R11 + 88]> */
		/* 82101270h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000058) );
		/* 82101270h case    0:*/		return 0x82101274;
		  /* 82101274h */ case    1:  		/* cmplw CR6, R9, R5 */
		/* 82101274h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 82101274h case    1:*/		return 0x82101278;
		  /* 82101278h */ case    2:  		/* bc 4, CR6_LT, 8 */
		/* 82101278h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82101280;  }
		/* 82101278h case    2:*/		return 0x8210127C;
		  /* 8210127Ch */ case    3:  		/* stw R5, <#[R11 + 88]> */
		/* 8210127Ch case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000058) );
		/* 8210127Ch case    3:*/		return 0x82101280;
	}
	return 0x82101280;
} // Block from 82101270h-82101280h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82101280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101280);
		  /* 82101280h */ case    0:  		/* lwz R9, <#[R11 + 92]> */
		/* 82101280h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000005C) );
		/* 82101280h case    0:*/		return 0x82101284;
		  /* 82101284h */ case    1:  		/* lwz R8, <#[R11 + 8]> */
		/* 82101284h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82101284h case    1:*/		return 0x82101288;
		  /* 82101288h */ case    2:  		/* addi R9, R9, 1 */
		/* 82101288h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82101288h case    2:*/		return 0x8210128C;
		  /* 8210128Ch */ case    3:  		/* cmpwi CR6, R8, -1 */
		/* 8210128Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 8210128Ch case    3:*/		return 0x82101290;
		  /* 82101290h */ case    4:  		/* stw R9, <#[R11 + 92]> */
		/* 82101290h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000005C) );
		/* 82101290h case    4:*/		return 0x82101294;
		  /* 82101294h */ case    5:  		/* bclr 12, CR6_EQ */
		/* 82101294h case    5:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82101294h case    5:*/		return 0x82101298;
	}
	return 0x82101298;
} // Block from 82101280h-82101298h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82101298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101298);
		  /* 82101298h */ case    0:  		/* lwz R9, <#[R10 + 40]> */
		/* 82101298h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000028) );
		/* 82101298h case    0:*/		return 0x8210129C;
		  /* 8210129Ch */ case    1:  		/* cmplw CR6, R9, R5 */
		/* 8210129Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 8210129Ch case    1:*/		return 0x821012A0;
		  /* 821012A0h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 821012A0h case    2:*/		if ( !regs.CR[6].gt ) { return 0x821012A8;  }
		/* 821012A0h case    2:*/		return 0x821012A4;
		  /* 821012A4h */ case    3:  		/* stw R5, <#[R10 + 40]> */
		/* 821012A4h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x00000028) );
		/* 821012A4h case    3:*/		return 0x821012A8;
	}
	return 0x821012A8;
} // Block from 82101298h-821012A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821012A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821012A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821012A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821012A8);
		  /* 821012A8h */ case    0:  		/* lwz R9, <#[R10 + 44]> */
		/* 821012A8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000002C) );
		/* 821012A8h case    0:*/		return 0x821012AC;
		  /* 821012ACh */ case    1:  		/* cmplw CR6, R9, R5 */
		/* 821012ACh case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 821012ACh case    1:*/		return 0x821012B0;
		  /* 821012B0h */ case    2:  		/* bc 4, CR6_LT, 8 */
		/* 821012B0h case    2:*/		if ( !regs.CR[6].lt ) { return 0x821012B8;  }
		/* 821012B0h case    2:*/		return 0x821012B4;
		  /* 821012B4h */ case    3:  		/* stw R5, <#[R10 + 44]> */
		/* 821012B4h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x0000002C) );
		/* 821012B4h case    3:*/		return 0x821012B8;
	}
	return 0x821012B8;
} // Block from 821012A8h-821012B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821012B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821012B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821012B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821012B8);
		  /* 821012B8h */ case    0:  		/* lwz R9, <#[R10 + 48]> */
		/* 821012B8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000030) );
		/* 821012B8h case    0:*/		return 0x821012BC;
		  /* 821012BCh */ case    1:  		/* addi R9, R9, 1 */
		/* 821012BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821012BCh case    1:*/		return 0x821012C0;
		  /* 821012C0h */ case    2:  		/* stw R9, <#[R10 + 48]> */
		/* 821012C0h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000030) );
		/* 821012C0h case    2:*/		return 0x821012C4;
		  /* 821012C4h */ case    3:  		/* lwz R4, <#[R11 + 8]> */
		/* 821012C4h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000008) );
		/* 821012C4h case    3:*/		return 0x821012C8;
		  /* 821012C8h */ case    4:  		/* b -152 */
		/* 821012C8h case    4:*/		return 0x82101230;
		/* 821012C8h case    4:*/		return 0x821012CC;
		  /* 821012CCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 821012CCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821012CCh case    5:*/		return 0x821012D0;
	}
	return 0x821012D0;
} // Block from 821012B8h-821012D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821012D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821012D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821012D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821012D0);
		  /* 821012D0h */ case    0:  		/* lwz R11, <#[R3 + 20]> */
		/* 821012D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 821012D0h case    0:*/		return 0x821012D4;
		  /* 821012D4h */ case    1:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 821012D4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 821012D4h case    1:*/		return 0x821012D8;
		  /* 821012D8h */ case    2:  		/* lwz R9, <#[R3 + 16]> */
		/* 821012D8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 821012D8h case    2:*/		return 0x821012DC;
		  /* 821012DCh */ case    3:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821012DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821012DCh case    3:*/		return 0x821012E0;
		  /* 821012E0h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 821012E0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821012E0h case    4:*/		return 0x821012E4;
		  /* 821012E4h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821012E4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821012E4h case    5:*/		return 0x821012E8;
		  /* 821012E8h */ case    6:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821012E8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821012E8h case    6:*/		return 0x821012EC;
		  /* 821012ECh */ case    7:  		/* stw R5, <#[R11 + 72]> */
		/* 821012ECh case    7:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000048) );
		/* 821012ECh case    7:*/		return 0x821012F0;
		  /* 821012F0h */ case    8:  		/* lwz R10, <#[R10 + 32]> */
		/* 821012F0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000020) );
		/* 821012F0h case    8:*/		return 0x821012F4;
		  /* 821012F4h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 821012F4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821012F4h case    9:*/		return 0x821012F8;
		  /* 821012F8h */ case   10:  		/* bc 12, CR6_EQ, 64 */
		/* 821012F8h case   10:*/		if ( regs.CR[6].eq ) { return 0x82101338;  }
		/* 821012F8h case   10:*/		return 0x821012FC;
		  /* 821012FCh */ case   11:  		/* lwz R9, <#[R11 + 12]> */
		/* 821012FCh case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821012FCh case   11:*/		return 0x82101300;
		  /* 82101300h */ case   12:  		/* lwz R8, <#[R11 + 16]> */
		/* 82101300h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 82101300h case   12:*/		return 0x82101304;
		  /* 82101304h */ case   13:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82101304h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82101304h case   13:*/		return 0x82101308;
		  /* 82101308h */ case   14:  		/* add R9, R9, R8 */
		/* 82101308h case   14:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82101308h case   14:*/		return 0x8210130C;
		  /* 8210130Ch */ case   15:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210130Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210130Ch case   15:*/		return 0x82101310;
		  /* 82101310h */ case   16:  		/* lwzx R8, <#[R9 + R10]> */
		/* 82101310h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82101310h case   16:*/		return 0x82101314;
		  /* 82101314h */ case   17:  		/* cmpwi CR6, R8, -1 */
		/* 82101314h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 82101314h case   17:*/		return 0x82101318;
		  /* 82101318h */ case   18:  		/* bc 12, CR6_EQ, 28 */
		/* 82101318h case   18:*/		if ( regs.CR[6].eq ) { return 0x82101334;  }
		/* 82101318h case   18:*/		return 0x8210131C;
		  /* 8210131Ch */ case   19:  		/* stw R8, <#[R11 + 76]> */
		/* 8210131Ch case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000004C) );
		/* 8210131Ch case   19:*/		return 0x82101320;
		  /* 82101320h */ case   20:  		/* lwz R8, <#[R3 + 20]> */
		/* 82101320h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 82101320h case   20:*/		return 0x82101324;
		  /* 82101324h */ case   21:  		/* lwzx R7, <#[R9 + R10]> */
		/* 82101324h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82101324h case   21:*/		return 0x82101328;
		  /* 82101328h */ case   22:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82101328h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82101328h case   22:*/		return 0x8210132C;
		  /* 8210132Ch */ case   23:  		/* lwzx R8, <#[R7 + R8]> */
		/* 8210132Ch case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8210132Ch case   23:*/		return 0x82101330;
		  /* 82101330h */ case   24:  		/* stw R4, <#[R8 + 80]> */
		/* 82101330h case   24:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R8 + 0x00000050) );
		/* 82101330h case   24:*/		return 0x82101334;
	}
	return 0x82101334;
} // Block from 821012D0h-82101334h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82101334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101334);
		  /* 82101334h */ case    0:  		/* stwx R4, <#[R9 + R10]> */
		/* 82101334h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82101334h case    0:*/		return 0x82101338;
	}
	return 0x82101338;
} // Block from 82101334h-82101338h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82101338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101338);
		  /* 82101338h */ case    0:  		/* lwz R4, <#[R11 + 20]> */
		/* 82101338h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000014) );
		/* 82101338h case    0:*/		return 0x8210133C;
		  /* 8210133Ch */ case    1:  		/* cmpwi CR6, R4, -1 */
		/* 8210133Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 8210133Ch case    1:*/		return 0x82101340;
		  /* 82101340h */ case    2:  		/* bclr 12, CR6_EQ */
		/* 82101340h case    2:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82101340h case    2:*/		return 0x82101344;
	}
	return 0x82101344;
} // Block from 82101338h-82101344h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82101344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101344);
		  /* 82101344h */ case    0:  		/* b -276 */
		/* 82101344h case    0:*/		return 0x82101230;
		/* 82101344h case    0:*/		return 0x82101348;
		  /* 82101348h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82101348h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82101348h case    1:*/		return 0x8210134C;
	}
	return 0x8210134C;
} // Block from 82101344h-8210134Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210134Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210134C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210134C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210134C);
		  /* 8210134Ch */ case    0:  		/* nop */
		/* 8210134Ch case    0:*/		cpu::op::nop();
		/* 8210134Ch case    0:*/		return 0x82101350;
		  /* 82101350h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 82101350h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82101350h case    1:*/		return 0x82101354;
		  /* 82101354h */ case    2:  		/* li R8, 0 */
		/* 82101354h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82101354h case    2:*/		return 0x82101358;
		  /* 82101358h */ case    3:  		/* li R6, 0 */
		/* 82101358h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82101358h case    3:*/		return 0x8210135C;
		  /* 8210135Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8210135Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210135Ch case    4:*/		return 0x82101360;
		  /* 82101360h */ case    5:  		/* bc 4, CR6_GT, 300 */
		/* 82101360h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8210148C;  }
		/* 82101360h case    5:*/		return 0x82101364;
		  /* 82101364h */ case    6:  		/* li R7, 0 */
		/* 82101364h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82101364h case    6:*/		return 0x82101368;
		  /* 82101368h */ case    7:  		/* lwz R11, <#[R3 + 20]> */
		/* 82101368h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82101368h case    7:*/		return 0x8210136C;
		  /* 8210136Ch */ case    8:  		/* lwzx R10, <#[R7 + R11]> */
		/* 8210136Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8210136Ch case    8:*/		return 0x82101370;
		  /* 82101370h */ case    9:  		/* lwz R9, <#[R10 + 56]> */
		/* 82101370h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000038) );
		/* 82101370h case    9:*/		return 0x82101374;
		  /* 82101374h */ case   10:  		/* cmpwi CR6, R9, -1 */
		/* 82101374h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82101374h case   10:*/		return 0x82101378;
		  /* 82101378h */ case   11:  		/* bc 12, CR6_EQ, 176 */
		/* 82101378h case   11:*/		if ( regs.CR[6].eq ) { return 0x82101428;  }
		/* 82101378h case   11:*/		return 0x8210137C;
		  /* 8210137Ch */ case   12:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210137Ch case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210137Ch case   12:*/		return 0x82101380;
		  /* 82101380h */ case   13:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82101380h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82101380h case   13:*/		return 0x82101384;
		  /* 82101384h */ case   14:  		/* lwz R9, <#[R11 + 4]> */
		/* 82101384h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82101384h case   14:*/		return 0x82101388;
		  /* 82101388h */ case   15:  		/* stw R9, <#[R10 + 4]> */
		/* 82101388h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82101388h case   15:*/		return 0x8210138C;
		  /* 8210138Ch */ case   16:  		/* lwz R9, <#[R11 + 8]> */
		/* 8210138Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8210138Ch case   16:*/		return 0x82101390;
		  /* 82101390h */ case   17:  		/* stw R9, <#[R10 + 8]> */
		/* 82101390h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 82101390h case   17:*/		return 0x82101394;
		  /* 82101394h */ case   18:  		/* lwz R9, <#[R11 + 12]> */
		/* 82101394h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82101394h case   18:*/		return 0x82101398;
		  /* 82101398h */ case   19:  		/* stw R9, <#[R10 + 12]> */
		/* 82101398h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 82101398h case   19:*/		return 0x8210139C;
		  /* 8210139Ch */ case   20:  		/* lwz R9, <#[R11 + 16]> */
		/* 8210139Ch case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 8210139Ch case   20:*/		return 0x821013A0;
		  /* 821013A0h */ case   21:  		/* stw R9, <#[R10 + 16]> */
		/* 821013A0h case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 821013A0h case   21:*/		return 0x821013A4;
		  /* 821013A4h */ case   22:  		/* lwz R9, <#[R11 + 72]> */
		/* 821013A4h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000048) );
		/* 821013A4h case   22:*/		return 0x821013A8;
		  /* 821013A8h */ case   23:  		/* stw R9, <#[R10 + 72]> */
		/* 821013A8h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000048) );
		/* 821013A8h case   23:*/		return 0x821013AC;
		  /* 821013ACh */ case   24:  		/* lwz R9, <#[R11 + 76]> */
		/* 821013ACh case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000004C) );
		/* 821013ACh case   24:*/		return 0x821013B0;
		  /* 821013B0h */ case   25:  		/* stw R9, <#[R10 + 76]> */
		/* 821013B0h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000004C) );
		/* 821013B0h case   25:*/		return 0x821013B4;
		  /* 821013B4h */ case   26:  		/* lwz R9, <#[R11 + 80]> */
		/* 821013B4h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000050) );
		/* 821013B4h case   26:*/		return 0x821013B8;
		  /* 821013B8h */ case   27:  		/* stw R9, <#[R10 + 80]> */
		/* 821013B8h case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000050) );
		/* 821013B8h case   27:*/		return 0x821013BC;
		  /* 821013BCh */ case   28:  		/* lwz R9, <#[R11 + 84]> */
		/* 821013BCh case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000054) );
		/* 821013BCh case   28:*/		return 0x821013C0;
		  /* 821013C0h */ case   29:  		/* cmpwi CR6, R9, -1 */
		/* 821013C0h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 821013C0h case   29:*/		return 0x821013C4;
		  /* 821013C4h */ case   30:  		/* bc 4, CR6_EQ, 28 */
		/* 821013C4h case   30:*/		if ( !regs.CR[6].eq ) { return 0x821013E0;  }
		/* 821013C4h case   30:*/		return 0x821013C8;
		  /* 821013C8h */ case   31:  		/* lwz R9, <#[R10 + 84]> */
		/* 821013C8h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000054) );
		/* 821013C8h case   31:*/		return 0x821013CC;
		  /* 821013CCh */ case   32:  		/* stw R9, <#[R11 + 84]> */
		/* 821013CCh case   32:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000054) );
		/* 821013CCh case   32:*/		return 0x821013D0;
		  /* 821013D0h */ case   33:  		/* lwz R9, <#[R10 + 88]> */
		/* 821013D0h case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000058) );
		/* 821013D0h case   33:*/		return 0x821013D4;
		  /* 821013D4h */ case   34:  		/* stw R9, <#[R11 + 88]> */
		/* 821013D4h case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000058) );
		/* 821013D4h case   34:*/		return 0x821013D8;
		  /* 821013D8h */ case   35:  		/* lwz R10, <#[R10 + 92]> */
		/* 821013D8h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000005C) );
		/* 821013D8h case   35:*/		return 0x821013DC;
		  /* 821013DCh */ case   36:  		/* b 68 */
		/* 821013DCh case   36:*/		return 0x82101420;
		/* 821013DCh case   36:*/		return 0x821013E0;
	}
	return 0x821013E0;
} // Block from 8210134Ch-821013E0h (37 instructions)

//////////////////////////////////////////////////////
// Block at 821013E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821013E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821013E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821013E0);
		  /* 821013E0h */ case    0:  		/* lwz R8, <#[R10 + 84]> */
		/* 821013E0h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000054) );
		/* 821013E0h case    0:*/		return 0x821013E4;
		  /* 821013E4h */ case    1:  		/* cmplw CR6, R9, R8 */
		/* 821013E4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821013E4h case    1:*/		return 0x821013E8;
		  /* 821013E8h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 821013E8h case    2:*/		if ( regs.CR[6].lt ) { return 0x821013F0;  }
		/* 821013E8h case    2:*/		return 0x821013EC;
		  /* 821013ECh */ case    3:  		/* mr R9, R8 */
		/* 821013ECh case    3:*/		regs.R9 = regs.R8;
		/* 821013ECh case    3:*/		return 0x821013F0;
	}
	return 0x821013F0;
} // Block from 821013E0h-821013F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821013F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821013F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821013F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821013F0);
		  /* 821013F0h */ case    0:  		/* stw R9, <#[R10 + 84]> */
		/* 821013F0h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000054) );
		/* 821013F0h case    0:*/		return 0x821013F4;
		  /* 821013F4h */ case    1:  		/* stw R9, <#[R11 + 84]> */
		/* 821013F4h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000054) );
		/* 821013F4h case    1:*/		return 0x821013F8;
		  /* 821013F8h */ case    2:  		/* lwz R9, <#[R11 + 88]> */
		/* 821013F8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000058) );
		/* 821013F8h case    2:*/		return 0x821013FC;
		  /* 821013FCh */ case    3:  		/* lwz R8, <#[R10 + 88]> */
		/* 821013FCh case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000058) );
		/* 821013FCh case    3:*/		return 0x82101400;
		  /* 82101400h */ case    4:  		/* cmplw CR6, R9, R8 */
		/* 82101400h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82101400h case    4:*/		return 0x82101404;
		  /* 82101404h */ case    5:  		/* bc 12, CR6_GT, 8 */
		/* 82101404h case    5:*/		if ( regs.CR[6].gt ) { return 0x8210140C;  }
		/* 82101404h case    5:*/		return 0x82101408;
		  /* 82101408h */ case    6:  		/* mr R9, R8 */
		/* 82101408h case    6:*/		regs.R9 = regs.R8;
		/* 82101408h case    6:*/		return 0x8210140C;
	}
	return 0x8210140C;
} // Block from 821013F0h-8210140Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210140Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210140C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210140C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210140C);
		  /* 8210140Ch */ case    0:  		/* stw R9, <#[R10 + 88]> */
		/* 8210140Ch case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000058) );
		/* 8210140Ch case    0:*/		return 0x82101410;
		  /* 82101410h */ case    1:  		/* stw R9, <#[R11 + 88]> */
		/* 82101410h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000058) );
		/* 82101410h case    1:*/		return 0x82101414;
		  /* 82101414h */ case    2:  		/* lwz R9, <#[R11 + 92]> */
		/* 82101414h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000005C) );
		/* 82101414h case    2:*/		return 0x82101418;
		  /* 82101418h */ case    3:  		/* lwz R10, <#[R10 + 92]> */
		/* 82101418h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000005C) );
		/* 82101418h case    3:*/		return 0x8210141C;
		  /* 8210141Ch */ case    4:  		/* add R10, R10, R9 */
		/* 8210141Ch case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8210141Ch case    4:*/		return 0x82101420;
	}
	return 0x82101420;
} // Block from 8210140Ch-82101420h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82101420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101420);
		  /* 82101420h */ case    0:  		/* stw R10, <#[R11 + 92]> */
		/* 82101420h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000005C) );
		/* 82101420h case    0:*/		return 0x82101424;
		  /* 82101424h */ case    1:  		/* li R8, 1 */
		/* 82101424h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82101424h case    1:*/		return 0x82101428;
	}
	return 0x82101428;
} // Block from 82101420h-82101428h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82101428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101428);
		  /* 82101428h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82101428h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82101428h case    0:*/		return 0x8210142C;
		  /* 8210142Ch */ case    1:  		/* addi R6, R6, 1 */
		/* 8210142Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210142Ch case    1:*/		return 0x82101430;
		  /* 82101430h */ case    2:  		/* addi R7, R7, 4 */
		/* 82101430h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82101430h case    2:*/		return 0x82101434;
		  /* 82101434h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 82101434h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 82101434h case    3:*/		return 0x82101438;
		  /* 82101438h */ case    4:  		/* bc 12, CR6_LT, -208 */
		/* 82101438h case    4:*/		if ( regs.CR[6].lt ) { return 0x82101368;  }
		/* 82101438h case    4:*/		return 0x8210143C;
		  /* 8210143Ch */ case    5:  		/* cmpwi CR6, R8, 0 */
		/* 8210143Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 8210143Ch case    5:*/		return 0x82101440;
		  /* 82101440h */ case    6:  		/* bc 12, CR6_EQ, 76 */
		/* 82101440h case    6:*/		if ( regs.CR[6].eq ) { return 0x8210148C;  }
		/* 82101440h case    6:*/		return 0x82101444;
		  /* 82101444h */ case    7:  		/* li R7, 0 */
		/* 82101444h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82101444h case    7:*/		return 0x82101448;
		  /* 82101448h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82101448h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82101448h case    8:*/		return 0x8210144C;
		  /* 8210144Ch */ case    9:  		/* bc 12, CR6_EQ, 64 */
		/* 8210144Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x8210148C;  }
		/* 8210144Ch case    9:*/		return 0x82101450;
		  /* 82101450h */ case   10:  		/* li R8, 0 */
		/* 82101450h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82101450h case   10:*/		return 0x82101454;
		  /* 82101454h */ case   11:  		/* lwz R11, <#[R3 + 20]> */
		/* 82101454h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82101454h case   11:*/		return 0x82101458;
		  /* 82101458h */ case   12:  		/* lwzx R10, <#[R8 + R11]> */
		/* 82101458h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82101458h case   12:*/		return 0x8210145C;
		  /* 8210145Ch */ case   13:  		/* lwz R9, <#[R10 + 56]> */
		/* 8210145Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000038) );
		/* 8210145Ch case   13:*/		return 0x82101460;
		  /* 82101460h */ case   14:  		/* cmpwi CR6, R9, -1 */
		/* 82101460h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82101460h case   14:*/		return 0x82101464;
		  /* 82101464h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 82101464h case   15:*/		if ( regs.CR[6].eq ) { return 0x82101478;  }
		/* 82101464h case   15:*/		return 0x82101468;
		  /* 82101468h */ case   16:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82101468h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82101468h case   16:*/		return 0x8210146C;
		  /* 8210146Ch */ case   17:  		/* lwzx R11, <#[R9 + R11]> */
		/* 8210146Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210146Ch case   17:*/		return 0x82101470;
		  /* 82101470h */ case   18:  		/* lwz R11, <#[R11 + 84]> */
		/* 82101470h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 82101470h case   18:*/		return 0x82101474;
		  /* 82101474h */ case   19:  		/* stw R11, <#[R10 + 84]> */
		/* 82101474h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000054) );
		/* 82101474h case   19:*/		return 0x82101478;
	}
	return 0x82101478;
} // Block from 82101428h-82101478h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82101478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101478);
		  /* 82101478h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82101478h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82101478h case    0:*/		return 0x8210147C;
		  /* 8210147Ch */ case    1:  		/* addi R7, R7, 1 */
		/* 8210147Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210147Ch case    1:*/		return 0x82101480;
		  /* 82101480h */ case    2:  		/* addi R8, R8, 4 */
		/* 82101480h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82101480h case    2:*/		return 0x82101484;
		  /* 82101484h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 82101484h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82101484h case    3:*/		return 0x82101488;
		  /* 82101488h */ case    4:  		/* bc 12, CR6_LT, -52 */
		/* 82101488h case    4:*/		if ( regs.CR[6].lt ) { return 0x82101454;  }
		/* 82101488h case    4:*/		return 0x8210148C;
	}
	return 0x8210148C;
} // Block from 82101478h-8210148Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210148Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210148C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210148C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210148C);
		  /* 8210148Ch */ case    0:  		/* li R3, 0 */
		/* 8210148Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210148Ch case    0:*/		return 0x82101490;
		  /* 82101490h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82101490h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82101490h case    1:*/		return 0x82101494;
	}
	return 0x82101494;
} // Block from 8210148Ch-82101494h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82101494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101494);
		  /* 82101494h */ case    0:  		/* nop */
		/* 82101494h case    0:*/		cpu::op::nop();
		/* 82101494h case    0:*/		return 0x82101498;
	}
	return 0x82101498;
} // Block from 82101494h-82101498h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82101498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101498);
		  /* 82101498h */ case    0:  		/* mfspr R12, LR */
		/* 82101498h case    0:*/		regs.R12 = regs.LR;
		/* 82101498h case    0:*/		return 0x8210149C;
		  /* 8210149Ch */ case    1:  		/* bl -459332 */
		/* 8210149Ch case    1:*/		regs.LR = 0x821014A0; return 0x82091258;
		/* 8210149Ch case    1:*/		return 0x821014A0;
		  /* 821014A0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821014A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821014A0h case    2:*/		return 0x821014A4;
		  /* 821014A4h */ case    3:  		/* mr R30, R3 */
		/* 821014A4h case    3:*/		regs.R30 = regs.R3;
		/* 821014A4h case    3:*/		return 0x821014A8;
		  /* 821014A8h */ case    4:  		/* mr R29, R5 */
		/* 821014A8h case    4:*/		regs.R29 = regs.R5;
		/* 821014A8h case    4:*/		return 0x821014AC;
		  /* 821014ACh */ case    5:  		/* rlwinm R28, R5, 2, 0, 29 */
		/* 821014ACh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R5);
		/* 821014ACh case    5:*/		return 0x821014B0;
		  /* 821014B0h */ case    6:  		/* lwz R11, <#[R30 + 24]> */
		/* 821014B0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 821014B0h case    6:*/		return 0x821014B4;
		  /* 821014B4h */ case    7:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 821014B4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 821014B4h case    7:*/		return 0x821014B8;
		  /* 821014B8h */ case    8:  		/* lwz R9, <#[R30 + 20]> */
		/* 821014B8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 821014B8h case    8:*/		return 0x821014BC;
		  /* 821014BCh */ case    9:  		/* cmpwi CR6, R6, 0 */
		/* 821014BCh case    9:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 821014BCh case    9:*/		return 0x821014C0;
		  /* 821014C0h */ case   10:  		/* lwzx R11, <#[R11 + R28]> */
		/* 821014C0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 821014C0h case   10:*/		return 0x821014C4;
		  /* 821014C4h */ case   11:  		/* lwzx R31, <#[R10 + R9]> */
		/* 821014C4h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821014C4h case   11:*/		return 0x821014C8;
		  /* 821014C8h */ case   12:  		/* bc 12, CR6_EQ, 124 */
		/* 821014C8h case   12:*/		if ( regs.CR[6].eq ) { return 0x82101544;  }
		/* 821014C8h case   12:*/		return 0x821014CC;
		  /* 821014CCh */ case   13:  		/* lwz R10, <#[R31 + 4]> */
		/* 821014CCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821014CCh case   13:*/		return 0x821014D0;
		  /* 821014D0h */ case   14:  		/* lwz R9, <#[R30 + 16]> */
		/* 821014D0h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 821014D0h case   14:*/		return 0x821014D4;
		  /* 821014D4h */ case   15:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821014D4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821014D4h case   15:*/		return 0x821014D8;
		  /* 821014D8h */ case   16:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821014D8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821014D8h case   16:*/		return 0x821014DC;
		  /* 821014DCh */ case   17:  		/* lwz R10, <#[R10 + 4]> */
		/* 821014DCh case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821014DCh case   17:*/		return 0x821014E0;
		  /* 821014E0h */ case   18:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 821014E0h case   18:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 821014E0h case   18:*/		return 0x821014E4;
		  /* 821014E4h */ case   19:  		/* bc 12, CR0_EQ, 96 */
		/* 821014E4h case   19:*/		if ( regs.CR[0].eq ) { return 0x82101544;  }
		/* 821014E4h case   19:*/		return 0x821014E8;
		  /* 821014E8h */ case   20:  		/* lwz R10, <#[R11 + 24]> */
		/* 821014E8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 821014E8h case   20:*/		return 0x821014EC;
		  /* 821014ECh */ case   21:  		/* cmplwi CR6, R10, 0 */
		/* 821014ECh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821014ECh case   21:*/		return 0x821014F0;
		  /* 821014F0h */ case   22:  		/* bc 12, CR6_EQ, 20 */
		/* 821014F0h case   22:*/		if ( regs.CR[6].eq ) { return 0x82101504;  }
		/* 821014F0h case   22:*/		return 0x821014F4;
		  /* 821014F4h */ case   23:  		/* lwz R9, <#[R11 + 20]> */
		/* 821014F4h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 821014F4h case   23:*/		return 0x821014F8;
		  /* 821014F8h */ case   24:  		/* lwz R8, <#[R31 + 72]> */
		/* 821014F8h case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000048) );
		/* 821014F8h case   24:*/		return 0x821014FC;
		  /* 821014FCh */ case   25:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821014FCh case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821014FCh case   25:*/		return 0x82101500;
		  /* 82101500h */ case   26:  		/* stwx R8, <#[R9 + R10]> */
		/* 82101500h case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82101500h case   26:*/		return 0x82101504;
	}
	return 0x82101504;
} // Block from 82101498h-82101504h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82101504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101504);
		  /* 82101504h */ case    0:  		/* lwz R10, <#[R11 + 20]> */
		/* 82101504h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82101504h case    0:*/		return 0x82101508;
		  /* 82101508h */ case    1:  		/* addi R10, R10, 1 */
		/* 82101508h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82101508h case    1:*/		return 0x8210150C;
		  /* 8210150Ch */ case    2:  		/* stw R10, <#[R11 + 20]> */
		/* 8210150Ch case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 8210150Ch case    2:*/		return 0x82101510;
		  /* 82101510h */ case    3:  		/* lwz R11, <#[R30 + 24]> */
		/* 82101510h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82101510h case    3:*/		return 0x82101514;
		  /* 82101514h */ case    4:  		/* lwz R10, <#[R31 + 72]> */
		/* 82101514h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000048) );
		/* 82101514h case    4:*/		return 0x82101518;
		  /* 82101518h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82101518h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82101518h case    5:*/		return 0x8210151C;
		  /* 8210151Ch */ case    6:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210151Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210151Ch case    6:*/		return 0x82101520;
		  /* 82101520h */ case    7:  		/* lwz R10, <#[R11 + 32]> */
		/* 82101520h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000020) );
		/* 82101520h case    7:*/		return 0x82101524;
		  /* 82101524h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 82101524h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82101524h case    8:*/		return 0x82101528;
		  /* 82101528h */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 82101528h case    9:*/		if ( regs.CR[6].eq ) { return 0x82101538;  }
		/* 82101528h case    9:*/		return 0x8210152C;
		  /* 8210152Ch */ case   10:  		/* lwz R9, <#[R11 + 28]> */
		/* 8210152Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000001C) );
		/* 8210152Ch case   10:*/		return 0x82101530;
		  /* 82101530h */ case   11:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82101530h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82101530h case   11:*/		return 0x82101534;
		  /* 82101534h */ case   12:  		/* stwx R29, <#[R9 + R10]> */
		/* 82101534h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82101534h case   12:*/		return 0x82101538;
	}
	return 0x82101538;
} // Block from 82101504h-82101538h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82101538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101538);
		  /* 82101538h */ case    0:  		/* lwz R10, <#[R11 + 28]> */
		/* 82101538h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 82101538h case    0:*/		return 0x8210153C;
		  /* 8210153Ch */ case    1:  		/* addi R10, R10, 1 */
		/* 8210153Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210153Ch case    1:*/		return 0x82101540;
		  /* 82101540h */ case    2:  		/* stw R10, <#[R11 + 28]> */
		/* 82101540h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 82101540h case    2:*/		return 0x82101544;
	}
	return 0x82101544;
} // Block from 82101538h-82101544h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82101544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101544);
		  /* 82101544h */ case    0:  		/* lwz R4, <#[R31 + 8]> */
		/* 82101544h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82101544h case    0:*/		return 0x82101548;
		  /* 82101548h */ case    1:  		/* cmpwi CR6, R4, -1 */
		/* 82101548h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 82101548h case    1:*/		return 0x8210154C;
		  /* 8210154Ch */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8210154Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82101560;  }
		/* 8210154Ch case    2:*/		return 0x82101550;
		  /* 82101550h */ case    3:  		/* li R6, 1 */
		/* 82101550h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82101550h case    3:*/		return 0x82101554;
		  /* 82101554h */ case    4:  		/* mr R5, R29 */
		/* 82101554h case    4:*/		regs.R5 = regs.R29;
		/* 82101554h case    4:*/		return 0x82101558;
		  /* 82101558h */ case    5:  		/* mr R3, R30 */
		/* 82101558h case    5:*/		regs.R3 = regs.R30;
		/* 82101558h case    5:*/		return 0x8210155C;
		  /* 8210155Ch */ case    6:  		/* bl -196 */
		/* 8210155Ch case    6:*/		regs.LR = 0x82101560; return 0x82101498;
		/* 8210155Ch case    6:*/		return 0x82101560;
	}
	return 0x82101560;
} // Block from 82101544h-82101560h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82101560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101560);
		  /* 82101560h */ case    0:  		/* lwz R4, <#[R31 + 20]> */
		/* 82101560h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 82101560h case    0:*/		return 0x82101564;
		  /* 82101564h */ case    1:  		/* cmpwi CR6, R4, -1 */
		/* 82101564h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 82101564h case    1:*/		return 0x82101568;
		  /* 82101568h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82101568h case    2:*/		if ( regs.CR[6].eq ) { return 0x82101574;  }
		/* 82101568h case    2:*/		return 0x8210156C;
		  /* 8210156Ch */ case    3:  		/* li R6, 1 */
		/* 8210156Ch case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8210156Ch case    3:*/		return 0x82101570;
	}
	return 0x82101570;
} // Block from 82101560h-82101570h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82101570h
// Function '?CanVectorize_CanRead@CProgram@D3DXShader@@AAAHIPAVCInstruction@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101570);
		  /* 82101570h */ case    0:  		/* b -192 */
		/* 82101570h case    0:*/		return 0x821014B0;
		/* 82101570h case    0:*/		return 0x82101574;
	}
	return 0x82101574;
} // Block from 82101570h-82101574h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82101574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101574);
		  /* 82101574h */ case    0:  		/* addi R1, R1, 128 */
		/* 82101574h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82101574h case    0:*/		return 0x82101578;
		  /* 82101578h */ case    1:  		/* b -459472 */
		/* 82101578h case    1:*/		return 0x820912A8;
		/* 82101578h case    1:*/		return 0x8210157C;
		  /* 8210157Ch */ case    2:  		/* nop */
		/* 8210157Ch case    2:*/		cpu::op::nop();
		/* 8210157Ch case    2:*/		return 0x82101580;
	}
	return 0x82101580;
} // Block from 82101574h-82101580h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82101580h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101580);
		  /* 82101580h */ case    0:  		/* lwz R10, <#[R3 + 8]> */
		/* 82101580h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82101580h case    0:*/		return 0x82101584;
		  /* 82101584h */ case    1:  		/* li R11, 0 */
		/* 82101584h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82101584h case    1:*/		return 0x82101588;
		  /* 82101588h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 82101588h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82101588h case    2:*/		return 0x8210158C;
		  /* 8210158Ch */ case    3:  		/* bc 4, CR6_GT, 40 */
		/* 8210158Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x821015B4;  }
		/* 8210158Ch case    3:*/		return 0x82101590;
		  /* 82101590h */ case    4:  		/* li R10, 0 */
		/* 82101590h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82101590h case    4:*/		return 0x82101594;
		  /* 82101594h */ case    5:  		/* lwz R9, <#[R3 + 20]> */
		/* 82101594h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82101594h case    5:*/		return 0x82101598;
		  /* 82101598h */ case    6:  		/* lwzx R9, <#[R9 + R10]> */
		/* 82101598h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82101598h case    6:*/		return 0x8210159C;
		  /* 8210159Ch */ case    7:  		/* addi R10, R10, 4 */
		/* 8210159Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210159Ch case    7:*/		return 0x821015A0;
		  /* 821015A0h */ case    8:  		/* stw R11, <#[R9 + 48]> */
		/* 821015A0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 821015A0h case    8:*/		return 0x821015A4;
		  /* 821015A4h */ case    9:  		/* addi R11, R11, 1 */
		/* 821015A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821015A4h case    9:*/		return 0x821015A8;
		  /* 821015A8h */ case   10:  		/* lwz R9, <#[R3 + 8]> */
		/* 821015A8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 821015A8h case   10:*/		return 0x821015AC;
		  /* 821015ACh */ case   11:  		/* cmplw CR6, R11, R9 */
		/* 821015ACh case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821015ACh case   11:*/		return 0x821015B0;
		  /* 821015B0h */ case   12:  		/* bc 12, CR6_LT, -28 */
		/* 821015B0h case   12:*/		if ( regs.CR[6].lt ) { return 0x82101594;  }
		/* 821015B0h case   12:*/		return 0x821015B4;
	}
	return 0x821015B4;
} // Block from 82101580h-821015B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821015B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821015B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821015B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821015B4);
		  /* 821015B4h */ case    0:  		/* li R3, 0 */
		/* 821015B4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821015B4h case    0:*/		return 0x821015B8;
		  /* 821015B8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821015B8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821015B8h case    1:*/		return 0x821015BC;
	}
	return 0x821015BC;
} // Block from 821015B4h-821015BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821015BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821015BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821015BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821015BC);
		  /* 821015BCh */ case    0:  		/* nop */
		/* 821015BCh case    0:*/		cpu::op::nop();
		/* 821015BCh case    0:*/		return 0x821015C0;
	}
	return 0x821015C0;
} // Block from 821015BCh-821015C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821015C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821015C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821015C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821015C0);
		  /* 821015C0h */ case    0:  		/* lis R3, -32768 */
		/* 821015C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 821015C0h case    0:*/		return 0x821015C4;
		  /* 821015C4h */ case    1:  		/* ori R3, R3, 16385 */
		/* 821015C4h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 821015C4h case    1:*/		return 0x821015C8;
		  /* 821015C8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 821015C8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821015C8h case    2:*/		return 0x821015CC;
	}
	return 0x821015CC;
} // Block from 821015C0h-821015CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821015CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821015CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821015CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821015CC);
		  /* 821015CCh */ case    0:  		/* nop */
		/* 821015CCh case    0:*/		cpu::op::nop();
		/* 821015CCh case    0:*/		return 0x821015D0;
	}
	return 0x821015D0;
} // Block from 821015CCh-821015D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821015D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821015D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821015D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821015D0);
		  /* 821015D0h */ case    0:  		/* mfspr R12, LR */
		/* 821015D0h case    0:*/		regs.R12 = regs.LR;
		/* 821015D0h case    0:*/		return 0x821015D4;
		  /* 821015D4h */ case    1:  		/* bl -459648 */
		/* 821015D4h case    1:*/		regs.LR = 0x821015D8; return 0x82091254;
		/* 821015D4h case    1:*/		return 0x821015D8;
		  /* 821015D8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821015D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821015D8h case    2:*/		return 0x821015DC;
		  /* 821015DCh */ case    3:  		/* lwz R11, <#[R5 + 24]> */
		/* 821015DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000018) );
		/* 821015DCh case    3:*/		return 0x821015E0;
		  /* 821015E0h */ case    4:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 821015E0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 821015E0h case    4:*/		return 0x821015E4;
		  /* 821015E4h */ case    5:  		/* rlwinm R9, R4, 2, 0, 29 */
		/* 821015E4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R4);
		/* 821015E4h case    5:*/		return 0x821015E8;
		  /* 821015E8h */ case    6:  		/* mr R30, R5 */
		/* 821015E8h case    6:*/		regs.R30 = regs.R5;
		/* 821015E8h case    6:*/		return 0x821015EC;
		  /* 821015ECh */ case    7:  		/* lwzx R31, <#[R10 + R11]> */
		/* 821015ECh case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821015ECh case    7:*/		return 0x821015F0;
		  /* 821015F0h */ case    8:  		/* lwzx R29, <#[R9 + R11]> */
		/* 821015F0h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821015F0h case    8:*/		return 0x821015F4;
		  /* 821015F4h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 821015F4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821015F4h case    9:*/		return 0x821015F8;
		  /* 821015F8h */ case   10:  		/* lwz R10, <#[R29]> */
		/* 821015F8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 821015F8h case   10:*/		return 0x821015FC;
		  /* 821015FCh */ case   11:  		/* rlwinm R9, R11, 0, 0, 11 */
		/* 821015FCh case   11:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R11);
		/* 821015FCh case   11:*/		return 0x82101600;
		  /* 82101600h */ case   12:  		/* rlwinm R8, R10, 0, 0, 11 */
		/* 82101600h case   12:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R8,regs.R10);
		/* 82101600h case   12:*/		return 0x82101604;
		  /* 82101604h */ case   13:  		/* cmplw CR6, R9, R8 */
		/* 82101604h case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82101604h case   13:*/		return 0x82101608;
		  /* 82101608h */ case   14:  		/* bc 4, CR6_LT, 12 */
		/* 82101608h case   14:*/		if ( !regs.CR[6].lt ) { return 0x82101614;  }
		/* 82101608h case   14:*/		return 0x8210160C;
		  /* 8210160Ch */ case   15:  		/* li R3, -1 */
		/* 8210160Ch case   15:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8210160Ch case   15:*/		return 0x82101610;
	}
	return 0x82101610;
} // Block from 821015D0h-82101610h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82101610h
// Function '?CanVectorize_IsSameRegister@CProgram@D3DXShader@@AAAHII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101610);
		  /* 82101610h */ case    0:  		/* b 476 */
		/* 82101610h case    0:*/		return 0x821017EC;
		/* 82101610h case    0:*/		return 0x82101614;
	}
	return 0x82101614;
} // Block from 82101610h-82101614h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82101614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101614);
		  /* 82101614h */ case    0:  		/* bc 4, CR6_GT, 12 */
		/* 82101614h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82101620;  }
		/* 82101614h case    0:*/		return 0x82101618;
		  /* 82101618h */ case    1:  		/* li R3, 1 */
		/* 82101618h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82101618h case    1:*/		return 0x8210161C;
		  /* 8210161Ch */ case    2:  		/* b 464 */
		/* 8210161Ch case    2:*/		return 0x821017EC;
		/* 8210161Ch case    2:*/		return 0x82101620;
	}
	return 0x82101620;
} // Block from 82101614h-82101620h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82101620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101620);
		  /* 82101620h */ case    0:  		/* rlwinm R10, R10, 0, 12, 31 */
		/* 82101620h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R10,regs.R10);
		/* 82101620h case    0:*/		return 0x82101624;
		  /* 82101624h */ case    1:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 82101624h case    1:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 82101624h case    1:*/		return 0x82101628;
		  /* 82101628h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82101628h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82101628h case    2:*/		return 0x8210162C;
		  /* 8210162Ch */ case    3:  		/* bc 12, CR6_LT, -20 */
		/* 8210162Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82101618;  }
		/* 8210162Ch case    3:*/		return 0x82101630;
		  /* 82101630h */ case    4:  		/* bc 12, CR6_GT, -36 */
		/* 82101630h case    4:*/		if ( regs.CR[6].gt ) { return 0x8210160C;  }
		/* 82101630h case    4:*/		return 0x82101634;
		  /* 82101634h */ case    5:  		/* lwz R28, <#[R31 + 12]> */
		/* 82101634h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x0000000C) );
		/* 82101634h case    5:*/		return 0x82101638;
		  /* 82101638h */ case    6:  		/* li R3, 0 */
		/* 82101638h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82101638h case    6:*/		return 0x8210163C;
		  /* 8210163Ch */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 8210163Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210163Ch case    7:*/		return 0x82101640;
		  /* 82101640h */ case    8:  		/* bc 12, CR6_EQ, 120 */
		/* 82101640h case    8:*/		if ( regs.CR[6].eq ) { return 0x821016B8;  }
		/* 82101640h case    8:*/		return 0x82101644;
		  /* 82101644h */ case    9:  		/* lwz R5, <#[R31 + 16]> */
		/* 82101644h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 82101644h case    9:*/		return 0x82101648;
		  /* 82101648h */ case   10:  		/* li R7, 0 */
		/* 82101648h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82101648h case   10:*/		return 0x8210164C;
		  /* 8210164Ch */ case   11:  		/* lwz R4, <#[R29 + 16]> */
		/* 8210164Ch case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000010) );
		/* 8210164Ch case   11:*/		return 0x82101650;
		  /* 82101650h */ case   12:  		/* lwz R6, <#[R30 + 20]> */
		/* 82101650h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000014) );
		/* 82101650h case   12:*/		return 0x82101654;
		  /* 82101654h */ case   13:  		/* lwzx R11, <#[R7 + R5]> */
		/* 82101654h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R5 + 0x00000000) );
		/* 82101654h case   13:*/		return 0x82101658;
		  /* 82101658h */ case   14:  		/* lwzx R10, <#[R7 + R4]> */
		/* 82101658h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R4 + 0x00000000) );
		/* 82101658h case   14:*/		return 0x8210165C;
		  /* 8210165Ch */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210165Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210165Ch case   15:*/		return 0x82101660;
		  /* 82101660h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82101660h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82101660h case   16:*/		return 0x82101664;
		  /* 82101664h */ case   17:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82101664h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82101664h case   17:*/		return 0x82101668;
		  /* 82101668h */ case   18:  		/* lwzx R10, <#[R10 + R6]> */
		/* 82101668h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82101668h case   18:*/		return 0x8210166C;
		  /* 8210166Ch */ case   19:  		/* lwz R9, <#[R11 + 4]> */
		/* 8210166Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8210166Ch case   19:*/		return 0x82101670;
		  /* 82101670h */ case   20:  		/* lwz R8, <#[R10 + 4]> */
		/* 82101670h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 82101670h case   20:*/		return 0x82101674;
		  /* 82101674h */ case   21:  		/* cmplw CR6, R9, R8 */
		/* 82101674h case   21:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82101674h case   21:*/		return 0x82101678;
	}
	return 0x82101678;
} // Block from 82101620h-82101678h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82101678h
// Function '?CanVectorize_TraceMulAdd@CProgram@D3DXShader@@AAAIIPAN0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101678);
		  /* 82101678h */ case    0:  		/* bc 12, CR6_LT, -108 */
		/* 82101678h case    0:*/		if ( regs.CR[6].lt ) { return 0x8210160C;  }
		/* 82101678h case    0:*/		return 0x8210167C;
		  /* 8210167Ch */ case    1:  		/* bc 12, CR6_GT, -100 */
		/* 8210167Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x82101618;  }
		/* 8210167Ch case    1:*/		return 0x82101680;
		  /* 82101680h */ case    2:  		/* lwz R9, <#[R11 + 20]> */
		/* 82101680h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82101680h case    2:*/		return 0x82101684;
		  /* 82101684h */ case    3:  		/* lwz R8, <#[R10 + 20]> */
		/* 82101684h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000014) );
		/* 82101684h case    3:*/		return 0x82101688;
		  /* 82101688h */ case    4:  		/* cmplw CR6, R9, R8 */
		/* 82101688h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82101688h case    4:*/		return 0x8210168C;
		  /* 8210168Ch */ case    5:  		/* bc 12, CR6_LT, -128 */
		/* 8210168Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8210160C;  }
		/* 8210168Ch case    5:*/		return 0x82101690;
		  /* 82101690h */ case    6:  		/* bc 12, CR6_GT, -120 */
		/* 82101690h case    6:*/		if ( regs.CR[6].gt ) { return 0x82101618;  }
		/* 82101690h case    6:*/		return 0x82101694;
		  /* 82101694h */ case    7:  		/* lwz R11, <#[R11 + 24]> */
		/* 82101694h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82101694h case    7:*/		return 0x82101698;
		  /* 82101698h */ case    8:  		/* lwz R10, <#[R10 + 24]> */
		/* 82101698h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 82101698h case    8:*/		return 0x8210169C;
		  /* 8210169Ch */ case    9:  		/* cmpw CR6, R11, R10 */
		/* 8210169Ch case    9:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8210169Ch case    9:*/		return 0x821016A0;
		  /* 821016A0h */ case   10:  		/* bc 12, CR6_LT, -148 */
		/* 821016A0h case   10:*/		if ( regs.CR[6].lt ) { return 0x8210160C;  }
		/* 821016A0h case   10:*/		return 0x821016A4;
		  /* 821016A4h */ case   11:  		/* bc 12, CR6_GT, -140 */
		/* 821016A4h case   11:*/		if ( regs.CR[6].gt ) { return 0x82101618;  }
		/* 821016A4h case   11:*/		return 0x821016A8;
		  /* 821016A8h */ case   12:  		/* addi R3, R3, 1 */
		/* 821016A8h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 821016A8h case   12:*/		return 0x821016AC;
		  /* 821016ACh */ case   13:  		/* addi R7, R7, 4 */
		/* 821016ACh case   13:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 821016ACh case   13:*/		return 0x821016B0;
		  /* 821016B0h */ case   14:  		/* cmplw CR6, R3, R28 */
		/* 821016B0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R28);
		/* 821016B0h case   14:*/		return 0x821016B4;
		  /* 821016B4h */ case   15:  		/* bc 12, CR6_LT, -96 */
		/* 821016B4h case   15:*/		if ( regs.CR[6].lt ) { return 0x82101654;  }
		/* 821016B4h case   15:*/		return 0x821016B8;
	}
	return 0x821016B8;
} // Block from 82101678h-821016B8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821016B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821016B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821016B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821016B8);
		  /* 821016B8h */ case    0:  		/* mr R3, R31 */
		/* 821016B8h case    0:*/		regs.R3 = regs.R31;
		/* 821016B8h case    0:*/		return 0x821016BC;
		  /* 821016BCh */ case    1:  		/* bl -22204 */
		/* 821016BCh case    1:*/		regs.LR = 0x821016C0; return 0x820FC000;
		/* 821016BCh case    1:*/		return 0x821016C0;
		  /* 821016C0h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 821016C0h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821016C0h case    2:*/		return 0x821016C4;
		  /* 821016C4h */ case    3:  		/* bc 12, CR0_EQ, 200 */
		/* 821016C4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8210178C;  }
		/* 821016C4h case    3:*/		return 0x821016C8;
		  /* 821016C8h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 821016C8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821016C8h case    4:*/		return 0x821016CC;
		  /* 821016CCh */ case    5:  		/* li R27, 0 */
		/* 821016CCh case    5:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821016CCh case    5:*/		return 0x821016D0;
		  /* 821016D0h */ case    6:  		/* rlwinm. R28, R11, 0, 12, 31 */
		/* 821016D0h case    6:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R28,regs.R11);
		/* 821016D0h case    6:*/		return 0x821016D4;
		  /* 821016D4h */ case    7:  		/* bc 12, CR0_EQ, 276 */
		/* 821016D4h case    7:*/		if ( regs.CR[0].eq ) { return 0x821017E8;  }
		/* 821016D4h case    7:*/		return 0x821016D8;
		  /* 821016D8h */ case    8:  		/* lwz R3, <#[R31 + 8]> */
		/* 821016D8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 821016D8h case    8:*/		return 0x821016DC;
		  /* 821016DCh */ case    9:  		/* li R8, 0 */
		/* 821016DCh case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821016DCh case    9:*/		return 0x821016E0;
		  /* 821016E0h */ case   10:  		/* lwz R31, <#[R29 + 8]> */
		/* 821016E0h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000008) );
		/* 821016E0h case   10:*/		return 0x821016E4;
		  /* 821016E4h */ case   11:  		/* rlwinm R7, R28, 2, 0, 29 */
		/* 821016E4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R28);
		/* 821016E4h case   11:*/		return 0x821016E8;
		  /* 821016E8h */ case   12:  		/* lwz R9, <#[R30 + 20]> */
		/* 821016E8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 821016E8h case   12:*/		return 0x821016EC;
		  /* 821016ECh */ case   13:  		/* lwzx R11, <#[R8 + R3]> */
		/* 821016ECh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 821016ECh case   13:*/		return 0x821016F0;
		  /* 821016F0h */ case   14:  		/* lwzx R10, <#[R7 + R3]> */
		/* 821016F0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R3 + 0x00000000) );
		/* 821016F0h case   14:*/		return 0x821016F4;
		  /* 821016F4h */ case   15:  		/* lwzx R6, <#[R8 + R31]> */
		/* 821016F4h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + regs.R31 + 0x00000000) );
		/* 821016F4h case   15:*/		return 0x821016F8;
		  /* 821016F8h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821016F8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821016F8h case   16:*/		return 0x821016FC;
		  /* 821016FCh */ case   17:  		/* lwzx R5, <#[R7 + R31]> */
		/* 821016FCh case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + regs.R31 + 0x00000000) );
		/* 821016FCh case   17:*/		return 0x82101700;
		  /* 82101700h */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82101700h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82101700h case   18:*/		return 0x82101704;
		  /* 82101704h */ case   19:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82101704h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82101704h case   19:*/		return 0x82101708;
		  /* 82101708h */ case   20:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82101708h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82101708h case   20:*/		return 0x8210170C;
		  /* 8210170Ch */ case   21:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210170Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210170Ch case   21:*/		return 0x82101710;
		  /* 82101710h */ case   22:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82101710h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82101710h case   22:*/		return 0x82101714;
		  /* 82101714h */ case   23:  		/* lwzx R6, <#[R6 + R9]> */
		/* 82101714h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R9 + 0x00000000) );
		/* 82101714h case   23:*/		return 0x82101718;
		  /* 82101718h */ case   24:  		/* lwzx R5, <#[R5 + R9]> */
		/* 82101718h case   24:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 82101718h case   24:*/		return 0x8210171C;
		  /* 8210171Ch */ case   25:  		/* lwz R11, <#[R11 + 48]> */
		/* 8210171Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 8210171Ch case   25:*/		return 0x82101720;
		  /* 82101720h */ case   26:  		/* lwz R10, <#[R10 + 48]> */
		/* 82101720h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 82101720h case   26:*/		return 0x82101724;
		  /* 82101724h */ case   27:  		/* lwz R6, <#[R6 + 48]> */
		/* 82101724h case   27:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000030) );
		/* 82101724h case   27:*/		return 0x82101728;
		  /* 82101728h */ case   28:  		/* mr R30, R11 */
		/* 82101728h case   28:*/		regs.R30 = regs.R11;
		/* 82101728h case   28:*/		return 0x8210172C;
		  /* 8210172Ch */ case   29:  		/* lwz R5, <#[R5 + 48]> */
		/* 8210172Ch case   29:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000030) );
		/* 8210172Ch case   29:*/		return 0x82101730;
		  /* 82101730h */ case   30:  		/* cmplw CR6, R11, R10 */
		/* 82101730h case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82101730h case   30:*/		return 0x82101734;
		  /* 82101734h */ case   31:  		/* bc 12, CR6_LT, 12 */
		/* 82101734h case   31:*/		if ( regs.CR[6].lt ) { return 0x82101740;  }
		/* 82101734h case   31:*/		return 0x82101738;
		  /* 82101738h */ case   32:  		/* mr R30, R10 */
		/* 82101738h case   32:*/		regs.R30 = regs.R10;
		/* 82101738h case   32:*/		return 0x8210173C;
		  /* 8210173Ch */ case   33:  		/* bc 12, CR6_GT, 8 */
		/* 8210173Ch case   33:*/		if ( regs.CR[6].gt ) { return 0x82101744;  }
		/* 8210173Ch case   33:*/		return 0x82101740;
	}
	return 0x82101740;
} // Block from 821016B8h-82101740h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82101740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101740);
		  /* 82101740h */ case    0:  		/* mr R11, R10 */
		/* 82101740h case    0:*/		regs.R11 = regs.R10;
		/* 82101740h case    0:*/		return 0x82101744;
	}
	return 0x82101744;
} // Block from 82101740h-82101744h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82101744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101744);
		  /* 82101744h */ case    0:  		/* cmplw CR6, R6, R5 */
		/* 82101744h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 82101744h case    0:*/		return 0x82101748;
		  /* 82101748h */ case    1:  		/* mr R4, R6 */
		/* 82101748h case    1:*/		regs.R4 = regs.R6;
		/* 82101748h case    1:*/		return 0x8210174C;
		  /* 8210174Ch */ case    2:  		/* bc 12, CR6_LT, 12 */
		/* 8210174Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x82101758;  }
		/* 8210174Ch case    2:*/		return 0x82101750;
		  /* 82101750h */ case    3:  		/* mr R4, R5 */
		/* 82101750h case    3:*/		regs.R4 = regs.R5;
		/* 82101750h case    3:*/		return 0x82101754;
		  /* 82101754h */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 82101754h case    4:*/		if ( regs.CR[6].gt ) { return 0x8210175C;  }
		/* 82101754h case    4:*/		return 0x82101758;
	}
	return 0x82101758;
} // Block from 82101744h-82101758h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82101758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101758);
		  /* 82101758h */ case    0:  		/* mr R6, R5 */
		/* 82101758h case    0:*/		regs.R6 = regs.R5;
		/* 82101758h case    0:*/		return 0x8210175C;
	}
	return 0x8210175C;
} // Block from 82101758h-8210175Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210175Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210175C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210175C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210175C);
		  /* 8210175Ch */ case    0:  		/* cmplw CR6, R30, R4 */
		/* 8210175Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R4);
		/* 8210175Ch case    0:*/		return 0x82101760;
		  /* 82101760h */ case    1:  		/* bc 12, CR6_LT, -340 */
		/* 82101760h case    1:*/		if ( regs.CR[6].lt ) { return 0x8210160C;  }
		/* 82101760h case    1:*/		return 0x82101764;
		  /* 82101764h */ case    2:  		/* bc 12, CR6_GT, -332 */
		/* 82101764h case    2:*/		if ( regs.CR[6].gt ) { return 0x82101618;  }
		/* 82101764h case    2:*/		return 0x82101768;
		  /* 82101768h */ case    3:  		/* cmplw CR6, R11, R6 */
		/* 82101768h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 82101768h case    3:*/		return 0x8210176C;
		  /* 8210176Ch */ case    4:  		/* bc 12, CR6_LT, -352 */
		/* 8210176Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8210160C;  }
		/* 8210176Ch case    4:*/		return 0x82101770;
		  /* 82101770h */ case    5:  		/* bc 12, CR6_GT, -344 */
		/* 82101770h case    5:*/		if ( regs.CR[6].gt ) { return 0x82101618;  }
		/* 82101770h case    5:*/		return 0x82101774;
		  /* 82101774h */ case    6:  		/* addi R27, R27, 1 */
		/* 82101774h case    6:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82101774h case    6:*/		return 0x82101778;
		  /* 82101778h */ case    7:  		/* addi R8, R8, 4 */
		/* 82101778h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82101778h case    7:*/		return 0x8210177C;
		  /* 8210177Ch */ case    8:  		/* addi R7, R7, 4 */
		/* 8210177Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210177Ch case    8:*/		return 0x82101780;
		  /* 82101780h */ case    9:  		/* cmplw CR6, R27, R28 */
		/* 82101780h case    9:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R28);
		/* 82101780h case    9:*/		return 0x82101784;
		  /* 82101784h */ case   10:  		/* bc 12, CR6_LT, -152 */
		/* 82101784h case   10:*/		if ( regs.CR[6].lt ) { return 0x821016EC;  }
		/* 82101784h case   10:*/		return 0x82101788;
		  /* 82101788h */ case   11:  		/* b 96 */
		/* 82101788h case   11:*/		return 0x821017E8;
		/* 82101788h case   11:*/		return 0x8210178C;
	}
	return 0x8210178C;
} // Block from 8210175Ch-8210178Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210178Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210178C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210178C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210178C);
		  /* 8210178Ch */ case    0:  		/* lwz R4, <#[R31 + 4]> */
		/* 8210178Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 8210178Ch case    0:*/		return 0x82101790;
		  /* 82101790h */ case    1:  		/* li R5, 0 */
		/* 82101790h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82101790h case    1:*/		return 0x82101794;
		  /* 82101794h */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 82101794h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82101794h case    2:*/		return 0x82101798;
		  /* 82101798h */ case    3:  		/* bc 12, CR6_EQ, 80 */
		/* 82101798h case    3:*/		if ( regs.CR[6].eq ) { return 0x821017E8;  }
		/* 82101798h case    3:*/		return 0x8210179C;
		  /* 8210179Ch */ case    4:  		/* lwz R7, <#[R31 + 8]> */
		/* 8210179Ch case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 8210179Ch case    4:*/		return 0x821017A0;
		  /* 821017A0h */ case    5:  		/* li R11, 0 */
		/* 821017A0h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821017A0h case    5:*/		return 0x821017A4;
		  /* 821017A4h */ case    6:  		/* lwz R6, <#[R29 + 8]> */
		/* 821017A4h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000008) );
		/* 821017A4h case    6:*/		return 0x821017A8;
		  /* 821017A8h */ case    7:  		/* lwz R10, <#[R30 + 20]> */
		/* 821017A8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 821017A8h case    7:*/		return 0x821017AC;
		  /* 821017ACh */ case    8:  		/* lwzx R9, <#[R11 + R7]> */
		/* 821017ACh case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 821017ACh case    8:*/		return 0x821017B0;
		  /* 821017B0h */ case    9:  		/* lwzx R8, <#[R11 + R6]> */
		/* 821017B0h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 821017B0h case    9:*/		return 0x821017B4;
		  /* 821017B4h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821017B4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821017B4h case   10:*/		return 0x821017B8;
		  /* 821017B8h */ case   11:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821017B8h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821017B8h case   11:*/		return 0x821017BC;
		  /* 821017BCh */ case   12:  		/* lwzx R9, <#[R9 + R10]> */
		/* 821017BCh case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821017BCh case   12:*/		return 0x821017C0;
		  /* 821017C0h */ case   13:  		/* lwzx R8, <#[R8 + R10]> */
		/* 821017C0h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 821017C0h case   13:*/		return 0x821017C4;
		  /* 821017C4h */ case   14:  		/* lwz R9, <#[R9 + 48]> */
		/* 821017C4h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000030) );
		/* 821017C4h case   14:*/		return 0x821017C8;
		  /* 821017C8h */ case   15:  		/* lwz R8, <#[R8 + 48]> */
		/* 821017C8h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000030) );
		/* 821017C8h case   15:*/		return 0x821017CC;
		  /* 821017CCh */ case   16:  		/* cmplw CR6, R9, R8 */
		/* 821017CCh case   16:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821017CCh case   16:*/		return 0x821017D0;
		  /* 821017D0h */ case   17:  		/* bc 12, CR6_LT, -452 */
		/* 821017D0h case   17:*/		if ( regs.CR[6].lt ) { return 0x8210160C;  }
		/* 821017D0h case   17:*/		return 0x821017D4;
		  /* 821017D4h */ case   18:  		/* bc 12, CR6_GT, -444 */
		/* 821017D4h case   18:*/		if ( regs.CR[6].gt ) { return 0x82101618;  }
		/* 821017D4h case   18:*/		return 0x821017D8;
		  /* 821017D8h */ case   19:  		/* addi R5, R5, 1 */
		/* 821017D8h case   19:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 821017D8h case   19:*/		return 0x821017DC;
		  /* 821017DCh */ case   20:  		/* addi R11, R11, 4 */
		/* 821017DCh case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821017DCh case   20:*/		return 0x821017E0;
		  /* 821017E0h */ case   21:  		/* cmplw CR6, R5, R4 */
		/* 821017E0h case   21:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 821017E0h case   21:*/		return 0x821017E4;
		  /* 821017E4h */ case   22:  		/* bc 12, CR6_LT, -56 */
		/* 821017E4h case   22:*/		if ( regs.CR[6].lt ) { return 0x821017AC;  }
		/* 821017E4h case   22:*/		return 0x821017E8;
	}
	return 0x821017E8;
} // Block from 8210178Ch-821017E8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821017E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821017E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821017E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821017E8);
		  /* 821017E8h */ case    0:  		/* li R3, 0 */
		/* 821017E8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821017E8h case    0:*/		return 0x821017EC;
	}
	return 0x821017EC;
} // Block from 821017E8h-821017ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821017ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821017EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821017EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821017EC);
		  /* 821017ECh */ case    0:  		/* addi R1, R1, 128 */
		/* 821017ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821017ECh case    0:*/		return 0x821017F0;
		  /* 821017F0h */ case    1:  		/* b -460108 */
		/* 821017F0h case    1:*/		return 0x820912A4;
		/* 821017F0h case    1:*/		return 0x821017F4;
		  /* 821017F4h */ case    2:  		/* nop */
		/* 821017F4h case    2:*/		cpu::op::nop();
		/* 821017F4h case    2:*/		return 0x821017F8;
	}
	return 0x821017F8;
} // Block from 821017ECh-821017F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821017F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821017F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821017F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821017F8);
		  /* 821017F8h */ case    0:  		/* mfspr R12, LR */
		/* 821017F8h case    0:*/		regs.R12 = regs.LR;
		/* 821017F8h case    0:*/		return 0x821017FC;
		  /* 821017FCh */ case    1:  		/* bl -460208 */
		/* 821017FCh case    1:*/		regs.LR = 0x82101800; return 0x8209124C;
		/* 821017FCh case    1:*/		return 0x82101800;
		  /* 82101800h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82101800h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82101800h case    2:*/		return 0x82101804;
		  /* 82101804h */ case    3:  		/* lwz R11, <#[R5 + 24]> */
		/* 82101804h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000018) );
		/* 82101804h case    3:*/		return 0x82101808;
		  /* 82101808h */ case    4:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82101808h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82101808h case    4:*/		return 0x8210180C;
		  /* 8210180Ch */ case    5:  		/* rlwinm R9, R4, 2, 0, 29 */
		/* 8210180Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R4);
		/* 8210180Ch case    5:*/		return 0x82101810;
		  /* 82101810h */ case    6:  		/* mr R25, R5 */
		/* 82101810h case    6:*/		regs.R25 = regs.R5;
		/* 82101810h case    6:*/		return 0x82101814;
		  /* 82101814h */ case    7:  		/* lwzx R29, <#[R10 + R11]> */
		/* 82101814h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82101814h case    7:*/		return 0x82101818;
		  /* 82101818h */ case    8:  		/* lwzx R27, <#[R9 + R11]> */
		/* 82101818h case    8:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82101818h case    8:*/		return 0x8210181C;
		  /* 8210181Ch */ case    9:  		/* lwz R11, <#[R29]> */
		/* 8210181Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8210181Ch case    9:*/		return 0x82101820;
		  /* 82101820h */ case   10:  		/* lwz R10, <#[R27]> */
		/* 82101820h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 82101820h case   10:*/		return 0x82101824;
		  /* 82101824h */ case   11:  		/* xor R9, R11, R10 */
		/* 82101824h case   11:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 82101824h case   11:*/		return 0x82101828;
		  /* 82101828h */ case   12:  		/* rlwinm. R9, R9, 0, 0, 11 */
		/* 82101828h case   12:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R9,regs.R9);
		/* 82101828h case   12:*/		return 0x8210182C;
		  /* 8210182Ch */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 8210182Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82101838;  }
		/* 8210182Ch case   13:*/		return 0x82101830;
		  /* 82101830h */ case   14:  		/* li R3, 0 */
		/* 82101830h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82101830h case   14:*/		return 0x82101834;
		  /* 82101834h */ case   15:  		/* b 508 */
		/* 82101834h case   15:*/		return 0x82101A30;
		/* 82101834h case   15:*/		return 0x82101838;
	}
	return 0x82101838;
} // Block from 821017F8h-82101838h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82101838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101838);
		  /* 82101838h */ case    0:  		/* rlwinm R3, R11, 0, 12, 31 */
		/* 82101838h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R3,regs.R11);
		/* 82101838h case    0:*/		return 0x8210183C;
		  /* 8210183Ch */ case    1:  		/* rlwinm R10, R10, 0, 12, 31 */
		/* 8210183Ch case    1:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R10,regs.R10);
		/* 8210183Ch case    1:*/		return 0x82101840;
		  /* 82101840h */ case    2:  		/* cmplw CR6, R3, R10 */
		/* 82101840h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 82101840h case    2:*/		return 0x82101844;
		  /* 82101844h */ case    3:  		/* bc 4, CR6_LT, -20 */
		/* 82101844h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82101830;  }
		/* 82101844h case    3:*/		return 0x82101848;
		  /* 82101848h */ case    4:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 82101848h case    4:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 82101848h case    4:*/		return 0x8210184C;
		  /* 8210184Ch */ case    5:  		/* lis R10, 4096 */
		/* 8210184Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 8210184Ch case    5:*/		return 0x82101850;
		  /* 82101850h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 82101850h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82101850h case    6:*/		return 0x82101854;
		  /* 82101854h */ case    7:  		/* bc 12, CR6_LT, -36 */
		/* 82101854h case    7:*/		if ( regs.CR[6].lt ) { return 0x82101830;  }
		/* 82101854h case    7:*/		return 0x82101858;
		  /* 82101858h */ case    8:  		/* lis R10, 16384 */
		/* 82101858h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x4000);
		/* 82101858h case    8:*/		return 0x8210185C;
		  /* 8210185Ch */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 8210185Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210185Ch case    9:*/		return 0x82101860;
		  /* 82101860h */ case   10:  		/* bc 12, CR6_GT, -48 */
		/* 82101860h case   10:*/		if ( regs.CR[6].gt ) { return 0x82101830;  }
		/* 82101860h case   10:*/		return 0x82101864;
		  /* 82101864h */ case   11:  		/* lwz R5, <#[R29 + 12]> */
		/* 82101864h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 82101864h case   11:*/		return 0x82101868;
	}
	return 0x82101868;
} // Block from 82101838h-82101868h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82101868h
// Function '?CombinePools@CProgram@D3DXShader@@AAAJIKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101868);
		  /* 82101868h */ case    0:  		/* li R4, 0 */
		/* 82101868h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82101868h case    0:*/		return 0x8210186C;
		  /* 8210186Ch */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 8210186Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8210186Ch case    1:*/		return 0x82101870;
		  /* 82101870h */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 82101870h case    2:*/		if ( regs.CR[6].eq ) { return 0x821018DC;  }
		/* 82101870h case    2:*/		return 0x82101874;
		  /* 82101874h */ case    3:  		/* lwz R7, <#[R29 + 16]> */
		/* 82101874h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R29 + 0x00000010) );
		/* 82101874h case    3:*/		return 0x82101878;
		  /* 82101878h */ case    4:  		/* li R11, 0 */
		/* 82101878h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82101878h case    4:*/		return 0x8210187C;
		  /* 8210187Ch */ case    5:  		/* lwz R6, <#[R27 + 16]> */
		/* 8210187Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R27 + 0x00000010) );
		/* 8210187Ch case    5:*/		return 0x82101880;
		  /* 82101880h */ case    6:  		/* lwz R8, <#[R25 + 20]> */
		/* 82101880h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000014) );
		/* 82101880h case    6:*/		return 0x82101884;
		  /* 82101884h */ case    7:  		/* lwzx R10, <#[R11 + R7]> */
		/* 82101884h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82101884h case    7:*/		return 0x82101888;
		  /* 82101888h */ case    8:  		/* lwzx R9, <#[R11 + R6]> */
		/* 82101888h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82101888h case    8:*/		return 0x8210188C;
		  /* 8210188Ch */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210188Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210188Ch case    9:*/		return 0x82101890;
		  /* 82101890h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82101890h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82101890h case   10:*/		return 0x82101894;
		  /* 82101894h */ case   11:  		/* lwzx R10, <#[R10 + R8]> */
		/* 82101894h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82101894h case   11:*/		return 0x82101898;
		  /* 82101898h */ case   12:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82101898h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82101898h case   12:*/		return 0x8210189C;
		  /* 8210189Ch */ case   13:  		/* lwz R31, <#[R10 + 4]> */
		/* 8210189Ch case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 8210189Ch case   13:*/		return 0x821018A0;
		  /* 821018A0h */ case   14:  		/* lwz R30, <#[R9 + 4]> */
		/* 821018A0h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000004) );
		/* 821018A0h case   14:*/		return 0x821018A4;
		  /* 821018A4h */ case   15:  		/* cmplw CR6, R31, R30 */
		/* 821018A4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 821018A4h case   15:*/		return 0x821018A8;
		  /* 821018A8h */ case   16:  		/* bc 4, CR6_EQ, -120 */
		/* 821018A8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82101830;  }
		/* 821018A8h case   16:*/		return 0x821018AC;
		  /* 821018ACh */ case   17:  		/* lwz R31, <#[R10 + 20]> */
		/* 821018ACh case   17:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000014) );
		/* 821018ACh case   17:*/		return 0x821018B0;
		  /* 821018B0h */ case   18:  		/* lwz R30, <#[R9 + 20]> */
		/* 821018B0h case   18:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000014) );
		/* 821018B0h case   18:*/		return 0x821018B4;
		  /* 821018B4h */ case   19:  		/* cmplw CR6, R31, R30 */
		/* 821018B4h case   19:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 821018B4h case   19:*/		return 0x821018B8;
		  /* 821018B8h */ case   20:  		/* bc 4, CR6_EQ, -136 */
		/* 821018B8h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82101830;  }
		/* 821018B8h case   20:*/		return 0x821018BC;
		  /* 821018BCh */ case   21:  		/* lwz R10, <#[R10 + 24]> */
		/* 821018BCh case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 821018BCh case   21:*/		return 0x821018C0;
		  /* 821018C0h */ case   22:  		/* lwz R9, <#[R9 + 24]> */
		/* 821018C0h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 821018C0h case   22:*/		return 0x821018C4;
		  /* 821018C4h */ case   23:  		/* cmpw CR6, R10, R9 */
		/* 821018C4h case   23:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 821018C4h case   23:*/		return 0x821018C8;
		  /* 821018C8h */ case   24:  		/* bc 4, CR6_EQ, -152 */
		/* 821018C8h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82101830;  }
		/* 821018C8h case   24:*/		return 0x821018CC;
		  /* 821018CCh */ case   25:  		/* addi R4, R4, 1 */
		/* 821018CCh case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 821018CCh case   25:*/		return 0x821018D0;
		  /* 821018D0h */ case   26:  		/* addi R11, R11, 4 */
		/* 821018D0h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821018D0h case   26:*/		return 0x821018D4;
		  /* 821018D4h */ case   27:  		/* cmplw CR6, R4, R5 */
		/* 821018D4h case   27:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 821018D4h case   27:*/		return 0x821018D8;
		  /* 821018D8h */ case   28:  		/* bc 12, CR6_LT, -84 */
		/* 821018D8h case   28:*/		if ( regs.CR[6].lt ) { return 0x82101884;  }
		/* 821018D8h case   28:*/		return 0x821018DC;
	}
	return 0x821018DC;
} // Block from 82101868h-821018DCh (29 instructions)

//////////////////////////////////////////////////////
// Block at 821018DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821018DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821018DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821018DC);
		  /* 821018DCh */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 821018DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821018DCh case    0:*/		return 0x821018E0;
		  /* 821018E0h */ case    1:  		/* li R28, 0 */
		/* 821018E0h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821018E0h case    1:*/		return 0x821018E4;
		  /* 821018E4h */ case    2:  		/* cmplwi CR6, R5, 0 */
		/* 821018E4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821018E4h case    2:*/		return 0x821018E8;
		  /* 821018E8h */ case    3:  		/* divwu R26, R11, R3 */
		/* 821018E8h case    3:*/		cpu::op::divwu<0>(regs,&regs.R26,regs.R11,regs.R3);
		/* 821018E8h case    3:*/		return 0x821018EC;
		  /* 821018ECh */ case    4:  		/* twi 6, R3, 0 */
		/* 821018ECh case    4:*/		cpu::op::tw<6>(regs, 0x821018EC, regs.R3, 0x00000000);
		/* 821018ECh case    4:*/		return 0x821018F0;
		  /* 821018F0h */ case    5:  		/* bc 12, CR6_EQ, 316 */
		/* 821018F0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82101A2C;  }
		/* 821018F0h case    5:*/		return 0x821018F4;
		  /* 821018F4h */ case    6:  		/* lwz R5, <#[R27 + 12]> */
		/* 821018F4h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 821018F4h case    6:*/		return 0x821018F8;
		  /* 821018F8h */ case    7:  		/* li R30, 0 */
		/* 821018F8h case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821018F8h case    7:*/		return 0x821018FC;
		  /* 821018FCh */ case    8:  		/* cmplwi CR6, R5, 0 */
		/* 821018FCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821018FCh case    8:*/		return 0x82101900;
		  /* 82101900h */ case    9:  		/* bc 12, CR6_EQ, 272 */
		/* 82101900h case    9:*/		if ( regs.CR[6].eq ) { return 0x82101A10;  }
		/* 82101900h case    9:*/		return 0x82101904;
		  /* 82101904h */ case   10:  		/* li R31, 0 */
		/* 82101904h case   10:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82101904h case   10:*/		return 0x82101908;
		  /* 82101908h */ case   11:  		/* cmplwi CR6, R26, 0 */
		/* 82101908h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82101908h case   11:*/		return 0x8210190C;
		  /* 8210190Ch */ case   12:  		/* bc 12, CR6_EQ, 96 */
		/* 8210190Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x8210196C;  }
		/* 8210190Ch case   12:*/		return 0x82101910;
		  /* 82101910h */ case   13:  		/* lwz R8, <#[R27 + 8]> */
		/* 82101910h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000008) );
		/* 82101910h case   13:*/		return 0x82101914;
		  /* 82101914h */ case   14:  		/* lwz R7, <#[R29 + 12]> */
		/* 82101914h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R29 + 0x0000000C) );
		/* 82101914h case   14:*/		return 0x82101918;
		  /* 82101918h */ case   15:  		/* lwz R6, <#[R29 + 8]> */
		/* 82101918h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000008) );
		/* 82101918h case   15:*/		return 0x8210191C;
		  /* 8210191Ch */ case   16:  		/* lwz R11, <#[R25 + 20]> */
		/* 8210191Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000014) );
		/* 8210191Ch case   16:*/		return 0x82101920;
		  /* 82101920h */ case   17:  		/* mullw R10, R5, R31 */
		/* 82101920h case   17:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R5,regs.R31);
		/* 82101920h case   17:*/		return 0x82101924;
		  /* 82101924h */ case   18:  		/* mullw R9, R7, R31 */
		/* 82101924h case   18:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R7,regs.R31);
		/* 82101924h case   18:*/		return 0x82101928;
		  /* 82101928h */ case   19:  		/* add R10, R10, R30 */
		/* 82101928h case   19:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 82101928h case   19:*/		return 0x8210192C;
		  /* 8210192Ch */ case   20:  		/* add R9, R9, R28 */
		/* 8210192Ch case   20:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R28);
		/* 8210192Ch case   20:*/		return 0x82101930;
		  /* 82101930h */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82101930h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82101930h case   21:*/		return 0x82101934;
		  /* 82101934h */ case   22:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82101934h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82101934h case   22:*/		return 0x82101938;
		  /* 82101938h */ case   23:  		/* lwzx R10, <#[R10 + R8]> */
		/* 82101938h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82101938h case   23:*/		return 0x8210193C;
		  /* 8210193Ch */ case   24:  		/* lwzx R9, <#[R9 + R6]> */
		/* 8210193Ch case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 8210193Ch case   24:*/		return 0x82101940;
		  /* 82101940h */ case   25:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82101940h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82101940h case   25:*/		return 0x82101944;
		  /* 82101944h */ case   26:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82101944h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82101944h case   26:*/		return 0x82101948;
		  /* 82101948h */ case   27:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82101948h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82101948h case   27:*/		return 0x8210194C;
		  /* 8210194Ch */ case   28:  		/* lwzx R9, <#[R9 + R11]> */
		/* 8210194Ch case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210194Ch case   28:*/		return 0x82101950;
		  /* 82101950h */ case   29:  		/* lwz R10, <#[R10 + 48]> */
		/* 82101950h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 82101950h case   29:*/		return 0x82101954;
		  /* 82101954h */ case   30:  		/* lwz R9, <#[R9 + 48]> */
		/* 82101954h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000030) );
		/* 82101954h case   30:*/		return 0x82101958;
		  /* 82101958h */ case   31:  		/* cmplw CR6, R9, R10 */
		/* 82101958h case   31:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82101958h case   31:*/		return 0x8210195C;
		  /* 8210195Ch */ case   32:  		/* bc 4, CR6_EQ, 16 */
		/* 8210195Ch case   32:*/		if ( !regs.CR[6].eq ) { return 0x8210196C;  }
		/* 8210195Ch case   32:*/		return 0x82101960;
		  /* 82101960h */ case   33:  		/* addi R31, R31, 1 */
		/* 82101960h case   33:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82101960h case   33:*/		return 0x82101964;
		  /* 82101964h */ case   34:  		/* cmplw CR6, R31, R26 */
		/* 82101964h case   34:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 82101964h case   34:*/		return 0x82101968;
		  /* 82101968h */ case   35:  		/* bc 12, CR6_LT, -72 */
		/* 82101968h case   35:*/		if ( regs.CR[6].lt ) { return 0x82101920;  }
		/* 82101968h case   35:*/		return 0x8210196C;
	}
	return 0x8210196C;
} // Block from 821018DCh-8210196Ch (36 instructions)

//////////////////////////////////////////////////////
// Block at 8210196Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210196C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210196C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210196C);
		  /* 8210196Ch */ case    0:  		/* cmplw CR6, R31, R26 */
		/* 8210196Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 8210196Ch case    0:*/		return 0x82101970;
		  /* 82101970h */ case    1:  		/* bc 12, CR6_EQ, 160 */
		/* 82101970h case    1:*/		if ( regs.CR[6].eq ) { return 0x82101A10;  }
		/* 82101970h case    1:*/		return 0x82101974;
		  /* 82101974h */ case    2:  		/* mr R3, R29 */
		/* 82101974h case    2:*/		regs.R3 = regs.R29;
		/* 82101974h case    2:*/		return 0x82101978;
		  /* 82101978h */ case    3:  		/* bl -22904 */
		/* 82101978h case    3:*/		regs.LR = 0x8210197C; return 0x820FC000;
		/* 82101978h case    3:*/		return 0x8210197C;
		  /* 8210197Ch */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 8210197Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210197Ch case    4:*/		return 0x82101980;
		  /* 82101980h */ case    5:  		/* bc 12, CR0_EQ, 120 */
		/* 82101980h case    5:*/		if ( regs.CR[0].eq ) { return 0x821019F8;  }
		/* 82101980h case    5:*/		return 0x82101984;
		  /* 82101984h */ case    6:  		/* li R31, 0 */
		/* 82101984h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82101984h case    6:*/		return 0x82101988;
		  /* 82101988h */ case    7:  		/* cmplwi CR6, R26, 0 */
		/* 82101988h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82101988h case    7:*/		return 0x8210198C;
		  /* 8210198Ch */ case    8:  		/* bc 12, CR6_EQ, 108 */
		/* 8210198Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x821019F8;  }
		/* 8210198Ch case    8:*/		return 0x82101990;
		  /* 82101990h */ case    9:  		/* lwz R7, <#[R29 + 12]> */
		/* 82101990h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R29 + 0x0000000C) );
		/* 82101990h case    9:*/		return 0x82101994;
		  /* 82101994h */ case   10:  		/* li R10, 1 */
		/* 82101994h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82101994h case   10:*/		return 0x82101998;
		  /* 82101998h */ case   11:  		/* lwz R6, <#[R29 + 8]> */
		/* 82101998h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000008) );
		/* 82101998h case   11:*/		return 0x8210199C;
		  /* 8210199Ch */ case   12:  		/* lwz R5, <#[R27 + 12]> */
		/* 8210199Ch case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 8210199Ch case   12:*/		return 0x821019A0;
		  /* 821019A0h */ case   13:  		/* lwz R4, <#[R27 + 8]> */
		/* 821019A0h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000008) );
		/* 821019A0h case   13:*/		return 0x821019A4;
		  /* 821019A4h */ case   14:  		/* lwz R11, <#[R25 + 20]> */
		/* 821019A4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000014) );
		/* 821019A4h case   14:*/		return 0x821019A8;
		  /* 821019A8h */ case   15:  		/* mullw R8, R5, R31 */
		/* 821019A8h case   15:*/		cpu::op::mullw<0>(regs,&regs.R8,regs.R5,regs.R31);
		/* 821019A8h case   15:*/		return 0x821019AC;
		  /* 821019ACh */ case   16:  		/* mullw R9, R10, R7 */
		/* 821019ACh case   16:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R10,regs.R7);
		/* 821019ACh case   16:*/		return 0x821019B0;
		  /* 821019B0h */ case   17:  		/* add R8, R8, R30 */
		/* 821019B0h case   17:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R30);
		/* 821019B0h case   17:*/		return 0x821019B4;
		  /* 821019B4h */ case   18:  		/* add R9, R9, R28 */
		/* 821019B4h case   18:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R28);
		/* 821019B4h case   18:*/		return 0x821019B8;
		  /* 821019B8h */ case   19:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821019B8h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821019B8h case   19:*/		return 0x821019BC;
		  /* 821019BCh */ case   20:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821019BCh case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821019BCh case   20:*/		return 0x821019C0;
		  /* 821019C0h */ case   21:  		/* lwzx R8, <#[R8 + R4]> */
		/* 821019C0h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R4 + 0x00000000) );
		/* 821019C0h case   21:*/		return 0x821019C4;
		  /* 821019C4h */ case   22:  		/* lwzx R9, <#[R9 + R6]> */
		/* 821019C4h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 821019C4h case   22:*/		return 0x821019C8;
		  /* 821019C8h */ case   23:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821019C8h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821019C8h case   23:*/		return 0x821019CC;
		  /* 821019CCh */ case   24:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821019CCh case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821019CCh case   24:*/		return 0x821019D0;
		  /* 821019D0h */ case   25:  		/* lwzx R8, <#[R8 + R11]> */
		/* 821019D0h case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 821019D0h case   25:*/		return 0x821019D4;
		  /* 821019D4h */ case   26:  		/* lwzx R9, <#[R9 + R11]> */
		/* 821019D4h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821019D4h case   26:*/		return 0x821019D8;
		  /* 821019D8h */ case   27:  		/* lwz R8, <#[R8 + 48]> */
		/* 821019D8h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000030) );
		/* 821019D8h case   27:*/		return 0x821019DC;
		  /* 821019DCh */ case   28:  		/* lwz R9, <#[R9 + 48]> */
		/* 821019DCh case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000030) );
		/* 821019DCh case   28:*/		return 0x821019E0;
		  /* 821019E0h */ case   29:  		/* cmplw CR6, R9, R8 */
		/* 821019E0h case   29:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821019E0h case   29:*/		return 0x821019E4;
		  /* 821019E4h */ case   30:  		/* bc 4, CR6_EQ, 20 */
		/* 821019E4h case   30:*/		if ( !regs.CR[6].eq ) { return 0x821019F8;  }
		/* 821019E4h case   30:*/		return 0x821019E8;
		  /* 821019E8h */ case   31:  		/* addi R31, R31, 1 */
		/* 821019E8h case   31:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821019E8h case   31:*/		return 0x821019EC;
		  /* 821019ECh */ case   32:  		/* addi R10, R10, -1 */
		/* 821019ECh case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821019ECh case   32:*/		return 0x821019F0;
		  /* 821019F0h */ case   33:  		/* cmplw CR6, R31, R26 */
		/* 821019F0h case   33:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 821019F0h case   33:*/		return 0x821019F4;
		  /* 821019F4h */ case   34:  		/* bc 12, CR6_LT, -76 */
		/* 821019F4h case   34:*/		if ( regs.CR[6].lt ) { return 0x821019A8;  }
		/* 821019F4h case   34:*/		return 0x821019F8;
	}
	return 0x821019F8;
} // Block from 8210196Ch-821019F8h (35 instructions)

//////////////////////////////////////////////////////
// Block at 821019F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821019F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821019F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821019F8);
		  /* 821019F8h */ case    0:  		/* cmplw CR6, R31, R26 */
		/* 821019F8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 821019F8h case    0:*/		return 0x821019FC;
		  /* 821019FCh */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 821019FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82101A10;  }
		/* 821019FCh case    1:*/		return 0x82101A00;
		  /* 82101A00h */ case    2:  		/* lwz R5, <#[R27 + 12]> */
		/* 82101A00h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 82101A00h case    2:*/		return 0x82101A04;
		  /* 82101A04h */ case    3:  		/* addi R30, R30, 1 */
		/* 82101A04h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82101A04h case    3:*/		return 0x82101A08;
		  /* 82101A08h */ case    4:  		/* cmplw CR6, R30, R5 */
		/* 82101A08h case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R5);
		/* 82101A08h case    4:*/		return 0x82101A0C;
		  /* 82101A0Ch */ case    5:  		/* bc 12, CR6_LT, -264 */
		/* 82101A0Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x82101904;  }
		/* 82101A0Ch case    5:*/		return 0x82101A10;
	}
	return 0x82101A10;
} // Block from 821019F8h-82101A10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82101A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101A10);
		  /* 82101A10h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 82101A10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 82101A10h case    0:*/		return 0x82101A14;
		  /* 82101A14h */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 82101A14h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82101A14h case    1:*/		return 0x82101A18;
		  /* 82101A18h */ case    2:  		/* bc 12, CR6_EQ, -488 */
		/* 82101A18h case    2:*/		if ( regs.CR[6].eq ) { return 0x82101830;  }
		/* 82101A18h case    2:*/		return 0x82101A1C;
		  /* 82101A1Ch */ case    3:  		/* lwz R11, <#[R29 + 12]> */
		/* 82101A1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82101A1Ch case    3:*/		return 0x82101A20;
		  /* 82101A20h */ case    4:  		/* addi R28, R28, 1 */
		/* 82101A20h case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82101A20h case    4:*/		return 0x82101A24;
		  /* 82101A24h */ case    5:  		/* cmplw CR6, R28, R11 */
		/* 82101A24h case    5:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82101A24h case    5:*/		return 0x82101A28;
		  /* 82101A28h */ case    6:  		/* bc 12, CR6_LT, -308 */
		/* 82101A28h case    6:*/		if ( regs.CR[6].lt ) { return 0x821018F4;  }
		/* 82101A28h case    6:*/		return 0x82101A2C;
	}
	return 0x82101A2C;
} // Block from 82101A10h-82101A2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82101A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101A2C);
		  /* 82101A2Ch */ case    0:  		/* li R3, 1 */
		/* 82101A2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82101A2Ch case    0:*/		return 0x82101A30;
	}
	return 0x82101A30;
} // Block from 82101A2Ch-82101A30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82101A30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101A30);
		  /* 82101A30h */ case    0:  		/* addi R1, R1, 144 */
		/* 82101A30h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82101A30h case    0:*/		return 0x82101A34;
		  /* 82101A34h */ case    1:  		/* b -460696 */
		/* 82101A34h case    1:*/		return 0x8209129C;
		/* 82101A34h case    1:*/		return 0x82101A38;
	}
	return 0x82101A38;
} // Block from 82101A30h-82101A38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82101A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101A38);
		  /* 82101A38h */ case    0:  		/* mfspr R12, LR */
		/* 82101A38h case    0:*/		regs.R12 = regs.LR;
		/* 82101A38h case    0:*/		return 0x82101A3C;
		  /* 82101A3Ch */ case    1:  		/* bl -460772 */
		/* 82101A3Ch case    1:*/		regs.LR = 0x82101A40; return 0x82091258;
		/* 82101A3Ch case    1:*/		return 0x82101A40;
	}
	return 0x82101A40;
} // Block from 82101A38h-82101A40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82101A40h
// Function '?MutuallyExclusive@CProgram@D3DXShader@@AAAHIHIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101A40);
		  /* 82101A40h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 82101A40h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82101A40h case    0:*/		return 0x82101A44;
		  /* 82101A44h */ case    1:  		/* mr R31, R3 */
		/* 82101A44h case    1:*/		regs.R31 = regs.R3;
		/* 82101A44h case    1:*/		return 0x82101A48;
		  /* 82101A48h */ case    2:  		/* mr R30, R4 */
		/* 82101A48h case    2:*/		regs.R30 = regs.R4;
		/* 82101A48h case    2:*/		return 0x82101A4C;
		  /* 82101A4Ch */ case    3:  		/* mr R29, R5 */
		/* 82101A4Ch case    3:*/		regs.R29 = regs.R5;
		/* 82101A4Ch case    3:*/		return 0x82101A50;
		  /* 82101A50h */ case    4:  		/* bl -600 */
		/* 82101A50h case    4:*/		regs.LR = 0x82101A54; return 0x821017F8;
		/* 82101A50h case    4:*/		return 0x82101A54;
		  /* 82101A54h */ case    5:  		/* mr R28, R3 */
		/* 82101A54h case    5:*/		regs.R28 = regs.R3;
		/* 82101A54h case    5:*/		return 0x82101A58;
		  /* 82101A58h */ case    6:  		/* mr R5, R29 */
		/* 82101A58h case    6:*/		regs.R5 = regs.R29;
		/* 82101A58h case    6:*/		return 0x82101A5C;
		  /* 82101A5Ch */ case    7:  		/* mr R4, R30 */
		/* 82101A5Ch case    7:*/		regs.R4 = regs.R30;
		/* 82101A5Ch case    7:*/		return 0x82101A60;
		  /* 82101A60h */ case    8:  		/* mr R3, R31 */
		/* 82101A60h case    8:*/		regs.R3 = regs.R31;
		/* 82101A60h case    8:*/		return 0x82101A64;
		  /* 82101A64h */ case    9:  		/* bl -620 */
		/* 82101A64h case    9:*/		regs.LR = 0x82101A68; return 0x821017F8;
		/* 82101A64h case    9:*/		return 0x82101A68;
		  /* 82101A68h */ case   10:  		/* cmpwi CR6, R28, 0 */
		/* 82101A68h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82101A68h case   10:*/		return 0x82101A6C;
		  /* 82101A6Ch */ case   11:  		/* bc 12, CR6_EQ, 12 */
		/* 82101A6Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82101A78;  }
		/* 82101A6Ch case   11:*/		return 0x82101A70;
		  /* 82101A70h */ case   12:  		/* li R3, 1 */
		/* 82101A70h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82101A70h case   12:*/		return 0x82101A74;
		  /* 82101A74h */ case   13:  		/* b 64 */
		/* 82101A74h case   13:*/		return 0x82101AB4;
		/* 82101A74h case   13:*/		return 0x82101A78;
	}
	return 0x82101A78;
} // Block from 82101A40h-82101A78h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82101A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101A78);
		  /* 82101A78h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 82101A78h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82101A78h case    0:*/		return 0x82101A7C;
		  /* 82101A7Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82101A7Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82101A88;  }
		/* 82101A7Ch case    1:*/		return 0x82101A80;
		  /* 82101A80h */ case    2:  		/* li R3, -1 */
		/* 82101A80h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82101A80h case    2:*/		return 0x82101A84;
		  /* 82101A84h */ case    3:  		/* b 48 */
		/* 82101A84h case    3:*/		return 0x82101AB4;
		/* 82101A84h case    3:*/		return 0x82101A88;
	}
	return 0x82101A88;
} // Block from 82101A78h-82101A88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82101A88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101A88);
		  /* 82101A88h */ case    0:  		/* mr R5, R29 */
		/* 82101A88h case    0:*/		regs.R5 = regs.R29;
		/* 82101A88h case    0:*/		return 0x82101A8C;
		  /* 82101A8Ch */ case    1:  		/* mr R4, R30 */
		/* 82101A8Ch case    1:*/		regs.R4 = regs.R30;
		/* 82101A8Ch case    1:*/		return 0x82101A90;
		  /* 82101A90h */ case    2:  		/* mr R3, R31 */
		/* 82101A90h case    2:*/		regs.R3 = regs.R31;
		/* 82101A90h case    2:*/		return 0x82101A94;
		  /* 82101A94h */ case    3:  		/* bl -1220 */
		/* 82101A94h case    3:*/		regs.LR = 0x82101A98; return 0x821015D0;
		/* 82101A94h case    3:*/		return 0x82101A98;
		  /* 82101A98h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 82101A98h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82101A98h case    4:*/		return 0x82101A9C;
		  /* 82101A9Ch */ case    5:  		/* bc 4, CR0_EQ, 24 */
		/* 82101A9Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x82101AB4;  }
		/* 82101A9Ch case    5:*/		return 0x82101AA0;
		  /* 82101AA0h */ case    6:  		/* cmplw CR6, R31, R30 */
		/* 82101AA0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 82101AA0h case    6:*/		return 0x82101AA4;
		  /* 82101AA4h */ case    7:  		/* bc 12, CR6_LT, -36 */
		/* 82101AA4h case    7:*/		if ( regs.CR[6].lt ) { return 0x82101A80;  }
		/* 82101AA4h case    7:*/		return 0x82101AA8;
		  /* 82101AA8h */ case    8:  		/* subfc R11, R31, R30 */
		/* 82101AA8h case    8:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R31,regs.R30);
		/* 82101AA8h case    8:*/		return 0x82101AAC;
		  /* 82101AACh */ case    9:  		/* subfe R11, R11, R11 */
		/* 82101AACh case    9:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82101AACh case    9:*/		return 0x82101AB0;
		  /* 82101AB0h */ case   10:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 82101AB0h case   10:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 82101AB0h case   10:*/		return 0x82101AB4;
	}
	return 0x82101AB4;
} // Block from 82101A88h-82101AB4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82101AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101AB4);
		  /* 82101AB4h */ case    0:  		/* addi R1, R1, 128 */
		/* 82101AB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82101AB4h case    0:*/		return 0x82101AB8;
		  /* 82101AB8h */ case    1:  		/* b -460816 */
		/* 82101AB8h case    1:*/		return 0x820912A8;
		/* 82101AB8h case    1:*/		return 0x82101ABC;
		  /* 82101ABCh */ case    2:  		/* nop */
		/* 82101ABCh case    2:*/		cpu::op::nop();
		/* 82101ABCh case    2:*/		return 0x82101AC0;
	}
	return 0x82101AC0;
} // Block from 82101AB4h-82101AC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82101AC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101AC0);
		  /* 82101AC0h */ case    0:  		/* mfspr R12, LR */
		/* 82101AC0h case    0:*/		regs.R12 = regs.LR;
		/* 82101AC0h case    0:*/		return 0x82101AC4;
		  /* 82101AC4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82101AC4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82101AC4h case    1:*/		return 0x82101AC8;
		  /* 82101AC8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82101AC8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82101AC8h case    2:*/		return 0x82101ACC;
		  /* 82101ACCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82101ACCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82101ACCh case    3:*/		return 0x82101AD0;
		  /* 82101AD0h */ case    4:  		/* mr R31, R3 */
		/* 82101AD0h case    4:*/		regs.R31 = regs.R3;
		/* 82101AD0h case    4:*/		return 0x82101AD4;
		  /* 82101AD4h */ case    5:  		/* lwz R3, <#[R3 + 208]> */
		/* 82101AD4h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000000D0) );
		/* 82101AD4h case    5:*/		return 0x82101AD8;
		  /* 82101AD8h */ case    6:  		/* lis R11, -32254 */
		/* 82101AD8h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 82101AD8h case    6:*/		return 0x82101ADC;
		  /* 82101ADCh */ case    7:  		/* lis R4, 9345 */
		/* 82101ADCh case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82101ADCh case    7:*/		return 0x82101AE0;
		  /* 82101AE0h */ case    8:  		/* addi R11, R11, -14372 */
		/* 82101AE0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC7DC);
		/* 82101AE0h case    8:*/		return 0x82101AE4;
		  /* 82101AE4h */ case    9:  		/* stw R11, <#[R31]> */
		/* 82101AE4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82101AE4h case    9:*/		return 0x82101AE8;
		  /* 82101AE8h */ case   10:  		/* bl -497584 */
		/* 82101AE8h case   10:*/		regs.LR = 0x82101AEC; return 0x82088338;
		/* 82101AE8h case   10:*/		return 0x82101AEC;
		  /* 82101AECh */ case   11:  		/* lwz R3, <#[R31 + 228]> */
		/* 82101AECh case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000E4) );
		/* 82101AECh case   11:*/		return 0x82101AF0;
		  /* 82101AF0h */ case   12:  		/* cmplwi CR6, R3, 0 */
		/* 82101AF0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82101AF0h case   12:*/		return 0x82101AF4;
		  /* 82101AF4h */ case   13:  		/* bc 12, CR6_EQ, 24 */
		/* 82101AF4h case   13:*/		if ( regs.CR[6].eq ) { return 0x82101B0C;  }
		/* 82101AF4h case   13:*/		return 0x82101AF8;
		  /* 82101AF8h */ case   14:  		/* lwz R11, <#[R3]> */
		/* 82101AF8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82101AF8h case   14:*/		return 0x82101AFC;
		  /* 82101AFCh */ case   15:  		/* li R4, 1 */
		/* 82101AFCh case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82101AFCh case   15:*/		return 0x82101B00;
		  /* 82101B00h */ case   16:  		/* lwz R11, <#[R11]> */
		/* 82101B00h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82101B00h case   16:*/		return 0x82101B04;
		  /* 82101B04h */ case   17:  		/* mtspr CTR, R11 */
		/* 82101B04h case   17:*/		regs.CTR = regs.R11;
		/* 82101B04h case   17:*/		return 0x82101B08;
		  /* 82101B08h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 82101B08h case   18:*/		if ( 1 ) { regs.LR = 0x82101B0C; return (uint32)regs.CTR; }
		/* 82101B08h case   18:*/		return 0x82101B0C;
	}
	return 0x82101B0C;
} // Block from 82101AC0h-82101B0Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82101B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101B0C);
		  /* 82101B0Ch */ case    0:  		/* mr R3, R31 */
		/* 82101B0Ch case    0:*/		regs.R3 = regs.R31;
		/* 82101B0Ch case    0:*/		return 0x82101B10;
		  /* 82101B10h */ case    1:  		/* bl -17960 */
		/* 82101B10h case    1:*/		regs.LR = 0x82101B14; return 0x820FD4E8;
		/* 82101B10h case    1:*/		return 0x82101B14;
		  /* 82101B14h */ case    2:  		/* addi R1, R1, 96 */
		/* 82101B14h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82101B14h case    2:*/		return 0x82101B18;
		  /* 82101B18h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82101B18h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82101B18h case    3:*/		return 0x82101B1C;
		  /* 82101B1Ch */ case    4:  		/* mtspr LR, R12 */
		/* 82101B1Ch case    4:*/		regs.LR = regs.R12;
		/* 82101B1Ch case    4:*/		return 0x82101B20;
		  /* 82101B20h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82101B20h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82101B20h case    5:*/		return 0x82101B24;
		  /* 82101B24h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82101B24h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82101B24h case    6:*/		return 0x82101B28;
	}
	return 0x82101B28;
} // Block from 82101B0Ch-82101B28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82101B28h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101B28);
		  /* 82101B28h */ case    0:  		/* mfspr R12, LR */
		/* 82101B28h case    0:*/		regs.R12 = regs.LR;
		/* 82101B28h case    0:*/		return 0x82101B2C;
		  /* 82101B2Ch */ case    1:  		/* bl -461012 */
		/* 82101B2Ch case    1:*/		regs.LR = 0x82101B30; return 0x82091258;
		/* 82101B2Ch case    1:*/		return 0x82101B30;
	}
	return 0x82101B30;
} // Block from 82101B28h-82101B30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82101B30h
// Function '?CompactPool_Map@CProgram@D3DXShader@@AAAIPAU_D3DXCP_DATA@2@III@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101B30);
		  /* 82101B30h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 82101B30h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82101B30h case    0:*/		return 0x82101B34;
		  /* 82101B34h */ case    1:  		/* mr R28, R3 */
		/* 82101B34h case    1:*/		regs.R28 = regs.R3;
		/* 82101B34h case    1:*/		return 0x82101B38;
		  /* 82101B38h */ case    2:  		/* mr R30, R4 */
		/* 82101B38h case    2:*/		regs.R30 = regs.R4;
		/* 82101B38h case    2:*/		return 0x82101B3C;
		  /* 82101B3Ch */ case    3:  		/* li R31, 0 */
		/* 82101B3Ch case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82101B3Ch case    3:*/		return 0x82101B40;
		  /* 82101B40h */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 82101B40h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82101B40h case    4:*/		return 0x82101B44;
		  /* 82101B44h */ case    5:  		/* bc 12, CR6_EQ, 88 */
		/* 82101B44h case    5:*/		if ( regs.CR[6].eq ) { return 0x82101B9C;  }
		/* 82101B44h case    5:*/		return 0x82101B48;
		  /* 82101B48h */ case    6:  		/* mr R11, R4 */
		/* 82101B48h case    6:*/		regs.R11 = regs.R4;
		/* 82101B48h case    6:*/		return 0x82101B4C;
		  /* 82101B4Ch */ case    7:  		/* lbz R10, <#[R11]> */
		/* 82101B4Ch case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82101B4Ch case    7:*/		return 0x82101B50;
		  /* 82101B50h */ case    8:  		/* addi R11, R11, 1 */
		/* 82101B50h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82101B50h case    8:*/		return 0x82101B54;
		  /* 82101B54h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 82101B54h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82101B54h case    9:*/		return 0x82101B58;
		  /* 82101B58h */ case   10:  		/* bc 4, CR6_EQ, -12 */
		/* 82101B58h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82101B4C;  }
		/* 82101B58h case   10:*/		return 0x82101B5C;
		  /* 82101B5Ch */ case   11:  		/* subf R11, R30, R11 */
		/* 82101B5Ch case   11:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 82101B5Ch case   11:*/		return 0x82101B60;
		  /* 82101B60h */ case   12:  		/* lis R4, 9345 */
		/* 82101B60h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82101B60h case   12:*/		return 0x82101B64;
		  /* 82101B64h */ case   13:  		/* addi R11, R11, -1 */
		/* 82101B64h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82101B64h case   13:*/		return 0x82101B68;
		  /* 82101B68h */ case   14:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82101B68h case   14:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82101B68h case   14:*/		return 0x82101B6C;
		  /* 82101B6Ch */ case   15:  		/* addi R29, R11, 1 */
		/* 82101B6Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1);
		/* 82101B6Ch case   15:*/		return 0x82101B70;
		  /* 82101B70h */ case   16:  		/* mr R3, R29 */
		/* 82101B70h case   16:*/		regs.R3 = regs.R29;
		/* 82101B70h case   16:*/		return 0x82101B74;
		  /* 82101B74h */ case   17:  		/* bl -498036 */
		/* 82101B74h case   17:*/		regs.LR = 0x82101B78; return 0x82088200;
		/* 82101B74h case   17:*/		return 0x82101B78;
		  /* 82101B78h */ case   18:  		/* or. R31, R3, R3 */
		/* 82101B78h case   18:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82101B78h case   18:*/		return 0x82101B7C;
		  /* 82101B7Ch */ case   19:  		/* bc 4, CR0_EQ, 16 */
		/* 82101B7Ch case   19:*/		if ( !regs.CR[0].eq ) { return 0x82101B8C;  }
		/* 82101B7Ch case   19:*/		return 0x82101B80;
		  /* 82101B80h */ case   20:  		/* lis R3, -32761 */
		/* 82101B80h case   20:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82101B80h case   20:*/		return 0x82101B84;
		  /* 82101B84h */ case   21:  		/* ori R3, R3, 14 */
		/* 82101B84h case   21:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82101B84h case   21:*/		return 0x82101B88;
		  /* 82101B88h */ case   22:  		/* b 40 */
		/* 82101B88h case   22:*/		return 0x82101BB0;
		/* 82101B88h case   22:*/		return 0x82101B8C;
	}
	return 0x82101B8C;
} // Block from 82101B30h-82101B8Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 82101B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101B8C);
		  /* 82101B8Ch */ case    0:  		/* mr R5, R29 */
		/* 82101B8Ch case    0:*/		regs.R5 = regs.R29;
		/* 82101B8Ch case    0:*/		return 0x82101B90;
		  /* 82101B90h */ case    1:  		/* mr R4, R30 */
		/* 82101B90h case    1:*/		regs.R4 = regs.R30;
		/* 82101B90h case    1:*/		return 0x82101B94;
		  /* 82101B94h */ case    2:  		/* mr R3, R31 */
		/* 82101B94h case    2:*/		regs.R3 = regs.R31;
		/* 82101B94h case    2:*/		return 0x82101B98;
		  /* 82101B98h */ case    3:  		/* bl -459240 */
		/* 82101B98h case    3:*/		regs.LR = 0x82101B9C; return 0x820919B0;
		/* 82101B98h case    3:*/		return 0x82101B9C;
	}
	return 0x82101B9C;
} // Block from 82101B8Ch-82101B9Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82101B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101B9C);
		  /* 82101B9Ch */ case    0:  		/* lis R4, 9345 */
		/* 82101B9Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82101B9Ch case    0:*/		return 0x82101BA0;
		  /* 82101BA0h */ case    1:  		/* lwz R3, <#[R28 + 208]> */
		/* 82101BA0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x000000D0) );
		/* 82101BA0h case    1:*/		return 0x82101BA4;
		  /* 82101BA4h */ case    2:  		/* bl -497772 */
		/* 82101BA4h case    2:*/		regs.LR = 0x82101BA8; return 0x82088338;
		/* 82101BA4h case    2:*/		return 0x82101BA8;
		  /* 82101BA8h */ case    3:  		/* stw R31, <#[R28 + 208]> */
		/* 82101BA8h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x000000D0) );
		/* 82101BA8h case    3:*/		return 0x82101BAC;
		  /* 82101BACh */ case    4:  		/* li R3, 0 */
		/* 82101BACh case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82101BACh case    4:*/		return 0x82101BB0;
	}
	return 0x82101BB0;
} // Block from 82101B9Ch-82101BB0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82101BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101BB0);
		  /* 82101BB0h */ case    0:  		/* addi R1, R1, 128 */
		/* 82101BB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82101BB0h case    0:*/		return 0x82101BB4;
		  /* 82101BB4h */ case    1:  		/* b -461068 */
		/* 82101BB4h case    1:*/		return 0x820912A8;
		/* 82101BB4h case    1:*/		return 0x82101BB8;
	}
	return 0x82101BB8;
} // Block from 82101BB0h-82101BB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82101BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101BB8);
		  /* 82101BB8h */ case    0:  		/* mfspr R12, LR */
		/* 82101BB8h case    0:*/		regs.R12 = regs.LR;
		/* 82101BB8h case    0:*/		return 0x82101BBC;
		  /* 82101BBCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82101BBCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82101BBCh case    1:*/		return 0x82101BC0;
		  /* 82101BC0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82101BC0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82101BC0h case    2:*/		return 0x82101BC4;
		  /* 82101BC4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82101BC4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82101BC4h case    3:*/		return 0x82101BC8;
		  /* 82101BC8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82101BC8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82101BC8h case    4:*/		return 0x82101BCC;
		  /* 82101BCCh */ case    5:  		/* mr R30, R3 */
		/* 82101BCCh case    5:*/		regs.R30 = regs.R3;
		/* 82101BCCh case    5:*/		return 0x82101BD0;
		  /* 82101BD0h */ case    6:  		/* b 108 */
		/* 82101BD0h case    6:*/		return 0x82101C3C;
		/* 82101BD0h case    6:*/		return 0x82101BD4;
		  /* 82101BD4h */ case    7:  		/* cmpwi CR6, R4, -1 */
		/* 82101BD4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 82101BD4h case    7:*/		return 0x82101BD8;
		  /* 82101BD8h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 82101BD8h case    8:*/		if ( regs.CR[6].eq ) { return 0x82101BF8;  }
		/* 82101BD8h case    8:*/		return 0x82101BDC;
		  /* 82101BDCh */ case    9:  		/* lwz R11, <#[R30 + 20]> */
		/* 82101BDCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82101BDCh case    9:*/		return 0x82101BE0;
		  /* 82101BE0h */ case   10:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 82101BE0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 82101BE0h case   10:*/		return 0x82101BE4;
		  /* 82101BE4h */ case   11:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82101BE4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82101BE4h case   11:*/		return 0x82101BE8;
		  /* 82101BE8h */ case   12:  		/* lwz R11, <#[R11 + 56]> */
		/* 82101BE8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000038) );
		/* 82101BE8h case   12:*/		return 0x82101BEC;
		  /* 82101BECh */ case   13:  		/* cmpwi CR6, R11, -1 */
		/* 82101BECh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82101BECh case   13:*/		return 0x82101BF0;
		  /* 82101BF0h */ case   14:  		/* bc 12, CR6_EQ, 8 */
		/* 82101BF0h case   14:*/		if ( regs.CR[6].eq ) { return 0x82101BF8;  }
		/* 82101BF0h case   14:*/		return 0x82101BF4;
		  /* 82101BF4h */ case   15:  		/* mr R4, R11 */
		/* 82101BF4h case   15:*/		regs.R4 = regs.R11;
		/* 82101BF4h case   15:*/		return 0x82101BF8;
	}
	return 0x82101BF8;
} // Block from 82101BB8h-82101BF8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82101BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101BF8);
		  /* 82101BF8h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 82101BF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82101BF8h case    0:*/		return 0x82101BFC;
		  /* 82101BFCh */ case    1:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 82101BFCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 82101BFCh case    1:*/		return 0x82101C00;
		  /* 82101C00h */ case    2:  		/* lwzx R31, <#[R10 + R11]> */
		/* 82101C00h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82101C00h case    2:*/		return 0x82101C04;
		  /* 82101C04h */ case    3:  		/* lwz R11, <#[R31 + 84]> */
		/* 82101C04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 82101C04h case    3:*/		return 0x82101C08;
		  /* 82101C08h */ case    4:  		/* cmplw CR6, R11, R5 */
		/* 82101C08h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 82101C08h case    4:*/		return 0x82101C0C;
		  /* 82101C0Ch */ case    5:  		/* bc 4, CR6_LT, 8 */
		/* 82101C0Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x82101C14;  }
		/* 82101C0Ch case    5:*/		return 0x82101C10;
		  /* 82101C10h */ case    6:  		/* stw R5, <#[R31 + 84]> */
		/* 82101C10h case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x00000054) );
		/* 82101C10h case    6:*/		return 0x82101C14;
	}
	return 0x82101C14;
} // Block from 82101BF8h-82101C14h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82101C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101C14);
		  /* 82101C14h */ case    0:  		/* lwz R4, <#[R31 + 8]> */
		/* 82101C14h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82101C14h case    0:*/		return 0x82101C18;
		  /* 82101C18h */ case    1:  		/* cmpwi CR6, R4, -1 */
		/* 82101C18h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 82101C18h case    1:*/		return 0x82101C1C;
		  /* 82101C1Ch */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 82101C1Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82101C2C;  }
		/* 82101C1Ch case    2:*/		return 0x82101C20;
		  /* 82101C20h */ case    3:  		/* mr R3, R30 */
		/* 82101C20h case    3:*/		regs.R3 = regs.R30;
		/* 82101C20h case    3:*/		return 0x82101C24;
		  /* 82101C24h */ case    4:  		/* lwz R5, <#[R31 + 84]> */
		/* 82101C24h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000054) );
		/* 82101C24h case    4:*/		return 0x82101C28;
		  /* 82101C28h */ case    5:  		/* bl -112 */
		/* 82101C28h case    5:*/		regs.LR = 0x82101C2C; return 0x82101BB8;
		/* 82101C28h case    5:*/		return 0x82101C2C;
	}
	return 0x82101C2C;
} // Block from 82101C14h-82101C2Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82101C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101C2C);
		  /* 82101C2Ch */ case    0:  		/* lwz R4, <#[R31 + 20]> */
		/* 82101C2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 82101C2Ch case    0:*/		return 0x82101C30;
		  /* 82101C30h */ case    1:  		/* cmpwi CR6, R4, -1 */
		/* 82101C30h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 82101C30h case    1:*/		return 0x82101C34;
		  /* 82101C34h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 82101C34h case    2:*/		if ( regs.CR[6].eq ) { return 0x82101C44;  }
		/* 82101C34h case    2:*/		return 0x82101C38;
		  /* 82101C38h */ case    3:  		/* lwz R5, <#[R31 + 84]> */
		/* 82101C38h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000054) );
		/* 82101C38h case    3:*/		return 0x82101C3C;
	}
	return 0x82101C3C;
} // Block from 82101C2Ch-82101C3Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82101C3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101C3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101C3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101C3C);
		  /* 82101C3Ch */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82101C3Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82101C3Ch case    0:*/		return 0x82101C40;
		  /* 82101C40h */ case    1:  		/* bc 4, CR6_EQ, -108 */
		/* 82101C40h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82101BD4;  }
		/* 82101C40h case    1:*/		return 0x82101C44;
	}
	return 0x82101C44;
} // Block from 82101C3Ch-82101C44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82101C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101C44);
		  /* 82101C44h */ case    0:  		/* addi R1, R1, 112 */
		/* 82101C44h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82101C44h case    0:*/		return 0x82101C48;
		  /* 82101C48h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82101C48h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82101C48h case    1:*/		return 0x82101C4C;
		  /* 82101C4Ch */ case    2:  		/* mtspr LR, R12 */
		/* 82101C4Ch case    2:*/		regs.LR = regs.R12;
		/* 82101C4Ch case    2:*/		return 0x82101C50;
		  /* 82101C50h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82101C50h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82101C50h case    3:*/		return 0x82101C54;
		  /* 82101C54h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82101C54h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82101C54h case    4:*/		return 0x82101C58;
		  /* 82101C58h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82101C58h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82101C58h case    5:*/		return 0x82101C5C;
	}
	return 0x82101C5C;
} // Block from 82101C44h-82101C5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82101C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101C5C);
		  /* 82101C5Ch */ case    0:  		/* nop */
		/* 82101C5Ch case    0:*/		cpu::op::nop();
		/* 82101C5Ch case    0:*/		return 0x82101C60;
	}
	return 0x82101C60;
} // Block from 82101C5Ch-82101C60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82101C60h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101C60);
		  /* 82101C60h */ case    0:  		/* mfspr R12, LR */
		/* 82101C60h case    0:*/		regs.R12 = regs.LR;
		/* 82101C60h case    0:*/		return 0x82101C64;
		  /* 82101C64h */ case    1:  		/* bl -461332 */
		/* 82101C64h case    1:*/		regs.LR = 0x82101C68; return 0x82091250;
		/* 82101C64h case    1:*/		return 0x82101C68;
		  /* 82101C68h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82101C68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82101C68h case    2:*/		return 0x82101C6C;
		  /* 82101C6Ch */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 82101C6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82101C6Ch case    3:*/		return 0x82101C70;
	}
	return 0x82101C70;
} // Block from 82101C60h-82101C70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82101C70h
// Function '?SwizzleParameter@CProgram@D3DXShader@@AAAJPAI0IH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101C70);
		  /* 82101C70h */ case    0:  		/* mr R31, R3 */
		/* 82101C70h case    0:*/		regs.R31 = regs.R3;
		/* 82101C70h case    0:*/		return 0x82101C74;
		  /* 82101C74h */ case    1:  		/* li R26, 0 */
		/* 82101C74h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82101C74h case    1:*/		return 0x82101C78;
		  /* 82101C78h */ case    2:  		/* li R30, 0 */
		/* 82101C78h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82101C78h case    2:*/		return 0x82101C7C;
		  /* 82101C7Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82101C7Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82101C7Ch case    3:*/		return 0x82101C80;
		  /* 82101C80h */ case    4:  		/* bc 4, CR6_GT, 84 */
		/* 82101C80h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82101CD4;  }
		/* 82101C80h case    4:*/		return 0x82101C84;
		  /* 82101C84h */ case    5:  		/* li R27, 0 */
		/* 82101C84h case    5:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82101C84h case    5:*/		return 0x82101C88;
		  /* 82101C88h */ case    6:  		/* li R28, 0 */
		/* 82101C88h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82101C88h case    6:*/		return 0x82101C8C;
		  /* 82101C8Ch */ case    7:  		/* lwz R11, <#[R31 + 24]> */
		/* 82101C8Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82101C8Ch case    7:*/		return 0x82101C90;
		  /* 82101C90h */ case    8:  		/* lwzx R29, <#[R28 + R11]> */
		/* 82101C90h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 82101C90h case    8:*/		return 0x82101C94;
		  /* 82101C94h */ case    9:  		/* lwz R10, <#[R29]> */
		/* 82101C94h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82101C94h case    9:*/		return 0x82101C98;
		  /* 82101C98h */ case   10:  		/* rlwinm. R10, R10, 0, 0, 11 */
		/* 82101C98h case   10:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82101C98h case   10:*/		return 0x82101C9C;
		  /* 82101C9Ch */ case   11:  		/* bc 4, CR0_EQ, 24 */
		/* 82101C9Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x82101CB4;  }
		/* 82101C9Ch case   11:*/		return 0x82101CA0;
		  /* 82101CA0h */ case   12:  		/* mr R3, R29 */
		/* 82101CA0h case   12:*/		regs.R3 = regs.R29;
		/* 82101CA0h case   12:*/		return 0x82101CA4;
		  /* 82101CA4h */ case   13:  		/* bl 1160988 */
		/* 82101CA4h case   13:*/		regs.LR = 0x82101CA8; return 0x8221D3C0;
		/* 82101CA4h case   13:*/		return 0x82101CA8;
		  /* 82101CA8h */ case   14:  		/* mr R3, R29 */
		/* 82101CA8h case   14:*/		regs.R3 = regs.R29;
		/* 82101CA8h case   14:*/		return 0x82101CAC;
		  /* 82101CACh */ case   15:  		/* bl -22204 */
		/* 82101CACh case   15:*/		regs.LR = 0x82101CB0; return 0x820FC5F0;
		/* 82101CACh case   15:*/		return 0x82101CB0;
		  /* 82101CB0h */ case   16:  		/* b 16 */
		/* 82101CB0h case   16:*/		return 0x82101CC0;
		/* 82101CB0h case   16:*/		return 0x82101CB4;
	}
	return 0x82101CB4;
} // Block from 82101C70h-82101CB4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82101CB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101CB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101CB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101CB4);
		  /* 82101CB4h */ case    0:  		/* stwx R29, <#[R27 + R11]> */
		/* 82101CB4h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 82101CB4h case    0:*/		return 0x82101CB8;
		  /* 82101CB8h */ case    1:  		/* addi R30, R30, 1 */
		/* 82101CB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82101CB8h case    1:*/		return 0x82101CBC;
		  /* 82101CBCh */ case    2:  		/* addi R27, R27, 4 */
		/* 82101CBCh case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 82101CBCh case    2:*/		return 0x82101CC0;
	}
	return 0x82101CC0;
} // Block from 82101CB4h-82101CC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82101CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101CC0);
		  /* 82101CC0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82101CC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82101CC0h case    0:*/		return 0x82101CC4;
		  /* 82101CC4h */ case    1:  		/* addi R26, R26, 1 */
		/* 82101CC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82101CC4h case    1:*/		return 0x82101CC8;
		  /* 82101CC8h */ case    2:  		/* addi R28, R28, 4 */
		/* 82101CC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82101CC8h case    2:*/		return 0x82101CCC;
		  /* 82101CCCh */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 82101CCCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82101CCCh case    3:*/		return 0x82101CD0;
		  /* 82101CD0h */ case    4:  		/* bc 12, CR6_LT, -68 */
		/* 82101CD0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82101C8C;  }
		/* 82101CD0h case    4:*/		return 0x82101CD4;
	}
	return 0x82101CD4;
} // Block from 82101CC0h-82101CD4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82101CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101CD4);
		  /* 82101CD4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82101CD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82101CD4h case    0:*/		return 0x82101CD8;
		  /* 82101CD8h */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 82101CD8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82101CD8h case    1:*/		return 0x82101CDC;
		  /* 82101CDCh */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82101CDCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x82101CE8;  }
		/* 82101CDCh case    2:*/		return 0x82101CE0;
		  /* 82101CE0h */ case    3:  		/* li R3, 1 */
		/* 82101CE0h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82101CE0h case    3:*/		return 0x82101CE4;
		  /* 82101CE4h */ case    4:  		/* b 40 */
		/* 82101CE4h case    4:*/		return 0x82101D0C;
		/* 82101CE4h case    4:*/		return 0x82101CE8;
	}
	return 0x82101CE8;
} // Block from 82101CD4h-82101CE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82101CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101CE8);
		  /* 82101CE8h */ case    0:  		/* subf R9, R30, R11 */
		/* 82101CE8h case    0:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R30,regs.R11);
		/* 82101CE8h case    0:*/		return 0x82101CEC;
		  /* 82101CECh */ case    1:  		/* lwz R10, <#[R31 + 24]> */
		/* 82101CECh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82101CECh case    1:*/		return 0x82101CF0;
		  /* 82101CF0h */ case    2:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 82101CF0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 82101CF0h case    2:*/		return 0x82101CF4;
		  /* 82101CF4h */ case    3:  		/* rlwinm R5, R9, 2, 0, 29 */
		/* 82101CF4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R9);
		/* 82101CF4h case    3:*/		return 0x82101CF8;
		  /* 82101CF8h */ case    4:  		/* li R4, 0 */
		/* 82101CF8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82101CF8h case    4:*/		return 0x82101CFC;
		  /* 82101CFCh */ case    5:  		/* add R3, R11, R10 */
		/* 82101CFCh case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82101CFCh case    5:*/		return 0x82101D00;
		  /* 82101D00h */ case    6:  		/* bl -461248 */
		/* 82101D00h case    6:*/		regs.LR = 0x82101D04; return 0x82091340;
		/* 82101D00h case    6:*/		return 0x82101D04;
		  /* 82101D04h */ case    7:  		/* stw R30, <#[R31 + 12]> */
		/* 82101D04h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 82101D04h case    7:*/		return 0x82101D08;
		  /* 82101D08h */ case    8:  		/* li R3, 0 */
		/* 82101D08h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82101D08h case    8:*/		return 0x82101D0C;
	}
	return 0x82101D0C;
} // Block from 82101CE8h-82101D0Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82101D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101D0C);
		  /* 82101D0Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 82101D0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82101D0Ch case    0:*/		return 0x82101D10;
		  /* 82101D10h */ case    1:  		/* b -461424 */
		/* 82101D10h case    1:*/		return 0x820912A0;
		/* 82101D10h case    1:*/		return 0x82101D14;
		  /* 82101D14h */ case    2:  		/* nop */
		/* 82101D14h case    2:*/		cpu::op::nop();
		/* 82101D14h case    2:*/		return 0x82101D18;
	}
	return 0x82101D18;
} // Block from 82101D0Ch-82101D18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82101D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101D18);
		  /* 82101D18h */ case    0:  		/* mfspr R12, LR */
		/* 82101D18h case    0:*/		regs.R12 = regs.LR;
		/* 82101D18h case    0:*/		return 0x82101D1C;
		  /* 82101D1Ch */ case    1:  		/* bl -461508 */
		/* 82101D1Ch case    1:*/		regs.LR = 0x82101D20; return 0x82091258;
		/* 82101D1Ch case    1:*/		return 0x82101D20;
		  /* 82101D20h */ case    2:  		/* lwz R11, <#[R3 + 8]> */
		/* 82101D20h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82101D20h case    2:*/		return 0x82101D24;
		  /* 82101D24h */ case    3:  		/* li R7, 0 */
		/* 82101D24h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82101D24h case    3:*/		return 0x82101D28;
		  /* 82101D28h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82101D28h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82101D28h case    4:*/		return 0x82101D2C;
		  /* 82101D2Ch */ case    5:  		/* bc 4, CR6_GT, 100 */
		/* 82101D2Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x82101D90;  }
		/* 82101D2Ch case    5:*/		return 0x82101D30;
		  /* 82101D30h */ case    6:  		/* li R8, 0 */
		/* 82101D30h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82101D30h case    6:*/		return 0x82101D34;
		  /* 82101D34h */ case    7:  		/* lwz R11, <#[R3 + 20]> */
		/* 82101D34h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82101D34h case    7:*/		return 0x82101D38;
		  /* 82101D38h */ case    8:  		/* lwz R10, <#[R3 + 16]> */
		/* 82101D38h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82101D38h case    8:*/		return 0x82101D3C;
		  /* 82101D3Ch */ case    9:  		/* lwzx R11, <#[R8 + R11]> */
		/* 82101D3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82101D3Ch case    9:*/		return 0x82101D40;
		  /* 82101D40h */ case   10:  		/* lwz R9, <#[R11 + 4]> */
		/* 82101D40h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82101D40h case   10:*/		return 0x82101D44;
		  /* 82101D44h */ case   11:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82101D44h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82101D44h case   11:*/		return 0x82101D48;
		  /* 82101D48h */ case   12:  		/* lwzx R9, <#[R9 + R10]> */
		/* 82101D48h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82101D48h case   12:*/		return 0x82101D4C;
		  /* 82101D4Ch */ case   13:  		/* lwz R10, <#[R9 + 4]> */
		/* 82101D4Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 82101D4Ch case   13:*/		return 0x82101D50;
		  /* 82101D50h */ case   14:  		/* rlwinm. R6, R10, 0, 26, 27 */
		/* 82101D50h case   14:*/		cpu::op::rlwinm<1,0,26,27>(regs,&regs.R6,regs.R10);
		/* 82101D50h case   14:*/		return 0x82101D54;
		  /* 82101D54h */ case   15:  		/* bc 12, CR0_EQ, 20 */
		/* 82101D54h case   15:*/		if ( regs.CR[0].eq ) { return 0x82101D68;  }
		/* 82101D54h case   15:*/		return 0x82101D58;
		  /* 82101D58h */ case   16:  		/* rlwinm. R10, R10, 0, 22, 22 */
		/* 82101D58h case   16:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R10,regs.R10);
		/* 82101D58h case   16:*/		return 0x82101D5C;
		  /* 82101D5Ch */ case   17:  		/* bc 4, CR0_EQ, 12 */
		/* 82101D5Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x82101D68;  }
		/* 82101D5Ch case   17:*/		return 0x82101D60;
		  /* 82101D60h */ case   18:  		/* lwz R10, <#[R3 + 116]> */
		/* 82101D60h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000074) );
		/* 82101D60h case   18:*/		return 0x82101D64;
		  /* 82101D64h */ case   19:  		/* stw R10, <#[R11 + 4]> */
		/* 82101D64h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82101D64h case   19:*/		return 0x82101D68;
	}
	return 0x82101D68;
} // Block from 82101D18h-82101D68h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82101D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101D68);
		  /* 82101D68h */ case    0:  		/* lwz R10, <#[R9 + 4]> */
		/* 82101D68h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 82101D68h case    0:*/		return 0x82101D6C;
		  /* 82101D6Ch */ case    1:  		/* rlwinm. R10, R10, 0, 29, 29 */
		/* 82101D6Ch case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R10);
		/* 82101D6Ch case    1:*/		return 0x82101D70;
		  /* 82101D70h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82101D70h case    2:*/		if ( regs.CR[0].eq ) { return 0x82101D7C;  }
		/* 82101D70h case    2:*/		return 0x82101D74;
		  /* 82101D74h */ case    3:  		/* lwz R10, <#[R3 + 136]> */
		/* 82101D74h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000088) );
		/* 82101D74h case    3:*/		return 0x82101D78;
		  /* 82101D78h */ case    4:  		/* stw R10, <#[R11 + 4]> */
		/* 82101D78h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82101D78h case    4:*/		return 0x82101D7C;
	}
	return 0x82101D7C;
} // Block from 82101D68h-82101D7Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82101D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101D7C);
		  /* 82101D7Ch */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 82101D7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82101D7Ch case    0:*/		return 0x82101D80;
		  /* 82101D80h */ case    1:  		/* addi R7, R7, 1 */
		/* 82101D80h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82101D80h case    1:*/		return 0x82101D84;
		  /* 82101D84h */ case    2:  		/* addi R8, R8, 4 */
		/* 82101D84h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82101D84h case    2:*/		return 0x82101D88;
		  /* 82101D88h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 82101D88h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82101D88h case    3:*/		return 0x82101D8C;
		  /* 82101D8Ch */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 82101D8Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82101D34;  }
		/* 82101D8Ch case    4:*/		return 0x82101D90;
	}
	return 0x82101D90;
} // Block from 82101D7Ch-82101D90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82101D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101D90);
		  /* 82101D90h */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 82101D90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82101D90h case    0:*/		return 0x82101D94;
		  /* 82101D94h */ case    1:  		/* li R29, 0 */
		/* 82101D94h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82101D94h case    1:*/		return 0x82101D98;
		  /* 82101D98h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82101D98h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82101D98h case    2:*/		return 0x82101D9C;
		  /* 82101D9Ch */ case    3:  		/* bc 4, CR6_GT, 588 */
		/* 82101D9Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x82101FE8;  }
		/* 82101D9Ch case    3:*/		return 0x82101DA0;
		  /* 82101DA0h */ case    4:  		/* li R30, 0 */
		/* 82101DA0h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82101DA0h case    4:*/		return 0x82101DA4;
		  /* 82101DA4h */ case    5:  		/* lwz R11, <#[R3 + 24]> */
		/* 82101DA4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82101DA4h case    5:*/		return 0x82101DA8;
	}
	return 0x82101DA8;
} // Block from 82101D90h-82101DA8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82101DA8h
// Function '?ReadWriteInfo_ReadInfo@CProgram@D3DXShader@@AAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101DA8);
		  /* 82101DA8h */ case    0:  		/* lwzx R11, <#[R30 + R11]> */
		/* 82101DA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82101DA8h case    0:*/		return 0x82101DAC;
		  /* 82101DACh */ case    1:  		/* lwz R31, <#[R11]> */
		/* 82101DACh case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82101DACh case    1:*/		return 0x82101DB0;
		  /* 82101DB0h */ case    2:  		/* rlwinm. R10, R31, 0, 0, 11 */
		/* 82101DB0h case    2:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R31);
		/* 82101DB0h case    2:*/		return 0x82101DB4;
		  /* 82101DB4h */ case    3:  		/* bc 12, CR0_EQ, 544 */
		/* 82101DB4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82101FD4;  }
		/* 82101DB4h case    3:*/		return 0x82101DB8;
		  /* 82101DB8h */ case    4:  		/* lwz R5, <#[R11 + 12]> */
		/* 82101DB8h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 82101DB8h case    4:*/		return 0x82101DBC;
		  /* 82101DBCh */ case    5:  		/* li R4, 0 */
		/* 82101DBCh case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82101DBCh case    5:*/		return 0x82101DC0;
		  /* 82101DC0h */ case    6:  		/* li R6, 0 */
		/* 82101DC0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82101DC0h case    6:*/		return 0x82101DC4;
		  /* 82101DC4h */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 82101DC4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82101DC4h case    7:*/		return 0x82101DC8;
		  /* 82101DC8h */ case    8:  		/* bc 12, CR6_EQ, 64 */
		/* 82101DC8h case    8:*/		if ( regs.CR[6].eq ) { return 0x82101E08;  }
		/* 82101DC8h case    8:*/		return 0x82101DCC;
		  /* 82101DCCh */ case    9:  		/* lwz R9, <#[R11 + 16]> */
		/* 82101DCCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 82101DCCh case    9:*/		return 0x82101DD0;
		  /* 82101DD0h */ case   10:  		/* li R10, 0 */
		/* 82101DD0h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82101DD0h case   10:*/		return 0x82101DD4;
		  /* 82101DD4h */ case   11:  		/* lwz R8, <#[R3 + 20]> */
		/* 82101DD4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 82101DD4h case   11:*/		return 0x82101DD8;
		  /* 82101DD8h */ case   12:  		/* rlwinm R7, R5, 0, 0, 31 */
		/* 82101DD8h case   12:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R7,regs.R5);
		/* 82101DD8h case   12:*/		return 0x82101DDC;
		  /* 82101DDCh */ case   13:  		/* lwzx R28, <#[R10 + R9]> */
		/* 82101DDCh case   13:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82101DDCh case   13:*/		return 0x82101DE0;
		  /* 82101DE0h */ case   14:  		/* rlwinm R28, R28, 2, 0, 29 */
		/* 82101DE0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R28);
		/* 82101DE0h case   14:*/		return 0x82101DE4;
		  /* 82101DE4h */ case   15:  		/* lwzx R28, <#[R28 + R8]> */
		/* 82101DE4h case   15:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + regs.R8 + 0x00000000) );
		/* 82101DE4h case   15:*/		return 0x82101DE8;
		  /* 82101DE8h */ case   16:  		/* lwz R28, <#[R28]> */
		/* 82101DE8h case   16:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000000) );
		/* 82101DE8h case   16:*/		return 0x82101DEC;
		  /* 82101DECh */ case   17:  		/* rlwinm. R28, R28, 0, 26, 26 */
		/* 82101DECh case   17:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R28,regs.R28);
		/* 82101DECh case   17:*/		return 0x82101DF0;
		  /* 82101DF0h */ case   18:  		/* bc 12, CR0_EQ, 8 */
		/* 82101DF0h case   18:*/		if ( regs.CR[0].eq ) { return 0x82101DF8;  }
		/* 82101DF0h case   18:*/		return 0x82101DF4;
		  /* 82101DF4h */ case   19:  		/* addi R4, R4, 1 */
		/* 82101DF4h case   19:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82101DF4h case   19:*/		return 0x82101DF8;
	}
	return 0x82101DF8;
} // Block from 82101DA8h-82101DF8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82101DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101DF8);
		  /* 82101DF8h */ case    0:  		/* addi R6, R6, 1 */
		/* 82101DF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82101DF8h case    0:*/		return 0x82101DFC;
		  /* 82101DFCh */ case    1:  		/* addi R10, R10, 4 */
		/* 82101DFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82101DFCh case    1:*/		return 0x82101E00;
		  /* 82101E00h */ case    2:  		/* cmplw CR6, R6, R7 */
		/* 82101E00h case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 82101E00h case    2:*/		return 0x82101E04;
		  /* 82101E04h */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 82101E04h case    3:*/		if ( regs.CR[6].lt ) { return 0x82101DDC;  }
		/* 82101E04h case    3:*/		return 0x82101E08;
	}
	return 0x82101E08;
} // Block from 82101DF8h-82101E08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82101E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101E08);
		  /* 82101E08h */ case    0:  		/* cmplw CR6, R4, R5 */
		/* 82101E08h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 82101E08h case    0:*/		return 0x82101E0C;
		  /* 82101E0Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82101E0Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82101E1C;  }
		/* 82101E0Ch case    1:*/		return 0x82101E10;
		  /* 82101E10h */ case    2:  		/* li R10, 0 */
		/* 82101E10h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82101E10h case    2:*/		return 0x82101E14;
		  /* 82101E14h */ case    3:  		/* stw R10, <#[R11]> */
		/* 82101E14h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82101E14h case    3:*/		return 0x82101E18;
		  /* 82101E18h */ case    4:  		/* b 444 */
		/* 82101E18h case    4:*/		return 0x82101FD4;
		/* 82101E18h case    4:*/		return 0x82101E1C;
	}
	return 0x82101E1C;
} // Block from 82101E08h-82101E1Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82101E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101E1C);
		  /* 82101E1Ch */ case    0:  		/* bc 4, CR6_LT, 316 */
		/* 82101E1Ch case    0:*/		if ( !regs.CR[6].lt ) { return 0x82101F58;  }
		/* 82101E1Ch case    0:*/		return 0x82101E20;
		  /* 82101E20h */ case    1:  		/* rlwinm R10, R31, 0, 0, 3 */
		/* 82101E20h case    1:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R31);
		/* 82101E20h case    1:*/		return 0x82101E24;
		  /* 82101E24h */ case    2:  		/* lis R9, 4096 */
		/* 82101E24h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 82101E24h case    2:*/		return 0x82101E28;
		  /* 82101E28h */ case    3:  		/* cmplw CR6, R10, R9 */
		/* 82101E28h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82101E28h case    3:*/		return 0x82101E2C;
		  /* 82101E2Ch */ case    4:  		/* bc 12, CR6_LT, 300 */
		/* 82101E2Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82101F58;  }
		/* 82101E2Ch case    4:*/		return 0x82101E30;
		  /* 82101E30h */ case    5:  		/* lis R9, 16384 */
		/* 82101E30h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0x4000);
		/* 82101E30h case    5:*/		return 0x82101E34;
		  /* 82101E34h */ case    6:  		/* cmplw CR6, R10, R9 */
		/* 82101E34h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82101E34h case    6:*/		return 0x82101E38;
		  /* 82101E38h */ case    7:  		/* bc 12, CR6_GT, 288 */
		/* 82101E38h case    7:*/		if ( regs.CR[6].gt ) { return 0x82101F58;  }
		/* 82101E38h case    7:*/		return 0x82101E3C;
		  /* 82101E3Ch */ case    8:  		/* lwz R10, <#[R11 + 4]> */
		/* 82101E3Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82101E3Ch case    8:*/		return 0x82101E40;
		  /* 82101E40h */ case    9:  		/* rlwinm R9, R31, 0, 12, 31 */
		/* 82101E40h case    9:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R9,regs.R31);
		/* 82101E40h case    9:*/		return 0x82101E44;
		  /* 82101E44h */ case   10:  		/* li R8, 0 */
		/* 82101E44h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82101E44h case   10:*/		return 0x82101E48;
	}
	return 0x82101E48;
} // Block from 82101E1Ch-82101E48h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82101E48h
// Function '?ReadWriteInfo_WriteInfo@CProgram@D3DXShader@@AAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101E48);
		  /* 82101E48h */ case    0:  		/* li R6, 0 */
		/* 82101E48h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82101E48h case    0:*/		return 0x82101E4C;
		  /* 82101E4Ch */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 82101E4Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82101E4Ch case    1:*/		return 0x82101E50;
		  /* 82101E50h */ case    2:  		/* divwu R4, R10, R9 */
		/* 82101E50h case    2:*/		cpu::op::divwu<0>(regs,&regs.R4,regs.R10,regs.R9);
		/* 82101E50h case    2:*/		return 0x82101E54;
		  /* 82101E54h */ case    3:  		/* twi 6, R9, 0 */
		/* 82101E54h case    3:*/		cpu::op::tw<6>(regs, 0x82101E54, regs.R9, 0x00000000);
		/* 82101E54h case    3:*/		return 0x82101E58;
		  /* 82101E58h */ case    4:  		/* bc 12, CR6_EQ, 140 */
		/* 82101E58h case    4:*/		if ( regs.CR[6].eq ) { return 0x82101EE4;  }
		/* 82101E58h case    4:*/		return 0x82101E5C;
		  /* 82101E5Ch */ case    5:  		/* li R5, 0 */
		/* 82101E5Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82101E5Ch case    5:*/		return 0x82101E60;
		  /* 82101E60h */ case    6:  		/* li R7, 0 */
		/* 82101E60h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82101E60h case    6:*/		return 0x82101E64;
		  /* 82101E64h */ case    7:  		/* lwz R9, <#[R11 + 16]> */
		/* 82101E64h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 82101E64h case    7:*/		return 0x82101E68;
		  /* 82101E68h */ case    8:  		/* lwz R10, <#[R3 + 20]> */
		/* 82101E68h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82101E68h case    8:*/		return 0x82101E6C;
		  /* 82101E6Ch */ case    9:  		/* lwzx R31, <#[R7 + R9]> */
		/* 82101E6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 82101E6Ch case    9:*/		return 0x82101E70;
		  /* 82101E70h */ case   10:  		/* rlwinm R31, R31, 2, 0, 29 */
		/* 82101E70h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R31);
		/* 82101E70h case   10:*/		return 0x82101E74;
		  /* 82101E74h */ case   11:  		/* lwzx R10, <#[R31 + R10]> */
		/* 82101E74h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 82101E74h case   11:*/		return 0x82101E78;
		  /* 82101E78h */ case   12:  		/* lwz R10, <#[R10]> */
		/* 82101E78h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82101E78h case   12:*/		return 0x82101E7C;
		  /* 82101E7Ch */ case   13:  		/* rlwinm. R10, R10, 0, 26, 26 */
		/* 82101E7Ch case   13:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R10);
		/* 82101E7Ch case   13:*/		return 0x82101E80;
		  /* 82101E80h */ case   14:  		/* bc 4, CR0_EQ, 80 */
		/* 82101E80h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82101ED0;  }
		/* 82101E80h case   14:*/		return 0x82101E84;
		  /* 82101E84h */ case   15:  		/* lwzx R31, <#[R7 + R9]> */
		/* 82101E84h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 82101E84h case   15:*/		return 0x82101E88;
		  /* 82101E88h */ case   16:  		/* li R10, 0 */
		/* 82101E88h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82101E88h case   16:*/		return 0x82101E8C;
		  /* 82101E8Ch */ case   17:  		/* cmplwi CR6, R4, 0 */
		/* 82101E8Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82101E8Ch case   17:*/		return 0x82101E90;
		  /* 82101E90h */ case   18:  		/* stwx R31, <#[R5 + R9]> */
		/* 82101E90h case   18:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 82101E90h case   18:*/		return 0x82101E94;
		  /* 82101E94h */ case   19:  		/* bc 12, CR6_EQ, 52 */
		/* 82101E94h case   19:*/		if ( regs.CR[6].eq ) { return 0x82101EC8;  }
		/* 82101E94h case   19:*/		return 0x82101E98;
		  /* 82101E98h */ case   20:  		/* mtspr CTR, R4 */
		/* 82101E98h case   20:*/		regs.CTR = regs.R4;
		/* 82101E98h case   20:*/		return 0x82101E9C;
		  /* 82101E9Ch */ case   21:  		/* lwz R9, <#[R11 + 12]> */
		/* 82101E9Ch case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82101E9Ch case   21:*/		return 0x82101EA0;
		  /* 82101EA0h */ case   22:  		/* lwz R31, <#[R11 + 8]> */
		/* 82101EA0h case   22:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000008) );
		/* 82101EA0h case   22:*/		return 0x82101EA4;
		  /* 82101EA4h */ case   23:  		/* mullw R9, R9, R10 */
		/* 82101EA4h case   23:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82101EA4h case   23:*/		return 0x82101EA8;
		  /* 82101EA8h */ case   24:  		/* add R28, R9, R6 */
		/* 82101EA8h case   24:*/		cpu::op::add<0>(regs,&regs.R28,regs.R9,regs.R6);
		/* 82101EA8h case   24:*/		return 0x82101EAC;
		  /* 82101EACh */ case   25:  		/* add R9, R9, R8 */
		/* 82101EACh case   25:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82101EACh case   25:*/		return 0x82101EB0;
		  /* 82101EB0h */ case   26:  		/* rlwinm R28, R28, 2, 0, 29 */
		/* 82101EB0h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R28);
		/* 82101EB0h case   26:*/		return 0x82101EB4;
		  /* 82101EB4h */ case   27:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82101EB4h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82101EB4h case   27:*/		return 0x82101EB8;
		  /* 82101EB8h */ case   28:  		/* addi R10, R10, 1 */
		/* 82101EB8h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82101EB8h case   28:*/		return 0x82101EBC;
		  /* 82101EBCh */ case   29:  		/* lwzx R28, <#[R28 + R31]> */
		/* 82101EBCh case   29:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + regs.R31 + 0x00000000) );
		/* 82101EBCh case   29:*/		return 0x82101EC0;
		  /* 82101EC0h */ case   30:  		/* stwx R28, <#[R9 + R31]> */
		/* 82101EC0h case   30:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R9 + regs.R31 + 0x00000000) );
		/* 82101EC0h case   30:*/		return 0x82101EC4;
		  /* 82101EC4h */ case   31:  		/* bc 16, CR0_LT, -40 */
		/* 82101EC4h case   31:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82101E9C;  }
		/* 82101EC4h case   31:*/		return 0x82101EC8;
	}
	return 0x82101EC8;
} // Block from 82101E48h-82101EC8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82101EC8h
// Function '?ReadWriteInfo_CommitOrigin@CProgram@D3DXShader@@AAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101EC8);
		  /* 82101EC8h */ case    0:  		/* addi R8, R8, 1 */
		/* 82101EC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82101EC8h case    0:*/		return 0x82101ECC;
		  /* 82101ECCh */ case    1:  		/* addi R5, R5, 4 */
		/* 82101ECCh case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 82101ECCh case    1:*/		return 0x82101ED0;
	}
	return 0x82101ED0;
} // Block from 82101EC8h-82101ED0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82101ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101ED0);
		  /* 82101ED0h */ case    0:  		/* lwz R10, <#[R11 + 12]> */
		/* 82101ED0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82101ED0h case    0:*/		return 0x82101ED4;
		  /* 82101ED4h */ case    1:  		/* addi R6, R6, 1 */
		/* 82101ED4h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82101ED4h case    1:*/		return 0x82101ED8;
		  /* 82101ED8h */ case    2:  		/* addi R7, R7, 4 */
		/* 82101ED8h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82101ED8h case    2:*/		return 0x82101EDC;
		  /* 82101EDCh */ case    3:  		/* cmplw CR6, R6, R10 */
		/* 82101EDCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82101EDCh case    3:*/		return 0x82101EE0;
		  /* 82101EE0h */ case    4:  		/* bc 12, CR6_LT, -124 */
		/* 82101EE0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82101E64;  }
		/* 82101EE0h case    4:*/		return 0x82101EE4;
	}
	return 0x82101EE4;
} // Block from 82101ED0h-82101EE4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82101EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101EE4);
		  /* 82101EE4h */ case    0:  		/* li R9, 1 */
		/* 82101EE4h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82101EE4h case    0:*/		return 0x82101EE8;
		  /* 82101EE8h */ case    1:  		/* cmplwi CR6, R4, 1 */
		/* 82101EE8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 82101EE8h case    1:*/		return 0x82101EEC;
		  /* 82101EECh */ case    2:  		/* bc 4, CR6_GT, 84 */
		/* 82101EECh case    2:*/		if ( !regs.CR[6].gt ) { return 0x82101F40;  }
		/* 82101EECh case    2:*/		return 0x82101EF0;
		  /* 82101EF0h */ case    3:  		/* mr R7, R8 */
		/* 82101EF0h case    3:*/		regs.R7 = regs.R8;
		/* 82101EF0h case    3:*/		return 0x82101EF4;
		  /* 82101EF4h */ case    4:  		/* li R10, 0 */
		/* 82101EF4h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82101EF4h case    4:*/		return 0x82101EF8;
		  /* 82101EF8h */ case    5:  		/* cmplwi CR6, R8, 0 */
		/* 82101EF8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82101EF8h case    5:*/		return 0x82101EFC;
		  /* 82101EFCh */ case    6:  		/* bc 12, CR6_EQ, 52 */
		/* 82101EFCh case    6:*/		if ( regs.CR[6].eq ) { return 0x82101F30;  }
		/* 82101EFCh case    6:*/		return 0x82101F00;
		  /* 82101F00h */ case    7:  		/* mtspr CTR, R8 */
		/* 82101F00h case    7:*/		regs.CTR = regs.R8;
		/* 82101F00h case    7:*/		return 0x82101F04;
		  /* 82101F04h */ case    8:  		/* lwz R6, <#[R11 + 12]> */
		/* 82101F04h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 82101F04h case    8:*/		return 0x82101F08;
		  /* 82101F08h */ case    9:  		/* add R5, R7, R10 */
		/* 82101F08h case    9:*/		cpu::op::add<0>(regs,&regs.R5,regs.R7,regs.R10);
		/* 82101F08h case    9:*/		return 0x82101F0C;
		  /* 82101F0Ch */ case   10:  		/* lwz R31, <#[R11 + 8]> */
		/* 82101F0Ch case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000008) );
		/* 82101F0Ch case   10:*/		return 0x82101F10;
		  /* 82101F10h */ case   11:  		/* mullw R6, R6, R9 */
		/* 82101F10h case   11:*/		cpu::op::mullw<0>(regs,&regs.R6,regs.R6,regs.R9);
		/* 82101F10h case   11:*/		return 0x82101F14;
		  /* 82101F14h */ case   12:  		/* add R6, R6, R10 */
		/* 82101F14h case   12:*/		cpu::op::add<0>(regs,&regs.R6,regs.R6,regs.R10);
		/* 82101F14h case   12:*/		return 0x82101F18;
		  /* 82101F18h */ case   13:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82101F18h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82101F18h case   13:*/		return 0x82101F1C;
		  /* 82101F1Ch */ case   14:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82101F1Ch case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82101F1Ch case   14:*/		return 0x82101F20;
		  /* 82101F20h */ case   15:  		/* addi R10, R10, 1 */
		/* 82101F20h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82101F20h case   15:*/		return 0x82101F24;
		  /* 82101F24h */ case   16:  		/* lwzx R6, <#[R6 + R31]> */
		/* 82101F24h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R31 + 0x00000000) );
		/* 82101F24h case   16:*/		return 0x82101F28;
		  /* 82101F28h */ case   17:  		/* stwx R6, <#[R5 + R31]> */
		/* 82101F28h case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R5 + regs.R31 + 0x00000000) );
		/* 82101F28h case   17:*/		return 0x82101F2C;
		  /* 82101F2Ch */ case   18:  		/* bc 16, CR0_LT, -40 */
		/* 82101F2Ch case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82101F04;  }
		/* 82101F2Ch case   18:*/		return 0x82101F30;
	}
	return 0x82101F30;
} // Block from 82101EE4h-82101F30h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82101F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101F30);
		  /* 82101F30h */ case    0:  		/* addi R9, R9, 1 */
		/* 82101F30h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82101F30h case    0:*/		return 0x82101F34;
		  /* 82101F34h */ case    1:  		/* add R7, R7, R8 */
		/* 82101F34h case    1:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R8);
		/* 82101F34h case    1:*/		return 0x82101F38;
		  /* 82101F38h */ case    2:  		/* cmplw CR6, R9, R4 */
		/* 82101F38h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 82101F38h case    2:*/		return 0x82101F3C;
		  /* 82101F3Ch */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 82101F3Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82101EF4;  }
		/* 82101F3Ch case    3:*/		return 0x82101F40;
	}
	return 0x82101F40;
} // Block from 82101F30h-82101F40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82101F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101F40);
		  /* 82101F40h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 82101F40h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82101F40h case    0:*/		return 0x82101F44;
		  /* 82101F44h */ case    1:  		/* mullw R9, R8, R4 */
		/* 82101F44h case    1:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R4);
		/* 82101F44h case    1:*/		return 0x82101F48;
		  /* 82101F48h */ case    2:  		/* stw R8, <#[R11 + 12]> */
		/* 82101F48h case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82101F48h case    2:*/		return 0x82101F4C;
		  /* 82101F4Ch */ case    3:  		/* stw R9, <#[R11 + 4]> */
		/* 82101F4Ch case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82101F4Ch case    3:*/		return 0x82101F50;
		  /* 82101F50h */ case    4:  		/* rlwimi R10, R8, 0, 12, 31 */
		/* 82101F50h case    4:*/		cpu::op::rlwimi<0,0,12,31>(regs,&regs.R10,regs.R8);
		/* 82101F50h case    4:*/		return 0x82101F54;
		  /* 82101F54h */ case    5:  		/* stw R10, <#[R11]> */
		/* 82101F54h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82101F54h case    5:*/		return 0x82101F58;
	}
	return 0x82101F58;
} // Block from 82101F40h-82101F58h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82101F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101F58);
		  /* 82101F58h */ case    0:  		/* lwz R10, <#[R11 + 12]> */
		/* 82101F58h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82101F58h case    0:*/		return 0x82101F5C;
		  /* 82101F5Ch */ case    1:  		/* li R4, 0 */
		/* 82101F5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82101F5Ch case    1:*/		return 0x82101F60;
		  /* 82101F60h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 82101F60h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82101F60h case    2:*/		return 0x82101F64;
		  /* 82101F64h */ case    3:  		/* bc 4, CR6_GT, 112 */
		/* 82101F64h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82101FD4;  }
		/* 82101F64h case    3:*/		return 0x82101F68;
		  /* 82101F68h */ case    4:  		/* li R8, 0 */
		/* 82101F68h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82101F68h case    4:*/		return 0x82101F6C;
		  /* 82101F6Ch */ case    5:  		/* lwz R10, <#[R11 + 16]> */
		/* 82101F6Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82101F6Ch case    5:*/		return 0x82101F70;
		  /* 82101F70h */ case    6:  		/* lwz R6, <#[R3 + 20]> */
		/* 82101F70h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000014) );
		/* 82101F70h case    6:*/		return 0x82101F74;
		  /* 82101F74h */ case    7:  		/* lwzx R10, <#[R8 + R10]> */
		/* 82101F74h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82101F74h case    7:*/		return 0x82101F78;
		  /* 82101F78h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82101F78h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82101F78h case    8:*/		return 0x82101F7C;
		  /* 82101F7Ch */ case    9:  		/* lwzx R9, <#[R10 + R6]> */
		/* 82101F7Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82101F7Ch case    9:*/		return 0x82101F80;
		  /* 82101F80h */ case   10:  		/* lwz R10, <#[R9 + 20]> */
		/* 82101F80h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000014) );
		/* 82101F80h case   10:*/		return 0x82101F84;
		  /* 82101F84h */ case   11:  		/* lwz R7, <#[R9 + 24]> */
		/* 82101F84h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000018) );
		/* 82101F84h case   11:*/		return 0x82101F88;
		  /* 82101F88h */ case   12:  		/* b 40 */
		/* 82101F88h case   12:*/		return 0x82101FB0;
		/* 82101F88h case   12:*/		return 0x82101F8C;
		  /* 82101F8Ch */ case   13:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 82101F8Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 82101F8Ch case   13:*/		return 0x82101F90;
		  /* 82101F90h */ case   14:  		/* lwzx R31, <#[R5 + R6]> */
		/* 82101F90h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 82101F90h case   14:*/		return 0x82101F94;
		  /* 82101F94h */ case   15:  		/* lwz R31, <#[R31]> */
		/* 82101F94h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000000) );
		/* 82101F94h case   15:*/		return 0x82101F98;
		  /* 82101F98h */ case   16:  		/* rlwinm. R31, R31, 0, 26, 26 */
		/* 82101F98h case   16:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R31,regs.R31);
		/* 82101F98h case   16:*/		return 0x82101F9C;
		  /* 82101F9Ch */ case   17:  		/* bc 12, CR0_EQ, 28 */
		/* 82101F9Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x82101FB8;  }
		/* 82101F9Ch case   17:*/		return 0x82101FA0;
		  /* 82101FA0h */ case   18:  		/* lwz R10, <#[R3 + 20]> */
		/* 82101FA0h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82101FA0h case   18:*/		return 0x82101FA4;
		  /* 82101FA4h */ case   19:  		/* lwzx R7, <#[R5 + R10]> */
		/* 82101FA4h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + regs.R10 + 0x00000000) );
		/* 82101FA4h case   19:*/		return 0x82101FA8;
		  /* 82101FA8h */ case   20:  		/* lwz R10, <#[R7 + 20]> */
		/* 82101FA8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000014) );
		/* 82101FA8h case   20:*/		return 0x82101FAC;
		  /* 82101FACh */ case   21:  		/* lwz R7, <#[R7 + 24]> */
		/* 82101FACh case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000018) );
		/* 82101FACh case   21:*/		return 0x82101FB0;
	}
	return 0x82101FB0;
} // Block from 82101F58h-82101FB0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82101FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101FB0);
		  /* 82101FB0h */ case    0:  		/* cmpwi CR6, R10, -1 */
		/* 82101FB0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82101FB0h case    0:*/		return 0x82101FB4;
		  /* 82101FB4h */ case    1:  		/* bc 4, CR6_EQ, -40 */
		/* 82101FB4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82101F8C;  }
		/* 82101FB4h case    1:*/		return 0x82101FB8;
	}
	return 0x82101FB8;
} // Block from 82101FB0h-82101FB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82101FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101FB8);
		  /* 82101FB8h */ case    0:  		/* addi R4, R4, 1 */
		/* 82101FB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82101FB8h case    0:*/		return 0x82101FBC;
		  /* 82101FBCh */ case    1:  		/* stw R7, <#[R9 + 24]> */
		/* 82101FBCh case    1:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000018) );
		/* 82101FBCh case    1:*/		return 0x82101FC0;
		  /* 82101FC0h */ case    2:  		/* stw R10, <#[R9 + 20]> */
		/* 82101FC0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000014) );
		/* 82101FC0h case    2:*/		return 0x82101FC4;
		  /* 82101FC4h */ case    3:  		/* addi R8, R8, 4 */
		/* 82101FC4h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82101FC4h case    3:*/		return 0x82101FC8;
		  /* 82101FC8h */ case    4:  		/* lwz R10, <#[R11 + 12]> */
		/* 82101FC8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82101FC8h case    4:*/		return 0x82101FCC;
		  /* 82101FCCh */ case    5:  		/* cmplw CR6, R4, R10 */
		/* 82101FCCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 82101FCCh case    5:*/		return 0x82101FD0;
		  /* 82101FD0h */ case    6:  		/* bc 12, CR6_LT, -100 */
		/* 82101FD0h case    6:*/		if ( regs.CR[6].lt ) { return 0x82101F6C;  }
		/* 82101FD0h case    6:*/		return 0x82101FD4;
	}
	return 0x82101FD4;
} // Block from 82101FB8h-82101FD4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82101FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101FD4);
		  /* 82101FD4h */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 82101FD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82101FD4h case    0:*/		return 0x82101FD8;
		  /* 82101FD8h */ case    1:  		/* addi R29, R29, 1 */
		/* 82101FD8h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82101FD8h case    1:*/		return 0x82101FDC;
		  /* 82101FDCh */ case    2:  		/* addi R30, R30, 4 */
		/* 82101FDCh case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82101FDCh case    2:*/		return 0x82101FE0;
		  /* 82101FE0h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 82101FE0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82101FE0h case    3:*/		return 0x82101FE4;
		  /* 82101FE4h */ case    4:  		/* bc 12, CR6_LT, -576 */
		/* 82101FE4h case    4:*/		if ( regs.CR[6].lt ) { return 0x82101DA4;  }
		/* 82101FE4h case    4:*/		return 0x82101FE8;
	}
	return 0x82101FE8;
} // Block from 82101FD4h-82101FE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82101FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101FE8);
		  /* 82101FE8h */ case    0:  		/* li R3, 0 */
		/* 82101FE8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82101FE8h case    0:*/		return 0x82101FEC;
		  /* 82101FECh */ case    1:  		/* b -462148 */
		/* 82101FECh case    1:*/		return 0x820912A8;
		/* 82101FECh case    1:*/		return 0x82101FF0;
	}
	return 0x82101FF0;
} // Block from 82101FE8h-82101FF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82101FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82101FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82101FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82101FF0);
		  /* 82101FF0h */ case    0:  		/* mfspr R12, LR */
		/* 82101FF0h case    0:*/		regs.R12 = regs.LR;
		/* 82101FF0h case    0:*/		return 0x82101FF4;
		  /* 82101FF4h */ case    1:  		/* bl -462240 */
		/* 82101FF4h case    1:*/		regs.LR = 0x82101FF8; return 0x82091254;
		/* 82101FF4h case    1:*/		return 0x82101FF8;
		  /* 82101FF8h */ case    2:  		/* lwz R11, <#[R3 + 12]> */
		/* 82101FF8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82101FF8h case    2:*/		return 0x82101FFC;
		  /* 82101FFCh */ case    3:  		/* li R28, 0 */
		/* 82101FFCh case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82101FFCh case    3:*/		return 0x82102000;
		  /* 82102000h */ case    4:  		/* li R29, 0 */
		/* 82102000h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82102000h case    4:*/		return 0x82102004;
		  /* 82102004h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82102004h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82102004h case    5:*/		return 0x82102008;
		  /* 82102008h */ case    6:  		/* bc 4, CR6_GT, 476 */
		/* 82102008h case    6:*/		if ( !regs.CR[6].gt ) { return 0x821021E4;  }
		/* 82102008h case    6:*/		return 0x8210200C;
		  /* 8210200Ch */ case    7:  		/* li R30, 0 */
		/* 8210200Ch case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8210200Ch case    7:*/		return 0x82102010;
	}
	return 0x82102010;
} // Block from 82101FF0h-82102010h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82102010h
// Function '?ParentChildInfo_ParentInfo@CProgram@D3DXShader@@AAAXIIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102010);
		  /* 82102010h */ case    0:  		/* lwz R11, <#[R3 + 24]> */
		/* 82102010h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82102010h case    0:*/		return 0x82102014;
		  /* 82102014h */ case    1:  		/* lwzx R11, <#[R30 + R11]> */
		/* 82102014h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82102014h case    1:*/		return 0x82102018;
		  /* 82102018h */ case    2:  		/* lwz R31, <#[R11]> */
		/* 82102018h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82102018h case    2:*/		return 0x8210201C;
		  /* 8210201Ch */ case    3:  		/* rlwinm. R10, R31, 0, 0, 11 */
		/* 8210201Ch case    3:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R31);
		/* 8210201Ch case    3:*/		return 0x82102020;
		  /* 82102020h */ case    4:  		/* bc 12, CR0_EQ, 432 */
		/* 82102020h case    4:*/		if ( regs.CR[0].eq ) { return 0x821021D0;  }
		/* 82102020h case    4:*/		return 0x82102024;
		  /* 82102024h */ case    5:  		/* lis R9, 4112 */
		/* 82102024h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0x1010);
		/* 82102024h case    5:*/		return 0x82102028;
		  /* 82102028h */ case    6:  		/* cmplw CR6, R10, R9 */
		/* 82102028h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82102028h case    6:*/		return 0x8210202C;
		  /* 8210202Ch */ case    7:  		/* bc 12, CR6_EQ, 420 */
		/* 8210202Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821021D0;  }
		/* 8210202Ch case    7:*/		return 0x82102030;
		  /* 82102030h */ case    8:  		/* lwz R4, <#[R11 + 12]> */
		/* 82102030h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 82102030h case    8:*/		return 0x82102034;
		  /* 82102034h */ case    9:  		/* li R5, 0 */
		/* 82102034h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82102034h case    9:*/		return 0x82102038;
		  /* 82102038h */ case   10:  		/* li R6, 0 */
		/* 82102038h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82102038h case   10:*/		return 0x8210203C;
		  /* 8210203Ch */ case   11:  		/* cmplwi CR6, R4, 0 */
		/* 8210203Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8210203Ch case   11:*/		return 0x82102040;
		  /* 82102040h */ case   12:  		/* bc 12, CR6_EQ, 400 */
		/* 82102040h case   12:*/		if ( regs.CR[6].eq ) { return 0x821021D0;  }
		/* 82102040h case   12:*/		return 0x82102044;
		  /* 82102044h */ case   13:  		/* lwz R8, <#[R11 + 16]> */
		/* 82102044h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 82102044h case   13:*/		return 0x82102048;
		  /* 82102048h */ case   14:  		/* rlwinm R9, R4, 0, 0, 31 */
		/* 82102048h case   14:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R4);
		/* 82102048h case   14:*/		return 0x8210204C;
		  /* 8210204Ch */ case   15:  		/* lwz R7, <#[R3 + 20]> */
		/* 8210204Ch case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000014) );
		/* 8210204Ch case   15:*/		return 0x82102050;
		  /* 82102050h */ case   16:  		/* li R10, 0 */
		/* 82102050h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82102050h case   16:*/		return 0x82102054;
		  /* 82102054h */ case   17:  		/* lwzx R27, <#[R10 + R8]> */
		/* 82102054h case   17:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82102054h case   17:*/		return 0x82102058;
		  /* 82102058h */ case   18:  		/* rlwinm R27, R27, 2, 0, 29 */
		/* 82102058h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R27);
		/* 82102058h case   18:*/		return 0x8210205C;
		  /* 8210205Ch */ case   19:  		/* lwzx R27, <#[R27 + R7]> */
		/* 8210205Ch case   19:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + regs.R7 + 0x00000000) );
		/* 8210205Ch case   19:*/		return 0x82102060;
		  /* 82102060h */ case   20:  		/* lwz R27, <#[R27]> */
		/* 82102060h case   20:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000000) );
		/* 82102060h case   20:*/		return 0x82102064;
		  /* 82102064h */ case   21:  		/* rlwinm. R27, R27, 0, 26, 26 */
		/* 82102064h case   21:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R27,regs.R27);
		/* 82102064h case   21:*/		return 0x82102068;
		  /* 82102068h */ case   22:  		/* bc 4, CR0_EQ, 8 */
		/* 82102068h case   22:*/		if ( !regs.CR[0].eq ) { return 0x82102070;  }
		/* 82102068h case   22:*/		return 0x8210206C;
		  /* 8210206Ch */ case   23:  		/* addi R5, R5, 1 */
		/* 8210206Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 8210206Ch case   23:*/		return 0x82102070;
	}
	return 0x82102070;
} // Block from 82102010h-82102070h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82102070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102070);
		  /* 82102070h */ case    0:  		/* addi R6, R6, 1 */
		/* 82102070h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82102070h case    0:*/		return 0x82102074;
		  /* 82102074h */ case    1:  		/* addi R10, R10, 4 */
		/* 82102074h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82102074h case    1:*/		return 0x82102078;
		  /* 82102078h */ case    2:  		/* cmplw CR6, R6, R9 */
		/* 82102078h case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R9);
		/* 82102078h case    2:*/		return 0x8210207C;
		  /* 8210207Ch */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 8210207Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82102054;  }
		/* 8210207Ch case    3:*/		return 0x82102080;
		  /* 82102080h */ case    4:  		/* cmplwi CR6, R5, 0 */
		/* 82102080h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82102080h case    4:*/		return 0x82102084;
		  /* 82102084h */ case    5:  		/* bc 12, CR6_EQ, 332 */
		/* 82102084h case    5:*/		if ( regs.CR[6].eq ) { return 0x821021D0;  }
		/* 82102084h case    5:*/		return 0x82102088;
		  /* 82102088h */ case    6:  		/* li R28, 1 */
		/* 82102088h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 82102088h case    6:*/		return 0x8210208C;
		  /* 8210208Ch */ case    7:  		/* cmplw CR6, R5, R4 */
		/* 8210208Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 8210208Ch case    7:*/		return 0x82102090;
		  /* 82102090h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 82102090h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8210209C;  }
		/* 82102090h case    8:*/		return 0x82102094;
		  /* 82102094h */ case    9:  		/* li R10, 0 */
		/* 82102094h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82102094h case    9:*/		return 0x82102098;
		  /* 82102098h */ case   10:  		/* b 308 */
		/* 82102098h case   10:*/		return 0x821021CC;
		/* 82102098h case   10:*/		return 0x8210209C;
	}
	return 0x8210209C;
} // Block from 82102070h-8210209Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8210209Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210209C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210209C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210209C);
		  /* 8210209Ch */ case    0:  		/* bc 4, CR6_LT, 308 */
		/* 8210209Ch case    0:*/		if ( !regs.CR[6].lt ) { return 0x821021D0;  }
		/* 8210209Ch case    0:*/		return 0x821020A0;
		  /* 821020A0h */ case    1:  		/* rlwinm R10, R31, 0, 0, 3 */
		/* 821020A0h case    1:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R31);
		/* 821020A0h case    1:*/		return 0x821020A4;
		  /* 821020A4h */ case    2:  		/* lis R9, 4096 */
		/* 821020A4h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 821020A4h case    2:*/		return 0x821020A8;
		  /* 821020A8h */ case    3:  		/* cmplw CR6, R10, R9 */
		/* 821020A8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821020A8h case    3:*/		return 0x821020AC;
		  /* 821020ACh */ case    4:  		/* bc 12, CR6_LT, 292 */
		/* 821020ACh case    4:*/		if ( regs.CR[6].lt ) { return 0x821021D0;  }
		/* 821020ACh case    4:*/		return 0x821020B0;
		  /* 821020B0h */ case    5:  		/* lis R9, 16384 */
		/* 821020B0h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0x4000);
		/* 821020B0h case    5:*/		return 0x821020B4;
		  /* 821020B4h */ case    6:  		/* cmplw CR6, R10, R9 */
		/* 821020B4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821020B4h case    6:*/		return 0x821020B8;
		  /* 821020B8h */ case    7:  		/* bc 12, CR6_GT, 280 */
		/* 821020B8h case    7:*/		if ( regs.CR[6].gt ) { return 0x821021D0;  }
		/* 821020B8h case    7:*/		return 0x821020BC;
		  /* 821020BCh */ case    8:  		/* lwz R10, <#[R11 + 4]> */
		/* 821020BCh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821020BCh case    8:*/		return 0x821020C0;
		  /* 821020C0h */ case    9:  		/* rlwinm R9, R31, 0, 12, 31 */
		/* 821020C0h case    9:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R9,regs.R31);
		/* 821020C0h case    9:*/		return 0x821020C4;
		  /* 821020C4h */ case   10:  		/* li R7, 0 */
		/* 821020C4h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821020C4h case   10:*/		return 0x821020C8;
		  /* 821020C8h */ case   11:  		/* li R6, 0 */
		/* 821020C8h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821020C8h case   11:*/		return 0x821020CC;
		  /* 821020CCh */ case   12:  		/* li R5, 0 */
		/* 821020CCh case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821020CCh case   12:*/		return 0x821020D0;
		  /* 821020D0h */ case   13:  		/* li R8, 0 */
		/* 821020D0h case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821020D0h case   13:*/		return 0x821020D4;
		  /* 821020D4h */ case   14:  		/* divwu R4, R10, R9 */
		/* 821020D4h case   14:*/		cpu::op::divwu<0>(regs,&regs.R4,regs.R10,regs.R9);
		/* 821020D4h case   14:*/		return 0x821020D8;
		  /* 821020D8h */ case   15:  		/* twi 6, R9, 0 */
		/* 821020D8h case   15:*/		cpu::op::tw<6>(regs, 0x821020D8, regs.R9, 0x00000000);
		/* 821020D8h case   15:*/		return 0x821020DC;
		  /* 821020DCh */ case   16:  		/* lwz R9, <#[R11 + 16]> */
		/* 821020DCh case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 821020DCh case   16:*/		return 0x821020E0;
		  /* 821020E0h */ case   17:  		/* lwz R10, <#[R3 + 20]> */
		/* 821020E0h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 821020E0h case   17:*/		return 0x821020E4;
		  /* 821020E4h */ case   18:  		/* lwzx R31, <#[R8 + R9]> */
		/* 821020E4h case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 821020E4h case   18:*/		return 0x821020E8;
		  /* 821020E8h */ case   19:  		/* rlwinm R31, R31, 2, 0, 29 */
		/* 821020E8h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R31);
		/* 821020E8h case   19:*/		return 0x821020EC;
		  /* 821020ECh */ case   20:  		/* lwzx R10, <#[R31 + R10]> */
		/* 821020ECh case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 821020ECh case   20:*/		return 0x821020F0;
		  /* 821020F0h */ case   21:  		/* lwz R10, <#[R10]> */
		/* 821020F0h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821020F0h case   21:*/		return 0x821020F4;
		  /* 821020F4h */ case   22:  		/* rlwinm. R10, R10, 0, 26, 26 */
		/* 821020F4h case   22:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R10);
		/* 821020F4h case   22:*/		return 0x821020F8;
	}
	return 0x821020F8;
} // Block from 8210209Ch-821020F8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821020F8h
// Function '?IdentityRemap@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821020F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821020F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821020F8);
		  /* 821020F8h */ case    0:  		/* bc 12, CR0_EQ, 80 */
		/* 821020F8h case    0:*/		if ( regs.CR[0].eq ) { return 0x82102148;  }
		/* 821020F8h case    0:*/		return 0x821020FC;
		  /* 821020FCh */ case    1:  		/* lwzx R31, <#[R8 + R9]> */
		/* 821020FCh case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 821020FCh case    1:*/		return 0x82102100;
		  /* 82102100h */ case    2:  		/* li R10, 0 */
		/* 82102100h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82102100h case    2:*/		return 0x82102104;
		  /* 82102104h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 82102104h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82102104h case    3:*/		return 0x82102108;
		  /* 82102108h */ case    4:  		/* stwx R31, <#[R5 + R9]> */
		/* 82102108h case    4:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 82102108h case    4:*/		return 0x8210210C;
		  /* 8210210Ch */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 8210210Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82102140;  }
		/* 8210210Ch case    5:*/		return 0x82102110;
		  /* 82102110h */ case    6:  		/* mtspr CTR, R4 */
		/* 82102110h case    6:*/		regs.CTR = regs.R4;
		/* 82102110h case    6:*/		return 0x82102114;
		  /* 82102114h */ case    7:  		/* lwz R9, <#[R11 + 12]> */
		/* 82102114h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82102114h case    7:*/		return 0x82102118;
		  /* 82102118h */ case    8:  		/* lwz R31, <#[R11 + 8]> */
		/* 82102118h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000008) );
		/* 82102118h case    8:*/		return 0x8210211C;
		  /* 8210211Ch */ case    9:  		/* mullw R9, R10, R9 */
		/* 8210211Ch case    9:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 8210211Ch case    9:*/		return 0x82102120;
		  /* 82102120h */ case   10:  		/* add R27, R9, R6 */
		/* 82102120h case   10:*/		cpu::op::add<0>(regs,&regs.R27,regs.R9,regs.R6);
		/* 82102120h case   10:*/		return 0x82102124;
		  /* 82102124h */ case   11:  		/* add R9, R9, R7 */
		/* 82102124h case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82102124h case   11:*/		return 0x82102128;
		  /* 82102128h */ case   12:  		/* rlwinm R27, R27, 2, 0, 29 */
		/* 82102128h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R27);
		/* 82102128h case   12:*/		return 0x8210212C;
		  /* 8210212Ch */ case   13:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210212Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210212Ch case   13:*/		return 0x82102130;
		  /* 82102130h */ case   14:  		/* addi R10, R10, 1 */
		/* 82102130h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82102130h case   14:*/		return 0x82102134;
		  /* 82102134h */ case   15:  		/* lwzx R27, <#[R27 + R31]> */
		/* 82102134h case   15:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + regs.R31 + 0x00000000) );
		/* 82102134h case   15:*/		return 0x82102138;
	}
	return 0x82102138;
} // Block from 821020F8h-82102138h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82102138h
// Function '?CompareDuplicateInstructions@D3DXShader@@YAHIIPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102138);
		  /* 82102138h */ case    0:  		/* stwx R27, <#[R9 + R31]> */
		/* 82102138h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R9 + regs.R31 + 0x00000000) );
		/* 82102138h case    0:*/		return 0x8210213C;
		  /* 8210213Ch */ case    1:  		/* bc 16, CR0_LT, -40 */
		/* 8210213Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82102114;  }
		/* 8210213Ch case    1:*/		return 0x82102140;
	}
	return 0x82102140;
} // Block from 82102138h-82102140h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102140);
		  /* 82102140h */ case    0:  		/* addi R7, R7, 1 */
		/* 82102140h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82102140h case    0:*/		return 0x82102144;
		  /* 82102144h */ case    1:  		/* addi R5, R5, 4 */
		/* 82102144h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 82102144h case    1:*/		return 0x82102148;
	}
	return 0x82102148;
} // Block from 82102140h-82102148h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102148);
		  /* 82102148h */ case    0:  		/* lwz R10, <#[R11 + 12]> */
		/* 82102148h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82102148h case    0:*/		return 0x8210214C;
		  /* 8210214Ch */ case    1:  		/* addi R6, R6, 1 */
		/* 8210214Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210214Ch case    1:*/		return 0x82102150;
		  /* 82102150h */ case    2:  		/* addi R8, R8, 4 */
		/* 82102150h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82102150h case    2:*/		return 0x82102154;
		  /* 82102154h */ case    3:  		/* cmplw CR6, R6, R10 */
		/* 82102154h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82102154h case    3:*/		return 0x82102158;
		  /* 82102158h */ case    4:  		/* bc 12, CR6_LT, -124 */
		/* 82102158h case    4:*/		if ( regs.CR[6].lt ) { return 0x821020DC;  }
		/* 82102158h case    4:*/		return 0x8210215C;
		  /* 8210215Ch */ case    5:  		/* li R9, 1 */
		/* 8210215Ch case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8210215Ch case    5:*/		return 0x82102160;
		  /* 82102160h */ case    6:  		/* cmplwi CR6, R4, 1 */
		/* 82102160h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 82102160h case    6:*/		return 0x82102164;
		  /* 82102164h */ case    7:  		/* bc 4, CR6_GT, 84 */
		/* 82102164h case    7:*/		if ( !regs.CR[6].gt ) { return 0x821021B8;  }
		/* 82102164h case    7:*/		return 0x82102168;
		  /* 82102168h */ case    8:  		/* mr R8, R7 */
		/* 82102168h case    8:*/		regs.R8 = regs.R7;
		/* 82102168h case    8:*/		return 0x8210216C;
		  /* 8210216Ch */ case    9:  		/* li R10, 0 */
		/* 8210216Ch case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210216Ch case    9:*/		return 0x82102170;
		  /* 82102170h */ case   10:  		/* cmplwi CR6, R7, 0 */
		/* 82102170h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82102170h case   10:*/		return 0x82102174;
		  /* 82102174h */ case   11:  		/* bc 12, CR6_EQ, 52 */
		/* 82102174h case   11:*/		if ( regs.CR[6].eq ) { return 0x821021A8;  }
		/* 82102174h case   11:*/		return 0x82102178;
		  /* 82102178h */ case   12:  		/* mtspr CTR, R7 */
		/* 82102178h case   12:*/		regs.CTR = regs.R7;
		/* 82102178h case   12:*/		return 0x8210217C;
		  /* 8210217Ch */ case   13:  		/* lwz R6, <#[R11 + 12]> */
		/* 8210217Ch case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210217Ch case   13:*/		return 0x82102180;
		  /* 82102180h */ case   14:  		/* add R5, R8, R10 */
		/* 82102180h case   14:*/		cpu::op::add<0>(regs,&regs.R5,regs.R8,regs.R10);
		/* 82102180h case   14:*/		return 0x82102184;
		  /* 82102184h */ case   15:  		/* lwz R31, <#[R11 + 8]> */
		/* 82102184h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000008) );
		/* 82102184h case   15:*/		return 0x82102188;
		  /* 82102188h */ case   16:  		/* mullw R6, R9, R6 */
		/* 82102188h case   16:*/		cpu::op::mullw<0>(regs,&regs.R6,regs.R9,regs.R6);
		/* 82102188h case   16:*/		return 0x8210218C;
		  /* 8210218Ch */ case   17:  		/* add R6, R6, R10 */
		/* 8210218Ch case   17:*/		cpu::op::add<0>(regs,&regs.R6,regs.R6,regs.R10);
		/* 8210218Ch case   17:*/		return 0x82102190;
		  /* 82102190h */ case   18:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82102190h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82102190h case   18:*/		return 0x82102194;
		  /* 82102194h */ case   19:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82102194h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82102194h case   19:*/		return 0x82102198;
		  /* 82102198h */ case   20:  		/* addi R10, R10, 1 */
		/* 82102198h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82102198h case   20:*/		return 0x8210219C;
		  /* 8210219Ch */ case   21:  		/* lwzx R6, <#[R6 + R31]> */
		/* 8210219Ch case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R31 + 0x00000000) );
		/* 8210219Ch case   21:*/		return 0x821021A0;
		  /* 821021A0h */ case   22:  		/* stwx R6, <#[R5 + R31]> */
		/* 821021A0h case   22:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R5 + regs.R31 + 0x00000000) );
		/* 821021A0h case   22:*/		return 0x821021A4;
		  /* 821021A4h */ case   23:  		/* bc 16, CR0_LT, -40 */
		/* 821021A4h case   23:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210217C;  }
		/* 821021A4h case   23:*/		return 0x821021A8;
	}
	return 0x821021A8;
} // Block from 82102148h-821021A8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821021A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821021A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821021A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821021A8);
		  /* 821021A8h */ case    0:  		/* addi R9, R9, 1 */
		/* 821021A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821021A8h case    0:*/		return 0x821021AC;
		  /* 821021ACh */ case    1:  		/* add R8, R8, R7 */
		/* 821021ACh case    1:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 821021ACh case    1:*/		return 0x821021B0;
		  /* 821021B0h */ case    2:  		/* cmplw CR6, R9, R4 */
		/* 821021B0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 821021B0h case    2:*/		return 0x821021B4;
		  /* 821021B4h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 821021B4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210216C;  }
		/* 821021B4h case    3:*/		return 0x821021B8;
	}
	return 0x821021B8;
} // Block from 821021A8h-821021B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821021B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821021B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821021B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821021B8);
		  /* 821021B8h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 821021B8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821021B8h case    0:*/		return 0x821021BC;
		  /* 821021BCh */ case    1:  		/* mullw R9, R7, R4 */
		/* 821021BCh case    1:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R7,regs.R4);
		/* 821021BCh case    1:*/		return 0x821021C0;
		  /* 821021C0h */ case    2:  		/* stw R7, <#[R11 + 12]> */
		/* 821021C0h case    2:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 821021C0h case    2:*/		return 0x821021C4;
		  /* 821021C4h */ case    3:  		/* stw R9, <#[R11 + 4]> */
		/* 821021C4h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821021C4h case    3:*/		return 0x821021C8;
		  /* 821021C8h */ case    4:  		/* rlwimi R10, R7, 0, 12, 31 */
		/* 821021C8h case    4:*/		cpu::op::rlwimi<0,0,12,31>(regs,&regs.R10,regs.R7);
		/* 821021C8h case    4:*/		return 0x821021CC;
	}
	return 0x821021CC;
} // Block from 821021B8h-821021CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821021CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821021CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821021CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821021CC);
		  /* 821021CCh */ case    0:  		/* stw R10, <#[R11]> */
		/* 821021CCh case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821021CCh case    0:*/		return 0x821021D0;
	}
	return 0x821021D0;
} // Block from 821021CCh-821021D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821021D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821021D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821021D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821021D0);
		  /* 821021D0h */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 821021D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821021D0h case    0:*/		return 0x821021D4;
		  /* 821021D4h */ case    1:  		/* addi R29, R29, 1 */
		/* 821021D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821021D4h case    1:*/		return 0x821021D8;
		  /* 821021D8h */ case    2:  		/* addi R30, R30, 4 */
		/* 821021D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 821021D8h case    2:*/		return 0x821021DC;
		  /* 821021DCh */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 821021DCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821021DCh case    3:*/		return 0x821021E0;
		  /* 821021E0h */ case    4:  		/* bc 12, CR6_LT, -464 */
		/* 821021E0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82102010;  }
		/* 821021E0h case    4:*/		return 0x821021E4;
	}
	return 0x821021E4;
} // Block from 821021D0h-821021E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821021E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821021E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821021E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821021E4);
		  /* 821021E4h */ case    0:  		/* cntlzw R11, R28 */
		/* 821021E4h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R28);
		/* 821021E4h case    0:*/		return 0x821021E8;
		  /* 821021E8h */ case    1:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 821021E8h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 821021E8h case    1:*/		return 0x821021EC;
		  /* 821021ECh */ case    2:  		/* b -462664 */
		/* 821021ECh case    2:*/		return 0x820912A4;
		/* 821021ECh case    2:*/		return 0x821021F0;
	}
	return 0x821021F0;
} // Block from 821021E4h-821021F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821021F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821021F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821021F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821021F0);
		  /* 821021F0h */ case    0:  		/* mfspr R12, LR */
		/* 821021F0h case    0:*/		regs.R12 = regs.LR;
		/* 821021F0h case    0:*/		return 0x821021F4;
		  /* 821021F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821021F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821021F4h case    1:*/		return 0x821021F8;
		  /* 821021F8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821021F8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821021F8h case    2:*/		return 0x821021FC;
		  /* 821021FCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821021FCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821021FCh case    3:*/		return 0x82102200;
		  /* 82102200h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82102200h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82102200h case    4:*/		return 0x82102204;
		  /* 82102204h */ case    5:  		/* mr R30, R3 */
		/* 82102204h case    5:*/		regs.R30 = regs.R3;
		/* 82102204h case    5:*/		return 0x82102208;
		  /* 82102208h */ case    6:  		/* mr R3, R4 */
		/* 82102208h case    6:*/		regs.R3 = regs.R4;
		/* 82102208h case    6:*/		return 0x8210220C;
		  /* 8210220Ch */ case    7:  		/* mr R31, R4 */
		/* 8210220Ch case    7:*/		regs.R31 = regs.R4;
		/* 8210220Ch case    7:*/		return 0x82102210;
		  /* 82102210h */ case    8:  		/* bl -23984 */
		/* 82102210h case    8:*/		regs.LR = 0x82102214; return 0x820FC460;
		/* 82102210h case    8:*/		return 0x82102214;
		  /* 82102214h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 82102214h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82102214h case    9:*/		return 0x82102218;
		  /* 82102218h */ case   10:  		/* bc 4, CR0_EQ, 12 */
		/* 82102218h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82102224;  }
		/* 82102218h case   10:*/		return 0x8210221C;
		  /* 8210221Ch */ case   11:  		/* li R3, 0 */
		/* 8210221Ch case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210221Ch case   11:*/		return 0x82102220;
		  /* 82102220h */ case   12:  		/* b 312 */
		/* 82102220h case   12:*/		return 0x82102358;
		/* 82102220h case   12:*/		return 0x82102224;
	}
	return 0x82102224;
} // Block from 821021F0h-82102224h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82102224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102224);
		  /* 82102224h */ case    0:  		/* lwz R9, <#[R31]> */
		/* 82102224h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82102224h case    0:*/		return 0x82102228;
		  /* 82102228h */ case    1:  		/* lis R10, 24704 */
		/* 82102228h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x6080);
		/* 82102228h case    1:*/		return 0x8210222C;
		  /* 8210222Ch */ case    2:  		/* rlwinm R11, R9, 0, 0, 11 */
		/* 8210222Ch case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R9);
		/* 8210222Ch case    2:*/		return 0x82102230;
		  /* 82102230h */ case    3:  		/* rlwinm R6, R9, 0, 12, 31 */
		/* 82102230h case    3:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R6,regs.R9);
		/* 82102230h case    3:*/		return 0x82102234;
		  /* 82102234h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 82102234h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82102234h case    4:*/		return 0x82102238;
		  /* 82102238h */ case    5:  		/* bc 12, CR6_GT, 96 */
		/* 82102238h case    5:*/		if ( regs.CR[6].gt ) { return 0x82102298;  }
		/* 82102238h case    5:*/		return 0x8210223C;
		  /* 8210223Ch */ case    6:  		/* bc 12, CR6_EQ, 164 */
		/* 8210223Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x821022E0;  }
		/* 8210223Ch case    6:*/		return 0x82102240;
		  /* 82102240h */ case    7:  		/* lis R10, 4304 */
		/* 82102240h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x10D0);
		/* 82102240h case    7:*/		return 0x82102244;
		  /* 82102244h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 82102244h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82102244h case    8:*/		return 0x82102248;
		  /* 82102248h */ case    9:  		/* bc 12, CR6_EQ, 72 */
		/* 82102248h case    9:*/		if ( regs.CR[6].eq ) { return 0x82102290;  }
		/* 82102248h case    9:*/		return 0x8210224C;
		  /* 8210224Ch */ case   10:  		/* lis R10, 4320 */
		/* 8210224Ch case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x10E0);
		/* 8210224Ch case   10:*/		return 0x82102250;
		  /* 82102250h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 82102250h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82102250h case   11:*/		return 0x82102254;
		  /* 82102254h */ case   12:  		/* bc 12, CR6_EQ, 60 */
		/* 82102254h case   12:*/		if ( regs.CR[6].eq ) { return 0x82102290;  }
		/* 82102254h case   12:*/		return 0x82102258;
		  /* 82102258h */ case   13:  		/* lis R10, 24576 */
		/* 82102258h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x6000);
		/* 82102258h case   13:*/		return 0x8210225C;
		  /* 8210225Ch */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 8210225Ch case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210225Ch case   14:*/		return 0x82102260;
		  /* 82102260h */ case   15:  		/* bc 12, CR6_EQ, 128 */
		/* 82102260h case   15:*/		if ( regs.CR[6].eq ) { return 0x821022E0;  }
		/* 82102260h case   15:*/		return 0x82102264;
		  /* 82102264h */ case   16:  		/* lis R10, 24608 */
		/* 82102264h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0x6020);
		/* 82102264h case   16:*/		return 0x82102268;
		  /* 82102268h */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 82102268h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82102268h case   17:*/		return 0x8210226C;
		  /* 8210226Ch */ case   18:  		/* bc 12, CR6_EQ, 116 */
		/* 8210226Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x821022E0;  }
		/* 8210226Ch case   18:*/		return 0x82102270;
		  /* 82102270h */ case   19:  		/* lis R10, 24624 */
		/* 82102270h case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0x6030);
		/* 82102270h case   19:*/		return 0x82102274;
		  /* 82102274h */ case   20:  		/* cmplw CR6, R11, R10 */
		/* 82102274h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82102274h case   20:*/		return 0x82102278;
		  /* 82102278h */ case   21:  		/* bc 12, CR6_EQ, 104 */
		/* 82102278h case   21:*/		if ( regs.CR[6].eq ) { return 0x821022E0;  }
		/* 82102278h case   21:*/		return 0x8210227C;
		  /* 8210227Ch */ case   22:  		/* lis R10, 24656 */
		/* 8210227Ch case   22:*/		cpu::op::lis<0>(regs,&regs.R10,0x6050);
		/* 8210227Ch case   22:*/		return 0x82102280;
		  /* 82102280h */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 82102280h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82102280h case   23:*/		return 0x82102284;
		  /* 82102284h */ case   24:  		/* bc 12, CR6_EQ, 92 */
		/* 82102284h case   24:*/		if ( regs.CR[6].eq ) { return 0x821022E0;  }
		/* 82102284h case   24:*/		return 0x82102288;
		  /* 82102288h */ case   25:  		/* lis R10, 24688 */
		/* 82102288h case   25:*/		cpu::op::lis<0>(regs,&regs.R10,0x6070);
		/* 82102288h case   25:*/		return 0x8210228C;
		  /* 8210228Ch */ case   26:  		/* b 76 */
		/* 8210228Ch case   26:*/		return 0x821022D8;
		/* 8210228Ch case   26:*/		return 0x82102290;
	}
	return 0x82102290;
} // Block from 82102224h-82102290h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82102290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102290);
		  /* 82102290h */ case    0:  		/* li R11, 0 */
		/* 82102290h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82102290h case    0:*/		return 0x82102294;
		  /* 82102294h */ case    1:  		/* b 80 */
		/* 82102294h case    1:*/		return 0x821022E4;
		/* 82102294h case    1:*/		return 0x82102298;
	}
	return 0x82102298;
} // Block from 82102290h-82102298h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102298);
		  /* 82102298h */ case    0:  		/* lis R10, 24736 */
		/* 82102298h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x60A0);
		/* 82102298h case    0:*/		return 0x8210229C;
		  /* 8210229Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 8210229Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210229Ch case    1:*/		return 0x821022A0;
		  /* 821022A0h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 821022A0h case    2:*/		if ( regs.CR[6].eq ) { return 0x821022E0;  }
		/* 821022A0h case    2:*/		return 0x821022A4;
		  /* 821022A4h */ case    3:  		/* lis R10, 24768 */
		/* 821022A4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x60C0);
		/* 821022A4h case    3:*/		return 0x821022A8;
		  /* 821022A8h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 821022A8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821022A8h case    4:*/		return 0x821022AC;
		  /* 821022ACh */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 821022ACh case    5:*/		if ( regs.CR[6].eq ) { return 0x821022E0;  }
		/* 821022ACh case    5:*/		return 0x821022B0;
		  /* 821022B0h */ case    6:  		/* lis R10, 24784 */
		/* 821022B0h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x60D0);
		/* 821022B0h case    6:*/		return 0x821022B4;
		  /* 821022B4h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 821022B4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821022B4h case    7:*/		return 0x821022B8;
		  /* 821022B8h */ case    8:  		/* bc 12, CR6_EQ, 40 */
		/* 821022B8h case    8:*/		if ( regs.CR[6].eq ) { return 0x821022E0;  }
		/* 821022B8h case    8:*/		return 0x821022BC;
		  /* 821022BCh */ case    9:  		/* lis R10, 24816 */
		/* 821022BCh case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0x60F0);
		/* 821022BCh case    9:*/		return 0x821022C0;
		  /* 821022C0h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 821022C0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821022C0h case   10:*/		return 0x821022C4;
		  /* 821022C4h */ case   11:  		/* bc 12, CR6_EQ, 28 */
		/* 821022C4h case   11:*/		if ( regs.CR[6].eq ) { return 0x821022E0;  }
		/* 821022C4h case   11:*/		return 0x821022C8;
		  /* 821022C8h */ case   12:  		/* lis R10, 24848 */
		/* 821022C8h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x6110);
		/* 821022C8h case   12:*/		return 0x821022CC;
		  /* 821022CCh */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 821022CCh case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821022CCh case   13:*/		return 0x821022D0;
		  /* 821022D0h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 821022D0h case   14:*/		if ( regs.CR[6].eq ) { return 0x821022E0;  }
		/* 821022D0h case   14:*/		return 0x821022D4;
		  /* 821022D4h */ case   15:  		/* lis R10, 24864 */
		/* 821022D4h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0x6120);
		/* 821022D4h case   15:*/		return 0x821022D8;
	}
	return 0x821022D8;
} // Block from 82102298h-821022D8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821022D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821022D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821022D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821022D8);
		  /* 821022D8h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 821022D8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821022D8h case    0:*/		return 0x821022DC;
		  /* 821022DCh */ case    1:  		/* bc 4, CR6_EQ, -192 */
		/* 821022DCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210221C;  }
		/* 821022DCh case    1:*/		return 0x821022E0;
	}
	return 0x821022E0;
} // Block from 821022D8h-821022E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821022E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821022E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821022E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821022E0);
		  /* 821022E0h */ case    0:  		/* mr R11, R6 */
		/* 821022E0h case    0:*/		regs.R11 = regs.R6;
		/* 821022E0h case    0:*/		return 0x821022E4;
	}
	return 0x821022E4;
} // Block from 821022E0h-821022E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821022E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821022E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821022E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821022E4);
		  /* 821022E4h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 821022E4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821022E4h case    0:*/		return 0x821022E8;
		  /* 821022E8h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821022E8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821022E8h case    1:*/		return 0x821022EC;
		  /* 821022ECh */ case    2:  		/* lwz R9, <#[R30 + 20]> */
		/* 821022ECh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 821022ECh case    2:*/		return 0x821022F0;
		  /* 821022F0h */ case    3:  		/* lwz R7, <#[R30 + 16]> */
		/* 821022F0h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000010) );
		/* 821022F0h case    3:*/		return 0x821022F4;
		  /* 821022F4h */ case    4:  		/* lwzx R8, <#[R10 + R11]> */
		/* 821022F4h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821022F4h case    4:*/		return 0x821022F8;
		  /* 821022F8h */ case    5:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821022F8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821022F8h case    5:*/		return 0x821022FC;
		  /* 821022FCh */ case    6:  		/* lwzx R8, <#[R8 + R9]> */
		/* 821022FCh case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 821022FCh case    6:*/		return 0x82102300;
		  /* 82102300h */ case    7:  		/* lwz R8, <#[R8 + 4]> */
		/* 82102300h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 82102300h case    7:*/		return 0x82102304;
		  /* 82102304h */ case    8:  		/* rlwinm R5, R8, 2, 0, 29 */
		/* 82102304h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R8);
		/* 82102304h case    8:*/		return 0x82102308;
		  /* 82102308h */ case    9:  		/* lwzx R7, <#[R5 + R7]> */
		/* 82102308h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + regs.R7 + 0x00000000) );
		/* 82102308h case    9:*/		return 0x8210230C;
		  /* 8210230Ch */ case   10:  		/* lwz R7, <#[R7 + 4]> */
		/* 8210230Ch case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 8210230Ch case   10:*/		return 0x82102310;
		  /* 82102310h */ case   11:  		/* andi. R7, R7, 528 */
		/* 82102310h case   11:*/		cpu::op::andi<1>(regs,&regs.R7,regs.R7,0x210);
		/* 82102310h case   11:*/		return 0x82102314;
		  /* 82102314h */ case   12:  		/* cmplwi CR0, R7, 0 */
		/* 82102314h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R7,0x00000000);
		/* 82102314h case   12:*/		return 0x82102318;
		  /* 82102318h */ case   13:  		/* bc 12, CR0_EQ, -252 */
		/* 82102318h case   13:*/		if ( regs.CR[0].eq ) { return 0x8210221C;  }
		/* 82102318h case   13:*/		return 0x8210231C;
		  /* 8210231Ch */ case   14:  		/* li R7, 1 */
		/* 8210231Ch case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8210231Ch case   14:*/		return 0x82102320;
		  /* 82102320h */ case   15:  		/* cmplwi CR6, R6, 1 */
		/* 82102320h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000001);
		/* 82102320h case   15:*/		return 0x82102324;
		  /* 82102324h */ case   16:  		/* bc 4, CR6_GT, 48 */
		/* 82102324h case   16:*/		if ( !regs.CR[6].gt ) { return 0x82102354;  }
		/* 82102324h case   16:*/		return 0x82102328;
		  /* 82102328h */ case   17:  		/* addi R11, R11, 4 */
		/* 82102328h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82102328h case   17:*/		return 0x8210232C;
		  /* 8210232Ch */ case   18:  		/* lwzx R5, <#[R11 + R10]> */
		/* 8210232Ch case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210232Ch case   18:*/		return 0x82102330;
		  /* 82102330h */ case   19:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82102330h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82102330h case   19:*/		return 0x82102334;
		  /* 82102334h */ case   20:  		/* lwzx R5, <#[R5 + R9]> */
		/* 82102334h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 82102334h case   20:*/		return 0x82102338;
		  /* 82102338h */ case   21:  		/* lwz R5, <#[R5 + 4]> */
		/* 82102338h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000004) );
		/* 82102338h case   21:*/		return 0x8210233C;
		  /* 8210233Ch */ case   22:  		/* cmplw CR6, R5, R8 */
		/* 8210233Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R8);
		/* 8210233Ch case   22:*/		return 0x82102340;
		  /* 82102340h */ case   23:  		/* bc 4, CR6_EQ, -292 */
		/* 82102340h case   23:*/		if ( !regs.CR[6].eq ) { return 0x8210221C;  }
		/* 82102340h case   23:*/		return 0x82102344;
		  /* 82102344h */ case   24:  		/* addi R7, R7, 1 */
		/* 82102344h case   24:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82102344h case   24:*/		return 0x82102348;
		  /* 82102348h */ case   25:  		/* addi R11, R11, 4 */
		/* 82102348h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82102348h case   25:*/		return 0x8210234C;
		  /* 8210234Ch */ case   26:  		/* cmplw CR6, R7, R6 */
		/* 8210234Ch case   26:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8210234Ch case   26:*/		return 0x82102350;
		  /* 82102350h */ case   27:  		/* bc 12, CR6_LT, -36 */
		/* 82102350h case   27:*/		if ( regs.CR[6].lt ) { return 0x8210232C;  }
		/* 82102350h case   27:*/		return 0x82102354;
	}
	return 0x82102354;
} // Block from 821022E4h-82102354h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82102354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102354);
		  /* 82102354h */ case    0:  		/* li R3, 1 */
		/* 82102354h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82102354h case    0:*/		return 0x82102358;
	}
	return 0x82102358;
} // Block from 82102354h-82102358h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82102358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102358);
		  /* 82102358h */ case    0:  		/* addi R1, R1, 112 */
		/* 82102358h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82102358h case    0:*/		return 0x8210235C;
		  /* 8210235Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8210235Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8210235Ch case    1:*/		return 0x82102360;
	}
	return 0x82102360;
} // Block from 82102358h-82102360h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102360h
// Function '?InstructionIsSubset@D3DXShader@@YAHIIPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102360);
		  /* 82102360h */ case    0:  		/* mtspr LR, R12 */
		/* 82102360h case    0:*/		regs.LR = regs.R12;
		/* 82102360h case    0:*/		return 0x82102364;
		  /* 82102364h */ case    1:  		/* ld R30, <#[R1 - 24]> */
		/* 82102364h case    1:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82102364h case    1:*/		return 0x82102368;
		  /* 82102368h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 82102368h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82102368h case    2:*/		return 0x8210236C;
		  /* 8210236Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 8210236Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8210236Ch case    3:*/		return 0x82102370;
	}
	return 0x82102370;
} // Block from 82102360h-82102370h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82102370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102370);
		  /* 82102370h */ case    0:  		/* mfspr R12, LR */
		/* 82102370h case    0:*/		regs.R12 = regs.LR;
		/* 82102370h case    0:*/		return 0x82102374;
		  /* 82102374h */ case    1:  		/* bl -463136 */
		/* 82102374h case    1:*/		regs.LR = 0x82102378; return 0x82091254;
		/* 82102374h case    1:*/		return 0x82102378;
		  /* 82102378h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82102378h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82102378h case    2:*/		return 0x8210237C;
		  /* 8210237Ch */ case    3:  		/* lwz R11, <#[R4 + 72]> */
		/* 8210237Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000048) );
		/* 8210237Ch case    3:*/		return 0x82102380;
		  /* 82102380h */ case    4:  		/* mr R31, R3 */
		/* 82102380h case    4:*/		regs.R31 = regs.R3;
		/* 82102380h case    4:*/		return 0x82102384;
		  /* 82102384h */ case    5:  		/* mr R28, R4 */
		/* 82102384h case    5:*/		regs.R28 = regs.R4;
		/* 82102384h case    5:*/		return 0x82102388;
		  /* 82102388h */ case    6:  		/* mr R27, R5 */
		/* 82102388h case    6:*/		regs.R27 = regs.R5;
		/* 82102388h case    6:*/		return 0x8210238C;
		  /* 8210238Ch */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 8210238Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210238Ch case    7:*/		return 0x82102390;
		  /* 82102390h */ case    8:  		/* bc 12, CR6_EQ, 376 */
		/* 82102390h case    8:*/		if ( regs.CR[6].eq ) { return 0x82102508;  }
		/* 82102390h case    8:*/		return 0x82102394;
		  /* 82102394h */ case    9:  		/* lwz R11, <#[R5 + 20]> */
		/* 82102394h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000014) );
		/* 82102394h case    9:*/		return 0x82102398;
		  /* 82102398h */ case   10:  		/* cmpwi CR6, R11, -1 */
		/* 82102398h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82102398h case   10:*/		return 0x8210239C;
		  /* 8210239Ch */ case   11:  		/* bc 12, CR6_EQ, 364 */
		/* 8210239Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82102508;  }
		/* 8210239Ch case   11:*/		return 0x821023A0;
		  /* 821023A0h */ case   12:  		/* li R29, 1 */
		/* 821023A0h case   12:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 821023A0h case   12:*/		return 0x821023A4;
		  /* 821023A4h */ case   13:  		/* b 40 */
		/* 821023A4h case   13:*/		return 0x821023CC;
		/* 821023A4h case   13:*/		return 0x821023A8;
		  /* 821023A8h */ case   14:  		/* lwz R10, <#[R31 + 24]> */
		/* 821023A8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 821023A8h case   14:*/		return 0x821023AC;
		  /* 821023ACh */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821023ACh case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821023ACh case   15:*/		return 0x821023B0;
		  /* 821023B0h */ case   16:  		/* lwzx R3, <#[R11 + R10]> */
		/* 821023B0h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821023B0h case   16:*/		return 0x821023B4;
		  /* 821023B4h */ case   17:  		/* bl -25204 */
		/* 821023B4h case   17:*/		regs.LR = 0x821023B8; return 0x820FC140;
		/* 821023B4h case   17:*/		return 0x821023B8;
		  /* 821023B8h */ case   18:  		/* cmpwi CR0, R3, 0 */
		/* 821023B8h case   18:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821023B8h case   18:*/		return 0x821023BC;
		  /* 821023BCh */ case   19:  		/* bc 12, CR0_EQ, 44 */
		/* 821023BCh case   19:*/		if ( regs.CR[0].eq ) { return 0x821023E8;  }
		/* 821023BCh case   19:*/		return 0x821023C0;
		  /* 821023C0h */ case   20:  		/* lwz R11, <#[R30 + 20]> */
		/* 821023C0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 821023C0h case   20:*/		return 0x821023C4;
		  /* 821023C4h */ case   21:  		/* cmpwi CR6, R11, -1 */
		/* 821023C4h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821023C4h case   21:*/		return 0x821023C8;
		  /* 821023C8h */ case   22:  		/* bc 12, CR6_EQ, 36 */
		/* 821023C8h case   22:*/		if ( regs.CR[6].eq ) { return 0x821023EC;  }
		/* 821023C8h case   22:*/		return 0x821023CC;
	}
	return 0x821023CC;
} // Block from 82102370h-821023CCh (23 instructions)

//////////////////////////////////////////////////////
// Block at 821023CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821023CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821023CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821023CC);
		  /* 821023CCh */ case    0:  		/* lwz R10, <#[R31 + 20]> */
		/* 821023CCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821023CCh case    0:*/		return 0x821023D0;
		  /* 821023D0h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821023D0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821023D0h case    1:*/		return 0x821023D4;
		  /* 821023D4h */ case    2:  		/* lwzx R30, <#[R11 + R10]> */
		/* 821023D4h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821023D4h case    2:*/		return 0x821023D8;
		  /* 821023D8h */ case    3:  		/* lwz R11, <#[R30 + 72]> */
		/* 821023D8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000048) );
		/* 821023D8h case    3:*/		return 0x821023DC;
		  /* 821023DCh */ case    4:  		/* cmpwi CR6, R11, -1 */
		/* 821023DCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821023DCh case    4:*/		return 0x821023E0;
		  /* 821023E0h */ case    5:  		/* bc 4, CR6_EQ, -56 */
		/* 821023E0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821023A8;  }
		/* 821023E0h case    5:*/		return 0x821023E4;
		  /* 821023E4h */ case    6:  		/* b 8 */
		/* 821023E4h case    6:*/		return 0x821023EC;
		/* 821023E4h case    6:*/		return 0x821023E8;
	}
	return 0x821023E8;
} // Block from 821023CCh-821023E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821023E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821023E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821023E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821023E8);
		  /* 821023E8h */ case    0:  		/* li R29, 0 */
		/* 821023E8h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821023E8h case    0:*/		return 0x821023EC;
	}
	return 0x821023EC;
} // Block from 821023E8h-821023ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821023ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821023EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821023EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821023EC);
		  /* 821023ECh */ case    0:  		/* lwz R11, <#[R28 + 72]> */
		/* 821023ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000048) );
		/* 821023ECh case    0:*/		return 0x821023F0;
		  /* 821023F0h */ case    1:  		/* lwz R10, <#[R31 + 24]> */
		/* 821023F0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 821023F0h case    1:*/		return 0x821023F4;
		  /* 821023F4h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821023F4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821023F4h case    2:*/		return 0x821023F8;
		  /* 821023F8h */ case    3:  		/* lwzx R30, <#[R11 + R10]> */
		/* 821023F8h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821023F8h case    3:*/		return 0x821023FC;
		  /* 821023FCh */ case    4:  		/* mr R3, R30 */
		/* 821023FCh case    4:*/		regs.R3 = regs.R30;
		/* 821023FCh case    4:*/		return 0x82102400;
		  /* 82102400h */ case    5:  		/* bl -24480 */
		/* 82102400h case    5:*/		regs.LR = 0x82102404; return 0x820FC460;
		/* 82102400h case    5:*/		return 0x82102404;
		  /* 82102404h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 82102404h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82102404h case    6:*/		return 0x82102408;
		  /* 82102408h */ case    7:  		/* bc 12, CR0_EQ, 256 */
		/* 82102408h case    7:*/		if ( regs.CR[0].eq ) { return 0x82102508;  }
		/* 82102408h case    7:*/		return 0x8210240C;
		  /* 8210240Ch */ case    8:  		/* mr R4, R30 */
		/* 8210240Ch case    8:*/		regs.R4 = regs.R30;
		/* 8210240Ch case    8:*/		return 0x82102410;
		  /* 82102410h */ case    9:  		/* mr R3, R31 */
		/* 82102410h case    9:*/		regs.R3 = regs.R31;
		/* 82102410h case    9:*/		return 0x82102414;
		  /* 82102414h */ case   10:  		/* bl -548 */
		/* 82102414h case   10:*/		regs.LR = 0x82102418; return 0x821021F0;
		/* 82102414h case   10:*/		return 0x82102418;
		  /* 82102418h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 82102418h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82102418h case   11:*/		return 0x8210241C;
		  /* 8210241Ch */ case   12:  		/* bc 4, CR0_EQ, 236 */
		/* 8210241Ch case   12:*/		if ( !regs.CR[0].eq ) { return 0x82102508;  }
		/* 8210241Ch case   12:*/		return 0x82102420;
		  /* 82102420h */ case   13:  		/* cmpwi CR6, R29, 0 */
		/* 82102420h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82102420h case   13:*/		return 0x82102424;
		  /* 82102424h */ case   14:  		/* bc 4, CR6_EQ, 228 */
		/* 82102424h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82102508;  }
		/* 82102424h case   14:*/		return 0x82102428;
		  /* 82102428h */ case   15:  		/* lwz R11, <#[R27 + 20]> */
		/* 82102428h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 82102428h case   15:*/		return 0x8210242C;
		  /* 8210242Ch */ case   16:  		/* lwz R10, <#[R31 + 20]> */
		/* 8210242Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 8210242Ch case   16:*/		return 0x82102430;
		  /* 82102430h */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102430h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102430h case   17:*/		return 0x82102434;
		  /* 82102434h */ case   18:  		/* lwz R9, <#[R31 + 24]> */
		/* 82102434h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 82102434h case   18:*/		return 0x82102438;
		  /* 82102438h */ case   19:  		/* lwzx R30, <#[R11 + R10]> */
		/* 82102438h case   19:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82102438h case   19:*/		return 0x8210243C;
		  /* 8210243Ch */ case   20:  		/* lwz R11, <#[R30 + 72]> */
		/* 8210243Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000048) );
		/* 8210243Ch case   20:*/		return 0x82102440;
		  /* 82102440h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102440h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102440h case   21:*/		return 0x82102444;
		  /* 82102444h */ case   22:  		/* lwzx R3, <#[R11 + R9]> */
		/* 82102444h case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82102444h case   22:*/		return 0x82102448;
		  /* 82102448h */ case   23:  		/* bl -25352 */
		/* 82102448h case   23:*/		regs.LR = 0x8210244C; return 0x820FC140;
		/* 82102448h case   23:*/		return 0x8210244C;
		  /* 8210244Ch */ case   24:  		/* mr R29, R28 */
		/* 8210244Ch case   24:*/		regs.R29 = regs.R28;
		/* 8210244Ch case   24:*/		return 0x82102450;
		  /* 82102450h */ case   25:  		/* cmpwi CR6, R3, 0 */
		/* 82102450h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82102450h case   25:*/		return 0x82102454;
		  /* 82102454h */ case   26:  		/* bc 4, CR6_EQ, 100 */
		/* 82102454h case   26:*/		if ( !regs.CR[6].eq ) { return 0x821024B8;  }
		/* 82102454h case   26:*/		return 0x82102458;
		  /* 82102458h */ case   27:  		/* lwz R11, <#[R30 + 20]> */
		/* 82102458h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82102458h case   27:*/		return 0x8210245C;
		  /* 8210245Ch */ case   28:  		/* stw R11, <#[R29 + 20]> */
		/* 8210245Ch case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 8210245Ch case   28:*/		return 0x82102460;
		  /* 82102460h */ case   29:  		/* lwz R11, <#[R30 + 24]> */
		/* 82102460h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82102460h case   29:*/		return 0x82102464;
		  /* 82102464h */ case   30:  		/* stw R11, <#[R29 + 24]> */
		/* 82102464h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 82102464h case   30:*/		return 0x82102468;
		  /* 82102468h */ case   31:  		/* lwz R11, <#[R30 + 20]> */
		/* 82102468h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82102468h case   31:*/		return 0x8210246C;
		  /* 8210246Ch */ case   32:  		/* cmpwi CR6, R11, -1 */
		/* 8210246Ch case   32:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210246Ch case   32:*/		return 0x82102470;
		  /* 82102470h */ case   33:  		/* bc 12, CR6_EQ, 64 */
		/* 82102470h case   33:*/		if ( regs.CR[6].eq ) { return 0x821024B0;  }
		/* 82102470h case   33:*/		return 0x82102474;
		  /* 82102474h */ case   34:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82102474h case   34:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82102474h case   34:*/		return 0x82102478;
		  /* 82102478h */ case   35:  		/* lwz R10, <#[R31 + 20]> */
		/* 82102478h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82102478h case   35:*/		return 0x8210247C;
		  /* 8210247Ch */ case   36:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210247Ch case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210247Ch case   36:*/		return 0x82102480;
		  /* 82102480h */ case   37:  		/* lwzx R30, <#[R11 + R10]> */
		/* 82102480h case   37:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82102480h case   37:*/		return 0x82102484;
		  /* 82102484h */ case   38:  		/* lwz R11, <#[R30 + 72]> */
		/* 82102484h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000048) );
		/* 82102484h case   38:*/		return 0x82102488;
		  /* 82102488h */ case   39:  		/* cmpwi CR6, R11, -1 */
		/* 82102488h case   39:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82102488h case   39:*/		return 0x8210248C;
		  /* 8210248Ch */ case   40:  		/* bc 12, CR6_EQ, 32 */
		/* 8210248Ch case   40:*/		if ( regs.CR[6].eq ) { return 0x821024AC;  }
		/* 8210248Ch case   40:*/		return 0x82102490;
		  /* 82102490h */ case   41:  		/* lwz R10, <#[R31 + 24]> */
		/* 82102490h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82102490h case   41:*/		return 0x82102494;
		  /* 82102494h */ case   42:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102494h case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102494h case   42:*/		return 0x82102498;
		  /* 82102498h */ case   43:  		/* lwzx R3, <#[R11 + R10]> */
		/* 82102498h case   43:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82102498h case   43:*/		return 0x8210249C;
		  /* 8210249Ch */ case   44:  		/* bl -25436 */
		/* 8210249Ch case   44:*/		regs.LR = 0x821024A0; return 0x820FC140;
		/* 8210249Ch case   44:*/		return 0x821024A0;
		  /* 821024A0h */ case   45:  		/* cmpwi CR0, R3, 0 */
		/* 821024A0h case   45:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821024A0h case   45:*/		return 0x821024A4;
		  /* 821024A4h */ case   46:  		/* bc 12, CR0_EQ, -76 */
		/* 821024A4h case   46:*/		if ( regs.CR[0].eq ) { return 0x82102458;  }
		/* 821024A4h case   46:*/		return 0x821024A8;
		  /* 821024A8h */ case   47:  		/* b 8 */
		/* 821024A8h case   47:*/		return 0x821024B0;
		/* 821024A8h case   47:*/		return 0x821024AC;
	}
	return 0x821024AC;
} // Block from 821023ECh-821024ACh (48 instructions)

//////////////////////////////////////////////////////
// Block at 821024ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821024AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821024AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821024AC);
		  /* 821024ACh */ case    0:  		/* li R3, 0 */
		/* 821024ACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821024ACh case    0:*/		return 0x821024B0;
	}
	return 0x821024B0;
} // Block from 821024ACh-821024B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821024B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821024B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821024B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821024B0);
		  /* 821024B0h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 821024B0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 821024B0h case    0:*/		return 0x821024B4;
		  /* 821024B4h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 821024B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82102508;  }
		/* 821024B4h case    1:*/		return 0x821024B8;
	}
	return 0x821024B8;
} // Block from 821024B0h-821024B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821024B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821024B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821024B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821024B8);
		  /* 821024B8h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 821024B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 821024B8h case    0:*/		return 0x821024BC;
		  /* 821024BCh */ case    1:  		/* mr R29, R30 */
		/* 821024BCh case    1:*/		regs.R29 = regs.R30;
		/* 821024BCh case    1:*/		return 0x821024C0;
		  /* 821024C0h */ case    2:  		/* cmpwi CR6, R11, -1 */
		/* 821024C0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821024C0h case    2:*/		return 0x821024C4;
		  /* 821024C4h */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 821024C4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82102500;  }
		/* 821024C4h case    3:*/		return 0x821024C8;
		  /* 821024C8h */ case    4:  		/* lwz R10, <#[R31 + 20]> */
		/* 821024C8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821024C8h case    4:*/		return 0x821024CC;
		  /* 821024CCh */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821024CCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821024CCh case    5:*/		return 0x821024D0;
		  /* 821024D0h */ case    6:  		/* lwzx R30, <#[R11 + R10]> */
		/* 821024D0h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821024D0h case    6:*/		return 0x821024D4;
		  /* 821024D4h */ case    7:  		/* lwz R11, <#[R30 + 72]> */
		/* 821024D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000048) );
		/* 821024D4h case    7:*/		return 0x821024D8;
		  /* 821024D8h */ case    8:  		/* cmpwi CR6, R11, -1 */
		/* 821024D8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821024D8h case    8:*/		return 0x821024DC;
		  /* 821024DCh */ case    9:  		/* bc 12, CR6_EQ, 32 */
		/* 821024DCh case    9:*/		if ( regs.CR[6].eq ) { return 0x821024FC;  }
		/* 821024DCh case    9:*/		return 0x821024E0;
		  /* 821024E0h */ case   10:  		/* lwz R10, <#[R31 + 24]> */
		/* 821024E0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 821024E0h case   10:*/		return 0x821024E4;
		  /* 821024E4h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821024E4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821024E4h case   11:*/		return 0x821024E8;
		  /* 821024E8h */ case   12:  		/* lwzx R3, <#[R11 + R10]> */
		/* 821024E8h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821024E8h case   12:*/		return 0x821024EC;
		  /* 821024ECh */ case   13:  		/* bl -25516 */
		/* 821024ECh case   13:*/		regs.LR = 0x821024F0; return 0x820FC140;
		/* 821024ECh case   13:*/		return 0x821024F0;
		  /* 821024F0h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 821024F0h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821024F0h case   14:*/		return 0x821024F4;
		  /* 821024F4h */ case   15:  		/* bc 4, CR0_EQ, -60 */
		/* 821024F4h case   15:*/		if ( !regs.CR[0].eq ) { return 0x821024B8;  }
		/* 821024F4h case   15:*/		return 0x821024F8;
		  /* 821024F8h */ case   16:  		/* b -168 */
		/* 821024F8h case   16:*/		return 0x82102450;
		/* 821024F8h case   16:*/		return 0x821024FC;
	}
	return 0x821024FC;
} // Block from 821024B8h-821024FCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 821024FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821024FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821024FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821024FC);
		  /* 821024FCh */ case    0:  		/* li R3, 0 */
		/* 821024FCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821024FCh case    0:*/		return 0x82102500;
	}
	return 0x82102500;
} // Block from 821024FCh-82102500h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82102500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102500);
		  /* 82102500h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 82102500h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82102500h case    0:*/		return 0x82102504;
		  /* 82102504h */ case    1:  		/* bc 12, CR6_EQ, -172 */
		/* 82102504h case    1:*/		if ( regs.CR[6].eq ) { return 0x82102458;  }
		/* 82102504h case    1:*/		return 0x82102508;
	}
	return 0x82102508;
} // Block from 82102500h-82102508h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102508);
		  /* 82102508h */ case    0:  		/* addi R5, R28, 24 */
		/* 82102508h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R28,0x18);
		/* 82102508h case    0:*/		return 0x8210250C;
		  /* 8210250Ch */ case    1:  		/* lwz R7, <#[R27 + 24]> */
		/* 8210250Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R27 + 0x00000018) );
		/* 8210250Ch case    1:*/		return 0x82102510;
		  /* 82102510h */ case    2:  		/* addi R4, R28, 20 */
		/* 82102510h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R28,0x14);
		/* 82102510h case    2:*/		return 0x82102514;
		  /* 82102514h */ case    3:  		/* lwz R6, <#[R27 + 20]> */
		/* 82102514h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R27 + 0x00000014) );
		/* 82102514h case    3:*/		return 0x82102518;
		  /* 82102518h */ case    4:  		/* mr R3, R31 */
		/* 82102518h case    4:*/		regs.R3 = regs.R31;
		/* 82102518h case    4:*/		return 0x8210251C;
		  /* 8210251Ch */ case    5:  		/* bl -17124 */
		/* 8210251Ch case    5:*/		regs.LR = 0x82102520; return 0x820FE238;
		/* 8210251Ch case    5:*/		return 0x82102520;
		  /* 82102520h */ case    6:  		/* addi R1, R1, 128 */
		/* 82102520h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82102520h case    6:*/		return 0x82102524;
		  /* 82102524h */ case    7:  		/* b -463488 */
		/* 82102524h case    7:*/		return 0x820912A4;
		/* 82102524h case    7:*/		return 0x82102528;
	}
	return 0x82102528;
} // Block from 82102508h-82102528h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82102528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102528);
		  /* 82102528h */ case    0:  		/* mfspr R12, LR */
		/* 82102528h case    0:*/		regs.R12 = regs.LR;
		/* 82102528h case    0:*/		return 0x8210252C;
		  /* 8210252Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8210252Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8210252Ch case    1:*/		return 0x82102530;
		  /* 82102530h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82102530h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82102530h case    2:*/		return 0x82102534;
		  /* 82102534h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82102534h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82102534h case    3:*/		return 0x82102538;
		  /* 82102538h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82102538h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82102538h case    4:*/		return 0x8210253C;
		  /* 8210253Ch */ case    5:  		/* lwz R10, <#[R3 + 20]> */
		/* 8210253Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 8210253Ch case    5:*/		return 0x82102540;
		  /* 82102540h */ case    6:  		/* rlwinm R9, R5, 2, 0, 29 */
		/* 82102540h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R5);
		/* 82102540h case    6:*/		return 0x82102544;
		  /* 82102544h */ case    7:  		/* rlwinm R8, R4, 2, 0, 29 */
		/* 82102544h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R4);
		/* 82102544h case    7:*/		return 0x82102548;
		  /* 82102548h */ case    8:  		/* mr R11, R4 */
		/* 82102548h case    8:*/		regs.R11 = regs.R4;
		/* 82102548h case    8:*/		return 0x8210254C;
		  /* 8210254Ch */ case    9:  		/* lwzx R30, <#[R9 + R10]> */
		/* 8210254Ch case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210254Ch case    9:*/		return 0x82102550;
		  /* 82102550h */ case   10:  		/* lwzx R31, <#[R8 + R10]> */
		/* 82102550h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82102550h case   10:*/		return 0x82102554;
		  /* 82102554h */ case   11:  		/* mr R5, R30 */
		/* 82102554h case   11:*/		regs.R5 = regs.R30;
		/* 82102554h case   11:*/		return 0x82102558;
		  /* 82102558h */ case   12:  		/* mr R4, R31 */
		/* 82102558h case   12:*/		regs.R4 = regs.R31;
		/* 82102558h case   12:*/		return 0x8210255C;
		  /* 8210255Ch */ case   13:  		/* stw R11, <#[R30 + 48]> */
		/* 8210255Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8210255Ch case   13:*/		return 0x82102560;
		  /* 82102560h */ case   14:  		/* bl -496 */
		/* 82102560h case   14:*/		regs.LR = 0x82102564; return 0x82102370;
		/* 82102560h case   14:*/		return 0x82102564;
		  /* 82102564h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 82102564h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82102564h case   15:*/		return 0x82102568;
		  /* 82102568h */ case   16:  		/* bc 12, CR0_LT, 80 */
		/* 82102568h case   16:*/		if ( regs.CR[0].lt ) { return 0x821025B8;  }
		/* 82102568h case   16:*/		return 0x8210256C;
		  /* 8210256Ch */ case   17:  		/* lwz R9, <#[R31]> */
		/* 8210256Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8210256Ch case   17:*/		return 0x82102570;
		  /* 82102570h */ case   18:  		/* lwz R10, <#[R30]> */
		/* 82102570h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82102570h case   18:*/		return 0x82102574;
		  /* 82102574h */ case   19:  		/* rlwinm R11, R9, 0, 4, 6 */
		/* 82102574h case   19:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R9);
		/* 82102574h case   19:*/		return 0x82102578;
		  /* 82102578h */ case   20:  		/* rlwinm R10, R10, 0, 4, 6 */
		/* 82102578h case   20:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R10,regs.R10);
		/* 82102578h case   20:*/		return 0x8210257C;
		  /* 8210257Ch */ case   21:  		/* rlwinm R9, R9, 0, 7, 3 */
		/* 8210257Ch case   21:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R9,regs.R9);
		/* 8210257Ch case   21:*/		return 0x82102580;
		  /* 82102580h */ case   22:  		/* cmplw CR6, R11, R10 */
		/* 82102580h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82102580h case   22:*/		return 0x82102584;
		  /* 82102584h */ case   23:  		/* stw R9, <#[R31]> */
		/* 82102584h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82102584h case   23:*/		return 0x82102588;
		  /* 82102588h */ case   24:  		/* bc 12, CR6_GT, 8 */
		/* 82102588h case   24:*/		if ( regs.CR[6].gt ) { return 0x82102590;  }
		/* 82102588h case   24:*/		return 0x8210258C;
		  /* 8210258Ch */ case   25:  		/* mr R11, R10 */
		/* 8210258Ch case   25:*/		regs.R11 = regs.R10;
		/* 8210258Ch case   25:*/		return 0x82102590;
	}
	return 0x82102590;
} // Block from 82102528h-82102590h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82102590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102590);
		  /* 82102590h */ case    0:  		/* lwz R10, <#[R31 + 96]> */
		/* 82102590h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000060) );
		/* 82102590h case    0:*/		return 0x82102594;
		  /* 82102594h */ case    1:  		/* or R11, R9, R11 */
		/* 82102594h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82102594h case    1:*/		return 0x82102598;
		  /* 82102598h */ case    2:  		/* stw R11, <#[R31]> */
		/* 82102598h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82102598h case    2:*/		return 0x8210259C;
		  /* 8210259Ch */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 8210259Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210259Ch case    3:*/		return 0x821025A0;
	}
	return 0x821025A0;
} // Block from 82102590h-821025A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821025A0h
// Function '?CompareDuplicateInstructionsStable@D3DXShader@@YAHIIPBX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821025A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821025A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821025A0);
		  /* 821025A0h */ case    0:  		/* bc 4, CR6_EQ, 20 */
		/* 821025A0h case    0:*/		if ( !regs.CR[6].eq ) { return 0x821025B4;  }
		/* 821025A0h case    0:*/		return 0x821025A4;
		  /* 821025A4h */ case    1:  		/* lwz R11, <#[R30 + 96]> */
		/* 821025A4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000060) );
		/* 821025A4h case    1:*/		return 0x821025A8;
		  /* 821025A8h */ case    2:  		/* stw R11, <#[R31 + 96]> */
		/* 821025A8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 821025A8h case    2:*/		return 0x821025AC;
		  /* 821025ACh */ case    3:  		/* lwz R11, <#[R30 + 100]> */
		/* 821025ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000064) );
		/* 821025ACh case    3:*/		return 0x821025B0;
		  /* 821025B0h */ case    4:  		/* stw R11, <#[R31 + 100]> */
		/* 821025B0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 821025B0h case    4:*/		return 0x821025B4;
	}
	return 0x821025B4;
} // Block from 821025A0h-821025B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821025B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821025B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821025B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821025B4);
		  /* 821025B4h */ case    0:  		/* li R3, 0 */
		/* 821025B4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821025B4h case    0:*/		return 0x821025B8;
	}
	return 0x821025B8;
} // Block from 821025B4h-821025B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821025B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821025B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821025B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821025B8);
		  /* 821025B8h */ case    0:  		/* addi R1, R1, 112 */
		/* 821025B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821025B8h case    0:*/		return 0x821025BC;
		  /* 821025BCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821025BCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821025BCh case    1:*/		return 0x821025C0;
		  /* 821025C0h */ case    2:  		/* mtspr LR, R12 */
		/* 821025C0h case    2:*/		regs.LR = regs.R12;
		/* 821025C0h case    2:*/		return 0x821025C4;
		  /* 821025C4h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821025C4h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821025C4h case    3:*/		return 0x821025C8;
		  /* 821025C8h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821025C8h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821025C8h case    4:*/		return 0x821025CC;
		  /* 821025CCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 821025CCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821025CCh case    5:*/		return 0x821025D0;
	}
	return 0x821025D0;
} // Block from 821025B8h-821025D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821025D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821025D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821025D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821025D0);
		  /* 821025D0h */ case    0:  		/* mfspr R12, LR */
		/* 821025D0h case    0:*/		regs.R12 = regs.LR;
		/* 821025D0h case    0:*/		return 0x821025D4;
		  /* 821025D4h */ case    1:  		/* bl -463796 */
		/* 821025D4h case    1:*/		regs.LR = 0x821025D8; return 0x82091220;
		/* 821025D4h case    1:*/		return 0x821025D8;
		  /* 821025D8h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 821025D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 821025D8h case    2:*/		return 0x821025DC;
		  /* 821025DCh */ case    3:  		/* lwz R10, <#[R3 + 20]> */
		/* 821025DCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 821025DCh case    3:*/		return 0x821025E0;
		  /* 821025E0h */ case    4:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 821025E0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 821025E0h case    4:*/		return 0x821025E4;
		  /* 821025E4h */ case    5:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 821025E4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 821025E4h case    5:*/		return 0x821025E8;
		  /* 821025E8h */ case    6:  		/* lwz R8, <#[R3 + 16]> */
		/* 821025E8h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 821025E8h case    6:*/		return 0x821025EC;
		  /* 821025ECh */ case    7:  		/* rlwinm R7, R6, 2, 0, 29 */
		/* 821025ECh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R6);
		/* 821025ECh case    7:*/		return 0x821025F0;
		  /* 821025F0h */ case    8:  		/* stw R4, <#[R1 + 300]> */
		/* 821025F0h case    8:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000012C) );
		/* 821025F0h case    8:*/		return 0x821025F4;
		  /* 821025F4h */ case    9:  		/* mr R17, R3 */
		/* 821025F4h case    9:*/		regs.R17 = regs.R3;
		/* 821025F4h case    9:*/		return 0x821025F8;
		  /* 821025F8h */ case   10:  		/* lwz R3, <#[R4]> */
		/* 821025F8h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000000) );
		/* 821025F8h case   10:*/		return 0x821025FC;
		  /* 821025FCh */ case   11:  		/* stw R5, <#[R1 + 308]> */
		/* 821025FCh case   11:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000134) );
		/* 821025FCh case   11:*/		return 0x82102600;
		  /* 82102600h */ case   12:  		/* lwzx R19, <#[R11 + R10]> */
		/* 82102600h case   12:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82102600h case   12:*/		return 0x82102604;
		  /* 82102604h */ case   13:  		/* lwzx R11, <#[R9 + R10]> */
		/* 82102604h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82102604h case   13:*/		return 0x82102608;
		  /* 82102608h */ case   14:  		/* lwzx R9, <#[R7 + R10]> */
		/* 82102608h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 82102608h case   14:*/		return 0x8210260C;
		  /* 8210260Ch */ case   15:  		/* lwz R7, <#[R19 + 4]> */
		/* 8210260Ch case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R19 + 0x00000004) );
		/* 8210260Ch case   15:*/		return 0x82102610;
		  /* 82102610h */ case   16:  		/* lwz R11, <#[R11 + 48]> */
		/* 82102610h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82102610h case   16:*/		return 0x82102614;
		  /* 82102614h */ case   17:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82102614h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82102614h case   17:*/		return 0x82102618;
		  /* 82102618h */ case   18:  		/* lwz R25, <#[R9 + 48]> */
		/* 82102618h case   18:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R9 + 0x00000030) );
		/* 82102618h case   18:*/		return 0x8210261C;
		  /* 8210261Ch */ case   19:  		/* stw R19, <#[R1 + 80]> */
		/* 8210261Ch case   19:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000050) );
		/* 8210261Ch case   19:*/		return 0x82102620;
		  /* 82102620h */ case   20:  		/* rlwinm R15, R25, 2, 0, 29 */
		/* 82102620h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R15,regs.R25);
		/* 82102620h case   20:*/		return 0x82102624;
		  /* 82102624h */ case   21:  		/* stw R11, <#[R1 + 324]> */
		/* 82102624h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000144) );
		/* 82102624h case   21:*/		return 0x82102628;
	}
	return 0x82102628;
} // Block from 821025D0h-82102628h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82102628h
// Function '??1CProgram@D3DXShader@@UAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102628);
		  /* 82102628h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102628h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102628h case    0:*/		return 0x8210262C;
		  /* 8210262Ch */ case    1:  		/* lwzx R9, <#[R7 + R8]> */
		/* 8210262Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8210262Ch case    1:*/		return 0x82102630;
		  /* 82102630h */ case    2:  		/* stw R11, <#[R1 + 84]> */
		/* 82102630h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82102630h case    2:*/		return 0x82102634;
		  /* 82102634h */ case    3:  		/* lwzx R16, <#[R10 + R15]> */
		/* 82102634h case    3:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R10 + regs.R15 + 0x00000000) );
		/* 82102634h case    3:*/		return 0x82102638;
		  /* 82102638h */ case    4:  		/* stw R25, <#[R1 + 316]> */
		/* 82102638h case    4:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x0000013C) );
		/* 82102638h case    4:*/		return 0x8210263C;
		  /* 8210263Ch */ case    5:  		/* lwzx R14, <#[R11 + R10]> */
		/* 8210263Ch case    5:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210263Ch case    5:*/		return 0x82102640;
		  /* 82102640h */ case    6:  		/* lwz R11, <#[R9 + 4]> */
		/* 82102640h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82102640h case    6:*/		return 0x82102644;
		  /* 82102644h */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82102644h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82102644h case    7:*/		return 0x82102648;
		  /* 82102648h */ case    8:  		/* bc 12, CR0_EQ, 5000 */
		/* 82102648h case    8:*/		if ( regs.CR[0].eq ) { return 0x821039D0;  }
		/* 82102648h case    8:*/		return 0x8210264C;
		  /* 8210264Ch */ case    9:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 8210264Ch case    9:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 8210264Ch case    9:*/		return 0x82102650;
		  /* 82102650h */ case   10:  		/* bc 4, CR0_EQ, 4992 */
		/* 82102650h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821039D0;  }
		/* 82102650h case   10:*/		return 0x82102654;
		  /* 82102654h */ case   11:  		/* lwz R11, <#[R19]> */
		/* 82102654h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82102654h case   11:*/		return 0x82102658;
		  /* 82102658h */ case   12:  		/* lis R29, 8192 */
		/* 82102658h case   12:*/		cpu::op::lis<0>(regs,&regs.R29,0x2000);
		/* 82102658h case   12:*/		return 0x8210265C;
		  /* 8210265Ch */ case   13:  		/* lwz R10, <#[R16]> */
		/* 8210265Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000000) );
		/* 8210265Ch case   13:*/		return 0x82102660;
		  /* 82102660h */ case   14:  		/* lis R26, 8208 */
		/* 82102660h case   14:*/		cpu::op::lis<0>(regs,&regs.R26,0x2010);
		/* 82102660h case   14:*/		return 0x82102664;
		  /* 82102664h */ case   15:  		/* lwz R9, <#[R14]> */
		/* 82102664h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + 0x00000000) );
		/* 82102664h case   15:*/		return 0x82102668;
		  /* 82102668h */ case   16:  		/* rlwinm. R8, R11, 0, 4, 6 */
		/* 82102668h case   16:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R11);
		/* 82102668h case   16:*/		return 0x8210266C;
		  /* 8210266Ch */ case   17:  		/* lis R22, 8256 */
		/* 8210266Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R22,0x2040);
		/* 8210266Ch case   17:*/		return 0x82102670;
		  /* 82102670h */ case   18:  		/* lis R7, 8304 */
		/* 82102670h case   18:*/		cpu::op::lis<0>(regs,&regs.R7,0x2070);
		/* 82102670h case   18:*/		return 0x82102674;
		  /* 82102674h */ case   19:  		/* lis R6, 8320 */
		/* 82102674h case   19:*/		cpu::op::lis<0>(regs,&regs.R6,0x2080);
		/* 82102674h case   19:*/		return 0x82102678;
		  /* 82102678h */ case   20:  		/* lis R31, 8336 */
		/* 82102678h case   20:*/		cpu::op::lis<0>(regs,&regs.R31,0x2090);
		/* 82102678h case   20:*/		return 0x8210267C;
		  /* 8210267Ch */ case   21:  		/* rlwinm R30, R10, 0, 27, 31 */
		/* 8210267Ch case   21:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R30,regs.R10);
		/* 8210267Ch case   21:*/		return 0x82102680;
		  /* 82102680h */ case   22:  		/* rlwinm R23, R9, 0, 27, 31 */
		/* 82102680h case   22:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R23,regs.R9);
		/* 82102680h case   22:*/		return 0x82102684;
		  /* 82102684h */ case   23:  		/* rlwinm R28, R11, 0, 25, 25 */
		/* 82102684h case   23:*/		cpu::op::rlwinm<0,0,25,25>(regs,&regs.R28,regs.R11);
		/* 82102684h case   23:*/		return 0x82102688;
		  /* 82102688h */ case   24:  		/* bc 4, CR0_EQ, 108 */
		/* 82102688h case   24:*/		if ( !regs.CR[0].eq ) { return 0x821026F4;  }
		/* 82102688h case   24:*/		return 0x8210268C;
		  /* 8210268Ch */ case   25:  		/* rlwinm R8, R3, 0, 0, 11 */
		/* 8210268Ch case   25:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R8,regs.R3);
		/* 8210268Ch case   25:*/		return 0x82102690;
	}
	return 0x82102690;
} // Block from 82102628h-82102690h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82102690h
// Function '?SetName@CProgram@D3DXShader@@QAAJPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102690);
		  /* 82102690h */ case    0:  		/* cmplw CR6, R8, R29 */
		/* 82102690h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R29);
		/* 82102690h case    0:*/		return 0x82102694;
		  /* 82102694h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 82102694h case    1:*/		if ( regs.CR[6].eq ) { return 0x821026C0;  }
		/* 82102694h case    1:*/		return 0x82102698;
		  /* 82102698h */ case    2:  		/* cmplw CR6, R8, R26 */
		/* 82102698h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R26);
		/* 82102698h case    2:*/		return 0x8210269C;
		  /* 8210269Ch */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 8210269Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x821026C0;  }
		/* 8210269Ch case    3:*/		return 0x821026A0;
		  /* 821026A0h */ case    4:  		/* cmplw CR6, R8, R22 */
		/* 821026A0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R22);
		/* 821026A0h case    4:*/		return 0x821026A4;
		  /* 821026A4h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 821026A4h case    5:*/		if ( regs.CR[6].eq ) { return 0x821026C0;  }
		/* 821026A4h case    5:*/		return 0x821026A8;
		  /* 821026A8h */ case    6:  		/* cmplw CR6, R8, R7 */
		/* 821026A8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 821026A8h case    6:*/		return 0x821026AC;
		  /* 821026ACh */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 821026ACh case    7:*/		if ( regs.CR[6].eq ) { return 0x821026C0;  }
		/* 821026ACh case    7:*/		return 0x821026B0;
		  /* 821026B0h */ case    8:  		/* cmplw CR6, R8, R6 */
		/* 821026B0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R6);
		/* 821026B0h case    8:*/		return 0x821026B4;
		  /* 821026B4h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 821026B4h case    9:*/		if ( regs.CR[6].eq ) { return 0x821026C0;  }
		/* 821026B4h case    9:*/		return 0x821026B8;
		  /* 821026B8h */ case   10:  		/* cmplw CR6, R8, R31 */
		/* 821026B8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R31);
		/* 821026B8h case   10:*/		return 0x821026BC;
		  /* 821026BCh */ case   11:  		/* bc 4, CR6_EQ, 56 */
		/* 821026BCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x821026F4;  }
		/* 821026BCh case   11:*/		return 0x821026C0;
	}
	return 0x821026C0;
} // Block from 82102690h-821026C0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821026C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821026C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821026C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821026C0);
		  /* 821026C0h */ case    0:  		/* or R10, R9, R10 */
		/* 821026C0h case    0:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821026C0h case    0:*/		return 0x821026C4;
		  /* 821026C4h */ case    1:  		/* rlwinm. R9, R10, 0, 4, 4 */
		/* 821026C4h case    1:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R9,regs.R10);
		/* 821026C4h case    1:*/		return 0x821026C8;
		  /* 821026C8h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 821026C8h case    2:*/		if ( regs.CR[0].eq ) { return 0x821026D4;  }
		/* 821026C8h case    2:*/		return 0x821026CC;
		  /* 821026CCh */ case    3:  		/* oris R11, R11, 2048 */
		/* 821026CCh case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x800);
		/* 821026CCh case    3:*/		return 0x821026D0;
		  /* 821026D0h */ case    4:  		/* b 32 */
		/* 821026D0h case    4:*/		return 0x821026F0;
		/* 821026D0h case    4:*/		return 0x821026D4;
	}
	return 0x821026D4;
} // Block from 821026C0h-821026D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821026D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821026D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821026D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821026D4);
		  /* 821026D4h */ case    0:  		/* rlwinm. R9, R10, 0, 5, 5 */
		/* 821026D4h case    0:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R9,regs.R10);
		/* 821026D4h case    0:*/		return 0x821026D8;
		  /* 821026D8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821026D8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821026E4;  }
		/* 821026D8h case    1:*/		return 0x821026DC;
		  /* 821026DCh */ case    2:  		/* oris R11, R11, 1024 */
		/* 821026DCh case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 821026DCh case    2:*/		return 0x821026E0;
		  /* 821026E0h */ case    3:  		/* b 16 */
		/* 821026E0h case    3:*/		return 0x821026F0;
		/* 821026E0h case    3:*/		return 0x821026E4;
	}
	return 0x821026E4;
} // Block from 821026D4h-821026E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821026E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821026E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821026E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821026E4);
		  /* 821026E4h */ case    0:  		/* rlwinm. R10, R10, 0, 6, 6 */
		/* 821026E4h case    0:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R10,regs.R10);
		/* 821026E4h case    0:*/		return 0x821026E8;
		  /* 821026E8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821026E8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821026F4;  }
		/* 821026E8h case    1:*/		return 0x821026EC;
		  /* 821026ECh */ case    2:  		/* oris R11, R11, 512 */
		/* 821026ECh case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821026ECh case    2:*/		return 0x821026F0;
	}
	return 0x821026F0;
} // Block from 821026E4h-821026F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821026F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821026F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821026F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821026F0);
		  /* 821026F0h */ case    0:  		/* stw R11, <#[R19]> */
		/* 821026F0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 821026F0h case    0:*/		return 0x821026F4;
	}
	return 0x821026F4;
} // Block from 821026F0h-821026F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821026F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821026F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821026F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821026F4);
		  /* 821026F4h */ case    0:  		/* lwz R11, <#[R14]> */
		/* 821026F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 821026F4h case    0:*/		return 0x821026F8;
		  /* 821026F8h */ case    1:  		/* lis R27, 8288 */
		/* 821026F8h case    1:*/		cpu::op::lis<0>(regs,&regs.R27,0x2060);
		/* 821026F8h case    1:*/		return 0x821026FC;
		  /* 821026FCh */ case    2:  		/* lwz R10, <#[R16]> */
		/* 821026FCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000000) );
		/* 821026FCh case    2:*/		return 0x82102700;
		  /* 82102700h */ case    3:  		/* lis R5, 8272 */
		/* 82102700h case    3:*/		cpu::op::lis<0>(regs,&regs.R5,0x2050);
		/* 82102700h case    3:*/		return 0x82102704;
		  /* 82102704h */ case    4:  		/* or R11, R11, R10 */
		/* 82102704h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82102704h case    4:*/		return 0x82102708;
		  /* 82102708h */ case    5:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82102708h case    5:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82102708h case    5:*/		return 0x8210270C;
		  /* 8210270Ch */ case    6:  		/* bc 12, CR0_EQ, 92 */
		/* 8210270Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82102768;  }
		/* 8210270Ch case    6:*/		return 0x82102710;
		  /* 82102710h */ case    7:  		/* rlwinm R11, R3, 0, 0, 11 */
		/* 82102710h case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R3);
		/* 82102710h case    7:*/		return 0x82102714;
		  /* 82102714h */ case    8:  		/* cmplw CR6, R11, R27 */
		/* 82102714h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 82102714h case    8:*/		return 0x82102718;
		  /* 82102718h */ case    9:  		/* bc 12, CR6_GT, 44 */
		/* 82102718h case    9:*/		if ( regs.CR[6].gt ) { return 0x82102744;  }
		/* 82102718h case    9:*/		return 0x8210271C;
		  /* 8210271Ch */ case   10:  		/* bc 12, CR6_EQ, 64 */
		/* 8210271Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x8210275C;  }
		/* 8210271Ch case   10:*/		return 0x82102720;
	}
	return 0x82102720;
} // Block from 821026F4h-82102720h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82102720h
// Function '?RemoveDeadCode_Reference@CProgram@D3DXShader@@AAAXII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102720);
		  /* 82102720h */ case    0:  		/* cmplw CR6, R11, R29 */
		/* 82102720h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 82102720h case    0:*/		return 0x82102724;
		  /* 82102724h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 82102724h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210275C;  }
		/* 82102724h case    1:*/		return 0x82102728;
		  /* 82102728h */ case    2:  		/* cmplw CR6, R11, R26 */
		/* 82102728h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 82102728h case    2:*/		return 0x8210272C;
		  /* 8210272Ch */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 8210272Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8210275C;  }
		/* 8210272Ch case    3:*/		return 0x82102730;
		  /* 82102730h */ case    4:  		/* cmplw CR6, R11, R22 */
		/* 82102730h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 82102730h case    4:*/		return 0x82102734;
		  /* 82102734h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 82102734h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210275C;  }
		/* 82102734h case    5:*/		return 0x82102738;
		  /* 82102738h */ case    6:  		/* cmplw CR6, R11, R5 */
		/* 82102738h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 82102738h case    6:*/		return 0x8210273C;
		  /* 8210273Ch */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 8210273Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8210275C;  }
		/* 8210273Ch case    7:*/		return 0x82102740;
		  /* 82102740h */ case    8:  		/* b 40 */
		/* 82102740h case    8:*/		return 0x82102768;
		/* 82102740h case    8:*/		return 0x82102744;
	}
	return 0x82102744;
} // Block from 82102720h-82102744h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82102744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102744);
		  /* 82102744h */ case    0:  		/* cmplw CR6, R11, R7 */
		/* 82102744h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 82102744h case    0:*/		return 0x82102748;
		  /* 82102748h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82102748h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210275C;  }
		/* 82102748h case    1:*/		return 0x8210274C;
		  /* 8210274Ch */ case    2:  		/* cmplw CR6, R11, R6 */
		/* 8210274Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 8210274Ch case    2:*/		return 0x82102750;
		  /* 82102750h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82102750h case    3:*/		if ( regs.CR[6].eq ) { return 0x8210275C;  }
		/* 82102750h case    3:*/		return 0x82102754;
		  /* 82102754h */ case    4:  		/* cmplw CR6, R11, R31 */
		/* 82102754h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82102754h case    4:*/		return 0x82102758;
		  /* 82102758h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 82102758h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82102768;  }
		/* 82102758h case    5:*/		return 0x8210275C;
	}
	return 0x8210275C;
} // Block from 82102744h-8210275Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210275Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210275C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210275C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210275C);
		  /* 8210275Ch */ case    0:  		/* lwz R11, <#[R19]> */
		/* 8210275Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8210275Ch case    0:*/		return 0x82102760;
		  /* 82102760h */ case    1:  		/* ori R11, R11, 64 */
		/* 82102760h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82102760h case    1:*/		return 0x82102764;
		  /* 82102764h */ case    2:  		/* stw R11, <#[R19]> */
		/* 82102764h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82102764h case    2:*/		return 0x82102768;
	}
	return 0x82102768;
} // Block from 8210275Ch-82102768h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102768);
		  /* 82102768h */ case    0:  		/* rlwinm R21, R3, 0, 0, 11 */
		/* 82102768h case    0:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R21,regs.R3);
		/* 82102768h case    0:*/		return 0x8210276C;
		  /* 8210276Ch */ case    1:  		/* lis R20, 8224 */
		/* 8210276Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R20,0x2020);
		/* 8210276Ch case    1:*/		return 0x82102770;
		  /* 82102770h */ case    2:  		/* lis R18, 8240 */
		/* 82102770h case    2:*/		cpu::op::lis<0>(regs,&regs.R18,0x2030);
		/* 82102770h case    2:*/		return 0x82102774;
		  /* 82102774h */ case    3:  		/* li R4, 0 */
		/* 82102774h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82102774h case    3:*/		return 0x82102778;
		  /* 82102778h */ case    4:  		/* lis R24, 4112 */
		/* 82102778h case    4:*/		cpu::op::lis<0>(regs,&regs.R24,0x1010);
		/* 82102778h case    4:*/		return 0x8210277C;
		  /* 8210277Ch */ case    5:  		/* cmplw CR6, R21, R22 */
		/* 8210277Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R22);
		/* 8210277Ch case    5:*/		return 0x82102780;
		  /* 82102780h */ case    6:  		/* bc 12, CR6_GT, 104 */
		/* 82102780h case    6:*/		if ( regs.CR[6].gt ) { return 0x821027E8;  }
		/* 82102780h case    6:*/		return 0x82102784;
		  /* 82102784h */ case    7:  		/* bc 12, CR6_EQ, 88 */
		/* 82102784h case    7:*/		if ( regs.CR[6].eq ) { return 0x821027DC;  }
		/* 82102784h case    7:*/		return 0x82102788;
		  /* 82102788h */ case    8:  		/* cmplw CR6, R21, R29 */
		/* 82102788h case    8:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R29);
		/* 82102788h case    8:*/		return 0x8210278C;
		  /* 8210278Ch */ case    9:  		/* bc 12, CR6_EQ, 68 */
		/* 8210278Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x821027D0;  }
		/* 8210278Ch case    9:*/		return 0x82102790;
		  /* 82102790h */ case   10:  		/* cmplw CR6, R21, R26 */
		/* 82102790h case   10:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R26);
		/* 82102790h case   10:*/		return 0x82102794;
		  /* 82102794h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 82102794h case   11:*/		if ( regs.CR[6].eq ) { return 0x821027B4;  }
		/* 82102794h case   11:*/		return 0x82102798;
		  /* 82102798h */ case   12:  		/* cmplw CR6, R21, R20 */
		/* 82102798h case   12:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R20);
		/* 82102798h case   12:*/		return 0x8210279C;
		  /* 8210279Ch */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 8210279Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x821027A8;  }
		/* 8210279Ch case   13:*/		return 0x821027A0;
		  /* 821027A0h */ case   14:  		/* cmplw CR6, R21, R18 */
		/* 821027A0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R18);
		/* 821027A0h case   14:*/		return 0x821027A4;
		  /* 821027A4h */ case   15:  		/* bc 4, CR6_EQ, 536 */
		/* 821027A4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821029BC;  }
		/* 821027A4h case   15:*/		return 0x821027A8;
	}
	return 0x821027A8;
} // Block from 82102768h-821027A8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821027A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821027A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821027A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821027A8);
		  /* 821027A8h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 821027A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 821027A8h case    0:*/		return 0x821027AC;
		  /* 821027ACh */ case    1:  		/* ori R11, R11, 23 */
		/* 821027ACh case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x17);
		/* 821027ACh case    1:*/		return 0x821027B0;
		  /* 821027B0h */ case    2:  		/* b 520 */
		/* 821027B0h case    2:*/		return 0x821029B8;
		/* 821027B0h case    2:*/		return 0x821027B4;
	}
	return 0x821027B4;
} // Block from 821027A8h-821027B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821027B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821027B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821027B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821027B4);
		  /* 821027B4h */ case    0:  		/* ori R11, R30, 4 */
		/* 821027B4h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R30,0x4);
		/* 821027B4h case    0:*/		return 0x821027B8;
		  /* 821027B8h */ case    1:  		/* rlwinm R9, R30, 0, 29, 29 */
		/* 821027B8h case    1:*/		cpu::op::rlwinm<0,0,29,29>(regs,&regs.R9,regs.R30);
		/* 821027B8h case    1:*/		return 0x821027BC;
		  /* 821027BCh */ case    2:  		/* and R11, R11, R23 */
		/* 821027BCh case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R23);
		/* 821027BCh case    2:*/		return 0x821027C0;
		  /* 821027C0h */ case    3:  		/* or R11, R11, R9 */
		/* 821027C0h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821027C0h case    3:*/		return 0x821027C4;
		  /* 821027C4h */ case    4:  		/* lwz R10, <#[R19]> */
		/* 821027C4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000000) );
		/* 821027C4h case    4:*/		return 0x821027C8;
	}
	return 0x821027C8;
} // Block from 821027B4h-821027C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821027C8h
// Function '?CompactInstructions@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821027C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821027C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821027C8);
		  /* 821027C8h */ case    0:  		/* or R11, R11, R10 */
		/* 821027C8h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821027C8h case    0:*/		return 0x821027CC;
		  /* 821027CCh */ case    1:  		/* b 492 */
		/* 821027CCh case    1:*/		return 0x821029B8;
		/* 821027CCh case    1:*/		return 0x821027D0;
	}
	return 0x821027D0;
} // Block from 821027C8h-821027D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821027D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821027D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821027D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821027D0);
		  /* 821027D0h */ case    0:  		/* ori R11, R30, 8 */
		/* 821027D0h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R30,0x8);
		/* 821027D0h case    0:*/		return 0x821027D4;
		  /* 821027D4h */ case    1:  		/* rlwinm R9, R30, 0, 28, 28 */
		/* 821027D4h case    1:*/		cpu::op::rlwinm<0,0,28,28>(regs,&regs.R9,regs.R30);
		/* 821027D4h case    1:*/		return 0x821027D8;
		  /* 821027D8h */ case    2:  		/* b -28 */
		/* 821027D8h case    2:*/		return 0x821027BC;
		/* 821027D8h case    2:*/		return 0x821027DC;
	}
	return 0x821027DC;
} // Block from 821027D0h-821027DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821027DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821027DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821027DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821027DC);
		  /* 821027DCh */ case    0:  		/* and R11, R23, R30 */
		/* 821027DCh case    0:*/		cpu::op::and<0>(regs,&regs.R11,regs.R23,regs.R30);
		/* 821027DCh case    0:*/		return 0x821027E0;
		  /* 821027E0h */ case    1:  		/* rlwinm R11, R11, 0, 28, 30 */
		/* 821027E0h case    1:*/		cpu::op::rlwinm<0,0,28,30>(regs,&regs.R11,regs.R11);
		/* 821027E0h case    1:*/		return 0x821027E4;
		  /* 821027E4h */ case    2:  		/* b -32 */
		/* 821027E4h case    2:*/		return 0x821027C4;
		/* 821027E4h case    2:*/		return 0x821027E8;
	}
	return 0x821027E8;
} // Block from 821027DCh-821027E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821027E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821027E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821027E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821027E8);
		  /* 821027E8h */ case    0:  		/* cmplw CR6, R21, R5 */
		/* 821027E8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R5);
		/* 821027E8h case    0:*/		return 0x821027EC;
		  /* 821027ECh */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 821027ECh case    1:*/		if ( regs.CR[6].eq ) { return 0x82102818;  }
		/* 821027ECh case    1:*/		return 0x821027F0;
		  /* 821027F0h */ case    2:  		/* cmplw CR6, R21, R7 */
		/* 821027F0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R7);
		/* 821027F0h case    2:*/		return 0x821027F4;
		  /* 821027F4h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 821027F4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82102808;  }
		/* 821027F4h case    3:*/		return 0x821027F8;
		  /* 821027F8h */ case    4:  		/* cmplw CR6, R21, R6 */
		/* 821027F8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R6);
		/* 821027F8h case    4:*/		return 0x821027FC;
		  /* 821027FCh */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 821027FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82102808;  }
		/* 821027FCh case    5:*/		return 0x82102800;
		  /* 82102800h */ case    6:  		/* cmplw CR6, R21, R31 */
		/* 82102800h case    6:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R31);
		/* 82102800h case    6:*/		return 0x82102804;
		  /* 82102804h */ case    7:  		/* bc 4, CR6_EQ, 440 */
		/* 82102804h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821029BC;  }
		/* 82102804h case    7:*/		return 0x82102808;
	}
	return 0x82102808;
} // Block from 821027E8h-82102808h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82102808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102808);
		  /* 82102808h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 82102808h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82102808h case    0:*/		return 0x8210280C;
		  /* 8210280Ch */ case    1:  		/* and R10, R23, R30 */
		/* 8210280Ch case    1:*/		cpu::op::and<0>(regs,&regs.R10,regs.R23,regs.R30);
		/* 8210280Ch case    1:*/		return 0x82102810;
		  /* 82102810h */ case    2:  		/* or R11, R10, R11 */
		/* 82102810h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82102810h case    2:*/		return 0x82102814;
		  /* 82102814h */ case    3:  		/* b 420 */
		/* 82102814h case    3:*/		return 0x821029B8;
		/* 82102814h case    3:*/		return 0x82102818;
	}
	return 0x82102818;
} // Block from 82102808h-82102818h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82102818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102818);
		  /* 82102818h */ case    0:  		/* and R11, R23, R30 */
		/* 82102818h case    0:*/		cpu::op::and<0>(regs,&regs.R11,regs.R23,regs.R30);
		/* 82102818h case    0:*/		return 0x8210281C;
		  /* 8210281Ch */ case    1:  		/* lwz R9, <#[R19]> */
		/* 8210281Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R19 + 0x00000000) );
		/* 8210281Ch case    1:*/		return 0x82102820;
		  /* 82102820h */ case    2:  		/* rlwinm. R10, R30, 0, 29, 29 */
		/* 82102820h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R30);
		/* 82102820h case    2:*/		return 0x82102824;
		  /* 82102824h */ case    3:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82102824h case    3:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82102824h case    3:*/		return 0x82102828;
		  /* 82102828h */ case    4:  		/* or R11, R11, R9 */
		/* 82102828h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82102828h case    4:*/		return 0x8210282C;
		  /* 8210282Ch */ case    5:  		/* stw R11, <#[R19]> */
		/* 8210282Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8210282Ch case    5:*/		return 0x82102830;
		  /* 82102830h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 82102830h case    6:*/		if ( regs.CR[0].eq ) { return 0x8210283C;  }
		/* 82102830h case    6:*/		return 0x82102834;
		  /* 82102834h */ case    7:  		/* rlwinm. R9, R23, 0, 29, 29 */
		/* 82102834h case    7:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R23);
		/* 82102834h case    7:*/		return 0x82102838;
		  /* 82102838h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 82102838h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8210284C;  }
		/* 82102838h case    8:*/		return 0x8210283C;
	}
	return 0x8210283C;
} // Block from 82102818h-8210283Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210283Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210283C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210283C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210283C);
		  /* 8210283Ch */ case    0:  		/* rlwinm. R9, R30, 0, 28, 28 */
		/* 8210283Ch case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R9,regs.R30);
		/* 8210283Ch case    0:*/		return 0x82102840;
		  /* 82102840h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82102840h case    1:*/		if ( regs.CR[0].eq ) { return 0x82102854;  }
		/* 82102840h case    1:*/		return 0x82102844;
		  /* 82102844h */ case    2:  		/* rlwinm. R9, R23, 0, 28, 28 */
		/* 82102844h case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R9,regs.R23);
		/* 82102844h case    2:*/		return 0x82102848;
		  /* 82102848h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82102848h case    3:*/		if ( regs.CR[0].eq ) { return 0x82102854;  }
		/* 82102848h case    3:*/		return 0x8210284C;
	}
	return 0x8210284C;
} // Block from 8210283Ch-8210284Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210284Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210284C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210284C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210284C);
		  /* 8210284Ch */ case    0:  		/* ori R11, R11, 4 */
		/* 8210284Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210284Ch case    0:*/		return 0x82102850;
		  /* 82102850h */ case    1:  		/* stw R11, <#[R19]> */
		/* 82102850h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82102850h case    1:*/		return 0x82102854;
	}
	return 0x82102854;
} // Block from 8210284Ch-82102854h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102854);
		  /* 82102854h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 82102854h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82102854h case    0:*/		return 0x82102858;
		  /* 82102858h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82102858h case    1:*/		if ( regs.CR[6].eq ) { return 0x82102864;  }
		/* 82102858h case    1:*/		return 0x8210285C;
		  /* 8210285Ch */ case    2:  		/* rlwinm. R11, R23, 0, 28, 28 */
		/* 8210285Ch case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R23);
		/* 8210285Ch case    2:*/		return 0x82102860;
		  /* 82102860h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 82102860h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82102874;  }
		/* 82102860h case    3:*/		return 0x82102864;
	}
	return 0x82102864;
} // Block from 82102854h-82102864h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82102864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102864);
		  /* 82102864h */ case    0:  		/* rlwinm. R11, R30, 0, 28, 28 */
		/* 82102864h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R30);
		/* 82102864h case    0:*/		return 0x82102868;
		  /* 82102868h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82102868h case    1:*/		if ( regs.CR[0].eq ) { return 0x82102880;  }
		/* 82102868h case    1:*/		return 0x8210286C;
		  /* 8210286Ch */ case    2:  		/* rlwinm. R11, R23, 0, 29, 29 */
		/* 8210286Ch case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R23);
		/* 8210286Ch case    2:*/		return 0x82102870;
		  /* 82102870h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 82102870h case    3:*/		if ( regs.CR[0].eq ) { return 0x82102880;  }
		/* 82102870h case    3:*/		return 0x82102874;
	}
	return 0x82102874;
} // Block from 82102864h-82102874h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82102874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102874);
		  /* 82102874h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 82102874h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82102874h case    0:*/		return 0x82102878;
		  /* 82102878h */ case    1:  		/* ori R11, R11, 8 */
		/* 82102878h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82102878h case    1:*/		return 0x8210287C;
		  /* 8210287Ch */ case    2:  		/* stw R11, <#[R19]> */
		/* 8210287Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8210287Ch case    2:*/		return 0x82102880;
	}
	return 0x82102880;
} // Block from 82102874h-82102880h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102880h
// Function '?StripVarying@CProgram@D3DXShader@@AAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102880);
		  /* 82102880h */ case    0:  		/* cmplw CR6, R16, R14 */
		/* 82102880h case    0:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R14);
		/* 82102880h case    0:*/		return 0x82102884;
		  /* 82102884h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82102884h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82102894;  }
		/* 82102884h case    1:*/		return 0x82102888;
		  /* 82102888h */ case    2:  		/* lwz R11, <#[R19]> */
		/* 82102888h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82102888h case    2:*/		return 0x8210288C;
		  /* 8210288Ch */ case    3:  		/* ori R11, R11, 4 */
		/* 8210288Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210288Ch case    3:*/		return 0x82102890;
		  /* 82102890h */ case    4:  		/* b 296 */
		/* 82102890h case    4:*/		return 0x821029B8;
		/* 82102890h case    4:*/		return 0x82102894;
	}
	return 0x82102894;
} // Block from 82102880h-82102894h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82102894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102894);
		  /* 82102894h */ case    0:  		/* lwz R10, <#[R16 + 4]> */
		/* 82102894h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000004) );
		/* 82102894h case    0:*/		return 0x82102898;
		  /* 82102898h */ case    1:  		/* lwz R11, <#[R17 + 16]> */
		/* 82102898h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000010) );
		/* 82102898h case    1:*/		return 0x8210289C;
		  /* 8210289Ch */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210289Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210289Ch case    2:*/		return 0x821028A0;
		  /* 821028A0h */ case    3:  		/* lwzx R10, <#[R10 + R11]> */
		/* 821028A0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821028A0h case    3:*/		return 0x821028A4;
		  /* 821028A4h */ case    4:  		/* lwz R10, <#[R10 + 4]> */
		/* 821028A4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821028A4h case    4:*/		return 0x821028A8;
		  /* 821028A8h */ case    5:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 821028A8h case    5:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 821028A8h case    5:*/		return 0x821028AC;
		  /* 821028ACh */ case    6:  		/* bc 12, CR0_EQ, 120 */
		/* 821028ACh case    6:*/		if ( regs.CR[0].eq ) { return 0x82102924;  }
		/* 821028ACh case    6:*/		return 0x821028B0;
		  /* 821028B0h */ case    7:  		/* lwz R10, <#[R16 + 72]> */
		/* 821028B0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000048) );
		/* 821028B0h case    7:*/		return 0x821028B4;
		  /* 821028B4h */ case    8:  		/* lwz R9, <#[R17 + 24]> */
		/* 821028B4h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000018) );
		/* 821028B4h case    8:*/		return 0x821028B8;
		  /* 821028B8h */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821028B8h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821028B8h case    9:*/		return 0x821028BC;
		  /* 821028BCh */ case   10:  		/* lwzx R9, <#[R10 + R9]> */
		/* 821028BCh case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821028BCh case   10:*/		return 0x821028C0;
		  /* 821028C0h */ case   11:  		/* lwz R10, <#[R9]> */
		/* 821028C0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 821028C0h case   11:*/		return 0x821028C4;
		  /* 821028C4h */ case   12:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 821028C4h case   12:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 821028C4h case   12:*/		return 0x821028C8;
		  /* 821028C8h */ case   13:  		/* cmplw CR6, R10, R24 */
		/* 821028C8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 821028C8h case   13:*/		return 0x821028CC;
		  /* 821028CCh */ case   14:  		/* bc 4, CR6_EQ, 88 */
		/* 821028CCh case   14:*/		if ( !regs.CR[6].eq ) { return 0x82102924;  }
		/* 821028CCh case   14:*/		return 0x821028D0;
		  /* 821028D0h */ case   15:  		/* lwz R8, <#[R9 + 12]> */
		/* 821028D0h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 821028D0h case   15:*/		return 0x821028D4;
		  /* 821028D4h */ case   16:  		/* mr R10, R4 */
		/* 821028D4h case   16:*/		regs.R10 = regs.R4;
		/* 821028D4h case   16:*/		return 0x821028D8;
		  /* 821028D8h */ case   17:  		/* cmplwi CR6, R8, 0 */
		/* 821028D8h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821028D8h case   17:*/		return 0x821028DC;
		  /* 821028DCh */ case   18:  		/* bc 12, CR6_EQ, 40 */
		/* 821028DCh case   18:*/		if ( regs.CR[6].eq ) { return 0x82102904;  }
		/* 821028DCh case   18:*/		return 0x821028E0;
		  /* 821028E0h */ case   19:  		/* lwz R7, <#[R9 + 16]> */
		/* 821028E0h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000010) );
		/* 821028E0h case   19:*/		return 0x821028E4;
		  /* 821028E4h */ case   20:  		/* mr R11, R4 */
		/* 821028E4h case   20:*/		regs.R11 = regs.R4;
		/* 821028E4h case   20:*/		return 0x821028E8;
		  /* 821028E8h */ case   21:  		/* lwzx R6, <#[R11 + R7]> */
		/* 821028E8h case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 821028E8h case   21:*/		return 0x821028EC;
		  /* 821028ECh */ case   22:  		/* cmplw CR6, R6, R25 */
		/* 821028ECh case   22:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R25);
		/* 821028ECh case   22:*/		return 0x821028F0;
		  /* 821028F0h */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 821028F0h case   23:*/		if ( regs.CR[6].eq ) { return 0x82102904;  }
		/* 821028F0h case   23:*/		return 0x821028F4;
		  /* 821028F4h */ case   24:  		/* addi R10, R10, 1 */
		/* 821028F4h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821028F4h case   24:*/		return 0x821028F8;
		  /* 821028F8h */ case   25:  		/* addi R11, R11, 4 */
		/* 821028F8h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821028F8h case   25:*/		return 0x821028FC;
		  /* 821028FCh */ case   26:  		/* cmplw CR6, R10, R8 */
		/* 821028FCh case   26:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 821028FCh case   26:*/		return 0x82102900;
		  /* 82102900h */ case   27:  		/* bc 12, CR6_LT, -24 */
		/* 82102900h case   27:*/		if ( regs.CR[6].lt ) { return 0x821028E8;  }
		/* 82102900h case   27:*/		return 0x82102904;
	}
	return 0x82102904;
} // Block from 82102894h-82102904h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82102904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102904);
		  /* 82102904h */ case    0:  		/* cmplw CR6, R10, R8 */
		/* 82102904h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82102904h case    0:*/		return 0x82102908;
		  /* 82102908h */ case    1:  		/* bc 4, CR6_LT, 180 */
		/* 82102908h case    1:*/		if ( !regs.CR[6].lt ) { return 0x821029BC;  }
		/* 82102908h case    1:*/		return 0x8210290C;
		  /* 8210290Ch */ case    2:  		/* lwz R11, <#[R9 + 8]> */
		/* 8210290Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 8210290Ch case    2:*/		return 0x82102910;
		  /* 82102910h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82102910h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82102910h case    3:*/		return 0x82102914;
		  /* 82102914h */ case    4:  		/* lwz R9, <#[R1 + 324]> */
		/* 82102914h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000144) );
		/* 82102914h case    4:*/		return 0x82102918;
		  /* 82102918h */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82102918h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82102918h case    5:*/		return 0x8210291C;
		  /* 8210291Ch */ case    6:  		/* cmplw CR6, R11, R9 */
		/* 8210291Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210291Ch case    6:*/		return 0x82102920;
		  /* 82102920h */ case    7:  		/* b 140 */
		/* 82102920h case    7:*/		return 0x821029AC;
		/* 82102920h case    7:*/		return 0x82102924;
	}
	return 0x82102924;
} // Block from 82102904h-82102924h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82102924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102924);
		  /* 82102924h */ case    0:  		/* lwz R10, <#[R14 + 4]> */
		/* 82102924h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000004) );
		/* 82102924h case    0:*/		return 0x82102928;
		  /* 82102928h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82102928h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82102928h case    1:*/		return 0x8210292C;
		  /* 8210292Ch */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210292Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210292Ch case    2:*/		return 0x82102930;
		  /* 82102930h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 82102930h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82102930h case    3:*/		return 0x82102934;
		  /* 82102934h */ case    4:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 82102934h case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 82102934h case    4:*/		return 0x82102938;
		  /* 82102938h */ case    5:  		/* bc 12, CR0_EQ, 132 */
		/* 82102938h case    5:*/		if ( regs.CR[0].eq ) { return 0x821029BC;  }
		/* 82102938h case    5:*/		return 0x8210293C;
		  /* 8210293Ch */ case    6:  		/* lwz R11, <#[R14 + 72]> */
		/* 8210293Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000048) );
		/* 8210293Ch case    6:*/		return 0x82102940;
		  /* 82102940h */ case    7:  		/* lwz R10, <#[R17 + 24]> */
		/* 82102940h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000018) );
		/* 82102940h case    7:*/		return 0x82102944;
		  /* 82102944h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102944h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102944h case    8:*/		return 0x82102948;
		  /* 82102948h */ case    9:  		/* lwzx R9, <#[R11 + R10]> */
		/* 82102948h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82102948h case    9:*/		return 0x8210294C;
		  /* 8210294Ch */ case   10:  		/* lwz R11, <#[R9]> */
		/* 8210294Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8210294Ch case   10:*/		return 0x82102950;
		  /* 82102950h */ case   11:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82102950h case   11:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82102950h case   11:*/		return 0x82102954;
		  /* 82102954h */ case   12:  		/* cmplw CR6, R11, R24 */
		/* 82102954h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 82102954h case   12:*/		return 0x82102958;
		  /* 82102958h */ case   13:  		/* bc 4, CR6_EQ, 100 */
		/* 82102958h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821029BC;  }
		/* 82102958h case   13:*/		return 0x8210295C;
		  /* 8210295Ch */ case   14:  		/* lwz R8, <#[R9 + 12]> */
		/* 8210295Ch case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 8210295Ch case   14:*/		return 0x82102960;
		  /* 82102960h */ case   15:  		/* mr R10, R4 */
		/* 82102960h case   15:*/		regs.R10 = regs.R4;
		/* 82102960h case   15:*/		return 0x82102964;
		  /* 82102964h */ case   16:  		/* cmplwi CR6, R8, 0 */
		/* 82102964h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82102964h case   16:*/		return 0x82102968;
		  /* 82102968h */ case   17:  		/* bc 12, CR6_EQ, 44 */
		/* 82102968h case   17:*/		if ( regs.CR[6].eq ) { return 0x82102994;  }
		/* 82102968h case   17:*/		return 0x8210296C;
		  /* 8210296Ch */ case   18:  		/* lwz R7, <#[R9 + 16]> */
		/* 8210296Ch case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000010) );
		/* 8210296Ch case   18:*/		return 0x82102970;
		  /* 82102970h */ case   19:  		/* mr R11, R4 */
		/* 82102970h case   19:*/		regs.R11 = regs.R4;
		/* 82102970h case   19:*/		return 0x82102974;
		  /* 82102974h */ case   20:  		/* lwzx R6, <#[R11 + R7]> */
		/* 82102974h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82102974h case   20:*/		return 0x82102978;
		  /* 82102978h */ case   21:  		/* lwz R3, <#[R1 + 324]> */
		/* 82102978h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000144) );
		/* 82102978h case   21:*/		return 0x8210297C;
		  /* 8210297Ch */ case   22:  		/* cmplw CR6, R6, R3 */
		/* 8210297Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R3);
		/* 8210297Ch case   22:*/		return 0x82102980;
		  /* 82102980h */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 82102980h case   23:*/		if ( regs.CR[6].eq ) { return 0x82102994;  }
		/* 82102980h case   23:*/		return 0x82102984;
		  /* 82102984h */ case   24:  		/* addi R10, R10, 1 */
		/* 82102984h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82102984h case   24:*/		return 0x82102988;
		  /* 82102988h */ case   25:  		/* addi R11, R11, 4 */
		/* 82102988h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82102988h case   25:*/		return 0x8210298C;
		  /* 8210298Ch */ case   26:  		/* cmplw CR6, R10, R8 */
		/* 8210298Ch case   26:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8210298Ch case   26:*/		return 0x82102990;
		  /* 82102990h */ case   27:  		/* bc 12, CR6_LT, -28 */
		/* 82102990h case   27:*/		if ( regs.CR[6].lt ) { return 0x82102974;  }
		/* 82102990h case   27:*/		return 0x82102994;
	}
	return 0x82102994;
} // Block from 82102924h-82102994h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82102994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102994);
		  /* 82102994h */ case    0:  		/* cmplw CR6, R10, R8 */
		/* 82102994h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82102994h case    0:*/		return 0x82102998;
		  /* 82102998h */ case    1:  		/* bc 4, CR6_LT, 36 */
		/* 82102998h case    1:*/		if ( !regs.CR[6].lt ) { return 0x821029BC;  }
		/* 82102998h case    1:*/		return 0x8210299C;
		  /* 8210299Ch */ case    2:  		/* lwz R11, <#[R9 + 8]> */
		/* 8210299Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 8210299Ch case    2:*/		return 0x821029A0;
		  /* 821029A0h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821029A0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821029A0h case    3:*/		return 0x821029A4;
		  /* 821029A4h */ case    4:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821029A4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821029A4h case    4:*/		return 0x821029A8;
		  /* 821029A8h */ case    5:  		/* cmplw CR6, R11, R25 */
		/* 821029A8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 821029A8h case    5:*/		return 0x821029AC;
	}
	return 0x821029AC;
} // Block from 82102994h-821029ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821029ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821029AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821029AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821029AC);
		  /* 821029ACh */ case    0:  		/* bc 4, CR6_EQ, 16 */
		/* 821029ACh case    0:*/		if ( !regs.CR[6].eq ) { return 0x821029BC;  }
		/* 821029ACh case    0:*/		return 0x821029B0;
		  /* 821029B0h */ case    1:  		/* lwz R11, <#[R19]> */
		/* 821029B0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 821029B0h case    1:*/		return 0x821029B4;
		  /* 821029B4h */ case    2:  		/* ori R11, R11, 8 */
		/* 821029B4h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 821029B4h case    2:*/		return 0x821029B8;
	}
	return 0x821029B8;
} // Block from 821029ACh-821029B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821029B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821029B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821029B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821029B8);
		  /* 821029B8h */ case    0:  		/* stw R11, <#[R19]> */
		/* 821029B8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 821029B8h case    0:*/		return 0x821029BC;
	}
	return 0x821029BC;
} // Block from 821029B8h-821029BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821029BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821029BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821029BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821029BC);
		  /* 821029BCh */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 821029BCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821029BCh case    0:*/		return 0x821029C0;
		  /* 821029C0h */ case    1:  		/* bc 4, CR6_EQ, 140 */
		/* 821029C0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82102A4C;  }
		/* 821029C0h case    1:*/		return 0x821029C4;
		  /* 821029C4h */ case    2:  		/* rlwinm. R11, R30, 0, 29, 29 */
		/* 821029C4h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R30);
		/* 821029C4h case    2:*/		return 0x821029C8;
		  /* 821029C8h */ case    3:  		/* bc 12, CR0_EQ, 100 */
		/* 821029C8h case    3:*/		if ( regs.CR[0].eq ) { return 0x82102A2C;  }
		/* 821029C8h case    3:*/		return 0x821029CC;
		  /* 821029CCh */ case    4:  		/* rlwinm. R11, R23, 0, 28, 28 */
		/* 821029CCh case    4:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R23);
		/* 821029CCh case    4:*/		return 0x821029D0;
		  /* 821029D0h */ case    5:  		/* bc 12, CR0_EQ, 92 */
		/* 821029D0h case    5:*/		if ( regs.CR[0].eq ) { return 0x82102A2C;  }
		/* 821029D0h case    5:*/		return 0x821029D4;
		  /* 821029D4h */ case    6:  		/* cmplw CR6, R21, R29 */
		/* 821029D4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R29);
		/* 821029D4h case    6:*/		return 0x821029D8;
		  /* 821029D8h */ case    7:  		/* bc 12, CR6_EQ, 72 */
		/* 821029D8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82102A20;  }
		/* 821029D8h case    7:*/		return 0x821029DC;
		  /* 821029DCh */ case    8:  		/* cmplw CR6, R21, R26 */
		/* 821029DCh case    8:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R26);
		/* 821029DCh case    8:*/		return 0x821029E0;
		  /* 821029E0h */ case    9:  		/* bc 12, CR6_EQ, 56 */
		/* 821029E0h case    9:*/		if ( regs.CR[6].eq ) { return 0x82102A18;  }
		/* 821029E0h case    9:*/		return 0x821029E4;
		  /* 821029E4h */ case   10:  		/* cmplw CR6, R21, R20 */
		/* 821029E4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R20);
		/* 821029E4h case   10:*/		return 0x821029E8;
		  /* 821029E8h */ case   11:  		/* bc 12, CR6_EQ, 1284 */
		/* 821029E8h case   11:*/		if ( regs.CR[6].eq ) { return 0x82102EEC;  }
		/* 821029E8h case   11:*/		return 0x821029EC;
		  /* 821029ECh */ case   12:  		/* cmplw CR6, R21, R18 */
		/* 821029ECh case   12:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R18);
		/* 821029ECh case   12:*/		return 0x821029F0;
		  /* 821029F0h */ case   13:  		/* bc 4, CR6_EQ, 60 */
		/* 821029F0h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82102A2C;  }
		/* 821029F0h case   13:*/		return 0x821029F4;
		  /* 821029F4h */ case   14:  		/* lis R11, -32256 */
		/* 821029F4h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821029F4h case   14:*/		return 0x821029F8;
		  /* 821029F8h */ case   15:  		/* lfd FR1, <#[R11 + 1848]> */
		/* 821029F8h case   15:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000738) );
		/* 821029F8h case   15:*/		return 0x821029FC;
		  /* 821029FCh */ case   16:  		/* li R6, 0 */
		/* 821029FCh case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821029FCh case   16:*/		return 0x82102A00;
		  /* 82102A00h */ case   17:  		/* lwz R4, <#[R17 + 120]> */
		/* 82102A00h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000078) );
		/* 82102A00h case   17:*/		return 0x82102A04;
		  /* 82102A04h */ case   18:  		/* li R5, 0 */
		/* 82102A04h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82102A04h case   18:*/		return 0x82102A08;
		  /* 82102A08h */ case   19:  		/* mr R3, R17 */
		/* 82102A08h case   19:*/		regs.R3 = regs.R17;
		/* 82102A08h case   19:*/		return 0x82102A0C;
		  /* 82102A0Ch */ case   20:  		/* bl -22500 */
		/* 82102A0Ch case   20:*/		regs.LR = 0x82102A10; return 0x820FD228;
		/* 82102A0Ch case   20:*/		return 0x82102A10;
		  /* 82102A10h */ case   21:  		/* stw R3, <#[R19 + 48]> */
		/* 82102A10h case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R19 + 0x00000030) );
		/* 82102A10h case   21:*/		return 0x82102A14;
		  /* 82102A14h */ case   22:  		/* b 4028 */
		/* 82102A14h case   22:*/		return 0x821039D0;
		/* 82102A14h case   22:*/		return 0x82102A18;
	}
	return 0x82102A18;
} // Block from 821029BCh-82102A18h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82102A18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102A18);
		  /* 82102A18h */ case    0:  		/* stw R25, <#[R19 + 48]> */
		/* 82102A18h case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R19 + 0x00000030) );
		/* 82102A18h case    0:*/		return 0x82102A1C;
		  /* 82102A1Ch */ case    1:  		/* b 4020 */
		/* 82102A1Ch case    1:*/		return 0x821039D0;
		/* 82102A1Ch case    1:*/		return 0x82102A20;
	}
	return 0x82102A20;
} // Block from 82102A18h-82102A20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102A20);
		  /* 82102A20h */ case    0:  		/* lwz R11, <#[R1 + 324]> */
		/* 82102A20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000144) );
		/* 82102A20h case    0:*/		return 0x82102A24;
		  /* 82102A24h */ case    1:  		/* stw R11, <#[R19 + 48]> */
		/* 82102A24h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000030) );
		/* 82102A24h case    1:*/		return 0x82102A28;
		  /* 82102A28h */ case    2:  		/* b 4008 */
		/* 82102A28h case    2:*/		return 0x821039D0;
		/* 82102A28h case    2:*/		return 0x82102A2C;
	}
	return 0x82102A2C;
} // Block from 82102A20h-82102A2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102A2C);
		  /* 82102A2Ch */ case    0:  		/* rlwinm. R11, R30, 0, 28, 28 */
		/* 82102A2Ch case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R30);
		/* 82102A2Ch case    0:*/		return 0x82102A30;
		  /* 82102A30h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 82102A30h case    1:*/		if ( regs.CR[0].eq ) { return 0x82102A4C;  }
		/* 82102A30h case    1:*/		return 0x82102A34;
		  /* 82102A34h */ case    2:  		/* rlwinm. R11, R23, 0, 29, 29 */
		/* 82102A34h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R23);
		/* 82102A34h case    2:*/		return 0x82102A38;
		  /* 82102A38h */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 82102A38h case    3:*/		if ( regs.CR[0].eq ) { return 0x82102A4C;  }
		/* 82102A38h case    3:*/		return 0x82102A3C;
		  /* 82102A3Ch */ case    4:  		/* cmplw CR6, R21, R29 */
		/* 82102A3Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R29);
		/* 82102A3Ch case    4:*/		return 0x82102A40;
		  /* 82102A40h */ case    5:  		/* bc 12, CR6_EQ, -40 */
		/* 82102A40h case    5:*/		if ( regs.CR[6].eq ) { return 0x82102A18;  }
		/* 82102A40h case    5:*/		return 0x82102A44;
		  /* 82102A44h */ case    6:  		/* cmplw CR6, R21, R26 */
		/* 82102A44h case    6:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R26);
		/* 82102A44h case    6:*/		return 0x82102A48;
		  /* 82102A48h */ case    7:  		/* bc 12, CR6_EQ, -40 */
		/* 82102A48h case    7:*/		if ( regs.CR[6].eq ) { return 0x82102A20;  }
		/* 82102A48h case    7:*/		return 0x82102A4C;
	}
	return 0x82102A4C;
} // Block from 82102A2Ch-82102A4Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82102A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102A4C);
		  /* 82102A4Ch */ case    0:  		/* lwz R11, <#[R16 + 4]> */
		/* 82102A4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000004) );
		/* 82102A4Ch case    0:*/		return 0x82102A50;
		  /* 82102A50h */ case    1:  		/* lwz R25, <#[R17 + 16]> */
		/* 82102A50h case    1:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R17 + 0x00000010) );
		/* 82102A50h case    1:*/		return 0x82102A54;
		  /* 82102A54h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102A54h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102A54h case    2:*/		return 0x82102A58;
		  /* 82102A58h */ case    3:  		/* lwzx R11, <#[R11 + R25]> */
		/* 82102A58h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 82102A58h case    3:*/		return 0x82102A5C;
		  /* 82102A5Ch */ case    4:  		/* lwz R6, <#[R11 + 4]> */
		/* 82102A5Ch case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82102A5Ch case    4:*/		return 0x82102A60;
		  /* 82102A60h */ case    5:  		/* rlwinm. R11, R6, 0, 23, 23 */
		/* 82102A60h case    5:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R6);
		/* 82102A60h case    5:*/		return 0x82102A64;
		  /* 82102A64h */ case    6:  		/* bc 12, CR0_EQ, 192 */
		/* 82102A64h case    6:*/		if ( regs.CR[0].eq ) { return 0x82102B24;  }
		/* 82102A64h case    6:*/		return 0x82102A68;
		  /* 82102A68h */ case    7:  		/* lwz R10, <#[R16 + 8]> */
		/* 82102A68h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000008) );
		/* 82102A68h case    7:*/		return 0x82102A6C;
		  /* 82102A6Ch */ case    8:  		/* cmpwi CR6, R10, -1 */
		/* 82102A6Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82102A6Ch case    8:*/		return 0x82102A70;
		  /* 82102A70h */ case    9:  		/* bc 4, CR6_EQ, 180 */
		/* 82102A70h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82102B24;  }
		/* 82102A70h case    9:*/		return 0x82102A74;
		  /* 82102A74h */ case   10:  		/* lwz R10, <#[R14 + 4]> */
		/* 82102A74h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000004) );
		/* 82102A74h case   10:*/		return 0x82102A78;
		  /* 82102A78h */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82102A78h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82102A78h case   11:*/		return 0x82102A7C;
		  /* 82102A7Ch */ case   12:  		/* lwzx R10, <#[R10 + R25]> */
		/* 82102A7Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 82102A7Ch case   12:*/		return 0x82102A80;
		  /* 82102A80h */ case   13:  		/* lwz R10, <#[R10 + 4]> */
		/* 82102A80h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82102A80h case   13:*/		return 0x82102A84;
		  /* 82102A84h */ case   14:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 82102A84h case   14:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 82102A84h case   14:*/		return 0x82102A88;
		  /* 82102A88h */ case   15:  		/* bc 12, CR0_EQ, 156 */
		/* 82102A88h case   15:*/		if ( regs.CR[0].eq ) { return 0x82102B24;  }
		/* 82102A88h case   15:*/		return 0x82102A8C;
		  /* 82102A8Ch */ case   16:  		/* lwz R10, <#[R14 + 8]> */
		/* 82102A8Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000008) );
		/* 82102A8Ch case   16:*/		return 0x82102A90;
		  /* 82102A90h */ case   17:  		/* cmpwi CR6, R10, -1 */
		/* 82102A90h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82102A90h case   17:*/		return 0x82102A94;
		  /* 82102A94h */ case   18:  		/* bc 4, CR6_EQ, 144 */
		/* 82102A94h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82102B24;  }
		/* 82102A94h case   18:*/		return 0x82102A98;
		  /* 82102A98h */ case   19:  		/* lfd FR1, <#[R16 + 32]> */
		/* 82102A98h case   19:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R16 + 0x00000020) );
		/* 82102A98h case   19:*/		return 0x82102A9C;
		  /* 82102A9Ch */ case   20:  		/* cmplw CR6, R21, R29 */
		/* 82102A9Ch case   20:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R29);
		/* 82102A9Ch case   20:*/		return 0x82102AA0;
		  /* 82102AA0h */ case   21:  		/* lfd FR2, <#[R14 + 32]> */
		/* 82102AA0h case   21:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R14 + 0x00000020) );
		/* 82102AA0h case   21:*/		return 0x82102AA4;
		  /* 82102AA4h */ case   22:  		/* bc 12, CR6_EQ, 112 */
		/* 82102AA4h case   22:*/		if ( regs.CR[6].eq ) { return 0x82102B14;  }
		/* 82102AA4h case   22:*/		return 0x82102AA8;
		  /* 82102AA8h */ case   23:  		/* cmplw CR6, R21, R26 */
		/* 82102AA8h case   23:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R26);
		/* 82102AA8h case   23:*/		return 0x82102AAC;
		  /* 82102AACh */ case   24:  		/* bc 12, CR6_EQ, 92 */
		/* 82102AACh case   24:*/		if ( regs.CR[6].eq ) { return 0x82102B08;  }
		/* 82102AACh case   24:*/		return 0x82102AB0;
		  /* 82102AB0h */ case   25:  		/* cmplw CR6, R21, R20 */
		/* 82102AB0h case   25:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R20);
		/* 82102AB0h case   25:*/		return 0x82102AB4;
		  /* 82102AB4h */ case   26:  		/* bc 12, CR6_EQ, 72 */
		/* 82102AB4h case   26:*/		if ( regs.CR[6].eq ) { return 0x82102AFC;  }
		/* 82102AB4h case   26:*/		return 0x82102AB8;
		  /* 82102AB8h */ case   27:  		/* cmplw CR6, R21, R18 */
		/* 82102AB8h case   27:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R18);
		/* 82102AB8h case   27:*/		return 0x82102ABC;
		  /* 82102ABCh */ case   28:  		/* bc 12, CR6_EQ, 52 */
		/* 82102ABCh case   28:*/		if ( regs.CR[6].eq ) { return 0x82102AF0;  }
		/* 82102ABCh case   28:*/		return 0x82102AC0;
		  /* 82102AC0h */ case   29:  		/* cmplw CR6, R21, R22 */
		/* 82102AC0h case   29:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R22);
		/* 82102AC0h case   29:*/		return 0x82102AC4;
		  /* 82102AC4h */ case   30:  		/* bc 12, CR6_EQ, 36 */
		/* 82102AC4h case   30:*/		if ( regs.CR[6].eq ) { return 0x82102AE8;  }
		/* 82102AC4h case   30:*/		return 0x82102AC8;
		  /* 82102AC8h */ case   31:  		/* cmplw CR6, R21, R5 */
		/* 82102AC8h case   31:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R5);
		/* 82102AC8h case   31:*/		return 0x82102ACC;
		  /* 82102ACCh */ case   32:  		/* bc 12, CR6_EQ, 20 */
		/* 82102ACCh case   32:*/		if ( regs.CR[6].eq ) { return 0x82102AE0;  }
		/* 82102ACCh case   32:*/		return 0x82102AD0;
		  /* 82102AD0h */ case   33:  		/* cmplw CR6, R21, R27 */
		/* 82102AD0h case   33:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R27);
		/* 82102AD0h case   33:*/		return 0x82102AD4;
		  /* 82102AD4h */ case   34:  		/* bc 4, CR6_EQ, 3836 */
		/* 82102AD4h case   34:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82102AD4h case   34:*/		return 0x82102AD8;
		  /* 82102AD8h */ case   35:  		/* bl 1463528 */
		/* 82102AD8h case   35:*/		regs.LR = 0x82102ADC; return 0x82267FC0;
		/* 82102AD8h case   35:*/		return 0x82102ADC;
		  /* 82102ADCh */ case   36:  		/* b -224 */
		/* 82102ADCh case   36:*/		return 0x821029FC;
		/* 82102ADCh case   36:*/		return 0x82102AE0;
	}
	return 0x82102AE0;
} // Block from 82102A4Ch-82102AE0h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82102AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102AE0);
		  /* 82102AE0h */ case    0:  		/* fmul FR1, FR2, FR1 */
		/* 82102AE0h case    0:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR2,regs.FR1);
		/* 82102AE0h case    0:*/		return 0x82102AE4;
		  /* 82102AE4h */ case    1:  		/* b -232 */
		/* 82102AE4h case    1:*/		return 0x821029FC;
		/* 82102AE4h case    1:*/		return 0x82102AE8;
	}
	return 0x82102AE8;
} // Block from 82102AE0h-82102AE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102AE8);
		  /* 82102AE8h */ case    0:  		/* fadd FR1, FR2, FR1 */
		/* 82102AE8h case    0:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR2,regs.FR1);
		/* 82102AE8h case    0:*/		return 0x82102AEC;
		  /* 82102AECh */ case    1:  		/* b -240 */
		/* 82102AECh case    1:*/		return 0x821029FC;
		/* 82102AECh case    1:*/		return 0x82102AF0;
	}
	return 0x82102AF0;
} // Block from 82102AE8h-82102AF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102AF0);
		  /* 82102AF0h */ case    0:  		/* fcmpu CR6, FR1, FR2 */
		/* 82102AF0h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR2);
		/* 82102AF0h case    0:*/		return 0x82102AF4;
		  /* 82102AF4h */ case    1:  		/* bc 12, CR6_LT, 1016 */
		/* 82102AF4h case    1:*/		if ( regs.CR[6].lt ) { return 0x82102EEC;  }
		/* 82102AF4h case    1:*/		return 0x82102AF8;
		  /* 82102AF8h */ case    2:  		/* b -260 */
		/* 82102AF8h case    2:*/		return 0x821029F4;
		/* 82102AF8h case    2:*/		return 0x82102AFC;
	}
	return 0x82102AFC;
} // Block from 82102AF0h-82102AFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102AFC);
		  /* 82102AFCh */ case    0:  		/* fcmpu CR6, FR1, FR2 */
		/* 82102AFCh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR2);
		/* 82102AFCh case    0:*/		return 0x82102B00;
		  /* 82102B00h */ case    1:  		/* bc 4, CR6_LT, 1004 */
		/* 82102B00h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82102EEC;  }
		/* 82102B00h case    1:*/		return 0x82102B04;
		  /* 82102B04h */ case    2:  		/* b -272 */
		/* 82102B04h case    2:*/		return 0x821029F4;
		/* 82102B04h case    2:*/		return 0x82102B08;
	}
	return 0x82102B08;
} // Block from 82102AFCh-82102B08h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102B08);
		  /* 82102B08h */ case    0:  		/* fcmpu CR6, FR1, FR2 */
		/* 82102B08h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR2);
		/* 82102B08h case    0:*/		return 0x82102B0C;
		  /* 82102B0Ch */ case    1:  		/* bc 4, CR6_LT, -272 */
		/* 82102B0Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x821029FC;  }
		/* 82102B0Ch case    1:*/		return 0x82102B10;
		  /* 82102B10h */ case    2:  		/* b 12 */
		/* 82102B10h case    2:*/		return 0x82102B1C;
		/* 82102B10h case    2:*/		return 0x82102B14;
	}
	return 0x82102B14;
} // Block from 82102B08h-82102B14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102B14);
		  /* 82102B14h */ case    0:  		/* fcmpu CR6, FR1, FR2 */
		/* 82102B14h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR2);
		/* 82102B14h case    0:*/		return 0x82102B18;
		  /* 82102B18h */ case    1:  		/* bc 12, CR6_LT, -284 */
		/* 82102B18h case    1:*/		if ( regs.CR[6].lt ) { return 0x821029FC;  }
		/* 82102B18h case    1:*/		return 0x82102B1C;
	}
	return 0x82102B1C;
} // Block from 82102B14h-82102B1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102B1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102B1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102B1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102B1C);
		  /* 82102B1Ch */ case    0:  		/* fmr FR1, FR2 */
		/* 82102B1Ch case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR2);
		/* 82102B1Ch case    0:*/		return 0x82102B20;
		  /* 82102B20h */ case    1:  		/* b -292 */
		/* 82102B20h case    1:*/		return 0x821029FC;
		/* 82102B20h case    1:*/		return 0x82102B24;
	}
	return 0x82102B24;
} // Block from 82102B1Ch-82102B24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102B24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102B24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102B24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102B24);
		  /* 82102B24h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 82102B24h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82102B24h case    0:*/		return 0x82102B28;
		  /* 82102B28h */ case    1:  		/* bc 4, CR6_EQ, 880 */
		/* 82102B28h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82102E98;  }
		/* 82102B28h case    1:*/		return 0x82102B2C;
		  /* 82102B2Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82102B2Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82102B2Ch case    2:*/		return 0x82102B30;
		  /* 82102B30h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 82102B30h case    3:*/		if ( regs.CR[6].eq ) { return 0x82102B40;  }
		/* 82102B30h case    3:*/		return 0x82102B34;
		  /* 82102B34h */ case    4:  		/* lwz R10, <#[R16 + 8]> */
		/* 82102B34h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000008) );
		/* 82102B34h case    4:*/		return 0x82102B38;
		  /* 82102B38h */ case    5:  		/* cmpwi CR6, R10, -1 */
		/* 82102B38h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82102B38h case    5:*/		return 0x82102B3C;
		  /* 82102B3Ch */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 82102B3Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82102B64;  }
		/* 82102B3Ch case    6:*/		return 0x82102B40;
	}
	return 0x82102B40;
} // Block from 82102B24h-82102B40h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82102B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102B40);
		  /* 82102B40h */ case    0:  		/* lwz R10, <#[R14 + 4]> */
		/* 82102B40h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000004) );
		/* 82102B40h case    0:*/		return 0x82102B44;
		  /* 82102B44h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82102B44h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82102B44h case    1:*/		return 0x82102B48;
		  /* 82102B48h */ case    2:  		/* lwzx R10, <#[R10 + R25]> */
		/* 82102B48h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 82102B48h case    2:*/		return 0x82102B4C;
		  /* 82102B4Ch */ case    3:  		/* lwz R10, <#[R10 + 4]> */
		/* 82102B4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82102B4Ch case    3:*/		return 0x82102B50;
		  /* 82102B50h */ case    4:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 82102B50h case    4:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 82102B50h case    4:*/		return 0x82102B54;
		  /* 82102B54h */ case    5:  		/* bc 12, CR0_EQ, 836 */
		/* 82102B54h case    5:*/		if ( regs.CR[0].eq ) { return 0x82102E98;  }
		/* 82102B54h case    5:*/		return 0x82102B58;
	}
	return 0x82102B58;
} // Block from 82102B40h-82102B58h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82102B58h
// Function '?StripUniform@CProgram@D3DXShader@@AAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102B58);
		  /* 82102B58h */ case    0:  		/* lwz R10, <#[R14 + 8]> */
		/* 82102B58h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000008) );
		/* 82102B58h case    0:*/		return 0x82102B5C;
		  /* 82102B5Ch */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 82102B5Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82102B5Ch case    1:*/		return 0x82102B60;
		  /* 82102B60h */ case    2:  		/* bc 4, CR6_EQ, 824 */
		/* 82102B60h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82102E98;  }
		/* 82102B60h case    2:*/		return 0x82102B64;
	}
	return 0x82102B64;
} // Block from 82102B58h-82102B64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102B64);
		  /* 82102B64h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82102B64h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82102B64h case    0:*/		return 0x82102B68;
		  /* 82102B68h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 82102B68h case    1:*/		if ( regs.CR[6].eq ) { return 0x82102B8C;  }
		/* 82102B68h case    1:*/		return 0x82102B6C;
		  /* 82102B6Ch */ case    2:  		/* lwz R11, <#[R16 + 8]> */
		/* 82102B6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 82102B6Ch case    2:*/		return 0x82102B70;
		  /* 82102B70h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82102B70h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82102B70h case    3:*/		return 0x82102B74;
		  /* 82102B74h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 82102B74h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82102B8C;  }
		/* 82102B74h case    4:*/		return 0x82102B78;
		  /* 82102B78h */ case    5:  		/* lwz R10, <#[R1 + 324]> */
		/* 82102B78h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000144) );
		/* 82102B78h case    5:*/		return 0x82102B7C;
		  /* 82102B7Ch */ case    6:  		/* lfd FR0, <#[R16 + 32]> */
		/* 82102B7Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R16 + 0x00000020) );
		/* 82102B7Ch case    6:*/		return 0x82102B80;
		  /* 82102B80h */ case    7:  		/* mr R11, R23 */
		/* 82102B80h case    7:*/		regs.R11 = regs.R23;
		/* 82102B80h case    7:*/		return 0x82102B84;
		  /* 82102B84h */ case    8:  		/* mr R6, R10 */
		/* 82102B84h case    8:*/		regs.R6 = regs.R10;
		/* 82102B84h case    8:*/		return 0x82102B88;
		  /* 82102B88h */ case    9:  		/* b 20 */
		/* 82102B88h case    9:*/		return 0x82102B9C;
		/* 82102B88h case    9:*/		return 0x82102B8C;
	}
	return 0x82102B8C;
} // Block from 82102B64h-82102B8Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82102B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102B8C);
		  /* 82102B8Ch */ case    0:  		/* lfd FR0, <#[R14 + 32]> */
		/* 82102B8Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R14 + 0x00000020) );
		/* 82102B8Ch case    0:*/		return 0x82102B90;
		  /* 82102B90h */ case    1:  		/* lwz R6, <#[R1 + 316]> */
		/* 82102B90h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000013C) );
		/* 82102B90h case    1:*/		return 0x82102B94;
		  /* 82102B94h */ case    2:  		/* lwz R10, <#[R1 + 324]> */
		/* 82102B94h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000144) );
		/* 82102B94h case    2:*/		return 0x82102B98;
		  /* 82102B98h */ case    3:  		/* mr R11, R30 */
		/* 82102B98h case    3:*/		regs.R11 = regs.R30;
		/* 82102B98h case    3:*/		return 0x82102B9C;
	}
	return 0x82102B9C;
} // Block from 82102B8Ch-82102B9Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82102B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102B9C);
		  /* 82102B9Ch */ case    0:  		/* cmplw CR6, R21, R29 */
		/* 82102B9Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R29);
		/* 82102B9Ch case    0:*/		return 0x82102BA0;
		  /* 82102BA0h */ case    1:  		/* bc 12, CR6_EQ, 704 */
		/* 82102BA0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82102E60;  }
		/* 82102BA0h case    1:*/		return 0x82102BA4;
		  /* 82102BA4h */ case    2:  		/* cmplw CR6, R21, R26 */
		/* 82102BA4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R26);
		/* 82102BA4h case    2:*/		return 0x82102BA8;
		  /* 82102BA8h */ case    3:  		/* bc 12, CR6_EQ, 648 */
		/* 82102BA8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82102E30;  }
		/* 82102BA8h case    3:*/		return 0x82102BAC;
		  /* 82102BACh */ case    4:  		/* cmplw CR6, R21, R20 */
		/* 82102BACh case    4:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R20);
		/* 82102BACh case    4:*/		return 0x82102BB0;
		  /* 82102BB0h */ case    5:  		/* bc 12, CR6_EQ, 480 */
		/* 82102BB0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82102D90;  }
		/* 82102BB0h case    5:*/		return 0x82102BB4;
		  /* 82102BB4h */ case    6:  		/* cmplw CR6, R21, R18 */
		/* 82102BB4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R18);
		/* 82102BB4h case    6:*/		return 0x82102BB8;
		  /* 82102BB8h */ case    7:  		/* bc 12, CR6_EQ, 328 */
		/* 82102BB8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82102D00;  }
		/* 82102BB8h case    7:*/		return 0x82102BBC;
		  /* 82102BBCh */ case    8:  		/* cmplw CR6, R21, R22 */
		/* 82102BBCh case    8:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R22);
		/* 82102BBCh case    8:*/		return 0x82102BC0;
		  /* 82102BC0h */ case    9:  		/* bc 12, CR6_EQ, 292 */
		/* 82102BC0h case    9:*/		if ( regs.CR[6].eq ) { return 0x82102CE4;  }
		/* 82102BC0h case    9:*/		return 0x82102BC4;
		  /* 82102BC4h */ case   10:  		/* cmplw CR6, R21, R5 */
		/* 82102BC4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R5);
		/* 82102BC4h case   10:*/		return 0x82102BC8;
		  /* 82102BC8h */ case   11:  		/* bc 12, CR6_EQ, 44 */
		/* 82102BC8h case   11:*/		if ( regs.CR[6].eq ) { return 0x82102BF4;  }
		/* 82102BC8h case   11:*/		return 0x82102BCC;
		  /* 82102BCCh */ case   12:  		/* cmplw CR6, R21, R27 */
		/* 82102BCCh case   12:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R27);
		/* 82102BCCh case   12:*/		return 0x82102BD0;
		  /* 82102BD0h */ case   13:  		/* bc 4, CR6_EQ, 3584 */
		/* 82102BD0h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82102BD0h case   13:*/		return 0x82102BD4;
		  /* 82102BD4h */ case   14:  		/* lis R11, -32256 */
		/* 82102BD4h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82102BD4h case   14:*/		return 0x82102BD8;
		  /* 82102BD8h */ case   15:  		/* lfd FR13, <#[R11 + 1808]> */
		/* 82102BD8h case   15:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000710) );
		/* 82102BD8h case   15:*/		return 0x82102BDC;
		  /* 82102BDCh */ case   16:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102BDCh case   16:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102BDCh case   16:*/		return 0x82102BE0;
		  /* 82102BE0h */ case   17:  		/* bc 4, CR6_EQ, 3568 */
		/* 82102BE0h case   17:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82102BE0h case   17:*/		return 0x82102BE4;
		  /* 82102BE4h */ case   18:  		/* lwz R11, <#[R1 + 316]> */
		/* 82102BE4h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000013C) );
		/* 82102BE4h case   18:*/		return 0x82102BE8;
		  /* 82102BE8h */ case   19:  		/* cmplw CR6, R6, R11 */
		/* 82102BE8h case   19:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 82102BE8h case   19:*/		return 0x82102BEC;
		  /* 82102BECh */ case   20:  		/* bc 4, CR6_EQ, 3556 */
		/* 82102BECh case   20:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82102BECh case   20:*/		return 0x82102BF0;
		  /* 82102BF0h */ case   21:  		/* b 476 */
		/* 82102BF0h case   21:*/		return 0x82102DCC;
		/* 82102BF0h case   21:*/		return 0x82102BF4;
	}
	return 0x82102BF4;
} // Block from 82102B9Ch-82102BF4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82102BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102BF4);
		  /* 82102BF4h */ case    0:  		/* lis R11, -32256 */
		/* 82102BF4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82102BF4h case    0:*/		return 0x82102BF8;
		  /* 82102BF8h */ case    1:  		/* lfd FR13, <#[R11 + 1808]> */
		/* 82102BF8h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000710) );
		/* 82102BF8h case    1:*/		return 0x82102BFC;
		  /* 82102BFCh */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102BFCh case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102BFCh case    2:*/		return 0x82102C00;
		  /* 82102C00h */ case    3:  		/* bc 12, CR6_EQ, 460 */
		/* 82102C00h case    3:*/		if ( regs.CR[6].eq ) { return 0x82102DCC;  }
		/* 82102C00h case    3:*/		return 0x82102C04;
		  /* 82102C04h */ case    4:  		/* lis R11, -32256 */
		/* 82102C04h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82102C04h case    4:*/		return 0x82102C08;
		  /* 82102C08h */ case    5:  		/* lfd FR13, <#[R11 + 1848]> */
		/* 82102C08h case    5:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000738) );
		/* 82102C08h case    5:*/		return 0x82102C0C;
		  /* 82102C0Ch */ case    6:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102C0Ch case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102C0Ch case    6:*/		return 0x82102C10;
		  /* 82102C10h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 82102C10h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82102C1C;  }
		/* 82102C10h case    7:*/		return 0x82102C14;
		  /* 82102C14h */ case    8:  		/* stw R6, <#[R19 + 48]> */
		/* 82102C14h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R19 + 0x00000030) );
		/* 82102C14h case    8:*/		return 0x82102C18;
		  /* 82102C18h */ case    9:  		/* b 3512 */
		/* 82102C18h case    9:*/		return 0x821039D0;
		/* 82102C18h case    9:*/		return 0x82102C1C;
	}
	return 0x82102C1C;
} // Block from 82102BF4h-82102C1Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82102C1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102C1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102C1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102C1C);
		  /* 82102C1Ch */ case    0:  		/* lis R11, -32256 */
		/* 82102C1Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82102C1Ch case    0:*/		return 0x82102C20;
		  /* 82102C20h */ case    1:  		/* lfd FR13, <#[R11 + 4736]> */
		/* 82102C20h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00001280) );
		/* 82102C20h case    1:*/		return 0x82102C24;
		  /* 82102C24h */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102C24h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102C24h case    2:*/		return 0x82102C28;
		  /* 82102C28h */ case    3:  		/* bc 4, CR6_EQ, 3496 */
		/* 82102C28h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82102C28h case    3:*/		return 0x82102C2C;
		  /* 82102C2Ch */ case    4:  		/* lwz R5, <#[R17 + 20]> */
		/* 82102C2Ch case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R17 + 0x00000014) );
		/* 82102C2Ch case    4:*/		return 0x82102C30;
		  /* 82102C30h */ case    5:  		/* rlwinm R11, R6, 2, 0, 29 */
		/* 82102C30h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R6);
		/* 82102C30h case    5:*/		return 0x82102C34;
		  /* 82102C34h */ case    6:  		/* lwzx R11, <#[R11 + R5]> */
		/* 82102C34h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 82102C34h case    6:*/		return 0x82102C38;
		  /* 82102C38h */ case    7:  		/* lwz R10, <#[R11 + 4]> */
		/* 82102C38h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82102C38h case    7:*/		return 0x82102C3C;
		  /* 82102C3Ch */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82102C3Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82102C3Ch case    8:*/		return 0x82102C40;
		  /* 82102C40h */ case    9:  		/* lwzx R10, <#[R10 + R25]> */
		/* 82102C40h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 82102C40h case    9:*/		return 0x82102C44;
		  /* 82102C44h */ case   10:  		/* lwz R10, <#[R10 + 4]> */
		/* 82102C44h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82102C44h case   10:*/		return 0x82102C48;
		  /* 82102C48h */ case   11:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 82102C48h case   11:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 82102C48h case   11:*/		return 0x82102C4C;
		  /* 82102C4Ch */ case   12:  		/* bc 12, CR0_EQ, 3460 */
		/* 82102C4Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x821039D0;  }
		/* 82102C4Ch case   12:*/		return 0x82102C50;
		  /* 82102C50h */ case   13:  		/* lwz R11, <#[R11 + 72]> */
		/* 82102C50h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82102C50h case   13:*/		return 0x82102C54;
		  /* 82102C54h */ case   14:  		/* lwz R10, <#[R17 + 24]> */
		/* 82102C54h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000018) );
		/* 82102C54h case   14:*/		return 0x82102C58;
		  /* 82102C58h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102C58h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102C58h case   15:*/		return 0x82102C5C;
		  /* 82102C5Ch */ case   16:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82102C5Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82102C5Ch case   16:*/		return 0x82102C60;
		  /* 82102C60h */ case   17:  		/* lwz R11, <#[R10]> */
		/* 82102C60h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82102C60h case   17:*/		return 0x82102C64;
		  /* 82102C64h */ case   18:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82102C64h case   18:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82102C64h case   18:*/		return 0x82102C68;
		  /* 82102C68h */ case   19:  		/* cmplw CR6, R11, R22 */
		/* 82102C68h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 82102C68h case   19:*/		return 0x82102C6C;
		  /* 82102C6Ch */ case   20:  		/* bc 4, CR6_EQ, 3428 */
		/* 82102C6Ch case   20:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82102C6Ch case   20:*/		return 0x82102C70;
		  /* 82102C70h */ case   21:  		/* lwz R8, <#[R10 + 12]> */
		/* 82102C70h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 82102C70h case   21:*/		return 0x82102C74;
		  /* 82102C74h */ case   22:  		/* mr R11, R4 */
		/* 82102C74h case   22:*/		regs.R11 = regs.R4;
		/* 82102C74h case   22:*/		return 0x82102C78;
		  /* 82102C78h */ case   23:  		/* cmplwi CR6, R8, 0 */
		/* 82102C78h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82102C78h case   23:*/		return 0x82102C7C;
		  /* 82102C7Ch */ case   24:  		/* bc 12, CR6_EQ, 40 */
		/* 82102C7Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x82102CA4;  }
		/* 82102C7Ch case   24:*/		return 0x82102C80;
		  /* 82102C80h */ case   25:  		/* lwz R7, <#[R10 + 16]> */
		/* 82102C80h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000010) );
		/* 82102C80h case   25:*/		return 0x82102C84;
		  /* 82102C84h */ case   26:  		/* mr R9, R4 */
		/* 82102C84h case   26:*/		regs.R9 = regs.R4;
		/* 82102C84h case   26:*/		return 0x82102C88;
		  /* 82102C88h */ case   27:  		/* lwzx R4, <#[R9 + R7]> */
		/* 82102C88h case   27:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82102C88h case   27:*/		return 0x82102C8C;
		  /* 82102C8Ch */ case   28:  		/* cmplw CR6, R4, R6 */
		/* 82102C8Ch case   28:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R6);
		/* 82102C8Ch case   28:*/		return 0x82102C90;
		  /* 82102C90h */ case   29:  		/* bc 12, CR6_EQ, 20 */
		/* 82102C90h case   29:*/		if ( regs.CR[6].eq ) { return 0x82102CA4;  }
		/* 82102C90h case   29:*/		return 0x82102C94;
		  /* 82102C94h */ case   30:  		/* addi R11, R11, 1 */
		/* 82102C94h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82102C94h case   30:*/		return 0x82102C98;
		  /* 82102C98h */ case   31:  		/* addi R9, R9, 4 */
		/* 82102C98h case   31:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82102C98h case   31:*/		return 0x82102C9C;
		  /* 82102C9Ch */ case   32:  		/* cmplw CR6, R11, R8 */
		/* 82102C9Ch case   32:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82102C9Ch case   32:*/		return 0x82102CA0;
		  /* 82102CA0h */ case   33:  		/* bc 12, CR6_LT, -24 */
		/* 82102CA0h case   33:*/		if ( regs.CR[6].lt ) { return 0x82102C88;  }
		/* 82102CA0h case   33:*/		return 0x82102CA4;
	}
	return 0x82102CA4;
} // Block from 82102C1Ch-82102CA4h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82102CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102CA4);
		  /* 82102CA4h */ case    0:  		/* cmplw CR6, R11, R8 */
		/* 82102CA4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82102CA4h case    0:*/		return 0x82102CA8;
		  /* 82102CA8h */ case    1:  		/* bc 4, CR6_LT, 3368 */
		/* 82102CA8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x821039D0;  }
		/* 82102CA8h case    1:*/		return 0x82102CAC;
		  /* 82102CACh */ case    2:  		/* add R9, R8, R11 */
		/* 82102CACh case    2:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R11);
		/* 82102CACh case    2:*/		return 0x82102CB0;
		  /* 82102CB0h */ case    3:  		/* lwz R8, <#[R10 + 8]> */
		/* 82102CB0h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 82102CB0h case    3:*/		return 0x82102CB4;
		  /* 82102CB4h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102CB4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102CB4h case    4:*/		return 0x82102CB8;
		  /* 82102CB8h */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82102CB8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82102CB8h case    5:*/		return 0x82102CBC;
		  /* 82102CBCh */ case    6:  		/* lwzx R7, <#[R8 + R11]> */
		/* 82102CBCh case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82102CBCh case    6:*/		return 0x82102CC0;
		  /* 82102CC0h */ case    7:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82102CC0h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82102CC0h case    7:*/		return 0x82102CC4;
		  /* 82102CC4h */ case    8:  		/* cmplw CR6, R7, R9 */
		/* 82102CC4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 82102CC4h case    8:*/		return 0x82102CC8;
		  /* 82102CC8h */ case    9:  		/* bc 4, CR6_EQ, 3336 */
		/* 82102CC8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82102CC8h case    9:*/		return 0x82102CCC;
		  /* 82102CCCh */ case   10:  		/* rlwinm R10, R8, 0, 0, 31 */
		/* 82102CCCh case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R8);
		/* 82102CCCh case   10:*/		return 0x82102CD0;
		  /* 82102CD0h */ case   11:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82102CD0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82102CD0h case   11:*/		return 0x82102CD4;
		  /* 82102CD4h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102CD4h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102CD4h case   12:*/		return 0x82102CD8;
		  /* 82102CD8h */ case   13:  		/* lwzx R11, <#[R11 + R5]> */
		/* 82102CD8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 82102CD8h case   13:*/		return 0x82102CDC;
		  /* 82102CDCh */ case   14:  		/* lwz R11, <#[R11 + 48]> */
		/* 82102CDCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82102CDCh case   14:*/		return 0x82102CE0;
		  /* 82102CE0h */ case   15:  		/* b -700 */
		/* 82102CE0h case   15:*/		return 0x82102A24;
		/* 82102CE0h case   15:*/		return 0x82102CE4;
	}
	return 0x82102CE4;
} // Block from 82102CA4h-82102CE4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82102CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102CE4);
		  /* 82102CE4h */ case    0:  		/* lis R11, -32256 */
		/* 82102CE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82102CE4h case    0:*/		return 0x82102CE8;
		  /* 82102CE8h */ case    1:  		/* li R3, 0 */
		/* 82102CE8h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82102CE8h case    1:*/		return 0x82102CEC;
		  /* 82102CECh */ case    2:  		/* lfd FR13, <#[R11 + 1808]> */
		/* 82102CECh case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000710) );
		/* 82102CECh case    2:*/		return 0x82102CF0;
		  /* 82102CF0h */ case    3:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102CF0h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102CF0h case    3:*/		return 0x82102CF4;
		  /* 82102CF4h */ case    4:  		/* bc 4, CR6_EQ, 3296 */
		/* 82102CF4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821039D4;  }
		/* 82102CF4h case    4:*/		return 0x82102CF8;
		  /* 82102CF8h */ case    5:  		/* stw R6, <#[R19 + 48]> */
		/* 82102CF8h case    5:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R19 + 0x00000030) );
		/* 82102CF8h case    5:*/		return 0x82102CFC;
		  /* 82102CFCh */ case    6:  		/* b 3288 */
		/* 82102CFCh case    6:*/		return 0x821039D4;
		/* 82102CFCh case    6:*/		return 0x82102D00;
	}
	return 0x82102D00;
} // Block from 82102CE4h-82102D00h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82102D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102D00);
		  /* 82102D00h */ case    0:  		/* cmplw CR6, R6, R10 */
		/* 82102D00h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82102D00h case    0:*/		return 0x82102D04;
		  /* 82102D04h */ case    1:  		/* lis R10, -32256 */
		/* 82102D04h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82102D04h case    1:*/		return 0x82102D08;
		  /* 82102D08h */ case    2:  		/* lfd FR13, <#[R10 + 1808]> */
		/* 82102D08h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000710) );
		/* 82102D08h case    2:*/		return 0x82102D0C;
		  /* 82102D0Ch */ case    3:  		/* bc 4, CR6_EQ, 56 */
		/* 82102D0Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82102D44;  }
		/* 82102D0Ch case    3:*/		return 0x82102D10;
		  /* 82102D10h */ case    4:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102D10h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102D10h case    4:*/		return 0x82102D14;
		  /* 82102D14h */ case    5:  		/* bc 4, CR6_LT, 12 */
		/* 82102D14h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82102D20;  }
		/* 82102D14h case    5:*/		return 0x82102D18;
		  /* 82102D18h */ case    6:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 82102D18h case    6:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 82102D18h case    6:*/		return 0x82102D1C;
		  /* 82102D1Ch */ case    7:  		/* bc 4, CR0_EQ, 176 */
		/* 82102D1Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82102DCC;  }
		/* 82102D1Ch case    7:*/		return 0x82102D20;
	}
	return 0x82102D20;
} // Block from 82102D00h-82102D20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82102D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102D20);
		  /* 82102D20h */ case    0:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102D20h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102D20h case    0:*/		return 0x82102D24;
		  /* 82102D24h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 82102D24h case    1:*/		if ( regs.CR[6].lt ) { return 0x82102D30;  }
		/* 82102D24h case    1:*/		return 0x82102D28;
		  /* 82102D28h */ case    2:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 82102D28h case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 82102D28h case    2:*/		return 0x82102D2C;
		  /* 82102D2Ch */ case    3:  		/* bc 4, CR0_EQ, 132 */
		/* 82102D2Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82102DB0;  }
		/* 82102D2Ch case    3:*/		return 0x82102D30;
	}
	return 0x82102D30;
} // Block from 82102D20h-82102D30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82102D30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102D30);
		  /* 82102D30h */ case    0:  		/* lis R10, -32256 */
		/* 82102D30h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82102D30h case    0:*/		return 0x82102D34;
		  /* 82102D34h */ case    1:  		/* lfd FR13, <#[R10 + 1848]> */
		/* 82102D34h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000738) );
		/* 82102D34h case    1:*/		return 0x82102D38;
		  /* 82102D38h */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102D38h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102D38h case    2:*/		return 0x82102D3C;
		  /* 82102D3Ch */ case    3:  		/* bc 12, CR6_LT, 3220 */
		/* 82102D3Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x821039D0;  }
		/* 82102D3Ch case    3:*/		return 0x82102D40;
		  /* 82102D40h */ case    4:  		/* b 228 */
		/* 82102D40h case    4:*/		return 0x82102E24;
		/* 82102D40h case    4:*/		return 0x82102D44;
	}
	return 0x82102D44;
} // Block from 82102D30h-82102D44h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82102D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102D44);
		  /* 82102D44h */ case    0:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102D44h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102D44h case    0:*/		return 0x82102D48;
		  /* 82102D48h */ case    1:  		/* bc 12, CR6_GT, 12 */
		/* 82102D48h case    1:*/		if ( regs.CR[6].gt ) { return 0x82102D54;  }
		/* 82102D48h case    1:*/		return 0x82102D4C;
		  /* 82102D4Ch */ case    2:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 82102D4Ch case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 82102D4Ch case    2:*/		return 0x82102D50;
		  /* 82102D50h */ case    3:  		/* bc 4, CR0_EQ, 96 */
		/* 82102D50h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82102DB0;  }
		/* 82102D50h case    3:*/		return 0x82102D54;
	}
	return 0x82102D54;
} // Block from 82102D44h-82102D54h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82102D54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102D54);
		  /* 82102D54h */ case    0:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102D54h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102D54h case    0:*/		return 0x82102D58;
	}
	return 0x82102D58;
} // Block from 82102D54h-82102D58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82102D58h
// Function '?InputsAreVRegisters@CProgram@D3DXShader@@QAAHPAVCInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102D58);
		  /* 82102D58h */ case    0:  		/* bc 4, CR6_GT, 12 */
		/* 82102D58h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82102D64;  }
		/* 82102D58h case    0:*/		return 0x82102D5C;
		  /* 82102D5Ch */ case    1:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 82102D5Ch case    1:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 82102D5Ch case    1:*/		return 0x82102D60;
		  /* 82102D60h */ case    2:  		/* bc 4, CR0_EQ, 108 */
		/* 82102D60h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82102DCC;  }
		/* 82102D60h case    2:*/		return 0x82102D64;
	}
	return 0x82102D64;
} // Block from 82102D58h-82102D64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102D64);
		  /* 82102D64h */ case    0:  		/* lis R10, -32256 */
		/* 82102D64h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82102D64h case    0:*/		return 0x82102D68;
		  /* 82102D68h */ case    1:  		/* lfd FR12, <#[R10 + 1848]> */
		/* 82102D68h case    1:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R10 + 0x00000738) );
		/* 82102D68h case    1:*/		return 0x82102D6C;
		  /* 82102D6Ch */ case    2:  		/* fcmpu CR6, FR0, FR12 */
		/* 82102D6Ch case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 82102D6Ch case    2:*/		return 0x82102D70;
		  /* 82102D70h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 82102D70h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82102D7C;  }
		/* 82102D70h case    3:*/		return 0x82102D74;
		  /* 82102D74h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82102D74h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82102D74h case    4:*/		return 0x82102D78;
		  /* 82102D78h */ case    5:  		/* bc 4, CR0_EQ, 84 */
		/* 82102D78h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82102DCC;  }
		/* 82102D78h case    5:*/		return 0x82102D7C;
	}
	return 0x82102D7C;
} // Block from 82102D64h-82102D7Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82102D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102D7C);
		  /* 82102D7Ch */ case    0:  		/* fcmpu CR6, FR0, FR12 */
		/* 82102D7Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 82102D7Ch case    0:*/		return 0x82102D80;
		  /* 82102D80h */ case    1:  		/* bc 4, CR6_EQ, 3152 */
		/* 82102D80h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82102D80h case    1:*/		return 0x82102D84;
		  /* 82102D84h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82102D84h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82102D84h case    2:*/		return 0x82102D88;
		  /* 82102D88h */ case    3:  		/* bc 12, CR0_EQ, 3144 */
		/* 82102D88h case    3:*/		if ( regs.CR[0].eq ) { return 0x821039D0;  }
		/* 82102D88h case    3:*/		return 0x82102D8C;
		  /* 82102D8Ch */ case    4:  		/* b -376 */
		/* 82102D8Ch case    4:*/		return 0x82102C14;
		/* 82102D8Ch case    4:*/		return 0x82102D90;
	}
	return 0x82102D90;
} // Block from 82102D7Ch-82102D90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82102D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102D90);
		  /* 82102D90h */ case    0:  		/* cmplw CR6, R6, R10 */
		/* 82102D90h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82102D90h case    0:*/		return 0x82102D94;
		  /* 82102D94h */ case    1:  		/* lis R10, -32256 */
		/* 82102D94h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82102D94h case    1:*/		return 0x82102D98;
		  /* 82102D98h */ case    2:  		/* lfd FR13, <#[R10 + 1808]> */
		/* 82102D98h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000710) );
		/* 82102D98h case    2:*/		return 0x82102D9C;
		  /* 82102D9Ch */ case    3:  		/* bc 4, CR6_EQ, 88 */
		/* 82102D9Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82102DF4;  }
		/* 82102D9Ch case    3:*/		return 0x82102DA0;
		  /* 82102DA0h */ case    4:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102DA0h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102DA0h case    4:*/		return 0x82102DA4;
		  /* 82102DA4h */ case    5:  		/* bc 4, CR6_LT, 24 */
		/* 82102DA4h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82102DBC;  }
		/* 82102DA4h case    5:*/		return 0x82102DA8;
		  /* 82102DA8h */ case    6:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 82102DA8h case    6:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 82102DA8h case    6:*/		return 0x82102DAC;
		  /* 82102DACh */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 82102DACh case    7:*/		if ( regs.CR[0].eq ) { return 0x82102DBC;  }
		/* 82102DACh case    7:*/		return 0x82102DB0;
	}
	return 0x82102DB0;
} // Block from 82102D90h-82102DB0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82102DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102DB0);
		  /* 82102DB0h */ case    0:  		/* lis R11, -32256 */
		/* 82102DB0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82102DB0h case    0:*/		return 0x82102DB4;
		  /* 82102DB4h */ case    1:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 82102DB4h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 82102DB4h case    1:*/		return 0x82102DB8;
		  /* 82102DB8h */ case    2:  		/* b 216 */
		/* 82102DB8h case    2:*/		return 0x82102E90;
		/* 82102DB8h case    2:*/		return 0x82102DBC;
	}
	return 0x82102DBC;
} // Block from 82102DB0h-82102DBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102DBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102DBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102DBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102DBC);
		  /* 82102DBCh */ case    0:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102DBCh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102DBCh case    0:*/		return 0x82102DC0;
		  /* 82102DC0h */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 82102DC0h case    1:*/		if ( regs.CR[6].lt ) { return 0x82102DD4;  }
		/* 82102DC0h case    1:*/		return 0x82102DC4;
		  /* 82102DC4h */ case    2:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 82102DC4h case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 82102DC4h case    2:*/		return 0x82102DC8;
		  /* 82102DC8h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82102DC8h case    3:*/		if ( regs.CR[0].eq ) { return 0x82102DD4;  }
		/* 82102DC8h case    3:*/		return 0x82102DCC;
	}
	return 0x82102DCC;
} // Block from 82102DBCh-82102DCCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82102DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102DCC);
		  /* 82102DCCh */ case    0:  		/* fmr FR0, FR13 */
		/* 82102DCCh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR13);
		/* 82102DCCh case    0:*/		return 0x82102DD0;
		  /* 82102DD0h */ case    1:  		/* b 192 */
		/* 82102DD0h case    1:*/		return 0x82102E90;
		/* 82102DD0h case    1:*/		return 0x82102DD4;
	}
	return 0x82102DD4;
} // Block from 82102DCCh-82102DD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102DD4);
		  /* 82102DD4h */ case    0:  		/* lis R10, -32256 */
		/* 82102DD4h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82102DD4h case    0:*/		return 0x82102DD8;
		  /* 82102DD8h */ case    1:  		/* lfd FR12, <#[R10 + 1848]> */
		/* 82102DD8h case    1:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R10 + 0x00000738) );
		/* 82102DD8h case    1:*/		return 0x82102DDC;
		  /* 82102DDCh */ case    2:  		/* fcmpu CR6, FR0, FR12 */
		/* 82102DDCh case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 82102DDCh case    2:*/		return 0x82102DE0;
		  /* 82102DE0h */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 82102DE0h case    3:*/		if ( regs.CR[6].lt ) { return 0x82102DEC;  }
		/* 82102DE0h case    3:*/		return 0x82102DE4;
		  /* 82102DE4h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82102DE4h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82102DE4h case    4:*/		return 0x82102DE8;
		  /* 82102DE8h */ case    5:  		/* bc 4, CR0_EQ, -28 */
		/* 82102DE8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82102DCC;  }
		/* 82102DE8h case    5:*/		return 0x82102DEC;
	}
	return 0x82102DEC;
} // Block from 82102DD4h-82102DECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82102DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102DEC);
		  /* 82102DECh */ case    0:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102DECh case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102DECh case    0:*/		return 0x82102DF0;
		  /* 82102DF0h */ case    1:  		/* b -112 */
		/* 82102DF0h case    1:*/		return 0x82102D80;
		/* 82102DF0h case    1:*/		return 0x82102DF4;
	}
	return 0x82102DF4;
} // Block from 82102DECh-82102DF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102DF4);
		  /* 82102DF4h */ case    0:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102DF4h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102DF4h case    0:*/		return 0x82102DF8;
		  /* 82102DF8h */ case    1:  		/* bc 12, CR6_GT, 12 */
		/* 82102DF8h case    1:*/		if ( regs.CR[6].gt ) { return 0x82102E04;  }
		/* 82102DF8h case    1:*/		return 0x82102DFC;
		  /* 82102DFCh */ case    2:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 82102DFCh case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 82102DFCh case    2:*/		return 0x82102E00;
		  /* 82102E00h */ case    3:  		/* bc 4, CR0_EQ, -52 */
		/* 82102E00h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82102DCC;  }
		/* 82102E00h case    3:*/		return 0x82102E04;
	}
	return 0x82102E04;
} // Block from 82102DF4h-82102E04h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82102E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102E04);
		  /* 82102E04h */ case    0:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102E04h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102E04h case    0:*/		return 0x82102E08;
		  /* 82102E08h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82102E08h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82102E14;  }
		/* 82102E08h case    1:*/		return 0x82102E0C;
		  /* 82102E0Ch */ case    2:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 82102E0Ch case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 82102E0Ch case    2:*/		return 0x82102E10;
		  /* 82102E10h */ case    3:  		/* bc 4, CR0_EQ, -96 */
		/* 82102E10h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82102DB0;  }
		/* 82102E10h case    3:*/		return 0x82102E14;
	}
	return 0x82102E14;
} // Block from 82102E04h-82102E14h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82102E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102E14);
		  /* 82102E14h */ case    0:  		/* lis R10, -32256 */
		/* 82102E14h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82102E14h case    0:*/		return 0x82102E18;
		  /* 82102E18h */ case    1:  		/* lfd FR13, <#[R10 + 1848]> */
		/* 82102E18h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000738) );
		/* 82102E18h case    1:*/		return 0x82102E1C;
		  /* 82102E1Ch */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102E1Ch case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102E1Ch case    2:*/		return 0x82102E20;
		  /* 82102E20h */ case    3:  		/* bc 4, CR6_GT, 2992 */
		/* 82102E20h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821039D0;  }
		/* 82102E20h case    3:*/		return 0x82102E24;
	}
	return 0x82102E24;
} // Block from 82102E14h-82102E24h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82102E24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102E24);
		  /* 82102E24h */ case    0:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82102E24h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82102E24h case    0:*/		return 0x82102E28;
		  /* 82102E28h */ case    1:  		/* bc 12, CR0_EQ, 2984 */
		/* 82102E28h case    1:*/		if ( regs.CR[0].eq ) { return 0x821039D0;  }
		/* 82102E28h case    1:*/		return 0x82102E2C;
		  /* 82102E2Ch */ case    2:  		/* b -96 */
		/* 82102E2Ch case    2:*/		return 0x82102DCC;
		/* 82102E2Ch case    2:*/		return 0x82102E30;
	}
	return 0x82102E30;
} // Block from 82102E24h-82102E30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102E30);
		  /* 82102E30h */ case    0:  		/* lis R10, -32256 */
		/* 82102E30h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82102E30h case    0:*/		return 0x82102E34;
		  /* 82102E34h */ case    1:  		/* lfd FR13, <#[R10 + 1848]> */
		/* 82102E34h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000738) );
		/* 82102E34h case    1:*/		return 0x82102E38;
		  /* 82102E38h */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102E38h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102E38h case    2:*/		return 0x82102E3C;
		  /* 82102E3Ch */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 82102E3Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82102E48;  }
		/* 82102E3Ch case    3:*/		return 0x82102E40;
		  /* 82102E40h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82102E40h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82102E40h case    4:*/		return 0x82102E44;
		  /* 82102E44h */ case    5:  		/* bc 4, CR0_EQ, 76 */
		/* 82102E44h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82102E90;  }
		/* 82102E44h case    5:*/		return 0x82102E48;
	}
	return 0x82102E48;
} // Block from 82102E30h-82102E48h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82102E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102E48);
		  /* 82102E48h */ case    0:  		/* lis R10, -32256 */
		/* 82102E48h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82102E48h case    0:*/		return 0x82102E4C;
		  /* 82102E4Ch */ case    1:  		/* lfd FR13, <#[R10 + 1808]> */
		/* 82102E4Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000710) );
		/* 82102E4Ch case    1:*/		return 0x82102E50;
		  /* 82102E50h */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102E50h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102E50h case    2:*/		return 0x82102E54;
		  /* 82102E54h */ case    3:  		/* bc 12, CR6_GT, 2940 */
		/* 82102E54h case    3:*/		if ( regs.CR[6].gt ) { return 0x821039D0;  }
		/* 82102E54h case    3:*/		return 0x82102E58;
		  /* 82102E58h */ case    4:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 82102E58h case    4:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 82102E58h case    4:*/		return 0x82102E5C;
		  /* 82102E5Ch */ case    5:  		/* b -212 */
		/* 82102E5Ch case    5:*/		return 0x82102D88;
		/* 82102E5Ch case    5:*/		return 0x82102E60;
	}
	return 0x82102E60;
} // Block from 82102E48h-82102E60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82102E60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102E60);
		  /* 82102E60h */ case    0:  		/* lis R10, -32256 */
		/* 82102E60h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82102E60h case    0:*/		return 0x82102E64;
		  /* 82102E64h */ case    1:  		/* lfd FR13, <#[R10 + 1848]> */
		/* 82102E64h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000738) );
		/* 82102E64h case    1:*/		return 0x82102E68;
		  /* 82102E68h */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102E68h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102E68h case    2:*/		return 0x82102E6C;
		  /* 82102E6Ch */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 82102E6Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82102E78;  }
		/* 82102E6Ch case    3:*/		return 0x82102E70;
		  /* 82102E70h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82102E70h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82102E70h case    4:*/		return 0x82102E74;
		  /* 82102E74h */ case    5:  		/* bc 4, CR0_EQ, -608 */
		/* 82102E74h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82102C14;  }
		/* 82102E74h case    5:*/		return 0x82102E78;
	}
	return 0x82102E78;
} // Block from 82102E60h-82102E78h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82102E78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102E78);
		  /* 82102E78h */ case    0:  		/* lis R10, -32256 */
		/* 82102E78h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82102E78h case    0:*/		return 0x82102E7C;
		  /* 82102E7Ch */ case    1:  		/* lfd FR13, <#[R10 + 1808]> */
		/* 82102E7Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000710) );
		/* 82102E7Ch case    1:*/		return 0x82102E80;
		  /* 82102E80h */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 82102E80h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82102E80h case    2:*/		return 0x82102E84;
		  /* 82102E84h */ case    3:  		/* bc 12, CR6_GT, 2892 */
		/* 82102E84h case    3:*/		if ( regs.CR[6].gt ) { return 0x821039D0;  }
		/* 82102E84h case    3:*/		return 0x82102E88;
		  /* 82102E88h */ case    4:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 82102E88h case    4:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 82102E88h case    4:*/		return 0x82102E8C;
		  /* 82102E8Ch */ case    5:  		/* bc 12, CR0_EQ, 2884 */
		/* 82102E8Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x821039D0;  }
		/* 82102E8Ch case    5:*/		return 0x82102E90;
	}
	return 0x82102E90;
} // Block from 82102E78h-82102E90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82102E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102E90);
		  /* 82102E90h */ case    0:  		/* fmr FR1, FR0 */
		/* 82102E90h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR0);
		/* 82102E90h case    0:*/		return 0x82102E94;
		  /* 82102E94h */ case    1:  		/* b -1176 */
		/* 82102E94h case    1:*/		return 0x821029FC;
		/* 82102E94h case    1:*/		return 0x82102E98;
	}
	return 0x82102E98;
} // Block from 82102E90h-82102E98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102E98);
		  /* 82102E98h */ case    0:  		/* cmplw CR6, R16, R14 */
		/* 82102E98h case    0:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R14);
		/* 82102E98h case    0:*/		return 0x82102E9C;
		  /* 82102E9Ch */ case    1:  		/* bc 4, CR6_EQ, 92 */
		/* 82102E9Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82102EF8;  }
		/* 82102E9Ch case    1:*/		return 0x82102EA0;
		  /* 82102EA0h */ case    2:  		/* cmplw CR6, R21, R29 */
		/* 82102EA0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R29);
		/* 82102EA0h case    2:*/		return 0x82102EA4;
		  /* 82102EA4h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 82102EA4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82102ED0;  }
		/* 82102EA4h case    3:*/		return 0x82102EA8;
		  /* 82102EA8h */ case    4:  		/* cmplw CR6, R21, R26 */
		/* 82102EA8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R26);
		/* 82102EA8h case    4:*/		return 0x82102EAC;
		  /* 82102EACh */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 82102EACh case    5:*/		if ( regs.CR[6].eq ) { return 0x82102ED0;  }
		/* 82102EACh case    5:*/		return 0x82102EB0;
		  /* 82102EB0h */ case    6:  		/* cmplw CR6, R21, R20 */
		/* 82102EB0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R20);
		/* 82102EB0h case    6:*/		return 0x82102EB4;
		  /* 82102EB4h */ case    7:  		/* bc 12, CR6_EQ, 48 */
		/* 82102EB4h case    7:*/		if ( regs.CR[6].eq ) { return 0x82102EE4;  }
		/* 82102EB4h case    7:*/		return 0x82102EB8;
		  /* 82102EB8h */ case    8:  		/* cmplw CR6, R21, R18 */
		/* 82102EB8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R18);
		/* 82102EB8h case    8:*/		return 0x82102EBC;
		  /* 82102EBCh */ case    9:  		/* bc 12, CR6_EQ, 28 */
		/* 82102EBCh case    9:*/		if ( regs.CR[6].eq ) { return 0x82102ED8;  }
		/* 82102EBCh case    9:*/		return 0x82102EC0;
		  /* 82102EC0h */ case   10:  		/* cmplw CR6, R21, R5 */
		/* 82102EC0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R5);
		/* 82102EC0h case   10:*/		return 0x82102EC4;
		  /* 82102EC4h */ case   11:  		/* bc 4, CR6_EQ, 52 */
		/* 82102EC4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82102EF8;  }
		/* 82102EC4h case   11:*/		return 0x82102EC8;
		  /* 82102EC8h */ case   12:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 82102EC8h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 82102EC8h case   12:*/		return 0x82102ECC;
		  /* 82102ECCh */ case   13:  		/* bc 12, CR0_EQ, 44 */
		/* 82102ECCh case   13:*/		if ( regs.CR[0].eq ) { return 0x82102EF8;  }
		/* 82102ECCh case   13:*/		return 0x82102ED0;
	}
	return 0x82102ED0;
} // Block from 82102E98h-82102ED0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82102ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102ED0);
		  /* 82102ED0h */ case    0:  		/* lwz R11, <#[R1 + 316]> */
		/* 82102ED0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000013C) );
		/* 82102ED0h case    0:*/		return 0x82102ED4;
		  /* 82102ED4h */ case    1:  		/* b -1200 */
		/* 82102ED4h case    1:*/		return 0x82102A24;
		/* 82102ED4h case    1:*/		return 0x82102ED8;
	}
	return 0x82102ED8;
} // Block from 82102ED0h-82102ED8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102ED8h
// Function '?MergePredicates@CProgram@D3DXShader@@AAAJPAVCArgument@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102ED8);
		  /* 82102ED8h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 82102ED8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82102ED8h case    0:*/		return 0x82102EDC;
		  /* 82102EDCh */ case    1:  		/* bc 4, CR6_EQ, 2804 */
		/* 82102EDCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82102EDCh case    1:*/		return 0x82102EE0;
		  /* 82102EE0h */ case    2:  		/* b -1260 */
		/* 82102EE0h case    2:*/		return 0x821029F4;
		/* 82102EE0h case    2:*/		return 0x82102EE4;
	}
	return 0x82102EE4;
} // Block from 82102ED8h-82102EE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102EE4);
		  /* 82102EE4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 82102EE4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82102EE4h case    0:*/		return 0x82102EE8;
		  /* 82102EE8h */ case    1:  		/* bc 4, CR6_EQ, 2792 */
		/* 82102EE8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82102EE8h case    1:*/		return 0x82102EEC;
	}
	return 0x82102EEC;
} // Block from 82102EE4h-82102EECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82102EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102EEC);
		  /* 82102EECh */ case    0:  		/* lis R11, -32256 */
		/* 82102EECh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82102EECh case    0:*/		return 0x82102EF0;
		  /* 82102EF0h */ case    1:  		/* lfd FR1, <#[R11 + 1808]> */
		/* 82102EF0h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000710) );
		/* 82102EF0h case    1:*/		return 0x82102EF4;
		  /* 82102EF4h */ case    2:  		/* b -1272 */
		/* 82102EF4h case    2:*/		return 0x821029FC;
		/* 82102EF4h case    2:*/		return 0x82102EF8;
	}
	return 0x82102EF8;
} // Block from 82102EECh-82102EF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82102EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102EF8);
		  /* 82102EF8h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 82102EF8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82102EF8h case    0:*/		return 0x82102EFC;
		  /* 82102EFCh */ case    1:  		/* bc 4, CR6_EQ, 2772 */
		/* 82102EFCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82102EFCh case    1:*/		return 0x82102F00;
		  /* 82102F00h */ case    2:  		/* cmplw CR6, R21, R22 */
		/* 82102F00h case    2:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R22);
		/* 82102F00h case    2:*/		return 0x82102F04;
		  /* 82102F04h */ case    3:  		/* bc 4, CR6_EQ, 844 */
		/* 82102F04h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82103250;  }
		/* 82102F04h case    3:*/		return 0x82102F08;
		  /* 82102F08h */ case    4:  		/* lwz R11, <#[R14 + 4]> */
		/* 82102F08h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 82102F08h case    4:*/		return 0x82102F0C;
		  /* 82102F0Ch */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102F0Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102F0Ch case    5:*/		return 0x82102F10;
		  /* 82102F10h */ case    6:  		/* lwzx R11, <#[R11 + R25]> */
		/* 82102F10h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 82102F10h case    6:*/		return 0x82102F14;
		  /* 82102F14h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 82102F14h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82102F14h case    7:*/		return 0x82102F18;
		  /* 82102F18h */ case    8:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 82102F18h case    8:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 82102F18h case    8:*/		return 0x82102F1C;
		  /* 82102F1Ch */ case    9:  		/* bc 12, CR0_EQ, 124 */
		/* 82102F1Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82102F98;  }
		/* 82102F1Ch case    9:*/		return 0x82102F20;
		  /* 82102F20h */ case   10:  		/* lwz R11, <#[R14 + 72]> */
		/* 82102F20h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000048) );
		/* 82102F20h case   10:*/		return 0x82102F24;
		  /* 82102F24h */ case   11:  		/* lwz R10, <#[R17 + 24]> */
		/* 82102F24h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000018) );
		/* 82102F24h case   11:*/		return 0x82102F28;
		  /* 82102F28h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102F28h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102F28h case   12:*/		return 0x82102F2C;
		  /* 82102F2Ch */ case   13:  		/* lwzx R9, <#[R11 + R10]> */
		/* 82102F2Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82102F2Ch case   13:*/		return 0x82102F30;
		  /* 82102F30h */ case   14:  		/* lwz R11, <#[R9]> */
		/* 82102F30h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 82102F30h case   14:*/		return 0x82102F34;
		  /* 82102F34h */ case   15:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82102F34h case   15:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82102F34h case   15:*/		return 0x82102F38;
		  /* 82102F38h */ case   16:  		/* cmplw CR6, R11, R24 */
		/* 82102F38h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 82102F38h case   16:*/		return 0x82102F3C;
		  /* 82102F3Ch */ case   17:  		/* bc 4, CR6_EQ, 92 */
		/* 82102F3Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x82102F98;  }
		/* 82102F3Ch case   17:*/		return 0x82102F40;
		  /* 82102F40h */ case   18:  		/* lwz R8, <#[R9 + 12]> */
		/* 82102F40h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 82102F40h case   18:*/		return 0x82102F44;
		  /* 82102F44h */ case   19:  		/* mr R10, R4 */
		/* 82102F44h case   19:*/		regs.R10 = regs.R4;
		/* 82102F44h case   19:*/		return 0x82102F48;
		  /* 82102F48h */ case   20:  		/* cmplwi CR6, R8, 0 */
		/* 82102F48h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82102F48h case   20:*/		return 0x82102F4C;
		  /* 82102F4Ch */ case   21:  		/* bc 12, CR6_EQ, 44 */
		/* 82102F4Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82102F78;  }
		/* 82102F4Ch case   21:*/		return 0x82102F50;
		  /* 82102F50h */ case   22:  		/* lwz R7, <#[R9 + 16]> */
		/* 82102F50h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000010) );
		/* 82102F50h case   22:*/		return 0x82102F54;
		  /* 82102F54h */ case   23:  		/* mr R11, R4 */
		/* 82102F54h case   23:*/		regs.R11 = regs.R4;
		/* 82102F54h case   23:*/		return 0x82102F58;
		  /* 82102F58h */ case   24:  		/* lwzx R3, <#[R11 + R7]> */
		/* 82102F58h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82102F58h case   24:*/		return 0x82102F5C;
		  /* 82102F5Ch */ case   25:  		/* lwz R31, <#[R1 + 324]> */
		/* 82102F5Ch case   25:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000144) );
		/* 82102F5Ch case   25:*/		return 0x82102F60;
		  /* 82102F60h */ case   26:  		/* cmplw CR6, R3, R31 */
		/* 82102F60h case   26:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R31);
		/* 82102F60h case   26:*/		return 0x82102F64;
		  /* 82102F64h */ case   27:  		/* bc 12, CR6_EQ, 20 */
		/* 82102F64h case   27:*/		if ( regs.CR[6].eq ) { return 0x82102F78;  }
		/* 82102F64h case   27:*/		return 0x82102F68;
		  /* 82102F68h */ case   28:  		/* addi R10, R10, 1 */
		/* 82102F68h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82102F68h case   28:*/		return 0x82102F6C;
		  /* 82102F6Ch */ case   29:  		/* addi R11, R11, 4 */
		/* 82102F6Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82102F6Ch case   29:*/		return 0x82102F70;
		  /* 82102F70h */ case   30:  		/* cmplw CR6, R10, R8 */
		/* 82102F70h case   30:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82102F70h case   30:*/		return 0x82102F74;
		  /* 82102F74h */ case   31:  		/* bc 12, CR6_LT, -28 */
		/* 82102F74h case   31:*/		if ( regs.CR[6].lt ) { return 0x82102F58;  }
		/* 82102F74h case   31:*/		return 0x82102F78;
	}
	return 0x82102F78;
} // Block from 82102EF8h-82102F78h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82102F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102F78);
		  /* 82102F78h */ case    0:  		/* cmplw CR6, R10, R8 */
		/* 82102F78h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82102F78h case    0:*/		return 0x82102F7C;
		  /* 82102F7Ch */ case    1:  		/* bc 4, CR6_LT, 28 */
		/* 82102F7Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x82102F98;  }
		/* 82102F7Ch case    1:*/		return 0x82102F80;
		  /* 82102F80h */ case    2:  		/* lwz R11, <#[R9 + 8]> */
		/* 82102F80h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82102F80h case    2:*/		return 0x82102F84;
		  /* 82102F84h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82102F84h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82102F84h case    3:*/		return 0x82102F88;
		  /* 82102F88h */ case    4:  		/* lwz R9, <#[R1 + 316]> */
		/* 82102F88h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000013C) );
		/* 82102F88h case    4:*/		return 0x82102F8C;
		  /* 82102F8Ch */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82102F8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82102F8Ch case    5:*/		return 0x82102F90;
		  /* 82102F90h */ case    6:  		/* cmplw CR6, R9, R11 */
		/* 82102F90h case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82102F90h case    6:*/		return 0x82102F94;
		  /* 82102F94h */ case    7:  		/* bc 12, CR6_EQ, -168 */
		/* 82102F94h case    7:*/		if ( regs.CR[6].eq ) { return 0x82102EEC;  }
		/* 82102F94h case    7:*/		return 0x82102F98;
	}
	return 0x82102F98;
} // Block from 82102F78h-82102F98h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82102F98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102F98);
		  /* 82102F98h */ case    0:  		/* rlwinm. R11, R6, 0, 30, 30 */
		/* 82102F98h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R6);
		/* 82102F98h case    0:*/		return 0x82102F9C;
		  /* 82102F9Ch */ case    1:  		/* bc 12, CR0_EQ, 124 */
		/* 82102F9Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82103018;  }
		/* 82102F9Ch case    1:*/		return 0x82102FA0;
		  /* 82102FA0h */ case    2:  		/* lwz R11, <#[R16 + 72]> */
		/* 82102FA0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000048) );
		/* 82102FA0h case    2:*/		return 0x82102FA4;
		  /* 82102FA4h */ case    3:  		/* lwz R10, <#[R17 + 24]> */
		/* 82102FA4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000018) );
		/* 82102FA4h case    3:*/		return 0x82102FA8;
		  /* 82102FA8h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82102FA8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82102FA8h case    4:*/		return 0x82102FAC;
		  /* 82102FACh */ case    5:  		/* lwzx R9, <#[R11 + R10]> */
		/* 82102FACh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82102FACh case    5:*/		return 0x82102FB0;
		  /* 82102FB0h */ case    6:  		/* lwz R11, <#[R9]> */
		/* 82102FB0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 82102FB0h case    6:*/		return 0x82102FB4;
		  /* 82102FB4h */ case    7:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82102FB4h case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82102FB4h case    7:*/		return 0x82102FB8;
		  /* 82102FB8h */ case    8:  		/* cmplw CR6, R11, R24 */
		/* 82102FB8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 82102FB8h case    8:*/		return 0x82102FBC;
		  /* 82102FBCh */ case    9:  		/* bc 4, CR6_EQ, 92 */
		/* 82102FBCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x82103018;  }
		/* 82102FBCh case    9:*/		return 0x82102FC0;
		  /* 82102FC0h */ case   10:  		/* lwz R8, <#[R9 + 12]> */
		/* 82102FC0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 82102FC0h case   10:*/		return 0x82102FC4;
		  /* 82102FC4h */ case   11:  		/* mr R10, R4 */
		/* 82102FC4h case   11:*/		regs.R10 = regs.R4;
		/* 82102FC4h case   11:*/		return 0x82102FC8;
		  /* 82102FC8h */ case   12:  		/* cmplwi CR6, R8, 0 */
		/* 82102FC8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82102FC8h case   12:*/		return 0x82102FCC;
		  /* 82102FCCh */ case   13:  		/* bc 12, CR6_EQ, 44 */
		/* 82102FCCh case   13:*/		if ( regs.CR[6].eq ) { return 0x82102FF8;  }
		/* 82102FCCh case   13:*/		return 0x82102FD0;
		  /* 82102FD0h */ case   14:  		/* lwz R7, <#[R9 + 16]> */
		/* 82102FD0h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000010) );
		/* 82102FD0h case   14:*/		return 0x82102FD4;
		  /* 82102FD4h */ case   15:  		/* mr R11, R4 */
		/* 82102FD4h case   15:*/		regs.R11 = regs.R4;
		/* 82102FD4h case   15:*/		return 0x82102FD8;
		  /* 82102FD8h */ case   16:  		/* lwzx R6, <#[R11 + R7]> */
		/* 82102FD8h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82102FD8h case   16:*/		return 0x82102FDC;
		  /* 82102FDCh */ case   17:  		/* lwz R3, <#[R1 + 316]> */
		/* 82102FDCh case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000013C) );
		/* 82102FDCh case   17:*/		return 0x82102FE0;
		  /* 82102FE0h */ case   18:  		/* cmplw CR6, R6, R3 */
		/* 82102FE0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R3);
		/* 82102FE0h case   18:*/		return 0x82102FE4;
		  /* 82102FE4h */ case   19:  		/* bc 12, CR6_EQ, 20 */
		/* 82102FE4h case   19:*/		if ( regs.CR[6].eq ) { return 0x82102FF8;  }
		/* 82102FE4h case   19:*/		return 0x82102FE8;
		  /* 82102FE8h */ case   20:  		/* addi R10, R10, 1 */
		/* 82102FE8h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82102FE8h case   20:*/		return 0x82102FEC;
		  /* 82102FECh */ case   21:  		/* addi R11, R11, 4 */
		/* 82102FECh case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82102FECh case   21:*/		return 0x82102FF0;
		  /* 82102FF0h */ case   22:  		/* cmplw CR6, R10, R8 */
		/* 82102FF0h case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82102FF0h case   22:*/		return 0x82102FF4;
		  /* 82102FF4h */ case   23:  		/* bc 12, CR6_LT, -28 */
		/* 82102FF4h case   23:*/		if ( regs.CR[6].lt ) { return 0x82102FD8;  }
		/* 82102FF4h case   23:*/		return 0x82102FF8;
	}
	return 0x82102FF8;
} // Block from 82102F98h-82102FF8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82102FF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82102FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82102FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82102FF8);
		  /* 82102FF8h */ case    0:  		/* cmplw CR6, R10, R8 */
		/* 82102FF8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82102FF8h case    0:*/		return 0x82102FFC;
		  /* 82102FFCh */ case    1:  		/* bc 4, CR6_LT, 28 */
		/* 82102FFCh case    1:*/		if ( !regs.CR[6].lt ) { return 0x82103018;  }
		/* 82102FFCh case    1:*/		return 0x82103000;
		  /* 82103000h */ case    2:  		/* lwz R11, <#[R9 + 8]> */
		/* 82103000h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82103000h case    2:*/		return 0x82103004;
		  /* 82103004h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82103004h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82103004h case    3:*/		return 0x82103008;
		  /* 82103008h */ case    4:  		/* lwz R9, <#[R1 + 324]> */
		/* 82103008h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000144) );
		/* 82103008h case    4:*/		return 0x8210300C;
		  /* 8210300Ch */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210300Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210300Ch case    5:*/		return 0x82103010;
		  /* 82103010h */ case    6:  		/* cmplw CR6, R9, R11 */
		/* 82103010h case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82103010h case    6:*/		return 0x82103014;
		  /* 82103014h */ case    7:  		/* bc 12, CR6_EQ, -296 */
		/* 82103014h case    7:*/		if ( regs.CR[6].eq ) { return 0x82102EEC;  }
		/* 82103014h case    7:*/		return 0x82103018;
	}
	return 0x82103018;
} // Block from 82102FF8h-82103018h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82103018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103018);
		  /* 82103018h */ case    0:  		/* mr R26, R4 */
		/* 82103018h case    0:*/		regs.R26 = regs.R4;
		/* 82103018h case    0:*/		return 0x8210301C;
		  /* 8210301Ch */ case    1:  		/* rlwinm. R11, R26, 0, 29, 29 */
		/* 8210301Ch case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R26);
		/* 8210301Ch case    1:*/		return 0x82103020;
		  /* 82103020h */ case    2:  		/* mr R30, R4 */
		/* 82103020h case    2:*/		regs.R30 = regs.R4;
		/* 82103020h case    2:*/		return 0x82103024;
		  /* 82103024h */ case    3:  		/* mr R27, R4 */
		/* 82103024h case    3:*/		regs.R27 = regs.R4;
		/* 82103024h case    3:*/		return 0x82103028;
		  /* 82103028h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82103028h case    4:*/		if ( regs.CR[0].eq ) { return 0x82103038;  }
		/* 82103028h case    4:*/		return 0x8210302C;
		  /* 8210302Ch */ case    5:  		/* lwz R29, <#[R1 + 316]> */
		/* 8210302Ch case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000013C) );
		/* 8210302Ch case    5:*/		return 0x82103030;
		  /* 82103030h */ case    6:  		/* lwz R3, <#[R1 + 324]> */
		/* 82103030h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000144) );
		/* 82103030h case    6:*/		return 0x82103034;
		  /* 82103034h */ case    7:  		/* b 12 */
		/* 82103034h case    7:*/		return 0x82103040;
		/* 82103034h case    7:*/		return 0x82103038;
	}
	return 0x82103038;
} // Block from 82103018h-82103038h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82103038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103038);
		  /* 82103038h */ case    0:  		/* lwz R29, <#[R1 + 324]> */
		/* 82103038h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000144) );
		/* 82103038h case    0:*/		return 0x8210303C;
		  /* 8210303Ch */ case    1:  		/* lwz R3, <#[R1 + 316]> */
		/* 8210303Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000013C) );
		/* 8210303Ch case    1:*/		return 0x82103040;
	}
	return 0x82103040;
} // Block from 82103038h-82103040h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82103040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103040);
		  /* 82103040h */ case    0:  		/* rlwinm. R28, R26, 0, 30, 30 */
		/* 82103040h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R28,regs.R26);
		/* 82103040h case    0:*/		return 0x82103044;
		  /* 82103044h */ case    1:  		/* bc 12, CR0_EQ, 152 */
		/* 82103044h case    1:*/		if ( regs.CR[0].eq ) { return 0x821030DC;  }
		/* 82103044h case    1:*/		return 0x82103048;
		  /* 82103048h */ case    2:  		/* lwz R6, <#[R17 + 20]> */
		/* 82103048h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R17 + 0x00000014) );
		/* 82103048h case    2:*/		return 0x8210304C;
		  /* 8210304Ch */ case    3:  		/* rlwinm R11, R29, 2, 0, 29 */
		/* 8210304Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R29);
		/* 8210304Ch case    3:*/		return 0x82103050;
		  /* 82103050h */ case    4:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82103050h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82103050h case    4:*/		return 0x82103054;
		  /* 82103054h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 82103054h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82103054h case    5:*/		return 0x82103058;
		  /* 82103058h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82103058h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82103058h case    6:*/		return 0x8210305C;
		  /* 8210305Ch */ case    7:  		/* lwzx R10, <#[R10 + R25]> */
		/* 8210305Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 8210305Ch case    7:*/		return 0x82103060;
		  /* 82103060h */ case    8:  		/* lwz R10, <#[R10 + 4]> */
		/* 82103060h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82103060h case    8:*/		return 0x82103064;
		  /* 82103064h */ case    9:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 82103064h case    9:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 82103064h case    9:*/		return 0x82103068;
		  /* 82103068h */ case   10:  		/* bc 12, CR0_EQ, 476 */
		/* 82103068h case   10:*/		if ( regs.CR[0].eq ) { return 0x82103244;  }
		/* 82103068h case   10:*/		return 0x8210306C;
		  /* 8210306Ch */ case   11:  		/* lwz R11, <#[R11 + 72]> */
		/* 8210306Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 8210306Ch case   11:*/		return 0x82103070;
		  /* 82103070h */ case   12:  		/* lwz R10, <#[R17 + 24]> */
		/* 82103070h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000018) );
		/* 82103070h case   12:*/		return 0x82103074;
		  /* 82103074h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103074h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103074h case   13:*/		return 0x82103078;
		  /* 82103078h */ case   14:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82103078h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82103078h case   14:*/		return 0x8210307C;
		  /* 8210307Ch */ case   15:  		/* lwz R10, <#[R11]> */
		/* 8210307Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210307Ch case   15:*/		return 0x82103080;
		  /* 82103080h */ case   16:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82103080h case   16:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82103080h case   16:*/		return 0x82103084;
		  /* 82103084h */ case   17:  		/* cmplw CR6, R10, R24 */
		/* 82103084h case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 82103084h case   17:*/		return 0x82103088;
		  /* 82103088h */ case   18:  		/* bc 4, CR6_EQ, 444 */
		/* 82103088h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82103244;  }
		/* 82103088h case   18:*/		return 0x8210308C;
		  /* 8210308Ch */ case   19:  		/* lwz R7, <#[R11 + 12]> */
		/* 8210308Ch case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210308Ch case   19:*/		return 0x82103090;
	}
	return 0x82103090;
} // Block from 82103040h-82103090h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82103090h
// Function '?MergeArguments@CProgram@D3DXShader@@AAAJII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103090);
		  /* 82103090h */ case    0:  		/* mr R9, R4 */
		/* 82103090h case    0:*/		regs.R9 = regs.R4;
		/* 82103090h case    0:*/		return 0x82103094;
		  /* 82103094h */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 82103094h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82103094h case    1:*/		return 0x82103098;
		  /* 82103098h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 82103098h case    2:*/		if ( regs.CR[6].eq ) { return 0x821030DC;  }
		/* 82103098h case    2:*/		return 0x8210309C;
		  /* 8210309Ch */ case    3:  		/* lwz R8, <#[R11 + 16]> */
		/* 8210309Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 8210309Ch case    3:*/		return 0x821030A0;
		  /* 821030A0h */ case    4:  		/* mr R10, R4 */
		/* 821030A0h case    4:*/		regs.R10 = regs.R4;
		/* 821030A0h case    4:*/		return 0x821030A4;
		  /* 821030A4h */ case    5:  		/* lwzx R31, <#[R10 + R8]> */
		/* 821030A4h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 821030A4h case    5:*/		return 0x821030A8;
		  /* 821030A8h */ case    6:  		/* cmplw CR6, R29, R31 */
		/* 821030A8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R31);
		/* 821030A8h case    6:*/		return 0x821030AC;
		  /* 821030ACh */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 821030ACh case    7:*/		if ( regs.CR[6].eq ) { return 0x821030C4;  }
		/* 821030ACh case    7:*/		return 0x821030B0;
		  /* 821030B0h */ case    8:  		/* addi R9, R9, 1 */
		/* 821030B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821030B0h case    8:*/		return 0x821030B4;
		  /* 821030B4h */ case    9:  		/* addi R10, R10, 4 */
		/* 821030B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821030B4h case    9:*/		return 0x821030B8;
		  /* 821030B8h */ case   10:  		/* cmplw CR6, R9, R7 */
		/* 821030B8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 821030B8h case   10:*/		return 0x821030BC;
		  /* 821030BCh */ case   11:  		/* bc 12, CR6_LT, -24 */
		/* 821030BCh case   11:*/		if ( regs.CR[6].lt ) { return 0x821030A4;  }
		/* 821030BCh case   11:*/		return 0x821030C0;
		  /* 821030C0h */ case   12:  		/* b 28 */
		/* 821030C0h case   12:*/		return 0x821030DC;
		/* 821030C0h case   12:*/		return 0x821030C4;
	}
	return 0x821030C4;
} // Block from 82103090h-821030C4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821030C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821030C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821030C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821030C4);
		  /* 821030C4h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821030C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821030C4h case    0:*/		return 0x821030C8;
		  /* 821030C8h */ case    1:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 821030C8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 821030C8h case    1:*/		return 0x821030CC;
		  /* 821030CCh */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821030CCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821030CCh case    2:*/		return 0x821030D0;
		  /* 821030D0h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821030D0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821030D0h case    3:*/		return 0x821030D4;
		  /* 821030D4h */ case    4:  		/* lwzx R11, <#[R11 + R6]> */
		/* 821030D4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 821030D4h case    4:*/		return 0x821030D8;
		  /* 821030D8h */ case    5:  		/* lwz R29, <#[R11 + 48]> */
		/* 821030D8h case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000030) );
		/* 821030D8h case    5:*/		return 0x821030DC;
	}
	return 0x821030DC;
} // Block from 821030C4h-821030DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821030DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821030DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821030DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821030DC);
		  /* 821030DCh */ case    0:  		/* lwz R31, <#[R17 + 20]> */
		/* 821030DCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R17 + 0x00000014) );
		/* 821030DCh case    0:*/		return 0x821030E0;
		  /* 821030E0h */ case    1:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 821030E0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 821030E0h case    1:*/		return 0x821030E4;
		  /* 821030E4h */ case    2:  		/* lwzx R11, <#[R11 + R31]> */
		/* 821030E4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 821030E4h case    2:*/		return 0x821030E8;
		  /* 821030E8h */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 821030E8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821030E8h case    3:*/		return 0x821030EC;
		  /* 821030ECh */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821030ECh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821030ECh case    4:*/		return 0x821030F0;
		  /* 821030F0h */ case    5:  		/* lwzx R10, <#[R10 + R25]> */
		/* 821030F0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 821030F0h case    5:*/		return 0x821030F4;
		  /* 821030F4h */ case    6:  		/* lwz R10, <#[R10 + 4]> */
		/* 821030F4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821030F4h case    6:*/		return 0x821030F8;
		  /* 821030F8h */ case    7:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 821030F8h case    7:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 821030F8h case    7:*/		return 0x821030FC;
		  /* 821030FCh */ case    8:  		/* bc 12, CR0_EQ, 328 */
		/* 821030FCh case    8:*/		if ( regs.CR[0].eq ) { return 0x82103244;  }
		/* 821030FCh case    8:*/		return 0x82103100;
		  /* 82103100h */ case    9:  		/* lwz R11, <#[R11 + 72]> */
		/* 82103100h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82103100h case    9:*/		return 0x82103104;
		  /* 82103104h */ case   10:  		/* lwz R6, <#[R17 + 24]> */
		/* 82103104h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R17 + 0x00000018) );
		/* 82103104h case   10:*/		return 0x82103108;
		  /* 82103108h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103108h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103108h case   11:*/		return 0x8210310C;
		  /* 8210310Ch */ case   12:  		/* lwzx R10, <#[R11 + R6]> */
		/* 8210310Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210310Ch case   12:*/		return 0x82103110;
		  /* 82103110h */ case   13:  		/* lwz R11, <#[R10]> */
		/* 82103110h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82103110h case   13:*/		return 0x82103114;
		  /* 82103114h */ case   14:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82103114h case   14:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82103114h case   14:*/		return 0x82103118;
		  /* 82103118h */ case   15:  		/* cmplw CR6, R11, R22 */
		/* 82103118h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 82103118h case   15:*/		return 0x8210311C;
		  /* 8210311Ch */ case   16:  		/* bc 4, CR6_EQ, 296 */
		/* 8210311Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x82103244;  }
		/* 8210311Ch case   16:*/		return 0x82103120;
		  /* 82103120h */ case   17:  		/* lwz R8, <#[R10 + 12]> */
		/* 82103120h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 82103120h case   17:*/		return 0x82103124;
		  /* 82103124h */ case   18:  		/* mr R11, R4 */
		/* 82103124h case   18:*/		regs.R11 = regs.R4;
		/* 82103124h case   18:*/		return 0x82103128;
		  /* 82103128h */ case   19:  		/* cmplwi CR6, R8, 0 */
		/* 82103128h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82103128h case   19:*/		return 0x8210312C;
		  /* 8210312Ch */ case   20:  		/* bc 12, CR6_EQ, 124 */
		/* 8210312Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x821031A8;  }
		/* 8210312Ch case   20:*/		return 0x82103130;
		  /* 82103130h */ case   21:  		/* lwz R7, <#[R10 + 16]> */
		/* 82103130h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000010) );
		/* 82103130h case   21:*/		return 0x82103134;
		  /* 82103134h */ case   22:  		/* mr R9, R4 */
		/* 82103134h case   22:*/		regs.R9 = regs.R4;
		/* 82103134h case   22:*/		return 0x82103138;
	}
	return 0x82103138;
} // Block from 821030DCh-82103138h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82103138h
// Function '?SimplifyBinary@CProgram@D3DXShader@@AAAJPAVCInstruction@2@III@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103138);
		  /* 82103138h */ case    0:  		/* lwzx R19, <#[R9 + R7]> */
		/* 82103138h case    0:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82103138h case    0:*/		return 0x8210313C;
		  /* 8210313Ch */ case    1:  		/* cmplw CR6, R3, R19 */
		/* 8210313Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R19);
		/* 8210313Ch case    1:*/		return 0x82103140;
		  /* 82103140h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82103140h case    2:*/		if ( regs.CR[6].eq ) { return 0x82103158;  }
		/* 82103140h case    2:*/		return 0x82103144;
		  /* 82103144h */ case    3:  		/* addi R11, R11, 1 */
		/* 82103144h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82103144h case    3:*/		return 0x82103148;
		  /* 82103148h */ case    4:  		/* addi R9, R9, 4 */
		/* 82103148h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82103148h case    4:*/		return 0x8210314C;
		  /* 8210314Ch */ case    5:  		/* cmplw CR6, R11, R8 */
		/* 8210314Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8210314Ch case    5:*/		return 0x82103150;
		  /* 82103150h */ case    6:  		/* bc 12, CR6_LT, -24 */
		/* 82103150h case    6:*/		if ( regs.CR[6].lt ) { return 0x82103138;  }
		/* 82103150h case    6:*/		return 0x82103154;
		  /* 82103154h */ case    7:  		/* b 80 */
		/* 82103154h case    7:*/		return 0x821031A4;
		/* 82103154h case    7:*/		return 0x82103158;
	}
	return 0x82103158;
} // Block from 82103138h-82103158h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82103158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103158);
		  /* 82103158h */ case    0:  		/* rlwinm. R9, R26, 0, 31, 31 */
		/* 82103158h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R26);
		/* 82103158h case    0:*/		return 0x8210315C;
		  /* 8210315Ch */ case    1:  		/* add R9, R8, R11 */
		/* 8210315Ch case    1:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R11);
		/* 8210315Ch case    1:*/		return 0x82103160;
		  /* 82103160h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103160h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103160h case    2:*/		return 0x82103164;
		  /* 82103164h */ case    3:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82103164h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82103164h case    3:*/		return 0x82103168;
		  /* 82103168h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 82103168h case    4:*/		if ( regs.CR[0].eq ) { return 0x8210317C;  }
		/* 82103168h case    4:*/		return 0x8210316C;
		  /* 8210316Ch */ case    5:  		/* lwz R8, <#[R10 + 8]> */
		/* 8210316Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 8210316Ch case    5:*/		return 0x82103170;
		  /* 82103170h */ case    6:  		/* lwzx R10, <#[R11 + R8]> */
		/* 82103170h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82103170h case    6:*/		return 0x82103174;
		  /* 82103174h */ case    7:  		/* lwzx R11, <#[R9 + R8]> */
		/* 82103174h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82103174h case    7:*/		return 0x82103178;
		  /* 82103178h */ case    8:  		/* b 16 */
		/* 82103178h case    8:*/		return 0x82103188;
		/* 82103178h case    8:*/		return 0x8210317C;
	}
	return 0x8210317C;
} // Block from 82103158h-8210317Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210317Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210317C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210317C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210317C);
		  /* 8210317Ch */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 8210317Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8210317Ch case    0:*/		return 0x82103180;
		  /* 82103180h */ case    1:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82103180h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82103180h case    1:*/		return 0x82103184;
		  /* 82103184h */ case    2:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82103184h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82103184h case    2:*/		return 0x82103188;
	}
	return 0x82103188;
} // Block from 8210317Ch-82103188h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82103188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103188);
		  /* 82103188h */ case    0:  		/* lwz R9, <#[R17 + 20]> */
		/* 82103188h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000014) );
		/* 82103188h case    0:*/		return 0x8210318C;
		  /* 8210318Ch */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210318Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210318Ch case    1:*/		return 0x82103190;
		  /* 82103190h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103190h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103190h case    2:*/		return 0x82103194;
		  /* 82103194h */ case    3:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82103194h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82103194h case    3:*/		return 0x82103198;
		  /* 82103198h */ case    4:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82103198h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82103198h case    4:*/		return 0x8210319C;
		  /* 8210319Ch */ case    5:  		/* lwz R30, <#[R10 + 48]> */
		/* 8210319Ch case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x00000030) );
		/* 8210319Ch case    5:*/		return 0x821031A0;
		  /* 821031A0h */ case    6:  		/* lwz R27, <#[R11 + 48]> */
		/* 821031A0h case    6:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000030) );
		/* 821031A0h case    6:*/		return 0x821031A4;
	}
	return 0x821031A4;
} // Block from 82103188h-821031A4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821031A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821031A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821031A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821031A4);
		  /* 821031A4h */ case    0:  		/* lwz R19, <#[R1 + 80]> */
		/* 821031A4h case    0:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R1 + 0x00000050) );
		/* 821031A4h case    0:*/		return 0x821031A8;
	}
	return 0x821031A8;
} // Block from 821031A4h-821031A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821031A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821031A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821031A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821031A8);
		  /* 821031A8h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 821031A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821031A8h case    0:*/		return 0x821031AC;
		  /* 821031ACh */ case    1:  		/* bc 4, CR6_EQ, 144 */
		/* 821031ACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210323C;  }
		/* 821031ACh case    1:*/		return 0x821031B0;
		  /* 821031B0h */ case    2:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 821031B0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 821031B0h case    2:*/		return 0x821031B4;
		  /* 821031B4h */ case    3:  		/* lwzx R11, <#[R11 + R31]> */
		/* 821031B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 821031B4h case    3:*/		return 0x821031B8;
		  /* 821031B8h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 821031B8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821031B8h case    4:*/		return 0x821031BC;
		  /* 821031BCh */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821031BCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821031BCh case    5:*/		return 0x821031C0;
		  /* 821031C0h */ case    6:  		/* lwzx R10, <#[R10 + R25]> */
		/* 821031C0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 821031C0h case    6:*/		return 0x821031C4;
		  /* 821031C4h */ case    7:  		/* lwz R10, <#[R10 + 4]> */
		/* 821031C4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821031C4h case    7:*/		return 0x821031C8;
		  /* 821031C8h */ case    8:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 821031C8h case    8:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 821031C8h case    8:*/		return 0x821031CC;
		  /* 821031CCh */ case    9:  		/* bc 12, CR0_EQ, 120 */
		/* 821031CCh case    9:*/		if ( regs.CR[0].eq ) { return 0x82103244;  }
		/* 821031CCh case    9:*/		return 0x821031D0;
		  /* 821031D0h */ case   10:  		/* lwz R11, <#[R11 + 72]> */
		/* 821031D0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 821031D0h case   10:*/		return 0x821031D4;
		  /* 821031D4h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821031D4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821031D4h case   11:*/		return 0x821031D8;
		  /* 821031D8h */ case   12:  		/* lwzx R11, <#[R11 + R6]> */
		/* 821031D8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 821031D8h case   12:*/		return 0x821031DC;
		  /* 821031DCh */ case   13:  		/* lwz R10, <#[R11]> */
		/* 821031DCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821031DCh case   13:*/		return 0x821031E0;
		  /* 821031E0h */ case   14:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 821031E0h case   14:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 821031E0h case   14:*/		return 0x821031E4;
		  /* 821031E4h */ case   15:  		/* cmplw CR6, R10, R24 */
		/* 821031E4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 821031E4h case   15:*/		return 0x821031E8;
		  /* 821031E8h */ case   16:  		/* bc 4, CR6_EQ, 92 */
		/* 821031E8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82103244;  }
		/* 821031E8h case   16:*/		return 0x821031EC;
		  /* 821031ECh */ case   17:  		/* lwz R7, <#[R11 + 12]> */
		/* 821031ECh case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 821031ECh case   17:*/		return 0x821031F0;
		  /* 821031F0h */ case   18:  		/* mr R9, R4 */
		/* 821031F0h case   18:*/		regs.R9 = regs.R4;
		/* 821031F0h case   18:*/		return 0x821031F4;
		  /* 821031F4h */ case   19:  		/* cmplwi CR6, R7, 0 */
		/* 821031F4h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 821031F4h case   19:*/		return 0x821031F8;
		  /* 821031F8h */ case   20:  		/* bc 12, CR6_EQ, 68 */
		/* 821031F8h case   20:*/		if ( regs.CR[6].eq ) { return 0x8210323C;  }
		/* 821031F8h case   20:*/		return 0x821031FC;
		  /* 821031FCh */ case   21:  		/* lwz R8, <#[R11 + 16]> */
		/* 821031FCh case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 821031FCh case   21:*/		return 0x82103200;
		  /* 82103200h */ case   22:  		/* mr R10, R4 */
		/* 82103200h case   22:*/		regs.R10 = regs.R4;
		/* 82103200h case   22:*/		return 0x82103204;
		  /* 82103204h */ case   23:  		/* lwzx R6, <#[R8 + R10]> */
		/* 82103204h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82103204h case   23:*/		return 0x82103208;
		  /* 82103208h */ case   24:  		/* cmplw CR6, R30, R6 */
		/* 82103208h case   24:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R6);
		/* 82103208h case   24:*/		return 0x8210320C;
		  /* 8210320Ch */ case   25:  		/* bc 12, CR6_EQ, 24 */
		/* 8210320Ch case   25:*/		if ( regs.CR[6].eq ) { return 0x82103224;  }
		/* 8210320Ch case   25:*/		return 0x82103210;
		  /* 82103210h */ case   26:  		/* addi R9, R9, 1 */
		/* 82103210h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82103210h case   26:*/		return 0x82103214;
		  /* 82103214h */ case   27:  		/* addi R10, R10, 4 */
		/* 82103214h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82103214h case   27:*/		return 0x82103218;
		  /* 82103218h */ case   28:  		/* cmplw CR6, R9, R7 */
		/* 82103218h case   28:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82103218h case   28:*/		return 0x8210321C;
		  /* 8210321Ch */ case   29:  		/* bc 12, CR6_LT, -24 */
		/* 8210321Ch case   29:*/		if ( regs.CR[6].lt ) { return 0x82103204;  }
		/* 8210321Ch case   29:*/		return 0x82103220;
		  /* 82103220h */ case   30:  		/* b 28 */
		/* 82103220h case   30:*/		return 0x8210323C;
		/* 82103220h case   30:*/		return 0x82103224;
	}
	return 0x82103224;
} // Block from 821031A8h-82103224h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82103224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103224);
		  /* 82103224h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82103224h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82103224h case    0:*/		return 0x82103228;
		  /* 82103228h */ case    1:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 82103228h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 82103228h case    1:*/		return 0x8210322C;
		  /* 8210322Ch */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210322Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210322Ch case    2:*/		return 0x82103230;
		  /* 82103230h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103230h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103230h case    3:*/		return 0x82103234;
		  /* 82103234h */ case    4:  		/* lwzx R11, <#[R11 + R31]> */
		/* 82103234h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82103234h case    4:*/		return 0x82103238;
		  /* 82103238h */ case    5:  		/* lwz R30, <#[R11 + 48]> */
		/* 82103238h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000030) );
		/* 82103238h case    5:*/		return 0x8210323C;
	}
	return 0x8210323C;
} // Block from 82103224h-8210323Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210323Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210323C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210323C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210323C);
		  /* 8210323Ch */ case    0:  		/* cmplw CR6, R29, R30 */
		/* 8210323Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 8210323Ch case    0:*/		return 0x82103240;
		  /* 82103240h */ case    1:  		/* bc 12, CR6_EQ, 152 */
		/* 82103240h case    1:*/		if ( regs.CR[6].eq ) { return 0x821032D8;  }
		/* 82103240h case    1:*/		return 0x82103244;
	}
	return 0x82103244;
} // Block from 8210323Ch-82103244h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82103244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103244);
		  /* 82103244h */ case    0:  		/* addi R26, R26, 1 */
		/* 82103244h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82103244h case    0:*/		return 0x82103248;
		  /* 82103248h */ case    1:  		/* cmplwi CR6, R26, 8 */
		/* 82103248h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000008);
		/* 82103248h case    1:*/		return 0x8210324C;
		  /* 8210324Ch */ case    2:  		/* bc 12, CR6_LT, -560 */
		/* 8210324Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x8210301C;  }
		/* 8210324Ch case    2:*/		return 0x82103250;
	}
	return 0x82103250;
} // Block from 82103244h-82103250h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82103250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103250);
		  /* 82103250h */ case    0:  		/* lis R28, 4144 */
		/* 82103250h case    0:*/		cpu::op::lis<0>(regs,&regs.R28,0x1030);
		/* 82103250h case    0:*/		return 0x82103254;
		  /* 82103254h */ case    1:  		/* cmplw CR6, R21, R5 */
		/* 82103254h case    1:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R5);
		/* 82103254h case    1:*/		return 0x82103258;
		  /* 82103258h */ case    2:  		/* bc 4, CR6_EQ, 372 */
		/* 82103258h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821033CC;  }
		/* 82103258h case    2:*/		return 0x8210325C;
		  /* 8210325Ch */ case    3:  		/* lwz R11, <#[R1 + 316]> */
		/* 8210325Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000013C) );
		/* 8210325Ch case    3:*/		return 0x82103260;
		  /* 82103260h */ case    4:  		/* mr R3, R4 */
		/* 82103260h case    4:*/		regs.R3 = regs.R4;
		/* 82103260h case    4:*/		return 0x82103264;
		  /* 82103264h */ case    5:  		/* lwz R10, <#[R1 + 324]> */
		/* 82103264h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000144) );
		/* 82103264h case    5:*/		return 0x82103268;
		  /* 82103268h */ case    6:  		/* lwz R31, <#[R17 + 20]> */
		/* 82103268h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R17 + 0x00000014) );
		/* 82103268h case    6:*/		return 0x8210326C;
		  /* 8210326Ch */ case    7:  		/* stw R4, <#[R1 + 108]> */
		/* 8210326Ch case    7:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000006C) );
		/* 8210326Ch case    7:*/		return 0x82103270;
		  /* 82103270h */ case    8:  		/* stw R4, <#[R1 + 104]> */
		/* 82103270h case    8:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 82103270h case    8:*/		return 0x82103274;
		  /* 82103274h */ case    9:  		/* stw R11, <#[R1 + 88]> */
		/* 82103274h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82103274h case    9:*/		return 0x82103278;
		  /* 82103278h */ case   10:  		/* stw R10, <#[R1 + 92]> */
		/* 82103278h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82103278h case   10:*/		return 0x8210327C;
		  /* 8210327Ch */ case   11:  		/* stw R4, <#[R1 + 100]> */
		/* 8210327Ch case   11:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000064) );
		/* 8210327Ch case   11:*/		return 0x82103280;
		  /* 82103280h */ case   12:  		/* stw R4, <#[R1 + 96]> */
		/* 82103280h case   12:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 82103280h case   12:*/		return 0x82103284;
		  /* 82103284h */ case   13:  		/* addi R11, R1, 88 */
		/* 82103284h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x58);
		/* 82103284h case   13:*/		return 0x82103288;
		  /* 82103288h */ case   14:  		/* add R30, R3, R11 */
		/* 82103288h case   14:*/		cpu::op::add<0>(regs,&regs.R30,regs.R3,regs.R11);
		/* 82103288h case   14:*/		return 0x8210328C;
		  /* 8210328Ch */ case   15:  		/* lwzx R7, <#[R3 + R11]> */
		/* 8210328Ch case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 8210328Ch case   15:*/		return 0x82103290;
		  /* 82103290h */ case   16:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 82103290h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 82103290h case   16:*/		return 0x82103294;
		  /* 82103294h */ case   17:  		/* lwzx R11, <#[R11 + R31]> */
		/* 82103294h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82103294h case   17:*/		return 0x82103298;
		  /* 82103298h */ case   18:  		/* lwz R10, <#[R11 + 4]> */
		/* 82103298h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82103298h case   18:*/		return 0x8210329C;
		  /* 8210329Ch */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210329Ch case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210329Ch case   19:*/		return 0x821032A0;
		  /* 821032A0h */ case   20:  		/* lwzx R10, <#[R10 + R25]> */
		/* 821032A0h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 821032A0h case   20:*/		return 0x821032A4;
		  /* 821032A4h */ case   21:  		/* lwz R10, <#[R10 + 4]> */
		/* 821032A4h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821032A4h case   21:*/		return 0x821032A8;
		  /* 821032A8h */ case   22:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 821032A8h case   22:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 821032A8h case   22:*/		return 0x821032AC;
		  /* 821032ACh */ case   23:  		/* bc 12, CR0_EQ, 200 */
		/* 821032ACh case   23:*/		if ( regs.CR[0].eq ) { return 0x82103374;  }
		/* 821032ACh case   23:*/		return 0x821032B0;
		  /* 821032B0h */ case   24:  		/* lwz R29, <#[R17 + 24]> */
		/* 821032B0h case   24:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R17 + 0x00000018) );
		/* 821032B0h case   24:*/		return 0x821032B4;
		  /* 821032B4h */ case   25:  		/* lwz R11, <#[R11 + 72]> */
		/* 821032B4h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 821032B4h case   25:*/		return 0x821032B8;
		  /* 821032B8h */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821032B8h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821032B8h case   26:*/		return 0x821032BC;
		  /* 821032BCh */ case   27:  		/* lwzx R9, <#[R11 + R29]> */
		/* 821032BCh case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 821032BCh case   27:*/		return 0x821032C0;
		  /* 821032C0h */ case   28:  		/* lwz R11, <#[R9]> */
		/* 821032C0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821032C0h case   28:*/		return 0x821032C4;
		  /* 821032C4h */ case   29:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 821032C4h case   29:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821032C4h case   29:*/		return 0x821032C8;
		  /* 821032C8h */ case   30:  		/* cmplw CR6, R11, R24 */
		/* 821032C8h case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 821032C8h case   30:*/		return 0x821032CC;
		  /* 821032CCh */ case   31:  		/* bc 4, CR6_EQ, 20 */
		/* 821032CCh case   31:*/		if ( !regs.CR[6].eq ) { return 0x821032E0;  }
		/* 821032CCh case   31:*/		return 0x821032D0;
		  /* 821032D0h */ case   32:  		/* addi R11, R1, 104 */
		/* 821032D0h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x68);
		/* 821032D0h case   32:*/		return 0x821032D4;
		  /* 821032D4h */ case   33:  		/* b 24 */
		/* 821032D4h case   33:*/		return 0x821032EC;
		/* 821032D4h case   33:*/		return 0x821032D8;
	}
	return 0x821032D8;
} // Block from 82103250h-821032D8h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821032D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821032D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821032D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821032D8);
		  /* 821032D8h */ case    0:  		/* stw R27, <#[R19 + 48]> */
		/* 821032D8h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R19 + 0x00000030) );
		/* 821032D8h case    0:*/		return 0x821032DC;
		  /* 821032DCh */ case    1:  		/* b 1780 */
		/* 821032DCh case    1:*/		return 0x821039D0;
		/* 821032DCh case    1:*/		return 0x821032E0;
	}
	return 0x821032E0;
} // Block from 821032D8h-821032E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821032E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821032E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821032E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821032E0);
		  /* 821032E0h */ case    0:  		/* cmplw CR6, R11, R28 */
		/* 821032E0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 821032E0h case    0:*/		return 0x821032E4;
		  /* 821032E4h */ case    1:  		/* bc 4, CR6_EQ, 144 */
		/* 821032E4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82103374;  }
		/* 821032E4h case    1:*/		return 0x821032E8;
		  /* 821032E8h */ case    2:  		/* addi R11, R1, 96 */
		/* 821032E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 821032E8h case    2:*/		return 0x821032EC;
	}
	return 0x821032EC;
} // Block from 821032E0h-821032ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821032ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821032EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821032EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821032EC);
		  /* 821032ECh */ case    0:  		/* lwzx R10, <#[R3 + R11]> */
		/* 821032ECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821032ECh case    0:*/		return 0x821032F0;
		  /* 821032F0h */ case    1:  		/* lwz R6, <#[R9 + 12]> */
		/* 821032F0h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x0000000C) );
		/* 821032F0h case    1:*/		return 0x821032F4;
		  /* 821032F4h */ case    2:  		/* cntlzw R10, R10 */
		/* 821032F4h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 821032F4h case    2:*/		return 0x821032F8;
		  /* 821032F8h */ case    3:  		/* cmplwi CR6, R6, 0 */
		/* 821032F8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821032F8h case    3:*/		return 0x821032FC;
		  /* 821032FCh */ case    4:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 821032FCh case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 821032FCh case    4:*/		return 0x82103300;
		  /* 82103300h */ case    5:  		/* stwx R10, <#[R3 + R11]> */
		/* 82103300h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82103300h case    5:*/		return 0x82103304;
		  /* 82103304h */ case    6:  		/* mr R10, R4 */
		/* 82103304h case    6:*/		regs.R10 = regs.R4;
		/* 82103304h case    6:*/		return 0x82103308;
		  /* 82103308h */ case    7:  		/* bc 12, CR6_EQ, 68 */
		/* 82103308h case    7:*/		if ( regs.CR[6].eq ) { return 0x8210334C;  }
		/* 82103308h case    7:*/		return 0x8210330C;
		  /* 8210330Ch */ case    8:  		/* lwz R8, <#[R9 + 16]> */
		/* 8210330Ch case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000010) );
		/* 8210330Ch case    8:*/		return 0x82103310;
		  /* 82103310h */ case    9:  		/* mr R11, R4 */
		/* 82103310h case    9:*/		regs.R11 = regs.R4;
		/* 82103310h case    9:*/		return 0x82103314;
		  /* 82103314h */ case   10:  		/* lwzx R5, <#[R8 + R11]> */
		/* 82103314h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82103314h case   10:*/		return 0x82103318;
		  /* 82103318h */ case   11:  		/* cmplw CR6, R5, R7 */
		/* 82103318h case   11:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R7);
		/* 82103318h case   11:*/		return 0x8210331C;
		  /* 8210331Ch */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 8210331Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x82103334;  }
		/* 8210331Ch case   12:*/		return 0x82103320;
		  /* 82103320h */ case   13:  		/* addi R10, R10, 1 */
		/* 82103320h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82103320h case   13:*/		return 0x82103324;
		  /* 82103324h */ case   14:  		/* addi R11, R11, 4 */
		/* 82103324h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82103324h case   14:*/		return 0x82103328;
		  /* 82103328h */ case   15:  		/* cmplw CR6, R10, R6 */
		/* 82103328h case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 82103328h case   15:*/		return 0x8210332C;
		  /* 8210332Ch */ case   16:  		/* bc 12, CR6_LT, -24 */
		/* 8210332Ch case   16:*/		if ( regs.CR[6].lt ) { return 0x82103314;  }
		/* 8210332Ch case   16:*/		return 0x82103330;
		  /* 82103330h */ case   17:  		/* b 28 */
		/* 82103330h case   17:*/		return 0x8210334C;
		/* 82103330h case   17:*/		return 0x82103334;
	}
	return 0x82103334;
} // Block from 821032ECh-82103334h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82103334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103334);
		  /* 82103334h */ case    0:  		/* lwz R11, <#[R9 + 8]> */
		/* 82103334h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82103334h case    0:*/		return 0x82103338;
		  /* 82103338h */ case    1:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 82103338h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 82103338h case    1:*/		return 0x8210333C;
		  /* 8210333Ch */ case    2:  		/* lwzx R11, <#[R9 + R11]> */
		/* 8210333Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210333Ch case    2:*/		return 0x82103340;
		  /* 82103340h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103340h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103340h case    3:*/		return 0x82103344;
		  /* 82103344h */ case    4:  		/* lwzx R11, <#[R11 + R31]> */
		/* 82103344h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82103344h case    4:*/		return 0x82103348;
		  /* 82103348h */ case    5:  		/* lwz R7, <#[R11 + 48]> */
		/* 82103348h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000030) );
		/* 82103348h case    5:*/		return 0x8210334C;
	}
	return 0x8210334C;
} // Block from 82103334h-8210334Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210334Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210334C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210334C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210334C);
		  /* 8210334Ch */ case    0:  		/* cmplw CR6, R10, R6 */
		/* 8210334Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 8210334Ch case    0:*/		return 0x82103350;
		  /* 82103350h */ case    1:  		/* bc 4, CR6_LT, 112 */
		/* 82103350h case    1:*/		if ( !regs.CR[6].lt ) { return 0x821033C0;  }
		/* 82103350h case    1:*/		return 0x82103354;
		  /* 82103354h */ case    2:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 82103354h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 82103354h case    2:*/		return 0x82103358;
		  /* 82103358h */ case    3:  		/* lwzx R11, <#[R11 + R31]> */
		/* 82103358h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82103358h case    3:*/		return 0x8210335C;
		  /* 8210335Ch */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210335Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210335Ch case    4:*/		return 0x82103360;
		  /* 82103360h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82103360h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82103360h case    5:*/		return 0x82103364;
		  /* 82103364h */ case    6:  		/* lwzx R10, <#[R10 + R25]> */
		/* 82103364h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 82103364h case    6:*/		return 0x82103368;
		  /* 82103368h */ case    7:  		/* lwz R10, <#[R10 + 4]> */
		/* 82103368h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82103368h case    7:*/		return 0x8210336C;
		  /* 8210336Ch */ case    8:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 8210336Ch case    8:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 8210336Ch case    8:*/		return 0x82103370;
		  /* 82103370h */ case    9:  		/* bc 4, CR0_EQ, -188 */
		/* 82103370h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821032B4;  }
		/* 82103370h case    9:*/		return 0x82103374;
	}
	return 0x82103374;
} // Block from 8210334Ch-82103374h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82103374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103374);
		  /* 82103374h */ case    0:  		/* addi R3, R3, 4 */
		/* 82103374h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82103374h case    0:*/		return 0x82103378;
		  /* 82103378h */ case    1:  		/* stw R7, <#[R30]> */
		/* 82103378h case    1:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x00000000) );
		/* 82103378h case    1:*/		return 0x8210337C;
		  /* 8210337Ch */ case    2:  		/* cmplwi CR6, R3, 8 */
		/* 8210337Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000008);
		/* 8210337Ch case    2:*/		return 0x82103380;
		  /* 82103380h */ case    3:  		/* bc 12, CR6_LT, -252 */
		/* 82103380h case    3:*/		if ( regs.CR[6].lt ) { return 0x82103284;  }
		/* 82103380h case    3:*/		return 0x82103384;
		  /* 82103384h */ case    4:  		/* lwz R11, <#[R1 + 92]> */
		/* 82103384h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82103384h case    4:*/		return 0x82103388;
		  /* 82103388h */ case    5:  		/* lwz R10, <#[R1 + 88]> */
		/* 82103388h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82103388h case    5:*/		return 0x8210338C;
		  /* 8210338Ch */ case    6:  		/* cmplw CR6, R10, R11 */
		/* 8210338Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8210338Ch case    6:*/		return 0x82103390;
		  /* 82103390h */ case    7:  		/* bc 4, CR6_EQ, 60 */
		/* 82103390h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821033CC;  }
		/* 82103390h case    7:*/		return 0x82103394;
		  /* 82103394h */ case    8:  		/* lwz R11, <#[R1 + 100]> */
		/* 82103394h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82103394h case    8:*/		return 0x82103398;
		  /* 82103398h */ case    9:  		/* lwz R10, <#[R1 + 96]> */
		/* 82103398h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82103398h case    9:*/		return 0x8210339C;
		  /* 8210339Ch */ case   10:  		/* cmpw CR6, R10, R11 */
		/* 8210339Ch case   10:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 8210339Ch case   10:*/		return 0x821033A0;
		  /* 821033A0h */ case   11:  		/* bc 12, CR6_EQ, 44 */
		/* 821033A0h case   11:*/		if ( regs.CR[6].eq ) { return 0x821033CC;  }
		/* 821033A0h case   11:*/		return 0x821033A4;
		  /* 821033A4h */ case   12:  		/* lwz R11, <#[R1 + 108]> */
		/* 821033A4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 821033A4h case   12:*/		return 0x821033A8;
		  /* 821033A8h */ case   13:  		/* lwz R10, <#[R1 + 104]> */
		/* 821033A8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 821033A8h case   13:*/		return 0x821033AC;
		  /* 821033ACh */ case   14:  		/* cmpw CR6, R10, R11 */
		/* 821033ACh case   14:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 821033ACh case   14:*/		return 0x821033B0;
		  /* 821033B0h */ case   15:  		/* bc 12, CR6_EQ, -2492 */
		/* 821033B0h case   15:*/		if ( regs.CR[6].eq ) { return 0x821029F4;  }
		/* 821033B0h case   15:*/		return 0x821033B4;
		  /* 821033B4h */ case   16:  		/* lis R11, -32255 */
		/* 821033B4h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821033B4h case   16:*/		return 0x821033B8;
		  /* 821033B8h */ case   17:  		/* lfd FR1, <#[R11 - 24488]> */
		/* 821033B8h case   17:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0xFFFFA058) );
		/* 821033B8h case   17:*/		return 0x821033BC;
		  /* 821033BCh */ case   18:  		/* b -2496 */
		/* 821033BCh case   18:*/		return 0x821029FC;
		/* 821033BCh case   18:*/		return 0x821033C0;
	}
	return 0x821033C0;
} // Block from 82103374h-821033C0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821033C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821033C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821033C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821033C0);
		  /* 821033C0h */ case    0:  		/* lis R3, -32768 */
		/* 821033C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 821033C0h case    0:*/		return 0x821033C4;
		  /* 821033C4h */ case    1:  		/* ori R3, R3, 16389 */
		/* 821033C4h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 821033C4h case    1:*/		return 0x821033C8;
		  /* 821033C8h */ case    2:  		/* b 1548 */
		/* 821033C8h case    2:*/		return 0x821039D4;
		/* 821033C8h case    2:*/		return 0x821033CC;
	}
	return 0x821033CC;
} // Block from 821033C0h-821033CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821033CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821033CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821033CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821033CC);
		  /* 821033CCh */ case    0:  		/* cmplw CR6, R21, R20 */
		/* 821033CCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R20);
		/* 821033CCh case    0:*/		return 0x821033D0;
		  /* 821033D0h */ case    1:  		/* bc 4, CR6_EQ, 156 */
		/* 821033D0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210346C;  }
		/* 821033D0h case    1:*/		return 0x821033D4;
		  /* 821033D4h */ case    2:  		/* lwz R11, <#[R17 + 20]> */
		/* 821033D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000014) );
		/* 821033D4h case    2:*/		return 0x821033D8;
		  /* 821033D8h */ case    3:  		/* lwzx R11, <#[R15 + R11]> */
		/* 821033D8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + regs.R11 + 0x00000000) );
		/* 821033D8h case    3:*/		return 0x821033DC;
		  /* 821033DCh */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 821033DCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821033DCh case    4:*/		return 0x821033E0;
		  /* 821033E0h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821033E0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821033E0h case    5:*/		return 0x821033E4;
		  /* 821033E4h */ case    6:  		/* lwzx R10, <#[R10 + R25]> */
		/* 821033E4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 821033E4h case    6:*/		return 0x821033E8;
		  /* 821033E8h */ case    7:  		/* lwz R10, <#[R10 + 4]> */
		/* 821033E8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821033E8h case    7:*/		return 0x821033EC;
		  /* 821033ECh */ case    8:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 821033ECh case    8:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 821033ECh case    8:*/		return 0x821033F0;
		  /* 821033F0h */ case    9:  		/* bc 12, CR0_EQ, 124 */
		/* 821033F0h case    9:*/		if ( regs.CR[0].eq ) { return 0x8210346C;  }
		/* 821033F0h case    9:*/		return 0x821033F4;
		  /* 821033F4h */ case   10:  		/* rlwinm. R10, R23, 0, 31, 31 */
		/* 821033F4h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R23);
		/* 821033F4h case   10:*/		return 0x821033F8;
		  /* 821033F8h */ case   11:  		/* bc 12, CR0_EQ, 116 */
		/* 821033F8h case   11:*/		if ( regs.CR[0].eq ) { return 0x8210346C;  }
		/* 821033F8h case   11:*/		return 0x821033FC;
		  /* 821033FCh */ case   12:  		/* lwz R11, <#[R11 + 72]> */
		/* 821033FCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 821033FCh case   12:*/		return 0x82103400;
		  /* 82103400h */ case   13:  		/* lwz R10, <#[R17 + 24]> */
		/* 82103400h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000018) );
		/* 82103400h case   13:*/		return 0x82103404;
		  /* 82103404h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103404h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103404h case   14:*/		return 0x82103408;
		  /* 82103408h */ case   15:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82103408h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82103408h case   15:*/		return 0x8210340C;
		  /* 8210340Ch */ case   16:  		/* lwz R11, <#[R10]> */
		/* 8210340Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8210340Ch case   16:*/		return 0x82103410;
		  /* 82103410h */ case   17:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82103410h case   17:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82103410h case   17:*/		return 0x82103414;
		  /* 82103414h */ case   18:  		/* cmplw CR6, R11, R24 */
		/* 82103414h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 82103414h case   18:*/		return 0x82103418;
		  /* 82103418h */ case   19:  		/* bc 4, CR6_EQ, 84 */
		/* 82103418h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8210346C;  }
		/* 82103418h case   19:*/		return 0x8210341C;
		  /* 8210341Ch */ case   20:  		/* lwz R7, <#[R10 + 12]> */
		/* 8210341Ch case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210341Ch case   20:*/		return 0x82103420;
		  /* 82103420h */ case   21:  		/* mr R9, R4 */
		/* 82103420h case   21:*/		regs.R9 = regs.R4;
		/* 82103420h case   21:*/		return 0x82103424;
		  /* 82103424h */ case   22:  		/* cmplwi CR6, R7, 0 */
		/* 82103424h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82103424h case   22:*/		return 0x82103428;
		  /* 82103428h */ case   23:  		/* bc 12, CR6_EQ, 44 */
		/* 82103428h case   23:*/		if ( regs.CR[6].eq ) { return 0x82103454;  }
		/* 82103428h case   23:*/		return 0x8210342C;
		  /* 8210342Ch */ case   24:  		/* lwz R8, <#[R10 + 16]> */
		/* 8210342Ch case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 8210342Ch case   24:*/		return 0x82103430;
		  /* 82103430h */ case   25:  		/* mr R11, R4 */
		/* 82103430h case   25:*/		regs.R11 = regs.R4;
		/* 82103430h case   25:*/		return 0x82103434;
		  /* 82103434h */ case   26:  		/* lwzx R6, <#[R8 + R11]> */
		/* 82103434h case   26:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82103434h case   26:*/		return 0x82103438;
		  /* 82103438h */ case   27:  		/* lwz R5, <#[R1 + 316]> */
		/* 82103438h case   27:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000013C) );
		/* 82103438h case   27:*/		return 0x8210343C;
		  /* 8210343Ch */ case   28:  		/* cmplw CR6, R6, R5 */
		/* 8210343Ch case   28:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 8210343Ch case   28:*/		return 0x82103440;
		  /* 82103440h */ case   29:  		/* bc 12, CR6_EQ, 20 */
		/* 82103440h case   29:*/		if ( regs.CR[6].eq ) { return 0x82103454;  }
		/* 82103440h case   29:*/		return 0x82103444;
		  /* 82103444h */ case   30:  		/* addi R9, R9, 1 */
		/* 82103444h case   30:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82103444h case   30:*/		return 0x82103448;
		  /* 82103448h */ case   31:  		/* addi R11, R11, 4 */
		/* 82103448h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82103448h case   31:*/		return 0x8210344C;
		  /* 8210344Ch */ case   32:  		/* cmplw CR6, R9, R7 */
		/* 8210344Ch case   32:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8210344Ch case   32:*/		return 0x82103450;
		  /* 82103450h */ case   33:  		/* bc 12, CR6_LT, -28 */
		/* 82103450h case   33:*/		if ( regs.CR[6].lt ) { return 0x82103434;  }
		/* 82103450h case   33:*/		return 0x82103454;
	}
	return 0x82103454;
} // Block from 821033CCh-82103454h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82103454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103454);
		  /* 82103454h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82103454h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82103454h case    0:*/		return 0x82103458;
		  /* 82103458h */ case    1:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82103458h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82103458h case    1:*/		return 0x8210345C;
		  /* 8210345Ch */ case    2:  		/* lwz R11, <#[R1 + 324]> */
		/* 8210345Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000144) );
		/* 8210345Ch case    2:*/		return 0x82103460;
		  /* 82103460h */ case    3:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82103460h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82103460h case    3:*/		return 0x82103464;
		  /* 82103464h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 82103464h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82103464h case    4:*/		return 0x82103468;
		  /* 82103468h */ case    5:  		/* bc 12, CR6_EQ, -2628 */
		/* 82103468h case    5:*/		if ( regs.CR[6].eq ) { return 0x82102A24;  }
		/* 82103468h case    5:*/		return 0x8210346C;
	}
	return 0x8210346C;
} // Block from 82103454h-8210346Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210346Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210346C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210346C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210346C);
		  /* 8210346Ch */ case    0:  		/* lwz R19, <#[R17 + 20]> */
		/* 8210346Ch case    0:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R17 + 0x00000014) );
		/* 8210346Ch case    0:*/		return 0x82103470;
		  /* 82103470h */ case    1:  		/* lwzx R11, <#[R15 + R19]> */
		/* 82103470h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + regs.R19 + 0x00000000) );
		/* 82103470h case    1:*/		return 0x82103474;
		  /* 82103474h */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 82103474h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82103474h case    2:*/		return 0x82103478;
		  /* 82103478h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82103478h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82103478h case    3:*/		return 0x8210347C;
		  /* 8210347Ch */ case    4:  		/* lwzx R10, <#[R10 + R25]> */
		/* 8210347Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 8210347Ch case    4:*/		return 0x82103480;
		  /* 82103480h */ case    5:  		/* lwz R10, <#[R10 + 4]> */
		/* 82103480h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82103480h case    5:*/		return 0x82103484;
		  /* 82103484h */ case    6:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 82103484h case    6:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 82103484h case    6:*/		return 0x82103488;
		  /* 82103488h */ case    7:  		/* bc 12, CR0_EQ, 1352 */
		/* 82103488h case    7:*/		if ( regs.CR[0].eq ) { return 0x821039D0;  }
		/* 82103488h case    7:*/		return 0x8210348C;
		  /* 8210348Ch */ case    8:  		/* lwz R10, <#[R1 + 84]> */
		/* 8210348Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8210348Ch case    8:*/		return 0x82103490;
		  /* 82103490h */ case    9:  		/* lwzx R9, <#[R10 + R19]> */
		/* 82103490h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R19 + 0x00000000) );
		/* 82103490h case    9:*/		return 0x82103494;
		  /* 82103494h */ case   10:  		/* lwz R9, <#[R9 + 4]> */
		/* 82103494h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82103494h case   10:*/		return 0x82103498;
		  /* 82103498h */ case   11:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82103498h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82103498h case   11:*/		return 0x8210349C;
		  /* 8210349Ch */ case   12:  		/* lwzx R9, <#[R9 + R25]> */
		/* 8210349Ch case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R25 + 0x00000000) );
		/* 8210349Ch case   12:*/		return 0x821034A0;
		  /* 821034A0h */ case   13:  		/* lwz R9, <#[R9 + 4]> */
		/* 821034A0h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 821034A0h case   13:*/		return 0x821034A4;
		  /* 821034A4h */ case   14:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 821034A4h case   14:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 821034A4h case   14:*/		return 0x821034A8;
		  /* 821034A8h */ case   15:  		/* bc 12, CR0_EQ, 1320 */
		/* 821034A8h case   15:*/		if ( regs.CR[0].eq ) { return 0x821039D0;  }
		/* 821034A8h case   15:*/		return 0x821034AC;
		  /* 821034ACh */ case   16:  		/* lis R29, 8272 */
		/* 821034ACh case   16:*/		cpu::op::lis<0>(regs,&regs.R29,0x2050);
		/* 821034ACh case   16:*/		return 0x821034B0;
		  /* 821034B0h */ case   17:  		/* cmplw CR6, R21, R29 */
		/* 821034B0h case   17:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R29);
		/* 821034B0h case   17:*/		return 0x821034B4;
		  /* 821034B4h */ case   18:  		/* bc 12, CR6_EQ, 20 */
		/* 821034B4h case   18:*/		if ( regs.CR[6].eq ) { return 0x821034C8;  }
		/* 821034B4h case   18:*/		return 0x821034B8;
		  /* 821034B8h */ case   19:  		/* cmplw CR6, R21, R20 */
		/* 821034B8h case   19:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R20);
		/* 821034B8h case   19:*/		return 0x821034BC;
		  /* 821034BCh */ case   20:  		/* bc 12, CR6_EQ, 12 */
		/* 821034BCh case   20:*/		if ( regs.CR[6].eq ) { return 0x821034C8;  }
		/* 821034BCh case   20:*/		return 0x821034C0;
		  /* 821034C0h */ case   21:  		/* cmplw CR6, R21, R18 */
		/* 821034C0h case   21:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R18);
		/* 821034C0h case   21:*/		return 0x821034C4;
		  /* 821034C4h */ case   22:  		/* bc 4, CR6_EQ, 376 */
		/* 821034C4h case   22:*/		if ( !regs.CR[6].eq ) { return 0x8210363C;  }
		/* 821034C4h case   22:*/		return 0x821034C8;
	}
	return 0x821034C8;
} // Block from 8210346Ch-821034C8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821034C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821034C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821034C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821034C8);
		  /* 821034C8h */ case    0:  		/* lwz R9, <#[R17 + 20]> */
		/* 821034C8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000014) );
		/* 821034C8h case    0:*/		return 0x821034CC;
		  /* 821034CCh */ case    1:  		/* lwz R8, <#[R17 + 24]> */
		/* 821034CCh case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R17 + 0x00000018) );
		/* 821034CCh case    1:*/		return 0x821034D0;
		  /* 821034D0h */ case    2:  		/* lwzx R7, <#[R15 + R9]> */
		/* 821034D0h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R15 + regs.R9 + 0x00000000) );
		/* 821034D0h case    2:*/		return 0x821034D4;
		  /* 821034D4h */ case    3:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821034D4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821034D4h case    3:*/		return 0x821034D8;
		  /* 821034D8h */ case    4:  		/* lwz R9, <#[R7 + 72]> */
		/* 821034D8h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000048) );
		/* 821034D8h case    4:*/		return 0x821034DC;
		  /* 821034DCh */ case    5:  		/* lwz R10, <#[R10 + 72]> */
		/* 821034DCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 821034DCh case    5:*/		return 0x821034E0;
		  /* 821034E0h */ case    6:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821034E0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821034E0h case    6:*/		return 0x821034E4;
		  /* 821034E4h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821034E4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821034E4h case    7:*/		return 0x821034E8;
		  /* 821034E8h */ case    8:  		/* lwzx R6, <#[R9 + R8]> */
		/* 821034E8h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 821034E8h case    8:*/		return 0x821034EC;
		  /* 821034ECh */ case    9:  		/* lwzx R3, <#[R10 + R8]> */
		/* 821034ECh case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 821034ECh case    9:*/		return 0x821034F0;
		  /* 821034F0h */ case   10:  		/* lwz R10, <#[R6]> */
		/* 821034F0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 821034F0h case   10:*/		return 0x821034F4;
		  /* 821034F4h */ case   11:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 821034F4h case   11:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 821034F4h case   11:*/		return 0x821034F8;
		  /* 821034F8h */ case   12:  		/* cmplw CR6, R10, R24 */
		/* 821034F8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 821034F8h case   12:*/		return 0x821034FC;
		  /* 821034FCh */ case   13:  		/* bc 4, CR6_EQ, 320 */
		/* 821034FCh case   13:*/		if ( !regs.CR[6].eq ) { return 0x8210363C;  }
		/* 821034FCh case   13:*/		return 0x82103500;
		  /* 82103500h */ case   14:  		/* lwz R10, <#[R3]> */
		/* 82103500h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82103500h case   14:*/		return 0x82103504;
		  /* 82103504h */ case   15:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82103504h case   15:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82103504h case   15:*/		return 0x82103508;
		  /* 82103508h */ case   16:  		/* cmplw CR6, R10, R24 */
		/* 82103508h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 82103508h case   16:*/		return 0x8210350C;
		  /* 8210350Ch */ case   17:  		/* bc 4, CR6_EQ, 304 */
		/* 8210350Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x8210363C;  }
		/* 8210350Ch case   17:*/		return 0x82103510;
		  /* 82103510h */ case   18:  		/* lwz R4, <#[R1 + 300]> */
		/* 82103510h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000012C) );
		/* 82103510h case   18:*/		return 0x82103514;
		  /* 82103514h */ case   19:  		/* li R31, 0 */
		/* 82103514h case   19:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82103514h case   19:*/		return 0x82103518;
		  /* 82103518h */ case   20:  		/* lwz R9, <#[R4 + 12]> */
		/* 82103518h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x0000000C) );
		/* 82103518h case   20:*/		return 0x8210351C;
		  /* 8210351Ch */ case   21:  		/* cmplwi CR6, R9, 0 */
		/* 8210351Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8210351Ch case   21:*/		return 0x82103520;
		  /* 82103520h */ case   22:  		/* bc 12, CR6_EQ, 44 */
		/* 82103520h case   22:*/		if ( regs.CR[6].eq ) { return 0x8210354C;  }
		/* 82103520h case   22:*/		return 0x82103524;
		  /* 82103524h */ case   23:  		/* lwz R10, <#[R4 + 16]> */
		/* 82103524h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 82103524h case   23:*/		return 0x82103528;
		  /* 82103528h */ case   24:  		/* li R11, 0 */
		/* 82103528h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82103528h case   24:*/		return 0x8210352C;
		  /* 8210352Ch */ case   25:  		/* lwzx R8, <#[R10 + R11]> */
		/* 8210352Ch case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210352Ch case   25:*/		return 0x82103530;
		  /* 82103530h */ case   26:  		/* lwz R7, <#[R1 + 308]> */
		/* 82103530h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000134) );
		/* 82103530h case   26:*/		return 0x82103534;
		  /* 82103534h */ case   27:  		/* cmplw CR6, R7, R8 */
		/* 82103534h case   27:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 82103534h case   27:*/		return 0x82103538;
		  /* 82103538h */ case   28:  		/* bc 12, CR6_EQ, 20 */
		/* 82103538h case   28:*/		if ( regs.CR[6].eq ) { return 0x8210354C;  }
		/* 82103538h case   28:*/		return 0x8210353C;
		  /* 8210353Ch */ case   29:  		/* addi R31, R31, 1 */
		/* 8210353Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8210353Ch case   29:*/		return 0x82103540;
		  /* 82103540h */ case   30:  		/* addi R11, R11, 4 */
		/* 82103540h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82103540h case   30:*/		return 0x82103544;
		  /* 82103544h */ case   31:  		/* cmplw CR6, R31, R9 */
		/* 82103544h case   31:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 82103544h case   31:*/		return 0x82103548;
		  /* 82103548h */ case   32:  		/* bc 12, CR6_LT, -28 */
		/* 82103548h case   32:*/		if ( regs.CR[6].lt ) { return 0x8210352C;  }
		/* 82103548h case   32:*/		return 0x8210354C;
	}
	return 0x8210354C;
} // Block from 821034C8h-8210354Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 8210354Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210354C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210354C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210354C);
		  /* 8210354Ch */ case    0:  		/* lwz R9, <#[R6 + 12]> */
		/* 8210354Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x0000000C) );
		/* 8210354Ch case    0:*/		return 0x82103550;
		  /* 82103550h */ case    1:  		/* li R7, 0 */
		/* 82103550h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82103550h case    1:*/		return 0x82103554;
		  /* 82103554h */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 82103554h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82103554h case    2:*/		return 0x82103558;
		  /* 82103558h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 82103558h case    3:*/		if ( regs.CR[6].eq ) { return 0x82103584;  }
		/* 82103558h case    3:*/		return 0x8210355C;
		  /* 8210355Ch */ case    4:  		/* lwz R10, <#[R6 + 16]> */
		/* 8210355Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000010) );
		/* 8210355Ch case    4:*/		return 0x82103560;
		  /* 82103560h */ case    5:  		/* li R11, 0 */
		/* 82103560h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82103560h case    5:*/		return 0x82103564;
		  /* 82103564h */ case    6:  		/* lwzx R8, <#[R10 + R11]> */
		/* 82103564h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82103564h case    6:*/		return 0x82103568;
		  /* 82103568h */ case    7:  		/* lwz R5, <#[R1 + 316]> */
		/* 82103568h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000013C) );
		/* 82103568h case    7:*/		return 0x8210356C;
		  /* 8210356Ch */ case    8:  		/* cmplw CR6, R5, R8 */
		/* 8210356Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R8);
		/* 8210356Ch case    8:*/		return 0x82103570;
		  /* 82103570h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 82103570h case    9:*/		if ( regs.CR[6].eq ) { return 0x82103584;  }
		/* 82103570h case    9:*/		return 0x82103574;
		  /* 82103574h */ case   10:  		/* addi R7, R7, 1 */
		/* 82103574h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82103574h case   10:*/		return 0x82103578;
		  /* 82103578h */ case   11:  		/* addi R11, R11, 4 */
		/* 82103578h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82103578h case   11:*/		return 0x8210357C;
		  /* 8210357Ch */ case   12:  		/* cmplw CR6, R7, R9 */
		/* 8210357Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 8210357Ch case   12:*/		return 0x82103580;
		  /* 82103580h */ case   13:  		/* bc 12, CR6_LT, -28 */
		/* 82103580h case   13:*/		if ( regs.CR[6].lt ) { return 0x82103564;  }
		/* 82103580h case   13:*/		return 0x82103584;
	}
	return 0x82103584;
} // Block from 8210354Ch-82103584h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82103584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103584);
		  /* 82103584h */ case    0:  		/* lwz R8, <#[R3 + 12]> */
		/* 82103584h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000000C) );
		/* 82103584h case    0:*/		return 0x82103588;
		  /* 82103588h */ case    1:  		/* li R11, 0 */
		/* 82103588h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82103588h case    1:*/		return 0x8210358C;
		  /* 8210358Ch */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 8210358Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8210358Ch case    2:*/		return 0x82103590;
		  /* 82103590h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 82103590h case    3:*/		if ( regs.CR[6].eq ) { return 0x821035BC;  }
		/* 82103590h case    3:*/		return 0x82103594;
		  /* 82103594h */ case    4:  		/* lwz R9, <#[R3 + 16]> */
		/* 82103594h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 82103594h case    4:*/		return 0x82103598;
		  /* 82103598h */ case    5:  		/* li R10, 0 */
		/* 82103598h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82103598h case    5:*/		return 0x8210359C;
		  /* 8210359Ch */ case    6:  		/* lwzx R5, <#[R9 + R10]> */
		/* 8210359Ch case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210359Ch case    6:*/		return 0x821035A0;
		  /* 821035A0h */ case    7:  		/* lwz R30, <#[R1 + 324]> */
		/* 821035A0h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000144) );
		/* 821035A0h case    7:*/		return 0x821035A4;
		  /* 821035A4h */ case    8:  		/* cmplw CR6, R30, R5 */
		/* 821035A4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R5);
		/* 821035A4h case    8:*/		return 0x821035A8;
		  /* 821035A8h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 821035A8h case    9:*/		if ( regs.CR[6].eq ) { return 0x821035BC;  }
		/* 821035A8h case    9:*/		return 0x821035AC;
		  /* 821035ACh */ case   10:  		/* addi R11, R11, 1 */
		/* 821035ACh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821035ACh case   10:*/		return 0x821035B0;
		  /* 821035B0h */ case   11:  		/* addi R10, R10, 4 */
		/* 821035B0h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821035B0h case   11:*/		return 0x821035B4;
		  /* 821035B4h */ case   12:  		/* cmplw CR6, R11, R8 */
		/* 821035B4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821035B4h case   12:*/		return 0x821035B8;
		  /* 821035B8h */ case   13:  		/* bc 12, CR6_LT, -28 */
		/* 821035B8h case   13:*/		if ( regs.CR[6].lt ) { return 0x8210359C;  }
		/* 821035B8h case   13:*/		return 0x821035BC;
	}
	return 0x821035BC;
} // Block from 82103584h-821035BCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 821035BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821035BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821035BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821035BC);
		  /* 821035BCh */ case    0:  		/* cmplw CR6, R21, R29 */
		/* 821035BCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R29);
		/* 821035BCh case    0:*/		return 0x821035C0;
		  /* 821035C0h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 821035C0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821035E0;  }
		/* 821035C0h case    1:*/		return 0x821035C4;
		  /* 821035C4h */ case    2:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 821035C4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 821035C4h case    2:*/		return 0x821035C8;
		  /* 821035C8h */ case    3:  		/* lwz R10, <#[R6 + 8]> */
		/* 821035C8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000008) );
		/* 821035C8h case    3:*/		return 0x821035CC;
		  /* 821035CCh */ case    4:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 821035CCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 821035CCh case    4:*/		return 0x821035D0;
		  /* 821035D0h */ case    5:  		/* lwz R8, <#[R3 + 8]> */
		/* 821035D0h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 821035D0h case    5:*/		return 0x821035D4;
		  /* 821035D4h */ case    6:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821035D4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821035D4h case    6:*/		return 0x821035D8;
		  /* 821035D8h */ case    7:  		/* lwzx R10, <#[R9 + R8]> */
		/* 821035D8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 821035D8h case    7:*/		return 0x821035DC;
		  /* 821035DCh */ case    8:  		/* b 28 */
		/* 821035DCh case    8:*/		return 0x821035F8;
		/* 821035DCh case    8:*/		return 0x821035E0;
	}
	return 0x821035E0;
} // Block from 821035BCh-821035E0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821035E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821035E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821035E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821035E0);
		  /* 821035E0h */ case    0:  		/* lwz R10, <#[R3 + 8]> */
		/* 821035E0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821035E0h case    0:*/		return 0x821035E4;
		  /* 821035E4h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821035E4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821035E4h case    1:*/		return 0x821035E8;
		  /* 821035E8h */ case    2:  		/* lwz R9, <#[R6 + 8]> */
		/* 821035E8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000008) );
		/* 821035E8h case    2:*/		return 0x821035EC;
		  /* 821035ECh */ case    3:  		/* rlwinm R8, R7, 2, 0, 29 */
		/* 821035ECh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R7);
		/* 821035ECh case    3:*/		return 0x821035F0;
		  /* 821035F0h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821035F0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821035F0h case    4:*/		return 0x821035F4;
		  /* 821035F4h */ case    5:  		/* lwzx R10, <#[R8 + R9]> */
		/* 821035F4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 821035F4h case    5:*/		return 0x821035F8;
	}
	return 0x821035F8;
} // Block from 821035E0h-821035F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821035F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821035F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821035F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821035F8);
		  /* 821035F8h */ case    0:  		/* lwz R9, <#[R17 + 20]> */
		/* 821035F8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000014) );
		/* 821035F8h case    0:*/		return 0x821035FC;
		  /* 821035FCh */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821035FCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821035FCh case    1:*/		return 0x82103600;
		  /* 82103600h */ case    2:  		/* lwz R8, <#[R4 + 8]> */
		/* 82103600h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000008) );
		/* 82103600h case    2:*/		return 0x82103604;
		  /* 82103604h */ case    3:  		/* rlwinm R7, R31, 2, 0, 29 */
		/* 82103604h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R31);
		/* 82103604h case    3:*/		return 0x82103608;
		  /* 82103608h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82103608h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82103608h case    4:*/		return 0x8210360C;
		  /* 8210360Ch */ case    5:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210360Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210360Ch case    5:*/		return 0x82103610;
		  /* 82103610h */ case    6:  		/* lwz R11, <#[R11 + 48]> */
		/* 82103610h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82103610h case    6:*/		return 0x82103614;
		  /* 82103614h */ case    7:  		/* stwx R11, <#[R7 + R8]> */
		/* 82103614h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 82103614h case    7:*/		return 0x82103618;
		  /* 82103618h */ case    8:  		/* lwz R9, <#[R17 + 20]> */
		/* 82103618h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000014) );
		/* 82103618h case    8:*/		return 0x8210361C;
		  /* 8210361Ch */ case    9:  		/* lwz R8, <#[R4 + 8]> */
		/* 8210361Ch case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000008) );
		/* 8210361Ch case    9:*/		return 0x82103620;
		  /* 82103620h */ case   10:  		/* lwz R11, <#[R4 + 12]> */
		/* 82103620h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82103620h case   10:*/		return 0x82103624;
		  /* 82103624h */ case   11:  		/* add R11, R11, R31 */
		/* 82103624h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82103624h case   11:*/		return 0x82103628;
		  /* 82103628h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103628h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103628h case   12:*/		return 0x8210362C;
		  /* 8210362Ch */ case   13:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210362Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210362Ch case   13:*/		return 0x82103630;
		  /* 82103630h */ case   14:  		/* lwz R10, <#[R10 + 48]> */
		/* 82103630h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 82103630h case   14:*/		return 0x82103634;
		  /* 82103634h */ case   15:  		/* stwx R10, <#[R11 + R8]> */
		/* 82103634h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82103634h case   15:*/		return 0x82103638;
		  /* 82103638h */ case   16:  		/* b 920 */
		/* 82103638h case   16:*/		return 0x821039D0;
		/* 82103638h case   16:*/		return 0x8210363C;
	}
	return 0x8210363C;
} // Block from 821035F8h-8210363Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8210363Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210363C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210363C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210363C);
		  /* 8210363Ch */ case    0:  		/* lwz R31, <#[R1 + 316]> */
		/* 8210363Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x0000013C) );
		/* 8210363Ch case    0:*/		return 0x82103640;
		  /* 82103640h */ case    1:  		/* cmplw CR6, R21, R29 */
		/* 82103640h case    1:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R29);
		/* 82103640h case    1:*/		return 0x82103644;
		  /* 82103644h */ case    2:  		/* lwz R30, <#[R1 + 324]> */
		/* 82103644h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000144) );
		/* 82103644h case    2:*/		return 0x82103648;
		  /* 82103648h */ case    3:  		/* bc 4, CR6_EQ, 904 */
		/* 82103648h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82103648h case    3:*/		return 0x8210364C;
		  /* 8210364Ch */ case    4:  		/* cmplw CR6, R31, R30 */
		/* 8210364Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 8210364Ch case    4:*/		return 0x82103650;
		  /* 82103650h */ case    5:  		/* bc 4, CR6_EQ, 312 */
		/* 82103650h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82103788;  }
		/* 82103650h case    5:*/		return 0x82103654;
		  /* 82103654h */ case    6:  		/* lwz R11, <#[R11 + 72]> */
		/* 82103654h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82103654h case    6:*/		return 0x82103658;
		  /* 82103658h */ case    7:  		/* lis R3, 4208 */
		/* 82103658h case    7:*/		cpu::op::lis<0>(regs,&regs.R3,0x1070);
		/* 82103658h case    7:*/		return 0x8210365C;
		  /* 8210365Ch */ case    8:  		/* lwz R5, <#[R17 + 24]> */
		/* 8210365Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R17 + 0x00000018) );
		/* 8210365Ch case    8:*/		return 0x82103660;
		  /* 82103660h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103660h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103660h case    9:*/		return 0x82103664;
		  /* 82103664h */ case   10:  		/* lwzx R7, <#[R11 + R5]> */
		/* 82103664h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 82103664h case   10:*/		return 0x82103668;
		  /* 82103668h */ case   11:  		/* lwz R11, <#[R7]> */
		/* 82103668h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82103668h case   11:*/		return 0x8210366C;
		  /* 8210366Ch */ case   12:  		/* rlwinm R4, R11, 0, 0, 11 */
		/* 8210366Ch case   12:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R4,regs.R11);
		/* 8210366Ch case   12:*/		return 0x82103670;
		  /* 82103670h */ case   13:  		/* cmplw CR6, R4, R28 */
		/* 82103670h case   13:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R28);
		/* 82103670h case   13:*/		return 0x82103674;
		  /* 82103674h */ case   14:  		/* bc 12, CR6_EQ, 12 */
		/* 82103674h case   14:*/		if ( regs.CR[6].eq ) { return 0x82103680;  }
		/* 82103674h case   14:*/		return 0x82103678;
		  /* 82103678h */ case   15:  		/* cmplw CR6, R4, R3 */
		/* 82103678h case   15:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 82103678h case   15:*/		return 0x8210367C;
		  /* 8210367Ch */ case   16:  		/* bc 4, CR6_EQ, 268 */
		/* 8210367Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x82103788;  }
		/* 8210367Ch case   16:*/		return 0x82103680;
	}
	return 0x82103680;
} // Block from 8210363Ch-82103680h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82103680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103680);
		  /* 82103680h */ case    0:  		/* lwz R8, <#[R7 + 12]> */
		/* 82103680h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x0000000C) );
		/* 82103680h case    0:*/		return 0x82103684;
		  /* 82103684h */ case    1:  		/* li R10, 0 */
		/* 82103684h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82103684h case    1:*/		return 0x82103688;
		  /* 82103688h */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 82103688h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82103688h case    2:*/		return 0x8210368C;
		  /* 8210368Ch */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 8210368Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x821036B4;  }
		/* 8210368Ch case    3:*/		return 0x82103690;
		  /* 82103690h */ case    4:  		/* lwz R9, <#[R7 + 16]> */
		/* 82103690h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000010) );
		/* 82103690h case    4:*/		return 0x82103694;
		  /* 82103694h */ case    5:  		/* li R11, 0 */
		/* 82103694h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82103694h case    5:*/		return 0x82103698;
		  /* 82103698h */ case    6:  		/* lwzx R6, <#[R9 + R11]> */
		/* 82103698h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82103698h case    6:*/		return 0x8210369C;
		  /* 8210369Ch */ case    7:  		/* cmplw CR6, R6, R31 */
		/* 8210369Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R31);
		/* 8210369Ch case    7:*/		return 0x821036A0;
		  /* 821036A0h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 821036A0h case    8:*/		if ( regs.CR[6].eq ) { return 0x821036B4;  }
		/* 821036A0h case    8:*/		return 0x821036A4;
		  /* 821036A4h */ case    9:  		/* addi R10, R10, 1 */
		/* 821036A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821036A4h case    9:*/		return 0x821036A8;
		  /* 821036A8h */ case   10:  		/* addi R11, R11, 4 */
		/* 821036A8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821036A8h case   10:*/		return 0x821036AC;
		  /* 821036ACh */ case   11:  		/* cmplw CR6, R10, R8 */
		/* 821036ACh case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 821036ACh case   11:*/		return 0x821036B0;
		  /* 821036B0h */ case   12:  		/* bc 12, CR6_LT, -24 */
		/* 821036B0h case   12:*/		if ( regs.CR[6].lt ) { return 0x82103698;  }
		/* 821036B0h case   12:*/		return 0x821036B4;
	}
	return 0x821036B4;
} // Block from 82103680h-821036B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821036B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821036B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821036B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821036B4);
		  /* 821036B4h */ case    0:  		/* rlwinm R6, R10, 2, 0, 29 */
		/* 821036B4h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R10);
		/* 821036B4h case    0:*/		return 0x821036B8;
		  /* 821036B8h */ case    1:  		/* lwz R11, <#[R7 + 8]> */
		/* 821036B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 821036B8h case    1:*/		return 0x821036BC;
		  /* 821036BCh */ case    2:  		/* lwzx R11, <#[R6 + R11]> */
		/* 821036BCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 821036BCh case    2:*/		return 0x821036C0;
		  /* 821036C0h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821036C0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821036C0h case    3:*/		return 0x821036C4;
		  /* 821036C4h */ case    4:  		/* lwzx R11, <#[R11 + R19]> */
		/* 821036C4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R19 + 0x00000000) );
		/* 821036C4h case    4:*/		return 0x821036C8;
		  /* 821036C8h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 821036C8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821036C8h case    5:*/		return 0x821036CC;
		  /* 821036CCh */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821036CCh case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821036CCh case    6:*/		return 0x821036D0;
		  /* 821036D0h */ case    7:  		/* lwzx R10, <#[R10 + R25]> */
		/* 821036D0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 821036D0h case    7:*/		return 0x821036D4;
		  /* 821036D4h */ case    8:  		/* lwz R10, <#[R10 + 4]> */
		/* 821036D4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821036D4h case    8:*/		return 0x821036D8;
		  /* 821036D8h */ case    9:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 821036D8h case    9:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 821036D8h case    9:*/		return 0x821036DC;
		  /* 821036DCh */ case   10:  		/* bc 12, CR0_EQ, 172 */
		/* 821036DCh case   10:*/		if ( regs.CR[0].eq ) { return 0x82103788;  }
		/* 821036DCh case   10:*/		return 0x821036E0;
		  /* 821036E0h */ case   11:  		/* lwz R10, <#[R11 + 8]> */
		/* 821036E0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821036E0h case   11:*/		return 0x821036E4;
		  /* 821036E4h */ case   12:  		/* cmpwi CR6, R10, -1 */
		/* 821036E4h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821036E4h case   12:*/		return 0x821036E8;
		  /* 821036E8h */ case   13:  		/* bc 4, CR6_EQ, 160 */
		/* 821036E8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82103788;  }
		/* 821036E8h case   13:*/		return 0x821036EC;
		  /* 821036ECh */ case   14:  		/* lwz R11, <#[R11 + 72]> */
		/* 821036ECh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 821036ECh case   14:*/		return 0x821036F0;
		  /* 821036F0h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821036F0h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821036F0h case   15:*/		return 0x821036F4;
		  /* 821036F4h */ case   16:  		/* lwzx R11, <#[R11 + R5]> */
		/* 821036F4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 821036F4h case   16:*/		return 0x821036F8;
		  /* 821036F8h */ case   17:  		/* lwz R10, <#[R11]> */
		/* 821036F8h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821036F8h case   17:*/		return 0x821036FC;
		  /* 821036FCh */ case   18:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 821036FCh case   18:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 821036FCh case   18:*/		return 0x82103700;
		  /* 82103700h */ case   19:  		/* cmplw CR6, R10, R28 */
		/* 82103700h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 82103700h case   19:*/		return 0x82103704;
		  /* 82103704h */ case   20:  		/* bc 12, CR6_EQ, 12 */
		/* 82103704h case   20:*/		if ( regs.CR[6].eq ) { return 0x82103710;  }
		/* 82103704h case   20:*/		return 0x82103708;
		  /* 82103708h */ case   21:  		/* cmplw CR6, R10, R3 */
		/* 82103708h case   21:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R3);
		/* 82103708h case   21:*/		return 0x8210370C;
		  /* 8210370Ch */ case   22:  		/* bc 4, CR6_EQ, 124 */
		/* 8210370Ch case   22:*/		if ( !regs.CR[6].eq ) { return 0x82103788;  }
		/* 8210370Ch case   22:*/		return 0x82103710;
	}
	return 0x82103710;
} // Block from 821036B4h-82103710h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82103710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103710);
		  /* 82103710h */ case    0:  		/* cmplw CR6, R4, R10 */
		/* 82103710h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 82103710h case    0:*/		return 0x82103714;
		  /* 82103714h */ case    1:  		/* bc 12, CR6_EQ, 116 */
		/* 82103714h case    1:*/		if ( regs.CR[6].eq ) { return 0x82103788;  }
		/* 82103714h case    1:*/		return 0x82103718;
		  /* 82103718h */ case    2:  		/* lwz R10, <#[R11 + 12]> */
		/* 82103718h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82103718h case    2:*/		return 0x8210371C;
		  /* 8210371Ch */ case    3:  		/* li R8, 0 */
		/* 8210371Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210371Ch case    3:*/		return 0x82103720;
		  /* 82103720h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 82103720h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82103720h case    4:*/		return 0x82103724;
		  /* 82103724h */ case    5:  		/* bc 4, CR6_GT, 60 */
		/* 82103724h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82103760;  }
		/* 82103724h case    5:*/		return 0x82103728;
		  /* 82103728h */ case    6:  		/* lwz R9, <#[R11 + 16]> */
		/* 82103728h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 82103728h case    6:*/		return 0x8210372C;
		  /* 8210372Ch */ case    7:  		/* li R10, 0 */
		/* 8210372Ch case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210372Ch case    7:*/		return 0x82103730;
		  /* 82103730h */ case    8:  		/* lwz R5, <#[R7 + 8]> */
		/* 82103730h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + 0x00000008) );
		/* 82103730h case    8:*/		return 0x82103734;
		  /* 82103734h */ case    9:  		/* lwzx R5, <#[R6 + R5]> */
		/* 82103734h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R6 + regs.R5 + 0x00000000) );
		/* 82103734h case    9:*/		return 0x82103738;
		  /* 82103738h */ case   10:  		/* stwx R5, <#[R9 + R10]> */
		/* 82103738h case   10:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82103738h case   10:*/		return 0x8210373C;
		  /* 8210373Ch */ case   11:  		/* lwz R9, <#[R11 + 16]> */
		/* 8210373Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 8210373Ch case   11:*/		return 0x82103740;
		  /* 82103740h */ case   12:  		/* lwzx R5, <#[R9 + R10]> */
		/* 82103740h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82103740h case   12:*/		return 0x82103744;
		  /* 82103744h */ case   13:  		/* cmplwi CR6, R5, 0 */
		/* 82103744h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82103744h case   13:*/		return 0x82103748;
		  /* 82103748h */ case   14:  		/* bc 4, CR6_EQ, 24 */
		/* 82103748h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82103760;  }
		/* 82103748h case   14:*/		return 0x8210374C;
		  /* 8210374Ch */ case   15:  		/* lwz R5, <#[R11 + 12]> */
		/* 8210374Ch case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210374Ch case   15:*/		return 0x82103750;
		  /* 82103750h */ case   16:  		/* addi R8, R8, 1 */
		/* 82103750h case   16:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82103750h case   16:*/		return 0x82103754;
		  /* 82103754h */ case   17:  		/* addi R10, R10, 4 */
		/* 82103754h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82103754h case   17:*/		return 0x82103758;
		  /* 82103758h */ case   18:  		/* cmplw CR6, R8, R5 */
		/* 82103758h case   18:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R5);
		/* 82103758h case   18:*/		return 0x8210375C;
		  /* 8210375Ch */ case   19:  		/* bc 12, CR6_LT, -44 */
		/* 8210375Ch case   19:*/		if ( regs.CR[6].lt ) { return 0x82103730;  }
		/* 8210375Ch case   19:*/		return 0x82103760;
	}
	return 0x82103760;
} // Block from 82103710h-82103760h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82103760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103760);
		  /* 82103760h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82103760h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82103760h case    0:*/		return 0x82103764;
		  /* 82103764h */ case    1:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 82103764h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 82103764h case    1:*/		return 0x82103768;
		  /* 82103768h */ case    2:  		/* lwz R9, <#[R17 + 20]> */
		/* 82103768h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000014) );
		/* 82103768h case    2:*/		return 0x8210376C;
		  /* 8210376Ch */ case    3:  		/* lwz R8, <#[R1 + 80]> */
		/* 8210376Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8210376Ch case    3:*/		return 0x82103770;
		  /* 82103770h */ case    4:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82103770h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82103770h case    4:*/		return 0x82103774;
		  /* 82103774h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103774h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103774h case    5:*/		return 0x82103778;
		  /* 82103778h */ case    6:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82103778h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82103778h case    6:*/		return 0x8210377C;
		  /* 8210377Ch */ case    7:  		/* lwz R11, <#[R11 + 48]> */
		/* 8210377Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 8210377Ch case    7:*/		return 0x82103780;
		  /* 82103780h */ case    8:  		/* stw R11, <#[R8 + 48]> */
		/* 82103780h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000030) );
		/* 82103780h case    8:*/		return 0x82103784;
		  /* 82103784h */ case    9:  		/* b 588 */
		/* 82103784h case    9:*/		return 0x821039D0;
		/* 82103784h case    9:*/		return 0x82103788;
	}
	return 0x82103788;
} // Block from 82103760h-82103788h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82103788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103788);
		  /* 82103788h */ case    0:  		/* cmplw CR6, R21, R29 */
		/* 82103788h case    0:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R29);
		/* 82103788h case    0:*/		return 0x8210378C;
		  /* 8210378Ch */ case    1:  		/* bc 4, CR6_EQ, 580 */
		/* 8210378Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821039D0;  }
		/* 8210378Ch case    1:*/		return 0x82103790;
		  /* 82103790h */ case    2:  		/* lwz R11, <#[R16]> */
		/* 82103790h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82103790h case    2:*/		return 0x82103794;
		  /* 82103794h */ case    3:  		/* rlwinm. R20, R11, 0, 31, 31 */
		/* 82103794h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R20,regs.R11);
		/* 82103794h case    3:*/		return 0x82103798;
		  /* 82103798h */ case    4:  		/* bc 12, CR0_EQ, 40 */
		/* 82103798h case    4:*/		if ( regs.CR[0].eq ) { return 0x821037C0;  }
		/* 82103798h case    4:*/		return 0x8210379C;
		  /* 8210379Ch */ case    5:  		/* mr R5, R30 */
		/* 8210379Ch case    5:*/		regs.R5 = regs.R30;
		/* 8210379Ch case    5:*/		return 0x821037A0;
		  /* 821037A0h */ case    6:  		/* mr R4, R31 */
		/* 821037A0h case    6:*/		regs.R4 = regs.R31;
		/* 821037A0h case    6:*/		return 0x821037A4;
		  /* 821037A4h */ case    7:  		/* mr R3, R17 */
		/* 821037A4h case    7:*/		regs.R3 = regs.R17;
		/* 821037A4h case    7:*/		return 0x821037A8;
		  /* 821037A8h */ case    8:  		/* bl -21520 */
		/* 821037A8h case    8:*/		regs.LR = 0x821037AC; return 0x820FE398;
		/* 821037A8h case    8:*/		return 0x821037AC;
		  /* 821037ACh */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 821037ACh case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821037ACh case    9:*/		return 0x821037B0;
		  /* 821037B0h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 821037B0h case   10:*/		if ( regs.CR[0].eq ) { return 0x821037C0;  }
		/* 821037B0h case   10:*/		return 0x821037B4;
		  /* 821037B4h */ case   11:  		/* lwz R11, <#[R1 + 80]> */
		/* 821037B4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821037B4h case   11:*/		return 0x821037B8;
		  /* 821037B8h */ case   12:  		/* stw R30, <#[R11 + 48]> */
		/* 821037B8h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000030) );
		/* 821037B8h case   12:*/		return 0x821037BC;
		  /* 821037BCh */ case   13:  		/* b 532 */
		/* 821037BCh case   13:*/		return 0x821039D0;
		/* 821037BCh case   13:*/		return 0x821037C0;
	}
	return 0x821037C0;
} // Block from 82103788h-821037C0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821037C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821037C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821037C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821037C0);
		  /* 821037C0h */ case    0:  		/* lwz R11, <#[R14]> */
		/* 821037C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 821037C0h case    0:*/		return 0x821037C4;
		  /* 821037C4h */ case    1:  		/* rlwinm. R21, R11, 0, 31, 31 */
		/* 821037C4h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R21,regs.R11);
		/* 821037C4h case    1:*/		return 0x821037C8;
		  /* 821037C8h */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 821037C8h case    2:*/		if ( regs.CR[0].eq ) { return 0x821037F0;  }
		/* 821037C8h case    2:*/		return 0x821037CC;
		  /* 821037CCh */ case    3:  		/* mr R5, R31 */
		/* 821037CCh case    3:*/		regs.R5 = regs.R31;
		/* 821037CCh case    3:*/		return 0x821037D0;
		  /* 821037D0h */ case    4:  		/* mr R4, R30 */
		/* 821037D0h case    4:*/		regs.R4 = regs.R30;
		/* 821037D0h case    4:*/		return 0x821037D4;
		  /* 821037D4h */ case    5:  		/* mr R3, R17 */
		/* 821037D4h case    5:*/		regs.R3 = regs.R17;
		/* 821037D4h case    5:*/		return 0x821037D8;
		  /* 821037D8h */ case    6:  		/* bl -21568 */
		/* 821037D8h case    6:*/		regs.LR = 0x821037DC; return 0x820FE398;
		/* 821037D8h case    6:*/		return 0x821037DC;
		  /* 821037DCh */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 821037DCh case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821037DCh case    7:*/		return 0x821037E0;
		  /* 821037E0h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 821037E0h case    8:*/		if ( regs.CR[0].eq ) { return 0x821037F0;  }
		/* 821037E0h case    8:*/		return 0x821037E4;
		  /* 821037E4h */ case    9:  		/* lwz R11, <#[R1 + 80]> */
		/* 821037E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821037E4h case    9:*/		return 0x821037E8;
		  /* 821037E8h */ case   10:  		/* stw R31, <#[R11 + 48]> */
		/* 821037E8h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000030) );
		/* 821037E8h case   10:*/		return 0x821037EC;
		  /* 821037ECh */ case   11:  		/* b 484 */
		/* 821037ECh case   11:*/		return 0x821039D0;
		/* 821037ECh case   11:*/		return 0x821037F0;
	}
	return 0x821037F0;
} // Block from 821037C0h-821037F0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821037F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821037F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821037F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821037F0);
		  /* 821037F0h */ case    0:  		/* lwz R10, <#[R1 + 80]> */
		/* 821037F0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821037F0h case    0:*/		return 0x821037F4;
		  /* 821037F4h */ case    1:  		/* li R25, 0 */
		/* 821037F4h case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821037F4h case    1:*/		return 0x821037F8;
		  /* 821037F8h */ case    2:  		/* li R26, 0 */
		/* 821037F8h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821037F8h case    2:*/		return 0x821037FC;
		  /* 821037FCh */ case    3:  		/* li R24, 1 */
		/* 821037FCh case    3:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 821037FCh case    3:*/		return 0x82103800;
		  /* 82103800h */ case    4:  		/* li R22, 1 */
		/* 82103800h case    4:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 82103800h case    4:*/		return 0x82103804;
		  /* 82103804h */ case    5:  		/* lwz R11, <#[R10 + 20]> */
		/* 82103804h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 82103804h case    5:*/		return 0x82103808;
		  /* 82103808h */ case    6:  		/* lwz R29, <#[R10 + 24]> */
		/* 82103808h case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000018) );
		/* 82103808h case    6:*/		return 0x8210380C;
		  /* 8210380Ch */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 8210380Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210380Ch case    7:*/		return 0x82103810;
		  /* 82103810h */ case    8:  		/* bc 12, CR6_EQ, 448 */
		/* 82103810h case    8:*/		if ( regs.CR[6].eq ) { return 0x821039D0;  }
		/* 82103810h case    8:*/		return 0x82103814;
		  /* 82103814h */ case    9:  		/* lwz R27, <#[R17 + 24]> */
		/* 82103814h case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R17 + 0x00000018) );
		/* 82103814h case    9:*/		return 0x82103818;
		  /* 82103818h */ case   10:  		/* lwz R23, <#[R17 + 20]> */
		/* 82103818h case   10:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R17 + 0x00000014) );
		/* 82103818h case   10:*/		return 0x8210381C;
		  /* 8210381Ch */ case   11:  		/* lwz R16, <#[R1 + 316]> */
		/* 8210381Ch case   11:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R1 + 0x0000013C) );
		/* 8210381Ch case   11:*/		return 0x82103820;
		  /* 82103820h */ case   12:  		/* lwz R18, <#[R1 + 324]> */
		/* 82103820h case   12:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000144) );
		/* 82103820h case   12:*/		return 0x82103824;
		  /* 82103824h */ case   13:  		/* rlwinm R28, R11, 2, 0, 29 */
		/* 82103824h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R11);
		/* 82103824h case   13:*/		return 0x82103828;
		  /* 82103828h */ case   14:  		/* li R30, 0 */
		/* 82103828h case   14:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82103828h case   14:*/		return 0x8210382C;
		  /* 8210382Ch */ case   15:  		/* lwzx R10, <#[R28 + R19]> */
		/* 8210382Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + regs.R19 + 0x00000000) );
		/* 8210382Ch case   15:*/		return 0x82103830;
		  /* 82103830h */ case   16:  		/* lwz R10, <#[R10 + 72]> */
		/* 82103830h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 82103830h case   16:*/		return 0x82103834;
		  /* 82103834h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82103834h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82103834h case   17:*/		return 0x82103838;
		  /* 82103838h */ case   18:  		/* lwzx R6, <#[R10 + R27]> */
		/* 82103838h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 82103838h case   18:*/		return 0x8210383C;
		  /* 8210383Ch */ case   19:  		/* lwz R9, <#[R6 + 12]> */
		/* 8210383Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x0000000C) );
		/* 8210383Ch case   19:*/		return 0x82103840;
		  /* 82103840h */ case   20:  		/* cmplwi CR6, R9, 0 */
		/* 82103840h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82103840h case   20:*/		return 0x82103844;
		  /* 82103844h */ case   21:  		/* bc 12, CR6_EQ, 40 */
		/* 82103844h case   21:*/		if ( regs.CR[6].eq ) { return 0x8210386C;  }
		/* 82103844h case   21:*/		return 0x82103848;
		  /* 82103848h */ case   22:  		/* lwz R8, <#[R6 + 16]> */
		/* 82103848h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000010) );
		/* 82103848h case   22:*/		return 0x8210384C;
		  /* 8210384Ch */ case   23:  		/* li R10, 0 */
		/* 8210384Ch case   23:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210384Ch case   23:*/		return 0x82103850;
		  /* 82103850h */ case   24:  		/* lwzx R7, <#[R8 + R10]> */
		/* 82103850h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82103850h case   24:*/		return 0x82103854;
		  /* 82103854h */ case   25:  		/* cmplw CR6, R7, R11 */
		/* 82103854h case   25:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82103854h case   25:*/		return 0x82103858;
		  /* 82103858h */ case   26:  		/* bc 12, CR6_EQ, 20 */
		/* 82103858h case   26:*/		if ( regs.CR[6].eq ) { return 0x8210386C;  }
		/* 82103858h case   26:*/		return 0x8210385C;
		  /* 8210385Ch */ case   27:  		/* addi R30, R30, 1 */
		/* 8210385Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8210385Ch case   27:*/		return 0x82103860;
		  /* 82103860h */ case   28:  		/* addi R10, R10, 4 */
		/* 82103860h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82103860h case   28:*/		return 0x82103864;
		  /* 82103864h */ case   29:  		/* cmplw CR6, R30, R9 */
		/* 82103864h case   29:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R9);
		/* 82103864h case   29:*/		return 0x82103868;
		  /* 82103868h */ case   30:  		/* bc 12, CR6_LT, -24 */
		/* 82103868h case   30:*/		if ( regs.CR[6].lt ) { return 0x82103850;  }
		/* 82103868h case   30:*/		return 0x8210386C;
	}
	return 0x8210386C;
} // Block from 821037F0h-8210386Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 8210386Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210386C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210386C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210386C);
		  /* 8210386Ch */ case    0:  		/* cmplwi CR6, R20, 0 */
		/* 8210386Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8210386Ch case    0:*/		return 0x82103870;
		  /* 82103870h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 82103870h case    1:*/		if ( regs.CR[6].eq ) { return 0x821038C4;  }
		/* 82103870h case    1:*/		return 0x82103874;
		  /* 82103874h */ case    2:  		/* lwz R11, <#[R6 + 8]> */
		/* 82103874h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 82103874h case    2:*/		return 0x82103878;
		  /* 82103878h */ case    3:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 82103878h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 82103878h case    3:*/		return 0x8210387C;
		  /* 8210387Ch */ case    4:  		/* mr R4, R16 */
		/* 8210387Ch case    4:*/		regs.R4 = regs.R16;
		/* 8210387Ch case    4:*/		return 0x82103880;
		  /* 82103880h */ case    5:  		/* mr R3, R17 */
		/* 82103880h case    5:*/		regs.R3 = regs.R17;
		/* 82103880h case    5:*/		return 0x82103884;
		  /* 82103884h */ case    6:  		/* lwzx R31, <#[R10 + R11]> */
		/* 82103884h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82103884h case    6:*/		return 0x82103888;
		  /* 82103888h */ case    7:  		/* mr R5, R31 */
		/* 82103888h case    7:*/		regs.R5 = regs.R31;
		/* 82103888h case    7:*/		return 0x8210388C;
		  /* 8210388Ch */ case    8:  		/* bl -21748 */
		/* 8210388Ch case    8:*/		regs.LR = 0x82103890; return 0x820FE398;
		/* 8210388Ch case    8:*/		return 0x82103890;
		  /* 82103890h */ case    9:  		/* and. R11, R3, R29 */
		/* 82103890h case    9:*/		cpu::op::and<1>(regs,&regs.R11,regs.R3,regs.R29);
		/* 82103890h case    9:*/		return 0x82103894;
		  /* 82103894h */ case   10:  		/* bc 12, CR0_EQ, 8 */
		/* 82103894h case   10:*/		if ( regs.CR[0].eq ) { return 0x8210389C;  }
		/* 82103894h case   10:*/		return 0x82103898;
		  /* 82103898h */ case   11:  		/* li R25, 1 */
		/* 82103898h case   11:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 82103898h case   11:*/		return 0x8210389C;
	}
	return 0x8210389C;
} // Block from 8210386Ch-8210389Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8210389Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210389C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210389C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210389C);
		  /* 8210389Ch */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 8210389Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8210389Ch case    0:*/		return 0x821038A0;
		  /* 821038A0h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 821038A0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821038C4;  }
		/* 821038A0h case    1:*/		return 0x821038A4;
		  /* 821038A4h */ case    2:  		/* mr R5, R16 */
		/* 821038A4h case    2:*/		regs.R5 = regs.R16;
		/* 821038A4h case    2:*/		return 0x821038A8;
		  /* 821038A8h */ case    3:  		/* mr R4, R31 */
		/* 821038A8h case    3:*/		regs.R4 = regs.R31;
		/* 821038A8h case    3:*/		return 0x821038AC;
		  /* 821038ACh */ case    4:  		/* mr R3, R17 */
		/* 821038ACh case    4:*/		regs.R3 = regs.R17;
		/* 821038ACh case    4:*/		return 0x821038B0;
		  /* 821038B0h */ case    5:  		/* bl -21784 */
		/* 821038B0h case    5:*/		regs.LR = 0x821038B4; return 0x820FE398;
		/* 821038B0h case    5:*/		return 0x821038B4;
		  /* 821038B4h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 821038B4h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821038B4h case    6:*/		return 0x821038B8;
		  /* 821038B8h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 821038B8h case    7:*/		if ( regs.CR[0].eq ) { return 0x821038C4;  }
		/* 821038B8h case    7:*/		return 0x821038BC;
		  /* 821038BCh */ case    8:  		/* li R25, 1 */
		/* 821038BCh case    8:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 821038BCh case    8:*/		return 0x821038C0;
		  /* 821038C0h */ case    9:  		/* li R24, 0 */
		/* 821038C0h case    9:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821038C0h case    9:*/		return 0x821038C4;
	}
	return 0x821038C4;
} // Block from 8210389Ch-821038C4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821038C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821038C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821038C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821038C4);
		  /* 821038C4h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 821038C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 821038C4h case    0:*/		return 0x821038C8;
		  /* 821038C8h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 821038C8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210391C;  }
		/* 821038C8h case    1:*/		return 0x821038CC;
		  /* 821038CCh */ case    2:  		/* lwz R11, <#[R6 + 8]> */
		/* 821038CCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 821038CCh case    2:*/		return 0x821038D0;
		  /* 821038D0h */ case    3:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 821038D0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 821038D0h case    3:*/		return 0x821038D4;
		  /* 821038D4h */ case    4:  		/* mr R4, R18 */
		/* 821038D4h case    4:*/		regs.R4 = regs.R18;
		/* 821038D4h case    4:*/		return 0x821038D8;
		  /* 821038D8h */ case    5:  		/* mr R3, R17 */
		/* 821038D8h case    5:*/		regs.R3 = regs.R17;
		/* 821038D8h case    5:*/		return 0x821038DC;
		  /* 821038DCh */ case    6:  		/* lwzx R6, <#[R10 + R11]> */
		/* 821038DCh case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821038DCh case    6:*/		return 0x821038E0;
		  /* 821038E0h */ case    7:  		/* mr R5, R6 */
		/* 821038E0h case    7:*/		regs.R5 = regs.R6;
		/* 821038E0h case    7:*/		return 0x821038E4;
		  /* 821038E4h */ case    8:  		/* bl -21836 */
		/* 821038E4h case    8:*/		regs.LR = 0x821038E8; return 0x820FE398;
		/* 821038E4h case    8:*/		return 0x821038E8;
		  /* 821038E8h */ case    9:  		/* and. R11, R3, R29 */
		/* 821038E8h case    9:*/		cpu::op::and<1>(regs,&regs.R11,regs.R3,regs.R29);
		/* 821038E8h case    9:*/		return 0x821038EC;
		  /* 821038ECh */ case   10:  		/* bc 12, CR0_EQ, 8 */
		/* 821038ECh case   10:*/		if ( regs.CR[0].eq ) { return 0x821038F4;  }
		/* 821038ECh case   10:*/		return 0x821038F0;
		  /* 821038F0h */ case   11:  		/* li R26, 1 */
		/* 821038F0h case   11:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 821038F0h case   11:*/		return 0x821038F4;
	}
	return 0x821038F4;
} // Block from 821038C4h-821038F4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821038F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821038F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821038F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821038F4);
		  /* 821038F4h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 821038F4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 821038F4h case    0:*/		return 0x821038F8;
		  /* 821038F8h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 821038F8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210391C;  }
		/* 821038F8h case    1:*/		return 0x821038FC;
		  /* 821038FCh */ case    2:  		/* mr R5, R18 */
		/* 821038FCh case    2:*/		regs.R5 = regs.R18;
		/* 821038FCh case    2:*/		return 0x82103900;
		  /* 82103900h */ case    3:  		/* mr R4, R6 */
		/* 82103900h case    3:*/		regs.R4 = regs.R6;
		/* 82103900h case    3:*/		return 0x82103904;
		  /* 82103904h */ case    4:  		/* mr R3, R17 */
		/* 82103904h case    4:*/		regs.R3 = regs.R17;
		/* 82103904h case    4:*/		return 0x82103908;
		  /* 82103908h */ case    5:  		/* bl -21872 */
		/* 82103908h case    5:*/		regs.LR = 0x8210390C; return 0x820FE398;
		/* 82103908h case    5:*/		return 0x8210390C;
		  /* 8210390Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 8210390Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210390Ch case    6:*/		return 0x82103910;
		  /* 82103910h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 82103910h case    7:*/		if ( regs.CR[0].eq ) { return 0x8210391C;  }
		/* 82103910h case    7:*/		return 0x82103914;
		  /* 82103914h */ case    8:  		/* li R26, 1 */
		/* 82103914h case    8:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82103914h case    8:*/		return 0x82103918;
		  /* 82103918h */ case    9:  		/* li R22, 0 */
		/* 82103918h case    9:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82103918h case    9:*/		return 0x8210391C;
	}
	return 0x8210391C;
} // Block from 821038F4h-8210391Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210391Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210391C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210391C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210391C);
		  /* 8210391Ch */ case    0:  		/* lwzx R10, <#[R23 + R28]> */
		/* 8210391Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + regs.R28 + 0x00000000) );
		/* 8210391Ch case    0:*/		return 0x82103920;
		  /* 82103920h */ case    1:  		/* lwz R11, <#[R10 + 20]> */
		/* 82103920h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 82103920h case    1:*/		return 0x82103924;
		  /* 82103924h */ case    2:  		/* lwz R29, <#[R10 + 24]> */
		/* 82103924h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000018) );
		/* 82103924h case    2:*/		return 0x82103928;
		  /* 82103928h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82103928h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82103928h case    3:*/		return 0x8210392C;
		  /* 8210392Ch */ case    4:  		/* bc 4, CR6_EQ, -264 */
		/* 8210392Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82103824;  }
		/* 8210392Ch case    4:*/		return 0x82103930;
		  /* 82103930h */ case    5:  		/* cmpwi CR6, R25, 0 */
		/* 82103930h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82103930h case    5:*/		return 0x82103934;
		  /* 82103934h */ case    6:  		/* bc 12, CR6_EQ, 76 */
		/* 82103934h case    6:*/		if ( regs.CR[6].eq ) { return 0x82103980;  }
		/* 82103934h case    6:*/		return 0x82103938;
		  /* 82103938h */ case    7:  		/* cmpwi CR6, R26, 0 */
		/* 82103938h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82103938h case    7:*/		return 0x8210393C;
		  /* 8210393Ch */ case    8:  		/* bc 12, CR6_EQ, 60 */
		/* 8210393Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82103978;  }
		/* 8210393Ch case    8:*/		return 0x82103940;
		  /* 82103940h */ case    9:  		/* cmpwi CR6, R24, 0 */
		/* 82103940h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82103940h case    9:*/		return 0x82103944;
		  /* 82103944h */ case   10:  		/* bc 12, CR6_EQ, 76 */
		/* 82103944h case   10:*/		if ( regs.CR[6].eq ) { return 0x82103990;  }
		/* 82103944h case   10:*/		return 0x82103948;
		  /* 82103948h */ case   11:  		/* cmpwi CR6, R22, 0 */
		/* 82103948h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 82103948h case   11:*/		return 0x8210394C;
		  /* 8210394Ch */ case   12:  		/* bc 12, CR6_EQ, 44 */
		/* 8210394Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x82103978;  }
		/* 8210394Ch case   12:*/		return 0x82103950;
		  /* 82103950h */ case   13:  		/* lis R11, -32256 */
		/* 82103950h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82103950h case   13:*/		return 0x82103954;
		  /* 82103954h */ case   14:  		/* lfd FR1, <#[R11 + 1848]> */
		/* 82103954h case   14:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000738) );
		/* 82103954h case   14:*/		return 0x82103958;
		  /* 82103958h */ case   15:  		/* mr R3, R17 */
		/* 82103958h case   15:*/		regs.R3 = regs.R17;
		/* 82103958h case   15:*/		return 0x8210395C;
		  /* 8210395Ch */ case   16:  		/* lwz R4, <#[R17 + 120]> */
		/* 8210395Ch case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x00000078) );
		/* 8210395Ch case   16:*/		return 0x82103960;
		  /* 82103960h */ case   17:  		/* li R5, 0 */
		/* 82103960h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82103960h case   17:*/		return 0x82103964;
		  /* 82103964h */ case   18:  		/* li R6, 0 */
		/* 82103964h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82103964h case   18:*/		return 0x82103968;
		  /* 82103968h */ case   19:  		/* bl -26432 */
		/* 82103968h case   19:*/		regs.LR = 0x8210396C; return 0x820FD228;
		/* 82103968h case   19:*/		return 0x8210396C;
		  /* 8210396Ch */ case   20:  		/* lwz R11, <#[R1 + 80]> */
		/* 8210396Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8210396Ch case   20:*/		return 0x82103970;
		  /* 82103970h */ case   21:  		/* stw R3, <#[R11 + 48]> */
		/* 82103970h case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000030) );
		/* 82103970h case   21:*/		return 0x82103974;
		  /* 82103974h */ case   22:  		/* b 92 */
		/* 82103974h case   22:*/		return 0x821039D0;
		/* 82103974h case   22:*/		return 0x82103978;
	}
	return 0x82103978;
} // Block from 8210391Ch-82103978h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82103978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103978);
		  /* 82103978h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 82103978h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82103978h case    0:*/		return 0x8210397C;
		  /* 8210397Ch */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 8210397Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82103990;  }
		/* 8210397Ch case    1:*/		return 0x82103980;
	}
	return 0x82103980;
} // Block from 82103978h-82103980h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82103980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103980);
		  /* 82103980h */ case    0:  		/* cmpwi CR6, R26, 0 */
		/* 82103980h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82103980h case    0:*/		return 0x82103984;
		  /* 82103984h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 82103984h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210399C;  }
		/* 82103984h case    1:*/		return 0x82103988;
		  /* 82103988h */ case    2:  		/* cmpwi CR6, R22, 0 */
		/* 82103988h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 82103988h case    2:*/		return 0x8210398C;
		  /* 8210398Ch */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 8210398Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8210399C;  }
		/* 8210398Ch case    3:*/		return 0x82103990;
	}
	return 0x82103990;
} // Block from 82103980h-82103990h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82103990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103990);
		  /* 82103990h */ case    0:  		/* lis R11, -32256 */
		/* 82103990h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82103990h case    0:*/		return 0x82103994;
		  /* 82103994h */ case    1:  		/* lfd FR1, <#[R11 + 1808]> */
		/* 82103994h case    1:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000710) );
		/* 82103994h case    1:*/		return 0x82103998;
		  /* 82103998h */ case    2:  		/* b -64 */
		/* 82103998h case    2:*/		return 0x82103958;
		/* 82103998h case    2:*/		return 0x8210399C;
	}
	return 0x8210399C;
} // Block from 82103990h-8210399Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210399Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210399C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210399C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210399C);
		  /* 8210399Ch */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 8210399Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8210399Ch case    0:*/		return 0x821039A0;
		  /* 821039A0h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821039A0h case    1:*/		if ( regs.CR[6].eq ) { return 0x821039B8;  }
		/* 821039A0h case    1:*/		return 0x821039A4;
		  /* 821039A4h */ case    2:  		/* cmpwi CR6, R24, 0 */
		/* 821039A4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 821039A4h case    2:*/		return 0x821039A8;
		  /* 821039A8h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821039A8h case    3:*/		if ( regs.CR[6].eq ) { return 0x821039B8;  }
		/* 821039A8h case    3:*/		return 0x821039AC;
		  /* 821039ACh */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 821039ACh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821039ACh case    4:*/		return 0x821039B0;
		  /* 821039B0h */ case    5:  		/* stw R18, <#[R11 + 48]> */
		/* 821039B0h case    5:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000030) );
		/* 821039B0h case    5:*/		return 0x821039B4;
		  /* 821039B4h */ case    6:  		/* b 28 */
		/* 821039B4h case    6:*/		return 0x821039D0;
		/* 821039B4h case    6:*/		return 0x821039B8;
	}
	return 0x821039B8;
} // Block from 8210399Ch-821039B8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821039B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821039B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821039B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821039B8);
		  /* 821039B8h */ case    0:  		/* cmpwi CR6, R26, 0 */
		/* 821039B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 821039B8h case    0:*/		return 0x821039BC;
		  /* 821039BCh */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 821039BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821039D0;  }
		/* 821039BCh case    1:*/		return 0x821039C0;
		  /* 821039C0h */ case    2:  		/* cmpwi CR6, R22, 0 */
		/* 821039C0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 821039C0h case    2:*/		return 0x821039C4;
		  /* 821039C4h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 821039C4h case    3:*/		if ( regs.CR[6].eq ) { return 0x821039D0;  }
		/* 821039C4h case    3:*/		return 0x821039C8;
		  /* 821039C8h */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 821039C8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821039C8h case    4:*/		return 0x821039CC;
		  /* 821039CCh */ case    5:  		/* stw R16, <#[R11 + 48]> */
		/* 821039CCh case    5:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R11 + 0x00000030) );
		/* 821039CCh case    5:*/		return 0x821039D0;
	}
	return 0x821039D0;
} // Block from 821039B8h-821039D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821039D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821039D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821039D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821039D0);
		  /* 821039D0h */ case    0:  		/* li R3, 0 */
		/* 821039D0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821039D0h case    0:*/		return 0x821039D4;
	}
	return 0x821039D4;
} // Block from 821039D0h-821039D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821039D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821039D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821039D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821039D4);
		  /* 821039D4h */ case    0:  		/* addi R1, R1, 272 */
		/* 821039D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 821039D4h case    0:*/		return 0x821039D8;
		  /* 821039D8h */ case    1:  		/* b -468840 */
		/* 821039D8h case    1:*/		return 0x82091270;
		/* 821039D8h case    1:*/		return 0x821039DC;
		  /* 821039DCh */ case    2:  		/* nop */
		/* 821039DCh case    2:*/		cpu::op::nop();
		/* 821039DCh case    2:*/		return 0x821039E0;
	}
	return 0x821039E0;
} // Block from 821039D4h-821039E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821039E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821039E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821039E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821039E0);
		  /* 821039E0h */ case    0:  		/* mfspr R12, LR */
		/* 821039E0h case    0:*/		regs.R12 = regs.LR;
		/* 821039E0h case    0:*/		return 0x821039E4;
		  /* 821039E4h */ case    1:  		/* bl -468924 */
		/* 821039E4h case    1:*/		regs.LR = 0x821039E8; return 0x82091228;
		/* 821039E4h case    1:*/		return 0x821039E8;
		  /* 821039E8h */ case    2:  		/* stwu R1, <#[R1 - 336]> */
		/* 821039E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEB0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEB0);
		/* 821039E8h case    2:*/		return 0x821039EC;
		  /* 821039ECh */ case    3:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 821039ECh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 821039ECh case    3:*/		return 0x821039F0;
		  /* 821039F0h */ case    4:  		/* lwz R7, <#[R3 + 20]> */
		/* 821039F0h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000014) );
		/* 821039F0h case    4:*/		return 0x821039F4;
		  /* 821039F4h */ case    5:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 821039F4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 821039F4h case    5:*/		return 0x821039F8;
		  /* 821039F8h */ case    6:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 821039F8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 821039F8h case    6:*/		return 0x821039FC;
		  /* 821039FCh */ case    7:  		/* lwz R6, <#[R3 + 16]> */
		/* 821039FCh case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000010) );
		/* 821039FCh case    7:*/		return 0x82103A00;
		  /* 82103A00h */ case    8:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82103A00h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82103A00h case    8:*/		return 0x82103A04;
		  /* 82103A04h */ case    9:  		/* mr R24, R3 */
		/* 82103A04h case    9:*/		regs.R24 = regs.R3;
		/* 82103A04h case    9:*/		return 0x82103A08;
		  /* 82103A08h */ case   10:  		/* mr R17, R4 */
		/* 82103A08h case   10:*/		regs.R17 = regs.R4;
		/* 82103A08h case   10:*/		return 0x82103A0C;
		  /* 82103A0Ch */ case   11:  		/* lwzx R3, <#[R11 + R7]> */
		/* 82103A0Ch case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82103A0Ch case   11:*/		return 0x82103A10;
		  /* 82103A10h */ case   12:  		/* mr R18, R5 */
		/* 82103A10h case   12:*/		regs.R18 = regs.R5;
		/* 82103A10h case   12:*/		return 0x82103A14;
		  /* 82103A14h */ case   13:  		/* lwzx R11, <#[R10 + R7]> */
		/* 82103A14h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82103A14h case   13:*/		return 0x82103A18;
		  /* 82103A18h */ case   14:  		/* lwzx R10, <#[R9 + R7]> */
		/* 82103A18h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82103A18h case   14:*/		return 0x82103A1C;
		  /* 82103A1Ch */ case   15:  		/* lwzx R9, <#[R8 + R7]> */
		/* 82103A1Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 82103A1Ch case   15:*/		return 0x82103A20;
		  /* 82103A20h */ case   16:  		/* lwz R8, <#[R3 + 4]> */
		/* 82103A20h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000004) );
		/* 82103A20h case   16:*/		return 0x82103A24;
		  /* 82103A24h */ case   17:  		/* lwz R23, <#[R11 + 48]> */
		/* 82103A24h case   17:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x00000030) );
		/* 82103A24h case   17:*/		return 0x82103A28;
		  /* 82103A28h */ case   18:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 82103A28h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 82103A28h case   18:*/		return 0x82103A2C;
		  /* 82103A2Ch */ case   19:  		/* lwz R20, <#[R10 + 48]> */
		/* 82103A2Ch case   19:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R10 + 0x00000030) );
		/* 82103A2Ch case   19:*/		return 0x82103A30;
		  /* 82103A30h */ case   20:  		/* lwz R19, <#[R9 + 48]> */
		/* 82103A30h case   20:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R9 + 0x00000030) );
		/* 82103A30h case   20:*/		return 0x82103A34;
		  /* 82103A34h */ case   21:  		/* rlwinm R9, R23, 2, 0, 29 */
		/* 82103A34h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R23);
		/* 82103A34h case   21:*/		return 0x82103A38;
		  /* 82103A38h */ case   22:  		/* rlwinm R5, R20, 2, 0, 29 */
		/* 82103A38h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R20);
		/* 82103A38h case   22:*/		return 0x82103A3C;
		  /* 82103A3Ch */ case   23:  		/* lwz R10, <#[R3]> */
		/* 82103A3Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82103A3Ch case   23:*/		return 0x82103A40;
		  /* 82103A40h */ case   24:  		/* rlwinm R4, R19, 2, 0, 29 */
		/* 82103A40h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R19);
		/* 82103A40h case   24:*/		return 0x82103A44;
		  /* 82103A44h */ case   25:  		/* rlwinm R8, R10, 0, 25, 25 */
		/* 82103A44h case   25:*/		cpu::op::rlwinm<0,0,25,25>(regs,&regs.R8,regs.R10);
		/* 82103A44h case   25:*/		return 0x82103A48;
		  /* 82103A48h */ case   26:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82103A48h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82103A48h case   26:*/		return 0x82103A4C;
		  /* 82103A4Ch */ case   27:  		/* lwzx R26, <#[R9 + R7]> */
		/* 82103A4Ch case   27:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82103A4Ch case   27:*/		return 0x82103A50;
		  /* 82103A50h */ case   28:  		/* lwzx R27, <#[R5 + R7]> */
		/* 82103A50h case   28:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R5 + regs.R7 + 0x00000000) );
		/* 82103A50h case   28:*/		return 0x82103A54;
		  /* 82103A54h */ case   29:  		/* lwzx R30, <#[R4 + R7]> */
		/* 82103A54h case   29:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + regs.R7 + 0x00000000) );
		/* 82103A54h case   29:*/		return 0x82103A58;
		  /* 82103A58h */ case   30:  		/* lwz R11, <#[R11 + 4]> */
		/* 82103A58h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82103A58h case   30:*/		return 0x82103A5C;
		  /* 82103A5Ch */ case   31:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82103A5Ch case   31:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82103A5Ch case   31:*/		return 0x82103A60;
		  /* 82103A60h */ case   32:  		/* bc 12, CR0_EQ, 344 */
		/* 82103A60h case   32:*/		if ( regs.CR[0].eq ) { return 0x82103BB8;  }
		/* 82103A60h case   32:*/		return 0x82103A64;
		  /* 82103A64h */ case   33:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 82103A64h case   33:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82103A64h case   33:*/		return 0x82103A68;
		  /* 82103A68h */ case   34:  		/* bc 4, CR0_EQ, 336 */
		/* 82103A68h case   34:*/		if ( !regs.CR[0].eq ) { return 0x82103BB8;  }
		/* 82103A68h case   34:*/		return 0x82103A6C;
		  /* 82103A6Ch */ case   35:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 82103A6Ch case   35:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 82103A6Ch case   35:*/		return 0x82103A70;
		  /* 82103A70h */ case   36:  		/* lis R9, 12288 */
		/* 82103A70h case   36:*/		cpu::op::lis<0>(regs,&regs.R9,0x3000);
		/* 82103A70h case   36:*/		return 0x82103A74;
		  /* 82103A74h */ case   37:  		/* bc 4, CR0_EQ, 108 */
		/* 82103A74h case   37:*/		if ( !regs.CR[0].eq ) { return 0x82103AE0;  }
		/* 82103A74h case   37:*/		return 0x82103A78;
		  /* 82103A78h */ case   38:  		/* lwz R11, <#[R17]> */
		/* 82103A78h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82103A78h case   38:*/		return 0x82103A7C;
		  /* 82103A7Ch */ case   39:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82103A7Ch case   39:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82103A7Ch case   39:*/		return 0x82103A80;
		  /* 82103A80h */ case   40:  		/* cmplw CR6, R11, R9 */
		/* 82103A80h case   40:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82103A80h case   40:*/		return 0x82103A84;
		  /* 82103A84h */ case   41:  		/* bc 4, CR6_EQ, 92 */
		/* 82103A84h case   41:*/		if ( !regs.CR[6].eq ) { return 0x82103AE0;  }
		/* 82103A84h case   41:*/		return 0x82103A88;
		  /* 82103A88h */ case   42:  		/* lwz R7, <#[R27]> */
		/* 82103A88h case   42:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R27 + 0x00000000) );
		/* 82103A88h case   42:*/		return 0x82103A8C;
		  /* 82103A8Ch */ case   43:  		/* lwz R11, <#[R30]> */
		/* 82103A8Ch case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82103A8Ch case   43:*/		return 0x82103A90;
		  /* 82103A90h */ case   44:  		/* or R11, R11, R7 */
		/* 82103A90h case   44:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82103A90h case   44:*/		return 0x82103A94;
		  /* 82103A94h */ case   45:  		/* rlwinm. R7, R11, 0, 4, 4 */
		/* 82103A94h case   45:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R7,regs.R11);
		/* 82103A94h case   45:*/		return 0x82103A98;
		  /* 82103A98h */ case   46:  		/* bc 12, CR0_EQ, 12 */
		/* 82103A98h case   46:*/		if ( regs.CR[0].eq ) { return 0x82103AA4;  }
		/* 82103A98h case   46:*/		return 0x82103A9C;
		  /* 82103A9Ch */ case   47:  		/* oris R11, R10, 2048 */
		/* 82103A9Ch case   47:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R10,0x800);
		/* 82103A9Ch case   47:*/		return 0x82103AA0;
		  /* 82103AA0h */ case   48:  		/* b 32 */
		/* 82103AA0h case   48:*/		return 0x82103AC0;
		/* 82103AA0h case   48:*/		return 0x82103AA4;
	}
	return 0x82103AA4;
} // Block from 821039E0h-82103AA4h (49 instructions)

//////////////////////////////////////////////////////
// Block at 82103AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103AA4);
		  /* 82103AA4h */ case    0:  		/* rlwinm. R7, R11, 0, 5, 5 */
		/* 82103AA4h case    0:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R7,regs.R11);
		/* 82103AA4h case    0:*/		return 0x82103AA8;
		  /* 82103AA8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82103AA8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82103AB4;  }
		/* 82103AA8h case    1:*/		return 0x82103AAC;
		  /* 82103AACh */ case    2:  		/* oris R11, R10, 1024 */
		/* 82103AACh case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R10,0x400);
		/* 82103AACh case    2:*/		return 0x82103AB0;
		  /* 82103AB0h */ case    3:  		/* b 16 */
		/* 82103AB0h case    3:*/		return 0x82103AC0;
		/* 82103AB0h case    3:*/		return 0x82103AB4;
	}
	return 0x82103AB4;
} // Block from 82103AA4h-82103AB4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82103AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103AB4);
		  /* 82103AB4h */ case    0:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 82103AB4h case    0:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 82103AB4h case    0:*/		return 0x82103AB8;
		  /* 82103AB8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82103AB8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82103AC4;  }
		/* 82103AB8h case    1:*/		return 0x82103ABC;
		  /* 82103ABCh */ case    2:  		/* oris R11, R10, 512 */
		/* 82103ABCh case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R10,0x200);
		/* 82103ABCh case    2:*/		return 0x82103AC0;
	}
	return 0x82103AC0;
} // Block from 82103AB4h-82103AC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82103AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103AC0);
		  /* 82103AC0h */ case    0:  		/* stw R11, <#[R3]> */
		/* 82103AC0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82103AC0h case    0:*/		return 0x82103AC4;
	}
	return 0x82103AC4;
} // Block from 82103AC0h-82103AC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82103AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103AC4);
		  /* 82103AC4h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82103AC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82103AC4h case    0:*/		return 0x82103AC8;
		  /* 82103AC8h */ case    1:  		/* lwz R10, <#[R27]> */
		/* 82103AC8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 82103AC8h case    1:*/		return 0x82103ACC;
		  /* 82103ACCh */ case    2:  		/* lwz R7, <#[R3]> */
		/* 82103ACCh case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000000) );
		/* 82103ACCh case    2:*/		return 0x82103AD0;
		  /* 82103AD0h */ case    3:  		/* and R11, R11, R10 */
		/* 82103AD0h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82103AD0h case    3:*/		return 0x82103AD4;
		  /* 82103AD4h */ case    4:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82103AD4h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82103AD4h case    4:*/		return 0x82103AD8;
		  /* 82103AD8h */ case    5:  		/* or R11, R11, R7 */
		/* 82103AD8h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82103AD8h case    5:*/		return 0x82103ADC;
		  /* 82103ADCh */ case    6:  		/* stw R11, <#[R3]> */
		/* 82103ADCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82103ADCh case    6:*/		return 0x82103AE0;
	}
	return 0x82103AE0;
} // Block from 82103AC4h-82103AE0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82103AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103AE0);
		  /* 82103AE0h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82103AE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82103AE0h case    0:*/		return 0x82103AE4;
		  /* 82103AE4h */ case    1:  		/* lwz R10, <#[R27]> */
		/* 82103AE4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 82103AE4h case    1:*/		return 0x82103AE8;
		  /* 82103AE8h */ case    2:  		/* or R11, R11, R10 */
		/* 82103AE8h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82103AE8h case    2:*/		return 0x82103AEC;
		  /* 82103AECh */ case    3:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82103AECh case    3:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82103AECh case    3:*/		return 0x82103AF0;
		  /* 82103AF0h */ case    4:  		/* bc 12, CR0_EQ, 36 */
		/* 82103AF0h case    4:*/		if ( regs.CR[0].eq ) { return 0x82103B14;  }
		/* 82103AF0h case    4:*/		return 0x82103AF4;
		  /* 82103AF4h */ case    5:  		/* lwz R11, <#[R17]> */
		/* 82103AF4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82103AF4h case    5:*/		return 0x82103AF8;
		  /* 82103AF8h */ case    6:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82103AF8h case    6:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82103AF8h case    6:*/		return 0x82103AFC;
		  /* 82103AFCh */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 82103AFCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82103AFCh case    7:*/		return 0x82103B00;
		  /* 82103B00h */ case    8:  		/* bc 4, CR6_EQ, 20 */
		/* 82103B00h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82103B14;  }
		/* 82103B00h case    8:*/		return 0x82103B04;
		  /* 82103B04h */ case    9:  		/* lwz R11, <#[R3]> */
		/* 82103B04h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82103B04h case    9:*/		return 0x82103B08;
		  /* 82103B08h */ case   10:  		/* li R8, 64 */
		/* 82103B08h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x40);
		/* 82103B08h case   10:*/		return 0x82103B0C;
		  /* 82103B0Ch */ case   11:  		/* ori R11, R11, 64 */
		/* 82103B0Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82103B0Ch case   11:*/		return 0x82103B10;
		  /* 82103B10h */ case   12:  		/* stw R11, <#[R3]> */
		/* 82103B10h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82103B10h case   12:*/		return 0x82103B14;
	}
	return 0x82103B14;
} // Block from 82103AE0h-82103B14h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82103B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103B14);
		  /* 82103B14h */ case    0:  		/* lwz R11, <#[R17]> */
		/* 82103B14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82103B14h case    0:*/		return 0x82103B18;
		  /* 82103B18h */ case    1:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82103B18h case    1:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82103B18h case    1:*/		return 0x82103B1C;
		  /* 82103B1Ch */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 82103B1Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82103B1Ch case    2:*/		return 0x82103B20;
		  /* 82103B20h */ case    3:  		/* bc 4, CR6_EQ, 112 */
		/* 82103B20h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82103B90;  }
		/* 82103B20h case    3:*/		return 0x82103B24;
		  /* 82103B24h */ case    4:  		/* lwz R11, <#[R26]> */
		/* 82103B24h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82103B24h case    4:*/		return 0x82103B28;
		  /* 82103B28h */ case    5:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82103B28h case    5:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82103B28h case    5:*/		return 0x82103B2C;
		  /* 82103B2Ch */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 82103B2Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x82103B34;  }
		/* 82103B2Ch case    6:*/		return 0x82103B30;
		  /* 82103B30h */ case    7:  		/* li R8, 64 */
		/* 82103B30h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x40);
		/* 82103B30h case    7:*/		return 0x82103B34;
	}
	return 0x82103B34;
} // Block from 82103B14h-82103B34h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82103B34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103B34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103B34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103B34);
		  /* 82103B34h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82103B34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82103B34h case    0:*/		return 0x82103B38;
		  /* 82103B38h */ case    1:  		/* cmplw CR6, R23, R20 */
		/* 82103B38h case    1:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R20);
		/* 82103B38h case    1:*/		return 0x82103B3C;
		  /* 82103B3Ch */ case    2:  		/* lwz R10, <#[R27]> */
		/* 82103B3Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 82103B3Ch case    2:*/		return 0x82103B40;
		  /* 82103B40h */ case    3:  		/* lwz R7, <#[R3]> */
		/* 82103B40h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000000) );
		/* 82103B40h case    3:*/		return 0x82103B44;
		  /* 82103B44h */ case    4:  		/* and R11, R11, R10 */
		/* 82103B44h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82103B44h case    4:*/		return 0x82103B48;
		  /* 82103B48h */ case    5:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82103B48h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82103B48h case    5:*/		return 0x82103B4C;
		  /* 82103B4Ch */ case    6:  		/* or R11, R11, R7 */
		/* 82103B4Ch case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82103B4Ch case    6:*/		return 0x82103B50;
		  /* 82103B50h */ case    7:  		/* stw R11, <#[R3]> */
		/* 82103B50h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82103B50h case    7:*/		return 0x82103B54;
		  /* 82103B54h */ case    8:  		/* bc 4, CR6_EQ, 28 */
		/* 82103B54h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82103B70;  }
		/* 82103B54h case    8:*/		return 0x82103B58;
		  /* 82103B58h */ case    9:  		/* lwz R11, <#[R30]> */
		/* 82103B58h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82103B58h case    9:*/		return 0x82103B5C;
		  /* 82103B5Ch */ case   10:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 82103B5Ch case   10:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 82103B5Ch case   10:*/		return 0x82103B60;
		  /* 82103B60h */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 82103B60h case   11:*/		if ( regs.CR[0].eq ) { return 0x82103B70;  }
		/* 82103B60h case   11:*/		return 0x82103B64;
		  /* 82103B64h */ case   12:  		/* lwz R11, <#[R3]> */
		/* 82103B64h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82103B64h case   12:*/		return 0x82103B68;
		  /* 82103B68h */ case   13:  		/* ori R11, R11, 4 */
		/* 82103B68h case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82103B68h case   13:*/		return 0x82103B6C;
		  /* 82103B6Ch */ case   14:  		/* stw R11, <#[R3]> */
		/* 82103B6Ch case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82103B6Ch case   14:*/		return 0x82103B70;
	}
	return 0x82103B70;
} // Block from 82103B34h-82103B70h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82103B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103B70);
		  /* 82103B70h */ case    0:  		/* cmplw CR6, R23, R19 */
		/* 82103B70h case    0:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R19);
		/* 82103B70h case    0:*/		return 0x82103B74;
		  /* 82103B74h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82103B74h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82103B90;  }
		/* 82103B74h case    1:*/		return 0x82103B78;
		  /* 82103B78h */ case    2:  		/* lwz R11, <#[R27]> */
		/* 82103B78h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82103B78h case    2:*/		return 0x82103B7C;
		  /* 82103B7Ch */ case    3:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 82103B7Ch case    3:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 82103B7Ch case    3:*/		return 0x82103B80;
		  /* 82103B80h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82103B80h case    4:*/		if ( regs.CR[0].eq ) { return 0x82103B90;  }
		/* 82103B80h case    4:*/		return 0x82103B84;
		  /* 82103B84h */ case    5:  		/* lwz R11, <#[R3]> */
		/* 82103B84h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82103B84h case    5:*/		return 0x82103B88;
		  /* 82103B88h */ case    6:  		/* ori R11, R11, 8 */
		/* 82103B88h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82103B88h case    6:*/		return 0x82103B8C;
		  /* 82103B8Ch */ case    7:  		/* stw R11, <#[R3]> */
		/* 82103B8Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82103B8Ch case    7:*/		return 0x82103B90;
	}
	return 0x82103B90;
} // Block from 82103B70h-82103B90h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82103B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103B90);
		  /* 82103B90h */ case    0:  		/* lwz R11, <#[R17]> */
		/* 82103B90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 82103B90h case    0:*/		return 0x82103B94;
		  /* 82103B94h */ case    1:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82103B94h case    1:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82103B94h case    1:*/		return 0x82103B98;
		  /* 82103B98h */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 82103B98h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82103B98h case    2:*/		return 0x82103B9C;
		  /* 82103B9Ch */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 82103B9Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82103BB8;  }
		/* 82103B9Ch case    3:*/		return 0x82103BA0;
		  /* 82103BA0h */ case    4:  		/* cmplwi CR6, R8, 0 */
		/* 82103BA0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82103BA0h case    4:*/		return 0x82103BA4;
		  /* 82103BA4h */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 82103BA4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82103BC4;  }
		/* 82103BA4h case    5:*/		return 0x82103BA8;
		  /* 82103BA8h */ case    6:  		/* lwz R11, <#[R26]> */
		/* 82103BA8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82103BA8h case    6:*/		return 0x82103BAC;
		  /* 82103BACh */ case    7:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 82103BACh case    7:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 82103BACh case    7:*/		return 0x82103BB0;
		  /* 82103BB0h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 82103BB0h case    8:*/		if ( regs.CR[0].eq ) { return 0x82103BC4;  }
		/* 82103BB0h case    8:*/		return 0x82103BB4;
		  /* 82103BB4h */ case    9:  		/* stw R20, <#[R3 + 48]> */
		/* 82103BB4h case    9:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000030) );
		/* 82103BB4h case    9:*/		return 0x82103BB8;
	}
	return 0x82103BB8;
} // Block from 82103B90h-82103BB8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82103BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103BB8);
		  /* 82103BB8h */ case    0:  		/* li R3, 0 */
		/* 82103BB8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82103BB8h case    0:*/		return 0x82103BBC;
		  /* 82103BBCh */ case    1:  		/* addi R1, R1, 336 */
		/* 82103BBCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x150);
		/* 82103BBCh case    1:*/		return 0x82103BC0;
		  /* 82103BC0h */ case    2:  		/* b -469320 */
		/* 82103BC0h case    2:*/		return 0x82091278;
		/* 82103BC0h case    2:*/		return 0x82103BC4;
	}
	return 0x82103BC4;
} // Block from 82103BB8h-82103BC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82103BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103BC4);
		  /* 82103BC4h */ case    0:  		/* lwz R11, <#[R26 + 4]> */
		/* 82103BC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82103BC4h case    0:*/		return 0x82103BC8;
		  /* 82103BC8h */ case    1:  		/* lwz R22, <#[R24 + 16]> */
		/* 82103BC8h case    1:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R24 + 0x00000010) );
		/* 82103BC8h case    1:*/		return 0x82103BCC;
		  /* 82103BCCh */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103BCCh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103BCCh case    2:*/		return 0x82103BD0;
		  /* 82103BD0h */ case    3:  		/* lwzx R11, <#[R11 + R22]> */
		/* 82103BD0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 82103BD0h case    3:*/		return 0x82103BD4;
		  /* 82103BD4h */ case    4:  		/* lwz R28, <#[R11 + 4]> */
		/* 82103BD4h case    4:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 82103BD4h case    4:*/		return 0x82103BD8;
		  /* 82103BD8h */ case    5:  		/* rlwinm. R11, R28, 0, 23, 23 */
		/* 82103BD8h case    5:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R28);
		/* 82103BD8h case    5:*/		return 0x82103BDC;
		  /* 82103BDCh */ case    6:  		/* bc 12, CR0_EQ, 52 */
		/* 82103BDCh case    6:*/		if ( regs.CR[0].eq ) { return 0x82103C10;  }
		/* 82103BDCh case    6:*/		return 0x82103BE0;
		  /* 82103BE0h */ case    7:  		/* lwz R11, <#[R26 + 8]> */
		/* 82103BE0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82103BE0h case    7:*/		return 0x82103BE4;
		  /* 82103BE4h */ case    8:  		/* cmpwi CR6, R11, -1 */
		/* 82103BE4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82103BE4h case    8:*/		return 0x82103BE8;
		  /* 82103BE8h */ case    9:  		/* bc 4, CR6_EQ, 40 */
		/* 82103BE8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82103C10;  }
		/* 82103BE8h case    9:*/		return 0x82103BEC;
		  /* 82103BECh */ case   10:  		/* lis R11, -32256 */
		/* 82103BECh case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82103BECh case   10:*/		return 0x82103BF0;
		  /* 82103BF0h */ case   11:  		/* lfd FR13, <#[R26 + 32]> */
		/* 82103BF0h case   11:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R26 + 0x00000020) );
		/* 82103BF0h case   11:*/		return 0x82103BF4;
		  /* 82103BF4h */ case   12:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82103BF4h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82103BF4h case   12:*/		return 0x82103BF8;
		  /* 82103BF8h */ case   13:  		/* mr R11, R20 */
		/* 82103BF8h case   13:*/		regs.R11 = regs.R20;
		/* 82103BF8h case   13:*/		return 0x82103BFC;
		  /* 82103BFCh */ case   14:  		/* fcmpu CR6, FR13, FR0 */
		/* 82103BFCh case   14:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82103BFCh case   14:*/		return 0x82103C00;
		  /* 82103C00h */ case   15:  		/* bc 4, CR6_LT, 8 */
		/* 82103C00h case   15:*/		if ( !regs.CR[6].lt ) { return 0x82103C08;  }
		/* 82103C00h case   15:*/		return 0x82103C04;
		  /* 82103C04h */ case   16:  		/* mr R11, R19 */
		/* 82103C04h case   16:*/		regs.R11 = regs.R19;
		/* 82103C04h case   16:*/		return 0x82103C08;
	}
	return 0x82103C08;
} // Block from 82103BC4h-82103C08h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82103C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103C08);
		  /* 82103C08h */ case    0:  		/* stw R11, <#[R3 + 48]> */
		/* 82103C08h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 82103C08h case    0:*/		return 0x82103C0C;
		  /* 82103C0Ch */ case    1:  		/* b -84 */
		/* 82103C0Ch case    1:*/		return 0x82103BB8;
		/* 82103C0Ch case    1:*/		return 0x82103C10;
	}
	return 0x82103C10;
} // Block from 82103C08h-82103C10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82103C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103C10);
		  /* 82103C10h */ case    0:  		/* cmplw CR6, R20, R19 */
		/* 82103C10h case    0:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R19);
		/* 82103C10h case    0:*/		return 0x82103C14;
		  /* 82103C14h */ case    1:  		/* bc 12, CR6_EQ, -96 */
		/* 82103C14h case    1:*/		if ( regs.CR[6].eq ) { return 0x82103BB4;  }
		/* 82103C14h case    1:*/		return 0x82103C18;
		  /* 82103C18h */ case    2:  		/* lwz R11, <#[R27 + 4]> */
		/* 82103C18h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82103C18h case    2:*/		return 0x82103C1C;
		  /* 82103C1Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103C1Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103C1Ch case    3:*/		return 0x82103C20;
		  /* 82103C20h */ case    4:  		/* lwzx R11, <#[R11 + R22]> */
		/* 82103C20h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 82103C20h case    4:*/		return 0x82103C24;
		  /* 82103C24h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82103C24h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82103C24h case    5:*/		return 0x82103C28;
		  /* 82103C28h */ case    6:  		/* rlwinm. R29, R11, 0, 23, 23 */
		/* 82103C28h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R29,regs.R11);
		/* 82103C28h case    6:*/		return 0x82103C2C;
		  /* 82103C2Ch */ case    7:  		/* bc 12, CR0_EQ, 68 */
		/* 82103C2Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82103C70;  }
		/* 82103C2Ch case    7:*/		return 0x82103C30;
		  /* 82103C30h */ case    8:  		/* lwz R11, <#[R27 + 8]> */
		/* 82103C30h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82103C30h case    8:*/		return 0x82103C34;
		  /* 82103C34h */ case    9:  		/* cmpwi CR6, R11, -1 */
		/* 82103C34h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82103C34h case    9:*/		return 0x82103C38;
		  /* 82103C38h */ case   10:  		/* bc 4, CR6_EQ, 56 */
		/* 82103C38h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82103C70;  }
		/* 82103C38h case   10:*/		return 0x82103C3C;
		  /* 82103C3Ch */ case   11:  		/* lwz R11, <#[R30 + 4]> */
		/* 82103C3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82103C3Ch case   11:*/		return 0x82103C40;
		  /* 82103C40h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103C40h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103C40h case   12:*/		return 0x82103C44;
		  /* 82103C44h */ case   13:  		/* lwzx R11, <#[R11 + R22]> */
		/* 82103C44h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 82103C44h case   13:*/		return 0x82103C48;
		  /* 82103C48h */ case   14:  		/* lwz R11, <#[R11 + 4]> */
		/* 82103C48h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82103C48h case   14:*/		return 0x82103C4C;
		  /* 82103C4Ch */ case   15:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 82103C4Ch case   15:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 82103C4Ch case   15:*/		return 0x82103C50;
		  /* 82103C50h */ case   16:  		/* bc 12, CR0_EQ, 32 */
		/* 82103C50h case   16:*/		if ( regs.CR[0].eq ) { return 0x82103C70;  }
		/* 82103C50h case   16:*/		return 0x82103C54;
		  /* 82103C54h */ case   17:  		/* lwz R11, <#[R30 + 8]> */
		/* 82103C54h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82103C54h case   17:*/		return 0x82103C58;
		  /* 82103C58h */ case   18:  		/* cmpwi CR6, R11, -1 */
		/* 82103C58h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82103C58h case   18:*/		return 0x82103C5C;
		  /* 82103C5Ch */ case   19:  		/* bc 4, CR6_EQ, 20 */
		/* 82103C5Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x82103C70;  }
		/* 82103C5Ch case   19:*/		return 0x82103C60;
		  /* 82103C60h */ case   20:  		/* lfd FR0, <#[R27 + 32]> */
		/* 82103C60h case   20:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R27 + 0x00000020) );
		/* 82103C60h case   20:*/		return 0x82103C64;
		  /* 82103C64h */ case   21:  		/* lfd FR13, <#[R30 + 32]> */
		/* 82103C64h case   21:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R30 + 0x00000020) );
		/* 82103C64h case   21:*/		return 0x82103C68;
		  /* 82103C68h */ case   22:  		/* fcmpu CR6, FR0, FR13 */
		/* 82103C68h case   22:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82103C68h case   22:*/		return 0x82103C6C;
		  /* 82103C6Ch */ case   23:  		/* bc 12, CR6_EQ, -184 */
		/* 82103C6Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x82103BB4;  }
		/* 82103C6Ch case   23:*/		return 0x82103C70;
	}
	return 0x82103C70;
} // Block from 82103C10h-82103C70h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82103C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103C70);
		  /* 82103C70h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 82103C70h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82103C70h case    0:*/		return 0x82103C74;
		  /* 82103C74h */ case    1:  		/* bc 4, CR6_EQ, -188 */
		/* 82103C74h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82103BB8;  }
		/* 82103C74h case    1:*/		return 0x82103C78;
		  /* 82103C78h */ case    2:  		/* lis R11, -32256 */
		/* 82103C78h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82103C78h case    2:*/		return 0x82103C7C;
		  /* 82103C7Ch */ case    3:  		/* lwz R31, <#[R26 + 8]> */
		/* 82103C7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000008) );
		/* 82103C7Ch case    3:*/		return 0x82103C80;
		  /* 82103C80h */ case    4:  		/* lis R10, -32256 */
		/* 82103C80h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82103C80h case    4:*/		return 0x82103C84;
		  /* 82103C84h */ case    5:  		/* lis R21, 4112 */
		/* 82103C84h case    5:*/		cpu::op::lis<0>(regs,&regs.R21,0x1010);
		/* 82103C84h case    5:*/		return 0x82103C88;
		  /* 82103C88h */ case    6:  		/* cmpwi CR6, R31, -1 */
		/* 82103C88h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 82103C88h case    6:*/		return 0x82103C8C;
		  /* 82103C8Ch */ case    7:  		/* lfd FR12, <#[R11 + 1848]> */
		/* 82103C8Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000738) );
		/* 82103C8Ch case    7:*/		return 0x82103C90;
		  /* 82103C90h */ case    8:  		/* lfd FR13, <#[R10 + 1808]> */
		/* 82103C90h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000710) );
		/* 82103C90h case    8:*/		return 0x82103C94;
		  /* 82103C94h */ case    9:  		/* bc 4, CR6_EQ, -220 */
		/* 82103C94h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82103BB8;  }
		/* 82103C94h case    9:*/		return 0x82103C98;
		  /* 82103C98h */ case   10:  		/* rlwinm. R11, R28, 0, 30, 30 */
		/* 82103C98h case   10:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R28);
		/* 82103C98h case   10:*/		return 0x82103C9C;
		  /* 82103C9Ch */ case   11:  		/* bc 12, CR0_EQ, 216 */
		/* 82103C9Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82103D74;  }
		/* 82103C9Ch case   11:*/		return 0x82103CA0;
		  /* 82103CA0h */ case   12:  		/* lwz R11, <#[R26 + 72]> */
		/* 82103CA0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000048) );
		/* 82103CA0h case   12:*/		return 0x82103CA4;
		  /* 82103CA4h */ case   13:  		/* lwz R10, <#[R24 + 24]> */
		/* 82103CA4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000018) );
		/* 82103CA4h case   13:*/		return 0x82103CA8;
		  /* 82103CA8h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103CA8h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103CA8h case   14:*/		return 0x82103CAC;
		  /* 82103CACh */ case   15:  		/* lwzx R9, <#[R11 + R10]> */
		/* 82103CACh case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82103CACh case   15:*/		return 0x82103CB0;
		  /* 82103CB0h */ case   16:  		/* lwz R11, <#[R9]> */
		/* 82103CB0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 82103CB0h case   16:*/		return 0x82103CB4;
		  /* 82103CB4h */ case   17:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82103CB4h case   17:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82103CB4h case   17:*/		return 0x82103CB8;
		  /* 82103CB8h */ case   18:  		/* cmplw CR6, R11, R21 */
		/* 82103CB8h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 82103CB8h case   18:*/		return 0x82103CBC;
		  /* 82103CBCh */ case   19:  		/* bc 4, CR6_EQ, 184 */
		/* 82103CBCh case   19:*/		if ( !regs.CR[6].eq ) { return 0x82103D74;  }
		/* 82103CBCh case   19:*/		return 0x82103CC0;
		  /* 82103CC0h */ case   20:  		/* cmplwi CR6, R29, 0 */
		/* 82103CC0h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82103CC0h case   20:*/		return 0x82103CC4;
		  /* 82103CC4h */ case   21:  		/* bc 12, CR6_EQ, 176 */
		/* 82103CC4h case   21:*/		if ( regs.CR[6].eq ) { return 0x82103D74;  }
		/* 82103CC4h case   21:*/		return 0x82103CC8;
		  /* 82103CC8h */ case   22:  		/* lwz R11, <#[R27 + 8]> */
		/* 82103CC8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82103CC8h case   22:*/		return 0x82103CCC;
		  /* 82103CCCh */ case   23:  		/* cmpwi CR6, R11, -1 */
		/* 82103CCCh case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82103CCCh case   23:*/		return 0x82103CD0;
		  /* 82103CD0h */ case   24:  		/* bc 4, CR6_EQ, 164 */
		/* 82103CD0h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82103D74;  }
		/* 82103CD0h case   24:*/		return 0x82103CD4;
		  /* 82103CD4h */ case   25:  		/* lfd FR0, <#[R27 + 32]> */
		/* 82103CD4h case   25:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R27 + 0x00000020) );
		/* 82103CD4h case   25:*/		return 0x82103CD8;
		  /* 82103CD8h */ case   26:  		/* fcmpu CR6, FR0, FR13 */
		/* 82103CD8h case   26:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82103CD8h case   26:*/		return 0x82103CDC;
		  /* 82103CDCh */ case   27:  		/* bc 4, CR6_EQ, 152 */
		/* 82103CDCh case   27:*/		if ( !regs.CR[6].eq ) { return 0x82103D74;  }
		/* 82103CDCh case   27:*/		return 0x82103CE0;
		  /* 82103CE0h */ case   28:  		/* lwz R11, <#[R30 + 4]> */
		/* 82103CE0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82103CE0h case   28:*/		return 0x82103CE4;
		  /* 82103CE4h */ case   29:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103CE4h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103CE4h case   29:*/		return 0x82103CE8;
		  /* 82103CE8h */ case   30:  		/* lwzx R11, <#[R11 + R22]> */
		/* 82103CE8h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 82103CE8h case   30:*/		return 0x82103CEC;
		  /* 82103CECh */ case   31:  		/* lwz R11, <#[R11 + 4]> */
		/* 82103CECh case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82103CECh case   31:*/		return 0x82103CF0;
		  /* 82103CF0h */ case   32:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 82103CF0h case   32:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 82103CF0h case   32:*/		return 0x82103CF4;
		  /* 82103CF4h */ case   33:  		/* bc 12, CR0_EQ, 128 */
		/* 82103CF4h case   33:*/		if ( regs.CR[0].eq ) { return 0x82103D74;  }
		/* 82103CF4h case   33:*/		return 0x82103CF8;
		  /* 82103CF8h */ case   34:  		/* lwz R11, <#[R30 + 8]> */
		/* 82103CF8h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82103CF8h case   34:*/		return 0x82103CFC;
		  /* 82103CFCh */ case   35:  		/* cmpwi CR6, R11, -1 */
		/* 82103CFCh case   35:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82103CFCh case   35:*/		return 0x82103D00;
		  /* 82103D00h */ case   36:  		/* bc 4, CR6_EQ, 116 */
		/* 82103D00h case   36:*/		if ( !regs.CR[6].eq ) { return 0x82103D74;  }
		/* 82103D00h case   36:*/		return 0x82103D04;
		  /* 82103D04h */ case   37:  		/* lfd FR0, <#[R30 + 32]> */
		/* 82103D04h case   37:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000020) );
		/* 82103D04h case   37:*/		return 0x82103D08;
		  /* 82103D08h */ case   38:  		/* fcmpu CR6, FR0, FR12 */
		/* 82103D08h case   38:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 82103D08h case   38:*/		return 0x82103D0C;
		  /* 82103D0Ch */ case   39:  		/* bc 4, CR6_EQ, 104 */
		/* 82103D0Ch case   39:*/		if ( !regs.CR[6].eq ) { return 0x82103D74;  }
		/* 82103D0Ch case   39:*/		return 0x82103D10;
		  /* 82103D10h */ case   40:  		/* lwz R7, <#[R9 + 12]> */
		/* 82103D10h case   40:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x0000000C) );
		/* 82103D10h case   40:*/		return 0x82103D14;
		  /* 82103D14h */ case   41:  		/* li R10, 0 */
		/* 82103D14h case   41:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82103D14h case   41:*/		return 0x82103D18;
		  /* 82103D18h */ case   42:  		/* cmplwi CR6, R7, 0 */
		/* 82103D18h case   42:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82103D18h case   42:*/		return 0x82103D1C;
		  /* 82103D1Ch */ case   43:  		/* bc 12, CR6_EQ, 40 */
		/* 82103D1Ch case   43:*/		if ( regs.CR[6].eq ) { return 0x82103D44;  }
		/* 82103D1Ch case   43:*/		return 0x82103D20;
		  /* 82103D20h */ case   44:  		/* lwz R8, <#[R9 + 16]> */
		/* 82103D20h case   44:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000010) );
		/* 82103D20h case   44:*/		return 0x82103D24;
		  /* 82103D24h */ case   45:  		/* li R11, 0 */
		/* 82103D24h case   45:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82103D24h case   45:*/		return 0x82103D28;
		  /* 82103D28h */ case   46:  		/* lwzx R6, <#[R11 + R8]> */
		/* 82103D28h case   46:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82103D28h case   46:*/		return 0x82103D2C;
		  /* 82103D2Ch */ case   47:  		/* cmplw CR6, R6, R23 */
		/* 82103D2Ch case   47:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R23);
		/* 82103D2Ch case   47:*/		return 0x82103D30;
		  /* 82103D30h */ case   48:  		/* bc 12, CR6_EQ, 20 */
		/* 82103D30h case   48:*/		if ( regs.CR[6].eq ) { return 0x82103D44;  }
		/* 82103D30h case   48:*/		return 0x82103D34;
		  /* 82103D34h */ case   49:  		/* addi R10, R10, 1 */
		/* 82103D34h case   49:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82103D34h case   49:*/		return 0x82103D38;
		  /* 82103D38h */ case   50:  		/* addi R11, R11, 4 */
		/* 82103D38h case   50:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82103D38h case   50:*/		return 0x82103D3C;
		  /* 82103D3Ch */ case   51:  		/* cmplw CR6, R10, R7 */
		/* 82103D3Ch case   51:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 82103D3Ch case   51:*/		return 0x82103D40;
		  /* 82103D40h */ case   52:  		/* bc 12, CR6_LT, -24 */
		/* 82103D40h case   52:*/		if ( regs.CR[6].lt ) { return 0x82103D28;  }
		/* 82103D40h case   52:*/		return 0x82103D44;
	}
	return 0x82103D44;
} // Block from 82103C70h-82103D44h (53 instructions)

//////////////////////////////////////////////////////
// Block at 82103D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103D44);
		  /* 82103D44h */ case    0:  		/* lwz R11, <#[R9 + 8]> */
		/* 82103D44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82103D44h case    0:*/		return 0x82103D48;
		  /* 82103D48h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82103D48h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82103D48h case    1:*/		return 0x82103D4C;
		  /* 82103D4Ch */ case    2:  		/* lwz R9, <#[R24 + 20]> */
		/* 82103D4Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000014) );
		/* 82103D4Ch case    2:*/		return 0x82103D50;
		  /* 82103D50h */ case    3:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82103D50h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82103D50h case    3:*/		return 0x82103D54;
		  /* 82103D54h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103D54h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103D54h case    4:*/		return 0x82103D58;
		  /* 82103D58h */ case    5:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82103D58h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82103D58h case    5:*/		return 0x82103D5C;
		  /* 82103D5Ch */ case    6:  		/* lwz R11, <#[R11 + 48]> */
		/* 82103D5Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82103D5Ch case    6:*/		return 0x82103D60;
		  /* 82103D60h */ case    7:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 82103D60h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 82103D60h case    7:*/		return 0x82103D64;
		  /* 82103D64h */ case    8:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82103D64h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82103D64h case    8:*/		return 0x82103D68;
		  /* 82103D68h */ case    9:  		/* lwz R10, <#[R10]> */
		/* 82103D68h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82103D68h case    9:*/		return 0x82103D6C;
		  /* 82103D6Ch */ case   10:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82103D6Ch case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82103D6Ch case   10:*/		return 0x82103D70;
		  /* 82103D70h */ case   11:  		/* bc 4, CR0_EQ, -360 */
		/* 82103D70h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82103C08;  }
		/* 82103D70h case   11:*/		return 0x82103D74;
	}
	return 0x82103D74;
} // Block from 82103D44h-82103D74h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82103D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103D74);
		  /* 82103D74h */ case    0:  		/* cmpwi CR6, R31, -1 */
		/* 82103D74h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 82103D74h case    0:*/		return 0x82103D78;
		  /* 82103D78h */ case    1:  		/* bc 4, CR6_EQ, -448 */
		/* 82103D78h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82103BB8;  }
		/* 82103D78h case    1:*/		return 0x82103D7C;
		  /* 82103D7Ch */ case    2:  		/* rlwinm. R11, R28, 0, 30, 30 */
		/* 82103D7Ch case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R28);
		/* 82103D7Ch case    2:*/		return 0x82103D80;
		  /* 82103D80h */ case    3:  		/* bc 12, CR0_EQ, 340 */
		/* 82103D80h case    3:*/		if ( regs.CR[0].eq ) { return 0x82103ED4;  }
		/* 82103D80h case    3:*/		return 0x82103D84;
		  /* 82103D84h */ case    4:  		/* lwz R11, <#[R26 + 72]> */
		/* 82103D84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000048) );
		/* 82103D84h case    4:*/		return 0x82103D88;
		  /* 82103D88h */ case    5:  		/* lis R10, 8272 */
		/* 82103D88h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x2050);
		/* 82103D88h case    5:*/		return 0x82103D8C;
		  /* 82103D8Ch */ case    6:  		/* lwz R9, <#[R24 + 24]> */
		/* 82103D8Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000018) );
		/* 82103D8Ch case    6:*/		return 0x82103D90;
		  /* 82103D90h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103D90h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103D90h case    7:*/		return 0x82103D94;
		  /* 82103D94h */ case    8:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82103D94h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82103D94h case    8:*/		return 0x82103D98;
		  /* 82103D98h */ case    9:  		/* lwz R9, <#[R11]> */
		/* 82103D98h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82103D98h case    9:*/		return 0x82103D9C;
		  /* 82103D9Ch */ case   10:  		/* rlwinm R9, R9, 0, 0, 11 */
		/* 82103D9Ch case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R9);
		/* 82103D9Ch case   10:*/		return 0x82103DA0;
		  /* 82103DA0h */ case   11:  		/* cmplw CR6, R9, R10 */
		/* 82103DA0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82103DA0h case   11:*/		return 0x82103DA4;
		  /* 82103DA4h */ case   12:  		/* bc 4, CR6_EQ, 304 */
		/* 82103DA4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82103ED4;  }
		/* 82103DA4h case   12:*/		return 0x82103DA8;
		  /* 82103DA8h */ case   13:  		/* cmplwi CR6, R29, 0 */
		/* 82103DA8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82103DA8h case   13:*/		return 0x82103DAC;
		  /* 82103DACh */ case   14:  		/* bc 12, CR6_EQ, 296 */
		/* 82103DACh case   14:*/		if ( regs.CR[6].eq ) { return 0x82103ED4;  }
		/* 82103DACh case   14:*/		return 0x82103DB0;
		  /* 82103DB0h */ case   15:  		/* lwz R10, <#[R27 + 8]> */
		/* 82103DB0h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 82103DB0h case   15:*/		return 0x82103DB4;
		  /* 82103DB4h */ case   16:  		/* cmpwi CR6, R10, -1 */
		/* 82103DB4h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82103DB4h case   16:*/		return 0x82103DB8;
		  /* 82103DB8h */ case   17:  		/* bc 4, CR6_EQ, 284 */
		/* 82103DB8h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82103ED4;  }
		/* 82103DB8h case   17:*/		return 0x82103DBC;
		  /* 82103DBCh */ case   18:  		/* lfd FR0, <#[R27 + 32]> */
		/* 82103DBCh case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R27 + 0x00000020) );
		/* 82103DBCh case   18:*/		return 0x82103DC0;
		  /* 82103DC0h */ case   19:  		/* fcmpu CR6, FR0, FR13 */
		/* 82103DC0h case   19:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82103DC0h case   19:*/		return 0x82103DC4;
		  /* 82103DC4h */ case   20:  		/* bc 4, CR6_EQ, 272 */
		/* 82103DC4h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82103ED4;  }
		/* 82103DC4h case   20:*/		return 0x82103DC8;
		  /* 82103DC8h */ case   21:  		/* lwz R10, <#[R30 + 4]> */
		/* 82103DC8h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82103DC8h case   21:*/		return 0x82103DCC;
		  /* 82103DCCh */ case   22:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82103DCCh case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82103DCCh case   22:*/		return 0x82103DD0;
		  /* 82103DD0h */ case   23:  		/* lwzx R10, <#[R10 + R22]> */
		/* 82103DD0h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R22 + 0x00000000) );
		/* 82103DD0h case   23:*/		return 0x82103DD4;
		  /* 82103DD4h */ case   24:  		/* lwz R10, <#[R10 + 4]> */
		/* 82103DD4h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82103DD4h case   24:*/		return 0x82103DD8;
		  /* 82103DD8h */ case   25:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 82103DD8h case   25:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 82103DD8h case   25:*/		return 0x82103DDC;
		  /* 82103DDCh */ case   26:  		/* bc 12, CR0_EQ, 248 */
		/* 82103DDCh case   26:*/		if ( regs.CR[0].eq ) { return 0x82103ED4;  }
		/* 82103DDCh case   26:*/		return 0x82103DE0;
		  /* 82103DE0h */ case   27:  		/* lwz R10, <#[R30 + 8]> */
		/* 82103DE0h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82103DE0h case   27:*/		return 0x82103DE4;
		  /* 82103DE4h */ case   28:  		/* cmpwi CR6, R10, -1 */
		/* 82103DE4h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82103DE4h case   28:*/		return 0x82103DE8;
		  /* 82103DE8h */ case   29:  		/* bc 4, CR6_EQ, 236 */
		/* 82103DE8h case   29:*/		if ( !regs.CR[6].eq ) { return 0x82103ED4;  }
		/* 82103DE8h case   29:*/		return 0x82103DEC;
		  /* 82103DECh */ case   30:  		/* lfd FR0, <#[R30 + 32]> */
		/* 82103DECh case   30:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000020) );
		/* 82103DECh case   30:*/		return 0x82103DF0;
		  /* 82103DF0h */ case   31:  		/* fcmpu CR6, FR0, FR12 */
		/* 82103DF0h case   31:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 82103DF0h case   31:*/		return 0x82103DF4;
		  /* 82103DF4h */ case   32:  		/* bc 4, CR6_EQ, 224 */
		/* 82103DF4h case   32:*/		if ( !regs.CR[6].eq ) { return 0x82103ED4;  }
		/* 82103DF4h case   32:*/		return 0x82103DF8;
		  /* 82103DF8h */ case   33:  		/* lwz R8, <#[R11 + 12]> */
		/* 82103DF8h case   33:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82103DF8h case   33:*/		return 0x82103DFC;
		  /* 82103DFCh */ case   34:  		/* li R4, 0 */
		/* 82103DFCh case   34:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82103DFCh case   34:*/		return 0x82103E00;
		  /* 82103E00h */ case   35:  		/* cmplwi CR6, R8, 0 */
		/* 82103E00h case   35:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82103E00h case   35:*/		return 0x82103E04;
		  /* 82103E04h */ case   36:  		/* bc 12, CR6_EQ, 40 */
		/* 82103E04h case   36:*/		if ( regs.CR[6].eq ) { return 0x82103E2C;  }
		/* 82103E04h case   36:*/		return 0x82103E08;
		  /* 82103E08h */ case   37:  		/* lwz R9, <#[R11 + 16]> */
		/* 82103E08h case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 82103E08h case   37:*/		return 0x82103E0C;
		  /* 82103E0Ch */ case   38:  		/* li R10, 0 */
		/* 82103E0Ch case   38:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82103E0Ch case   38:*/		return 0x82103E10;
		  /* 82103E10h */ case   39:  		/* lwzx R7, <#[R10 + R9]> */
		/* 82103E10h case   39:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82103E10h case   39:*/		return 0x82103E14;
		  /* 82103E14h */ case   40:  		/* cmplw CR6, R7, R23 */
		/* 82103E14h case   40:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R23);
		/* 82103E14h case   40:*/		return 0x82103E18;
		  /* 82103E18h */ case   41:  		/* bc 12, CR6_EQ, 20 */
		/* 82103E18h case   41:*/		if ( regs.CR[6].eq ) { return 0x82103E2C;  }
		/* 82103E18h case   41:*/		return 0x82103E1C;
		  /* 82103E1Ch */ case   42:  		/* addi R4, R4, 1 */
		/* 82103E1Ch case   42:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82103E1Ch case   42:*/		return 0x82103E20;
		  /* 82103E20h */ case   43:  		/* addi R10, R10, 4 */
		/* 82103E20h case   43:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82103E20h case   43:*/		return 0x82103E24;
		  /* 82103E24h */ case   44:  		/* cmplw CR6, R4, R8 */
		/* 82103E24h case   44:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R8);
		/* 82103E24h case   44:*/		return 0x82103E28;
		  /* 82103E28h */ case   45:  		/* bc 12, CR6_LT, -24 */
		/* 82103E28h case   45:*/		if ( regs.CR[6].lt ) { return 0x82103E10;  }
		/* 82103E28h case   45:*/		return 0x82103E2C;
	}
	return 0x82103E2C;
} // Block from 82103D74h-82103E2Ch (46 instructions)

//////////////////////////////////////////////////////
// Block at 82103E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103E2C);
		  /* 82103E2Ch */ case    0:  		/* lwz R10, <#[R11 + 12]> */
		/* 82103E2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82103E2Ch case    0:*/		return 0x82103E30;
		  /* 82103E30h */ case    1:  		/* li R8, 0 */
		/* 82103E30h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82103E30h case    1:*/		return 0x82103E34;
		  /* 82103E34h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 82103E34h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82103E34h case    2:*/		return 0x82103E38;
		  /* 82103E38h */ case    3:  		/* li R6, 1 */
		/* 82103E38h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82103E38h case    3:*/		return 0x82103E3C;
		  /* 82103E3Ch */ case    4:  		/* lwz R11, <#[R24 + 20]> */
		/* 82103E3Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 82103E3Ch case    4:*/		return 0x82103E40;
		  /* 82103E40h */ case    5:  		/* mullw R7, R10, R8 */
		/* 82103E40h case    5:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R8);
		/* 82103E40h case    5:*/		return 0x82103E44;
		  /* 82103E44h */ case    6:  		/* add R5, R7, R4 */
		/* 82103E44h case    6:*/		cpu::op::add<0>(regs,&regs.R5,regs.R7,regs.R4);
		/* 82103E44h case    6:*/		return 0x82103E48;
		  /* 82103E48h */ case    7:  		/* mullw R7, R6, R10 */
		/* 82103E48h case    7:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R6,regs.R10);
		/* 82103E48h case    7:*/		return 0x82103E4C;
		  /* 82103E4Ch */ case    8:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82103E4Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82103E4Ch case    8:*/		return 0x82103E50;
		  /* 82103E50h */ case    9:  		/* add R7, R7, R4 */
		/* 82103E50h case    9:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R4);
		/* 82103E50h case    9:*/		return 0x82103E54;
		  /* 82103E54h */ case   10:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82103E54h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82103E54h case   10:*/		return 0x82103E58;
		  /* 82103E58h */ case   11:  		/* lwzx R5, <#[R5 + R9]> */
		/* 82103E58h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 82103E58h case   11:*/		return 0x82103E5C;
		  /* 82103E5Ch */ case   12:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82103E5Ch case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82103E5Ch case   12:*/		return 0x82103E60;
		  /* 82103E60h */ case   13:  		/* lwzx R7, <#[R7 + R9]> */
		/* 82103E60h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 82103E60h case   13:*/		return 0x82103E64;
		  /* 82103E64h */ case   14:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82103E64h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82103E64h case   14:*/		return 0x82103E68;
		  /* 82103E68h */ case   15:  		/* lwzx R5, <#[R5 + R11]> */
		/* 82103E68h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82103E68h case   15:*/		return 0x82103E6C;
		  /* 82103E6Ch */ case   16:  		/* lwzx R25, <#[R7 + R11]> */
		/* 82103E6Ch case   16:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82103E6Ch case   16:*/		return 0x82103E70;
		  /* 82103E70h */ case   17:  		/* lwz R7, <#[R5 + 48]> */
		/* 82103E70h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000030) );
		/* 82103E70h case   17:*/		return 0x82103E74;
		  /* 82103E74h */ case   18:  		/* rlwinm R5, R7, 2, 0, 29 */
		/* 82103E74h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R7);
		/* 82103E74h case   18:*/		return 0x82103E78;
		  /* 82103E78h */ case   19:  		/* lwz R25, <#[R25 + 48]> */
		/* 82103E78h case   19:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R25 + 0x00000030) );
		/* 82103E78h case   19:*/		return 0x82103E7C;
		  /* 82103E7Ch */ case   20:  		/* rlwinm R25, R25, 2, 0, 29 */
		/* 82103E7Ch case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R25,regs.R25);
		/* 82103E7Ch case   20:*/		return 0x82103E80;
		  /* 82103E80h */ case   21:  		/* lwzx R16, <#[R5 + R11]> */
		/* 82103E80h case   21:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82103E80h case   21:*/		return 0x82103E84;
		  /* 82103E84h */ case   22:  		/* lwzx R5, <#[R25 + R11]> */
		/* 82103E84h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R25 + regs.R11 + 0x00000000) );
		/* 82103E84h case   22:*/		return 0x82103E88;
		  /* 82103E88h */ case   23:  		/* lwz R25, <#[R16]> */
		/* 82103E88h case   23:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R16 + 0x00000000) );
		/* 82103E88h case   23:*/		return 0x82103E8C;
		  /* 82103E8Ch */ case   24:  		/* rlwinm. R25, R25, 0, 31, 31 */
		/* 82103E8Ch case   24:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R25,regs.R25);
		/* 82103E8Ch case   24:*/		return 0x82103E90;
		  /* 82103E90h */ case   25:  		/* bc 12, CR0_EQ, 52 */
		/* 82103E90h case   25:*/		if ( regs.CR[0].eq ) { return 0x82103EC4;  }
		/* 82103E90h case   25:*/		return 0x82103E94;
		  /* 82103E94h */ case   26:  		/* lwz R25, <#[R5 + 4]> */
		/* 82103E94h case   26:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R5 + 0x00000004) );
		/* 82103E94h case   26:*/		return 0x82103E98;
		  /* 82103E98h */ case   27:  		/* rlwinm R25, R25, 2, 0, 29 */
		/* 82103E98h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R25,regs.R25);
		/* 82103E98h case   27:*/		return 0x82103E9C;
		  /* 82103E9Ch */ case   28:  		/* lwzx R25, <#[R25 + R22]> */
		/* 82103E9Ch case   28:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R25 + regs.R22 + 0x00000000) );
		/* 82103E9Ch case   28:*/		return 0x82103EA0;
		  /* 82103EA0h */ case   29:  		/* lwz R25, <#[R25 + 4]> */
		/* 82103EA0h case   29:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R25 + 0x00000004) );
		/* 82103EA0h case   29:*/		return 0x82103EA4;
		  /* 82103EA4h */ case   30:  		/* rlwinm. R25, R25, 0, 23, 23 */
		/* 82103EA4h case   30:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R25,regs.R25);
		/* 82103EA4h case   30:*/		return 0x82103EA8;
		  /* 82103EA8h */ case   31:  		/* bc 12, CR0_EQ, 28 */
		/* 82103EA8h case   31:*/		if ( regs.CR[0].eq ) { return 0x82103EC4;  }
		/* 82103EA8h case   31:*/		return 0x82103EAC;
		  /* 82103EACh */ case   32:  		/* lwz R25, <#[R5 + 8]> */
		/* 82103EACh case   32:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R5 + 0x00000008) );
		/* 82103EACh case   32:*/		return 0x82103EB0;
		  /* 82103EB0h */ case   33:  		/* cmpwi CR6, R25, -1 */
		/* 82103EB0h case   33:*/		cpu::op::cmpwi<6>(regs,regs.R25,0xFFFFFFFF);
		/* 82103EB0h case   33:*/		return 0x82103EB4;
		  /* 82103EB4h */ case   34:  		/* bc 4, CR6_EQ, 16 */
		/* 82103EB4h case   34:*/		if ( !regs.CR[6].eq ) { return 0x82103EC4;  }
		/* 82103EB4h case   34:*/		return 0x82103EB8;
		  /* 82103EB8h */ case   35:  		/* lfd FR0, <#[R5 + 32]> */
		/* 82103EB8h case   35:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R5 + 0x00000020) );
		/* 82103EB8h case   35:*/		return 0x82103EBC;
		  /* 82103EBCh */ case   36:  		/* fcmpu CR6, FR0, FR13 */
		/* 82103EBCh case   36:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82103EBCh case   36:*/		return 0x82103EC0;
		  /* 82103EC0h */ case   37:  		/* bc 12, CR6_LT, 164 */
		/* 82103EC0h case   37:*/		if ( regs.CR[6].lt ) { return 0x82103F64;  }
		/* 82103EC0h case   37:*/		return 0x82103EC4;
	}
	return 0x82103EC4;
} // Block from 82103E2Ch-82103EC4h (38 instructions)

//////////////////////////////////////////////////////
// Block at 82103EC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103EC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103EC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103EC4);
		  /* 82103EC4h */ case    0:  		/* addi R8, R8, 1 */
		/* 82103EC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82103EC4h case    0:*/		return 0x82103EC8;
		  /* 82103EC8h */ case    1:  		/* addi R6, R6, -1 */
		/* 82103EC8h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82103EC8h case    1:*/		return 0x82103ECC;
		  /* 82103ECCh */ case    2:  		/* cmplwi CR6, R8, 2 */
		/* 82103ECCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000002);
		/* 82103ECCh case    2:*/		return 0x82103ED0;
		  /* 82103ED0h */ case    3:  		/* bc 12, CR6_LT, -144 */
		/* 82103ED0h case    3:*/		if ( regs.CR[6].lt ) { return 0x82103E40;  }
		/* 82103ED0h case    3:*/		return 0x82103ED4;
	}
	return 0x82103ED4;
} // Block from 82103EC4h-82103ED4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82103ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103ED4);
		  /* 82103ED4h */ case    0:  		/* cmpwi CR6, R31, -1 */
		/* 82103ED4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 82103ED4h case    0:*/		return 0x82103ED8;
		  /* 82103ED8h */ case    1:  		/* bc 4, CR6_EQ, -800 */
		/* 82103ED8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82103BB8;  }
		/* 82103ED8h case    1:*/		return 0x82103EDC;
		  /* 82103EDCh */ case    2:  		/* rlwinm. R11, R28, 0, 30, 30 */
		/* 82103EDCh case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R28);
		/* 82103EDCh case    2:*/		return 0x82103EE0;
		  /* 82103EE0h */ case    3:  		/* bc 12, CR0_EQ, -808 */
		/* 82103EE0h case    3:*/		if ( regs.CR[0].eq ) { return 0x82103BB8;  }
		/* 82103EE0h case    3:*/		return 0x82103EE4;
		  /* 82103EE4h */ case    4:  		/* lwz R11, <#[R26 + 72]> */
		/* 82103EE4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000048) );
		/* 82103EE4h case    4:*/		return 0x82103EE8;
		  /* 82103EE8h */ case    5:  		/* lis R9, 8256 */
		/* 82103EE8h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0x2040);
		/* 82103EE8h case    5:*/		return 0x82103EEC;
		  /* 82103EECh */ case    6:  		/* lwz R25, <#[R24 + 24]> */
		/* 82103EECh case    6:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R24 + 0x00000018) );
		/* 82103EECh case    6:*/		return 0x82103EF0;
		  /* 82103EF0h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103EF0h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103EF0h case    7:*/		return 0x82103EF4;
		  /* 82103EF4h */ case    8:  		/* lwzx R10, <#[R11 + R25]> */
		/* 82103EF4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 82103EF4h case    8:*/		return 0x82103EF8;
		  /* 82103EF8h */ case    9:  		/* lwz R11, <#[R10]> */
		/* 82103EF8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82103EF8h case    9:*/		return 0x82103EFC;
		  /* 82103EFCh */ case   10:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82103EFCh case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82103EFCh case   10:*/		return 0x82103F00;
		  /* 82103F00h */ case   11:  		/* cmplw CR6, R11, R9 */
		/* 82103F00h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82103F00h case   11:*/		return 0x82103F04;
		  /* 82103F04h */ case   12:  		/* bc 4, CR6_EQ, -844 */
		/* 82103F04h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82103BB8;  }
		/* 82103F04h case   12:*/		return 0x82103F08;
		  /* 82103F08h */ case   13:  		/* li R31, -1 */
		/* 82103F08h case   13:*/		cpu::op::li<0>(regs,&regs.R31,0xFFFFFFFF);
		/* 82103F08h case   13:*/		return 0x82103F0C;
		  /* 82103F0Ch */ case   14:  		/* cmplwi CR6, R29, 0 */
		/* 82103F0Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82103F0Ch case   14:*/		return 0x82103F10;
		  /* 82103F10h */ case   15:  		/* bc 12, CR6_EQ, 120 */
		/* 82103F10h case   15:*/		if ( regs.CR[6].eq ) { return 0x82103F88;  }
		/* 82103F10h case   15:*/		return 0x82103F14;
		  /* 82103F14h */ case   16:  		/* lwz R11, <#[R27 + 8]> */
		/* 82103F14h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82103F14h case   16:*/		return 0x82103F18;
		  /* 82103F18h */ case   17:  		/* cmpwi CR6, R11, -1 */
		/* 82103F18h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82103F18h case   17:*/		return 0x82103F1C;
		  /* 82103F1Ch */ case   18:  		/* bc 4, CR6_EQ, 108 */
		/* 82103F1Ch case   18:*/		if ( !regs.CR[6].eq ) { return 0x82103F88;  }
		/* 82103F1Ch case   18:*/		return 0x82103F20;
		  /* 82103F20h */ case   19:  		/* lwz R11, <#[R30 + 4]> */
		/* 82103F20h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82103F20h case   19:*/		return 0x82103F24;
		  /* 82103F24h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103F24h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103F24h case   20:*/		return 0x82103F28;
		  /* 82103F28h */ case   21:  		/* lwzx R11, <#[R11 + R22]> */
		/* 82103F28h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 82103F28h case   21:*/		return 0x82103F2C;
		  /* 82103F2Ch */ case   22:  		/* lwz R11, <#[R11 + 4]> */
		/* 82103F2Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82103F2Ch case   22:*/		return 0x82103F30;
		  /* 82103F30h */ case   23:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 82103F30h case   23:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 82103F30h case   23:*/		return 0x82103F34;
		  /* 82103F34h */ case   24:  		/* bc 12, CR0_EQ, 84 */
		/* 82103F34h case   24:*/		if ( regs.CR[0].eq ) { return 0x82103F88;  }
		/* 82103F34h case   24:*/		return 0x82103F38;
		  /* 82103F38h */ case   25:  		/* lwz R11, <#[R30 + 8]> */
		/* 82103F38h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82103F38h case   25:*/		return 0x82103F3C;
		  /* 82103F3Ch */ case   26:  		/* cmpwi CR6, R11, -1 */
		/* 82103F3Ch case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82103F3Ch case   26:*/		return 0x82103F40;
		  /* 82103F40h */ case   27:  		/* bc 4, CR6_EQ, 72 */
		/* 82103F40h case   27:*/		if ( !regs.CR[6].eq ) { return 0x82103F88;  }
		/* 82103F40h case   27:*/		return 0x82103F44;
		  /* 82103F44h */ case   28:  		/* lfd FR0, <#[R27 + 32]> */
		/* 82103F44h case   28:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R27 + 0x00000020) );
		/* 82103F44h case   28:*/		return 0x82103F48;
		  /* 82103F48h */ case   29:  		/* fcmpu CR6, FR0, FR13 */
		/* 82103F48h case   29:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82103F48h case   29:*/		return 0x82103F4C;
		  /* 82103F4Ch */ case   30:  		/* bc 4, CR6_EQ, 32 */
		/* 82103F4Ch case   30:*/		if ( !regs.CR[6].eq ) { return 0x82103F6C;  }
		/* 82103F4Ch case   30:*/		return 0x82103F50;
		  /* 82103F50h */ case   31:  		/* lfd FR11, <#[R30 + 32]> */
		/* 82103F50h case   31:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R30 + 0x00000020) );
		/* 82103F50h case   31:*/		return 0x82103F54;
		  /* 82103F54h */ case   32:  		/* fcmpu CR6, FR11, FR12 */
		/* 82103F54h case   32:*/		cpu::op::fcmpu<6>(regs,regs.FR11,regs.FR12);
		/* 82103F54h case   32:*/		return 0x82103F58;
		  /* 82103F58h */ case   33:  		/* bc 4, CR6_EQ, 20 */
		/* 82103F58h case   33:*/		if ( !regs.CR[6].eq ) { return 0x82103F6C;  }
		/* 82103F58h case   33:*/		return 0x82103F5C;
		  /* 82103F5Ch */ case   34:  		/* lis R31, 8224 */
		/* 82103F5Ch case   34:*/		cpu::op::lis<0>(regs,&regs.R31,0x2020);
		/* 82103F5Ch case   34:*/		return 0x82103F60;
		  /* 82103F60h */ case   35:  		/* b 36 */
		/* 82103F60h case   35:*/		return 0x82103F84;
		/* 82103F60h case   35:*/		return 0x82103F64;
	}
	return 0x82103F64;
} // Block from 82103ED4h-82103F64h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82103F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103F64);
		  /* 82103F64h */ case    0:  		/* stw R7, <#[R3 + 48]> */
		/* 82103F64h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000030) );
		/* 82103F64h case    0:*/		return 0x82103F68;
		  /* 82103F68h */ case    1:  		/* b -944 */
		/* 82103F68h case    1:*/		return 0x82103BB8;
		/* 82103F68h case    1:*/		return 0x82103F6C;
	}
	return 0x82103F6C;
} // Block from 82103F64h-82103F6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82103F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103F6C);
		  /* 82103F6Ch */ case    0:  		/* fcmpu CR6, FR0, FR12 */
		/* 82103F6Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 82103F6Ch case    0:*/		return 0x82103F70;
		  /* 82103F70h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82103F70h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82103F88;  }
		/* 82103F70h case    1:*/		return 0x82103F74;
		  /* 82103F74h */ case    2:  		/* lfd FR0, <#[R30 + 32]> */
		/* 82103F74h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000020) );
		/* 82103F74h case    2:*/		return 0x82103F78;
		  /* 82103F78h */ case    3:  		/* fcmpu CR6, FR0, FR13 */
		/* 82103F78h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82103F78h case    3:*/		return 0x82103F7C;
		  /* 82103F7Ch */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 82103F7Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82103F88;  }
		/* 82103F7Ch case    4:*/		return 0x82103F80;
		  /* 82103F80h */ case    5:  		/* lis R31, 8240 */
		/* 82103F80h case    5:*/		cpu::op::lis<0>(regs,&regs.R31,0x2030);
		/* 82103F80h case    5:*/		return 0x82103F84;
	}
	return 0x82103F84;
} // Block from 82103F6Ch-82103F84h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82103F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103F84);
		  /* 82103F84h */ case    0:  		/* ori R31, R31, 1 */
		/* 82103F84h case    0:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82103F84h case    0:*/		return 0x82103F88;
	}
	return 0x82103F88;
} // Block from 82103F84h-82103F88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82103F88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103F88);
		  /* 82103F88h */ case    0:  		/* lwz R7, <#[R10 + 12]> */
		/* 82103F88h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x0000000C) );
		/* 82103F88h case    0:*/		return 0x82103F8C;
		  /* 82103F8Ch */ case    1:  		/* li R9, 0 */
		/* 82103F8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82103F8Ch case    1:*/		return 0x82103F90;
		  /* 82103F90h */ case    2:  		/* cmplwi CR6, R7, 0 */
		/* 82103F90h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82103F90h case    2:*/		return 0x82103F94;
		  /* 82103F94h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 82103F94h case    3:*/		if ( regs.CR[6].eq ) { return 0x82103FBC;  }
		/* 82103F94h case    3:*/		return 0x82103F98;
		  /* 82103F98h */ case    4:  		/* lwz R8, <#[R10 + 16]> */
		/* 82103F98h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 82103F98h case    4:*/		return 0x82103F9C;
		  /* 82103F9Ch */ case    5:  		/* li R11, 0 */
		/* 82103F9Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82103F9Ch case    5:*/		return 0x82103FA0;
		  /* 82103FA0h */ case    6:  		/* lwzx R6, <#[R11 + R8]> */
		/* 82103FA0h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82103FA0h case    6:*/		return 0x82103FA4;
		  /* 82103FA4h */ case    7:  		/* cmplw CR6, R6, R23 */
		/* 82103FA4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R23);
		/* 82103FA4h case    7:*/		return 0x82103FA8;
		  /* 82103FA8h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82103FA8h case    8:*/		if ( regs.CR[6].eq ) { return 0x82103FBC;  }
		/* 82103FA8h case    8:*/		return 0x82103FAC;
		  /* 82103FACh */ case    9:  		/* addi R9, R9, 1 */
		/* 82103FACh case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82103FACh case    9:*/		return 0x82103FB0;
		  /* 82103FB0h */ case   10:  		/* addi R11, R11, 4 */
		/* 82103FB0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82103FB0h case   10:*/		return 0x82103FB4;
		  /* 82103FB4h */ case   11:  		/* cmplw CR6, R9, R7 */
		/* 82103FB4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82103FB4h case   11:*/		return 0x82103FB8;
		  /* 82103FB8h */ case   12:  		/* bc 12, CR6_LT, -24 */
		/* 82103FB8h case   12:*/		if ( regs.CR[6].lt ) { return 0x82103FA0;  }
		/* 82103FB8h case   12:*/		return 0x82103FBC;
	}
	return 0x82103FBC;
} // Block from 82103F88h-82103FBCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 82103FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82103FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82103FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82103FBC);
		  /* 82103FBCh */ case    0:  		/* lwz R11, <#[R10 + 12]> */
		/* 82103FBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 82103FBCh case    0:*/		return 0x82103FC0;
		  /* 82103FC0h */ case    1:  		/* rlwinm R8, R9, 2, 0, 29 */
		/* 82103FC0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 82103FC0h case    1:*/		return 0x82103FC4;
		  /* 82103FC4h */ case    2:  		/* lwz R10, <#[R10 + 8]> */
		/* 82103FC4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82103FC4h case    2:*/		return 0x82103FC8;
		  /* 82103FC8h */ case    3:  		/* li R29, 0 */
		/* 82103FC8h case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82103FC8h case    3:*/		return 0x82103FCC;
		  /* 82103FCCh */ case    4:  		/* add R9, R11, R9 */
		/* 82103FCCh case    4:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 82103FCCh case    4:*/		return 0x82103FD0;
		  /* 82103FD0h */ case    5:  		/* lwz R3, <#[R24 + 20]> */
		/* 82103FD0h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000014) );
		/* 82103FD0h case    5:*/		return 0x82103FD4;
		  /* 82103FD4h */ case    6:  		/* rlwinm R27, R11, 2, 0, 29 */
		/* 82103FD4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R11);
		/* 82103FD4h case    6:*/		return 0x82103FD8;
		  /* 82103FD8h */ case    7:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82103FD8h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82103FD8h case    7:*/		return 0x82103FDC;
		  /* 82103FDCh */ case    8:  		/* mulli R26, R11, -4 */
		/* 82103FDCh case    8:*/		cpu::op::mulli<0>(regs,&regs.R26,regs.R11,0xFFFFFFFC);
		/* 82103FDCh case    8:*/		return 0x82103FE0;
		  /* 82103FE0h */ case    9:  		/* add R5, R8, R10 */
		/* 82103FE0h case    9:*/		cpu::op::add<0>(regs,&regs.R5,regs.R8,regs.R10);
		/* 82103FE0h case    9:*/		return 0x82103FE4;
		  /* 82103FE4h */ case   10:  		/* add R4, R9, R10 */
		/* 82103FE4h case   10:*/		cpu::op::add<0>(regs,&regs.R4,regs.R9,regs.R10);
		/* 82103FE4h case   10:*/		return 0x82103FE8;
		  /* 82103FE8h */ case   11:  		/* lwz R11, <#[R4]> */
		/* 82103FE8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82103FE8h case   11:*/		return 0x82103FEC;
		  /* 82103FECh */ case   12:  		/* lwz R10, <#[R5]> */
		/* 82103FECh case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 82103FECh case   12:*/		return 0x82103FF0;
		  /* 82103FF0h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82103FF0h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82103FF0h case   13:*/		return 0x82103FF4;
		  /* 82103FF4h */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82103FF4h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82103FF4h case   14:*/		return 0x82103FF8;
		  /* 82103FF8h */ case   15:  		/* lwzx R11, <#[R11 + R3]> */
		/* 82103FF8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82103FF8h case   15:*/		return 0x82103FFC;
		  /* 82103FFCh */ case   16:  		/* lwzx R10, <#[R10 + R3]> */
		/* 82103FFCh case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82103FFCh case   16:*/		return 0x82104000;
		  /* 82104000h */ case   17:  		/* lwz R6, <#[R11 + 48]> */
		/* 82104000h case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000030) );
		/* 82104000h case   17:*/		return 0x82104004;
		  /* 82104004h */ case   18:  		/* lwz R28, <#[R10 + 48]> */
		/* 82104004h case   18:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + 0x00000030) );
		/* 82104004h case   18:*/		return 0x82104008;
		  /* 82104008h */ case   19:  		/* rlwinm R11, R6, 2, 0, 29 */
		/* 82104008h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R6);
		/* 82104008h case   19:*/		return 0x8210400C;
		  /* 8210400Ch */ case   20:  		/* lwzx R11, <#[R11 + R3]> */
		/* 8210400Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8210400Ch case   20:*/		return 0x82104010;
		  /* 82104010h */ case   21:  		/* lwz R10, <#[R11 + 8]> */
		/* 82104010h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82104010h case   21:*/		return 0x82104014;
		  /* 82104014h */ case   22:  		/* cmpwi CR6, R10, -1 */
		/* 82104014h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82104014h case   22:*/		return 0x82104018;
		  /* 82104018h */ case   23:  		/* bc 4, CR6_EQ, 176 */
		/* 82104018h case   23:*/		if ( !regs.CR[6].eq ) { return 0x821040C8;  }
		/* 82104018h case   23:*/		return 0x8210401C;
		  /* 8210401Ch */ case   24:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210401Ch case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210401Ch case   24:*/		return 0x82104020;
		  /* 82104020h */ case   25:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82104020h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82104020h case   25:*/		return 0x82104024;
		  /* 82104024h */ case   26:  		/* lwzx R10, <#[R10 + R22]> */
		/* 82104024h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R22 + 0x00000000) );
		/* 82104024h case   26:*/		return 0x82104028;
		  /* 82104028h */ case   27:  		/* lwz R10, <#[R10 + 4]> */
		/* 82104028h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82104028h case   27:*/		return 0x8210402C;
		  /* 8210402Ch */ case   28:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 8210402Ch case   28:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 8210402Ch case   28:*/		return 0x82104030;
		  /* 82104030h */ case   29:  		/* bc 12, CR0_EQ, 152 */
		/* 82104030h case   29:*/		if ( regs.CR[0].eq ) { return 0x821040C8;  }
		/* 82104030h case   29:*/		return 0x82104034;
		  /* 82104034h */ case   30:  		/* lwz R11, <#[R11 + 72]> */
		/* 82104034h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82104034h case   30:*/		return 0x82104038;
		  /* 82104038h */ case   31:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82104038h case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82104038h case   31:*/		return 0x8210403C;
		  /* 8210403Ch */ case   32:  		/* lwzx R11, <#[R11 + R25]> */
		/* 8210403Ch case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 8210403Ch case   32:*/		return 0x82104040;
		  /* 82104040h */ case   33:  		/* lwz R10, <#[R11]> */
		/* 82104040h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82104040h case   33:*/		return 0x82104044;
		  /* 82104044h */ case   34:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82104044h case   34:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82104044h case   34:*/		return 0x82104048;
		  /* 82104048h */ case   35:  		/* cmplw CR6, R10, R21 */
		/* 82104048h case   35:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R21);
		/* 82104048h case   35:*/		return 0x8210404C;
		  /* 8210404Ch */ case   36:  		/* bc 4, CR6_EQ, 124 */
		/* 8210404Ch case   36:*/		if ( !regs.CR[6].eq ) { return 0x821040C8;  }
		/* 8210404Ch case   36:*/		return 0x82104050;
		  /* 82104050h */ case   37:  		/* lwz R7, <#[R11 + 12]> */
		/* 82104050h case   37:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 82104050h case   37:*/		return 0x82104054;
		  /* 82104054h */ case   38:  		/* li R9, 0 */
		/* 82104054h case   38:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82104054h case   38:*/		return 0x82104058;
		  /* 82104058h */ case   39:  		/* cmplwi CR6, R7, 0 */
		/* 82104058h case   39:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82104058h case   39:*/		return 0x8210405C;
		  /* 8210405Ch */ case   40:  		/* bc 12, CR6_EQ, 40 */
		/* 8210405Ch case   40:*/		if ( regs.CR[6].eq ) { return 0x82104084;  }
		/* 8210405Ch case   40:*/		return 0x82104060;
		  /* 82104060h */ case   41:  		/* lwz R8, <#[R11 + 16]> */
		/* 82104060h case   41:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 82104060h case   41:*/		return 0x82104064;
		  /* 82104064h */ case   42:  		/* li R10, 0 */
		/* 82104064h case   42:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82104064h case   42:*/		return 0x82104068;
		  /* 82104068h */ case   43:  		/* lwzx R30, <#[R10 + R8]> */
		/* 82104068h case   43:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82104068h case   43:*/		return 0x8210406C;
		  /* 8210406Ch */ case   44:  		/* cmplw CR6, R30, R6 */
		/* 8210406Ch case   44:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R6);
		/* 8210406Ch case   44:*/		return 0x82104070;
		  /* 82104070h */ case   45:  		/* bc 12, CR6_EQ, 20 */
		/* 82104070h case   45:*/		if ( regs.CR[6].eq ) { return 0x82104084;  }
		/* 82104070h case   45:*/		return 0x82104074;
		  /* 82104074h */ case   46:  		/* addi R9, R9, 1 */
		/* 82104074h case   46:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82104074h case   46:*/		return 0x82104078;
		  /* 82104078h */ case   47:  		/* addi R10, R10, 4 */
		/* 82104078h case   47:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82104078h case   47:*/		return 0x8210407C;
		  /* 8210407Ch */ case   48:  		/* cmplw CR6, R9, R7 */
		/* 8210407Ch case   48:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8210407Ch case   48:*/		return 0x82104080;
		  /* 82104080h */ case   49:  		/* bc 12, CR6_LT, -24 */
		/* 82104080h case   49:*/		if ( regs.CR[6].lt ) { return 0x82104068;  }
		/* 82104080h case   49:*/		return 0x82104084;
	}
	return 0x82104084;
} // Block from 82103FBCh-82104084h (50 instructions)

//////////////////////////////////////////////////////
// Block at 82104084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104084);
		  /* 82104084h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82104084h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82104084h case    0:*/		return 0x82104088;
		  /* 82104088h */ case    1:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 82104088h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 82104088h case    1:*/		return 0x8210408C;
		  /* 8210408Ch */ case    2:  		/* lwz R9, <#[R24 + 20]> */
		/* 8210408Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000014) );
		/* 8210408Ch case    2:*/		return 0x82104090;
		  /* 82104090h */ case    3:  		/* cmpwi CR6, R31, -1 */
		/* 82104090h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 82104090h case    3:*/		return 0x82104094;
		  /* 82104094h */ case    4:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82104094h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82104094h case    4:*/		return 0x82104098;
		  /* 82104098h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82104098h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82104098h case    5:*/		return 0x8210409C;
		  /* 8210409Ch */ case    6:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210409Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210409Ch case    6:*/		return 0x821040A0;
		  /* 821040A0h */ case    7:  		/* lwz R30, <#[R11 + 48]> */
		/* 821040A0h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000030) );
		/* 821040A0h case    7:*/		return 0x821040A4;
		  /* 821040A4h */ case    8:  		/* bc 4, CR6_EQ, 76 */
		/* 821040A4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821040F0;  }
		/* 821040A4h case    8:*/		return 0x821040A8;
		  /* 821040A8h */ case    9:  		/* cmplw CR6, R20, R30 */
		/* 821040A8h case    9:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R30);
		/* 821040A8h case    9:*/		return 0x821040AC;
		  /* 821040ACh */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 821040ACh case   10:*/		if ( !regs.CR[6].eq ) { return 0x821040B8;  }
		/* 821040ACh case   10:*/		return 0x821040B0;
		  /* 821040B0h */ case   11:  		/* cmplw CR6, R19, R28 */
		/* 821040B0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R28);
		/* 821040B0h case   11:*/		return 0x821040B4;
		  /* 821040B4h */ case   12:  		/* bc 12, CR6_EQ, 44 */
		/* 821040B4h case   12:*/		if ( regs.CR[6].eq ) { return 0x821040E0;  }
		/* 821040B4h case   12:*/		return 0x821040B8;
	}
	return 0x821040B8;
} // Block from 82104084h-821040B8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821040B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821040B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821040B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821040B8);
		  /* 821040B8h */ case    0:  		/* cmplw CR6, R20, R28 */
		/* 821040B8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R28);
		/* 821040B8h case    0:*/		return 0x821040BC;
		  /* 821040BCh */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 821040BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821040C8;  }
		/* 821040BCh case    1:*/		return 0x821040C0;
		  /* 821040C0h */ case    2:  		/* cmplw CR6, R19, R30 */
		/* 821040C0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R30);
		/* 821040C0h case    2:*/		return 0x821040C4;
		  /* 821040C4h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 821040C4h case    3:*/		if ( regs.CR[6].eq ) { return 0x821040E8;  }
		/* 821040C4h case    3:*/		return 0x821040C8;
	}
	return 0x821040C8;
} // Block from 821040B8h-821040C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821040C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821040C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821040C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821040C8);
		  /* 821040C8h */ case    0:  		/* addi R29, R29, 1 */
		/* 821040C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821040C8h case    0:*/		return 0x821040CC;
		  /* 821040CCh */ case    1:  		/* add R5, R27, R5 */
		/* 821040CCh case    1:*/		cpu::op::add<0>(regs,&regs.R5,regs.R27,regs.R5);
		/* 821040CCh case    1:*/		return 0x821040D0;
		  /* 821040D0h */ case    2:  		/* add R4, R26, R4 */
		/* 821040D0h case    2:*/		cpu::op::add<0>(regs,&regs.R4,regs.R26,regs.R4);
		/* 821040D0h case    2:*/		return 0x821040D4;
		  /* 821040D4h */ case    3:  		/* cmplwi CR6, R29, 2 */
		/* 821040D4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000002);
		/* 821040D4h case    3:*/		return 0x821040D8;
		  /* 821040D8h */ case    4:  		/* bc 12, CR6_LT, -240 */
		/* 821040D8h case    4:*/		if ( regs.CR[6].lt ) { return 0x82103FE8;  }
		/* 821040D8h case    4:*/		return 0x821040DC;
		  /* 821040DCh */ case    5:  		/* b -1316 */
		/* 821040DCh case    5:*/		return 0x82103BB8;
		/* 821040DCh case    5:*/		return 0x821040E0;
	}
	return 0x821040E0;
} // Block from 821040C8h-821040E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821040E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821040E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821040E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821040E0);
		  /* 821040E0h */ case    0:  		/* lis R31, 8192 */
		/* 821040E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0x2000);
		/* 821040E0h case    0:*/		return 0x821040E4;
		  /* 821040E4h */ case    1:  		/* b 8 */
		/* 821040E4h case    1:*/		return 0x821040EC;
		/* 821040E4h case    1:*/		return 0x821040E8;
	}
	return 0x821040E8;
} // Block from 821040E0h-821040E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821040E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821040E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821040E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821040E8);
		  /* 821040E8h */ case    0:  		/* lis R31, 8208 */
		/* 821040E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0x2010);
		/* 821040E8h case    0:*/		return 0x821040EC;
	}
	return 0x821040EC;
} // Block from 821040E8h-821040ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821040ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821040EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821040EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821040EC);
		  /* 821040ECh */ case    0:  		/* ori R31, R31, 1 */
		/* 821040ECh case    0:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821040ECh case    0:*/		return 0x821040F0;
	}
	return 0x821040F0;
} // Block from 821040ECh-821040F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821040F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821040F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821040F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821040F0);
		  /* 821040F0h */ case    0:  		/* addi R3, R1, 80 */
		/* 821040F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821040F0h case    0:*/		return 0x821040F4;
		  /* 821040F4h */ case    1:  		/* bl -33364 */
		/* 821040F4h case    1:*/		regs.LR = 0x821040F8; return 0x820FBEA0;
		/* 821040F4h case    1:*/		return 0x821040F8;
		  /* 821040F8h */ case    2:  		/* li R7, 0 */
		/* 821040F8h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821040F8h case    2:*/		return 0x821040FC;
		  /* 821040FCh */ case    3:  		/* li R6, 1 */
		/* 821040FCh case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821040FCh case    3:*/		return 0x82104100;
		  /* 82104100h */ case    4:  		/* li R5, 2 */
		/* 82104100h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82104100h case    4:*/		return 0x82104104;
		  /* 82104104h */ case    5:  		/* mr R4, R31 */
		/* 82104104h case    5:*/		regs.R4 = regs.R31;
		/* 82104104h case    5:*/		return 0x82104108;
		  /* 82104108h */ case    6:  		/* addi R3, R1, 80 */
		/* 82104108h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82104108h case    6:*/		return 0x8210410C;
		  /* 8210410Ch */ case    7:  		/* bl -31452 */
		/* 8210410Ch case    7:*/		regs.LR = 0x82104110; return 0x820FC630;
		/* 8210410Ch case    7:*/		return 0x82104110;
		  /* 82104110h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 82104110h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82104110h case    8:*/		return 0x82104114;
		  /* 82104114h */ case    9:  		/* bc 12, CR0_LT, 72 */
		/* 82104114h case    9:*/		if ( regs.CR[0].lt ) { return 0x8210415C;  }
		/* 82104114h case    9:*/		return 0x82104118;
		  /* 82104118h */ case   10:  		/* mr R4, R17 */
		/* 82104118h case   10:*/		regs.R4 = regs.R17;
		/* 82104118h case   10:*/		return 0x8210411C;
		  /* 8210411Ch */ case   11:  		/* addi R3, R1, 80 */
		/* 8210411Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8210411Ch case   11:*/		return 0x82104120;
		  /* 82104120h */ case   12:  		/* bl -33328 */
		/* 82104120h case   12:*/		regs.LR = 0x82104124; return 0x820FBEF0;
		/* 82104120h case   12:*/		return 0x82104124;
		  /* 82104124h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 82104124h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82104124h case   13:*/		return 0x82104128;
		  /* 82104128h */ case   14:  		/* bc 12, CR0_LT, 52 */
		/* 82104128h case   14:*/		if ( regs.CR[0].lt ) { return 0x8210415C;  }
		/* 82104128h case   14:*/		return 0x8210412C;
		  /* 8210412Ch */ case   15:  		/* lwz R11, <#[R1 + 96]> */
		/* 8210412Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8210412Ch case   15:*/		return 0x82104130;
		  /* 82104130h */ case   16:  		/* mr R7, R30 */
		/* 82104130h case   16:*/		regs.R7 = regs.R30;
		/* 82104130h case   16:*/		return 0x82104134;
		  /* 82104134h */ case   17:  		/* mr R6, R28 */
		/* 82104134h case   17:*/		regs.R6 = regs.R28;
		/* 82104134h case   17:*/		return 0x82104138;
		  /* 82104138h */ case   18:  		/* mr R5, R18 */
		/* 82104138h case   18:*/		regs.R5 = regs.R18;
		/* 82104138h case   18:*/		return 0x8210413C;
		  /* 8210413Ch */ case   19:  		/* addi R4, R1, 80 */
		/* 8210413Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8210413Ch case   19:*/		return 0x82104140;
		  /* 82104140h */ case   20:  		/* mr R3, R24 */
		/* 82104140h case   20:*/		regs.R3 = regs.R24;
		/* 82104140h case   20:*/		return 0x82104144;
		  /* 82104144h */ case   21:  		/* stw R18, <#[R11]> */
		/* 82104144h case   21:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000000) );
		/* 82104144h case   21:*/		return 0x82104148;
		  /* 82104148h */ case   22:  		/* lwz R11, <#[R1 + 88]> */
		/* 82104148h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82104148h case   22:*/		return 0x8210414C;
		  /* 8210414Ch */ case   23:  		/* stw R28, <#[R11]> */
		/* 8210414Ch case   23:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 8210414Ch case   23:*/		return 0x82104150;
		  /* 82104150h */ case   24:  		/* lwz R11, <#[R1 + 88]> */
		/* 82104150h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82104150h case   24:*/		return 0x82104154;
		  /* 82104154h */ case   25:  		/* stw R30, <#[R11 + 4]> */
		/* 82104154h case   25:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 82104154h case   25:*/		return 0x82104158;
		  /* 82104158h */ case   26:  		/* bl -7048 */
		/* 82104158h case   26:*/		regs.LR = 0x8210415C; return 0x821025D0;
		/* 82104158h case   26:*/		return 0x8210415C;
	}
	return 0x8210415C;
} // Block from 821040F0h-8210415Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8210415Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210415C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210415C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210415C);
		  /* 8210415Ch */ case    0:  		/* mr R31, R3 */
		/* 8210415Ch case    0:*/		regs.R31 = regs.R3;
		/* 8210415Ch case    0:*/		return 0x82104160;
		  /* 82104160h */ case    1:  		/* addi R3, R1, 80 */
		/* 82104160h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82104160h case    1:*/		return 0x82104164;
		  /* 82104164h */ case    2:  		/* bl 1151580 */
		/* 82104164h case    2:*/		regs.LR = 0x82104168; return 0x8221D3C0;
		/* 82104164h case    2:*/		return 0x82104168;
		  /* 82104168h */ case    3:  		/* mr R3, R31 */
		/* 82104168h case    3:*/		regs.R3 = regs.R31;
		/* 82104168h case    3:*/		return 0x8210416C;
		  /* 8210416Ch */ case    4:  		/* b -1456 */
		/* 8210416Ch case    4:*/		return 0x82103BBC;
		/* 8210416Ch case    4:*/		return 0x82104170;
	}
	return 0x82104170;
} // Block from 8210415Ch-82104170h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82104170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104170);
		  /* 82104170h */ case    0:  		/* mfspr R12, LR */
		/* 82104170h case    0:*/		regs.R12 = regs.LR;
		/* 82104170h case    0:*/		return 0x82104174;
		  /* 82104174h */ case    1:  		/* bl -470848 */
		/* 82104174h case    1:*/		regs.LR = 0x82104178; return 0x82091234;
		/* 82104174h case    1:*/		return 0x82104178;
		  /* 82104178h */ case    2:  		/* stfd FR31, <#[R1 - 120]> */
		/* 82104178h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 82104178h case    2:*/		return 0x8210417C;
		  /* 8210417Ch */ case    3:  		/* stwu R1, <#[R1 - 208]> */
		/* 8210417Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 8210417Ch case    3:*/		return 0x82104180;
		  /* 82104180h */ case    4:  		/* lwz R10, <#[R4]> */
		/* 82104180h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82104180h case    4:*/		return 0x82104184;
		  /* 82104184h */ case    5:  		/* lis R11, 20480 */
		/* 82104184h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0x5000);
		/* 82104184h case    5:*/		return 0x82104188;
		  /* 82104188h */ case    6:  		/* mr R25, R3 */
		/* 82104188h case    6:*/		regs.R25 = regs.R3;
		/* 82104188h case    6:*/		return 0x8210418C;
		  /* 8210418Ch */ case    7:  		/* rlwinm R9, R10, 0, 0, 11 */
		/* 8210418Ch case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R10);
		/* 8210418Ch case    7:*/		return 0x82104190;
		  /* 82104190h */ case    8:  		/* mr R22, R4 */
		/* 82104190h case    8:*/		regs.R22 = regs.R4;
		/* 82104190h case    8:*/		return 0x82104194;
		  /* 82104194h */ case    9:  		/* mr R19, R5 */
		/* 82104194h case    9:*/		regs.R19 = regs.R5;
		/* 82104194h case    9:*/		return 0x82104198;
		  /* 82104198h */ case   10:  		/* cmplw CR6, R9, R11 */
		/* 82104198h case   10:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82104198h case   10:*/		return 0x8210419C;
		  /* 8210419Ch */ case   11:  		/* bc 4, CR6_EQ, 1840 */
		/* 8210419Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x821048CC;  }
		/* 8210419Ch case   11:*/		return 0x821041A0;
		  /* 821041A0h */ case   12:  		/* lwz R11, <#[R4 + 16]> */
		/* 821041A0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 821041A0h case   12:*/		return 0x821041A4;
		  /* 821041A4h */ case   13:  		/* lwz R9, <#[R3 + 20]> */
		/* 821041A4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 821041A4h case   13:*/		return 0x821041A8;
		  /* 821041A8h */ case   14:  		/* lwz R8, <#[R3 + 16]> */
		/* 821041A8h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 821041A8h case   14:*/		return 0x821041AC;
		  /* 821041ACh */ case   15:  		/* lwz R11, <#[R11]> */
		/* 821041ACh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821041ACh case   15:*/		return 0x821041B0;
		  /* 821041B0h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821041B0h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821041B0h case   16:*/		return 0x821041B4;
		  /* 821041B4h */ case   17:  		/* lwzx R24, <#[R11 + R9]> */
		/* 821041B4h case   17:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821041B4h case   17:*/		return 0x821041B8;
		  /* 821041B8h */ case   18:  		/* lwz R11, <#[R24 + 4]> */
		/* 821041B8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 821041B8h case   18:*/		return 0x821041BC;
		  /* 821041BCh */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821041BCh case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821041BCh case   19:*/		return 0x821041C0;
		  /* 821041C0h */ case   20:  		/* lwzx R11, <#[R11 + R8]> */
		/* 821041C0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 821041C0h case   20:*/		return 0x821041C4;
		  /* 821041C4h */ case   21:  		/* lwz R11, <#[R11 + 4]> */
		/* 821041C4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821041C4h case   21:*/		return 0x821041C8;
		  /* 821041C8h */ case   22:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821041C8h case   22:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821041C8h case   22:*/		return 0x821041CC;
		  /* 821041CCh */ case   23:  		/* bc 12, CR0_EQ, 1792 */
		/* 821041CCh case   23:*/		if ( regs.CR[0].eq ) { return 0x821048CC;  }
		/* 821041CCh case   23:*/		return 0x821041D0;
		  /* 821041D0h */ case   24:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 821041D0h case   24:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 821041D0h case   24:*/		return 0x821041D4;
		  /* 821041D4h */ case   25:  		/* bc 4, CR0_EQ, 1784 */
		/* 821041D4h case   25:*/		if ( !regs.CR[0].eq ) { return 0x821048CC;  }
		/* 821041D4h case   25:*/		return 0x821041D8;
		  /* 821041D8h */ case   26:  		/* rlwinm. R23, R10, 0, 12, 31 */
		/* 821041D8h case   26:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R23,regs.R10);
		/* 821041D8h case   26:*/		return 0x821041DC;
		  /* 821041DCh */ case   27:  		/* li R21, 0 */
		/* 821041DCh case   27:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 821041DCh case   27:*/		return 0x821041E0;
		  /* 821041E0h */ case   28:  		/* li R3, 14 */
		/* 821041E0h case   28:*/		cpu::op::li<0>(regs,&regs.R3,0xE);
		/* 821041E0h case   28:*/		return 0x821041E4;
		  /* 821041E4h */ case   29:  		/* bc 12, CR0_EQ, 224 */
		/* 821041E4h case   29:*/		if ( regs.CR[0].eq ) { return 0x821042C4;  }
		/* 821041E4h case   29:*/		return 0x821041E8;
		  /* 821041E8h */ case   30:  		/* lwz R7, <#[R4 + 8]> */
		/* 821041E8h case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000008) );
		/* 821041E8h case   30:*/		return 0x821041EC;
		  /* 821041ECh */ case   31:  		/* mr R9, R21 */
		/* 821041ECh case   31:*/		regs.R9 = regs.R21;
		/* 821041ECh case   31:*/		return 0x821041F0;
		  /* 821041F0h */ case   32:  		/* mtspr CTR, R23 */
		/* 821041F0h case   32:*/		regs.CTR = regs.R23;
		/* 821041F0h case   32:*/		return 0x821041F4;
		  /* 821041F4h */ case   33:  		/* rlwinm R8, R23, 2, 0, 29 */
		/* 821041F4h case   33:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R23);
		/* 821041F4h case   33:*/		return 0x821041F8;
		  /* 821041F8h */ case   34:  		/* lwzx R11, <#[R9 + R7]> */
		/* 821041F8h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 821041F8h case   34:*/		return 0x821041FC;
		  /* 821041FCh */ case   35:  		/* cmpwi CR6, R19, 0 */
		/* 821041FCh case   35:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 821041FCh case   35:*/		return 0x82104200;
		  /* 82104200h */ case   36:  		/* lwzx R10, <#[R8 + R7]> */
		/* 82104200h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 82104200h case   36:*/		return 0x82104204;
		  /* 82104204h */ case   37:  		/* lwz R6, <#[R25 + 20]> */
		/* 82104204h case   37:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R25 + 0x00000014) );
		/* 82104204h case   37:*/		return 0x82104208;
		  /* 82104208h */ case   38:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82104208h case   38:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82104208h case   38:*/		return 0x8210420C;
		  /* 8210420Ch */ case   39:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210420Ch case   39:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210420Ch case   39:*/		return 0x82104210;
		  /* 82104210h */ case   40:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82104210h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82104210h case   40:*/		return 0x82104214;
		  /* 82104214h */ case   41:  		/* lwzx R10, <#[R10 + R6]> */
		/* 82104214h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82104214h case   41:*/		return 0x82104218;
		  /* 82104218h */ case   42:  		/* bc 12, CR6_EQ, 28 */
		/* 82104218h case   42:*/		if ( regs.CR[6].eq ) { return 0x82104234;  }
		/* 82104218h case   42:*/		return 0x8210421C;
		  /* 8210421Ch */ case   43:  		/* lwz R11, <#[R11 + 48]> */
		/* 8210421Ch case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 8210421Ch case   43:*/		return 0x82104220;
		  /* 82104220h */ case   44:  		/* lwz R10, <#[R10 + 48]> */
		/* 82104220h case   44:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 82104220h case   44:*/		return 0x82104224;
		  /* 82104224h */ case   45:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82104224h case   45:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82104224h case   45:*/		return 0x82104228;
		  /* 82104228h */ case   46:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82104228h case   46:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82104228h case   46:*/		return 0x8210422C;
		  /* 8210422Ch */ case   47:  		/* lwzx R11, <#[R11 + R6]> */
		/* 8210422Ch case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210422Ch case   47:*/		return 0x82104230;
		  /* 82104230h */ case   48:  		/* lwzx R10, <#[R10 + R6]> */
		/* 82104230h case   48:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82104230h case   48:*/		return 0x82104234;
	}
	return 0x82104234;
} // Block from 82104170h-82104234h (49 instructions)

//////////////////////////////////////////////////////
// Block at 82104234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104234);
		  /* 82104234h */ case    0:  		/* lwz R5, <#[R11]> */
		/* 82104234h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 82104234h case    0:*/		return 0x82104238;
		  /* 82104238h */ case    1:  		/* mr R4, R21 */
		/* 82104238h case    1:*/		regs.R4 = regs.R21;
		/* 82104238h case    1:*/		return 0x8210423C;
		  /* 8210423Ch */ case    2:  		/* rlwinm. R6, R5, 0, 29, 29 */
		/* 8210423Ch case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R6,regs.R5);
		/* 8210423Ch case    2:*/		return 0x82104240;
		  /* 82104240h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 82104240h case    3:*/		if ( regs.CR[0].eq ) { return 0x82104250;  }
		/* 82104240h case    3:*/		return 0x82104244;
		  /* 82104244h */ case    4:  		/* lwz R31, <#[R10]> */
		/* 82104244h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000000) );
		/* 82104244h case    4:*/		return 0x82104248;
		  /* 82104248h */ case    5:  		/* rlwinm. R31, R31, 0, 29, 29 */
		/* 82104248h case    5:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R31,regs.R31);
		/* 82104248h case    5:*/		return 0x8210424C;
		  /* 8210424Ch */ case    6:  		/* bc 4, CR0_EQ, 32 */
		/* 8210424Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x8210426C;  }
		/* 8210424Ch case    6:*/		return 0x82104250;
	}
	return 0x82104250;
} // Block from 82104234h-82104250h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82104250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104250);
		  /* 82104250h */ case    0:  		/* rlwinm. R31, R5, 0, 28, 28 */
		/* 82104250h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R31,regs.R5);
		/* 82104250h case    0:*/		return 0x82104254;
		  /* 82104254h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82104254h case    1:*/		if ( regs.CR[0].eq ) { return 0x82104264;  }
		/* 82104254h case    1:*/		return 0x82104258;
		  /* 82104258h */ case    2:  		/* lwz R31, <#[R10]> */
		/* 82104258h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000000) );
		/* 82104258h case    2:*/		return 0x8210425C;
		  /* 8210425Ch */ case    3:  		/* rlwinm. R31, R31, 0, 28, 28 */
		/* 8210425Ch case    3:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R31,regs.R31);
		/* 8210425Ch case    3:*/		return 0x82104260;
		  /* 82104260h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 82104260h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8210426C;  }
		/* 82104260h case    4:*/		return 0x82104264;
	}
	return 0x82104264;
} // Block from 82104250h-82104264h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82104264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104264);
		  /* 82104264h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 82104264h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82104264h case    0:*/		return 0x82104268;
		  /* 82104268h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82104268h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82104270;  }
		/* 82104268h case    1:*/		return 0x8210426C;
	}
	return 0x8210426C;
} // Block from 82104264h-8210426Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210426Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210426C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210426C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210426C);
		  /* 8210426Ch */ case    0:  		/* li R4, 4 */
		/* 8210426Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 8210426Ch case    0:*/		return 0x82104270;
	}
	return 0x82104270;
} // Block from 8210426Ch-82104270h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82104270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104270);
		  /* 82104270h */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 82104270h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82104270h case    0:*/		return 0x82104274;
		  /* 82104274h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 82104274h case    1:*/		if ( regs.CR[6].eq ) { return 0x82104284;  }
		/* 82104274h case    1:*/		return 0x82104278;
		  /* 82104278h */ case    2:  		/* lwz R11, <#[R10]> */
		/* 82104278h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82104278h case    2:*/		return 0x8210427C;
		  /* 8210427Ch */ case    3:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 8210427Ch case    3:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 8210427Ch case    3:*/		return 0x82104280;
		  /* 82104280h */ case    4:  		/* bc 4, CR0_EQ, 24 */
		/* 82104280h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82104298;  }
		/* 82104280h case    4:*/		return 0x82104284;
	}
	return 0x82104284;
} // Block from 82104270h-82104284h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82104284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104284);
		  /* 82104284h */ case    0:  		/* rlwinm. R11, R5, 0, 28, 28 */
		/* 82104284h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R5);
		/* 82104284h case    0:*/		return 0x82104288;
		  /* 82104288h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82104288h case    1:*/		if ( regs.CR[0].eq ) { return 0x8210429C;  }
		/* 82104288h case    1:*/		return 0x8210428C;
		  /* 8210428Ch */ case    2:  		/* lwz R11, <#[R10]> */
		/* 8210428Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8210428Ch case    2:*/		return 0x82104290;
		  /* 82104290h */ case    3:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 82104290h case    3:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 82104290h case    3:*/		return 0x82104294;
		  /* 82104294h */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 82104294h case    4:*/		if ( regs.CR[0].eq ) { return 0x8210429C;  }
		/* 82104294h case    4:*/		return 0x82104298;
	}
	return 0x82104298;
} // Block from 82104284h-82104298h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82104298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104298);
		  /* 82104298h */ case    0:  		/* ori R4, R4, 8 */
		/* 82104298h case    0:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x8);
		/* 82104298h case    0:*/		return 0x8210429C;
	}
	return 0x8210429C;
} // Block from 82104298h-8210429Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210429Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210429C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210429C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210429C);
		  /* 8210429Ch */ case    0:  		/* rlwinm. R11, R5, 0, 30, 30 */
		/* 8210429Ch case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R5);
		/* 8210429Ch case    0:*/		return 0x821042A0;
		  /* 821042A0h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821042A0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821042B4;  }
		/* 821042A0h case    1:*/		return 0x821042A4;
		  /* 821042A4h */ case    2:  		/* lwz R11, <#[R10]> */
		/* 821042A4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821042A4h case    2:*/		return 0x821042A8;
		  /* 821042A8h */ case    3:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 821042A8h case    3:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 821042A8h case    3:*/		return 0x821042AC;
		  /* 821042ACh */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 821042ACh case    4:*/		if ( regs.CR[0].eq ) { return 0x821042B4;  }
		/* 821042ACh case    4:*/		return 0x821042B0;
		  /* 821042B0h */ case    5:  		/* ori R4, R4, 2 */
		/* 821042B0h case    5:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x2);
		/* 821042B0h case    5:*/		return 0x821042B4;
	}
	return 0x821042B4;
} // Block from 8210429Ch-821042B4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821042B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821042B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821042B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821042B4);
		  /* 821042B4h */ case    0:  		/* and R3, R4, R3 */
		/* 821042B4h case    0:*/		cpu::op::and<0>(regs,&regs.R3,regs.R4,regs.R3);
		/* 821042B4h case    0:*/		return 0x821042B8;
		  /* 821042B8h */ case    1:  		/* addi R9, R9, 4 */
		/* 821042B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821042B8h case    1:*/		return 0x821042BC;
		  /* 821042BCh */ case    2:  		/* addi R8, R8, 4 */
		/* 821042BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 821042BCh case    2:*/		return 0x821042C0;
		  /* 821042C0h */ case    3:  		/* bc 16, CR0_LT, -200 */
		/* 821042C0h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821041F8;  }
		/* 821042C0h case    3:*/		return 0x821042C4;
	}
	return 0x821042C4;
} // Block from 821042B4h-821042C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821042C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821042C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821042C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821042C4);
		  /* 821042C4h */ case    0:  		/* lwz R11, <#[R24]> */
		/* 821042C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821042C4h case    0:*/		return 0x821042C8;
		  /* 821042C8h */ case    1:  		/* lis R10, -32256 */
		/* 821042C8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 821042C8h case    1:*/		return 0x821042CC;
		  /* 821042CCh */ case    2:  		/* lis R9, -32256 */
		/* 821042CCh case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 821042CCh case    2:*/		return 0x821042D0;
		  /* 821042D0h */ case    3:  		/* or R11, R11, R3 */
		/* 821042D0h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 821042D0h case    3:*/		return 0x821042D4;
		  /* 821042D4h */ case    4:  		/* li R20, 1 */
		/* 821042D4h case    4:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 821042D4h case    4:*/		return 0x821042D8;
		  /* 821042D8h */ case    5:  		/* cmpwi CR6, R19, 0 */
		/* 821042D8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 821042D8h case    5:*/		return 0x821042DC;
		  /* 821042DCh */ case    6:  		/* stw R11, <#[R24]> */
		/* 821042DCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821042DCh case    6:*/		return 0x821042E0;
		  /* 821042E0h */ case    7:  		/* lfd FR31, <#[R10 + 1848]> */
		/* 821042E0h case    7:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000738) );
		/* 821042E0h case    7:*/		return 0x821042E4;
		  /* 821042E4h */ case    8:  		/* lfd FR0, <#[R9 + 1808]> */
		/* 821042E4h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000710) );
		/* 821042E4h case    8:*/		return 0x821042E8;
		  /* 821042E8h */ case    9:  		/* bc 12, CR6_EQ, 448 */
		/* 821042E8h case    9:*/		if ( regs.CR[6].eq ) { return 0x821044A8;  }
		/* 821042E8h case    9:*/		return 0x821042EC;
		  /* 821042ECh */ case   10:  		/* fmr FR1, FR0 */
		/* 821042ECh case   10:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR0);
		/* 821042ECh case   10:*/		return 0x821042F0;
		  /* 821042F0h */ case   11:  		/* mr R27, R21 */
		/* 821042F0h case   11:*/		regs.R27 = regs.R21;
		/* 821042F0h case   11:*/		return 0x821042F4;
		  /* 821042F4h */ case   12:  		/* li R26, -1 */
		/* 821042F4h case   12:*/		cpu::op::li<0>(regs,&regs.R26,0xFFFFFFFF);
		/* 821042F4h case   12:*/		return 0x821042F8;
		  /* 821042F8h */ case   13:  		/* mr R29, R21 */
		/* 821042F8h case   13:*/		regs.R29 = regs.R21;
		/* 821042F8h case   13:*/		return 0x821042FC;
		  /* 821042FCh */ case   14:  		/* mr R28, R21 */
		/* 821042FCh case   14:*/		regs.R28 = regs.R21;
		/* 821042FCh case   14:*/		return 0x82104300;
		  /* 82104300h */ case   15:  		/* cmplwi CR6, R23, 0 */
		/* 82104300h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82104300h case   15:*/		return 0x82104304;
		  /* 82104304h */ case   16:  		/* bc 12, CR6_EQ, 356 */
		/* 82104304h case   16:*/		if ( regs.CR[6].eq ) { return 0x82104468;  }
		/* 82104304h case   16:*/		return 0x82104308;
		  /* 82104308h */ case   17:  		/* lwz R31, <#[R22 + 8]> */
		/* 82104308h case   17:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R22 + 0x00000008) );
		/* 82104308h case   17:*/		return 0x8210430C;
		  /* 8210430Ch */ case   18:  		/* mr R4, R21 */
		/* 8210430Ch case   18:*/		regs.R4 = regs.R21;
		/* 8210430Ch case   18:*/		return 0x82104310;
		  /* 82104310h */ case   19:  		/* lwz R11, <#[R25 + 20]> */
		/* 82104310h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000014) );
		/* 82104310h case   19:*/		return 0x82104314;
		  /* 82104314h */ case   20:  		/* rlwinm R3, R23, 2, 0, 29 */
		/* 82104314h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R23);
		/* 82104314h case   20:*/		return 0x82104318;
		  /* 82104318h */ case   21:  		/* lwz R30, <#[R25 + 16]> */
		/* 82104318h case   21:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R25 + 0x00000010) );
		/* 82104318h case   21:*/		return 0x8210431C;
		  /* 8210431Ch */ case   22:  		/* lwzx R10, <#[R4 + R31]> */
		/* 8210431Ch case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + regs.R31 + 0x00000000) );
		/* 8210431Ch case   22:*/		return 0x82104320;
		  /* 82104320h */ case   23:  		/* lwzx R9, <#[R3 + R31]> */
		/* 82104320h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + regs.R31 + 0x00000000) );
		/* 82104320h case   23:*/		return 0x82104324;
		  /* 82104324h */ case   24:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82104324h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82104324h case   24:*/		return 0x82104328;
		  /* 82104328h */ case   25:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82104328h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82104328h case   25:*/		return 0x8210432C;
		  /* 8210432Ch */ case   26:  		/* lwzx R10, <#[R10 + R11]> */
		/* 8210432Ch case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210432Ch case   26:*/		return 0x82104330;
		  /* 82104330h */ case   27:  		/* lwzx R9, <#[R9 + R11]> */
		/* 82104330h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82104330h case   27:*/		return 0x82104334;
		  /* 82104334h */ case   28:  		/* lwz R8, <#[R10 + 48]> */
		/* 82104334h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000030) );
		/* 82104334h case   28:*/		return 0x82104338;
		  /* 82104338h */ case   29:  		/* lwz R7, <#[R9 + 48]> */
		/* 82104338h case   29:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000030) );
		/* 82104338h case   29:*/		return 0x8210433C;
		  /* 8210433Ch */ case   30:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 8210433Ch case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 8210433Ch case   30:*/		return 0x82104340;
		  /* 82104340h */ case   31:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 82104340h case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 82104340h case   31:*/		return 0x82104344;
		  /* 82104344h */ case   32:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82104344h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82104344h case   32:*/		return 0x82104348;
		  /* 82104348h */ case   33:  		/* lwzx R6, <#[R9 + R11]> */
		/* 82104348h case   33:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82104348h case   33:*/		return 0x8210434C;
		  /* 8210434Ch */ case   34:  		/* lwz R9, <#[R10 + 4]> */
		/* 8210434Ch case   34:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8210434Ch case   34:*/		return 0x82104350;
		  /* 82104350h */ case   35:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82104350h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82104350h case   35:*/		return 0x82104354;
		  /* 82104354h */ case   36:  		/* lwzx R9, <#[R9 + R30]> */
		/* 82104354h case   36:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82104354h case   36:*/		return 0x82104358;
		  /* 82104358h */ case   37:  		/* lwz R9, <#[R9 + 4]> */
		/* 82104358h case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82104358h case   37:*/		return 0x8210435C;
		  /* 8210435Ch */ case   38:  		/* rlwinm. R9, R9, 0, 23, 23 */
		/* 8210435Ch case   38:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R9);
		/* 8210435Ch case   38:*/		return 0x82104360;
		  /* 82104360h */ case   39:  		/* bc 12, CR0_EQ, 20 */
		/* 82104360h case   39:*/		if ( regs.CR[0].eq ) { return 0x82104374;  }
		/* 82104360h case   39:*/		return 0x82104364;
		  /* 82104364h */ case   40:  		/* lwz R9, <#[R10 + 8]> */
		/* 82104364h case   40:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 82104364h case   40:*/		return 0x82104368;
		  /* 82104368h */ case   41:  		/* mr R5, R20 */
		/* 82104368h case   41:*/		regs.R5 = regs.R20;
		/* 82104368h case   41:*/		return 0x8210436C;
		  /* 8210436Ch */ case   42:  		/* cmpwi CR6, R9, -1 */
		/* 8210436Ch case   42:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 8210436Ch case   42:*/		return 0x82104370;
		  /* 82104370h */ case   43:  		/* bc 12, CR6_EQ, 8 */
		/* 82104370h case   43:*/		if ( regs.CR[6].eq ) { return 0x82104378;  }
		/* 82104370h case   43:*/		return 0x82104374;
	}
	return 0x82104374;
} // Block from 821042C4h-82104374h (44 instructions)

//////////////////////////////////////////////////////
// Block at 82104374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104374);
		  /* 82104374h */ case    0:  		/* mr R5, R21 */
		/* 82104374h case    0:*/		regs.R5 = regs.R21;
		/* 82104374h case    0:*/		return 0x82104378;
	}
	return 0x82104378;
} // Block from 82104374h-82104378h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82104378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104378);
		  /* 82104378h */ case    0:  		/* lwz R9, <#[R6 + 4]> */
		/* 82104378h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000004) );
		/* 82104378h case    0:*/		return 0x8210437C;
		  /* 8210437Ch */ case    1:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210437Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210437Ch case    1:*/		return 0x82104380;
		  /* 82104380h */ case    2:  		/* lwzx R9, <#[R9 + R30]> */
		/* 82104380h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82104380h case    2:*/		return 0x82104384;
		  /* 82104384h */ case    3:  		/* lwz R9, <#[R9 + 4]> */
		/* 82104384h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82104384h case    3:*/		return 0x82104388;
		  /* 82104388h */ case    4:  		/* rlwinm. R9, R9, 0, 23, 23 */
		/* 82104388h case    4:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R9);
		/* 82104388h case    4:*/		return 0x8210438C;
		  /* 8210438Ch */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 8210438Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x821043A0;  }
		/* 8210438Ch case    5:*/		return 0x82104390;
		  /* 82104390h */ case    6:  		/* lwz R9, <#[R6 + 8]> */
		/* 82104390h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000008) );
		/* 82104390h case    6:*/		return 0x82104394;
		  /* 82104394h */ case    7:  		/* cmpwi CR6, R9, -1 */
		/* 82104394h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82104394h case    7:*/		return 0x82104398;
		  /* 82104398h */ case    8:  		/* mr R9, R20 */
		/* 82104398h case    8:*/		regs.R9 = regs.R20;
		/* 82104398h case    8:*/		return 0x8210439C;
		  /* 8210439Ch */ case    9:  		/* bc 12, CR6_EQ, 8 */
		/* 8210439Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x821043A4;  }
		/* 8210439Ch case    9:*/		return 0x821043A0;
	}
	return 0x821043A0;
} // Block from 82104378h-821043A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821043A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821043A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821043A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821043A0);
		  /* 821043A0h */ case    0:  		/* mr R9, R21 */
		/* 821043A0h case    0:*/		regs.R9 = regs.R21;
		/* 821043A0h case    0:*/		return 0x821043A4;
	}
	return 0x821043A4;
} // Block from 821043A0h-821043A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821043A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821043A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821043A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821043A4);
		  /* 821043A4h */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 821043A4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 821043A4h case    0:*/		return 0x821043A8;
		  /* 821043A8h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 821043A8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821043B8;  }
		/* 821043A8h case    1:*/		return 0x821043AC;
		  /* 821043ACh */ case    2:  		/* lfd FR13, <#[R10 + 32]> */
		/* 821043ACh case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000020) );
		/* 821043ACh case    2:*/		return 0x821043B0;
		  /* 821043B0h */ case    3:  		/* fcmpu CR6, FR13, FR0 */
		/* 821043B0h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821043B0h case    3:*/		return 0x821043B4;
		  /* 821043B4h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 821043B4h case    4:*/		if ( regs.CR[6].eq ) { return 0x821043CC;  }
		/* 821043B4h case    4:*/		return 0x821043B8;
	}
	return 0x821043B8;
} // Block from 821043A4h-821043B8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821043B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821043B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821043B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821043B8);
		  /* 821043B8h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 821043B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 821043B8h case    0:*/		return 0x821043BC;
		  /* 821043BCh */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821043BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821043D4;  }
		/* 821043BCh case    1:*/		return 0x821043C0;
		  /* 821043C0h */ case    2:  		/* lfd FR13, <#[R6 + 32]> */
		/* 821043C0h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R6 + 0x00000020) );
		/* 821043C0h case    2:*/		return 0x821043C4;
		  /* 821043C4h */ case    3:  		/* fcmpu CR6, FR13, FR0 */
		/* 821043C4h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821043C4h case    3:*/		return 0x821043C8;
		  /* 821043C8h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 821043C8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821043D4;  }
		/* 821043C8h case    4:*/		return 0x821043CC;
	}
	return 0x821043CC;
} // Block from 821043B8h-821043CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821043CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821043CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821043CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821043CC);
		  /* 821043CCh */ case    0:  		/* addi R27, R27, 1 */
		/* 821043CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821043CCh case    0:*/		return 0x821043D0;
		  /* 821043D0h */ case    1:  		/* b 88 */
		/* 821043D0h case    1:*/		return 0x82104428;
		/* 821043D0h case    1:*/		return 0x821043D4;
	}
	return 0x821043D4;
} // Block from 821043CCh-821043D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821043D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821043D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821043D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821043D4);
		  /* 821043D4h */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 821043D4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 821043D4h case    0:*/		return 0x821043D8;
		  /* 821043D8h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 821043D8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210440C;  }
		/* 821043D8h case    1:*/		return 0x821043DC;
		  /* 821043DCh */ case    2:  		/* cmpwi CR6, R9, 0 */
		/* 821043DCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 821043DCh case    2:*/		return 0x821043E0;
		  /* 821043E0h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 821043E0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821043F8;  }
		/* 821043E0h case    3:*/		return 0x821043E4;
		  /* 821043E4h */ case    4:  		/* lfd FR13, <#[R6 + 32]> */
		/* 821043E4h case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R6 + 0x00000020) );
		/* 821043E4h case    4:*/		return 0x821043E8;
		  /* 821043E8h */ case    5:  		/* addi R27, R27, 1 */
		/* 821043E8h case    5:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821043E8h case    5:*/		return 0x821043EC;
		  /* 821043ECh */ case    6:  		/* lfd FR12, <#[R10 + 32]> */
		/* 821043ECh case    6:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R10 + 0x00000020) );
		/* 821043ECh case    6:*/		return 0x821043F0;
		  /* 821043F0h */ case    7:  		/* fmadd FR1, FR13, FR12, FR1 */
		/* 821043F0h case    7:*/		cpu::op::fmadd<0>(regs,&regs.FR1,regs.FR13,regs.FR12,regs.FR1);
		/* 821043F0h case    7:*/		return 0x821043F4;
		  /* 821043F4h */ case    8:  		/* b 52 */
		/* 821043F4h case    8:*/		return 0x82104428;
		/* 821043F4h case    8:*/		return 0x821043F8;
	}
	return 0x821043F8;
} // Block from 821043D4h-821043F8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821043F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821043F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821043F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821043F8);
		  /* 821043F8h */ case    0:  		/* lfd FR13, <#[R10 + 32]> */
		/* 821043F8h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000020) );
		/* 821043F8h case    0:*/		return 0x821043FC;
		  /* 821043FCh */ case    1:  		/* fcmpu CR6, FR13, FR31 */
		/* 821043FCh case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 821043FCh case    1:*/		return 0x82104400;
		  /* 82104400h */ case    2:  		/* bc 4, CR6_EQ, 60 */
		/* 82104400h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8210443C;  }
		/* 82104400h case    2:*/		return 0x82104404;
		  /* 82104404h */ case    3:  		/* mr R26, R7 */
		/* 82104404h case    3:*/		regs.R26 = regs.R7;
		/* 82104404h case    3:*/		return 0x82104408;
		  /* 82104408h */ case    4:  		/* b 28 */
		/* 82104408h case    4:*/		return 0x82104424;
		/* 82104408h case    4:*/		return 0x8210440C;
	}
	return 0x8210440C;
} // Block from 821043F8h-8210440Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210440Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210440C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210440C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210440C);
		  /* 8210440Ch */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 8210440Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8210440Ch case    0:*/		return 0x82104410;
		  /* 82104410h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 82104410h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210443C;  }
		/* 82104410h case    1:*/		return 0x82104414;
		  /* 82104414h */ case    2:  		/* lfd FR13, <#[R6 + 32]> */
		/* 82104414h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R6 + 0x00000020) );
		/* 82104414h case    2:*/		return 0x82104418;
		  /* 82104418h */ case    3:  		/* fcmpu CR6, FR13, FR31 */
		/* 82104418h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 82104418h case    3:*/		return 0x8210441C;
		  /* 8210441Ch */ case    4:  		/* bc 4, CR6_EQ, 32 */
		/* 8210441Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x8210443C;  }
		/* 8210441Ch case    4:*/		return 0x82104420;
		  /* 82104420h */ case    5:  		/* mr R26, R8 */
		/* 82104420h case    5:*/		regs.R26 = regs.R8;
		/* 82104420h case    5:*/		return 0x82104424;
	}
	return 0x82104424;
} // Block from 8210440Ch-82104424h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82104424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104424);
		  /* 82104424h */ case    0:  		/* addi R29, R29, 1 */
		/* 82104424h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82104424h case    0:*/		return 0x82104428;
	}
	return 0x82104428;
} // Block from 82104424h-82104428h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82104428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104428);
		  /* 82104428h */ case    0:  		/* addi R28, R28, 1 */
		/* 82104428h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82104428h case    0:*/		return 0x8210442C;
		  /* 8210442Ch */ case    1:  		/* addi R4, R4, 4 */
		/* 8210442Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 8210442Ch case    1:*/		return 0x82104430;
		  /* 82104430h */ case    2:  		/* addi R3, R3, 4 */
		/* 82104430h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82104430h case    2:*/		return 0x82104434;
		  /* 82104434h */ case    3:  		/* cmplw CR6, R28, R23 */
		/* 82104434h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R23);
		/* 82104434h case    3:*/		return 0x82104438;
		  /* 82104438h */ case    4:  		/* bc 12, CR6_LT, -284 */
		/* 82104438h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210431C;  }
		/* 82104438h case    4:*/		return 0x8210443C;
	}
	return 0x8210443C;
} // Block from 82104428h-8210443Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210443Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210443C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210443C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210443C);
		  /* 8210443Ch */ case    0:  		/* cmplwi CR6, R29, 1 */
		/* 8210443Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000001);
		/* 8210443Ch case    0:*/		return 0x82104440;
		  /* 82104440h */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 82104440h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82104468;  }
		/* 82104440h case    1:*/		return 0x82104444;
		  /* 82104444h */ case    2:  		/* addi R11, R23, -1 */
		/* 82104444h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R23,0xFFFFFFFF);
		/* 82104444h case    2:*/		return 0x82104448;
		  /* 82104448h */ case    3:  		/* cmplw CR6, R11, R27 */
		/* 82104448h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 82104448h case    3:*/		return 0x8210444C;
		  /* 8210444Ch */ case    4:  		/* bc 4, CR6_EQ, 28 */
		/* 8210444Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82104468;  }
		/* 8210444Ch case    4:*/		return 0x82104450;
		  /* 82104450h */ case    5:  		/* fcmpu CR6, FR1, FR0 */
		/* 82104450h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82104450h case    5:*/		return 0x82104454;
		  /* 82104454h */ case    6:  		/* bc 4, CR6_EQ, 20 */
		/* 82104454h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82104468;  }
		/* 82104454h case    6:*/		return 0x82104458;
		  /* 82104458h */ case    7:  		/* stw R21, <#[R22]> */
		/* 82104458h case    7:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R22 + 0x00000000) );
		/* 82104458h case    7:*/		return 0x8210445C;
		  /* 8210445Ch */ case    8:  		/* li R3, 0 */
		/* 8210445Ch case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210445Ch case    8:*/		return 0x82104460;
		  /* 82104460h */ case    9:  		/* stw R26, <#[R24 + 48]> */
		/* 82104460h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R24 + 0x00000030) );
		/* 82104460h case    9:*/		return 0x82104464;
		  /* 82104464h */ case   10:  		/* b 1132 */
		/* 82104464h case   10:*/		return 0x821048D0;
		/* 82104464h case   10:*/		return 0x82104468;
	}
	return 0x82104468;
} // Block from 8210443Ch-82104468h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82104468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104468);
		  /* 82104468h */ case    0:  		/* cmplw CR6, R23, R27 */
		/* 82104468h case    0:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R27);
		/* 82104468h case    0:*/		return 0x8210446C;
		  /* 8210446Ch */ case    1:  		/* bc 4, CR6_EQ, 60 */
		/* 8210446Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821044A8;  }
		/* 8210446Ch case    1:*/		return 0x82104470;
		  /* 82104470h */ case    2:  		/* stw R21, <#[R22]> */
		/* 82104470h case    2:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R22 + 0x00000000) );
		/* 82104470h case    2:*/		return 0x82104474;
		  /* 82104474h */ case    3:  		/* li R6, 0 */
		/* 82104474h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82104474h case    3:*/		return 0x82104478;
		  /* 82104478h */ case    4:  		/* li R5, 0 */
		/* 82104478h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82104478h case    4:*/		return 0x8210447C;
		  /* 8210447Ch */ case    5:  		/* lwz R4, <#[R25 + 120]> */
		/* 8210447Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x00000078) );
		/* 8210447Ch case    5:*/		return 0x82104480;
		  /* 82104480h */ case    6:  		/* mr R3, R25 */
		/* 82104480h case    6:*/		regs.R3 = regs.R25;
		/* 82104480h case    6:*/		return 0x82104484;
		  /* 82104484h */ case    7:  		/* bl -29276 */
		/* 82104484h case    7:*/		regs.LR = 0x82104488; return 0x820FD228;
		/* 82104484h case    7:*/		return 0x82104488;
		  /* 82104488h */ case    8:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82104488h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82104488h case    8:*/		return 0x8210448C;
		  /* 8210448Ch */ case    9:  		/* stw R3, <#[R24 + 48]> */
		/* 8210448Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R24 + 0x00000030) );
		/* 8210448Ch case    9:*/		return 0x82104490;
		  /* 82104490h */ case   10:  		/* mr R11, R3 */
		/* 82104490h case   10:*/		regs.R11 = regs.R3;
		/* 82104490h case   10:*/		return 0x82104494;
		  /* 82104494h */ case   11:  		/* lwz R9, <#[R25 + 20]> */
		/* 82104494h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000014) );
		/* 82104494h case   11:*/		return 0x82104498;
		  /* 82104498h */ case   12:  		/* li R3, 0 */
		/* 82104498h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82104498h case   12:*/		return 0x8210449C;
		  /* 8210449Ch */ case   13:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210449Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210449Ch case   13:*/		return 0x821044A0;
		  /* 821044A0h */ case   14:  		/* stw R11, <#[R10 + 48]> */
		/* 821044A0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000030) );
		/* 821044A0h case   14:*/		return 0x821044A4;
		  /* 821044A4h */ case   15:  		/* b 1068 */
		/* 821044A4h case   15:*/		return 0x821048D0;
		/* 821044A4h case   15:*/		return 0x821044A8;
	}
	return 0x821044A8;
} // Block from 82104468h-821044A8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821044A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821044A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821044A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821044A8);
		  /* 821044A8h */ case    0:  		/* mr R4, R21 */
		/* 821044A8h case    0:*/		regs.R4 = regs.R21;
		/* 821044A8h case    0:*/		return 0x821044AC;
		  /* 821044ACh */ case    1:  		/* mr R3, R21 */
		/* 821044ACh case    1:*/		regs.R3 = regs.R21;
		/* 821044ACh case    1:*/		return 0x821044B0;
		  /* 821044B0h */ case    2:  		/* mr R5, R21 */
		/* 821044B0h case    2:*/		regs.R5 = regs.R21;
		/* 821044B0h case    2:*/		return 0x821044B4;
		  /* 821044B4h */ case    3:  		/* mr R31, R21 */
		/* 821044B4h case    3:*/		regs.R31 = regs.R21;
		/* 821044B4h case    3:*/		return 0x821044B8;
		  /* 821044B8h */ case    4:  		/* cmplwi CR6, R23, 0 */
		/* 821044B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 821044B8h case    4:*/		return 0x821044BC;
		  /* 821044BCh */ case    5:  		/* bc 12, CR6_EQ, 600 */
		/* 821044BCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82104714;  }
		/* 821044BCh case    5:*/		return 0x821044C0;
		  /* 821044C0h */ case    6:  		/* rlwinm R30, R23, 2, 0, 29 */
		/* 821044C0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R23);
		/* 821044C0h case    6:*/		return 0x821044C4;
		  /* 821044C4h */ case    7:  		/* lwz R6, <#[R25 + 16]> */
		/* 821044C4h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R25 + 0x00000010) );
		/* 821044C4h case    7:*/		return 0x821044C8;
		  /* 821044C8h */ case    8:  		/* lwz R11, <#[R22 + 8]> */
		/* 821044C8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 821044C8h case    8:*/		return 0x821044CC;
		  /* 821044CCh */ case    9:  		/* mtspr CTR, R23 */
		/* 821044CCh case    9:*/		regs.CTR = regs.R23;
		/* 821044CCh case    9:*/		return 0x821044D0;
		  /* 821044D0h */ case   10:  		/* mr R8, R21 */
		/* 821044D0h case   10:*/		regs.R8 = regs.R21;
		/* 821044D0h case   10:*/		return 0x821044D4;
		  /* 821044D4h */ case   11:  		/* mr R7, R30 */
		/* 821044D4h case   11:*/		regs.R7 = regs.R30;
		/* 821044D4h case   11:*/		return 0x821044D8;
		  /* 821044D8h */ case   12:  		/* lwzx R10, <#[R8 + R11]> */
		/* 821044D8h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 821044D8h case   12:*/		return 0x821044DC;
		  /* 821044DCh */ case   13:  		/* cmpwi CR6, R19, 0 */
		/* 821044DCh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 821044DCh case   13:*/		return 0x821044E0;
		  /* 821044E0h */ case   14:  		/* lwzx R9, <#[R7 + R11]> */
		/* 821044E0h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 821044E0h case   14:*/		return 0x821044E4;
		  /* 821044E4h */ case   15:  		/* lwz R29, <#[R25 + 20]> */
		/* 821044E4h case   15:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R25 + 0x00000014) );
		/* 821044E4h case   15:*/		return 0x821044E8;
		  /* 821044E8h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821044E8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821044E8h case   16:*/		return 0x821044EC;
		  /* 821044ECh */ case   17:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821044ECh case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821044ECh case   17:*/		return 0x821044F0;
		  /* 821044F0h */ case   18:  		/* lwzx R10, <#[R10 + R29]> */
		/* 821044F0h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 821044F0h case   18:*/		return 0x821044F4;
		  /* 821044F4h */ case   19:  		/* lwzx R9, <#[R9 + R29]> */
		/* 821044F4h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R29 + 0x00000000) );
		/* 821044F4h case   19:*/		return 0x821044F8;
		  /* 821044F8h */ case   20:  		/* bc 12, CR6_EQ, 28 */
		/* 821044F8h case   20:*/		if ( regs.CR[6].eq ) { return 0x82104514;  }
		/* 821044F8h case   20:*/		return 0x821044FC;
		  /* 821044FCh */ case   21:  		/* lwz R10, <#[R10 + 48]> */
		/* 821044FCh case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 821044FCh case   21:*/		return 0x82104500;
		  /* 82104500h */ case   22:  		/* lwz R9, <#[R9 + 48]> */
		/* 82104500h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000030) );
		/* 82104500h case   22:*/		return 0x82104504;
		  /* 82104504h */ case   23:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82104504h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82104504h case   23:*/		return 0x82104508;
		  /* 82104508h */ case   24:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82104508h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82104508h case   24:*/		return 0x8210450C;
		  /* 8210450Ch */ case   25:  		/* lwzx R10, <#[R10 + R29]> */
		/* 8210450Ch case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 8210450Ch case   25:*/		return 0x82104510;
		  /* 82104510h */ case   26:  		/* lwzx R9, <#[R9 + R29]> */
		/* 82104510h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R29 + 0x00000000) );
		/* 82104510h case   26:*/		return 0x82104514;
	}
	return 0x82104514;
} // Block from 821044A8h-82104514h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82104514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104514);
		  /* 82104514h */ case    0:  		/* lwz R29, <#[R10 + 4]> */
		/* 82104514h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000004) );
		/* 82104514h case    0:*/		return 0x82104518;
		  /* 82104518h */ case    1:  		/* rlwinm R29, R29, 2, 0, 29 */
		/* 82104518h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R29);
		/* 82104518h case    1:*/		return 0x8210451C;
		  /* 8210451Ch */ case    2:  		/* lwzx R29, <#[R29 + R6]> */
		/* 8210451Ch case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + regs.R6 + 0x00000000) );
		/* 8210451Ch case    2:*/		return 0x82104520;
		  /* 82104520h */ case    3:  		/* lwz R29, <#[R29 + 4]> */
		/* 82104520h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000004) );
		/* 82104520h case    3:*/		return 0x82104524;
		  /* 82104524h */ case    4:  		/* rlwinm. R29, R29, 0, 23, 23 */
		/* 82104524h case    4:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R29,regs.R29);
		/* 82104524h case    4:*/		return 0x82104528;
		  /* 82104528h */ case    5:  		/* bc 12, CR0_EQ, 28 */
		/* 82104528h case    5:*/		if ( regs.CR[0].eq ) { return 0x82104544;  }
		/* 82104528h case    5:*/		return 0x8210452C;
		  /* 8210452Ch */ case    6:  		/* lwz R29, <#[R10 + 8]> */
		/* 8210452Ch case    6:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000008) );
		/* 8210452Ch case    6:*/		return 0x82104530;
		  /* 82104530h */ case    7:  		/* cmpwi CR6, R29, -1 */
		/* 82104530h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 82104530h case    7:*/		return 0x82104534;
		  /* 82104534h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 82104534h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82104544;  }
		/* 82104534h case    8:*/		return 0x82104538;
		  /* 82104538h */ case    9:  		/* lfd FR13, <#[R10 + 32]> */
		/* 82104538h case    9:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000020) );
		/* 82104538h case    9:*/		return 0x8210453C;
		  /* 8210453Ch */ case   10:  		/* fcmpu CR6, FR13, FR0 */
		/* 8210453Ch case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 8210453Ch case   10:*/		return 0x82104540;
		  /* 82104540h */ case   11:  		/* bc 12, CR6_EQ, 52 */
		/* 82104540h case   11:*/		if ( regs.CR[6].eq ) { return 0x82104574;  }
		/* 82104540h case   11:*/		return 0x82104544;
	}
	return 0x82104544;
} // Block from 82104514h-82104544h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82104544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104544);
		  /* 82104544h */ case    0:  		/* lwz R10, <#[R9 + 4]> */
		/* 82104544h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 82104544h case    0:*/		return 0x82104548;
	}
	return 0x82104548;
} // Block from 82104544h-82104548h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82104548h
// Function '?SimplifyTernary@CProgram@D3DXShader@@AAAJPAVCInstruction@2@IIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104548);
		  /* 82104548h */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82104548h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82104548h case    0:*/		return 0x8210454C;
		  /* 8210454Ch */ case    1:  		/* lwzx R10, <#[R10 + R6]> */
		/* 8210454Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 8210454Ch case    1:*/		return 0x82104550;
		  /* 82104550h */ case    2:  		/* lwz R10, <#[R10 + 4]> */
		/* 82104550h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82104550h case    2:*/		return 0x82104554;
		  /* 82104554h */ case    3:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 82104554h case    3:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 82104554h case    3:*/		return 0x82104558;
		  /* 82104558h */ case    4:  		/* bc 12, CR0_EQ, 40 */
		/* 82104558h case    4:*/		if ( regs.CR[0].eq ) { return 0x82104580;  }
		/* 82104558h case    4:*/		return 0x8210455C;
		  /* 8210455Ch */ case    5:  		/* lwz R10, <#[R9 + 8]> */
		/* 8210455Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 8210455Ch case    5:*/		return 0x82104560;
		  /* 82104560h */ case    6:  		/* cmpwi CR6, R10, -1 */
		/* 82104560h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82104560h case    6:*/		return 0x82104564;
		  /* 82104564h */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 82104564h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82104580;  }
		/* 82104564h case    7:*/		return 0x82104568;
		  /* 82104568h */ case    8:  		/* lfd FR13, <#[R9 + 32]> */
		/* 82104568h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R9 + 0x00000020) );
		/* 82104568h case    8:*/		return 0x8210456C;
		  /* 8210456Ch */ case    9:  		/* fcmpu CR6, FR13, FR0 */
		/* 8210456Ch case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 8210456Ch case    9:*/		return 0x82104570;
		  /* 82104570h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 82104570h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82104580;  }
		/* 82104570h case   10:*/		return 0x82104574;
	}
	return 0x82104574;
} // Block from 82104548h-82104574h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82104574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104574);
		  /* 82104574h */ case    0:  		/* addi R4, R4, 1 */
		/* 82104574h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82104574h case    0:*/		return 0x82104578;
		  /* 82104578h */ case    1:  		/* addi R5, R5, 1 */
		/* 82104578h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82104578h case    1:*/		return 0x8210457C;
		  /* 8210457Ch */ case    2:  		/* b 12 */
		/* 8210457Ch case    2:*/		return 0x82104588;
		/* 8210457Ch case    2:*/		return 0x82104580;
	}
	return 0x82104580;
} // Block from 82104574h-82104580h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82104580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104580);
		  /* 82104580h */ case    0:  		/* addi R3, R3, 1 */
		/* 82104580h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82104580h case    0:*/		return 0x82104584;
		  /* 82104584h */ case    1:  		/* mr R5, R21 */
		/* 82104584h case    1:*/		regs.R5 = regs.R21;
		/* 82104584h case    1:*/		return 0x82104588;
	}
	return 0x82104588;
} // Block from 82104580h-82104588h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82104588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104588);
		  /* 82104588h */ case    0:  		/* addi R8, R8, 4 */
		/* 82104588h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82104588h case    0:*/		return 0x8210458C;
		  /* 8210458Ch */ case    1:  		/* addi R7, R7, 4 */
		/* 8210458Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210458Ch case    1:*/		return 0x82104590;
		  /* 82104590h */ case    2:  		/* bc 16, CR0_LT, -184 */
		/* 82104590h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821044D8;  }
		/* 82104590h case    2:*/		return 0x82104594;
		  /* 82104594h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 82104594h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82104594h case    3:*/		return 0x82104598;
		  /* 82104598h */ case    4:  		/* bc 12, CR6_EQ, 380 */
		/* 82104598h case    4:*/		if ( regs.CR[6].eq ) { return 0x82104714;  }
		/* 82104598h case    4:*/		return 0x8210459C;
		  /* 8210459Ch */ case    5:  		/* cmplwi CR6, R3, 2 */
		/* 8210459Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000002);
		/* 8210459Ch case    5:*/		return 0x821045A0;
		  /* 821045A0h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 821045A0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821045B0;  }
		/* 821045A0h case    6:*/		return 0x821045A4;
		  /* 821045A4h */ case    7:  		/* lwz R11, <#[R25 + 108]> */
		/* 821045A4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000006C) );
		/* 821045A4h case    7:*/		return 0x821045A8;
		  /* 821045A8h */ case    8:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 821045A8h case    8:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 821045A8h case    8:*/		return 0x821045AC;
		  /* 821045ACh */ case    9:  		/* bc 12, CR0_EQ, 360 */
		/* 821045ACh case    9:*/		if ( regs.CR[0].eq ) { return 0x82104714;  }
		/* 821045ACh case    9:*/		return 0x821045B0;
	}
	return 0x821045B0;
} // Block from 82104588h-821045B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821045B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821045B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821045B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821045B0);
		  /* 821045B0h */ case    0:  		/* cmplwi CR6, R3, 1 */
		/* 821045B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 821045B0h case    0:*/		return 0x821045B4;
		  /* 821045B4h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 821045B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821045D4;  }
		/* 821045B4h case    1:*/		return 0x821045B8;
		  /* 821045B8h */ case    2:  		/* cmplw CR6, R4, R5 */
		/* 821045B8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 821045B8h case    2:*/		return 0x821045BC;
		  /* 821045BCh */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 821045BCh case    3:*/		if ( regs.CR[6].eq ) { return 0x821045D4;  }
		/* 821045BCh case    3:*/		return 0x821045C0;
		  /* 821045C0h */ case    4:  		/* lwz R11, <#[R25 + 108]> */
		/* 821045C0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000006C) );
		/* 821045C0h case    4:*/		return 0x821045C4;
		  /* 821045C4h */ case    5:  		/* rlwinm. R10, R11, 0, 3, 3 */
		/* 821045C4h case    5:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R11);
		/* 821045C4h case    5:*/		return 0x821045C8;
		  /* 821045C8h */ case    6:  		/* bc 4, CR0_EQ, 332 */
		/* 821045C8h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82104714;  }
		/* 821045C8h case    6:*/		return 0x821045CC;
		  /* 821045CCh */ case    7:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 821045CCh case    7:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 821045CCh case    7:*/		return 0x821045D0;
		  /* 821045D0h */ case    8:  		/* bc 4, CR0_EQ, 324 */
		/* 821045D0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82104714;  }
		/* 821045D0h case    8:*/		return 0x821045D4;
	}
	return 0x821045D4;
} // Block from 821045B0h-821045D4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821045D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821045D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821045D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821045D4);
		  /* 821045D4h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 821045D4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821045D4h case    0:*/		return 0x821045D8;
		  /* 821045D8h */ case    1:  		/* bc 12, CR6_EQ, 712 */
		/* 821045D8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821048A0;  }
		/* 821045D8h case    1:*/		return 0x821045DC;
		  /* 821045DCh */ case    2:  		/* mr R31, R21 */
		/* 821045DCh case    2:*/		regs.R31 = regs.R21;
		/* 821045DCh case    2:*/		return 0x821045E0;
		  /* 821045E0h */ case    3:  		/* mtspr CTR, R23 */
		/* 821045E0h case    3:*/		regs.CTR = regs.R23;
		/* 821045E0h case    3:*/		return 0x821045E4;
		  /* 821045E4h */ case    4:  		/* mr R5, R21 */
		/* 821045E4h case    4:*/		regs.R5 = regs.R21;
		/* 821045E4h case    4:*/		return 0x821045E8;
		  /* 821045E8h */ case    5:  		/* mr R10, R21 */
		/* 821045E8h case    5:*/		regs.R10 = regs.R21;
		/* 821045E8h case    5:*/		return 0x821045EC;
		  /* 821045ECh */ case    6:  		/* mr R4, R30 */
		/* 821045ECh case    6:*/		regs.R4 = regs.R30;
		/* 821045ECh case    6:*/		return 0x821045F0;
		  /* 821045F0h */ case    7:  		/* mr R9, R30 */
		/* 821045F0h case    7:*/		regs.R9 = regs.R30;
		/* 821045F0h case    7:*/		return 0x821045F4;
		  /* 821045F4h */ case    8:  		/* lwz R11, <#[R22 + 8]> */
		/* 821045F4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 821045F4h case    8:*/		return 0x821045F8;
		  /* 821045F8h */ case    9:  		/* cmpwi CR6, R19, 0 */
		/* 821045F8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 821045F8h case    9:*/		return 0x821045FC;
		  /* 821045FCh */ case   10:  		/* lwz R8, <#[R25 + 20]> */
		/* 821045FCh case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000014) );
		/* 821045FCh case   10:*/		return 0x82104600;
		  /* 82104600h */ case   11:  		/* lwzx R7, <#[R9 + R11]> */
		/* 82104600h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82104600h case   11:*/		return 0x82104604;
		  /* 82104604h */ case   12:  		/* lwzx R6, <#[R10 + R11]> */
		/* 82104604h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82104604h case   12:*/		return 0x82104608;
		  /* 82104608h */ case   13:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82104608h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82104608h case   13:*/		return 0x8210460C;
		  /* 8210460Ch */ case   14:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 8210460Ch case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 8210460Ch case   14:*/		return 0x82104610;
		  /* 82104610h */ case   15:  		/* lwzx R7, <#[R7 + R8]> */
		/* 82104610h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 82104610h case   15:*/		return 0x82104614;
		  /* 82104614h */ case   16:  		/* bc 12, CR6_EQ, 28 */
		/* 82104614h case   16:*/		if ( regs.CR[6].eq ) { return 0x82104630;  }
		/* 82104614h case   16:*/		return 0x82104618;
		  /* 82104618h */ case   17:  		/* lwzx R6, <#[R6 + R8]> */
		/* 82104618h case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 82104618h case   17:*/		return 0x8210461C;
		  /* 8210461Ch */ case   18:  		/* lwz R7, <#[R7 + 48]> */
		/* 8210461Ch case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000030) );
		/* 8210461Ch case   18:*/		return 0x82104620;
		  /* 82104620h */ case   19:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82104620h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82104620h case   19:*/		return 0x82104624;
		  /* 82104624h */ case   20:  		/* lwz R6, <#[R6 + 48]> */
		/* 82104624h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000030) );
		/* 82104624h case   20:*/		return 0x82104628;
		  /* 82104628h */ case   21:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82104628h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82104628h case   21:*/		return 0x8210462C;
		  /* 8210462Ch */ case   22:  		/* lwzx R7, <#[R7 + R8]> */
		/* 8210462Ch case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8210462Ch case   22:*/		return 0x82104630;
	}
	return 0x82104630;
} // Block from 821045D4h-82104630h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82104630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104630);
		  /* 82104630h */ case    0:  		/* lwzx R8, <#[R6 + R8]> */
		/* 82104630h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + regs.R8 + 0x00000000) );
		/* 82104630h case    0:*/		return 0x82104634;
		  /* 82104634h */ case    1:  		/* lwz R6, <#[R25 + 16]> */
		/* 82104634h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R25 + 0x00000010) );
		/* 82104634h case    1:*/		return 0x82104638;
		  /* 82104638h */ case    2:  		/* lwz R3, <#[R8 + 4]> */
		/* 82104638h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + 0x00000004) );
		/* 82104638h case    2:*/		return 0x8210463C;
		  /* 8210463Ch */ case    3:  		/* rlwinm R3, R3, 2, 0, 29 */
		/* 8210463Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R3);
		/* 8210463Ch case    3:*/		return 0x82104640;
		  /* 82104640h */ case    4:  		/* lwzx R3, <#[R3 + R6]> */
		/* 82104640h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + regs.R6 + 0x00000000) );
		/* 82104640h case    4:*/		return 0x82104644;
		  /* 82104644h */ case    5:  		/* lwz R3, <#[R3 + 4]> */
		/* 82104644h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 82104644h case    5:*/		return 0x82104648;
		  /* 82104648h */ case    6:  		/* rlwinm. R3, R3, 0, 23, 23 */
		/* 82104648h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R3,regs.R3);
		/* 82104648h case    6:*/		return 0x8210464C;
		  /* 8210464Ch */ case    7:  		/* bc 12, CR0_EQ, 28 */
		/* 8210464Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82104668;  }
		/* 8210464Ch case    7:*/		return 0x82104650;
		  /* 82104650h */ case    8:  		/* lwz R3, <#[R8 + 8]> */
		/* 82104650h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + 0x00000008) );
		/* 82104650h case    8:*/		return 0x82104654;
		  /* 82104654h */ case    9:  		/* cmpwi CR6, R3, -1 */
		/* 82104654h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82104654h case    9:*/		return 0x82104658;
		  /* 82104658h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 82104658h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82104668;  }
		/* 82104658h case   10:*/		return 0x8210465C;
		  /* 8210465Ch */ case   11:  		/* lfd FR13, <#[R8 + 32]> */
		/* 8210465Ch case   11:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R8 + 0x00000020) );
		/* 8210465Ch case   11:*/		return 0x82104660;
		  /* 82104660h */ case   12:  		/* fcmpu CR6, FR13, FR0 */
		/* 82104660h case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82104660h case   12:*/		return 0x82104664;
		  /* 82104664h */ case   13:  		/* bc 12, CR6_EQ, 84 */
		/* 82104664h case   13:*/		if ( regs.CR[6].eq ) { return 0x821046B8;  }
		/* 82104664h case   13:*/		return 0x82104668;
	}
	return 0x82104668;
} // Block from 82104630h-82104668h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82104668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104668);
		  /* 82104668h */ case    0:  		/* lwz R8, <#[R7 + 4]> */
		/* 82104668h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000004) );
		/* 82104668h case    0:*/		return 0x8210466C;
		  /* 8210466Ch */ case    1:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8210466Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8210466Ch case    1:*/		return 0x82104670;
		  /* 82104670h */ case    2:  		/* lwzx R8, <#[R8 + R6]> */
		/* 82104670h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 82104670h case    2:*/		return 0x82104674;
		  /* 82104674h */ case    3:  		/* lwz R8, <#[R8 + 4]> */
		/* 82104674h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 82104674h case    3:*/		return 0x82104678;
		  /* 82104678h */ case    4:  		/* rlwinm. R8, R8, 0, 23, 23 */
		/* 82104678h case    4:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R8,regs.R8);
		/* 82104678h case    4:*/		return 0x8210467C;
		  /* 8210467Ch */ case    5:  		/* bc 12, CR0_EQ, 28 */
		/* 8210467Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82104698;  }
		/* 8210467Ch case    5:*/		return 0x82104680;
		  /* 82104680h */ case    6:  		/* lwz R8, <#[R7 + 8]> */
		/* 82104680h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000008) );
		/* 82104680h case    6:*/		return 0x82104684;
		  /* 82104684h */ case    7:  		/* cmpwi CR6, R8, -1 */
		/* 82104684h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 82104684h case    7:*/		return 0x82104688;
		  /* 82104688h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 82104688h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82104698;  }
		/* 82104688h case    8:*/		return 0x8210468C;
		  /* 8210468Ch */ case    9:  		/* lfd FR13, <#[R7 + 32]> */
		/* 8210468Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R7 + 0x00000020) );
		/* 8210468Ch case    9:*/		return 0x82104690;
		  /* 82104690h */ case   10:  		/* fcmpu CR6, FR13, FR0 */
		/* 82104690h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82104690h case   10:*/		return 0x82104694;
		  /* 82104694h */ case   11:  		/* bc 12, CR6_EQ, 36 */
		/* 82104694h case   11:*/		if ( regs.CR[6].eq ) { return 0x821046B8;  }
		/* 82104694h case   11:*/		return 0x82104698;
	}
	return 0x82104698;
} // Block from 82104668h-82104698h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82104698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104698);
		  /* 82104698h */ case    0:  		/* lwzx R8, <#[R10 + R11]> */
		/* 82104698h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82104698h case    0:*/		return 0x8210469C;
		  /* 8210469Ch */ case    1:  		/* addi R31, R31, 1 */
		/* 8210469Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8210469Ch case    1:*/		return 0x821046A0;
		  /* 821046A0h */ case    2:  		/* stwx R8, <#[R5 + R11]> */
		/* 821046A0h case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 821046A0h case    2:*/		return 0x821046A4;
		  /* 821046A4h */ case    3:  		/* addi R5, R5, 4 */
		/* 821046A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 821046A4h case    3:*/		return 0x821046A8;
		  /* 821046A8h */ case    4:  		/* lwz R11, <#[R22 + 8]> */
		/* 821046A8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 821046A8h case    4:*/		return 0x821046AC;
		  /* 821046ACh */ case    5:  		/* lwzx R8, <#[R9 + R11]> */
		/* 821046ACh case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821046ACh case    5:*/		return 0x821046B0;
		  /* 821046B0h */ case    6:  		/* stwx R8, <#[R4 + R11]> */
		/* 821046B0h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 821046B0h case    6:*/		return 0x821046B4;
		  /* 821046B4h */ case    7:  		/* addi R4, R4, 4 */
		/* 821046B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 821046B4h case    7:*/		return 0x821046B8;
	}
	return 0x821046B8;
} // Block from 82104698h-821046B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821046B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821046B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821046B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821046B8);
		  /* 821046B8h */ case    0:  		/* addi R10, R10, 4 */
		/* 821046B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821046B8h case    0:*/		return 0x821046BC;
		  /* 821046BCh */ case    1:  		/* addi R9, R9, 4 */
		/* 821046BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821046BCh case    1:*/		return 0x821046C0;
		  /* 821046C0h */ case    2:  		/* bc 16, CR0_LT, -204 */
		/* 821046C0h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821045F4;  }
		/* 821046C0h case    2:*/		return 0x821046C4;
		  /* 821046C4h */ case    3:  		/* lwz R11, <#[R22 + 8]> */
		/* 821046C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 821046C4h case    3:*/		return 0x821046C8;
		  /* 821046C8h */ case    4:  		/* rlwinm R5, R31, 2, 0, 29 */
		/* 821046C8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R31);
		/* 821046C8h case    4:*/		return 0x821046CC;
		  /* 821046CCh */ case    5:  		/* add R4, R30, R11 */
		/* 821046CCh case    5:*/		cpu::op::add<0>(regs,&regs.R4,regs.R30,regs.R11);
		/* 821046CCh case    5:*/		return 0x821046D0;
		  /* 821046D0h */ case    6:  		/* add R3, R5, R11 */
		/* 821046D0h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R5,regs.R11);
		/* 821046D0h case    6:*/		return 0x821046D4;
		  /* 821046D4h */ case    7:  		/* bl -470308 */
		/* 821046D4h case    7:*/		regs.LR = 0x821046D8; return 0x820919B0;
		/* 821046D4h case    7:*/		return 0x821046D8;
		  /* 821046D8h */ case    8:  		/* cmplwi CR6, R31, 1 */
		/* 821046D8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000001);
		/* 821046D8h case    8:*/		return 0x821046DC;
		  /* 821046DCh */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 821046DCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x821046EC;  }
		/* 821046DCh case    9:*/		return 0x821046E0;
		  /* 821046E0h */ case   10:  		/* lis R11, 8272 */
		/* 821046E0h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0x2050);
		/* 821046E0h case   10:*/		return 0x821046E4;
		  /* 821046E4h */ case   11:  		/* ori R11, R11, 1 */
		/* 821046E4h case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821046E4h case   11:*/		return 0x821046E8;
		  /* 821046E8h */ case   12:  		/* b 12 */
		/* 821046E8h case   12:*/		return 0x821046F4;
		/* 821046E8h case   12:*/		return 0x821046EC;
	}
	return 0x821046EC;
} // Block from 821046B8h-821046ECh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821046ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821046EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821046EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821046EC);
		  /* 821046ECh */ case    0:  		/* rlwinm R11, R31, 0, 12, 31 */
		/* 821046ECh case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R31);
		/* 821046ECh case    0:*/		return 0x821046F0;
		  /* 821046F0h */ case    1:  		/* oris R11, R11, 20480 */
		/* 821046F0h case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x5000);
		/* 821046F0h case    1:*/		return 0x821046F4;
	}
	return 0x821046F4;
} // Block from 821046ECh-821046F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821046F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821046F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821046F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821046F4);
		  /* 821046F4h */ case    0:  		/* subf R10, R23, R31 */
		/* 821046F4h case    0:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R23,regs.R31);
		/* 821046F4h case    0:*/		return 0x821046F8;
		  /* 821046F8h */ case    1:  		/* stw R11, <#[R22]> */
		/* 821046F8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 821046F8h case    1:*/		return 0x821046FC;
		  /* 821046FCh */ case    2:  		/* rlwinm R11, R31, 1, 0, 30 */
		/* 821046FCh case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R31);
		/* 821046FCh case    2:*/		return 0x82104700;
		  /* 82104700h */ case    3:  		/* stw R20, <#[R22 + 12]> */
		/* 82104700h case    3:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R22 + 0x0000000C) );
		/* 82104700h case    3:*/		return 0x82104704;
		  /* 82104704h */ case    4:  		/* addic R9, R10, -1 */
		/* 82104704h case    4:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 82104704h case    4:*/		return 0x82104708;
		  /* 82104708h */ case    5:  		/* mr R23, R31 */
		/* 82104708h case    5:*/		regs.R23 = regs.R31;
		/* 82104708h case    5:*/		return 0x8210470C;
		  /* 8210470Ch */ case    6:  		/* stw R11, <#[R22 + 4]> */
		/* 8210470Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 8210470Ch case    6:*/		return 0x82104710;
		  /* 82104710h */ case    7:  		/* subfe R31, R9, R10 */
		/* 82104710h case    7:*/		cpu::op::subfe<0>(regs,&regs.R31,regs.R9,regs.R10);
		/* 82104710h case    7:*/		return 0x82104714;
	}
	return 0x82104714;
} // Block from 821046F4h-82104714h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82104714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104714);
		  /* 82104714h */ case    0:  		/* cmplwi CR6, R23, 1 */
		/* 82104714h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000001);
		/* 82104714h case    0:*/		return 0x82104718;
		  /* 82104718h */ case    1:  		/* bc 4, CR6_GT, 24 */
		/* 82104718h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82104730;  }
		/* 82104718h case    1:*/		return 0x8210471C;
		  /* 8210471Ch */ case    2:  		/* cmplwi CR6, R23, 2 */
		/* 8210471Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000002);
		/* 8210471Ch case    2:*/		return 0x82104720;
		  /* 82104720h */ case    3:  		/* bc 4, CR6_EQ, 416 */
		/* 82104720h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821048C0;  }
		/* 82104720h case    3:*/		return 0x82104724;
		  /* 82104724h */ case    4:  		/* lwz R11, <#[R25 + 108]> */
		/* 82104724h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000006C) );
		/* 82104724h case    4:*/		return 0x82104728;
		  /* 82104728h */ case    5:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 82104728h case    5:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 82104728h case    5:*/		return 0x8210472C;
		  /* 8210472Ch */ case    6:  		/* bc 4, CR0_EQ, 404 */
		/* 8210472Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x821048C0;  }
		/* 8210472Ch case    6:*/		return 0x82104730;
	}
	return 0x82104730;
} // Block from 82104714h-82104730h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82104730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104730);
		  /* 82104730h */ case    0:  		/* mr R7, R21 */
		/* 82104730h case    0:*/		regs.R7 = regs.R21;
		/* 82104730h case    0:*/		return 0x82104734;
		  /* 82104734h */ case    1:  		/* cmplwi CR6, R23, 0 */
		/* 82104734h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82104734h case    1:*/		return 0x82104738;
		  /* 82104738h */ case    2:  		/* bc 12, CR6_EQ, 196 */
		/* 82104738h case    2:*/		if ( regs.CR[6].eq ) { return 0x821047FC;  }
		/* 82104738h case    2:*/		return 0x8210473C;
		  /* 8210473Ch */ case    3:  		/* lwz R6, <#[R25 + 16]> */
		/* 8210473Ch case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R25 + 0x00000010) );
		/* 8210473Ch case    3:*/		return 0x82104740;
		  /* 82104740h */ case    4:  		/* mr R11, R21 */
		/* 82104740h case    4:*/		regs.R11 = regs.R21;
		/* 82104740h case    4:*/		return 0x82104744;
		  /* 82104744h */ case    5:  		/* rlwinm R10, R23, 2, 0, 29 */
		/* 82104744h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R23);
		/* 82104744h case    5:*/		return 0x82104748;
		  /* 82104748h */ case    6:  		/* lwz R9, <#[R22 + 8]> */
		/* 82104748h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000008) );
		/* 82104748h case    6:*/		return 0x8210474C;
		  /* 8210474Ch */ case    7:  		/* cmpwi CR6, R19, 0 */
		/* 8210474Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 8210474Ch case    7:*/		return 0x82104750;
		  /* 82104750h */ case    8:  		/* lwz R8, <#[R25 + 20]> */
		/* 82104750h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000014) );
		/* 82104750h case    8:*/		return 0x82104754;
		  /* 82104754h */ case    9:  		/* lwzx R5, <#[R11 + R9]> */
		/* 82104754h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82104754h case    9:*/		return 0x82104758;
		  /* 82104758h */ case   10:  		/* lwzx R9, <#[R10 + R9]> */
		/* 82104758h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82104758h case   10:*/		return 0x8210475C;
		  /* 8210475Ch */ case   11:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 8210475Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 8210475Ch case   11:*/		return 0x82104760;
		  /* 82104760h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 82104760h case   12:*/		if ( regs.CR[6].eq ) { return 0x8210477C;  }
		/* 82104760h case   12:*/		return 0x82104764;
		  /* 82104764h */ case   13:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82104764h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82104764h case   13:*/		return 0x82104768;
		  /* 82104768h */ case   14:  		/* lwzx R5, <#[R5 + R8]> */
		/* 82104768h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 82104768h case   14:*/		return 0x8210476C;
		  /* 8210476Ch */ case   15:  		/* lwzx R9, <#[R9 + R8]> */
		/* 8210476Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8210476Ch case   15:*/		return 0x82104770;
		  /* 82104770h */ case   16:  		/* lwz R5, <#[R5 + 48]> */
		/* 82104770h case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000030) );
		/* 82104770h case   16:*/		return 0x82104774;
		  /* 82104774h */ case   17:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82104774h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82104774h case   17:*/		return 0x82104778;
		  /* 82104778h */ case   18:  		/* lwz R9, <#[R9 + 48]> */
		/* 82104778h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000030) );
		/* 82104778h case   18:*/		return 0x8210477C;
	}
	return 0x8210477C;
} // Block from 82104730h-8210477Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8210477Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210477C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210477C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210477C);
		  /* 8210477Ch */ case    0:  		/* rlwinm R4, R9, 2, 0, 29 */
		/* 8210477Ch case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R9);
		/* 8210477Ch case    0:*/		return 0x82104780;
		  /* 82104780h */ case    1:  		/* lwzx R9, <#[R5 + R8]> */
		/* 82104780h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 82104780h case    1:*/		return 0x82104784;
		  /* 82104784h */ case    2:  		/* lwz R5, <#[R9 + 4]> */
		/* 82104784h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000004) );
		/* 82104784h case    2:*/		return 0x82104788;
		  /* 82104788h */ case    3:  		/* lwzx R8, <#[R4 + R8]> */
		/* 82104788h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + regs.R8 + 0x00000000) );
		/* 82104788h case    3:*/		return 0x8210478C;
		  /* 8210478Ch */ case    4:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 8210478Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 8210478Ch case    4:*/		return 0x82104790;
		  /* 82104790h */ case    5:  		/* lwzx R5, <#[R5 + R6]> */
		/* 82104790h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 82104790h case    5:*/		return 0x82104794;
		  /* 82104794h */ case    6:  		/* lwz R5, <#[R5 + 4]> */
		/* 82104794h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000004) );
		/* 82104794h case    6:*/		return 0x82104798;
		  /* 82104798h */ case    7:  		/* rlwinm. R5, R5, 0, 23, 23 */
		/* 82104798h case    7:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R5,regs.R5);
		/* 82104798h case    7:*/		return 0x8210479C;
		  /* 8210479Ch */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 8210479Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x821047B8;  }
		/* 8210479Ch case    8:*/		return 0x821047A0;
		  /* 821047A0h */ case    9:  		/* lwz R5, <#[R9 + 8]> */
		/* 821047A0h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000008) );
		/* 821047A0h case    9:*/		return 0x821047A4;
		  /* 821047A4h */ case   10:  		/* cmpwi CR6, R5, -1 */
		/* 821047A4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 821047A4h case   10:*/		return 0x821047A8;
		  /* 821047A8h */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 821047A8h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821047B8;  }
		/* 821047A8h case   11:*/		return 0x821047AC;
		  /* 821047ACh */ case   12:  		/* lfd FR0, <#[R9 + 32]> */
		/* 821047ACh case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000020) );
		/* 821047ACh case   12:*/		return 0x821047B0;
		  /* 821047B0h */ case   13:  		/* fcmpu CR6, FR0, FR31 */
		/* 821047B0h case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 821047B0h case   13:*/		return 0x821047B4;
		  /* 821047B4h */ case   14:  		/* bc 12, CR6_EQ, 52 */
		/* 821047B4h case   14:*/		if ( regs.CR[6].eq ) { return 0x821047E8;  }
		/* 821047B4h case   14:*/		return 0x821047B8;
	}
	return 0x821047B8;
} // Block from 8210477Ch-821047B8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821047B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821047B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821047B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821047B8);
		  /* 821047B8h */ case    0:  		/* lwz R9, <#[R8 + 4]> */
		/* 821047B8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000004) );
		/* 821047B8h case    0:*/		return 0x821047BC;
		  /* 821047BCh */ case    1:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821047BCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821047BCh case    1:*/		return 0x821047C0;
		  /* 821047C0h */ case    2:  		/* lwzx R9, <#[R9 + R6]> */
		/* 821047C0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 821047C0h case    2:*/		return 0x821047C4;
		  /* 821047C4h */ case    3:  		/* lwz R9, <#[R9 + 4]> */
		/* 821047C4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 821047C4h case    3:*/		return 0x821047C8;
		  /* 821047C8h */ case    4:  		/* rlwinm. R9, R9, 0, 23, 23 */
		/* 821047C8h case    4:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R9,regs.R9);
		/* 821047C8h case    4:*/		return 0x821047CC;
		  /* 821047CCh */ case    5:  		/* bc 12, CR0_EQ, 48 */
		/* 821047CCh case    5:*/		if ( regs.CR[0].eq ) { return 0x821047FC;  }
		/* 821047CCh case    5:*/		return 0x821047D0;
		  /* 821047D0h */ case    6:  		/* lwz R9, <#[R8 + 8]> */
		/* 821047D0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000008) );
		/* 821047D0h case    6:*/		return 0x821047D4;
		  /* 821047D4h */ case    7:  		/* cmpwi CR6, R9, -1 */
		/* 821047D4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 821047D4h case    7:*/		return 0x821047D8;
		  /* 821047D8h */ case    8:  		/* bc 4, CR6_EQ, 36 */
		/* 821047D8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821047FC;  }
		/* 821047D8h case    8:*/		return 0x821047DC;
		  /* 821047DCh */ case    9:  		/* lfd FR0, <#[R8 + 32]> */
		/* 821047DCh case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R8 + 0x00000020) );
		/* 821047DCh case    9:*/		return 0x821047E0;
		  /* 821047E0h */ case   10:  		/* fcmpu CR6, FR0, FR31 */
		/* 821047E0h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 821047E0h case   10:*/		return 0x821047E4;
		  /* 821047E4h */ case   11:  		/* bc 4, CR6_EQ, 24 */
		/* 821047E4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821047FC;  }
		/* 821047E4h case   11:*/		return 0x821047E8;
	}
	return 0x821047E8;
} // Block from 821047B8h-821047E8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821047E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821047E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821047E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821047E8);
		  /* 821047E8h */ case    0:  		/* addi R7, R7, 1 */
		/* 821047E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821047E8h case    0:*/		return 0x821047EC;
		  /* 821047ECh */ case    1:  		/* addi R11, R11, 4 */
		/* 821047ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821047ECh case    1:*/		return 0x821047F0;
		  /* 821047F0h */ case    2:  		/* addi R10, R10, 4 */
		/* 821047F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821047F0h case    2:*/		return 0x821047F4;
		  /* 821047F4h */ case    3:  		/* cmplw CR6, R7, R23 */
		/* 821047F4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R23);
		/* 821047F4h case    3:*/		return 0x821047F8;
		  /* 821047F8h */ case    4:  		/* bc 12, CR6_LT, -176 */
		/* 821047F8h case    4:*/		if ( regs.CR[6].lt ) { return 0x82104748;  }
		/* 821047F8h case    4:*/		return 0x821047FC;
	}
	return 0x821047FC;
} // Block from 821047E8h-821047FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821047FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821047FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821047FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821047FC);
		  /* 821047FCh */ case    0:  		/* cmplw CR6, R7, R23 */
		/* 821047FCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R23);
		/* 821047FCh case    0:*/		return 0x82104800;
		  /* 82104800h */ case    1:  		/* bc 4, CR6_EQ, 192 */
		/* 82104800h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821048C0;  }
		/* 82104800h case    1:*/		return 0x82104804;
		  /* 82104804h */ case    2:  		/* cmplwi CR6, R23, 0 */
		/* 82104804h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82104804h case    2:*/		return 0x82104808;
		  /* 82104808h */ case    3:  		/* bc 12, CR6_EQ, 128 */
		/* 82104808h case    3:*/		if ( regs.CR[6].eq ) { return 0x82104888;  }
		/* 82104808h case    3:*/		return 0x8210480C;
		  /* 8210480Ch */ case    4:  		/* mtspr CTR, R23 */
		/* 8210480Ch case    4:*/		regs.CTR = regs.R23;
		/* 8210480Ch case    4:*/		return 0x82104810;
		  /* 82104810h */ case    5:  		/* mr R10, R21 */
		/* 82104810h case    5:*/		regs.R10 = regs.R21;
		/* 82104810h case    5:*/		return 0x82104814;
		  /* 82104814h */ case    6:  		/* rlwinm R8, R23, 2, 0, 29 */
		/* 82104814h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R23);
		/* 82104814h case    6:*/		return 0x82104818;
		  /* 82104818h */ case    7:  		/* lwz R11, <#[R22 + 8]> */
		/* 82104818h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 82104818h case    7:*/		return 0x8210481C;
		  /* 8210481Ch */ case    8:  		/* cmpwi CR6, R19, 0 */
		/* 8210481Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 8210481Ch case    8:*/		return 0x82104820;
		  /* 82104820h */ case    9:  		/* lwz R9, <#[R25 + 20]> */
		/* 82104820h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000014) );
		/* 82104820h case    9:*/		return 0x82104824;
		  /* 82104824h */ case   10:  		/* lwzx R7, <#[R11 + R10]> */
		/* 82104824h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82104824h case   10:*/		return 0x82104828;
		  /* 82104828h */ case   11:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82104828h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82104828h case   11:*/		return 0x8210482C;
		  /* 8210482Ch */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 8210482Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x8210483C;  }
		/* 8210482Ch case   12:*/		return 0x82104830;
		  /* 82104830h */ case   13:  		/* lwzx R7, <#[R7 + R9]> */
		/* 82104830h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 82104830h case   13:*/		return 0x82104834;
		  /* 82104834h */ case   14:  		/* lwz R7, <#[R7 + 48]> */
		/* 82104834h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000030) );
		/* 82104834h case   14:*/		return 0x82104838;
		  /* 82104838h */ case   15:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82104838h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82104838h case   15:*/		return 0x8210483C;
	}
	return 0x8210483C;
} // Block from 821047FCh-8210483Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210483Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210483C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210483C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210483C);
		  /* 8210483Ch */ case    0:  		/* lwzx R9, <#[R7 + R9]> */
		/* 8210483Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 8210483Ch case    0:*/		return 0x82104840;
		  /* 82104840h */ case    1:  		/* lwz R6, <#[R25 + 16]> */
		/* 82104840h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R25 + 0x00000010) );
		/* 82104840h case    1:*/		return 0x82104844;
		  /* 82104844h */ case    2:  		/* lwz R7, <#[R9 + 4]> */
		/* 82104844h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000004) );
		/* 82104844h case    2:*/		return 0x82104848;
		  /* 82104848h */ case    3:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82104848h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82104848h case    3:*/		return 0x8210484C;
		  /* 8210484Ch */ case    4:  		/* lwzx R7, <#[R7 + R6]> */
		/* 8210484Ch case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 8210484Ch case    4:*/		return 0x82104850;
		  /* 82104850h */ case    5:  		/* lwz R7, <#[R7 + 4]> */
		/* 82104850h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 82104850h case    5:*/		return 0x82104854;
		  /* 82104854h */ case    6:  		/* rlwinm. R7, R7, 0, 23, 23 */
		/* 82104854h case    6:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R7,regs.R7);
		/* 82104854h case    6:*/		return 0x82104858;
		  /* 82104858h */ case    7:  		/* bc 12, CR0_EQ, 36 */
		/* 82104858h case    7:*/		if ( regs.CR[0].eq ) { return 0x8210487C;  }
		/* 82104858h case    7:*/		return 0x8210485C;
		  /* 8210485Ch */ case    8:  		/* lwz R7, <#[R9 + 8]> */
		/* 8210485Ch case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000008) );
		/* 8210485Ch case    8:*/		return 0x82104860;
		  /* 82104860h */ case    9:  		/* cmpwi CR6, R7, -1 */
		/* 82104860h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 82104860h case    9:*/		return 0x82104864;
		  /* 82104864h */ case   10:  		/* bc 4, CR6_EQ, 24 */
		/* 82104864h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8210487C;  }
		/* 82104864h case   10:*/		return 0x82104868;
		  /* 82104868h */ case   11:  		/* lfd FR0, <#[R9 + 32]> */
		/* 82104868h case   11:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000020) );
		/* 82104868h case   11:*/		return 0x8210486C;
		  /* 8210486Ch */ case   12:  		/* fcmpu CR6, FR0, FR31 */
		/* 8210486Ch case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 8210486Ch case   12:*/		return 0x82104870;
		  /* 82104870h */ case   13:  		/* bc 4, CR6_EQ, 12 */
		/* 82104870h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8210487C;  }
		/* 82104870h case   13:*/		return 0x82104874;
		  /* 82104874h */ case   14:  		/* lwzx R9, <#[R8 + R11]> */
		/* 82104874h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82104874h case   14:*/		return 0x82104878;
		  /* 82104878h */ case   15:  		/* stwx R9, <#[R11 + R10]> */
		/* 82104878h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82104878h case   15:*/		return 0x8210487C;
	}
	return 0x8210487C;
} // Block from 8210483Ch-8210487Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210487Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210487C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210487C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210487C);
		  /* 8210487Ch */ case    0:  		/* addi R10, R10, 4 */
		/* 8210487Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210487Ch case    0:*/		return 0x82104880;
		  /* 82104880h */ case    1:  		/* addi R8, R8, 4 */
		/* 82104880h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82104880h case    1:*/		return 0x82104884;
		  /* 82104884h */ case    2:  		/* bc 16, CR0_LT, -108 */
		/* 82104884h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82104818;  }
		/* 82104884h case    2:*/		return 0x82104888;
	}
	return 0x82104888;
} // Block from 8210487Ch-82104888h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82104888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104888);
		  /* 82104888h */ case    0:  		/* cmplwi CR6, R23, 2 */
		/* 82104888h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000002);
		/* 82104888h case    0:*/		return 0x8210488C;
		  /* 8210488Ch */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 8210488Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821048AC;  }
		/* 8210488Ch case    1:*/		return 0x82104890;
		  /* 82104890h */ case    2:  		/* li R10, 2 */
		/* 82104890h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 82104890h case    2:*/		return 0x82104894;
		  /* 82104894h */ case    3:  		/* lis R11, 8256 */
		/* 82104894h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x2040);
		/* 82104894h case    3:*/		return 0x82104898;
		  /* 82104898h */ case    4:  		/* stw R10, <#[R22 + 4]> */
		/* 82104898h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R22 + 0x00000004) );
		/* 82104898h case    4:*/		return 0x8210489C;
		  /* 8210489Ch */ case    5:  		/* b 24 */
		/* 8210489Ch case    5:*/		return 0x821048B4;
		/* 8210489Ch case    5:*/		return 0x821048A0;
	}
	return 0x821048A0;
} // Block from 82104888h-821048A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821048A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821048A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821048A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821048A0);
		  /* 821048A0h */ case    0:  		/* li R3, 0 */
		/* 821048A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821048A0h case    0:*/		return 0x821048A4;
		  /* 821048A4h */ case    1:  		/* stw R21, <#[R22]> */
		/* 821048A4h case    1:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R22 + 0x00000000) );
		/* 821048A4h case    1:*/		return 0x821048A8;
		  /* 821048A8h */ case    2:  		/* b 40 */
		/* 821048A8h case    2:*/		return 0x821048D0;
		/* 821048A8h case    2:*/		return 0x821048AC;
	}
	return 0x821048AC;
} // Block from 821048A0h-821048ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821048ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821048AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821048AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821048AC);
		  /* 821048ACh */ case    0:  		/* lis R11, 4096 */
		/* 821048ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x1000);
		/* 821048ACh case    0:*/		return 0x821048B0;
		  /* 821048B0h */ case    1:  		/* stw R20, <#[R22 + 4]> */
		/* 821048B0h case    1:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R22 + 0x00000004) );
		/* 821048B0h case    1:*/		return 0x821048B4;
	}
	return 0x821048B4;
} // Block from 821048ACh-821048B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821048B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821048B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821048B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821048B4);
		  /* 821048B4h */ case    0:  		/* ori R11, R11, 1 */
		/* 821048B4h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821048B4h case    0:*/		return 0x821048B8;
		  /* 821048B8h */ case    1:  		/* mr R31, R20 */
		/* 821048B8h case    1:*/		regs.R31 = regs.R20;
		/* 821048B8h case    1:*/		return 0x821048BC;
		  /* 821048BCh */ case    2:  		/* stw R11, <#[R22]> */
		/* 821048BCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 821048BCh case    2:*/		return 0x821048C0;
	}
	return 0x821048C0;
} // Block from 821048B4h-821048C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821048C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821048C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821048C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821048C0);
		  /* 821048C0h */ case    0:  		/* cntlzw R11, R31 */
		/* 821048C0h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R31);
		/* 821048C0h case    0:*/		return 0x821048C4;
		  /* 821048C4h */ case    1:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 821048C4h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 821048C4h case    1:*/		return 0x821048C8;
		  /* 821048C8h */ case    2:  		/* b 8 */
		/* 821048C8h case    2:*/		return 0x821048D0;
		/* 821048C8h case    2:*/		return 0x821048CC;
	}
	return 0x821048CC;
} // Block from 821048C0h-821048CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821048CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821048CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821048CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821048CC);
		  /* 821048CCh */ case    0:  		/* li R3, 1 */
		/* 821048CCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821048CCh case    0:*/		return 0x821048D0;
	}
	return 0x821048D0;
} // Block from 821048CCh-821048D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821048D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821048D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821048D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821048D0);
		  /* 821048D0h */ case    0:  		/* addi R1, R1, 208 */
		/* 821048D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 821048D0h case    0:*/		return 0x821048D4;
		  /* 821048D4h */ case    1:  		/* lfd FR31, <#[R1 - 120]> */
		/* 821048D4h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 821048D4h case    1:*/		return 0x821048D8;
		  /* 821048D8h */ case    2:  		/* b -472660 */
		/* 821048D8h case    2:*/		return 0x82091284;
		/* 821048D8h case    2:*/		return 0x821048DC;
		  /* 821048DCh */ case    3:  		/* nop */
		/* 821048DCh case    3:*/		cpu::op::nop();
		/* 821048DCh case    3:*/		return 0x821048E0;
	}
	return 0x821048E0;
} // Block from 821048D0h-821048E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821048E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821048E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821048E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821048E0);
		  /* 821048E0h */ case    0:  		/* mfspr R12, LR */
		/* 821048E0h case    0:*/		regs.R12 = regs.LR;
		/* 821048E0h case    0:*/		return 0x821048E4;
		  /* 821048E4h */ case    1:  		/* bl -472728 */
		/* 821048E4h case    1:*/		regs.LR = 0x821048E8; return 0x8209124C;
		/* 821048E4h case    1:*/		return 0x821048E8;
		  /* 821048E8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821048E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821048E8h case    2:*/		return 0x821048EC;
		  /* 821048ECh */ case    3:  		/* lwz R11, <#[R4]> */
		/* 821048ECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821048ECh case    3:*/		return 0x821048F0;
		  /* 821048F0h */ case    4:  		/* mr R31, R3 */
		/* 821048F0h case    4:*/		regs.R31 = regs.R3;
		/* 821048F0h case    4:*/		return 0x821048F4;
		  /* 821048F4h */ case    5:  		/* lwz R10, <#[R4 + 4]> */
		/* 821048F4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 821048F4h case    5:*/		return 0x821048F8;
		  /* 821048F8h */ case    6:  		/* li R26, 0 */
		/* 821048F8h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821048F8h case    6:*/		return 0x821048FC;
		  /* 821048FCh */ case    7:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 821048FCh case    7:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 821048FCh case    7:*/		return 0x82104900;
		  /* 82104900h */ case    8:  		/* divwu. R25, R10, R11 */
		/* 82104900h case    8:*/		cpu::op::divwu<1>(regs,&regs.R25,regs.R10,regs.R11);
		/* 82104900h case    8:*/		return 0x82104904;
		  /* 82104904h */ case    9:  		/* twi 6, R11, 0 */
		/* 82104904h case    9:*/		cpu::op::tw<6>(regs, 0x82104904, regs.R11, 0x00000000);
		/* 82104904h case    9:*/		return 0x82104908;
		  /* 82104908h */ case   10:  		/* bc 12, CR0_EQ, 136 */
		/* 82104908h case   10:*/		if ( regs.CR[0].eq ) { return 0x82104990;  }
		/* 82104908h case   10:*/		return 0x8210490C;
		  /* 8210490Ch */ case   11:  		/* lwz R30, <#[R4 + 8]> */
		/* 8210490Ch case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x00000008) );
		/* 8210490Ch case   11:*/		return 0x82104910;
		  /* 82104910h */ case   12:  		/* rlwinm R27, R11, 2, 0, 29 */
		/* 82104910h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R11);
		/* 82104910h case   12:*/		return 0x82104914;
		  /* 82104914h */ case   13:  		/* lwz R29, <#[R3 + 20]> */
		/* 82104914h case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000014) );
		/* 82104914h case   13:*/		return 0x82104918;
		  /* 82104918h */ case   14:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82104918h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82104918h case   14:*/		return 0x8210491C;
		  /* 8210491Ch */ case   15:  		/* lwz R28, <#[R3 + 16]> */
		/* 8210491Ch case   15:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000010) );
		/* 8210491Ch case   15:*/		return 0x82104920;
		  /* 82104920h */ case   16:  		/* rlwinm R7, R5, 2, 0, 29 */
		/* 82104920h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R5);
		/* 82104920h case   16:*/		return 0x82104924;
		  /* 82104924h */ case   17:  		/* lwzx R4, <#[R7 + R30]> */
		/* 82104924h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R7 + regs.R30 + 0x00000000) );
		/* 82104924h case   17:*/		return 0x82104928;
		  /* 82104928h */ case   18:  		/* lwzx R5, <#[R6 + R30]> */
		/* 82104928h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R6 + regs.R30 + 0x00000000) );
		/* 82104928h case   18:*/		return 0x8210492C;
		  /* 8210492Ch */ case   19:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 8210492Ch case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 8210492Ch case   19:*/		return 0x82104930;
		  /* 82104930h */ case   20:  		/* lwzx R11, <#[R11 + R29]> */
		/* 82104930h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82104930h case   20:*/		return 0x82104934;
		  /* 82104934h */ case   21:  		/* lwz R11, <#[R11 + 4]> */
		/* 82104934h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82104934h case   21:*/		return 0x82104938;
		  /* 82104938h */ case   22:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82104938h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82104938h case   22:*/		return 0x8210493C;
		  /* 8210493Ch */ case   23:  		/* lwzx R11, <#[R11 + R28]> */
		/* 8210493Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8210493Ch case   23:*/		return 0x82104940;
		  /* 82104940h */ case   24:  		/* lwz R11, <#[R11 + 4]> */
		/* 82104940h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82104940h case   24:*/		return 0x82104944;
		  /* 82104944h */ case   25:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82104944h case   25:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82104944h case   25:*/		return 0x82104948;
		  /* 82104948h */ case   26:  		/* bc 12, CR0_EQ, 52 */
		/* 82104948h case   26:*/		if ( regs.CR[0].eq ) { return 0x8210497C;  }
		/* 82104948h case   26:*/		return 0x8210494C;
		  /* 8210494Ch */ case   27:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 8210494Ch case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 8210494Ch case   27:*/		return 0x82104950;
		  /* 82104950h */ case   28:  		/* lwzx R11, <#[R11 + R29]> */
		/* 82104950h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82104950h case   28:*/		return 0x82104954;
		  /* 82104954h */ case   29:  		/* lwz R11, <#[R11 + 4]> */
		/* 82104954h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82104954h case   29:*/		return 0x82104958;
		  /* 82104958h */ case   30:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82104958h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82104958h case   30:*/		return 0x8210495C;
		  /* 8210495Ch */ case   31:  		/* lwzx R11, <#[R11 + R28]> */
		/* 8210495Ch case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8210495Ch case   31:*/		return 0x82104960;
		  /* 82104960h */ case   32:  		/* lwz R11, <#[R11 + 4]> */
		/* 82104960h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82104960h case   32:*/		return 0x82104964;
		  /* 82104964h */ case   33:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82104964h case   33:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82104964h case   33:*/		return 0x82104968;
		  /* 82104968h */ case   34:  		/* bc 12, CR0_EQ, 20 */
		/* 82104968h case   34:*/		if ( regs.CR[0].eq ) { return 0x8210497C;  }
		/* 82104968h case   34:*/		return 0x8210496C;
		  /* 8210496Ch */ case   35:  		/* mr R3, R31 */
		/* 8210496Ch case   35:*/		regs.R3 = regs.R31;
		/* 8210496Ch case   35:*/		return 0x82104970;
		  /* 82104970h */ case   36:  		/* bl -22864 */
		/* 82104970h case   36:*/		regs.LR = 0x82104974; return 0x820FF020;
		/* 82104970h case   36:*/		return 0x82104974;
		  /* 82104974h */ case   37:  		/* cmpwi CR0, R3, 0 */
		/* 82104974h case   37:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82104974h case   37:*/		return 0x82104978;
		  /* 82104978h */ case   38:  		/* bc 12, CR0_EQ, 36 */
		/* 82104978h case   38:*/		if ( regs.CR[0].eq ) { return 0x8210499C;  }
		/* 82104978h case   38:*/		return 0x8210497C;
	}
	return 0x8210497C;
} // Block from 821048E0h-8210497Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 8210497Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210497C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210497C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210497C);
		  /* 8210497Ch */ case    0:  		/* addi R26, R26, 1 */
		/* 8210497Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8210497Ch case    0:*/		return 0x82104980;
		  /* 82104980h */ case    1:  		/* add R7, R27, R7 */
		/* 82104980h case    1:*/		cpu::op::add<0>(regs,&regs.R7,regs.R27,regs.R7);
		/* 82104980h case    1:*/		return 0x82104984;
		  /* 82104984h */ case    2:  		/* add R6, R27, R6 */
		/* 82104984h case    2:*/		cpu::op::add<0>(regs,&regs.R6,regs.R27,regs.R6);
		/* 82104984h case    2:*/		return 0x82104988;
		  /* 82104988h */ case    3:  		/* cmplw CR6, R26, R25 */
		/* 82104988h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R25);
		/* 82104988h case    3:*/		return 0x8210498C;
		  /* 8210498Ch */ case    4:  		/* bc 12, CR6_LT, -104 */
		/* 8210498Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82104924;  }
		/* 8210498Ch case    4:*/		return 0x82104990;
	}
	return 0x82104990;
} // Block from 8210497Ch-82104990h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82104990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104990);
		  /* 82104990h */ case    0:  		/* li R3, 0 */
		/* 82104990h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82104990h case    0:*/		return 0x82104994;
		  /* 82104994h */ case    1:  		/* addi R1, R1, 144 */
		/* 82104994h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82104994h case    1:*/		return 0x82104998;
		  /* 82104998h */ case    2:  		/* b -472828 */
		/* 82104998h case    2:*/		return 0x8209129C;
		/* 82104998h case    2:*/		return 0x8210499C;
	}
	return 0x8210499C;
} // Block from 82104990h-8210499Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210499Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210499C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210499C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210499C);
		  /* 8210499Ch */ case    0:  		/* li R3, 1 */
		/* 8210499Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8210499Ch case    0:*/		return 0x821049A0;
		  /* 821049A0h */ case    1:  		/* b -12 */
		/* 821049A0h case    1:*/		return 0x82104994;
		/* 821049A0h case    1:*/		return 0x821049A4;
		  /* 821049A4h */ case    2:  		/* nop */
		/* 821049A4h case    2:*/		cpu::op::nop();
		/* 821049A4h case    2:*/		return 0x821049A8;
	}
	return 0x821049A8;
} // Block from 8210499Ch-821049A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821049A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821049A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821049A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821049A8);
		  /* 821049A8h */ case    0:  		/* mfspr R12, LR */
		/* 821049A8h case    0:*/		regs.R12 = regs.LR;
		/* 821049A8h case    0:*/		return 0x821049AC;
		  /* 821049ACh */ case    1:  		/* bl -472968 */
		/* 821049ACh case    1:*/		regs.LR = 0x821049B0; return 0x82091224;
		/* 821049ACh case    1:*/		return 0x821049B0;
		  /* 821049B0h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 821049B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 821049B0h case    2:*/		return 0x821049B4;
		  /* 821049B4h */ case    3:  		/* lwz R18, <#[R4 + 12]> */
		/* 821049B4h case    3:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R4 + 0x0000000C) );
		/* 821049B4h case    3:*/		return 0x821049B8;
		  /* 821049B8h */ case    4:  		/* mr R22, R3 */
		/* 821049B8h case    4:*/		regs.R22 = regs.R3;
		/* 821049B8h case    4:*/		return 0x821049BC;
		  /* 821049BCh */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 821049BCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821049BCh case    5:*/		return 0x821049C0;
		  /* 821049C0h */ case    6:  		/* mr R3, R4 */
		/* 821049C0h case    6:*/		regs.R3 = regs.R4;
		/* 821049C0h case    6:*/		return 0x821049C4;
		  /* 821049C4h */ case    7:  		/* mr R31, R4 */
		/* 821049C4h case    7:*/		regs.R31 = regs.R4;
		/* 821049C4h case    7:*/		return 0x821049C8;
		  /* 821049C8h */ case    8:  		/* divwu R15, R11, R18 */
		/* 821049C8h case    8:*/		cpu::op::divwu<0>(regs,&regs.R15,regs.R11,regs.R18);
		/* 821049C8h case    8:*/		return 0x821049CC;
		  /* 821049CCh */ case    9:  		/* twi 6, R18, 0 */
		/* 821049CCh case    9:*/		cpu::op::tw<6>(regs, 0x821049CC, regs.R18, 0x00000000);
		/* 821049CCh case    9:*/		return 0x821049D0;
		  /* 821049D0h */ case   10:  		/* bl -35352 */
		/* 821049D0h case   10:*/		regs.LR = 0x821049D4; return 0x820FBFB8;
		/* 821049D0h case   10:*/		return 0x821049D4;
		  /* 821049D4h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 821049D4h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821049D4h case   11:*/		return 0x821049D8;
		  /* 821049D8h */ case   12:  		/* cmplwi CR6, R18, 0 */
		/* 821049D8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 821049D8h case   12:*/		return 0x821049DC;
		  /* 821049DCh */ case   13:  		/* bc 12, CR0_EQ, 180 */
		/* 821049DCh case   13:*/		if ( regs.CR[0].eq ) { return 0x82104A90;  }
		/* 821049DCh case   13:*/		return 0x821049E0;
		  /* 821049E0h */ case   14:  		/* li R29, 0 */
		/* 821049E0h case   14:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821049E0h case   14:*/		return 0x821049E4;
		  /* 821049E4h */ case   15:  		/* bc 12, CR6_EQ, 1304 */
		/* 821049E4h case   15:*/		if ( regs.CR[6].eq ) { return 0x82104EFC;  }
		/* 821049E4h case   15:*/		return 0x821049E8;
		  /* 821049E8h */ case   16:  		/* li R28, 0 */
		/* 821049E8h case   16:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821049E8h case   16:*/		return 0x821049EC;
		  /* 821049ECh */ case   17:  		/* li R17, -1 */
		/* 821049ECh case   17:*/		cpu::op::li<0>(regs,&regs.R17,0xFFFFFFFF);
		/* 821049ECh case   17:*/		return 0x821049F0;
		  /* 821049F0h */ case   18:  		/* lwz R4, <#[R31]> */
		/* 821049F0h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 821049F0h case   18:*/		return 0x821049F4;
		  /* 821049F4h */ case   19:  		/* li R11, 1 */
		/* 821049F4h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821049F4h case   19:*/		return 0x821049F8;
		  /* 821049F8h */ case   20:  		/* mr R6, R17 */
		/* 821049F8h case   20:*/		regs.R6 = regs.R17;
		/* 821049F8h case   20:*/		return 0x821049FC;
		  /* 821049FCh */ case   21:  		/* rlwimi R4, R11, 0, 12, 31 */
		/* 821049FCh case   21:*/		cpu::op::rlwimi<0,0,12,31>(regs,&regs.R4,regs.R11);
		/* 821049FCh case   21:*/		return 0x82104A00;
		  /* 82104A00h */ case   22:  		/* mr R5, R17 */
		/* 82104A00h case   22:*/		regs.R5 = regs.R17;
		/* 82104A00h case   22:*/		return 0x82104A04;
		  /* 82104A04h */ case   23:  		/* mr R3, R22 */
		/* 82104A04h case   23:*/		regs.R3 = regs.R22;
		/* 82104A04h case   23:*/		return 0x82104A08;
		  /* 82104A08h */ case   24:  		/* bl -30528 */
		/* 82104A08h case   24:*/		regs.LR = 0x82104A0C; return 0x820FD2C8;
		/* 82104A08h case   24:*/		return 0x82104A0C;
		  /* 82104A0Ch */ case   25:  		/* cmpwi CR6, R3, -1 */
		/* 82104A0Ch case   25:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82104A0Ch case   25:*/		return 0x82104A10;
		  /* 82104A10h */ case   26:  		/* bc 12, CR6_EQ, 656 */
		/* 82104A10h case   26:*/		if ( regs.CR[6].eq ) { return 0x82104CA0;  }
		/* 82104A10h case   26:*/		return 0x82104A14;
		  /* 82104A14h */ case   27:  		/* lwz R11, <#[R22 + 24]> */
		/* 82104A14h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000018) );
		/* 82104A14h case   27:*/		return 0x82104A18;
		  /* 82104A18h */ case   28:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82104A18h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82104A18h case   28:*/		return 0x82104A1C;
		  /* 82104A1Ch */ case   29:  		/* mr R4, R31 */
		/* 82104A1Ch case   29:*/		regs.R4 = regs.R31;
		/* 82104A1Ch case   29:*/		return 0x82104A20;
		  /* 82104A20h */ case   30:  		/* lwzx R30, <#[R10 + R11]> */
		/* 82104A20h case   30:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82104A20h case   30:*/		return 0x82104A24;
		  /* 82104A24h */ case   31:  		/* mr R3, R30 */
		/* 82104A24h case   31:*/		regs.R3 = regs.R30;
		/* 82104A24h case   31:*/		return 0x82104A28;
		  /* 82104A28h */ case   32:  		/* bl -35640 */
		/* 82104A28h case   32:*/		regs.LR = 0x82104A2C; return 0x820FBEF0;
		/* 82104A28h case   32:*/		return 0x82104A2C;
		  /* 82104A2Ch */ case   33:  		/* li R11, 0 */
		/* 82104A2Ch case   33:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82104A2Ch case   33:*/		return 0x82104A30;
		  /* 82104A30h */ case   34:  		/* cmplwi CR6, R15, 0 */
		/* 82104A30h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R15,0x00000000);
		/* 82104A30h case   34:*/		return 0x82104A34;
		  /* 82104A34h */ case   35:  		/* bc 12, CR6_EQ, 56 */
		/* 82104A34h case   35:*/		if ( regs.CR[6].eq ) { return 0x82104A6C;  }
		/* 82104A34h case   35:*/		return 0x82104A38;
		  /* 82104A38h */ case   36:  		/* mtspr CTR, R15 */
		/* 82104A38h case   36:*/		regs.CTR = regs.R15;
		/* 82104A38h case   36:*/		return 0x82104A3C;
		  /* 82104A3Ch */ case   37:  		/* li R10, 0 */
		/* 82104A3Ch case   37:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82104A3Ch case   37:*/		return 0x82104A40;
		  /* 82104A40h */ case   38:  		/* lwz R9, <#[R31 + 12]> */
		/* 82104A40h case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 82104A40h case   38:*/		return 0x82104A44;
		  /* 82104A44h */ case   39:  		/* lwz R8, <#[R31 + 8]> */
		/* 82104A44h case   39:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82104A44h case   39:*/		return 0x82104A48;
		  /* 82104A48h */ case   40:  		/* mullw R9, R11, R9 */
		/* 82104A48h case   40:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 82104A48h case   40:*/		return 0x82104A4C;
		  /* 82104A4Ch */ case   41:  		/* lwz R7, <#[R30 + 8]> */
		/* 82104A4Ch case   41:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 82104A4Ch case   41:*/		return 0x82104A50;
		  /* 82104A50h */ case   42:  		/* add R9, R9, R29 */
		/* 82104A50h case   42:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R29);
		/* 82104A50h case   42:*/		return 0x82104A54;
		  /* 82104A54h */ case   43:  		/* addi R11, R11, 1 */
		/* 82104A54h case   43:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82104A54h case   43:*/		return 0x82104A58;
		  /* 82104A58h */ case   44:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82104A58h case   44:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82104A58h case   44:*/		return 0x82104A5C;
		  /* 82104A5Ch */ case   45:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82104A5Ch case   45:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82104A5Ch case   45:*/		return 0x82104A60;
		  /* 82104A60h */ case   46:  		/* stwx R9, <#[R10 + R7]> */
		/* 82104A60h case   46:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82104A60h case   46:*/		return 0x82104A64;
		  /* 82104A64h */ case   47:  		/* addi R10, R10, 4 */
		/* 82104A64h case   47:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82104A64h case   47:*/		return 0x82104A68;
		  /* 82104A68h */ case   48:  		/* bc 16, CR0_LT, -40 */
		/* 82104A68h case   48:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82104A40;  }
		/* 82104A68h case   48:*/		return 0x82104A6C;
	}
	return 0x82104A6C;
} // Block from 821049A8h-82104A6Ch (49 instructions)

//////////////////////////////////////////////////////
// Block at 82104A6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104A6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104A6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104A6C);
		  /* 82104A6Ch */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82104A6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82104A6Ch case    0:*/		return 0x82104A70;
		  /* 82104A70h */ case    1:  		/* addi R29, R29, 1 */
		/* 82104A70h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82104A70h case    1:*/		return 0x82104A74;
		  /* 82104A74h */ case    2:  		/* lwz R10, <#[R30 + 16]> */
		/* 82104A74h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 82104A74h case    2:*/		return 0x82104A78;
		  /* 82104A78h */ case    3:  		/* cmplw CR6, R29, R18 */
		/* 82104A78h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R18);
		/* 82104A78h case    3:*/		return 0x82104A7C;
		  /* 82104A7Ch */ case    4:  		/* lwzx R11, <#[R11 + R28]> */
		/* 82104A7Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82104A7Ch case    4:*/		return 0x82104A80;
		  /* 82104A80h */ case    5:  		/* addi R28, R28, 4 */
		/* 82104A80h case    5:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82104A80h case    5:*/		return 0x82104A84;
		  /* 82104A84h */ case    6:  		/* stw R11, <#[R10]> */
		/* 82104A84h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82104A84h case    6:*/		return 0x82104A88;
		  /* 82104A88h */ case    7:  		/* bc 12, CR6_LT, -152 */
		/* 82104A88h case    7:*/		if ( regs.CR[6].lt ) { return 0x821049F0;  }
		/* 82104A88h case    7:*/		return 0x82104A8C;
		  /* 82104A8Ch */ case    8:  		/* b 1136 */
		/* 82104A8Ch case    8:*/		return 0x82104EFC;
		/* 82104A8Ch case    8:*/		return 0x82104A90;
	}
	return 0x82104A90;
} // Block from 82104A6Ch-82104A90h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82104A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104A90);
		  /* 82104A90h */ case    0:  		/* mr R16, R18 */
		/* 82104A90h case    0:*/		regs.R16 = regs.R18;
		/* 82104A90h case    0:*/		return 0x82104A94;
		  /* 82104A94h */ case    1:  		/* li R17, -1 */
		/* 82104A94h case    1:*/		cpu::op::li<0>(regs,&regs.R17,0xFFFFFFFF);
		/* 82104A94h case    1:*/		return 0x82104A98;
		  /* 82104A98h */ case    2:  		/* li R26, 0 */
		/* 82104A98h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82104A98h case    2:*/		return 0x82104A9C;
		  /* 82104A9Ch */ case    3:  		/* bc 12, CR6_EQ, 400 */
		/* 82104A9Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82104C2C;  }
		/* 82104A9Ch case    3:*/		return 0x82104AA0;
		  /* 82104AA0h */ case    4:  		/* li R27, 0 */
		/* 82104AA0h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82104AA0h case    4:*/		return 0x82104AA4;
		  /* 82104AA4h */ case    5:  		/* lwz R29, <#[R31 + 16]> */
		/* 82104AA4h case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000010) );
		/* 82104AA4h case    5:*/		return 0x82104AA8;
		  /* 82104AA8h */ case    6:  		/* lwzx R11, <#[R29 + R27]> */
		/* 82104AA8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R27 + 0x00000000) );
		/* 82104AA8h case    6:*/		return 0x82104AAC;
		  /* 82104AACh */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 82104AACh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82104AACh case    7:*/		return 0x82104AB0;
		  /* 82104AB0h */ case    8:  		/* bc 12, CR6_EQ, 364 */
		/* 82104AB0h case    8:*/		if ( regs.CR[6].eq ) { return 0x82104C1C;  }
		/* 82104AB0h case    8:*/		return 0x82104AB4;
		  /* 82104AB4h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82104AB4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82104AB4h case    9:*/		return 0x82104AB8;
		  /* 82104AB8h */ case   10:  		/* lwz R10, <#[R22 + 20]> */
		/* 82104AB8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000014) );
		/* 82104AB8h case   10:*/		return 0x82104ABC;
		  /* 82104ABCh */ case   11:  		/* lwz R9, <#[R22 + 16]> */
		/* 82104ABCh case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000010) );
		/* 82104ABCh case   11:*/		return 0x82104AC0;
		  /* 82104AC0h */ case   12:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82104AC0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82104AC0h case   12:*/		return 0x82104AC4;
		  /* 82104AC4h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 82104AC4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82104AC4h case   13:*/		return 0x82104AC8;
		  /* 82104AC8h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82104AC8h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82104AC8h case   14:*/		return 0x82104ACC;
		  /* 82104ACCh */ case   15:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82104ACCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82104ACCh case   15:*/		return 0x82104AD0;
		  /* 82104AD0h */ case   16:  		/* lwz R11, <#[R11 + 4]> */
		/* 82104AD0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82104AD0h case   16:*/		return 0x82104AD4;
		  /* 82104AD4h */ case   17:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82104AD4h case   17:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82104AD4h case   17:*/		return 0x82104AD8;
		  /* 82104AD8h */ case   18:  		/* bc 12, CR0_EQ, 324 */
		/* 82104AD8h case   18:*/		if ( regs.CR[0].eq ) { return 0x82104C1C;  }
		/* 82104AD8h case   18:*/		return 0x82104ADC;
		  /* 82104ADCh */ case   19:  		/* li R30, 0 */
		/* 82104ADCh case   19:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82104ADCh case   19:*/		return 0x82104AE0;
		  /* 82104AE0h */ case   20:  		/* cmplw CR6, R26, R18 */
		/* 82104AE0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R18);
		/* 82104AE0h case   20:*/		return 0x82104AE4;
		  /* 82104AE4h */ case   21:  		/* bc 4, CR6_LT, 68 */
		/* 82104AE4h case   21:*/		if ( !regs.CR[6].lt ) { return 0x82104B28;  }
		/* 82104AE4h case   21:*/		return 0x82104AE8;
		  /* 82104AE8h */ case   22:  		/* mr R7, R27 */
		/* 82104AE8h case   22:*/		regs.R7 = regs.R27;
		/* 82104AE8h case   22:*/		return 0x82104AEC;
		  /* 82104AECh */ case   23:  		/* subf R6, R26, R18 */
		/* 82104AECh case   23:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R26,regs.R18);
		/* 82104AECh case   23:*/		return 0x82104AF0;
		  /* 82104AF0h */ case   24:  		/* lwzx R11, <#[R29 + R7]> */
		/* 82104AF0h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R7 + 0x00000000) );
		/* 82104AF0h case   24:*/		return 0x82104AF4;
		  /* 82104AF4h */ case   25:  		/* cmpwi CR6, R11, -1 */
		/* 82104AF4h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82104AF4h case   25:*/		return 0x82104AF8;
		  /* 82104AF8h */ case   26:  		/* bc 12, CR6_EQ, 36 */
		/* 82104AF8h case   26:*/		if ( regs.CR[6].eq ) { return 0x82104B1C;  }
		/* 82104AF8h case   26:*/		return 0x82104AFC;
		  /* 82104AFCh */ case   27:  		/* lwz R11, <#[R31 + 16]> */
		/* 82104AFCh case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82104AFCh case   27:*/		return 0x82104B00;
		  /* 82104B00h */ case   28:  		/* mr R3, R22 */
		/* 82104B00h case   28:*/		regs.R3 = regs.R22;
		/* 82104B00h case   28:*/		return 0x82104B04;
		  /* 82104B04h */ case   29:  		/* lwzx R5, <#[R11 + R7]> */
		/* 82104B04h case   29:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82104B04h case   29:*/		return 0x82104B08;
		  /* 82104B08h */ case   30:  		/* lwzx R4, <#[R11 + R27]> */
		/* 82104B08h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82104B08h case   30:*/		return 0x82104B0C;
		  /* 82104B0Ch */ case   31:  		/* bl -23276 */
		/* 82104B0Ch case   31:*/		regs.LR = 0x82104B10; return 0x820FF020;
		/* 82104B0Ch case   31:*/		return 0x82104B10;
		  /* 82104B10h */ case   32:  		/* cmpwi CR0, R3, 0 */
		/* 82104B10h case   32:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82104B10h case   32:*/		return 0x82104B14;
		  /* 82104B14h */ case   33:  		/* bc 12, CR0_EQ, 8 */
		/* 82104B14h case   33:*/		if ( regs.CR[0].eq ) { return 0x82104B1C;  }
		/* 82104B14h case   33:*/		return 0x82104B18;
		  /* 82104B18h */ case   34:  		/* addi R30, R30, 1 */
		/* 82104B18h case   34:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82104B18h case   34:*/		return 0x82104B1C;
	}
	return 0x82104B1C;
} // Block from 82104A90h-82104B1Ch (35 instructions)

//////////////////////////////////////////////////////
// Block at 82104B1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104B1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104B1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104B1C);
		  /* 82104B1Ch */ case    0:  		/* addic. R6, R6, -1 */
		/* 82104B1Ch case    0:*/		cpu::op::addic<1>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82104B1Ch case    0:*/		return 0x82104B20;
		  /* 82104B20h */ case    1:  		/* addi R7, R7, 4 */
		/* 82104B20h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82104B20h case    1:*/		return 0x82104B24;
		  /* 82104B24h */ case    2:  		/* bc 4, CR0_EQ, -52 */
		/* 82104B24h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82104AF0;  }
		/* 82104B24h case    2:*/		return 0x82104B28;
	}
	return 0x82104B28;
} // Block from 82104B1Ch-82104B28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82104B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104B28);
		  /* 82104B28h */ case    0:  		/* lwz R4, <#[R31]> */
		/* 82104B28h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82104B28h case    0:*/		return 0x82104B2C;
		  /* 82104B2Ch */ case    1:  		/* mr R6, R17 */
		/* 82104B2Ch case    1:*/		regs.R6 = regs.R17;
		/* 82104B2Ch case    1:*/		return 0x82104B30;
		  /* 82104B30h */ case    2:  		/* mr R5, R17 */
		/* 82104B30h case    2:*/		regs.R5 = regs.R17;
		/* 82104B30h case    2:*/		return 0x82104B34;
		  /* 82104B34h */ case    3:  		/* rlwimi R4, R30, 0, 12, 31 */
		/* 82104B34h case    3:*/		cpu::op::rlwimi<0,0,12,31>(regs,&regs.R4,regs.R30);
		/* 82104B34h case    3:*/		return 0x82104B38;
		  /* 82104B38h */ case    4:  		/* mr R3, R22 */
		/* 82104B38h case    4:*/		regs.R3 = regs.R22;
		/* 82104B38h case    4:*/		return 0x82104B3C;
		  /* 82104B3Ch */ case    5:  		/* bl -30836 */
		/* 82104B3Ch case    5:*/		regs.LR = 0x82104B40; return 0x820FD2C8;
		/* 82104B3Ch case    5:*/		return 0x82104B40;
		  /* 82104B40h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 82104B40h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82104B40h case    6:*/		return 0x82104B44;
		  /* 82104B44h */ case    7:  		/* bc 12, CR6_EQ, 348 */
		/* 82104B44h case    7:*/		if ( regs.CR[6].eq ) { return 0x82104CA0;  }
		/* 82104B44h case    7:*/		return 0x82104B48;
		  /* 82104B48h */ case    8:  		/* lwz R11, <#[R22 + 24]> */
		/* 82104B48h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000018) );
		/* 82104B48h case    8:*/		return 0x82104B4C;
		  /* 82104B4Ch */ case    9:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82104B4Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82104B4Ch case    9:*/		return 0x82104B50;
		  /* 82104B50h */ case   10:  		/* mr R4, R31 */
		/* 82104B50h case   10:*/		regs.R4 = regs.R31;
		/* 82104B50h case   10:*/		return 0x82104B54;
		  /* 82104B54h */ case   11:  		/* lwzx R30, <#[R10 + R11]> */
		/* 82104B54h case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82104B54h case   11:*/		return 0x82104B58;
		  /* 82104B58h */ case   12:  		/* mr R3, R30 */
		/* 82104B58h case   12:*/		regs.R3 = regs.R30;
		/* 82104B58h case   12:*/		return 0x82104B5C;
		  /* 82104B5Ch */ case   13:  		/* bl -35948 */
		/* 82104B5Ch case   13:*/		regs.LR = 0x82104B60; return 0x820FBEF0;
		/* 82104B5Ch case   13:*/		return 0x82104B60;
		  /* 82104B60h */ case   14:  		/* lwz R11, <#[R31 + 16]> */
		/* 82104B60h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82104B60h case   14:*/		return 0x82104B64;
		  /* 82104B64h */ case   15:  		/* li R7, 0 */
		/* 82104B64h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82104B64h case   15:*/		return 0x82104B68;
		  /* 82104B68h */ case   16:  		/* mr R29, R26 */
		/* 82104B68h case   16:*/		regs.R29 = regs.R26;
		/* 82104B68h case   16:*/		return 0x82104B6C;
		  /* 82104B6Ch */ case   17:  		/* cmplw CR6, R26, R18 */
		/* 82104B6Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R18);
		/* 82104B6Ch case   17:*/		return 0x82104B70;
		  /* 82104B70h */ case   18:  		/* lwzx R4, <#[R11 + R27]> */
		/* 82104B70h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82104B70h case   18:*/		return 0x82104B74;
		  /* 82104B74h */ case   19:  		/* bc 4, CR6_LT, 168 */
		/* 82104B74h case   19:*/		if ( !regs.CR[6].lt ) { return 0x82104C1C;  }
		/* 82104B74h case   19:*/		return 0x82104B78;
		  /* 82104B78h */ case   20:  		/* mr R6, R27 */
		/* 82104B78h case   20:*/		regs.R6 = regs.R27;
		/* 82104B78h case   20:*/		return 0x82104B7C;
		  /* 82104B7Ch */ case   21:  		/* li R28, 0 */
		/* 82104B7Ch case   21:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82104B7Ch case   21:*/		return 0x82104B80;
		  /* 82104B80h */ case   22:  		/* lwz R11, <#[R31 + 16]> */
		/* 82104B80h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82104B80h case   22:*/		return 0x82104B84;
		  /* 82104B84h */ case   23:  		/* lwzx R5, <#[R11 + R6]> */
		/* 82104B84h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82104B84h case   23:*/		return 0x82104B88;
		  /* 82104B88h */ case   24:  		/* cmpwi CR6, R5, -1 */
		/* 82104B88h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 82104B88h case   24:*/		return 0x82104B8C;
		  /* 82104B8Ch */ case   25:  		/* bc 12, CR6_EQ, 128 */
		/* 82104B8Ch case   25:*/		if ( regs.CR[6].eq ) { return 0x82104C0C;  }
		/* 82104B8Ch case   25:*/		return 0x82104B90;
		  /* 82104B90h */ case   26:  		/* mr R3, R22 */
		/* 82104B90h case   26:*/		regs.R3 = regs.R22;
		/* 82104B90h case   26:*/		return 0x82104B94;
		  /* 82104B94h */ case   27:  		/* bl -23412 */
		/* 82104B94h case   27:*/		regs.LR = 0x82104B98; return 0x820FF020;
		/* 82104B94h case   27:*/		return 0x82104B98;
		  /* 82104B98h */ case   28:  		/* cmpwi CR0, R3, 0 */
		/* 82104B98h case   28:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82104B98h case   28:*/		return 0x82104B9C;
		  /* 82104B9Ch */ case   29:  		/* bc 12, CR0_EQ, 112 */
		/* 82104B9Ch case   29:*/		if ( regs.CR[0].eq ) { return 0x82104C0C;  }
		/* 82104B9Ch case   29:*/		return 0x82104BA0;
		  /* 82104BA0h */ case   30:  		/* li R11, 0 */
		/* 82104BA0h case   30:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82104BA0h case   30:*/		return 0x82104BA4;
		  /* 82104BA4h */ case   31:  		/* cmplwi CR6, R15, 0 */
		/* 82104BA4h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R15,0x00000000);
		/* 82104BA4h case   31:*/		return 0x82104BA8;
		  /* 82104BA8h */ case   32:  		/* bc 12, CR6_EQ, 64 */
		/* 82104BA8h case   32:*/		if ( regs.CR[6].eq ) { return 0x82104BE8;  }
		/* 82104BA8h case   32:*/		return 0x82104BAC;
		  /* 82104BACh */ case   33:  		/* mtspr CTR, R15 */
		/* 82104BACh case   33:*/		regs.CTR = regs.R15;
		/* 82104BACh case   33:*/		return 0x82104BB0;
		  /* 82104BB0h */ case   34:  		/* lwz R10, <#[R31 + 12]> */
		/* 82104BB0h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82104BB0h case   34:*/		return 0x82104BB4;
		  /* 82104BB4h */ case   35:  		/* lwz R9, <#[R30 + 12]> */
		/* 82104BB4h case   35:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 82104BB4h case   35:*/		return 0x82104BB8;
		  /* 82104BB8h */ case   36:  		/* mullw R10, R11, R10 */
		/* 82104BB8h case   36:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82104BB8h case   36:*/		return 0x82104BBC;
		  /* 82104BBCh */ case   37:  		/* lwz R8, <#[R31 + 8]> */
		/* 82104BBCh case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82104BBCh case   37:*/		return 0x82104BC0;
		  /* 82104BC0h */ case   38:  		/* lwz R5, <#[R30 + 8]> */
		/* 82104BC0h case   38:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000008) );
		/* 82104BC0h case   38:*/		return 0x82104BC4;
		  /* 82104BC4h */ case   39:  		/* add R3, R10, R29 */
		/* 82104BC4h case   39:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R29);
		/* 82104BC4h case   39:*/		return 0x82104BC8;
		  /* 82104BC8h */ case   40:  		/* mullw R10, R11, R9 */
		/* 82104BC8h case   40:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 82104BC8h case   40:*/		return 0x82104BCC;
		  /* 82104BCCh */ case   41:  		/* rlwinm R9, R3, 2, 0, 29 */
		/* 82104BCCh case   41:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R3);
		/* 82104BCCh case   41:*/		return 0x82104BD0;
		  /* 82104BD0h */ case   42:  		/* add R10, R10, R7 */
		/* 82104BD0h case   42:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82104BD0h case   42:*/		return 0x82104BD4;
		  /* 82104BD4h */ case   43:  		/* addi R11, R11, 1 */
		/* 82104BD4h case   43:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82104BD4h case   43:*/		return 0x82104BD8;
		  /* 82104BD8h */ case   44:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82104BD8h case   44:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82104BD8h case   44:*/		return 0x82104BDC;
		  /* 82104BDCh */ case   45:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82104BDCh case   45:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82104BDCh case   45:*/		return 0x82104BE0;
		  /* 82104BE0h */ case   46:  		/* stwx R9, <#[R10 + R5]> */
		/* 82104BE0h case   46:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 82104BE0h case   46:*/		return 0x82104BE4;
		  /* 82104BE4h */ case   47:  		/* bc 16, CR0_LT, -52 */
		/* 82104BE4h case   47:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82104BB0;  }
		/* 82104BE4h case   47:*/		return 0x82104BE8;
	}
	return 0x82104BE8;
} // Block from 82104B28h-82104BE8h (48 instructions)

//////////////////////////////////////////////////////
// Block at 82104BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104BE8);
		  /* 82104BE8h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82104BE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82104BE8h case    0:*/		return 0x82104BEC;
		  /* 82104BECh */ case    1:  		/* addi R16, R16, -1 */
		/* 82104BECh case    1:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0xFFFFFFFF);
		/* 82104BECh case    1:*/		return 0x82104BF0;
		  /* 82104BF0h */ case    2:  		/* lwz R10, <#[R30 + 16]> */
		/* 82104BF0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 82104BF0h case    2:*/		return 0x82104BF4;
		  /* 82104BF4h */ case    3:  		/* addi R7, R7, 1 */
		/* 82104BF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82104BF4h case    3:*/		return 0x82104BF8;
		  /* 82104BF8h */ case    4:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82104BF8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82104BF8h case    4:*/		return 0x82104BFC;
		  /* 82104BFCh */ case    5:  		/* stwx R11, <#[R10 + R28]> */
		/* 82104BFCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 82104BFCh case    5:*/		return 0x82104C00;
		  /* 82104C00h */ case    6:  		/* addi R28, R28, 4 */
		/* 82104C00h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82104C00h case    6:*/		return 0x82104C04;
		  /* 82104C04h */ case    7:  		/* lwz R11, <#[R31 + 16]> */
		/* 82104C04h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82104C04h case    7:*/		return 0x82104C08;
		  /* 82104C08h */ case    8:  		/* stwx R17, <#[R11 + R6]> */
		/* 82104C08h case    8:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82104C08h case    8:*/		return 0x82104C0C;
	}
	return 0x82104C0C;
} // Block from 82104BE8h-82104C0Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82104C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104C0C);
		  /* 82104C0Ch */ case    0:  		/* addi R29, R29, 1 */
		/* 82104C0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82104C0Ch case    0:*/		return 0x82104C10;
		  /* 82104C10h */ case    1:  		/* addi R6, R6, 4 */
		/* 82104C10h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 82104C10h case    1:*/		return 0x82104C14;
		  /* 82104C14h */ case    2:  		/* cmplw CR6, R29, R18 */
		/* 82104C14h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R18);
		/* 82104C14h case    2:*/		return 0x82104C18;
		  /* 82104C18h */ case    3:  		/* bc 12, CR6_LT, -152 */
		/* 82104C18h case    3:*/		if ( regs.CR[6].lt ) { return 0x82104B80;  }
		/* 82104C18h case    3:*/		return 0x82104C1C;
	}
	return 0x82104C1C;
} // Block from 82104C0Ch-82104C1Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82104C1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104C1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104C1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104C1C);
		  /* 82104C1Ch */ case    0:  		/* addi R26, R26, 1 */
		/* 82104C1Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82104C1Ch case    0:*/		return 0x82104C20;
		  /* 82104C20h */ case    1:  		/* addi R27, R27, 4 */
		/* 82104C20h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 82104C20h case    1:*/		return 0x82104C24;
		  /* 82104C24h */ case    2:  		/* cmplw CR6, R26, R18 */
		/* 82104C24h case    2:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R18);
		/* 82104C24h case    2:*/		return 0x82104C28;
		  /* 82104C28h */ case    3:  		/* bc 12, CR6_LT, -388 */
		/* 82104C28h case    3:*/		if ( regs.CR[6].lt ) { return 0x82104AA4;  }
		/* 82104C28h case    3:*/		return 0x82104C2C;
	}
	return 0x82104C2C;
} // Block from 82104C1Ch-82104C2Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82104C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104C2C);
		  /* 82104C2Ch */ case    0:  		/* mr R3, R31 */
		/* 82104C2Ch case    0:*/		regs.R3 = regs.R31;
		/* 82104C2Ch case    0:*/		return 0x82104C30;
		  /* 82104C30h */ case    1:  		/* bl -35208 */
		/* 82104C30h case    1:*/		regs.LR = 0x82104C34; return 0x820FC2A8;
		/* 82104C30h case    1:*/		return 0x82104C34;
		  /* 82104C34h */ case    2:  		/* or. R21, R3, R3 */
		/* 82104C34h case    2:*/		cpu::op::or<1>(regs,&regs.R21,regs.R3,regs.R3);
		/* 82104C34h case    2:*/		return 0x82104C38;
		  /* 82104C38h */ case    3:  		/* li R20, 1 */
		/* 82104C38h case    3:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 82104C38h case    3:*/		return 0x82104C3C;
		  /* 82104C3Ch */ case    4:  		/* li R19, 1 */
		/* 82104C3Ch case    4:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 82104C3Ch case    4:*/		return 0x82104C40;
		  /* 82104C40h */ case    5:  		/* bc 4, CR0_EQ, 692 */
		/* 82104C40h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82104EF4;  }
		/* 82104C40h case    5:*/		return 0x82104C44;
		  /* 82104C44h */ case    6:  		/* li R9, 0 */
		/* 82104C44h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82104C44h case    6:*/		return 0x82104C48;
		  /* 82104C48h */ case    7:  		/* cmplwi CR6, R18, 0 */
		/* 82104C48h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82104C48h case    7:*/		return 0x82104C4C;
		  /* 82104C4Ch */ case    8:  		/* bc 12, CR6_EQ, 680 */
		/* 82104C4Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82104EF4;  }
		/* 82104C4Ch case    8:*/		return 0x82104C50;
		  /* 82104C50h */ case    9:  		/* lwz R8, <#[R31 + 16]> */
		/* 82104C50h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 82104C50h case    9:*/		return 0x82104C54;
		  /* 82104C54h */ case   10:  		/* li R11, 0 */
		/* 82104C54h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82104C54h case   10:*/		return 0x82104C58;
		  /* 82104C58h */ case   11:  		/* lwzx R10, <#[R8 + R11]> */
		/* 82104C58h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82104C58h case   11:*/		return 0x82104C5C;
		  /* 82104C5Ch */ case   12:  		/* cmpwi CR6, R10, -1 */
		/* 82104C5Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82104C5Ch case   12:*/		return 0x82104C60;
		  /* 82104C60h */ case   13:  		/* bc 12, CR6_EQ, 44 */
		/* 82104C60h case   13:*/		if ( regs.CR[6].eq ) { return 0x82104C8C;  }
		/* 82104C60h case   13:*/		return 0x82104C64;
		  /* 82104C64h */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82104C64h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82104C64h case   14:*/		return 0x82104C68;
		  /* 82104C68h */ case   15:  		/* lwz R7, <#[R22 + 20]> */
		/* 82104C68h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R22 + 0x00000014) );
		/* 82104C68h case   15:*/		return 0x82104C6C;
		  /* 82104C6Ch */ case   16:  		/* lwz R6, <#[R22 + 16]> */
		/* 82104C6Ch case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R22 + 0x00000010) );
		/* 82104C6Ch case   16:*/		return 0x82104C70;
		  /* 82104C70h */ case   17:  		/* lwzx R10, <#[R10 + R7]> */
		/* 82104C70h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82104C70h case   17:*/		return 0x82104C74;
		  /* 82104C74h */ case   18:  		/* lwz R10, <#[R10 + 4]> */
		/* 82104C74h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82104C74h case   18:*/		return 0x82104C78;
		  /* 82104C78h */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82104C78h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82104C78h case   19:*/		return 0x82104C7C;
		  /* 82104C7Ch */ case   20:  		/* lwzx R10, <#[R10 + R6]> */
		/* 82104C7Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82104C7Ch case   20:*/		return 0x82104C80;
		  /* 82104C80h */ case   21:  		/* lwz R10, <#[R10 + 4]> */
		/* 82104C80h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82104C80h case   21:*/		return 0x82104C84;
		  /* 82104C84h */ case   22:  		/* rlwinm. R10, R10, 0, 19, 19 */
		/* 82104C84h case   22:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R10,regs.R10);
		/* 82104C84h case   22:*/		return 0x82104C88;
		  /* 82104C88h */ case   23:  		/* bc 4, CR0_EQ, 36 */
		/* 82104C88h case   23:*/		if ( !regs.CR[0].eq ) { return 0x82104CAC;  }
		/* 82104C88h case   23:*/		return 0x82104C8C;
	}
	return 0x82104C8C;
} // Block from 82104C2Ch-82104C8Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 82104C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104C8C);
		  /* 82104C8Ch */ case    0:  		/* addi R9, R9, 1 */
		/* 82104C8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82104C8Ch case    0:*/		return 0x82104C90;
		  /* 82104C90h */ case    1:  		/* addi R11, R11, 4 */
		/* 82104C90h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82104C90h case    1:*/		return 0x82104C94;
		  /* 82104C94h */ case    2:  		/* cmplw CR6, R9, R18 */
		/* 82104C94h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R18);
		/* 82104C94h case    2:*/		return 0x82104C98;
		  /* 82104C98h */ case    3:  		/* bc 12, CR6_LT, -64 */
		/* 82104C98h case    3:*/		if ( regs.CR[6].lt ) { return 0x82104C58;  }
		/* 82104C98h case    3:*/		return 0x82104C9C;
		  /* 82104C9Ch */ case    4:  		/* b 600 */
		/* 82104C9Ch case    4:*/		return 0x82104EF4;
		/* 82104C9Ch case    4:*/		return 0x82104CA0;
	}
	return 0x82104CA0;
} // Block from 82104C8Ch-82104CA0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82104CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104CA0);
		  /* 82104CA0h */ case    0:  		/* lis R3, -32761 */
		/* 82104CA0h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82104CA0h case    0:*/		return 0x82104CA4;
		  /* 82104CA4h */ case    1:  		/* ori R3, R3, 14 */
		/* 82104CA4h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82104CA4h case    1:*/		return 0x82104CA8;
		  /* 82104CA8h */ case    2:  		/* b 600 */
		/* 82104CA8h case    2:*/		return 0x82104F00;
		/* 82104CA8h case    2:*/		return 0x82104CAC;
	}
	return 0x82104CAC;
} // Block from 82104CA0h-82104CACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82104CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104CAC);
		  /* 82104CACh */ case    0:  		/* li R21, 1 */
		/* 82104CACh case    0:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 82104CACh case    0:*/		return 0x82104CB0;
		  /* 82104CB0h */ case    1:  		/* b 580 */
		/* 82104CB0h case    1:*/		return 0x82104EF4;
		/* 82104CB0h case    1:*/		return 0x82104CB4;
		  /* 82104CB4h */ case    2:  		/* cmplwi CR6, R16, 4 */
		/* 82104CB4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000004);
		/* 82104CB4h case    2:*/		return 0x82104CB8;
		  /* 82104CB8h */ case    3:  		/* bc 12, CR6_GT, 20 */
		/* 82104CB8h case    3:*/		if ( regs.CR[6].gt ) { return 0x82104CCC;  }
		/* 82104CB8h case    3:*/		return 0x82104CBC;
		  /* 82104CBCh */ case    4:  		/* cmpwi CR6, R21, 0 */
		/* 82104CBCh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 82104CBCh case    4:*/		return 0x82104CC0;
		  /* 82104CC0h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82104CC0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82104CCC;  }
		/* 82104CC0h case    5:*/		return 0x82104CC4;
		  /* 82104CC4h */ case    6:  		/* li R20, 0 */
		/* 82104CC4h case    6:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 82104CC4h case    6:*/		return 0x82104CC8;
		  /* 82104CC8h */ case    7:  		/* li R19, 0 */
		/* 82104CC8h case    7:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 82104CC8h case    7:*/		return 0x82104CCC;
	}
	return 0x82104CCC;
} // Block from 82104CACh-82104CCCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 82104CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104CCC);
		  /* 82104CCCh */ case    0:  		/* li R25, 0 */
		/* 82104CCCh case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82104CCCh case    0:*/		return 0x82104CD0;
		  /* 82104CD0h */ case    1:  		/* li R23, 0 */
		/* 82104CD0h case    1:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82104CD0h case    1:*/		return 0x82104CD4;
		  /* 82104CD4h */ case    2:  		/* li R27, 0 */
		/* 82104CD4h case    2:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82104CD4h case    2:*/		return 0x82104CD8;
	}
	return 0x82104CD8;
} // Block from 82104CCCh-82104CD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82104CD8h
// Function '?SimplifyDotProduct@CProgram@D3DXShader@@AAAJPAVCInstruction@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104CD8);
		  /* 82104CD8h */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 82104CD8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82104CD8h case    0:*/		return 0x82104CDC;
		  /* 82104CDCh */ case    1:  		/* bc 12, CR6_EQ, 544 */
		/* 82104CDCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82104EFC;  }
		/* 82104CDCh case    1:*/		return 0x82104CE0;
		  /* 82104CE0h */ case    2:  		/* lwz R24, <#[R31 + 16]> */
		/* 82104CE0h case    2:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R31 + 0x00000010) );
		/* 82104CE0h case    2:*/		return 0x82104CE4;
		  /* 82104CE4h */ case    3:  		/* li R26, 0 */
		/* 82104CE4h case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82104CE4h case    3:*/		return 0x82104CE8;
		  /* 82104CE8h */ case    4:  		/* lwzx R11, <#[R24 + R26]> */
		/* 82104CE8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + regs.R26 + 0x00000000) );
		/* 82104CE8h case    4:*/		return 0x82104CEC;
		  /* 82104CECh */ case    5:  		/* cmpwi CR6, R11, -1 */
		/* 82104CECh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82104CECh case    5:*/		return 0x82104CF0;
		  /* 82104CF0h */ case    6:  		/* bc 12, CR6_EQ, 172 */
		/* 82104CF0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82104D9C;  }
		/* 82104CF0h case    6:*/		return 0x82104CF4;
		  /* 82104CF4h */ case    7:  		/* li R28, 0 */
		/* 82104CF4h case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82104CF4h case    7:*/		return 0x82104CF8;
		  /* 82104CF8h */ case    8:  		/* li R29, 0 */
		/* 82104CF8h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82104CF8h case    8:*/		return 0x82104CFC;
		  /* 82104CFCh */ case    9:  		/* li R30, 0 */
		/* 82104CFCh case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82104CFCh case    9:*/		return 0x82104D00;
		  /* 82104D00h */ case   10:  		/* cmplwi CR6, R28, 4 */
		/* 82104D00h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000004);
		/* 82104D00h case   10:*/		return 0x82104D04;
		  /* 82104D04h */ case   11:  		/* bc 4, CR6_LT, 136 */
		/* 82104D04h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82104D8C;  }
		/* 82104D04h case   11:*/		return 0x82104D08;
		  /* 82104D08h */ case   12:  		/* lwzx R11, <#[R24 + R30]> */
		/* 82104D08h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + regs.R30 + 0x00000000) );
		/* 82104D08h case   12:*/		return 0x82104D0C;
		  /* 82104D0Ch */ case   13:  		/* cmpwi CR6, R11, -1 */
		/* 82104D0Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82104D0Ch case   13:*/		return 0x82104D10;
		  /* 82104D10h */ case   14:  		/* bc 12, CR6_EQ, 108 */
		/* 82104D10h case   14:*/		if ( regs.CR[6].eq ) { return 0x82104D7C;  }
		/* 82104D10h case   14:*/		return 0x82104D14;
		  /* 82104D14h */ case   15:  		/* cmpwi CR6, R20, 0 */
		/* 82104D14h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 82104D14h case   15:*/		return 0x82104D18;
		  /* 82104D18h */ case   16:  		/* bc 12, CR6_EQ, 60 */
		/* 82104D18h case   16:*/		if ( regs.CR[6].eq ) { return 0x82104D54;  }
		/* 82104D18h case   16:*/		return 0x82104D1C;
		  /* 82104D1Ch */ case   17:  		/* lwz R10, <#[R31 + 16]> */
		/* 82104D1Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82104D1Ch case   17:*/		return 0x82104D20;
		  /* 82104D20h */ case   18:  		/* lwzx R11, <#[R10 + R30]> */
		/* 82104D20h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 82104D20h case   18:*/		return 0x82104D24;
		  /* 82104D24h */ case   19:  		/* lwzx R10, <#[R10 + R26]> */
		/* 82104D24h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 82104D24h case   19:*/		return 0x82104D28;
		  /* 82104D28h */ case   20:  		/* cmplw CR6, R10, R11 */
		/* 82104D28h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82104D28h case   20:*/		return 0x82104D2C;
		  /* 82104D2Ch */ case   21:  		/* bc 12, CR6_EQ, 40 */
		/* 82104D2Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82104D54;  }
		/* 82104D2Ch case   21:*/		return 0x82104D30;
		  /* 82104D30h */ case   22:  		/* lwz R9, <#[R22 + 20]> */
		/* 82104D30h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000014) );
		/* 82104D30h case   22:*/		return 0x82104D34;
		  /* 82104D34h */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82104D34h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82104D34h case   23:*/		return 0x82104D38;
		  /* 82104D38h */ case   24:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82104D38h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82104D38h case   24:*/		return 0x82104D3C;
		  /* 82104D3Ch */ case   25:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82104D3Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82104D3Ch case   25:*/		return 0x82104D40;
		  /* 82104D40h */ case   26:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82104D40h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82104D40h case   26:*/		return 0x82104D44;
		  /* 82104D44h */ case   27:  		/* lwz R11, <#[R11 + 64]> */
		/* 82104D44h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000040) );
		/* 82104D44h case   27:*/		return 0x82104D48;
		  /* 82104D48h */ case   28:  		/* lwz R10, <#[R10 + 64]> */
		/* 82104D48h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000040) );
		/* 82104D48h case   28:*/		return 0x82104D4C;
		  /* 82104D4Ch */ case   29:  		/* and. R11, R10, R11 */
		/* 82104D4Ch case   29:*/		cpu::op::and<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82104D4Ch case   29:*/		return 0x82104D50;
		  /* 82104D50h */ case   30:  		/* bc 12, CR0_EQ, 44 */
		/* 82104D50h case   30:*/		if ( regs.CR[0].eq ) { return 0x82104D7C;  }
		/* 82104D50h case   30:*/		return 0x82104D54;
	}
	return 0x82104D54;
} // Block from 82104CD8h-82104D54h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82104D54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104D54);
		  /* 82104D54h */ case    0:  		/* cmpwi CR6, R19, 0 */
		/* 82104D54h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 82104D54h case    0:*/		return 0x82104D58;
		  /* 82104D58h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 82104D58h case    1:*/		if ( regs.CR[6].eq ) { return 0x82104D78;  }
		/* 82104D58h case    1:*/		return 0x82104D5C;
		  /* 82104D5Ch */ case    2:  		/* mr R6, R29 */
		/* 82104D5Ch case    2:*/		regs.R6 = regs.R29;
		/* 82104D5Ch case    2:*/		return 0x82104D60;
		  /* 82104D60h */ case    3:  		/* mr R5, R27 */
		/* 82104D60h case    3:*/		regs.R5 = regs.R27;
		/* 82104D60h case    3:*/		return 0x82104D64;
		  /* 82104D64h */ case    4:  		/* mr R4, R31 */
		/* 82104D64h case    4:*/		regs.R4 = regs.R31;
		/* 82104D64h case    4:*/		return 0x82104D68;
		  /* 82104D68h */ case    5:  		/* mr R3, R22 */
		/* 82104D68h case    5:*/		regs.R3 = regs.R22;
		/* 82104D68h case    5:*/		return 0x82104D6C;
		  /* 82104D6Ch */ case    6:  		/* bl -1164 */
		/* 82104D6Ch case    6:*/		regs.LR = 0x82104D70; return 0x821048E0;
		/* 82104D6Ch case    6:*/		return 0x82104D70;
		  /* 82104D70h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 82104D70h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82104D70h case    7:*/		return 0x82104D74;
		  /* 82104D74h */ case    8:  		/* bc 4, CR0_EQ, 8 */
		/* 82104D74h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82104D7C;  }
		/* 82104D74h case    8:*/		return 0x82104D78;
	}
	return 0x82104D78;
} // Block from 82104D54h-82104D78h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82104D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104D78);
		  /* 82104D78h */ case    0:  		/* addi R28, R28, 1 */
		/* 82104D78h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82104D78h case    0:*/		return 0x82104D7C;
	}
	return 0x82104D7C;
} // Block from 82104D78h-82104D7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82104D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104D7C);
		  /* 82104D7Ch */ case    0:  		/* addi R29, R29, 1 */
		/* 82104D7Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82104D7Ch case    0:*/		return 0x82104D80;
		  /* 82104D80h */ case    1:  		/* addi R30, R30, 4 */
		/* 82104D80h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82104D80h case    1:*/		return 0x82104D84;
		  /* 82104D84h */ case    2:  		/* cmplw CR6, R29, R18 */
		/* 82104D84h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R18);
		/* 82104D84h case    2:*/		return 0x82104D88;
		  /* 82104D88h */ case    3:  		/* bc 12, CR6_LT, -136 */
		/* 82104D88h case    3:*/		if ( regs.CR[6].lt ) { return 0x82104D00;  }
		/* 82104D88h case    3:*/		return 0x82104D8C;
	}
	return 0x82104D8C;
} // Block from 82104D7Ch-82104D8Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82104D8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104D8C);
		  /* 82104D8Ch */ case    0:  		/* cmplw CR6, R25, R28 */
		/* 82104D8Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R28);
		/* 82104D8Ch case    0:*/		return 0x82104D90;
		  /* 82104D90h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 82104D90h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82104D9C;  }
		/* 82104D90h case    1:*/		return 0x82104D94;
		  /* 82104D94h */ case    2:  		/* mr R25, R28 */
		/* 82104D94h case    2:*/		regs.R25 = regs.R28;
		/* 82104D94h case    2:*/		return 0x82104D98;
		  /* 82104D98h */ case    3:  		/* mr R23, R27 */
		/* 82104D98h case    3:*/		regs.R23 = regs.R27;
		/* 82104D98h case    3:*/		return 0x82104D9C;
	}
	return 0x82104D9C;
} // Block from 82104D8Ch-82104D9Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82104D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104D9C);
		  /* 82104D9Ch */ case    0:  		/* addi R27, R27, 1 */
		/* 82104D9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82104D9Ch case    0:*/		return 0x82104DA0;
		  /* 82104DA0h */ case    1:  		/* addi R26, R26, 4 */
		/* 82104DA0h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 82104DA0h case    1:*/		return 0x82104DA4;
		  /* 82104DA4h */ case    2:  		/* cmplw CR6, R27, R18 */
		/* 82104DA4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R18);
		/* 82104DA4h case    2:*/		return 0x82104DA8;
		  /* 82104DA8h */ case    3:  		/* bc 12, CR6_LT, -192 */
		/* 82104DA8h case    3:*/		if ( regs.CR[6].lt ) { return 0x82104CE8;  }
		/* 82104DA8h case    3:*/		return 0x82104DAC;
		  /* 82104DACh */ case    4:  		/* cmplwi CR6, R25, 0 */
		/* 82104DACh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82104DACh case    4:*/		return 0x82104DB0;
		  /* 82104DB0h */ case    5:  		/* bc 12, CR6_EQ, 332 */
		/* 82104DB0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82104EFC;  }
		/* 82104DB0h case    5:*/		return 0x82104DB4;
		  /* 82104DB4h */ case    6:  		/* lwz R4, <#[R31]> */
		/* 82104DB4h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82104DB4h case    6:*/		return 0x82104DB8;
		  /* 82104DB8h */ case    7:  		/* mr R6, R17 */
		/* 82104DB8h case    7:*/		regs.R6 = regs.R17;
		/* 82104DB8h case    7:*/		return 0x82104DBC;
		  /* 82104DBCh */ case    8:  		/* mr R5, R17 */
		/* 82104DBCh case    8:*/		regs.R5 = regs.R17;
		/* 82104DBCh case    8:*/		return 0x82104DC0;
		  /* 82104DC0h */ case    9:  		/* rlwimi R4, R25, 0, 12, 31 */
		/* 82104DC0h case    9:*/		cpu::op::rlwimi<0,0,12,31>(regs,&regs.R4,regs.R25);
		/* 82104DC0h case    9:*/		return 0x82104DC4;
		  /* 82104DC4h */ case   10:  		/* mr R3, R22 */
		/* 82104DC4h case   10:*/		regs.R3 = regs.R22;
		/* 82104DC4h case   10:*/		return 0x82104DC8;
		  /* 82104DC8h */ case   11:  		/* bl -31488 */
		/* 82104DC8h case   11:*/		regs.LR = 0x82104DCC; return 0x820FD2C8;
		/* 82104DC8h case   11:*/		return 0x82104DCC;
		  /* 82104DCCh */ case   12:  		/* cmpwi CR6, R3, -1 */
		/* 82104DCCh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82104DCCh case   12:*/		return 0x82104DD0;
		  /* 82104DD0h */ case   13:  		/* bc 12, CR6_EQ, -304 */
		/* 82104DD0h case   13:*/		if ( regs.CR[6].eq ) { return 0x82104CA0;  }
		/* 82104DD0h case   13:*/		return 0x82104DD4;
		  /* 82104DD4h */ case   14:  		/* lwz R11, <#[R22 + 24]> */
		/* 82104DD4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000018) );
		/* 82104DD4h case   14:*/		return 0x82104DD8;
		  /* 82104DD8h */ case   15:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82104DD8h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82104DD8h case   15:*/		return 0x82104DDC;
		  /* 82104DDCh */ case   16:  		/* mr R4, R31 */
		/* 82104DDCh case   16:*/		regs.R4 = regs.R31;
		/* 82104DDCh case   16:*/		return 0x82104DE0;
		  /* 82104DE0h */ case   17:  		/* lwzx R30, <#[R10 + R11]> */
		/* 82104DE0h case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82104DE0h case   17:*/		return 0x82104DE4;
		  /* 82104DE4h */ case   18:  		/* mr R3, R30 */
		/* 82104DE4h case   18:*/		regs.R3 = regs.R30;
		/* 82104DE4h case   18:*/		return 0x82104DE8;
		  /* 82104DE8h */ case   19:  		/* bl -36600 */
		/* 82104DE8h case   19:*/		regs.LR = 0x82104DEC; return 0x820FBEF0;
		/* 82104DE8h case   19:*/		return 0x82104DEC;
		  /* 82104DECh */ case   20:  		/* lwz R10, <#[R31 + 16]> */
		/* 82104DECh case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82104DECh case   20:*/		return 0x82104DF0;
		  /* 82104DF0h */ case   21:  		/* rlwinm R11, R23, 2, 0, 29 */
		/* 82104DF0h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R23);
		/* 82104DF0h case   21:*/		return 0x82104DF4;
		  /* 82104DF4h */ case   22:  		/* li R28, 0 */
		/* 82104DF4h case   22:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82104DF4h case   22:*/		return 0x82104DF8;
		  /* 82104DF8h */ case   23:  		/* li R27, 0 */
		/* 82104DF8h case   23:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82104DF8h case   23:*/		return 0x82104DFC;
		  /* 82104DFCh */ case   24:  		/* li R29, 0 */
		/* 82104DFCh case   24:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82104DFCh case   24:*/		return 0x82104E00;
		  /* 82104E00h */ case   25:  		/* li R26, 0 */
		/* 82104E00h case   25:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82104E00h case   25:*/		return 0x82104E04;
		  /* 82104E04h */ case   26:  		/* lwzx R25, <#[R11 + R10]> */
		/* 82104E04h case   26:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82104E04h case   26:*/		return 0x82104E08;
		  /* 82104E08h */ case   27:  		/* cmplwi CR6, R26, 16 */
		/* 82104E08h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000010);
		/* 82104E08h case   27:*/		return 0x82104E0C;
		  /* 82104E0Ch */ case   28:  		/* bc 4, CR6_LT, 232 */
		/* 82104E0Ch case   28:*/		if ( !regs.CR[6].lt ) { return 0x82104EF4;  }
		/* 82104E0Ch case   28:*/		return 0x82104E10;
		  /* 82104E10h */ case   29:  		/* lwz R11, <#[R31 + 16]> */
		/* 82104E10h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82104E10h case   29:*/		return 0x82104E14;
		  /* 82104E14h */ case   30:  		/* lwzx R11, <#[R11 + R29]> */
		/* 82104E14h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82104E14h case   30:*/		return 0x82104E18;
		  /* 82104E18h */ case   31:  		/* cmpwi CR6, R11, -1 */
		/* 82104E18h case   31:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82104E18h case   31:*/		return 0x82104E1C;
		  /* 82104E1Ch */ case   32:  		/* bc 12, CR6_EQ, 200 */
		/* 82104E1Ch case   32:*/		if ( regs.CR[6].eq ) { return 0x82104EE4;  }
		/* 82104E1Ch case   32:*/		return 0x82104E20;
		  /* 82104E20h */ case   33:  		/* cmpwi CR6, R20, 0 */
		/* 82104E20h case   33:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 82104E20h case   33:*/		return 0x82104E24;
		  /* 82104E24h */ case   34:  		/* bc 12, CR6_EQ, 48 */
		/* 82104E24h case   34:*/		if ( regs.CR[6].eq ) { return 0x82104E54;  }
		/* 82104E24h case   34:*/		return 0x82104E28;
		  /* 82104E28h */ case   35:  		/* cmplw CR6, R25, R11 */
		/* 82104E28h case   35:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 82104E28h case   35:*/		return 0x82104E2C;
		  /* 82104E2Ch */ case   36:  		/* bc 12, CR6_EQ, 40 */
		/* 82104E2Ch case   36:*/		if ( regs.CR[6].eq ) { return 0x82104E54;  }
		/* 82104E2Ch case   36:*/		return 0x82104E30;
		  /* 82104E30h */ case   37:  		/* lwz R10, <#[R22 + 20]> */
		/* 82104E30h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000014) );
		/* 82104E30h case   37:*/		return 0x82104E34;
		  /* 82104E34h */ case   38:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82104E34h case   38:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82104E34h case   38:*/		return 0x82104E38;
		  /* 82104E38h */ case   39:  		/* rlwinm R9, R25, 2, 0, 29 */
		/* 82104E38h case   39:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R25);
		/* 82104E38h case   39:*/		return 0x82104E3C;
		  /* 82104E3Ch */ case   40:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82104E3Ch case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82104E3Ch case   40:*/		return 0x82104E40;
		  /* 82104E40h */ case   41:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82104E40h case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82104E40h case   41:*/		return 0x82104E44;
		  /* 82104E44h */ case   42:  		/* lwz R11, <#[R11 + 64]> */
		/* 82104E44h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000040) );
		/* 82104E44h case   42:*/		return 0x82104E48;
		  /* 82104E48h */ case   43:  		/* lwz R10, <#[R10 + 64]> */
		/* 82104E48h case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000040) );
		/* 82104E48h case   43:*/		return 0x82104E4C;
		  /* 82104E4Ch */ case   44:  		/* and. R11, R11, R10 */
		/* 82104E4Ch case   44:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82104E4Ch case   44:*/		return 0x82104E50;
		  /* 82104E50h */ case   45:  		/* bc 12, CR0_EQ, 148 */
		/* 82104E50h case   45:*/		if ( regs.CR[0].eq ) { return 0x82104EE4;  }
		/* 82104E50h case   45:*/		return 0x82104E54;
	}
	return 0x82104E54;
} // Block from 82104D9Ch-82104E54h (46 instructions)

//////////////////////////////////////////////////////
// Block at 82104E54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104E54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104E54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104E54);
		  /* 82104E54h */ case    0:  		/* cmpwi CR6, R19, 0 */
		/* 82104E54h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 82104E54h case    0:*/		return 0x82104E58;
		  /* 82104E58h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 82104E58h case    1:*/		if ( regs.CR[6].eq ) { return 0x82104E78;  }
		/* 82104E58h case    1:*/		return 0x82104E5C;
		  /* 82104E5Ch */ case    2:  		/* mr R6, R27 */
		/* 82104E5Ch case    2:*/		regs.R6 = regs.R27;
		/* 82104E5Ch case    2:*/		return 0x82104E60;
		  /* 82104E60h */ case    3:  		/* mr R5, R23 */
		/* 82104E60h case    3:*/		regs.R5 = regs.R23;
		/* 82104E60h case    3:*/		return 0x82104E64;
		  /* 82104E64h */ case    4:  		/* mr R4, R31 */
		/* 82104E64h case    4:*/		regs.R4 = regs.R31;
		/* 82104E64h case    4:*/		return 0x82104E68;
		  /* 82104E68h */ case    5:  		/* mr R3, R22 */
		/* 82104E68h case    5:*/		regs.R3 = regs.R22;
		/* 82104E68h case    5:*/		return 0x82104E6C;
		  /* 82104E6Ch */ case    6:  		/* bl -1420 */
		/* 82104E6Ch case    6:*/		regs.LR = 0x82104E70; return 0x821048E0;
		/* 82104E6Ch case    6:*/		return 0x82104E70;
		  /* 82104E70h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 82104E70h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82104E70h case    7:*/		return 0x82104E74;
		  /* 82104E74h */ case    8:  		/* bc 4, CR0_EQ, 112 */
		/* 82104E74h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82104EE4;  }
		/* 82104E74h case    8:*/		return 0x82104E78;
	}
	return 0x82104E78;
} // Block from 82104E54h-82104E78h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82104E78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104E78);
		  /* 82104E78h */ case    0:  		/* li R11, 0 */
		/* 82104E78h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82104E78h case    0:*/		return 0x82104E7C;
		  /* 82104E7Ch */ case    1:  		/* cmplwi CR6, R15, 0 */
		/* 82104E7Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R15,0x00000000);
		/* 82104E7Ch case    1:*/		return 0x82104E80;
		  /* 82104E80h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 82104E80h case    2:*/		if ( regs.CR[6].eq ) { return 0x82104EC0;  }
		/* 82104E80h case    2:*/		return 0x82104E84;
		  /* 82104E84h */ case    3:  		/* mtspr CTR, R15 */
		/* 82104E84h case    3:*/		regs.CTR = regs.R15;
		/* 82104E84h case    3:*/		return 0x82104E88;
		  /* 82104E88h */ case    4:  		/* lwz R10, <#[R31 + 12]> */
		/* 82104E88h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82104E88h case    4:*/		return 0x82104E8C;
		  /* 82104E8Ch */ case    5:  		/* lwz R9, <#[R30 + 12]> */
		/* 82104E8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 82104E8Ch case    5:*/		return 0x82104E90;
		  /* 82104E90h */ case    6:  		/* mullw R10, R11, R10 */
		/* 82104E90h case    6:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82104E90h case    6:*/		return 0x82104E94;
		  /* 82104E94h */ case    7:  		/* lwz R8, <#[R31 + 8]> */
		/* 82104E94h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82104E94h case    7:*/		return 0x82104E98;
		  /* 82104E98h */ case    8:  		/* lwz R7, <#[R30 + 8]> */
		/* 82104E98h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 82104E98h case    8:*/		return 0x82104E9C;
		  /* 82104E9Ch */ case    9:  		/* add R6, R10, R27 */
		/* 82104E9Ch case    9:*/		cpu::op::add<0>(regs,&regs.R6,regs.R10,regs.R27);
		/* 82104E9Ch case    9:*/		return 0x82104EA0;
		  /* 82104EA0h */ case   10:  		/* mullw R10, R9, R11 */
		/* 82104EA0h case   10:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R9,regs.R11);
		/* 82104EA0h case   10:*/		return 0x82104EA4;
		  /* 82104EA4h */ case   11:  		/* rlwinm R9, R6, 2, 0, 29 */
		/* 82104EA4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R6);
		/* 82104EA4h case   11:*/		return 0x82104EA8;
		  /* 82104EA8h */ case   12:  		/* add R10, R10, R28 */
		/* 82104EA8h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R28);
		/* 82104EA8h case   12:*/		return 0x82104EAC;
		  /* 82104EACh */ case   13:  		/* addi R11, R11, 1 */
		/* 82104EACh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82104EACh case   13:*/		return 0x82104EB0;
		  /* 82104EB0h */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82104EB0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82104EB0h case   14:*/		return 0x82104EB4;
		  /* 82104EB4h */ case   15:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82104EB4h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82104EB4h case   15:*/		return 0x82104EB8;
		  /* 82104EB8h */ case   16:  		/* stwx R9, <#[R10 + R7]> */
		/* 82104EB8h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82104EB8h case   16:*/		return 0x82104EBC;
		  /* 82104EBCh */ case   17:  		/* bc 16, CR0_LT, -52 */
		/* 82104EBCh case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82104E88;  }
		/* 82104EBCh case   17:*/		return 0x82104EC0;
	}
	return 0x82104EC0;
} // Block from 82104E78h-82104EC0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82104EC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104EC0);
		  /* 82104EC0h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82104EC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82104EC0h case    0:*/		return 0x82104EC4;
		  /* 82104EC4h */ case    1:  		/* addi R16, R16, -1 */
		/* 82104EC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0xFFFFFFFF);
		/* 82104EC4h case    1:*/		return 0x82104EC8;
		  /* 82104EC8h */ case    2:  		/* lwz R10, <#[R30 + 16]> */
		/* 82104EC8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 82104EC8h case    2:*/		return 0x82104ECC;
		  /* 82104ECCh */ case    3:  		/* addi R28, R28, 1 */
		/* 82104ECCh case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82104ECCh case    3:*/		return 0x82104ED0;
		  /* 82104ED0h */ case    4:  		/* lwzx R11, <#[R11 + R29]> */
		/* 82104ED0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82104ED0h case    4:*/		return 0x82104ED4;
		  /* 82104ED4h */ case    5:  		/* stwx R11, <#[R10 + R26]> */
		/* 82104ED4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 82104ED4h case    5:*/		return 0x82104ED8;
		  /* 82104ED8h */ case    6:  		/* addi R26, R26, 4 */
		/* 82104ED8h case    6:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 82104ED8h case    6:*/		return 0x82104EDC;
		  /* 82104EDCh */ case    7:  		/* lwz R11, <#[R31 + 16]> */
		/* 82104EDCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82104EDCh case    7:*/		return 0x82104EE0;
		  /* 82104EE0h */ case    8:  		/* stwx R17, <#[R11 + R29]> */
		/* 82104EE0h case    8:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82104EE0h case    8:*/		return 0x82104EE4;
	}
	return 0x82104EE4;
} // Block from 82104EC0h-82104EE4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82104EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104EE4);
		  /* 82104EE4h */ case    0:  		/* addi R27, R27, 1 */
		/* 82104EE4h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82104EE4h case    0:*/		return 0x82104EE8;
		  /* 82104EE8h */ case    1:  		/* addi R29, R29, 4 */
		/* 82104EE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82104EE8h case    1:*/		return 0x82104EEC;
		  /* 82104EECh */ case    2:  		/* cmplw CR6, R27, R18 */
		/* 82104EECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R18);
		/* 82104EECh case    2:*/		return 0x82104EF0;
		  /* 82104EF0h */ case    3:  		/* bc 12, CR6_LT, -232 */
		/* 82104EF0h case    3:*/		if ( regs.CR[6].lt ) { return 0x82104E08;  }
		/* 82104EF0h case    3:*/		return 0x82104EF4;
	}
	return 0x82104EF4;
} // Block from 82104EE4h-82104EF4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82104EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104EF4);
		  /* 82104EF4h */ case    0:  		/* cmplwi CR6, R16, 0 */
		/* 82104EF4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 82104EF4h case    0:*/		return 0x82104EF8;
		  /* 82104EF8h */ case    1:  		/* bc 4, CR6_EQ, -580 */
		/* 82104EF8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82104CB4;  }
		/* 82104EF8h case    1:*/		return 0x82104EFC;
	}
	return 0x82104EFC;
} // Block from 82104EF4h-82104EFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82104EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104EFC);
		  /* 82104EFCh */ case    0:  		/* li R3, 0 */
		/* 82104EFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82104EFCh case    0:*/		return 0x82104F00;
	}
	return 0x82104F00;
} // Block from 82104EFCh-82104F00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82104F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104F00);
		  /* 82104F00h */ case    0:  		/* addi R1, R1, 224 */
		/* 82104F00h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 82104F00h case    0:*/		return 0x82104F04;
		  /* 82104F04h */ case    1:  		/* b -474256 */
		/* 82104F04h case    1:*/		return 0x82091274;
		/* 82104F04h case    1:*/		return 0x82104F08;
	}
	return 0x82104F08;
} // Block from 82104F00h-82104F08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82104F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104F08);
		  /* 82104F08h */ case    0:  		/* mfspr R12, LR */
		/* 82104F08h case    0:*/		regs.R12 = regs.LR;
		/* 82104F08h case    0:*/		return 0x82104F0C;
		  /* 82104F0Ch */ case    1:  		/* bl -474304 */
		/* 82104F0Ch case    1:*/		regs.LR = 0x82104F10; return 0x8209124C;
		/* 82104F0Ch case    1:*/		return 0x82104F10;
		  /* 82104F10h */ case    2:  		/* stfd FR31, <#[R1 - 72]> */
		/* 82104F10h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 82104F10h case    2:*/		return 0x82104F14;
		  /* 82104F14h */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 82104F14h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82104F14h case    3:*/		return 0x82104F18;
		  /* 82104F18h */ case    4:  		/* mr R30, R3 */
		/* 82104F18h case    4:*/		regs.R30 = regs.R3;
		/* 82104F18h case    4:*/		return 0x82104F1C;
		  /* 82104F1Ch */ case    5:  		/* mr R28, R4 */
		/* 82104F1Ch case    5:*/		regs.R28 = regs.R4;
		/* 82104F1Ch case    5:*/		return 0x82104F20;
		  /* 82104F20h */ case    6:  		/* bl -31416 */
		/* 82104F20h case    6:*/		regs.LR = 0x82104F24; return 0x820FD468;
		/* 82104F20h case    6:*/		return 0x82104F24;
		  /* 82104F24h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 82104F24h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82104F24h case    7:*/		return 0x82104F28;
		  /* 82104F28h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 82104F28h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82104F38;  }
		/* 82104F28h case    8:*/		return 0x82104F2C;
		  /* 82104F2Ch */ case    9:  		/* lis R3, -32761 */
		/* 82104F2Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82104F2Ch case    9:*/		return 0x82104F30;
		  /* 82104F30h */ case   10:  		/* ori R3, R3, 14 */
		/* 82104F30h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82104F30h case   10:*/		return 0x82104F34;
		  /* 82104F34h */ case   11:  		/* b 488 */
		/* 82104F34h case   11:*/		return 0x8210511C;
		/* 82104F34h case   11:*/		return 0x82104F38;
	}
	return 0x82104F38;
} // Block from 82104F08h-82104F38h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82104F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104F38);
		  /* 82104F38h */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 82104F38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82104F38h case    0:*/		return 0x82104F3C;
		  /* 82104F3Ch */ case    1:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82104F3Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82104F3Ch case    1:*/		return 0x82104F40;
		  /* 82104F40h */ case    2:  		/* mr R4, R28 */
		/* 82104F40h case    2:*/		regs.R4 = regs.R28;
		/* 82104F40h case    2:*/		return 0x82104F44;
		  /* 82104F44h */ case    3:  		/* lwzx R29, <#[R10 + R11]> */
		/* 82104F44h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82104F44h case    3:*/		return 0x82104F48;
		  /* 82104F48h */ case    4:  		/* mr R3, R29 */
		/* 82104F48h case    4:*/		regs.R3 = regs.R29;
		/* 82104F48h case    4:*/		return 0x82104F4C;
		  /* 82104F4Ch */ case    5:  		/* bl -36956 */
		/* 82104F4Ch case    5:*/		regs.LR = 0x82104F50; return 0x820FBEF0;
		/* 82104F4Ch case    5:*/		return 0x82104F50;
		  /* 82104F50h */ case    6:  		/* lwz R6, <#[R28 + 12]> */
		/* 82104F50h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R28 + 0x0000000C) );
		/* 82104F50h case    6:*/		return 0x82104F54;
		  /* 82104F54h */ case    7:  		/* li R27, 0 */
		/* 82104F54h case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82104F54h case    7:*/		return 0x82104F58;
		  /* 82104F58h */ case    8:  		/* cmplwi CR6, R6, 0 */
		/* 82104F58h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82104F58h case    8:*/		return 0x82104F5C;
		  /* 82104F5Ch */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 82104F5Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82104F90;  }
		/* 82104F5Ch case    9:*/		return 0x82104F60;
		  /* 82104F60h */ case   10:  		/* lwz R31, <#[R28 + 16]> */
		/* 82104F60h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000010) );
		/* 82104F60h case   10:*/		return 0x82104F64;
		  /* 82104F64h */ case   11:  		/* li R7, 0 */
		/* 82104F64h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82104F64h case   11:*/		return 0x82104F68;
		  /* 82104F68h */ case   12:  		/* lwz R4, <#[R31]> */
		/* 82104F68h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82104F68h case   12:*/		return 0x82104F6C;
		  /* 82104F6Ch */ case   13:  		/* mr R3, R30 */
		/* 82104F6Ch case   13:*/		regs.R3 = regs.R30;
		/* 82104F6Ch case   13:*/		return 0x82104F70;
		  /* 82104F70h */ case   14:  		/* lwzx R5, <#[R7 + R31]> */
		/* 82104F70h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + regs.R31 + 0x00000000) );
		/* 82104F70h case   14:*/		return 0x82104F74;
		  /* 82104F74h */ case   15:  		/* bl -24404 */
		/* 82104F74h case   15:*/		regs.LR = 0x82104F78; return 0x820FF020;
		/* 82104F74h case   15:*/		return 0x82104F78;
		  /* 82104F78h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 82104F78h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82104F78h case   16:*/		return 0x82104F7C;
		  /* 82104F7Ch */ case   17:  		/* bc 12, CR0_EQ, 20 */
		/* 82104F7Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x82104F90;  }
		/* 82104F7Ch case   17:*/		return 0x82104F80;
		  /* 82104F80h */ case   18:  		/* addi R27, R27, 1 */
		/* 82104F80h case   18:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82104F80h case   18:*/		return 0x82104F84;
		  /* 82104F84h */ case   19:  		/* addi R7, R7, 4 */
		/* 82104F84h case   19:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82104F84h case   19:*/		return 0x82104F88;
		  /* 82104F88h */ case   20:  		/* cmplw CR6, R27, R6 */
		/* 82104F88h case   20:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R6);
		/* 82104F88h case   20:*/		return 0x82104F8C;
		  /* 82104F8Ch */ case   21:  		/* bc 12, CR6_LT, -32 */
		/* 82104F8Ch case   21:*/		if ( regs.CR[6].lt ) { return 0x82104F6C;  }
		/* 82104F8Ch case   21:*/		return 0x82104F90;
	}
	return 0x82104F90;
} // Block from 82104F38h-82104F90h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82104F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82104F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82104F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82104F90);
		  /* 82104F90h */ case    0:  		/* cmplw CR6, R27, R6 */
		/* 82104F90h case    0:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R6);
		/* 82104F90h case    0:*/		return 0x82104F94;
		  /* 82104F94h */ case    1:  		/* bc 12, CR6_EQ, 388 */
		/* 82104F94h case    1:*/		if ( regs.CR[6].eq ) { return 0x82105118;  }
		/* 82104F94h case    1:*/		return 0x82104F98;
		  /* 82104F98h */ case    2:  		/* mr R4, R6 */
		/* 82104F98h case    2:*/		regs.R4 = regs.R6;
		/* 82104F98h case    2:*/		return 0x82104F9C;
		  /* 82104F9Ch */ case    3:  		/* li R11, 1 */
		/* 82104F9Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82104F9Ch case    3:*/		return 0x82104FA0;
		  /* 82104FA0h */ case    4:  		/* li R25, -1 */
		/* 82104FA0h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 82104FA0h case    4:*/		return 0x82104FA4;
		  /* 82104FA4h */ case    5:  		/* rlwimi R4, R11, 28, 0, 11 */
		/* 82104FA4h case    5:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R11);
		/* 82104FA4h case    5:*/		return 0x82104FA8;
		  /* 82104FA8h */ case    6:  		/* mr R6, R25 */
		/* 82104FA8h case    6:*/		regs.R6 = regs.R25;
		/* 82104FA8h case    6:*/		return 0x82104FAC;
		  /* 82104FACh */ case    7:  		/* mr R5, R25 */
		/* 82104FACh case    7:*/		regs.R5 = regs.R25;
		/* 82104FACh case    7:*/		return 0x82104FB0;
		  /* 82104FB0h */ case    8:  		/* mr R3, R30 */
		/* 82104FB0h case    8:*/		regs.R3 = regs.R30;
		/* 82104FB0h case    8:*/		return 0x82104FB4;
		  /* 82104FB4h */ case    9:  		/* bl -31980 */
		/* 82104FB4h case    9:*/		regs.LR = 0x82104FB8; return 0x820FD2C8;
		/* 82104FB4h case    9:*/		return 0x82104FB8;
		  /* 82104FB8h */ case   10:  		/* cmpwi CR6, R3, -1 */
		/* 82104FB8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82104FB8h case   10:*/		return 0x82104FBC;
		  /* 82104FBCh */ case   11:  		/* bc 12, CR6_EQ, -144 */
		/* 82104FBCh case   11:*/		if ( regs.CR[6].eq ) { return 0x82104F2C;  }
		/* 82104FBCh case   11:*/		return 0x82104FC0;
		  /* 82104FC0h */ case   12:  		/* lwz R11, <#[R30 + 24]> */
		/* 82104FC0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82104FC0h case   12:*/		return 0x82104FC4;
		  /* 82104FC4h */ case   13:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82104FC4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82104FC4h case   13:*/		return 0x82104FC8;
		  /* 82104FC8h */ case   14:  		/* mr R4, R28 */
		/* 82104FC8h case   14:*/		regs.R4 = regs.R28;
		/* 82104FC8h case   14:*/		return 0x82104FCC;
		  /* 82104FCCh */ case   15:  		/* lwzx R27, <#[R10 + R11]> */
		/* 82104FCCh case   15:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82104FCCh case   15:*/		return 0x82104FD0;
		  /* 82104FD0h */ case   16:  		/* mr R3, R27 */
		/* 82104FD0h case   16:*/		regs.R3 = regs.R27;
		/* 82104FD0h case   16:*/		return 0x82104FD4;
		  /* 82104FD4h */ case   17:  		/* bl -37092 */
		/* 82104FD4h case   17:*/		regs.LR = 0x82104FD8; return 0x820FBEF0;
		/* 82104FD4h case   17:*/		return 0x82104FD8;
		  /* 82104FD8h */ case   18:  		/* lwz R11, <#[R29 + 12]> */
		/* 82104FD8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82104FD8h case   18:*/		return 0x82104FDC;
		  /* 82104FDCh */ case   19:  		/* li R26, 0 */
		/* 82104FDCh case   19:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82104FDCh case   19:*/		return 0x82104FE0;
		  /* 82104FE0h */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 82104FE0h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82104FE0h case   20:*/		return 0x82104FE4;
		  /* 82104FE4h */ case   21:  		/* bc 4, CR6_GT, 280 */
		/* 82104FE4h case   21:*/		if ( !regs.CR[6].gt ) { return 0x821050FC;  }
		/* 82104FE4h case   21:*/		return 0x82104FE8;
		  /* 82104FE8h */ case   22:  		/* lis R11, -32256 */
		/* 82104FE8h case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82104FE8h case   22:*/		return 0x82104FEC;
		  /* 82104FECh */ case   23:  		/* li R31, 0 */
		/* 82104FECh case   23:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82104FECh case   23:*/		return 0x82104FF0;
		  /* 82104FF0h */ case   24:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82104FF0h case   24:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82104FF0h case   24:*/		return 0x82104FF4;
		  /* 82104FF4h */ case   25:  		/* lwz R11, <#[R29 + 16]> */
		/* 82104FF4h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82104FF4h case   25:*/		return 0x82104FF8;
		  /* 82104FF8h */ case   26:  		/* mr R6, R25 */
		/* 82104FF8h case   26:*/		regs.R6 = regs.R25;
		/* 82104FF8h case   26:*/		return 0x82104FFC;
		  /* 82104FFCh */ case   27:  		/* lwz R10, <#[R27 + 16]> */
		/* 82104FFCh case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 82104FFCh case   27:*/		return 0x82105000;
		  /* 82105000h */ case   28:  		/* mr R5, R25 */
		/* 82105000h case   28:*/		regs.R5 = regs.R25;
		/* 82105000h case   28:*/		return 0x82105004;
		  /* 82105004h */ case   29:  		/* mr R3, R30 */
		/* 82105004h case   29:*/		regs.R3 = regs.R30;
		/* 82105004h case   29:*/		return 0x82105008;
		  /* 82105008h */ case   30:  		/* fmr FR1, FR31 */
		/* 82105008h case   30:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82105008h case   30:*/		return 0x8210500C;
		  /* 8210500Ch */ case   31:  		/* lwzx R11, <#[R31 + R11]> */
		/* 8210500Ch case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210500Ch case   31:*/		return 0x82105010;
		  /* 82105010h */ case   32:  		/* stwx R11, <#[R31 + R10]> */
		/* 82105010h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 82105010h case   32:*/		return 0x82105014;
		  /* 82105014h */ case   33:  		/* lwz R4, <#[R30 + 136]> */
		/* 82105014h case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000088) );
		/* 82105014h case   33:*/		return 0x82105018;
		  /* 82105018h */ case   34:  		/* bl -32240 */
		/* 82105018h case   34:*/		regs.LR = 0x8210501C; return 0x820FD228;
		/* 82105018h case   34:*/		return 0x8210501C;
		  /* 8210501Ch */ case   35:  		/* lwz R11, <#[R27 + 8]> */
		/* 8210501Ch case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8210501Ch case   35:*/		return 0x82105020;
		  /* 82105020h */ case   36:  		/* stwx R3, <#[R31 + R11]> */
		/* 82105020h case   36:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82105020h case   36:*/		return 0x82105024;
		  /* 82105024h */ case   37:  		/* lwz R11, <#[R29 + 16]> */
		/* 82105024h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82105024h case   37:*/		return 0x82105028;
		  /* 82105028h */ case   38:  		/* stwx R3, <#[R31 + R11]> */
		/* 82105028h case   38:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82105028h case   38:*/		return 0x8210502C;
		  /* 8210502Ch */ case   39:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210502Ch case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210502Ch case   39:*/		return 0x82105030;
		  /* 82105030h */ case   40:  		/* lwzx R11, <#[R31 + R11]> */
		/* 82105030h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82105030h case   40:*/		return 0x82105034;
		  /* 82105034h */ case   41:  		/* cmpwi CR6, R11, -1 */
		/* 82105034h case   41:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82105034h case   41:*/		return 0x82105038;
		  /* 82105038h */ case   42:  		/* bc 12, CR6_EQ, -268 */
		/* 82105038h case   42:*/		if ( regs.CR[6].eq ) { return 0x82104F2C;  }
		/* 82105038h case   42:*/		return 0x8210503C;
		  /* 8210503Ch */ case   43:  		/* lwz R11, <#[R28 + 16]> */
		/* 8210503Ch case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8210503Ch case   43:*/		return 0x82105040;
		  /* 82105040h */ case   44:  		/* lwz R10, <#[R29 + 16]> */
		/* 82105040h case   44:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 82105040h case   44:*/		return 0x82105044;
		  /* 82105044h */ case   45:  		/* lwz R9, <#[R30 + 20]> */
		/* 82105044h case   45:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 82105044h case   45:*/		return 0x82105048;
		  /* 82105048h */ case   46:  		/* lwzx R11, <#[R31 + R11]> */
		/* 82105048h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82105048h case   46:*/		return 0x8210504C;
		  /* 8210504Ch */ case   47:  		/* lwzx R10, <#[R31 + R10]> */
		/* 8210504Ch case   47:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 8210504Ch case   47:*/		return 0x82105050;
		  /* 82105050h */ case   48:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105050h case   48:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105050h case   48:*/		return 0x82105054;
		  /* 82105054h */ case   49:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82105054h case   49:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82105054h case   49:*/		return 0x82105058;
		  /* 82105058h */ case   50:  		/* lwzx R4, <#[R11 + R9]> */
		/* 82105058h case   50:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82105058h case   50:*/		return 0x8210505C;
		  /* 8210505Ch */ case   51:  		/* lwzx R3, <#[R10 + R9]> */
		/* 8210505Ch case   51:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210505Ch case   51:*/		return 0x82105060;
		  /* 82105060h */ case   52:  		/* bl -33728 */
		/* 82105060h case   52:*/		regs.LR = 0x82105064; return 0x820FCCA0;
		/* 82105060h case   52:*/		return 0x82105064;
		  /* 82105064h */ case   53:  		/* lwz R11, <#[R28 + 16]> */
		/* 82105064h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 82105064h case   53:*/		return 0x82105068;
		  /* 82105068h */ case   54:  		/* addi R26, R26, 1 */
		/* 82105068h case   54:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82105068h case   54:*/		return 0x8210506C;
		  /* 8210506Ch */ case   55:  		/* lwz R10, <#[R29 + 16]> */
		/* 8210506Ch case   55:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 8210506Ch case   55:*/		return 0x82105070;
		  /* 82105070h */ case   56:  		/* lwz R9, <#[R30 + 20]> */
		/* 82105070h case   56:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 82105070h case   56:*/		return 0x82105074;
		  /* 82105074h */ case   57:  		/* lwzx R11, <#[R31 + R11]> */
		/* 82105074h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82105074h case   57:*/		return 0x82105078;
		  /* 82105078h */ case   58:  		/* lwzx R10, <#[R31 + R10]> */
		/* 82105078h case   58:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 82105078h case   58:*/		return 0x8210507C;
		  /* 8210507Ch */ case   59:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210507Ch case   59:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210507Ch case   59:*/		return 0x82105080;
		  /* 82105080h */ case   60:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82105080h case   60:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82105080h case   60:*/		return 0x82105084;
		  /* 82105084h */ case   61:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82105084h case   61:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82105084h case   61:*/		return 0x82105088;
		  /* 82105088h */ case   62:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82105088h case   62:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82105088h case   62:*/		return 0x8210508C;
		  /* 8210508Ch */ case   63:  		/* lwz R11, <#[R11 + 20]> */
		/* 8210508Ch case   63:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8210508Ch case   63:*/		return 0x82105090;
		  /* 82105090h */ case   64:  		/* stw R11, <#[R10 + 20]> */
		/* 82105090h case   64:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 82105090h case   64:*/		return 0x82105094;
		  /* 82105094h */ case   65:  		/* lwz R11, <#[R29 + 16]> */
		/* 82105094h case   65:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82105094h case   65:*/		return 0x82105098;
		  /* 82105098h */ case   66:  		/* lwz R10, <#[R28 + 16]> */
		/* 82105098h case   66:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 82105098h case   66:*/		return 0x8210509C;
		  /* 8210509Ch */ case   67:  		/* lwz R9, <#[R30 + 20]> */
		/* 8210509Ch case   67:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 8210509Ch case   67:*/		return 0x821050A0;
		  /* 821050A0h */ case   68:  		/* lwzx R11, <#[R31 + R11]> */
		/* 821050A0h case   68:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 821050A0h case   68:*/		return 0x821050A4;
		  /* 821050A4h */ case   69:  		/* lwzx R10, <#[R31 + R10]> */
		/* 821050A4h case   69:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 821050A4h case   69:*/		return 0x821050A8;
		  /* 821050A8h */ case   70:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821050A8h case   70:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821050A8h case   70:*/		return 0x821050AC;
		  /* 821050ACh */ case   71:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821050ACh case   71:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821050ACh case   71:*/		return 0x821050B0;
		  /* 821050B0h */ case   72:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821050B0h case   72:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821050B0h case   72:*/		return 0x821050B4;
		  /* 821050B4h */ case   73:  		/* lwz R10, <#[R10 + 24]> */
		/* 821050B4h case   73:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 821050B4h case   73:*/		return 0x821050B8;
		  /* 821050B8h */ case   74:  		/* lwzx R11, <#[R11 + R9]> */
		/* 821050B8h case   74:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821050B8h case   74:*/		return 0x821050BC;
		  /* 821050BCh */ case   75:  		/* stw R10, <#[R11 + 24]> */
		/* 821050BCh case   75:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 821050BCh case   75:*/		return 0x821050C0;
		  /* 821050C0h */ case   76:  		/* lwz R11, <#[R29 + 16]> */
		/* 821050C0h case   76:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821050C0h case   76:*/		return 0x821050C4;
		  /* 821050C4h */ case   77:  		/* lwz R10, <#[R28 + 16]> */
		/* 821050C4h case   77:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 821050C4h case   77:*/		return 0x821050C8;
		  /* 821050C8h */ case   78:  		/* lwz R9, <#[R30 + 20]> */
		/* 821050C8h case   78:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 821050C8h case   78:*/		return 0x821050CC;
		  /* 821050CCh */ case   79:  		/* lwzx R11, <#[R31 + R11]> */
		/* 821050CCh case   79:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 821050CCh case   79:*/		return 0x821050D0;
		  /* 821050D0h */ case   80:  		/* lwzx R10, <#[R31 + R10]> */
		/* 821050D0h case   80:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 821050D0h case   80:*/		return 0x821050D4;
		  /* 821050D4h */ case   81:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821050D4h case   81:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821050D4h case   81:*/		return 0x821050D8;
		  /* 821050D8h */ case   82:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821050D8h case   82:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821050D8h case   82:*/		return 0x821050DC;
		  /* 821050DCh */ case   83:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821050DCh case   83:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821050DCh case   83:*/		return 0x821050E0;
		  /* 821050E0h */ case   84:  		/* lwz R10, <#[R10]> */
		/* 821050E0h case   84:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821050E0h case   84:*/		return 0x821050E4;
		  /* 821050E4h */ case   85:  		/* addi R31, R31, 4 */
		/* 821050E4h case   85:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821050E4h case   85:*/		return 0x821050E8;
		  /* 821050E8h */ case   86:  		/* lwzx R11, <#[R11 + R9]> */
		/* 821050E8h case   86:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821050E8h case   86:*/		return 0x821050EC;
		  /* 821050ECh */ case   87:  		/* stw R10, <#[R11]> */
		/* 821050ECh case   87:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821050ECh case   87:*/		return 0x821050F0;
		  /* 821050F0h */ case   88:  		/* lwz R11, <#[R29 + 12]> */
		/* 821050F0h case   88:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821050F0h case   88:*/		return 0x821050F4;
		  /* 821050F4h */ case   89:  		/* cmplw CR6, R26, R11 */
		/* 821050F4h case   89:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 821050F4h case   89:*/		return 0x821050F8;
		  /* 821050F8h */ case   90:  		/* bc 12, CR6_LT, -260 */
		/* 821050F8h case   90:*/		if ( regs.CR[6].lt ) { return 0x82104FF4;  }
		/* 821050F8h case   90:*/		return 0x821050FC;
	}
	return 0x821050FC;
} // Block from 82104F90h-821050FCh (91 instructions)

//////////////////////////////////////////////////////
// Block at 821050FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821050FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821050FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821050FC);
		  /* 821050FCh */ case    0:  		/* mr R4, R27 */
		/* 821050FCh case    0:*/		regs.R4 = regs.R27;
		/* 821050FCh case    0:*/		return 0x82105100;
		  /* 82105100h */ case    1:  		/* mr R3, R30 */
		/* 82105100h case    1:*/		regs.R3 = regs.R30;
		/* 82105100h case    1:*/		return 0x82105104;
		  /* 82105104h */ case    2:  		/* bl -1884 */
		/* 82105104h case    2:*/		regs.LR = 0x82105108; return 0x821049A8;
		/* 82105104h case    2:*/		return 0x82105108;
		  /* 82105108h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 82105108h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82105108h case    3:*/		return 0x8210510C;
		  /* 8210510Ch */ case    4:  		/* bc 12, CR0_LT, 16 */
		/* 8210510Ch case    4:*/		if ( regs.CR[0].lt ) { return 0x8210511C;  }
		/* 8210510Ch case    4:*/		return 0x82105110;
		  /* 82105110h */ case    5:  		/* li R11, 0 */
		/* 82105110h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82105110h case    5:*/		return 0x82105114;
		  /* 82105114h */ case    6:  		/* stw R11, <#[R27]> */
		/* 82105114h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82105114h case    6:*/		return 0x82105118;
	}
	return 0x82105118;
} // Block from 821050FCh-82105118h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82105118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105118);
		  /* 82105118h */ case    0:  		/* li R3, 0 */
		/* 82105118h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82105118h case    0:*/		return 0x8210511C;
	}
	return 0x8210511C;
} // Block from 82105118h-8210511Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210511Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210511C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210511C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210511C);
		  /* 8210511Ch */ case    0:  		/* addi R1, R1, 160 */
		/* 8210511Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8210511Ch case    0:*/		return 0x82105120;
		  /* 82105120h */ case    1:  		/* lfd FR31, <#[R1 - 72]> */
		/* 82105120h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 82105120h case    1:*/		return 0x82105124;
		  /* 82105124h */ case    2:  		/* b -474760 */
		/* 82105124h case    2:*/		return 0x8209129C;
		/* 82105124h case    2:*/		return 0x82105128;
	}
	return 0x82105128;
} // Block from 8210511Ch-82105128h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82105128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105128);
		  /* 82105128h */ case    0:  		/* mfspr R12, LR */
		/* 82105128h case    0:*/		regs.R12 = regs.LR;
		/* 82105128h case    0:*/		return 0x8210512C;
		  /* 8210512Ch */ case    1:  		/* bl -474840 */
		/* 8210512Ch case    1:*/		regs.LR = 0x82105130; return 0x82091254;
		/* 8210512Ch case    1:*/		return 0x82105130;
		  /* 82105130h */ case    2:  		/* lwz R11, <#[R4]> */
		/* 82105130h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82105130h case    2:*/		return 0x82105134;
		  /* 82105134h */ case    3:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 82105134h case    3:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 82105134h case    3:*/		return 0x82105138;
		  /* 82105138h */ case    4:  		/* bc 12, CR0_EQ, 340 */
		/* 82105138h case    4:*/		if ( regs.CR[0].eq ) { return 0x8210528C;  }
		/* 82105138h case    4:*/		return 0x8210513C;
		  /* 8210513Ch */ case    5:  		/* lwz R10, <#[R4 + 4]> */
		/* 8210513Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 8210513Ch case    5:*/		return 0x82105140;
		  /* 82105140h */ case    6:  		/* rlwinm R5, R11, 0, 12, 31 */
		/* 82105140h case    6:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R5,regs.R11);
		/* 82105140h case    6:*/		return 0x82105144;
		  /* 82105144h */ case    7:  		/* divwu. R11, R10, R5 */
		/* 82105144h case    7:*/		cpu::op::divwu<1>(regs,&regs.R11,regs.R10,regs.R5);
		/* 82105144h case    7:*/		return 0x82105148;
		  /* 82105148h */ case    8:  		/* twi 6, R5, 0 */
		/* 82105148h case    8:*/		cpu::op::tw<6>(regs, 0x82105148, regs.R5, 0x00000000);
		/* 82105148h case    8:*/		return 0x8210514C;
		  /* 8210514Ch */ case    9:  		/* bc 12, CR0_EQ, 320 */
		/* 8210514Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8210528C;  }
		/* 8210514Ch case    9:*/		return 0x82105150;
		  /* 82105150h */ case   10:  		/* li R6, 0 */
		/* 82105150h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82105150h case   10:*/		return 0x82105154;
		  /* 82105154h */ case   11:  		/* mr R31, R11 */
		/* 82105154h case   11:*/		regs.R31 = regs.R11;
		/* 82105154h case   11:*/		return 0x82105158;
		  /* 82105158h */ case   12:  		/* li R30, 1 */
		/* 82105158h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82105158h case   12:*/		return 0x8210515C;
		  /* 8210515Ch */ case   13:  		/* li R8, 0 */
		/* 8210515Ch case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210515Ch case   13:*/		return 0x82105160;
		  /* 82105160h */ case   14:  		/* cmplwi CR6, R5, 0 */
		/* 82105160h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82105160h case   14:*/		return 0x82105164;
		  /* 82105164h */ case   15:  		/* bc 12, CR6_EQ, 160 */
		/* 82105164h case   15:*/		if ( regs.CR[6].eq ) { return 0x82105204;  }
		/* 82105164h case   15:*/		return 0x82105168;
		  /* 82105168h */ case   16:  		/* mtspr CTR, R5 */
		/* 82105168h case   16:*/		regs.CTR = regs.R5;
		/* 82105168h case   16:*/		return 0x8210516C;
		  /* 8210516Ch */ case   17:  		/* li R7, 0 */
		/* 8210516Ch case   17:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210516Ch case   17:*/		return 0x82105170;
		  /* 82105170h */ case   18:  		/* add R11, R6, R8 */
		/* 82105170h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R6,regs.R8);
		/* 82105170h case   18:*/		return 0x82105174;
		  /* 82105174h */ case   19:  		/* lwz R10, <#[R4 + 8]> */
		/* 82105174h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 82105174h case   19:*/		return 0x82105178;
		  /* 82105178h */ case   20:  		/* lwz R9, <#[R3 + 20]> */
		/* 82105178h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000014) );
		/* 82105178h case   20:*/		return 0x8210517C;
		  /* 8210517Ch */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210517Ch case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210517Ch case   21:*/		return 0x82105180;
		  /* 82105180h */ case   22:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82105180h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82105180h case   22:*/		return 0x82105184;
		  /* 82105184h */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105184h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105184h case   23:*/		return 0x82105188;
		  /* 82105188h */ case   24:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82105188h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82105188h case   24:*/		return 0x8210518C;
		  /* 8210518Ch */ case   25:  		/* lwz R10, <#[R11 + 72]> */
		/* 8210518Ch case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000048) );
		/* 8210518Ch case   25:*/		return 0x82105190;
		  /* 82105190h */ case   26:  		/* cmpwi CR6, R10, -1 */
		/* 82105190h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82105190h case   26:*/		return 0x82105194;
		  /* 82105194h */ case   27:  		/* bc 12, CR6_EQ, 100 */
		/* 82105194h case   27:*/		if ( regs.CR[6].eq ) { return 0x821051F8;  }
		/* 82105194h case   27:*/		return 0x82105198;
		  /* 82105198h */ case   28:  		/* lwz R29, <#[R11 + 8]> */
		/* 82105198h case   28:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000008) );
		/* 82105198h case   28:*/		return 0x8210519C;
		  /* 8210519Ch */ case   29:  		/* cmpwi CR6, R29, -1 */
		/* 8210519Ch case   29:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 8210519Ch case   29:*/		return 0x821051A0;
		  /* 821051A0h */ case   30:  		/* bc 4, CR6_EQ, 88 */
		/* 821051A0h case   30:*/		if ( !regs.CR[6].eq ) { return 0x821051F8;  }
		/* 821051A0h case   30:*/		return 0x821051A4;
		  /* 821051A4h */ case   31:  		/* lwz R29, <#[R3 + 24]> */
		/* 821051A4h case   31:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000018) );
		/* 821051A4h case   31:*/		return 0x821051A8;
		  /* 821051A8h */ case   32:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821051A8h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821051A8h case   32:*/		return 0x821051AC;
		  /* 821051ACh */ case   33:  		/* lwz R28, <#[R4]> */
		/* 821051ACh case   33:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R4 + 0x00000000) );
		/* 821051ACh case   33:*/		return 0x821051B0;
		  /* 821051B0h */ case   34:  		/* lis R27, 4400 */
		/* 821051B0h case   34:*/		cpu::op::lis<0>(regs,&regs.R27,0x1130);
		/* 821051B0h case   34:*/		return 0x821051B4;
		  /* 821051B4h */ case   35:  		/* rlwinm R28, R28, 0, 0, 11 */
		/* 821051B4h case   35:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R28,regs.R28);
		/* 821051B4h case   35:*/		return 0x821051B8;
		  /* 821051B8h */ case   36:  		/* lwzx R10, <#[R10 + R29]> */
		/* 821051B8h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 821051B8h case   36:*/		return 0x821051BC;
		  /* 821051BCh */ case   37:  		/* cmplw CR6, R28, R27 */
		/* 821051BCh case   37:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R27);
		/* 821051BCh case   37:*/		return 0x821051C0;
		  /* 821051C0h */ case   38:  		/* bc 4, CR6_EQ, 32 */
		/* 821051C0h case   38:*/		if ( !regs.CR[6].eq ) { return 0x821051E0;  }
		/* 821051C0h case   38:*/		return 0x821051C4;
		  /* 821051C4h */ case   39:  		/* lwz R10, <#[R4 + 16]> */
		/* 821051C4h case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 821051C4h case   39:*/		return 0x821051C8;
		  /* 821051C8h */ case   40:  		/* lwzx R10, <#[R10 + R7]> */
		/* 821051C8h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 821051C8h case   40:*/		return 0x821051CC;
		  /* 821051CCh */ case   41:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821051CCh case   41:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821051CCh case   41:*/		return 0x821051D0;
		  /* 821051D0h */ case   42:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821051D0h case   42:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821051D0h case   42:*/		return 0x821051D4;
		  /* 821051D4h */ case   43:  		/* lwz R10, <#[R10 + 64]> */
		/* 821051D4h case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000040) );
		/* 821051D4h case   43:*/		return 0x821051D8;
		  /* 821051D8h */ case   44:  		/* stw R10, <#[R11 + 64]> */
		/* 821051D8h case   44:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000040) );
		/* 821051D8h case   44:*/		return 0x821051DC;
		  /* 821051DCh */ case   45:  		/* b 28 */
		/* 821051DCh case   45:*/		return 0x821051F8;
		/* 821051DCh case   45:*/		return 0x821051E0;
	}
	return 0x821051E0;
} // Block from 82105128h-821051E0h (46 instructions)

//////////////////////////////////////////////////////
// Block at 821051E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821051E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821051E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821051E0);
		  /* 821051E0h */ case    0:  		/* lwz R9, <#[R10 + 36]> */
		/* 821051E0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000024) );
		/* 821051E0h case    0:*/		return 0x821051E4;
		  /* 821051E4h */ case    1:  		/* lwz R29, <#[R11 + 64]> */
		/* 821051E4h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000040) );
		/* 821051E4h case    1:*/		return 0x821051E8;
		  /* 821051E8h */ case    2:  		/* slw R9, R30, R9 */
		/* 821051E8h case    2:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 821051E8h case    2:*/		return 0x821051EC;
		  /* 821051ECh */ case    3:  		/* or R9, R9, R29 */
		/* 821051ECh case    3:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R29);
		/* 821051ECh case    3:*/		return 0x821051F0;
		  /* 821051F0h */ case    4:  		/* stw R9, <#[R11 + 64]> */
		/* 821051F0h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000040) );
		/* 821051F0h case    4:*/		return 0x821051F4;
		  /* 821051F4h */ case    5:  		/* stw R30, <#[R10 + 40]> */
		/* 821051F4h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00000028) );
		/* 821051F4h case    5:*/		return 0x821051F8;
	}
	return 0x821051F8;
} // Block from 821051E0h-821051F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821051F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821051F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821051F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821051F8);
		  /* 821051F8h */ case    0:  		/* addi R8, R8, 1 */
		/* 821051F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821051F8h case    0:*/		return 0x821051FC;
		  /* 821051FCh */ case    1:  		/* addi R7, R7, 4 */
		/* 821051FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 821051FCh case    1:*/		return 0x82105200;
		  /* 82105200h */ case    2:  		/* bc 16, CR0_LT, -144 */
		/* 82105200h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82105170;  }
		/* 82105200h case    2:*/		return 0x82105204;
	}
	return 0x82105204;
} // Block from 821051F8h-82105204h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82105204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105204);
		  /* 82105204h */ case    0:  		/* li R9, 0 */
		/* 82105204h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82105204h case    0:*/		return 0x82105208;
		  /* 82105208h */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 82105208h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82105208h case    1:*/		return 0x8210520C;
		  /* 8210520Ch */ case    2:  		/* bc 12, CR6_EQ, 116 */
		/* 8210520Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82105280;  }
		/* 8210520Ch case    2:*/		return 0x82105210;
		  /* 82105210h */ case    3:  		/* mtspr CTR, R5 */
		/* 82105210h case    3:*/		regs.CTR = regs.R5;
		/* 82105210h case    3:*/		return 0x82105214;
		  /* 82105214h */ case    4:  		/* add R11, R6, R9 */
		/* 82105214h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R6,regs.R9);
		/* 82105214h case    4:*/		return 0x82105218;
		  /* 82105218h */ case    5:  		/* lwz R10, <#[R4 + 8]> */
		/* 82105218h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 82105218h case    5:*/		return 0x8210521C;
		  /* 8210521Ch */ case    6:  		/* lwz R8, <#[R3 + 20]> */
		/* 8210521Ch case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 8210521Ch case    6:*/		return 0x82105220;
		  /* 82105220h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105220h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105220h case    7:*/		return 0x82105224;
		  /* 82105224h */ case    8:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82105224h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82105224h case    8:*/		return 0x82105228;
		  /* 82105228h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105228h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105228h case    9:*/		return 0x8210522C;
		  /* 8210522Ch */ case   10:  		/* lwzx R10, <#[R11 + R8]> */
		/* 8210522Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210522Ch case   10:*/		return 0x82105230;
		  /* 82105230h */ case   11:  		/* lwz R11, <#[R10 + 72]> */
		/* 82105230h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000048) );
		/* 82105230h case   11:*/		return 0x82105234;
		  /* 82105234h */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 82105234h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82105234h case   12:*/		return 0x82105238;
		  /* 82105238h */ case   13:  		/* bc 12, CR6_EQ, 64 */
		/* 82105238h case   13:*/		if ( regs.CR[6].eq ) { return 0x82105278;  }
		/* 82105238h case   13:*/		return 0x8210523C;
		  /* 8210523Ch */ case   14:  		/* lwz R10, <#[R10 + 8]> */
		/* 8210523Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8210523Ch case   14:*/		return 0x82105240;
		  /* 82105240h */ case   15:  		/* cmpwi CR6, R10, -1 */
		/* 82105240h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82105240h case   15:*/		return 0x82105244;
		  /* 82105244h */ case   16:  		/* bc 4, CR6_EQ, 52 */
		/* 82105244h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82105278;  }
		/* 82105244h case   16:*/		return 0x82105248;
		  /* 82105248h */ case   17:  		/* lwz R10, <#[R3 + 24]> */
		/* 82105248h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 82105248h case   17:*/		return 0x8210524C;
		  /* 8210524Ch */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210524Ch case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210524Ch case   18:*/		return 0x82105250;
		  /* 82105250h */ case   19:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82105250h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82105250h case   19:*/		return 0x82105254;
		  /* 82105254h */ case   20:  		/* lwz R10, <#[R11 + 40]> */
		/* 82105254h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000028) );
		/* 82105254h case   20:*/		return 0x82105258;
		  /* 82105258h */ case   21:  		/* cmplwi CR6, R10, 0 */
		/* 82105258h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82105258h case   21:*/		return 0x8210525C;
		  /* 8210525Ch */ case   22:  		/* bc 12, CR6_EQ, 28 */
		/* 8210525Ch case   22:*/		if ( regs.CR[6].eq ) { return 0x82105278;  }
		/* 8210525Ch case   22:*/		return 0x82105260;
		  /* 82105260h */ case   23:  		/* lwz R10, <#[R11 + 36]> */
		/* 82105260h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 82105260h case   23:*/		return 0x82105264;
		  /* 82105264h */ case   24:  		/* li R8, 0 */
		/* 82105264h case   24:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82105264h case   24:*/		return 0x82105268;
		  /* 82105268h */ case   25:  		/* addi R10, R10, 1 */
		/* 82105268h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82105268h case   25:*/		return 0x8210526C;
		  /* 8210526Ch */ case   26:  		/* stw R8, <#[R11 + 40]> */
		/* 8210526Ch case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000028) );
		/* 8210526Ch case   26:*/		return 0x82105270;
		  /* 82105270h */ case   27:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 82105270h case   27:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 82105270h case   27:*/		return 0x82105274;
		  /* 82105274h */ case   28:  		/* stw R10, <#[R11 + 36]> */
		/* 82105274h case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000024) );
		/* 82105274h case   28:*/		return 0x82105278;
	}
	return 0x82105278;
} // Block from 82105204h-82105278h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82105278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105278);
		  /* 82105278h */ case    0:  		/* addi R9, R9, 1 */
		/* 82105278h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82105278h case    0:*/		return 0x8210527C;
		  /* 8210527Ch */ case    1:  		/* bc 16, CR0_LT, -104 */
		/* 8210527Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82105214;  }
		/* 8210527Ch case    1:*/		return 0x82105280;
	}
	return 0x82105280;
} // Block from 82105278h-82105280h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82105280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105280);
		  /* 82105280h */ case    0:  		/* addic. R31, R31, -1 */
		/* 82105280h case    0:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82105280h case    0:*/		return 0x82105284;
		  /* 82105284h */ case    1:  		/* add R6, R6, R5 */
		/* 82105284h case    1:*/		cpu::op::add<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 82105284h case    1:*/		return 0x82105288;
		  /* 82105288h */ case    2:  		/* bc 4, CR0_EQ, -300 */
		/* 82105288h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8210515C;  }
		/* 82105288h case    2:*/		return 0x8210528C;
	}
	return 0x8210528C;
} // Block from 82105280h-8210528Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210528Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210528C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210528C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210528C);
		  /* 8210528Ch */ case    0:  		/* li R3, 0 */
		/* 8210528Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210528Ch case    0:*/		return 0x82105290;
		  /* 82105290h */ case    1:  		/* b -475116 */
		/* 82105290h case    1:*/		return 0x820912A4;
		/* 82105290h case    1:*/		return 0x82105294;
		  /* 82105294h */ case    2:  		/* nop */
		/* 82105294h case    2:*/		cpu::op::nop();
		/* 82105294h case    2:*/		return 0x82105298;
	}
	return 0x82105298;
} // Block from 8210528Ch-82105298h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82105298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105298);
		  /* 82105298h */ case    0:  		/* mfspr R12, LR */
		/* 82105298h case    0:*/		regs.R12 = regs.LR;
		/* 82105298h case    0:*/		return 0x8210529C;
		  /* 8210529Ch */ case    1:  		/* bl -475212 */
		/* 8210529Ch case    1:*/		regs.LR = 0x821052A0; return 0x82091250;
		/* 8210529Ch case    1:*/		return 0x821052A0;
		  /* 821052A0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821052A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821052A0h case    2:*/		return 0x821052A4;
		  /* 821052A4h */ case    3:  		/* lwz R10, <#[R3 + 8]> */
		/* 821052A4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821052A4h case    3:*/		return 0x821052A8;
		  /* 821052A8h */ case    4:  		/* mr R30, R3 */
		/* 821052A8h case    4:*/		regs.R30 = regs.R3;
		/* 821052A8h case    4:*/		return 0x821052AC;
		  /* 821052ACh */ case    5:  		/* li R26, 0 */
		/* 821052ACh case    5:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821052ACh case    5:*/		return 0x821052B0;
		  /* 821052B0h */ case    6:  		/* li R11, 0 */
		/* 821052B0h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821052B0h case    6:*/		return 0x821052B4;
		  /* 821052B4h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 821052B4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821052B4h case    7:*/		return 0x821052B8;
		  /* 821052B8h */ case    8:  		/* bc 4, CR6_GT, 44 */
		/* 821052B8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x821052E4;  }
		/* 821052B8h case    8:*/		return 0x821052BC;
		  /* 821052BCh */ case    9:  		/* li R10, 0 */
		/* 821052BCh case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821052BCh case    9:*/		return 0x821052C0;
		  /* 821052C0h */ case   10:  		/* lwz R9, <#[R30 + 20]> */
		/* 821052C0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 821052C0h case   10:*/		return 0x821052C4;
		  /* 821052C4h */ case   11:  		/* li R8, -1 */
		/* 821052C4h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 821052C4h case   11:*/		return 0x821052C8;
		  /* 821052C8h */ case   12:  		/* addi R11, R11, 1 */
		/* 821052C8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821052C8h case   12:*/		return 0x821052CC;
		  /* 821052CCh */ case   13:  		/* lwzx R9, <#[R10 + R9]> */
		/* 821052CCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821052CCh case   13:*/		return 0x821052D0;
		  /* 821052D0h */ case   14:  		/* addi R10, R10, 4 */
		/* 821052D0h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821052D0h case   14:*/		return 0x821052D4;
		  /* 821052D4h */ case   15:  		/* stw R8, <#[R9 + 48]> */
		/* 821052D4h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000030) );
		/* 821052D4h case   15:*/		return 0x821052D8;
		  /* 821052D8h */ case   16:  		/* lwz R9, <#[R30 + 8]> */
		/* 821052D8h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 821052D8h case   16:*/		return 0x821052DC;
		  /* 821052DCh */ case   17:  		/* cmplw CR6, R11, R9 */
		/* 821052DCh case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821052DCh case   17:*/		return 0x821052E0;
		  /* 821052E0h */ case   18:  		/* bc 12, CR6_LT, -32 */
		/* 821052E0h case   18:*/		if ( regs.CR[6].lt ) { return 0x821052C0;  }
		/* 821052E0h case   18:*/		return 0x821052E4;
	}
	return 0x821052E4;
} // Block from 82105298h-821052E4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821052E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821052E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821052E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821052E4);
		  /* 821052E4h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 821052E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 821052E4h case    0:*/		return 0x821052E8;
		  /* 821052E8h */ case    1:  		/* li R27, 0 */
		/* 821052E8h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821052E8h case    1:*/		return 0x821052EC;
		  /* 821052ECh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821052ECh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821052ECh case    2:*/		return 0x821052F0;
		  /* 821052F0h */ case    3:  		/* bc 4, CR6_GT, 500 */
		/* 821052F0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821054E4;  }
		/* 821052F0h case    3:*/		return 0x821052F4;
		  /* 821052F4h */ case    4:  		/* li R28, 0 */
		/* 821052F4h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821052F4h case    4:*/		return 0x821052F8;
		  /* 821052F8h */ case    5:  		/* lwz R11, <#[R30 + 24]> */
		/* 821052F8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 821052F8h case    5:*/		return 0x821052FC;
		  /* 821052FCh */ case    6:  		/* lwzx R31, <#[R28 + R11]> */
		/* 821052FCh case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 821052FCh case    6:*/		return 0x82105300;
		  /* 82105300h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82105300h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82105300h case    7:*/		return 0x82105304;
		  /* 82105304h */ case    8:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 82105304h case    8:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82105304h case    8:*/		return 0x82105308;
		  /* 82105308h */ case    9:  		/* bc 12, CR0_EQ, 456 */
		/* 82105308h case    9:*/		if ( regs.CR[0].eq ) { return 0x821054D0;  }
		/* 82105308h case    9:*/		return 0x8210530C;
		  /* 8210530Ch */ case   10:  		/* li R4, 0 */
		/* 8210530Ch case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210530Ch case   10:*/		return 0x82105310;
		  /* 82105310h */ case   11:  		/* li R29, 0 */
		/* 82105310h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82105310h case   11:*/		return 0x82105314;
		  /* 82105314h */ case   12:  		/* b 220 */
		/* 82105314h case   12:*/		return 0x821053F0;
		/* 82105314h case   12:*/		return 0x82105318;
		  /* 82105318h */ case   13:  		/* lwz R6, <#[R1 + 80]> */
		/* 82105318h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 82105318h case   13:*/		return 0x8210531C;
		  /* 8210531Ch */ case   14:  		/* lwz R8, <#[R30 + 20]> */
		/* 8210531Ch case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000014) );
		/* 8210531Ch case   14:*/		return 0x82105320;
		  /* 82105320h */ case   15:  		/* lwz R11, <#[R6]> */
		/* 82105320h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 82105320h case   15:*/		return 0x82105324;
		  /* 82105324h */ case   16:  		/* rlwinm R7, R11, 2, 0, 29 */
		/* 82105324h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R11);
		/* 82105324h case   16:*/		return 0x82105328;
		  /* 82105328h */ case   17:  		/* lwzx R11, <#[R7 + R8]> */
		/* 82105328h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 82105328h case   17:*/		return 0x8210532C;
		  /* 8210532Ch */ case   18:  		/* lwz R11, <#[R11 + 48]> */
		/* 8210532Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 8210532Ch case   18:*/		return 0x82105330;
		  /* 82105330h */ case   19:  		/* cmpwi CR6, R11, -1 */
		/* 82105330h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82105330h case   19:*/		return 0x82105334;
		  /* 82105334h */ case   20:  		/* bc 12, CR6_EQ, 180 */
		/* 82105334h case   20:*/		if ( regs.CR[6].eq ) { return 0x821053E8;  }
		/* 82105334h case   20:*/		return 0x82105338;
		  /* 82105338h */ case   21:  		/* li R9, 1 */
		/* 82105338h case   21:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82105338h case   21:*/		return 0x8210533C;
		  /* 8210533Ch */ case   22:  		/* cmplwi CR6, R3, 1 */
		/* 8210533Ch case   22:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 8210533Ch case   22:*/		return 0x82105340;
		  /* 82105340h */ case   23:  		/* bc 4, CR6_GT, 108 */
		/* 82105340h case   23:*/		if ( !regs.CR[6].gt ) { return 0x821053AC;  }
		/* 82105340h case   23:*/		return 0x82105344;
		  /* 82105344h */ case   24:  		/* addi R10, R6, 4 */
		/* 82105344h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0x4);
		/* 82105344h case   24:*/		return 0x82105348;
		  /* 82105348h */ case   25:  		/* lwz R11, <#[R10]> */
		/* 82105348h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82105348h case   25:*/		return 0x8210534C;
		  /* 8210534Ch */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210534Ch case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210534Ch case   26:*/		return 0x82105350;
		  /* 82105350h */ case   27:  		/* lwzx R5, <#[R11 + R8]> */
		/* 82105350h case   27:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82105350h case   27:*/		return 0x82105354;
		  /* 82105354h */ case   28:  		/* lwz R5, <#[R5 + 48]> */
		/* 82105354h case   28:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000030) );
		/* 82105354h case   28:*/		return 0x82105358;
		  /* 82105358h */ case   29:  		/* cmpwi CR6, R5, -1 */
		/* 82105358h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 82105358h case   29:*/		return 0x8210535C;
		  /* 8210535Ch */ case   30:  		/* bc 12, CR6_EQ, 72 */
		/* 8210535Ch case   30:*/		if ( regs.CR[6].eq ) { return 0x821053A4;  }
		/* 8210535Ch case   30:*/		return 0x82105360;
		  /* 82105360h */ case   31:  		/* lwz R5, <#[R30 + 20]> */
		/* 82105360h case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000014) );
		/* 82105360h case   31:*/		return 0x82105364;
		  /* 82105364h */ case   32:  		/* lwzx R11, <#[R11 + R5]> */
		/* 82105364h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 82105364h case   32:*/		return 0x82105368;
		  /* 82105368h */ case   33:  		/* lwzx R4, <#[R5 + R7]> */
		/* 82105368h case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + regs.R7 + 0x00000000) );
		/* 82105368h case   33:*/		return 0x8210536C;
		  /* 8210536Ch */ case   34:  		/* lwz R11, <#[R11 + 48]> */
		/* 8210536Ch case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 8210536Ch case   34:*/		return 0x82105370;
		  /* 82105370h */ case   35:  		/* lwz R4, <#[R4 + 48]> */
		/* 82105370h case   35:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000030) );
		/* 82105370h case   35:*/		return 0x82105374;
		  /* 82105374h */ case   36:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105374h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105374h case   36:*/		return 0x82105378;
		  /* 82105378h */ case   37:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 82105378h case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 82105378h case   37:*/		return 0x8210537C;
		  /* 8210537Ch */ case   38:  		/* lwzx R11, <#[R11 + R5]> */
		/* 8210537Ch case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8210537Ch case   38:*/		return 0x82105380;
		  /* 82105380h */ case   39:  		/* lwzx R4, <#[R4 + R5]> */
		/* 82105380h case   39:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R5 + 0x00000000) );
		/* 82105380h case   39:*/		return 0x82105384;
		  /* 82105384h */ case   40:  		/* lwz R11, <#[R11 + 12]> */
		/* 82105384h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82105384h case   40:*/		return 0x82105388;
		  /* 82105388h */ case   41:  		/* lwz R5, <#[R4 + 12]> */
		/* 82105388h case   41:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x0000000C) );
		/* 82105388h case   41:*/		return 0x8210538C;
		  /* 8210538Ch */ case   42:  		/* cmplw CR6, R5, R11 */
		/* 8210538Ch case   42:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 8210538Ch case   42:*/		return 0x82105390;
		  /* 82105390h */ case   43:  		/* bc 4, CR6_EQ, 20 */
		/* 82105390h case   43:*/		if ( !regs.CR[6].eq ) { return 0x821053A4;  }
		/* 82105390h case   43:*/		return 0x82105394;
		  /* 82105394h */ case   44:  		/* addi R9, R9, 1 */
		/* 82105394h case   44:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82105394h case   44:*/		return 0x82105398;
		  /* 82105398h */ case   45:  		/* addi R10, R10, 4 */
		/* 82105398h case   45:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82105398h case   45:*/		return 0x8210539C;
		  /* 8210539Ch */ case   46:  		/* cmplw CR6, R9, R3 */
		/* 8210539Ch case   46:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R3);
		/* 8210539Ch case   46:*/		return 0x821053A0;
		  /* 821053A0h */ case   47:  		/* bc 12, CR6_LT, -88 */
		/* 821053A0h case   47:*/		if ( regs.CR[6].lt ) { return 0x82105348;  }
		/* 821053A0h case   47:*/		return 0x821053A4;
	}
	return 0x821053A4;
} // Block from 821052E4h-821053A4h (48 instructions)

//////////////////////////////////////////////////////
// Block at 821053A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821053A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821053A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821053A4);
		  /* 821053A4h */ case    0:  		/* cmplw CR6, R9, R3 */
		/* 821053A4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R3);
		/* 821053A4h case    0:*/		return 0x821053A8;
		  /* 821053A8h */ case    1:  		/* bc 12, CR6_LT, 64 */
		/* 821053A8h case    1:*/		if ( regs.CR[6].lt ) { return 0x821053E8;  }
		/* 821053A8h case    1:*/		return 0x821053AC;
	}
	return 0x821053AC;
} // Block from 821053A4h-821053ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821053ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821053AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821053AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821053AC);
		  /* 821053ACh */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 821053ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821053ACh case    0:*/		return 0x821053B0;
		  /* 821053B0h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 821053B0h case    1:*/		if ( regs.CR[6].eq ) { return 0x821053E4;  }
		/* 821053B0h case    1:*/		return 0x821053B4;
		  /* 821053B4h */ case    2:  		/* li R11, 0 */
		/* 821053B4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821053B4h case    2:*/		return 0x821053B8;
		  /* 821053B8h */ case    3:  		/* mtspr CTR, R3 */
		/* 821053B8h case    3:*/		regs.CTR = regs.R3;
		/* 821053B8h case    3:*/		return 0x821053BC;
		  /* 821053BCh */ case    4:  		/* b 8 */
		/* 821053BCh case    4:*/		return 0x821053C4;
		/* 821053BCh case    4:*/		return 0x821053C0;
		  /* 821053C0h */ case    5:  		/* lwz R6, <#[R1 + 80]> */
		/* 821053C0h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 821053C0h case    5:*/		return 0x821053C4;
	}
	return 0x821053C4;
} // Block from 821053ACh-821053C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821053C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821053C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821053C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821053C4);
		  /* 821053C4h */ case    0:  		/* lwzx R10, <#[R11 + R6]> */
		/* 821053C4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 821053C4h case    0:*/		return 0x821053C8;
		  /* 821053C8h */ case    1:  		/* lwz R9, <#[R30 + 20]> */
		/* 821053C8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 821053C8h case    1:*/		return 0x821053CC;
		  /* 821053CCh */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821053CCh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821053CCh case    2:*/		return 0x821053D0;
		  /* 821053D0h */ case    3:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821053D0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821053D0h case    3:*/		return 0x821053D4;
		  /* 821053D4h */ case    4:  		/* lwz R10, <#[R10 + 48]> */
		/* 821053D4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 821053D4h case    4:*/		return 0x821053D8;
		  /* 821053D8h */ case    5:  		/* stwx R10, <#[R11 + R6]> */
		/* 821053D8h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 821053D8h case    5:*/		return 0x821053DC;
		  /* 821053DCh */ case    6:  		/* addi R11, R11, 4 */
		/* 821053DCh case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821053DCh case    6:*/		return 0x821053E0;
		  /* 821053E0h */ case    7:  		/* bc 16, CR0_LT, -32 */
		/* 821053E0h case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821053C0;  }
		/* 821053E0h case    7:*/		return 0x821053E4;
	}
	return 0x821053E4;
} // Block from 821053C4h-821053E4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821053E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821053E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821053E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821053E4);
		  /* 821053E4h */ case    0:  		/* li R26, 1 */
		/* 821053E4h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 821053E4h case    0:*/		return 0x821053E8;
	}
	return 0x821053E8;
} // Block from 821053E4h-821053E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821053E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821053E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821053E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821053E8);
		  /* 821053E8h */ case    0:  		/* addi R29, R29, 1 */
		/* 821053E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821053E8h case    0:*/		return 0x821053EC;
		  /* 821053ECh */ case    1:  		/* mr R4, R29 */
		/* 821053ECh case    1:*/		regs.R4 = regs.R29;
		/* 821053ECh case    1:*/		return 0x821053F0;
	}
	return 0x821053F0;
} // Block from 821053E8h-821053F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821053F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821053F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821053F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821053F0);
		  /* 821053F0h */ case    0:  		/* addi R5, R1, 80 */
		/* 821053F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821053F0h case    0:*/		return 0x821053F4;
		  /* 821053F4h */ case    1:  		/* mr R3, R31 */
		/* 821053F4h case    1:*/		regs.R3 = regs.R31;
		/* 821053F4h case    1:*/		return 0x821053F8;
		  /* 821053F8h */ case    2:  		/* bl -38112 */
		/* 821053F8h case    2:*/		regs.LR = 0x821053FC; return 0x820FBF18;
		/* 821053F8h case    2:*/		return 0x821053FC;
		  /* 821053FCh */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 821053FCh case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821053FCh case    3:*/		return 0x82105400;
		  /* 82105400h */ case    4:  		/* bc 4, CR0_EQ, -232 */
		/* 82105400h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82105318;  }
		/* 82105400h case    4:*/		return 0x82105404;
		  /* 82105404h */ case    5:  		/* lwz R11, <#[R31]> */
		/* 82105404h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82105404h case    5:*/		return 0x82105408;
		  /* 82105408h */ case    6:  		/* lis R10, 4096 */
		/* 82105408h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 82105408h case    6:*/		return 0x8210540C;
		  /* 8210540Ch */ case    7:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 8210540Ch case    7:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210540Ch case    7:*/		return 0x82105410;
		  /* 82105410h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 82105410h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82105410h case    8:*/		return 0x82105414;
		  /* 82105414h */ case    9:  		/* bc 4, CR6_EQ, 188 */
		/* 82105414h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821054D0;  }
		/* 82105414h case    9:*/		return 0x82105418;
		  /* 82105418h */ case   10:  		/* lwz R11, <#[R31 + 12]> */
		/* 82105418h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82105418h case   10:*/		return 0x8210541C;
		  /* 8210541Ch */ case   11:  		/* li R7, 0 */
		/* 8210541Ch case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210541Ch case   11:*/		return 0x82105420;
		  /* 82105420h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 82105420h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82105420h case   12:*/		return 0x82105424;
		  /* 82105424h */ case   13:  		/* bc 4, CR6_GT, 172 */
		/* 82105424h case   13:*/		if ( !regs.CR[6].gt ) { return 0x821054D0;  }
		/* 82105424h case   13:*/		return 0x82105428;
		  /* 82105428h */ case   14:  		/* li R9, 0 */
		/* 82105428h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82105428h case   14:*/		return 0x8210542C;
		  /* 8210542Ch */ case   15:  		/* lwz R11, <#[R31 + 16]> */
		/* 8210542Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8210542Ch case   15:*/		return 0x82105430;
		  /* 82105430h */ case   16:  		/* lwz R10, <#[R31 + 8]> */
		/* 82105430h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82105430h case   16:*/		return 0x82105434;
		  /* 82105434h */ case   17:  		/* lwz R6, <#[R30 + 20]> */
		/* 82105434h case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000014) );
		/* 82105434h case   17:*/		return 0x82105438;
		  /* 82105438h */ case   18:  		/* lwzx R8, <#[R9 + R11]> */
		/* 82105438h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82105438h case   18:*/		return 0x8210543C;
		  /* 8210543Ch */ case   19:  		/* lwzx R11, <#[R9 + R10]> */
		/* 8210543Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8210543Ch case   19:*/		return 0x82105440;
		  /* 82105440h */ case   20:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 82105440h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 82105440h case   20:*/		return 0x82105444;
		  /* 82105444h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105444h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105444h case   21:*/		return 0x82105448;
	}
	return 0x82105448;
} // Block from 821053F0h-82105448h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82105448h
// Function '?VectorizeLeft_IsConflicting@CProgram@D3DXShader@@AAAHPAVCInstruction@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105448);
		  /* 82105448h */ case    0:  		/* lwzx R10, <#[R10 + R6]> */
		/* 82105448h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82105448h case    0:*/		return 0x8210544C;
		  /* 8210544Ch */ case    1:  		/* lwzx R11, <#[R11 + R6]> */
		/* 8210544Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210544Ch case    1:*/		return 0x82105450;
		  /* 82105450h */ case    2:  		/* lwz R6, <#[R10 + 4]> */
		/* 82105450h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82105450h case    2:*/		return 0x82105454;
		  /* 82105454h */ case    3:  		/* lwz R5, <#[R11 + 4]> */
		/* 82105454h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000004) );
		/* 82105454h case    3:*/		return 0x82105458;
		  /* 82105458h */ case    4:  		/* cmplw CR6, R6, R5 */
		/* 82105458h case    4:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 82105458h case    4:*/		return 0x8210545C;
		  /* 8210545Ch */ case    5:  		/* bc 4, CR6_EQ, 96 */
		/* 8210545Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821054BC;  }
		/* 8210545Ch case    5:*/		return 0x82105460;
		  /* 82105460h */ case    6:  		/* lwz R6, <#[R10 + 8]> */
		/* 82105460h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000008) );
		/* 82105460h case    6:*/		return 0x82105464;
		  /* 82105464h */ case    7:  		/* lwz R5, <#[R11 + 8]> */
		/* 82105464h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000008) );
		/* 82105464h case    7:*/		return 0x82105468;
		  /* 82105468h */ case    8:  		/* cmplw CR6, R6, R5 */
		/* 82105468h case    8:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 82105468h case    8:*/		return 0x8210546C;
		  /* 8210546Ch */ case    9:  		/* bc 4, CR6_EQ, 80 */
		/* 8210546Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x821054BC;  }
		/* 8210546Ch case    9:*/		return 0x82105470;
		  /* 82105470h */ case   10:  		/* lwz R6, <#[R10 + 16]> */
		/* 82105470h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000010) );
		/* 82105470h case   10:*/		return 0x82105474;
		  /* 82105474h */ case   11:  		/* lwz R5, <#[R11 + 16]> */
		/* 82105474h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000010) );
		/* 82105474h case   11:*/		return 0x82105478;
		  /* 82105478h */ case   12:  		/* cmplw CR6, R6, R5 */
		/* 82105478h case   12:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 82105478h case   12:*/		return 0x8210547C;
		  /* 8210547Ch */ case   13:  		/* bc 4, CR6_EQ, 64 */
		/* 8210547Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x821054BC;  }
		/* 8210547Ch case   13:*/		return 0x82105480;
		  /* 82105480h */ case   14:  		/* lwz R6, <#[R10 + 20]> */
		/* 82105480h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000014) );
		/* 82105480h case   14:*/		return 0x82105484;
		  /* 82105484h */ case   15:  		/* lwz R5, <#[R11 + 20]> */
		/* 82105484h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000014) );
		/* 82105484h case   15:*/		return 0x82105488;
		  /* 82105488h */ case   16:  		/* cmplw CR6, R6, R5 */
		/* 82105488h case   16:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 82105488h case   16:*/		return 0x8210548C;
		  /* 8210548Ch */ case   17:  		/* bc 4, CR6_EQ, 48 */
		/* 8210548Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x821054BC;  }
		/* 8210548Ch case   17:*/		return 0x82105490;
		  /* 82105490h */ case   18:  		/* lwz R6, <#[R10 + 24]> */
		/* 82105490h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000018) );
		/* 82105490h case   18:*/		return 0x82105494;
		  /* 82105494h */ case   19:  		/* lwz R5, <#[R11 + 24]> */
		/* 82105494h case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000018) );
		/* 82105494h case   19:*/		return 0x82105498;
		  /* 82105498h */ case   20:  		/* cmpw CR6, R6, R5 */
		/* 82105498h case   20:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R5);
		/* 82105498h case   20:*/		return 0x8210549C;
		  /* 8210549Ch */ case   21:  		/* bc 4, CR6_EQ, 32 */
		/* 8210549Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x821054BC;  }
		/* 8210549Ch case   21:*/		return 0x821054A0;
		  /* 821054A0h */ case   22:  		/* lwz R6, <#[R11 + 56]> */
		/* 821054A0h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000038) );
		/* 821054A0h case   22:*/		return 0x821054A4;
		  /* 821054A4h */ case   23:  		/* cmpwi CR6, R6, -1 */
		/* 821054A4h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 821054A4h case   23:*/		return 0x821054A8;
		  /* 821054A8h */ case   24:  		/* bc 4, CR6_EQ, 20 */
		/* 821054A8h case   24:*/		if ( !regs.CR[6].eq ) { return 0x821054BC;  }
		/* 821054A8h case   24:*/		return 0x821054AC;
		  /* 821054ACh */ case   25:  		/* lwz R10, <#[R10 + 60]> */
		/* 821054ACh case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000003C) );
		/* 821054ACh case   25:*/		return 0x821054B0;
		  /* 821054B0h */ case   26:  		/* cmplwi CR6, R10, 0 */
		/* 821054B0h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821054B0h case   26:*/		return 0x821054B4;
		  /* 821054B4h */ case   27:  		/* bc 4, CR6_EQ, 8 */
		/* 821054B4h case   27:*/		if ( !regs.CR[6].eq ) { return 0x821054BC;  }
		/* 821054B4h case   27:*/		return 0x821054B8;
		  /* 821054B8h */ case   28:  		/* stw R8, <#[R11 + 48]> */
		/* 821054B8h case   28:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000030) );
		/* 821054B8h case   28:*/		return 0x821054BC;
	}
	return 0x821054BC;
} // Block from 82105448h-821054BCh (29 instructions)

//////////////////////////////////////////////////////
// Block at 821054BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821054BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821054BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821054BC);
		  /* 821054BCh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821054BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821054BCh case    0:*/		return 0x821054C0;
		  /* 821054C0h */ case    1:  		/* addi R7, R7, 1 */
		/* 821054C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821054C0h case    1:*/		return 0x821054C4;
		  /* 821054C4h */ case    2:  		/* addi R9, R9, 4 */
		/* 821054C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821054C4h case    2:*/		return 0x821054C8;
		  /* 821054C8h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 821054C8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 821054C8h case    3:*/		return 0x821054CC;
		  /* 821054CCh */ case    4:  		/* bc 12, CR6_LT, -160 */
		/* 821054CCh case    4:*/		if ( regs.CR[6].lt ) { return 0x8210542C;  }
		/* 821054CCh case    4:*/		return 0x821054D0;
	}
	return 0x821054D0;
} // Block from 821054BCh-821054D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821054D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821054D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821054D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821054D0);
		  /* 821054D0h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 821054D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 821054D0h case    0:*/		return 0x821054D4;
		  /* 821054D4h */ case    1:  		/* addi R27, R27, 1 */
		/* 821054D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821054D4h case    1:*/		return 0x821054D8;
		  /* 821054D8h */ case    2:  		/* addi R28, R28, 4 */
		/* 821054D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 821054D8h case    2:*/		return 0x821054DC;
		  /* 821054DCh */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 821054DCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 821054DCh case    3:*/		return 0x821054E0;
		  /* 821054E0h */ case    4:  		/* bc 12, CR6_LT, -488 */
		/* 821054E0h case    4:*/		if ( regs.CR[6].lt ) { return 0x821052F8;  }
		/* 821054E0h case    4:*/		return 0x821054E4;
	}
	return 0x821054E4;
} // Block from 821054D0h-821054E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821054E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821054E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821054E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821054E4);
		  /* 821054E4h */ case    0:  		/* cntlzw R11, R26 */
		/* 821054E4h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R26);
		/* 821054E4h case    0:*/		return 0x821054E8;
		  /* 821054E8h */ case    1:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 821054E8h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 821054E8h case    1:*/		return 0x821054EC;
		  /* 821054ECh */ case    2:  		/* addi R1, R1, 144 */
		/* 821054ECh case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821054ECh case    2:*/		return 0x821054F0;
		  /* 821054F0h */ case    3:  		/* b -475728 */
		/* 821054F0h case    3:*/		return 0x820912A0;
		/* 821054F0h case    3:*/		return 0x821054F4;
		  /* 821054F4h */ case    4:  		/* nop */
		/* 821054F4h case    4:*/		cpu::op::nop();
		/* 821054F4h case    4:*/		return 0x821054F8;
	}
	return 0x821054F8;
} // Block from 821054E4h-821054F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821054F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821054F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821054F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821054F8);
		  /* 821054F8h */ case    0:  		/* mfspr R12, LR */
		/* 821054F8h case    0:*/		regs.R12 = regs.LR;
		/* 821054F8h case    0:*/		return 0x821054FC;
		  /* 821054FCh */ case    1:  		/* bl -475868 */
		/* 821054FCh case    1:*/		regs.LR = 0x82105500; return 0x82091220;
		/* 821054FCh case    1:*/		return 0x82105500;
		  /* 82105500h */ case    2:  		/* stwu R1, <#[R1 - 288]> */
		/* 82105500h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 82105500h case    2:*/		return 0x82105504;
		  /* 82105504h */ case    3:  		/* lwz R11, <#[R3 + 20]> */
		/* 82105504h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82105504h case    3:*/		return 0x82105508;
		  /* 82105508h */ case    4:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 82105508h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 82105508h case    4:*/		return 0x8210550C;
		  /* 8210550Ch */ case    5:  		/* stw R9, <#[R1 + 356]> */
		/* 8210550Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000164) );
		/* 8210550Ch case    5:*/		return 0x82105510;
	}
	return 0x82105510;
} // Block from 821054F8h-82105510h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82105510h
// Function '?VectorizeLeft_PerComponent@CProgram@D3DXShader@@AAAJPAVCInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105510);
		  /* 82105510h */ case    0:  		/* li R20, 4 */
		/* 82105510h case    0:*/		cpu::op::li<0>(regs,&regs.R20,0x4);
		/* 82105510h case    0:*/		return 0x82105514;
		  /* 82105514h */ case    1:  		/* lwz R9, <#[R4 + 8]> */
		/* 82105514h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000008) );
		/* 82105514h case    1:*/		return 0x82105518;
		  /* 82105518h */ case    2:  		/* mr R14, R3 */
		/* 82105518h case    2:*/		regs.R14 = regs.R3;
		/* 82105518h case    2:*/		return 0x8210551C;
		  /* 8210551Ch */ case    3:  		/* mr R17, R4 */
		/* 8210551Ch case    3:*/		regs.R17 = regs.R4;
		/* 8210551Ch case    3:*/		return 0x82105520;
		  /* 82105520h */ case    4:  		/* stw R6, <#[R1 + 332]> */
		/* 82105520h case    4:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000014C) );
		/* 82105520h case    4:*/		return 0x82105524;
		  /* 82105524h */ case    5:  		/* mr R16, R7 */
		/* 82105524h case    5:*/		regs.R16 = regs.R7;
		/* 82105524h case    5:*/		return 0x82105528;
		  /* 82105528h */ case    6:  		/* stw R8, <#[R1 + 348]> */
		/* 82105528h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000015C) );
		/* 82105528h case    6:*/		return 0x8210552C;
		  /* 8210552Ch */ case    7:  		/* lwzx R15, <#[R10 + R11]> */
		/* 8210552Ch case    7:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210552Ch case    7:*/		return 0x82105530;
		  /* 82105530h */ case    8:  		/* mr R30, R8 */
		/* 82105530h case    8:*/		regs.R30 = regs.R8;
		/* 82105530h case    8:*/		return 0x82105534;
		  /* 82105534h */ case    9:  		/* stw R20, <#[R1 + 80]> */
		/* 82105534h case    9:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000050) );
		/* 82105534h case    9:*/		return 0x82105538;
		  /* 82105538h */ case   10:  		/* lwz R11, <#[R15 + 12]> */
		/* 82105538h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000000C) );
		/* 82105538h case   10:*/		return 0x8210553C;
		  /* 8210553Ch */ case   11:  		/* lwz R10, <#[R15]> */
		/* 8210553Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000000) );
		/* 8210553Ch case   11:*/		return 0x82105540;
		  /* 82105540h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105540h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105540h case   12:*/		return 0x82105544;
		  /* 82105544h */ case   13:  		/* rlwinm. R10, R10, 0, 0, 0 */
		/* 82105544h case   13:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R10);
		/* 82105544h case   13:*/		return 0x82105548;
		  /* 82105548h */ case   14:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82105548h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82105548h case   14:*/		return 0x8210554C;
		  /* 8210554Ch */ case   15:  		/* stw R11, <#[R1 + 84]> */
		/* 8210554Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8210554Ch case   15:*/		return 0x82105550;
		  /* 82105550h */ case   16:  		/* bc 4, CR0_EQ, 72 */
		/* 82105550h case   16:*/		if ( !regs.CR[0].eq ) { return 0x82105598;  }
		/* 82105550h case   16:*/		return 0x82105554;
		  /* 82105554h */ case   17:  		/* cmplwi CR6, R11, 1 */
		/* 82105554h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82105554h case   17:*/		return 0x82105558;
		  /* 82105558h */ case   18:  		/* bc 4, CR6_EQ, 20 */
		/* 82105558h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8210556C;  }
		/* 82105558h case   18:*/		return 0x8210555C;
		  /* 8210555Ch */ case   19:  		/* lwz R10, <#[R3 + 108]> */
		/* 8210555Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000006C) );
		/* 8210555Ch case   19:*/		return 0x82105560;
		  /* 82105560h */ case   20:  		/* rlwinm. R10, R10, 0, 3, 3 */
		/* 82105560h case   20:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R10);
		/* 82105560h case   20:*/		return 0x82105564;
		  /* 82105564h */ case   21:  		/* bc 4, CR0_EQ, 52 */
		/* 82105564h case   21:*/		if ( !regs.CR[0].eq ) { return 0x82105598;  }
		/* 82105564h case   21:*/		return 0x82105568;
		  /* 82105568h */ case   22:  		/* cmplwi CR6, R11, 1 */
		/* 82105568h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82105568h case   22:*/		return 0x8210556C;
	}
	return 0x8210556C;
} // Block from 82105510h-8210556Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8210556Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210556C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210556C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210556C);
		  /* 8210556Ch */ case    0:  		/* bc 4, CR6_GT, 16 */
		/* 8210556Ch case    0:*/		if ( !regs.CR[6].gt ) { return 0x8210557C;  }
		/* 8210556Ch case    0:*/		return 0x82105570;
		  /* 82105570h */ case    1:  		/* lwz R11, <#[R14 + 108]> */
		/* 82105570h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000006C) );
		/* 82105570h case    1:*/		return 0x82105574;
		  /* 82105574h */ case    2:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 82105574h case    2:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 82105574h case    2:*/		return 0x82105578;
		  /* 82105578h */ case    3:  		/* bc 4, CR0_EQ, 32 */
		/* 82105578h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82105598;  }
		/* 82105578h case    3:*/		return 0x8210557C;
	}
	return 0x8210557C;
} // Block from 8210556Ch-8210557Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210557Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210557C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210557C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210557C);
		  /* 8210557Ch */ case    0:  		/* lwz R11, <#[R15 + 72]> */
		/* 8210557Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000048) );
		/* 8210557Ch case    0:*/		return 0x82105580;
		  /* 82105580h */ case    1:  		/* lwz R10, <#[R14 + 24]> */
		/* 82105580h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000018) );
		/* 82105580h case    1:*/		return 0x82105584;
		  /* 82105584h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105584h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105584h case    2:*/		return 0x82105588;
		  /* 82105588h */ case    3:  		/* lwzx R3, <#[R11 + R10]> */
		/* 82105588h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82105588h case    3:*/		return 0x8210558C;
		  /* 8210558Ch */ case    4:  		/* bl -38428 */
		/* 8210558Ch case    4:*/		regs.LR = 0x82105590; return 0x820FBF70;
		/* 8210558Ch case    4:*/		return 0x82105590;
		  /* 82105590h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 82105590h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82105590h case    5:*/		return 0x82105594;
		  /* 82105594h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 82105594h case    6:*/		if ( regs.CR[0].eq ) { return 0x821055A0;  }
		/* 82105594h case    6:*/		return 0x82105598;
	}
	return 0x82105598;
} // Block from 8210557Ch-82105598h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82105598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105598);
		  /* 82105598h */ case    0:  		/* li R11, 1 */
		/* 82105598h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82105598h case    0:*/		return 0x8210559C;
		  /* 8210559Ch */ case    1:  		/* stw R11, <#[R1 + 80]> */
		/* 8210559Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8210559Ch case    1:*/		return 0x821055A0;
	}
	return 0x821055A0;
} // Block from 82105598h-821055A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821055A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821055A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821055A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821055A0);
		  /* 821055A0h */ case    0:  		/* addi R10, R1, 112 */
		/* 821055A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 821055A0h case    0:*/		return 0x821055A4;
		  /* 821055A4h */ case    1:  		/* lwz R9, <#[R15 + 12]> */
		/* 821055A4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R15 + 0x0000000C) );
		/* 821055A4h case    1:*/		return 0x821055A8;
		  /* 821055A8h */ case    2:  		/* addi R8, R1, 96 */
		/* 821055A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 821055A8h case    2:*/		return 0x821055AC;
		  /* 821055ACh */ case    3:  		/* li R11, -1 */
		/* 821055ACh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 821055ACh case    3:*/		return 0x821055B0;
		  /* 821055B0h */ case    4:  		/* li R23, 0 */
		/* 821055B0h case    4:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 821055B0h case    4:*/		return 0x821055B4;
		  /* 821055B4h */ case    5:  		/* addi R19, R1, 96 */
		/* 821055B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R1,0x60);
		/* 821055B4h case    5:*/		return 0x821055B8;
		  /* 821055B8h */ case    6:  		/* std R11, <#[R10]> */
		/* 821055B8h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821055B8h case    6:*/		return 0x821055BC;
		  /* 821055BCh */ case    7:  		/* rlwinm R28, R9, 4, 0, 27 */
		/* 821055BCh case    7:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R28,regs.R9);
		/* 821055BCh case    7:*/		return 0x821055C0;
		  /* 821055C0h */ case    8:  		/* std R11, <#[R8]> */
		/* 821055C0h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821055C0h case    8:*/		return 0x821055C4;
		  /* 821055C4h */ case    9:  		/* std R11, <#[R10 + 8]> */
		/* 821055C4h case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821055C4h case    9:*/		return 0x821055C8;
		  /* 821055C8h */ case   10:  		/* std R11, <#[R8 + 8]> */
		/* 821055C8h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 821055C8h case   10:*/		return 0x821055CC;
		  /* 821055CCh */ case   11:  		/* lwz R11, <#[R17 + 24]> */
		/* 821055CCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 821055CCh case   11:*/		return 0x821055D0;
		  /* 821055D0h */ case   12:  		/* li R18, 0 */
		/* 821055D0h case   12:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 821055D0h case   12:*/		return 0x821055D4;
		  /* 821055D4h */ case   13:  		/* lwzx R22, <#[R28 + R11]> */
		/* 821055D4h case   13:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 821055D4h case   13:*/		return 0x821055D8;
		  /* 821055D8h */ case   14:  		/* cmpwi CR6, R22, -1 */
		/* 821055D8h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R22,0xFFFFFFFF);
		/* 821055D8h case   14:*/		return 0x821055DC;
		  /* 821055DCh */ case   15:  		/* bc 12, CR6_EQ, 220 */
		/* 821055DCh case   15:*/		if ( regs.CR[6].eq ) { return 0x821056B8;  }
		/* 821055DCh case   15:*/		return 0x821055E0;
		  /* 821055E0h */ case   16:  		/* lwz R11, <#[R17 + 48]> */
		/* 821055E0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000030) );
		/* 821055E0h case   16:*/		return 0x821055E4;
		  /* 821055E4h */ case   17:  		/* li R27, 0 */
		/* 821055E4h case   17:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821055E4h case   17:*/		return 0x821055E8;
		  /* 821055E8h */ case   18:  		/* lwzx R21, <#[R11 + R28]> */
		/* 821055E8h case   18:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 821055E8h case   18:*/		return 0x821055EC;
		  /* 821055ECh */ case   19:  		/* cmplwi CR6, R21, 0 */
		/* 821055ECh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 821055ECh case   19:*/		return 0x821055F0;
		  /* 821055F0h */ case   20:  		/* bc 12, CR6_EQ, 200 */
		/* 821055F0h case   20:*/		if ( regs.CR[6].eq ) { return 0x821056B8;  }
		/* 821055F0h case   20:*/		return 0x821055F4;
		  /* 821055F4h */ case   21:  		/* lwz R26, <#[R17 + 52]> */
		/* 821055F4h case   21:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R17 + 0x00000034) );
		/* 821055F4h case   21:*/		return 0x821055F8;
		  /* 821055F8h */ case   22:  		/* lwz R25, <#[R17 + 56]> */
		/* 821055F8h case   22:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R17 + 0x00000038) );
		/* 821055F8h case   22:*/		return 0x821055FC;
		  /* 821055FCh */ case   23:  		/* lwz R24, <#[R17 + 16]> */
		/* 821055FCh case   23:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R17 + 0x00000010) );
		/* 821055FCh case   23:*/		return 0x82105600;
		  /* 82105600h */ case   24:  		/* lwzx R11, <#[R28 + R26]> */
		/* 82105600h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R26 + 0x00000000) );
		/* 82105600h case   24:*/		return 0x82105604;
		  /* 82105604h */ case   25:  		/* add R11, R11, R27 */
		/* 82105604h case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 82105604h case   25:*/		return 0x82105608;
		  /* 82105608h */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105608h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105608h case   26:*/		return 0x8210560C;
		  /* 8210560Ch */ case   27:  		/* lwzx R10, <#[R11 + R25]> */
		/* 8210560Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 8210560Ch case   27:*/		return 0x82105610;
		  /* 82105610h */ case   28:  		/* rlwinm R11, R10, 0, 0, 29 */
		/* 82105610h case   28:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R10);
		/* 82105610h case   28:*/		return 0x82105614;
		  /* 82105614h */ case   29:  		/* lwzx R11, <#[R11 + R24]> */
		/* 82105614h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 82105614h case   29:*/		return 0x82105618;
		  /* 82105618h */ case   30:  		/* cmpwi CR6, R11, -1 */
		/* 82105618h case   30:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82105618h case   30:*/		return 0x8210561C;
		  /* 8210561Ch */ case   31:  		/* bc 12, CR6_EQ, 8 */
		/* 8210561Ch case   31:*/		if ( regs.CR[6].eq ) { return 0x82105624;  }
		/* 8210561Ch case   31:*/		return 0x82105620;
		  /* 82105620h */ case   32:  		/* li R18, 1 */
		/* 82105620h case   32:*/		cpu::op::li<0>(regs,&regs.R18,0x1);
		/* 82105620h case   32:*/		return 0x82105624;
	}
	return 0x82105624;
} // Block from 821055A0h-82105624h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82105624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105624);
		  /* 82105624h */ case    0:  		/* lwz R9, <#[R1 + 332]> */
		/* 82105624h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000014C) );
		/* 82105624h case    0:*/		return 0x82105628;
		  /* 82105628h */ case    1:  		/* cmplw CR6, R9, R11 */
		/* 82105628h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82105628h case    1:*/		return 0x8210562C;
		  /* 8210562Ch */ case    2:  		/* bc 4, CR6_EQ, 100 */
		/* 8210562Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82105690;  }
		/* 8210562Ch case    2:*/		return 0x82105630;
		  /* 82105630h */ case    3:  		/* lwz R11, <#[R17 + 20]> */
		/* 82105630h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000014) );
		/* 82105630h case    3:*/		return 0x82105634;
		  /* 82105634h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82105634h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82105634h case    4:*/		return 0x82105638;
		  /* 82105638h */ case    5:  		/* lwzx R31, <#[R10 + R11]> */
		/* 82105638h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82105638h case    5:*/		return 0x8210563C;
		  /* 8210563Ch */ case    6:  		/* cmpwi CR6, R31, -1 */
		/* 8210563Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 8210563Ch case    6:*/		return 0x82105640;
		  /* 82105640h */ case    7:  		/* bc 12, CR6_EQ, 80 */
		/* 82105640h case    7:*/		if ( regs.CR[6].eq ) { return 0x82105690;  }
		/* 82105640h case    7:*/		return 0x82105644;
		  /* 82105644h */ case    8:  		/* rlwinm R29, R31, 2, 0, 29 */
		/* 82105644h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R31);
		/* 82105644h case    8:*/		return 0x82105648;
		  /* 82105648h */ case    9:  		/* addi R30, R1, 112 */
		/* 82105648h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x70);
		/* 82105648h case    9:*/		return 0x8210564C;
		  /* 8210564Ch */ case   10:  		/* lwzx R11, <#[R29 + R30]> */
		/* 8210564Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8210564Ch case   10:*/		return 0x82105650;
		  /* 82105650h */ case   11:  		/* cmpwi CR6, R11, -1 */
		/* 82105650h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82105650h case   11:*/		return 0x82105654;
		  /* 82105654h */ case   12:  		/* bc 4, CR6_EQ, 56 */
		/* 82105654h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8210568C;  }
		/* 82105654h case   12:*/		return 0x82105658;
		  /* 82105658h */ case   13:  		/* lwz R11, <#[R1 + 80]> */
		/* 82105658h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82105658h case   13:*/		return 0x8210565C;
		  /* 8210565Ch */ case   14:  		/* cmplwi CR6, R11, 1 */
		/* 8210565Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8210565Ch case   14:*/		return 0x82105660;
		  /* 82105660h */ case   15:  		/* bc 4, CR6_EQ, 12 */
		/* 82105660h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8210566C;  }
		/* 82105660h case   15:*/		return 0x82105664;
		  /* 82105664h */ case   16:  		/* cmplw CR6, R23, R31 */
		/* 82105664h case   16:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R31);
		/* 82105664h case   16:*/		return 0x82105668;
		  /* 82105668h */ case   17:  		/* bc 4, CR6_EQ, 36 */
		/* 82105668h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8210568C;  }
		/* 82105668h case   17:*/		return 0x8210566C;
	}
	return 0x8210566C;
} // Block from 82105624h-8210566Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8210566Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210566C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210566C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210566C);
		  /* 8210566Ch */ case    0:  		/* mr R7, R31 */
		/* 8210566Ch case    0:*/		regs.R7 = regs.R31;
		/* 8210566Ch case    0:*/		return 0x82105670;
		  /* 82105670h */ case    1:  		/* lwz R6, <#[R1 + 332]> */
		/* 82105670h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000014C) );
		/* 82105670h case    1:*/		return 0x82105674;
		  /* 82105674h */ case    2:  		/* mr R5, R22 */
		/* 82105674h case    2:*/		regs.R5 = regs.R22;
		/* 82105674h case    2:*/		return 0x82105678;
		  /* 82105678h */ case    3:  		/* mr R4, R17 */
		/* 82105678h case    3:*/		regs.R4 = regs.R17;
		/* 82105678h case    3:*/		return 0x8210567C;
		  /* 8210567Ch */ case    4:  		/* mr R3, R14 */
		/* 8210567Ch case    4:*/		regs.R3 = regs.R14;
		/* 8210567Ch case    4:*/		return 0x82105680;
		  /* 82105680h */ case    5:  		/* bl -18120 */
		/* 82105680h case    5:*/		regs.LR = 0x82105684; return 0x82100FB8;
		/* 82105680h case    5:*/		return 0x82105684;
		  /* 82105684h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 82105684h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82105684h case    6:*/		return 0x82105688;
		  /* 82105688h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 82105688h case    7:*/		if ( regs.CR[6].eq ) { return 0x821056A0;  }
		/* 82105688h case    7:*/		return 0x8210568C;
	}
	return 0x8210568C;
} // Block from 8210566Ch-8210568Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8210568Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210568C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210568C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210568C);
		  /* 8210568Ch */ case    0:  		/* lwz R30, <#[R1 + 348]> */
		/* 8210568Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000015C) );
		/* 8210568Ch case    0:*/		return 0x82105690;
	}
	return 0x82105690;
} // Block from 8210568Ch-82105690h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82105690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105690);
		  /* 82105690h */ case    0:  		/* addi R27, R27, 1 */
		/* 82105690h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82105690h case    0:*/		return 0x82105694;
		  /* 82105694h */ case    1:  		/* cmplw CR6, R27, R21 */
		/* 82105694h case    1:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R21);
		/* 82105694h case    1:*/		return 0x82105698;
		  /* 82105698h */ case    2:  		/* bc 12, CR6_LT, -152 */
		/* 82105698h case    2:*/		if ( regs.CR[6].lt ) { return 0x82105600;  }
		/* 82105698h case    2:*/		return 0x8210569C;
		  /* 8210569Ch */ case    3:  		/* b 20 */
		/* 8210569Ch case    3:*/		return 0x821056B0;
		/* 8210569Ch case    3:*/		return 0x821056A0;
	}
	return 0x821056A0;
} // Block from 82105690h-821056A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821056A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821056A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821056A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821056A0);
		  /* 821056A0h */ case    0:  		/* stwx R23, <#[R29 + R30]> */
		/* 821056A0h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 821056A0h case    0:*/		return 0x821056A4;
		  /* 821056A4h */ case    1:  		/* addi R20, R20, -1 */
		/* 821056A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0xFFFFFFFF);
		/* 821056A4h case    1:*/		return 0x821056A8;
		  /* 821056A8h */ case    2:  		/* lwz R30, <#[R1 + 348]> */
		/* 821056A8h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000015C) );
		/* 821056A8h case    2:*/		return 0x821056AC;
		  /* 821056ACh */ case    3:  		/* stw R31, <#[R19]> */
		/* 821056ACh case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R19 + 0x00000000) );
		/* 821056ACh case    3:*/		return 0x821056B0;
	}
	return 0x821056B0;
} // Block from 821056A0h-821056B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821056B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821056B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821056B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821056B0);
		  /* 821056B0h */ case    0:  		/* cmpwi CR6, R18, 0 */
		/* 821056B0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R18,0x00000000);
		/* 821056B0h case    0:*/		return 0x821056B4;
		  /* 821056B4h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 821056B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821056BC;  }
		/* 821056B4h case    1:*/		return 0x821056B8;
	}
	return 0x821056B8;
} // Block from 821056B0h-821056B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821056B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821056B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821056B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821056B8);
		  /* 821056B8h */ case    0:  		/* addi R20, R20, -1 */
		/* 821056B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0xFFFFFFFF);
		/* 821056B8h case    0:*/		return 0x821056BC;
	}
	return 0x821056BC;
} // Block from 821056B8h-821056BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821056BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821056BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821056BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821056BC);
		  /* 821056BCh */ case    0:  		/* addi R23, R23, 1 */
		/* 821056BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 821056BCh case    0:*/		return 0x821056C0;
		  /* 821056C0h */ case    1:  		/* addi R28, R28, 4 */
		/* 821056C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 821056C0h case    1:*/		return 0x821056C4;
		  /* 821056C4h */ case    2:  		/* addi R19, R19, 4 */
		/* 821056C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x4);
		/* 821056C4h case    2:*/		return 0x821056C8;
		  /* 821056C8h */ case    3:  		/* cmplwi CR6, R23, 4 */
		/* 821056C8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000004);
		/* 821056C8h case    3:*/		return 0x821056CC;
		  /* 821056CCh */ case    4:  		/* bc 12, CR6_LT, -256 */
		/* 821056CCh case    4:*/		if ( regs.CR[6].lt ) { return 0x821055CC;  }
		/* 821056CCh case    4:*/		return 0x821056D0;
		  /* 821056D0h */ case    5:  		/* lwz R10, <#[R1 + 356]> */
		/* 821056D0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000164) );
		/* 821056D0h case    5:*/		return 0x821056D4;
		  /* 821056D4h */ case    6:  		/* rlwinm R3, R20, 29, 0, 2 */
		/* 821056D4h case    6:*/		cpu::op::rlwinm<0,29,0,2>(regs,&regs.R3,regs.R20);
		/* 821056D4h case    6:*/		return 0x821056D8;
		  /* 821056D8h */ case    7:  		/* cmplw CR6, R3, R10 */
		/* 821056D8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 821056D8h case    7:*/		return 0x821056DC;
		  /* 821056DCh */ case    8:  		/* bc 4, CR6_LT, 424 */
		/* 821056DCh case    8:*/		if ( !regs.CR[6].lt ) { return 0x82105884;  }
		/* 821056DCh case    8:*/		return 0x821056E0;
		  /* 821056E0h */ case    9:  		/* li R11, 0 */
		/* 821056E0h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821056E0h case    9:*/		return 0x821056E4;
		  /* 821056E4h */ case   10:  		/* cmpwi CR6, R16, 0 */
		/* 821056E4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R16,0x00000000);
		/* 821056E4h case   10:*/		return 0x821056E8;
		  /* 821056E8h */ case   11:  		/* bc 4, CR6_LT, 20 */
		/* 821056E8h case   11:*/		if ( !regs.CR[6].lt ) { return 0x821056FC;  }
		/* 821056E8h case   11:*/		return 0x821056EC;
		  /* 821056ECh */ case   12:  		/* lwz R9, <#[R1 + 332]> */
		/* 821056ECh case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000014C) );
		/* 821056ECh case   12:*/		return 0x821056F0;
		  /* 821056F0h */ case   13:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 821056F0h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 821056F0h case   13:*/		return 0x821056F4;
		  /* 821056F4h */ case   14:  		/* bc 12, CR0_EQ, 28 */
		/* 821056F4h case   14:*/		if ( regs.CR[0].eq ) { return 0x82105710;  }
		/* 821056F4h case   14:*/		return 0x821056F8;
		  /* 821056F8h */ case   15:  		/* b 20 */
		/* 821056F8h case   15:*/		return 0x8210570C;
		/* 821056F8h case   15:*/		return 0x821056FC;
	}
	return 0x821056FC;
} // Block from 821056BCh-821056FCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 821056FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821056FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821056FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821056FC);
		  /* 821056FCh */ case    0:  		/* bc 4, CR6_GT, 20 */
		/* 821056FCh case    0:*/		if ( !regs.CR[6].gt ) { return 0x82105710;  }
		/* 821056FCh case    0:*/		return 0x82105700;
		  /* 82105700h */ case    1:  		/* lwz R9, <#[R1 + 332]> */
		/* 82105700h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000014C) );
		/* 82105700h case    1:*/		return 0x82105704;
		  /* 82105704h */ case    2:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82105704h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82105704h case    2:*/		return 0x82105708;
		  /* 82105708h */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 82105708h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82105710;  }
		/* 82105708h case    3:*/		return 0x8210570C;
	}
	return 0x8210570C;
} // Block from 821056FCh-8210570Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210570Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210570C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210570C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210570C);
		  /* 8210570Ch */ case    0:  		/* li R11, 1 */
		/* 8210570Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8210570Ch case    0:*/		return 0x82105710;
	}
	return 0x82105710;
} // Block from 8210570Ch-82105710h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82105710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105710);
		  /* 82105710h */ case    0:  		/* rlwinm R11, R11, 28, 0, 3 */
		/* 82105710h case    0:*/		cpu::op::rlwinm<0,28,0,3>(regs,&regs.R11,regs.R11);
		/* 82105710h case    0:*/		return 0x82105714;
		  /* 82105714h */ case    1:  		/* or R25, R11, R3 */
		/* 82105714h case    1:*/		cpu::op::or<0>(regs,&regs.R25,regs.R11,regs.R3);
		/* 82105714h case    1:*/		return 0x82105718;
		  /* 82105718h */ case    2:  		/* cmplw CR6, R25, R10 */
		/* 82105718h case    2:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R10);
		/* 82105718h case    2:*/		return 0x8210571C;
		  /* 8210571Ch */ case    3:  		/* bc 4, CR6_LT, 356 */
		/* 8210571Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x82105880;  }
		/* 8210571Ch case    3:*/		return 0x82105720;
		  /* 82105720h */ case    4:  		/* li R26, 0 */
		/* 82105720h case    4:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82105720h case    4:*/		return 0x82105724;
		  /* 82105724h */ case    5:  		/* addi R24, R1, 96 */
		/* 82105724h case    5:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R1,0x60);
		/* 82105724h case    5:*/		return 0x82105728;
		  /* 82105728h */ case    6:  		/* lwz R11, <#[R24]> */
		/* 82105728h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82105728h case    6:*/		return 0x8210572C;
		  /* 8210572Ch */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 8210572Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210572Ch case    7:*/		return 0x82105730;
		  /* 82105730h */ case    8:  		/* bc 4, CR6_EQ, 276 */
		/* 82105730h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82105844;  }
		/* 82105730h case    8:*/		return 0x82105734;
		  /* 82105734h */ case    9:  		/* lwz R11, <#[R15 + 12]> */
		/* 82105734h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000000C) );
		/* 82105734h case    9:*/		return 0x82105738;
		  /* 82105738h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105738h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105738h case   10:*/		return 0x8210573C;
		  /* 8210573Ch */ case   11:  		/* add R10, R11, R26 */
		/* 8210573Ch case   11:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R26);
		/* 8210573Ch case   11:*/		return 0x82105740;
		  /* 82105740h */ case   12:  		/* lwz R11, <#[R17 + 24]> */
		/* 82105740h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000018) );
		/* 82105740h case   12:*/		return 0x82105744;
		  /* 82105744h */ case   13:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82105744h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82105744h case   13:*/		return 0x82105748;
		  /* 82105748h */ case   14:  		/* lwzx R27, <#[R10 + R11]> */
		/* 82105748h case   14:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82105748h case   14:*/		return 0x8210574C;
		  /* 8210574Ch */ case   15:  		/* cmpwi CR6, R27, -1 */
		/* 8210574Ch case   15:*/		cpu::op::cmpwi<6>(regs,regs.R27,0xFFFFFFFF);
		/* 8210574Ch case   15:*/		return 0x82105750;
		  /* 82105750h */ case   16:  		/* bc 12, CR6_EQ, 244 */
		/* 82105750h case   16:*/		if ( regs.CR[6].eq ) { return 0x82105844;  }
		/* 82105750h case   16:*/		return 0x82105754;
		  /* 82105754h */ case   17:  		/* lwz R11, <#[R1 + 80]> */
		/* 82105754h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82105754h case   17:*/		return 0x82105758;
		  /* 82105758h */ case   18:  		/* li R28, 0 */
		/* 82105758h case   18:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82105758h case   18:*/		return 0x8210575C;
		  /* 8210575Ch */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 8210575Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210575Ch case   19:*/		return 0x82105760;
		  /* 82105760h */ case   20:  		/* bc 12, CR6_EQ, 172 */
		/* 82105760h case   20:*/		if ( regs.CR[6].eq ) { return 0x8210580C;  }
		/* 82105760h case   20:*/		return 0x82105764;
		  /* 82105764h */ case   21:  		/* lwz R11, <#[R1 + 84]> */
		/* 82105764h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82105764h case   21:*/		return 0x82105768;
		  /* 82105768h */ case   22:  		/* add R10, R28, R26 */
		/* 82105768h case   22:*/		cpu::op::add<0>(regs,&regs.R10,regs.R28,regs.R26);
		/* 82105768h case   22:*/		return 0x8210576C;
		  /* 8210576Ch */ case   23:  		/* cmplwi CR6, R11, 1 */
		/* 8210576Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8210576Ch case   23:*/		return 0x82105770;
		  /* 82105770h */ case   24:  		/* rlwinm R31, R10, 0, 30, 31 */
		/* 82105770h case   24:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R31,regs.R10);
		/* 82105770h case   24:*/		return 0x82105774;
		  /* 82105774h */ case   25:  		/* bc 4, CR6_EQ, 68 */
		/* 82105774h case   25:*/		if ( !regs.CR[6].eq ) { return 0x821057B8;  }
		/* 82105774h case   25:*/		return 0x82105778;
		  /* 82105778h */ case   26:  		/* lwz R11, <#[R14 + 112]> */
		/* 82105778h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000070) );
		/* 82105778h case   26:*/		return 0x8210577C;
		  /* 8210577Ch */ case   27:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 8210577Ch case   27:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 8210577Ch case   27:*/		return 0x82105780;
		  /* 82105780h */ case   28:  		/* bc 12, CR0_EQ, 52 */
		/* 82105780h case   28:*/		if ( regs.CR[0].eq ) { return 0x821057B4;  }
		/* 82105780h case   28:*/		return 0x82105784;
		  /* 82105784h */ case   29:  		/* lwz R11, <#[R15 + 72]> */
		/* 82105784h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000048) );
		/* 82105784h case   29:*/		return 0x82105788;
		  /* 82105788h */ case   30:  		/* lis R10, 20480 */
		/* 82105788h case   30:*/		cpu::op::lis<0>(regs,&regs.R10,0x5000);
		/* 82105788h case   30:*/		return 0x8210578C;
		  /* 8210578Ch */ case   31:  		/* lwz R9, <#[R14 + 24]> */
		/* 8210578Ch case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + 0x00000018) );
		/* 8210578Ch case   31:*/		return 0x82105790;
		  /* 82105790h */ case   32:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105790h case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105790h case   32:*/		return 0x82105794;
		  /* 82105794h */ case   33:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82105794h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82105794h case   33:*/		return 0x82105798;
		  /* 82105798h */ case   34:  		/* lwz R11, <#[R11]> */
		/* 82105798h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82105798h case   34:*/		return 0x8210579C;
		  /* 8210579Ch */ case   35:  		/* rlwinm R9, R11, 0, 0, 11 */
		/* 8210579Ch case   35:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R11);
		/* 8210579Ch case   35:*/		return 0x821057A0;
		  /* 821057A0h */ case   36:  		/* cmplw CR6, R9, R10 */
		/* 821057A0h case   36:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 821057A0h case   36:*/		return 0x821057A4;
		  /* 821057A4h */ case   37:  		/* bc 4, CR6_EQ, 16 */
		/* 821057A4h case   37:*/		if ( !regs.CR[6].eq ) { return 0x821057B4;  }
		/* 821057A4h case   37:*/		return 0x821057A8;
		  /* 821057A8h */ case   38:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 821057A8h case   38:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 821057A8h case   38:*/		return 0x821057AC;
		  /* 821057ACh */ case   39:  		/* cmplwi CR6, R11, 4 */
		/* 821057ACh case   39:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821057ACh case   39:*/		return 0x821057B0;
		  /* 821057B0h */ case   40:  		/* bc 12, CR6_LT, 8 */
		/* 821057B0h case   40:*/		if ( regs.CR[6].lt ) { return 0x821057B8;  }
		/* 821057B0h case   40:*/		return 0x821057B4;
	}
	return 0x821057B4;
} // Block from 82105710h-821057B4h (41 instructions)

//////////////////////////////////////////////////////
// Block at 821057B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821057B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821057B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821057B4);
		  /* 821057B4h */ case    0:  		/* subfic R31, R31, 3 */
		/* 821057B4h case    0:*/		cpu::op::subfic<0>(regs,&regs.R31,regs.R31,0x3);
		/* 821057B4h case    0:*/		return 0x821057B8;
	}
	return 0x821057B8;
} // Block from 821057B4h-821057B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821057B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821057B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821057B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821057B8);
		  /* 821057B8h */ case    0:  		/* rlwinm R30, R31, 2, 0, 29 */
		/* 821057B8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R31);
		/* 821057B8h case    0:*/		return 0x821057BC;
		  /* 821057BCh */ case    1:  		/* addi R29, R1, 112 */
		/* 821057BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R1,0x70);
		/* 821057BCh case    1:*/		return 0x821057C0;
		  /* 821057C0h */ case    2:  		/* lwzx R11, <#[R30 + R29]> */
		/* 821057C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 821057C0h case    2:*/		return 0x821057C4;
		  /* 821057C4h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 821057C4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821057C4h case    3:*/		return 0x821057C8;
		  /* 821057C8h */ case    4:  		/* bc 4, CR6_EQ, 36 */
		/* 821057C8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821057EC;  }
		/* 821057C8h case    4:*/		return 0x821057CC;
		  /* 821057CCh */ case    5:  		/* mr R7, R31 */
		/* 821057CCh case    5:*/		regs.R7 = regs.R31;
		/* 821057CCh case    5:*/		return 0x821057D0;
		  /* 821057D0h */ case    6:  		/* lwz R6, <#[R1 + 332]> */
		/* 821057D0h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000014C) );
		/* 821057D0h case    6:*/		return 0x821057D4;
		  /* 821057D4h */ case    7:  		/* mr R5, R27 */
		/* 821057D4h case    7:*/		regs.R5 = regs.R27;
		/* 821057D4h case    7:*/		return 0x821057D8;
		  /* 821057D8h */ case    8:  		/* mr R4, R17 */
		/* 821057D8h case    8:*/		regs.R4 = regs.R17;
		/* 821057D8h case    8:*/		return 0x821057DC;
		  /* 821057DCh */ case    9:  		/* mr R3, R14 */
		/* 821057DCh case    9:*/		regs.R3 = regs.R14;
		/* 821057DCh case    9:*/		return 0x821057E0;
		  /* 821057E0h */ case   10:  		/* bl -18472 */
		/* 821057E0h case   10:*/		regs.LR = 0x821057E4; return 0x82100FB8;
		/* 821057E0h case   10:*/		return 0x821057E4;
		  /* 821057E4h */ case   11:  		/* cmpwi CR6, R3, -1 */
		/* 821057E4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 821057E4h case   11:*/		return 0x821057E8;
		  /* 821057E8h */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 821057E8h case   12:*/		if ( regs.CR[6].eq ) { return 0x82105800;  }
		/* 821057E8h case   12:*/		return 0x821057EC;
	}
	return 0x821057EC;
} // Block from 821057B8h-821057ECh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821057ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821057EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821057EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821057EC);
		  /* 821057ECh */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 821057ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821057ECh case    0:*/		return 0x821057F0;
		  /* 821057F0h */ case    1:  		/* addi R28, R28, 1 */
		/* 821057F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 821057F0h case    1:*/		return 0x821057F4;
		  /* 821057F4h */ case    2:  		/* cmplw CR6, R28, R11 */
		/* 821057F4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 821057F4h case    2:*/		return 0x821057F8;
		  /* 821057F8h */ case    3:  		/* bc 12, CR6_LT, -148 */
		/* 821057F8h case    3:*/		if ( regs.CR[6].lt ) { return 0x82105764;  }
		/* 821057F8h case    3:*/		return 0x821057FC;
		  /* 821057FCh */ case    4:  		/* b 12 */
		/* 821057FCh case    4:*/		return 0x82105808;
		/* 821057FCh case    4:*/		return 0x82105800;
	}
	return 0x82105800;
} // Block from 821057ECh-82105800h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82105800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105800);
		  /* 82105800h */ case    0:  		/* stwx R26, <#[R30 + R29]> */
		/* 82105800h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 82105800h case    0:*/		return 0x82105804;
		  /* 82105804h */ case    1:  		/* stw R31, <#[R24]> */
		/* 82105804h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R24 + 0x00000000) );
		/* 82105804h case    1:*/		return 0x82105808;
	}
	return 0x82105808;
} // Block from 82105800h-82105808h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82105808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105808);
		  /* 82105808h */ case    0:  		/* lwz R30, <#[R1 + 348]> */
		/* 82105808h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000015C) );
		/* 82105808h case    0:*/		return 0x8210580C;
	}
	return 0x8210580C;
} // Block from 82105808h-8210580Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210580Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210580C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210580C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210580C);
		  /* 8210580Ch */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 8210580Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8210580Ch case    0:*/		return 0x82105810;
		  /* 82105810h */ case    1:  		/* cmplw CR6, R11, R28 */
		/* 82105810h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 82105810h case    1:*/		return 0x82105814;
		  /* 82105814h */ case    2:  		/* bc 12, CR6_EQ, 120 */
		/* 82105814h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210588C;  }
		/* 82105814h case    2:*/		return 0x82105818;
		  /* 82105818h */ case    3:  		/* lwz R11, <#[R17 + 96]> */
		/* 82105818h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000060) );
		/* 82105818h case    3:*/		return 0x8210581C;
		  /* 8210581Ch */ case    4:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 8210581Ch case    4:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8210581Ch case    4:*/		return 0x82105820;
		  /* 82105820h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82105820h case    5:*/		if ( regs.CR[0].eq ) { return 0x82105830;  }
		/* 82105820h case    5:*/		return 0x82105824;
		  /* 82105824h */ case    6:  		/* lwz R11, <#[R1 + 84]> */
		/* 82105824h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82105824h case    6:*/		return 0x82105828;
		  /* 82105828h */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 82105828h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82105828h case    7:*/		return 0x8210582C;
		  /* 8210582Ch */ case    8:  		/* bc 4, CR6_GT, 24 */
		/* 8210582Ch case    8:*/		if ( !regs.CR[6].gt ) { return 0x82105844;  }
		/* 8210582Ch case    8:*/		return 0x82105830;
	}
	return 0x82105830;
} // Block from 8210580Ch-82105830h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82105830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105830);
		  /* 82105830h */ case    0:  		/* rlwinm R11, R28, 24, 0, 7 */
		/* 82105830h case    0:*/		cpu::op::rlwinm<0,24,0,7>(regs,&regs.R11,regs.R28);
		/* 82105830h case    0:*/		return 0x82105834;
		  /* 82105834h */ case    1:  		/* lwz R10, <#[R1 + 356]> */
		/* 82105834h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000164) );
		/* 82105834h case    1:*/		return 0x82105838;
		  /* 82105838h */ case    2:  		/* add R25, R11, R25 */
		/* 82105838h case    2:*/		cpu::op::add<0>(regs,&regs.R25,regs.R11,regs.R25);
		/* 82105838h case    2:*/		return 0x8210583C;
		  /* 8210583Ch */ case    3:  		/* cmplw CR6, R25, R10 */
		/* 8210583Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R10);
		/* 8210583Ch case    3:*/		return 0x82105840;
		  /* 82105840h */ case    4:  		/* bc 4, CR6_LT, 64 */
		/* 82105840h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82105880;  }
		/* 82105840h case    4:*/		return 0x82105844;
	}
	return 0x82105844;
} // Block from 82105830h-82105844h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82105844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105844);
		  /* 82105844h */ case    0:  		/* addi R26, R26, 1 */
		/* 82105844h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82105844h case    0:*/		return 0x82105848;
		  /* 82105848h */ case    1:  		/* addi R24, R24, 4 */
		/* 82105848h case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 82105848h case    1:*/		return 0x8210584C;
		  /* 8210584Ch */ case    2:  		/* cmplwi CR6, R26, 4 */
		/* 8210584Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000004);
		/* 8210584Ch case    2:*/		return 0x82105850;
		  /* 82105850h */ case    3:  		/* bc 12, CR6_LT, -296 */
		/* 82105850h case    3:*/		if ( regs.CR[6].lt ) { return 0x82105728;  }
		/* 82105850h case    3:*/		return 0x82105854;
		  /* 82105854h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 82105854h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82105854h case    4:*/		return 0x82105858;
		  /* 82105858h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 82105858h case    5:*/		if ( regs.CR[6].eq ) { return 0x82105880;  }
		/* 82105858h case    5:*/		return 0x8210585C;
		  /* 8210585Ch */ case    6:  		/* addi R11, R1, 96 */
		/* 8210585Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8210585Ch case    6:*/		return 0x82105860;
		  /* 82105860h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 82105860h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82105860h case    7:*/		return 0x82105864;
		  /* 82105864h */ case    8:  		/* lwz R9, <#[R11 + 4]> */
		/* 82105864h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82105864h case    8:*/		return 0x82105868;
		  /* 82105868h */ case    9:  		/* lwz R8, <#[R11 + 8]> */
		/* 82105868h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82105868h case    9:*/		return 0x8210586C;
		  /* 8210586Ch */ case   10:  		/* lwz R11, <#[R11 + 12]> */
		/* 8210586Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210586Ch case   10:*/		return 0x82105870;
		  /* 82105870h */ case   11:  		/* stw R10, <#[R30]> */
		/* 82105870h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82105870h case   11:*/		return 0x82105874;
		  /* 82105874h */ case   12:  		/* stw R9, <#[R30 + 4]> */
		/* 82105874h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000004) );
		/* 82105874h case   12:*/		return 0x82105878;
		  /* 82105878h */ case   13:  		/* stw R8, <#[R30 + 8]> */
		/* 82105878h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000008) );
		/* 82105878h case   13:*/		return 0x8210587C;
		  /* 8210587Ch */ case   14:  		/* stw R11, <#[R30 + 12]> */
		/* 8210587Ch case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210587Ch case   14:*/		return 0x82105880;
	}
	return 0x82105880;
} // Block from 82105844h-82105880h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82105880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105880);
		  /* 82105880h */ case    0:  		/* mr R3, R25 */
		/* 82105880h case    0:*/		regs.R3 = regs.R25;
		/* 82105880h case    0:*/		return 0x82105884;
	}
	return 0x82105884;
} // Block from 82105880h-82105884h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82105884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105884);
		  /* 82105884h */ case    0:  		/* addi R1, R1, 288 */
		/* 82105884h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 82105884h case    0:*/		return 0x82105888;
		  /* 82105888h */ case    1:  		/* b -476696 */
		/* 82105888h case    1:*/		return 0x82091270;
		/* 82105888h case    1:*/		return 0x8210588C;
	}
	return 0x8210588C;
} // Block from 82105884h-8210588Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210588Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210588C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210588C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210588C);
		  /* 8210588Ch */ case    0:  		/* li R3, -1 */
		/* 8210588Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8210588Ch case    0:*/		return 0x82105890;
		  /* 82105890h */ case    1:  		/* b -12 */
		/* 82105890h case    1:*/		return 0x82105884;
		/* 82105890h case    1:*/		return 0x82105894;
		  /* 82105894h */ case    2:  		/* nop */
		/* 82105894h case    2:*/		cpu::op::nop();
		/* 82105894h case    2:*/		return 0x82105898;
	}
	return 0x82105898;
} // Block from 8210588Ch-82105898h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82105898h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105898);
		  /* 82105898h */ case    0:  		/* mfspr R12, LR */
		/* 82105898h case    0:*/		regs.R12 = regs.LR;
		/* 82105898h case    0:*/		return 0x8210589C;
		  /* 8210589Ch */ case    1:  		/* bl -476736 */
		/* 8210589Ch case    1:*/		regs.LR = 0x821058A0; return 0x8209125C;
		/* 8210589Ch case    1:*/		return 0x821058A0;
		  /* 821058A0h */ case    2:  		/* lwz R11, <#[R3 + 20]> */
		/* 821058A0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 821058A0h case    2:*/		return 0x821058A4;
		  /* 821058A4h */ case    3:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 821058A4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 821058A4h case    3:*/		return 0x821058A8;
		  /* 821058A8h */ case    4:  		/* lwzx R10, <#[R10 + R11]> */
		/* 821058A8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821058A8h case    4:*/		return 0x821058AC;
		  /* 821058ACh */ case    5:  		/* lwz R10, <#[R10 + 56]> */
		/* 821058ACh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 821058ACh case    5:*/		return 0x821058B0;
		  /* 821058B0h */ case    6:  		/* cmpwi CR6, R10, -1 */
		/* 821058B0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821058B0h case    6:*/		return 0x821058B4;
		  /* 821058B4h */ case    7:  		/* bc 12, CR6_EQ, 8 */
		/* 821058B4h case    7:*/		if ( regs.CR[6].eq ) { return 0x821058BC;  }
		/* 821058B4h case    7:*/		return 0x821058B8;
		  /* 821058B8h */ case    8:  		/* mr R5, R10 */
		/* 821058B8h case    8:*/		regs.R5 = regs.R10;
		/* 821058B8h case    8:*/		return 0x821058BC;
	}
	return 0x821058BC;
} // Block from 82105898h-821058BCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821058BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821058BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821058BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821058BC);
		  /* 821058BCh */ case    0:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 821058BCh case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 821058BCh case    0:*/		return 0x821058C0;
		  /* 821058C0h */ case    1:  		/* lwz R9, <#[R4]> */
		/* 821058C0h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000000) );
		/* 821058C0h case    1:*/		return 0x821058C4;
		  /* 821058C4h */ case    2:  		/* lwzx R8, <#[R10 + R11]> */
		/* 821058C4h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821058C4h case    2:*/		return 0x821058C8;
		  /* 821058C8h */ case    3:  		/* lwz R11, <#[R8 + 4]> */
		/* 821058C8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 821058C8h case    3:*/		return 0x821058CC;
		  /* 821058CCh */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 821058CCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821058CCh case    4:*/		return 0x821058D0;
		  /* 821058D0h */ case    5:  		/* bc 4, CR6_EQ, 428 */
		/* 821058D0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82105A7C;  }
		/* 821058D0h case    5:*/		return 0x821058D4;
		  /* 821058D4h */ case    6:  		/* lwz R11, <#[R4 + 88]> */
		/* 821058D4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000058) );
		/* 821058D4h case    6:*/		return 0x821058D8;
		  /* 821058D8h */ case    7:  		/* lwz R31, <#[R8 + 116]> */
		/* 821058D8h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R8 + 0x00000074) );
		/* 821058D8h case    7:*/		return 0x821058DC;
		  /* 821058DCh */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 821058DCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821058DCh case    8:*/		return 0x821058E0;
		  /* 821058E0h */ case    9:  		/* bc 12, CR6_EQ, 392 */
		/* 821058E0h case    9:*/		if ( regs.CR[6].eq ) { return 0x82105A68;  }
		/* 821058E0h case    9:*/		return 0x821058E4;
		  /* 821058E4h */ case   10:  		/* lwz R11, <#[R4 + 80]> */
		/* 821058E4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000050) );
		/* 821058E4h case   10:*/		return 0x821058E8;
		  /* 821058E8h */ case   11:  		/* rlwinm R7, R31, 2, 0, 29 */
		/* 821058E8h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R31);
		/* 821058E8h case   11:*/		return 0x821058EC;
		  /* 821058ECh */ case   12:  		/* lwz R5, <#[R4 + 76]> */
		/* 821058ECh case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x0000004C) );
		/* 821058ECh case   12:*/		return 0x821058F0;
		  /* 821058F0h */ case   13:  		/* rlwinm R9, R6, 2, 0, 29 */
		/* 821058F0h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R6);
		/* 821058F0h case   13:*/		return 0x821058F4;
		  /* 821058F4h */ case   14:  		/* lwz R30, <#[R4 + 84]> */
		/* 821058F4h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x00000054) );
		/* 821058F4h case   14:*/		return 0x821058F8;
		  /* 821058F8h */ case   15:  		/* lis R29, 8304 */
		/* 821058F8h case   15:*/		cpu::op::lis<0>(regs,&regs.R29,0x2070);
		/* 821058F8h case   15:*/		return 0x821058FC;
		  /* 821058FCh */ case   16:  		/* lwzx R10, <#[R11 + R7]> */
		/* 821058FCh case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 821058FCh case   16:*/		return 0x82105900;
		  /* 82105900h */ case   17:  		/* lwzx R11, <#[R5 + R7]> */
		/* 82105900h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R7 + 0x00000000) );
		/* 82105900h case   17:*/		return 0x82105904;
		  /* 82105904h */ case   18:  		/* add R10, R10, R11 */
		/* 82105904h case   18:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82105904h case   18:*/		return 0x82105908;
		  /* 82105908h */ case   19:  		/* rlwinm R7, R10, 2, 0, 29 */
		/* 82105908h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R10);
		/* 82105908h case   19:*/		return 0x8210590C;
		  /* 8210590Ch */ case   20:  		/* mulli R11, R10, 12 */
		/* 8210590Ch case   20:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R10,0xC);
		/* 8210590Ch case   20:*/		return 0x82105910;
		  /* 82105910h */ case   21:  		/* stwx R10, <#[R30 + R7]> */
		/* 82105910h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + regs.R7 + 0x00000000) );
		/* 82105910h case   21:*/		return 0x82105914;
		  /* 82105914h */ case   22:  		/* lwz R10, <#[R4 + 88]> */
		/* 82105914h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000058) );
		/* 82105914h case   22:*/		return 0x82105918;
		  /* 82105918h */ case   23:  		/* stwx R6, <#[R11 + R10]> */
		/* 82105918h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82105918h case   23:*/		return 0x8210591C;
		  /* 8210591Ch */ case   24:  		/* lwz R10, <#[R3 + 24]> */
		/* 8210591Ch case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 8210591Ch case   24:*/		return 0x82105920;
		  /* 82105920h */ case   25:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82105920h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82105920h case   25:*/		return 0x82105924;
		  /* 82105924h */ case   26:  		/* lwz R10, <#[R10]> */
		/* 82105924h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82105924h case   26:*/		return 0x82105928;
		  /* 82105928h */ case   27:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82105928h case   27:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82105928h case   27:*/		return 0x8210592C;
		  /* 8210592Ch */ case   28:  		/* cmplw CR6, R10, R29 */
		/* 8210592Ch case   28:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 8210592Ch case   28:*/		return 0x82105930;
		  /* 82105930h */ case   29:  		/* bc 12, CR6_EQ, 28 */
		/* 82105930h case   29:*/		if ( regs.CR[6].eq ) { return 0x8210594C;  }
		/* 82105930h case   29:*/		return 0x82105934;
		  /* 82105934h */ case   30:  		/* lis R7, 8320 */
		/* 82105934h case   30:*/		cpu::op::lis<0>(regs,&regs.R7,0x2080);
		/* 82105934h case   30:*/		return 0x82105938;
		  /* 82105938h */ case   31:  		/* cmplw CR6, R10, R7 */
		/* 82105938h case   31:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 82105938h case   31:*/		return 0x8210593C;
		  /* 8210593Ch */ case   32:  		/* bc 12, CR6_EQ, 16 */
		/* 8210593Ch case   32:*/		if ( regs.CR[6].eq ) { return 0x8210594C;  }
		/* 8210593Ch case   32:*/		return 0x82105940;
		  /* 82105940h */ case   33:  		/* lis R7, 4432 */
		/* 82105940h case   33:*/		cpu::op::lis<0>(regs,&regs.R7,0x1150);
		/* 82105940h case   33:*/		return 0x82105944;
		  /* 82105944h */ case   34:  		/* cmplw CR6, R10, R7 */
		/* 82105944h case   34:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 82105944h case   34:*/		return 0x82105948;
		  /* 82105948h */ case   35:  		/* bc 4, CR6_EQ, 28 */
		/* 82105948h case   35:*/		if ( !regs.CR[6].eq ) { return 0x82105964;  }
		/* 82105948h case   35:*/		return 0x8210594C;
	}
	return 0x8210594C;
} // Block from 821058BCh-8210594Ch (36 instructions)

//////////////////////////////////////////////////////
// Block at 8210594Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210594C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210594C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210594C);
		  /* 8210594Ch */ case    0:  		/* lwz R10, <#[R4 + 88]> */
		/* 8210594Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000058) );
		/* 8210594Ch case    0:*/		return 0x82105950;
		  /* 82105950h */ case    1:  		/* lwz R9, <#[R8 + 20]> */
		/* 82105950h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000014) );
		/* 82105950h case    1:*/		return 0x82105954;
		  /* 82105954h */ case    2:  		/* add R10, R11, R10 */
		/* 82105954h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82105954h case    2:*/		return 0x82105958;
		  /* 82105958h */ case    3:  		/* stw R9, <#[R10 + 4]> */
		/* 82105958h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82105958h case    3:*/		return 0x8210595C;
		  /* 8210595Ch */ case    4:  		/* lwz R9, <#[R8 + 24]> */
		/* 8210595Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000018) );
		/* 8210595Ch case    4:*/		return 0x82105960;
		  /* 82105960h */ case    5:  		/* b 80 */
		/* 82105960h case    5:*/		return 0x821059B0;
		/* 82105960h case    5:*/		return 0x82105964;
	}
	return 0x82105964;
} // Block from 8210594Ch-82105964h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82105964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105964);
		  /* 82105964h */ case    0:  		/* lwz R7, <#[R3 + 24]> */
		/* 82105964h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000018) );
		/* 82105964h case    0:*/		return 0x82105968;
		  /* 82105968h */ case    1:  		/* lwz R5, <#[R3 + 20]> */
		/* 82105968h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 82105968h case    1:*/		return 0x8210596C;
		  /* 8210596Ch */ case    2:  		/* lwz R10, <#[R4 + 88]> */
		/* 8210596Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000058) );
		/* 8210596Ch case    2:*/		return 0x82105970;
		  /* 82105970h */ case    3:  		/* add R10, R11, R10 */
		/* 82105970h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82105970h case    3:*/		return 0x82105974;
		  /* 82105974h */ case    4:  		/* lwzx R7, <#[R7 + R9]> */
		/* 82105974h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 82105974h case    4:*/		return 0x82105978;
		  /* 82105978h */ case    5:  		/* lwz R7, <#[R7 + 16]> */
		/* 82105978h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000010) );
		/* 82105978h case    5:*/		return 0x8210597C;
		  /* 8210597Ch */ case    6:  		/* lwz R7, <#[R7]> */
		/* 8210597Ch case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000000) );
		/* 8210597Ch case    6:*/		return 0x82105980;
		  /* 82105980h */ case    7:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82105980h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82105980h case    7:*/		return 0x82105984;
		  /* 82105984h */ case    8:  		/* lwzx R7, <#[R7 + R5]> */
		/* 82105984h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R5 + 0x00000000) );
		/* 82105984h case    8:*/		return 0x82105988;
		  /* 82105988h */ case    9:  		/* lwz R7, <#[R7 + 20]> */
		/* 82105988h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000014) );
		/* 82105988h case    9:*/		return 0x8210598C;
		  /* 8210598Ch */ case   10:  		/* stw R7, <#[R10 + 4]> */
		/* 8210598Ch case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8210598Ch case   10:*/		return 0x82105990;
		  /* 82105990h */ case   11:  		/* lwz R7, <#[R3 + 24]> */
		/* 82105990h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000018) );
		/* 82105990h case   11:*/		return 0x82105994;
		  /* 82105994h */ case   12:  		/* lwz R5, <#[R3 + 20]> */
		/* 82105994h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 82105994h case   12:*/		return 0x82105998;
		  /* 82105998h */ case   13:  		/* lwzx R9, <#[R7 + R9]> */
		/* 82105998h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 82105998h case   13:*/		return 0x8210599C;
		  /* 8210599Ch */ case   14:  		/* lwz R9, <#[R9 + 16]> */
		/* 8210599Ch case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000010) );
		/* 8210599Ch case   14:*/		return 0x821059A0;
		  /* 821059A0h */ case   15:  		/* lwz R9, <#[R9]> */
		/* 821059A0h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 821059A0h case   15:*/		return 0x821059A4;
		  /* 821059A4h */ case   16:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821059A4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821059A4h case   16:*/		return 0x821059A8;
		  /* 821059A8h */ case   17:  		/* lwzx R9, <#[R9 + R5]> */
		/* 821059A8h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 821059A8h case   17:*/		return 0x821059AC;
		  /* 821059ACh */ case   18:  		/* lwz R9, <#[R9 + 24]> */
		/* 821059ACh case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 821059ACh case   18:*/		return 0x821059B0;
	}
	return 0x821059B0;
} // Block from 82105964h-821059B0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821059B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821059B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821059B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821059B0);
		  /* 821059B0h */ case    0:  		/* lwz R10, <#[R4 + 88]> */
		/* 821059B0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000058) );
		/* 821059B0h case    0:*/		return 0x821059B4;
		  /* 821059B4h */ case    1:  		/* add R10, R11, R10 */
		/* 821059B4h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 821059B4h case    1:*/		return 0x821059B8;
		  /* 821059B8h */ case    2:  		/* stw R9, <#[R10 + 8]> */
		/* 821059B8h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 821059B8h case    2:*/		return 0x821059BC;
		  /* 821059BCh */ case    3:  		/* lwz R10, <#[R4 + 88]> */
		/* 821059BCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000058) );
		/* 821059BCh case    3:*/		return 0x821059C0;
		  /* 821059C0h */ case    4:  		/* add R9, R11, R10 */
		/* 821059C0h case    4:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 821059C0h case    4:*/		return 0x821059C4;
		  /* 821059C4h */ case    5:  		/* lwz R10, <#[R9 + 4]> */
		/* 821059C4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 821059C4h case    5:*/		return 0x821059C8;
		  /* 821059C8h */ case    6:  		/* lwz R7, <#[R9 + 8]> */
		/* 821059C8h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000008) );
		/* 821059C8h case    6:*/		return 0x821059CC;
		  /* 821059CCh */ case    7:  		/* b 144 */
		/* 821059CCh case    7:*/		return 0x82105A5C;
		/* 821059CCh case    7:*/		return 0x821059D0;
		  /* 821059D0h */ case    8:  		/* lwz R5, <#[R3 + 20]> */
		/* 821059D0h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 821059D0h case    8:*/		return 0x821059D4;
		  /* 821059D4h */ case    9:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 821059D4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 821059D4h case    9:*/		return 0x821059D8;
		  /* 821059D8h */ case   10:  		/* lwz R30, <#[R3 + 16]> */
		/* 821059D8h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000010) );
		/* 821059D8h case   10:*/		return 0x821059DC;
		  /* 821059DCh */ case   11:  		/* lwzx R5, <#[R9 + R5]> */
		/* 821059DCh case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 821059DCh case   11:*/		return 0x821059E0;
		  /* 821059E0h */ case   12:  		/* lwz R5, <#[R5 + 4]> */
		/* 821059E0h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000004) );
		/* 821059E0h case   12:*/		return 0x821059E4;
		  /* 821059E4h */ case   13:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 821059E4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 821059E4h case   13:*/		return 0x821059E8;
		  /* 821059E8h */ case   14:  		/* lwzx R5, <#[R5 + R30]> */
		/* 821059E8h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R30 + 0x00000000) );
		/* 821059E8h case   14:*/		return 0x821059EC;
		  /* 821059ECh */ case   15:  		/* lwz R5, <#[R5 + 4]> */
		/* 821059ECh case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000004) );
		/* 821059ECh case   15:*/		return 0x821059F0;
		  /* 821059F0h */ case   16:  		/* rlwinm. R5, R5, 0, 16, 16 */
		/* 821059F0h case   16:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R5,regs.R5);
		/* 821059F0h case   16:*/		return 0x821059F4;
		  /* 821059F4h */ case   17:  		/* bc 12, CR0_EQ, 88 */
		/* 821059F4h case   17:*/		if ( regs.CR[0].eq ) { return 0x82105A4C;  }
		/* 821059F4h case   17:*/		return 0x821059F8;
		  /* 821059F8h */ case   18:  		/* lwz R5, <#[R4 + 88]> */
		/* 821059F8h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x00000058) );
		/* 821059F8h case   18:*/		return 0x821059FC;
		  /* 821059FCh */ case   19:  		/* add R5, R11, R5 */
		/* 821059FCh case   19:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 821059FCh case   19:*/		return 0x82105A00;
		  /* 82105A00h */ case   20:  		/* stw R10, <#[R5 + 4]> */
		/* 82105A00h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000004) );
		/* 82105A00h case   20:*/		return 0x82105A04;
		  /* 82105A04h */ case   21:  		/* lwz R10, <#[R4 + 88]> */
		/* 82105A04h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000058) );
		/* 82105A04h case   21:*/		return 0x82105A08;
		  /* 82105A08h */ case   22:  		/* add R10, R11, R10 */
		/* 82105A08h case   22:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82105A08h case   22:*/		return 0x82105A0C;
		  /* 82105A0Ch */ case   23:  		/* stw R7, <#[R10 + 8]> */
		/* 82105A0Ch case   23:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000008) );
		/* 82105A0Ch case   23:*/		return 0x82105A10;
		  /* 82105A10h */ case   24:  		/* lwz R10, <#[R3 + 20]> */
		/* 82105A10h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82105A10h case   24:*/		return 0x82105A14;
		  /* 82105A14h */ case   25:  		/* lwz R7, <#[R4 + 88]> */
		/* 82105A14h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000058) );
		/* 82105A14h case   25:*/		return 0x82105A18;
		  /* 82105A18h */ case   26:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82105A18h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82105A18h case   26:*/		return 0x82105A1C;
		  /* 82105A1Ch */ case   27:  		/* lwz R10, <#[R10 + 88]> */
		/* 82105A1Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000058) );
		/* 82105A1Ch case   27:*/		return 0x82105A20;
		  /* 82105A20h */ case   28:  		/* stwx R10, <#[R11 + R7]> */
		/* 82105A20h case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82105A20h case   28:*/		return 0x82105A24;
		  /* 82105A24h */ case   29:  		/* lwz R10, <#[R3 + 20]> */
		/* 82105A24h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82105A24h case   29:*/		return 0x82105A28;
		  /* 82105A28h */ case   30:  		/* lwz R7, <#[R8 + 88]> */
		/* 82105A28h case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000058) );
		/* 82105A28h case   30:*/		return 0x82105A2C;
		  /* 82105A2Ch */ case   31:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82105A2Ch case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82105A2Ch case   31:*/		return 0x82105A30;
		  /* 82105A30h */ case   32:  		/* lwz R10, <#[R10 + 88]> */
		/* 82105A30h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000058) );
		/* 82105A30h case   32:*/		return 0x82105A34;
		  /* 82105A34h */ case   33:  		/* cmplw CR6, R7, R10 */
		/* 82105A34h case   33:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 82105A34h case   33:*/		return 0x82105A38;
		  /* 82105A38h */ case   34:  		/* bc 4, CR6_LT, 20 */
		/* 82105A38h case   34:*/		if ( !regs.CR[6].lt ) { return 0x82105A4C;  }
		/* 82105A38h case   34:*/		return 0x82105A3C;
		  /* 82105A3Ch */ case   35:  		/* lwz R10, <#[R3 + 20]> */
		/* 82105A3Ch case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82105A3Ch case   35:*/		return 0x82105A40;
		  /* 82105A40h */ case   36:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82105A40h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82105A40h case   36:*/		return 0x82105A44;
		  /* 82105A44h */ case   37:  		/* lwz R10, <#[R10 + 88]> */
		/* 82105A44h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000058) );
		/* 82105A44h case   37:*/		return 0x82105A48;
		  /* 82105A48h */ case   38:  		/* stw R10, <#[R8 + 88]> */
		/* 82105A48h case   38:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000058) );
		/* 82105A48h case   38:*/		return 0x82105A4C;
	}
	return 0x82105A4C;
} // Block from 821059B0h-82105A4Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 82105A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105A4C);
		  /* 82105A4Ch */ case    0:  		/* lwz R10, <#[R3 + 20]> */
		/* 82105A4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82105A4Ch case    0:*/		return 0x82105A50;
		  /* 82105A50h */ case    1:  		/* lwzx R9, <#[R9 + R10]> */
		/* 82105A50h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82105A50h case    1:*/		return 0x82105A54;
		  /* 82105A54h */ case    2:  		/* lwz R10, <#[R9 + 20]> */
		/* 82105A54h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000014) );
		/* 82105A54h case    2:*/		return 0x82105A58;
		  /* 82105A58h */ case    3:  		/* lwz R7, <#[R9 + 24]> */
		/* 82105A58h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000018) );
		/* 82105A58h case    3:*/		return 0x82105A5C;
	}
	return 0x82105A5C;
} // Block from 82105A4Ch-82105A5Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82105A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105A5C);
		  /* 82105A5Ch */ case    0:  		/* lwz R5, <#[R8 + 20]> */
		/* 82105A5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000014) );
		/* 82105A5Ch case    0:*/		return 0x82105A60;
		  /* 82105A60h */ case    1:  		/* cmplw CR6, R10, R5 */
		/* 82105A60h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R5);
		/* 82105A60h case    1:*/		return 0x82105A64;
		  /* 82105A64h */ case    2:  		/* bc 4, CR6_EQ, -148 */
		/* 82105A64h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821059D0;  }
		/* 82105A64h case    2:*/		return 0x82105A68;
	}
	return 0x82105A68;
} // Block from 82105A5Ch-82105A68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82105A68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105A68);
		  /* 82105A68h */ case    0:  		/* lwz R11, <#[R4 + 76]> */
		/* 82105A68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000004C) );
		/* 82105A68h case    0:*/		return 0x82105A6C;
		  /* 82105A6Ch */ case    1:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82105A6Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82105A6Ch case    1:*/		return 0x82105A70;
	}
	return 0x82105A70;
} // Block from 82105A68h-82105A70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82105A70h
// Function '?VectorizeLeft_Special@CProgram@D3DXShader@@AAAJPAVCInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105A70);
		  /* 82105A70h */ case    0:  		/* lwzx R9, <#[R11 + R10]> */
		/* 82105A70h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82105A70h case    0:*/		return 0x82105A74;
		  /* 82105A74h */ case    1:  		/* addi R9, R9, 1 */
		/* 82105A74h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82105A74h case    1:*/		return 0x82105A78;
		  /* 82105A78h */ case    2:  		/* stwx R9, <#[R11 + R10]> */
		/* 82105A78h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82105A78h case    2:*/		return 0x82105A7C;
	}
	return 0x82105A7C;
} // Block from 82105A70h-82105A7Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82105A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105A7C);
		  /* 82105A7Ch */ case    0:  		/* lwz R5, <#[R8 + 8]> */
		/* 82105A7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000008) );
		/* 82105A7Ch case    0:*/		return 0x82105A80;
		  /* 82105A80h */ case    1:  		/* cmpwi CR6, R5, -1 */
		/* 82105A80h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 82105A80h case    1:*/		return 0x82105A84;
		  /* 82105A84h */ case    2:  		/* bc 4, CR6_EQ, -484 */
		/* 82105A84h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821058A0;  }
		/* 82105A84h case    2:*/		return 0x82105A88;
		  /* 82105A88h */ case    3:  		/* b -477148 */
		/* 82105A88h case    3:*/		return 0x820912AC;
		/* 82105A88h case    3:*/		return 0x82105A8C;
		  /* 82105A8Ch */ case    4:  		/* nop */
		/* 82105A8Ch case    4:*/		cpu::op::nop();
		/* 82105A8Ch case    4:*/		return 0x82105A90;
	}
	return 0x82105A90;
} // Block from 82105A7Ch-82105A90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82105A90h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105A90);
		  /* 82105A90h */ case    0:  		/* mfspr R12, LR */
		/* 82105A90h case    0:*/		regs.R12 = regs.LR;
		/* 82105A90h case    0:*/		return 0x82105A94;
		  /* 82105A94h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82105A94h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82105A94h case    1:*/		return 0x82105A98;
		  /* 82105A98h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82105A98h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82105A98h case    2:*/		return 0x82105A9C;
		  /* 82105A9Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82105A9Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82105A9Ch case    3:*/		return 0x82105AA0;
		  /* 82105AA0h */ case    4:  		/* mr R31, R4 */
		/* 82105AA0h case    4:*/		regs.R31 = regs.R4;
		/* 82105AA0h case    4:*/		return 0x82105AA4;
		  /* 82105AA4h */ case    5:  		/* lis R4, 9345 */
		/* 82105AA4h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105AA4h case    5:*/		return 0x82105AA8;
		  /* 82105AA8h */ case    6:  		/* lwz R3, <#[R31 + 8]> */
		/* 82105AA8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 82105AA8h case    6:*/		return 0x82105AAC;
		  /* 82105AACh */ case    7:  		/* bl -513908 */
		/* 82105AACh case    7:*/		regs.LR = 0x82105AB0; return 0x82088338;
		/* 82105AACh case    7:*/		return 0x82105AB0;
		  /* 82105AB0h */ case    8:  		/* lis R4, 9345 */
		/* 82105AB0h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105AB0h case    8:*/		return 0x82105AB4;
		  /* 82105AB4h */ case    9:  		/* lwz R3, <#[R31 + 12]> */
		/* 82105AB4h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 82105AB4h case    9:*/		return 0x82105AB8;
		  /* 82105AB8h */ case   10:  		/* bl -513920 */
		/* 82105AB8h case   10:*/		regs.LR = 0x82105ABC; return 0x82088338;
		/* 82105AB8h case   10:*/		return 0x82105ABC;
		  /* 82105ABCh */ case   11:  		/* lis R4, 9345 */
		/* 82105ABCh case   11:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105ABCh case   11:*/		return 0x82105AC0;
		  /* 82105AC0h */ case   12:  		/* lwz R3, <#[R31 + 16]> */
		/* 82105AC0h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82105AC0h case   12:*/		return 0x82105AC4;
		  /* 82105AC4h */ case   13:  		/* bl -513932 */
		/* 82105AC4h case   13:*/		regs.LR = 0x82105AC8; return 0x82088338;
		/* 82105AC4h case   13:*/		return 0x82105AC8;
		  /* 82105AC8h */ case   14:  		/* lis R4, 9345 */
		/* 82105AC8h case   14:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105AC8h case   14:*/		return 0x82105ACC;
		  /* 82105ACCh */ case   15:  		/* lwz R3, <#[R31 + 20]> */
		/* 82105ACCh case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 82105ACCh case   15:*/		return 0x82105AD0;
		  /* 82105AD0h */ case   16:  		/* bl -513944 */
		/* 82105AD0h case   16:*/		regs.LR = 0x82105AD4; return 0x82088338;
		/* 82105AD0h case   16:*/		return 0x82105AD4;
		  /* 82105AD4h */ case   17:  		/* lis R4, 9345 */
		/* 82105AD4h case   17:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105AD4h case   17:*/		return 0x82105AD8;
		  /* 82105AD8h */ case   18:  		/* lwz R3, <#[R31 + 24]> */
		/* 82105AD8h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 82105AD8h case   18:*/		return 0x82105ADC;
		  /* 82105ADCh */ case   19:  		/* bl -513956 */
		/* 82105ADCh case   19:*/		regs.LR = 0x82105AE0; return 0x82088338;
		/* 82105ADCh case   19:*/		return 0x82105AE0;
		  /* 82105AE0h */ case   20:  		/* lis R4, 9345 */
		/* 82105AE0h case   20:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105AE0h case   20:*/		return 0x82105AE4;
		  /* 82105AE4h */ case   21:  		/* lwz R3, <#[R31 + 28]> */
		/* 82105AE4h case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 82105AE4h case   21:*/		return 0x82105AE8;
		  /* 82105AE8h */ case   22:  		/* bl -513968 */
		/* 82105AE8h case   22:*/		regs.LR = 0x82105AEC; return 0x82088338;
		/* 82105AE8h case   22:*/		return 0x82105AEC;
		  /* 82105AECh */ case   23:  		/* lis R4, 9345 */
		/* 82105AECh case   23:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105AECh case   23:*/		return 0x82105AF0;
		  /* 82105AF0h */ case   24:  		/* lwz R3, <#[R31 + 32]> */
		/* 82105AF0h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 82105AF0h case   24:*/		return 0x82105AF4;
		  /* 82105AF4h */ case   25:  		/* bl -513980 */
		/* 82105AF4h case   25:*/		regs.LR = 0x82105AF8; return 0x82088338;
		/* 82105AF4h case   25:*/		return 0x82105AF8;
		  /* 82105AF8h */ case   26:  		/* lis R4, 9345 */
		/* 82105AF8h case   26:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105AF8h case   26:*/		return 0x82105AFC;
		  /* 82105AFCh */ case   27:  		/* lwz R3, <#[R31 + 48]> */
		/* 82105AFCh case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82105AFCh case   27:*/		return 0x82105B00;
		  /* 82105B00h */ case   28:  		/* bl -513992 */
		/* 82105B00h case   28:*/		regs.LR = 0x82105B04; return 0x82088338;
		/* 82105B00h case   28:*/		return 0x82105B04;
		  /* 82105B04h */ case   29:  		/* lis R4, 9345 */
		/* 82105B04h case   29:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105B04h case   29:*/		return 0x82105B08;
		  /* 82105B08h */ case   30:  		/* lwz R3, <#[R31 + 52]> */
		/* 82105B08h case   30:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 82105B08h case   30:*/		return 0x82105B0C;
		  /* 82105B0Ch */ case   31:  		/* bl -514004 */
		/* 82105B0Ch case   31:*/		regs.LR = 0x82105B10; return 0x82088338;
		/* 82105B0Ch case   31:*/		return 0x82105B10;
		  /* 82105B10h */ case   32:  		/* lis R4, 9345 */
		/* 82105B10h case   32:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105B10h case   32:*/		return 0x82105B14;
		  /* 82105B14h */ case   33:  		/* lwz R3, <#[R31 + 56]> */
		/* 82105B14h case   33:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 82105B14h case   33:*/		return 0x82105B18;
		  /* 82105B18h */ case   34:  		/* bl -514016 */
		/* 82105B18h case   34:*/		regs.LR = 0x82105B1C; return 0x82088338;
		/* 82105B18h case   34:*/		return 0x82105B1C;
		  /* 82105B1Ch */ case   35:  		/* lis R4, 9345 */
		/* 82105B1Ch case   35:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105B1Ch case   35:*/		return 0x82105B20;
		  /* 82105B20h */ case   36:  		/* lwz R3, <#[R31 + 60]> */
		/* 82105B20h case   36:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 82105B20h case   36:*/		return 0x82105B24;
		  /* 82105B24h */ case   37:  		/* bl -514028 */
		/* 82105B24h case   37:*/		regs.LR = 0x82105B28; return 0x82088338;
		/* 82105B24h case   37:*/		return 0x82105B28;
		  /* 82105B28h */ case   38:  		/* lis R4, 9345 */
		/* 82105B28h case   38:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105B28h case   38:*/		return 0x82105B2C;
		  /* 82105B2Ch */ case   39:  		/* lwz R3, <#[R31 + 64]> */
		/* 82105B2Ch case   39:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000040) );
		/* 82105B2Ch case   39:*/		return 0x82105B30;
		  /* 82105B30h */ case   40:  		/* bl -514040 */
		/* 82105B30h case   40:*/		regs.LR = 0x82105B34; return 0x82088338;
		/* 82105B30h case   40:*/		return 0x82105B34;
		  /* 82105B34h */ case   41:  		/* lis R4, 9345 */
		/* 82105B34h case   41:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105B34h case   41:*/		return 0x82105B38;
		  /* 82105B38h */ case   42:  		/* lwz R3, <#[R31 + 68]> */
		/* 82105B38h case   42:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000044) );
		/* 82105B38h case   42:*/		return 0x82105B3C;
		  /* 82105B3Ch */ case   43:  		/* bl -514052 */
		/* 82105B3Ch case   43:*/		regs.LR = 0x82105B40; return 0x82088338;
		/* 82105B3Ch case   43:*/		return 0x82105B40;
		  /* 82105B40h */ case   44:  		/* lis R4, 9345 */
		/* 82105B40h case   44:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105B40h case   44:*/		return 0x82105B44;
		  /* 82105B44h */ case   45:  		/* lwz R3, <#[R31 + 76]> */
		/* 82105B44h case   45:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000004C) );
		/* 82105B44h case   45:*/		return 0x82105B48;
		  /* 82105B48h */ case   46:  		/* bl -514064 */
		/* 82105B48h case   46:*/		regs.LR = 0x82105B4C; return 0x82088338;
		/* 82105B48h case   46:*/		return 0x82105B4C;
		  /* 82105B4Ch */ case   47:  		/* lis R4, 9345 */
		/* 82105B4Ch case   47:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105B4Ch case   47:*/		return 0x82105B50;
		  /* 82105B50h */ case   48:  		/* lwz R3, <#[R31 + 80]> */
		/* 82105B50h case   48:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000050) );
		/* 82105B50h case   48:*/		return 0x82105B54;
		  /* 82105B54h */ case   49:  		/* bl -514076 */
		/* 82105B54h case   49:*/		regs.LR = 0x82105B58; return 0x82088338;
		/* 82105B54h case   49:*/		return 0x82105B58;
		  /* 82105B58h */ case   50:  		/* lis R4, 9345 */
		/* 82105B58h case   50:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105B58h case   50:*/		return 0x82105B5C;
		  /* 82105B5Ch */ case   51:  		/* lwz R3, <#[R31 + 84]> */
		/* 82105B5Ch case   51:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000054) );
		/* 82105B5Ch case   51:*/		return 0x82105B60;
		  /* 82105B60h */ case   52:  		/* bl -514088 */
		/* 82105B60h case   52:*/		regs.LR = 0x82105B64; return 0x82088338;
		/* 82105B60h case   52:*/		return 0x82105B64;
		  /* 82105B64h */ case   53:  		/* lis R4, 9345 */
		/* 82105B64h case   53:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105B64h case   53:*/		return 0x82105B68;
		  /* 82105B68h */ case   54:  		/* lwz R3, <#[R31 + 88]> */
		/* 82105B68h case   54:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000058) );
		/* 82105B68h case   54:*/		return 0x82105B6C;
		  /* 82105B6Ch */ case   55:  		/* bl -514100 */
		/* 82105B6Ch case   55:*/		regs.LR = 0x82105B70; return 0x82088338;
		/* 82105B6Ch case   55:*/		return 0x82105B70;
		  /* 82105B70h */ case   56:  		/* li R5, 100 */
		/* 82105B70h case   56:*/		cpu::op::li<0>(regs,&regs.R5,0x64);
		/* 82105B70h case   56:*/		return 0x82105B74;
		  /* 82105B74h */ case   57:  		/* li R4, 0 */
		/* 82105B74h case   57:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82105B74h case   57:*/		return 0x82105B78;
		  /* 82105B78h */ case   58:  		/* mr R3, R31 */
		/* 82105B78h case   58:*/		regs.R3 = regs.R31;
		/* 82105B78h case   58:*/		return 0x82105B7C;
		  /* 82105B7Ch */ case   59:  		/* bl -477244 */
		/* 82105B7Ch case   59:*/		regs.LR = 0x82105B80; return 0x82091340;
		/* 82105B7Ch case   59:*/		return 0x82105B80;
		  /* 82105B80h */ case   60:  		/* li R3, 0 */
		/* 82105B80h case   60:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82105B80h case   60:*/		return 0x82105B84;
		  /* 82105B84h */ case   61:  		/* addi R1, R1, 96 */
		/* 82105B84h case   61:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82105B84h case   61:*/		return 0x82105B88;
		  /* 82105B88h */ case   62:  		/* lwz R12, <#[R1 - 8]> */
		/* 82105B88h case   62:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82105B88h case   62:*/		return 0x82105B8C;
		  /* 82105B8Ch */ case   63:  		/* mtspr LR, R12 */
		/* 82105B8Ch case   63:*/		regs.LR = regs.R12;
		/* 82105B8Ch case   63:*/		return 0x82105B90;
		  /* 82105B90h */ case   64:  		/* ld R31, <#[R1 - 16]> */
		/* 82105B90h case   64:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82105B90h case   64:*/		return 0x82105B94;
		  /* 82105B94h */ case   65:  		/* bclr 20, CR0_LT */
		/* 82105B94h case   65:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82105B94h case   65:*/		return 0x82105B98;
	}
	return 0x82105B98;
} // Block from 82105A90h-82105B98h (66 instructions)

//////////////////////////////////////////////////////
// Block at 82105B98h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105B98);
		  /* 82105B98h */ case    0:  		/* mfspr R12, LR */
		/* 82105B98h case    0:*/		regs.R12 = regs.LR;
		/* 82105B98h case    0:*/		return 0x82105B9C;
		  /* 82105B9Ch */ case    1:  		/* bl -477520 */
		/* 82105B9Ch case    1:*/		regs.LR = 0x82105BA0; return 0x8209124C;
		/* 82105B9Ch case    1:*/		return 0x82105BA0;
		  /* 82105BA0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82105BA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82105BA0h case    2:*/		return 0x82105BA4;
		  /* 82105BA4h */ case    3:  		/* lwz R10, <#[R3 + 4]> */
		/* 82105BA4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82105BA4h case    3:*/		return 0x82105BA8;
		  /* 82105BA8h */ case    4:  		/* li R27, 0 */
		/* 82105BA8h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82105BA8h case    4:*/		return 0x82105BAC;
		  /* 82105BACh */ case    5:  		/* mr R31, R3 */
		/* 82105BACh case    5:*/		regs.R31 = regs.R3;
		/* 82105BACh case    5:*/		return 0x82105BB0;
		  /* 82105BB0h */ case    6:  		/* li R25, -1 */
		/* 82105BB0h case    6:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 82105BB0h case    6:*/		return 0x82105BB4;
		  /* 82105BB4h */ case    7:  		/* mr R11, R27 */
		/* 82105BB4h case    7:*/		regs.R11 = regs.R27;
		/* 82105BB4h case    7:*/		return 0x82105BB8;
		  /* 82105BB8h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 82105BB8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82105BB8h case    8:*/		return 0x82105BBC;
		  /* 82105BBCh */ case    9:  		/* bc 4, CR6_GT, 52 */
		/* 82105BBCh case    9:*/		if ( !regs.CR[6].gt ) { return 0x82105BF0;  }
		/* 82105BBCh case    9:*/		return 0x82105BC0;
		  /* 82105BC0h */ case   10:  		/* mr R10, R27 */
		/* 82105BC0h case   10:*/		regs.R10 = regs.R27;
		/* 82105BC0h case   10:*/		return 0x82105BC4;
		  /* 82105BC4h */ case   11:  		/* lwz R9, <#[R31 + 16]> */
		/* 82105BC4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82105BC4h case   11:*/		return 0x82105BC8;
		  /* 82105BC8h */ case   12:  		/* addi R11, R11, 1 */
		/* 82105BC8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82105BC8h case   12:*/		return 0x82105BCC;
		  /* 82105BCCh */ case   13:  		/* lwzx R9, <#[R10 + R9]> */
		/* 82105BCCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82105BCCh case   13:*/		return 0x82105BD0;
		  /* 82105BD0h */ case   14:  		/* addi R10, R10, 4 */
		/* 82105BD0h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82105BD0h case   14:*/		return 0x82105BD4;
		  /* 82105BD4h */ case   15:  		/* stw R25, <#[R9 + 40]> */
		/* 82105BD4h case   15:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R9 + 0x00000028) );
		/* 82105BD4h case   15:*/		return 0x82105BD8;
		  /* 82105BD8h */ case   16:  		/* stw R27, <#[R9 + 44]> */
		/* 82105BD8h case   16:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R9 + 0x0000002C) );
		/* 82105BD8h case   16:*/		return 0x82105BDC;
		  /* 82105BDCh */ case   17:  		/* stw R27, <#[R9 + 48]> */
		/* 82105BDCh case   17:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R9 + 0x00000030) );
		/* 82105BDCh case   17:*/		return 0x82105BE0;
		  /* 82105BE0h */ case   18:  		/* stw R27, <#[R9 + 32]> */
		/* 82105BE0h case   18:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R9 + 0x00000020) );
		/* 82105BE0h case   18:*/		return 0x82105BE4;
		  /* 82105BE4h */ case   19:  		/* lwz R9, <#[R31 + 4]> */
		/* 82105BE4h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82105BE4h case   19:*/		return 0x82105BE8;
		  /* 82105BE8h */ case   20:  		/* cmplw CR6, R11, R9 */
		/* 82105BE8h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82105BE8h case   20:*/		return 0x82105BEC;
		  /* 82105BECh */ case   21:  		/* bc 12, CR6_LT, -40 */
		/* 82105BECh case   21:*/		if ( regs.CR[6].lt ) { return 0x82105BC4;  }
		/* 82105BECh case   21:*/		return 0x82105BF0;
	}
	return 0x82105BF0;
} // Block from 82105B98h-82105BF0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82105BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105BF0);
		  /* 82105BF0h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 82105BF0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82105BF0h case    0:*/		return 0x82105BF4;
		  /* 82105BF4h */ case    1:  		/* mr R11, R27 */
		/* 82105BF4h case    1:*/		regs.R11 = regs.R27;
		/* 82105BF4h case    1:*/		return 0x82105BF8;
		  /* 82105BF8h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 82105BF8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82105BF8h case    2:*/		return 0x82105BFC;
		  /* 82105BFCh */ case    3:  		/* bc 4, CR6_GT, 64 */
		/* 82105BFCh case    3:*/		if ( !regs.CR[6].gt ) { return 0x82105C3C;  }
		/* 82105BFCh case    3:*/		return 0x82105C00;
		  /* 82105C00h */ case    4:  		/* mr R10, R27 */
		/* 82105C00h case    4:*/		regs.R10 = regs.R27;
		/* 82105C00h case    4:*/		return 0x82105C04;
		  /* 82105C04h */ case    5:  		/* lwz R9, <#[R31 + 20]> */
		/* 82105C04h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 82105C04h case    5:*/		return 0x82105C08;
		  /* 82105C08h */ case    6:  		/* lwzx R9, <#[R10 + R9]> */
		/* 82105C08h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82105C08h case    6:*/		return 0x82105C0C;
		  /* 82105C0Ch */ case    7:  		/* addi R10, R10, 4 */
		/* 82105C0Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82105C0Ch case    7:*/		return 0x82105C10;
		  /* 82105C10h */ case    8:  		/* stw R11, <#[R9 + 52]> */
		/* 82105C10h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000034) );
		/* 82105C10h case    8:*/		return 0x82105C14;
		  /* 82105C14h */ case    9:  		/* addi R11, R11, 1 */
		/* 82105C14h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82105C14h case    9:*/		return 0x82105C18;
		  /* 82105C18h */ case   10:  		/* stw R25, <#[R9 + 84]> */
		/* 82105C18h case   10:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R9 + 0x00000054) );
		/* 82105C18h case   10:*/		return 0x82105C1C;
		  /* 82105C1Ch */ case   11:  		/* stw R27, <#[R9 + 88]> */
		/* 82105C1Ch case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R9 + 0x00000058) );
		/* 82105C1Ch case   11:*/		return 0x82105C20;
		  /* 82105C20h */ case   12:  		/* stw R27, <#[R9 + 92]> */
		/* 82105C20h case   12:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R9 + 0x0000005C) );
		/* 82105C20h case   12:*/		return 0x82105C24;
		  /* 82105C24h */ case   13:  		/* stw R25, <#[R9 + 72]> */
		/* 82105C24h case   13:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R9 + 0x00000048) );
		/* 82105C24h case   13:*/		return 0x82105C28;
		  /* 82105C28h */ case   14:  		/* stw R25, <#[R9 + 76]> */
		/* 82105C28h case   14:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R9 + 0x0000004C) );
		/* 82105C28h case   14:*/		return 0x82105C2C;
		  /* 82105C2Ch */ case   15:  		/* stw R25, <#[R9 + 80]> */
		/* 82105C2Ch case   15:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R9 + 0x00000050) );
		/* 82105C2Ch case   15:*/		return 0x82105C30;
		  /* 82105C30h */ case   16:  		/* lwz R9, <#[R31 + 8]> */
		/* 82105C30h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82105C30h case   16:*/		return 0x82105C34;
		  /* 82105C34h */ case   17:  		/* cmplw CR6, R11, R9 */
		/* 82105C34h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82105C34h case   17:*/		return 0x82105C38;
		  /* 82105C38h */ case   18:  		/* bc 12, CR6_LT, -52 */
		/* 82105C38h case   18:*/		if ( regs.CR[6].lt ) { return 0x82105C04;  }
		/* 82105C38h case   18:*/		return 0x82105C3C;
	}
	return 0x82105C3C;
} // Block from 82105BF0h-82105C3Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82105C3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105C3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105C3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105C3C);
		  /* 82105C3Ch */ case    0:  		/* lwz R11, <#[R31 + 220]> */
		/* 82105C3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000DC) );
		/* 82105C3Ch case    0:*/		return 0x82105C40;
		  /* 82105C40h */ case    1:  		/* mr R26, R27 */
		/* 82105C40h case    1:*/		regs.R26 = regs.R27;
		/* 82105C40h case    1:*/		return 0x82105C44;
		  /* 82105C44h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 82105C44h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82105C44h case    2:*/		return 0x82105C48;
		  /* 82105C48h */ case    3:  		/* bc 12, CR6_EQ, 380 */
		/* 82105C48h case    3:*/		if ( regs.CR[6].eq ) { return 0x82105DC4;  }
		/* 82105C48h case    3:*/		return 0x82105C4C;
		  /* 82105C4Ch */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 82105C4Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82105C4Ch case    4:*/		return 0x82105C50;
		  /* 82105C50h */ case    5:  		/* mr R10, R27 */
		/* 82105C50h case    5:*/		regs.R10 = regs.R27;
		/* 82105C50h case    5:*/		return 0x82105C54;
		  /* 82105C54h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82105C54h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82105C54h case    6:*/		return 0x82105C58;
		  /* 82105C58h */ case    7:  		/* bc 4, CR6_GT, 40 */
		/* 82105C58h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82105C80;  }
		/* 82105C58h case    7:*/		return 0x82105C5C;
		  /* 82105C5Ch */ case    8:  		/* mr R11, R27 */
		/* 82105C5Ch case    8:*/		regs.R11 = regs.R27;
		/* 82105C5Ch case    8:*/		return 0x82105C60;
		  /* 82105C60h */ case    9:  		/* lwz R9, <#[R31 + 16]> */
		/* 82105C60h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82105C60h case    9:*/		return 0x82105C64;
		  /* 82105C64h */ case   10:  		/* addi R10, R10, 1 */
		/* 82105C64h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82105C64h case   10:*/		return 0x82105C68;
		  /* 82105C68h */ case   11:  		/* lwzx R9, <#[R11 + R9]> */
		/* 82105C68h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82105C68h case   11:*/		return 0x82105C6C;
		  /* 82105C6Ch */ case   12:  		/* addi R11, R11, 4 */
		/* 82105C6Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82105C6Ch case   12:*/		return 0x82105C70;
		  /* 82105C70h */ case   13:  		/* stw R27, <#[R9 + 16]> */
		/* 82105C70h case   13:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R9 + 0x00000010) );
		/* 82105C70h case   13:*/		return 0x82105C74;
		  /* 82105C74h */ case   14:  		/* lwz R9, <#[R31 + 4]> */
		/* 82105C74h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82105C74h case   14:*/		return 0x82105C78;
		  /* 82105C78h */ case   15:  		/* cmplw CR6, R10, R9 */
		/* 82105C78h case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82105C78h case   15:*/		return 0x82105C7C;
		  /* 82105C7Ch */ case   16:  		/* bc 12, CR6_LT, -28 */
		/* 82105C7Ch case   16:*/		if ( regs.CR[6].lt ) { return 0x82105C60;  }
		/* 82105C7Ch case   16:*/		return 0x82105C80;
	}
	return 0x82105C80;
} // Block from 82105C3Ch-82105C80h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82105C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105C80);
		  /* 82105C80h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82105C80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82105C80h case    0:*/		return 0x82105C84;
		  /* 82105C84h */ case    1:  		/* mr R7, R27 */
		/* 82105C84h case    1:*/		regs.R7 = regs.R27;
		/* 82105C84h case    1:*/		return 0x82105C88;
		  /* 82105C88h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82105C88h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82105C88h case    2:*/		return 0x82105C8C;
		  /* 82105C8Ch */ case    3:  		/* bc 4, CR6_GT, 96 */
		/* 82105C8Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x82105CEC;  }
		/* 82105C8Ch case    3:*/		return 0x82105C90;
	}
	return 0x82105C90;
} // Block from 82105C80h-82105C90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82105C90h
// Function '?VectorizeLeft_UpdateLinks@CProgram@D3DXShader@@AAAJPAVCInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105C90);
		  /* 82105C90h */ case    0:  		/* mr R8, R27 */
		/* 82105C90h case    0:*/		regs.R8 = regs.R27;
		/* 82105C90h case    0:*/		return 0x82105C94;
		  /* 82105C94h */ case    1:  		/* lwz R11, <#[R31 + 20]> */
		/* 82105C94h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82105C94h case    1:*/		return 0x82105C98;
		  /* 82105C98h */ case    2:  		/* lwz R9, <#[R31 + 16]> */
		/* 82105C98h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82105C98h case    2:*/		return 0x82105C9C;
		  /* 82105C9Ch */ case    3:  		/* lwzx R10, <#[R11 + R8]> */
		/* 82105C9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82105C9Ch case    3:*/		return 0x82105CA0;
		  /* 82105CA0h */ case    4:  		/* lwz R11, <#[R10 + 4]> */
		/* 82105CA0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82105CA0h case    4:*/		return 0x82105CA4;
		  /* 82105CA4h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82105CA4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82105CA4h case    5:*/		return 0x82105CA8;
		  /* 82105CA8h */ case    6:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82105CA8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82105CA8h case    6:*/		return 0x82105CAC;
		  /* 82105CACh */ case    7:  		/* lwz R9, <#[R11 + 4]> */
		/* 82105CACh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82105CACh case    7:*/		return 0x82105CB0;
		  /* 82105CB0h */ case    8:  		/* rlwinm. R6, R9, 0, 25, 25 */
		/* 82105CB0h case    8:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R6,regs.R9);
		/* 82105CB0h case    8:*/		return 0x82105CB4;
		  /* 82105CB4h */ case    9:  		/* bc 4, CR0_EQ, 36 */
		/* 82105CB4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82105CD8;  }
		/* 82105CB4h case    9:*/		return 0x82105CB8;
		  /* 82105CB8h */ case   10:  		/* rlwinm. R9, R9, 0, 30, 30 */
		/* 82105CB8h case   10:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R9);
		/* 82105CB8h case   10:*/		return 0x82105CBC;
		  /* 82105CBCh */ case   11:  		/* bc 12, CR0_EQ, 28 */
		/* 82105CBCh case   11:*/		if ( regs.CR[0].eq ) { return 0x82105CD8;  }
		/* 82105CBCh case   11:*/		return 0x82105CC0;
		  /* 82105CC0h */ case   12:  		/* lwz R10, <#[R10 + 12]> */
		/* 82105CC0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 82105CC0h case   12:*/		return 0x82105CC4;
		  /* 82105CC4h */ case   13:  		/* lwz R9, <#[R11 + 16]> */
		/* 82105CC4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 82105CC4h case   13:*/		return 0x82105CC8;
		  /* 82105CC8h */ case   14:  		/* addi R10, R10, 1 */
		/* 82105CC8h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82105CC8h case   14:*/		return 0x82105CCC;
		  /* 82105CCCh */ case   15:  		/* cmplw CR6, R9, R10 */
		/* 82105CCCh case   15:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82105CCCh case   15:*/		return 0x82105CD0;
		  /* 82105CD0h */ case   16:  		/* bc 4, CR6_LT, 8 */
		/* 82105CD0h case   16:*/		if ( !regs.CR[6].lt ) { return 0x82105CD8;  }
		/* 82105CD0h case   16:*/		return 0x82105CD4;
		  /* 82105CD4h */ case   17:  		/* stw R10, <#[R11 + 16]> */
		/* 82105CD4h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82105CD4h case   17:*/		return 0x82105CD8;
	}
	return 0x82105CD8;
} // Block from 82105C90h-82105CD8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82105CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105CD8);
		  /* 82105CD8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82105CD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82105CD8h case    0:*/		return 0x82105CDC;
		  /* 82105CDCh */ case    1:  		/* addi R7, R7, 1 */
		/* 82105CDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82105CDCh case    1:*/		return 0x82105CE0;
		  /* 82105CE0h */ case    2:  		/* addi R8, R8, 4 */
		/* 82105CE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82105CE0h case    2:*/		return 0x82105CE4;
		  /* 82105CE4h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 82105CE4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82105CE4h case    3:*/		return 0x82105CE8;
		  /* 82105CE8h */ case    4:  		/* bc 12, CR6_LT, -84 */
		/* 82105CE8h case    4:*/		if ( regs.CR[6].lt ) { return 0x82105C94;  }
		/* 82105CE8h case    4:*/		return 0x82105CEC;
	}
	return 0x82105CEC;
} // Block from 82105CD8h-82105CECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82105CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105CEC);
		  /* 82105CECh */ case    0:  		/* lwz R8, <#[R31 + 4]> */
		/* 82105CECh case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 82105CECh case    0:*/		return 0x82105CF0;
		  /* 82105CF0h */ case    1:  		/* mr R9, R27 */
		/* 82105CF0h case    1:*/		regs.R9 = regs.R27;
		/* 82105CF0h case    1:*/		return 0x82105CF4;
		  /* 82105CF4h */ case    2:  		/* mr R10, R27 */
		/* 82105CF4h case    2:*/		regs.R10 = regs.R27;
		/* 82105CF4h case    2:*/		return 0x82105CF8;
		  /* 82105CF8h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 82105CF8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82105CF8h case    3:*/		return 0x82105CFC;
		  /* 82105CFCh */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 82105CFCh case    4:*/		if ( regs.CR[6].eq ) { return 0x82105D24;  }
		/* 82105CFCh case    4:*/		return 0x82105D00;
		  /* 82105D00h */ case    5:  		/* lwz R6, <#[R31 + 16]> */
		/* 82105D00h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 82105D00h case    5:*/		return 0x82105D04;
		  /* 82105D04h */ case    6:  		/* mr R11, R27 */
		/* 82105D04h case    6:*/		regs.R11 = regs.R27;
		/* 82105D04h case    6:*/		return 0x82105D08;
		  /* 82105D08h */ case    7:  		/* lwzx R7, <#[R6 + R11]> */
		/* 82105D08h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82105D08h case    7:*/		return 0x82105D0C;
		  /* 82105D0Ch */ case    8:  		/* addi R10, R10, 1 */
		/* 82105D0Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82105D0Ch case    8:*/		return 0x82105D10;
		  /* 82105D10h */ case    9:  		/* addi R11, R11, 4 */
		/* 82105D10h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82105D10h case    9:*/		return 0x82105D14;
		  /* 82105D14h */ case   10:  		/* cmplw CR6, R10, R8 */
		/* 82105D14h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82105D14h case   10:*/		return 0x82105D18;
		  /* 82105D18h */ case   11:  		/* lwz R7, <#[R7 + 16]> */
		/* 82105D18h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000010) );
		/* 82105D18h case   11:*/		return 0x82105D1C;
		  /* 82105D1Ch */ case   12:  		/* add R9, R7, R9 */
		/* 82105D1Ch case   12:*/		cpu::op::add<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 82105D1Ch case   12:*/		return 0x82105D20;
		  /* 82105D20h */ case   13:  		/* bc 12, CR6_LT, -24 */
		/* 82105D20h case   13:*/		if ( regs.CR[6].lt ) { return 0x82105D08;  }
		/* 82105D20h case   13:*/		return 0x82105D24;
	}
	return 0x82105D24;
} // Block from 82105CECh-82105D24h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82105D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105D24);
		  /* 82105D24h */ case    0:  		/* rlwinm R30, R9, 4, 0, 27 */
		/* 82105D24h case    0:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R30,regs.R9);
		/* 82105D24h case    0:*/		return 0x82105D28;
		  /* 82105D28h */ case    1:  		/* lis R4, 9345 */
		/* 82105D28h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82105D28h case    1:*/		return 0x82105D2C;
		  /* 82105D2Ch */ case    2:  		/* mr R3, R30 */
		/* 82105D2Ch case    2:*/		regs.R3 = regs.R30;
		/* 82105D2Ch case    2:*/		return 0x82105D30;
		  /* 82105D30h */ case    3:  		/* bl -514864 */
		/* 82105D30h case    3:*/		regs.LR = 0x82105D34; return 0x82088200;
		/* 82105D30h case    3:*/		return 0x82105D34;
		  /* 82105D34h */ case    4:  		/* or. R26, R3, R3 */
		/* 82105D34h case    4:*/		cpu::op::or<1>(regs,&regs.R26,regs.R3,regs.R3);
		/* 82105D34h case    4:*/		return 0x82105D38;
		  /* 82105D38h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82105D38h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82105D48;  }
		/* 82105D38h case    5:*/		return 0x82105D3C;
		  /* 82105D3Ch */ case    6:  		/* lis R3, -32761 */
		/* 82105D3Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82105D3Ch case    6:*/		return 0x82105D40;
		  /* 82105D40h */ case    7:  		/* ori R3, R3, 14 */
		/* 82105D40h case    7:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82105D40h case    7:*/		return 0x82105D44;
		  /* 82105D44h */ case    8:  		/* b 788 */
		/* 82105D44h case    8:*/		return 0x82106058;
		/* 82105D44h case    8:*/		return 0x82105D48;
	}
	return 0x82105D48;
} // Block from 82105D24h-82105D48h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82105D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105D48);
		  /* 82105D48h */ case    0:  		/* mr R5, R30 */
		/* 82105D48h case    0:*/		regs.R5 = regs.R30;
		/* 82105D48h case    0:*/		return 0x82105D4C;
		  /* 82105D4Ch */ case    1:  		/* li R4, 255 */
		/* 82105D4Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 82105D4Ch case    1:*/		return 0x82105D50;
		  /* 82105D50h */ case    2:  		/* mr R3, R26 */
		/* 82105D50h case    2:*/		regs.R3 = regs.R26;
		/* 82105D50h case    2:*/		return 0x82105D54;
		  /* 82105D54h */ case    3:  		/* bl -477716 */
		/* 82105D54h case    3:*/		regs.LR = 0x82105D58; return 0x82091340;
		/* 82105D54h case    3:*/		return 0x82105D58;
		  /* 82105D58h */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 82105D58h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82105D58h case    4:*/		return 0x82105D5C;
		  /* 82105D5Ch */ case    5:  		/* mr R9, R27 */
		/* 82105D5Ch case    5:*/		regs.R9 = regs.R27;
		/* 82105D5Ch case    5:*/		return 0x82105D60;
		  /* 82105D60h */ case    6:  		/* mr R8, R27 */
		/* 82105D60h case    6:*/		regs.R8 = regs.R27;
		/* 82105D60h case    6:*/		return 0x82105D64;
		  /* 82105D64h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82105D64h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82105D64h case    7:*/		return 0x82105D68;
		  /* 82105D68h */ case    8:  		/* bc 4, CR6_GT, 92 */
		/* 82105D68h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82105DC4;  }
		/* 82105D68h case    8:*/		return 0x82105D6C;
		  /* 82105D6Ch */ case    9:  		/* lwz R10, <#[R31 + 16]> */
		/* 82105D6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82105D6Ch case    9:*/		return 0x82105D70;
		  /* 82105D70h */ case   10:  		/* mr R11, R27 */
		/* 82105D70h case   10:*/		regs.R11 = regs.R27;
		/* 82105D70h case   10:*/		return 0x82105D74;
		  /* 82105D74h */ case   11:  		/* lwz R7, <#[R31 + 16]> */
		/* 82105D74h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 82105D74h case   11:*/		return 0x82105D78;
		  /* 82105D78h */ case   12:  		/* lwzx R7, <#[R7 + R11]> */
		/* 82105D78h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82105D78h case   12:*/		return 0x82105D7C;
		  /* 82105D7Ch */ case   13:  		/* lwz R7, <#[R7 + 16]> */
		/* 82105D7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000010) );
		/* 82105D7Ch case   13:*/		return 0x82105D80;
		  /* 82105D80h */ case   14:  		/* cmplwi CR6, R7, 0 */
		/* 82105D80h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82105D80h case   14:*/		return 0x82105D84;
		  /* 82105D84h */ case   15:  		/* bc 12, CR6_EQ, 16 */
		/* 82105D84h case   15:*/		if ( regs.CR[6].eq ) { return 0x82105D94;  }
		/* 82105D84h case   15:*/		return 0x82105D88;
		  /* 82105D88h */ case   16:  		/* rlwinm R7, R9, 4, 0, 27 */
		/* 82105D88h case   16:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R7,regs.R9);
		/* 82105D88h case   16:*/		return 0x82105D8C;
		  /* 82105D8Ch */ case   17:  		/* add R7, R7, R26 */
		/* 82105D8Ch case   17:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R26);
		/* 82105D8Ch case   17:*/		return 0x82105D90;
		  /* 82105D90h */ case   18:  		/* b 8 */
		/* 82105D90h case   18:*/		return 0x82105D98;
		/* 82105D90h case   18:*/		return 0x82105D94;
	}
	return 0x82105D94;
} // Block from 82105D48h-82105D94h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82105D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105D94);
		  /* 82105D94h */ case    0:  		/* mr R7, R27 */
		/* 82105D94h case    0:*/		regs.R7 = regs.R27;
		/* 82105D94h case    0:*/		return 0x82105D98;
	}
	return 0x82105D98;
} // Block from 82105D94h-82105D98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82105D98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105D98);
		  /* 82105D98h */ case    0:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82105D98h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82105D98h case    0:*/		return 0x82105D9C;
		  /* 82105D9Ch */ case    1:  		/* addi R8, R8, 1 */
		/* 82105D9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82105D9Ch case    1:*/		return 0x82105DA0;
		  /* 82105DA0h */ case    2:  		/* stw R7, <#[R10 + 32]> */
		/* 82105DA0h case    2:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000020) );
		/* 82105DA0h case    2:*/		return 0x82105DA4;
		  /* 82105DA4h */ case    3:  		/* lwz R10, <#[R31 + 4]> */
		/* 82105DA4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82105DA4h case    3:*/		return 0x82105DA8;
		  /* 82105DA8h */ case    4:  		/* cmplw CR6, R8, R10 */
		/* 82105DA8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 82105DA8h case    4:*/		return 0x82105DAC;
		  /* 82105DACh */ case    5:  		/* lwz R10, <#[R31 + 16]> */
		/* 82105DACh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82105DACh case    5:*/		return 0x82105DB0;
		  /* 82105DB0h */ case    6:  		/* lwzx R7, <#[R10 + R11]> */
		/* 82105DB0h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82105DB0h case    6:*/		return 0x82105DB4;
		  /* 82105DB4h */ case    7:  		/* addi R11, R11, 4 */
		/* 82105DB4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82105DB4h case    7:*/		return 0x82105DB8;
		  /* 82105DB8h */ case    8:  		/* lwz R7, <#[R7 + 16]> */
		/* 82105DB8h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000010) );
		/* 82105DB8h case    8:*/		return 0x82105DBC;
		  /* 82105DBCh */ case    9:  		/* add R9, R7, R9 */
		/* 82105DBCh case    9:*/		cpu::op::add<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 82105DBCh case    9:*/		return 0x82105DC0;
		  /* 82105DC0h */ case   10:  		/* bc 12, CR6_LT, -76 */
		/* 82105DC0h case   10:*/		if ( regs.CR[6].lt ) { return 0x82105D74;  }
		/* 82105DC0h case   10:*/		return 0x82105DC4;
	}
	return 0x82105DC4;
} // Block from 82105D98h-82105DC4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82105DC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105DC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105DC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105DC4);
		  /* 82105DC4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82105DC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82105DC4h case    0:*/		return 0x82105DC8;
		  /* 82105DC8h */ case    1:  		/* mr R5, R27 */
		/* 82105DC8h case    1:*/		regs.R5 = regs.R27;
		/* 82105DC8h case    1:*/		return 0x82105DCC;
		  /* 82105DCCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82105DCCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82105DCCh case    2:*/		return 0x82105DD0;
		  /* 82105DD0h */ case    3:  		/* bc 4, CR6_GT, 340 */
		/* 82105DD0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82105F24;  }
		/* 82105DD0h case    3:*/		return 0x82105DD4;
		  /* 82105DD4h */ case    4:  		/* mr R28, R27 */
		/* 82105DD4h case    4:*/		regs.R28 = regs.R27;
		/* 82105DD4h case    4:*/		return 0x82105DD8;
		  /* 82105DD8h */ case    5:  		/* lwz R11, <#[R31 + 24]> */
		/* 82105DD8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82105DD8h case    5:*/		return 0x82105DDC;
		  /* 82105DDCh */ case    6:  		/* lwzx R6, <#[R11 + R28]> */
		/* 82105DDCh case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82105DDCh case    6:*/		return 0x82105DE0;
		  /* 82105DE0h */ case    7:  		/* cmplwi CR6, R6, 0 */
		/* 82105DE0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82105DE0h case    7:*/		return 0x82105DE4;
		  /* 82105DE4h */ case    8:  		/* bc 12, CR6_EQ, 300 */
		/* 82105DE4h case    8:*/		if ( regs.CR[6].eq ) { return 0x82105F10;  }
		/* 82105DE4h case    8:*/		return 0x82105DE8;
		  /* 82105DE8h */ case    9:  		/* lwz R11, <#[R6]> */
		/* 82105DE8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 82105DE8h case    9:*/		return 0x82105DEC;
		  /* 82105DECh */ case   10:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 82105DECh case   10:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82105DECh case   10:*/		return 0x82105DF0;
		  /* 82105DF0h */ case   11:  		/* bc 12, CR0_EQ, 288 */
		/* 82105DF0h case   11:*/		if ( regs.CR[0].eq ) { return 0x82105F10;  }
		/* 82105DF0h case   11:*/		return 0x82105DF4;
		  /* 82105DF4h */ case   12:  		/* lwz R11, <#[R6 + 4]> */
		/* 82105DF4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 82105DF4h case   12:*/		return 0x82105DF8;
		  /* 82105DF8h */ case   13:  		/* mr R30, R27 */
		/* 82105DF8h case   13:*/		regs.R30 = regs.R27;
		/* 82105DF8h case   13:*/		return 0x82105DFC;
		  /* 82105DFCh */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82105DFCh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82105DFCh case   14:*/		return 0x82105E00;
	}
	return 0x82105E00;
} // Block from 82105DC4h-82105E00h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82105E00h
// Function '?PropagateMovs@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105E00);
		  /* 82105E00h */ case    0:  		/* bc 4, CR6_GT, 44 */
		/* 82105E00h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82105E2C;  }
		/* 82105E00h case    0:*/		return 0x82105E04;
		  /* 82105E04h */ case    1:  		/* mr R7, R27 */
		/* 82105E04h case    1:*/		regs.R7 = regs.R27;
		/* 82105E04h case    1:*/		return 0x82105E08;
		  /* 82105E08h */ case    2:  		/* lwz R11, <#[R6 + 8]> */
		/* 82105E08h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 82105E08h case    2:*/		return 0x82105E0C;
		  /* 82105E0Ch */ case    3:  		/* mr R3, R31 */
		/* 82105E0Ch case    3:*/		regs.R3 = regs.R31;
		/* 82105E0Ch case    3:*/		return 0x82105E10;
		  /* 82105E10h */ case    4:  		/* lwzx R4, <#[R11 + R7]> */
		/* 82105E10h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82105E10h case    4:*/		return 0x82105E14;
		  /* 82105E14h */ case    5:  		/* bl -19428 */
		/* 82105E14h case    5:*/		regs.LR = 0x82105E18; return 0x82101230;
		/* 82105E14h case    5:*/		return 0x82105E18;
		  /* 82105E18h */ case    6:  		/* lwz R11, <#[R6 + 4]> */
		/* 82105E18h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 82105E18h case    6:*/		return 0x82105E1C;
		  /* 82105E1Ch */ case    7:  		/* addi R30, R30, 1 */
		/* 82105E1Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82105E1Ch case    7:*/		return 0x82105E20;
		  /* 82105E20h */ case    8:  		/* addi R7, R7, 4 */
		/* 82105E20h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82105E20h case    8:*/		return 0x82105E24;
		  /* 82105E24h */ case    9:  		/* cmplw CR6, R30, R11 */
		/* 82105E24h case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82105E24h case    9:*/		return 0x82105E28;
		  /* 82105E28h */ case   10:  		/* bc 12, CR6_LT, -32 */
		/* 82105E28h case   10:*/		if ( regs.CR[6].lt ) { return 0x82105E08;  }
		/* 82105E28h case   10:*/		return 0x82105E2C;
	}
	return 0x82105E2C;
} // Block from 82105E00h-82105E2Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82105E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105E2C);
		  /* 82105E2Ch */ case    0:  		/* lwz R11, <#[R6 + 12]> */
		/* 82105E2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x0000000C) );
		/* 82105E2Ch case    0:*/		return 0x82105E30;
		  /* 82105E30h */ case    1:  		/* mr R30, R27 */
		/* 82105E30h case    1:*/		regs.R30 = regs.R27;
		/* 82105E30h case    1:*/		return 0x82105E34;
		  /* 82105E34h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82105E34h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82105E34h case    2:*/		return 0x82105E38;
		  /* 82105E38h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 82105E38h case    3:*/		if ( regs.CR[6].eq ) { return 0x82105E64;  }
		/* 82105E38h case    3:*/		return 0x82105E3C;
		  /* 82105E3Ch */ case    4:  		/* mr R29, R27 */
		/* 82105E3Ch case    4:*/		regs.R29 = regs.R27;
		/* 82105E3Ch case    4:*/		return 0x82105E40;
		  /* 82105E40h */ case    5:  		/* lwz R11, <#[R6 + 16]> */
		/* 82105E40h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000010) );
		/* 82105E40h case    5:*/		return 0x82105E44;
		  /* 82105E44h */ case    6:  		/* mr R3, R31 */
		/* 82105E44h case    6:*/		regs.R3 = regs.R31;
		/* 82105E44h case    6:*/		return 0x82105E48;
		  /* 82105E48h */ case    7:  		/* lwzx R4, <#[R29 + R11]> */
		/* 82105E48h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82105E48h case    7:*/		return 0x82105E4C;
		  /* 82105E4Ch */ case    8:  		/* bl -19324 */
		/* 82105E4Ch case    8:*/		regs.LR = 0x82105E50; return 0x821012D0;
		/* 82105E4Ch case    8:*/		return 0x82105E50;
		  /* 82105E50h */ case    9:  		/* lwz R11, <#[R6 + 12]> */
		/* 82105E50h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x0000000C) );
		/* 82105E50h case    9:*/		return 0x82105E54;
		  /* 82105E54h */ case   10:  		/* addi R30, R30, 1 */
		/* 82105E54h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82105E54h case   10:*/		return 0x82105E58;
		  /* 82105E58h */ case   11:  		/* addi R29, R29, 4 */
		/* 82105E58h case   11:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82105E58h case   11:*/		return 0x82105E5C;
		  /* 82105E5Ch */ case   12:  		/* cmplw CR6, R30, R11 */
		/* 82105E5Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82105E5Ch case   12:*/		return 0x82105E60;
		  /* 82105E60h */ case   13:  		/* bc 12, CR6_LT, -32 */
		/* 82105E60h case   13:*/		if ( regs.CR[6].lt ) { return 0x82105E40;  }
		/* 82105E60h case   13:*/		return 0x82105E64;
	}
	return 0x82105E64;
} // Block from 82105E2Ch-82105E64h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82105E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105E64);
		  /* 82105E64h */ case    0:  		/* lwz R10, <#[R6]> */
		/* 82105E64h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 82105E64h case    0:*/		return 0x82105E68;
		  /* 82105E68h */ case    1:  		/* lis R9, 4096 */
		/* 82105E68h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 82105E68h case    1:*/		return 0x82105E6C;
		  /* 82105E6Ch */ case    2:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 82105E6Ch case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 82105E6Ch case    2:*/		return 0x82105E70;
		  /* 82105E70h */ case    3:  		/* cmplw CR6, R10, R9 */
		/* 82105E70h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82105E70h case    3:*/		return 0x82105E74;
		  /* 82105E74h */ case    4:  		/* bc 4, CR6_EQ, 156 */
		/* 82105E74h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82105F10;  }
		/* 82105E74h case    4:*/		return 0x82105E78;
		  /* 82105E78h */ case    5:  		/* lwz R10, <#[R31 + 204]> */
		/* 82105E78h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000CC) );
		/* 82105E78h case    5:*/		return 0x82105E7C;
		  /* 82105E7Ch */ case    6:  		/* rlwinm. R10, R10, 0, 29, 29 */
		/* 82105E7Ch case    6:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R10);
		/* 82105E7Ch case    6:*/		return 0x82105E80;
		  /* 82105E80h */ case    7:  		/* bc 4, CR0_EQ, 144 */
		/* 82105E80h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82105F10;  }
		/* 82105E80h case    7:*/		return 0x82105E84;
		  /* 82105E84h */ case    8:  		/* mr R7, R27 */
		/* 82105E84h case    8:*/		regs.R7 = regs.R27;
		/* 82105E84h case    8:*/		return 0x82105E88;
		  /* 82105E88h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82105E88h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82105E88h case    9:*/		return 0x82105E8C;
		  /* 82105E8Ch */ case   10:  		/* bc 12, CR6_EQ, 132 */
		/* 82105E8Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82105F10;  }
		/* 82105E8Ch case   10:*/		return 0x82105E90;
		  /* 82105E90h */ case   11:  		/* mr R11, R27 */
		/* 82105E90h case   11:*/		regs.R11 = regs.R27;
		/* 82105E90h case   11:*/		return 0x82105E94;
		  /* 82105E94h */ case   12:  		/* lwz R10, <#[R6 + 16]> */
		/* 82105E94h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000010) );
		/* 82105E94h case   12:*/		return 0x82105E98;
		  /* 82105E98h */ case   13:  		/* lwz R8, <#[R6 + 8]> */
		/* 82105E98h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000008) );
		/* 82105E98h case   13:*/		return 0x82105E9C;
		  /* 82105E9Ch */ case   14:  		/* lwz R9, <#[R31 + 20]> */
		/* 82105E9Ch case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 82105E9Ch case   14:*/		return 0x82105EA0;
		  /* 82105EA0h */ case   15:  		/* lwz R4, <#[R31 + 16]> */
		/* 82105EA0h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 82105EA0h case   15:*/		return 0x82105EA4;
		  /* 82105EA4h */ case   16:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82105EA4h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82105EA4h case   16:*/		return 0x82105EA8;
		  /* 82105EA8h */ case   17:  		/* lwzx R8, <#[R8 + R11]> */
		/* 82105EA8h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82105EA8h case   17:*/		return 0x82105EAC;
		  /* 82105EACh */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82105EACh case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82105EACh case   18:*/		return 0x82105EB0;
		  /* 82105EB0h */ case   19:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82105EB0h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82105EB0h case   19:*/		return 0x82105EB4;
		  /* 82105EB4h */ case   20:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82105EB4h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82105EB4h case   20:*/		return 0x82105EB8;
		  /* 82105EB8h */ case   21:  		/* lwzx R8, <#[R8 + R9]> */
		/* 82105EB8h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82105EB8h case   21:*/		return 0x82105EBC;
		  /* 82105EBCh */ case   22:  		/* lwz R9, <#[R10 + 4]> */
		/* 82105EBCh case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82105EBCh case   22:*/		return 0x82105EC0;
		  /* 82105EC0h */ case   23:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82105EC0h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82105EC0h case   23:*/		return 0x82105EC4;
		  /* 82105EC4h */ case   24:  		/* lwzx R9, <#[R9 + R4]> */
		/* 82105EC4h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R4 + 0x00000000) );
		/* 82105EC4h case   24:*/		return 0x82105EC8;
		  /* 82105EC8h */ case   25:  		/* lwz R9, <#[R9 + 4]> */
		/* 82105EC8h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82105EC8h case   25:*/		return 0x82105ECC;
		  /* 82105ECCh */ case   26:  		/* andi. R4, R9, 4128 */
		/* 82105ECCh case   26:*/		cpu::op::andi<1>(regs,&regs.R4,regs.R9,0x1020);
		/* 82105ECCh case   26:*/		return 0x82105ED0;
		  /* 82105ED0h */ case   27:  		/* cmplwi CR0, R4, 0 */
		/* 82105ED0h case   27:*/		cpu::op::cmplwi<0>(regs,regs.R4,0x00000000);
		/* 82105ED0h case   27:*/		return 0x82105ED4;
		  /* 82105ED4h */ case   28:  		/* bc 4, CR0_EQ, 40 */
		/* 82105ED4h case   28:*/		if ( !regs.CR[0].eq ) { return 0x82105EFC;  }
		/* 82105ED4h case   28:*/		return 0x82105ED8;
		  /* 82105ED8h */ case   29:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82105ED8h case   29:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82105ED8h case   29:*/		return 0x82105EDC;
		  /* 82105EDCh */ case   30:  		/* bc 12, CR0_EQ, 32 */
		/* 82105EDCh case   30:*/		if ( regs.CR[0].eq ) { return 0x82105EFC;  }
		/* 82105EDCh case   30:*/		return 0x82105EE0;
		  /* 82105EE0h */ case   31:  		/* lwz R9, <#[R8 + 60]> */
		/* 82105EE0h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x0000003C) );
		/* 82105EE0h case   31:*/		return 0x82105EE4;
		  /* 82105EE4h */ case   32:  		/* cmplwi CR6, R9, 0 */
		/* 82105EE4h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82105EE4h case   32:*/		return 0x82105EE8;
		  /* 82105EE8h */ case   33:  		/* bc 4, CR6_EQ, 20 */
		/* 82105EE8h case   33:*/		if ( !regs.CR[6].eq ) { return 0x82105EFC;  }
		/* 82105EE8h case   33:*/		return 0x82105EEC;
		  /* 82105EECh */ case   34:  		/* lwz R9, <#[R8 + 52]> */
		/* 82105EECh case   34:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000034) );
		/* 82105EECh case   34:*/		return 0x82105EF0;
		  /* 82105EF0h */ case   35:  		/* lwz R4, <#[R10 + 52]> */
		/* 82105EF0h case   35:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000034) );
		/* 82105EF0h case   35:*/		return 0x82105EF4;
		  /* 82105EF4h */ case   36:  		/* stw R9, <#[R10 + 52]> */
		/* 82105EF4h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000034) );
		/* 82105EF4h case   36:*/		return 0x82105EF8;
		  /* 82105EF8h */ case   37:  		/* stw R4, <#[R8 + 52]> */
		/* 82105EF8h case   37:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R8 + 0x00000034) );
		/* 82105EF8h case   37:*/		return 0x82105EFC;
	}
	return 0x82105EFC;
} // Block from 82105E64h-82105EFCh (38 instructions)

//////////////////////////////////////////////////////
// Block at 82105EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105EFC);
		  /* 82105EFCh */ case    0:  		/* lwz R10, <#[R6 + 12]> */
		/* 82105EFCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x0000000C) );
		/* 82105EFCh case    0:*/		return 0x82105F00;
		  /* 82105F00h */ case    1:  		/* addi R7, R7, 1 */
		/* 82105F00h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82105F00h case    1:*/		return 0x82105F04;
		  /* 82105F04h */ case    2:  		/* addi R11, R11, 4 */
		/* 82105F04h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82105F04h case    2:*/		return 0x82105F08;
		  /* 82105F08h */ case    3:  		/* cmplw CR6, R7, R10 */
		/* 82105F08h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 82105F08h case    3:*/		return 0x82105F0C;
		  /* 82105F0Ch */ case    4:  		/* bc 12, CR6_LT, -120 */
		/* 82105F0Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82105E94;  }
		/* 82105F0Ch case    4:*/		return 0x82105F10;
	}
	return 0x82105F10;
} // Block from 82105EFCh-82105F10h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82105F10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105F10);
		  /* 82105F10h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82105F10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82105F10h case    0:*/		return 0x82105F14;
		  /* 82105F14h */ case    1:  		/* addi R5, R5, 1 */
		/* 82105F14h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82105F14h case    1:*/		return 0x82105F18;
		  /* 82105F18h */ case    2:  		/* addi R28, R28, 4 */
		/* 82105F18h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82105F18h case    2:*/		return 0x82105F1C;
		  /* 82105F1Ch */ case    3:  		/* cmplw CR6, R5, R11 */
		/* 82105F1Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 82105F1Ch case    3:*/		return 0x82105F20;
		  /* 82105F20h */ case    4:  		/* bc 12, CR6_LT, -328 */
		/* 82105F20h case    4:*/		if ( regs.CR[6].lt ) { return 0x82105DD8;  }
		/* 82105F20h case    4:*/		return 0x82105F24;
	}
	return 0x82105F24;
} // Block from 82105F10h-82105F24h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82105F24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105F24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105F24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105F24);
		  /* 82105F24h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82105F24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82105F24h case    0:*/		return 0x82105F28;
		  /* 82105F28h */ case    1:  		/* mr R7, R27 */
		/* 82105F28h case    1:*/		regs.R7 = regs.R27;
		/* 82105F28h case    1:*/		return 0x82105F2C;
		  /* 82105F2Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82105F2Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82105F2Ch case    2:*/		return 0x82105F30;
		  /* 82105F30h */ case    3:  		/* bc 12, CR6_EQ, 92 */
		/* 82105F30h case    3:*/		if ( regs.CR[6].eq ) { return 0x82105F8C;  }
		/* 82105F30h case    3:*/		return 0x82105F34;
		  /* 82105F34h */ case    4:  		/* mr R8, R27 */
		/* 82105F34h case    4:*/		regs.R8 = regs.R27;
		/* 82105F34h case    4:*/		return 0x82105F38;
		  /* 82105F38h */ case    5:  		/* lwz R11, <#[R31 + 20]> */
		/* 82105F38h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82105F38h case    5:*/		return 0x82105F3C;
		  /* 82105F3Ch */ case    6:  		/* lwz R10, <#[R31 + 16]> */
		/* 82105F3Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82105F3Ch case    6:*/		return 0x82105F40;
		  /* 82105F40h */ case    7:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82105F40h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82105F40h case    7:*/		return 0x82105F44;
		  /* 82105F44h */ case    8:  		/* lwz R9, <#[R11 + 4]> */
		/* 82105F44h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82105F44h case    8:*/		return 0x82105F48;
		  /* 82105F48h */ case    9:  		/* lwz R6, <#[R11 + 84]> */
		/* 82105F48h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000054) );
		/* 82105F48h case    9:*/		return 0x82105F4C;
		  /* 82105F4Ch */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82105F4Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82105F4Ch case   10:*/		return 0x82105F50;
		  /* 82105F50h */ case   11:  		/* lwzx R9, <#[R9 + R10]> */
		/* 82105F50h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82105F50h case   11:*/		return 0x82105F54;
		  /* 82105F54h */ case   12:  		/* lwz R10, <#[R9 + 40]> */
		/* 82105F54h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000028) );
		/* 82105F54h case   12:*/		return 0x82105F58;
		  /* 82105F58h */ case   13:  		/* cmplw CR6, R6, R10 */
		/* 82105F58h case   13:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82105F58h case   13:*/		return 0x82105F5C;
		  /* 82105F5Ch */ case   14:  		/* bc 4, CR6_GT, 8 */
		/* 82105F5Ch case   14:*/		if ( !regs.CR[6].gt ) { return 0x82105F64;  }
		/* 82105F5Ch case   14:*/		return 0x82105F60;
		  /* 82105F60h */ case   15:  		/* stw R10, <#[R11 + 84]> */
		/* 82105F60h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000054) );
		/* 82105F60h case   15:*/		return 0x82105F64;
	}
	return 0x82105F64;
} // Block from 82105F24h-82105F64h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82105F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105F64);
		  /* 82105F64h */ case    0:  		/* lwz R10, <#[R9 + 44]> */
		/* 82105F64h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000002C) );
		/* 82105F64h case    0:*/		return 0x82105F68;
		  /* 82105F68h */ case    1:  		/* lwz R9, <#[R11 + 88]> */
		/* 82105F68h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000058) );
		/* 82105F68h case    1:*/		return 0x82105F6C;
		  /* 82105F6Ch */ case    2:  		/* cmplw CR6, R9, R10 */
		/* 82105F6Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82105F6Ch case    2:*/		return 0x82105F70;
		  /* 82105F70h */ case    3:  		/* bc 4, CR6_LT, 8 */
		/* 82105F70h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82105F78;  }
		/* 82105F70h case    3:*/		return 0x82105F74;
		  /* 82105F74h */ case    4:  		/* stw R10, <#[R11 + 88]> */
		/* 82105F74h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000058) );
		/* 82105F74h case    4:*/		return 0x82105F78;
	}
	return 0x82105F78;
} // Block from 82105F64h-82105F78h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82105F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105F78);
		  /* 82105F78h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82105F78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82105F78h case    0:*/		return 0x82105F7C;
		  /* 82105F7Ch */ case    1:  		/* addi R7, R7, 1 */
		/* 82105F7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82105F7Ch case    1:*/		return 0x82105F80;
		  /* 82105F80h */ case    2:  		/* addi R8, R8, 4 */
		/* 82105F80h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82105F80h case    2:*/		return 0x82105F84;
		  /* 82105F84h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 82105F84h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82105F84h case    3:*/		return 0x82105F88;
		  /* 82105F88h */ case    4:  		/* bc 12, CR6_LT, -80 */
		/* 82105F88h case    4:*/		if ( regs.CR[6].lt ) { return 0x82105F38;  }
		/* 82105F88h case    4:*/		return 0x82105F8C;
	}
	return 0x82105F8C;
} // Block from 82105F78h-82105F8Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82105F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105F8C);
		  /* 82105F8Ch */ case    0:  		/* lwz R10, <#[R31 + 220]> */
		/* 82105F8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000DC) );
		/* 82105F8Ch case    0:*/		return 0x82105F90;
		  /* 82105F90h */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 82105F90h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82105F90h case    1:*/		return 0x82105F94;
		  /* 82105F94h */ case    2:  		/* bc 12, CR6_EQ, 160 */
		/* 82105F94h case    2:*/		if ( regs.CR[6].eq ) { return 0x82106034;  }
		/* 82105F94h case    2:*/		return 0x82105F98;
		  /* 82105F98h */ case    3:  		/* mr R7, R27 */
		/* 82105F98h case    3:*/		regs.R7 = regs.R27;
		/* 82105F98h case    3:*/		return 0x82105F9C;
		  /* 82105F9Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82105F9Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82105F9Ch case    4:*/		return 0x82105FA0;
		  /* 82105FA0h */ case    5:  		/* bc 12, CR6_EQ, 148 */
		/* 82105FA0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82106034;  }
		/* 82105FA0h case    5:*/		return 0x82105FA4;
		  /* 82105FA4h */ case    6:  		/* mr R8, R27 */
		/* 82105FA4h case    6:*/		regs.R8 = regs.R27;
		/* 82105FA4h case    6:*/		return 0x82105FA8;
		  /* 82105FA8h */ case    7:  		/* lwz R10, <#[R31 + 20]> */
		/* 82105FA8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82105FA8h case    7:*/		return 0x82105FAC;
		  /* 82105FACh */ case    8:  		/* lwzx R11, <#[R10 + R8]> */
		/* 82105FACh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82105FACh case    8:*/		return 0x82105FB0;
		  /* 82105FB0h */ case    9:  		/* lwz R9, <#[R11 + 76]> */
		/* 82105FB0h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000004C) );
		/* 82105FB0h case    9:*/		return 0x82105FB4;
		  /* 82105FB4h */ case   10:  		/* cmpwi CR6, R9, -1 */
		/* 82105FB4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82105FB4h case   10:*/		return 0x82105FB8;
		  /* 82105FB8h */ case   11:  		/* bc 12, CR6_EQ, 44 */
		/* 82105FB8h case   11:*/		if ( regs.CR[6].eq ) { return 0x82105FE4;  }
		/* 82105FB8h case   11:*/		return 0x82105FBC;
		  /* 82105FBCh */ case   12:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82105FBCh case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82105FBCh case   12:*/		return 0x82105FC0;
		  /* 82105FC0h */ case   13:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82105FC0h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82105FC0h case   13:*/		return 0x82105FC4;
		  /* 82105FC4h */ case   14:  		/* lwz R9, <#[R10 + 88]> */
		/* 82105FC4h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000058) );
		/* 82105FC4h case   14:*/		return 0x82105FC8;
		  /* 82105FC8h */ case   15:  		/* stw R9, <#[R11 + 76]> */
		/* 82105FC8h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000004C) );
		/* 82105FC8h case   15:*/		return 0x82105FCC;
		  /* 82105FCCh */ case   16:  		/* lwz R10, <#[R10 + 72]> */
		/* 82105FCCh case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 82105FCCh case   16:*/		return 0x82105FD0;
		  /* 82105FD0h */ case   17:  		/* cmplw CR6, R9, R10 */
		/* 82105FD0h case   17:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82105FD0h case   17:*/		return 0x82105FD4;
		  /* 82105FD4h */ case   18:  		/* bc 12, CR6_GT, 20 */
		/* 82105FD4h case   18:*/		if ( regs.CR[6].gt ) { return 0x82105FE8;  }
		/* 82105FD4h case   18:*/		return 0x82105FD8;
		  /* 82105FD8h */ case   19:  		/* addi R10, R10, 1 */
		/* 82105FD8h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82105FD8h case   19:*/		return 0x82105FDC;
		  /* 82105FDCh */ case   20:  		/* stw R10, <#[R11 + 76]> */
		/* 82105FDCh case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 82105FDCh case   20:*/		return 0x82105FE0;
		  /* 82105FE0h */ case   21:  		/* b 8 */
		/* 82105FE0h case   21:*/		return 0x82105FE8;
		/* 82105FE0h case   21:*/		return 0x82105FE4;
	}
	return 0x82105FE4;
} // Block from 82105F8Ch-82105FE4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82105FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105FE4);
		  /* 82105FE4h */ case    0:  		/* stw R27, <#[R11 + 76]> */
		/* 82105FE4h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x0000004C) );
		/* 82105FE4h case    0:*/		return 0x82105FE8;
	}
	return 0x82105FE8;
} // Block from 82105FE4h-82105FE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82105FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82105FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82105FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82105FE8);
		  /* 82105FE8h */ case    0:  		/* lwz R10, <#[R11 + 80]> */
		/* 82105FE8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 82105FE8h case    0:*/		return 0x82105FEC;
		  /* 82105FECh */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 82105FECh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82105FECh case    1:*/		return 0x82105FF0;
		  /* 82105FF0h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 82105FF0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210601C;  }
		/* 82105FF0h case    2:*/		return 0x82105FF4;
		  /* 82105FF4h */ case    3:  		/* lwz R9, <#[R31 + 20]> */
		/* 82105FF4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 82105FF4h case    3:*/		return 0x82105FF8;
		  /* 82105FF8h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82105FF8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82105FF8h case    4:*/		return 0x82105FFC;
		  /* 82105FFCh */ case    5:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82105FFCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82105FFCh case    5:*/		return 0x82106000;
		  /* 82106000h */ case    6:  		/* lwz R9, <#[R10 + 84]> */
		/* 82106000h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000054) );
		/* 82106000h case    6:*/		return 0x82106004;
		  /* 82106004h */ case    7:  		/* stw R9, <#[R11 + 80]> */
		/* 82106004h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000050) );
		/* 82106004h case    7:*/		return 0x82106008;
		  /* 82106008h */ case    8:  		/* lwz R10, <#[R10 + 72]> */
		/* 82106008h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 82106008h case    8:*/		return 0x8210600C;
		  /* 8210600Ch */ case    9:  		/* cmplw CR6, R9, R10 */
		/* 8210600Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8210600Ch case    9:*/		return 0x82106010;
		  /* 82106010h */ case   10:  		/* bc 4, CR6_GT, 16 */
		/* 82106010h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82106020;  }
		/* 82106010h case   10:*/		return 0x82106014;
		  /* 82106014h */ case   11:  		/* stw R10, <#[R11 + 80]> */
		/* 82106014h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 82106014h case   11:*/		return 0x82106018;
		  /* 82106018h */ case   12:  		/* b 8 */
		/* 82106018h case   12:*/		return 0x82106020;
		/* 82106018h case   12:*/		return 0x8210601C;
	}
	return 0x8210601C;
} // Block from 82105FE8h-8210601Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8210601Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210601C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210601C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210601C);
		  /* 8210601Ch */ case    0:  		/* stw R25, <#[R11 + 80]> */
		/* 8210601Ch case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000050) );
		/* 8210601Ch case    0:*/		return 0x82106020;
	}
	return 0x82106020;
} // Block from 8210601Ch-82106020h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82106020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106020);
		  /* 82106020h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82106020h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82106020h case    0:*/		return 0x82106024;
		  /* 82106024h */ case    1:  		/* addi R7, R7, 1 */
		/* 82106024h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82106024h case    1:*/		return 0x82106028;
		  /* 82106028h */ case    2:  		/* addi R8, R8, 4 */
		/* 82106028h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82106028h case    2:*/		return 0x8210602C;
		  /* 8210602Ch */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 8210602Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 8210602Ch case    3:*/		return 0x82106030;
		  /* 82106030h */ case    4:  		/* bc 12, CR6_LT, -136 */
		/* 82106030h case    4:*/		if ( regs.CR[6].lt ) { return 0x82105FA8;  }
		/* 82106030h case    4:*/		return 0x82106034;
	}
	return 0x82106034;
} // Block from 82106020h-82106034h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82106034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106034);
		  /* 82106034h */ case    0:  		/* lwz R11, <#[R31 + 216]> */
		/* 82106034h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000D8) );
		/* 82106034h case    0:*/		return 0x82106038;
		  /* 82106038h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82106038h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82106038h case    1:*/		return 0x8210603C;
		  /* 8210603Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8210603Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82106048;  }
		/* 8210603Ch case    2:*/		return 0x82106040;
		  /* 82106040h */ case    3:  		/* mr R3, R31 */
		/* 82106040h case    3:*/		regs.R3 = regs.R31;
		/* 82106040h case    3:*/		return 0x82106044;
		  /* 82106044h */ case    4:  		/* bl -19700 */
		/* 82106044h case    4:*/		regs.LR = 0x82106048; return 0x82101350;
		/* 82106044h case    4:*/		return 0x82106048;
	}
	return 0x82106048;
} // Block from 82106034h-82106048h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82106048h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106048);
		  /* 82106048h */ case    0:  		/* lis R4, 9345 */
		/* 82106048h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82106048h case    0:*/		return 0x8210604C;
		  /* 8210604Ch */ case    1:  		/* mr R3, R26 */
		/* 8210604Ch case    1:*/		regs.R3 = regs.R26;
		/* 8210604Ch case    1:*/		return 0x82106050;
		  /* 82106050h */ case    2:  		/* bl -515352 */
		/* 82106050h case    2:*/		regs.LR = 0x82106054; return 0x82088338;
		/* 82106050h case    2:*/		return 0x82106054;
		  /* 82106054h */ case    3:  		/* li R3, 0 */
		/* 82106054h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82106054h case    3:*/		return 0x82106058;
	}
	return 0x82106058;
} // Block from 82106048h-82106058h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82106058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106058);
		  /* 82106058h */ case    0:  		/* addi R1, R1, 144 */
		/* 82106058h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82106058h case    0:*/		return 0x8210605C;
		  /* 8210605Ch */ case    1:  		/* b -478656 */
		/* 8210605Ch case    1:*/		return 0x8209129C;
		/* 8210605Ch case    1:*/		return 0x82106060;
	}
	return 0x82106060;
} // Block from 82106058h-82106060h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82106060h
// Function '?CompactPool_Score@CProgram@D3DXShader@@AAAIPAU_D3DXCP_DATA@2@IIHPAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106060);
		  /* 82106060h */ case    0:  		/* mfspr R12, LR */
		/* 82106060h case    0:*/		regs.R12 = regs.LR;
		/* 82106060h case    0:*/		return 0x82106064;
		  /* 82106064h */ case    1:  		/* bl -478740 */
		/* 82106064h case    1:*/		regs.LR = 0x82106068; return 0x82091250;
		/* 82106064h case    1:*/		return 0x82106068;
		  /* 82106068h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82106068h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82106068h case    2:*/		return 0x8210606C;
		  /* 8210606Ch */ case    3:  		/* mr R27, R3 */
		/* 8210606Ch case    3:*/		regs.R27 = regs.R3;
		/* 8210606Ch case    3:*/		return 0x82106070;
		  /* 82106070h */ case    4:  		/* bl -1240 */
		/* 82106070h case    4:*/		regs.LR = 0x82106074; return 0x82105B98;
		/* 82106070h case    4:*/		return 0x82106074;
		  /* 82106074h */ case    5:  		/* lwz R11, <#[R27 + 12]> */
		/* 82106074h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 82106074h case    5:*/		return 0x82106078;
		  /* 82106078h */ case    6:  		/* li R26, 0 */
		/* 82106078h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82106078h case    6:*/		return 0x8210607C;
		  /* 8210607Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8210607Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210607Ch case    7:*/		return 0x82106080;
		  /* 82106080h */ case    8:  		/* mr R10, R26 */
		/* 82106080h case    8:*/		regs.R10 = regs.R26;
		/* 82106080h case    8:*/		return 0x82106084;
		  /* 82106084h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 82106084h case    9:*/		if ( regs.CR[6].eq ) { return 0x821060B8;  }
		/* 82106084h case    9:*/		return 0x82106088;
		  /* 82106088h */ case   10:  		/* mr R9, R26 */
		/* 82106088h case   10:*/		regs.R9 = regs.R26;
		/* 82106088h case   10:*/		return 0x8210608C;
		  /* 8210608Ch */ case   11:  		/* lwz R11, <#[R27 + 24]> */
		/* 8210608Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 8210608Ch case   11:*/		return 0x82106090;
		  /* 82106090h */ case   12:  		/* addi R10, R10, 1 */
		/* 82106090h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82106090h case   12:*/		return 0x82106094;
		  /* 82106094h */ case   13:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82106094h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82106094h case   13:*/		return 0x82106098;
		  /* 82106098h */ case   14:  		/* addi R9, R9, 4 */
		/* 82106098h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82106098h case   14:*/		return 0x8210609C;
		  /* 8210609Ch */ case   15:  		/* stw R26, <#[R11 + 24]> */
		/* 8210609Ch case   15:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000018) );
		/* 8210609Ch case   15:*/		return 0x821060A0;
		  /* 821060A0h */ case   16:  		/* stw R26, <#[R11 + 32]> */
		/* 821060A0h case   16:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000020) );
		/* 821060A0h case   16:*/		return 0x821060A4;
		  /* 821060A4h */ case   17:  		/* stw R26, <#[R11 + 20]> */
		/* 821060A4h case   17:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000014) );
		/* 821060A4h case   17:*/		return 0x821060A8;
		  /* 821060A8h */ case   18:  		/* stw R26, <#[R11 + 28]> */
		/* 821060A8h case   18:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000001C) );
		/* 821060A8h case   18:*/		return 0x821060AC;
		  /* 821060ACh */ case   19:  		/* lwz R11, <#[R27 + 12]> */
		/* 821060ACh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 821060ACh case   19:*/		return 0x821060B0;
		  /* 821060B0h */ case   20:  		/* cmplw CR6, R10, R11 */
		/* 821060B0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821060B0h case   20:*/		return 0x821060B4;
		  /* 821060B4h */ case   21:  		/* bc 12, CR6_LT, -40 */
		/* 821060B4h case   21:*/		if ( regs.CR[6].lt ) { return 0x8210608C;  }
		/* 821060B4h case   21:*/		return 0x821060B8;
	}
	return 0x821060B8;
} // Block from 82106060h-821060B8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821060B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821060B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821060B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821060B8);
		  /* 821060B8h */ case    0:  		/* mr R29, R26 */
		/* 821060B8h case    0:*/		regs.R29 = regs.R26;
		/* 821060B8h case    0:*/		return 0x821060BC;
		  /* 821060BCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821060BCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821060BCh case    1:*/		return 0x821060C0;
		  /* 821060C0h */ case    2:  		/* bc 12, CR6_EQ, 216 */
		/* 821060C0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82106198;  }
		/* 821060C0h case    2:*/		return 0x821060C4;
		  /* 821060C4h */ case    3:  		/* mr R28, R26 */
		/* 821060C4h case    3:*/		regs.R28 = regs.R26;
		/* 821060C4h case    3:*/		return 0x821060C8;
		  /* 821060C8h */ case    4:  		/* lwz R11, <#[R27 + 24]> */
		/* 821060C8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 821060C8h case    4:*/		return 0x821060CC;
		  /* 821060CCh */ case    5:  		/* lwzx R7, <#[R28 + R11]> */
		/* 821060CCh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 821060CCh case    5:*/		return 0x821060D0;
		  /* 821060D0h */ case    6:  		/* lwz R11, <#[R7]> */
		/* 821060D0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 821060D0h case    6:*/		return 0x821060D4;
		  /* 821060D4h */ case    7:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 821060D4h case    7:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821060D4h case    7:*/		return 0x821060D8;
		  /* 821060D8h */ case    8:  		/* bc 12, CR0_EQ, 172 */
		/* 821060D8h case    8:*/		if ( regs.CR[0].eq ) { return 0x82106184;  }
		/* 821060D8h case    8:*/		return 0x821060DC;
		  /* 821060DCh */ case    9:  		/* lwz R11, <#[R7 + 12]> */
		/* 821060DCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000000C) );
		/* 821060DCh case    9:*/		return 0x821060E0;
		  /* 821060E0h */ case   10:  		/* mr R30, R26 */
		/* 821060E0h case   10:*/		regs.R30 = regs.R26;
		/* 821060E0h case   10:*/		return 0x821060E4;
		  /* 821060E4h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 821060E4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821060E4h case   11:*/		return 0x821060E8;
		  /* 821060E8h */ case   12:  		/* bc 4, CR6_GT, 52 */
		/* 821060E8h case   12:*/		if ( !regs.CR[6].gt ) { return 0x8210611C;  }
		/* 821060E8h case   12:*/		return 0x821060EC;
		  /* 821060ECh */ case   13:  		/* mr R31, R26 */
		/* 821060ECh case   13:*/		regs.R31 = regs.R26;
		/* 821060ECh case   13:*/		return 0x821060F0;
		  /* 821060F0h */ case   14:  		/* lwz R11, <#[R7 + 16]> */
		/* 821060F0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000010) );
		/* 821060F0h case   14:*/		return 0x821060F4;
		  /* 821060F4h */ case   15:  		/* li R6, 0 */
		/* 821060F4h case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821060F4h case   15:*/		return 0x821060F8;
		  /* 821060F8h */ case   16:  		/* mr R5, R29 */
		/* 821060F8h case   16:*/		regs.R5 = regs.R29;
		/* 821060F8h case   16:*/		return 0x821060FC;
		  /* 821060FCh */ case   17:  		/* mr R3, R27 */
		/* 821060FCh case   17:*/		regs.R3 = regs.R27;
		/* 821060FCh case   17:*/		return 0x82106100;
		  /* 82106100h */ case   18:  		/* lwzx R4, <#[R11 + R31]> */
		/* 82106100h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82106100h case   18:*/		return 0x82106104;
		  /* 82106104h */ case   19:  		/* bl -19564 */
		/* 82106104h case   19:*/		regs.LR = 0x82106108; return 0x82101498;
		/* 82106104h case   19:*/		return 0x82106108;
		  /* 82106108h */ case   20:  		/* lwz R11, <#[R7 + 12]> */
		/* 82106108h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000000C) );
		/* 82106108h case   20:*/		return 0x8210610C;
		  /* 8210610Ch */ case   21:  		/* addi R30, R30, 1 */
		/* 8210610Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8210610Ch case   21:*/		return 0x82106110;
		  /* 82106110h */ case   22:  		/* addi R31, R31, 4 */
		/* 82106110h case   22:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82106110h case   22:*/		return 0x82106114;
		  /* 82106114h */ case   23:  		/* cmplw CR6, R30, R11 */
		/* 82106114h case   23:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82106114h case   23:*/		return 0x82106118;
		  /* 82106118h */ case   24:  		/* bc 12, CR6_LT, -40 */
		/* 82106118h case   24:*/		if ( regs.CR[6].lt ) { return 0x821060F0;  }
		/* 82106118h case   24:*/		return 0x8210611C;
	}
	return 0x8210611C;
} // Block from 821060B8h-8210611Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8210611Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210611C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210611C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210611C);
		  /* 8210611Ch */ case    0:  		/* lwz R11, <#[R7 + 4]> */
		/* 8210611Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000004) );
		/* 8210611Ch case    0:*/		return 0x82106120;
		  /* 82106120h */ case    1:  		/* mr R30, R26 */
		/* 82106120h case    1:*/		regs.R30 = regs.R26;
		/* 82106120h case    1:*/		return 0x82106124;
		  /* 82106124h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82106124h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106124h case    2:*/		return 0x82106128;
		  /* 82106128h */ case    3:  		/* bc 4, CR6_GT, 92 */
		/* 82106128h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82106184;  }
		/* 82106128h case    3:*/		return 0x8210612C;
		  /* 8210612Ch */ case    4:  		/* mr R31, R26 */
		/* 8210612Ch case    4:*/		regs.R31 = regs.R26;
		/* 8210612Ch case    4:*/		return 0x82106130;
		  /* 82106130h */ case    5:  		/* lwz R11, <#[R7 + 8]> */
		/* 82106130h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 82106130h case    5:*/		return 0x82106134;
		  /* 82106134h */ case    6:  		/* lwzx R11, <#[R31 + R11]> */
		/* 82106134h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82106134h case    6:*/		return 0x82106138;
		  /* 82106138h */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 82106138h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82106138h case    7:*/		return 0x8210613C;
		  /* 8210613Ch */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 8210613Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x8210615C;  }
		/* 8210613Ch case    8:*/		return 0x82106140;
		  /* 82106140h */ case    9:  		/* lwz R10, <#[R27 + 20]> */
		/* 82106140h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 82106140h case    9:*/		return 0x82106144;
		  /* 82106144h */ case   10:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82106144h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82106144h case   10:*/		return 0x82106148;
		  /* 82106148h */ case   11:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82106148h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82106148h case   11:*/		return 0x8210614C;
		  /* 8210614Ch */ case   12:  		/* lwz R10, <#[R10 + 56]> */
		/* 8210614Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 8210614Ch case   12:*/		return 0x82106150;
		  /* 82106150h */ case   13:  		/* cmpwi CR6, R10, -1 */
		/* 82106150h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82106150h case   13:*/		return 0x82106154;
		  /* 82106154h */ case   14:  		/* bc 12, CR6_EQ, 8 */
		/* 82106154h case   14:*/		if ( regs.CR[6].eq ) { return 0x8210615C;  }
		/* 82106154h case   14:*/		return 0x82106158;
		  /* 82106158h */ case   15:  		/* mr R11, R10 */
		/* 82106158h case   15:*/		regs.R11 = regs.R10;
		/* 82106158h case   15:*/		return 0x8210615C;
	}
	return 0x8210615C;
} // Block from 8210611Ch-8210615Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210615Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210615C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210615C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210615C);
		  /* 8210615Ch */ case    0:  		/* li R6, 1 */
		/* 8210615Ch case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8210615Ch case    0:*/		return 0x82106160;
		  /* 82106160h */ case    1:  		/* mr R5, R29 */
		/* 82106160h case    1:*/		regs.R5 = regs.R29;
		/* 82106160h case    1:*/		return 0x82106164;
		  /* 82106164h */ case    2:  		/* mr R4, R11 */
		/* 82106164h case    2:*/		regs.R4 = regs.R11;
		/* 82106164h case    2:*/		return 0x82106168;
		  /* 82106168h */ case    3:  		/* mr R3, R27 */
		/* 82106168h case    3:*/		regs.R3 = regs.R27;
		/* 82106168h case    3:*/		return 0x8210616C;
		  /* 8210616Ch */ case    4:  		/* bl -19668 */
		/* 8210616Ch case    4:*/		regs.LR = 0x82106170; return 0x82101498;
		/* 8210616Ch case    4:*/		return 0x82106170;
		  /* 82106170h */ case    5:  		/* lwz R11, <#[R7 + 4]> */
		/* 82106170h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000004) );
		/* 82106170h case    5:*/		return 0x82106174;
		  /* 82106174h */ case    6:  		/* addi R30, R30, 1 */
		/* 82106174h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82106174h case    6:*/		return 0x82106178;
		  /* 82106178h */ case    7:  		/* addi R31, R31, 4 */
		/* 82106178h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82106178h case    7:*/		return 0x8210617C;
		  /* 8210617Ch */ case    8:  		/* cmplw CR6, R30, R11 */
		/* 8210617Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8210617Ch case    8:*/		return 0x82106180;
		  /* 82106180h */ case    9:  		/* bc 12, CR6_LT, -80 */
		/* 82106180h case    9:*/		if ( regs.CR[6].lt ) { return 0x82106130;  }
		/* 82106180h case    9:*/		return 0x82106184;
	}
	return 0x82106184;
} // Block from 8210615Ch-82106184h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82106184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106184);
		  /* 82106184h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 82106184h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 82106184h case    0:*/		return 0x82106188;
		  /* 82106188h */ case    1:  		/* addi R29, R29, 1 */
		/* 82106188h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82106188h case    1:*/		return 0x8210618C;
		  /* 8210618Ch */ case    2:  		/* addi R28, R28, 4 */
		/* 8210618Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8210618Ch case    2:*/		return 0x82106190;
		  /* 82106190h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 82106190h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82106190h case    3:*/		return 0x82106194;
		  /* 82106194h */ case    4:  		/* bc 12, CR6_LT, -204 */
		/* 82106194h case    4:*/		if ( regs.CR[6].lt ) { return 0x821060C8;  }
		/* 82106194h case    4:*/		return 0x82106198;
	}
	return 0x82106198;
} // Block from 82106184h-82106198h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82106198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106198);
		  /* 82106198h */ case    0:  		/* mr R29, R26 */
		/* 82106198h case    0:*/		regs.R29 = regs.R26;
		/* 82106198h case    0:*/		return 0x8210619C;
		  /* 8210619Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8210619Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210619Ch case    1:*/		return 0x821061A0;
		  /* 821061A0h */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 821061A0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82106204;  }
		/* 821061A0h case    2:*/		return 0x821061A4;
		  /* 821061A4h */ case    3:  		/* mr R30, R26 */
		/* 821061A4h case    3:*/		regs.R30 = regs.R26;
		/* 821061A4h case    3:*/		return 0x821061A8;
		  /* 821061A8h */ case    4:  		/* lwz R11, <#[R27 + 24]> */
		/* 821061A8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 821061A8h case    4:*/		return 0x821061AC;
		  /* 821061ACh */ case    5:  		/* lwzx R31, <#[R30 + R11]> */
		/* 821061ACh case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821061ACh case    5:*/		return 0x821061B0;
		  /* 821061B0h */ case    6:  		/* lwz R3, <#[R31 + 20]> */
		/* 821061B0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 821061B0h case    6:*/		return 0x821061B4;
		  /* 821061B4h */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 821061B4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821061B4h case    7:*/		return 0x821061B8;
		  /* 821061B8h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 821061B8h case    8:*/		if ( regs.CR[6].eq ) { return 0x821061CC;  }
		/* 821061B8h case    8:*/		return 0x821061BC;
		  /* 821061BCh */ case    9:  		/* bl -40036 */
		/* 821061BCh case    9:*/		regs.LR = 0x821061C0; return 0x820FC558;
		/* 821061BCh case    9:*/		return 0x821061C0;
		  /* 821061C0h */ case   10:  		/* stw R3, <#[R31 + 24]> */
		/* 821061C0h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 821061C0h case   10:*/		return 0x821061C4;
		  /* 821061C4h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 821061C4h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821061C4h case   11:*/		return 0x821061C8;
		  /* 821061C8h */ case   12:  		/* bc 12, CR0_EQ, 588 */
		/* 821061C8h case   12:*/		if ( regs.CR[0].eq ) { return 0x82106414;  }
		/* 821061C8h case   12:*/		return 0x821061CC;
	}
	return 0x821061CC;
} // Block from 82106198h-821061CCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821061CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821061CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821061CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821061CC);
		  /* 821061CCh */ case    0:  		/* lwz R3, <#[R31 + 28]> */
		/* 821061CCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 821061CCh case    0:*/		return 0x821061D0;
		  /* 821061D0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 821061D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821061D0h case    1:*/		return 0x821061D4;
		  /* 821061D4h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 821061D4h case    2:*/		if ( regs.CR[6].eq ) { return 0x821061E8;  }
		/* 821061D4h case    2:*/		return 0x821061D8;
		  /* 821061D8h */ case    3:  		/* bl -40064 */
		/* 821061D8h case    3:*/		regs.LR = 0x821061DC; return 0x820FC558;
		/* 821061D8h case    3:*/		return 0x821061DC;
		  /* 821061DCh */ case    4:  		/* stw R3, <#[R31 + 32]> */
		/* 821061DCh case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 821061DCh case    4:*/		return 0x821061E0;
		  /* 821061E0h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 821061E0h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821061E0h case    5:*/		return 0x821061E4;
		  /* 821061E4h */ case    6:  		/* bc 12, CR0_EQ, 560 */
		/* 821061E4h case    6:*/		if ( regs.CR[0].eq ) { return 0x82106414;  }
		/* 821061E4h case    6:*/		return 0x821061E8;
	}
	return 0x821061E8;
} // Block from 821061CCh-821061E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821061E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821061E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821061E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821061E8);
		  /* 821061E8h */ case    0:  		/* addi R29, R29, 1 */
		/* 821061E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821061E8h case    0:*/		return 0x821061EC;
		  /* 821061ECh */ case    1:  		/* stw R26, <#[R31 + 20]> */
		/* 821061ECh case    1:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000014) );
		/* 821061ECh case    1:*/		return 0x821061F0;
		  /* 821061F0h */ case    2:  		/* stw R26, <#[R31 + 28]> */
		/* 821061F0h case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x0000001C) );
		/* 821061F0h case    2:*/		return 0x821061F4;
		  /* 821061F4h */ case    3:  		/* addi R30, R30, 4 */
		/* 821061F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 821061F4h case    3:*/		return 0x821061F8;
		  /* 821061F8h */ case    4:  		/* lwz R11, <#[R27 + 12]> */
		/* 821061F8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 821061F8h case    4:*/		return 0x821061FC;
		  /* 821061FCh */ case    5:  		/* cmplw CR6, R29, R11 */
		/* 821061FCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821061FCh case    5:*/		return 0x82106200;
		  /* 82106200h */ case    6:  		/* bc 12, CR6_LT, -88 */
		/* 82106200h case    6:*/		if ( regs.CR[6].lt ) { return 0x821061A8;  }
		/* 82106200h case    6:*/		return 0x82106204;
	}
	return 0x82106204;
} // Block from 821061E8h-82106204h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82106204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106204);
		  /* 82106204h */ case    0:  		/* mr R29, R26 */
		/* 82106204h case    0:*/		regs.R29 = regs.R26;
		/* 82106204h case    0:*/		return 0x82106208;
		  /* 82106208h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82106208h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106208h case    1:*/		return 0x8210620C;
		  /* 8210620Ch */ case    2:  		/* bc 12, CR6_EQ, 216 */
		/* 8210620Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821062E4;  }
		/* 8210620Ch case    2:*/		return 0x82106210;
		  /* 82106210h */ case    3:  		/* mr R28, R26 */
		/* 82106210h case    3:*/		regs.R28 = regs.R26;
		/* 82106210h case    3:*/		return 0x82106214;
		  /* 82106214h */ case    4:  		/* lwz R11, <#[R27 + 24]> */
		/* 82106214h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 82106214h case    4:*/		return 0x82106218;
		  /* 82106218h */ case    5:  		/* lwzx R7, <#[R28 + R11]> */
		/* 82106218h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 82106218h case    5:*/		return 0x8210621C;
		  /* 8210621Ch */ case    6:  		/* lwz R11, <#[R7]> */
		/* 8210621Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8210621Ch case    6:*/		return 0x82106220;
		  /* 82106220h */ case    7:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 82106220h case    7:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82106220h case    7:*/		return 0x82106224;
		  /* 82106224h */ case    8:  		/* bc 12, CR0_EQ, 172 */
		/* 82106224h case    8:*/		if ( regs.CR[0].eq ) { return 0x821062D0;  }
		/* 82106224h case    8:*/		return 0x82106228;
		  /* 82106228h */ case    9:  		/* lwz R11, <#[R7 + 12]> */
		/* 82106228h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000000C) );
		/* 82106228h case    9:*/		return 0x8210622C;
		  /* 8210622Ch */ case   10:  		/* mr R30, R26 */
		/* 8210622Ch case   10:*/		regs.R30 = regs.R26;
		/* 8210622Ch case   10:*/		return 0x82106230;
		  /* 82106230h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 82106230h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106230h case   11:*/		return 0x82106234;
		  /* 82106234h */ case   12:  		/* bc 4, CR6_GT, 52 */
		/* 82106234h case   12:*/		if ( !regs.CR[6].gt ) { return 0x82106268;  }
		/* 82106234h case   12:*/		return 0x82106238;
		  /* 82106238h */ case   13:  		/* mr R31, R26 */
		/* 82106238h case   13:*/		regs.R31 = regs.R26;
		/* 82106238h case   13:*/		return 0x8210623C;
		  /* 8210623Ch */ case   14:  		/* lwz R11, <#[R7 + 16]> */
		/* 8210623Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000010) );
		/* 8210623Ch case   14:*/		return 0x82106240;
		  /* 82106240h */ case   15:  		/* li R6, 0 */
		/* 82106240h case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82106240h case   15:*/		return 0x82106244;
		  /* 82106244h */ case   16:  		/* mr R5, R29 */
		/* 82106244h case   16:*/		regs.R5 = regs.R29;
		/* 82106244h case   16:*/		return 0x82106248;
		  /* 82106248h */ case   17:  		/* mr R3, R27 */
		/* 82106248h case   17:*/		regs.R3 = regs.R27;
		/* 82106248h case   17:*/		return 0x8210624C;
		  /* 8210624Ch */ case   18:  		/* lwzx R4, <#[R31 + R11]> */
		/* 8210624Ch case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210624Ch case   18:*/		return 0x82106250;
		  /* 82106250h */ case   19:  		/* bl -19896 */
		/* 82106250h case   19:*/		regs.LR = 0x82106254; return 0x82101498;
		/* 82106250h case   19:*/		return 0x82106254;
		  /* 82106254h */ case   20:  		/* lwz R11, <#[R7 + 12]> */
		/* 82106254h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000000C) );
		/* 82106254h case   20:*/		return 0x82106258;
		  /* 82106258h */ case   21:  		/* addi R30, R30, 1 */
		/* 82106258h case   21:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82106258h case   21:*/		return 0x8210625C;
		  /* 8210625Ch */ case   22:  		/* addi R31, R31, 4 */
		/* 8210625Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8210625Ch case   22:*/		return 0x82106260;
		  /* 82106260h */ case   23:  		/* cmplw CR6, R30, R11 */
		/* 82106260h case   23:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82106260h case   23:*/		return 0x82106264;
		  /* 82106264h */ case   24:  		/* bc 12, CR6_LT, -40 */
		/* 82106264h case   24:*/		if ( regs.CR[6].lt ) { return 0x8210623C;  }
		/* 82106264h case   24:*/		return 0x82106268;
	}
	return 0x82106268;
} // Block from 82106204h-82106268h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82106268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106268);
		  /* 82106268h */ case    0:  		/* lwz R11, <#[R7 + 4]> */
		/* 82106268h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000004) );
		/* 82106268h case    0:*/		return 0x8210626C;
		  /* 8210626Ch */ case    1:  		/* mr R30, R26 */
		/* 8210626Ch case    1:*/		regs.R30 = regs.R26;
		/* 8210626Ch case    1:*/		return 0x82106270;
		  /* 82106270h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82106270h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106270h case    2:*/		return 0x82106274;
		  /* 82106274h */ case    3:  		/* bc 4, CR6_GT, 92 */
		/* 82106274h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821062D0;  }
		/* 82106274h case    3:*/		return 0x82106278;
		  /* 82106278h */ case    4:  		/* mr R31, R26 */
		/* 82106278h case    4:*/		regs.R31 = regs.R26;
		/* 82106278h case    4:*/		return 0x8210627C;
		  /* 8210627Ch */ case    5:  		/* lwz R11, <#[R7 + 8]> */
		/* 8210627Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 8210627Ch case    5:*/		return 0x82106280;
		  /* 82106280h */ case    6:  		/* lwzx R11, <#[R31 + R11]> */
		/* 82106280h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 82106280h case    6:*/		return 0x82106284;
		  /* 82106284h */ case    7:  		/* cmpwi CR6, R11, -1 */
		/* 82106284h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82106284h case    7:*/		return 0x82106288;
		  /* 82106288h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 82106288h case    8:*/		if ( regs.CR[6].eq ) { return 0x821062A8;  }
		/* 82106288h case    8:*/		return 0x8210628C;
		  /* 8210628Ch */ case    9:  		/* lwz R10, <#[R27 + 20]> */
		/* 8210628Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 8210628Ch case    9:*/		return 0x82106290;
		  /* 82106290h */ case   10:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82106290h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82106290h case   10:*/		return 0x82106294;
		  /* 82106294h */ case   11:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82106294h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82106294h case   11:*/		return 0x82106298;
		  /* 82106298h */ case   12:  		/* lwz R10, <#[R10 + 56]> */
		/* 82106298h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 82106298h case   12:*/		return 0x8210629C;
		  /* 8210629Ch */ case   13:  		/* cmpwi CR6, R10, -1 */
		/* 8210629Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210629Ch case   13:*/		return 0x821062A0;
		  /* 821062A0h */ case   14:  		/* bc 12, CR6_EQ, 8 */
		/* 821062A0h case   14:*/		if ( regs.CR[6].eq ) { return 0x821062A8;  }
		/* 821062A0h case   14:*/		return 0x821062A4;
		  /* 821062A4h */ case   15:  		/* mr R11, R10 */
		/* 821062A4h case   15:*/		regs.R11 = regs.R10;
		/* 821062A4h case   15:*/		return 0x821062A8;
	}
	return 0x821062A8;
} // Block from 82106268h-821062A8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821062A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821062A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821062A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821062A8);
		  /* 821062A8h */ case    0:  		/* li R6, 1 */
		/* 821062A8h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821062A8h case    0:*/		return 0x821062AC;
		  /* 821062ACh */ case    1:  		/* mr R5, R29 */
		/* 821062ACh case    1:*/		regs.R5 = regs.R29;
		/* 821062ACh case    1:*/		return 0x821062B0;
		  /* 821062B0h */ case    2:  		/* mr R4, R11 */
		/* 821062B0h case    2:*/		regs.R4 = regs.R11;
		/* 821062B0h case    2:*/		return 0x821062B4;
		  /* 821062B4h */ case    3:  		/* mr R3, R27 */
		/* 821062B4h case    3:*/		regs.R3 = regs.R27;
		/* 821062B4h case    3:*/		return 0x821062B8;
		  /* 821062B8h */ case    4:  		/* bl -20000 */
		/* 821062B8h case    4:*/		regs.LR = 0x821062BC; return 0x82101498;
		/* 821062B8h case    4:*/		return 0x821062BC;
		  /* 821062BCh */ case    5:  		/* lwz R11, <#[R7 + 4]> */
		/* 821062BCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000004) );
		/* 821062BCh case    5:*/		return 0x821062C0;
		  /* 821062C0h */ case    6:  		/* addi R30, R30, 1 */
		/* 821062C0h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 821062C0h case    6:*/		return 0x821062C4;
		  /* 821062C4h */ case    7:  		/* addi R31, R31, 4 */
		/* 821062C4h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821062C4h case    7:*/		return 0x821062C8;
		  /* 821062C8h */ case    8:  		/* cmplw CR6, R30, R11 */
		/* 821062C8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 821062C8h case    8:*/		return 0x821062CC;
		  /* 821062CCh */ case    9:  		/* bc 12, CR6_LT, -80 */
		/* 821062CCh case    9:*/		if ( regs.CR[6].lt ) { return 0x8210627C;  }
		/* 821062CCh case    9:*/		return 0x821062D0;
	}
	return 0x821062D0;
} // Block from 821062A8h-821062D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821062D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821062D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821062D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821062D0);
		  /* 821062D0h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 821062D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 821062D0h case    0:*/		return 0x821062D4;
		  /* 821062D4h */ case    1:  		/* addi R29, R29, 1 */
		/* 821062D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821062D4h case    1:*/		return 0x821062D8;
		  /* 821062D8h */ case    2:  		/* addi R28, R28, 4 */
		/* 821062D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 821062D8h case    2:*/		return 0x821062DC;
		  /* 821062DCh */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 821062DCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821062DCh case    3:*/		return 0x821062E0;
		  /* 821062E0h */ case    4:  		/* bc 12, CR6_LT, -204 */
		/* 821062E0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82106214;  }
		/* 821062E0h case    4:*/		return 0x821062E4;
	}
	return 0x821062E4;
} // Block from 821062D0h-821062E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821062E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821062E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821062E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821062E4);
		  /* 821062E4h */ case    0:  		/* mr R29, R26 */
		/* 821062E4h case    0:*/		regs.R29 = regs.R26;
		/* 821062E4h case    0:*/		return 0x821062E8;
		  /* 821062E8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821062E8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821062E8h case    1:*/		return 0x821062EC;
		  /* 821062ECh */ case    2:  		/* bc 12, CR6_EQ, 284 */
		/* 821062ECh case    2:*/		if ( regs.CR[6].eq ) { return 0x82106408;  }
		/* 821062ECh case    2:*/		return 0x821062F0;
		  /* 821062F0h */ case    3:  		/* mr R30, R26 */
		/* 821062F0h case    3:*/		regs.R30 = regs.R26;
		/* 821062F0h case    3:*/		return 0x821062F4;
		  /* 821062F4h */ case    4:  		/* lwz R11, <#[R27 + 24]> */
		/* 821062F4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 821062F4h case    4:*/		return 0x821062F8;
		  /* 821062F8h */ case    5:  		/* lwzx R31, <#[R30 + R11]> */
		/* 821062F8h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821062F8h case    5:*/		return 0x821062FC;
		  /* 821062FCh */ case    6:  		/* lwz R5, <#[R31 + 20]> */
		/* 821062FCh case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000014) );
		/* 821062FCh case    6:*/		return 0x82106300;
		  /* 82106300h */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 82106300h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82106300h case    7:*/		return 0x82106304;
		  /* 82106304h */ case    8:  		/* bc 12, CR6_EQ, 116 */
		/* 82106304h case    8:*/		if ( regs.CR[6].eq ) { return 0x82106378;  }
		/* 82106304h case    8:*/		return 0x82106308;
		  /* 82106308h */ case    9:  		/* lis R11, -32240 */
		/* 82106308h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8210);
		/* 82106308h case    9:*/		return 0x8210630C;
		  /* 8210630Ch */ case   10:  		/* lwz R4, <#[R31 + 24]> */
		/* 8210630Ch case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 8210630Ch case   10:*/		return 0x82106310;
		  /* 82106310h */ case   11:  		/* li R6, 0 */
		/* 82106310h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82106310h case   11:*/		return 0x82106314;
		  /* 82106314h */ case   12:  		/* addi R3, R11, -9712 */
		/* 82106314h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFDA10);
		/* 82106314h case   12:*/		return 0x82106318;
		  /* 82106318h */ case   13:  		/* bl -33912 */
		/* 82106318h case   13:*/		regs.LR = 0x8210631C; return 0x820FDEA0;
		/* 82106318h case   13:*/		return 0x8210631C;
		  /* 8210631Ch */ case   14:  		/* lwz R11, <#[R31 + 20]> */
		/* 8210631Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8210631Ch case   14:*/		return 0x82106320;
		  /* 82106320h */ case   15:  		/* li R7, 1 */
		/* 82106320h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82106320h case   15:*/		return 0x82106324;
		  /* 82106324h */ case   16:  		/* li R6, 1 */
		/* 82106324h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82106324h case   16:*/		return 0x82106328;
		  /* 82106328h */ case   17:  		/* cmplwi CR6, R11, 1 */
		/* 82106328h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82106328h case   17:*/		return 0x8210632C;
		  /* 8210632Ch */ case   18:  		/* bc 4, CR6_GT, 72 */
		/* 8210632Ch case   18:*/		if ( !regs.CR[6].gt ) { return 0x82106374;  }
		/* 8210632Ch case   18:*/		return 0x82106330;
		  /* 82106330h */ case   19:  		/* li R8, 4 */
		/* 82106330h case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82106330h case   19:*/		return 0x82106334;
		  /* 82106334h */ case   20:  		/* li R9, 4 */
		/* 82106334h case   20:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 82106334h case   20:*/		return 0x82106338;
		  /* 82106338h */ case   21:  		/* lwz R10, <#[R31 + 24]> */
		/* 82106338h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82106338h case   21:*/		return 0x8210633C;
		  /* 8210633Ch */ case   22:  		/* add R11, R9, R10 */
		/* 8210633Ch case   22:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 8210633Ch case   22:*/		return 0x82106340;
		  /* 82106340h */ case   23:  		/* lwzx R5, <#[R9 + R10]> */
		/* 82106340h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82106340h case   23:*/		return 0x82106344;
		  /* 82106344h */ case   24:  		/* lwz R4, <#[R11 - 4]> */
		/* 82106344h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82106344h case   24:*/		return 0x82106348;
		  /* 82106348h */ case   25:  		/* cmplw CR6, R5, R4 */
		/* 82106348h case   25:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 82106348h case   25:*/		return 0x8210634C;
		  /* 8210634Ch */ case   26:  		/* bc 12, CR6_EQ, 20 */
		/* 8210634Ch case   26:*/		if ( regs.CR[6].eq ) { return 0x82106360;  }
		/* 8210634Ch case   26:*/		return 0x82106350;
		  /* 82106350h */ case   27:  		/* lwz R11, <#[R11]> */
		/* 82106350h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82106350h case   27:*/		return 0x82106354;
		  /* 82106354h */ case   28:  		/* addi R7, R7, 1 */
		/* 82106354h case   28:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82106354h case   28:*/		return 0x82106358;
		  /* 82106358h */ case   29:  		/* stwx R11, <#[R8 + R10]> */
		/* 82106358h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82106358h case   29:*/		return 0x8210635C;
		  /* 8210635Ch */ case   30:  		/* addi R8, R8, 4 */
		/* 8210635Ch case   30:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8210635Ch case   30:*/		return 0x82106360;
	}
	return 0x82106360;
} // Block from 821062E4h-82106360h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82106360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106360);
		  /* 82106360h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 82106360h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82106360h case    0:*/		return 0x82106364;
		  /* 82106364h */ case    1:  		/* addi R6, R6, 1 */
		/* 82106364h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82106364h case    1:*/		return 0x82106368;
		  /* 82106368h */ case    2:  		/* addi R9, R9, 4 */
		/* 82106368h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82106368h case    2:*/		return 0x8210636C;
		  /* 8210636Ch */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 8210636Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 8210636Ch case    3:*/		return 0x82106370;
		  /* 82106370h */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 82106370h case    4:*/		if ( regs.CR[6].lt ) { return 0x82106338;  }
		/* 82106370h case    4:*/		return 0x82106374;
	}
	return 0x82106374;
} // Block from 82106360h-82106374h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82106374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106374);
		  /* 82106374h */ case    0:  		/* stw R7, <#[R31 + 20]> */
		/* 82106374h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 82106374h case    0:*/		return 0x82106378;
	}
	return 0x82106378;
} // Block from 82106374h-82106378h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82106378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106378);
		  /* 82106378h */ case    0:  		/* lwz R5, <#[R31 + 28]> */
		/* 82106378h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000001C) );
		/* 82106378h case    0:*/		return 0x8210637C;
		  /* 8210637Ch */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 8210637Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8210637Ch case    1:*/		return 0x82106380;
		  /* 82106380h */ case    2:  		/* bc 12, CR6_EQ, 116 */
		/* 82106380h case    2:*/		if ( regs.CR[6].eq ) { return 0x821063F4;  }
		/* 82106380h case    2:*/		return 0x82106384;
		  /* 82106384h */ case    3:  		/* lis R11, -32240 */
		/* 82106384h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8210);
		/* 82106384h case    3:*/		return 0x82106388;
		  /* 82106388h */ case    4:  		/* lwz R4, <#[R31 + 32]> */
		/* 82106388h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000020) );
		/* 82106388h case    4:*/		return 0x8210638C;
		  /* 8210638Ch */ case    5:  		/* li R6, 0 */
		/* 8210638Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8210638Ch case    5:*/		return 0x82106390;
		  /* 82106390h */ case    6:  		/* addi R3, R11, -9712 */
		/* 82106390h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFDA10);
		/* 82106390h case    6:*/		return 0x82106394;
		  /* 82106394h */ case    7:  		/* bl -34036 */
		/* 82106394h case    7:*/		regs.LR = 0x82106398; return 0x820FDEA0;
		/* 82106394h case    7:*/		return 0x82106398;
		  /* 82106398h */ case    8:  		/* lwz R11, <#[R31 + 28]> */
		/* 82106398h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82106398h case    8:*/		return 0x8210639C;
		  /* 8210639Ch */ case    9:  		/* li R7, 1 */
		/* 8210639Ch case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8210639Ch case    9:*/		return 0x821063A0;
		  /* 821063A0h */ case   10:  		/* li R6, 1 */
		/* 821063A0h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821063A0h case   10:*/		return 0x821063A4;
		  /* 821063A4h */ case   11:  		/* cmplwi CR6, R11, 1 */
		/* 821063A4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821063A4h case   11:*/		return 0x821063A8;
		  /* 821063A8h */ case   12:  		/* bc 4, CR6_GT, 72 */
		/* 821063A8h case   12:*/		if ( !regs.CR[6].gt ) { return 0x821063F0;  }
		/* 821063A8h case   12:*/		return 0x821063AC;
		  /* 821063ACh */ case   13:  		/* li R8, 4 */
		/* 821063ACh case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821063ACh case   13:*/		return 0x821063B0;
		  /* 821063B0h */ case   14:  		/* li R9, 4 */
		/* 821063B0h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 821063B0h case   14:*/		return 0x821063B4;
		  /* 821063B4h */ case   15:  		/* lwz R10, <#[R31 + 32]> */
		/* 821063B4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 821063B4h case   15:*/		return 0x821063B8;
		  /* 821063B8h */ case   16:  		/* add R11, R9, R10 */
		/* 821063B8h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 821063B8h case   16:*/		return 0x821063BC;
		  /* 821063BCh */ case   17:  		/* lwzx R5, <#[R9 + R10]> */
		/* 821063BCh case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821063BCh case   17:*/		return 0x821063C0;
		  /* 821063C0h */ case   18:  		/* lwz R4, <#[R11 - 4]> */
		/* 821063C0h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 821063C0h case   18:*/		return 0x821063C4;
		  /* 821063C4h */ case   19:  		/* cmplw CR6, R5, R4 */
		/* 821063C4h case   19:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 821063C4h case   19:*/		return 0x821063C8;
		  /* 821063C8h */ case   20:  		/* bc 12, CR6_EQ, 20 */
		/* 821063C8h case   20:*/		if ( regs.CR[6].eq ) { return 0x821063DC;  }
		/* 821063C8h case   20:*/		return 0x821063CC;
		  /* 821063CCh */ case   21:  		/* lwz R11, <#[R11]> */
		/* 821063CCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821063CCh case   21:*/		return 0x821063D0;
		  /* 821063D0h */ case   22:  		/* addi R7, R7, 1 */
		/* 821063D0h case   22:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821063D0h case   22:*/		return 0x821063D4;
		  /* 821063D4h */ case   23:  		/* stwx R11, <#[R8 + R10]> */
		/* 821063D4h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 821063D4h case   23:*/		return 0x821063D8;
		  /* 821063D8h */ case   24:  		/* addi R8, R8, 4 */
		/* 821063D8h case   24:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 821063D8h case   24:*/		return 0x821063DC;
	}
	return 0x821063DC;
} // Block from 82106378h-821063DCh (25 instructions)

//////////////////////////////////////////////////////
// Block at 821063DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821063DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821063DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821063DC);
		  /* 821063DCh */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 821063DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 821063DCh case    0:*/		return 0x821063E0;
		  /* 821063E0h */ case    1:  		/* addi R6, R6, 1 */
		/* 821063E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821063E0h case    1:*/		return 0x821063E4;
		  /* 821063E4h */ case    2:  		/* addi R9, R9, 4 */
		/* 821063E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821063E4h case    2:*/		return 0x821063E8;
		  /* 821063E8h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 821063E8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 821063E8h case    3:*/		return 0x821063EC;
		  /* 821063ECh */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 821063ECh case    4:*/		if ( regs.CR[6].lt ) { return 0x821063B4;  }
		/* 821063ECh case    4:*/		return 0x821063F0;
	}
	return 0x821063F0;
} // Block from 821063DCh-821063F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821063F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821063F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821063F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821063F0);
		  /* 821063F0h */ case    0:  		/* stw R7, <#[R31 + 28]> */
		/* 821063F0h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x0000001C) );
		/* 821063F0h case    0:*/		return 0x821063F4;
	}
	return 0x821063F4;
} // Block from 821063F0h-821063F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821063F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821063F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821063F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821063F4);
		  /* 821063F4h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 821063F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 821063F4h case    0:*/		return 0x821063F8;
		  /* 821063F8h */ case    1:  		/* addi R29, R29, 1 */
		/* 821063F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821063F8h case    1:*/		return 0x821063FC;
		  /* 821063FCh */ case    2:  		/* addi R30, R30, 4 */
		/* 821063FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 821063FCh case    2:*/		return 0x82106400;
	}
	return 0x82106400;
} // Block from 821063F4h-82106400h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82106400h
// Function '?CompactPool_ReadCount@CProgram@D3DXShader@@AAAXPAU_D3DXCP_DATA@2@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106400);
		  /* 82106400h */ case    0:  		/* cmplw CR6, R29, R11 */
		/* 82106400h case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82106400h case    0:*/		return 0x82106404;
		  /* 82106404h */ case    1:  		/* bc 12, CR6_LT, -272 */
		/* 82106404h case    1:*/		if ( regs.CR[6].lt ) { return 0x821062F4;  }
		/* 82106404h case    1:*/		return 0x82106408;
	}
	return 0x82106408;
} // Block from 82106400h-82106408h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82106408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106408);
		  /* 82106408h */ case    0:  		/* li R3, 0 */
		/* 82106408h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82106408h case    0:*/		return 0x8210640C;
		  /* 8210640Ch */ case    1:  		/* addi R1, R1, 144 */
		/* 8210640Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8210640Ch case    1:*/		return 0x82106410;
		  /* 82106410h */ case    2:  		/* b -479600 */
		/* 82106410h case    2:*/		return 0x820912A0;
		/* 82106410h case    2:*/		return 0x82106414;
	}
	return 0x82106414;
} // Block from 82106408h-82106414h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82106414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106414);
		  /* 82106414h */ case    0:  		/* lis R3, -32761 */
		/* 82106414h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82106414h case    0:*/		return 0x82106418;
		  /* 82106418h */ case    1:  		/* ori R3, R3, 14 */
		/* 82106418h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82106418h case    1:*/		return 0x8210641C;
		  /* 8210641Ch */ case    2:  		/* b -16 */
		/* 8210641Ch case    2:*/		return 0x8210640C;
		/* 8210641Ch case    2:*/		return 0x82106420;
	}
	return 0x82106420;
} // Block from 82106414h-82106420h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82106420h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106420);
		  /* 82106420h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 82106420h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82106420h case    0:*/		return 0x82106424;
		  /* 82106424h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 82106424h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82106424h case    1:*/		return 0x82106428;
		  /* 82106428h */ case    2:  		/* li R4, -1 */
		/* 82106428h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 82106428h case    2:*/		return 0x8210642C;
		  /* 8210642Ch */ case    3:  		/* li R7, 0 */
		/* 8210642Ch case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210642Ch case    3:*/		return 0x82106430;
		  /* 82106430h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82106430h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106430h case    4:*/		return 0x82106434;
		  /* 82106434h */ case    5:  		/* bc 4, CR6_GT, 152 */
		/* 82106434h case    5:*/		if ( !regs.CR[6].gt ) { return 0x821064CC;  }
		/* 82106434h case    5:*/		return 0x82106438;
		  /* 82106438h */ case    6:  		/* li R8, 0 */
		/* 82106438h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82106438h case    6:*/		return 0x8210643C;
		  /* 8210643Ch */ case    7:  		/* lwz R11, <#[R3 + 20]> */
		/* 8210643Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8210643Ch case    7:*/		return 0x82106440;
		  /* 82106440h */ case    8:  		/* lwzx R9, <#[R8 + R11]> */
		/* 82106440h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82106440h case    8:*/		return 0x82106444;
		  /* 82106444h */ case    9:  		/* lwz R10, <#[R9 + 8]> */
		/* 82106444h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 82106444h case    9:*/		return 0x82106448;
		  /* 82106448h */ case   10:  		/* cmpwi CR6, R10, -1 */
		/* 82106448h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82106448h case   10:*/		return 0x8210644C;
		  /* 8210644Ch */ case   11:  		/* bc 12, CR6_EQ, 20 */
		/* 8210644Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82106460;  }
		/* 8210644Ch case   11:*/		return 0x82106450;
		  /* 82106450h */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82106450h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82106450h case   12:*/		return 0x82106454;
		  /* 82106454h */ case   13:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82106454h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82106454h case   13:*/		return 0x82106458;
		  /* 82106458h */ case   14:  		/* lwz R11, <#[R11 + 48]> */
		/* 82106458h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82106458h case   14:*/		return 0x8210645C;
		  /* 8210645Ch */ case   15:  		/* b 8 */
		/* 8210645Ch case   15:*/		return 0x82106464;
		/* 8210645Ch case   15:*/		return 0x82106460;
	}
	return 0x82106460;
} // Block from 82106420h-82106460h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82106460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106460);
		  /* 82106460h */ case    0:  		/* mr R11, R4 */
		/* 82106460h case    0:*/		regs.R11 = regs.R4;
		/* 82106460h case    0:*/		return 0x82106464;
	}
	return 0x82106464;
} // Block from 82106460h-82106464h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82106464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106464);
		  /* 82106464h */ case    0:  		/* stw R11, <#[R9 + 8]> */
		/* 82106464h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82106464h case    0:*/		return 0x82106468;
		  /* 82106468h */ case    1:  		/* lwz R11, <#[R9 + 20]> */
		/* 82106468h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 82106468h case    1:*/		return 0x8210646C;
		  /* 8210646Ch */ case    2:  		/* cmpwi CR6, R11, -1 */
		/* 8210646Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210646Ch case    2:*/		return 0x82106470;
		  /* 82106470h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82106470h case    3:*/		if ( regs.CR[6].eq ) { return 0x82106488;  }
		/* 82106470h case    3:*/		return 0x82106474;
		  /* 82106474h */ case    4:  		/* lwz R10, <#[R3 + 20]> */
		/* 82106474h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 82106474h case    4:*/		return 0x82106478;
		  /* 82106478h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82106478h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82106478h case    5:*/		return 0x8210647C;
		  /* 8210647Ch */ case    6:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210647Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210647Ch case    6:*/		return 0x82106480;
		  /* 82106480h */ case    7:  		/* lwz R11, <#[R11 + 48]> */
		/* 82106480h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82106480h case    7:*/		return 0x82106484;
		  /* 82106484h */ case    8:  		/* b 8 */
		/* 82106484h case    8:*/		return 0x8210648C;
		/* 82106484h case    8:*/		return 0x82106488;
	}
	return 0x82106488;
} // Block from 82106464h-82106488h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82106488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106488);
		  /* 82106488h */ case    0:  		/* mr R11, R4 */
		/* 82106488h case    0:*/		regs.R11 = regs.R4;
		/* 82106488h case    0:*/		return 0x8210648C;
	}
	return 0x8210648C;
} // Block from 82106488h-8210648Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210648Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210648C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210648C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210648C);
		  /* 8210648Ch */ case    0:  		/* stw R11, <#[R9 + 20]> */
		/* 8210648Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 8210648Ch case    0:*/		return 0x82106490;
		  /* 82106490h */ case    1:  		/* lwz R11, <#[R9 + 56]> */
		/* 82106490h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000038) );
		/* 82106490h case    1:*/		return 0x82106494;
		  /* 82106494h */ case    2:  		/* cmpwi CR6, R11, -1 */
		/* 82106494h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82106494h case    2:*/		return 0x82106498;
		  /* 82106498h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82106498h case    3:*/		if ( regs.CR[6].eq ) { return 0x821064B0;  }
		/* 82106498h case    3:*/		return 0x8210649C;
		  /* 8210649Ch */ case    4:  		/* lwz R10, <#[R3 + 20]> */
		/* 8210649Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 8210649Ch case    4:*/		return 0x821064A0;
		  /* 821064A0h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821064A0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821064A0h case    5:*/		return 0x821064A4;
		  /* 821064A4h */ case    6:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821064A4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821064A4h case    6:*/		return 0x821064A8;
		  /* 821064A8h */ case    7:  		/* lwz R11, <#[R11 + 48]> */
		/* 821064A8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 821064A8h case    7:*/		return 0x821064AC;
		  /* 821064ACh */ case    8:  		/* b 8 */
		/* 821064ACh case    8:*/		return 0x821064B4;
		/* 821064ACh case    8:*/		return 0x821064B0;
	}
	return 0x821064B0;
} // Block from 8210648Ch-821064B0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821064B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821064B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821064B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821064B0);
		  /* 821064B0h */ case    0:  		/* mr R11, R4 */
		/* 821064B0h case    0:*/		regs.R11 = regs.R4;
		/* 821064B0h case    0:*/		return 0x821064B4;
	}
	return 0x821064B4;
} // Block from 821064B0h-821064B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821064B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821064B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821064B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821064B4);
		  /* 821064B4h */ case    0:  		/* addi R7, R7, 1 */
		/* 821064B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821064B4h case    0:*/		return 0x821064B8;
		  /* 821064B8h */ case    1:  		/* stw R11, <#[R9 + 56]> */
		/* 821064B8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000038) );
		/* 821064B8h case    1:*/		return 0x821064BC;
		  /* 821064BCh */ case    2:  		/* lwz R11, <#[R3 + 8]> */
		/* 821064BCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821064BCh case    2:*/		return 0x821064C0;
		  /* 821064C0h */ case    3:  		/* addi R8, R8, 4 */
		/* 821064C0h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 821064C0h case    3:*/		return 0x821064C4;
		  /* 821064C4h */ case    4:  		/* cmplw CR6, R7, R11 */
		/* 821064C4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 821064C4h case    4:*/		return 0x821064C8;
		  /* 821064C8h */ case    5:  		/* bc 12, CR6_LT, -140 */
		/* 821064C8h case    5:*/		if ( regs.CR[6].lt ) { return 0x8210643C;  }
		/* 821064C8h case    5:*/		return 0x821064CC;
	}
	return 0x821064CC;
} // Block from 821064B4h-821064CCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821064CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821064CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821064CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821064CC);
		  /* 821064CCh */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 821064CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821064CCh case    0:*/		return 0x821064D0;
		  /* 821064D0h */ case    1:  		/* li R5, 0 */
		/* 821064D0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821064D0h case    1:*/		return 0x821064D4;
		  /* 821064D4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821064D4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821064D4h case    2:*/		return 0x821064D8;
		  /* 821064D8h */ case    3:  		/* bc 4, CR6_GT, 216 */
		/* 821064D8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821065B0;  }
		/* 821064D8h case    3:*/		return 0x821064DC;
		  /* 821064DCh */ case    4:  		/* li R6, 0 */
		/* 821064DCh case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821064DCh case    4:*/		return 0x821064E0;
		  /* 821064E0h */ case    5:  		/* lwz R11, <#[R3 + 24]> */
		/* 821064E0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 821064E0h case    5:*/		return 0x821064E4;
		  /* 821064E4h */ case    6:  		/* lwzx R10, <#[R11 + R6]> */
		/* 821064E4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 821064E4h case    6:*/		return 0x821064E8;
		  /* 821064E8h */ case    7:  		/* lwz R11, <#[R10]> */
		/* 821064E8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821064E8h case    7:*/		return 0x821064EC;
		  /* 821064ECh */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 821064ECh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821064ECh case    8:*/		return 0x821064F0;
		  /* 821064F0h */ case    9:  		/* bc 12, CR6_EQ, 172 */
		/* 821064F0h case    9:*/		if ( regs.CR[6].eq ) { return 0x8210659C;  }
		/* 821064F0h case    9:*/		return 0x821064F4;
		  /* 821064F4h */ case   10:  		/* lwz R11, <#[R10 + 4]> */
		/* 821064F4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 821064F4h case   10:*/		return 0x821064F8;
		  /* 821064F8h */ case   11:  		/* li R7, 0 */
		/* 821064F8h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821064F8h case   11:*/		return 0x821064FC;
		  /* 821064FCh */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 821064FCh case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821064FCh case   12:*/		return 0x82106500;
		  /* 82106500h */ case   13:  		/* bc 4, CR6_GT, 72 */
		/* 82106500h case   13:*/		if ( !regs.CR[6].gt ) { return 0x82106548;  }
		/* 82106500h case   13:*/		return 0x82106504;
		  /* 82106504h */ case   14:  		/* li R11, 0 */
		/* 82106504h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82106504h case   14:*/		return 0x82106508;
		  /* 82106508h */ case   15:  		/* lwz R8, <#[R10 + 8]> */
		/* 82106508h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 82106508h case   15:*/		return 0x8210650C;
		  /* 8210650Ch */ case   16:  		/* lwzx R9, <#[R11 + R8]> */
		/* 8210650Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210650Ch case   16:*/		return 0x82106510;
		  /* 82106510h */ case   17:  		/* cmpwi CR6, R9, -1 */
		/* 82106510h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82106510h case   17:*/		return 0x82106514;
		  /* 82106514h */ case   18:  		/* bc 12, CR6_EQ, 24 */
		/* 82106514h case   18:*/		if ( regs.CR[6].eq ) { return 0x8210652C;  }
		/* 82106514h case   18:*/		return 0x82106518;
		  /* 82106518h */ case   19:  		/* lwz R31, <#[R3 + 20]> */
		/* 82106518h case   19:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000014) );
		/* 82106518h case   19:*/		return 0x8210651C;
		  /* 8210651Ch */ case   20:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210651Ch case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210651Ch case   20:*/		return 0x82106520;
		  /* 82106520h */ case   21:  		/* lwzx R9, <#[R9 + R31]> */
		/* 82106520h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R31 + 0x00000000) );
		/* 82106520h case   21:*/		return 0x82106524;
		  /* 82106524h */ case   22:  		/* lwz R9, <#[R9 + 48]> */
		/* 82106524h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000030) );
		/* 82106524h case   22:*/		return 0x82106528;
		  /* 82106528h */ case   23:  		/* b 8 */
		/* 82106528h case   23:*/		return 0x82106530;
		/* 82106528h case   23:*/		return 0x8210652C;
	}
	return 0x8210652C;
} // Block from 821064CCh-8210652Ch (24 instructions)

//////////////////////////////////////////////////////
// Block at 8210652Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210652C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210652C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210652C);
		  /* 8210652Ch */ case    0:  		/* mr R9, R4 */
		/* 8210652Ch case    0:*/		regs.R9 = regs.R4;
		/* 8210652Ch case    0:*/		return 0x82106530;
	}
	return 0x82106530;
} // Block from 8210652Ch-82106530h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82106530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106530);
		  /* 82106530h */ case    0:  		/* addi R7, R7, 1 */
		/* 82106530h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82106530h case    0:*/		return 0x82106534;
		  /* 82106534h */ case    1:  		/* stwx R9, <#[R11 + R8]> */
		/* 82106534h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82106534h case    1:*/		return 0x82106538;
		  /* 82106538h */ case    2:  		/* lwz R9, <#[R10 + 4]> */
		/* 82106538h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82106538h case    2:*/		return 0x8210653C;
		  /* 8210653Ch */ case    3:  		/* addi R11, R11, 4 */
		/* 8210653Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210653Ch case    3:*/		return 0x82106540;
		  /* 82106540h */ case    4:  		/* cmplw CR6, R7, R9 */
		/* 82106540h case    4:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 82106540h case    4:*/		return 0x82106544;
		  /* 82106544h */ case    5:  		/* bc 12, CR6_LT, -60 */
		/* 82106544h case    5:*/		if ( regs.CR[6].lt ) { return 0x82106508;  }
		/* 82106544h case    5:*/		return 0x82106548;
	}
	return 0x82106548;
} // Block from 82106530h-82106548h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82106548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106548);
		  /* 82106548h */ case    0:  		/* lwz R11, <#[R10 + 12]> */
		/* 82106548h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 82106548h case    0:*/		return 0x8210654C;
		  /* 8210654Ch */ case    1:  		/* li R7, 0 */
		/* 8210654Ch case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210654Ch case    1:*/		return 0x82106550;
		  /* 82106550h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82106550h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106550h case    2:*/		return 0x82106554;
		  /* 82106554h */ case    3:  		/* bc 4, CR6_GT, 72 */
		/* 82106554h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210659C;  }
		/* 82106554h case    3:*/		return 0x82106558;
		  /* 82106558h */ case    4:  		/* li R11, 0 */
		/* 82106558h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82106558h case    4:*/		return 0x8210655C;
		  /* 8210655Ch */ case    5:  		/* lwz R8, <#[R10 + 16]> */
		/* 8210655Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 8210655Ch case    5:*/		return 0x82106560;
		  /* 82106560h */ case    6:  		/* lwzx R9, <#[R8 + R11]> */
		/* 82106560h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82106560h case    6:*/		return 0x82106564;
		  /* 82106564h */ case    7:  		/* cmpwi CR6, R9, -1 */
		/* 82106564h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82106564h case    7:*/		return 0x82106568;
		  /* 82106568h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 82106568h case    8:*/		if ( regs.CR[6].eq ) { return 0x82106580;  }
		/* 82106568h case    8:*/		return 0x8210656C;
		  /* 8210656Ch */ case    9:  		/* lwz R31, <#[R3 + 20]> */
		/* 8210656Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000014) );
		/* 8210656Ch case    9:*/		return 0x82106570;
		  /* 82106570h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82106570h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82106570h case   10:*/		return 0x82106574;
		  /* 82106574h */ case   11:  		/* lwzx R9, <#[R9 + R31]> */
		/* 82106574h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R31 + 0x00000000) );
		/* 82106574h case   11:*/		return 0x82106578;
		  /* 82106578h */ case   12:  		/* lwz R9, <#[R9 + 48]> */
		/* 82106578h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000030) );
		/* 82106578h case   12:*/		return 0x8210657C;
		  /* 8210657Ch */ case   13:  		/* b 8 */
		/* 8210657Ch case   13:*/		return 0x82106584;
		/* 8210657Ch case   13:*/		return 0x82106580;
	}
	return 0x82106580;
} // Block from 82106548h-82106580h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82106580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106580);
		  /* 82106580h */ case    0:  		/* mr R9, R4 */
		/* 82106580h case    0:*/		regs.R9 = regs.R4;
		/* 82106580h case    0:*/		return 0x82106584;
	}
	return 0x82106584;
} // Block from 82106580h-82106584h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82106584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106584);
		  /* 82106584h */ case    0:  		/* stwx R9, <#[R8 + R11]> */
		/* 82106584h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82106584h case    0:*/		return 0x82106588;
		  /* 82106588h */ case    1:  		/* addi R7, R7, 1 */
		/* 82106588h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82106588h case    1:*/		return 0x8210658C;
		  /* 8210658Ch */ case    2:  		/* addi R11, R11, 4 */
		/* 8210658Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210658Ch case    2:*/		return 0x82106590;
		  /* 82106590h */ case    3:  		/* lwz R9, <#[R10 + 12]> */
		/* 82106590h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 82106590h case    3:*/		return 0x82106594;
		  /* 82106594h */ case    4:  		/* cmplw CR6, R7, R9 */
		/* 82106594h case    4:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 82106594h case    4:*/		return 0x82106598;
		  /* 82106598h */ case    5:  		/* bc 12, CR6_LT, -60 */
		/* 82106598h case    5:*/		if ( regs.CR[6].lt ) { return 0x8210655C;  }
		/* 82106598h case    5:*/		return 0x8210659C;
	}
	return 0x8210659C;
} // Block from 82106584h-8210659Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210659Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210659C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210659C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210659C);
		  /* 8210659Ch */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 8210659Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8210659Ch case    0:*/		return 0x821065A0;
		  /* 821065A0h */ case    1:  		/* addi R5, R5, 1 */
		/* 821065A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 821065A0h case    1:*/		return 0x821065A4;
		  /* 821065A4h */ case    2:  		/* addi R6, R6, 4 */
		/* 821065A4h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 821065A4h case    2:*/		return 0x821065A8;
		  /* 821065A8h */ case    3:  		/* cmplw CR6, R5, R11 */
		/* 821065A8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 821065A8h case    3:*/		return 0x821065AC;
		  /* 821065ACh */ case    4:  		/* bc 12, CR6_LT, -204 */
		/* 821065ACh case    4:*/		if ( regs.CR[6].lt ) { return 0x821064E0;  }
		/* 821065ACh case    4:*/		return 0x821065B0;
	}
	return 0x821065B0;
} // Block from 8210659Ch-821065B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821065B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821065B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821065B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821065B0);
		  /* 821065B0h */ case    0:  		/* li R3, 0 */
		/* 821065B0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821065B0h case    0:*/		return 0x821065B4;
		  /* 821065B4h */ case    1:  		/* ld R31, <#[R1 - 8]> */
		/* 821065B4h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821065B4h case    1:*/		return 0x821065B8;
		  /* 821065B8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 821065B8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821065B8h case    2:*/		return 0x821065BC;
	}
	return 0x821065BC;
} // Block from 821065B0h-821065BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821065BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821065BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821065BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821065BC);
		  /* 821065BCh */ case    0:  		/* nop */
		/* 821065BCh case    0:*/		cpu::op::nop();
		/* 821065BCh case    0:*/		return 0x821065C0;
	}
	return 0x821065C0;
} // Block from 821065BCh-821065C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821065C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821065C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821065C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821065C0);
		  /* 821065C0h */ case    0:  		/* mfspr R12, LR */
		/* 821065C0h case    0:*/		regs.R12 = regs.LR;
		/* 821065C0h case    0:*/		return 0x821065C4;
		  /* 821065C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821065C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821065C4h case    1:*/		return 0x821065C8;
		  /* 821065C8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821065C8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821065C8h case    2:*/		return 0x821065CC;
		  /* 821065CCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821065CCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821065CCh case    3:*/		return 0x821065D0;
		  /* 821065D0h */ case    4:  		/* lis R11, -32254 */
		/* 821065D0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 821065D0h case    4:*/		return 0x821065D4;
		  /* 821065D4h */ case    5:  		/* mr R31, R3 */
		/* 821065D4h case    5:*/		regs.R31 = regs.R3;
		/* 821065D4h case    5:*/		return 0x821065D8;
		  /* 821065D8h */ case    6:  		/* addi R11, R11, -14340 */
		/* 821065D8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC7FC);
		/* 821065D8h case    6:*/		return 0x821065DC;
		  /* 821065DCh */ case    7:  		/* rlwinm. R10, R4, 0, 31, 31 */
		/* 821065DCh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R4);
		/* 821065DCh case    7:*/		return 0x821065E0;
		  /* 821065E0h */ case    8:  		/* stw R11, <#[R3]> */
		/* 821065E0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821065E0h case    8:*/		return 0x821065E4;
		  /* 821065E4h */ case    9:  		/* bc 12, CR0_EQ, 8 */
		/* 821065E4h case    9:*/		if ( regs.CR[0].eq ) { return 0x821065EC;  }
		/* 821065E4h case    9:*/		return 0x821065E8;
		  /* 821065E8h */ case   10:  		/* bl -475776 */
		/* 821065E8h case   10:*/		regs.LR = 0x821065EC; return 0x82092368;
		/* 821065E8h case   10:*/		return 0x821065EC;
	}
	return 0x821065EC;
} // Block from 821065C0h-821065ECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821065ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821065EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821065EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821065EC);
		  /* 821065ECh */ case    0:  		/* mr R3, R31 */
		/* 821065ECh case    0:*/		regs.R3 = regs.R31;
		/* 821065ECh case    0:*/		return 0x821065F0;
		  /* 821065F0h */ case    1:  		/* addi R1, R1, 96 */
		/* 821065F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821065F0h case    1:*/		return 0x821065F4;
		  /* 821065F4h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821065F4h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821065F4h case    2:*/		return 0x821065F8;
	}
	return 0x821065F8;
} // Block from 821065ECh-821065F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821065F8h
// Function '?CompactPool_End@CProgram@D3DXShader@@IAAJPAU_D3DXCP_DATA@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821065F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821065F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821065F8);
		  /* 821065F8h */ case    0:  		/* mtspr LR, R12 */
		/* 821065F8h case    0:*/		regs.LR = regs.R12;
		/* 821065F8h case    0:*/		return 0x821065FC;
		  /* 821065FCh */ case    1:  		/* ld R31, <#[R1 - 16]> */
		/* 821065FCh case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821065FCh case    1:*/		return 0x82106600;
		  /* 82106600h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82106600h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82106600h case    2:*/		return 0x82106604;
	}
	return 0x82106604;
} // Block from 821065F8h-82106604h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82106604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106604);
		  /* 82106604h */ case    0:  		/* nop */
		/* 82106604h case    0:*/		cpu::op::nop();
		/* 82106604h case    0:*/		return 0x82106608;
	}
	return 0x82106608;
} // Block from 82106604h-82106608h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82106608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106608);
		  /* 82106608h */ case    0:  		/* mfspr R12, LR */
		/* 82106608h case    0:*/		regs.R12 = regs.LR;
		/* 82106608h case    0:*/		return 0x8210660C;
		  /* 8210660Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8210660Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8210660Ch case    1:*/		return 0x82106610;
		  /* 82106610h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82106610h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82106610h case    2:*/		return 0x82106614;
		  /* 82106614h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82106614h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82106614h case    3:*/		return 0x82106618;
		  /* 82106618h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82106618h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82106618h case    4:*/		return 0x8210661C;
		  /* 8210661Ch */ case    5:  		/* mr R31, R3 */
		/* 8210661Ch case    5:*/		regs.R31 = regs.R3;
		/* 8210661Ch case    5:*/		return 0x82106620;
		  /* 82106620h */ case    6:  		/* mr R30, R4 */
		/* 82106620h case    6:*/		regs.R30 = regs.R4;
		/* 82106620h case    6:*/		return 0x82106624;
		  /* 82106624h */ case    7:  		/* bl -19300 */
		/* 82106624h case    7:*/		regs.LR = 0x82106628; return 0x82101AC0;
		/* 82106624h case    7:*/		return 0x82106628;
		  /* 82106628h */ case    8:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 82106628h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 82106628h case    8:*/		return 0x8210662C;
		  /* 8210662Ch */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 8210662Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8210663C;  }
		/* 8210662Ch case    9:*/		return 0x82106630;
		  /* 82106630h */ case   10:  		/* lis R4, 9345 */
		/* 82106630h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82106630h case   10:*/		return 0x82106634;
		  /* 82106634h */ case   11:  		/* mr R3, R31 */
		/* 82106634h case   11:*/		regs.R3 = regs.R31;
		/* 82106634h case   11:*/		return 0x82106638;
		  /* 82106638h */ case   12:  		/* bl -516864 */
		/* 82106638h case   12:*/		regs.LR = 0x8210663C; return 0x82088338;
		/* 82106638h case   12:*/		return 0x8210663C;
	}
	return 0x8210663C;
} // Block from 82106608h-8210663Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8210663Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210663C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210663C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210663C);
		  /* 8210663Ch */ case    0:  		/* mr R3, R31 */
		/* 8210663Ch case    0:*/		regs.R3 = regs.R31;
		/* 8210663Ch case    0:*/		return 0x82106640;
		  /* 82106640h */ case    1:  		/* addi R1, R1, 112 */
		/* 82106640h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82106640h case    1:*/		return 0x82106644;
		  /* 82106644h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82106644h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82106644h case    2:*/		return 0x82106648;
		  /* 82106648h */ case    3:  		/* mtspr LR, R12 */
		/* 82106648h case    3:*/		regs.LR = regs.R12;
		/* 82106648h case    3:*/		return 0x8210664C;
		  /* 8210664Ch */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 8210664Ch case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8210664Ch case    4:*/		return 0x82106650;
		  /* 82106650h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82106650h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82106650h case    5:*/		return 0x82106654;
		  /* 82106654h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82106654h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82106654h case    6:*/		return 0x82106658;
	}
	return 0x82106658;
} // Block from 8210663Ch-82106658h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82106658h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106658);
		  /* 82106658h */ case    0:  		/* mfspr R12, LR */
		/* 82106658h case    0:*/		regs.R12 = regs.LR;
		/* 82106658h case    0:*/		return 0x8210665C;
		  /* 8210665Ch */ case    1:  		/* bl -480268 */
		/* 8210665Ch case    1:*/		regs.LR = 0x82106660; return 0x82091250;
		/* 8210665Ch case    1:*/		return 0x82106660;
		  /* 82106660h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82106660h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82106660h case    2:*/		return 0x82106664;
		  /* 82106664h */ case    3:  		/* mr R31, R3 */
		/* 82106664h case    3:*/		regs.R31 = regs.R3;
		/* 82106664h case    3:*/		return 0x82106668;
		  /* 82106668h */ case    4:  		/* cmplwi CR6, R5, 0 */
		/* 82106668h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82106668h case    4:*/		return 0x8210666C;
		  /* 8210666Ch */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 8210666Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8210667C;  }
		/* 8210666Ch case    5:*/		return 0x82106670;
		  /* 82106670h */ case    6:  		/* lis R3, -32768 */
		/* 82106670h case    6:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82106670h case    6:*/		return 0x82106674;
		  /* 82106674h */ case    7:  		/* ori R3, R3, 16389 */
		/* 82106674h case    7:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 82106674h case    7:*/		return 0x82106678;
		  /* 82106678h */ case    8:  		/* b 724 */
		/* 82106678h case    8:*/		return 0x8210694C;
		/* 82106678h case    8:*/		return 0x8210667C;
	}
	return 0x8210667C;
} // Block from 82106658h-8210667Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210667Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210667C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210667C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210667C);
		  /* 8210667Ch */ case    0:  		/* li R29, 0 */
		/* 8210667Ch case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210667Ch case    0:*/		return 0x82106680;
		  /* 82106680h */ case    1:  		/* stw R4, <#[R31 + 192]> */
		/* 82106680h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x000000C0) );
		/* 82106680h case    1:*/		return 0x82106684;
		  /* 82106684h */ case    2:  		/* stw R5, <#[R31 + 196]> */
		/* 82106684h case    2:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x000000C4) );
		/* 82106684h case    2:*/		return 0x82106688;
		  /* 82106688h */ case    3:  		/* lis R11, -32255 */
		/* 82106688h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82106688h case    3:*/		return 0x8210668C;
		  /* 8210668Ch */ case    4:  		/* stw R6, <#[R31 + 200]> */
		/* 8210668Ch case    4:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x000000C8) );
		/* 8210668Ch case    4:*/		return 0x82106690;
		  /* 82106690h */ case    5:  		/* li R30, -1 */
		/* 82106690h case    5:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 82106690h case    5:*/		return 0x82106694;
		  /* 82106694h */ case    6:  		/* stw R7, <#[R31 + 204]> */
		/* 82106694h case    6:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x000000CC) );
		/* 82106694h case    6:*/		return 0x82106698;
		  /* 82106698h */ case    7:  		/* addi R4, R11, 12560 */
		/* 82106698h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3110);
		/* 82106698h case    7:*/		return 0x8210669C;
		  /* 8210669Ch */ case    8:  		/* stw R29, <#[R31 + 212]> */
		/* 8210669Ch case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x000000D4) );
		/* 8210669Ch case    8:*/		return 0x821066A0;
		  /* 821066A0h */ case    9:  		/* mr R6, R30 */
		/* 821066A0h case    9:*/		regs.R6 = regs.R30;
		/* 821066A0h case    9:*/		return 0x821066A4;
		  /* 821066A4h */ case   10:  		/* stw R29, <#[R31 + 216]> */
		/* 821066A4h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x000000D8) );
		/* 821066A4h case   10:*/		return 0x821066A8;
		  /* 821066A8h */ case   11:  		/* li R7, 4 */
		/* 821066A8h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 821066A8h case   11:*/		return 0x821066AC;
		  /* 821066ACh */ case   12:  		/* stw R29, <#[R31 + 220]> */
		/* 821066ACh case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x000000DC) );
		/* 821066ACh case   12:*/		return 0x821066B0;
		  /* 821066B0h */ case   13:  		/* li R5, 0 */
		/* 821066B0h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821066B0h case   13:*/		return 0x821066B4;
		  /* 821066B4h */ case   14:  		/* mr R3, R31 */
		/* 821066B4h case   14:*/		regs.R3 = regs.R31;
		/* 821066B4h case   14:*/		return 0x821066B8;
		  /* 821066B8h */ case   15:  		/* bl -38192 */
		/* 821066B8h case   15:*/		regs.LR = 0x821066BC; return 0x820FD188;
		/* 821066B8h case   15:*/		return 0x821066BC;
		  /* 821066BCh */ case   16:  		/* stw R3, <#[R31 + 116]> */
		/* 821066BCh case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000074) );
		/* 821066BCh case   16:*/		return 0x821066C0;
		  /* 821066C0h */ case   17:  		/* lis R11, -32255 */
		/* 821066C0h case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821066C0h case   17:*/		return 0x821066C4;
		  /* 821066C4h */ case   18:  		/* mr R6, R30 */
		/* 821066C4h case   18:*/		regs.R6 = regs.R30;
		/* 821066C4h case   18:*/		return 0x821066C8;
		  /* 821066C8h */ case   19:  		/* addi R4, R11, -8824 */
		/* 821066C8h case   19:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFDD88);
		/* 821066C8h case   19:*/		return 0x821066CC;
		  /* 821066CCh */ case   20:  		/* li R7, 4 */
		/* 821066CCh case   20:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 821066CCh case   20:*/		return 0x821066D0;
		  /* 821066D0h */ case   21:  		/* li R5, 785 */
		/* 821066D0h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x311);
		/* 821066D0h case   21:*/		return 0x821066D4;
		  /* 821066D4h */ case   22:  		/* mr R3, R31 */
		/* 821066D4h case   22:*/		regs.R3 = regs.R31;
		/* 821066D4h case   22:*/		return 0x821066D8;
		  /* 821066D8h */ case   23:  		/* bl -38224 */
		/* 821066D8h case   23:*/		regs.LR = 0x821066DC; return 0x820FD188;
		/* 821066D8h case   23:*/		return 0x821066DC;
		  /* 821066DCh */ case   24:  		/* stw R3, <#[R31 + 120]> */
		/* 821066DCh case   24:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000078) );
		/* 821066DCh case   24:*/		return 0x821066E0;
		  /* 821066E0h */ case   25:  		/* lis R11, -32255 */
		/* 821066E0h case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821066E0h case   25:*/		return 0x821066E4;
		  /* 821066E4h */ case   26:  		/* mr R6, R30 */
		/* 821066E4h case   26:*/		regs.R6 = regs.R30;
		/* 821066E4h case   26:*/		return 0x821066E8;
		  /* 821066E8h */ case   27:  		/* addi R28, R11, -8736 */
		/* 821066E8h case   27:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFDDE0);
		/* 821066E8h case   27:*/		return 0x821066EC;
		  /* 821066ECh */ case   28:  		/* li R7, 4 */
		/* 821066ECh case   28:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 821066ECh case   28:*/		return 0x821066F0;
		  /* 821066F0h */ case   29:  		/* mr R4, R28 */
		/* 821066F0h case   29:*/		regs.R4 = regs.R28;
		/* 821066F0h case   29:*/		return 0x821066F4;
		  /* 821066F4h */ case   30:  		/* li R5, 593 */
		/* 821066F4h case   30:*/		cpu::op::li<0>(regs,&regs.R5,0x251);
		/* 821066F4h case   30:*/		return 0x821066F8;
		  /* 821066F8h */ case   31:  		/* mr R3, R31 */
		/* 821066F8h case   31:*/		regs.R3 = regs.R31;
		/* 821066F8h case   31:*/		return 0x821066FC;
		  /* 821066FCh */ case   32:  		/* bl -38260 */
		/* 821066FCh case   32:*/		regs.LR = 0x82106700; return 0x820FD188;
		/* 821066FCh case   32:*/		return 0x82106700;
	}
	return 0x82106700;
} // Block from 8210667Ch-82106700h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82106700h
// Function '?ReadWriteInfo@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106700);
		  /* 82106700h */ case    0:  		/* stw R3, <#[R31 + 124]> */
		/* 82106700h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000007C) );
		/* 82106700h case    0:*/		return 0x82106704;
		  /* 82106704h */ case    1:  		/* lis R11, -32255 */
		/* 82106704h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82106704h case    1:*/		return 0x82106708;
		  /* 82106708h */ case    2:  		/* mr R6, R30 */
		/* 82106708h case    2:*/		regs.R6 = regs.R30;
		/* 82106708h case    2:*/		return 0x8210670C;
		  /* 8210670Ch */ case    3:  		/* addi R4, R11, -8728 */
		/* 8210670Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFDDE8);
		/* 8210670Ch case    3:*/		return 0x82106710;
		  /* 82106710h */ case    4:  		/* li R7, 4 */
		/* 82106710h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 82106710h case    4:*/		return 0x82106714;
		  /* 82106714h */ case    5:  		/* li R5, 81 */
		/* 82106714h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x51);
		/* 82106714h case    5:*/		return 0x82106718;
		  /* 82106718h */ case    6:  		/* mr R3, R31 */
		/* 82106718h case    6:*/		regs.R3 = regs.R31;
		/* 82106718h case    6:*/		return 0x8210671C;
		  /* 8210671Ch */ case    7:  		/* bl -38292 */
		/* 8210671Ch case    7:*/		regs.LR = 0x82106720; return 0x820FD188;
		/* 8210671Ch case    7:*/		return 0x82106720;
		  /* 82106720h */ case    8:  		/* stw R3, <#[R31 + 128]> */
		/* 82106720h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000080) );
		/* 82106720h case    8:*/		return 0x82106724;
		  /* 82106724h */ case    9:  		/* lis R11, -32255 */
		/* 82106724h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82106724h case    9:*/		return 0x82106728;
		  /* 82106728h */ case   10:  		/* mr R6, R30 */
		/* 82106728h case   10:*/		regs.R6 = regs.R30;
		/* 82106728h case   10:*/		return 0x8210672C;
		  /* 8210672Ch */ case   11:  		/* addi R4, R11, -8832 */
		/* 8210672Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFDD80);
		/* 8210672Ch case   11:*/		return 0x82106730;
		  /* 82106730h */ case   12:  		/* li R7, 4 */
		/* 82106730h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 82106730h case   12:*/		return 0x82106734;
		  /* 82106734h */ case   13:  		/* li R5, 98 */
		/* 82106734h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x62);
		/* 82106734h case   13:*/		return 0x82106738;
		  /* 82106738h */ case   14:  		/* mr R3, R31 */
		/* 82106738h case   14:*/		regs.R3 = regs.R31;
		/* 82106738h case   14:*/		return 0x8210673C;
		  /* 8210673Ch */ case   15:  		/* bl -38324 */
		/* 8210673Ch case   15:*/		regs.LR = 0x82106740; return 0x820FD188;
		/* 8210673Ch case   15:*/		return 0x82106740;
		  /* 82106740h */ case   16:  		/* stw R3, <#[R31 + 132]> */
		/* 82106740h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000084) );
		/* 82106740h case   16:*/		return 0x82106744;
		  /* 82106744h */ case   17:  		/* lis R11, -32255 */
		/* 82106744h case   17:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82106744h case   17:*/		return 0x82106748;
		  /* 82106748h */ case   18:  		/* mr R6, R30 */
		/* 82106748h case   18:*/		regs.R6 = regs.R30;
		/* 82106748h case   18:*/		return 0x8210674C;
		  /* 8210674Ch */ case   19:  		/* addi R4, R11, -8732 */
		/* 8210674Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFDDE4);
		/* 8210674Ch case   19:*/		return 0x82106750;
		  /* 82106750h */ case   20:  		/* li R7, 4 */
		/* 82106750h case   20:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 82106750h case   20:*/		return 0x82106754;
		  /* 82106754h */ case   21:  		/* li R5, 3 */
		/* 82106754h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82106754h case   21:*/		return 0x82106758;
		  /* 82106758h */ case   22:  		/* mr R3, R31 */
		/* 82106758h case   22:*/		regs.R3 = regs.R31;
		/* 82106758h case   22:*/		return 0x8210675C;
		  /* 8210675Ch */ case   23:  		/* bl -38356 */
		/* 8210675Ch case   23:*/		regs.LR = 0x82106760; return 0x820FD188;
		/* 8210675Ch case   23:*/		return 0x82106760;
		  /* 82106760h */ case   24:  		/* stw R3, <#[R31 + 136]> */
		/* 82106760h case   24:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000088) );
		/* 82106760h case   24:*/		return 0x82106764;
		  /* 82106764h */ case   25:  		/* lis R11, -32255 */
		/* 82106764h case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82106764h case   25:*/		return 0x82106768;
		  /* 82106768h */ case   26:  		/* mr R6, R30 */
		/* 82106768h case   26:*/		regs.R6 = regs.R30;
		/* 82106768h case   26:*/		return 0x8210676C;
		  /* 8210676Ch */ case   27:  		/* addi R4, R11, -8740 */
		/* 8210676Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFDDDC);
		/* 8210676Ch case   27:*/		return 0x82106770;
		  /* 82106770h */ case   28:  		/* li R7, 4 */
		/* 82106770h case   28:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 82106770h case   28:*/		return 0x82106774;
		  /* 82106774h */ case   29:  		/* li R5, 6 */
		/* 82106774h case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 82106774h case   29:*/		return 0x82106778;
		  /* 82106778h */ case   30:  		/* mr R3, R31 */
		/* 82106778h case   30:*/		regs.R3 = regs.R31;
		/* 82106778h case   30:*/		return 0x8210677C;
		  /* 8210677Ch */ case   31:  		/* bl -38388 */
		/* 8210677Ch case   31:*/		regs.LR = 0x82106780; return 0x820FD188;
		/* 8210677Ch case   31:*/		return 0x82106780;
		  /* 82106780h */ case   32:  		/* stw R3, <#[R31 + 140]> */
		/* 82106780h case   32:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000008C) );
		/* 82106780h case   32:*/		return 0x82106784;
		  /* 82106784h */ case   33:  		/* lis R11, -32255 */
		/* 82106784h case   33:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82106784h case   33:*/		return 0x82106788;
		  /* 82106788h */ case   34:  		/* mr R6, R30 */
		/* 82106788h case   34:*/		regs.R6 = regs.R30;
		/* 82106788h case   34:*/		return 0x8210678C;
		  /* 8210678Ch */ case   35:  		/* addi R27, R11, -8828 */
		/* 8210678Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFDD84);
		/* 8210678Ch case   35:*/		return 0x82106790;
		  /* 82106790h */ case   36:  		/* li R7, 4 */
		/* 82106790h case   36:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 82106790h case   36:*/		return 0x82106794;
		  /* 82106794h */ case   37:  		/* mr R4, R27 */
		/* 82106794h case   37:*/		regs.R4 = regs.R27;
		/* 82106794h case   37:*/		return 0x82106798;
		  /* 82106798h */ case   38:  		/* li R5, 10 */
		/* 82106798h case   38:*/		cpu::op::li<0>(regs,&regs.R5,0xA);
		/* 82106798h case   38:*/		return 0x8210679C;
		  /* 8210679Ch */ case   39:  		/* mr R3, R31 */
		/* 8210679Ch case   39:*/		regs.R3 = regs.R31;
		/* 8210679Ch case   39:*/		return 0x821067A0;
		  /* 821067A0h */ case   40:  		/* bl -38424 */
		/* 821067A0h case   40:*/		regs.LR = 0x821067A4; return 0x820FD188;
		/* 821067A0h case   40:*/		return 0x821067A4;
		  /* 821067A4h */ case   41:  		/* lis R11, -32255 */
		/* 821067A4h case   41:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821067A4h case   41:*/		return 0x821067A8;
		  /* 821067A8h */ case   42:  		/* stw R3, <#[R31 + 144]> */
		/* 821067A8h case   42:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000090) );
		/* 821067A8h case   42:*/		return 0x821067AC;
		  /* 821067ACh */ case   43:  		/* li R7, 4 */
		/* 821067ACh case   43:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 821067ACh case   43:*/		return 0x821067B0;
		  /* 821067B0h */ case   44:  		/* addi R4, R11, -8796 */
		/* 821067B0h case   44:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFDDA4);
		/* 821067B0h case   44:*/		return 0x821067B4;
		  /* 821067B4h */ case   45:  		/* mr R6, R30 */
		/* 821067B4h case   45:*/		regs.R6 = regs.R30;
		/* 821067B4h case   45:*/		return 0x821067B8;
		  /* 821067B8h */ case   46:  		/* li R5, 721 */
		/* 821067B8h case   46:*/		cpu::op::li<0>(regs,&regs.R5,0x2D1);
		/* 821067B8h case   46:*/		return 0x821067BC;
		  /* 821067BCh */ case   47:  		/* mr R3, R31 */
		/* 821067BCh case   47:*/		regs.R3 = regs.R31;
		/* 821067BCh case   47:*/		return 0x821067C0;
		  /* 821067C0h */ case   48:  		/* bl -38456 */
		/* 821067C0h case   48:*/		regs.LR = 0x821067C4; return 0x820FD188;
		/* 821067C0h case   48:*/		return 0x821067C4;
		  /* 821067C4h */ case   49:  		/* stw R3, <#[R31 + 148]> */
		/* 821067C4h case   49:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000094) );
		/* 821067C4h case   49:*/		return 0x821067C8;
		  /* 821067C8h */ case   50:  		/* lis R11, -32255 */
		/* 821067C8h case   50:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 821067C8h case   50:*/		return 0x821067CC;
		  /* 821067CCh */ case   51:  		/* mr R6, R30 */
		/* 821067CCh case   51:*/		regs.R6 = regs.R30;
		/* 821067CCh case   51:*/		return 0x821067D0;
		  /* 821067D0h */ case   52:  		/* addi R26, R11, -8780 */
		/* 821067D0h case   52:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0xFFFFDDB4);
		/* 821067D0h case   52:*/		return 0x821067D4;
		  /* 821067D4h */ case   53:  		/* li R7, 4 */
		/* 821067D4h case   53:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 821067D4h case   53:*/		return 0x821067D8;
		  /* 821067D8h */ case   54:  		/* mr R4, R26 */
		/* 821067D8h case   54:*/		regs.R4 = regs.R26;
		/* 821067D8h case   54:*/		return 0x821067DC;
		  /* 821067DCh */ case   55:  		/* li R5, 4099 */
		/* 821067DCh case   55:*/		cpu::op::li<0>(regs,&regs.R5,0x1003);
		/* 821067DCh case   55:*/		return 0x821067E0;
		  /* 821067E0h */ case   56:  		/* mr R3, R31 */
		/* 821067E0h case   56:*/		regs.R3 = regs.R31;
		/* 821067E0h case   56:*/		return 0x821067E4;
		  /* 821067E4h */ case   57:  		/* bl -38492 */
		/* 821067E4h case   57:*/		regs.LR = 0x821067E8; return 0x820FD188;
		/* 821067E4h case   57:*/		return 0x821067E8;
		  /* 821067E8h */ case   58:  		/* stw R3, <#[R31 + 152]> */
		/* 821067E8h case   58:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000098) );
		/* 821067E8h case   58:*/		return 0x821067EC;
		  /* 821067ECh */ case   59:  		/* mr R6, R30 */
		/* 821067ECh case   59:*/		regs.R6 = regs.R30;
		/* 821067ECh case   59:*/		return 0x821067F0;
		  /* 821067F0h */ case   60:  		/* mr R4, R28 */
		/* 821067F0h case   60:*/		regs.R4 = regs.R28;
		/* 821067F0h case   60:*/		return 0x821067F4;
		  /* 821067F4h */ case   61:  		/* li R7, 4 */
		/* 821067F4h case   61:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 821067F4h case   61:*/		return 0x821067F8;
		  /* 821067F8h */ case   62:  		/* li R5, 8785 */
		/* 821067F8h case   62:*/		cpu::op::li<0>(regs,&regs.R5,0x2251);
		/* 821067F8h case   62:*/		return 0x821067FC;
		  /* 821067FCh */ case   63:  		/* mr R3, R31 */
		/* 821067FCh case   63:*/		regs.R3 = regs.R31;
		/* 821067FCh case   63:*/		return 0x82106800;
		  /* 82106800h */ case   64:  		/* bl -38520 */
		/* 82106800h case   64:*/		regs.LR = 0x82106804; return 0x820FD188;
		/* 82106800h case   64:*/		return 0x82106804;
		  /* 82106804h */ case   65:  		/* stw R3, <#[R31 + 156]> */
		/* 82106804h case   65:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000009C) );
		/* 82106804h case   65:*/		return 0x82106808;
		  /* 82106808h */ case   66:  		/* mr R6, R30 */
		/* 82106808h case   66:*/		regs.R6 = regs.R30;
		/* 82106808h case   66:*/		return 0x8210680C;
		  /* 8210680Ch */ case   67:  		/* mr R4, R27 */
		/* 8210680Ch case   67:*/		regs.R4 = regs.R27;
		/* 8210680Ch case   67:*/		return 0x82106810;
		  /* 82106810h */ case   68:  		/* li R7, 4 */
		/* 82106810h case   68:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 82106810h case   68:*/		return 0x82106814;
		  /* 82106814h */ case   69:  		/* li R5, 16394 */
		/* 82106814h case   69:*/		cpu::op::li<0>(regs,&regs.R5,0x400A);
		/* 82106814h case   69:*/		return 0x82106818;
		  /* 82106818h */ case   70:  		/* mr R3, R31 */
		/* 82106818h case   70:*/		regs.R3 = regs.R31;
		/* 82106818h case   70:*/		return 0x8210681C;
		  /* 8210681Ch */ case   71:  		/* bl -38548 */
		/* 8210681Ch case   71:*/		regs.LR = 0x82106820; return 0x820FD188;
		/* 8210681Ch case   71:*/		return 0x82106820;
		  /* 82106820h */ case   72:  		/* stw R3, <#[R31 + 160]> */
		/* 82106820h case   72:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000A0) );
		/* 82106820h case   72:*/		return 0x82106824;
		  /* 82106824h */ case   73:  		/* lis R11, -32254 */
		/* 82106824h case   73:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 82106824h case   73:*/		return 0x82106828;
		  /* 82106828h */ case   74:  		/* lis R5, 0 */
		/* 82106828h case   74:*/		cpu::op::lis<0>(regs,&regs.R5,0x0);
		/* 82106828h case   74:*/		return 0x8210682C;
		  /* 8210682Ch */ case   75:  		/* mr R6, R30 */
		/* 8210682Ch case   75:*/		regs.R6 = regs.R30;
		/* 8210682Ch case   75:*/		return 0x82106830;
		  /* 82106830h */ case   76:  		/* addi R4, R11, -14308 */
		/* 82106830h case   76:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC81C);
		/* 82106830h case   76:*/		return 0x82106834;
		  /* 82106834h */ case   77:  		/* li R7, 4 */
		/* 82106834h case   77:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 82106834h case   77:*/		return 0x82106838;
		  /* 82106838h */ case   78:  		/* ori R5, R5, 49162 */
		/* 82106838h case   78:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0xC00A);
		/* 82106838h case   78:*/		return 0x8210683C;
		  /* 8210683Ch */ case   79:  		/* mr R3, R31 */
		/* 8210683Ch case   79:*/		regs.R3 = regs.R31;
		/* 8210683Ch case   79:*/		return 0x82106840;
		  /* 82106840h */ case   80:  		/* bl -38584 */
		/* 82106840h case   80:*/		regs.LR = 0x82106844; return 0x820FD188;
		/* 82106840h case   80:*/		return 0x82106844;
		  /* 82106844h */ case   81:  		/* stw R3, <#[R31 + 164]> */
		/* 82106844h case   81:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000A4) );
		/* 82106844h case   81:*/		return 0x82106848;
		  /* 82106848h */ case   82:  		/* lis R11, -32254 */
		/* 82106848h case   82:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 82106848h case   82:*/		return 0x8210684C;
		  /* 8210684Ch */ case   83:  		/* lis R5, 1 */
		/* 8210684Ch case   83:*/		cpu::op::lis<0>(regs,&regs.R5,0x1);
		/* 8210684Ch case   83:*/		return 0x82106850;
		  /* 82106850h */ case   84:  		/* li R7, 4 */
		/* 82106850h case   84:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 82106850h case   84:*/		return 0x82106854;
		  /* 82106854h */ case   85:  		/* addi R4, R11, -14312 */
		/* 82106854h case   85:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC818);
		/* 82106854h case   85:*/		return 0x82106858;
		  /* 82106858h */ case   86:  		/* li R6, 0 */
		/* 82106858h case   86:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82106858h case   86:*/		return 0x8210685C;
		  /* 8210685Ch */ case   87:  		/* ori R5, R5, 66 */
		/* 8210685Ch case   87:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x42);
		/* 8210685Ch case   87:*/		return 0x82106860;
		  /* 82106860h */ case   88:  		/* mr R3, R31 */
		/* 82106860h case   88:*/		regs.R3 = regs.R31;
		/* 82106860h case   88:*/		return 0x82106864;
		  /* 82106864h */ case   89:  		/* bl -38620 */
		/* 82106864h case   89:*/		regs.LR = 0x82106868; return 0x820FD188;
		/* 82106864h case   89:*/		return 0x82106868;
		  /* 82106868h */ case   90:  		/* stw R3, <#[R31 + 168]> */
		/* 82106868h case   90:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000A8) );
		/* 82106868h case   90:*/		return 0x8210686C;
		  /* 8210686Ch */ case   91:  		/* lis R11, -32255 */
		/* 8210686Ch case   91:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8210686Ch case   91:*/		return 0x82106870;
		  /* 82106870h */ case   92:  		/* lis R5, 2 */
		/* 82106870h case   92:*/		cpu::op::lis<0>(regs,&regs.R5,0x2);
		/* 82106870h case   92:*/		return 0x82106874;
		  /* 82106874h */ case   93:  		/* mr R6, R30 */
		/* 82106874h case   93:*/		regs.R6 = regs.R30;
		/* 82106874h case   93:*/		return 0x82106878;
		  /* 82106878h */ case   94:  		/* addi R4, R11, 12556 */
		/* 82106878h case   94:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x310C);
		/* 82106878h case   94:*/		return 0x8210687C;
		  /* 8210687Ch */ case   95:  		/* li R7, 4 */
		/* 8210687Ch case   95:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 8210687Ch case   95:*/		return 0x82106880;
		  /* 82106880h */ case   96:  		/* ori R5, R5, 3 */
		/* 82106880h case   96:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x3);
		/* 82106880h case   96:*/		return 0x82106884;
		  /* 82106884h */ case   97:  		/* mr R3, R31 */
		/* 82106884h case   97:*/		regs.R3 = regs.R31;
		/* 82106884h case   97:*/		return 0x82106888;
		  /* 82106888h */ case   98:  		/* bl -38656 */
		/* 82106888h case   98:*/		regs.LR = 0x8210688C; return 0x820FD188;
		/* 82106888h case   98:*/		return 0x8210688C;
		  /* 8210688Ch */ case   99:  		/* stw R3, <#[R31 + 172]> */
		/* 8210688Ch case   99:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8210688Ch case   99:*/		return 0x82106890;
		  /* 82106890h */ case  100:  		/* lis R5, 4 */
		/* 82106890h case  100:*/		cpu::op::lis<0>(regs,&regs.R5,0x4);
		/* 82106890h case  100:*/		return 0x82106894;
		  /* 82106894h */ case  101:  		/* mr R6, R30 */
		/* 82106894h case  101:*/		regs.R6 = regs.R30;
		/* 82106894h case  101:*/		return 0x82106898;
		  /* 82106898h */ case  102:  		/* mr R4, R26 */
		/* 82106898h case  102:*/		regs.R4 = regs.R26;
		/* 82106898h case  102:*/		return 0x8210689C;
		  /* 8210689Ch */ case  103:  		/* li R7, 4 */
		/* 8210689Ch case  103:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 8210689Ch case  103:*/		return 0x821068A0;
		  /* 821068A0h */ case  104:  		/* ori R5, R5, 529 */
		/* 821068A0h case  104:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x211);
		/* 821068A0h case  104:*/		return 0x821068A4;
		  /* 821068A4h */ case  105:  		/* mr R3, R31 */
		/* 821068A4h case  105:*/		regs.R3 = regs.R31;
		/* 821068A4h case  105:*/		return 0x821068A8;
		  /* 821068A8h */ case  106:  		/* bl -38688 */
		/* 821068A8h case  106:*/		regs.LR = 0x821068AC; return 0x820FD188;
		/* 821068A8h case  106:*/		return 0x821068AC;
		  /* 821068ACh */ case  107:  		/* stw R3, <#[R31 + 176]> */
		/* 821068ACh case  107:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000B0) );
		/* 821068ACh case  107:*/		return 0x821068B0;
		  /* 821068B0h */ case  108:  		/* lis R11, -32254 */
		/* 821068B0h case  108:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 821068B0h case  108:*/		return 0x821068B4;
		  /* 821068B4h */ case  109:  		/* mr R6, R30 */
		/* 821068B4h case  109:*/		regs.R6 = regs.R30;
		/* 821068B4h case  109:*/		return 0x821068B8;
		  /* 821068B8h */ case  110:  		/* addi R4, R11, -14316 */
		/* 821068B8h case  110:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC814);
		/* 821068B8h case  110:*/		return 0x821068BC;
		  /* 821068BCh */ case  111:  		/* li R7, 4 */
		/* 821068BCh case  111:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 821068BCh case  111:*/		return 0x821068C0;
		  /* 821068C0h */ case  112:  		/* li R5, 8290 */
		/* 821068C0h case  112:*/		cpu::op::li<0>(regs,&regs.R5,0x2062);
		/* 821068C0h case  112:*/		return 0x821068C4;
		  /* 821068C4h */ case  113:  		/* mr R3, R31 */
		/* 821068C4h case  113:*/		regs.R3 = regs.R31;
		/* 821068C4h case  113:*/		return 0x821068C8;
		  /* 821068C8h */ case  114:  		/* bl -38720 */
		/* 821068C8h case  114:*/		regs.LR = 0x821068CC; return 0x820FD188;
		/* 821068C8h case  114:*/		return 0x821068CC;
		  /* 821068CCh */ case  115:  		/* stw R3, <#[R31 + 180]> */
		/* 821068CCh case  115:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000B4) );
		/* 821068CCh case  115:*/		return 0x821068D0;
		  /* 821068D0h */ case  116:  		/* lis R11, -32254 */
		/* 821068D0h case  116:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8202);
		/* 821068D0h case  116:*/		return 0x821068D4;
		  /* 821068D4h */ case  117:  		/* lis R5, 4 */
		/* 821068D4h case  117:*/		cpu::op::lis<0>(regs,&regs.R5,0x4);
		/* 821068D4h case  117:*/		return 0x821068D8;
		  /* 821068D8h */ case  118:  		/* li R7, 4 */
		/* 821068D8h case  118:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 821068D8h case  118:*/		return 0x821068DC;
		  /* 821068DCh */ case  119:  		/* addi R4, R11, -14320 */
		/* 821068DCh case  119:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC810);
		/* 821068DCh case  119:*/		return 0x821068E0;
		  /* 821068E0h */ case  120:  		/* mr R6, R30 */
		/* 821068E0h case  120:*/		regs.R6 = regs.R30;
		/* 821068E0h case  120:*/		return 0x821068E4;
		  /* 821068E4h */ case  121:  		/* ori R5, R5, 98 */
		/* 821068E4h case  121:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x62);
		/* 821068E4h case  121:*/		return 0x821068E8;
		  /* 821068E8h */ case  122:  		/* mr R3, R31 */
		/* 821068E8h case  122:*/		regs.R3 = regs.R31;
		/* 821068E8h case  122:*/		return 0x821068EC;
		  /* 821068ECh */ case  123:  		/* bl -38756 */
		/* 821068ECh case  123:*/		regs.LR = 0x821068F0; return 0x820FD188;
		/* 821068ECh case  123:*/		return 0x821068F0;
		  /* 821068F0h */ case  124:  		/* lwz R11, <#[R31 + 4]> */
		/* 821068F0h case  124:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821068F0h case  124:*/		return 0x821068F4;
		  /* 821068F4h */ case  125:  		/* stw R3, <#[R31 + 184]> */
		/* 821068F4h case  125:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000B8) );
		/* 821068F4h case  125:*/		return 0x821068F8;
		  /* 821068F8h */ case  126:  		/* cmplwi CR6, R11, 18 */
		/* 821068F8h case  126:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000012);
		/* 821068F8h case  126:*/		return 0x821068FC;
		  /* 821068FCh */ case  127:  		/* bc 12, CR6_EQ, 16 */
		/* 821068FCh case  127:*/		if ( regs.CR[6].eq ) { return 0x8210690C;  }
		/* 821068FCh case  127:*/		return 0x82106900;
		  /* 82106900h */ case  128:  		/* lis R3, -32761 */
		/* 82106900h case  128:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82106900h case  128:*/		return 0x82106904;
		  /* 82106904h */ case  129:  		/* ori R3, R3, 14 */
		/* 82106904h case  129:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82106904h case  129:*/		return 0x82106908;
		  /* 82106908h */ case  130:  		/* b 68 */
		/* 82106908h case  130:*/		return 0x8210694C;
		/* 82106908h case  130:*/		return 0x8210690C;
	}
	return 0x8210690C;
} // Block from 82106700h-8210690Ch (131 instructions)

//////////////////////////////////////////////////////
// Block at 8210690Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210690C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210690C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210690C);
		  /* 8210690Ch */ case    0:  		/* li R5, 76 */
		/* 8210690Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x4C);
		/* 8210690Ch case    0:*/		return 0x82106910;
		  /* 82106910h */ case    1:  		/* li R4, 0 */
		/* 82106910h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82106910h case    1:*/		return 0x82106914;
		  /* 82106914h */ case    2:  		/* addi R3, R31, 40 */
		/* 82106914h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x28);
		/* 82106914h case    2:*/		return 0x82106918;
		  /* 82106918h */ case    3:  		/* bl -480728 */
		/* 82106918h case    3:*/		regs.LR = 0x8210691C; return 0x82091340;
		/* 82106918h case    3:*/		return 0x8210691C;
		  /* 8210691Ch */ case    4:  		/* lwz R11, <#[R31]> */
		/* 8210691Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8210691Ch case    4:*/		return 0x82106920;
		  /* 82106920h */ case    5:  		/* mr R3, R31 */
		/* 82106920h case    5:*/		regs.R3 = regs.R31;
		/* 82106920h case    5:*/		return 0x82106924;
		  /* 82106924h */ case    6:  		/* lwz R11, <#[R11 + 12]> */
		/* 82106924h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82106924h case    6:*/		return 0x82106928;
		  /* 82106928h */ case    7:  		/* mtspr CTR, R11 */
		/* 82106928h case    7:*/		regs.CTR = regs.R11;
		/* 82106928h case    7:*/		return 0x8210692C;
		  /* 8210692Ch */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 8210692Ch case    8:*/		if ( 1 ) { regs.LR = 0x82106930; return (uint32)regs.CTR; }
		/* 8210692Ch case    8:*/		return 0x82106930;
		  /* 82106930h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 82106930h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82106930h case    9:*/		return 0x82106934;
		  /* 82106934h */ case   10:  		/* bc 12, CR0_LT, 24 */
		/* 82106934h case   10:*/		if ( regs.CR[0].lt ) { return 0x8210694C;  }
		/* 82106934h case   10:*/		return 0x82106938;
		  /* 82106938h */ case   11:  		/* lis R4, 9345 */
		/* 82106938h case   11:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82106938h case   11:*/		return 0x8210693C;
		  /* 8210693Ch */ case   12:  		/* lwz R3, <#[R31 + 208]> */
		/* 8210693Ch case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000D0) );
		/* 8210693Ch case   12:*/		return 0x82106940;
		  /* 82106940h */ case   13:  		/* bl -517640 */
		/* 82106940h case   13:*/		regs.LR = 0x82106944; return 0x82088338;
		/* 82106940h case   13:*/		return 0x82106944;
		  /* 82106944h */ case   14:  		/* li R3, 0 */
		/* 82106944h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82106944h case   14:*/		return 0x82106948;
		  /* 82106948h */ case   15:  		/* stw R29, <#[R31 + 208]> */
		/* 82106948h case   15:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x000000D0) );
		/* 82106948h case   15:*/		return 0x8210694C;
	}
	return 0x8210694C;
} // Block from 8210690Ch-8210694Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210694Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210694C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210694C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210694C);
		  /* 8210694Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 8210694Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8210694Ch case    0:*/		return 0x82106950;
		  /* 82106950h */ case    1:  		/* b -480944 */
		/* 82106950h case    1:*/		return 0x820912A0;
		/* 82106950h case    1:*/		return 0x82106954;
		  /* 82106954h */ case    2:  		/* nop */
		/* 82106954h case    2:*/		cpu::op::nop();
		/* 82106954h case    2:*/		return 0x82106958;
	}
	return 0x82106958;
} // Block from 8210694Ch-82106958h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82106958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106958);
		  /* 82106958h */ case    0:  		/* mfspr R12, LR */
		/* 82106958h case    0:*/		regs.R12 = regs.LR;
		/* 82106958h case    0:*/		return 0x8210695C;
		  /* 8210695Ch */ case    1:  		/* bl -481032 */
		/* 8210695Ch case    1:*/		regs.LR = 0x82106960; return 0x82091254;
		/* 8210695Ch case    1:*/		return 0x82106960;
		  /* 82106960h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82106960h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82106960h case    2:*/		return 0x82106964;
		  /* 82106964h */ case    3:  		/* mr R31, R3 */
		/* 82106964h case    3:*/		regs.R31 = regs.R3;
		/* 82106964h case    3:*/		return 0x82106968;
		  /* 82106968h */ case    4:  		/* mr R30, R4 */
		/* 82106968h case    4:*/		regs.R30 = regs.R4;
		/* 82106968h case    4:*/		return 0x8210696C;
		  /* 8210696Ch */ case    5:  		/* mr R28, R5 */
		/* 8210696Ch case    5:*/		regs.R28 = regs.R5;
		/* 8210696Ch case    5:*/		return 0x82106970;
		  /* 82106970h */ case    6:  		/* mr R27, R6 */
		/* 82106970h case    6:*/		regs.R27 = regs.R6;
		/* 82106970h case    6:*/		return 0x82106974;
		  /* 82106974h */ case    7:  		/* bl -37700 */
		/* 82106974h case    7:*/		regs.LR = 0x82106978; return 0x820FD630;
		/* 82106974h case    7:*/		return 0x82106978;
		  /* 82106978h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 82106978h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82106978h case    8:*/		return 0x8210697C;
		  /* 8210697Ch */ case    9:  		/* bc 12, CR0_LT, 252 */
		/* 8210697Ch case    9:*/		if ( regs.CR[0].lt ) { return 0x82106A78;  }
		/* 8210697Ch case    9:*/		return 0x82106980;
		  /* 82106980h */ case   10:  		/* lwz R11, <#[R30 + 192]> */
		/* 82106980h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000C0) );
		/* 82106980h case   10:*/		return 0x82106984;
		  /* 82106984h */ case   11:  		/* li R29, 0 */
		/* 82106984h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82106984h case   11:*/		return 0x82106988;
		  /* 82106988h */ case   12:  		/* li R5, 76 */
		/* 82106988h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x4C);
		/* 82106988h case   12:*/		return 0x8210698C;
		  /* 8210698Ch */ case   13:  		/* li R4, 0 */
		/* 8210698Ch case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210698Ch case   13:*/		return 0x82106990;
		  /* 82106990h */ case   14:  		/* addi R3, R31, 40 */
		/* 82106990h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x28);
		/* 82106990h case   14:*/		return 0x82106994;
		  /* 82106994h */ case   15:  		/* stw R11, <#[R31 + 192]> */
		/* 82106994h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000C0) );
		/* 82106994h case   15:*/		return 0x82106998;
		  /* 82106998h */ case   16:  		/* lwz R11, <#[R30 + 196]> */
		/* 82106998h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000C4) );
		/* 82106998h case   16:*/		return 0x8210699C;
		  /* 8210699Ch */ case   17:  		/* stw R11, <#[R31 + 196]> */
		/* 8210699Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 8210699Ch case   17:*/		return 0x821069A0;
		  /* 821069A0h */ case   18:  		/* stw R28, <#[R31 + 200]> */
		/* 821069A0h case   18:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x000000C8) );
		/* 821069A0h case   18:*/		return 0x821069A4;
		  /* 821069A4h */ case   19:  		/* stw R27, <#[R31 + 204]> */
		/* 821069A4h case   19:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x000000CC) );
		/* 821069A4h case   19:*/		return 0x821069A8;
		  /* 821069A8h */ case   20:  		/* stw R29, <#[R31 + 212]> */
		/* 821069A8h case   20:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x000000D4) );
		/* 821069A8h case   20:*/		return 0x821069AC;
		  /* 821069ACh */ case   21:  		/* stw R29, <#[R31 + 216]> */
		/* 821069ACh case   21:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x000000D8) );
		/* 821069ACh case   21:*/		return 0x821069B0;
		  /* 821069B0h */ case   22:  		/* stw R29, <#[R31 + 220]> */
		/* 821069B0h case   22:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x000000DC) );
		/* 821069B0h case   22:*/		return 0x821069B4;
		  /* 821069B4h */ case   23:  		/* lwz R11, <#[R30 + 116]> */
		/* 821069B4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000074) );
		/* 821069B4h case   23:*/		return 0x821069B8;
		  /* 821069B8h */ case   24:  		/* stw R11, <#[R31 + 116]> */
		/* 821069B8h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000074) );
		/* 821069B8h case   24:*/		return 0x821069BC;
		  /* 821069BCh */ case   25:  		/* lwz R11, <#[R30 + 120]> */
		/* 821069BCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000078) );
		/* 821069BCh case   25:*/		return 0x821069C0;
		  /* 821069C0h */ case   26:  		/* stw R11, <#[R31 + 120]> */
		/* 821069C0h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000078) );
		/* 821069C0h case   26:*/		return 0x821069C4;
		  /* 821069C4h */ case   27:  		/* lwz R11, <#[R30 + 124]> */
		/* 821069C4h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000007C) );
		/* 821069C4h case   27:*/		return 0x821069C8;
		  /* 821069C8h */ case   28:  		/* stw R11, <#[R31 + 124]> */
		/* 821069C8h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000007C) );
		/* 821069C8h case   28:*/		return 0x821069CC;
		  /* 821069CCh */ case   29:  		/* lwz R11, <#[R30 + 128]> */
		/* 821069CCh case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000080) );
		/* 821069CCh case   29:*/		return 0x821069D0;
		  /* 821069D0h */ case   30:  		/* stw R11, <#[R31 + 128]> */
		/* 821069D0h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000080) );
		/* 821069D0h case   30:*/		return 0x821069D4;
		  /* 821069D4h */ case   31:  		/* lwz R11, <#[R30 + 132]> */
		/* 821069D4h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 821069D4h case   31:*/		return 0x821069D8;
		  /* 821069D8h */ case   32:  		/* stw R11, <#[R31 + 132]> */
		/* 821069D8h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000084) );
		/* 821069D8h case   32:*/		return 0x821069DC;
		  /* 821069DCh */ case   33:  		/* lwz R11, <#[R30 + 136]> */
		/* 821069DCh case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000088) );
		/* 821069DCh case   33:*/		return 0x821069E0;
		  /* 821069E0h */ case   34:  		/* stw R11, <#[R31 + 136]> */
		/* 821069E0h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000088) );
		/* 821069E0h case   34:*/		return 0x821069E4;
		  /* 821069E4h */ case   35:  		/* lwz R11, <#[R30 + 140]> */
		/* 821069E4h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000008C) );
		/* 821069E4h case   35:*/		return 0x821069E8;
		  /* 821069E8h */ case   36:  		/* stw R11, <#[R31 + 140]> */
		/* 821069E8h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000008C) );
		/* 821069E8h case   36:*/		return 0x821069EC;
		  /* 821069ECh */ case   37:  		/* lwz R11, <#[R30 + 144]> */
		/* 821069ECh case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000090) );
		/* 821069ECh case   37:*/		return 0x821069F0;
		  /* 821069F0h */ case   38:  		/* stw R11, <#[R31 + 144]> */
		/* 821069F0h case   38:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000090) );
		/* 821069F0h case   38:*/		return 0x821069F4;
		  /* 821069F4h */ case   39:  		/* lwz R11, <#[R30 + 148]> */
		/* 821069F4h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000094) );
		/* 821069F4h case   39:*/		return 0x821069F8;
		  /* 821069F8h */ case   40:  		/* stw R11, <#[R31 + 148]> */
		/* 821069F8h case   40:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000094) );
		/* 821069F8h case   40:*/		return 0x821069FC;
		  /* 821069FCh */ case   41:  		/* lwz R11, <#[R30 + 152]> */
		/* 821069FCh case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000098) );
		/* 821069FCh case   41:*/		return 0x82106A00;
		  /* 82106A00h */ case   42:  		/* stw R11, <#[R31 + 152]> */
		/* 82106A00h case   42:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000098) );
		/* 82106A00h case   42:*/		return 0x82106A04;
		  /* 82106A04h */ case   43:  		/* lwz R11, <#[R30 + 156]> */
		/* 82106A04h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000009C) );
		/* 82106A04h case   43:*/		return 0x82106A08;
		  /* 82106A08h */ case   44:  		/* stw R11, <#[R31 + 156]> */
		/* 82106A08h case   44:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000009C) );
		/* 82106A08h case   44:*/		return 0x82106A0C;
		  /* 82106A0Ch */ case   45:  		/* lwz R11, <#[R30 + 160]> */
		/* 82106A0Ch case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000A0) );
		/* 82106A0Ch case   45:*/		return 0x82106A10;
		  /* 82106A10h */ case   46:  		/* stw R11, <#[R31 + 160]> */
		/* 82106A10h case   46:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000A0) );
		/* 82106A10h case   46:*/		return 0x82106A14;
		  /* 82106A14h */ case   47:  		/* lwz R11, <#[R30 + 164]> */
		/* 82106A14h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000A4) );
		/* 82106A14h case   47:*/		return 0x82106A18;
		  /* 82106A18h */ case   48:  		/* stw R11, <#[R31 + 164]> */
		/* 82106A18h case   48:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000A4) );
		/* 82106A18h case   48:*/		return 0x82106A1C;
		  /* 82106A1Ch */ case   49:  		/* lwz R11, <#[R30 + 168]> */
		/* 82106A1Ch case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000A8) );
		/* 82106A1Ch case   49:*/		return 0x82106A20;
		  /* 82106A20h */ case   50:  		/* stw R11, <#[R31 + 168]> */
		/* 82106A20h case   50:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000A8) );
		/* 82106A20h case   50:*/		return 0x82106A24;
		  /* 82106A24h */ case   51:  		/* lwz R11, <#[R30 + 172]> */
		/* 82106A24h case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000AC) );
		/* 82106A24h case   51:*/		return 0x82106A28;
		  /* 82106A28h */ case   52:  		/* stw R11, <#[R31 + 172]> */
		/* 82106A28h case   52:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000AC) );
		/* 82106A28h case   52:*/		return 0x82106A2C;
		  /* 82106A2Ch */ case   53:  		/* lwz R11, <#[R30 + 176]> */
		/* 82106A2Ch case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000B0) );
		/* 82106A2Ch case   53:*/		return 0x82106A30;
		  /* 82106A30h */ case   54:  		/* stw R11, <#[R31 + 176]> */
		/* 82106A30h case   54:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000B0) );
		/* 82106A30h case   54:*/		return 0x82106A34;
		  /* 82106A34h */ case   55:  		/* lwz R11, <#[R30 + 180]> */
		/* 82106A34h case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000B4) );
		/* 82106A34h case   55:*/		return 0x82106A38;
		  /* 82106A38h */ case   56:  		/* stw R11, <#[R31 + 180]> */
		/* 82106A38h case   56:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000B4) );
		/* 82106A38h case   56:*/		return 0x82106A3C;
		  /* 82106A3Ch */ case   57:  		/* lwz R11, <#[R30 + 184]> */
		/* 82106A3Ch case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000B8) );
		/* 82106A3Ch case   57:*/		return 0x82106A40;
		  /* 82106A40h */ case   58:  		/* stw R11, <#[R31 + 184]> */
		/* 82106A40h case   58:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000B8) );
		/* 82106A40h case   58:*/		return 0x82106A44;
		  /* 82106A44h */ case   59:  		/* bl -481028 */
		/* 82106A44h case   59:*/		regs.LR = 0x82106A48; return 0x82091340;
		/* 82106A44h case   59:*/		return 0x82106A48;
		  /* 82106A48h */ case   60:  		/* lwz R11, <#[R31]> */
		/* 82106A48h case   60:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82106A48h case   60:*/		return 0x82106A4C;
		  /* 82106A4Ch */ case   61:  		/* mr R3, R31 */
		/* 82106A4Ch case   61:*/		regs.R3 = regs.R31;
		/* 82106A4Ch case   61:*/		return 0x82106A50;
		  /* 82106A50h */ case   62:  		/* lwz R11, <#[R11 + 12]> */
		/* 82106A50h case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82106A50h case   62:*/		return 0x82106A54;
		  /* 82106A54h */ case   63:  		/* mtspr CTR, R11 */
		/* 82106A54h case   63:*/		regs.CTR = regs.R11;
		/* 82106A54h case   63:*/		return 0x82106A58;
		  /* 82106A58h */ case   64:  		/* bcctrl 20, CR0_LT */
		/* 82106A58h case   64:*/		if ( 1 ) { regs.LR = 0x82106A5C; return (uint32)regs.CTR; }
		/* 82106A58h case   64:*/		return 0x82106A5C;
		  /* 82106A5Ch */ case   65:  		/* cmpwi CR0, R3, 0 */
		/* 82106A5Ch case   65:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82106A5Ch case   65:*/		return 0x82106A60;
		  /* 82106A60h */ case   66:  		/* bc 12, CR0_LT, 24 */
		/* 82106A60h case   66:*/		if ( regs.CR[0].lt ) { return 0x82106A78;  }
		/* 82106A60h case   66:*/		return 0x82106A64;
		  /* 82106A64h */ case   67:  		/* lis R4, 9345 */
		/* 82106A64h case   67:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82106A64h case   67:*/		return 0x82106A68;
		  /* 82106A68h */ case   68:  		/* lwz R3, <#[R31 + 208]> */
		/* 82106A68h case   68:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000D0) );
		/* 82106A68h case   68:*/		return 0x82106A6C;
		  /* 82106A6Ch */ case   69:  		/* bl -517940 */
		/* 82106A6Ch case   69:*/		regs.LR = 0x82106A70; return 0x82088338;
		/* 82106A6Ch case   69:*/		return 0x82106A70;
		  /* 82106A70h */ case   70:  		/* li R3, 0 */
		/* 82106A70h case   70:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82106A70h case   70:*/		return 0x82106A74;
		  /* 82106A74h */ case   71:  		/* stw R29, <#[R31 + 208]> */
		/* 82106A74h case   71:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x000000D0) );
		/* 82106A74h case   71:*/		return 0x82106A78;
	}
	return 0x82106A78;
} // Block from 82106958h-82106A78h (72 instructions)

//////////////////////////////////////////////////////
// Block at 82106A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106A78);
		  /* 82106A78h */ case    0:  		/* addi R1, R1, 128 */
		/* 82106A78h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82106A78h case    0:*/		return 0x82106A7C;
		  /* 82106A7Ch */ case    1:  		/* b -481240 */
		/* 82106A7Ch case    1:*/		return 0x820912A4;
		/* 82106A7Ch case    1:*/		return 0x82106A80;
	}
	return 0x82106A80;
} // Block from 82106A78h-82106A80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82106A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106A80);
		  /* 82106A80h */ case    0:  		/* mfspr R12, LR */
		/* 82106A80h case    0:*/		regs.R12 = regs.LR;
		/* 82106A80h case    0:*/		return 0x82106A84;
		  /* 82106A84h */ case    1:  		/* bl -481352 */
		/* 82106A84h case    1:*/		regs.LR = 0x82106A88; return 0x8209123C;
		/* 82106A84h case    1:*/		return 0x82106A88;
		  /* 82106A88h */ case    2:  		/* stfd FR31, <#[R1 - 104]> */
		/* 82106A88h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF98) );
		/* 82106A88h case    2:*/		return 0x82106A8C;
		  /* 82106A8Ch */ case    3:  		/* stwu R1, <#[R1 - 192]> */
		/* 82106A8Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82106A8Ch case    3:*/		return 0x82106A90;
		  /* 82106A90h */ case    4:  		/* lwz R6, <#[R3 + 8]> */
		/* 82106A90h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000008) );
		/* 82106A90h case    4:*/		return 0x82106A94;
		  /* 82106A94h */ case    5:  		/* mr R31, R3 */
		/* 82106A94h case    5:*/		regs.R31 = regs.R3;
		/* 82106A94h case    5:*/		return 0x82106A98;
		  /* 82106A98h */ case    6:  		/* li R9, 0 */
		/* 82106A98h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82106A98h case    6:*/		return 0x82106A9C;
		  /* 82106A9Ch */ case    7:  		/* li R8, 0 */
		/* 82106A9Ch case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82106A9Ch case    7:*/		return 0x82106AA0;
		  /* 82106AA0h */ case    8:  		/* cmplwi CR6, R6, 0 */
		/* 82106AA0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82106AA0h case    8:*/		return 0x82106AA4;
		  /* 82106AA4h */ case    9:  		/* bc 12, CR6_EQ, 56 */
		/* 82106AA4h case    9:*/		if ( regs.CR[6].eq ) { return 0x82106ADC;  }
		/* 82106AA4h case    9:*/		return 0x82106AA8;
		  /* 82106AA8h */ case   10:  		/* lwz R7, <#[R3 + 20]> */
		/* 82106AA8h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000014) );
		/* 82106AA8h case   10:*/		return 0x82106AAC;
		  /* 82106AACh */ case   11:  		/* li R11, 0 */
		/* 82106AACh case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82106AACh case   11:*/		return 0x82106AB0;
		  /* 82106AB0h */ case   12:  		/* lwzx R10, <#[R11 + R7]> */
		/* 82106AB0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82106AB0h case   12:*/		return 0x82106AB4;
		  /* 82106AB4h */ case   13:  		/* lwz R10, <#[R10 + 12]> */
		/* 82106AB4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 82106AB4h case   13:*/		return 0x82106AB8;
		  /* 82106AB8h */ case   14:  		/* cmplw CR6, R10, R9 */
		/* 82106AB8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82106AB8h case   14:*/		return 0x82106ABC;
		  /* 82106ABCh */ case   15:  		/* bc 4, CR6_GT, 16 */
		/* 82106ABCh case   15:*/		if ( !regs.CR[6].gt ) { return 0x82106ACC;  }
		/* 82106ABCh case   15:*/		return 0x82106AC0;
		  /* 82106AC0h */ case   16:  		/* cmpwi CR6, R10, -1 */
		/* 82106AC0h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82106AC0h case   16:*/		return 0x82106AC4;
		  /* 82106AC4h */ case   17:  		/* bc 12, CR6_EQ, 8 */
		/* 82106AC4h case   17:*/		if ( regs.CR[6].eq ) { return 0x82106ACC;  }
		/* 82106AC4h case   17:*/		return 0x82106AC8;
		  /* 82106AC8h */ case   18:  		/* mr R9, R10 */
		/* 82106AC8h case   18:*/		regs.R9 = regs.R10;
		/* 82106AC8h case   18:*/		return 0x82106ACC;
	}
	return 0x82106ACC;
} // Block from 82106A80h-82106ACCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 82106ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106ACC);
		  /* 82106ACCh */ case    0:  		/* addi R8, R8, 1 */
		/* 82106ACCh case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82106ACCh case    0:*/		return 0x82106AD0;
		  /* 82106AD0h */ case    1:  		/* addi R11, R11, 4 */
		/* 82106AD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82106AD0h case    1:*/		return 0x82106AD4;
		  /* 82106AD4h */ case    2:  		/* cmplw CR6, R8, R6 */
		/* 82106AD4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R6);
		/* 82106AD4h case    2:*/		return 0x82106AD8;
		  /* 82106AD8h */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 82106AD8h case    3:*/		if ( regs.CR[6].lt ) { return 0x82106AB0;  }
		/* 82106AD8h case    3:*/		return 0x82106ADC;
	}
	return 0x82106ADC;
} // Block from 82106ACCh-82106ADCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82106ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106ADC);
		  /* 82106ADCh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82106ADCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82106ADCh case    0:*/		return 0x82106AE0;
		  /* 82106AE0h */ case    1:  		/* addi R23, R9, 1 */
		/* 82106AE0h case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R9,0x1);
		/* 82106AE0h case    1:*/		return 0x82106AE4;
		  /* 82106AE4h */ case    2:  		/* li R22, 0 */
		/* 82106AE4h case    2:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82106AE4h case    2:*/		return 0x82106AE8;
		  /* 82106AE8h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82106AE8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106AE8h case    3:*/		return 0x82106AEC;
		  /* 82106AECh */ case    4:  		/* bc 4, CR6_GT, 392 */
		/* 82106AECh case    4:*/		if ( !regs.CR[6].gt ) { return 0x82106C74;  }
		/* 82106AECh case    4:*/		return 0x82106AF0;
		  /* 82106AF0h */ case    5:  		/* lis R11, -32256 */
		/* 82106AF0h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82106AF0h case    5:*/		return 0x82106AF4;
		  /* 82106AF4h */ case    6:  		/* li R24, 0 */
		/* 82106AF4h case    6:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82106AF4h case    6:*/		return 0x82106AF8;
		  /* 82106AF8h */ case    7:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82106AF8h case    7:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82106AF8h case    7:*/		return 0x82106AFC;
		  /* 82106AFCh */ case    8:  		/* lwz R11, <#[R31 + 24]> */
		/* 82106AFCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82106AFCh case    8:*/		return 0x82106B00;
		  /* 82106B00h */ case    9:  		/* li R5, 0 */
		/* 82106B00h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82106B00h case    9:*/		return 0x82106B04;
		  /* 82106B04h */ case   10:  		/* lwzx R29, <#[R24 + R11]> */
		/* 82106B04h case   10:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R24 + regs.R11 + 0x00000000) );
		/* 82106B04h case   10:*/		return 0x82106B08;
		  /* 82106B08h */ case   11:  		/* lwz R10, <#[R29 + 12]> */
		/* 82106B08h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 82106B08h case   11:*/		return 0x82106B0C;
		  /* 82106B0Ch */ case   12:  		/* mr R6, R10 */
		/* 82106B0Ch case   12:*/		regs.R6 = regs.R10;
		/* 82106B0Ch case   12:*/		return 0x82106B10;
		  /* 82106B10h */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 82106B10h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82106B10h case   13:*/		return 0x82106B14;
		  /* 82106B14h */ case   14:  		/* bc 12, CR6_EQ, 88 */
		/* 82106B14h case   14:*/		if ( regs.CR[6].eq ) { return 0x82106B6C;  }
		/* 82106B14h case   14:*/		return 0x82106B18;
		  /* 82106B18h */ case   15:  		/* lwz R8, <#[R29 + 16]> */
		/* 82106B18h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000010) );
		/* 82106B18h case   15:*/		return 0x82106B1C;
		  /* 82106B1Ch */ case   16:  		/* li R11, 0 */
		/* 82106B1Ch case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82106B1Ch case   16:*/		return 0x82106B20;
		  /* 82106B20h */ case   17:  		/* lwz R7, <#[R31 + 20]> */
		/* 82106B20h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 82106B20h case   17:*/		return 0x82106B24;
		  /* 82106B24h */ case   18:  		/* lwzx R9, <#[R11 + R8]> */
		/* 82106B24h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82106B24h case   18:*/		return 0x82106B28;
		  /* 82106B28h */ case   19:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82106B28h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82106B28h case   19:*/		return 0x82106B2C;
		  /* 82106B2Ch */ case   20:  		/* lwzx R9, <#[R9 + R7]> */
		/* 82106B2Ch case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82106B2Ch case   20:*/		return 0x82106B30;
		  /* 82106B30h */ case   21:  		/* lwz R4, <#[R9 + 68]> */
		/* 82106B30h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + 0x00000044) );
		/* 82106B30h case   21:*/		return 0x82106B34;
		  /* 82106B34h */ case   22:  		/* cmpwi CR6, R4, -1 */
		/* 82106B34h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 82106B34h case   22:*/		return 0x82106B38;
		  /* 82106B38h */ case   23:  		/* bc 4, CR6_EQ, 36 */
		/* 82106B38h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82106B5C;  }
		/* 82106B38h case   23:*/		return 0x82106B3C;
		  /* 82106B3Ch */ case   24:  		/* lwz R9, <#[R9 + 4]> */
		/* 82106B3Ch case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82106B3Ch case   24:*/		return 0x82106B40;
		  /* 82106B40h */ case   25:  		/* lwz R4, <#[R31 + 16]> */
		/* 82106B40h case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 82106B40h case   25:*/		return 0x82106B44;
		  /* 82106B44h */ case   26:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82106B44h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82106B44h case   26:*/		return 0x82106B48;
		  /* 82106B48h */ case   27:  		/* lwzx R9, <#[R9 + R4]> */
		/* 82106B48h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R4 + 0x00000000) );
		/* 82106B48h case   27:*/		return 0x82106B4C;
		  /* 82106B4Ch */ case   28:  		/* lwz R9, <#[R9 + 4]> */
		/* 82106B4Ch case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82106B4Ch case   28:*/		return 0x82106B50;
		  /* 82106B50h */ case   29:  		/* rlwinm. R9, R9, 0, 26, 26 */
		/* 82106B50h case   29:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R9,regs.R9);
		/* 82106B50h case   29:*/		return 0x82106B54;
		  /* 82106B54h */ case   30:  		/* bc 12, CR0_EQ, 8 */
		/* 82106B54h case   30:*/		if ( regs.CR[0].eq ) { return 0x82106B5C;  }
		/* 82106B54h case   30:*/		return 0x82106B58;
		  /* 82106B58h */ case   31:  		/* addi R6, R6, -1 */
		/* 82106B58h case   31:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82106B58h case   31:*/		return 0x82106B5C;
	}
	return 0x82106B5C;
} // Block from 82106ADCh-82106B5Ch (32 instructions)

//////////////////////////////////////////////////////
// Block at 82106B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106B5C);
		  /* 82106B5Ch */ case    0:  		/* addi R5, R5, 1 */
		/* 82106B5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82106B5Ch case    0:*/		return 0x82106B60;
		  /* 82106B60h */ case    1:  		/* addi R11, R11, 4 */
		/* 82106B60h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82106B60h case    1:*/		return 0x82106B64;
		  /* 82106B64h */ case    2:  		/* cmplw CR6, R5, R10 */
		/* 82106B64h case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 82106B64h case    2:*/		return 0x82106B68;
		  /* 82106B68h */ case    3:  		/* bc 12, CR6_LT, -68 */
		/* 82106B68h case    3:*/		if ( regs.CR[6].lt ) { return 0x82106B24;  }
		/* 82106B68h case    3:*/		return 0x82106B6C;
	}
	return 0x82106B6C;
} // Block from 82106B5Ch-82106B6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82106B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106B6C);
		  /* 82106B6Ch */ case    0:  		/* cmplw CR6, R6, R10 */
		/* 82106B6Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82106B6Ch case    0:*/		return 0x82106B70;
		  /* 82106B70h */ case    1:  		/* bc 12, CR6_EQ, 240 */
		/* 82106B70h case    1:*/		if ( regs.CR[6].eq ) { return 0x82106C60;  }
		/* 82106B70h case    1:*/		return 0x82106B74;
		  /* 82106B74h */ case    2:  		/* li R26, 0 */
		/* 82106B74h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82106B74h case    2:*/		return 0x82106B78;
		  /* 82106B78h */ case    3:  		/* cmplwi CR6, R6, 0 */
		/* 82106B78h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82106B78h case    3:*/		return 0x82106B7C;
		  /* 82106B7Ch */ case    4:  		/* bc 12, CR6_EQ, 60 */
		/* 82106B7Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82106BB8;  }
		/* 82106B7Ch case    4:*/		return 0x82106B80;
		  /* 82106B80h */ case    5:  		/* mr R4, R6 */
		/* 82106B80h case    5:*/		regs.R4 = regs.R6;
		/* 82106B80h case    5:*/		return 0x82106B84;
		  /* 82106B84h */ case    6:  		/* li R11, 1 */
		/* 82106B84h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82106B84h case    6:*/		return 0x82106B88;
		  /* 82106B88h */ case    7:  		/* mr R5, R6 */
		/* 82106B88h case    7:*/		regs.R5 = regs.R6;
		/* 82106B88h case    7:*/		return 0x82106B8C;
		  /* 82106B8Ch */ case    8:  		/* rlwimi R4, R11, 28, 0, 11 */
		/* 82106B8Ch case    8:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R11);
		/* 82106B8Ch case    8:*/		return 0x82106B90;
		  /* 82106B90h */ case    9:  		/* mr R3, R31 */
		/* 82106B90h case    9:*/		regs.R3 = regs.R31;
		/* 82106B90h case    9:*/		return 0x82106B94;
		  /* 82106B94h */ case   10:  		/* bl -39116 */
		/* 82106B94h case   10:*/		regs.LR = 0x82106B98; return 0x820FD2C8;
		/* 82106B94h case   10:*/		return 0x82106B98;
		  /* 82106B98h */ case   11:  		/* cmpwi CR6, R3, -1 */
		/* 82106B98h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82106B98h case   11:*/		return 0x82106B9C;
		  /* 82106B9Ch */ case   12:  		/* bc 12, CR6_EQ, 328 */
		/* 82106B9Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x82106CE4;  }
		/* 82106B9Ch case   12:*/		return 0x82106BA0;
		  /* 82106BA0h */ case   13:  		/* lwz R11, <#[R31 + 24]> */
		/* 82106BA0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82106BA0h case   13:*/		return 0x82106BA4;
		  /* 82106BA4h */ case   14:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82106BA4h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82106BA4h case   14:*/		return 0x82106BA8;
		  /* 82106BA8h */ case   15:  		/* mr R4, R29 */
		/* 82106BA8h case   15:*/		regs.R4 = regs.R29;
		/* 82106BA8h case   15:*/		return 0x82106BAC;
		  /* 82106BACh */ case   16:  		/* lwzx R26, <#[R10 + R11]> */
		/* 82106BACh case   16:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82106BACh case   16:*/		return 0x82106BB0;
		  /* 82106BB0h */ case   17:  		/* mr R3, R26 */
		/* 82106BB0h case   17:*/		regs.R3 = regs.R26;
		/* 82106BB0h case   17:*/		return 0x82106BB4;
		  /* 82106BB4h */ case   18:  		/* bl -44228 */
		/* 82106BB4h case   18:*/		regs.LR = 0x82106BB8; return 0x820FBEF0;
		/* 82106BB4h case   18:*/		return 0x82106BB8;
	}
	return 0x82106BB8;
} // Block from 82106B6Ch-82106BB8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82106BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106BB8);
		  /* 82106BB8h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 82106BB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82106BB8h case    0:*/		return 0x82106BBC;
		  /* 82106BBCh */ case    1:  		/* li R25, 0 */
		/* 82106BBCh case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82106BBCh case    1:*/		return 0x82106BC0;
		  /* 82106BC0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82106BC0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106BC0h case    2:*/		return 0x82106BC4;
		  /* 82106BC4h */ case    3:  		/* bc 4, CR6_GT, 152 */
		/* 82106BC4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82106C5C;  }
		/* 82106BC4h case    3:*/		return 0x82106BC8;
	}
	return 0x82106BC8;
} // Block from 82106BB8h-82106BC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82106BC8h
// Function '?ParentChildInfo@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106BC8);
		  /* 82106BC8h */ case    0:  		/* li R30, 0 */
		/* 82106BC8h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82106BC8h case    0:*/		return 0x82106BCC;
		  /* 82106BCCh */ case    1:  		/* li R28, 0 */
		/* 82106BCCh case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82106BCCh case    1:*/		return 0x82106BD0;
		  /* 82106BD0h */ case    2:  		/* lwz R11, <#[R29 + 16]> */
		/* 82106BD0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82106BD0h case    2:*/		return 0x82106BD4;
		  /* 82106BD4h */ case    3:  		/* mr R5, R23 */
		/* 82106BD4h case    3:*/		regs.R5 = regs.R23;
		/* 82106BD4h case    3:*/		return 0x82106BD8;
		  /* 82106BD8h */ case    4:  		/* lwz R10, <#[R31 + 20]> */
		/* 82106BD8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82106BD8h case    4:*/		return 0x82106BDC;
		  /* 82106BDCh */ case    5:  		/* mr R3, R31 */
		/* 82106BDCh case    5:*/		regs.R3 = regs.R31;
		/* 82106BDCh case    5:*/		return 0x82106BE0;
		  /* 82106BE0h */ case    6:  		/* lwz R9, <#[R31 + 16]> */
		/* 82106BE0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82106BE0h case    6:*/		return 0x82106BE4;
		  /* 82106BE4h */ case    7:  		/* fmr FR1, FR31 */
		/* 82106BE4h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82106BE4h case    7:*/		return 0x82106BE8;
		  /* 82106BE8h */ case    8:  		/* lwz R4, <#[R31 + 136]> */
		/* 82106BE8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000088) );
		/* 82106BE8h case    8:*/		return 0x82106BEC;
		  /* 82106BECh */ case    9:  		/* lwzx R11, <#[R11 + R30]> */
		/* 82106BECh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82106BECh case    9:*/		return 0x82106BF0;
		  /* 82106BF0h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82106BF0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82106BF0h case   10:*/		return 0x82106BF4;
		  /* 82106BF4h */ case   11:  		/* lwzx R21, <#[R11 + R10]> */
		/* 82106BF4h case   11:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82106BF4h case   11:*/		return 0x82106BF8;
		  /* 82106BF8h */ case   12:  		/* lwz R11, <#[R21 + 4]> */
		/* 82106BF8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 82106BF8h case   12:*/		return 0x82106BFC;
		  /* 82106BFCh */ case   13:  		/* lwz R6, <#[R21 + 16]> */
		/* 82106BFCh case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R21 + 0x00000010) );
		/* 82106BFCh case   13:*/		return 0x82106C00;
		  /* 82106C00h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82106C00h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82106C00h case   14:*/		return 0x82106C04;
		  /* 82106C04h */ case   15:  		/* lwzx R27, <#[R11 + R9]> */
		/* 82106C04h case   15:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82106C04h case   15:*/		return 0x82106C08;
		  /* 82106C08h */ case   16:  		/* bl -39392 */
		/* 82106C08h case   16:*/		regs.LR = 0x82106C0C; return 0x820FD228;
		/* 82106C08h case   16:*/		return 0x82106C0C;
		  /* 82106C0Ch */ case   17:  		/* lwz R11, <#[R21 + 68]> */
		/* 82106C0Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000044) );
		/* 82106C0Ch case   17:*/		return 0x82106C10;
		  /* 82106C10h */ case   18:  		/* cmpwi CR6, R11, -1 */
		/* 82106C10h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82106C10h case   18:*/		return 0x82106C14;
		  /* 82106C14h */ case   19:  		/* bc 4, CR6_EQ, 16 */
		/* 82106C14h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82106C24;  }
		/* 82106C14h case   19:*/		return 0x82106C18;
		  /* 82106C18h */ case   20:  		/* lwz R11, <#[R27 + 4]> */
		/* 82106C18h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82106C18h case   20:*/		return 0x82106C1C;
		  /* 82106C1Ch */ case   21:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82106C1Ch case   21:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82106C1Ch case   21:*/		return 0x82106C20;
		  /* 82106C20h */ case   22:  		/* bc 4, CR0_EQ, 32 */
		/* 82106C20h case   22:*/		if ( !regs.CR[0].eq ) { return 0x82106C40;  }
		/* 82106C20h case   22:*/		return 0x82106C24;
	}
	return 0x82106C24;
} // Block from 82106BC8h-82106C24h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82106C24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106C24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106C24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106C24);
		  /* 82106C24h */ case    0:  		/* lwz R11, <#[R29 + 16]> */
		/* 82106C24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82106C24h case    0:*/		return 0x82106C28;
		  /* 82106C28h */ case    1:  		/* lwz R10, <#[R26 + 16]> */
		/* 82106C28h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 82106C28h case    1:*/		return 0x82106C2C;
		  /* 82106C2Ch */ case    2:  		/* lwzx R11, <#[R11 + R30]> */
		/* 82106C2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82106C2Ch case    2:*/		return 0x82106C30;
		  /* 82106C30h */ case    3:  		/* stwx R11, <#[R10 + R28]> */
		/* 82106C30h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 82106C30h case    3:*/		return 0x82106C34;
		  /* 82106C34h */ case    4:  		/* lwz R11, <#[R26 + 8]> */
		/* 82106C34h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82106C34h case    4:*/		return 0x82106C38;
		  /* 82106C38h */ case    5:  		/* stwx R3, <#[R11 + R28]> */
		/* 82106C38h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82106C38h case    5:*/		return 0x82106C3C;
		  /* 82106C3Ch */ case    6:  		/* addi R28, R28, 4 */
		/* 82106C3Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82106C3Ch case    6:*/		return 0x82106C40;
	}
	return 0x82106C40;
} // Block from 82106C24h-82106C40h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82106C40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106C40);
		  /* 82106C40h */ case    0:  		/* lwz R11, <#[R29 + 16]> */
		/* 82106C40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82106C40h case    0:*/		return 0x82106C44;
		  /* 82106C44h */ case    1:  		/* addi R25, R25, 1 */
		/* 82106C44h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 82106C44h case    1:*/		return 0x82106C48;
		  /* 82106C48h */ case    2:  		/* stwx R3, <#[R11 + R30]> */
		/* 82106C48h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82106C48h case    2:*/		return 0x82106C4C;
		  /* 82106C4Ch */ case    3:  		/* addi R30, R30, 4 */
		/* 82106C4Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82106C4Ch case    3:*/		return 0x82106C50;
		  /* 82106C50h */ case    4:  		/* lwz R11, <#[R29 + 12]> */
		/* 82106C50h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82106C50h case    4:*/		return 0x82106C54;
		  /* 82106C54h */ case    5:  		/* cmplw CR6, R25, R11 */
		/* 82106C54h case    5:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 82106C54h case    5:*/		return 0x82106C58;
		  /* 82106C58h */ case    6:  		/* bc 12, CR6_LT, -136 */
		/* 82106C58h case    6:*/		if ( regs.CR[6].lt ) { return 0x82106BD0;  }
		/* 82106C58h case    6:*/		return 0x82106C5C;
	}
	return 0x82106C5C;
} // Block from 82106C40h-82106C5Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82106C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106C5C);
		  /* 82106C5Ch */ case    0:  		/* addi R23, R23, 1 */
		/* 82106C5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 82106C5Ch case    0:*/		return 0x82106C60;
	}
	return 0x82106C60;
} // Block from 82106C5Ch-82106C60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82106C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106C60);
		  /* 82106C60h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82106C60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82106C60h case    0:*/		return 0x82106C64;
		  /* 82106C64h */ case    1:  		/* addi R22, R22, 1 */
		/* 82106C64h case    1:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 82106C64h case    1:*/		return 0x82106C68;
		  /* 82106C68h */ case    2:  		/* addi R24, R24, 4 */
		/* 82106C68h case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 82106C68h case    2:*/		return 0x82106C6C;
		  /* 82106C6Ch */ case    3:  		/* cmplw CR6, R22, R11 */
		/* 82106C6Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82106C6Ch case    3:*/		return 0x82106C70;
		  /* 82106C70h */ case    4:  		/* bc 12, CR6_LT, -372 */
		/* 82106C70h case    4:*/		if ( regs.CR[6].lt ) { return 0x82106AFC;  }
		/* 82106C70h case    4:*/		return 0x82106C74;
	}
	return 0x82106C74;
} // Block from 82106C60h-82106C74h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82106C74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106C74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106C74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106C74);
		  /* 82106C74h */ case    0:  		/* mr R3, R31 */
		/* 82106C74h case    0:*/		regs.R3 = regs.R31;
		/* 82106C74h case    0:*/		return 0x82106C78;
		  /* 82106C78h */ case    1:  		/* bl -4320 */
		/* 82106C78h case    1:*/		regs.LR = 0x82106C7C; return 0x82105B98;
		/* 82106C78h case    1:*/		return 0x82106C7C;
		  /* 82106C7Ch */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 82106C7Ch case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82106C7Ch case    2:*/		return 0x82106C80;
		  /* 82106C80h */ case    3:  		/* bc 12, CR0_LT, 88 */
		/* 82106C80h case    3:*/		if ( regs.CR[0].lt ) { return 0x82106CD8;  }
		/* 82106C80h case    3:*/		return 0x82106C84;
		  /* 82106C84h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 82106C84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82106C84h case    4:*/		return 0x82106C88;
		  /* 82106C88h */ case    5:  		/* li R9, 0 */
		/* 82106C88h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82106C88h case    5:*/		return 0x82106C8C;
		  /* 82106C8Ch */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82106C8Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106C8Ch case    6:*/		return 0x82106C90;
		  /* 82106C90h */ case    7:  		/* bc 4, CR6_GT, 68 */
		/* 82106C90h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82106CD4;  }
		/* 82106C90h case    7:*/		return 0x82106C94;
		  /* 82106C94h */ case    8:  		/* li R10, 0 */
		/* 82106C94h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82106C94h case    8:*/		return 0x82106C98;
		  /* 82106C98h */ case    9:  		/* lwz R11, <#[R31 + 20]> */
		/* 82106C98h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82106C98h case    9:*/		return 0x82106C9C;
		  /* 82106C9Ch */ case   10:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82106C9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82106C9Ch case   10:*/		return 0x82106CA0;
		  /* 82106CA0h */ case   11:  		/* lwz R8, <#[R11 + 72]> */
		/* 82106CA0h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000048) );
		/* 82106CA0h case   11:*/		return 0x82106CA4;
		  /* 82106CA4h */ case   12:  		/* cmpwi CR6, R8, -1 */
		/* 82106CA4h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 82106CA4h case   12:*/		return 0x82106CA8;
		  /* 82106CA8h */ case   13:  		/* bc 4, CR6_EQ, 24 */
		/* 82106CA8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82106CC0;  }
		/* 82106CA8h case   13:*/		return 0x82106CAC;
		  /* 82106CACh */ case   14:  		/* lwz R8, <#[R11 + 84]> */
		/* 82106CACh case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000054) );
		/* 82106CACh case   14:*/		return 0x82106CB0;
		  /* 82106CB0h */ case   15:  		/* cmpwi CR6, R8, -1 */
		/* 82106CB0h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 82106CB0h case   15:*/		return 0x82106CB4;
		  /* 82106CB4h */ case   16:  		/* bc 4, CR6_EQ, 12 */
		/* 82106CB4h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82106CC0;  }
		/* 82106CB4h case   16:*/		return 0x82106CB8;
		  /* 82106CB8h */ case   17:  		/* lwz R8, <#[R31 + 116]> */
		/* 82106CB8h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000074) );
		/* 82106CB8h case   17:*/		return 0x82106CBC;
		  /* 82106CBCh */ case   18:  		/* stw R8, <#[R11 + 4]> */
		/* 82106CBCh case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82106CBCh case   18:*/		return 0x82106CC0;
	}
	return 0x82106CC0;
} // Block from 82106C74h-82106CC0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82106CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106CC0);
		  /* 82106CC0h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82106CC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82106CC0h case    0:*/		return 0x82106CC4;
		  /* 82106CC4h */ case    1:  		/* addi R9, R9, 1 */
		/* 82106CC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82106CC4h case    1:*/		return 0x82106CC8;
		  /* 82106CC8h */ case    2:  		/* addi R10, R10, 4 */
		/* 82106CC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82106CC8h case    2:*/		return 0x82106CCC;
		  /* 82106CCCh */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 82106CCCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82106CCCh case    3:*/		return 0x82106CD0;
		  /* 82106CD0h */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 82106CD0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82106C98;  }
		/* 82106CD0h case    4:*/		return 0x82106CD4;
	}
	return 0x82106CD4;
} // Block from 82106CC0h-82106CD4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82106CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106CD4);
		  /* 82106CD4h */ case    0:  		/* li R3, 0 */
		/* 82106CD4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82106CD4h case    0:*/		return 0x82106CD8;
	}
	return 0x82106CD8;
} // Block from 82106CD4h-82106CD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82106CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106CD8);
		  /* 82106CD8h */ case    0:  		/* addi R1, R1, 192 */
		/* 82106CD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82106CD8h case    0:*/		return 0x82106CDC;
		  /* 82106CDCh */ case    1:  		/* lfd FR31, <#[R1 - 104]> */
		/* 82106CDCh case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF98) );
		/* 82106CDCh case    1:*/		return 0x82106CE0;
		  /* 82106CE0h */ case    2:  		/* b -481876 */
		/* 82106CE0h case    2:*/		return 0x8209128C;
		/* 82106CE0h case    2:*/		return 0x82106CE4;
	}
	return 0x82106CE4;
} // Block from 82106CD8h-82106CE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82106CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106CE4);
		  /* 82106CE4h */ case    0:  		/* lis R3, -32761 */
		/* 82106CE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82106CE4h case    0:*/		return 0x82106CE8;
		  /* 82106CE8h */ case    1:  		/* ori R3, R3, 14 */
		/* 82106CE8h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 82106CE8h case    1:*/		return 0x82106CEC;
		  /* 82106CECh */ case    2:  		/* b -20 */
		/* 82106CECh case    2:*/		return 0x82106CD8;
		/* 82106CECh case    2:*/		return 0x82106CF0;
	}
	return 0x82106CF0;
} // Block from 82106CE4h-82106CF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82106CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106CF0);
		  /* 82106CF0h */ case    0:  		/* mfspr R12, LR */
		/* 82106CF0h case    0:*/		regs.R12 = regs.LR;
		/* 82106CF0h case    0:*/		return 0x82106CF4;
		  /* 82106CF4h */ case    1:  		/* bl -481984 */
		/* 82106CF4h case    1:*/		regs.LR = 0x82106CF8; return 0x82091234;
		/* 82106CF4h case    1:*/		return 0x82106CF8;
		  /* 82106CF8h */ case    2:  		/* stfd FR31, <#[R1 - 120]> */
		/* 82106CF8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 82106CF8h case    2:*/		return 0x82106CFC;
		  /* 82106CFCh */ case    3:  		/* stwu R1, <#[R1 - 208]> */
		/* 82106CFCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 82106CFCh case    3:*/		return 0x82106D00;
		  /* 82106D00h */ case    4:  		/* mr R31, R3 */
		/* 82106D00h case    4:*/		regs.R31 = regs.R3;
		/* 82106D00h case    4:*/		return 0x82106D04;
		  /* 82106D04h */ case    5:  		/* li R19, 0 */
		/* 82106D04h case    5:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 82106D04h case    5:*/		return 0x82106D08;
		  /* 82106D08h */ case    6:  		/* bl -4464 */
		/* 82106D08h case    6:*/		regs.LR = 0x82106D0C; return 0x82105B98;
		/* 82106D08h case    6:*/		return 0x82106D0C;
		  /* 82106D0Ch */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 82106D0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82106D0Ch case    7:*/		return 0x82106D10;
		  /* 82106D10h */ case    8:  		/* li R28, 0 */
		/* 82106D10h case    8:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82106D10h case    8:*/		return 0x82106D14;
		  /* 82106D14h */ case    9:  		/* li R29, 0 */
		/* 82106D14h case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82106D14h case    9:*/		return 0x82106D18;
		  /* 82106D18h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82106D18h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106D18h case   10:*/		return 0x82106D1C;
		  /* 82106D1Ch */ case   11:  		/* bc 4, CR6_GT, 800 */
		/* 82106D1Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x8210703C;  }
		/* 82106D1Ch case   11:*/		return 0x82106D20;
		  /* 82106D20h */ case   12:  		/* lis R11, -32256 */
		/* 82106D20h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82106D20h case   12:*/		return 0x82106D24;
		  /* 82106D24h */ case   13:  		/* li R27, 0 */
		/* 82106D24h case   13:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82106D24h case   13:*/		return 0x82106D28;
		  /* 82106D28h */ case   14:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82106D28h case   14:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82106D28h case   14:*/		return 0x82106D2C;
		  /* 82106D2Ch */ case   15:  		/* lwz R11, <#[R31 + 20]> */
		/* 82106D2Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82106D2Ch case   15:*/		return 0x82106D30;
		  /* 82106D30h */ case   16:  		/* lwz R10, <#[R31 + 16]> */
		/* 82106D30h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82106D30h case   16:*/		return 0x82106D34;
		  /* 82106D34h */ case   17:  		/* lwzx R30, <#[R27 + R11]> */
		/* 82106D34h case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 82106D34h case   17:*/		return 0x82106D38;
		  /* 82106D38h */ case   18:  		/* lwz R11, <#[R30 + 4]> */
		/* 82106D38h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82106D38h case   18:*/		return 0x82106D3C;
		  /* 82106D3Ch */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82106D3Ch case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82106D3Ch case   19:*/		return 0x82106D40;
		  /* 82106D40h */ case   20:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82106D40h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82106D40h case   20:*/		return 0x82106D44;
		  /* 82106D44h */ case   21:  		/* lwz R11, <#[R11 + 4]> */
		/* 82106D44h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82106D44h case   21:*/		return 0x82106D48;
		  /* 82106D48h */ case   22:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82106D48h case   22:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82106D48h case   22:*/		return 0x82106D4C;
		  /* 82106D4Ch */ case   23:  		/* bc 12, CR0_EQ, 92 */
		/* 82106D4Ch case   23:*/		if ( regs.CR[0].eq ) { return 0x82106DA8;  }
		/* 82106D4Ch case   23:*/		return 0x82106D50;
		  /* 82106D50h */ case   24:  		/* li R6, 0 */
		/* 82106D50h case   24:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82106D50h case   24:*/		return 0x82106D54;
		  /* 82106D54h */ case   25:  		/* lwz R4, <#[R31 + 136]> */
		/* 82106D54h case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000088) );
		/* 82106D54h case   25:*/		return 0x82106D58;
		  /* 82106D58h */ case   26:  		/* li R5, 0 */
		/* 82106D58h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82106D58h case   26:*/		return 0x82106D5C;
		  /* 82106D5Ch */ case   27:  		/* fmr FR1, FR31 */
		/* 82106D5Ch case   27:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82106D5Ch case   27:*/		return 0x82106D60;
		  /* 82106D60h */ case   28:  		/* mr R3, R31 */
		/* 82106D60h case   28:*/		regs.R3 = regs.R31;
		/* 82106D60h case   28:*/		return 0x82106D64;
		  /* 82106D64h */ case   29:  		/* bl -39740 */
		/* 82106D64h case   29:*/		regs.LR = 0x82106D68; return 0x820FD228;
		/* 82106D64h case   29:*/		return 0x82106D68;
		  /* 82106D68h */ case   30:  		/* cmpwi CR6, R3, -1 */
		/* 82106D68h case   30:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82106D68h case   30:*/		return 0x82106D6C;
		  /* 82106D6Ch */ case   31:  		/* stw R3, <#[R30 + 48]> */
		/* 82106D6Ch case   31:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 82106D6Ch case   31:*/		return 0x82106D70;
		  /* 82106D70h */ case   32:  		/* bc 12, CR6_EQ, 748 */
		/* 82106D70h case   32:*/		if ( regs.CR[6].eq ) { return 0x8210705C;  }
		/* 82106D70h case   32:*/		return 0x82106D74;
		  /* 82106D74h */ case   33:  		/* lwz R11, <#[R31 + 20]> */
		/* 82106D74h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82106D74h case   33:*/		return 0x82106D78;
		  /* 82106D78h */ case   34:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82106D78h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82106D78h case   34:*/		return 0x82106D7C;
		  /* 82106D7Ch */ case   35:  		/* lwz R9, <#[R30 + 20]> */
		/* 82106D7Ch case   35:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 82106D7Ch case   35:*/		return 0x82106D80;
		  /* 82106D80h */ case   36:  		/* addi R28, R28, 1 */
		/* 82106D80h case   36:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82106D80h case   36:*/		return 0x82106D84;
		  /* 82106D84h */ case   37:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82106D84h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82106D84h case   37:*/		return 0x82106D88;
		  /* 82106D88h */ case   38:  		/* stw R9, <#[R11 + 20]> */
		/* 82106D88h case   38:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82106D88h case   38:*/		return 0x82106D8C;
		  /* 82106D8Ch */ case   39:  		/* lwz R11, <#[R31 + 20]> */
		/* 82106D8Ch case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82106D8Ch case   39:*/		return 0x82106D90;
		  /* 82106D90h */ case   40:  		/* lwz R10, <#[R30 + 24]> */
		/* 82106D90h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 82106D90h case   40:*/		return 0x82106D94;
		  /* 82106D94h */ case   41:  		/* lwz R9, <#[R30 + 48]> */
		/* 82106D94h case   41:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000030) );
		/* 82106D94h case   41:*/		return 0x82106D98;
		  /* 82106D98h */ case   42:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82106D98h case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82106D98h case   42:*/		return 0x82106D9C;
		  /* 82106D9Ch */ case   43:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82106D9Ch case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82106D9Ch case   43:*/		return 0x82106DA0;
		  /* 82106DA0h */ case   44:  		/* stw R10, <#[R11 + 24]> */
		/* 82106DA0h case   44:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 82106DA0h case   44:*/		return 0x82106DA4;
		  /* 82106DA4h */ case   45:  		/* b 8 */
		/* 82106DA4h case   45:*/		return 0x82106DAC;
		/* 82106DA4h case   45:*/		return 0x82106DA8;
	}
	return 0x82106DA8;
} // Block from 82106CF0h-82106DA8h (46 instructions)

//////////////////////////////////////////////////////
// Block at 82106DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106DA8);
		  /* 82106DA8h */ case    0:  		/* stw R29, <#[R30 + 48]> */
		/* 82106DA8h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000030) );
		/* 82106DA8h case    0:*/		return 0x82106DAC;
	}
	return 0x82106DAC;
} // Block from 82106DA8h-82106DACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82106DACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106DAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106DAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106DAC);
		  /* 82106DACh */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82106DACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82106DACh case    0:*/		return 0x82106DB0;
		  /* 82106DB0h */ case    1:  		/* addi R29, R29, 1 */
		/* 82106DB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82106DB0h case    1:*/		return 0x82106DB4;
		  /* 82106DB4h */ case    2:  		/* addi R27, R27, 4 */
		/* 82106DB4h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 82106DB4h case    2:*/		return 0x82106DB8;
		  /* 82106DB8h */ case    3:  		/* cmplw CR6, R29, R11 */
		/* 82106DB8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82106DB8h case    3:*/		return 0x82106DBC;
		  /* 82106DBCh */ case    4:  		/* bc 12, CR6_LT, -144 */
		/* 82106DBCh case    4:*/		if ( regs.CR[6].lt ) { return 0x82106D2C;  }
		/* 82106DBCh case    4:*/		return 0x82106DC0;
		  /* 82106DC0h */ case    5:  		/* cmplwi CR6, R28, 0 */
		/* 82106DC0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82106DC0h case    5:*/		return 0x82106DC4;
		  /* 82106DC4h */ case    6:  		/* bc 12, CR6_EQ, 632 */
		/* 82106DC4h case    6:*/		if ( regs.CR[6].eq ) { return 0x8210703C;  }
		/* 82106DC4h case    6:*/		return 0x82106DC8;
		  /* 82106DC8h */ case    7:  		/* mr R3, R31 */
		/* 82106DC8h case    7:*/		regs.R3 = regs.R31;
		/* 82106DC8h case    7:*/		return 0x82106DCC;
		  /* 82106DCCh */ case    8:  		/* bl -2476 */
		/* 82106DCCh case    8:*/		regs.LR = 0x82106DD0; return 0x82106420;
		/* 82106DCCh case    8:*/		return 0x82106DD0;
		  /* 82106DD0h */ case    9:  		/* lis R4, 9345 */
		/* 82106DD0h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82106DD0h case    9:*/		return 0x82106DD4;
		  /* 82106DD4h */ case   10:  		/* rlwinm R3, R28, 2, 0, 29 */
		/* 82106DD4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R28);
		/* 82106DD4h case   10:*/		return 0x82106DD8;
		  /* 82106DD8h */ case   11:  		/* bl -519128 */
		/* 82106DD8h case   11:*/		regs.LR = 0x82106DDC; return 0x82088200;
		/* 82106DD8h case   11:*/		return 0x82106DDC;
		  /* 82106DDCh */ case   12:  		/* or. R19, R3, R3 */
		/* 82106DDCh case   12:*/		cpu::op::or<1>(regs,&regs.R19,regs.R3,regs.R3);
		/* 82106DDCh case   12:*/		return 0x82106DE0;
		  /* 82106DE0h */ case   13:  		/* bc 12, CR0_EQ, 636 */
		/* 82106DE0h case   13:*/		if ( regs.CR[0].eq ) { return 0x8210705C;  }
		/* 82106DE0h case   13:*/		return 0x82106DE4;
		  /* 82106DE4h */ case   14:  		/* lwz R10, <#[R31 + 8]> */
		/* 82106DE4h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82106DE4h case   14:*/		return 0x82106DE8;
		  /* 82106DE8h */ case   15:  		/* li R21, 0 */
		/* 82106DE8h case   15:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 82106DE8h case   15:*/		return 0x82106DEC;
		  /* 82106DECh */ case   16:  		/* li R11, 0 */
		/* 82106DECh case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82106DECh case   16:*/		return 0x82106DF0;
		  /* 82106DF0h */ case   17:  		/* cmplwi CR6, R10, 0 */
		/* 82106DF0h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82106DF0h case   17:*/		return 0x82106DF4;
		  /* 82106DF4h */ case   18:  		/* bc 4, CR6_GT, 76 */
		/* 82106DF4h case   18:*/		if ( !regs.CR[6].gt ) { return 0x82106E40;  }
		/* 82106DF4h case   18:*/		return 0x82106DF8;
		  /* 82106DF8h */ case   19:  		/* li R10, 0 */
		/* 82106DF8h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82106DF8h case   19:*/		return 0x82106DFC;
		  /* 82106DFCh */ case   20:  		/* addi R9, R19, -4 */
		/* 82106DFCh case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R19,0xFFFFFFFC);
		/* 82106DFCh case   20:*/		return 0x82106E00;
		  /* 82106E00h */ case   21:  		/* lwz R8, <#[R31 + 20]> */
		/* 82106E00h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 82106E00h case   21:*/		return 0x82106E04;
		  /* 82106E04h */ case   22:  		/* lwz R7, <#[R31 + 16]> */
		/* 82106E04h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 82106E04h case   22:*/		return 0x82106E08;
		  /* 82106E08h */ case   23:  		/* lwzx R8, <#[R10 + R8]> */
		/* 82106E08h case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82106E08h case   23:*/		return 0x82106E0C;
		  /* 82106E0Ch */ case   24:  		/* lwz R8, <#[R8 + 4]> */
		/* 82106E0Ch case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 82106E0Ch case   24:*/		return 0x82106E10;
		  /* 82106E10h */ case   25:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82106E10h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82106E10h case   25:*/		return 0x82106E14;
		  /* 82106E14h */ case   26:  		/* lwzx R8, <#[R8 + R7]> */
		/* 82106E14h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 82106E14h case   26:*/		return 0x82106E18;
		  /* 82106E18h */ case   27:  		/* lwz R8, <#[R8 + 4]> */
		/* 82106E18h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 82106E18h case   27:*/		return 0x82106E1C;
		  /* 82106E1Ch */ case   28:  		/* rlwinm. R8, R8, 0, 26, 26 */
		/* 82106E1Ch case   28:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R8,regs.R8);
		/* 82106E1Ch case   28:*/		return 0x82106E20;
		  /* 82106E20h */ case   29:  		/* bc 12, CR0_EQ, 12 */
		/* 82106E20h case   29:*/		if ( regs.CR[0].eq ) { return 0x82106E2C;  }
		/* 82106E20h case   29:*/		return 0x82106E24;
		  /* 82106E24h */ case   30:  		/* stwu R11, <#[R9 + 4]> */
		/* 82106E24h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 82106E24h case   30:*/		return 0x82106E28;
		  /* 82106E28h */ case   31:  		/* addi R21, R21, 1 */
		/* 82106E28h case   31:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 82106E28h case   31:*/		return 0x82106E2C;
	}
	return 0x82106E2C;
} // Block from 82106DACh-82106E2Ch (32 instructions)

//////////////////////////////////////////////////////
// Block at 82106E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106E2C);
		  /* 82106E2Ch */ case    0:  		/* lwz R8, <#[R31 + 8]> */
		/* 82106E2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 82106E2Ch case    0:*/		return 0x82106E30;
		  /* 82106E30h */ case    1:  		/* addi R11, R11, 1 */
		/* 82106E30h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82106E30h case    1:*/		return 0x82106E34;
		  /* 82106E34h */ case    2:  		/* addi R10, R10, 4 */
		/* 82106E34h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82106E34h case    2:*/		return 0x82106E38;
		  /* 82106E38h */ case    3:  		/* cmplw CR6, R11, R8 */
		/* 82106E38h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82106E38h case    3:*/		return 0x82106E3C;
		  /* 82106E3Ch */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 82106E3Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82106E00;  }
		/* 82106E3Ch case    4:*/		return 0x82106E40;
	}
	return 0x82106E40;
} // Block from 82106E2Ch-82106E40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82106E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106E40);
		  /* 82106E40h */ case    0:  		/* lis R11, -32240 */
		/* 82106E40h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8210);
		/* 82106E40h case    0:*/		return 0x82106E44;
		  /* 82106E44h */ case    1:  		/* mr R6, R31 */
		/* 82106E44h case    1:*/		regs.R6 = regs.R31;
		/* 82106E44h case    1:*/		return 0x82106E48;
		  /* 82106E48h */ case    2:  		/* mr R5, R21 */
		/* 82106E48h case    2:*/		regs.R5 = regs.R21;
		/* 82106E48h case    2:*/		return 0x82106E4C;
		  /* 82106E4Ch */ case    3:  		/* mr R4, R19 */
		/* 82106E4Ch case    3:*/		regs.R4 = regs.R19;
		/* 82106E4Ch case    3:*/		return 0x82106E50;
		  /* 82106E50h */ case    4:  		/* addi R3, R11, -9928 */
		/* 82106E50h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFD938);
		/* 82106E50h case    4:*/		return 0x82106E54;
		  /* 82106E54h */ case    5:  		/* bl -36788 */
		/* 82106E54h case    5:*/		regs.LR = 0x82106E58; return 0x820FDEA0;
		/* 82106E54h case    5:*/		return 0x82106E58;
		  /* 82106E58h */ case    6:  		/* li R22, 0 */
		/* 82106E58h case    6:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82106E58h case    6:*/		return 0x82106E5C;
		  /* 82106E5Ch */ case    7:  		/* cmplwi CR6, R21, 0 */
		/* 82106E5Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 82106E5Ch case    7:*/		return 0x82106E60;
		  /* 82106E60h */ case    8:  		/* bc 12, CR6_EQ, 476 */
		/* 82106E60h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210703C;  }
		/* 82106E60h case    8:*/		return 0x82106E64;
		  /* 82106E64h */ case    9:  		/* li R20, -1 */
		/* 82106E64h case    9:*/		cpu::op::li<0>(regs,&regs.R20,0xFFFFFFFF);
		/* 82106E64h case    9:*/		return 0x82106E68;
		  /* 82106E68h */ case   10:  		/* rlwinm R10, R22, 2, 0, 29 */
		/* 82106E68h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R22);
		/* 82106E68h case   10:*/		return 0x82106E6C;
		  /* 82106E6Ch */ case   11:  		/* lwz R7, <#[R31 + 20]> */
		/* 82106E6Ch case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 82106E6Ch case   11:*/		return 0x82106E70;
		  /* 82106E70h */ case   12:  		/* addi R11, R22, 1 */
		/* 82106E70h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R22,0x1);
		/* 82106E70h case   12:*/		return 0x82106E74;
		  /* 82106E74h */ case   13:  		/* add R23, R10, R19 */
		/* 82106E74h case   13:*/		cpu::op::add<0>(regs,&regs.R23,regs.R10,regs.R19);
		/* 82106E74h case   13:*/		return 0x82106E78;
		  /* 82106E78h */ case   14:  		/* li R27, 1 */
		/* 82106E78h case   14:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82106E78h case   14:*/		return 0x82106E7C;
		  /* 82106E7Ch */ case   15:  		/* cmplw CR6, R11, R21 */
		/* 82106E7Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 82106E7Ch case   15:*/		return 0x82106E80;
		  /* 82106E80h */ case   16:  		/* lwzx R10, <#[R10 + R19]> */
		/* 82106E80h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R19 + 0x00000000) );
		/* 82106E80h case   16:*/		return 0x82106E84;
		  /* 82106E84h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82106E84h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82106E84h case   17:*/		return 0x82106E88;
		  /* 82106E88h */ case   18:  		/* lwzx R9, <#[R10 + R7]> */
		/* 82106E88h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82106E88h case   18:*/		return 0x82106E8C;
		  /* 82106E8Ch */ case   19:  		/* bc 4, CR6_LT, 88 */
		/* 82106E8Ch case   19:*/		if ( !regs.CR[6].lt ) { return 0x82106EE4;  }
		/* 82106E8Ch case   19:*/		return 0x82106E90;
		  /* 82106E90h */ case   20:  		/* lwz R6, <#[R9 + 4]> */
		/* 82106E90h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000004) );
		/* 82106E90h case   20:*/		return 0x82106E94;
		  /* 82106E94h */ case   21:  		/* addi R10, R23, 4 */
		/* 82106E94h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R23,0x4);
		/* 82106E94h case   21:*/		return 0x82106E98;
		  /* 82106E98h */ case   22:  		/* lwz R8, <#[R10]> */
		/* 82106E98h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82106E98h case   22:*/		return 0x82106E9C;
		  /* 82106E9Ch */ case   23:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82106E9Ch case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82106E9Ch case   23:*/		return 0x82106EA0;
		  /* 82106EA0h */ case   24:  		/* lwzx R8, <#[R8 + R7]> */
		/* 82106EA0h case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 82106EA0h case   24:*/		return 0x82106EA4;
		  /* 82106EA4h */ case   25:  		/* lwz R5, <#[R8 + 4]> */
		/* 82106EA4h case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000004) );
		/* 82106EA4h case   25:*/		return 0x82106EA8;
		  /* 82106EA8h */ case   26:  		/* cmplw CR6, R6, R5 */
		/* 82106EA8h case   26:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 82106EA8h case   26:*/		return 0x82106EAC;
		  /* 82106EACh */ case   27:  		/* bc 4, CR6_EQ, 56 */
		/* 82106EACh case   27:*/		if ( !regs.CR[6].eq ) { return 0x82106EE4;  }
		/* 82106EACh case   27:*/		return 0x82106EB0;
		  /* 82106EB0h */ case   28:  		/* lwz R5, <#[R9 + 8]> */
		/* 82106EB0h case   28:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000008) );
		/* 82106EB0h case   28:*/		return 0x82106EB4;
		  /* 82106EB4h */ case   29:  		/* lwz R4, <#[R8 + 8]> */
		/* 82106EB4h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + 0x00000008) );
		/* 82106EB4h case   29:*/		return 0x82106EB8;
		  /* 82106EB8h */ case   30:  		/* cmplw CR6, R5, R4 */
		/* 82106EB8h case   30:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 82106EB8h case   30:*/		return 0x82106EBC;
		  /* 82106EBCh */ case   31:  		/* bc 4, CR6_EQ, 40 */
		/* 82106EBCh case   31:*/		if ( !regs.CR[6].eq ) { return 0x82106EE4;  }
		/* 82106EBCh case   31:*/		return 0x82106EC0;
		  /* 82106EC0h */ case   32:  		/* lwz R5, <#[R9 + 12]> */
		/* 82106EC0h case   32:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x0000000C) );
		/* 82106EC0h case   32:*/		return 0x82106EC4;
		  /* 82106EC4h */ case   33:  		/* lwz R8, <#[R8 + 12]> */
		/* 82106EC4h case   33:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 82106EC4h case   33:*/		return 0x82106EC8;
		  /* 82106EC8h */ case   34:  		/* cmplw CR6, R5, R8 */
		/* 82106EC8h case   34:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R8);
		/* 82106EC8h case   34:*/		return 0x82106ECC;
		  /* 82106ECCh */ case   35:  		/* bc 4, CR6_EQ, 24 */
		/* 82106ECCh case   35:*/		if ( !regs.CR[6].eq ) { return 0x82106EE4;  }
		/* 82106ECCh case   35:*/		return 0x82106ED0;
		  /* 82106ED0h */ case   36:  		/* addi R11, R11, 1 */
		/* 82106ED0h case   36:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82106ED0h case   36:*/		return 0x82106ED4;
		  /* 82106ED4h */ case   37:  		/* addi R27, R27, 1 */
		/* 82106ED4h case   37:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82106ED4h case   37:*/		return 0x82106ED8;
		  /* 82106ED8h */ case   38:  		/* addi R10, R10, 4 */
		/* 82106ED8h case   38:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82106ED8h case   38:*/		return 0x82106EDC;
		  /* 82106EDCh */ case   39:  		/* cmplw CR6, R11, R21 */
		/* 82106EDCh case   39:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 82106EDCh case   39:*/		return 0x82106EE0;
		  /* 82106EE0h */ case   40:  		/* bc 12, CR6_LT, -72 */
		/* 82106EE0h case   40:*/		if ( regs.CR[6].lt ) { return 0x82106E98;  }
		/* 82106EE0h case   40:*/		return 0x82106EE4;
	}
	return 0x82106EE4;
} // Block from 82106E40h-82106EE4h (41 instructions)

//////////////////////////////////////////////////////
// Block at 82106EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106EE4);
		  /* 82106EE4h */ case    0:  		/* li R11, 1 */
		/* 82106EE4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82106EE4h case    0:*/		return 0x82106EE8;
		  /* 82106EE8h */ case    1:  		/* mr R4, R27 */
		/* 82106EE8h case    1:*/		regs.R4 = regs.R27;
		/* 82106EE8h case    1:*/		return 0x82106EEC;
		  /* 82106EECh */ case    2:  		/* mr R6, R20 */
		/* 82106EECh case    2:*/		regs.R6 = regs.R20;
		/* 82106EECh case    2:*/		return 0x82106EF0;
		  /* 82106EF0h */ case    3:  		/* rlwimi R4, R11, 28, 0, 11 */
		/* 82106EF0h case    3:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R4,regs.R11);
		/* 82106EF0h case    3:*/		return 0x82106EF4;
		  /* 82106EF4h */ case    4:  		/* mr R5, R20 */
		/* 82106EF4h case    4:*/		regs.R5 = regs.R20;
		/* 82106EF4h case    4:*/		return 0x82106EF8;
		  /* 82106EF8h */ case    5:  		/* mr R3, R31 */
		/* 82106EF8h case    5:*/		regs.R3 = regs.R31;
		/* 82106EF8h case    5:*/		return 0x82106EFC;
		  /* 82106EFCh */ case    6:  		/* bl -39988 */
		/* 82106EFCh case    6:*/		regs.LR = 0x82106F00; return 0x820FD2C8;
		/* 82106EFCh case    6:*/		return 0x82106F00;
		  /* 82106F00h */ case    7:  		/* cmpwi CR6, R3, -1 */
		/* 82106F00h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82106F00h case    7:*/		return 0x82106F04;
		  /* 82106F04h */ case    8:  		/* bc 12, CR6_EQ, 344 */
		/* 82106F04h case    8:*/		if ( regs.CR[6].eq ) { return 0x8210705C;  }
		/* 82106F04h case    8:*/		return 0x82106F08;
		  /* 82106F08h */ case    9:  		/* lwz R11, <#[R31 + 24]> */
		/* 82106F08h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82106F08h case    9:*/		return 0x82106F0C;
		  /* 82106F0Ch */ case   10:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82106F0Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82106F0Ch case   10:*/		return 0x82106F10;
		  /* 82106F10h */ case   11:  		/* li R24, 0 */
		/* 82106F10h case   11:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82106F10h case   11:*/		return 0x82106F14;
		  /* 82106F14h */ case   12:  		/* cmplwi CR6, R27, 0 */
		/* 82106F14h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82106F14h case   12:*/		return 0x82106F18;
		  /* 82106F18h */ case   13:  		/* lwzx R25, <#[R10 + R11]> */
		/* 82106F18h case   13:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82106F18h case   13:*/		return 0x82106F1C;
		  /* 82106F1Ch */ case   14:  		/* bc 12, CR6_EQ, 276 */
		/* 82106F1Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x82107030;  }
		/* 82106F1Ch case   14:*/		return 0x82106F20;
		  /* 82106F20h */ case   15:  		/* mr R26, R23 */
		/* 82106F20h case   15:*/		regs.R26 = regs.R23;
		/* 82106F20h case   15:*/		return 0x82106F24;
		  /* 82106F24h */ case   16:  		/* lwz R11, <#[R26]> */
		/* 82106F24h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82106F24h case   16:*/		return 0x82106F28;
		  /* 82106F28h */ case   17:  		/* lwz R10, <#[R31 + 20]> */
		/* 82106F28h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82106F28h case   17:*/		return 0x82106F2C;
		  /* 82106F2Ch */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82106F2Ch case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82106F2Ch case   18:*/		return 0x82106F30;
		  /* 82106F30h */ case   19:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82106F30h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82106F30h case   19:*/		return 0x82106F34;
		  /* 82106F34h */ case   20:  		/* lwz R11, <#[R10 + 72]> */
		/* 82106F34h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000048) );
		/* 82106F34h case   20:*/		return 0x82106F38;
		  /* 82106F38h */ case   21:  		/* lwz R28, <#[R10 + 48]> */
		/* 82106F38h case   21:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + 0x00000030) );
		/* 82106F38h case   21:*/		return 0x82106F3C;
		  /* 82106F3Ch */ case   22:  		/* b 148 */
		/* 82106F3Ch case   22:*/		return 0x82106FD0;
		/* 82106F3Ch case   22:*/		return 0x82106F40;
		  /* 82106F40h */ case   23:  		/* lwz R10, <#[R31 + 24]> */
		/* 82106F40h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82106F40h case   23:*/		return 0x82106F44;
		  /* 82106F44h */ case   24:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82106F44h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82106F44h case   24:*/		return 0x82106F48;
		  /* 82106F48h */ case   25:  		/* lwzx R30, <#[R11 + R10]> */
		/* 82106F48h case   25:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82106F48h case   25:*/		return 0x82106F4C;
		  /* 82106F4Ch */ case   26:  		/* lwz R11, <#[R30 + 60]> */
		/* 82106F4Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000003C) );
		/* 82106F4Ch case   26:*/		return 0x82106F50;
		  /* 82106F50h */ case   27:  		/* cmplwi CR6, R11, 0 */
		/* 82106F50h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106F50h case   27:*/		return 0x82106F54;
		  /* 82106F54h */ case   28:  		/* bc 12, CR6_EQ, 24 */
		/* 82106F54h case   28:*/		if ( regs.CR[6].eq ) { return 0x82106F6C;  }
		/* 82106F54h case   28:*/		return 0x82106F58;
		  /* 82106F58h */ case   29:  		/* mr R4, R30 */
		/* 82106F58h case   29:*/		regs.R4 = regs.R30;
		/* 82106F58h case   29:*/		return 0x82106F5C;
		  /* 82106F5Ch */ case   30:  		/* mr R3, R25 */
		/* 82106F5Ch case   30:*/		regs.R3 = regs.R25;
		/* 82106F5Ch case   30:*/		return 0x82106F60;
		  /* 82106F60h */ case   31:  		/* bl -45168 */
		/* 82106F60h case   31:*/		regs.LR = 0x82106F64; return 0x820FBEF0;
		/* 82106F60h case   31:*/		return 0x82106F64;
		  /* 82106F64h */ case   32:  		/* or. R29, R3, R3 */
		/* 82106F64h case   32:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 82106F64h case   32:*/		return 0x82106F68;
		  /* 82106F68h */ case   33:  		/* bc 12, CR0_LT, 216 */
		/* 82106F68h case   33:*/		if ( regs.CR[0].lt ) { return 0x82107040;  }
		/* 82106F68h case   33:*/		return 0x82106F6C;
	}
	return 0x82106F6C;
} // Block from 82106EE4h-82106F6Ch (34 instructions)

//////////////////////////////////////////////////////
// Block at 82106F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106F6C);
		  /* 82106F6Ch */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82106F6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82106F6Ch case    0:*/		return 0x82106F70;
		  /* 82106F70h */ case    1:  		/* lis R10, 4096 */
		/* 82106F70h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 82106F70h case    1:*/		return 0x82106F74;
		  /* 82106F74h */ case    2:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82106F74h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82106F74h case    2:*/		return 0x82106F78;
		  /* 82106F78h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82106F78h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82106F78h case    3:*/		return 0x82106F7C;
		  /* 82106F7Ch */ case    4:  		/* bc 4, CR6_EQ, 92 */
		/* 82106F7Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82106FD8;  }
		/* 82106F7Ch case    4:*/		return 0x82106F80;
		  /* 82106F80h */ case    5:  		/* lwz R8, <#[R30 + 12]> */
		/* 82106F80h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000000C) );
		/* 82106F80h case    5:*/		return 0x82106F84;
		  /* 82106F84h */ case    6:  		/* li R10, 0 */
		/* 82106F84h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82106F84h case    6:*/		return 0x82106F88;
	}
	return 0x82106F88;
} // Block from 82106F6Ch-82106F88h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82106F88h
// Function '?RemapArguments@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106F88);
		  /* 82106F88h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 82106F88h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82106F88h case    0:*/		return 0x82106F8C;
		  /* 82106F8Ch */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 82106F8Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82106FB4;  }
		/* 82106F8Ch case    1:*/		return 0x82106F90;
		  /* 82106F90h */ case    2:  		/* lwz R9, <#[R30 + 16]> */
		/* 82106F90h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 82106F90h case    2:*/		return 0x82106F94;
		  /* 82106F94h */ case    3:  		/* li R11, 0 */
		/* 82106F94h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82106F94h case    3:*/		return 0x82106F98;
		  /* 82106F98h */ case    4:  		/* lwzx R7, <#[R11 + R9]> */
		/* 82106F98h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82106F98h case    4:*/		return 0x82106F9C;
		  /* 82106F9Ch */ case    5:  		/* cmplw CR6, R28, R7 */
		/* 82106F9Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R7);
		/* 82106F9Ch case    5:*/		return 0x82106FA0;
		  /* 82106FA0h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82106FA0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82106FB4;  }
		/* 82106FA0h case    6:*/		return 0x82106FA4;
		  /* 82106FA4h */ case    7:  		/* addi R10, R10, 1 */
		/* 82106FA4h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82106FA4h case    7:*/		return 0x82106FA8;
		  /* 82106FA8h */ case    8:  		/* addi R11, R11, 4 */
		/* 82106FA8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82106FA8h case    8:*/		return 0x82106FAC;
		  /* 82106FACh */ case    9:  		/* cmplw CR6, R10, R8 */
		/* 82106FACh case    9:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82106FACh case    9:*/		return 0x82106FB0;
		  /* 82106FB0h */ case   10:  		/* bc 12, CR6_LT, -24 */
		/* 82106FB0h case   10:*/		if ( regs.CR[6].lt ) { return 0x82106F98;  }
		/* 82106FB0h case   10:*/		return 0x82106FB4;
	}
	return 0x82106FB4;
} // Block from 82106F88h-82106FB4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82106FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106FB4);
		  /* 82106FB4h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82106FB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82106FB4h case    0:*/		return 0x82106FB8;
		  /* 82106FB8h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82106FB8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82106FB8h case    1:*/		return 0x82106FBC;
		  /* 82106FBCh */ case    2:  		/* lwz R9, <#[R31 + 20]> */
		/* 82106FBCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 82106FBCh case    2:*/		return 0x82106FC0;
		  /* 82106FC0h */ case    3:  		/* lwzx R28, <#[R10 + R11]> */
		/* 82106FC0h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82106FC0h case    3:*/		return 0x82106FC4;
		  /* 82106FC4h */ case    4:  		/* rlwinm R11, R28, 2, 0, 29 */
		/* 82106FC4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R28);
		/* 82106FC4h case    4:*/		return 0x82106FC8;
		  /* 82106FC8h */ case    5:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82106FC8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82106FC8h case    5:*/		return 0x82106FCC;
		  /* 82106FCCh */ case    6:  		/* lwz R11, <#[R11 + 72]> */
		/* 82106FCCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82106FCCh case    6:*/		return 0x82106FD0;
	}
	return 0x82106FD0;
} // Block from 82106FB4h-82106FD0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82106FD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106FD0);
		  /* 82106FD0h */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 82106FD0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82106FD0h case    0:*/		return 0x82106FD4;
		  /* 82106FD4h */ case    1:  		/* bc 4, CR6_EQ, -148 */
		/* 82106FD4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82106F40;  }
		/* 82106FD4h case    1:*/		return 0x82106FD8;
	}
	return 0x82106FD8;
} // Block from 82106FD0h-82106FD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82106FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106FD8);
		  /* 82106FD8h */ case    0:  		/* lwz R11, <#[R25 + 60]> */
		/* 82106FD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000003C) );
		/* 82106FD8h case    0:*/		return 0x82106FDC;
		  /* 82106FDCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82106FDCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82106FDCh case    1:*/		return 0x82106FE0;
		  /* 82106FE0h */ case    2:  		/* bc 4, CR6_EQ, 20 */
		/* 82106FE0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82106FF4;  }
		/* 82106FE0h case    2:*/		return 0x82106FE4;
		  /* 82106FE4h */ case    3:  		/* addi R24, R24, 1 */
		/* 82106FE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 82106FE4h case    3:*/		return 0x82106FE8;
		  /* 82106FE8h */ case    4:  		/* addi R26, R26, 4 */
		/* 82106FE8h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 82106FE8h case    4:*/		return 0x82106FEC;
		  /* 82106FECh */ case    5:  		/* cmplw CR6, R24, R27 */
		/* 82106FECh case    5:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R27);
		/* 82106FECh case    5:*/		return 0x82106FF0;
		  /* 82106FF0h */ case    6:  		/* bc 12, CR6_LT, -204 */
		/* 82106FF0h case    6:*/		if ( regs.CR[6].lt ) { return 0x82106F24;  }
		/* 82106FF0h case    6:*/		return 0x82106FF4;
	}
	return 0x82106FF4;
} // Block from 82106FD8h-82106FF4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82106FF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82106FF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82106FF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82106FF4);
		  /* 82106FF4h */ case    0:  		/* mtspr CTR, R27 */
		/* 82106FF4h case    0:*/		regs.CTR = regs.R27;
		/* 82106FF4h case    0:*/		return 0x82106FF8;
		  /* 82106FF8h */ case    1:  		/* li R11, 0 */
		/* 82106FF8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82106FF8h case    1:*/		return 0x82106FFC;
		  /* 82106FFCh */ case    2:  		/* addi R10, R23, -4 */
		/* 82106FFCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R23,0xFFFFFFFC);
		/* 82106FFCh case    2:*/		return 0x82107000;
		  /* 82107000h */ case    3:  		/* lwz R9, <#[R10 + 4]> */
		/* 82107000h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82107000h case    3:*/		return 0x82107004;
		  /* 82107004h */ case    4:  		/* lwz R8, <#[R31 + 20]> */
		/* 82107004h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 82107004h case    4:*/		return 0x82107008;
		  /* 82107008h */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82107008h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82107008h case    5:*/		return 0x8210700C;
		  /* 8210700Ch */ case    6:  		/* lwz R7, <#[R25 + 8]> */
		/* 8210700Ch case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000008) );
		/* 8210700Ch case    6:*/		return 0x82107010;
		  /* 82107010h */ case    7:  		/* lwzx R9, <#[R9 + R8]> */
		/* 82107010h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82107010h case    7:*/		return 0x82107014;
		  /* 82107014h */ case    8:  		/* lwz R9, <#[R9 + 48]> */
		/* 82107014h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000030) );
		/* 82107014h case    8:*/		return 0x82107018;
		  /* 82107018h */ case    9:  		/* stwx R9, <#[R11 + R7]> */
		/* 82107018h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 82107018h case    9:*/		return 0x8210701C;
		  /* 8210701Ch */ case   10:  		/* lwz R8, <#[R25 + 16]> */
		/* 8210701Ch case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R25 + 0x00000010) );
		/* 8210701Ch case   10:*/		return 0x82107020;
		  /* 82107020h */ case   11:  		/* lwzu R9, <#[R10 + 4]> */
		/* 82107020h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82107020h case   11:*/		return 0x82107024;
		  /* 82107024h */ case   12:  		/* stwx R9, <#[R11 + R8]> */
		/* 82107024h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82107024h case   12:*/		return 0x82107028;
		  /* 82107028h */ case   13:  		/* addi R11, R11, 4 */
		/* 82107028h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82107028h case   13:*/		return 0x8210702C;
		  /* 8210702Ch */ case   14:  		/* bc 16, CR0_LT, -44 */
		/* 8210702Ch case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82107000;  }
		/* 8210702Ch case   14:*/		return 0x82107030;
	}
	return 0x82107030;
} // Block from 82106FF4h-82107030h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82107030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107030);
		  /* 82107030h */ case    0:  		/* add R22, R27, R22 */
		/* 82107030h case    0:*/		cpu::op::add<0>(regs,&regs.R22,regs.R27,regs.R22);
		/* 82107030h case    0:*/		return 0x82107034;
		  /* 82107034h */ case    1:  		/* cmplw CR6, R22, R21 */
		/* 82107034h case    1:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R21);
		/* 82107034h case    1:*/		return 0x82107038;
		  /* 82107038h */ case    2:  		/* bc 12, CR6_LT, -464 */
		/* 82107038h case    2:*/		if ( regs.CR[6].lt ) { return 0x82106E68;  }
		/* 82107038h case    2:*/		return 0x8210703C;
	}
	return 0x8210703C;
} // Block from 82107030h-8210703Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210703Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210703C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210703C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210703C);
		  /* 8210703Ch */ case    0:  		/* li R29, 0 */
		/* 8210703Ch case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210703Ch case    0:*/		return 0x82107040;
	}
	return 0x82107040;
} // Block from 8210703Ch-82107040h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107040);
		  /* 82107040h */ case    0:  		/* lis R4, 9345 */
		/* 82107040h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82107040h case    0:*/		return 0x82107044;
		  /* 82107044h */ case    1:  		/* mr R3, R19 */
		/* 82107044h case    1:*/		regs.R3 = regs.R19;
		/* 82107044h case    1:*/		return 0x82107048;
		  /* 82107048h */ case    2:  		/* bl -519440 */
		/* 82107048h case    2:*/		regs.LR = 0x8210704C; return 0x82088338;
		/* 82107048h case    2:*/		return 0x8210704C;
		  /* 8210704Ch */ case    3:  		/* mr R3, R29 */
		/* 8210704Ch case    3:*/		regs.R3 = regs.R29;
		/* 8210704Ch case    3:*/		return 0x82107050;
		  /* 82107050h */ case    4:  		/* addi R1, R1, 208 */
		/* 82107050h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 82107050h case    4:*/		return 0x82107054;
		  /* 82107054h */ case    5:  		/* lfd FR31, <#[R1 - 120]> */
		/* 82107054h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 82107054h case    5:*/		return 0x82107058;
		  /* 82107058h */ case    6:  		/* b -482772 */
		/* 82107058h case    6:*/		return 0x82091284;
		/* 82107058h case    6:*/		return 0x8210705C;
	}
	return 0x8210705C;
} // Block from 82107040h-8210705Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210705Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210705C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210705C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210705C);
		  /* 8210705Ch */ case    0:  		/* lis R29, -32761 */
		/* 8210705Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8007);
		/* 8210705Ch case    0:*/		return 0x82107060;
		  /* 82107060h */ case    1:  		/* ori R29, R29, 14 */
		/* 82107060h case    1:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0xE);
		/* 82107060h case    1:*/		return 0x82107064;
		  /* 82107064h */ case    2:  		/* b -36 */
		/* 82107064h case    2:*/		return 0x82107040;
		/* 82107064h case    2:*/		return 0x82107068;
	}
	return 0x82107068;
} // Block from 8210705Ch-82107068h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82107068h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107068);
		  /* 82107068h */ case    0:  		/* mfspr R12, LR */
		/* 82107068h case    0:*/		regs.R12 = regs.LR;
		/* 82107068h case    0:*/		return 0x8210706C;
		  /* 8210706Ch */ case    1:  		/* bl -482868 */
		/* 8210706Ch case    1:*/		regs.LR = 0x82107070; return 0x82091238;
		/* 8210706Ch case    1:*/		return 0x82107070;
		  /* 82107070h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82107070h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82107070h case    2:*/		return 0x82107074;
		  /* 82107074h */ case    3:  		/* li R24, 0 */
		/* 82107074h case    3:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82107074h case    3:*/		return 0x82107078;
		  /* 82107078h */ case    4:  		/* mr R26, R3 */
		/* 82107078h case    4:*/		regs.R26 = regs.R3;
		/* 82107078h case    4:*/		return 0x8210707C;
		  /* 8210707Ch */ case    5:  		/* mr R21, R24 */
		/* 8210707Ch case    5:*/		regs.R21 = regs.R24;
		/* 8210707Ch case    5:*/		return 0x82107080;
		  /* 82107080h */ case    6:  		/* bl -5352 */
		/* 82107080h case    6:*/		regs.LR = 0x82107084; return 0x82105B98;
		/* 82107080h case    6:*/		return 0x82107084;
		  /* 82107084h */ case    7:  		/* lwz R11, <#[R26 + 8]> */
		/* 82107084h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82107084h case    7:*/		return 0x82107088;
		  /* 82107088h */ case    8:  		/* mr R9, R24 */
		/* 82107088h case    8:*/		regs.R9 = regs.R24;
		/* 82107088h case    8:*/		return 0x8210708C;
		  /* 8210708Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8210708Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210708Ch case    9:*/		return 0x82107090;
		  /* 82107090h */ case   10:  		/* bc 4, CR6_GT, 84 */
		/* 82107090h case   10:*/		if ( !regs.CR[6].gt ) { return 0x821070E4;  }
		/* 82107090h case   10:*/		return 0x82107094;
		  /* 82107094h */ case   11:  		/* mr R10, R24 */
		/* 82107094h case   11:*/		regs.R10 = regs.R24;
		/* 82107094h case   11:*/		return 0x82107098;
		  /* 82107098h */ case   12:  		/* lwz R11, <#[R26 + 20]> */
		/* 82107098h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82107098h case   12:*/		return 0x8210709C;
		  /* 8210709Ch */ case   13:  		/* lwz R8, <#[R26 + 16]> */
		/* 8210709Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000010) );
		/* 8210709Ch case   13:*/		return 0x821070A0;
		  /* 821070A0h */ case   14:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821070A0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821070A0h case   14:*/		return 0x821070A4;
		  /* 821070A4h */ case   15:  		/* lwz R7, <#[R11 + 4]> */
		/* 821070A4h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821070A4h case   15:*/		return 0x821070A8;
		  /* 821070A8h */ case   16:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 821070A8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 821070A8h case   16:*/		return 0x821070AC;
		  /* 821070ACh */ case   17:  		/* lwzx R8, <#[R7 + R8]> */
		/* 821070ACh case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 821070ACh case   17:*/		return 0x821070B0;
		  /* 821070B0h */ case   18:  		/* lwz R8, <#[R8 + 4]> */
		/* 821070B0h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 821070B0h case   18:*/		return 0x821070B4;
		  /* 821070B4h */ case   19:  		/* rlwinm R8, R8, 0, 15, 26 */
		/* 821070B4h case   19:*/		cpu::op::rlwinm<0,0,15,26>(regs,&regs.R8,regs.R8);
		/* 821070B4h case   19:*/		return 0x821070B8;
		  /* 821070B8h */ case   20:  		/* rlwinm. R8, R8, 0, 26, 15 */
		/* 821070B8h case   20:*/		cpu::op::rlwinm<1,0,26,15>(regs,&regs.R8,regs.R8);
		/* 821070B8h case   20:*/		return 0x821070BC;
		  /* 821070BCh */ case   21:  		/* bc 12, CR0_EQ, 16 */
		/* 821070BCh case   21:*/		if ( regs.CR[0].eq ) { return 0x821070CC;  }
		/* 821070BCh case   21:*/		return 0x821070C0;
		  /* 821070C0h */ case   22:  		/* li R8, 2 */
		/* 821070C0h case   22:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 821070C0h case   22:*/		return 0x821070C4;
		  /* 821070C4h */ case   23:  		/* stw R8, <#[R11 + 84]> */
		/* 821070C4h case   23:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000054) );
		/* 821070C4h case   23:*/		return 0x821070C8;
		  /* 821070C8h */ case   24:  		/* b 8 */
		/* 821070C8h case   24:*/		return 0x821070D0;
		/* 821070C8h case   24:*/		return 0x821070CC;
	}
	return 0x821070CC;
} // Block from 82107068h-821070CCh (25 instructions)

//////////////////////////////////////////////////////
// Block at 821070CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821070CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821070CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821070CC);
		  /* 821070CCh */ case    0:  		/* stw R24, <#[R11 + 84]> */
		/* 821070CCh case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000054) );
		/* 821070CCh case    0:*/		return 0x821070D0;
	}
	return 0x821070D0;
} // Block from 821070CCh-821070D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821070D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821070D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821070D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821070D0);
		  /* 821070D0h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 821070D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821070D0h case    0:*/		return 0x821070D4;
		  /* 821070D4h */ case    1:  		/* addi R9, R9, 1 */
		/* 821070D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821070D4h case    1:*/		return 0x821070D8;
		  /* 821070D8h */ case    2:  		/* addi R10, R10, 4 */
		/* 821070D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821070D8h case    2:*/		return 0x821070DC;
		  /* 821070DCh */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 821070DCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821070DCh case    3:*/		return 0x821070E0;
		  /* 821070E0h */ case    4:  		/* bc 12, CR6_LT, -72 */
		/* 821070E0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82107098;  }
		/* 821070E0h case    4:*/		return 0x821070E4;
	}
	return 0x821070E4;
} // Block from 821070D0h-821070E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821070E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821070E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821070E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821070E4);
		  /* 821070E4h */ case    0:  		/* lwz R8, <#[R26 + 12]> */
		/* 821070E4h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x0000000C) );
		/* 821070E4h case    0:*/		return 0x821070E8;
		  /* 821070E8h */ case    1:  		/* lis R25, 8336 */
		/* 821070E8h case    1:*/		cpu::op::lis<0>(regs,&regs.R25,0x2090);
		/* 821070E8h case    1:*/		return 0x821070EC;
		  /* 821070ECh */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 821070ECh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821070ECh case    2:*/		return 0x821070F0;
		  /* 821070F0h */ case    3:  		/* bc 12, CR6_EQ, 128 */
		/* 821070F0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82107170;  }
		/* 821070F0h case    3:*/		return 0x821070F4;
		  /* 821070F4h */ case    4:  		/* rlwinm R6, R8, 2, 0, 29 */
		/* 821070F4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R8);
		/* 821070F4h case    4:*/		return 0x821070F8;
		  /* 821070F8h */ case    5:  		/* lwz R11, <#[R26 + 24]> */
		/* 821070F8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 821070F8h case    5:*/		return 0x821070FC;
		  /* 821070FCh */ case    6:  		/* addi R6, R6, -4 */
		/* 821070FCh case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFC);
		/* 821070FCh case    6:*/		return 0x82107100;
		  /* 82107100h */ case    7:  		/* addi R8, R8, -1 */
		/* 82107100h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 82107100h case    7:*/		return 0x82107104;
		  /* 82107104h */ case    8:  		/* lwzx R11, <#[R6 + R11]> */
		/* 82107104h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82107104h case    8:*/		return 0x82107108;
		  /* 82107108h */ case    9:  		/* lwz R10, <#[R11]> */
		/* 82107108h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82107108h case    9:*/		return 0x8210710C;
		  /* 8210710Ch */ case   10:  		/* rlwinm R10, R10, 0, 0, 11 */
		/* 8210710Ch case   10:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R10);
		/* 8210710Ch case   10:*/		return 0x82107110;
		  /* 82107110h */ case   11:  		/* cmplw CR6, R10, R25 */
		/* 82107110h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R25);
		/* 82107110h case   11:*/		return 0x82107114;
		  /* 82107114h */ case   12:  		/* bc 4, CR6_EQ, 84 */
		/* 82107114h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82107168;  }
		/* 82107114h case   12:*/		return 0x82107118;
		  /* 82107118h */ case   13:  		/* lwz R10, <#[R11 + 12]> */
		/* 82107118h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82107118h case   13:*/		return 0x8210711C;
		  /* 8210711Ch */ case   14:  		/* mr R7, R24 */
		/* 8210711Ch case   14:*/		regs.R7 = regs.R24;
		/* 8210711Ch case   14:*/		return 0x82107120;
		  /* 82107120h */ case   15:  		/* cmplwi CR6, R10, 0 */
		/* 82107120h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82107120h case   15:*/		return 0x82107124;
		  /* 82107124h */ case   16:  		/* bc 4, CR6_GT, 68 */
		/* 82107124h case   16:*/		if ( !regs.CR[6].gt ) { return 0x82107168;  }
		/* 82107124h case   16:*/		return 0x82107128;
	}
	return 0x82107128;
} // Block from 821070E4h-82107128h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82107128h
// Function '??_ECTransform@D3DXShader@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107128);
		  /* 82107128h */ case    0:  		/* mr R10, R24 */
		/* 82107128h case    0:*/		regs.R10 = regs.R24;
		/* 82107128h case    0:*/		return 0x8210712C;
		  /* 8210712Ch */ case    1:  		/* lwz R9, <#[R11 + 16]> */
		/* 8210712Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 8210712Ch case    1:*/		return 0x82107130;
		  /* 82107130h */ case    2:  		/* lwz R5, <#[R26 + 20]> */
		/* 82107130h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x00000014) );
		/* 82107130h case    2:*/		return 0x82107134;
		  /* 82107134h */ case    3:  		/* lwzx R9, <#[R9 + R10]> */
		/* 82107134h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82107134h case    3:*/		return 0x82107138;
		  /* 82107138h */ case    4:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82107138h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82107138h case    4:*/		return 0x8210713C;
		  /* 8210713Ch */ case    5:  		/* lwzx R9, <#[R9 + R5]> */
		/* 8210713Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 8210713Ch case    5:*/		return 0x82107140;
		  /* 82107140h */ case    6:  		/* lwz R5, <#[R9 + 84]> */
		/* 82107140h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000054) );
		/* 82107140h case    6:*/		return 0x82107144;
		  /* 82107144h */ case    7:  		/* cmplwi CR6, R5, 2 */
		/* 82107144h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000002);
		/* 82107144h case    7:*/		return 0x82107148;
		  /* 82107148h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82107148h case    8:*/		if ( regs.CR[6].eq ) { return 0x82107154;  }
		/* 82107148h case    8:*/		return 0x8210714C;
		  /* 8210714Ch */ case    9:  		/* li R5, 1 */
		/* 8210714Ch case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8210714Ch case    9:*/		return 0x82107150;
		  /* 82107150h */ case   10:  		/* stw R5, <#[R9 + 84]> */
		/* 82107150h case   10:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R9 + 0x00000054) );
		/* 82107150h case   10:*/		return 0x82107154;
	}
	return 0x82107154;
} // Block from 82107128h-82107154h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82107154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107154);
		  /* 82107154h */ case    0:  		/* lwz R9, <#[R11 + 12]> */
		/* 82107154h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82107154h case    0:*/		return 0x82107158;
		  /* 82107158h */ case    1:  		/* addi R7, R7, 1 */
		/* 82107158h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82107158h case    1:*/		return 0x8210715C;
		  /* 8210715Ch */ case    2:  		/* addi R10, R10, 4 */
		/* 8210715Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210715Ch case    2:*/		return 0x82107160;
		  /* 82107160h */ case    3:  		/* cmplw CR6, R7, R9 */
		/* 82107160h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 82107160h case    3:*/		return 0x82107164;
		  /* 82107164h */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 82107164h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210712C;  }
		/* 82107164h case    4:*/		return 0x82107168;
	}
	return 0x82107168;
} // Block from 82107154h-82107168h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82107168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107168);
		  /* 82107168h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 82107168h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82107168h case    0:*/		return 0x8210716C;
		  /* 8210716Ch */ case    1:  		/* bc 4, CR6_EQ, -116 */
		/* 8210716Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821070F8;  }
		/* 8210716Ch case    1:*/		return 0x82107170;
	}
	return 0x82107170;
} // Block from 82107168h-82107170h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82107170h
// Function '??_ECProgram@D3DXShader@@UAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107170);
		  /* 82107170h */ case    0:  		/* lis R23, 4096 */
		/* 82107170h case    0:*/		cpu::op::lis<0>(regs,&regs.R23,0x1000);
		/* 82107170h case    0:*/		return 0x82107174;
		  /* 82107174h */ case    1:  		/* lis R22, 16384 */
		/* 82107174h case    1:*/		cpu::op::lis<0>(regs,&regs.R22,0x4000);
		/* 82107174h case    1:*/		return 0x82107178;
		  /* 82107178h */ case    2:  		/* lwz R29, <#[R26 + 12]> */
		/* 82107178h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R26 + 0x0000000C) );
		/* 82107178h case    2:*/		return 0x8210717C;
		  /* 8210717Ch */ case    3:  		/* mr R27, R24 */
		/* 8210717Ch case    3:*/		regs.R27 = regs.R24;
		/* 8210717Ch case    3:*/		return 0x82107180;
		  /* 82107180h */ case    4:  		/* cmplwi CR6, R29, 0 */
		/* 82107180h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82107180h case    4:*/		return 0x82107184;
		  /* 82107184h */ case    5:  		/* bc 12, CR6_EQ, 792 */
		/* 82107184h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210749C;  }
		/* 82107184h case    5:*/		return 0x82107188;
		  /* 82107188h */ case    6:  		/* rlwinm R28, R29, 2, 0, 29 */
		/* 82107188h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R29);
		/* 82107188h case    6:*/		return 0x8210718C;
		  /* 8210718Ch */ case    7:  		/* lwz R11, <#[R26 + 24]> */
		/* 8210718Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 8210718Ch case    7:*/		return 0x82107190;
		  /* 82107190h */ case    8:  		/* addi R28, R28, -4 */
		/* 82107190h case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0xFFFFFFFC);
		/* 82107190h case    8:*/		return 0x82107194;
		  /* 82107194h */ case    9:  		/* addi R29, R29, -1 */
		/* 82107194h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 82107194h case    9:*/		return 0x82107198;
		  /* 82107198h */ case   10:  		/* lwzx R9, <#[R28 + R11]> */
		/* 82107198h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 82107198h case   10:*/		return 0x8210719C;
		  /* 8210719Ch */ case   11:  		/* lwz R11, <#[R9]> */
		/* 8210719Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8210719Ch case   11:*/		return 0x821071A0;
		  /* 821071A0h */ case   12:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 821071A0h case   12:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 821071A0h case   12:*/		return 0x821071A4;
		  /* 821071A4h */ case   13:  		/* bc 12, CR0_EQ, 396 */
		/* 821071A4h case   13:*/		if ( regs.CR[0].eq ) { return 0x82107330;  }
		/* 821071A4h case   13:*/		return 0x821071A8;
		  /* 821071A8h */ case   14:  		/* rlwinm R10, R11, 0, 0, 3 */
		/* 821071A8h case   14:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R11);
		/* 821071A8h case   14:*/		return 0x821071AC;
		  /* 821071ACh */ case   15:  		/* cmplw CR6, R10, R23 */
		/* 821071ACh case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R23);
		/* 821071ACh case   15:*/		return 0x821071B0;
		  /* 821071B0h */ case   16:  		/* bc 12, CR6_LT, 180 */
		/* 821071B0h case   16:*/		if ( regs.CR[6].lt ) { return 0x82107264;  }
		/* 821071B0h case   16:*/		return 0x821071B4;
		  /* 821071B4h */ case   17:  		/* cmplw CR6, R10, R22 */
		/* 821071B4h case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R22);
		/* 821071B4h case   17:*/		return 0x821071B8;
		  /* 821071B8h */ case   18:  		/* bc 12, CR6_GT, 172 */
		/* 821071B8h case   18:*/		if ( regs.CR[6].gt ) { return 0x82107264;  }
		/* 821071B8h case   18:*/		return 0x821071BC;
		  /* 821071BCh */ case   19:  		/* lwz R10, <#[R9 + 4]> */
		/* 821071BCh case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 821071BCh case   19:*/		return 0x821071C0;
	}
	return 0x821071C0;
} // Block from 82107170h-821071C0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821071C0h
// Function '?Initialize@CProgram@D3DXShader@@QAAJPAVCNode@2@PAVCTErrors@2@KK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821071C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821071C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821071C0);
		  /* 821071C0h */ case    0:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 821071C0h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 821071C0h case    0:*/		return 0x821071C4;
		  /* 821071C4h */ case    1:  		/* lwz R8, <#[R9 + 12]> */
		/* 821071C4h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 821071C4h case    1:*/		return 0x821071C8;
		  /* 821071C8h */ case    2:  		/* mr R6, R24 */
		/* 821071C8h case    2:*/		regs.R6 = regs.R24;
		/* 821071C8h case    2:*/		return 0x821071CC;
		  /* 821071CCh */ case    3:  		/* divwu R31, R10, R11 */
		/* 821071CCh case    3:*/		cpu::op::divwu<0>(regs,&regs.R31,regs.R10,regs.R11);
		/* 821071CCh case    3:*/		return 0x821071D0;
		  /* 821071D0h */ case    4:  		/* twi 6, R11, 0 */
		/* 821071D0h case    4:*/		cpu::op::tw<6>(regs, 0x821071D0, regs.R11, 0x00000000);
		/* 821071D0h case    4:*/		return 0x821071D4;
		  /* 821071D4h */ case    5:  		/* cmplwi CR6, R8, 0 */
		/* 821071D4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821071D4h case    5:*/		return 0x821071D8;
		  /* 821071D8h */ case    6:  		/* bc 4, CR6_GT, 344 */
		/* 821071D8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82107330;  }
		/* 821071D8h case    6:*/		return 0x821071DC;
		  /* 821071DCh */ case    7:  		/* mr R30, R24 */
		/* 821071DCh case    7:*/		regs.R30 = regs.R24;
		/* 821071DCh case    7:*/		return 0x821071E0;
		  /* 821071E0h */ case    8:  		/* lwz R11, <#[R9 + 16]> */
		/* 821071E0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 821071E0h case    8:*/		return 0x821071E4;
		  /* 821071E4h */ case    9:  		/* lwz R10, <#[R26 + 20]> */
		/* 821071E4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 821071E4h case    9:*/		return 0x821071E8;
		  /* 821071E8h */ case   10:  		/* lwzx R4, <#[R30 + R11]> */
		/* 821071E8h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821071E8h case   10:*/		return 0x821071EC;
		  /* 821071ECh */ case   11:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 821071ECh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 821071ECh case   11:*/		return 0x821071F0;
		  /* 821071F0h */ case   12:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821071F0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821071F0h case   12:*/		return 0x821071F4;
		  /* 821071F4h */ case   13:  		/* lwz R7, <#[R11 + 84]> */
		/* 821071F4h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000054) );
		/* 821071F4h case   13:*/		return 0x821071F8;
		  /* 821071F8h */ case   14:  		/* cmplwi CR6, R7, 1 */
		/* 821071F8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000001);
		/* 821071F8h case   14:*/		return 0x821071FC;
		  /* 821071FCh */ case   15:  		/* bc 4, CR6_EQ, 8 */
		/* 821071FCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x82107204;  }
		/* 821071FCh case   15:*/		return 0x82107200;
		  /* 82107200h */ case   16:  		/* li R27, 1 */
		/* 82107200h case   16:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82107200h case   16:*/		return 0x82107204;
	}
	return 0x82107204;
} // Block from 821071C0h-82107204h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82107204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107204);
		  /* 82107204h */ case    0:  		/* mr R5, R7 */
		/* 82107204h case    0:*/		regs.R5 = regs.R7;
		/* 82107204h case    0:*/		return 0x82107208;
		  /* 82107208h */ case    1:  		/* mr R3, R26 */
		/* 82107208h case    1:*/		regs.R3 = regs.R26;
		/* 82107208h case    1:*/		return 0x8210720C;
		  /* 8210720Ch */ case    2:  		/* bl -22100 */
		/* 8210720Ch case    2:*/		regs.LR = 0x82107210; return 0x82101BB8;
		/* 8210720Ch case    2:*/		return 0x82107210;
		  /* 82107210h */ case    3:  		/* mr R8, R24 */
		/* 82107210h case    3:*/		regs.R8 = regs.R24;
		/* 82107210h case    3:*/		return 0x82107214;
		  /* 82107214h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 82107214h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82107214h case    4:*/		return 0x82107218;
		  /* 82107218h */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 82107218h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210724C;  }
		/* 82107218h case    5:*/		return 0x8210721C;
		  /* 8210721Ch */ case    6:  		/* lwz R11, <#[R9 + 12]> */
		/* 8210721Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 8210721Ch case    6:*/		return 0x82107220;
		  /* 82107220h */ case    7:  		/* mr R5, R7 */
		/* 82107220h case    7:*/		regs.R5 = regs.R7;
		/* 82107220h case    7:*/		return 0x82107224;
		  /* 82107224h */ case    8:  		/* lwz R10, <#[R9 + 8]> */
		/* 82107224h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 82107224h case    8:*/		return 0x82107228;
		  /* 82107228h */ case    9:  		/* mr R3, R26 */
		/* 82107228h case    9:*/		regs.R3 = regs.R26;
		/* 82107228h case    9:*/		return 0x8210722C;
		  /* 8210722Ch */ case   10:  		/* mullw R11, R11, R8 */
		/* 8210722Ch case   10:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8210722Ch case   10:*/		return 0x82107230;
		  /* 82107230h */ case   11:  		/* add R11, R11, R6 */
		/* 82107230h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82107230h case   11:*/		return 0x82107234;
		  /* 82107234h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107234h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107234h case   12:*/		return 0x82107238;
		  /* 82107238h */ case   13:  		/* lwzx R4, <#[R11 + R10]> */
		/* 82107238h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82107238h case   13:*/		return 0x8210723C;
		  /* 8210723Ch */ case   14:  		/* bl -22148 */
		/* 8210723Ch case   14:*/		regs.LR = 0x82107240; return 0x82101BB8;
		/* 8210723Ch case   14:*/		return 0x82107240;
		  /* 82107240h */ case   15:  		/* addi R8, R8, 1 */
		/* 82107240h case   15:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82107240h case   15:*/		return 0x82107244;
		  /* 82107244h */ case   16:  		/* cmplw CR6, R8, R31 */
		/* 82107244h case   16:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R31);
		/* 82107244h case   16:*/		return 0x82107248;
		  /* 82107248h */ case   17:  		/* bc 12, CR6_LT, -44 */
		/* 82107248h case   17:*/		if ( regs.CR[6].lt ) { return 0x8210721C;  }
		/* 82107248h case   17:*/		return 0x8210724C;
	}
	return 0x8210724C;
} // Block from 82107204h-8210724Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8210724Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210724C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210724C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210724C);
		  /* 8210724Ch */ case    0:  		/* lwz R11, <#[R9 + 12]> */
		/* 8210724Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 8210724Ch case    0:*/		return 0x82107250;
		  /* 82107250h */ case    1:  		/* addi R6, R6, 1 */
		/* 82107250h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82107250h case    1:*/		return 0x82107254;
		  /* 82107254h */ case    2:  		/* addi R30, R30, 4 */
		/* 82107254h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82107254h case    2:*/		return 0x82107258;
		  /* 82107258h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 82107258h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 82107258h case    3:*/		return 0x8210725C;
		  /* 8210725Ch */ case    4:  		/* bc 12, CR6_LT, -124 */
		/* 8210725Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x821071E0;  }
		/* 8210725Ch case    4:*/		return 0x82107260;
		  /* 82107260h */ case    5:  		/* b 208 */
		/* 82107260h case    5:*/		return 0x82107330;
		/* 82107260h case    5:*/		return 0x82107264;
	}
	return 0x82107264;
} // Block from 8210724Ch-82107264h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82107264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107264);
		  /* 82107264h */ case    0:  		/* lwz R4, <#[R9 + 12]> */
		/* 82107264h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + 0x0000000C) );
		/* 82107264h case    0:*/		return 0x82107268;
		  /* 82107268h */ case    1:  		/* mr R6, R24 */
		/* 82107268h case    1:*/		regs.R6 = regs.R24;
		/* 82107268h case    1:*/		return 0x8210726C;
		  /* 8210726Ch */ case    2:  		/* mr R5, R24 */
		/* 8210726Ch case    2:*/		regs.R5 = regs.R24;
		/* 8210726Ch case    2:*/		return 0x82107270;
		  /* 82107270h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 82107270h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82107270h case    3:*/		return 0x82107274;
		  /* 82107274h */ case    4:  		/* bc 12, CR6_EQ, 72 */
		/* 82107274h case    4:*/		if ( regs.CR[6].eq ) { return 0x821072BC;  }
		/* 82107274h case    4:*/		return 0x82107278;
		  /* 82107278h */ case    5:  		/* lwz R8, <#[R9 + 16]> */
		/* 82107278h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000010) );
		/* 82107278h case    5:*/		return 0x8210727C;
		  /* 8210727Ch */ case    6:  		/* mr R11, R24 */
		/* 8210727Ch case    6:*/		regs.R11 = regs.R24;
		/* 8210727Ch case    6:*/		return 0x82107280;
		  /* 82107280h */ case    7:  		/* lwz R7, <#[R26 + 20]> */
		/* 82107280h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000014) );
		/* 82107280h case    7:*/		return 0x82107284;
		  /* 82107284h */ case    8:  		/* lwzx R10, <#[R8 + R11]> */
		/* 82107284h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82107284h case    8:*/		return 0x82107288;
		  /* 82107288h */ case    9:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82107288h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82107288h case    9:*/		return 0x8210728C;
		  /* 8210728Ch */ case   10:  		/* lwzx R10, <#[R10 + R7]> */
		/* 8210728Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8210728Ch case   10:*/		return 0x82107290;
		  /* 82107290h */ case   11:  		/* lwz R10, <#[R10 + 84]> */
		/* 82107290h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000054) );
		/* 82107290h case   11:*/		return 0x82107294;
		  /* 82107294h */ case   12:  		/* cmplw CR6, R6, R10 */
		/* 82107294h case   12:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82107294h case   12:*/		return 0x82107298;
		  /* 82107298h */ case   13:  		/* bc 4, CR6_LT, 8 */
		/* 82107298h case   13:*/		if ( !regs.CR[6].lt ) { return 0x821072A0;  }
		/* 82107298h case   13:*/		return 0x8210729C;
		  /* 8210729Ch */ case   14:  		/* mr R6, R10 */
		/* 8210729Ch case   14:*/		regs.R6 = regs.R10;
		/* 8210729Ch case   14:*/		return 0x821072A0;
	}
	return 0x821072A0;
} // Block from 82107264h-821072A0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821072A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821072A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821072A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821072A0);
		  /* 821072A0h */ case    0:  		/* addi R5, R5, 1 */
		/* 821072A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 821072A0h case    0:*/		return 0x821072A4;
		  /* 821072A4h */ case    1:  		/* addi R11, R11, 4 */
		/* 821072A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821072A4h case    1:*/		return 0x821072A8;
		  /* 821072A8h */ case    2:  		/* cmplw CR6, R5, R4 */
		/* 821072A8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 821072A8h case    2:*/		return 0x821072AC;
		  /* 821072ACh */ case    3:  		/* bc 12, CR6_LT, -40 */
		/* 821072ACh case    3:*/		if ( regs.CR[6].lt ) { return 0x82107284;  }
		/* 821072ACh case    3:*/		return 0x821072B0;
		  /* 821072B0h */ case    4:  		/* cmplwi CR6, R6, 1 */
		/* 821072B0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000001);
		/* 821072B0h case    4:*/		return 0x821072B4;
		  /* 821072B4h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 821072B4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821072BC;  }
		/* 821072B4h case    5:*/		return 0x821072B8;
		  /* 821072B8h */ case    6:  		/* li R27, 1 */
		/* 821072B8h case    6:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 821072B8h case    6:*/		return 0x821072BC;
	}
	return 0x821072BC;
} // Block from 821072A0h-821072BCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821072BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821072BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821072BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821072BC);
		  /* 821072BCh */ case    0:  		/* mr R7, R24 */
		/* 821072BCh case    0:*/		regs.R7 = regs.R24;
		/* 821072BCh case    0:*/		return 0x821072C0;
		  /* 821072C0h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 821072C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821072C0h case    1:*/		return 0x821072C4;
		  /* 821072C4h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 821072C4h case    2:*/		if ( regs.CR[6].eq ) { return 0x821072F4;  }
		/* 821072C4h case    2:*/		return 0x821072C8;
		  /* 821072C8h */ case    3:  		/* mr R8, R24 */
		/* 821072C8h case    3:*/		regs.R8 = regs.R24;
		/* 821072C8h case    3:*/		return 0x821072CC;
		  /* 821072CCh */ case    4:  		/* lwz R11, <#[R9 + 16]> */
		/* 821072CCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 821072CCh case    4:*/		return 0x821072D0;
		  /* 821072D0h */ case    5:  		/* mr R5, R6 */
		/* 821072D0h case    5:*/		regs.R5 = regs.R6;
		/* 821072D0h case    5:*/		return 0x821072D4;
		  /* 821072D4h */ case    6:  		/* mr R3, R26 */
		/* 821072D4h case    6:*/		regs.R3 = regs.R26;
		/* 821072D4h case    6:*/		return 0x821072D8;
		  /* 821072D8h */ case    7:  		/* lwzx R4, <#[R8 + R11]> */
		/* 821072D8h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 821072D8h case    7:*/		return 0x821072DC;
		  /* 821072DCh */ case    8:  		/* bl -22308 */
		/* 821072DCh case    8:*/		regs.LR = 0x821072E0; return 0x82101BB8;
		/* 821072DCh case    8:*/		return 0x821072E0;
		  /* 821072E0h */ case    9:  		/* lwz R11, <#[R9 + 12]> */
		/* 821072E0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 821072E0h case    9:*/		return 0x821072E4;
		  /* 821072E4h */ case   10:  		/* addi R7, R7, 1 */
		/* 821072E4h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821072E4h case   10:*/		return 0x821072E8;
		  /* 821072E8h */ case   11:  		/* addi R8, R8, 4 */
		/* 821072E8h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 821072E8h case   11:*/		return 0x821072EC;
		  /* 821072ECh */ case   12:  		/* cmplw CR6, R7, R11 */
		/* 821072ECh case   12:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 821072ECh case   12:*/		return 0x821072F0;
		  /* 821072F0h */ case   13:  		/* bc 12, CR6_LT, -36 */
		/* 821072F0h case   13:*/		if ( regs.CR[6].lt ) { return 0x821072CC;  }
		/* 821072F0h case   13:*/		return 0x821072F4;
	}
	return 0x821072F4;
} // Block from 821072BCh-821072F4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821072F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821072F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821072F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821072F4);
		  /* 821072F4h */ case    0:  		/* lwz R11, <#[R9 + 4]> */
		/* 821072F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 821072F4h case    0:*/		return 0x821072F8;
		  /* 821072F8h */ case    1:  		/* mr R7, R24 */
		/* 821072F8h case    1:*/		regs.R7 = regs.R24;
		/* 821072F8h case    1:*/		return 0x821072FC;
		  /* 821072FCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821072FCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821072FCh case    2:*/		return 0x82107300;
		  /* 82107300h */ case    3:  		/* bc 4, CR6_GT, 48 */
		/* 82107300h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82107330;  }
		/* 82107300h case    3:*/		return 0x82107304;
		  /* 82107304h */ case    4:  		/* mr R8, R24 */
		/* 82107304h case    4:*/		regs.R8 = regs.R24;
		/* 82107304h case    4:*/		return 0x82107308;
		  /* 82107308h */ case    5:  		/* lwz R11, <#[R9 + 8]> */
		/* 82107308h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82107308h case    5:*/		return 0x8210730C;
		  /* 8210730Ch */ case    6:  		/* mr R5, R6 */
		/* 8210730Ch case    6:*/		regs.R5 = regs.R6;
		/* 8210730Ch case    6:*/		return 0x82107310;
		  /* 82107310h */ case    7:  		/* mr R3, R26 */
		/* 82107310h case    7:*/		regs.R3 = regs.R26;
		/* 82107310h case    7:*/		return 0x82107314;
		  /* 82107314h */ case    8:  		/* lwzx R4, <#[R8 + R11]> */
		/* 82107314h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82107314h case    8:*/		return 0x82107318;
		  /* 82107318h */ case    9:  		/* bl -22368 */
		/* 82107318h case    9:*/		regs.LR = 0x8210731C; return 0x82101BB8;
		/* 82107318h case    9:*/		return 0x8210731C;
		  /* 8210731Ch */ case   10:  		/* lwz R11, <#[R9 + 4]> */
		/* 8210731Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8210731Ch case   10:*/		return 0x82107320;
		  /* 82107320h */ case   11:  		/* addi R7, R7, 1 */
		/* 82107320h case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82107320h case   11:*/		return 0x82107324;
		  /* 82107324h */ case   12:  		/* addi R8, R8, 4 */
		/* 82107324h case   12:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82107324h case   12:*/		return 0x82107328;
		  /* 82107328h */ case   13:  		/* cmplw CR6, R7, R11 */
		/* 82107328h case   13:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82107328h case   13:*/		return 0x8210732C;
		  /* 8210732Ch */ case   14:  		/* bc 12, CR6_LT, -36 */
		/* 8210732Ch case   14:*/		if ( regs.CR[6].lt ) { return 0x82107308;  }
		/* 8210732Ch case   14:*/		return 0x82107330;
	}
	return 0x82107330;
} // Block from 821072F4h-82107330h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82107330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107330);
		  /* 82107330h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82107330h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82107330h case    0:*/		return 0x82107334;
		  /* 82107334h */ case    1:  		/* bc 4, CR6_EQ, -424 */
		/* 82107334h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210718C;  }
		/* 82107334h case    1:*/		return 0x82107338;
		  /* 82107338h */ case    2:  		/* cmpwi CR6, R27, 0 */
		/* 82107338h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82107338h case    2:*/		return 0x8210733C;
		  /* 8210733Ch */ case    3:  		/* bc 12, CR6_EQ, 352 */
		/* 8210733Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8210749C;  }
		/* 8210733Ch case    3:*/		return 0x82107340;
		  /* 82107340h */ case    4:  		/* lwz R11, <#[R26 + 12]> */
		/* 82107340h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 82107340h case    4:*/		return 0x82107344;
		  /* 82107344h */ case    5:  		/* mr R27, R24 */
		/* 82107344h case    5:*/		regs.R27 = regs.R24;
		/* 82107344h case    5:*/		return 0x82107348;
		  /* 82107348h */ case    6:  		/* mr R28, R24 */
		/* 82107348h case    6:*/		regs.R28 = regs.R24;
		/* 82107348h case    6:*/		return 0x8210734C;
		  /* 8210734Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8210734Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210734Ch case    7:*/		return 0x82107350;
		  /* 82107350h */ case    8:  		/* bc 4, CR6_GT, 332 */
		/* 82107350h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8210749C;  }
		/* 82107350h case    8:*/		return 0x82107354;
		  /* 82107354h */ case    9:  		/* mr R29, R24 */
		/* 82107354h case    9:*/		regs.R29 = regs.R24;
		/* 82107354h case    9:*/		return 0x82107358;
		  /* 82107358h */ case   10:  		/* lwz R11, <#[R26 + 24]> */
		/* 82107358h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 82107358h case   10:*/		return 0x8210735C;
		  /* 8210735Ch */ case   11:  		/* lwzx R4, <#[R29 + R11]> */
		/* 8210735Ch case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8210735Ch case   11:*/		return 0x82107360;
		  /* 82107360h */ case   12:  		/* lwz R11, <#[R4]> */
		/* 82107360h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82107360h case   12:*/		return 0x82107364;
		  /* 82107364h */ case   13:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82107364h case   13:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82107364h case   13:*/		return 0x82107368;
		  /* 82107368h */ case   14:  		/* cmplw CR6, R11, R25 */
		/* 82107368h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 82107368h case   14:*/		return 0x8210736C;
		  /* 8210736Ch */ case   15:  		/* bc 4, CR6_EQ, 276 */
		/* 8210736Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x82107480;  }
		/* 8210736Ch case   15:*/		return 0x82107370;
		  /* 82107370h */ case   16:  		/* lwz R11, <#[R4 + 12]> */
		/* 82107370h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82107370h case   16:*/		return 0x82107374;
		  /* 82107374h */ case   17:  		/* mr R31, R24 */
		/* 82107374h case   17:*/		regs.R31 = regs.R24;
		/* 82107374h case   17:*/		return 0x82107378;
		  /* 82107378h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 82107378h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82107378h case   18:*/		return 0x8210737C;
		  /* 8210737Ch */ case   19:  		/* bc 12, CR6_EQ, 260 */
		/* 8210737Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x82107480;  }
		/* 8210737Ch case   19:*/		return 0x82107380;
		  /* 82107380h */ case   20:  		/* mr R30, R24 */
		/* 82107380h case   20:*/		regs.R30 = regs.R24;
		/* 82107380h case   20:*/		return 0x82107384;
		  /* 82107384h */ case   21:  		/* lwz R10, <#[R4 + 16]> */
		/* 82107384h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 82107384h case   21:*/		return 0x82107388;
		  /* 82107388h */ case   22:  		/* lwz R5, <#[R26 + 20]> */
		/* 82107388h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x00000014) );
		/* 82107388h case   22:*/		return 0x8210738C;
		  /* 8210738Ch */ case   23:  		/* lwzx R10, <#[R30 + R10]> */
		/* 8210738Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + regs.R10 + 0x00000000) );
		/* 8210738Ch case   23:*/		return 0x82107390;
		  /* 82107390h */ case   24:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82107390h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82107390h case   24:*/		return 0x82107394;
		  /* 82107394h */ case   25:  		/* lwzx R3, <#[R10 + R5]> */
		/* 82107394h case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 82107394h case   25:*/		return 0x82107398;
		  /* 82107398h */ case   26:  		/* lwz R10, <#[R3 + 84]> */
		/* 82107398h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000054) );
		/* 82107398h case   26:*/		return 0x8210739C;
		  /* 8210739Ch */ case   27:  		/* cmplwi CR6, R10, 1 */
		/* 8210739Ch case   27:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8210739Ch case   27:*/		return 0x821073A0;
		  /* 821073A0h */ case   28:  		/* bc 4, CR6_EQ, 204 */
		/* 821073A0h case   28:*/		if ( !regs.CR[6].eq ) { return 0x8210746C;  }
		/* 821073A0h case   28:*/		return 0x821073A4;
		  /* 821073A4h */ case   29:  		/* add R11, R31, R11 */
		/* 821073A4h case   29:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 821073A4h case   29:*/		return 0x821073A8;
		  /* 821073A8h */ case   30:  		/* lwz R10, <#[R4 + 8]> */
		/* 821073A8h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 821073A8h case   30:*/		return 0x821073AC;
		  /* 821073ACh */ case   31:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821073ACh case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821073ACh case   31:*/		return 0x821073B0;
		  /* 821073B0h */ case   32:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821073B0h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821073B0h case   32:*/		return 0x821073B4;
		  /* 821073B4h */ case   33:  		/* cmpwi CR6, R11, -1 */
		/* 821073B4h case   33:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821073B4h case   33:*/		return 0x821073B8;
		  /* 821073B8h */ case   34:  		/* bc 12, CR6_EQ, 28 */
		/* 821073B8h case   34:*/		if ( regs.CR[6].eq ) { return 0x821073D4;  }
		/* 821073B8h case   34:*/		return 0x821073BC;
		  /* 821073BCh */ case   35:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 821073BCh case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 821073BCh case   35:*/		return 0x821073C0;
		  /* 821073C0h */ case   36:  		/* lwzx R10, <#[R10 + R5]> */
		/* 821073C0h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 821073C0h case   36:*/		return 0x821073C4;
		  /* 821073C4h */ case   37:  		/* lwz R10, <#[R10 + 56]> */
		/* 821073C4h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 821073C4h case   37:*/		return 0x821073C8;
		  /* 821073C8h */ case   38:  		/* cmpwi CR6, R10, -1 */
		/* 821073C8h case   38:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 821073C8h case   38:*/		return 0x821073CC;
		  /* 821073CCh */ case   39:  		/* mr R7, R10 */
		/* 821073CCh case   39:*/		regs.R7 = regs.R10;
		/* 821073CCh case   39:*/		return 0x821073D0;
		  /* 821073D0h */ case   40:  		/* bc 4, CR6_EQ, 8 */
		/* 821073D0h case   40:*/		if ( !regs.CR[6].eq ) { return 0x821073D8;  }
		/* 821073D0h case   40:*/		return 0x821073D4;
	}
	return 0x821073D4;
} // Block from 82107330h-821073D4h (41 instructions)

//////////////////////////////////////////////////////
// Block at 821073D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821073D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821073D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821073D4);
		  /* 821073D4h */ case    0:  		/* mr R7, R11 */
		/* 821073D4h case    0:*/		regs.R7 = regs.R11;
		/* 821073D4h case    0:*/		return 0x821073D8;
	}
	return 0x821073D8;
} // Block from 821073D4h-821073D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821073D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821073D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821073D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821073D8);
		  /* 821073D8h */ case    0:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 821073D8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 821073D8h case    0:*/		return 0x821073DC;
		  /* 821073DCh */ case    1:  		/* lwz R10, <#[R26 + 24]> */
		/* 821073DCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000018) );
		/* 821073DCh case    1:*/		return 0x821073E0;
		  /* 821073E0h */ case    2:  		/* mr R9, R24 */
		/* 821073E0h case    2:*/		regs.R9 = regs.R24;
		/* 821073E0h case    2:*/		return 0x821073E4;
		  /* 821073E4h */ case    3:  		/* lwzx R11, <#[R11 + R5]> */
		/* 821073E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 821073E4h case    3:*/		return 0x821073E8;
		  /* 821073E8h */ case    4:  		/* lwz R11, <#[R11 + 72]> */
		/* 821073E8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 821073E8h case    4:*/		return 0x821073EC;
		  /* 821073ECh */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821073ECh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821073ECh case    5:*/		return 0x821073F0;
		  /* 821073F0h */ case    6:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821073F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821073F0h case    6:*/		return 0x821073F4;
		  /* 821073F4h */ case    7:  		/* lwz R8, <#[R11 + 12]> */
		/* 821073F4h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 821073F4h case    7:*/		return 0x821073F8;
		  /* 821073F8h */ case    8:  		/* cmplwi CR6, R8, 0 */
		/* 821073F8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821073F8h case    8:*/		return 0x821073FC;
		  /* 821073FCh */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 821073FCh case    9:*/		if ( regs.CR[6].eq ) { return 0x82107424;  }
		/* 821073FCh case    9:*/		return 0x82107400;
		  /* 82107400h */ case   10:  		/* lwz R6, <#[R11 + 16]> */
		/* 82107400h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000010) );
		/* 82107400h case   10:*/		return 0x82107404;
		  /* 82107404h */ case   11:  		/* mr R10, R24 */
		/* 82107404h case   11:*/		regs.R10 = regs.R24;
		/* 82107404h case   11:*/		return 0x82107408;
		  /* 82107408h */ case   12:  		/* lwzx R20, <#[R10 + R6]> */
		/* 82107408h case   12:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82107408h case   12:*/		return 0x8210740C;
		  /* 8210740Ch */ case   13:  		/* cmplw CR6, R20, R7 */
		/* 8210740Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R7);
		/* 8210740Ch case   13:*/		return 0x82107410;
		  /* 82107410h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 82107410h case   14:*/		if ( regs.CR[6].eq ) { return 0x82107424;  }
		/* 82107410h case   14:*/		return 0x82107414;
		  /* 82107414h */ case   15:  		/* addi R9, R9, 1 */
		/* 82107414h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82107414h case   15:*/		return 0x82107418;
		  /* 82107418h */ case   16:  		/* addi R10, R10, 4 */
		/* 82107418h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82107418h case   16:*/		return 0x8210741C;
		  /* 8210741Ch */ case   17:  		/* cmplw CR6, R9, R8 */
		/* 8210741Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8210741Ch case   17:*/		return 0x82107420;
		  /* 82107420h */ case   18:  		/* bc 12, CR6_LT, -24 */
		/* 82107420h case   18:*/		if ( regs.CR[6].lt ) { return 0x82107408;  }
		/* 82107420h case   18:*/		return 0x82107424;
	}
	return 0x82107424;
} // Block from 821073D8h-82107424h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82107424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107424);
		  /* 82107424h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82107424h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82107424h case    0:*/		return 0x82107428;
		  /* 82107428h */ case    1:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 82107428h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 82107428h case    1:*/		return 0x8210742C;
		  /* 8210742Ch */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210742Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210742Ch case    2:*/		return 0x82107430;
		  /* 82107430h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82107430h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107430h case    3:*/		return 0x82107434;
		  /* 82107434h */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 82107434h case    4:*/		if ( regs.CR[6].eq ) { return 0x82107450;  }
		/* 82107434h case    4:*/		return 0x82107438;
		  /* 82107438h */ case    5:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 82107438h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 82107438h case    5:*/		return 0x8210743C;
		  /* 8210743Ch */ case    6:  		/* lwzx R10, <#[R10 + R5]> */
		/* 8210743Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8210743Ch case    6:*/		return 0x82107440;
		  /* 82107440h */ case    7:  		/* lwz R10, <#[R10 + 56]> */
		/* 82107440h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000038) );
		/* 82107440h case    7:*/		return 0x82107444;
		  /* 82107444h */ case    8:  		/* cmpwi CR6, R10, -1 */
		/* 82107444h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82107444h case    8:*/		return 0x82107448;
		  /* 82107448h */ case    9:  		/* bc 12, CR6_EQ, 8 */
		/* 82107448h case    9:*/		if ( regs.CR[6].eq ) { return 0x82107450;  }
		/* 82107448h case    9:*/		return 0x8210744C;
		  /* 8210744Ch */ case   10:  		/* mr R11, R10 */
		/* 8210744Ch case   10:*/		regs.R11 = regs.R10;
		/* 8210744Ch case   10:*/		return 0x82107450;
	}
	return 0x82107450;
} // Block from 82107424h-82107450h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82107450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107450);
		  /* 82107450h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107450h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107450h case    0:*/		return 0x82107454;
		  /* 82107454h */ case    1:  		/* lwzx R11, <#[R11 + R5]> */
		/* 82107454h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 82107454h case    1:*/		return 0x82107458;
		  /* 82107458h */ case    2:  		/* lwz R11, <#[R11 + 84]> */
		/* 82107458h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 82107458h case    2:*/		return 0x8210745C;
		  /* 8210745Ch */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 8210745Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8210745Ch case    3:*/		return 0x82107460;
		  /* 82107460h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82107460h case    4:*/		if ( regs.CR[6].eq ) { return 0x8210746C;  }
		/* 82107460h case    4:*/		return 0x82107464;
		  /* 82107464h */ case    5:  		/* stw R11, <#[R3 + 84]> */
		/* 82107464h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000054) );
		/* 82107464h case    5:*/		return 0x82107468;
		  /* 82107468h */ case    6:  		/* li R27, 1 */
		/* 82107468h case    6:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82107468h case    6:*/		return 0x8210746C;
	}
	return 0x8210746C;
} // Block from 82107450h-8210746Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210746Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210746C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210746C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210746C);
		  /* 8210746Ch */ case    0:  		/* lwz R11, <#[R4 + 12]> */
		/* 8210746Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 8210746Ch case    0:*/		return 0x82107470;
		  /* 82107470h */ case    1:  		/* addi R31, R31, 1 */
		/* 82107470h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82107470h case    1:*/		return 0x82107474;
		  /* 82107474h */ case    2:  		/* addi R30, R30, 4 */
		/* 82107474h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82107474h case    2:*/		return 0x82107478;
		  /* 82107478h */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 82107478h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82107478h case    3:*/		return 0x8210747C;
		  /* 8210747Ch */ case    4:  		/* bc 12, CR6_LT, -248 */
		/* 8210747Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82107384;  }
		/* 8210747Ch case    4:*/		return 0x82107480;
	}
	return 0x82107480;
} // Block from 8210746Ch-82107480h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82107480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107480);
		  /* 82107480h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 82107480h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 82107480h case    0:*/		return 0x82107484;
		  /* 82107484h */ case    1:  		/* addi R28, R28, 1 */
		/* 82107484h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82107484h case    1:*/		return 0x82107488;
		  /* 82107488h */ case    2:  		/* addi R29, R29, 4 */
		/* 82107488h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82107488h case    2:*/		return 0x8210748C;
		  /* 8210748Ch */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 8210748Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8210748Ch case    3:*/		return 0x82107490;
		  /* 82107490h */ case    4:  		/* bc 12, CR6_LT, -312 */
		/* 82107490h case    4:*/		if ( regs.CR[6].lt ) { return 0x82107358;  }
		/* 82107490h case    4:*/		return 0x82107494;
		  /* 82107494h */ case    5:  		/* cmpwi CR6, R27, 0 */
		/* 82107494h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82107494h case    5:*/		return 0x82107498;
		  /* 82107498h */ case    6:  		/* bc 4, CR6_EQ, -800 */
		/* 82107498h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82107178;  }
		/* 82107498h case    6:*/		return 0x8210749C;
	}
	return 0x8210749C;
} // Block from 82107480h-8210749Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210749Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210749C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210749C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210749C);
		  /* 8210749Ch */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 8210749Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8210749Ch case    0:*/		return 0x821074A0;
		  /* 821074A0h */ case    1:  		/* mr R31, R24 */
		/* 821074A0h case    1:*/		regs.R31 = regs.R24;
		/* 821074A0h case    1:*/		return 0x821074A4;
		  /* 821074A4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821074A4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821074A4h case    2:*/		return 0x821074A8;
		  /* 821074A8h */ case    3:  		/* bc 4, CR6_GT, 484 */
		/* 821074A8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210768C;  }
		/* 821074A8h case    3:*/		return 0x821074AC;
		  /* 821074ACh */ case    4:  		/* mr R3, R24 */
		/* 821074ACh case    4:*/		regs.R3 = regs.R24;
		/* 821074ACh case    4:*/		return 0x821074B0;
		  /* 821074B0h */ case    5:  		/* lwz R11, <#[R26 + 24]> */
		/* 821074B0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 821074B0h case    5:*/		return 0x821074B4;
		  /* 821074B4h */ case    6:  		/* lwzx R11, <#[R3 + R11]> */
		/* 821074B4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821074B4h case    6:*/		return 0x821074B8;
		  /* 821074B8h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 821074B8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821074B8h case    7:*/		return 0x821074BC;
		  /* 821074BCh */ case    8:  		/* rlwinm. R9, R10, 0, 0, 11 */
		/* 821074BCh case    8:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R9,regs.R10);
		/* 821074BCh case    8:*/		return 0x821074C0;
	}
	return 0x821074C0;
} // Block from 8210749Ch-821074C0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821074C0h
// Function '?Initialize@CProgram@D3DXShader@@QAAJPAV12@KK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821074C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821074C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821074C0);
		  /* 821074C0h */ case    0:  		/* bc 12, CR0_EQ, 440 */
		/* 821074C0h case    0:*/		if ( regs.CR[0].eq ) { return 0x82107678;  }
		/* 821074C0h case    0:*/		return 0x821074C4;
		  /* 821074C4h */ case    1:  		/* rlwinm R9, R10, 0, 0, 3 */
		/* 821074C4h case    1:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R9,regs.R10);
		/* 821074C4h case    1:*/		return 0x821074C8;
		  /* 821074C8h */ case    2:  		/* cmplw CR6, R9, R23 */
		/* 821074C8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R23);
		/* 821074C8h case    2:*/		return 0x821074CC;
		  /* 821074CCh */ case    3:  		/* bc 12, CR6_LT, 332 */
		/* 821074CCh case    3:*/		if ( regs.CR[6].lt ) { return 0x82107618;  }
		/* 821074CCh case    3:*/		return 0x821074D0;
		  /* 821074D0h */ case    4:  		/* cmplw CR6, R9, R22 */
		/* 821074D0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R22);
		/* 821074D0h case    4:*/		return 0x821074D4;
		  /* 821074D4h */ case    5:  		/* bc 12, CR6_GT, 324 */
		/* 821074D4h case    5:*/		if ( regs.CR[6].gt ) { return 0x82107618;  }
		/* 821074D4h case    5:*/		return 0x821074D8;
		  /* 821074D8h */ case    6:  		/* lwz R9, <#[R11 + 4]> */
		/* 821074D8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821074D8h case    6:*/		return 0x821074DC;
		  /* 821074DCh */ case    7:  		/* rlwinm R10, R10, 0, 12, 31 */
		/* 821074DCh case    7:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R10,regs.R10);
		/* 821074DCh case    7:*/		return 0x821074E0;
		  /* 821074E0h */ case    8:  		/* lwz R7, <#[R11 + 12]> */
		/* 821074E0h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 821074E0h case    8:*/		return 0x821074E4;
		  /* 821074E4h */ case    9:  		/* mr R6, R24 */
		/* 821074E4h case    9:*/		regs.R6 = regs.R24;
		/* 821074E4h case    9:*/		return 0x821074E8;
		  /* 821074E8h */ case   10:  		/* mr R8, R24 */
		/* 821074E8h case   10:*/		regs.R8 = regs.R24;
		/* 821074E8h case   10:*/		return 0x821074EC;
		  /* 821074ECh */ case   11:  		/* divwu R4, R9, R10 */
		/* 821074ECh case   11:*/		cpu::op::divwu<0>(regs,&regs.R4,regs.R9,regs.R10);
		/* 821074ECh case   11:*/		return 0x821074F0;
		  /* 821074F0h */ case   12:  		/* twi 6, R10, 0 */
		/* 821074F0h case   12:*/		cpu::op::tw<6>(regs, 0x821074F0, regs.R10, 0x00000000);
		/* 821074F0h case   12:*/		return 0x821074F4;
		  /* 821074F4h */ case   13:  		/* cmplwi CR6, R7, 0 */
		/* 821074F4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 821074F4h case   13:*/		return 0x821074F8;
		  /* 821074F8h */ case   14:  		/* bc 4, CR6_GT, 140 */
		/* 821074F8h case   14:*/		if ( !regs.CR[6].gt ) { return 0x82107584;  }
		/* 821074F8h case   14:*/		return 0x821074FC;
		  /* 821074FCh */ case   15:  		/* mr R5, R24 */
		/* 821074FCh case   15:*/		regs.R5 = regs.R24;
		/* 821074FCh case   15:*/		return 0x82107500;
		  /* 82107500h */ case   16:  		/* mr R7, R24 */
		/* 82107500h case   16:*/		regs.R7 = regs.R24;
		/* 82107500h case   16:*/		return 0x82107504;
		  /* 82107504h */ case   17:  		/* lwz R9, <#[R11 + 16]> */
		/* 82107504h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 82107504h case   17:*/		return 0x82107508;
		  /* 82107508h */ case   18:  		/* lwz R10, <#[R26 + 20]> */
		/* 82107508h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 82107508h case   18:*/		return 0x8210750C;
		  /* 8210750Ch */ case   19:  		/* lwzx R30, <#[R7 + R9]> */
		/* 8210750Ch case   19:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 8210750Ch case   19:*/		return 0x82107510;
		  /* 82107510h */ case   20:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 82107510h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 82107510h case   20:*/		return 0x82107514;
		  /* 82107514h */ case   21:  		/* lwzx R10, <#[R30 + R10]> */
		/* 82107514h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + regs.R10 + 0x00000000) );
		/* 82107514h case   21:*/		return 0x82107518;
		  /* 82107518h */ case   22:  		/* lwz R10, <#[R10 + 84]> */
		/* 82107518h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000054) );
		/* 82107518h case   22:*/		return 0x8210751C;
		  /* 8210751Ch */ case   23:  		/* cmplwi CR6, R10, 2 */
		/* 8210751Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 8210751Ch case   23:*/		return 0x82107520;
		  /* 82107520h */ case   24:  		/* bc 4, CR6_EQ, 80 */
		/* 82107520h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82107570;  }
		/* 82107520h case   24:*/		return 0x82107524;
		  /* 82107524h */ case   25:  		/* lwzx R30, <#[R7 + R9]> */
		/* 82107524h case   25:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 82107524h case   25:*/		return 0x82107528;
		  /* 82107528h */ case   26:  		/* mr R10, R24 */
		/* 82107528h case   26:*/		regs.R10 = regs.R24;
		/* 82107528h case   26:*/		return 0x8210752C;
		  /* 8210752Ch */ case   27:  		/* cmplwi CR6, R4, 0 */
		/* 8210752Ch case   27:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8210752Ch case   27:*/		return 0x82107530;
		  /* 82107530h */ case   28:  		/* stwx R30, <#[R5 + R9]> */
		/* 82107530h case   28:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 82107530h case   28:*/		return 0x82107534;
		  /* 82107534h */ case   29:  		/* bc 12, CR6_EQ, 52 */
		/* 82107534h case   29:*/		if ( regs.CR[6].eq ) { return 0x82107568;  }
		/* 82107534h case   29:*/		return 0x82107538;
		  /* 82107538h */ case   30:  		/* mtspr CTR, R4 */
		/* 82107538h case   30:*/		regs.CTR = regs.R4;
		/* 82107538h case   30:*/		return 0x8210753C;
		  /* 8210753Ch */ case   31:  		/* lwz R9, <#[R11 + 12]> */
		/* 8210753Ch case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210753Ch case   31:*/		return 0x82107540;
		  /* 82107540h */ case   32:  		/* lwz R30, <#[R11 + 8]> */
		/* 82107540h case   32:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000008) );
		/* 82107540h case   32:*/		return 0x82107544;
		  /* 82107544h */ case   33:  		/* mullw R9, R10, R9 */
		/* 82107544h case   33:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 82107544h case   33:*/		return 0x82107548;
		  /* 82107548h */ case   34:  		/* add R29, R9, R6 */
		/* 82107548h case   34:*/		cpu::op::add<0>(regs,&regs.R29,regs.R9,regs.R6);
		/* 82107548h case   34:*/		return 0x8210754C;
		  /* 8210754Ch */ case   35:  		/* add R9, R9, R8 */
		/* 8210754Ch case   35:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8210754Ch case   35:*/		return 0x82107550;
		  /* 82107550h */ case   36:  		/* rlwinm R29, R29, 2, 0, 29 */
		/* 82107550h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R29);
		/* 82107550h case   36:*/		return 0x82107554;
		  /* 82107554h */ case   37:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82107554h case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82107554h case   37:*/		return 0x82107558;
		  /* 82107558h */ case   38:  		/* addi R10, R10, 1 */
		/* 82107558h case   38:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82107558h case   38:*/		return 0x8210755C;
		  /* 8210755Ch */ case   39:  		/* lwzx R29, <#[R29 + R30]> */
		/* 8210755Ch case   39:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8210755Ch case   39:*/		return 0x82107560;
		  /* 82107560h */ case   40:  		/* stwx R29, <#[R9 + R30]> */
		/* 82107560h case   40:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82107560h case   40:*/		return 0x82107564;
		  /* 82107564h */ case   41:  		/* bc 16, CR0_LT, -40 */
		/* 82107564h case   41:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210753C;  }
		/* 82107564h case   41:*/		return 0x82107568;
	}
	return 0x82107568;
} // Block from 821074C0h-82107568h (42 instructions)

//////////////////////////////////////////////////////
// Block at 82107568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107568);
		  /* 82107568h */ case    0:  		/* addi R8, R8, 1 */
		/* 82107568h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82107568h case    0:*/		return 0x8210756C;
		  /* 8210756Ch */ case    1:  		/* addi R5, R5, 4 */
		/* 8210756Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 8210756Ch case    1:*/		return 0x82107570;
	}
	return 0x82107570;
} // Block from 82107568h-82107570h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82107570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107570);
		  /* 82107570h */ case    0:  		/* lwz R10, <#[R11 + 12]> */
		/* 82107570h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82107570h case    0:*/		return 0x82107574;
		  /* 82107574h */ case    1:  		/* addi R6, R6, 1 */
		/* 82107574h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82107574h case    1:*/		return 0x82107578;
		  /* 82107578h */ case    2:  		/* addi R7, R7, 4 */
		/* 82107578h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82107578h case    2:*/		return 0x8210757C;
		  /* 8210757Ch */ case    3:  		/* cmplw CR6, R6, R10 */
		/* 8210757Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 8210757Ch case    3:*/		return 0x82107580;
		  /* 82107580h */ case    4:  		/* bc 12, CR6_LT, -124 */
		/* 82107580h case    4:*/		if ( regs.CR[6].lt ) { return 0x82107504;  }
		/* 82107580h case    4:*/		return 0x82107584;
	}
	return 0x82107584;
} // Block from 82107570h-82107584h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82107584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107584);
		  /* 82107584h */ case    0:  		/* lwz R10, <#[R11 + 12]> */
		/* 82107584h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82107584h case    0:*/		return 0x82107588;
		  /* 82107588h */ case    1:  		/* cmplw CR6, R8, R10 */
		/* 82107588h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 82107588h case    1:*/		return 0x8210758C;
		  /* 8210758Ch */ case    2:  		/* bc 12, CR6_EQ, 236 */
		/* 8210758Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82107678;  }
		/* 8210758Ch case    2:*/		return 0x82107590;
		  /* 82107590h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 82107590h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82107590h case    3:*/		return 0x82107594;
		  /* 82107594h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82107594h case    4:*/		if ( regs.CR[6].eq ) { return 0x821075A4;  }
		/* 82107594h case    4:*/		return 0x82107598;
		  /* 82107598h */ case    5:  		/* lwz R10, <#[R11]> */
		/* 82107598h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82107598h case    5:*/		return 0x8210759C;
		  /* 8210759Ch */ case    6:  		/* rlwimi R10, R8, 0, 12, 31 */
		/* 8210759Ch case    6:*/		cpu::op::rlwimi<0,0,12,31>(regs,&regs.R10,regs.R8);
		/* 8210759Ch case    6:*/		return 0x821075A0;
		  /* 821075A0h */ case    7:  		/* b 8 */
		/* 821075A0h case    7:*/		return 0x821075A8;
		/* 821075A0h case    7:*/		return 0x821075A4;
	}
	return 0x821075A4;
} // Block from 82107584h-821075A4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821075A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821075A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821075A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821075A4);
		  /* 821075A4h */ case    0:  		/* mr R10, R24 */
		/* 821075A4h case    0:*/		regs.R10 = regs.R24;
		/* 821075A4h case    0:*/		return 0x821075A8;
	}
	return 0x821075A8;
} // Block from 821075A4h-821075A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821075A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821075A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821075A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821075A8);
		  /* 821075A8h */ case    0:  		/* stw R10, <#[R11]> */
		/* 821075A8h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821075A8h case    0:*/		return 0x821075AC;
		  /* 821075ACh */ case    1:  		/* li R9, 1 */
		/* 821075ACh case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821075ACh case    1:*/		return 0x821075B0;
		  /* 821075B0h */ case    2:  		/* cmplwi CR6, R4, 1 */
		/* 821075B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 821075B0h case    2:*/		return 0x821075B4;
		  /* 821075B4h */ case    3:  		/* bc 4, CR6_GT, 84 */
		/* 821075B4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82107608;  }
		/* 821075B4h case    3:*/		return 0x821075B8;
		  /* 821075B8h */ case    4:  		/* mr R7, R8 */
		/* 821075B8h case    4:*/		regs.R7 = regs.R8;
		/* 821075B8h case    4:*/		return 0x821075BC;
		  /* 821075BCh */ case    5:  		/* mr R10, R24 */
		/* 821075BCh case    5:*/		regs.R10 = regs.R24;
		/* 821075BCh case    5:*/		return 0x821075C0;
		  /* 821075C0h */ case    6:  		/* cmplwi CR6, R8, 0 */
		/* 821075C0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821075C0h case    6:*/		return 0x821075C4;
		  /* 821075C4h */ case    7:  		/* bc 12, CR6_EQ, 52 */
		/* 821075C4h case    7:*/		if ( regs.CR[6].eq ) { return 0x821075F8;  }
		/* 821075C4h case    7:*/		return 0x821075C8;
		  /* 821075C8h */ case    8:  		/* mtspr CTR, R8 */
		/* 821075C8h case    8:*/		regs.CTR = regs.R8;
		/* 821075C8h case    8:*/		return 0x821075CC;
		  /* 821075CCh */ case    9:  		/* lwz R6, <#[R11 + 12]> */
		/* 821075CCh case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 821075CCh case    9:*/		return 0x821075D0;
		  /* 821075D0h */ case   10:  		/* add R5, R7, R10 */
		/* 821075D0h case   10:*/		cpu::op::add<0>(regs,&regs.R5,regs.R7,regs.R10);
		/* 821075D0h case   10:*/		return 0x821075D4;
		  /* 821075D4h */ case   11:  		/* lwz R30, <#[R11 + 8]> */
		/* 821075D4h case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000008) );
		/* 821075D4h case   11:*/		return 0x821075D8;
		  /* 821075D8h */ case   12:  		/* mullw R6, R9, R6 */
		/* 821075D8h case   12:*/		cpu::op::mullw<0>(regs,&regs.R6,regs.R9,regs.R6);
		/* 821075D8h case   12:*/		return 0x821075DC;
		  /* 821075DCh */ case   13:  		/* add R6, R6, R10 */
		/* 821075DCh case   13:*/		cpu::op::add<0>(regs,&regs.R6,regs.R6,regs.R10);
		/* 821075DCh case   13:*/		return 0x821075E0;
		  /* 821075E0h */ case   14:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 821075E0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 821075E0h case   14:*/		return 0x821075E4;
		  /* 821075E4h */ case   15:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 821075E4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 821075E4h case   15:*/		return 0x821075E8;
	}
	return 0x821075E8;
} // Block from 821075A8h-821075E8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821075E8h
// Function '?DeadLinkRemove@CProgram@D3DXShader@@AAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821075E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821075E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821075E8);
		  /* 821075E8h */ case    0:  		/* addi R10, R10, 1 */
		/* 821075E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821075E8h case    0:*/		return 0x821075EC;
		  /* 821075ECh */ case    1:  		/* lwzx R6, <#[R6 + R30]> */
		/* 821075ECh case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R30 + 0x00000000) );
		/* 821075ECh case    1:*/		return 0x821075F0;
		  /* 821075F0h */ case    2:  		/* stwx R6, <#[R5 + R30]> */
		/* 821075F0h case    2:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R5 + regs.R30 + 0x00000000) );
		/* 821075F0h case    2:*/		return 0x821075F4;
		  /* 821075F4h */ case    3:  		/* bc 16, CR0_LT, -40 */
		/* 821075F4h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821075CC;  }
		/* 821075F4h case    3:*/		return 0x821075F8;
	}
	return 0x821075F8;
} // Block from 821075E8h-821075F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821075F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821075F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821075F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821075F8);
		  /* 821075F8h */ case    0:  		/* addi R9, R9, 1 */
		/* 821075F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821075F8h case    0:*/		return 0x821075FC;
		  /* 821075FCh */ case    1:  		/* add R7, R7, R8 */
		/* 821075FCh case    1:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R8);
		/* 821075FCh case    1:*/		return 0x82107600;
		  /* 82107600h */ case    2:  		/* cmplw CR6, R9, R4 */
		/* 82107600h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 82107600h case    2:*/		return 0x82107604;
		  /* 82107604h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 82107604h case    3:*/		if ( regs.CR[6].lt ) { return 0x821075BC;  }
		/* 82107604h case    3:*/		return 0x82107608;
	}
	return 0x82107608;
} // Block from 821075F8h-82107608h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82107608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107608);
		  /* 82107608h */ case    0:  		/* mullw R10, R8, R4 */
		/* 82107608h case    0:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R8,regs.R4);
		/* 82107608h case    0:*/		return 0x8210760C;
		  /* 8210760Ch */ case    1:  		/* stw R8, <#[R11 + 12]> */
		/* 8210760Ch case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210760Ch case    1:*/		return 0x82107610;
		  /* 82107610h */ case    2:  		/* stw R10, <#[R11 + 4]> */
		/* 82107610h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82107610h case    2:*/		return 0x82107614;
		  /* 82107614h */ case    3:  		/* b 96 */
		/* 82107614h case    3:*/		return 0x82107674;
		/* 82107614h case    3:*/		return 0x82107618;
	}
	return 0x82107618;
} // Block from 82107608h-82107618h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82107618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107618);
		  /* 82107618h */ case    0:  		/* lwz R6, <#[R11 + 12]> */
		/* 82107618h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000000C) );
		/* 82107618h case    0:*/		return 0x8210761C;
		  /* 8210761Ch */ case    1:  		/* mr R9, R24 */
		/* 8210761Ch case    1:*/		regs.R9 = regs.R24;
		/* 8210761Ch case    1:*/		return 0x82107620;
		  /* 82107620h */ case    2:  		/* cmplwi CR6, R6, 0 */
		/* 82107620h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82107620h case    2:*/		return 0x82107624;
		  /* 82107624h */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 82107624h case    3:*/		if ( regs.CR[6].eq ) { return 0x82107660;  }
		/* 82107624h case    3:*/		return 0x82107628;
		  /* 82107628h */ case    4:  		/* lwz R8, <#[R11 + 16]> */
		/* 82107628h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 82107628h case    4:*/		return 0x8210762C;
		  /* 8210762Ch */ case    5:  		/* mr R10, R24 */
		/* 8210762Ch case    5:*/		regs.R10 = regs.R24;
		/* 8210762Ch case    5:*/		return 0x82107630;
		  /* 82107630h */ case    6:  		/* lwz R7, <#[R26 + 20]> */
		/* 82107630h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000014) );
		/* 82107630h case    6:*/		return 0x82107634;
		  /* 82107634h */ case    7:  		/* lwzx R5, <#[R10 + R8]> */
		/* 82107634h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82107634h case    7:*/		return 0x82107638;
		  /* 82107638h */ case    8:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82107638h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82107638h case    8:*/		return 0x8210763C;
		  /* 8210763Ch */ case    9:  		/* lwzx R5, <#[R5 + R7]> */
		/* 8210763Ch case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R7 + 0x00000000) );
		/* 8210763Ch case    9:*/		return 0x82107640;
		  /* 82107640h */ case   10:  		/* lwz R5, <#[R5 + 84]> */
		/* 82107640h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000054) );
		/* 82107640h case   10:*/		return 0x82107644;
		  /* 82107644h */ case   11:  		/* cmplwi CR6, R5, 2 */
		/* 82107644h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000002);
		/* 82107644h case   11:*/		return 0x82107648;
		  /* 82107648h */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 82107648h case   12:*/		if ( regs.CR[6].eq ) { return 0x82107660;  }
		/* 82107648h case   12:*/		return 0x8210764C;
		  /* 8210764Ch */ case   13:  		/* lwz R5, <#[R11 + 12]> */
		/* 8210764Ch case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210764Ch case   13:*/		return 0x82107650;
		  /* 82107650h */ case   14:  		/* addi R9, R9, 1 */
		/* 82107650h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82107650h case   14:*/		return 0x82107654;
		  /* 82107654h */ case   15:  		/* addi R10, R10, 4 */
		/* 82107654h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82107654h case   15:*/		return 0x82107658;
		  /* 82107658h */ case   16:  		/* cmplw CR6, R9, R5 */
		/* 82107658h case   16:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 82107658h case   16:*/		return 0x8210765C;
		  /* 8210765Ch */ case   17:  		/* bc 12, CR6_LT, -40 */
		/* 8210765Ch case   17:*/		if ( regs.CR[6].lt ) { return 0x82107634;  }
		/* 8210765Ch case   17:*/		return 0x82107660;
	}
	return 0x82107660;
} // Block from 82107618h-82107660h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82107660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107660);
		  /* 82107660h */ case    0:  		/* cmplw CR6, R9, R6 */
		/* 82107660h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 82107660h case    0:*/		return 0x82107664;
		  /* 82107664h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 82107664h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82107678;  }
		/* 82107664h case    1:*/		return 0x82107668;
		  /* 82107668h */ case    2:  		/* stw R24, <#[R11]> */
		/* 82107668h case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000000) );
		/* 82107668h case    2:*/		return 0x8210766C;
		  /* 8210766Ch */ case    3:  		/* stw R24, <#[R11 + 12]> */
		/* 8210766Ch case    3:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210766Ch case    3:*/		return 0x82107670;
		  /* 82107670h */ case    4:  		/* stw R24, <#[R11 + 4]> */
		/* 82107670h case    4:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000004) );
		/* 82107670h case    4:*/		return 0x82107674;
	}
	return 0x82107674;
} // Block from 82107660h-82107674h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82107674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107674);
		  /* 82107674h */ case    0:  		/* li R21, 1 */
		/* 82107674h case    0:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 82107674h case    0:*/		return 0x82107678;
	}
	return 0x82107678;
} // Block from 82107674h-82107678h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107678);
		  /* 82107678h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 82107678h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 82107678h case    0:*/		return 0x8210767C;
		  /* 8210767Ch */ case    1:  		/* addi R31, R31, 1 */
		/* 8210767Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8210767Ch case    1:*/		return 0x82107680;
		  /* 82107680h */ case    2:  		/* addi R3, R3, 4 */
		/* 82107680h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82107680h case    2:*/		return 0x82107684;
		  /* 82107684h */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 82107684h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82107684h case    3:*/		return 0x82107688;
		  /* 82107688h */ case    4:  		/* bc 12, CR6_LT, -472 */
		/* 82107688h case    4:*/		if ( regs.CR[6].lt ) { return 0x821074B0;  }
		/* 82107688h case    4:*/		return 0x8210768C;
	}
	return 0x8210768C;
} // Block from 82107678h-8210768Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210768Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210768C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210768C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210768C);
		  /* 8210768Ch */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 8210768Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8210768Ch case    0:*/		return 0x82107690;
		  /* 82107690h */ case    1:  		/* mr R8, R24 */
		/* 82107690h case    1:*/		regs.R8 = regs.R24;
		/* 82107690h case    1:*/		return 0x82107694;
		  /* 82107694h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82107694h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82107694h case    2:*/		return 0x82107698;
		  /* 82107698h */ case    3:  		/* bc 4, CR6_GT, 188 */
		/* 82107698h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82107754;  }
		/* 82107698h case    3:*/		return 0x8210769C;
		  /* 8210769Ch */ case    4:  		/* mr R7, R24 */
		/* 8210769Ch case    4:*/		regs.R7 = regs.R24;
		/* 8210769Ch case    4:*/		return 0x821076A0;
		  /* 821076A0h */ case    5:  		/* lwz R10, <#[R26 + 20]> */
		/* 821076A0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 821076A0h case    5:*/		return 0x821076A4;
		  /* 821076A4h */ case    6:  		/* cmpwi CR6, R8, -1 */
		/* 821076A4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 821076A4h case    6:*/		return 0x821076A8;
		  /* 821076A8h */ case    7:  		/* lwzx R9, <#[R10 + R7]> */
		/* 821076A8h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 821076A8h case    7:*/		return 0x821076AC;
		  /* 821076ACh */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 821076ACh case    8:*/		if ( regs.CR[6].eq ) { return 0x821076BC;  }
		/* 821076ACh case    8:*/		return 0x821076B0;
		  /* 821076B0h */ case    9:  		/* lwz R11, <#[R9 + 56]> */
		/* 821076B0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000038) );
		/* 821076B0h case    9:*/		return 0x821076B4;
		  /* 821076B4h */ case   10:  		/* cmpwi CR6, R11, -1 */
		/* 821076B4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821076B4h case   10:*/		return 0x821076B8;
		  /* 821076B8h */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 821076B8h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821076C0;  }
		/* 821076B8h case   11:*/		return 0x821076BC;
	}
	return 0x821076BC;
} // Block from 8210768Ch-821076BCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 821076BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821076BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821076BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821076BC);
		  /* 821076BCh */ case    0:  		/* mr R11, R8 */
		/* 821076BCh case    0:*/		regs.R11 = regs.R8;
		/* 821076BCh case    0:*/		return 0x821076C0;
	}
	return 0x821076C0;
} // Block from 821076BCh-821076C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821076C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821076C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821076C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821076C0);
		  /* 821076C0h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821076C0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821076C0h case    0:*/		return 0x821076C4;
		  /* 821076C4h */ case    1:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821076C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821076C4h case    1:*/		return 0x821076C8;
		  /* 821076C8h */ case    2:  		/* lwz R11, <#[R11 + 84]> */
		/* 821076C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 821076C8h case    2:*/		return 0x821076CC;
		  /* 821076CCh */ case    3:  		/* cmplwi CR6, R11, 2 */
		/* 821076CCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 821076CCh case    3:*/		return 0x821076D0;
		  /* 821076D0h */ case    4:  		/* bc 12, CR6_EQ, 112 */
		/* 821076D0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82107740;  }
		/* 821076D0h case    4:*/		return 0x821076D4;
		  /* 821076D4h */ case    5:  		/* lwz R10, <#[R26 + 116]> */
		/* 821076D4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000074) );
		/* 821076D4h case    5:*/		return 0x821076D8;
		  /* 821076D8h */ case    6:  		/* lwz R11, <#[R9 + 4]> */
		/* 821076D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 821076D8h case    6:*/		return 0x821076DC;
		  /* 821076DCh */ case    7:  		/* cmplw CR6, R10, R11 */
		/* 821076DCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821076DCh case    7:*/		return 0x821076E0;
		  /* 821076E0h */ case    8:  		/* bc 12, CR6_EQ, 96 */
		/* 821076E0h case    8:*/		if ( regs.CR[6].eq ) { return 0x82107740;  }
		/* 821076E0h case    8:*/		return 0x821076E4;
		  /* 821076E4h */ case    9:  		/* lwz R6, <#[R9 + 8]> */
		/* 821076E4h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000008) );
		/* 821076E4h case    9:*/		return 0x821076E8;
		  /* 821076E8h */ case   10:  		/* cmpwi CR6, R6, -1 */
		/* 821076E8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 821076E8h case   10:*/		return 0x821076EC;
		  /* 821076ECh */ case   11:  		/* bc 4, CR6_EQ, 28 */
		/* 821076ECh case   11:*/		if ( !regs.CR[6].eq ) { return 0x82107708;  }
		/* 821076ECh case   11:*/		return 0x821076F0;
		  /* 821076F0h */ case   12:  		/* lwz R6, <#[R26 + 16]> */
		/* 821076F0h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000010) );
		/* 821076F0h case   12:*/		return 0x821076F4;
		  /* 821076F4h */ case   13:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 821076F4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 821076F4h case   13:*/		return 0x821076F8;
		  /* 821076F8h */ case   14:  		/* lwzx R6, <#[R5 + R6]> */
		/* 821076F8h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 821076F8h case   14:*/		return 0x821076FC;
		  /* 821076FCh */ case   15:  		/* lwz R6, <#[R6 + 4]> */
		/* 821076FCh case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000004) );
		/* 821076FCh case   15:*/		return 0x82107700;
		  /* 82107700h */ case   16:  		/* rlwinm. R6, R6, 0, 21, 21 */
		/* 82107700h case   16:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R6,regs.R6);
		/* 82107700h case   16:*/		return 0x82107704;
		  /* 82107704h */ case   17:  		/* bc 4, CR0_EQ, 60 */
		/* 82107704h case   17:*/		if ( !regs.CR[0].eq ) { return 0x82107740;  }
		/* 82107704h case   17:*/		return 0x82107708;
	}
	return 0x82107708;
} // Block from 821076C0h-82107708h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82107708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107708);
		  /* 82107708h */ case    0:  		/* lwz R6, <#[R26 + 16]> */
		/* 82107708h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R26 + 0x00000010) );
		/* 82107708h case    0:*/		return 0x8210770C;
		  /* 8210770Ch */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210770Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210770Ch case    1:*/		return 0x82107710;
		  /* 82107710h */ case    2:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107710h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107710h case    2:*/		return 0x82107714;
		  /* 82107714h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 82107714h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82107714h case    3:*/		return 0x82107718;
		  /* 82107718h */ case    4:  		/* rlwinm. R6, R11, 0, 22, 23 */
		/* 82107718h case    4:*/		cpu::op::rlwinm<1,0,22,23>(regs,&regs.R6,regs.R11);
		/* 82107718h case    4:*/		return 0x8210771C;
		  /* 8210771Ch */ case    5:  		/* bc 12, CR0_EQ, 28 */
		/* 8210771Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82107738;  }
		/* 8210771Ch case    5:*/		return 0x82107720;
		  /* 82107720h */ case    6:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 82107720h case    6:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 82107720h case    6:*/		return 0x82107724;
		  /* 82107724h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 82107724h case    7:*/		if ( regs.CR[0].eq ) { return 0x82107738;  }
		/* 82107724h case    7:*/		return 0x82107728;
		  /* 82107728h */ case    8:  		/* lwz R11, <#[R9]> */
		/* 82107728h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 82107728h case    8:*/		return 0x8210772C;
		  /* 8210772Ch */ case    9:  		/* oris R11, R11, 4096 */
		/* 8210772Ch case    9:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 8210772Ch case    9:*/		return 0x82107730;
		  /* 82107730h */ case   10:  		/* stw R11, <#[R9]> */
		/* 82107730h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 82107730h case   10:*/		return 0x82107734;
		  /* 82107734h */ case   11:  		/* b 12 */
		/* 82107734h case   11:*/		return 0x82107740;
		/* 82107734h case   11:*/		return 0x82107738;
	}
	return 0x82107738;
} // Block from 82107708h-82107738h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82107738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107738);
		  /* 82107738h */ case    0:  		/* stw R10, <#[R9 + 4]> */
		/* 82107738h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 82107738h case    0:*/		return 0x8210773C;
		  /* 8210773Ch */ case    1:  		/* li R21, 1 */
		/* 8210773Ch case    1:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 8210773Ch case    1:*/		return 0x82107740;
	}
	return 0x82107740;
} // Block from 82107738h-82107740h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82107740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107740);
		  /* 82107740h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82107740h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82107740h case    0:*/		return 0x82107744;
		  /* 82107744h */ case    1:  		/* addi R8, R8, 1 */
		/* 82107744h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82107744h case    1:*/		return 0x82107748;
		  /* 82107748h */ case    2:  		/* addi R7, R7, 4 */
		/* 82107748h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82107748h case    2:*/		return 0x8210774C;
		  /* 8210774Ch */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8210774Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210774Ch case    3:*/		return 0x82107750;
		  /* 82107750h */ case    4:  		/* bc 12, CR6_LT, -176 */
		/* 82107750h case    4:*/		if ( regs.CR[6].lt ) { return 0x821076A0;  }
		/* 82107750h case    4:*/		return 0x82107754;
	}
	return 0x82107754;
} // Block from 82107740h-82107754h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82107754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107754);
		  /* 82107754h */ case    0:  		/* cntlzw R11, R21 */
		/* 82107754h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R21);
		/* 82107754h case    0:*/		return 0x82107758;
		  /* 82107758h */ case    1:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 82107758h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 82107758h case    1:*/		return 0x8210775C;
		  /* 8210775Ch */ case    2:  		/* addi R1, R1, 192 */
		/* 8210775Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 8210775Ch case    2:*/		return 0x82107760;
		  /* 82107760h */ case    3:  		/* b -484568 */
		/* 82107760h case    3:*/		return 0x82091288;
		/* 82107760h case    3:*/		return 0x82107764;
		  /* 82107764h */ case    4:  		/* nop */
		/* 82107764h case    4:*/		cpu::op::nop();
		/* 82107764h case    4:*/		return 0x82107768;
	}
	return 0x82107768;
} // Block from 82107754h-82107768h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82107768h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107768);
		  /* 82107768h */ case    0:  		/* mfspr R12, LR */
		/* 82107768h case    0:*/		regs.R12 = regs.LR;
		/* 82107768h case    0:*/		return 0x8210776C;
		  /* 8210776Ch */ case    1:  		/* bl -484640 */
		/* 8210776Ch case    1:*/		regs.LR = 0x82107770; return 0x8209124C;
		/* 8210776Ch case    1:*/		return 0x82107770;
		  /* 82107770h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82107770h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82107770h case    2:*/		return 0x82107774;
		  /* 82107774h */ case    3:  		/* mr R31, R3 */
		/* 82107774h case    3:*/		regs.R31 = regs.R3;
		/* 82107774h case    3:*/		return 0x82107778;
		  /* 82107778h */ case    4:  		/* li R25, 0 */
		/* 82107778h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82107778h case    4:*/		return 0x8210777C;
		  /* 8210777Ch */ case    5:  		/* bl -7140 */
		/* 8210777Ch case    5:*/		regs.LR = 0x82107780; return 0x82105B98;
		/* 8210777Ch case    5:*/		return 0x82107780;
		  /* 82107780h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 82107780h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82107780h case    6:*/		return 0x82107784;
		  /* 82107784h */ case    7:  		/* lis R4, 9345 */
		/* 82107784h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82107784h case    7:*/		return 0x82107788;
		  /* 82107788h */ case    8:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 82107788h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 82107788h case    8:*/		return 0x8210778C;
		  /* 8210778Ch */ case    9:  		/* bl -521612 */
		/* 8210778Ch case    9:*/		regs.LR = 0x82107790; return 0x82088200;
		/* 8210778Ch case    9:*/		return 0x82107790;
		  /* 82107790h */ case   10:  		/* or. R26, R3, R3 */
		/* 82107790h case   10:*/		cpu::op::or<1>(regs,&regs.R26,regs.R3,regs.R3);
		/* 82107790h case   10:*/		return 0x82107794;
		  /* 82107794h */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 82107794h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821077A4;  }
		/* 82107794h case   11:*/		return 0x82107798;
		  /* 82107798h */ case   12:  		/* lis R3, -32761 */
		/* 82107798h case   12:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 82107798h case   12:*/		return 0x8210779C;
		  /* 8210779Ch */ case   13:  		/* ori R3, R3, 14 */
		/* 8210779Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 8210779Ch case   13:*/		return 0x821077A0;
		  /* 821077A0h */ case   14:  		/* b 612 */
		/* 821077A0h case   14:*/		return 0x82107A04;
		/* 821077A0h case   14:*/		return 0x821077A4;
	}
	return 0x821077A4;
} // Block from 82107768h-821077A4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821077A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821077A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821077A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821077A4);
		  /* 821077A4h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 821077A4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821077A4h case    0:*/		return 0x821077A8;
		  /* 821077A8h */ case    1:  		/* li R30, 0 */
		/* 821077A8h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821077A8h case    1:*/		return 0x821077AC;
		  /* 821077ACh */ case    2:  		/* li R29, 0 */
		/* 821077ACh case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821077ACh case    2:*/		return 0x821077B0;
		  /* 821077B0h */ case    3:  		/* li R11, 0 */
		/* 821077B0h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821077B0h case    3:*/		return 0x821077B4;
		  /* 821077B4h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 821077B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821077B4h case    4:*/		return 0x821077B8;
		  /* 821077B8h */ case    5:  		/* bc 4, CR6_GT, 104 */
		/* 821077B8h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82107820;  }
		/* 821077B8h case    5:*/		return 0x821077BC;
		  /* 821077BCh */ case    6:  		/* li R9, 0 */
		/* 821077BCh case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821077BCh case    6:*/		return 0x821077C0;
		  /* 821077C0h */ case    7:  		/* addi R8, R26, -4 */
		/* 821077C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R26,0xFFFFFFFC);
		/* 821077C0h case    7:*/		return 0x821077C4;
		  /* 821077C4h */ case    8:  		/* lwz R10, <#[R31 + 20]> */
		/* 821077C4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821077C4h case    8:*/		return 0x821077C8;
		  /* 821077C8h */ case    9:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821077C8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821077C8h case    9:*/		return 0x821077CC;
		  /* 821077CCh */ case   10:  		/* stw R11, <#[R10 + 48]> */
		/* 821077CCh case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000030) );
		/* 821077CCh case   10:*/		return 0x821077D0;
		  /* 821077D0h */ case   11:  		/* lwz R10, <#[R10 + 4]> */
		/* 821077D0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821077D0h case   11:*/		return 0x821077D4;
		  /* 821077D4h */ case   12:  		/* lwz R7, <#[R31 + 16]> */
		/* 821077D4h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 821077D4h case   12:*/		return 0x821077D8;
		  /* 821077D8h */ case   13:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821077D8h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821077D8h case   13:*/		return 0x821077DC;
		  /* 821077DCh */ case   14:  		/* lwzx R10, <#[R10 + R7]> */
		/* 821077DCh case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 821077DCh case   14:*/		return 0x821077E0;
		  /* 821077E0h */ case   15:  		/* lwz R10, <#[R10 + 4]> */
		/* 821077E0h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821077E0h case   15:*/		return 0x821077E4;
		  /* 821077E4h */ case   16:  		/* rlwinm. R7, R10, 0, 23, 23 */
		/* 821077E4h case   16:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R7,regs.R10);
		/* 821077E4h case   16:*/		return 0x821077E8;
		  /* 821077E8h */ case   17:  		/* bc 12, CR0_EQ, 36 */
		/* 821077E8h case   17:*/		if ( regs.CR[0].eq ) { return 0x8210780C;  }
		/* 821077E8h case   17:*/		return 0x821077EC;
		  /* 821077ECh */ case   18:  		/* rlwinm. R7, R10, 0, 21, 21 */
		/* 821077ECh case   18:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R7,regs.R10);
		/* 821077ECh case   18:*/		return 0x821077F0;
		  /* 821077F0h */ case   19:  		/* bc 4, CR0_EQ, 28 */
		/* 821077F0h case   19:*/		if ( !regs.CR[0].eq ) { return 0x8210780C;  }
		/* 821077F0h case   19:*/		return 0x821077F4;
		  /* 821077F4h */ case   20:  		/* rlwinm. R7, R10, 0, 20, 20 */
		/* 821077F4h case   20:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R7,regs.R10);
		/* 821077F4h case   20:*/		return 0x821077F8;
		  /* 821077F8h */ case   21:  		/* bc 4, CR0_EQ, 20 */
		/* 821077F8h case   21:*/		if ( !regs.CR[0].eq ) { return 0x8210780C;  }
		/* 821077F8h case   21:*/		return 0x821077FC;
		  /* 821077FCh */ case   22:  		/* rlwinm. R10, R10, 0, 25, 25 */
		/* 821077FCh case   22:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R10);
		/* 821077FCh case   22:*/		return 0x82107800;
		  /* 82107800h */ case   23:  		/* bc 4, CR0_EQ, 12 */
		/* 82107800h case   23:*/		if ( !regs.CR[0].eq ) { return 0x8210780C;  }
		/* 82107800h case   23:*/		return 0x82107804;
		  /* 82107804h */ case   24:  		/* stwu R11, <#[R8 + 4]> */
		/* 82107804h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 82107804h case   24:*/		return 0x82107808;
		  /* 82107808h */ case   25:  		/* addi R30, R30, 1 */
		/* 82107808h case   25:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82107808h case   25:*/		return 0x8210780C;
	}
	return 0x8210780C;
} // Block from 821077A4h-8210780Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 8210780Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210780C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210780C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210780C);
		  /* 8210780Ch */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 8210780Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8210780Ch case    0:*/		return 0x82107810;
		  /* 82107810h */ case    1:  		/* addi R11, R11, 1 */
		/* 82107810h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82107810h case    1:*/		return 0x82107814;
		  /* 82107814h */ case    2:  		/* addi R9, R9, 4 */
		/* 82107814h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82107814h case    2:*/		return 0x82107818;
		  /* 82107818h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82107818h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82107818h case    3:*/		return 0x8210781C;
		  /* 8210781Ch */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 8210781Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x821077C4;  }
		/* 8210781Ch case    4:*/		return 0x82107820;
	}
	return 0x82107820;
} // Block from 8210780Ch-82107820h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82107820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107820);
		  /* 82107820h */ case    0:  		/* lis R11, -32240 */
		/* 82107820h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8210);
		/* 82107820h case    0:*/		return 0x82107824;
		  /* 82107824h */ case    1:  		/* mr R6, R31 */
		/* 82107824h case    1:*/		regs.R6 = regs.R31;
		/* 82107824h case    1:*/		return 0x82107828;
		  /* 82107828h */ case    2:  		/* mr R5, R30 */
		/* 82107828h case    2:*/		regs.R5 = regs.R30;
		/* 82107828h case    2:*/		return 0x8210782C;
		  /* 8210782Ch */ case    3:  		/* mr R4, R26 */
		/* 8210782Ch case    3:*/		regs.R4 = regs.R26;
		/* 8210782Ch case    3:*/		return 0x82107830;
		  /* 82107830h */ case    4:  		/* addi R3, R11, -10064 */
		/* 82107830h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFD8B0);
		/* 82107830h case    4:*/		return 0x82107834;
		  /* 82107834h */ case    5:  		/* bl -39316 */
		/* 82107834h case    5:*/		regs.LR = 0x82107838; return 0x820FDEA0;
		/* 82107834h case    5:*/		return 0x82107838;
		  /* 82107838h */ case    6:  		/* cmplwi CR6, R30, 1 */
		/* 82107838h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000001);
		/* 82107838h case    6:*/		return 0x8210783C;
		  /* 8210783Ch */ case    7:  		/* bc 4, CR6_GT, 148 */
		/* 8210783Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x821078D0;  }
		/* 8210783Ch case    7:*/		return 0x82107840;
		  /* 82107840h */ case    8:  		/* addi R7, R26, 4 */
		/* 82107840h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R26,0x4);
		/* 82107840h case    8:*/		return 0x82107844;
		  /* 82107844h */ case    9:  		/* addi R6, R30, -1 */
		/* 82107844h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R30,0xFFFFFFFF);
		/* 82107844h case    9:*/		return 0x82107848;
		  /* 82107848h */ case   10:  		/* lwz R11, <#[R7 - 4]> */
		/* 82107848h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0xFFFFFFFC) );
		/* 82107848h case   10:*/		return 0x8210784C;
		  /* 8210784Ch */ case   11:  		/* mr R5, R31 */
		/* 8210784Ch case   11:*/		regs.R5 = regs.R31;
		/* 8210784Ch case   11:*/		return 0x82107850;
		  /* 82107850h */ case   12:  		/* lwz R10, <#[R31 + 20]> */
		/* 82107850h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82107850h case   12:*/		return 0x82107854;
		  /* 82107854h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107854h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107854h case   13:*/		return 0x82107858;
	}
	return 0x82107858;
} // Block from 82107820h-82107858h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82107858h
// Function '?DelayOutputs@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107858);
		  /* 82107858h */ case    0:  		/* lwz R4, <#[R7]> */
		/* 82107858h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R7 + 0x00000000) );
		/* 82107858h case    0:*/		return 0x8210785C;
		  /* 8210785Ch */ case    1:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210785Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210785Ch case    1:*/		return 0x82107860;
		  /* 82107860h */ case    2:  		/* lwz R3, <#[R11 + 48]> */
		/* 82107860h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000030) );
		/* 82107860h case    2:*/		return 0x82107864;
		  /* 82107864h */ case    3:  		/* bl -40884 */
		/* 82107864h case    3:*/		regs.LR = 0x82107868; return 0x820FD8B0;
		/* 82107864h case    3:*/		return 0x82107868;
		  /* 82107868h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 82107868h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82107868h case    4:*/		return 0x8210786C;
		  /* 8210786Ch */ case    5:  		/* bc 4, CR0_EQ, 68 */
		/* 8210786Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x821078B0;  }
		/* 8210786Ch case    5:*/		return 0x82107870;
		  /* 82107870h */ case    6:  		/* rlwinm R11, R4, 0, 0, 31 */
		/* 82107870h case    6:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R4);
		/* 82107870h case    6:*/		return 0x82107874;
		  /* 82107874h */ case    7:  		/* lwz R10, <#[R31 + 20]> */
		/* 82107874h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82107874h case    7:*/		return 0x82107878;
		  /* 82107878h */ case    8:  		/* lwz R9, <#[R31 + 116]> */
		/* 82107878h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000074) );
		/* 82107878h case    8:*/		return 0x8210787C;
		  /* 8210787Ch */ case    9:  		/* li R29, 1 */
		/* 8210787Ch case    9:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 8210787Ch case    9:*/		return 0x82107880;
		  /* 82107880h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107880h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107880h case   10:*/		return 0x82107884;
		  /* 82107884h */ case   11:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82107884h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82107884h case   11:*/		return 0x82107888;
		  /* 82107888h */ case   12:  		/* stw R9, <#[R11 + 4]> */
		/* 82107888h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82107888h case   12:*/		return 0x8210788C;
		  /* 8210788Ch */ case   13:  		/* lwz R11, <#[R7]> */
		/* 8210788Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8210788Ch case   13:*/		return 0x82107890;
		  /* 82107890h */ case   14:  		/* lwz R10, <#[R31 + 20]> */
		/* 82107890h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82107890h case   14:*/		return 0x82107894;
		  /* 82107894h */ case   15:  		/* lwz R9, <#[R7 - 4]> */
		/* 82107894h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0xFFFFFFFC) );
		/* 82107894h case   15:*/		return 0x82107898;
		  /* 82107898h */ case   16:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82107898h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82107898h case   16:*/		return 0x8210789C;
		  /* 8210789Ch */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210789Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210789Ch case   17:*/		return 0x821078A0;
		  /* 821078A0h */ case   18:  		/* lwzx R9, <#[R9 + R10]> */
		/* 821078A0h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821078A0h case   18:*/		return 0x821078A4;
		  /* 821078A4h */ case   19:  		/* lwz R9, <#[R9 + 48]> */
		/* 821078A4h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000030) );
		/* 821078A4h case   19:*/		return 0x821078A8;
		  /* 821078A8h */ case   20:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821078A8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821078A8h case   20:*/		return 0x821078AC;
		  /* 821078ACh */ case   21:  		/* stw R9, <#[R11 + 48]> */
		/* 821078ACh case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 821078ACh case   21:*/		return 0x821078B0;
	}
	return 0x821078B0;
} // Block from 82107858h-821078B0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821078B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821078B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821078B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821078B0);
		  /* 821078B0h */ case    0:  		/* addic. R6, R6, -1 */
		/* 821078B0h case    0:*/		cpu::op::addic<1>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 821078B0h case    0:*/		return 0x821078B4;
		  /* 821078B4h */ case    1:  		/* addi R7, R7, 4 */
		/* 821078B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 821078B4h case    1:*/		return 0x821078B8;
		  /* 821078B8h */ case    2:  		/* bc 4, CR0_EQ, -112 */
		/* 821078B8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82107848;  }
		/* 821078B8h case    2:*/		return 0x821078BC;
		  /* 821078BCh */ case    3:  		/* cmpwi CR6, R29, 0 */
		/* 821078BCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 821078BCh case    3:*/		return 0x821078C0;
		  /* 821078C0h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 821078C0h case    4:*/		if ( regs.CR[6].eq ) { return 0x821078D0;  }
		/* 821078C0h case    4:*/		return 0x821078C4;
		  /* 821078C4h */ case    5:  		/* mr R3, R31 */
		/* 821078C4h case    5:*/		regs.R3 = regs.R31;
		/* 821078C4h case    5:*/		return 0x821078C8;
		  /* 821078C8h */ case    6:  		/* bl -5288 */
		/* 821078C8h case    6:*/		regs.LR = 0x821078CC; return 0x82106420;
		/* 821078C8h case    6:*/		return 0x821078CC;
		  /* 821078CCh */ case    7:  		/* li R25, 1 */
		/* 821078CCh case    7:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 821078CCh case    7:*/		return 0x821078D0;
	}
	return 0x821078D0;
} // Block from 821078B0h-821078D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821078D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821078D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821078D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821078D0);
		  /* 821078D0h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 821078D0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821078D0h case    0:*/		return 0x821078D4;
		  /* 821078D4h */ case    1:  		/* li R28, 0 */
		/* 821078D4h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821078D4h case    1:*/		return 0x821078D8;
		  /* 821078D8h */ case    2:  		/* li R27, 0 */
		/* 821078D8h case    2:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821078D8h case    2:*/		return 0x821078DC;
		  /* 821078DCh */ case    3:  		/* li R11, 0 */
		/* 821078DCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821078DCh case    3:*/		return 0x821078E0;
		  /* 821078E0h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 821078E0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821078E0h case    4:*/		return 0x821078E4;
		  /* 821078E4h */ case    5:  		/* bc 4, CR6_GT, 104 */
		/* 821078E4h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8210794C;  }
		/* 821078E4h case    5:*/		return 0x821078E8;
		  /* 821078E8h */ case    6:  		/* li R9, 0 */
		/* 821078E8h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821078E8h case    6:*/		return 0x821078EC;
		  /* 821078ECh */ case    7:  		/* addi R8, R26, -4 */
		/* 821078ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R26,0xFFFFFFFC);
		/* 821078ECh case    7:*/		return 0x821078F0;
		  /* 821078F0h */ case    8:  		/* lwz R10, <#[R31 + 20]> */
		/* 821078F0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821078F0h case    8:*/		return 0x821078F4;
		  /* 821078F4h */ case    9:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821078F4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821078F4h case    9:*/		return 0x821078F8;
		  /* 821078F8h */ case   10:  		/* stw R11, <#[R10 + 48]> */
		/* 821078F8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000030) );
		/* 821078F8h case   10:*/		return 0x821078FC;
		  /* 821078FCh */ case   11:  		/* lwz R10, <#[R10 + 4]> */
		/* 821078FCh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821078FCh case   11:*/		return 0x82107900;
		  /* 82107900h */ case   12:  		/* lwz R7, <#[R31 + 116]> */
		/* 82107900h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000074) );
		/* 82107900h case   12:*/		return 0x82107904;
		  /* 82107904h */ case   13:  		/* cmplw CR6, R7, R10 */
		/* 82107904h case   13:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 82107904h case   13:*/		return 0x82107908;
		  /* 82107908h */ case   14:  		/* bc 12, CR6_EQ, 48 */
		/* 82107908h case   14:*/		if ( regs.CR[6].eq ) { return 0x82107938;  }
		/* 82107908h case   14:*/		return 0x8210790C;
		  /* 8210790Ch */ case   15:  		/* lwz R7, <#[R31 + 16]> */
		/* 8210790Ch case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 8210790Ch case   15:*/		return 0x82107910;
		  /* 82107910h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82107910h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82107910h case   16:*/		return 0x82107914;
		  /* 82107914h */ case   17:  		/* lwzx R10, <#[R10 + R7]> */
		/* 82107914h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82107914h case   17:*/		return 0x82107918;
		  /* 82107918h */ case   18:  		/* lwz R10, <#[R10 + 4]> */
		/* 82107918h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82107918h case   18:*/		return 0x8210791C;
		  /* 8210791Ch */ case   19:  		/* rlwinm. R10, R10, 0, 25, 25 */
		/* 8210791Ch case   19:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R10);
		/* 8210791Ch case   19:*/		return 0x82107920;
		  /* 82107920h */ case   20:  		/* bc 4, CR0_EQ, 16 */
		/* 82107920h case   20:*/		if ( !regs.CR[0].eq ) { return 0x82107930;  }
		/* 82107920h case   20:*/		return 0x82107924;
		  /* 82107924h */ case   21:  		/* lwz R10, <#[R31 + 220]> */
		/* 82107924h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000DC) );
		/* 82107924h case   21:*/		return 0x82107928;
		  /* 82107928h */ case   22:  		/* cmpwi CR6, R10, 0 */
		/* 82107928h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82107928h case   22:*/		return 0x8210792C;
		  /* 8210792Ch */ case   23:  		/* bc 12, CR6_EQ, 12 */
		/* 8210792Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x82107938;  }
		/* 8210792Ch case   23:*/		return 0x82107930;
	}
	return 0x82107930;
} // Block from 821078D0h-82107930h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82107930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107930);
		  /* 82107930h */ case    0:  		/* stwu R11, <#[R8 + 4]> */
		/* 82107930h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 82107930h case    0:*/		return 0x82107934;
		  /* 82107934h */ case    1:  		/* addi R28, R28, 1 */
		/* 82107934h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82107934h case    1:*/		return 0x82107938;
	}
	return 0x82107938;
} // Block from 82107930h-82107938h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82107938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107938);
		  /* 82107938h */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 82107938h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82107938h case    0:*/		return 0x8210793C;
		  /* 8210793Ch */ case    1:  		/* addi R11, R11, 1 */
		/* 8210793Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210793Ch case    1:*/		return 0x82107940;
		  /* 82107940h */ case    2:  		/* addi R9, R9, 4 */
		/* 82107940h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82107940h case    2:*/		return 0x82107944;
		  /* 82107944h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82107944h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82107944h case    3:*/		return 0x82107948;
		  /* 82107948h */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 82107948h case    4:*/		if ( regs.CR[6].lt ) { return 0x821078F0;  }
		/* 82107948h case    4:*/		return 0x8210794C;
	}
	return 0x8210794C;
} // Block from 82107938h-8210794Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210794Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210794C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210794C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210794C);
		  /* 8210794Ch */ case    0:  		/* lis R11, -32240 */
		/* 8210794Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8210);
		/* 8210794Ch case    0:*/		return 0x82107950;
		  /* 82107950h */ case    1:  		/* mr R6, R31 */
		/* 82107950h case    1:*/		regs.R6 = regs.R31;
		/* 82107950h case    1:*/		return 0x82107954;
		  /* 82107954h */ case    2:  		/* mr R5, R28 */
		/* 82107954h case    2:*/		regs.R5 = regs.R28;
		/* 82107954h case    2:*/		return 0x82107958;
		  /* 82107958h */ case    3:  		/* mr R4, R26 */
		/* 82107958h case    3:*/		regs.R4 = regs.R26;
		/* 82107958h case    3:*/		return 0x8210795C;
		  /* 8210795Ch */ case    4:  		/* addi R3, R11, -9928 */
		/* 8210795Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFD938);
		/* 8210795Ch case    4:*/		return 0x82107960;
		  /* 82107960h */ case    5:  		/* bl -39616 */
		/* 82107960h case    5:*/		regs.LR = 0x82107964; return 0x820FDEA0;
		/* 82107960h case    5:*/		return 0x82107964;
		  /* 82107964h */ case    6:  		/* li R29, 0 */
		/* 82107964h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82107964h case    6:*/		return 0x82107968;
		  /* 82107968h */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 82107968h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82107968h case    7:*/		return 0x8210796C;
		  /* 8210796Ch */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 8210796Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82107974;  }
		/* 8210796Ch case    8:*/		return 0x82107970;
		  /* 82107970h */ case    9:  		/* lwz R29, <#[R26]> */
		/* 82107970h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R26 + 0x00000000) );
		/* 82107970h case    9:*/		return 0x82107974;
	}
	return 0x82107974;
} // Block from 8210794Ch-82107974h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82107974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107974);
		  /* 82107974h */ case    0:  		/* cmplwi CR6, R28, 1 */
		/* 82107974h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000001);
		/* 82107974h case    0:*/		return 0x82107978;
		  /* 82107978h */ case    1:  		/* bc 4, CR6_GT, 120 */
		/* 82107978h case    1:*/		if ( !regs.CR[6].gt ) { return 0x821079F0;  }
		/* 82107978h case    1:*/		return 0x8210797C;
		  /* 8210797Ch */ case    2:  		/* addi R30, R26, 4 */
		/* 8210797Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R26,0x4);
		/* 8210797Ch case    2:*/		return 0x82107980;
		  /* 82107980h */ case    3:  		/* addi R28, R28, -1 */
		/* 82107980h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0xFFFFFFFF);
		/* 82107980h case    3:*/		return 0x82107984;
		  /* 82107984h */ case    4:  		/* mr R5, R31 */
		/* 82107984h case    4:*/		regs.R5 = regs.R31;
		/* 82107984h case    4:*/		return 0x82107988;
		  /* 82107988h */ case    5:  		/* lwz R4, <#[R30]> */
		/* 82107988h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 82107988h case    5:*/		return 0x8210798C;
		  /* 8210798Ch */ case    6:  		/* mr R3, R29 */
		/* 8210798Ch case    6:*/		regs.R3 = regs.R29;
		/* 8210798Ch case    6:*/		return 0x82107990;
		  /* 82107990h */ case    7:  		/* bl -41048 */
		/* 82107990h case    7:*/		regs.LR = 0x82107994; return 0x820FD938;
		/* 82107990h case    7:*/		return 0x82107994;
		  /* 82107994h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 82107994h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82107994h case    8:*/		return 0x82107998;
		  /* 82107998h */ case    9:  		/* bc 4, CR0_EQ, 52 */
		/* 82107998h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821079CC;  }
		/* 82107998h case    9:*/		return 0x8210799C;
		  /* 8210799Ch */ case   10:  		/* mr R5, R4 */
		/* 8210799Ch case   10:*/		regs.R5 = regs.R4;
		/* 8210799Ch case   10:*/		return 0x821079A0;
		  /* 821079A0h */ case   11:  		/* mr R4, R29 */
		/* 821079A0h case   11:*/		regs.R4 = regs.R29;
		/* 821079A0h case   11:*/		return 0x821079A4;
		  /* 821079A4h */ case   12:  		/* mr R3, R31 */
		/* 821079A4h case   12:*/		regs.R3 = regs.R31;
		/* 821079A4h case   12:*/		return 0x821079A8;
		  /* 821079A8h */ case   13:  		/* bl -21632 */
		/* 821079A8h case   13:*/		regs.LR = 0x821079AC; return 0x82102528;
		/* 821079A8h case   13:*/		return 0x821079AC;
		  /* 821079ACh */ case   14:  		/* lwz R11, <#[R30]> */
		/* 821079ACh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821079ACh case   14:*/		return 0x821079B0;
		  /* 821079B0h */ case   15:  		/* lwz R10, <#[R31 + 20]> */
		/* 821079B0h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 821079B0h case   15:*/		return 0x821079B4;
		  /* 821079B4h */ case   16:  		/* li R27, 1 */
		/* 821079B4h case   16:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 821079B4h case   16:*/		return 0x821079B8;
		  /* 821079B8h */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821079B8h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821079B8h case   17:*/		return 0x821079BC;
		  /* 821079BCh */ case   18:  		/* lwz R9, <#[R31 + 116]> */
		/* 821079BCh case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000074) );
		/* 821079BCh case   18:*/		return 0x821079C0;
		  /* 821079C0h */ case   19:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821079C0h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821079C0h case   19:*/		return 0x821079C4;
		  /* 821079C4h */ case   20:  		/* stw R9, <#[R11 + 4]> */
		/* 821079C4h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821079C4h case   20:*/		return 0x821079C8;
		  /* 821079C8h */ case   21:  		/* b 8 */
		/* 821079C8h case   21:*/		return 0x821079D0;
		/* 821079C8h case   21:*/		return 0x821079CC;
	}
	return 0x821079CC;
} // Block from 82107974h-821079CCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 821079CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821079CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821079CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821079CC);
		  /* 821079CCh */ case    0:  		/* mr R29, R4 */
		/* 821079CCh case    0:*/		regs.R29 = regs.R4;
		/* 821079CCh case    0:*/		return 0x821079D0;
	}
	return 0x821079D0;
} // Block from 821079CCh-821079D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821079D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821079D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821079D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821079D0);
		  /* 821079D0h */ case    0:  		/* addic. R28, R28, -1 */
		/* 821079D0h case    0:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R28,0xFFFFFFFF);
		/* 821079D0h case    0:*/		return 0x821079D4;
		  /* 821079D4h */ case    1:  		/* addi R30, R30, 4 */
		/* 821079D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 821079D4h case    1:*/		return 0x821079D8;
		  /* 821079D8h */ case    2:  		/* bc 4, CR0_EQ, -84 */
		/* 821079D8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82107984;  }
		/* 821079D8h case    2:*/		return 0x821079DC;
		  /* 821079DCh */ case    3:  		/* cmpwi CR6, R27, 0 */
		/* 821079DCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 821079DCh case    3:*/		return 0x821079E0;
		  /* 821079E0h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 821079E0h case    4:*/		if ( regs.CR[6].eq ) { return 0x821079F0;  }
		/* 821079E0h case    4:*/		return 0x821079E4;
		  /* 821079E4h */ case    5:  		/* mr R3, R31 */
		/* 821079E4h case    5:*/		regs.R3 = regs.R31;
		/* 821079E4h case    5:*/		return 0x821079E8;
		  /* 821079E8h */ case    6:  		/* bl -5576 */
		/* 821079E8h case    6:*/		regs.LR = 0x821079EC; return 0x82106420;
		/* 821079E8h case    6:*/		return 0x821079EC;
		  /* 821079ECh */ case    7:  		/* li R25, 1 */
		/* 821079ECh case    7:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 821079ECh case    7:*/		return 0x821079F0;
	}
	return 0x821079F0;
} // Block from 821079D0h-821079F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821079F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821079F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821079F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821079F0);
		  /* 821079F0h */ case    0:  		/* lis R4, 9345 */
		/* 821079F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 821079F0h case    0:*/		return 0x821079F4;
		  /* 821079F4h */ case    1:  		/* mr R3, R26 */
		/* 821079F4h case    1:*/		regs.R3 = regs.R26;
		/* 821079F4h case    1:*/		return 0x821079F8;
		  /* 821079F8h */ case    2:  		/* bl -521920 */
		/* 821079F8h case    2:*/		regs.LR = 0x821079FC; return 0x82088338;
		/* 821079F8h case    2:*/		return 0x821079FC;
		  /* 821079FCh */ case    3:  		/* cntlzw R11, R25 */
		/* 821079FCh case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R25);
		/* 821079FCh case    3:*/		return 0x82107A00;
		  /* 82107A00h */ case    4:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 82107A00h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 82107A00h case    4:*/		return 0x82107A04;
	}
	return 0x82107A04;
} // Block from 821079F0h-82107A04h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82107A04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107A04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107A04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107A04);
		  /* 82107A04h */ case    0:  		/* addi R1, R1, 144 */
		/* 82107A04h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82107A04h case    0:*/		return 0x82107A08;
		  /* 82107A08h */ case    1:  		/* b -485228 */
		/* 82107A08h case    1:*/		return 0x8209129C;
		/* 82107A08h case    1:*/		return 0x82107A0C;
		  /* 82107A0Ch */ case    2:  		/* nop */
		/* 82107A0Ch case    2:*/		cpu::op::nop();
		/* 82107A0Ch case    2:*/		return 0x82107A10;
	}
	return 0x82107A10;
} // Block from 82107A04h-82107A10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82107A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107A10);
		  /* 82107A10h */ case    0:  		/* mfspr R12, LR */
		/* 82107A10h case    0:*/		regs.R12 = regs.LR;
		/* 82107A10h case    0:*/		return 0x82107A14;
		  /* 82107A14h */ case    1:  		/* bl -485356 */
		/* 82107A14h case    1:*/		regs.LR = 0x82107A18; return 0x82091228;
		/* 82107A14h case    1:*/		return 0x82107A18;
		  /* 82107A18h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 82107A18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 82107A18h case    2:*/		return 0x82107A1C;
		  /* 82107A1Ch */ case    3:  		/* lwz R10, <#[R3 + 8]> */
		/* 82107A1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82107A1Ch case    3:*/		return 0x82107A20;
		  /* 82107A20h */ case    4:  		/* mr R18, R3 */
		/* 82107A20h case    4:*/		regs.R18 = regs.R3;
		/* 82107A20h case    4:*/		return 0x82107A24;
		  /* 82107A24h */ case    5:  		/* li R17, 0 */
		/* 82107A24h case    5:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 82107A24h case    5:*/		return 0x82107A28;
		  /* 82107A28h */ case    6:  		/* li R11, 0 */
		/* 82107A28h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82107A28h case    6:*/		return 0x82107A2C;
		  /* 82107A2Ch */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 82107A2Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82107A2Ch case    7:*/		return 0x82107A30;
		  /* 82107A30h */ case    8:  		/* bc 4, CR6_GT, 40 */
		/* 82107A30h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82107A58;  }
		/* 82107A30h case    8:*/		return 0x82107A34;
		  /* 82107A34h */ case    9:  		/* li R10, 0 */
		/* 82107A34h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82107A34h case    9:*/		return 0x82107A38;
		  /* 82107A38h */ case   10:  		/* lwz R9, <#[R18 + 20]> */
		/* 82107A38h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R18 + 0x00000014) );
		/* 82107A38h case   10:*/		return 0x82107A3C;
		  /* 82107A3Ch */ case   11:  		/* lwzx R9, <#[R10 + R9]> */
		/* 82107A3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82107A3Ch case   11:*/		return 0x82107A40;
		  /* 82107A40h */ case   12:  		/* addi R10, R10, 4 */
		/* 82107A40h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82107A40h case   12:*/		return 0x82107A44;
		  /* 82107A44h */ case   13:  		/* stw R11, <#[R9 + 48]> */
		/* 82107A44h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 82107A44h case   13:*/		return 0x82107A48;
		  /* 82107A48h */ case   14:  		/* addi R11, R11, 1 */
		/* 82107A48h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82107A48h case   14:*/		return 0x82107A4C;
		  /* 82107A4Ch */ case   15:  		/* lwz R9, <#[R18 + 8]> */
		/* 82107A4Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R18 + 0x00000008) );
		/* 82107A4Ch case   15:*/		return 0x82107A50;
		  /* 82107A50h */ case   16:  		/* cmplw CR6, R11, R9 */
		/* 82107A50h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82107A50h case   16:*/		return 0x82107A54;
		  /* 82107A54h */ case   17:  		/* bc 12, CR6_LT, -28 */
		/* 82107A54h case   17:*/		if ( regs.CR[6].lt ) { return 0x82107A38;  }
		/* 82107A54h case   17:*/		return 0x82107A58;
	}
	return 0x82107A58;
} // Block from 82107A10h-82107A58h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82107A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107A58);
		  /* 82107A58h */ case    0:  		/* lwz R11, <#[R18 + 12]> */
		/* 82107A58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x0000000C) );
		/* 82107A58h case    0:*/		return 0x82107A5C;
		  /* 82107A5Ch */ case    1:  		/* li R16, 0 */
		/* 82107A5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 82107A5Ch case    1:*/		return 0x82107A60;
		  /* 82107A60h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82107A60h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82107A60h case    2:*/		return 0x82107A64;
		  /* 82107A64h */ case    3:  		/* bc 4, CR6_GT, 1524 */
		/* 82107A64h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82108058;  }
		/* 82107A64h case    3:*/		return 0x82107A68;
		  /* 82107A68h */ case    4:  		/* li R26, -1 */
		/* 82107A68h case    4:*/		cpu::op::li<0>(regs,&regs.R26,0xFFFFFFFF);
		/* 82107A68h case    4:*/		return 0x82107A6C;
		  /* 82107A6Ch */ case    5:  		/* lwz R11, <#[R18 + 24]> */
		/* 82107A6Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000018) );
		/* 82107A6Ch case    5:*/		return 0x82107A70;
		  /* 82107A70h */ case    6:  		/* rlwinm R10, R16, 2, 0, 29 */
		/* 82107A70h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R16);
		/* 82107A70h case    6:*/		return 0x82107A74;
		  /* 82107A74h */ case    7:  		/* lis R9, 4096 */
		/* 82107A74h case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 82107A74h case    7:*/		return 0x82107A78;
		  /* 82107A78h */ case    8:  		/* lwzx R30, <#[R10 + R11]> */
		/* 82107A78h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82107A78h case    8:*/		return 0x82107A7C;
		  /* 82107A7Ch */ case    9:  		/* lwz R11, <#[R30]> */
		/* 82107A7Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82107A7Ch case    9:*/		return 0x82107A80;
		  /* 82107A80h */ case   10:  		/* rlwinm R10, R11, 0, 0, 3 */
		/* 82107A80h case   10:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R11);
		/* 82107A80h case   10:*/		return 0x82107A84;
		  /* 82107A84h */ case   11:  		/* cmplw CR6, R10, R9 */
		/* 82107A84h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82107A84h case   11:*/		return 0x82107A88;
		  /* 82107A88h */ case   12:  		/* bc 12, CR6_LT, 1464 */
		/* 82107A88h case   12:*/		if ( regs.CR[6].lt ) { return 0x82108040;  }
		/* 82107A88h case   12:*/		return 0x82107A8C;
		  /* 82107A8Ch */ case   13:  		/* lis R9, 16384 */
		/* 82107A8Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0x4000);
		/* 82107A8Ch case   13:*/		return 0x82107A90;
		  /* 82107A90h */ case   14:  		/* cmplw CR6, R10, R9 */
		/* 82107A90h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82107A90h case   14:*/		return 0x82107A94;
		  /* 82107A94h */ case   15:  		/* bc 12, CR6_GT, 1452 */
		/* 82107A94h case   15:*/		if ( regs.CR[6].gt ) { return 0x82108040;  }
		/* 82107A94h case   15:*/		return 0x82107A98;
		  /* 82107A98h */ case   16:  		/* lwz R10, <#[R30 + 4]> */
		/* 82107A98h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82107A98h case   16:*/		return 0x82107A9C;
		  /* 82107A9Ch */ case   17:  		/* rlwinm R28, R11, 0, 12, 31 */
		/* 82107A9Ch case   17:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R28,regs.R11);
		/* 82107A9Ch case   17:*/		return 0x82107AA0;
		  /* 82107AA0h */ case   18:  		/* mr R3, R30 */
		/* 82107AA0h case   18:*/		regs.R3 = regs.R30;
		/* 82107AA0h case   18:*/		return 0x82107AA4;
		  /* 82107AA4h */ case   19:  		/* divwu R20, R10, R28 */
		/* 82107AA4h case   19:*/		cpu::op::divwu<0>(regs,&regs.R20,regs.R10,regs.R28);
		/* 82107AA4h case   19:*/		return 0x82107AA8;
		  /* 82107AA8h */ case   20:  		/* twi 6, R28, 0 */
		/* 82107AA8h case   20:*/		cpu::op::tw<6>(regs, 0x82107AA8, regs.R28, 0x00000000);
		/* 82107AA8h case   20:*/		return 0x82107AAC;
		  /* 82107AACh */ case   21:  		/* bl -47788 */
		/* 82107AACh case   21:*/		regs.LR = 0x82107AB0; return 0x820FC000;
		/* 82107AACh case   21:*/		return 0x82107AB0;
		  /* 82107AB0h */ case   22:  		/* mr R21, R3 */
		/* 82107AB0h case   22:*/		regs.R21 = regs.R3;
		/* 82107AB0h case   22:*/		return 0x82107AB4;
		  /* 82107AB4h */ case   23:  		/* mr R22, R28 */
		/* 82107AB4h case   23:*/		regs.R22 = regs.R28;
		/* 82107AB4h case   23:*/		return 0x82107AB8;
		  /* 82107AB8h */ case   24:  		/* li R27, 1 */
		/* 82107AB8h case   24:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82107AB8h case   24:*/		return 0x82107ABC;
		  /* 82107ABCh */ case   25:  		/* cmplwi CR6, R28, 1 */
		/* 82107ABCh case   25:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000001);
		/* 82107ABCh case   25:*/		return 0x82107AC0;
		  /* 82107AC0h */ case   26:  		/* bc 4, CR6_GT, 1408 */
		/* 82107AC0h case   26:*/		if ( !regs.CR[6].gt ) { return 0x82108040;  }
		/* 82107AC0h case   26:*/		return 0x82107AC4;
		  /* 82107AC4h */ case   27:  		/* rlwinm R19, R28, 2, 0, 29 */
		/* 82107AC4h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R19,regs.R28);
		/* 82107AC4h case   27:*/		return 0x82107AC8;
		  /* 82107AC8h */ case   28:  		/* li R31, 4 */
		/* 82107AC8h case   28:*/		cpu::op::li<0>(regs,&regs.R31,0x4);
		/* 82107AC8h case   28:*/		return 0x82107ACC;
		  /* 82107ACCh */ case   29:  		/* addi R24, R19, 4 */
		/* 82107ACCh case   29:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R19,0x4);
		/* 82107ACCh case   29:*/		return 0x82107AD0;
		  /* 82107AD0h */ case   30:  		/* lwz R25, <#[R30 + 16]> */
		/* 82107AD0h case   30:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R30 + 0x00000010) );
		/* 82107AD0h case   30:*/		return 0x82107AD4;
		  /* 82107AD4h */ case   31:  		/* lwz R6, <#[R18 + 20]> */
		/* 82107AD4h case   31:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R18 + 0x00000014) );
		/* 82107AD4h case   31:*/		return 0x82107AD8;
		  /* 82107AD8h */ case   32:  		/* lwz R23, <#[R18 + 16]> */
		/* 82107AD8h case   32:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R18 + 0x00000010) );
		/* 82107AD8h case   32:*/		return 0x82107ADC;
		  /* 82107ADCh */ case   33:  		/* lwzx R5, <#[R25 + R31]> */
		/* 82107ADCh case   33:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R25 + regs.R31 + 0x00000000) );
		/* 82107ADCh case   33:*/		return 0x82107AE0;
		  /* 82107AE0h */ case   34:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 82107AE0h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 82107AE0h case   34:*/		return 0x82107AE4;
		  /* 82107AE4h */ case   35:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107AE4h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107AE4h case   35:*/		return 0x82107AE8;
		  /* 82107AE8h */ case   36:  		/* lwz R11, <#[R11 + 4]> */
		/* 82107AE8h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82107AE8h case   36:*/		return 0x82107AEC;
		  /* 82107AECh */ case   37:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107AECh case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107AECh case   37:*/		return 0x82107AF0;
		  /* 82107AF0h */ case   38:  		/* lwzx R11, <#[R11 + R23]> */
		/* 82107AF0h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R23 + 0x00000000) );
		/* 82107AF0h case   38:*/		return 0x82107AF4;
		  /* 82107AF4h */ case   39:  		/* lwz R11, <#[R11 + 4]> */
		/* 82107AF4h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82107AF4h case   39:*/		return 0x82107AF8;
		  /* 82107AF8h */ case   40:  		/* andi. R11, R11, 4128 */
		/* 82107AF8h case   40:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x1020);
		/* 82107AF8h case   40:*/		return 0x82107AFC;
		  /* 82107AFCh */ case   41:  		/* cmplwi CR0, R11, 0 */
		/* 82107AFCh case   41:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82107AFCh case   41:*/		return 0x82107B00;
		  /* 82107B00h */ case   42:  		/* bc 4, CR0_EQ, 1096 */
		/* 82107B00h case   42:*/		if ( !regs.CR[0].eq ) { return 0x82107F48;  }
		/* 82107B00h case   42:*/		return 0x82107B04;
		  /* 82107B04h */ case   43:  		/* li R4, 0 */
		/* 82107B04h case   43:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82107B04h case   43:*/		return 0x82107B08;
		  /* 82107B08h */ case   44:  		/* cmplwi CR6, R27, 0 */
		/* 82107B08h case   44:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82107B08h case   44:*/		return 0x82107B0C;
		  /* 82107B0Ch */ case   45:  		/* bc 12, CR6_EQ, 1084 */
		/* 82107B0Ch case   45:*/		if ( regs.CR[6].eq ) { return 0x82107F48;  }
		/* 82107B0Ch case   45:*/		return 0x82107B10;
		  /* 82107B10h */ case   46:  		/* li R3, 0 */
		/* 82107B10h case   46:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82107B10h case   46:*/		return 0x82107B14;
		  /* 82107B14h */ case   47:  		/* mr R29, R19 */
		/* 82107B14h case   47:*/		regs.R29 = regs.R19;
		/* 82107B14h case   47:*/		return 0x82107B18;
		  /* 82107B18h */ case   48:  		/* lwzx R11, <#[R25 + R3]> */
		/* 82107B18h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + regs.R3 + 0x00000000) );
		/* 82107B18h case   48:*/		return 0x82107B1C;
		  /* 82107B1Ch */ case   49:  		/* cmpwi CR6, R11, -1 */
		/* 82107B1Ch case   49:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107B1Ch case   49:*/		return 0x82107B20;
		  /* 82107B20h */ case   50:  		/* bc 12, CR6_EQ, 1012 */
		/* 82107B20h case   50:*/		if ( regs.CR[6].eq ) { return 0x82107F14;  }
		/* 82107B20h case   50:*/		return 0x82107B24;
		  /* 82107B24h */ case   51:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107B24h case   51:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107B24h case   51:*/		return 0x82107B28;
		  /* 82107B28h */ case   52:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107B28h case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107B28h case   52:*/		return 0x82107B2C;
		  /* 82107B2Ch */ case   53:  		/* lwz R11, <#[R11 + 4]> */
		/* 82107B2Ch case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82107B2Ch case   53:*/		return 0x82107B30;
		  /* 82107B30h */ case   54:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107B30h case   54:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107B30h case   54:*/		return 0x82107B34;
		  /* 82107B34h */ case   55:  		/* lwzx R11, <#[R11 + R23]> */
		/* 82107B34h case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R23 + 0x00000000) );
		/* 82107B34h case   55:*/		return 0x82107B38;
		  /* 82107B38h */ case   56:  		/* lwz R11, <#[R11 + 4]> */
		/* 82107B38h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82107B38h case   56:*/		return 0x82107B3C;
		  /* 82107B3Ch */ case   57:  		/* andi. R11, R11, 4128 */
		/* 82107B3Ch case   57:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x1020);
		/* 82107B3Ch case   57:*/		return 0x82107B40;
		  /* 82107B40h */ case   58:  		/* cmplwi CR0, R11, 0 */
		/* 82107B40h case   58:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82107B40h case   58:*/		return 0x82107B44;
		  /* 82107B44h */ case   59:  		/* bc 4, CR0_EQ, 976 */
		/* 82107B44h case   59:*/		if ( !regs.CR[0].eq ) { return 0x82107F14;  }
		/* 82107B44h case   59:*/		return 0x82107B48;
		  /* 82107B48h */ case   60:  		/* cmplwi CR6, R20, 1 */
		/* 82107B48h case   60:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000001);
		/* 82107B48h case   60:*/		return 0x82107B4C;
		  /* 82107B4Ch */ case   61:  		/* bc 4, CR6_EQ, 80 */
		/* 82107B4Ch case   61:*/		if ( !regs.CR[6].eq ) { return 0x82107B9C;  }
		/* 82107B4Ch case   61:*/		return 0x82107B50;
		  /* 82107B50h */ case   62:  		/* lwz R10, <#[R30 + 8]> */
		/* 82107B50h case   62:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82107B50h case   62:*/		return 0x82107B54;
		  /* 82107B54h */ case   63:  		/* lwzx R11, <#[R31 + R10]> */
		/* 82107B54h case   63:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 82107B54h case   63:*/		return 0x82107B58;
		  /* 82107B58h */ case   64:  		/* cmpwi CR6, R11, -1 */
		/* 82107B58h case   64:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107B58h case   64:*/		return 0x82107B5C;
		  /* 82107B5Ch */ case   65:  		/* bc 12, CR6_EQ, 20 */
		/* 82107B5Ch case   65:*/		if ( regs.CR[6].eq ) { return 0x82107B70;  }
		/* 82107B5Ch case   65:*/		return 0x82107B60;
		  /* 82107B60h */ case   66:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107B60h case   66:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107B60h case   66:*/		return 0x82107B64;
		  /* 82107B64h */ case   67:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107B64h case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107B64h case   67:*/		return 0x82107B68;
		  /* 82107B68h */ case   68:  		/* lwz R9, <#[R11 + 48]> */
		/* 82107B68h case   68:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 82107B68h case   68:*/		return 0x82107B6C;
		  /* 82107B6Ch */ case   69:  		/* b 8 */
		/* 82107B6Ch case   69:*/		return 0x82107B74;
		/* 82107B6Ch case   69:*/		return 0x82107B70;
	}
	return 0x82107B70;
} // Block from 82107A58h-82107B70h (70 instructions)

//////////////////////////////////////////////////////
// Block at 82107B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107B70);
		  /* 82107B70h */ case    0:  		/* mr R9, R26 */
		/* 82107B70h case    0:*/		regs.R9 = regs.R26;
		/* 82107B70h case    0:*/		return 0x82107B74;
	}
	return 0x82107B74;
} // Block from 82107B70h-82107B74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107B74);
		  /* 82107B74h */ case    0:  		/* lwzx R11, <#[R3 + R10]> */
		/* 82107B74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 82107B74h case    0:*/		return 0x82107B78;
		  /* 82107B78h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 82107B78h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107B78h case    1:*/		return 0x82107B7C;
		  /* 82107B7Ch */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82107B7Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82107B90;  }
		/* 82107B7Ch case    2:*/		return 0x82107B80;
		  /* 82107B80h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107B80h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107B80h case    3:*/		return 0x82107B84;
		  /* 82107B84h */ case    4:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107B84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107B84h case    4:*/		return 0x82107B88;
		  /* 82107B88h */ case    5:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107B88h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107B88h case    5:*/		return 0x82107B8C;
		  /* 82107B8Ch */ case    6:  		/* b 8 */
		/* 82107B8Ch case    6:*/		return 0x82107B94;
		/* 82107B8Ch case    6:*/		return 0x82107B90;
	}
	return 0x82107B90;
} // Block from 82107B74h-82107B90h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82107B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107B90);
		  /* 82107B90h */ case    0:  		/* mr R11, R26 */
		/* 82107B90h case    0:*/		regs.R11 = regs.R26;
		/* 82107B90h case    0:*/		return 0x82107B94;
	}
	return 0x82107B94;
} // Block from 82107B90h-82107B94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107B94);
		  /* 82107B94h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82107B94h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82107B94h case    0:*/		return 0x82107B98;
		  /* 82107B98h */ case    1:  		/* bc 12, CR6_EQ, 916 */
		/* 82107B98h case    1:*/		if ( regs.CR[6].eq ) { return 0x82107F2C;  }
		/* 82107B98h case    1:*/		return 0x82107B9C;
	}
	return 0x82107B9C;
} // Block from 82107B94h-82107B9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82107B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107B9C);
		  /* 82107B9Ch */ case    0:  		/* cmplwi CR6, R20, 2 */
		/* 82107B9Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000002);
		/* 82107B9Ch case    0:*/		return 0x82107BA0;
		  /* 82107BA0h */ case    1:  		/* bc 4, CR6_EQ, 296 */
		/* 82107BA0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82107CC8;  }
		/* 82107BA0h case    1:*/		return 0x82107BA4;
		  /* 82107BA4h */ case    2:  		/* lwz R9, <#[R30 + 8]> */
		/* 82107BA4h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 82107BA4h case    2:*/		return 0x82107BA8;
		  /* 82107BA8h */ case    3:  		/* lwzx R8, <#[R31 + R9]> */
		/* 82107BA8h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + regs.R9 + 0x00000000) );
		/* 82107BA8h case    3:*/		return 0x82107BAC;
		  /* 82107BACh */ case    4:  		/* cmpwi CR6, R8, -1 */
		/* 82107BACh case    4:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 82107BACh case    4:*/		return 0x82107BB0;
		  /* 82107BB0h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82107BB0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82107BC4;  }
		/* 82107BB0h case    5:*/		return 0x82107BB4;
		  /* 82107BB4h */ case    6:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 82107BB4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 82107BB4h case    6:*/		return 0x82107BB8;
		  /* 82107BB8h */ case    7:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107BB8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107BB8h case    7:*/		return 0x82107BBC;
		  /* 82107BBCh */ case    8:  		/* lwz R10, <#[R11 + 48]> */
		/* 82107BBCh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82107BBCh case    8:*/		return 0x82107BC0;
		  /* 82107BC0h */ case    9:  		/* b 8 */
		/* 82107BC0h case    9:*/		return 0x82107BC8;
		/* 82107BC0h case    9:*/		return 0x82107BC4;
	}
	return 0x82107BC4;
} // Block from 82107B9Ch-82107BC4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82107BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107BC4);
		  /* 82107BC4h */ case    0:  		/* mr R10, R26 */
		/* 82107BC4h case    0:*/		regs.R10 = regs.R26;
		/* 82107BC4h case    0:*/		return 0x82107BC8;
	}
	return 0x82107BC8;
} // Block from 82107BC4h-82107BC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107BC8);
		  /* 82107BC8h */ case    0:  		/* lwzx R7, <#[R3 + R9]> */
		/* 82107BC8h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + regs.R9 + 0x00000000) );
		/* 82107BC8h case    0:*/		return 0x82107BCC;
		  /* 82107BCCh */ case    1:  		/* cmpwi CR6, R7, -1 */
		/* 82107BCCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 82107BCCh case    1:*/		return 0x82107BD0;
	}
	return 0x82107BD0;
} // Block from 82107BC8h-82107BD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82107BD0h
// Function '?RemoveDeadCode@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107BD0);
		  /* 82107BD0h */ case    0:  		/* bc 12, CR6_EQ, 20 */
		/* 82107BD0h case    0:*/		if ( regs.CR[6].eq ) { return 0x82107BE4;  }
		/* 82107BD0h case    0:*/		return 0x82107BD4;
		  /* 82107BD4h */ case    1:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 82107BD4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 82107BD4h case    1:*/		return 0x82107BD8;
		  /* 82107BD8h */ case    2:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107BD8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107BD8h case    2:*/		return 0x82107BDC;
		  /* 82107BDCh */ case    3:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107BDCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107BDCh case    3:*/		return 0x82107BE0;
		  /* 82107BE0h */ case    4:  		/* b 8 */
		/* 82107BE0h case    4:*/		return 0x82107BE8;
		/* 82107BE0h case    4:*/		return 0x82107BE4;
	}
	return 0x82107BE4;
} // Block from 82107BD0h-82107BE4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82107BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107BE4);
		  /* 82107BE4h */ case    0:  		/* mr R11, R26 */
		/* 82107BE4h case    0:*/		regs.R11 = regs.R26;
		/* 82107BE4h case    0:*/		return 0x82107BE8;
	}
	return 0x82107BE8;
} // Block from 82107BE4h-82107BE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107BE8);
		  /* 82107BE8h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82107BE8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82107BE8h case    0:*/		return 0x82107BEC;
		  /* 82107BECh */ case    1:  		/* bc 4, CR6_EQ, 76 */
		/* 82107BECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82107C38;  }
		/* 82107BECh case    1:*/		return 0x82107BF0;
		  /* 82107BF0h */ case    2:  		/* lwzx R11, <#[R24 + R9]> */
		/* 82107BF0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + regs.R9 + 0x00000000) );
		/* 82107BF0h case    2:*/		return 0x82107BF4;
		  /* 82107BF4h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82107BF4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107BF4h case    3:*/		return 0x82107BF8;
		  /* 82107BF8h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82107BF8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82107C0C;  }
		/* 82107BF8h case    4:*/		return 0x82107BFC;
		  /* 82107BFCh */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107BFCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107BFCh case    5:*/		return 0x82107C00;
		  /* 82107C00h */ case    6:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107C00h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107C00h case    6:*/		return 0x82107C04;
		  /* 82107C04h */ case    7:  		/* lwz R10, <#[R11 + 48]> */
		/* 82107C04h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82107C04h case    7:*/		return 0x82107C08;
		  /* 82107C08h */ case    8:  		/* b 8 */
		/* 82107C08h case    8:*/		return 0x82107C10;
		/* 82107C08h case    8:*/		return 0x82107C0C;
	}
	return 0x82107C0C;
} // Block from 82107BE8h-82107C0Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82107C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107C0C);
		  /* 82107C0Ch */ case    0:  		/* mr R10, R26 */
		/* 82107C0Ch case    0:*/		regs.R10 = regs.R26;
		/* 82107C0Ch case    0:*/		return 0x82107C10;
	}
	return 0x82107C10;
} // Block from 82107C0Ch-82107C10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107C10);
		  /* 82107C10h */ case    0:  		/* lwzx R11, <#[R29 + R9]> */
		/* 82107C10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R9 + 0x00000000) );
		/* 82107C10h case    0:*/		return 0x82107C14;
		  /* 82107C14h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 82107C14h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107C14h case    1:*/		return 0x82107C18;
		  /* 82107C18h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82107C18h case    2:*/		if ( regs.CR[6].eq ) { return 0x82107C2C;  }
		/* 82107C18h case    2:*/		return 0x82107C1C;
		  /* 82107C1Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107C1Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107C1Ch case    3:*/		return 0x82107C20;
		  /* 82107C20h */ case    4:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107C20h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107C20h case    4:*/		return 0x82107C24;
		  /* 82107C24h */ case    5:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107C24h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107C24h case    5:*/		return 0x82107C28;
		  /* 82107C28h */ case    6:  		/* b 8 */
		/* 82107C28h case    6:*/		return 0x82107C30;
		/* 82107C28h case    6:*/		return 0x82107C2C;
	}
	return 0x82107C2C;
} // Block from 82107C10h-82107C2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82107C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107C2C);
		  /* 82107C2Ch */ case    0:  		/* mr R11, R26 */
		/* 82107C2Ch case    0:*/		regs.R11 = regs.R26;
		/* 82107C2Ch case    0:*/		return 0x82107C30;
	}
	return 0x82107C30;
} // Block from 82107C2Ch-82107C30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107C30);
		  /* 82107C30h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82107C30h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82107C30h case    0:*/		return 0x82107C34;
		  /* 82107C34h */ case    1:  		/* bc 12, CR6_EQ, 760 */
		/* 82107C34h case    1:*/		if ( regs.CR[6].eq ) { return 0x82107F2C;  }
		/* 82107C34h case    1:*/		return 0x82107C38;
	}
	return 0x82107C38;
} // Block from 82107C30h-82107C38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82107C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107C38);
		  /* 82107C38h */ case    0:  		/* cmpwi CR6, R21, 0 */
		/* 82107C38h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 82107C38h case    0:*/		return 0x82107C3C;
		  /* 82107C3Ch */ case    1:  		/* bc 12, CR6_EQ, 728 */
		/* 82107C3Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82107F14;  }
		/* 82107C3Ch case    1:*/		return 0x82107C40;
		  /* 82107C40h */ case    2:  		/* cmpwi CR6, R8, -1 */
		/* 82107C40h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 82107C40h case    2:*/		return 0x82107C44;
		  /* 82107C44h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 82107C44h case    3:*/		if ( regs.CR[6].eq ) { return 0x82107C58;  }
		/* 82107C44h case    3:*/		return 0x82107C48;
		  /* 82107C48h */ case    4:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 82107C48h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 82107C48h case    4:*/		return 0x82107C4C;
		  /* 82107C4Ch */ case    5:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107C4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107C4Ch case    5:*/		return 0x82107C50;
		  /* 82107C50h */ case    6:  		/* lwz R10, <#[R11 + 48]> */
		/* 82107C50h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82107C50h case    6:*/		return 0x82107C54;
		  /* 82107C54h */ case    7:  		/* b 8 */
		/* 82107C54h case    7:*/		return 0x82107C5C;
		/* 82107C54h case    7:*/		return 0x82107C58;
	}
	return 0x82107C58;
} // Block from 82107C38h-82107C58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82107C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107C58);
		  /* 82107C58h */ case    0:  		/* mr R10, R26 */
		/* 82107C58h case    0:*/		regs.R10 = regs.R26;
		/* 82107C58h case    0:*/		return 0x82107C5C;
	}
	return 0x82107C5C;
} // Block from 82107C58h-82107C5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107C5C);
		  /* 82107C5Ch */ case    0:  		/* lwzx R11, <#[R29 + R9]> */
		/* 82107C5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R9 + 0x00000000) );
		/* 82107C5Ch case    0:*/		return 0x82107C60;
		  /* 82107C60h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 82107C60h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107C60h case    1:*/		return 0x82107C64;
		  /* 82107C64h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82107C64h case    2:*/		if ( regs.CR[6].eq ) { return 0x82107C78;  }
		/* 82107C64h case    2:*/		return 0x82107C68;
		  /* 82107C68h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107C68h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107C68h case    3:*/		return 0x82107C6C;
		  /* 82107C6Ch */ case    4:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107C6Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107C6Ch case    4:*/		return 0x82107C70;
		  /* 82107C70h */ case    5:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107C70h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107C70h case    5:*/		return 0x82107C74;
		  /* 82107C74h */ case    6:  		/* b 8 */
		/* 82107C74h case    6:*/		return 0x82107C7C;
		/* 82107C74h case    6:*/		return 0x82107C78;
	}
	return 0x82107C78;
} // Block from 82107C5Ch-82107C78h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82107C78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107C78);
		  /* 82107C78h */ case    0:  		/* mr R11, R26 */
		/* 82107C78h case    0:*/		regs.R11 = regs.R26;
		/* 82107C78h case    0:*/		return 0x82107C7C;
	}
	return 0x82107C7C;
} // Block from 82107C78h-82107C7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107C7C);
		  /* 82107C7Ch */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82107C7Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82107C7Ch case    0:*/		return 0x82107C80;
		  /* 82107C80h */ case    1:  		/* bc 4, CR6_EQ, 660 */
		/* 82107C80h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82107F14;  }
		/* 82107C80h case    1:*/		return 0x82107C84;
		  /* 82107C84h */ case    2:  		/* lwzx R11, <#[R24 + R9]> */
		/* 82107C84h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + regs.R9 + 0x00000000) );
		/* 82107C84h case    2:*/		return 0x82107C88;
		  /* 82107C88h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82107C88h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107C88h case    3:*/		return 0x82107C8C;
		  /* 82107C8Ch */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82107C8Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82107CA0;  }
		/* 82107C8Ch case    4:*/		return 0x82107C90;
		  /* 82107C90h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107C90h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107C90h case    5:*/		return 0x82107C94;
		  /* 82107C94h */ case    6:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107C94h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107C94h case    6:*/		return 0x82107C98;
		  /* 82107C98h */ case    7:  		/* lwz R10, <#[R11 + 48]> */
		/* 82107C98h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82107C98h case    7:*/		return 0x82107C9C;
		  /* 82107C9Ch */ case    8:  		/* b 8 */
		/* 82107C9Ch case    8:*/		return 0x82107CA4;
		/* 82107C9Ch case    8:*/		return 0x82107CA0;
	}
	return 0x82107CA0;
} // Block from 82107C7Ch-82107CA0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82107CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107CA0);
		  /* 82107CA0h */ case    0:  		/* mr R10, R26 */
		/* 82107CA0h case    0:*/		regs.R10 = regs.R26;
		/* 82107CA0h case    0:*/		return 0x82107CA4;
	}
	return 0x82107CA4;
} // Block from 82107CA0h-82107CA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107CA4);
		  /* 82107CA4h */ case    0:  		/* cmpwi CR6, R7, -1 */
		/* 82107CA4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 82107CA4h case    0:*/		return 0x82107CA8;
		  /* 82107CA8h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82107CA8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82107CBC;  }
		/* 82107CA8h case    1:*/		return 0x82107CAC;
		  /* 82107CACh */ case    2:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 82107CACh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 82107CACh case    2:*/		return 0x82107CB0;
		  /* 82107CB0h */ case    3:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107CB0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107CB0h case    3:*/		return 0x82107CB4;
		  /* 82107CB4h */ case    4:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107CB4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107CB4h case    4:*/		return 0x82107CB8;
		  /* 82107CB8h */ case    5:  		/* b 8 */
		/* 82107CB8h case    5:*/		return 0x82107CC0;
		/* 82107CB8h case    5:*/		return 0x82107CBC;
	}
	return 0x82107CBC;
} // Block from 82107CA4h-82107CBCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82107CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107CBC);
		  /* 82107CBCh */ case    0:  		/* mr R11, R26 */
		/* 82107CBCh case    0:*/		regs.R11 = regs.R26;
		/* 82107CBCh case    0:*/		return 0x82107CC0;
	}
	return 0x82107CC0;
} // Block from 82107CBCh-82107CC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107CC0);
		  /* 82107CC0h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82107CC0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82107CC0h case    0:*/		return 0x82107CC4;
		  /* 82107CC4h */ case    1:  		/* bc 12, CR6_EQ, 616 */
		/* 82107CC4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82107F2C;  }
		/* 82107CC4h case    1:*/		return 0x82107CC8;
	}
	return 0x82107CC8;
} // Block from 82107CC0h-82107CC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82107CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107CC8);
		  /* 82107CC8h */ case    0:  		/* cmplwi CR6, R20, 3 */
		/* 82107CC8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000003);
		/* 82107CC8h case    0:*/		return 0x82107CCC;
		  /* 82107CCCh */ case    1:  		/* bc 4, CR6_EQ, 244 */
		/* 82107CCCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82107DC0;  }
		/* 82107CCCh case    1:*/		return 0x82107CD0;
		  /* 82107CD0h */ case    2:  		/* lwz R8, <#[R30 + 8]> */
		/* 82107CD0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000008) );
		/* 82107CD0h case    2:*/		return 0x82107CD4;
		  /* 82107CD4h */ case    3:  		/* lwzx R11, <#[R31 + R8]> */
		/* 82107CD4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R8 + 0x00000000) );
		/* 82107CD4h case    3:*/		return 0x82107CD8;
		  /* 82107CD8h */ case    4:  		/* cmpwi CR6, R11, -1 */
		/* 82107CD8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107CD8h case    4:*/		return 0x82107CDC;
		  /* 82107CDCh */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82107CDCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82107CF0;  }
		/* 82107CDCh case    5:*/		return 0x82107CE0;
		  /* 82107CE0h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107CE0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107CE0h case    6:*/		return 0x82107CE4;
		  /* 82107CE4h */ case    7:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107CE4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107CE4h case    7:*/		return 0x82107CE8;
		  /* 82107CE8h */ case    8:  		/* lwz R10, <#[R11 + 48]> */
		/* 82107CE8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82107CE8h case    8:*/		return 0x82107CEC;
		  /* 82107CECh */ case    9:  		/* b 8 */
		/* 82107CECh case    9:*/		return 0x82107CF4;
		/* 82107CECh case    9:*/		return 0x82107CF0;
	}
	return 0x82107CF0;
} // Block from 82107CC8h-82107CF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82107CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107CF0);
		  /* 82107CF0h */ case    0:  		/* mr R10, R26 */
		/* 82107CF0h case    0:*/		regs.R10 = regs.R26;
		/* 82107CF0h case    0:*/		return 0x82107CF4;
	}
	return 0x82107CF4;
} // Block from 82107CF0h-82107CF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107CF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107CF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107CF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107CF4);
		  /* 82107CF4h */ case    0:  		/* lwzx R11, <#[R3 + R8]> */
		/* 82107CF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R8 + 0x00000000) );
		/* 82107CF4h case    0:*/		return 0x82107CF8;
		  /* 82107CF8h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 82107CF8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107CF8h case    1:*/		return 0x82107CFC;
		  /* 82107CFCh */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82107CFCh case    2:*/		if ( regs.CR[6].eq ) { return 0x82107D10;  }
		/* 82107CFCh case    2:*/		return 0x82107D00;
		  /* 82107D00h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107D00h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107D00h case    3:*/		return 0x82107D04;
		  /* 82107D04h */ case    4:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107D04h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107D04h case    4:*/		return 0x82107D08;
		  /* 82107D08h */ case    5:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107D08h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107D08h case    5:*/		return 0x82107D0C;
		  /* 82107D0Ch */ case    6:  		/* b 8 */
		/* 82107D0Ch case    6:*/		return 0x82107D14;
		/* 82107D0Ch case    6:*/		return 0x82107D10;
	}
	return 0x82107D10;
} // Block from 82107CF4h-82107D10h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82107D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107D10);
		  /* 82107D10h */ case    0:  		/* mr R11, R26 */
		/* 82107D10h case    0:*/		regs.R11 = regs.R26;
		/* 82107D10h case    0:*/		return 0x82107D14;
	}
	return 0x82107D14;
} // Block from 82107D10h-82107D14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107D14);
		  /* 82107D14h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82107D14h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82107D14h case    0:*/		return 0x82107D18;
		  /* 82107D18h */ case    1:  		/* bc 4, CR6_EQ, 508 */
		/* 82107D18h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82107F14;  }
		/* 82107D18h case    1:*/		return 0x82107D1C;
		  /* 82107D1Ch */ case    2:  		/* lwzx R11, <#[R24 + R8]> */
		/* 82107D1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + regs.R8 + 0x00000000) );
		/* 82107D1Ch case    2:*/		return 0x82107D20;
		  /* 82107D20h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82107D20h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107D20h case    3:*/		return 0x82107D24;
		  /* 82107D24h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82107D24h case    4:*/		if ( regs.CR[6].eq ) { return 0x82107D38;  }
		/* 82107D24h case    4:*/		return 0x82107D28;
		  /* 82107D28h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107D28h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107D28h case    5:*/		return 0x82107D2C;
		  /* 82107D2Ch */ case    6:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107D2Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107D2Ch case    6:*/		return 0x82107D30;
		  /* 82107D30h */ case    7:  		/* lwz R10, <#[R11 + 48]> */
		/* 82107D30h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82107D30h case    7:*/		return 0x82107D34;
		  /* 82107D34h */ case    8:  		/* b 8 */
		/* 82107D34h case    8:*/		return 0x82107D3C;
		/* 82107D34h case    8:*/		return 0x82107D38;
	}
	return 0x82107D38;
} // Block from 82107D14h-82107D38h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82107D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107D38);
		  /* 82107D38h */ case    0:  		/* mr R10, R26 */
		/* 82107D38h case    0:*/		regs.R10 = regs.R26;
		/* 82107D38h case    0:*/		return 0x82107D3C;
	}
	return 0x82107D3C;
} // Block from 82107D38h-82107D3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107D3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107D3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107D3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107D3C);
		  /* 82107D3Ch */ case    0:  		/* lwzx R11, <#[R29 + R8]> */
		/* 82107D3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R8 + 0x00000000) );
		/* 82107D3Ch case    0:*/		return 0x82107D40;
		  /* 82107D40h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 82107D40h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107D40h case    1:*/		return 0x82107D44;
		  /* 82107D44h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82107D44h case    2:*/		if ( regs.CR[6].eq ) { return 0x82107D58;  }
		/* 82107D44h case    2:*/		return 0x82107D48;
		  /* 82107D48h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107D48h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107D48h case    3:*/		return 0x82107D4C;
		  /* 82107D4Ch */ case    4:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107D4Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107D4Ch case    4:*/		return 0x82107D50;
		  /* 82107D50h */ case    5:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107D50h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107D50h case    5:*/		return 0x82107D54;
		  /* 82107D54h */ case    6:  		/* b 8 */
		/* 82107D54h case    6:*/		return 0x82107D5C;
		/* 82107D54h case    6:*/		return 0x82107D58;
	}
	return 0x82107D58;
} // Block from 82107D3Ch-82107D58h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82107D58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107D58);
		  /* 82107D58h */ case    0:  		/* mr R11, R26 */
		/* 82107D58h case    0:*/		regs.R11 = regs.R26;
		/* 82107D58h case    0:*/		return 0x82107D5C;
	}
	return 0x82107D5C;
} // Block from 82107D58h-82107D5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107D5C);
		  /* 82107D5Ch */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82107D5Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82107D5Ch case    0:*/		return 0x82107D60;
		  /* 82107D60h */ case    1:  		/* bc 4, CR6_EQ, 436 */
		/* 82107D60h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82107F14;  }
		/* 82107D60h case    1:*/		return 0x82107D64;
		  /* 82107D64h */ case    2:  		/* rlwinm R10, R28, 1, 0, 30 */
		/* 82107D64h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R28);
		/* 82107D64h case    2:*/		return 0x82107D68;
		  /* 82107D68h */ case    3:  		/* add R11, R10, R27 */
		/* 82107D68h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R27);
		/* 82107D68h case    3:*/		return 0x82107D6C;
		  /* 82107D6Ch */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107D6Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107D6Ch case    4:*/		return 0x82107D70;
		  /* 82107D70h */ case    5:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82107D70h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82107D70h case    5:*/		return 0x82107D74;
		  /* 82107D74h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 82107D74h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107D74h case    6:*/		return 0x82107D78;
		  /* 82107D78h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82107D78h case    7:*/		if ( regs.CR[6].eq ) { return 0x82107D8C;  }
		/* 82107D78h case    7:*/		return 0x82107D7C;
		  /* 82107D7Ch */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107D7Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107D7Ch case    8:*/		return 0x82107D80;
		  /* 82107D80h */ case    9:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107D80h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107D80h case    9:*/		return 0x82107D84;
		  /* 82107D84h */ case   10:  		/* lwz R9, <#[R11 + 48]> */
		/* 82107D84h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 82107D84h case   10:*/		return 0x82107D88;
		  /* 82107D88h */ case   11:  		/* b 8 */
		/* 82107D88h case   11:*/		return 0x82107D90;
		/* 82107D88h case   11:*/		return 0x82107D8C;
	}
	return 0x82107D8C;
} // Block from 82107D5Ch-82107D8Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 82107D8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107D8C);
		  /* 82107D8Ch */ case    0:  		/* mr R9, R26 */
		/* 82107D8Ch case    0:*/		regs.R9 = regs.R26;
		/* 82107D8Ch case    0:*/		return 0x82107D90;
	}
	return 0x82107D90;
} // Block from 82107D8Ch-82107D90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107D90);
		  /* 82107D90h */ case    0:  		/* add R11, R10, R4 */
		/* 82107D90h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R4);
		/* 82107D90h case    0:*/		return 0x82107D94;
		  /* 82107D94h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107D94h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107D94h case    1:*/		return 0x82107D98;
		  /* 82107D98h */ case    2:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82107D98h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82107D98h case    2:*/		return 0x82107D9C;
		  /* 82107D9Ch */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82107D9Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107D9Ch case    3:*/		return 0x82107DA0;
		  /* 82107DA0h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82107DA0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82107DB4;  }
		/* 82107DA0h case    4:*/		return 0x82107DA4;
		  /* 82107DA4h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107DA4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107DA4h case    5:*/		return 0x82107DA8;
		  /* 82107DA8h */ case    6:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107DA8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107DA8h case    6:*/		return 0x82107DAC;
		  /* 82107DACh */ case    7:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107DACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107DACh case    7:*/		return 0x82107DB0;
		  /* 82107DB0h */ case    8:  		/* b 8 */
		/* 82107DB0h case    8:*/		return 0x82107DB8;
		/* 82107DB0h case    8:*/		return 0x82107DB4;
	}
	return 0x82107DB4;
} // Block from 82107D90h-82107DB4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82107DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107DB4);
		  /* 82107DB4h */ case    0:  		/* mr R11, R26 */
		/* 82107DB4h case    0:*/		regs.R11 = regs.R26;
		/* 82107DB4h case    0:*/		return 0x82107DB8;
	}
	return 0x82107DB8;
} // Block from 82107DB4h-82107DB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107DB8);
		  /* 82107DB8h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82107DB8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82107DB8h case    0:*/		return 0x82107DBC;
		  /* 82107DBCh */ case    1:  		/* bc 12, CR6_EQ, 368 */
		/* 82107DBCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82107F2C;  }
		/* 82107DBCh case    1:*/		return 0x82107DC0;
	}
	return 0x82107DC0;
} // Block from 82107DB8h-82107DC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82107DC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107DC0);
		  /* 82107DC0h */ case    0:  		/* cmplwi CR6, R20, 4 */
		/* 82107DC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000004);
		/* 82107DC0h case    0:*/		return 0x82107DC4;
		  /* 82107DC4h */ case    1:  		/* bc 4, CR6_EQ, 336 */
		/* 82107DC4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82107F14;  }
		/* 82107DC4h case    1:*/		return 0x82107DC8;
		  /* 82107DC8h */ case    2:  		/* lwz R8, <#[R30 + 8]> */
		/* 82107DC8h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000008) );
		/* 82107DC8h case    2:*/		return 0x82107DCC;
		  /* 82107DCCh */ case    3:  		/* lwzx R11, <#[R31 + R8]> */
		/* 82107DCCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R8 + 0x00000000) );
		/* 82107DCCh case    3:*/		return 0x82107DD0;
		  /* 82107DD0h */ case    4:  		/* cmpwi CR6, R11, -1 */
		/* 82107DD0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107DD0h case    4:*/		return 0x82107DD4;
		  /* 82107DD4h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82107DD4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82107DE8;  }
		/* 82107DD4h case    5:*/		return 0x82107DD8;
		  /* 82107DD8h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107DD8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107DD8h case    6:*/		return 0x82107DDC;
		  /* 82107DDCh */ case    7:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107DDCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107DDCh case    7:*/		return 0x82107DE0;
		  /* 82107DE0h */ case    8:  		/* lwz R10, <#[R11 + 48]> */
		/* 82107DE0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82107DE0h case    8:*/		return 0x82107DE4;
		  /* 82107DE4h */ case    9:  		/* b 8 */
		/* 82107DE4h case    9:*/		return 0x82107DEC;
		/* 82107DE4h case    9:*/		return 0x82107DE8;
	}
	return 0x82107DE8;
} // Block from 82107DC0h-82107DE8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82107DE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107DE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107DE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107DE8);
		  /* 82107DE8h */ case    0:  		/* mr R10, R26 */
		/* 82107DE8h case    0:*/		regs.R10 = regs.R26;
		/* 82107DE8h case    0:*/		return 0x82107DEC;
	}
	return 0x82107DEC;
} // Block from 82107DE8h-82107DECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107DEC);
		  /* 82107DECh */ case    0:  		/* lwzx R11, <#[R3 + R8]> */
		/* 82107DECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R8 + 0x00000000) );
		/* 82107DECh case    0:*/		return 0x82107DF0;
		  /* 82107DF0h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 82107DF0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107DF0h case    1:*/		return 0x82107DF4;
		  /* 82107DF4h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82107DF4h case    2:*/		if ( regs.CR[6].eq ) { return 0x82107E08;  }
		/* 82107DF4h case    2:*/		return 0x82107DF8;
		  /* 82107DF8h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107DF8h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107DF8h case    3:*/		return 0x82107DFC;
		  /* 82107DFCh */ case    4:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107DFCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107DFCh case    4:*/		return 0x82107E00;
		  /* 82107E00h */ case    5:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107E00h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107E00h case    5:*/		return 0x82107E04;
		  /* 82107E04h */ case    6:  		/* b 8 */
		/* 82107E04h case    6:*/		return 0x82107E0C;
		/* 82107E04h case    6:*/		return 0x82107E08;
	}
	return 0x82107E08;
} // Block from 82107DECh-82107E08h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82107E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107E08);
		  /* 82107E08h */ case    0:  		/* mr R11, R26 */
		/* 82107E08h case    0:*/		regs.R11 = regs.R26;
		/* 82107E08h case    0:*/		return 0x82107E0C;
	}
	return 0x82107E0C;
} // Block from 82107E08h-82107E0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107E0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107E0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107E0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107E0C);
		  /* 82107E0Ch */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82107E0Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82107E0Ch case    0:*/		return 0x82107E10;
		  /* 82107E10h */ case    1:  		/* bc 4, CR6_EQ, 260 */
		/* 82107E10h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82107F14;  }
		/* 82107E10h case    1:*/		return 0x82107E14;
		  /* 82107E14h */ case    2:  		/* lwzx R11, <#[R24 + R8]> */
		/* 82107E14h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + regs.R8 + 0x00000000) );
		/* 82107E14h case    2:*/		return 0x82107E18;
		  /* 82107E18h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82107E18h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107E18h case    3:*/		return 0x82107E1C;
		  /* 82107E1Ch */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82107E1Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82107E30;  }
		/* 82107E1Ch case    4:*/		return 0x82107E20;
		  /* 82107E20h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107E20h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107E20h case    5:*/		return 0x82107E24;
		  /* 82107E24h */ case    6:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107E24h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107E24h case    6:*/		return 0x82107E28;
		  /* 82107E28h */ case    7:  		/* lwz R10, <#[R11 + 48]> */
		/* 82107E28h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82107E28h case    7:*/		return 0x82107E2C;
		  /* 82107E2Ch */ case    8:  		/* b 8 */
		/* 82107E2Ch case    8:*/		return 0x82107E34;
		/* 82107E2Ch case    8:*/		return 0x82107E30;
	}
	return 0x82107E30;
} // Block from 82107E0Ch-82107E30h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82107E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107E30);
		  /* 82107E30h */ case    0:  		/* mr R10, R26 */
		/* 82107E30h case    0:*/		regs.R10 = regs.R26;
		/* 82107E30h case    0:*/		return 0x82107E34;
	}
	return 0x82107E34;
} // Block from 82107E30h-82107E34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107E34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107E34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107E34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107E34);
		  /* 82107E34h */ case    0:  		/* lwzx R11, <#[R29 + R8]> */
		/* 82107E34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R8 + 0x00000000) );
		/* 82107E34h case    0:*/		return 0x82107E38;
		  /* 82107E38h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 82107E38h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107E38h case    1:*/		return 0x82107E3C;
		  /* 82107E3Ch */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82107E3Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82107E50;  }
		/* 82107E3Ch case    2:*/		return 0x82107E40;
		  /* 82107E40h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107E40h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107E40h case    3:*/		return 0x82107E44;
		  /* 82107E44h */ case    4:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107E44h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107E44h case    4:*/		return 0x82107E48;
		  /* 82107E48h */ case    5:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107E48h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107E48h case    5:*/		return 0x82107E4C;
		  /* 82107E4Ch */ case    6:  		/* b 8 */
		/* 82107E4Ch case    6:*/		return 0x82107E54;
		/* 82107E4Ch case    6:*/		return 0x82107E50;
	}
	return 0x82107E50;
} // Block from 82107E34h-82107E50h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82107E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107E50);
		  /* 82107E50h */ case    0:  		/* mr R11, R26 */
		/* 82107E50h case    0:*/		regs.R11 = regs.R26;
		/* 82107E50h case    0:*/		return 0x82107E54;
	}
	return 0x82107E54;
} // Block from 82107E50h-82107E54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107E54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107E54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107E54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107E54);
		  /* 82107E54h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82107E54h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82107E54h case    0:*/		return 0x82107E58;
		  /* 82107E58h */ case    1:  		/* bc 4, CR6_EQ, 188 */
		/* 82107E58h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82107F14;  }
		/* 82107E58h case    1:*/		return 0x82107E5C;
		  /* 82107E5Ch */ case    2:  		/* rlwinm R10, R28, 1, 0, 30 */
		/* 82107E5Ch case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R28);
		/* 82107E5Ch case    2:*/		return 0x82107E60;
		  /* 82107E60h */ case    3:  		/* add R11, R10, R27 */
		/* 82107E60h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R27);
		/* 82107E60h case    3:*/		return 0x82107E64;
		  /* 82107E64h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107E64h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107E64h case    4:*/		return 0x82107E68;
		  /* 82107E68h */ case    5:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82107E68h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82107E68h case    5:*/		return 0x82107E6C;
		  /* 82107E6Ch */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 82107E6Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107E6Ch case    6:*/		return 0x82107E70;
		  /* 82107E70h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82107E70h case    7:*/		if ( regs.CR[6].eq ) { return 0x82107E84;  }
		/* 82107E70h case    7:*/		return 0x82107E74;
		  /* 82107E74h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107E74h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107E74h case    8:*/		return 0x82107E78;
		  /* 82107E78h */ case    9:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107E78h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107E78h case    9:*/		return 0x82107E7C;
		  /* 82107E7Ch */ case   10:  		/* lwz R9, <#[R11 + 48]> */
		/* 82107E7Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 82107E7Ch case   10:*/		return 0x82107E80;
		  /* 82107E80h */ case   11:  		/* b 8 */
		/* 82107E80h case   11:*/		return 0x82107E88;
		/* 82107E80h case   11:*/		return 0x82107E84;
	}
	return 0x82107E84;
} // Block from 82107E54h-82107E84h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82107E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107E84);
		  /* 82107E84h */ case    0:  		/* mr R9, R26 */
		/* 82107E84h case    0:*/		regs.R9 = regs.R26;
		/* 82107E84h case    0:*/		return 0x82107E88;
	}
	return 0x82107E88;
} // Block from 82107E84h-82107E88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107E88);
		  /* 82107E88h */ case    0:  		/* add R11, R10, R4 */
		/* 82107E88h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R4);
		/* 82107E88h case    0:*/		return 0x82107E8C;
		  /* 82107E8Ch */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107E8Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107E8Ch case    1:*/		return 0x82107E90;
		  /* 82107E90h */ case    2:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82107E90h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82107E90h case    2:*/		return 0x82107E94;
		  /* 82107E94h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82107E94h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107E94h case    3:*/		return 0x82107E98;
		  /* 82107E98h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82107E98h case    4:*/		if ( regs.CR[6].eq ) { return 0x82107EAC;  }
		/* 82107E98h case    4:*/		return 0x82107E9C;
		  /* 82107E9Ch */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107E9Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107E9Ch case    5:*/		return 0x82107EA0;
		  /* 82107EA0h */ case    6:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107EA0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107EA0h case    6:*/		return 0x82107EA4;
		  /* 82107EA4h */ case    7:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107EA4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107EA4h case    7:*/		return 0x82107EA8;
		  /* 82107EA8h */ case    8:  		/* b 8 */
		/* 82107EA8h case    8:*/		return 0x82107EB0;
		/* 82107EA8h case    8:*/		return 0x82107EAC;
	}
	return 0x82107EAC;
} // Block from 82107E88h-82107EACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82107EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107EAC);
		  /* 82107EACh */ case    0:  		/* mr R11, R26 */
		/* 82107EACh case    0:*/		regs.R11 = regs.R26;
		/* 82107EACh case    0:*/		return 0x82107EB0;
	}
	return 0x82107EB0;
} // Block from 82107EACh-82107EB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107EB0);
		  /* 82107EB0h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82107EB0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82107EB0h case    0:*/		return 0x82107EB4;
		  /* 82107EB4h */ case    1:  		/* bc 4, CR6_EQ, 96 */
		/* 82107EB4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82107F14;  }
		/* 82107EB4h case    1:*/		return 0x82107EB8;
		  /* 82107EB8h */ case    2:  		/* mulli R10, R28, 3 */
		/* 82107EB8h case    2:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R28,0x3);
		/* 82107EB8h case    2:*/		return 0x82107EBC;
		  /* 82107EBCh */ case    3:  		/* add R11, R10, R27 */
		/* 82107EBCh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R27);
		/* 82107EBCh case    3:*/		return 0x82107EC0;
		  /* 82107EC0h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107EC0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107EC0h case    4:*/		return 0x82107EC4;
		  /* 82107EC4h */ case    5:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82107EC4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82107EC4h case    5:*/		return 0x82107EC8;
		  /* 82107EC8h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 82107EC8h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107EC8h case    6:*/		return 0x82107ECC;
		  /* 82107ECCh */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82107ECCh case    7:*/		if ( regs.CR[6].eq ) { return 0x82107EE0;  }
		/* 82107ECCh case    7:*/		return 0x82107ED0;
		  /* 82107ED0h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107ED0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107ED0h case    8:*/		return 0x82107ED4;
		  /* 82107ED4h */ case    9:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107ED4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107ED4h case    9:*/		return 0x82107ED8;
		  /* 82107ED8h */ case   10:  		/* lwz R9, <#[R11 + 48]> */
		/* 82107ED8h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 82107ED8h case   10:*/		return 0x82107EDC;
		  /* 82107EDCh */ case   11:  		/* b 8 */
		/* 82107EDCh case   11:*/		return 0x82107EE4;
		/* 82107EDCh case   11:*/		return 0x82107EE0;
	}
	return 0x82107EE0;
} // Block from 82107EB0h-82107EE0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82107EE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107EE0);
		  /* 82107EE0h */ case    0:  		/* mr R9, R26 */
		/* 82107EE0h case    0:*/		regs.R9 = regs.R26;
		/* 82107EE0h case    0:*/		return 0x82107EE4;
	}
	return 0x82107EE4;
} // Block from 82107EE0h-82107EE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107EE4);
		  /* 82107EE4h */ case    0:  		/* add R11, R10, R4 */
		/* 82107EE4h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R4);
		/* 82107EE4h case    0:*/		return 0x82107EE8;
		  /* 82107EE8h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107EE8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107EE8h case    1:*/		return 0x82107EEC;
		  /* 82107EECh */ case    2:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82107EECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82107EECh case    2:*/		return 0x82107EF0;
		  /* 82107EF0h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82107EF0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82107EF0h case    3:*/		return 0x82107EF4;
		  /* 82107EF4h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82107EF4h case    4:*/		if ( regs.CR[6].eq ) { return 0x82107F08;  }
		/* 82107EF4h case    4:*/		return 0x82107EF8;
		  /* 82107EF8h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82107EF8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82107EF8h case    5:*/		return 0x82107EFC;
		  /* 82107EFCh */ case    6:  		/* lwzx R11, <#[R11 + R6]> */
		/* 82107EFCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107EFCh case    6:*/		return 0x82107F00;
		  /* 82107F00h */ case    7:  		/* lwz R11, <#[R11 + 48]> */
		/* 82107F00h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82107F00h case    7:*/		return 0x82107F04;
		  /* 82107F04h */ case    8:  		/* b 8 */
		/* 82107F04h case    8:*/		return 0x82107F0C;
		/* 82107F04h case    8:*/		return 0x82107F08;
	}
	return 0x82107F08;
} // Block from 82107EE4h-82107F08h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82107F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107F08);
		  /* 82107F08h */ case    0:  		/* mr R11, R26 */
		/* 82107F08h case    0:*/		regs.R11 = regs.R26;
		/* 82107F08h case    0:*/		return 0x82107F0C;
	}
	return 0x82107F0C;
} // Block from 82107F08h-82107F0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107F0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107F0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107F0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107F0C);
		  /* 82107F0Ch */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82107F0Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82107F0Ch case    0:*/		return 0x82107F10;
		  /* 82107F10h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82107F10h case    1:*/		if ( regs.CR[6].eq ) { return 0x82107F2C;  }
		/* 82107F10h case    1:*/		return 0x82107F14;
	}
	return 0x82107F14;
} // Block from 82107F0Ch-82107F14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82107F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107F14);
		  /* 82107F14h */ case    0:  		/* addi R4, R4, 1 */
		/* 82107F14h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82107F14h case    0:*/		return 0x82107F18;
		  /* 82107F18h */ case    1:  		/* addi R3, R3, 4 */
		/* 82107F18h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82107F18h case    1:*/		return 0x82107F1C;
		  /* 82107F1Ch */ case    2:  		/* addi R29, R29, 4 */
		/* 82107F1Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82107F1Ch case    2:*/		return 0x82107F20;
		  /* 82107F20h */ case    3:  		/* cmplw CR6, R4, R27 */
		/* 82107F20h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R27);
		/* 82107F20h case    3:*/		return 0x82107F24;
		  /* 82107F24h */ case    4:  		/* bc 12, CR6_LT, -1036 */
		/* 82107F24h case    4:*/		if ( regs.CR[6].lt ) { return 0x82107B18;  }
		/* 82107F24h case    4:*/		return 0x82107F28;
		  /* 82107F28h */ case    5:  		/* b 32 */
		/* 82107F28h case    5:*/		return 0x82107F48;
		/* 82107F28h case    5:*/		return 0x82107F2C;
	}
	return 0x82107F2C;
} // Block from 82107F14h-82107F2Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82107F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107F2C);
		  /* 82107F2Ch */ case    0:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82107F2Ch case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82107F2Ch case    0:*/		return 0x82107F30;
		  /* 82107F30h */ case    1:  		/* mr R3, R18 */
		/* 82107F30h case    1:*/		regs.R3 = regs.R18;
		/* 82107F30h case    1:*/		return 0x82107F34;
		  /* 82107F34h */ case    2:  		/* lwzx R4, <#[R11 + R25]> */
		/* 82107F34h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 82107F34h case    2:*/		return 0x82107F38;
		  /* 82107F38h */ case    3:  		/* bl -23056 */
		/* 82107F38h case    3:*/		regs.LR = 0x82107F3C; return 0x82102528;
		/* 82107F38h case    3:*/		return 0x82107F3C;
		  /* 82107F3Ch */ case    4:  		/* lwz R11, <#[R30 + 16]> */
		/* 82107F3Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82107F3Ch case    4:*/		return 0x82107F40;
		  /* 82107F40h */ case    5:  		/* addi R22, R22, -1 */
		/* 82107F40h case    5:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0xFFFFFFFF);
		/* 82107F40h case    5:*/		return 0x82107F44;
		  /* 82107F44h */ case    6:  		/* stwx R26, <#[R11 + R31]> */
		/* 82107F44h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82107F44h case    6:*/		return 0x82107F48;
	}
	return 0x82107F48;
} // Block from 82107F2Ch-82107F48h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82107F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107F48);
		  /* 82107F48h */ case    0:  		/* addi R27, R27, 1 */
		/* 82107F48h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82107F48h case    0:*/		return 0x82107F4C;
		  /* 82107F4Ch */ case    1:  		/* addi R24, R24, 4 */
		/* 82107F4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 82107F4Ch case    1:*/		return 0x82107F50;
		  /* 82107F50h */ case    2:  		/* addi R31, R31, 4 */
		/* 82107F50h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82107F50h case    2:*/		return 0x82107F54;
		  /* 82107F54h */ case    3:  		/* cmplw CR6, R27, R28 */
		/* 82107F54h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R28);
		/* 82107F54h case    3:*/		return 0x82107F58;
		  /* 82107F58h */ case    4:  		/* bc 12, CR6_LT, -1160 */
		/* 82107F58h case    4:*/		if ( regs.CR[6].lt ) { return 0x82107AD0;  }
		/* 82107F58h case    4:*/		return 0x82107F5C;
		  /* 82107F5Ch */ case    5:  		/* cmplw CR6, R22, R28 */
		/* 82107F5Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R28);
		/* 82107F5Ch case    5:*/		return 0x82107F60;
		  /* 82107F60h */ case    6:  		/* bc 4, CR6_LT, 224 */
		/* 82107F60h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82108040;  }
		/* 82107F60h case    6:*/		return 0x82107F64;
		  /* 82107F64h */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 82107F64h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82107F64h case    7:*/		return 0x82107F68;
		  /* 82107F68h */ case    8:  		/* bc 12, CR6_EQ, 100 */
		/* 82107F68h case    8:*/		if ( regs.CR[6].eq ) { return 0x82107FCC;  }
		/* 82107F68h case    8:*/		return 0x82107F6C;
		  /* 82107F6Ch */ case    9:  		/* li R9, 0 */
		/* 82107F6Ch case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82107F6Ch case    9:*/		return 0x82107F70;
		  /* 82107F70h */ case   10:  		/* li R8, 0 */
		/* 82107F70h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82107F70h case   10:*/		return 0x82107F74;
		  /* 82107F74h */ case   11:  		/* mr R7, R28 */
		/* 82107F74h case   11:*/		regs.R7 = regs.R28;
		/* 82107F74h case   11:*/		return 0x82107F78;
		  /* 82107F78h */ case   12:  		/* lwz R11, <#[R30 + 16]> */
		/* 82107F78h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82107F78h case   12:*/		return 0x82107F7C;
		  /* 82107F7Ch */ case   13:  		/* lwzx R10, <#[R11 + R9]> */
		/* 82107F7Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82107F7Ch case   13:*/		return 0x82107F80;
		  /* 82107F80h */ case   14:  		/* cmpwi CR6, R10, -1 */
		/* 82107F80h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82107F80h case   14:*/		return 0x82107F84;
		  /* 82107F84h */ case   15:  		/* bc 12, CR6_EQ, 60 */
		/* 82107F84h case   15:*/		if ( regs.CR[6].eq ) { return 0x82107FC0;  }
		/* 82107F84h case   15:*/		return 0x82107F88;
		  /* 82107F88h */ case   16:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 82107F88h case   16:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 82107F88h case   16:*/		return 0x82107F8C;
		  /* 82107F8Ch */ case   17:  		/* cmplwi CR6, R20, 0 */
		/* 82107F8Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 82107F8Ch case   17:*/		return 0x82107F90;
		  /* 82107F90h */ case   18:  		/* stwx R10, <#[R11 + R8]> */
		/* 82107F90h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82107F90h case   18:*/		return 0x82107F94;
		  /* 82107F94h */ case   19:  		/* bc 12, CR6_EQ, 40 */
		/* 82107F94h case   19:*/		if ( regs.CR[6].eq ) { return 0x82107FBC;  }
		/* 82107F94h case   19:*/		return 0x82107F98;
		  /* 82107F98h */ case   20:  		/* mtspr CTR, R20 */
		/* 82107F98h case   20:*/		regs.CTR = regs.R20;
		/* 82107F98h case   20:*/		return 0x82107F9C;
		  /* 82107F9Ch */ case   21:  		/* mr R10, R8 */
		/* 82107F9Ch case   21:*/		regs.R10 = regs.R8;
		/* 82107F9Ch case   21:*/		return 0x82107FA0;
		  /* 82107FA0h */ case   22:  		/* mr R11, R9 */
		/* 82107FA0h case   22:*/		regs.R11 = regs.R9;
		/* 82107FA0h case   22:*/		return 0x82107FA4;
		  /* 82107FA4h */ case   23:  		/* lwz R6, <#[R30 + 8]> */
		/* 82107FA4h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000008) );
		/* 82107FA4h case   23:*/		return 0x82107FA8;
		  /* 82107FA8h */ case   24:  		/* lwzx R5, <#[R11 + R6]> */
		/* 82107FA8h case   24:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82107FA8h case   24:*/		return 0x82107FAC;
		  /* 82107FACh */ case   25:  		/* add R11, R11, R19 */
		/* 82107FACh case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R19);
		/* 82107FACh case   25:*/		return 0x82107FB0;
		  /* 82107FB0h */ case   26:  		/* stwx R5, <#[R10 + R6]> */
		/* 82107FB0h case   26:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82107FB0h case   26:*/		return 0x82107FB4;
		  /* 82107FB4h */ case   27:  		/* add R10, R10, R19 */
		/* 82107FB4h case   27:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R19);
		/* 82107FB4h case   27:*/		return 0x82107FB8;
		  /* 82107FB8h */ case   28:  		/* bc 16, CR0_LT, -20 */
		/* 82107FB8h case   28:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82107FA4;  }
		/* 82107FB8h case   28:*/		return 0x82107FBC;
	}
	return 0x82107FBC;
} // Block from 82107F48h-82107FBCh (29 instructions)

//////////////////////////////////////////////////////
// Block at 82107FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107FBC);
		  /* 82107FBCh */ case    0:  		/* addi R8, R8, 4 */
		/* 82107FBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82107FBCh case    0:*/		return 0x82107FC0;
	}
	return 0x82107FC0;
} // Block from 82107FBCh-82107FC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82107FC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107FC0);
		  /* 82107FC0h */ case    0:  		/* addic. R7, R7, -1 */
		/* 82107FC0h case    0:*/		cpu::op::addic<1>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 82107FC0h case    0:*/		return 0x82107FC4;
		  /* 82107FC4h */ case    1:  		/* addi R9, R9, 4 */
		/* 82107FC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82107FC4h case    1:*/		return 0x82107FC8;
		  /* 82107FC8h */ case    2:  		/* bc 4, CR0_EQ, -80 */
		/* 82107FC8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82107F78;  }
		/* 82107FC8h case    2:*/		return 0x82107FCC;
	}
	return 0x82107FCC;
} // Block from 82107FC0h-82107FCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82107FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82107FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82107FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82107FCC);
		  /* 82107FCCh */ case    0:  		/* cmplwi CR6, R20, 1 */
		/* 82107FCCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000001);
		/* 82107FCCh case    0:*/		return 0x82107FD0;
		  /* 82107FD0h */ case    1:  		/* bc 4, CR6_GT, 84 */
		/* 82107FD0h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82108024;  }
		/* 82107FD0h case    1:*/		return 0x82107FD4;
		  /* 82107FD4h */ case    2:  		/* mr R9, R22 */
		/* 82107FD4h case    2:*/		regs.R9 = regs.R22;
		/* 82107FD4h case    2:*/		return 0x82107FD8;
		  /* 82107FD8h */ case    3:  		/* mr R10, R28 */
		/* 82107FD8h case    3:*/		regs.R10 = regs.R28;
		/* 82107FD8h case    3:*/		return 0x82107FDC;
		  /* 82107FDCh */ case    4:  		/* addi R8, R20, -1 */
		/* 82107FDCh case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R20,0xFFFFFFFF);
		/* 82107FDCh case    4:*/		return 0x82107FE0;
		  /* 82107FE0h */ case    5:  		/* li R11, 0 */
		/* 82107FE0h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82107FE0h case    5:*/		return 0x82107FE4;
		  /* 82107FE4h */ case    6:  		/* cmplwi CR6, R22, 0 */
		/* 82107FE4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 82107FE4h case    6:*/		return 0x82107FE8;
		  /* 82107FE8h */ case    7:  		/* bc 12, CR6_EQ, 44 */
		/* 82107FE8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82108014;  }
		/* 82107FE8h case    7:*/		return 0x82107FEC;
		  /* 82107FECh */ case    8:  		/* mtspr CTR, R22 */
		/* 82107FECh case    8:*/		regs.CTR = regs.R22;
		/* 82107FECh case    8:*/		return 0x82107FF0;
		  /* 82107FF0h */ case    9:  		/* add R7, R10, R11 */
		/* 82107FF0h case    9:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 82107FF0h case    9:*/		return 0x82107FF4;
		  /* 82107FF4h */ case   10:  		/* lwz R6, <#[R30 + 8]> */
		/* 82107FF4h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000008) );
		/* 82107FF4h case   10:*/		return 0x82107FF8;
		  /* 82107FF8h */ case   11:  		/* add R5, R9, R11 */
		/* 82107FF8h case   11:*/		cpu::op::add<0>(regs,&regs.R5,regs.R9,regs.R11);
		/* 82107FF8h case   11:*/		return 0x82107FFC;
		  /* 82107FFCh */ case   12:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82107FFCh case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82107FFCh case   12:*/		return 0x82108000;
		  /* 82108000h */ case   13:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82108000h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82108000h case   13:*/		return 0x82108004;
		  /* 82108004h */ case   14:  		/* addi R11, R11, 1 */
		/* 82108004h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82108004h case   14:*/		return 0x82108008;
		  /* 82108008h */ case   15:  		/* lwzx R7, <#[R7 + R6]> */
		/* 82108008h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 82108008h case   15:*/		return 0x8210800C;
		  /* 8210800Ch */ case   16:  		/* stwx R7, <#[R5 + R6]> */
		/* 8210800Ch case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 8210800Ch case   16:*/		return 0x82108010;
		  /* 82108010h */ case   17:  		/* bc 16, CR0_LT, -32 */
		/* 82108010h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82107FF0;  }
		/* 82108010h case   17:*/		return 0x82108014;
	}
	return 0x82108014;
} // Block from 82107FCCh-82108014h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82108014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108014);
		  /* 82108014h */ case    0:  		/* addic. R8, R8, -1 */
		/* 82108014h case    0:*/		cpu::op::addic<1>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 82108014h case    0:*/		return 0x82108018;
		  /* 82108018h */ case    1:  		/* add R10, R10, R28 */
		/* 82108018h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R28);
		/* 82108018h case    1:*/		return 0x8210801C;
		  /* 8210801Ch */ case    2:  		/* add R9, R9, R22 */
		/* 8210801Ch case    2:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R22);
		/* 8210801Ch case    2:*/		return 0x82108020;
		  /* 82108020h */ case    3:  		/* bc 4, CR0_EQ, -64 */
		/* 82108020h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82107FE0;  }
		/* 82108020h case    3:*/		return 0x82108024;
	}
	return 0x82108024;
} // Block from 82108014h-82108024h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82108024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108024);
		  /* 82108024h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82108024h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82108024h case    0:*/		return 0x82108028;
		  /* 82108028h */ case    1:  		/* mullw R10, R22, R20 */
		/* 82108028h case    1:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R22,regs.R20);
		/* 82108028h case    1:*/		return 0x8210802C;
		  /* 8210802Ch */ case    2:  		/* stw R22, <#[R30 + 12]> */
		/* 8210802Ch case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210802Ch case    2:*/		return 0x82108030;
		  /* 82108030h */ case    3:  		/* stw R10, <#[R30 + 4]> */
		/* 82108030h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82108030h case    3:*/		return 0x82108034;
		  /* 82108034h */ case    4:  		/* rlwimi R11, R22, 0, 12, 31 */
		/* 82108034h case    4:*/		cpu::op::rlwimi<0,0,12,31>(regs,&regs.R11,regs.R22);
		/* 82108034h case    4:*/		return 0x82108038;
		  /* 82108038h */ case    5:  		/* li R17, 1 */
		/* 82108038h case    5:*/		cpu::op::li<0>(regs,&regs.R17,0x1);
		/* 82108038h case    5:*/		return 0x8210803C;
		  /* 8210803Ch */ case    6:  		/* stw R11, <#[R30]> */
		/* 8210803Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8210803Ch case    6:*/		return 0x82108040;
	}
	return 0x82108040;
} // Block from 82108024h-82108040h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82108040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108040);
		  /* 82108040h */ case    0:  		/* lwz R11, <#[R18 + 12]> */
		/* 82108040h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x0000000C) );
		/* 82108040h case    0:*/		return 0x82108044;
		  /* 82108044h */ case    1:  		/* addi R16, R16, 1 */
		/* 82108044h case    1:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x1);
		/* 82108044h case    1:*/		return 0x82108048;
		  /* 82108048h */ case    2:  		/* cmplw CR6, R16, R11 */
		/* 82108048h case    2:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R11);
		/* 82108048h case    2:*/		return 0x8210804C;
		  /* 8210804Ch */ case    3:  		/* bc 12, CR6_LT, -1504 */
		/* 8210804Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82107A6C;  }
		/* 8210804Ch case    3:*/		return 0x82108050;
		  /* 82108050h */ case    4:  		/* cmpwi CR6, R17, 0 */
		/* 82108050h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R17,0x00000000);
		/* 82108050h case    4:*/		return 0x82108054;
		  /* 82108054h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82108054h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82108060;  }
		/* 82108054h case    5:*/		return 0x82108058;
	}
	return 0x82108058;
} // Block from 82108040h-82108058h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82108058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108058);
		  /* 82108058h */ case    0:  		/* li R3, 1 */
		/* 82108058h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82108058h case    0:*/		return 0x8210805C;
		  /* 8210805Ch */ case    1:  		/* b 16 */
		/* 8210805Ch case    1:*/		return 0x8210806C;
		/* 8210805Ch case    1:*/		return 0x82108060;
	}
	return 0x82108060;
} // Block from 82108058h-82108060h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82108060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108060);
		  /* 82108060h */ case    0:  		/* mr R3, R18 */
		/* 82108060h case    0:*/		regs.R3 = regs.R18;
		/* 82108060h case    0:*/		return 0x82108064;
		  /* 82108064h */ case    1:  		/* bl -7236 */
		/* 82108064h case    1:*/		regs.LR = 0x82108068; return 0x82106420;
		/* 82108064h case    1:*/		return 0x82108068;
		  /* 82108068h */ case    2:  		/* li R3, 0 */
		/* 82108068h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82108068h case    2:*/		return 0x8210806C;
	}
	return 0x8210806C;
} // Block from 82108060h-8210806Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210806Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210806C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210806C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210806C);
		  /* 8210806Ch */ case    0:  		/* addi R1, R1, 224 */
		/* 8210806Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 8210806Ch case    0:*/		return 0x82108070;
		  /* 82108070h */ case    1:  		/* b -486904 */
		/* 82108070h case    1:*/		return 0x82091278;
		/* 82108070h case    1:*/		return 0x82108074;
		  /* 82108074h */ case    2:  		/* nop */
		/* 82108074h case    2:*/		cpu::op::nop();
		/* 82108074h case    2:*/		return 0x82108078;
	}
	return 0x82108078;
} // Block from 8210806Ch-82108078h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82108078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108078);
		  /* 82108078h */ case    0:  		/* mfspr R12, LR */
		/* 82108078h case    0:*/		regs.R12 = regs.LR;
		/* 82108078h case    0:*/		return 0x8210807C;
		  /* 8210807Ch */ case    1:  		/* bl -487000 */
		/* 8210807Ch case    1:*/		regs.LR = 0x82108080; return 0x82091224;
		/* 8210807Ch case    1:*/		return 0x82108080;
		  /* 82108080h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 82108080h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 82108080h case    2:*/		return 0x82108084;
		  /* 82108084h */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 82108084h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82108084h case    3:*/		return 0x82108088;
		  /* 82108088h */ case    4:  		/* mr R24, R3 */
		/* 82108088h case    4:*/		regs.R24 = regs.R3;
		/* 82108088h case    4:*/		return 0x8210808C;
		  /* 8210808Ch */ case    5:  		/* mr R31, R4 */
		/* 8210808Ch case    5:*/		regs.R31 = regs.R4;
		/* 8210808Ch case    5:*/		return 0x82108090;
		  /* 82108090h */ case    6:  		/* li R17, 0 */
		/* 82108090h case    6:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 82108090h case    6:*/		return 0x82108094;
		  /* 82108094h */ case    7:  		/* lis R4, 9345 */
		/* 82108094h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82108094h case    7:*/		return 0x82108098;
		  /* 82108098h */ case    8:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 82108098h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 82108098h case    8:*/		return 0x8210809C;
		  /* 8210809Ch */ case    9:  		/* mr R16, R17 */
		/* 8210809Ch case    9:*/		regs.R16 = regs.R17;
		/* 8210809Ch case    9:*/		return 0x821080A0;
		  /* 821080A0h */ case   10:  		/* bl -523936 */
		/* 821080A0h case   10:*/		regs.LR = 0x821080A4; return 0x82088200;
		/* 821080A0h case   10:*/		return 0x821080A4;
		  /* 821080A4h */ case   11:  		/* or. R15, R3, R3 */
		/* 821080A4h case   11:*/		cpu::op::or<1>(regs,&regs.R15,regs.R3,regs.R3);
		/* 821080A4h case   11:*/		return 0x821080A8;
		  /* 821080A8h */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 821080A8h case   12:*/		if ( !regs.CR[0].eq ) { return 0x821080B8;  }
		/* 821080A8h case   12:*/		return 0x821080AC;
		  /* 821080ACh */ case   13:  		/* lis R31, -32761 */
		/* 821080ACh case   13:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 821080ACh case   13:*/		return 0x821080B0;
		  /* 821080B0h */ case   14:  		/* ori R31, R31, 14 */
		/* 821080B0h case   14:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 821080B0h case   14:*/		return 0x821080B4;
		  /* 821080B4h */ case   15:  		/* b 1228 */
		/* 821080B4h case   15:*/		return 0x82108580;
		/* 821080B4h case   15:*/		return 0x821080B8;
	}
	return 0x821080B8;
} // Block from 82108078h-821080B8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821080B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821080B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821080B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821080B8);
		  /* 821080B8h */ case    0:  		/* lwz R11, <#[R24 + 12]> */
		/* 821080B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 821080B8h case    0:*/		return 0x821080BC;
		  /* 821080BCh */ case    1:  		/* mr R4, R17 */
		/* 821080BCh case    1:*/		regs.R4 = regs.R17;
		/* 821080BCh case    1:*/		return 0x821080C0;
		  /* 821080C0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821080C0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821080C0h case    2:*/		return 0x821080C4;
		  /* 821080C4h */ case    3:  		/* bc 4, CR6_GT, 284 */
		/* 821080C4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821081E0;  }
		/* 821080C4h case    3:*/		return 0x821080C8;
		  /* 821080C8h */ case    4:  		/* mr R5, R17 */
		/* 821080C8h case    4:*/		regs.R5 = regs.R17;
		/* 821080C8h case    4:*/		return 0x821080CC;
		  /* 821080CCh */ case    5:  		/* addi R3, R15, -4 */
		/* 821080CCh case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R15,0xFFFFFFFC);
		/* 821080CCh case    5:*/		return 0x821080D0;
		  /* 821080D0h */ case    6:  		/* lwz R11, <#[R24 + 24]> */
		/* 821080D0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000018) );
		/* 821080D0h case    6:*/		return 0x821080D4;
		  /* 821080D4h */ case    7:  		/* lwzx R10, <#[R11 + R5]> */
		/* 821080D4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 821080D4h case    7:*/		return 0x821080D8;
		  /* 821080D8h */ case    8:  		/* lwz R11, <#[R10]> */
		/* 821080D8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821080D8h case    8:*/		return 0x821080DC;
		  /* 821080DCh */ case    9:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 821080DCh case    9:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821080DCh case    9:*/		return 0x821080E0;
		  /* 821080E0h */ case   10:  		/* bc 12, CR0_EQ, 236 */
		/* 821080E0h case   10:*/		if ( regs.CR[0].eq ) { return 0x821081CC;  }
		/* 821080E0h case   10:*/		return 0x821080E4;
		  /* 821080E4h */ case   11:  		/* cmpwi CR6, R31, 0 */
		/* 821080E4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 821080E4h case   11:*/		return 0x821080E8;
		  /* 821080E8h */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 821080E8h case   12:*/		if ( regs.CR[6].eq ) { return 0x821080F8;  }
		/* 821080E8h case   12:*/		return 0x821080EC;
		  /* 821080ECh */ case   13:  		/* lwz R9, <#[R10 + 36]> */
		/* 821080ECh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000024) );
		/* 821080ECh case   13:*/		return 0x821080F0;
		  /* 821080F0h */ case   14:  		/* cmplwi CR6, R9, 0 */
		/* 821080F0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821080F0h case   14:*/		return 0x821080F4;
		  /* 821080F4h */ case   15:  		/* bc 4, CR6_EQ, 216 */
		/* 821080F4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821081CC;  }
		/* 821080F4h case   15:*/		return 0x821080F8;
	}
	return 0x821080F8;
} // Block from 821080B8h-821080F8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821080F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821080F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821080F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821080F8);
		  /* 821080F8h */ case    0:  		/* lis R9, 4336 */
		/* 821080F8h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0x10F0);
		/* 821080F8h case    0:*/		return 0x821080FC;
		  /* 821080FCh */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 821080FCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821080FCh case    1:*/		return 0x82108100;
		  /* 82108100h */ case    2:  		/* bc 12, CR6_EQ, 204 */
		/* 82108100h case    2:*/		if ( regs.CR[6].eq ) { return 0x821081CC;  }
		/* 82108100h case    2:*/		return 0x82108104;
		  /* 82108104h */ case    3:  		/* lis R9, 8304 */
		/* 82108104h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x2070);
		/* 82108104h case    3:*/		return 0x82108108;
		  /* 82108108h */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 82108108h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82108108h case    4:*/		return 0x8210810C;
		  /* 8210810Ch */ case    5:  		/* bc 12, CR6_EQ, 192 */
		/* 8210810Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821081CC;  }
		/* 8210810Ch case    5:*/		return 0x82108110;
		  /* 82108110h */ case    6:  		/* lis R9, 4368 */
		/* 82108110h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0x1110);
		/* 82108110h case    6:*/		return 0x82108114;
		  /* 82108114h */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 82108114h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82108114h case    7:*/		return 0x82108118;
		  /* 82108118h */ case    8:  		/* bc 12, CR6_EQ, 180 */
		/* 82108118h case    8:*/		if ( regs.CR[6].eq ) { return 0x821081CC;  }
		/* 82108118h case    8:*/		return 0x8210811C;
		  /* 8210811Ch */ case    9:  		/* lis R9, 4384 */
		/* 8210811Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x1120);
		/* 8210811Ch case    9:*/		return 0x82108120;
		  /* 82108120h */ case   10:  		/* cmplw CR6, R11, R9 */
		/* 82108120h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82108120h case   10:*/		return 0x82108124;
		  /* 82108124h */ case   11:  		/* bc 12, CR6_EQ, 168 */
		/* 82108124h case   11:*/		if ( regs.CR[6].eq ) { return 0x821081CC;  }
		/* 82108124h case   11:*/		return 0x82108128;
		  /* 82108128h */ case   12:  		/* lis R9, 4400 */
		/* 82108128h case   12:*/		cpu::op::lis<0>(regs,&regs.R9,0x1130);
		/* 82108128h case   12:*/		return 0x8210812C;
		  /* 8210812Ch */ case   13:  		/* cmplw CR6, R11, R9 */
		/* 8210812Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210812Ch case   13:*/		return 0x82108130;
		  /* 82108130h */ case   14:  		/* bc 12, CR6_EQ, 156 */
		/* 82108130h case   14:*/		if ( regs.CR[6].eq ) { return 0x821081CC;  }
		/* 82108130h case   14:*/		return 0x82108134;
		  /* 82108134h */ case   15:  		/* lis R9, 4416 */
		/* 82108134h case   15:*/		cpu::op::lis<0>(regs,&regs.R9,0x1140);
		/* 82108134h case   15:*/		return 0x82108138;
		  /* 82108138h */ case   16:  		/* cmplw CR6, R11, R9 */
		/* 82108138h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82108138h case   16:*/		return 0x8210813C;
		  /* 8210813Ch */ case   17:  		/* bc 12, CR6_EQ, 144 */
		/* 8210813Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x821081CC;  }
		/* 8210813Ch case   17:*/		return 0x82108140;
		  /* 82108140h */ case   18:  		/* lis R9, 8320 */
		/* 82108140h case   18:*/		cpu::op::lis<0>(regs,&regs.R9,0x2080);
		/* 82108140h case   18:*/		return 0x82108144;
		  /* 82108144h */ case   19:  		/* cmplw CR6, R11, R9 */
		/* 82108144h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82108144h case   19:*/		return 0x82108148;
		  /* 82108148h */ case   20:  		/* bc 12, CR6_EQ, 132 */
		/* 82108148h case   20:*/		if ( regs.CR[6].eq ) { return 0x821081CC;  }
		/* 82108148h case   20:*/		return 0x8210814C;
		  /* 8210814Ch */ case   21:  		/* lis R9, 8336 */
		/* 8210814Ch case   21:*/		cpu::op::lis<0>(regs,&regs.R9,0x2090);
		/* 8210814Ch case   21:*/		return 0x82108150;
		  /* 82108150h */ case   22:  		/* cmplw CR6, R11, R9 */
		/* 82108150h case   22:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82108150h case   22:*/		return 0x82108154;
		  /* 82108154h */ case   23:  		/* bc 12, CR6_EQ, 120 */
		/* 82108154h case   23:*/		if ( regs.CR[6].eq ) { return 0x821081CC;  }
		/* 82108154h case   23:*/		return 0x82108158;
		  /* 82108158h */ case   24:  		/* lis R9, 4432 */
		/* 82108158h case   24:*/		cpu::op::lis<0>(regs,&regs.R9,0x1150);
		/* 82108158h case   24:*/		return 0x8210815C;
		  /* 8210815Ch */ case   25:  		/* cmplw CR6, R11, R9 */
		/* 8210815Ch case   25:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210815Ch case   25:*/		return 0x82108160;
		  /* 82108160h */ case   26:  		/* bc 12, CR6_EQ, 108 */
		/* 82108160h case   26:*/		if ( regs.CR[6].eq ) { return 0x821081CC;  }
		/* 82108160h case   26:*/		return 0x82108164;
		  /* 82108164h */ case   27:  		/* lwz R6, <#[R10 + 12]> */
		/* 82108164h case   27:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x0000000C) );
		/* 82108164h case   27:*/		return 0x82108168;
		  /* 82108168h */ case   28:  		/* mr R7, R17 */
		/* 82108168h case   28:*/		regs.R7 = regs.R17;
		/* 82108168h case   28:*/		return 0x8210816C;
		  /* 8210816Ch */ case   29:  		/* cmplwi CR6, R6, 0 */
		/* 8210816Ch case   29:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8210816Ch case   29:*/		return 0x82108170;
		  /* 82108170h */ case   30:  		/* bc 12, CR6_EQ, 76 */
		/* 82108170h case   30:*/		if ( regs.CR[6].eq ) { return 0x821081BC;  }
		/* 82108170h case   30:*/		return 0x82108174;
		  /* 82108174h */ case   31:  		/* lwz R10, <#[R10 + 16]> */
		/* 82108174h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 82108174h case   31:*/		return 0x82108178;
		  /* 82108178h */ case   32:  		/* mr R11, R17 */
		/* 82108178h case   32:*/		regs.R11 = regs.R17;
		/* 82108178h case   32:*/		return 0x8210817C;
		  /* 8210817Ch */ case   33:  		/* lwz R9, <#[R24 + 20]> */
		/* 8210817Ch case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000014) );
		/* 8210817Ch case   33:*/		return 0x82108180;
		  /* 82108180h */ case   34:  		/* lwz R8, <#[R24 + 16]> */
		/* 82108180h case   34:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R24 + 0x00000010) );
		/* 82108180h case   34:*/		return 0x82108184;
		  /* 82108184h */ case   35:  		/* lwzx R30, <#[R11 + R10]> */
		/* 82108184h case   35:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82108184h case   35:*/		return 0x82108188;
		  /* 82108188h */ case   36:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 82108188h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 82108188h case   36:*/		return 0x8210818C;
		  /* 8210818Ch */ case   37:  		/* lwzx R30, <#[R30 + R9]> */
		/* 8210818Ch case   37:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 8210818Ch case   37:*/		return 0x82108190;
		  /* 82108190h */ case   38:  		/* lwz R30, <#[R30 + 4]> */
		/* 82108190h case   38:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 82108190h case   38:*/		return 0x82108194;
		  /* 82108194h */ case   39:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 82108194h case   39:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 82108194h case   39:*/		return 0x82108198;
		  /* 82108198h */ case   40:  		/* lwzx R30, <#[R30 + R8]> */
		/* 82108198h case   40:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + regs.R8 + 0x00000000) );
		/* 82108198h case   40:*/		return 0x8210819C;
		  /* 8210819Ch */ case   41:  		/* lwz R30, <#[R30 + 4]> */
		/* 8210819Ch case   41:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 8210819Ch case   41:*/		return 0x821081A0;
		  /* 821081A0h */ case   42:  		/* andi. R30, R30, 4128 */
		/* 821081A0h case   42:*/		cpu::op::andi<1>(regs,&regs.R30,regs.R30,0x1020);
		/* 821081A0h case   42:*/		return 0x821081A4;
		  /* 821081A4h */ case   43:  		/* cmplwi CR0, R30, 0 */
		/* 821081A4h case   43:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 821081A4h case   43:*/		return 0x821081A8;
		  /* 821081A8h */ case   44:  		/* bc 4, CR0_EQ, 20 */
		/* 821081A8h case   44:*/		if ( !regs.CR[0].eq ) { return 0x821081BC;  }
		/* 821081A8h case   44:*/		return 0x821081AC;
		  /* 821081ACh */ case   45:  		/* addi R7, R7, 1 */
		/* 821081ACh case   45:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821081ACh case   45:*/		return 0x821081B0;
		  /* 821081B0h */ case   46:  		/* addi R11, R11, 4 */
		/* 821081B0h case   46:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821081B0h case   46:*/		return 0x821081B4;
		  /* 821081B4h */ case   47:  		/* cmplw CR6, R7, R6 */
		/* 821081B4h case   47:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 821081B4h case   47:*/		return 0x821081B8;
		  /* 821081B8h */ case   48:  		/* bc 12, CR6_LT, -52 */
		/* 821081B8h case   48:*/		if ( regs.CR[6].lt ) { return 0x82108184;  }
		/* 821081B8h case   48:*/		return 0x821081BC;
	}
	return 0x821081BC;
} // Block from 821080F8h-821081BCh (49 instructions)

//////////////////////////////////////////////////////
// Block at 821081BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821081BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821081BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821081BC);
		  /* 821081BCh */ case    0:  		/* cmplw CR6, R7, R6 */
		/* 821081BCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 821081BCh case    0:*/		return 0x821081C0;
		  /* 821081C0h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 821081C0h case    1:*/		if ( regs.CR[6].lt ) { return 0x821081CC;  }
		/* 821081C0h case    1:*/		return 0x821081C4;
		  /* 821081C4h */ case    2:  		/* stwu R4, <#[R3 + 4]> */
		/* 821081C4h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 821081C4h case    2:*/		return 0x821081C8;
		  /* 821081C8h */ case    3:  		/* addi R16, R16, 1 */
		/* 821081C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x1);
		/* 821081C8h case    3:*/		return 0x821081CC;
	}
	return 0x821081CC;
} // Block from 821081BCh-821081CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821081CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821081CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821081CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821081CC);
		  /* 821081CCh */ case    0:  		/* lwz R11, <#[R24 + 12]> */
		/* 821081CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 821081CCh case    0:*/		return 0x821081D0;
		  /* 821081D0h */ case    1:  		/* addi R4, R4, 1 */
		/* 821081D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 821081D0h case    1:*/		return 0x821081D4;
		  /* 821081D4h */ case    2:  		/* addi R5, R5, 4 */
		/* 821081D4h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 821081D4h case    2:*/		return 0x821081D8;
		  /* 821081D8h */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 821081D8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 821081D8h case    3:*/		return 0x821081DC;
		  /* 821081DCh */ case    4:  		/* bc 12, CR6_LT, -268 */
		/* 821081DCh case    4:*/		if ( regs.CR[6].lt ) { return 0x821080D0;  }
		/* 821081DCh case    4:*/		return 0x821081E0;
	}
	return 0x821081E0;
} // Block from 821081CCh-821081E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821081E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821081E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821081E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821081E0);
		  /* 821081E0h */ case    0:  		/* mr R29, R17 */
		/* 821081E0h case    0:*/		regs.R29 = regs.R17;
		/* 821081E0h case    0:*/		return 0x821081E4;
		  /* 821081E4h */ case    1:  		/* lwz R10, <#[R24 + 8]> */
		/* 821081E4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000008) );
		/* 821081E4h case    1:*/		return 0x821081E8;
		  /* 821081E8h */ case    2:  		/* mr R30, R17 */
		/* 821081E8h case    2:*/		regs.R30 = regs.R17;
		/* 821081E8h case    2:*/		return 0x821081EC;
		  /* 821081ECh */ case    3:  		/* mr R11, R17 */
		/* 821081ECh case    3:*/		regs.R11 = regs.R17;
		/* 821081ECh case    3:*/		return 0x821081F0;
		  /* 821081F0h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 821081F0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821081F0h case    4:*/		return 0x821081F4;
		  /* 821081F4h */ case    5:  		/* bc 4, CR6_GT, 40 */
		/* 821081F4h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8210821C;  }
		/* 821081F4h case    5:*/		return 0x821081F8;
		  /* 821081F8h */ case    6:  		/* mr R10, R17 */
		/* 821081F8h case    6:*/		regs.R10 = regs.R17;
		/* 821081F8h case    6:*/		return 0x821081FC;
		  /* 821081FCh */ case    7:  		/* lwz R9, <#[R24 + 20]> */
		/* 821081FCh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000014) );
		/* 821081FCh case    7:*/		return 0x82108200;
		  /* 82108200h */ case    8:  		/* lwzx R9, <#[R9 + R10]> */
		/* 82108200h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82108200h case    8:*/		return 0x82108204;
		  /* 82108204h */ case    9:  		/* addi R10, R10, 4 */
		/* 82108204h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82108204h case    9:*/		return 0x82108208;
		  /* 82108208h */ case   10:  		/* stw R11, <#[R9 + 48]> */
		/* 82108208h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 82108208h case   10:*/		return 0x8210820C;
		  /* 8210820Ch */ case   11:  		/* addi R11, R11, 1 */
		/* 8210820Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210820Ch case   11:*/		return 0x82108210;
		  /* 82108210h */ case   12:  		/* lwz R9, <#[R24 + 8]> */
		/* 82108210h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 82108210h case   12:*/		return 0x82108214;
		  /* 82108214h */ case   13:  		/* cmplw CR6, R11, R9 */
		/* 82108214h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82108214h case   13:*/		return 0x82108218;
		  /* 82108218h */ case   14:  		/* bc 12, CR6_LT, -28 */
		/* 82108218h case   14:*/		if ( regs.CR[6].lt ) { return 0x821081FC;  }
		/* 82108218h case   14:*/		return 0x8210821C;
	}
	return 0x8210821C;
} // Block from 821081E0h-8210821Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8210821Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210821C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210821C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210821C);
		  /* 8210821Ch */ case    0:  		/* lis R11, -32240 */
		/* 8210821Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8210);
		/* 8210821Ch case    0:*/		return 0x82108220;
		  /* 82108220h */ case    1:  		/* mr R6, R24 */
		/* 82108220h case    1:*/		regs.R6 = regs.R24;
		/* 82108220h case    1:*/		return 0x82108224;
		  /* 82108224h */ case    2:  		/* mr R5, R16 */
		/* 82108224h case    2:*/		regs.R5 = regs.R16;
		/* 82108224h case    2:*/		return 0x82108228;
		  /* 82108228h */ case    3:  		/* mr R4, R15 */
		/* 82108228h case    3:*/		regs.R4 = regs.R15;
		/* 82108228h case    3:*/		return 0x8210822C;
		  /* 8210822Ch */ case    4:  		/* addi R3, R11, 6712 */
		/* 8210822Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1A38);
		/* 8210822Ch case    4:*/		return 0x82108230;
		  /* 82108230h */ case    5:  		/* bl -41872 */
		/* 82108230h case    5:*/		regs.LR = 0x82108234; return 0x820FDEA0;
		/* 82108230h case    5:*/		return 0x82108234;
		  /* 82108234h */ case    6:  		/* cmplwi CR6, R16, 0 */
		/* 82108234h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 82108234h case    6:*/		return 0x82108238;
		  /* 82108238h */ case    7:  		/* bc 12, CR6_EQ, 816 */
		/* 82108238h case    7:*/		if ( regs.CR[6].eq ) { return 0x82108568;  }
		/* 82108238h case    7:*/		return 0x8210823C;
		  /* 8210823Ch */ case    8:  		/* li R21, 1 */
		/* 8210823Ch case    8:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 8210823Ch case    8:*/		return 0x82108240;
		  /* 82108240h */ case    9:  		/* mr R20, R15 */
		/* 82108240h case    9:*/		regs.R20 = regs.R15;
		/* 82108240h case    9:*/		return 0x82108244;
		  /* 82108244h */ case   10:  		/* mr R18, R16 */
		/* 82108244h case   10:*/		regs.R18 = regs.R16;
		/* 82108244h case   10:*/		return 0x82108248;
		  /* 82108248h */ case   11:  		/* lwz R22, <#[R20]> */
		/* 82108248h case   11:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R20 + 0x00000000) );
		/* 82108248h case   11:*/		return 0x8210824C;
		  /* 8210824Ch */ case   12:  		/* cmpwi CR6, R22, -1 */
		/* 8210824Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R22,0xFFFFFFFF);
		/* 8210824Ch case   12:*/		return 0x82108250;
		  /* 82108250h */ case   13:  		/* bc 12, CR6_EQ, 616 */
		/* 82108250h case   13:*/		if ( regs.CR[6].eq ) { return 0x821084B8;  }
		/* 82108250h case   13:*/		return 0x82108254;
		  /* 82108254h */ case   14:  		/* mr R19, R21 */
		/* 82108254h case   14:*/		regs.R19 = regs.R21;
		/* 82108254h case   14:*/		return 0x82108258;
		  /* 82108258h */ case   15:  		/* cmplw CR6, R21, R16 */
		/* 82108258h case   15:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R16);
		/* 82108258h case   15:*/		return 0x8210825C;
		  /* 8210825Ch */ case   16:  		/* bc 4, CR6_LT, 604 */
		/* 8210825Ch case   16:*/		if ( !regs.CR[6].lt ) { return 0x821084B8;  }
		/* 8210825Ch case   16:*/		return 0x82108260;
		  /* 82108260h */ case   17:  		/* addi R23, R20, 4 */
		/* 82108260h case   17:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R20,0x4);
		/* 82108260h case   17:*/		return 0x82108264;
		  /* 82108264h */ case   18:  		/* lwz R31, <#[R23]> */
		/* 82108264h case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R23 + 0x00000000) );
		/* 82108264h case   18:*/		return 0x82108268;
		  /* 82108268h */ case   19:  		/* cmpwi CR6, R31, -1 */
		/* 82108268h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R31,0xFFFFFFFF);
		/* 82108268h case   19:*/		return 0x8210826C;
		  /* 8210826Ch */ case   20:  		/* bc 12, CR6_EQ, 572 */
		/* 8210826Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x821084A8;  }
		/* 8210826Ch case   20:*/		return 0x82108270;
		  /* 82108270h */ case   21:  		/* cmplw CR6, R22, R31 */
		/* 82108270h case   21:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R31);
		/* 82108270h case   21:*/		return 0x82108274;
		  /* 82108274h */ case   22:  		/* bc 4, CR6_LT, 580 */
		/* 82108274h case   22:*/		if ( !regs.CR[6].lt ) { return 0x821084B8;  }
		/* 82108274h case   22:*/		return 0x82108278;
		  /* 82108278h */ case   23:  		/* mr R5, R24 */
		/* 82108278h case   23:*/		regs.R5 = regs.R24;
		/* 82108278h case   23:*/		return 0x8210827C;
		  /* 8210827Ch */ case   24:  		/* mr R4, R31 */
		/* 8210827Ch case   24:*/		regs.R4 = regs.R31;
		/* 8210827Ch case   24:*/		return 0x82108280;
		  /* 82108280h */ case   25:  		/* mr R3, R22 */
		/* 82108280h case   25:*/		regs.R3 = regs.R22;
		/* 82108280h case   25:*/		return 0x82108284;
		  /* 82108284h */ case   26:  		/* bl -27828 */
		/* 82108284h case   26:*/		regs.LR = 0x82108288; return 0x821015D0;
		/* 82108284h case   26:*/		return 0x82108288;
		  /* 82108288h */ case   27:  		/* cmpwi CR0, R3, 0 */
		/* 82108288h case   27:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82108288h case   27:*/		return 0x8210828C;
		  /* 8210828Ch */ case   28:  		/* bc 4, CR0_EQ, 556 */
		/* 8210828Ch case   28:*/		if ( !regs.CR[0].eq ) { return 0x821084B8;  }
		/* 8210828Ch case   28:*/		return 0x82108290;
		  /* 82108290h */ case   29:  		/* lwz R11, <#[R24 + 24]> */
		/* 82108290h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000018) );
		/* 82108290h case   29:*/		return 0x82108294;
		  /* 82108294h */ case   30:  		/* rlwinm R10, R22, 2, 0, 29 */
		/* 82108294h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R22);
		/* 82108294h case   30:*/		return 0x82108298;
		  /* 82108298h */ case   31:  		/* rlwinm R9, R31, 2, 0, 29 */
		/* 82108298h case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R31);
		/* 82108298h case   31:*/		return 0x8210829C;
		  /* 8210829Ch */ case   32:  		/* lis R8, 4096 */
		/* 8210829Ch case   32:*/		cpu::op::lis<0>(regs,&regs.R8,0x1000);
		/* 8210829Ch case   32:*/		return 0x821082A0;
		  /* 821082A0h */ case   33:  		/* lwzx R29, <#[R10 + R11]> */
		/* 821082A0h case   33:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821082A0h case   33:*/		return 0x821082A4;
		  /* 821082A4h */ case   34:  		/* lwzx R30, <#[R9 + R11]> */
		/* 821082A4h case   34:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821082A4h case   34:*/		return 0x821082A8;
		  /* 821082A8h */ case   35:  		/* lwz R11, <#[R29]> */
		/* 821082A8h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821082A8h case   35:*/		return 0x821082AC;
		  /* 821082ACh */ case   36:  		/* lwz R10, <#[R29 + 4]> */
		/* 821082ACh case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 821082ACh case   36:*/		return 0x821082B0;
		  /* 821082B0h */ case   37:  		/* rlwinm R9, R11, 0, 12, 31 */
		/* 821082B0h case   37:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R9,regs.R11);
		/* 821082B0h case   37:*/		return 0x821082B4;
		  /* 821082B4h */ case   38:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 821082B4h case   38:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 821082B4h case   38:*/		return 0x821082B8;
		  /* 821082B8h */ case   39:  		/* divwu R26, R10, R9 */
		/* 821082B8h case   39:*/		cpu::op::divwu<0>(regs,&regs.R26,regs.R10,regs.R9);
		/* 821082B8h case   39:*/		return 0x821082BC;
		  /* 821082BCh */ case   40:  		/* twi 6, R9, 0 */
		/* 821082BCh case   40:*/		cpu::op::tw<6>(regs, 0x821082BC, regs.R9, 0x00000000);
		/* 821082BCh case   40:*/		return 0x821082C0;
		  /* 821082C0h */ case   41:  		/* cmplw CR6, R11, R8 */
		/* 821082C0h case   41:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821082C0h case   41:*/		return 0x821082C4;
		  /* 821082C4h */ case   42:  		/* bc 12, CR6_LT, 384 */
		/* 821082C4h case   42:*/		if ( regs.CR[6].lt ) { return 0x82108444;  }
		/* 821082C4h case   42:*/		return 0x821082C8;
		  /* 821082C8h */ case   43:  		/* lis R10, 16384 */
		/* 821082C8h case   43:*/		cpu::op::lis<0>(regs,&regs.R10,0x4000);
		/* 821082C8h case   43:*/		return 0x821082CC;
		  /* 821082CCh */ case   44:  		/* cmplw CR6, R11, R10 */
		/* 821082CCh case   44:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821082CCh case   44:*/		return 0x821082D0;
	}
	return 0x821082D0;
} // Block from 8210821Ch-821082D0h (45 instructions)

//////////////////////////////////////////////////////
// Block at 821082D0h
// Function '?RemoveDuplicateArguments@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821082D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821082D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821082D0);
		  /* 821082D0h */ case    0:  		/* bc 12, CR6_GT, 372 */
		/* 821082D0h case    0:*/		if ( regs.CR[6].gt ) { return 0x82108444;  }
		/* 821082D0h case    0:*/		return 0x821082D4;
		  /* 821082D4h */ case    1:  		/* lwz R11, <#[R30 + 12]> */
		/* 821082D4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 821082D4h case    1:*/		return 0x821082D8;
		  /* 821082D8h */ case    2:  		/* mr R27, R17 */
		/* 821082D8h case    2:*/		regs.R27 = regs.R17;
		/* 821082D8h case    2:*/		return 0x821082DC;
		  /* 821082DCh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821082DCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821082DCh case    3:*/		return 0x821082E0;
		  /* 821082E0h */ case    4:  		/* bc 4, CR6_GT, 428 */
		/* 821082E0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8210848C;  }
		/* 821082E0h case    4:*/		return 0x821082E4;
		  /* 821082E4h */ case    5:  		/* mr R25, R17 */
		/* 821082E4h case    5:*/		regs.R25 = regs.R17;
		/* 821082E4h case    5:*/		return 0x821082E8;
		  /* 821082E8h */ case    6:  		/* lwz R5, <#[R29 + 12]> */
		/* 821082E8h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821082E8h case    6:*/		return 0x821082EC;
		  /* 821082ECh */ case    7:  		/* mr R28, R17 */
		/* 821082ECh case    7:*/		regs.R28 = regs.R17;
		/* 821082ECh case    7:*/		return 0x821082F0;
		  /* 821082F0h */ case    8:  		/* cmplwi CR6, R5, 0 */
		/* 821082F0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821082F0h case    8:*/		return 0x821082F4;
		  /* 821082F4h */ case    9:  		/* bc 12, CR6_EQ, 312 */
		/* 821082F4h case    9:*/		if ( regs.CR[6].eq ) { return 0x8210842C;  }
		/* 821082F4h case    9:*/		return 0x821082F8;
		  /* 821082F8h */ case   10:  		/* mr R31, R17 */
		/* 821082F8h case   10:*/		regs.R31 = regs.R17;
		/* 821082F8h case   10:*/		return 0x821082FC;
		  /* 821082FCh */ case   11:  		/* cmplwi CR6, R26, 0 */
		/* 821082FCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821082FCh case   11:*/		return 0x82108300;
		  /* 82108300h */ case   12:  		/* bc 12, CR6_EQ, 96 */
		/* 82108300h case   12:*/		if ( regs.CR[6].eq ) { return 0x82108360;  }
		/* 82108300h case   12:*/		return 0x82108304;
		  /* 82108304h */ case   13:  		/* lwz R8, <#[R30 + 12]> */
		/* 82108304h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000000C) );
		/* 82108304h case   13:*/		return 0x82108308;
		  /* 82108308h */ case   14:  		/* lwz R7, <#[R30 + 8]> */
		/* 82108308h case   14:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 82108308h case   14:*/		return 0x8210830C;
		  /* 8210830Ch */ case   15:  		/* lwz R6, <#[R29 + 8]> */
		/* 8210830Ch case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000008) );
		/* 8210830Ch case   15:*/		return 0x82108310;
		  /* 82108310h */ case   16:  		/* lwz R11, <#[R24 + 20]> */
		/* 82108310h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 82108310h case   16:*/		return 0x82108314;
		  /* 82108314h */ case   17:  		/* mullw R10, R5, R31 */
		/* 82108314h case   17:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R5,regs.R31);
		/* 82108314h case   17:*/		return 0x82108318;
		  /* 82108318h */ case   18:  		/* mullw R9, R8, R31 */
		/* 82108318h case   18:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R31);
		/* 82108318h case   18:*/		return 0x8210831C;
		  /* 8210831Ch */ case   19:  		/* add R10, R10, R28 */
		/* 8210831Ch case   19:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R28);
		/* 8210831Ch case   19:*/		return 0x82108320;
		  /* 82108320h */ case   20:  		/* add R9, R9, R27 */
		/* 82108320h case   20:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R27);
		/* 82108320h case   20:*/		return 0x82108324;
		  /* 82108324h */ case   21:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82108324h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82108324h case   21:*/		return 0x82108328;
		  /* 82108328h */ case   22:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82108328h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82108328h case   22:*/		return 0x8210832C;
		  /* 8210832Ch */ case   23:  		/* lwzx R10, <#[R10 + R6]> */
		/* 8210832Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 8210832Ch case   23:*/		return 0x82108330;
		  /* 82108330h */ case   24:  		/* lwzx R9, <#[R9 + R7]> */
		/* 82108330h case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82108330h case   24:*/		return 0x82108334;
		  /* 82108334h */ case   25:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82108334h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82108334h case   25:*/		return 0x82108338;
		  /* 82108338h */ case   26:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82108338h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82108338h case   26:*/		return 0x8210833C;
		  /* 8210833Ch */ case   27:  		/* lwzx R10, <#[R10 + R11]> */
		/* 8210833Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210833Ch case   27:*/		return 0x82108340;
		  /* 82108340h */ case   28:  		/* lwzx R9, <#[R9 + R11]> */
		/* 82108340h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82108340h case   28:*/		return 0x82108344;
		  /* 82108344h */ case   29:  		/* lwz R10, <#[R10 + 48]> */
		/* 82108344h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 82108344h case   29:*/		return 0x82108348;
		  /* 82108348h */ case   30:  		/* lwz R9, <#[R9 + 48]> */
		/* 82108348h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000030) );
		/* 82108348h case   30:*/		return 0x8210834C;
		  /* 8210834Ch */ case   31:  		/* cmplw CR6, R10, R9 */
		/* 8210834Ch case   31:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210834Ch case   31:*/		return 0x82108350;
		  /* 82108350h */ case   32:  		/* bc 4, CR6_EQ, 16 */
		/* 82108350h case   32:*/		if ( !regs.CR[6].eq ) { return 0x82108360;  }
		/* 82108350h case   32:*/		return 0x82108354;
		  /* 82108354h */ case   33:  		/* addi R31, R31, 1 */
		/* 82108354h case   33:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82108354h case   33:*/		return 0x82108358;
		  /* 82108358h */ case   34:  		/* cmplw CR6, R31, R26 */
		/* 82108358h case   34:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 82108358h case   34:*/		return 0x8210835C;
		  /* 8210835Ch */ case   35:  		/* bc 12, CR6_LT, -72 */
		/* 8210835Ch case   35:*/		if ( regs.CR[6].lt ) { return 0x82108314;  }
		/* 8210835Ch case   35:*/		return 0x82108360;
	}
	return 0x82108360;
} // Block from 821082D0h-82108360h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82108360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108360);
		  /* 82108360h */ case    0:  		/* cmplw CR6, R31, R26 */
		/* 82108360h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 82108360h case    0:*/		return 0x82108364;
		  /* 82108364h */ case    1:  		/* bc 12, CR6_EQ, 164 */
		/* 82108364h case    1:*/		if ( regs.CR[6].eq ) { return 0x82108408;  }
		/* 82108364h case    1:*/		return 0x82108368;
		  /* 82108368h */ case    2:  		/* mr R3, R29 */
		/* 82108368h case    2:*/		regs.R3 = regs.R29;
		/* 82108368h case    2:*/		return 0x8210836C;
		  /* 8210836Ch */ case    3:  		/* bl -50028 */
		/* 8210836Ch case    3:*/		regs.LR = 0x82108370; return 0x820FC000;
		/* 8210836Ch case    3:*/		return 0x82108370;
		  /* 82108370h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 82108370h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82108370h case    4:*/		return 0x82108374;
		  /* 82108374h */ case    5:  		/* bc 12, CR0_EQ, 120 */
		/* 82108374h case    5:*/		if ( regs.CR[0].eq ) { return 0x821083EC;  }
		/* 82108374h case    5:*/		return 0x82108378;
		  /* 82108378h */ case    6:  		/* mr R31, R17 */
		/* 82108378h case    6:*/		regs.R31 = regs.R17;
		/* 82108378h case    6:*/		return 0x8210837C;
		  /* 8210837Ch */ case    7:  		/* cmplwi CR6, R26, 0 */
		/* 8210837Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8210837Ch case    7:*/		return 0x82108380;
		  /* 82108380h */ case    8:  		/* bc 12, CR6_EQ, 108 */
		/* 82108380h case    8:*/		if ( regs.CR[6].eq ) { return 0x821083EC;  }
		/* 82108380h case    8:*/		return 0x82108384;
		  /* 82108384h */ case    9:  		/* lwz R7, <#[R29 + 12]> */
		/* 82108384h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R29 + 0x0000000C) );
		/* 82108384h case    9:*/		return 0x82108388;
		  /* 82108388h */ case   10:  		/* li R10, 1 */
		/* 82108388h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82108388h case   10:*/		return 0x8210838C;
		  /* 8210838Ch */ case   11:  		/* lwz R6, <#[R29 + 8]> */
		/* 8210838Ch case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000008) );
		/* 8210838Ch case   11:*/		return 0x82108390;
		  /* 82108390h */ case   12:  		/* lwz R5, <#[R30 + 12]> */
		/* 82108390h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 82108390h case   12:*/		return 0x82108394;
		  /* 82108394h */ case   13:  		/* lwz R4, <#[R30 + 8]> */
		/* 82108394h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000008) );
		/* 82108394h case   13:*/		return 0x82108398;
		  /* 82108398h */ case   14:  		/* lwz R11, <#[R24 + 20]> */
		/* 82108398h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 82108398h case   14:*/		return 0x8210839C;
		  /* 8210839Ch */ case   15:  		/* mullw R9, R7, R10 */
		/* 8210839Ch case   15:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R7,regs.R10);
		/* 8210839Ch case   15:*/		return 0x821083A0;
		  /* 821083A0h */ case   16:  		/* mullw R8, R5, R31 */
		/* 821083A0h case   16:*/		cpu::op::mullw<0>(regs,&regs.R8,regs.R5,regs.R31);
		/* 821083A0h case   16:*/		return 0x821083A4;
		  /* 821083A4h */ case   17:  		/* add R9, R9, R28 */
		/* 821083A4h case   17:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R28);
		/* 821083A4h case   17:*/		return 0x821083A8;
		  /* 821083A8h */ case   18:  		/* add R8, R8, R27 */
		/* 821083A8h case   18:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R27);
		/* 821083A8h case   18:*/		return 0x821083AC;
		  /* 821083ACh */ case   19:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821083ACh case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821083ACh case   19:*/		return 0x821083B0;
		  /* 821083B0h */ case   20:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821083B0h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821083B0h case   20:*/		return 0x821083B4;
		  /* 821083B4h */ case   21:  		/* lwzx R9, <#[R9 + R6]> */
		/* 821083B4h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 821083B4h case   21:*/		return 0x821083B8;
		  /* 821083B8h */ case   22:  		/* lwzx R8, <#[R8 + R4]> */
		/* 821083B8h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R4 + 0x00000000) );
		/* 821083B8h case   22:*/		return 0x821083BC;
		  /* 821083BCh */ case   23:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821083BCh case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821083BCh case   23:*/		return 0x821083C0;
		  /* 821083C0h */ case   24:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821083C0h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821083C0h case   24:*/		return 0x821083C4;
		  /* 821083C4h */ case   25:  		/* lwzx R9, <#[R9 + R11]> */
		/* 821083C4h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821083C4h case   25:*/		return 0x821083C8;
		  /* 821083C8h */ case   26:  		/* lwzx R8, <#[R8 + R11]> */
		/* 821083C8h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 821083C8h case   26:*/		return 0x821083CC;
		  /* 821083CCh */ case   27:  		/* lwz R9, <#[R9 + 48]> */
		/* 821083CCh case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000030) );
		/* 821083CCh case   27:*/		return 0x821083D0;
		  /* 821083D0h */ case   28:  		/* lwz R8, <#[R8 + 48]> */
		/* 821083D0h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000030) );
		/* 821083D0h case   28:*/		return 0x821083D4;
		  /* 821083D4h */ case   29:  		/* cmplw CR6, R9, R8 */
		/* 821083D4h case   29:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821083D4h case   29:*/		return 0x821083D8;
		  /* 821083D8h */ case   30:  		/* bc 4, CR6_EQ, 20 */
		/* 821083D8h case   30:*/		if ( !regs.CR[6].eq ) { return 0x821083EC;  }
		/* 821083D8h case   30:*/		return 0x821083DC;
		  /* 821083DCh */ case   31:  		/* addi R31, R31, 1 */
		/* 821083DCh case   31:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821083DCh case   31:*/		return 0x821083E0;
		  /* 821083E0h */ case   32:  		/* addi R10, R10, -1 */
		/* 821083E0h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821083E0h case   32:*/		return 0x821083E4;
		  /* 821083E4h */ case   33:  		/* cmplw CR6, R31, R26 */
		/* 821083E4h case   33:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 821083E4h case   33:*/		return 0x821083E8;
		  /* 821083E8h */ case   34:  		/* bc 12, CR6_LT, -76 */
		/* 821083E8h case   34:*/		if ( regs.CR[6].lt ) { return 0x8210839C;  }
		/* 821083E8h case   34:*/		return 0x821083EC;
	}
	return 0x821083EC;
} // Block from 82108360h-821083ECh (35 instructions)

//////////////////////////////////////////////////////
// Block at 821083ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821083EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821083EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821083EC);
		  /* 821083ECh */ case    0:  		/* cmplw CR6, R31, R26 */
		/* 821083ECh case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 821083ECh case    0:*/		return 0x821083F0;
		  /* 821083F0h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821083F0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82108408;  }
		/* 821083F0h case    1:*/		return 0x821083F4;
		  /* 821083F4h */ case    2:  		/* lwz R5, <#[R29 + 12]> */
		/* 821083F4h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821083F4h case    2:*/		return 0x821083F8;
		  /* 821083F8h */ case    3:  		/* addi R28, R28, 1 */
		/* 821083F8h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 821083F8h case    3:*/		return 0x821083FC;
		  /* 821083FCh */ case    4:  		/* cmplw CR6, R28, R5 */
		/* 821083FCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R5);
		/* 821083FCh case    4:*/		return 0x82108400;
		  /* 82108400h */ case    5:  		/* bc 12, CR6_LT, -264 */
		/* 82108400h case    5:*/		if ( regs.CR[6].lt ) { return 0x821082F8;  }
		/* 82108400h case    5:*/		return 0x82108404;
		  /* 82108404h */ case    6:  		/* b 40 */
		/* 82108404h case    6:*/		return 0x8210842C;
		/* 82108404h case    6:*/		return 0x82108408;
	}
	return 0x82108408;
} // Block from 821083ECh-82108408h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82108408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108408);
		  /* 82108408h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 82108408h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82108408h case    0:*/		return 0x8210840C;
		  /* 8210840Ch */ case    1:  		/* rlwinm R10, R28, 2, 0, 29 */
		/* 8210840Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R28);
		/* 8210840Ch case    1:*/		return 0x82108410;
		  /* 82108410h */ case    2:  		/* lwz R9, <#[R29 + 16]> */
		/* 82108410h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000010) );
		/* 82108410h case    2:*/		return 0x82108414;
		  /* 82108414h */ case    3:  		/* lwz R8, <#[R24 + 20]> */
		/* 82108414h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R24 + 0x00000014) );
		/* 82108414h case    3:*/		return 0x82108418;
		  /* 82108418h */ case    4:  		/* lwzx R11, <#[R11 + R25]> */
		/* 82108418h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 82108418h case    4:*/		return 0x8210841C;
		  /* 8210841Ch */ case    5:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210841Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210841Ch case    5:*/		return 0x82108420;
		  /* 82108420h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82108420h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82108420h case    6:*/		return 0x82108424;
		  /* 82108424h */ case    7:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82108424h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82108424h case    7:*/		return 0x82108428;
		  /* 82108428h */ case    8:  		/* stw R10, <#[R11 + 48]> */
		/* 82108428h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82108428h case    8:*/		return 0x8210842C;
	}
	return 0x8210842C;
} // Block from 82108408h-8210842Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210842Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210842C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210842C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210842C);
		  /* 8210842Ch */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 8210842Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210842Ch case    0:*/		return 0x82108430;
		  /* 82108430h */ case    1:  		/* addi R27, R27, 1 */
		/* 82108430h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82108430h case    1:*/		return 0x82108434;
		  /* 82108434h */ case    2:  		/* addi R25, R25, 4 */
		/* 82108434h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82108434h case    2:*/		return 0x82108438;
		  /* 82108438h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 82108438h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82108438h case    3:*/		return 0x8210843C;
		  /* 8210843Ch */ case    4:  		/* bc 12, CR6_LT, -340 */
		/* 8210843Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x821082E8;  }
		/* 8210843Ch case    4:*/		return 0x82108440;
		  /* 82108440h */ case    5:  		/* b 76 */
		/* 82108440h case    5:*/		return 0x8210848C;
		/* 82108440h case    5:*/		return 0x82108444;
	}
	return 0x82108444;
} // Block from 8210842Ch-82108444h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82108444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108444);
		  /* 82108444h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82108444h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82108444h case    0:*/		return 0x82108448;
		  /* 82108448h */ case    1:  		/* mr R10, R17 */
		/* 82108448h case    1:*/		regs.R10 = regs.R17;
		/* 82108448h case    1:*/		return 0x8210844C;
		  /* 8210844Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210844Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210844Ch case    2:*/		return 0x82108450;
		  /* 82108450h */ case    3:  		/* bc 4, CR6_GT, 60 */
		/* 82108450h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210848C;  }
		/* 82108450h case    3:*/		return 0x82108454;
		  /* 82108454h */ case    4:  		/* mr R11, R17 */
		/* 82108454h case    4:*/		regs.R11 = regs.R17;
		/* 82108454h case    4:*/		return 0x82108458;
		  /* 82108458h */ case    5:  		/* lwz R9, <#[R30 + 16]> */
		/* 82108458h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 82108458h case    5:*/		return 0x8210845C;
		  /* 8210845Ch */ case    6:  		/* addi R10, R10, 1 */
		/* 8210845Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210845Ch case    6:*/		return 0x82108460;
		  /* 82108460h */ case    7:  		/* lwz R8, <#[R29 + 16]> */
		/* 82108460h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000010) );
		/* 82108460h case    7:*/		return 0x82108464;
		  /* 82108464h */ case    8:  		/* lwz R7, <#[R24 + 20]> */
		/* 82108464h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R24 + 0x00000014) );
		/* 82108464h case    8:*/		return 0x82108468;
		  /* 82108468h */ case    9:  		/* lwzx R9, <#[R9 + R11]> */
		/* 82108468h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82108468h case    9:*/		return 0x8210846C;
		  /* 8210846Ch */ case   10:  		/* lwzx R8, <#[R8 + R11]> */
		/* 8210846Ch case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210846Ch case   10:*/		return 0x82108470;
		  /* 82108470h */ case   11:  		/* addi R11, R11, 4 */
		/* 82108470h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82108470h case   11:*/		return 0x82108474;
		  /* 82108474h */ case   12:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82108474h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82108474h case   12:*/		return 0x82108478;
		  /* 82108478h */ case   13:  		/* lwzx R9, <#[R9 + R7]> */
		/* 82108478h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82108478h case   13:*/		return 0x8210847C;
		  /* 8210847Ch */ case   14:  		/* stw R8, <#[R9 + 48]> */
		/* 8210847Ch case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000030) );
		/* 8210847Ch case   14:*/		return 0x82108480;
		  /* 82108480h */ case   15:  		/* lwz R9, <#[R30 + 12]> */
		/* 82108480h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 82108480h case   15:*/		return 0x82108484;
		  /* 82108484h */ case   16:  		/* cmplw CR6, R10, R9 */
		/* 82108484h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82108484h case   16:*/		return 0x82108488;
		  /* 82108488h */ case   17:  		/* bc 12, CR6_LT, -48 */
		/* 82108488h case   17:*/		if ( regs.CR[6].lt ) { return 0x82108458;  }
		/* 82108488h case   17:*/		return 0x8210848C;
	}
	return 0x8210848C;
} // Block from 82108444h-8210848Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8210848Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210848C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210848C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210848C);
		  /* 8210848Ch */ case    0:  		/* li R11, -1 */
		/* 8210848Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8210848Ch case    0:*/		return 0x82108490;
		  /* 82108490h */ case    1:  		/* li R29, 1 */
		/* 82108490h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82108490h case    1:*/		return 0x82108494;
		  /* 82108494h */ case    2:  		/* stw R11, <#[R23]> */
		/* 82108494h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82108494h case    2:*/		return 0x82108498;
		  /* 82108498h */ case    3:  		/* stw R17, <#[R30]> */
		/* 82108498h case    3:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R30 + 0x00000000) );
		/* 82108498h case    3:*/		return 0x8210849C;
		  /* 8210849Ch */ case    4:  		/* stw R17, <#[R30 + 4]> */
		/* 8210849Ch case    4:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R30 + 0x00000004) );
		/* 8210849Ch case    4:*/		return 0x821084A0;
		  /* 821084A0h */ case    5:  		/* stw R17, <#[R30 + 12]> */
		/* 821084A0h case    5:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R30 + 0x0000000C) );
		/* 821084A0h case    5:*/		return 0x821084A4;
		  /* 821084A4h */ case    6:  		/* li R30, 1 */
		/* 821084A4h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 821084A4h case    6:*/		return 0x821084A8;
	}
	return 0x821084A8;
} // Block from 8210848Ch-821084A8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821084A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821084A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821084A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821084A8);
		  /* 821084A8h */ case    0:  		/* addi R19, R19, 1 */
		/* 821084A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 821084A8h case    0:*/		return 0x821084AC;
		  /* 821084ACh */ case    1:  		/* addi R23, R23, 4 */
		/* 821084ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x4);
		/* 821084ACh case    1:*/		return 0x821084B0;
		  /* 821084B0h */ case    2:  		/* cmplw CR6, R19, R16 */
		/* 821084B0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R16);
		/* 821084B0h case    2:*/		return 0x821084B4;
		  /* 821084B4h */ case    3:  		/* bc 12, CR6_LT, -592 */
		/* 821084B4h case    3:*/		if ( regs.CR[6].lt ) { return 0x82108264;  }
		/* 821084B4h case    3:*/		return 0x821084B8;
	}
	return 0x821084B8;
} // Block from 821084A8h-821084B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821084B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821084B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821084B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821084B8);
		  /* 821084B8h */ case    0:  		/* addic. R18, R18, -1 */
		/* 821084B8h case    0:*/		cpu::op::addic<1>(regs,&regs.R18,regs.R18,0xFFFFFFFF);
		/* 821084B8h case    0:*/		return 0x821084BC;
		  /* 821084BCh */ case    1:  		/* addi R20, R20, 4 */
		/* 821084BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x4);
		/* 821084BCh case    1:*/		return 0x821084C0;
		  /* 821084C0h */ case    2:  		/* addi R21, R21, 1 */
		/* 821084C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821084C0h case    2:*/		return 0x821084C4;
		  /* 821084C4h */ case    3:  		/* bc 4, CR0_EQ, -636 */
		/* 821084C4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82108248;  }
		/* 821084C4h case    3:*/		return 0x821084C8;
		  /* 821084C8h */ case    4:  		/* cmpwi CR6, R30, 0 */
		/* 821084C8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 821084C8h case    4:*/		return 0x821084CC;
		  /* 821084CCh */ case    5:  		/* bc 12, CR6_EQ, 156 */
		/* 821084CCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82108568;  }
		/* 821084CCh case    5:*/		return 0x821084D0;
		  /* 821084D0h */ case    6:  		/* or. R11, R16, R16 */
		/* 821084D0h case    6:*/		cpu::op::or<1>(regs,&regs.R11,regs.R16,regs.R16);
		/* 821084D0h case    6:*/		return 0x821084D4;
		  /* 821084D4h */ case    7:  		/* mr R16, R17 */
		/* 821084D4h case    7:*/		regs.R16 = regs.R17;
		/* 821084D4h case    7:*/		return 0x821084D8;
		  /* 821084D8h */ case    8:  		/* bc 12, CR0_EQ, 132 */
		/* 821084D8h case    8:*/		if ( regs.CR[0].eq ) { return 0x8210855C;  }
		/* 821084D8h case    8:*/		return 0x821084DC;
		  /* 821084DCh */ case    9:  		/* addi R5, R15, -4 */
		/* 821084DCh case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R15,0xFFFFFFFC);
		/* 821084DCh case    9:*/		return 0x821084E0;
		  /* 821084E0h */ case   10:  		/* mtspr CTR, R11 */
		/* 821084E0h case   10:*/		regs.CTR = regs.R11;
		/* 821084E0h case   10:*/		return 0x821084E4;
		  /* 821084E4h */ case   11:  		/* mr R4, R15 */
		/* 821084E4h case   11:*/		regs.R4 = regs.R15;
		/* 821084E4h case   11:*/		return 0x821084E8;
		  /* 821084E8h */ case   12:  		/* lwz R6, <#[R4]> */
		/* 821084E8h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R4 + 0x00000000) );
		/* 821084E8h case   12:*/		return 0x821084EC;
		  /* 821084ECh */ case   13:  		/* cmpwi CR6, R6, -1 */
		/* 821084ECh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 821084ECh case   13:*/		return 0x821084F0;
		  /* 821084F0h */ case   14:  		/* bc 12, CR6_EQ, 100 */
		/* 821084F0h case   14:*/		if ( regs.CR[6].eq ) { return 0x82108554;  }
		/* 821084F0h case   14:*/		return 0x821084F4;
		  /* 821084F4h */ case   15:  		/* lwz R11, <#[R24 + 24]> */
		/* 821084F4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000018) );
		/* 821084F4h case   15:*/		return 0x821084F8;
		  /* 821084F8h */ case   16:  		/* rlwinm R9, R6, 2, 0, 29 */
		/* 821084F8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R6);
		/* 821084F8h case   16:*/		return 0x821084FC;
		  /* 821084FCh */ case   17:  		/* mr R10, R17 */
		/* 821084FCh case   17:*/		regs.R10 = regs.R17;
		/* 821084FCh case   17:*/		return 0x82108500;
		  /* 82108500h */ case   18:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82108500h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82108500h case   18:*/		return 0x82108504;
		  /* 82108504h */ case   19:  		/* lwz R9, <#[R11 + 4]> */
		/* 82108504h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82108504h case   19:*/		return 0x82108508;
		  /* 82108508h */ case   20:  		/* cmplwi CR6, R9, 0 */
		/* 82108508h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82108508h case   20:*/		return 0x8210850C;
		  /* 8210850Ch */ case   21:  		/* bc 12, CR6_EQ, 56 */
		/* 8210850Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82108544;  }
		/* 8210850Ch case   21:*/		return 0x82108510;
		  /* 82108510h */ case   22:  		/* lwz R8, <#[R11 + 8]> */
		/* 82108510h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82108510h case   22:*/		return 0x82108514;
		  /* 82108514h */ case   23:  		/* mr R11, R17 */
		/* 82108514h case   23:*/		regs.R11 = regs.R17;
		/* 82108514h case   23:*/		return 0x82108518;
		  /* 82108518h */ case   24:  		/* lwz R7, <#[R24 + 20]> */
		/* 82108518h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R24 + 0x00000014) );
		/* 82108518h case   24:*/		return 0x8210851C;
		  /* 8210851Ch */ case   25:  		/* lwzx R3, <#[R8 + R11]> */
		/* 8210851Ch case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210851Ch case   25:*/		return 0x82108520;
		  /* 82108520h */ case   26:  		/* rlwinm R31, R3, 2, 0, 29 */
		/* 82108520h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R3);
		/* 82108520h case   26:*/		return 0x82108524;
		  /* 82108524h */ case   27:  		/* lwzx R31, <#[R31 + R7]> */
		/* 82108524h case   27:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R7 + 0x00000000) );
		/* 82108524h case   27:*/		return 0x82108528;
		  /* 82108528h */ case   28:  		/* lwz R31, <#[R31 + 48]> */
		/* 82108528h case   28:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000030) );
		/* 82108528h case   28:*/		return 0x8210852C;
		  /* 8210852Ch */ case   29:  		/* cmplw CR6, R31, R3 */
		/* 8210852Ch case   29:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R3);
		/* 8210852Ch case   29:*/		return 0x82108530;
		  /* 82108530h */ case   30:  		/* bc 4, CR6_EQ, 20 */
		/* 82108530h case   30:*/		if ( !regs.CR[6].eq ) { return 0x82108544;  }
		/* 82108530h case   30:*/		return 0x82108534;
		  /* 82108534h */ case   31:  		/* addi R10, R10, 1 */
		/* 82108534h case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82108534h case   31:*/		return 0x82108538;
		  /* 82108538h */ case   32:  		/* addi R11, R11, 4 */
		/* 82108538h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82108538h case   32:*/		return 0x8210853C;
		  /* 8210853Ch */ case   33:  		/* cmplw CR6, R10, R9 */
		/* 8210853Ch case   33:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210853Ch case   33:*/		return 0x82108540;
		  /* 82108540h */ case   34:  		/* bc 12, CR6_LT, -36 */
		/* 82108540h case   34:*/		if ( regs.CR[6].lt ) { return 0x8210851C;  }
		/* 82108540h case   34:*/		return 0x82108544;
	}
	return 0x82108544;
} // Block from 821084B8h-82108544h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82108544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108544);
		  /* 82108544h */ case    0:  		/* cmplw CR6, R10, R9 */
		/* 82108544h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82108544h case    0:*/		return 0x82108548;
		  /* 82108548h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82108548h case    1:*/		if ( regs.CR[6].eq ) { return 0x82108554;  }
		/* 82108548h case    1:*/		return 0x8210854C;
		  /* 8210854Ch */ case    2:  		/* stwu R6, <#[R5 + 4]> */
		/* 8210854Ch case    2:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 8210854Ch case    2:*/		return 0x82108550;
		  /* 82108550h */ case    3:  		/* addi R16, R16, 1 */
		/* 82108550h case    3:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x1);
		/* 82108550h case    3:*/		return 0x82108554;
	}
	return 0x82108554;
} // Block from 82108544h-82108554h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82108554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108554);
		  /* 82108554h */ case    0:  		/* addi R4, R4, 4 */
		/* 82108554h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 82108554h case    0:*/		return 0x82108558;
		  /* 82108558h */ case    1:  		/* bc 16, CR0_LT, -112 */
		/* 82108558h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821084E8;  }
		/* 82108558h case    1:*/		return 0x8210855C;
	}
	return 0x8210855C;
} // Block from 82108554h-8210855Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210855Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210855C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210855C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210855C);
		  /* 8210855Ch */ case    0:  		/* mr R3, R24 */
		/* 8210855Ch case    0:*/		regs.R3 = regs.R24;
		/* 8210855Ch case    0:*/		return 0x82108560;
		  /* 82108560h */ case    1:  		/* bl -8512 */
		/* 82108560h case    1:*/		regs.LR = 0x82108564; return 0x82106420;
		/* 82108560h case    1:*/		return 0x82108564;
		  /* 82108564h */ case    2:  		/* b -896 */
		/* 82108564h case    2:*/		return 0x821081E4;
		/* 82108564h case    2:*/		return 0x82108568;
	}
	return 0x82108568;
} // Block from 8210855Ch-82108568h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82108568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108568);
		  /* 82108568h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 82108568h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82108568h case    0:*/		return 0x8210856C;
		  /* 8210856Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8210856Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82108578;  }
		/* 8210856Ch case    1:*/		return 0x82108570;
		  /* 82108570h */ case    2:  		/* mr R3, R24 */
		/* 82108570h case    2:*/		regs.R3 = regs.R24;
		/* 82108570h case    2:*/		return 0x82108574;
		  /* 82108574h */ case    3:  		/* bl -3596 */
		/* 82108574h case    3:*/		regs.LR = 0x82108578; return 0x82107768;
		/* 82108574h case    3:*/		return 0x82108578;
	}
	return 0x82108578;
} // Block from 82108568h-82108578h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82108578h
// Function '?SquishInstructions@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108578);
		  /* 82108578h */ case    0:  		/* cntlzw R11, R29 */
		/* 82108578h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R29);
		/* 82108578h case    0:*/		return 0x8210857C;
		  /* 8210857Ch */ case    1:  		/* rlwinm R31, R11, 27, 31, 31 */
		/* 8210857Ch case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R31,regs.R11);
		/* 8210857Ch case    1:*/		return 0x82108580;
	}
	return 0x82108580;
} // Block from 82108578h-82108580h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82108580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108580);
		  /* 82108580h */ case    0:  		/* lis R4, 9345 */
		/* 82108580h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82108580h case    0:*/		return 0x82108584;
		  /* 82108584h */ case    1:  		/* mr R3, R15 */
		/* 82108584h case    1:*/		regs.R3 = regs.R15;
		/* 82108584h case    1:*/		return 0x82108588;
		  /* 82108588h */ case    2:  		/* bl -524880 */
		/* 82108588h case    2:*/		regs.LR = 0x8210858C; return 0x82088338;
		/* 82108588h case    2:*/		return 0x8210858C;
		  /* 8210858Ch */ case    3:  		/* mr R3, R31 */
		/* 8210858Ch case    3:*/		regs.R3 = regs.R31;
		/* 8210858Ch case    3:*/		return 0x82108590;
		  /* 82108590h */ case    4:  		/* addi R1, R1, 224 */
		/* 82108590h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 82108590h case    4:*/		return 0x82108594;
		  /* 82108594h */ case    5:  		/* b -488224 */
		/* 82108594h case    5:*/		return 0x82091274;
		/* 82108594h case    5:*/		return 0x82108598;
	}
	return 0x82108598;
} // Block from 82108580h-82108598h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82108598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108598);
		  /* 82108598h */ case    0:  		/* mfspr R12, LR */
		/* 82108598h case    0:*/		regs.R12 = regs.LR;
		/* 82108598h case    0:*/		return 0x8210859C;
		  /* 8210859Ch */ case    1:  		/* bl -488316 */
		/* 8210859Ch case    1:*/		regs.LR = 0x821085A0; return 0x82091220;
		/* 8210859Ch case    1:*/		return 0x821085A0;
		  /* 821085A0h */ case    2:  		/* stwu R1, <#[R1 - 272]> */
		/* 821085A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 821085A0h case    2:*/		return 0x821085A4;
		  /* 821085A4h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 821085A4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821085A4h case    3:*/		return 0x821085A8;
		  /* 821085A8h */ case    4:  		/* mr R21, R3 */
		/* 821085A8h case    4:*/		regs.R21 = regs.R3;
		/* 821085A8h case    4:*/		return 0x821085AC;
		  /* 821085ACh */ case    5:  		/* lis R4, 9345 */
		/* 821085ACh case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 821085ACh case    5:*/		return 0x821085B0;
		  /* 821085B0h */ case    6:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 821085B0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 821085B0h case    6:*/		return 0x821085B4;
		  /* 821085B4h */ case    7:  		/* bl -525236 */
		/* 821085B4h case    7:*/		regs.LR = 0x821085B8; return 0x82088200;
		/* 821085B4h case    7:*/		return 0x821085B8;
		  /* 821085B8h */ case    8:  		/* or. R22, R3, R3 */
		/* 821085B8h case    8:*/		cpu::op::or<1>(regs,&regs.R22,regs.R3,regs.R3);
		/* 821085B8h case    8:*/		return 0x821085BC;
		  /* 821085BCh */ case    9:  		/* stw R22, <#[R1 + 92]> */
		/* 821085BCh case    9:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x0000005C) );
		/* 821085BCh case    9:*/		return 0x821085C0;
		  /* 821085C0h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 821085C0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821085D0;  }
		/* 821085C0h case   10:*/		return 0x821085C4;
		  /* 821085C4h */ case   11:  		/* lis R31, -32761 */
		/* 821085C4h case   11:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 821085C4h case   11:*/		return 0x821085C8;
		  /* 821085C8h */ case   12:  		/* ori R31, R31, 14 */
		/* 821085C8h case   12:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 821085C8h case   12:*/		return 0x821085CC;
		  /* 821085CCh */ case   13:  		/* b 1448 */
		/* 821085CCh case   13:*/		return 0x82108B74;
		/* 821085CCh case   13:*/		return 0x821085D0;
	}
	return 0x821085D0;
} // Block from 82108598h-821085D0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821085D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821085D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821085D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821085D0);
		  /* 821085D0h */ case    0:  		/* li R11, 0 */
		/* 821085D0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821085D0h case    0:*/		return 0x821085D4;
		  /* 821085D4h */ case    1:  		/* stw R11, <#[R1 + 88]> */
		/* 821085D4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 821085D4h case    1:*/		return 0x821085D8;
		  /* 821085D8h */ case    2:  		/* li R11, 0 */
		/* 821085D8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821085D8h case    2:*/		return 0x821085DC;
		  /* 821085DCh */ case    3:  		/* li R23, 0 */
		/* 821085DCh case    3:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 821085DCh case    3:*/		return 0x821085E0;
		  /* 821085E0h */ case    4:  		/* mr R3, R21 */
		/* 821085E0h case    4:*/		regs.R3 = regs.R21;
		/* 821085E0h case    4:*/		return 0x821085E4;
		  /* 821085E4h */ case    5:  		/* stw R11, <#[R1 + 104]> */
		/* 821085E4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 821085E4h case    5:*/		return 0x821085E8;
		  /* 821085E8h */ case    6:  		/* stw R23, <#[R1 + 80]> */
		/* 821085E8h case    6:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000050) );
		/* 821085E8h case    6:*/		return 0x821085EC;
		  /* 821085ECh */ case    7:  		/* bl -10836 */
		/* 821085ECh case    7:*/		regs.LR = 0x821085F0; return 0x82105B98;
		/* 821085ECh case    7:*/		return 0x821085F0;
		  /* 821085F0h */ case    8:  		/* lwz R11, <#[R21 + 8]> */
		/* 821085F0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 821085F0h case    8:*/		return 0x821085F4;
		  /* 821085F4h */ case    9:  		/* li R10, 0 */
		/* 821085F4h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821085F4h case    9:*/		return 0x821085F8;
		  /* 821085F8h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 821085F8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821085F8h case   10:*/		return 0x821085FC;
		  /* 821085FCh */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 821085FCh case   11:*/		if ( regs.CR[6].eq ) { return 0x82108624;  }
		/* 821085FCh case   11:*/		return 0x82108600;
		  /* 82108600h */ case   12:  		/* li R9, 0 */
		/* 82108600h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82108600h case   12:*/		return 0x82108604;
		  /* 82108604h */ case   13:  		/* lwz R11, <#[R21 + 20]> */
		/* 82108604h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000014) );
		/* 82108604h case   13:*/		return 0x82108608;
		  /* 82108608h */ case   14:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82108608h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82108608h case   14:*/		return 0x8210860C;
		  /* 8210860Ch */ case   15:  		/* addi R9, R9, 4 */
		/* 8210860Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210860Ch case   15:*/		return 0x82108610;
		  /* 82108610h */ case   16:  		/* stw R10, <#[R11 + 48]> */
		/* 82108610h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82108610h case   16:*/		return 0x82108614;
		  /* 82108614h */ case   17:  		/* addi R10, R10, 1 */
		/* 82108614h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82108614h case   17:*/		return 0x82108618;
		  /* 82108618h */ case   18:  		/* lwz R11, <#[R21 + 8]> */
		/* 82108618h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 82108618h case   18:*/		return 0x8210861C;
		  /* 8210861Ch */ case   19:  		/* cmplw CR6, R10, R11 */
		/* 8210861Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8210861Ch case   19:*/		return 0x82108620;
		  /* 82108620h */ case   20:  		/* bc 12, CR6_LT, -28 */
		/* 82108620h case   20:*/		if ( regs.CR[6].lt ) { return 0x82108604;  }
		/* 82108620h case   20:*/		return 0x82108624;
	}
	return 0x82108624;
} // Block from 821085D0h-82108624h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82108624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108624);
		  /* 82108624h */ case    0:  		/* li R26, 0 */
		/* 82108624h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82108624h case    0:*/		return 0x82108628;
		  /* 82108628h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82108628h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82108628h case    1:*/		return 0x8210862C;
		  /* 8210862Ch */ case    2:  		/* bc 12, CR6_EQ, 400 */
		/* 8210862Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821087BC;  }
		/* 8210862Ch case    2:*/		return 0x82108630;
		  /* 82108630h */ case    3:  		/* li R25, 0 */
		/* 82108630h case    3:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82108630h case    3:*/		return 0x82108634;
		  /* 82108634h */ case    4:  		/* addi R24, R22, -4 */
		/* 82108634h case    4:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R22,0xFFFFFFFC);
		/* 82108634h case    4:*/		return 0x82108638;
		  /* 82108638h */ case    5:  		/* lis R20, 4416 */
		/* 82108638h case    5:*/		cpu::op::lis<0>(regs,&regs.R20,0x1140);
		/* 82108638h case    5:*/		return 0x8210863C;
		  /* 8210863Ch */ case    6:  		/* lwz R11, <#[R21 + 20]> */
		/* 8210863Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000014) );
		/* 8210863Ch case    6:*/		return 0x82108640;
		  /* 82108640h */ case    7:  		/* lwzx R27, <#[R11 + R25]> */
		/* 82108640h case    7:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 82108640h case    7:*/		return 0x82108644;
		  /* 82108644h */ case    8:  		/* lwz R11, <#[R27 + 8]> */
		/* 82108644h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82108644h case    8:*/		return 0x82108648;
		  /* 82108648h */ case    9:  		/* cmpwi CR6, R11, -1 */
		/* 82108648h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82108648h case    9:*/		return 0x8210864C;
		  /* 8210864Ch */ case   10:  		/* bc 4, CR6_EQ, 344 */
		/* 8210864Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x821087A4;  }
		/* 8210864Ch case   10:*/		return 0x82108650;
		  /* 82108650h */ case   11:  		/* lwz R10, <#[R27 + 72]> */
		/* 82108650h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000048) );
		/* 82108650h case   11:*/		return 0x82108654;
		  /* 82108654h */ case   12:  		/* cmpwi CR6, R10, -1 */
		/* 82108654h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82108654h case   12:*/		return 0x82108658;
		  /* 82108658h */ case   13:  		/* bc 12, CR6_EQ, 332 */
		/* 82108658h case   13:*/		if ( regs.CR[6].eq ) { return 0x821087A4;  }
		/* 82108658h case   13:*/		return 0x8210865C;
		  /* 8210865Ch */ case   14:  		/* lwz R11, <#[R27 + 4]> */
		/* 8210865Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 8210865Ch case   14:*/		return 0x82108660;
		  /* 82108660h */ case   15:  		/* lwz R9, <#[R21 + 16]> */
		/* 82108660h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R21 + 0x00000010) );
		/* 82108660h case   15:*/		return 0x82108664;
		  /* 82108664h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82108664h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82108664h case   16:*/		return 0x82108668;
		  /* 82108668h */ case   17:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82108668h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82108668h case   17:*/		return 0x8210866C;
		  /* 8210866Ch */ case   18:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210866Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210866Ch case   18:*/		return 0x82108670;
		  /* 82108670h */ case   19:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 82108670h case   19:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 82108670h case   19:*/		return 0x82108674;
		  /* 82108674h */ case   20:  		/* bc 12, CR0_EQ, 304 */
		/* 82108674h case   20:*/		if ( regs.CR[0].eq ) { return 0x821087A4;  }
		/* 82108674h case   20:*/		return 0x82108678;
		  /* 82108678h */ case   21:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82108678h case   21:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82108678h case   21:*/		return 0x8210867C;
		  /* 8210867Ch */ case   22:  		/* bc 4, CR0_EQ, 296 */
		/* 8210867Ch case   22:*/		if ( !regs.CR[0].eq ) { return 0x821087A4;  }
		/* 8210867Ch case   22:*/		return 0x82108680;
		  /* 82108680h */ case   23:  		/* lwz R11, <#[R21 + 24]> */
		/* 82108680h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000018) );
		/* 82108680h case   23:*/		return 0x82108684;
		  /* 82108684h */ case   24:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82108684h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82108684h case   24:*/		return 0x82108688;
		  /* 82108688h */ case   25:  		/* lis R9, 4096 */
		/* 82108688h case   25:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 82108688h case   25:*/		return 0x8210868C;
		  /* 8210868Ch */ case   26:  		/* lwzx R29, <#[R10 + R11]> */
		/* 8210868Ch case   26:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210868Ch case   26:*/		return 0x82108690;
		  /* 82108690h */ case   27:  		/* lwz R8, <#[R29]> */
		/* 82108690h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000000) );
		/* 82108690h case   27:*/		return 0x82108694;
		  /* 82108694h */ case   28:  		/* rlwinm R11, R8, 0, 0, 3 */
		/* 82108694h case   28:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R8);
		/* 82108694h case   28:*/		return 0x82108698;
		  /* 82108698h */ case   29:  		/* cmplw CR6, R11, R9 */
		/* 82108698h case   29:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82108698h case   29:*/		return 0x8210869C;
		  /* 8210869Ch */ case   30:  		/* bc 12, CR6_LT, 264 */
		/* 8210869Ch case   30:*/		if ( regs.CR[6].lt ) { return 0x821087A4;  }
		/* 8210869Ch case   30:*/		return 0x821086A0;
		  /* 821086A0h */ case   31:  		/* lis R10, 16384 */
		/* 821086A0h case   31:*/		cpu::op::lis<0>(regs,&regs.R10,0x4000);
		/* 821086A0h case   31:*/		return 0x821086A4;
		  /* 821086A4h */ case   32:  		/* cmplw CR6, R11, R10 */
		/* 821086A4h case   32:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821086A4h case   32:*/		return 0x821086A8;
		  /* 821086A8h */ case   33:  		/* bc 12, CR6_GT, 252 */
		/* 821086A8h case   33:*/		if ( regs.CR[6].gt ) { return 0x821087A4;  }
		/* 821086A8h case   33:*/		return 0x821086AC;
		  /* 821086ACh */ case   34:  		/* rlwinm R31, R8, 0, 0, 11 */
		/* 821086ACh case   34:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R31,regs.R8);
		/* 821086ACh case   34:*/		return 0x821086B0;
		  /* 821086B0h */ case   35:  		/* cmplw CR6, R31, R20 */
		/* 821086B0h case   35:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R20);
		/* 821086B0h case   35:*/		return 0x821086B4;
		  /* 821086B4h */ case   36:  		/* bc 12, CR6_GT, 52 */
		/* 821086B4h case   36:*/		if ( regs.CR[6].gt ) { return 0x821086E8;  }
		/* 821086B4h case   36:*/		return 0x821086B8;
		  /* 821086B8h */ case   37:  		/* bc 12, CR6_EQ, 236 */
		/* 821086B8h case   37:*/		if ( regs.CR[6].eq ) { return 0x821087A4;  }
		/* 821086B8h case   37:*/		return 0x821086BC;
		  /* 821086BCh */ case   38:  		/* lis R11, 4336 */
		/* 821086BCh case   38:*/		cpu::op::lis<0>(regs,&regs.R11,0x10F0);
		/* 821086BCh case   38:*/		return 0x821086C0;
		  /* 821086C0h */ case   39:  		/* cmplw CR6, R31, R11 */
		/* 821086C0h case   39:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 821086C0h case   39:*/		return 0x821086C4;
		  /* 821086C4h */ case   40:  		/* bc 12, CR6_EQ, 224 */
		/* 821086C4h case   40:*/		if ( regs.CR[6].eq ) { return 0x821087A4;  }
		/* 821086C4h case   40:*/		return 0x821086C8;
		  /* 821086C8h */ case   41:  		/* lis R11, 4368 */
		/* 821086C8h case   41:*/		cpu::op::lis<0>(regs,&regs.R11,0x1110);
		/* 821086C8h case   41:*/		return 0x821086CC;
		  /* 821086CCh */ case   42:  		/* cmplw CR6, R31, R11 */
		/* 821086CCh case   42:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 821086CCh case   42:*/		return 0x821086D0;
		  /* 821086D0h */ case   43:  		/* bc 12, CR6_EQ, 212 */
		/* 821086D0h case   43:*/		if ( regs.CR[6].eq ) { return 0x821087A4;  }
		/* 821086D0h case   43:*/		return 0x821086D4;
		  /* 821086D4h */ case   44:  		/* lis R11, 4384 */
		/* 821086D4h case   44:*/		cpu::op::lis<0>(regs,&regs.R11,0x1120);
		/* 821086D4h case   44:*/		return 0x821086D8;
		  /* 821086D8h */ case   45:  		/* cmplw CR6, R31, R11 */
		/* 821086D8h case   45:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 821086D8h case   45:*/		return 0x821086DC;
		  /* 821086DCh */ case   46:  		/* bc 12, CR6_EQ, 200 */
		/* 821086DCh case   46:*/		if ( regs.CR[6].eq ) { return 0x821087A4;  }
		/* 821086DCh case   46:*/		return 0x821086E0;
		  /* 821086E0h */ case   47:  		/* lis R11, 4400 */
		/* 821086E0h case   47:*/		cpu::op::lis<0>(regs,&regs.R11,0x1130);
		/* 821086E0h case   47:*/		return 0x821086E4;
		  /* 821086E4h */ case   48:  		/* b 44 */
		/* 821086E4h case   48:*/		return 0x82108710;
		/* 821086E4h case   48:*/		return 0x821086E8;
	}
	return 0x821086E8;
} // Block from 82108624h-821086E8h (49 instructions)

//////////////////////////////////////////////////////
// Block at 821086E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821086E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821086E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821086E8);
		  /* 821086E8h */ case    0:  		/* lis R11, 4432 */
		/* 821086E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x1150);
		/* 821086E8h case    0:*/		return 0x821086EC;
		  /* 821086ECh */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 821086ECh case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 821086ECh case    1:*/		return 0x821086F0;
		  /* 821086F0h */ case    2:  		/* bc 12, CR6_EQ, 180 */
		/* 821086F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x821087A4;  }
		/* 821086F0h case    2:*/		return 0x821086F4;
		  /* 821086F4h */ case    3:  		/* lis R11, 8304 */
		/* 821086F4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x2070);
		/* 821086F4h case    3:*/		return 0x821086F8;
		  /* 821086F8h */ case    4:  		/* cmplw CR6, R31, R11 */
		/* 821086F8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 821086F8h case    4:*/		return 0x821086FC;
		  /* 821086FCh */ case    5:  		/* bc 12, CR6_EQ, 168 */
		/* 821086FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x821087A4;  }
		/* 821086FCh case    5:*/		return 0x82108700;
		  /* 82108700h */ case    6:  		/* lis R11, 8320 */
		/* 82108700h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0x2080);
		/* 82108700h case    6:*/		return 0x82108704;
		  /* 82108704h */ case    7:  		/* cmplw CR6, R31, R11 */
		/* 82108704h case    7:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82108704h case    7:*/		return 0x82108708;
		  /* 82108708h */ case    8:  		/* bc 12, CR6_EQ, 156 */
		/* 82108708h case    8:*/		if ( regs.CR[6].eq ) { return 0x821087A4;  }
		/* 82108708h case    8:*/		return 0x8210870C;
		  /* 8210870Ch */ case    9:  		/* lis R11, 8336 */
		/* 8210870Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0x2090);
		/* 8210870Ch case    9:*/		return 0x82108710;
	}
	return 0x82108710;
} // Block from 821086E8h-82108710h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82108710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108710);
		  /* 82108710h */ case    0:  		/* cmplw CR6, R31, R11 */
		/* 82108710h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82108710h case    0:*/		return 0x82108714;
		  /* 82108714h */ case    1:  		/* bc 12, CR6_EQ, 144 */
		/* 82108714h case    1:*/		if ( regs.CR[6].eq ) { return 0x821087A4;  }
		/* 82108714h case    1:*/		return 0x82108718;
		  /* 82108718h */ case    2:  		/* lwz R9, <#[R29 + 12]> */
		/* 82108718h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x0000000C) );
		/* 82108718h case    2:*/		return 0x8210871C;
		  /* 8210871Ch */ case    3:  		/* li R28, 0 */
		/* 8210871Ch case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8210871Ch case    3:*/		return 0x82108720;
		  /* 82108720h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 82108720h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82108720h case    4:*/		return 0x82108724;
		  /* 82108724h */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 82108724h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210874C;  }
		/* 82108724h case    5:*/		return 0x82108728;
		  /* 82108728h */ case    6:  		/* lwz R10, <#[R29 + 16]> */
		/* 82108728h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 82108728h case    6:*/		return 0x8210872C;
		  /* 8210872Ch */ case    7:  		/* li R11, 0 */
		/* 8210872Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210872Ch case    7:*/		return 0x82108730;
		  /* 82108730h */ case    8:  		/* lwzx R7, <#[R10 + R11]> */
		/* 82108730h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82108730h case    8:*/		return 0x82108734;
		  /* 82108734h */ case    9:  		/* cmplw CR6, R26, R7 */
		/* 82108734h case    9:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R7);
		/* 82108734h case    9:*/		return 0x82108738;
		  /* 82108738h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 82108738h case   10:*/		if ( regs.CR[6].eq ) { return 0x8210874C;  }
		/* 82108738h case   10:*/		return 0x8210873C;
		  /* 8210873Ch */ case   11:  		/* addi R28, R28, 1 */
		/* 8210873Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210873Ch case   11:*/		return 0x82108740;
		  /* 82108740h */ case   12:  		/* addi R11, R11, 4 */
		/* 82108740h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82108740h case   12:*/		return 0x82108744;
		  /* 82108744h */ case   13:  		/* cmplw CR6, R28, R9 */
		/* 82108744h case   13:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R9);
		/* 82108744h case   13:*/		return 0x82108748;
		  /* 82108748h */ case   14:  		/* bc 12, CR6_LT, -24 */
		/* 82108748h case   14:*/		if ( regs.CR[6].lt ) { return 0x82108730;  }
		/* 82108748h case   14:*/		return 0x8210874C;
	}
	return 0x8210874C;
} // Block from 82108710h-8210874Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8210874Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210874C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210874C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210874C);
		  /* 8210874Ch */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 8210874Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8210874Ch case    0:*/		return 0x82108750;
		  /* 82108750h */ case    1:  		/* rlwinm R10, R8, 0, 12, 31 */
		/* 82108750h case    1:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R10,regs.R8);
		/* 82108750h case    1:*/		return 0x82108754;
		  /* 82108754h */ case    2:  		/* mr R3, R29 */
		/* 82108754h case    2:*/		regs.R3 = regs.R29;
		/* 82108754h case    2:*/		return 0x82108758;
		  /* 82108758h */ case    3:  		/* divwu R30, R11, R10 */
		/* 82108758h case    3:*/		cpu::op::divwu<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 82108758h case    3:*/		return 0x8210875C;
		  /* 8210875Ch */ case    4:  		/* twi 6, R10, 0 */
		/* 8210875Ch case    4:*/		cpu::op::tw<6>(regs, 0x8210875C, regs.R10, 0x00000000);
		/* 8210875Ch case    4:*/		return 0x82108760;
		  /* 82108760h */ case    5:  		/* bl -51040 */
		/* 82108760h case    5:*/		regs.LR = 0x82108764; return 0x820FC000;
		/* 82108760h case    5:*/		return 0x82108764;
		  /* 82108764h */ case    6:  		/* mr R7, R3 */
		/* 82108764h case    6:*/		regs.R7 = regs.R3;
		/* 82108764h case    6:*/		return 0x82108768;
		  /* 82108768h */ case    7:  		/* li R5, 0 */
		/* 82108768h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82108768h case    7:*/		return 0x8210876C;
		  /* 8210876Ch */ case    8:  		/* cmplwi CR6, R30, 0 */
		/* 8210876Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8210876Ch case    8:*/		return 0x82108770;
		  /* 82108770h */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 82108770h case    9:*/		if ( regs.CR[6].eq ) { return 0x82108798;  }
		/* 82108770h case    9:*/		return 0x82108774;
		  /* 82108774h */ case   10:  		/* mr R6, R28 */
		/* 82108774h case   10:*/		regs.R6 = regs.R28;
		/* 82108774h case   10:*/		return 0x82108778;
		  /* 82108778h */ case   11:  		/* mr R4, R29 */
		/* 82108778h case   11:*/		regs.R4 = regs.R29;
		/* 82108778h case   11:*/		return 0x8210877C;
		  /* 8210877Ch */ case   12:  		/* mr R3, R21 */
		/* 8210877Ch case   12:*/		regs.R3 = regs.R21;
		/* 8210877Ch case   12:*/		return 0x82108780;
		  /* 82108780h */ case   13:  		/* bl -42552 */
		/* 82108780h case   13:*/		regs.LR = 0x82108784; return 0x820FE148;
		/* 82108780h case   13:*/		return 0x82108784;
		  /* 82108784h */ case   14:  		/* mulli R11, R31, 2111 */
		/* 82108784h case   14:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R31,0x83F);
		/* 82108784h case   14:*/		return 0x82108788;
		  /* 82108788h */ case   15:  		/* addi R5, R5, 1 */
		/* 82108788h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82108788h case   15:*/		return 0x8210878C;
		  /* 8210878Ch */ case   16:  		/* add R31, R3, R11 */
		/* 8210878Ch case   16:*/		cpu::op::add<0>(regs,&regs.R31,regs.R3,regs.R11);
		/* 8210878Ch case   16:*/		return 0x82108790;
		  /* 82108790h */ case   17:  		/* cmplw CR6, R5, R30 */
		/* 82108790h case   17:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R30);
		/* 82108790h case   17:*/		return 0x82108794;
		  /* 82108794h */ case   18:  		/* bc 12, CR6_LT, -32 */
		/* 82108794h case   18:*/		if ( regs.CR[6].lt ) { return 0x82108774;  }
		/* 82108794h case   18:*/		return 0x82108798;
	}
	return 0x82108798;
} // Block from 8210874Ch-82108798h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82108798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108798);
		  /* 82108798h */ case    0:  		/* stw R31, <#[R27 + 64]> */
		/* 82108798h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R27 + 0x00000040) );
		/* 82108798h case    0:*/		return 0x8210879C;
		  /* 8210879Ch */ case    1:  		/* addi R23, R23, 1 */
		/* 8210879Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 8210879Ch case    1:*/		return 0x821087A0;
		  /* 821087A0h */ case    2:  		/* stwu R26, <#[R24 + 4]> */
		/* 821087A0h case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R24 + 0x00000004) );
		regs.R24 = (uint32)(regs.R24 + 0x00000004);
		/* 821087A0h case    2:*/		return 0x821087A4;
	}
	return 0x821087A4;
} // Block from 82108798h-821087A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821087A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821087A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821087A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821087A4);
		  /* 821087A4h */ case    0:  		/* lwz R11, <#[R21 + 8]> */
		/* 821087A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 821087A4h case    0:*/		return 0x821087A8;
		  /* 821087A8h */ case    1:  		/* addi R26, R26, 1 */
		/* 821087A8h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 821087A8h case    1:*/		return 0x821087AC;
		  /* 821087ACh */ case    2:  		/* addi R25, R25, 4 */
		/* 821087ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 821087ACh case    2:*/		return 0x821087B0;
		  /* 821087B0h */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 821087B0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 821087B0h case    3:*/		return 0x821087B4;
		  /* 821087B4h */ case    4:  		/* bc 12, CR6_LT, -376 */
		/* 821087B4h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210863C;  }
		/* 821087B4h case    4:*/		return 0x821087B8;
		  /* 821087B8h */ case    5:  		/* stw R23, <#[R1 + 80]> */
		/* 821087B8h case    5:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000050) );
		/* 821087B8h case    5:*/		return 0x821087BC;
	}
	return 0x821087BC;
} // Block from 821087A4h-821087BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821087BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821087BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821087BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821087BC);
		  /* 821087BCh */ case    0:  		/* lis R11, -32240 */
		/* 821087BCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8210);
		/* 821087BCh case    0:*/		return 0x821087C0;
		  /* 821087C0h */ case    1:  		/* mr R6, R21 */
		/* 821087C0h case    1:*/		regs.R6 = regs.R21;
		/* 821087C0h case    1:*/		return 0x821087C4;
		  /* 821087C4h */ case    2:  		/* mr R5, R23 */
		/* 821087C4h case    2:*/		regs.R5 = regs.R23;
		/* 821087C4h case    2:*/		return 0x821087C8;
		  /* 821087C8h */ case    3:  		/* mr R4, R22 */
		/* 821087C8h case    3:*/		regs.R4 = regs.R22;
		/* 821087C8h case    3:*/		return 0x821087CC;
		  /* 821087CCh */ case    4:  		/* addi R3, R11, -8608 */
		/* 821087CCh case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFDE60);
		/* 821087CCh case    4:*/		return 0x821087D0;
		  /* 821087D0h */ case    5:  		/* bl -43312 */
		/* 821087D0h case    5:*/		regs.LR = 0x821087D4; return 0x820FDEA0;
		/* 821087D0h case    5:*/		return 0x821087D4;
		  /* 821087D4h */ case    6:  		/* cmplwi CR6, R23, 0 */
		/* 821087D4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 821087D4h case    6:*/		return 0x821087D8;
		  /* 821087D8h */ case    7:  		/* bc 12, CR6_EQ, 912 */
		/* 821087D8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82108B68;  }
		/* 821087D8h case    7:*/		return 0x821087DC;
		  /* 821087DCh */ case    8:  		/* li R10, 1 */
		/* 821087DCh case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821087DCh case    8:*/		return 0x821087E0;
		  /* 821087E0h */ case    9:  		/* stw R23, <#[R1 + 100]> */
		/* 821087E0h case    9:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000064) );
		/* 821087E0h case    9:*/		return 0x821087E4;
		  /* 821087E4h */ case   10:  		/* mr R14, R22 */
		/* 821087E4h case   10:*/		regs.R14 = regs.R22;
		/* 821087E4h case   10:*/		return 0x821087E8;
		  /* 821087E8h */ case   11:  		/* stw R10, <#[R1 + 84]> */
		/* 821087E8h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 821087E8h case   11:*/		return 0x821087EC;
		  /* 821087ECh */ case   12:  		/* lwz R11, <#[R14]> */
		/* 821087ECh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 821087ECh case   12:*/		return 0x821087F0;
		  /* 821087F0h */ case   13:  		/* lwz R9, <#[R21 + 20]> */
		/* 821087F0h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R21 + 0x00000014) );
		/* 821087F0h case   13:*/		return 0x821087F4;
		  /* 821087F4h */ case   14:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 821087F4h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 821087F4h case   14:*/		return 0x821087F8;
		  /* 821087F8h */ case   15:  		/* lwz R7, <#[R21 + 24]> */
		/* 821087F8h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R21 + 0x00000018) );
		/* 821087F8h case   15:*/		return 0x821087FC;
		  /* 821087FCh */ case   16:  		/* lwzx R17, <#[R8 + R9]> */
		/* 821087FCh case   16:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 821087FCh case   16:*/		return 0x82108800;
		  /* 82108800h */ case   17:  		/* lwz R9, <#[R17 + 72]> */
		/* 82108800h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000048) );
		/* 82108800h case   17:*/		return 0x82108804;
		  /* 82108804h */ case   18:  		/* lwz R8, <#[R17 + 48]> */
		/* 82108804h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R17 + 0x00000030) );
		/* 82108804h case   18:*/		return 0x82108808;
		  /* 82108808h */ case   19:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82108808h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82108808h case   19:*/		return 0x8210880C;
		  /* 8210880Ch */ case   20:  		/* cmplw CR6, R8, R11 */
		/* 8210880Ch case   20:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210880Ch case   20:*/		return 0x82108810;
		  /* 82108810h */ case   21:  		/* lwzx R16, <#[R9 + R7]> */
		/* 82108810h case   21:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82108810h case   21:*/		return 0x82108814;
		  /* 82108814h */ case   22:  		/* bc 4, CR6_EQ, 692 */
		/* 82108814h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82108AC8;  }
		/* 82108814h case   22:*/		return 0x82108818;
		  /* 82108818h */ case   23:  		/* stw R10, <#[R1 + 96]> */
		/* 82108818h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82108818h case   23:*/		return 0x8210881C;
		  /* 8210881Ch */ case   24:  		/* cmplw CR6, R10, R23 */
		/* 8210881Ch case   24:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R23);
		/* 8210881Ch case   24:*/		return 0x82108820;
		  /* 82108820h */ case   25:  		/* bc 4, CR6_LT, 680 */
		/* 82108820h case   25:*/		if ( !regs.CR[6].lt ) { return 0x82108AC8;  }
		/* 82108820h case   25:*/		return 0x82108824;
		  /* 82108824h */ case   26:  		/* addi R15, R14, 4 */
		/* 82108824h case   26:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R14,0x4);
		/* 82108824h case   26:*/		return 0x82108828;
		  /* 82108828h */ case   27:  		/* lwz R11, <#[R15]> */
		/* 82108828h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82108828h case   27:*/		return 0x8210882C;
		  /* 8210882Ch */ case   28:  		/* lwz R9, <#[R21 + 20]> */
		/* 8210882Ch case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R21 + 0x00000014) );
		/* 8210882Ch case   28:*/		return 0x82108830;
		  /* 82108830h */ case   29:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 82108830h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 82108830h case   29:*/		return 0x82108834;
		  /* 82108834h */ case   30:  		/* lwz R7, <#[R17 + 64]> */
		/* 82108834h case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R17 + 0x00000040) );
		/* 82108834h case   30:*/		return 0x82108838;
		  /* 82108838h */ case   31:  		/* lwzx R20, <#[R8 + R9]> */
		/* 82108838h case   31:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82108838h case   31:*/		return 0x8210883C;
		  /* 8210883Ch */ case   32:  		/* lwz R9, <#[R20 + 64]> */
		/* 8210883Ch case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x00000040) );
		/* 8210883Ch case   32:*/		return 0x82108840;
		  /* 82108840h */ case   33:  		/* cmplw CR6, R7, R9 */
		/* 82108840h case   33:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 82108840h case   33:*/		return 0x82108844;
		  /* 82108844h */ case   34:  		/* bc 4, CR6_EQ, 644 */
		/* 82108844h case   34:*/		if ( !regs.CR[6].eq ) { return 0x82108AC8;  }
		/* 82108844h case   34:*/		return 0x82108848;
		  /* 82108848h */ case   35:  		/* lwz R9, <#[R20 + 48]> */
		/* 82108848h case   35:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x00000030) );
		/* 82108848h case   35:*/		return 0x8210884C;
		  /* 8210884Ch */ case   36:  		/* cmplw CR6, R9, R11 */
		/* 8210884Ch case   36:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8210884Ch case   36:*/		return 0x82108850;
		  /* 82108850h */ case   37:  		/* bc 4, CR6_EQ, 608 */
		/* 82108850h case   37:*/		if ( !regs.CR[6].eq ) { return 0x82108AB0;  }
		/* 82108850h case   37:*/		return 0x82108854;
		  /* 82108854h */ case   38:  		/* lwz R9, <#[R17 + 72]> */
		/* 82108854h case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000048) );
		/* 82108854h case   38:*/		return 0x82108858;
		  /* 82108858h */ case   39:  		/* lwz R11, <#[R20 + 72]> */
		/* 82108858h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000048) );
		/* 82108858h case   39:*/		return 0x8210885C;
		  /* 8210885Ch */ case   40:  		/* cmplw CR6, R9, R11 */
		/* 8210885Ch case   40:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8210885Ch case   40:*/		return 0x82108860;
		  /* 82108860h */ case   41:  		/* bc 12, CR6_EQ, 592 */
		/* 82108860h case   41:*/		if ( regs.CR[6].eq ) { return 0x82108AB0;  }
		/* 82108860h case   41:*/		return 0x82108864;
		  /* 82108864h */ case   42:  		/* lwz R9, <#[R17 + 4]> */
		/* 82108864h case   42:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000004) );
		/* 82108864h case   42:*/		return 0x82108868;
		  /* 82108868h */ case   43:  		/* lwz R8, <#[R20 + 4]> */
		/* 82108868h case   43:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R20 + 0x00000004) );
		/* 82108868h case   43:*/		return 0x8210886C;
		  /* 8210886Ch */ case   44:  		/* cmplw CR6, R9, R8 */
		/* 8210886Ch case   44:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8210886Ch case   44:*/		return 0x82108870;
		  /* 82108870h */ case   45:  		/* bc 4, CR6_EQ, 576 */
		/* 82108870h case   45:*/		if ( !regs.CR[6].eq ) { return 0x82108AB0;  }
		/* 82108870h case   45:*/		return 0x82108874;
		  /* 82108874h */ case   46:  		/* lwz R9, <#[R17 + 20]> */
		/* 82108874h case   46:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000014) );
		/* 82108874h case   46:*/		return 0x82108878;
		  /* 82108878h */ case   47:  		/* lwz R8, <#[R20 + 20]> */
		/* 82108878h case   47:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R20 + 0x00000014) );
		/* 82108878h case   47:*/		return 0x8210887C;
		  /* 8210887Ch */ case   48:  		/* cmplw CR6, R9, R8 */
		/* 8210887Ch case   48:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8210887Ch case   48:*/		return 0x82108880;
		  /* 82108880h */ case   49:  		/* bc 4, CR6_EQ, 560 */
		/* 82108880h case   49:*/		if ( !regs.CR[6].eq ) { return 0x82108AB0;  }
		/* 82108880h case   49:*/		return 0x82108884;
		  /* 82108884h */ case   50:  		/* lwz R9, <#[R17 + 24]> */
		/* 82108884h case   50:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000018) );
		/* 82108884h case   50:*/		return 0x82108888;
		  /* 82108888h */ case   51:  		/* lwz R8, <#[R20 + 24]> */
		/* 82108888h case   51:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R20 + 0x00000018) );
		/* 82108888h case   51:*/		return 0x8210888C;
		  /* 8210888Ch */ case   52:  		/* cmpw CR6, R9, R8 */
		/* 8210888Ch case   52:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R8);
		/* 8210888Ch case   52:*/		return 0x82108890;
		  /* 82108890h */ case   53:  		/* bc 4, CR6_EQ, 544 */
		/* 82108890h case   53:*/		if ( !regs.CR[6].eq ) { return 0x82108AB0;  }
		/* 82108890h case   53:*/		return 0x82108894;
		  /* 82108894h */ case   54:  		/* lwz R9, <#[R21 + 24]> */
		/* 82108894h case   54:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R21 + 0x00000018) );
		/* 82108894h case   54:*/		return 0x82108898;
		  /* 82108898h */ case   55:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 82108898h case   55:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 82108898h case   55:*/		return 0x8210889C;
		  /* 8210889Ch */ case   56:  		/* lwz R11, <#[R16]> */
		/* 8210889Ch case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 8210889Ch case   56:*/		return 0x821088A0;
		  /* 821088A0h */ case   57:  		/* lwzx R9, <#[R8 + R9]> */
		/* 821088A0h case   57:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 821088A0h case   57:*/		return 0x821088A4;
		  /* 821088A4h */ case   58:  		/* lwz R9, <#[R9]> */
		/* 821088A4h case   58:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 821088A4h case   58:*/		return 0x821088A8;
		  /* 821088A8h */ case   59:  		/* xor R9, R9, R11 */
		/* 821088A8h case   59:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821088A8h case   59:*/		return 0x821088AC;
		  /* 821088ACh */ case   60:  		/* rlwinm. R9, R9, 0, 0, 11 */
		/* 821088ACh case   60:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R9,regs.R9);
		/* 821088ACh case   60:*/		return 0x821088B0;
		  /* 821088B0h */ case   61:  		/* bc 4, CR0_EQ, 512 */
		/* 821088B0h case   61:*/		if ( !regs.CR[0].eq ) { return 0x82108AB0;  }
		/* 821088B0h case   61:*/		return 0x821088B4;
		  /* 821088B4h */ case   62:  		/* lwz R10, <#[R16 + 4]> */
		/* 821088B4h case   62:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000004) );
		/* 821088B4h case   62:*/		return 0x821088B8;
		  /* 821088B8h */ case   63:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 821088B8h case   63:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 821088B8h case   63:*/		return 0x821088BC;
		  /* 821088BCh */ case   64:  		/* mr R3, R16 */
		/* 821088BCh case   64:*/		regs.R3 = regs.R16;
		/* 821088BCh case   64:*/		return 0x821088C0;
		  /* 821088C0h */ case   65:  		/* divwu R18, R10, R11 */
		/* 821088C0h case   65:*/		cpu::op::divwu<0>(regs,&regs.R18,regs.R10,regs.R11);
		/* 821088C0h case   65:*/		return 0x821088C4;
		  /* 821088C4h */ case   66:  		/* twi 6, R11, 0 */
		/* 821088C4h case   66:*/		cpu::op::tw<6>(regs, 0x821088C4, regs.R11, 0x00000000);
		/* 821088C4h case   66:*/		return 0x821088C8;
		  /* 821088C8h */ case   67:  		/* bl -51400 */
		/* 821088C8h case   67:*/		regs.LR = 0x821088CC; return 0x820FC000;
		/* 821088C8h case   67:*/		return 0x821088CC;
		  /* 821088CCh */ case   68:  		/* lwz R22, <#[R21 + 24]> */
		/* 821088CCh case   68:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R21 + 0x00000018) );
		/* 821088CCh case   68:*/		return 0x821088D0;
		  /* 821088D0h */ case   69:  		/* mr R7, R3 */
		/* 821088D0h case   69:*/		regs.R7 = regs.R3;
		/* 821088D0h case   69:*/		return 0x821088D4;
		  /* 821088D4h */ case   70:  		/* li R19, 0 */
		/* 821088D4h case   70:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 821088D4h case   70:*/		return 0x821088D8;
		  /* 821088D8h */ case   71:  		/* cmplwi CR6, R19, 0 */
		/* 821088D8h case   71:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 821088D8h case   71:*/		return 0x821088DC;
		  /* 821088DCh */ case   72:  		/* bc 12, CR6_EQ, 12 */
		/* 821088DCh case   72:*/		if ( regs.CR[6].eq ) { return 0x821088E8;  }
		/* 821088DCh case   72:*/		return 0x821088E0;
		  /* 821088E0h */ case   73:  		/* lwz R23, <#[R20 + 72]> */
		/* 821088E0h case   73:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R20 + 0x00000048) );
		/* 821088E0h case   73:*/		return 0x821088E4;
		  /* 821088E4h */ case   74:  		/* b 8 */
		/* 821088E4h case   74:*/		return 0x821088EC;
		/* 821088E4h case   74:*/		return 0x821088E8;
	}
	return 0x821088E8;
} // Block from 821087BCh-821088E8h (75 instructions)

//////////////////////////////////////////////////////
// Block at 821088E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821088E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821088E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821088E8);
		  /* 821088E8h */ case    0:  		/* lwz R23, <#[R17 + 72]> */
		/* 821088E8h case    0:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R17 + 0x00000048) );
		/* 821088E8h case    0:*/		return 0x821088EC;
	}
	return 0x821088EC;
} // Block from 821088E8h-821088ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821088ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821088EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821088EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821088EC);
		  /* 821088ECh */ case    0:  		/* cmplwi CR6, R19, 0 */
		/* 821088ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 821088ECh case    0:*/		return 0x821088F0;
		  /* 821088F0h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 821088F0h case    1:*/		if ( regs.CR[6].eq ) { return 0x821088FC;  }
		/* 821088F0h case    1:*/		return 0x821088F4;
		  /* 821088F4h */ case    2:  		/* lwz R11, <#[R17 + 72]> */
		/* 821088F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000048) );
		/* 821088F4h case    2:*/		return 0x821088F8;
		  /* 821088F8h */ case    3:  		/* b 8 */
		/* 821088F8h case    3:*/		return 0x82108900;
		/* 821088F8h case    3:*/		return 0x821088FC;
	}
	return 0x821088FC;
} // Block from 821088ECh-821088FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821088FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821088FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821088FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821088FC);
		  /* 821088FCh */ case    0:  		/* lwz R11, <#[R20 + 72]> */
		/* 821088FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000048) );
		/* 821088FCh case    0:*/		return 0x82108900;
	}
	return 0x82108900;
} // Block from 821088FCh-82108900h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82108900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108900);
		  /* 82108900h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82108900h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82108900h case    0:*/		return 0x82108904;
		  /* 82108904h */ case    1:  		/* rlwinm R10, R23, 2, 0, 29 */
		/* 82108904h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R23);
		/* 82108904h case    1:*/		return 0x82108908;
		  /* 82108908h */ case    2:  		/* li R29, 0 */
		/* 82108908h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82108908h case    2:*/		return 0x8210890C;
		  /* 8210890Ch */ case    3:  		/* lwzx R30, <#[R11 + R22]> */
		/* 8210890Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 8210890Ch case    3:*/		return 0x82108910;
		  /* 82108910h */ case    4:  		/* lwzx R27, <#[R10 + R22]> */
		/* 82108910h case    4:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + regs.R22 + 0x00000000) );
		/* 82108910h case    4:*/		return 0x82108914;
		  /* 82108914h */ case    5:  		/* lwz R25, <#[R30 + 12]> */
		/* 82108914h case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R30 + 0x0000000C) );
		/* 82108914h case    5:*/		return 0x82108918;
		  /* 82108918h */ case    6:  		/* cmplwi CR6, R25, 0 */
		/* 82108918h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82108918h case    6:*/		return 0x8210891C;
		  /* 8210891Ch */ case    7:  		/* bc 12, CR6_EQ, 176 */
		/* 8210891Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821089CC;  }
		/* 8210891Ch case    7:*/		return 0x82108920;
		  /* 82108920h */ case    8:  		/* lwz R24, <#[R21 + 20]> */
		/* 82108920h case    8:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R21 + 0x00000014) );
		/* 82108920h case    8:*/		return 0x82108924;
		  /* 82108924h */ case    9:  		/* lwz R26, <#[R30 + 16]> */
		/* 82108924h case    9:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R30 + 0x00000010) );
		/* 82108924h case    9:*/		return 0x82108928;
		  /* 82108928h */ case   10:  		/* lwz R11, <#[R26]> */
		/* 82108928h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82108928h case   10:*/		return 0x8210892C;
		  /* 8210892Ch */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210892Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210892Ch case   11:*/		return 0x82108930;
		  /* 82108930h */ case   12:  		/* lwzx R11, <#[R11 + R24]> */
		/* 82108930h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 82108930h case   12:*/		return 0x82108934;
		  /* 82108934h */ case   13:  		/* lwz R11, <#[R11 + 84]> */
		/* 82108934h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 82108934h case   13:*/		return 0x82108938;
		  /* 82108938h */ case   14:  		/* cmplw CR6, R11, R23 */
		/* 82108938h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 82108938h case   14:*/		return 0x8210893C;
		  /* 8210893Ch */ case   15:  		/* bc 4, CR6_GT, 144 */
		/* 8210893Ch case   15:*/		if ( !regs.CR[6].gt ) { return 0x821089CC;  }
		/* 8210893Ch case   15:*/		return 0x82108940;
		  /* 82108940h */ case   16:  		/* lwz R28, <#[R27 + 12]> */
		/* 82108940h case   16:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R27 + 0x0000000C) );
		/* 82108940h case   16:*/		return 0x82108944;
		  /* 82108944h */ case   17:  		/* li R31, 0 */
		/* 82108944h case   17:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82108944h case   17:*/		return 0x82108948;
		  /* 82108948h */ case   18:  		/* cmplwi CR6, R28, 0 */
		/* 82108948h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82108948h case   18:*/		return 0x8210894C;
		  /* 8210894Ch */ case   19:  		/* bc 12, CR6_EQ, 100 */
		/* 8210894Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x821089B0;  }
		/* 8210894Ch case   19:*/		return 0x82108950;
		  /* 82108950h */ case   20:  		/* li R5, 0 */
		/* 82108950h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82108950h case   20:*/		return 0x82108954;
		  /* 82108954h */ case   21:  		/* cmplwi CR6, R18, 0 */
		/* 82108954h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82108954h case   21:*/		return 0x82108958;
		  /* 82108958h */ case   22:  		/* bc 12, CR6_EQ, 68 */
		/* 82108958h case   22:*/		if ( regs.CR[6].eq ) { return 0x8210899C;  }
		/* 82108958h case   22:*/		return 0x8210895C;
		  /* 8210895Ch */ case   23:  		/* mr R6, R31 */
		/* 8210895Ch case   23:*/		regs.R6 = regs.R31;
		/* 8210895Ch case   23:*/		return 0x82108960;
		  /* 82108960h */ case   24:  		/* mr R4, R27 */
		/* 82108960h case   24:*/		regs.R4 = regs.R27;
		/* 82108960h case   24:*/		return 0x82108964;
		  /* 82108964h */ case   25:  		/* mr R3, R21 */
		/* 82108964h case   25:*/		regs.R3 = regs.R21;
		/* 82108964h case   25:*/		return 0x82108968;
		  /* 82108968h */ case   26:  		/* bl -43040 */
		/* 82108968h case   26:*/		regs.LR = 0x8210896C; return 0x820FE148;
		/* 82108968h case   26:*/		return 0x8210896C;
		  /* 8210896Ch */ case   27:  		/* mr R11, R3 */
		/* 8210896Ch case   27:*/		regs.R11 = regs.R3;
		/* 8210896Ch case   27:*/		return 0x82108970;
		  /* 82108970h */ case   28:  		/* mr R6, R29 */
		/* 82108970h case   28:*/		regs.R6 = regs.R29;
		/* 82108970h case   28:*/		return 0x82108974;
		  /* 82108974h */ case   29:  		/* mr R4, R30 */
		/* 82108974h case   29:*/		regs.R4 = regs.R30;
		/* 82108974h case   29:*/		return 0x82108978;
		  /* 82108978h */ case   30:  		/* stw R11, <#[R1 + 108]> */
		/* 82108978h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82108978h case   30:*/		return 0x8210897C;
		  /* 8210897Ch */ case   31:  		/* mr R3, R21 */
		/* 8210897Ch case   31:*/		regs.R3 = regs.R21;
		/* 8210897Ch case   31:*/		return 0x82108980;
		  /* 82108980h */ case   32:  		/* bl -43064 */
		/* 82108980h case   32:*/		regs.LR = 0x82108984; return 0x820FE148;
		/* 82108980h case   32:*/		return 0x82108984;
		  /* 82108984h */ case   33:  		/* lwz R11, <#[R1 + 108]> */
		/* 82108984h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82108984h case   33:*/		return 0x82108988;
		  /* 82108988h */ case   34:  		/* cmplw CR6, R11, R3 */
		/* 82108988h case   34:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 82108988h case   34:*/		return 0x8210898C;
		  /* 8210898Ch */ case   35:  		/* bc 4, CR6_EQ, 16 */
		/* 8210898Ch case   35:*/		if ( !regs.CR[6].eq ) { return 0x8210899C;  }
		/* 8210898Ch case   35:*/		return 0x82108990;
		  /* 82108990h */ case   36:  		/* addi R5, R5, 1 */
		/* 82108990h case   36:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82108990h case   36:*/		return 0x82108994;
		  /* 82108994h */ case   37:  		/* cmplw CR6, R5, R18 */
		/* 82108994h case   37:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R18);
		/* 82108994h case   37:*/		return 0x82108998;
		  /* 82108998h */ case   38:  		/* bc 12, CR6_LT, -60 */
		/* 82108998h case   38:*/		if ( regs.CR[6].lt ) { return 0x8210895C;  }
		/* 82108998h case   38:*/		return 0x8210899C;
	}
	return 0x8210899C;
} // Block from 82108900h-8210899Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 8210899Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210899C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210899C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210899C);
		  /* 8210899Ch */ case    0:  		/* cmplw CR6, R5, R18 */
		/* 8210899Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R18);
		/* 8210899Ch case    0:*/		return 0x821089A0;
		  /* 821089A0h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 821089A0h case    1:*/		if ( regs.CR[6].eq ) { return 0x821089B0;  }
		/* 821089A0h case    1:*/		return 0x821089A4;
		  /* 821089A4h */ case    2:  		/* addi R31, R31, 1 */
		/* 821089A4h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821089A4h case    2:*/		return 0x821089A8;
		  /* 821089A8h */ case    3:  		/* cmplw CR6, R31, R28 */
		/* 821089A8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 821089A8h case    3:*/		return 0x821089AC;
		  /* 821089ACh */ case    4:  		/* bc 12, CR6_LT, -92 */
		/* 821089ACh case    4:*/		if ( regs.CR[6].lt ) { return 0x82108950;  }
		/* 821089ACh case    4:*/		return 0x821089B0;
	}
	return 0x821089B0;
} // Block from 8210899Ch-821089B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821089B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821089B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821089B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821089B0);
		  /* 821089B0h */ case    0:  		/* cmplw CR6, R31, R28 */
		/* 821089B0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R28);
		/* 821089B0h case    0:*/		return 0x821089B4;
		  /* 821089B4h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821089B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821089CC;  }
		/* 821089B4h case    1:*/		return 0x821089B8;
		  /* 821089B8h */ case    2:  		/* lwz R11, <#[R30 + 12]> */
		/* 821089B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 821089B8h case    2:*/		return 0x821089BC;
		  /* 821089BCh */ case    3:  		/* addi R29, R29, 1 */
		/* 821089BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821089BCh case    3:*/		return 0x821089C0;
		  /* 821089C0h */ case    4:  		/* addi R26, R26, 4 */
		/* 821089C0h case    4:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 821089C0h case    4:*/		return 0x821089C4;
		  /* 821089C4h */ case    5:  		/* cmplw CR6, R29, R11 */
		/* 821089C4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821089C4h case    5:*/		return 0x821089C8;
		  /* 821089C8h */ case    6:  		/* bc 12, CR6_LT, -160 */
		/* 821089C8h case    6:*/		if ( regs.CR[6].lt ) { return 0x82108928;  }
		/* 821089C8h case    6:*/		return 0x821089CC;
	}
	return 0x821089CC;
} // Block from 821089B0h-821089CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821089CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821089CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821089CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821089CC);
		  /* 821089CCh */ case    0:  		/* cmplw CR6, R29, R25 */
		/* 821089CCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R25);
		/* 821089CCh case    0:*/		return 0x821089D0;
		  /* 821089D0h */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 821089D0h case    1:*/		if ( !regs.CR[6].lt ) { return 0x821089E4;  }
		/* 821089D0h case    1:*/		return 0x821089D4;
		  /* 821089D4h */ case    2:  		/* addi R19, R19, 1 */
		/* 821089D4h case    2:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 821089D4h case    2:*/		return 0x821089D8;
		  /* 821089D8h */ case    3:  		/* cmplwi CR6, R19, 2 */
		/* 821089D8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000002);
		/* 821089D8h case    3:*/		return 0x821089DC;
		  /* 821089DCh */ case    4:  		/* bc 12, CR6_LT, -260 */
		/* 821089DCh case    4:*/		if ( regs.CR[6].lt ) { return 0x821088D8;  }
		/* 821089DCh case    4:*/		return 0x821089E0;
		  /* 821089E0h */ case    5:  		/* b 196 */
		/* 821089E0h case    5:*/		return 0x82108AA4;
		/* 821089E0h case    5:*/		return 0x821089E4;
	}
	return 0x821089E4;
} // Block from 821089CCh-821089E4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821089E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821089E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821089E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821089E4);
		  /* 821089E4h */ case    0:  		/* li R29, 0 */
		/* 821089E4h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821089E4h case    0:*/		return 0x821089E8;
		  /* 821089E8h */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 821089E8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821089E8h case    1:*/		return 0x821089EC;
		  /* 821089ECh */ case    2:  		/* bc 12, CR6_EQ, 168 */
		/* 821089ECh case    2:*/		if ( regs.CR[6].eq ) { return 0x82108A94;  }
		/* 821089ECh case    2:*/		return 0x821089F0;
		  /* 821089F0h */ case    3:  		/* li R28, 0 */
		/* 821089F0h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821089F0h case    3:*/		return 0x821089F4;
		  /* 821089F4h */ case    4:  		/* lwz R26, <#[R27 + 12]> */
		/* 821089F4h case    4:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R27 + 0x0000000C) );
		/* 821089F4h case    4:*/		return 0x821089F8;
		  /* 821089F8h */ case    5:  		/* li R31, 0 */
		/* 821089F8h case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821089F8h case    5:*/		return 0x821089FC;
		  /* 821089FCh */ case    6:  		/* cmplwi CR6, R26, 0 */
		/* 821089FCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821089FCh case    6:*/		return 0x82108A00;
		  /* 82108A00h */ case    7:  		/* bc 12, CR6_EQ, 92 */
		/* 82108A00h case    7:*/		if ( regs.CR[6].eq ) { return 0x82108A5C;  }
		/* 82108A00h case    7:*/		return 0x82108A04;
		  /* 82108A04h */ case    8:  		/* li R5, 0 */
		/* 82108A04h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82108A04h case    8:*/		return 0x82108A08;
		  /* 82108A08h */ case    9:  		/* cmplwi CR6, R18, 0 */
		/* 82108A08h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82108A08h case    9:*/		return 0x82108A0C;
		  /* 82108A0Ch */ case   10:  		/* bc 12, CR6_EQ, 60 */
		/* 82108A0Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82108A48;  }
		/* 82108A0Ch case   10:*/		return 0x82108A10;
		  /* 82108A10h */ case   11:  		/* mr R6, R29 */
		/* 82108A10h case   11:*/		regs.R6 = regs.R29;
		/* 82108A10h case   11:*/		return 0x82108A14;
		  /* 82108A14h */ case   12:  		/* mr R4, R30 */
		/* 82108A14h case   12:*/		regs.R4 = regs.R30;
		/* 82108A14h case   12:*/		return 0x82108A18;
		  /* 82108A18h */ case   13:  		/* mr R3, R21 */
		/* 82108A18h case   13:*/		regs.R3 = regs.R21;
		/* 82108A18h case   13:*/		return 0x82108A1C;
		  /* 82108A1Ch */ case   14:  		/* bl -43220 */
		/* 82108A1Ch case   14:*/		regs.LR = 0x82108A20; return 0x820FE148;
		/* 82108A1Ch case   14:*/		return 0x82108A20;
		  /* 82108A20h */ case   15:  		/* mr R25, R3 */
		/* 82108A20h case   15:*/		regs.R25 = regs.R3;
		/* 82108A20h case   15:*/		return 0x82108A24;
		  /* 82108A24h */ case   16:  		/* mr R6, R31 */
		/* 82108A24h case   16:*/		regs.R6 = regs.R31;
		/* 82108A24h case   16:*/		return 0x82108A28;
		  /* 82108A28h */ case   17:  		/* mr R4, R27 */
		/* 82108A28h case   17:*/		regs.R4 = regs.R27;
		/* 82108A28h case   17:*/		return 0x82108A2C;
		  /* 82108A2Ch */ case   18:  		/* mr R3, R21 */
		/* 82108A2Ch case   18:*/		regs.R3 = regs.R21;
		/* 82108A2Ch case   18:*/		return 0x82108A30;
		  /* 82108A30h */ case   19:  		/* bl -43240 */
		/* 82108A30h case   19:*/		regs.LR = 0x82108A34; return 0x820FE148;
		/* 82108A30h case   19:*/		return 0x82108A34;
		  /* 82108A34h */ case   20:  		/* cmplw CR6, R3, R25 */
		/* 82108A34h case   20:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R25);
		/* 82108A34h case   20:*/		return 0x82108A38;
		  /* 82108A38h */ case   21:  		/* bc 4, CR6_EQ, 16 */
		/* 82108A38h case   21:*/		if ( !regs.CR[6].eq ) { return 0x82108A48;  }
		/* 82108A38h case   21:*/		return 0x82108A3C;
		  /* 82108A3Ch */ case   22:  		/* addi R5, R5, 1 */
		/* 82108A3Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82108A3Ch case   22:*/		return 0x82108A40;
		  /* 82108A40h */ case   23:  		/* cmplw CR6, R5, R18 */
		/* 82108A40h case   23:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R18);
		/* 82108A40h case   23:*/		return 0x82108A44;
		  /* 82108A44h */ case   24:  		/* bc 12, CR6_LT, -52 */
		/* 82108A44h case   24:*/		if ( regs.CR[6].lt ) { return 0x82108A10;  }
		/* 82108A44h case   24:*/		return 0x82108A48;
	}
	return 0x82108A48;
} // Block from 821089E4h-82108A48h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82108A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108A48);
		  /* 82108A48h */ case    0:  		/* cmplw CR6, R5, R18 */
		/* 82108A48h case    0:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R18);
		/* 82108A48h case    0:*/		return 0x82108A4C;
		  /* 82108A4Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 82108A4Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82108A5C;  }
		/* 82108A4Ch case    1:*/		return 0x82108A50;
		  /* 82108A50h */ case    2:  		/* addi R31, R31, 1 */
		/* 82108A50h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82108A50h case    2:*/		return 0x82108A54;
		  /* 82108A54h */ case    3:  		/* cmplw CR6, R31, R26 */
		/* 82108A54h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 82108A54h case    3:*/		return 0x82108A58;
		  /* 82108A58h */ case    4:  		/* bc 12, CR6_LT, -84 */
		/* 82108A58h case    4:*/		if ( regs.CR[6].lt ) { return 0x82108A04;  }
		/* 82108A58h case    4:*/		return 0x82108A5C;
	}
	return 0x82108A5C;
} // Block from 82108A48h-82108A5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82108A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108A5C);
		  /* 82108A5Ch */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 82108A5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82108A5Ch case    0:*/		return 0x82108A60;
		  /* 82108A60h */ case    1:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82108A60h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82108A60h case    1:*/		return 0x82108A64;
		  /* 82108A64h */ case    2:  		/* lwz R9, <#[R27 + 16]> */
		/* 82108A64h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000010) );
		/* 82108A64h case    2:*/		return 0x82108A68;
		  /* 82108A68h */ case    3:  		/* addi R29, R29, 1 */
		/* 82108A68h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82108A68h case    3:*/		return 0x82108A6C;
		  /* 82108A6Ch */ case    4:  		/* lwz R8, <#[R21 + 20]> */
		/* 82108A6Ch case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R21 + 0x00000014) );
		/* 82108A6Ch case    4:*/		return 0x82108A70;
		  /* 82108A70h */ case    5:  		/* lwzx R11, <#[R11 + R28]> */
		/* 82108A70h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82108A70h case    5:*/		return 0x82108A74;
		  /* 82108A74h */ case    6:  		/* addi R28, R28, 4 */
		/* 82108A74h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82108A74h case    6:*/		return 0x82108A78;
		  /* 82108A78h */ case    7:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82108A78h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82108A78h case    7:*/		return 0x82108A7C;
		  /* 82108A7Ch */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82108A7Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82108A7Ch case    8:*/		return 0x82108A80;
		  /* 82108A80h */ case    9:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82108A80h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82108A80h case    9:*/		return 0x82108A84;
		  /* 82108A84h */ case   10:  		/* stw R10, <#[R11 + 48]> */
		/* 82108A84h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82108A84h case   10:*/		return 0x82108A88;
		  /* 82108A88h */ case   11:  		/* lwz R11, <#[R30 + 12]> */
		/* 82108A88h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82108A88h case   11:*/		return 0x82108A8C;
		  /* 82108A8Ch */ case   12:  		/* cmplw CR6, R29, R11 */
		/* 82108A8Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82108A8Ch case   12:*/		return 0x82108A90;
		  /* 82108A90h */ case   13:  		/* bc 12, CR6_LT, -156 */
		/* 82108A90h case   13:*/		if ( regs.CR[6].lt ) { return 0x821089F4;  }
		/* 82108A90h case   13:*/		return 0x82108A94;
	}
	return 0x82108A94;
} // Block from 82108A5Ch-82108A94h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82108A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108A94);
		  /* 82108A94h */ case    0:  		/* li R11, 1 */
		/* 82108A94h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82108A94h case    0:*/		return 0x82108A98;
		  /* 82108A98h */ case    1:  		/* li R9, 0 */
		/* 82108A98h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82108A98h case    1:*/		return 0x82108A9C;
		  /* 82108A9Ch */ case    2:  		/* stw R11, <#[R1 + 104]> */
		/* 82108A9Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82108A9Ch case    2:*/		return 0x82108AA0;
		  /* 82108AA0h */ case    3:  		/* stw R9, <#[R30]> */
		/* 82108AA0h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82108AA0h case    3:*/		return 0x82108AA4;
	}
	return 0x82108AA4;
} // Block from 82108A94h-82108AA4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82108AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108AA4);
		  /* 82108AA4h */ case    0:  		/* lwz R22, <#[R1 + 92]> */
		/* 82108AA4h case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x0000005C) );
		/* 82108AA4h case    0:*/		return 0x82108AA8;
		  /* 82108AA8h */ case    1:  		/* lwz R23, <#[R1 + 80]> */
		/* 82108AA8h case    1:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x00000050) );
		/* 82108AA8h case    1:*/		return 0x82108AAC;
		  /* 82108AACh */ case    2:  		/* lwz R10, <#[R1 + 84]> */
		/* 82108AACh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82108AACh case    2:*/		return 0x82108AB0;
	}
	return 0x82108AB0;
} // Block from 82108AA4h-82108AB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82108AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108AB0);
		  /* 82108AB0h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 82108AB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82108AB0h case    0:*/		return 0x82108AB4;
		  /* 82108AB4h */ case    1:  		/* addi R15, R15, 4 */
		/* 82108AB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R15,0x4);
		/* 82108AB4h case    1:*/		return 0x82108AB8;
		  /* 82108AB8h */ case    2:  		/* addi R11, R11, 1 */
		/* 82108AB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82108AB8h case    2:*/		return 0x82108ABC;
		  /* 82108ABCh */ case    3:  		/* stw R11, <#[R1 + 96]> */
		/* 82108ABCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82108ABCh case    3:*/		return 0x82108AC0;
		  /* 82108AC0h */ case    4:  		/* cmplw CR6, R11, R23 */
		/* 82108AC0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 82108AC0h case    4:*/		return 0x82108AC4;
		  /* 82108AC4h */ case    5:  		/* bc 12, CR6_LT, -668 */
		/* 82108AC4h case    5:*/		if ( regs.CR[6].lt ) { return 0x82108828;  }
		/* 82108AC4h case    5:*/		return 0x82108AC8;
	}
	return 0x82108AC8;
} // Block from 82108AB0h-82108AC8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82108AC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108AC8);
		  /* 82108AC8h */ case    0:  		/* lwz R11, <#[R1 + 100]> */
		/* 82108AC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82108AC8h case    0:*/		return 0x82108ACC;
		  /* 82108ACCh */ case    1:  		/* addi R10, R10, 1 */
		/* 82108ACCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82108ACCh case    1:*/		return 0x82108AD0;
		  /* 82108AD0h */ case    2:  		/* addi R14, R14, 4 */
		/* 82108AD0h case    2:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R14,0x4);
		/* 82108AD0h case    2:*/		return 0x82108AD4;
		  /* 82108AD4h */ case    3:  		/* addic. R11, R11, -1 */
		/* 82108AD4h case    3:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82108AD4h case    3:*/		return 0x82108AD8;
		  /* 82108AD8h */ case    4:  		/* stw R10, <#[R1 + 84]> */
		/* 82108AD8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82108AD8h case    4:*/		return 0x82108ADC;
		  /* 82108ADCh */ case    5:  		/* stw R11, <#[R1 + 100]> */
		/* 82108ADCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82108ADCh case    5:*/		return 0x82108AE0;
		  /* 82108AE0h */ case    6:  		/* bc 4, CR0_EQ, -756 */
		/* 82108AE0h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821087EC;  }
		/* 82108AE0h case    6:*/		return 0x82108AE4;
		  /* 82108AE4h */ case    7:  		/* lwz R11, <#[R1 + 104]> */
		/* 82108AE4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82108AE4h case    7:*/		return 0x82108AE8;
		  /* 82108AE8h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 82108AE8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82108AE8h case    8:*/		return 0x82108AEC;
		  /* 82108AECh */ case    9:  		/* bc 12, CR6_EQ, 124 */
		/* 82108AECh case    9:*/		if ( regs.CR[6].eq ) { return 0x82108B68;  }
		/* 82108AECh case    9:*/		return 0x82108AF0;
		  /* 82108AF0h */ case   10:  		/* lwz R11, <#[R21 + 8]> */
		/* 82108AF0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 82108AF0h case   10:*/		return 0x82108AF4;
		  /* 82108AF4h */ case   11:  		/* li R8, 0 */
		/* 82108AF4h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82108AF4h case   11:*/		return 0x82108AF8;
		  /* 82108AF8h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 82108AF8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82108AF8h case   12:*/		return 0x82108AFC;
		  /* 82108AFCh */ case   13:  		/* bc 4, CR6_GT, 88 */
		/* 82108AFCh case   13:*/		if ( !regs.CR[6].gt ) { return 0x82108B54;  }
		/* 82108AFCh case   13:*/		return 0x82108B00;
		  /* 82108B00h */ case   14:  		/* lwz R11, <#[R21 + 20]> */
		/* 82108B00h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000014) );
		/* 82108B00h case   14:*/		return 0x82108B04;
		  /* 82108B04h */ case   15:  		/* li R9, 0 */
		/* 82108B04h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82108B04h case   15:*/		return 0x82108B08;
		  /* 82108B08h */ case   16:  		/* lwzx R10, <#[R11 + R9]> */
		/* 82108B08h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82108B08h case   16:*/		return 0x82108B0C;
		  /* 82108B0Ch */ case   17:  		/* b 28 */
		/* 82108B0Ch case   17:*/		return 0x82108B28;
		/* 82108B0Ch case   17:*/		return 0x82108B10;
		  /* 82108B10h */ case   18:  		/* lwz R7, <#[R10 + 48]> */
		/* 82108B10h case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000030) );
		/* 82108B10h case   18:*/		return 0x82108B14;
		  /* 82108B14h */ case   19:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82108B14h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82108B14h case   19:*/		return 0x82108B18;
		  /* 82108B18h */ case   20:  		/* lwzx R11, <#[R7 + R11]> */
		/* 82108B18h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82108B18h case   20:*/		return 0x82108B1C;
		  /* 82108B1Ch */ case   21:  		/* lwz R11, <#[R11 + 48]> */
		/* 82108B1Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 82108B1Ch case   21:*/		return 0x82108B20;
		  /* 82108B20h */ case   22:  		/* stw R11, <#[R10 + 48]> */
		/* 82108B20h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000030) );
		/* 82108B20h case   22:*/		return 0x82108B24;
		  /* 82108B24h */ case   23:  		/* lwz R11, <#[R21 + 20]> */
		/* 82108B24h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000014) );
		/* 82108B24h case   23:*/		return 0x82108B28;
	}
	return 0x82108B28;
} // Block from 82108AC8h-82108B28h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82108B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108B28);
		  /* 82108B28h */ case    0:  		/* lwz R7, <#[R10 + 48]> */
		/* 82108B28h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000030) );
		/* 82108B28h case    0:*/		return 0x82108B2C;
		  /* 82108B2Ch */ case    1:  		/* rlwinm R6, R7, 2, 0, 29 */
		/* 82108B2Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R7);
		/* 82108B2Ch case    1:*/		return 0x82108B30;
		  /* 82108B30h */ case    2:  		/* lwzx R6, <#[R6 + R11]> */
		/* 82108B30h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82108B30h case    2:*/		return 0x82108B34;
		  /* 82108B34h */ case    3:  		/* lwz R6, <#[R6 + 48]> */
		/* 82108B34h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000030) );
		/* 82108B34h case    3:*/		return 0x82108B38;
		  /* 82108B38h */ case    4:  		/* cmplw CR6, R7, R6 */
		/* 82108B38h case    4:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 82108B38h case    4:*/		return 0x82108B3C;
		  /* 82108B3Ch */ case    5:  		/* bc 4, CR6_EQ, -44 */
		/* 82108B3Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82108B10;  }
		/* 82108B3Ch case    5:*/		return 0x82108B40;
		  /* 82108B40h */ case    6:  		/* lwz R10, <#[R21 + 8]> */
		/* 82108B40h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000008) );
		/* 82108B40h case    6:*/		return 0x82108B44;
		  /* 82108B44h */ case    7:  		/* addi R8, R8, 1 */
		/* 82108B44h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82108B44h case    7:*/		return 0x82108B48;
		  /* 82108B48h */ case    8:  		/* addi R9, R9, 4 */
		/* 82108B48h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82108B48h case    8:*/		return 0x82108B4C;
		  /* 82108B4Ch */ case    9:  		/* cmplw CR6, R8, R10 */
		/* 82108B4Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 82108B4Ch case    9:*/		return 0x82108B50;
		  /* 82108B50h */ case   10:  		/* bc 12, CR6_LT, -72 */
		/* 82108B50h case   10:*/		if ( regs.CR[6].lt ) { return 0x82108B08;  }
		/* 82108B50h case   10:*/		return 0x82108B54;
	}
	return 0x82108B54;
} // Block from 82108B28h-82108B54h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82108B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108B54);
		  /* 82108B54h */ case    0:  		/* mr R3, R21 */
		/* 82108B54h case    0:*/		regs.R3 = regs.R21;
		/* 82108B54h case    0:*/		return 0x82108B58;
		  /* 82108B58h */ case    1:  		/* bl -10040 */
		/* 82108B58h case    1:*/		regs.LR = 0x82108B5C; return 0x82106420;
		/* 82108B58h case    1:*/		return 0x82108B5C;
		  /* 82108B5Ch */ case    2:  		/* lwz R11, <#[R1 + 88]> */
		/* 82108B5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82108B5Ch case    2:*/		return 0x82108B60;
		  /* 82108B60h */ case    3:  		/* addi R11, R11, 1 */
		/* 82108B60h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82108B60h case    3:*/		return 0x82108B64;
		  /* 82108B64h */ case    4:  		/* b -1424 */
		/* 82108B64h case    4:*/		return 0x821085D4;
		/* 82108B64h case    4:*/		return 0x82108B68;
	}
	return 0x82108B68;
} // Block from 82108B54h-82108B68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82108B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108B68);
		  /* 82108B68h */ case    0:  		/* lwz R11, <#[R1 + 88]> */
		/* 82108B68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82108B68h case    0:*/		return 0x82108B6C;
		  /* 82108B6Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 82108B6Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82108B6Ch case    1:*/		return 0x82108B70;
		  /* 82108B70h */ case    2:  		/* rlwinm R31, R11, 27, 31, 31 */
		/* 82108B70h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R31,regs.R11);
		/* 82108B70h case    2:*/		return 0x82108B74;
	}
	return 0x82108B74;
} // Block from 82108B68h-82108B74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82108B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108B74);
		  /* 82108B74h */ case    0:  		/* lis R4, 9345 */
		/* 82108B74h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 82108B74h case    0:*/		return 0x82108B78;
		  /* 82108B78h */ case    1:  		/* mr R3, R22 */
		/* 82108B78h case    1:*/		regs.R3 = regs.R22;
		/* 82108B78h case    1:*/		return 0x82108B7C;
		  /* 82108B7Ch */ case    2:  		/* bl -526404 */
		/* 82108B7Ch case    2:*/		regs.LR = 0x82108B80; return 0x82088338;
		/* 82108B7Ch case    2:*/		return 0x82108B80;
		  /* 82108B80h */ case    3:  		/* mr R3, R31 */
		/* 82108B80h case    3:*/		regs.R3 = regs.R31;
		/* 82108B80h case    3:*/		return 0x82108B84;
		  /* 82108B84h */ case    4:  		/* addi R1, R1, 272 */
		/* 82108B84h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 82108B84h case    4:*/		return 0x82108B88;
		  /* 82108B88h */ case    5:  		/* b -489752 */
		/* 82108B88h case    5:*/		return 0x82091270;
		/* 82108B88h case    5:*/		return 0x82108B8C;
		  /* 82108B8Ch */ case    6:  		/* nop */
		/* 82108B8Ch case    6:*/		cpu::op::nop();
		/* 82108B8Ch case    6:*/		return 0x82108B90;
	}
	return 0x82108B90;
} // Block from 82108B74h-82108B90h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82108B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108B90);
		  /* 82108B90h */ case    0:  		/* mfspr R12, LR */
		/* 82108B90h case    0:*/		regs.R12 = regs.LR;
		/* 82108B90h case    0:*/		return 0x82108B94;
		  /* 82108B94h */ case    1:  		/* bl -489844 */
		/* 82108B94h case    1:*/		regs.LR = 0x82108B98; return 0x82091220;
		/* 82108B94h case    1:*/		return 0x82108B98;
		  /* 82108B98h */ case    2:  		/* stfd FR30, <#[R1 - 168]> */
		/* 82108B98h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 82108B98h case    2:*/		return 0x82108B9C;
		  /* 82108B9Ch */ case    3:  		/* stfd FR31, <#[R1 - 160]> */
		/* 82108B9Ch case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 82108B9Ch case    3:*/		return 0x82108BA0;
		  /* 82108BA0h */ case    4:  		/* stwu R1, <#[R1 - 256]> */
		/* 82108BA0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 82108BA0h case    4:*/		return 0x82108BA4;
		  /* 82108BA4h */ case    5:  		/* mr R16, R3 */
		/* 82108BA4h case    5:*/		regs.R16 = regs.R3;
		/* 82108BA4h case    5:*/		return 0x82108BA8;
		  /* 82108BA8h */ case    6:  		/* bl -12304 */
		/* 82108BA8h case    6:*/		regs.LR = 0x82108BAC; return 0x82105B98;
		/* 82108BA8h case    6:*/		return 0x82108BAC;
		  /* 82108BACh */ case    7:  		/* lwz R10, <#[R16 + 8]> */
		/* 82108BACh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000008) );
		/* 82108BACh case    7:*/		return 0x82108BB0;
		  /* 82108BB0h */ case    8:  		/* li R14, 0 */
		/* 82108BB0h case    8:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 82108BB0h case    8:*/		return 0x82108BB4;
		  /* 82108BB4h */ case    9:  		/* mr R11, R14 */
		/* 82108BB4h case    9:*/		regs.R11 = regs.R14;
		/* 82108BB4h case    9:*/		return 0x82108BB8;
		  /* 82108BB8h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 82108BB8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82108BB8h case   10:*/		return 0x82108BBC;
		  /* 82108BBCh */ case   11:  		/* bc 4, CR6_GT, 40 */
		/* 82108BBCh case   11:*/		if ( !regs.CR[6].gt ) { return 0x82108BE4;  }
		/* 82108BBCh case   11:*/		return 0x82108BC0;
		  /* 82108BC0h */ case   12:  		/* mr R10, R14 */
		/* 82108BC0h case   12:*/		regs.R10 = regs.R14;
		/* 82108BC0h case   12:*/		return 0x82108BC4;
		  /* 82108BC4h */ case   13:  		/* lwz R9, <#[R16 + 20]> */
		/* 82108BC4h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R16 + 0x00000014) );
		/* 82108BC4h case   13:*/		return 0x82108BC8;
		  /* 82108BC8h */ case   14:  		/* lwzx R9, <#[R10 + R9]> */
		/* 82108BC8h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82108BC8h case   14:*/		return 0x82108BCC;
		  /* 82108BCCh */ case   15:  		/* addi R10, R10, 4 */
		/* 82108BCCh case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82108BCCh case   15:*/		return 0x82108BD0;
		  /* 82108BD0h */ case   16:  		/* stw R11, <#[R9 + 48]> */
		/* 82108BD0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 82108BD0h case   16:*/		return 0x82108BD4;
		  /* 82108BD4h */ case   17:  		/* addi R11, R11, 1 */
		/* 82108BD4h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82108BD4h case   17:*/		return 0x82108BD8;
		  /* 82108BD8h */ case   18:  		/* lwz R9, <#[R16 + 8]> */
		/* 82108BD8h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R16 + 0x00000008) );
		/* 82108BD8h case   18:*/		return 0x82108BDC;
		  /* 82108BDCh */ case   19:  		/* cmplw CR6, R11, R9 */
		/* 82108BDCh case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82108BDCh case   19:*/		return 0x82108BE0;
	}
	return 0x82108BE0;
} // Block from 82108B90h-82108BE0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82108BE0h
// Function '?RemoveDuplicateInstructions@CProgram@D3DXShader@@IAAJH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108BE0);
		  /* 82108BE0h */ case    0:  		/* bc 12, CR6_LT, -28 */
		/* 82108BE0h case    0:*/		if ( regs.CR[6].lt ) { return 0x82108BC4;  }
		/* 82108BE0h case    0:*/		return 0x82108BE4;
	}
	return 0x82108BE4;
} // Block from 82108BE0h-82108BE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82108BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108BE4);
		  /* 82108BE4h */ case    0:  		/* lis R11, -32256 */
		/* 82108BE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82108BE4h case    0:*/		return 0x82108BE8;
		  /* 82108BE8h */ case    1:  		/* lwz R10, <#[R16 + 12]> */
		/* 82108BE8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x0000000C) );
		/* 82108BE8h case    1:*/		return 0x82108BEC;
		  /* 82108BECh */ case    2:  		/* lis R9, -32256 */
		/* 82108BECh case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82108BECh case    2:*/		return 0x82108BF0;
		  /* 82108BF0h */ case    3:  		/* li R20, -1 */
		/* 82108BF0h case    3:*/		cpu::op::li<0>(regs,&regs.R20,0xFFFFFFFF);
		/* 82108BF0h case    3:*/		return 0x82108BF4;
		  /* 82108BF4h */ case    4:  		/* mr R15, R14 */
		/* 82108BF4h case    4:*/		regs.R15 = regs.R14;
		/* 82108BF4h case    4:*/		return 0x82108BF8;
		  /* 82108BF8h */ case    5:  		/* mr R19, R20 */
		/* 82108BF8h case    5:*/		regs.R19 = regs.R20;
		/* 82108BF8h case    5:*/		return 0x82108BFC;
		  /* 82108BFCh */ case    6:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 82108BFCh case    6:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 82108BFCh case    6:*/		return 0x82108C00;
		  /* 82108C00h */ case    7:  		/* mr R18, R14 */
		/* 82108C00h case    7:*/		regs.R18 = regs.R14;
		/* 82108C00h case    7:*/		return 0x82108C04;
		  /* 82108C04h */ case    8:  		/* lfd FR30, <#[R9 + 1848]> */
		/* 82108C04h case    8:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R9 + 0x00000738) );
		/* 82108C04h case    8:*/		return 0x82108C08;
		  /* 82108C08h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 82108C08h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82108C08h case    9:*/		return 0x82108C0C;
		  /* 82108C0Ch */ case   10:  		/* bc 4, CR6_GT, 708 */
		/* 82108C0Ch case   10:*/		if ( !regs.CR[6].gt ) { return 0x82108ED0;  }
		/* 82108C0Ch case   10:*/		return 0x82108C10;
		  /* 82108C10h */ case   11:  		/* mr R17, R14 */
		/* 82108C10h case   11:*/		regs.R17 = regs.R14;
		/* 82108C10h case   11:*/		return 0x82108C14;
		  /* 82108C14h */ case   12:  		/* lwz R11, <#[R16 + 24]> */
		/* 82108C14h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000018) );
		/* 82108C14h case   12:*/		return 0x82108C18;
		  /* 82108C18h */ case   13:  		/* lwzx R30, <#[R17 + R11]> */
		/* 82108C18h case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 82108C18h case   13:*/		return 0x82108C1C;
		  /* 82108C1Ch */ case   14:  		/* lwz R11, <#[R30]> */
		/* 82108C1Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82108C1Ch case   14:*/		return 0x82108C20;
		  /* 82108C20h */ case   15:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 82108C20h case   15:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 82108C20h case   15:*/		return 0x82108C24;
		  /* 82108C24h */ case   16:  		/* bc 12, CR0_EQ, 664 */
		/* 82108C24h case   16:*/		if ( regs.CR[0].eq ) { return 0x82108EBC;  }
		/* 82108C24h case   16:*/		return 0x82108C28;
		  /* 82108C28h */ case   17:  		/* rlwinm R10, R11, 0, 0, 3 */
		/* 82108C28h case   17:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R11);
		/* 82108C28h case   17:*/		return 0x82108C2C;
		  /* 82108C2Ch */ case   18:  		/* lis R9, 4096 */
		/* 82108C2Ch case   18:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 82108C2Ch case   18:*/		return 0x82108C30;
		  /* 82108C30h */ case   19:  		/* cmplw CR6, R10, R9 */
		/* 82108C30h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82108C30h case   19:*/		return 0x82108C34;
		  /* 82108C34h */ case   20:  		/* bc 12, CR6_LT, 648 */
		/* 82108C34h case   20:*/		if ( regs.CR[6].lt ) { return 0x82108EBC;  }
		/* 82108C34h case   20:*/		return 0x82108C38;
		  /* 82108C38h */ case   21:  		/* lis R9, 16384 */
		/* 82108C38h case   21:*/		cpu::op::lis<0>(regs,&regs.R9,0x4000);
		/* 82108C38h case   21:*/		return 0x82108C3C;
		  /* 82108C3Ch */ case   22:  		/* cmplw CR6, R10, R9 */
		/* 82108C3Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82108C3Ch case   22:*/		return 0x82108C40;
		  /* 82108C40h */ case   23:  		/* bc 12, CR6_GT, 636 */
		/* 82108C40h case   23:*/		if ( regs.CR[6].gt ) { return 0x82108EBC;  }
		/* 82108C40h case   23:*/		return 0x82108C44;
		  /* 82108C44h */ case   24:  		/* lwz R10, <#[R30 + 4]> */
		/* 82108C44h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 82108C44h case   24:*/		return 0x82108C48;
		  /* 82108C48h */ case   25:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 82108C48h case   25:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 82108C48h case   25:*/		return 0x82108C4C;
		  /* 82108C4Ch */ case   26:  		/* mr R23, R14 */
		/* 82108C4Ch case   26:*/		regs.R23 = regs.R14;
		/* 82108C4Ch case   26:*/		return 0x82108C50;
		  /* 82108C50h */ case   27:  		/* divwu. R21, R10, R11 */
		/* 82108C50h case   27:*/		cpu::op::divwu<1>(regs,&regs.R21,regs.R10,regs.R11);
		/* 82108C50h case   27:*/		return 0x82108C54;
		  /* 82108C54h */ case   28:  		/* twi 6, R11, 0 */
		/* 82108C54h case   28:*/		cpu::op::tw<6>(regs, 0x82108C54, regs.R11, 0x00000000);
		/* 82108C54h case   28:*/		return 0x82108C58;
		  /* 82108C58h */ case   29:  		/* bc 12, CR0_EQ, 612 */
		/* 82108C58h case   29:*/		if ( regs.CR[0].eq ) { return 0x82108EBC;  }
		/* 82108C58h case   29:*/		return 0x82108C5C;
		  /* 82108C5Ch */ case   30:  		/* lwz R11, <#[R30 + 12]> */
		/* 82108C5Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82108C5Ch case   30:*/		return 0x82108C60;
		  /* 82108C60h */ case   31:  		/* mr R22, R14 */
		/* 82108C60h case   31:*/		regs.R22 = regs.R14;
		/* 82108C60h case   31:*/		return 0x82108C64;
		  /* 82108C64h */ case   32:  		/* mr R25, R14 */
		/* 82108C64h case   32:*/		regs.R25 = regs.R14;
		/* 82108C64h case   32:*/		return 0x82108C68;
		  /* 82108C68h */ case   33:  		/* cmplwi CR6, R11, 0 */
		/* 82108C68h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82108C68h case   33:*/		return 0x82108C6C;
		  /* 82108C6Ch */ case   34:  		/* bc 12, CR6_EQ, 292 */
		/* 82108C6Ch case   34:*/		if ( regs.CR[6].eq ) { return 0x82108D90;  }
		/* 82108C6Ch case   34:*/		return 0x82108C70;
		  /* 82108C70h */ case   35:  		/* mr R24, R14 */
		/* 82108C70h case   35:*/		regs.R24 = regs.R14;
		/* 82108C70h case   35:*/		return 0x82108C74;
		  /* 82108C74h */ case   36:  		/* mullw R11, R11, R23 */
		/* 82108C74h case   36:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R23);
		/* 82108C74h case   36:*/		return 0x82108C78;
		  /* 82108C78h */ case   37:  		/* lwz R10, <#[R30 + 8]> */
		/* 82108C78h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82108C78h case   37:*/		return 0x82108C7C;
		  /* 82108C7Ch */ case   38:  		/* lwz R9, <#[R16 + 20]> */
		/* 82108C7Ch case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R16 + 0x00000014) );
		/* 82108C7Ch case   38:*/		return 0x82108C80;
		  /* 82108C80h */ case   39:  		/* lwz R8, <#[R30 + 16]> */
		/* 82108C80h case   39:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000010) );
		/* 82108C80h case   39:*/		return 0x82108C84;
		  /* 82108C84h */ case   40:  		/* lwzx R8, <#[R24 + R8]> */
		/* 82108C84h case   40:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R24 + regs.R8 + 0x00000000) );
		/* 82108C84h case   40:*/		return 0x82108C88;
		  /* 82108C88h */ case   41:  		/* add R11, R11, R25 */
		/* 82108C88h case   41:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 82108C88h case   41:*/		return 0x82108C8C;
		  /* 82108C8Ch */ case   42:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82108C8Ch case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82108C8Ch case   42:*/		return 0x82108C90;
		  /* 82108C90h */ case   43:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82108C90h case   43:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82108C90h case   43:*/		return 0x82108C94;
		  /* 82108C94h */ case   44:  		/* lwzx R26, <#[R8 + R9]> */
		/* 82108C94h case   44:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82108C94h case   44:*/		return 0x82108C98;
		  /* 82108C98h */ case   45:  		/* lwzx R29, <#[R11 + R10]> */
		/* 82108C98h case   45:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82108C98h case   45:*/		return 0x82108C9C;
		  /* 82108C9Ch */ case   46:  		/* rlwinm R11, R29, 2, 0, 29 */
		/* 82108C9Ch case   46:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R29);
		/* 82108C9Ch case   46:*/		return 0x82108CA0;
		  /* 82108CA0h */ case   47:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82108CA0h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82108CA0h case   47:*/		return 0x82108CA4;
		  /* 82108CA4h */ case   48:  		/* lwz R11, <#[R11]> */
		/* 82108CA4h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82108CA4h case   48:*/		return 0x82108CA8;
		  /* 82108CA8h */ case   49:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82108CA8h case   49:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82108CA8h case   49:*/		return 0x82108CAC;
		  /* 82108CACh */ case   50:  		/* bc 12, CR0_EQ, 208 */
		/* 82108CACh case   50:*/		if ( regs.CR[0].eq ) { return 0x82108D7C;  }
		/* 82108CACh case   50:*/		return 0x82108CB0;
		  /* 82108CB0h */ case   51:  		/* lwz R9, <#[R26 + 20]> */
		/* 82108CB0h case   51:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000014) );
		/* 82108CB0h case   51:*/		return 0x82108CB4;
		  /* 82108CB4h */ case   52:  		/* lwz R5, <#[R26 + 24]> */
		/* 82108CB4h case   52:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R26 + 0x00000018) );
		/* 82108CB4h case   52:*/		return 0x82108CB8;
		  /* 82108CB8h */ case   53:  		/* cmpwi CR6, R9, -1 */
		/* 82108CB8h case   53:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82108CB8h case   53:*/		return 0x82108CBC;
		  /* 82108CBCh */ case   54:  		/* bc 12, CR6_EQ, 192 */
		/* 82108CBCh case   54:*/		if ( regs.CR[6].eq ) { return 0x82108D7C;  }
		/* 82108CBCh case   54:*/		return 0x82108CC0;
		  /* 82108CC0h */ case   55:  		/* lwz R28, <#[R16 + 20]> */
		/* 82108CC0h case   55:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R16 + 0x00000014) );
		/* 82108CC0h case   55:*/		return 0x82108CC4;
		  /* 82108CC4h */ case   56:  		/* lwz R27, <#[R16 + 24]> */
		/* 82108CC4h case   56:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R16 + 0x00000018) );
		/* 82108CC4h case   56:*/		return 0x82108CC8;
		  /* 82108CC8h */ case   57:  		/* rlwinm R31, R9, 2, 0, 29 */
		/* 82108CC8h case   57:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R9);
		/* 82108CC8h case   57:*/		return 0x82108CCC;
		  /* 82108CCCh */ case   58:  		/* mr R10, R14 */
		/* 82108CCCh case   58:*/		regs.R10 = regs.R14;
		/* 82108CCCh case   58:*/		return 0x82108CD0;
		  /* 82108CD0h */ case   59:  		/* lwzx R11, <#[R31 + R28]> */
		/* 82108CD0h case   59:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R28 + 0x00000000) );
		/* 82108CD0h case   59:*/		return 0x82108CD4;
		  /* 82108CD4h */ case   60:  		/* lwz R11, <#[R11 + 72]> */
		/* 82108CD4h case   60:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82108CD4h case   60:*/		return 0x82108CD8;
		  /* 82108CD8h */ case   61:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82108CD8h case   61:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82108CD8h case   61:*/		return 0x82108CDC;
		  /* 82108CDCh */ case   62:  		/* lwzx R11, <#[R11 + R27]> */
		/* 82108CDCh case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82108CDCh case   62:*/		return 0x82108CE0;
		  /* 82108CE0h */ case   63:  		/* lwz R7, <#[R11 + 12]> */
		/* 82108CE0h case   63:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 82108CE0h case   63:*/		return 0x82108CE4;
		  /* 82108CE4h */ case   64:  		/* cmplwi CR6, R7, 0 */
		/* 82108CE4h case   64:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82108CE4h case   64:*/		return 0x82108CE8;
		  /* 82108CE8h */ case   65:  		/* bc 12, CR6_EQ, 40 */
		/* 82108CE8h case   65:*/		if ( regs.CR[6].eq ) { return 0x82108D10;  }
		/* 82108CE8h case   65:*/		return 0x82108CEC;
		  /* 82108CECh */ case   66:  		/* lwz R6, <#[R11 + 16]> */
		/* 82108CECh case   66:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000010) );
		/* 82108CECh case   66:*/		return 0x82108CF0;
		  /* 82108CF0h */ case   67:  		/* mr R8, R14 */
		/* 82108CF0h case   67:*/		regs.R8 = regs.R14;
		/* 82108CF0h case   67:*/		return 0x82108CF4;
		  /* 82108CF4h */ case   68:  		/* lwzx R4, <#[R8 + R6]> */
		/* 82108CF4h case   68:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 82108CF4h case   68:*/		return 0x82108CF8;
		  /* 82108CF8h */ case   69:  		/* cmplw CR6, R4, R9 */
		/* 82108CF8h case   69:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R9);
		/* 82108CF8h case   69:*/		return 0x82108CFC;
		  /* 82108CFCh */ case   70:  		/* bc 12, CR6_EQ, 20 */
		/* 82108CFCh case   70:*/		if ( regs.CR[6].eq ) { return 0x82108D10;  }
		/* 82108CFCh case   70:*/		return 0x82108D00;
		  /* 82108D00h */ case   71:  		/* addi R10, R10, 1 */
		/* 82108D00h case   71:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82108D00h case   71:*/		return 0x82108D04;
		  /* 82108D04h */ case   72:  		/* addi R8, R8, 4 */
		/* 82108D04h case   72:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82108D04h case   72:*/		return 0x82108D08;
		  /* 82108D08h */ case   73:  		/* cmplw CR6, R10, R7 */
		/* 82108D08h case   73:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 82108D08h case   73:*/		return 0x82108D0C;
		  /* 82108D0Ch */ case   74:  		/* bc 12, CR6_LT, -24 */
		/* 82108D0Ch case   74:*/		if ( regs.CR[6].lt ) { return 0x82108CF4;  }
		/* 82108D0Ch case   74:*/		return 0x82108D10;
	}
	return 0x82108D10;
} // Block from 82108BE4h-82108D10h (75 instructions)

//////////////////////////////////////////////////////
// Block at 82108D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108D10);
		  /* 82108D10h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82108D10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82108D10h case    0:*/		return 0x82108D14;
		  /* 82108D14h */ case    1:  		/* cmpwi CR6, R5, 0 */
		/* 82108D14h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 82108D14h case    1:*/		return 0x82108D18;
		  /* 82108D18h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82108D18h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82108D18h case    2:*/		return 0x82108D1C;
		  /* 82108D1Ch */ case    3:  		/* mr R3, R16 */
		/* 82108D1Ch case    3:*/		regs.R3 = regs.R16;
		/* 82108D1Ch case    3:*/		return 0x82108D20;
		  /* 82108D20h */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 82108D20h case    4:*/		if ( regs.CR[6].eq ) { return 0x82108D44;  }
		/* 82108D20h case    4:*/		return 0x82108D24;
		  /* 82108D24h */ case    5:  		/* mr R4, R29 */
		/* 82108D24h case    5:*/		regs.R4 = regs.R29;
		/* 82108D24h case    5:*/		return 0x82108D28;
		  /* 82108D28h */ case    6:  		/* lwzx R5, <#[R10 + R11]> */
		/* 82108D28h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82108D28h case    6:*/		return 0x82108D2C;
		  /* 82108D2Ch */ case    7:  		/* bl -43412 */
		/* 82108D2Ch case    7:*/		regs.LR = 0x82108D30; return 0x820FE398;
		/* 82108D2Ch case    7:*/		return 0x82108D30;
		  /* 82108D30h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 82108D30h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82108D30h case    8:*/		return 0x82108D34;
		  /* 82108D34h */ case    9:  		/* bc 12, CR0_EQ, 36 */
		/* 82108D34h case    9:*/		if ( regs.CR[0].eq ) { return 0x82108D58;  }
		/* 82108D34h case    9:*/		return 0x82108D38;
		  /* 82108D38h */ case   10:  		/* li R11, 1 */
		/* 82108D38h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82108D38h case   10:*/		return 0x82108D3C;
		  /* 82108D3Ch */ case   11:  		/* stw R11, <#[R26 + 64]> */
		/* 82108D3Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000040) );
		/* 82108D3Ch case   11:*/		return 0x82108D40;
		  /* 82108D40h */ case   12:  		/* b 56 */
		/* 82108D40h case   12:*/		return 0x82108D78;
		/* 82108D40h case   12:*/		return 0x82108D44;
	}
	return 0x82108D44;
} // Block from 82108D10h-82108D44h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82108D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108D44);
		  /* 82108D44h */ case    0:  		/* mr R5, R29 */
		/* 82108D44h case    0:*/		regs.R5 = regs.R29;
		/* 82108D44h case    0:*/		return 0x82108D48;
		  /* 82108D48h */ case    1:  		/* lwzx R4, <#[R10 + R11]> */
		/* 82108D48h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82108D48h case    1:*/		return 0x82108D4C;
		  /* 82108D4Ch */ case    2:  		/* bl -43444 */
		/* 82108D4Ch case    2:*/		regs.LR = 0x82108D50; return 0x820FE398;
		/* 82108D4Ch case    2:*/		return 0x82108D50;
		  /* 82108D50h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 82108D50h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82108D50h case    3:*/		return 0x82108D54;
		  /* 82108D54h */ case    4:  		/* bc 4, CR0_EQ, 32 */
		/* 82108D54h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82108D74;  }
		/* 82108D54h case    4:*/		return 0x82108D58;
	}
	return 0x82108D58;
} // Block from 82108D44h-82108D58h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82108D58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108D58);
		  /* 82108D58h */ case    0:  		/* lwz R11, <#[R16 + 20]> */
		/* 82108D58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000014) );
		/* 82108D58h case    0:*/		return 0x82108D5C;
		  /* 82108D5Ch */ case    1:  		/* lwzx R11, <#[R11 + R31]> */
		/* 82108D5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82108D5Ch case    1:*/		return 0x82108D60;
		  /* 82108D60h */ case    2:  		/* lwz R9, <#[R11 + 20]> */
		/* 82108D60h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82108D60h case    2:*/		return 0x82108D64;
		  /* 82108D64h */ case    3:  		/* lwz R5, <#[R11 + 24]> */
		/* 82108D64h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000018) );
		/* 82108D64h case    3:*/		return 0x82108D68;
		  /* 82108D68h */ case    4:  		/* cmpwi CR6, R9, -1 */
		/* 82108D68h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82108D68h case    4:*/		return 0x82108D6C;
		  /* 82108D6Ch */ case    5:  		/* bc 4, CR6_EQ, -164 */
		/* 82108D6Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82108CC8;  }
		/* 82108D6Ch case    5:*/		return 0x82108D70;
		  /* 82108D70h */ case    6:  		/* b 12 */
		/* 82108D70h case    6:*/		return 0x82108D7C;
		/* 82108D70h case    6:*/		return 0x82108D74;
	}
	return 0x82108D74;
} // Block from 82108D58h-82108D74h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82108D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108D74);
		  /* 82108D74h */ case    0:  		/* stw R14, <#[R26 + 64]> */
		/* 82108D74h case    0:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R26 + 0x00000040) );
		/* 82108D74h case    0:*/		return 0x82108D78;
	}
	return 0x82108D78;
} // Block from 82108D74h-82108D78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82108D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108D78);
		  /* 82108D78h */ case    0:  		/* addi R22, R22, 1 */
		/* 82108D78h case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 82108D78h case    0:*/		return 0x82108D7C;
	}
	return 0x82108D7C;
} // Block from 82108D78h-82108D7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82108D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108D7C);
		  /* 82108D7Ch */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82108D7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82108D7Ch case    0:*/		return 0x82108D80;
		  /* 82108D80h */ case    1:  		/* addi R25, R25, 1 */
		/* 82108D80h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 82108D80h case    1:*/		return 0x82108D84;
		  /* 82108D84h */ case    2:  		/* addi R24, R24, 4 */
		/* 82108D84h case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 82108D84h case    2:*/		return 0x82108D88;
		  /* 82108D88h */ case    3:  		/* cmplw CR6, R25, R11 */
		/* 82108D88h case    3:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 82108D88h case    3:*/		return 0x82108D8C;
		  /* 82108D8Ch */ case    4:  		/* bc 12, CR6_LT, -280 */
		/* 82108D8Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82108C74;  }
		/* 82108D8Ch case    4:*/		return 0x82108D90;
	}
	return 0x82108D90;
} // Block from 82108D7Ch-82108D90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82108D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108D90);
		  /* 82108D90h */ case    0:  		/* cmplw CR6, R22, R11 */
		/* 82108D90h case    0:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82108D90h case    0:*/		return 0x82108D94;
		  /* 82108D94h */ case    1:  		/* bc 4, CR6_EQ, 284 */
		/* 82108D94h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82108EB0;  }
		/* 82108D94h case    1:*/		return 0x82108D98;
		  /* 82108D98h */ case    2:  		/* mr R31, R14 */
		/* 82108D98h case    2:*/		regs.R31 = regs.R14;
		/* 82108D98h case    2:*/		return 0x82108D9C;
		  /* 82108D9Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82108D9Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82108D9Ch case    3:*/		return 0x82108DA0;
		  /* 82108DA0h */ case    4:  		/* bc 12, CR6_EQ, 272 */
		/* 82108DA0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82108EB0;  }
		/* 82108DA0h case    4:*/		return 0x82108DA4;
		  /* 82108DA4h */ case    5:  		/* mr R29, R14 */
		/* 82108DA4h case    5:*/		regs.R29 = regs.R14;
		/* 82108DA4h case    5:*/		return 0x82108DA8;
		  /* 82108DA8h */ case    6:  		/* mullw R11, R11, R23 */
		/* 82108DA8h case    6:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R23);
		/* 82108DA8h case    6:*/		return 0x82108DAC;
		  /* 82108DACh */ case    7:  		/* lwz R10, <#[R30 + 16]> */
		/* 82108DACh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 82108DACh case    7:*/		return 0x82108DB0;
		  /* 82108DB0h */ case    8:  		/* lwz R8, <#[R30 + 8]> */
		/* 82108DB0h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000008) );
		/* 82108DB0h case    8:*/		return 0x82108DB4;
		  /* 82108DB4h */ case    9:  		/* lwz R9, <#[R16 + 20]> */
		/* 82108DB4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R16 + 0x00000014) );
		/* 82108DB4h case    9:*/		return 0x82108DB8;
		  /* 82108DB8h */ case   10:  		/* lwzx R10, <#[R29 + R10]> */
		/* 82108DB8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 82108DB8h case   10:*/		return 0x82108DBC;
		  /* 82108DBCh */ case   11:  		/* add R11, R11, R31 */
		/* 82108DBCh case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82108DBCh case   11:*/		return 0x82108DC0;
		  /* 82108DC0h */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82108DC0h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82108DC0h case   12:*/		return 0x82108DC4;
		  /* 82108DC4h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82108DC4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82108DC4h case   13:*/		return 0x82108DC8;
		  /* 82108DC8h */ case   14:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82108DC8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82108DC8h case   14:*/		return 0x82108DCC;
		  /* 82108DCCh */ case   15:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82108DCCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82108DCCh case   15:*/		return 0x82108DD0;
		  /* 82108DD0h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82108DD0h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82108DD0h case   16:*/		return 0x82108DD4;
		  /* 82108DD4h */ case   17:  		/* lwz R10, <#[R10 + 64]> */
		/* 82108DD4h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000040) );
		/* 82108DD4h case   17:*/		return 0x82108DD8;
		  /* 82108DD8h */ case   18:  		/* cmplwi CR6, R10, 0 */
		/* 82108DD8h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82108DD8h case   18:*/		return 0x82108DDC;
		  /* 82108DDCh */ case   19:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82108DDCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82108DDCh case   19:*/		return 0x82108DE0;
		  /* 82108DE0h */ case   20:  		/* lwz R9, <#[R16 + 16]> */
		/* 82108DE0h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R16 + 0x00000010) );
		/* 82108DE0h case   20:*/		return 0x82108DE4;
		  /* 82108DE4h */ case   21:  		/* lwz R10, <#[R11 + 4]> */
		/* 82108DE4h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82108DE4h case   21:*/		return 0x82108DE8;
		  /* 82108DE8h */ case   22:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82108DE8h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82108DE8h case   22:*/		return 0x82108DEC;
		  /* 82108DECh */ case   23:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82108DECh case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82108DECh case   23:*/		return 0x82108DF0;
		  /* 82108DF0h */ case   24:  		/* lwz R10, <#[R10 + 4]> */
		/* 82108DF0h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82108DF0h case   24:*/		return 0x82108DF4;
		  /* 82108DF4h */ case   25:  		/* rlwinm. R10, R10, 0, 23, 23 */
		/* 82108DF4h case   25:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R10,regs.R10);
		/* 82108DF4h case   25:*/		return 0x82108DF8;
		  /* 82108DF8h */ case   26:  		/* bc 12, CR6_EQ, 84 */
		/* 82108DF8h case   26:*/		if ( regs.CR[6].eq ) { return 0x82108E4C;  }
		/* 82108DF8h case   26:*/		return 0x82108DFC;
		  /* 82108DFCh */ case   27:  		/* bc 12, CR0_EQ, 16 */
		/* 82108DFCh case   27:*/		if ( regs.CR[0].eq ) { return 0x82108E0C;  }
		/* 82108DFCh case   27:*/		return 0x82108E00;
		  /* 82108E00h */ case   28:  		/* lfd FR0, <#[R11 + 32]> */
		/* 82108E00h case   28:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 82108E00h case   28:*/		return 0x82108E04;
		  /* 82108E04h */ case   29:  		/* fcmpu CR6, FR0, FR30 */
		/* 82108E04h case   29:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR30);
		/* 82108E04h case   29:*/		return 0x82108E08;
		  /* 82108E08h */ case   30:  		/* bc 12, CR6_EQ, 148 */
		/* 82108E08h case   30:*/		if ( regs.CR[6].eq ) { return 0x82108E9C;  }
		/* 82108E08h case   30:*/		return 0x82108E0C;
	}
	return 0x82108E0C;
} // Block from 82108D90h-82108E0Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 82108E0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108E0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108E0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108E0C);
		  /* 82108E0Ch */ case    0:  		/* cmpwi CR6, R19, -1 */
		/* 82108E0Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R19,0xFFFFFFFF);
		/* 82108E0Ch case    0:*/		return 0x82108E10;
		  /* 82108E10h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82108E10h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82108E30;  }
		/* 82108E10h case    1:*/		return 0x82108E14;
		  /* 82108E14h */ case    2:  		/* li R6, 0 */
		/* 82108E14h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82108E14h case    2:*/		return 0x82108E18;
		  /* 82108E18h */ case    3:  		/* lwz R4, <#[R16 + 120]> */
		/* 82108E18h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R16 + 0x00000078) );
		/* 82108E18h case    3:*/		return 0x82108E1C;
		  /* 82108E1Ch */ case    4:  		/* li R5, 0 */
		/* 82108E1Ch case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82108E1Ch case    4:*/		return 0x82108E20;
		  /* 82108E20h */ case    5:  		/* fmr FR1, FR30 */
		/* 82108E20h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82108E20h case    5:*/		return 0x82108E24;
		  /* 82108E24h */ case    6:  		/* mr R3, R16 */
		/* 82108E24h case    6:*/		regs.R3 = regs.R16;
		/* 82108E24h case    6:*/		return 0x82108E28;
		  /* 82108E28h */ case    7:  		/* bl -48128 */
		/* 82108E28h case    7:*/		regs.LR = 0x82108E2C; return 0x820FD228;
		/* 82108E28h case    7:*/		return 0x82108E2C;
		  /* 82108E2Ch */ case    8:  		/* mr R19, R3 */
		/* 82108E2Ch case    8:*/		regs.R19 = regs.R3;
		/* 82108E2Ch case    8:*/		return 0x82108E30;
	}
	return 0x82108E30;
} // Block from 82108E0Ch-82108E30h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82108E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108E30);
		  /* 82108E30h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82108E30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82108E30h case    0:*/		return 0x82108E34;
		  /* 82108E34h */ case    1:  		/* lwz R10, <#[R30 + 8]> */
		/* 82108E34h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82108E34h case    1:*/		return 0x82108E38;
		  /* 82108E38h */ case    2:  		/* mullw R11, R23, R11 */
		/* 82108E38h case    2:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R23,regs.R11);
		/* 82108E38h case    2:*/		return 0x82108E3C;
		  /* 82108E3Ch */ case    3:  		/* add R11, R11, R31 */
		/* 82108E3Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82108E3Ch case    3:*/		return 0x82108E40;
		  /* 82108E40h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82108E40h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82108E40h case    4:*/		return 0x82108E44;
		  /* 82108E44h */ case    5:  		/* stwx R19, <#[R11 + R10]> */
		/* 82108E44h case    5:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82108E44h case    5:*/		return 0x82108E48;
		  /* 82108E48h */ case    6:  		/* b 80 */
		/* 82108E48h case    6:*/		return 0x82108E98;
		/* 82108E48h case    6:*/		return 0x82108E4C;
	}
	return 0x82108E4C;
} // Block from 82108E30h-82108E4Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82108E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108E4C);
		  /* 82108E4Ch */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 82108E4Ch case    0:*/		if ( regs.CR[0].eq ) { return 0x82108E5C;  }
		/* 82108E4Ch case    0:*/		return 0x82108E50;
		  /* 82108E50h */ case    1:  		/* lfd FR0, <#[R11 + 32]> */
		/* 82108E50h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 82108E50h case    1:*/		return 0x82108E54;
		  /* 82108E54h */ case    2:  		/* fcmpu CR6, FR0, FR31 */
		/* 82108E54h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82108E54h case    2:*/		return 0x82108E58;
		  /* 82108E58h */ case    3:  		/* bc 12, CR6_EQ, 68 */
		/* 82108E58h case    3:*/		if ( regs.CR[6].eq ) { return 0x82108E9C;  }
		/* 82108E58h case    3:*/		return 0x82108E5C;
	}
	return 0x82108E5C;
} // Block from 82108E4Ch-82108E5Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82108E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108E5C);
		  /* 82108E5Ch */ case    0:  		/* cmpwi CR6, R20, -1 */
		/* 82108E5Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R20,0xFFFFFFFF);
		/* 82108E5Ch case    0:*/		return 0x82108E60;
		  /* 82108E60h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82108E60h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82108E80;  }
		/* 82108E60h case    1:*/		return 0x82108E64;
		  /* 82108E64h */ case    2:  		/* li R6, 0 */
		/* 82108E64h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82108E64h case    2:*/		return 0x82108E68;
		  /* 82108E68h */ case    3:  		/* lwz R4, <#[R16 + 120]> */
		/* 82108E68h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R16 + 0x00000078) );
		/* 82108E68h case    3:*/		return 0x82108E6C;
		  /* 82108E6Ch */ case    4:  		/* li R5, 0 */
		/* 82108E6Ch case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82108E6Ch case    4:*/		return 0x82108E70;
		  /* 82108E70h */ case    5:  		/* fmr FR1, FR31 */
		/* 82108E70h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82108E70h case    5:*/		return 0x82108E74;
		  /* 82108E74h */ case    6:  		/* mr R3, R16 */
		/* 82108E74h case    6:*/		regs.R3 = regs.R16;
		/* 82108E74h case    6:*/		return 0x82108E78;
		  /* 82108E78h */ case    7:  		/* bl -48208 */
		/* 82108E78h case    7:*/		regs.LR = 0x82108E7C; return 0x820FD228;
		/* 82108E78h case    7:*/		return 0x82108E7C;
		  /* 82108E7Ch */ case    8:  		/* mr R20, R3 */
		/* 82108E7Ch case    8:*/		regs.R20 = regs.R3;
		/* 82108E7Ch case    8:*/		return 0x82108E80;
	}
	return 0x82108E80;
} // Block from 82108E5Ch-82108E80h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82108E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108E80);
		  /* 82108E80h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82108E80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82108E80h case    0:*/		return 0x82108E84;
		  /* 82108E84h */ case    1:  		/* lwz R10, <#[R30 + 8]> */
		/* 82108E84h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82108E84h case    1:*/		return 0x82108E88;
		  /* 82108E88h */ case    2:  		/* mullw R11, R23, R11 */
		/* 82108E88h case    2:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R23,regs.R11);
		/* 82108E88h case    2:*/		return 0x82108E8C;
		  /* 82108E8Ch */ case    3:  		/* add R11, R11, R31 */
		/* 82108E8Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82108E8Ch case    3:*/		return 0x82108E90;
		  /* 82108E90h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82108E90h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82108E90h case    4:*/		return 0x82108E94;
		  /* 82108E94h */ case    5:  		/* stwx R20, <#[R11 + R10]> */
		/* 82108E94h case    5:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82108E94h case    5:*/		return 0x82108E98;
	}
	return 0x82108E98;
} // Block from 82108E80h-82108E98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82108E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108E98);
		  /* 82108E98h */ case    0:  		/* li R15, 1 */
		/* 82108E98h case    0:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 82108E98h case    0:*/		return 0x82108E9C;
	}
	return 0x82108E9C;
} // Block from 82108E98h-82108E9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82108E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108E9C);
		  /* 82108E9Ch */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 82108E9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82108E9Ch case    0:*/		return 0x82108EA0;
		  /* 82108EA0h */ case    1:  		/* addi R31, R31, 1 */
		/* 82108EA0h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82108EA0h case    1:*/		return 0x82108EA4;
		  /* 82108EA4h */ case    2:  		/* addi R29, R29, 4 */
		/* 82108EA4h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82108EA4h case    2:*/		return 0x82108EA8;
		  /* 82108EA8h */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 82108EA8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82108EA8h case    3:*/		return 0x82108EAC;
		  /* 82108EACh */ case    4:  		/* bc 12, CR6_LT, -260 */
		/* 82108EACh case    4:*/		if ( regs.CR[6].lt ) { return 0x82108DA8;  }
		/* 82108EACh case    4:*/		return 0x82108EB0;
	}
	return 0x82108EB0;
} // Block from 82108E9Ch-82108EB0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82108EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108EB0);
		  /* 82108EB0h */ case    0:  		/* addi R23, R23, 1 */
		/* 82108EB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 82108EB0h case    0:*/		return 0x82108EB4;
		  /* 82108EB4h */ case    1:  		/* cmplw CR6, R23, R21 */
		/* 82108EB4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R21);
		/* 82108EB4h case    1:*/		return 0x82108EB8;
		  /* 82108EB8h */ case    2:  		/* bc 12, CR6_LT, -604 */
		/* 82108EB8h case    2:*/		if ( regs.CR[6].lt ) { return 0x82108C5C;  }
		/* 82108EB8h case    2:*/		return 0x82108EBC;
	}
	return 0x82108EBC;
} // Block from 82108EB0h-82108EBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82108EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108EBC);
		  /* 82108EBCh */ case    0:  		/* lwz R11, <#[R16 + 12]> */
		/* 82108EBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x0000000C) );
		/* 82108EBCh case    0:*/		return 0x82108EC0;
		  /* 82108EC0h */ case    1:  		/* addi R18, R18, 1 */
		/* 82108EC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x1);
		/* 82108EC0h case    1:*/		return 0x82108EC4;
		  /* 82108EC4h */ case    2:  		/* addi R17, R17, 4 */
		/* 82108EC4h case    2:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x4);
		/* 82108EC4h case    2:*/		return 0x82108EC8;
		  /* 82108EC8h */ case    3:  		/* cmplw CR6, R18, R11 */
		/* 82108EC8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R11);
		/* 82108EC8h case    3:*/		return 0x82108ECC;
		  /* 82108ECCh */ case    4:  		/* bc 12, CR6_LT, -696 */
		/* 82108ECCh case    4:*/		if ( regs.CR[6].lt ) { return 0x82108C14;  }
		/* 82108ECCh case    4:*/		return 0x82108ED0;
	}
	return 0x82108ED0;
} // Block from 82108EBCh-82108ED0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82108ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108ED0);
		  /* 82108ED0h */ case    0:  		/* lwz R10, <#[R16 + 8]> */
		/* 82108ED0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000008) );
		/* 82108ED0h case    0:*/		return 0x82108ED4;
		  /* 82108ED4h */ case    1:  		/* mr R25, R14 */
		/* 82108ED4h case    1:*/		regs.R25 = regs.R14;
		/* 82108ED4h case    1:*/		return 0x82108ED8;
		  /* 82108ED8h */ case    2:  		/* mr R11, R14 */
		/* 82108ED8h case    2:*/		regs.R11 = regs.R14;
		/* 82108ED8h case    2:*/		return 0x82108EDC;
		  /* 82108EDCh */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82108EDCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82108EDCh case    3:*/		return 0x82108EE0;
		  /* 82108EE0h */ case    4:  		/* bc 4, CR6_GT, 40 */
		/* 82108EE0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82108F08;  }
		/* 82108EE0h case    4:*/		return 0x82108EE4;
		  /* 82108EE4h */ case    5:  		/* mr R10, R14 */
		/* 82108EE4h case    5:*/		regs.R10 = regs.R14;
		/* 82108EE4h case    5:*/		return 0x82108EE8;
		  /* 82108EE8h */ case    6:  		/* lwz R9, <#[R16 + 20]> */
		/* 82108EE8h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R16 + 0x00000014) );
		/* 82108EE8h case    6:*/		return 0x82108EEC;
		  /* 82108EECh */ case    7:  		/* lwzx R9, <#[R10 + R9]> */
		/* 82108EECh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82108EECh case    7:*/		return 0x82108EF0;
		  /* 82108EF0h */ case    8:  		/* addi R10, R10, 4 */
		/* 82108EF0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82108EF0h case    8:*/		return 0x82108EF4;
		  /* 82108EF4h */ case    9:  		/* stw R11, <#[R9 + 48]> */
		/* 82108EF4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 82108EF4h case    9:*/		return 0x82108EF8;
		  /* 82108EF8h */ case   10:  		/* addi R11, R11, 1 */
		/* 82108EF8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82108EF8h case   10:*/		return 0x82108EFC;
		  /* 82108EFCh */ case   11:  		/* lwz R9, <#[R16 + 8]> */
		/* 82108EFCh case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R16 + 0x00000008) );
		/* 82108EFCh case   11:*/		return 0x82108F00;
		  /* 82108F00h */ case   12:  		/* cmplw CR6, R11, R9 */
		/* 82108F00h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82108F00h case   12:*/		return 0x82108F04;
		  /* 82108F04h */ case   13:  		/* bc 12, CR6_LT, -28 */
		/* 82108F04h case   13:*/		if ( regs.CR[6].lt ) { return 0x82108EE8;  }
		/* 82108F04h case   13:*/		return 0x82108F08;
	}
	return 0x82108F08;
} // Block from 82108ED0h-82108F08h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82108F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108F08);
		  /* 82108F08h */ case    0:  		/* lwz R11, <#[R16 + 12]> */
		/* 82108F08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x0000000C) );
		/* 82108F08h case    0:*/		return 0x82108F0C;
		  /* 82108F0Ch */ case    1:  		/* mr R24, R14 */
		/* 82108F0Ch case    1:*/		regs.R24 = regs.R14;
		/* 82108F0Ch case    1:*/		return 0x82108F10;
		  /* 82108F10h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82108F10h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82108F10h case    2:*/		return 0x82108F14;
		  /* 82108F14h */ case    3:  		/* bc 4, CR6_GT, 1452 */
		/* 82108F14h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821094C0;  }
		/* 82108F14h case    3:*/		return 0x82108F18;
		  /* 82108F18h */ case    4:  		/* lwz R11, <#[R16 + 24]> */
		/* 82108F18h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000018) );
		/* 82108F18h case    4:*/		return 0x82108F1C;
		  /* 82108F1Ch */ case    5:  		/* rlwinm R10, R24, 2, 0, 29 */
		/* 82108F1Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R24);
		/* 82108F1Ch case    5:*/		return 0x82108F20;
		  /* 82108F20h */ case    6:  		/* lwzx R31, <#[R10 + R11]> */
		/* 82108F20h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82108F20h case    6:*/		return 0x82108F24;
		  /* 82108F24h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82108F24h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82108F24h case    7:*/		return 0x82108F28;
		  /* 82108F28h */ case    8:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 82108F28h case    8:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82108F28h case    8:*/		return 0x82108F2C;
		  /* 82108F2Ch */ case    9:  		/* bc 12, CR0_EQ, 1396 */
		/* 82108F2Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x821094A0;  }
		/* 82108F2Ch case    9:*/		return 0x82108F30;
		  /* 82108F30h */ case   10:  		/* lwz R11, <#[R31 + 12]> */
		/* 82108F30h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82108F30h case   10:*/		return 0x82108F34;
		  /* 82108F34h */ case   11:  		/* mr R4, R14 */
		/* 82108F34h case   11:*/		regs.R4 = regs.R14;
		/* 82108F34h case   11:*/		return 0x82108F38;
		  /* 82108F38h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 82108F38h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82108F38h case   12:*/		return 0x82108F3C;
		  /* 82108F3Ch */ case   13:  		/* bc 4, CR6_GT, 128 */
		/* 82108F3Ch case   13:*/		if ( !regs.CR[6].gt ) { return 0x82108FBC;  }
		/* 82108F3Ch case   13:*/		return 0x82108F40;
		  /* 82108F40h */ case   14:  		/* mr R5, R14 */
		/* 82108F40h case   14:*/		regs.R5 = regs.R14;
		/* 82108F40h case   14:*/		return 0x82108F44;
		  /* 82108F44h */ case   15:  		/* lwz R11, <#[R31 + 16]> */
		/* 82108F44h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82108F44h case   15:*/		return 0x82108F48;
		  /* 82108F48h */ case   16:  		/* lwz R6, <#[R16 + 20]> */
		/* 82108F48h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R16 + 0x00000014) );
		/* 82108F48h case   16:*/		return 0x82108F4C;
		  /* 82108F4Ch */ case   17:  		/* lwzx R11, <#[R5 + R11]> */
		/* 82108F4Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82108F4Ch case   17:*/		return 0x82108F50;
		  /* 82108F50h */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82108F50h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82108F50h case   18:*/		return 0x82108F54;
		  /* 82108F54h */ case   19:  		/* lwzx R9, <#[R11 + R6]> */
		/* 82108F54h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82108F54h case   19:*/		return 0x82108F58;
		  /* 82108F58h */ case   20:  		/* lwz R11, <#[R9 + 20]> */
		/* 82108F58h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 82108F58h case   20:*/		return 0x82108F5C;
		  /* 82108F5Ch */ case   21:  		/* lwz R10, <#[R9 + 24]> */
		/* 82108F5Ch case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000018) );
		/* 82108F5Ch case   21:*/		return 0x82108F60;
		  /* 82108F60h */ case   22:  		/* b 56 */
		/* 82108F60h case   22:*/		return 0x82108F98;
		/* 82108F60h case   22:*/		return 0x82108F64;
		  /* 82108F64h */ case   23:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 82108F64h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 82108F64h case   23:*/		return 0x82108F68;
		  /* 82108F68h */ case   24:  		/* lwzx R7, <#[R8 + R6]> */
		/* 82108F68h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 82108F68h case   24:*/		return 0x82108F6C;
		  /* 82108F6Ch */ case   25:  		/* lwz R3, <#[R7]> */
		/* 82108F6Ch case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R7 + 0x00000000) );
		/* 82108F6Ch case   25:*/		return 0x82108F70;
		  /* 82108F70h */ case   26:  		/* rlwinm. R3, R3, 0, 24, 24 */
		/* 82108F70h case   26:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R3,regs.R3);
		/* 82108F70h case   26:*/		return 0x82108F74;
		  /* 82108F74h */ case   27:  		/* bc 12, CR0_EQ, 44 */
		/* 82108F74h case   27:*/		if ( regs.CR[0].eq ) { return 0x82108FA0;  }
		/* 82108F74h case   27:*/		return 0x82108F78;
		  /* 82108F78h */ case   28:  		/* lfd FR0, <#[R7 + 32]> */
		/* 82108F78h case   28:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R7 + 0x00000020) );
		/* 82108F78h case   28:*/		return 0x82108F7C;
		  /* 82108F7Ch */ case   29:  		/* cmpwi CR6, R10, 0 */
		/* 82108F7Ch case   29:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82108F7Ch case   29:*/		return 0x82108F80;
		  /* 82108F80h */ case   30:  		/* bc 4, CR6_EQ, 432 */
		/* 82108F80h case   30:*/		if ( !regs.CR[6].eq ) { return 0x82109130;  }
		/* 82108F80h case   30:*/		return 0x82108F84;
		  /* 82108F84h */ case   31:  		/* fcmpu CR6, FR0, FR31 */
		/* 82108F84h case   31:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82108F84h case   31:*/		return 0x82108F88;
		  /* 82108F88h */ case   32:  		/* bc 12, CR6_EQ, 432 */
		/* 82108F88h case   32:*/		if ( regs.CR[6].eq ) { return 0x82109138;  }
		/* 82108F88h case   32:*/		return 0x82108F8C;
		  /* 82108F8Ch */ case   33:  		/* mr R10, R14 */
		/* 82108F8Ch case   33:*/		regs.R10 = regs.R14;
		/* 82108F8Ch case   33:*/		return 0x82108F90;
		  /* 82108F90h */ case   34:  		/* li R11, -1 */
		/* 82108F90h case   34:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82108F90h case   34:*/		return 0x82108F94;
		  /* 82108F94h */ case   35:  		/* li R15, 1 */
		/* 82108F94h case   35:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 82108F94h case   35:*/		return 0x82108F98;
	}
	return 0x82108F98;
} // Block from 82108F08h-82108F98h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82108F98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108F98);
		  /* 82108F98h */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 82108F98h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82108F98h case    0:*/		return 0x82108F9C;
		  /* 82108F9Ch */ case    1:  		/* bc 4, CR6_EQ, -56 */
		/* 82108F9Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82108F64;  }
		/* 82108F9Ch case    1:*/		return 0x82108FA0;
	}
	return 0x82108FA0;
} // Block from 82108F98h-82108FA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82108FA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108FA0);
		  /* 82108FA0h */ case    0:  		/* addi R4, R4, 1 */
		/* 82108FA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82108FA0h case    0:*/		return 0x82108FA4;
		  /* 82108FA4h */ case    1:  		/* stw R11, <#[R9 + 20]> */
		/* 82108FA4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 82108FA4h case    1:*/		return 0x82108FA8;
		  /* 82108FA8h */ case    2:  		/* stw R10, <#[R9 + 24]> */
		/* 82108FA8h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000018) );
		/* 82108FA8h case    2:*/		return 0x82108FAC;
		  /* 82108FACh */ case    3:  		/* addi R5, R5, 4 */
		/* 82108FACh case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 82108FACh case    3:*/		return 0x82108FB0;
		  /* 82108FB0h */ case    4:  		/* lwz R11, <#[R31 + 12]> */
		/* 82108FB0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82108FB0h case    4:*/		return 0x82108FB4;
		  /* 82108FB4h */ case    5:  		/* cmplw CR6, R4, R11 */
		/* 82108FB4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82108FB4h case    5:*/		return 0x82108FB8;
		  /* 82108FB8h */ case    6:  		/* bc 12, CR6_LT, -116 */
		/* 82108FB8h case    6:*/		if ( regs.CR[6].lt ) { return 0x82108F44;  }
		/* 82108FB8h case    6:*/		return 0x82108FBC;
	}
	return 0x82108FBC;
} // Block from 82108FA0h-82108FBCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82108FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82108FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82108FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82108FBC);
		  /* 82108FBCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82108FBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82108FBCh case    0:*/		return 0x82108FC0;
		  /* 82108FC0h */ case    1:  		/* lis R9, 4336 */
		/* 82108FC0h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0x10F0);
		/* 82108FC0h case    1:*/		return 0x82108FC4;
		  /* 82108FC4h */ case    2:  		/* rlwinm R10, R11, 0, 0, 11 */
		/* 82108FC4h case    2:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R10,regs.R11);
		/* 82108FC4h case    2:*/		return 0x82108FC8;
		  /* 82108FC8h */ case    3:  		/* cmplw CR6, R10, R9 */
		/* 82108FC8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82108FC8h case    3:*/		return 0x82108FCC;
		  /* 82108FCCh */ case    4:  		/* bc 12, CR6_EQ, 924 */
		/* 82108FCCh case    4:*/		if ( regs.CR[6].eq ) { return 0x82109368;  }
		/* 82108FCCh case    4:*/		return 0x82108FD0;
		  /* 82108FD0h */ case    5:  		/* lis R9, 4416 */
		/* 82108FD0h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0x1140);
		/* 82108FD0h case    5:*/		return 0x82108FD4;
		  /* 82108FD4h */ case    6:  		/* cmplw CR6, R10, R9 */
		/* 82108FD4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82108FD4h case    6:*/		return 0x82108FD8;
		  /* 82108FD8h */ case    7:  		/* bc 12, CR6_EQ, 912 */
		/* 82108FD8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82109368;  }
		/* 82108FD8h case    7:*/		return 0x82108FDC;
		  /* 82108FDCh */ case    8:  		/* lis R9, 8304 */
		/* 82108FDCh case    8:*/		cpu::op::lis<0>(regs,&regs.R9,0x2070);
		/* 82108FDCh case    8:*/		return 0x82108FE0;
		  /* 82108FE0h */ case    9:  		/* cmplw CR6, R10, R9 */
		/* 82108FE0h case    9:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82108FE0h case    9:*/		return 0x82108FE4;
		  /* 82108FE4h */ case   10:  		/* bc 12, CR6_EQ, 496 */
		/* 82108FE4h case   10:*/		if ( regs.CR[6].eq ) { return 0x821091D4;  }
		/* 82108FE4h case   10:*/		return 0x82108FE8;
		  /* 82108FE8h */ case   11:  		/* lis R9, 8320 */
		/* 82108FE8h case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0x2080);
		/* 82108FE8h case   11:*/		return 0x82108FEC;
		  /* 82108FECh */ case   12:  		/* cmplw CR6, R10, R9 */
		/* 82108FECh case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82108FECh case   12:*/		return 0x82108FF0;
		  /* 82108FF0h */ case   13:  		/* bc 12, CR6_EQ, 484 */
		/* 82108FF0h case   13:*/		if ( regs.CR[6].eq ) { return 0x821091D4;  }
		/* 82108FF0h case   13:*/		return 0x82108FF4;
		  /* 82108FF4h */ case   14:  		/* rlwinm R10, R11, 0, 0, 3 */
		/* 82108FF4h case   14:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R11);
		/* 82108FF4h case   14:*/		return 0x82108FF8;
		  /* 82108FF8h */ case   15:  		/* lis R9, 4096 */
		/* 82108FF8h case   15:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 82108FF8h case   15:*/		return 0x82108FFC;
		  /* 82108FFCh */ case   16:  		/* cmplw CR6, R10, R9 */
		/* 82108FFCh case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82108FFCh case   16:*/		return 0x82109000;
		  /* 82109000h */ case   17:  		/* bc 12, CR6_LT, 352 */
		/* 82109000h case   17:*/		if ( regs.CR[6].lt ) { return 0x82109160;  }
		/* 82109000h case   17:*/		return 0x82109004;
		  /* 82109004h */ case   18:  		/* lis R9, 16384 */
		/* 82109004h case   18:*/		cpu::op::lis<0>(regs,&regs.R9,0x4000);
		/* 82109004h case   18:*/		return 0x82109008;
		  /* 82109008h */ case   19:  		/* cmplw CR6, R10, R9 */
		/* 82109008h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82109008h case   19:*/		return 0x8210900C;
		  /* 8210900Ch */ case   20:  		/* bc 12, CR6_GT, 340 */
		/* 8210900Ch case   20:*/		if ( regs.CR[6].gt ) { return 0x82109160;  }
		/* 8210900Ch case   20:*/		return 0x82109010;
		  /* 82109010h */ case   21:  		/* lwz R10, <#[R31 + 12]> */
		/* 82109010h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109010h case   21:*/		return 0x82109014;
		  /* 82109014h */ case   22:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 82109014h case   22:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 82109014h case   22:*/		return 0x82109018;
		  /* 82109018h */ case   23:  		/* lwz R9, <#[R31 + 4]> */
		/* 82109018h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82109018h case   23:*/		return 0x8210901C;
		  /* 8210901Ch */ case   24:  		/* mr R27, R14 */
		/* 8210901Ch case   24:*/		regs.R27 = regs.R14;
		/* 8210901Ch case   24:*/		return 0x82109020;
		  /* 82109020h */ case   25:  		/* mr R8, R14 */
		/* 82109020h case   25:*/		regs.R8 = regs.R14;
		/* 82109020h case   25:*/		return 0x82109024;
		  /* 82109024h */ case   26:  		/* cmplwi CR6, R10, 0 */
		/* 82109024h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82109024h case   26:*/		return 0x82109028;
		  /* 82109028h */ case   27:  		/* divwu R26, R9, R11 */
		/* 82109028h case   27:*/		cpu::op::divwu<0>(regs,&regs.R26,regs.R9,regs.R11);
		/* 82109028h case   27:*/		return 0x8210902C;
		  /* 8210902Ch */ case   28:  		/* twi 6, R11, 0 */
		/* 8210902Ch case   28:*/		cpu::op::tw<6>(regs, 0x8210902C, regs.R11, 0x00000000);
		/* 8210902Ch case   28:*/		return 0x82109030;
		  /* 82109030h */ case   29:  		/* bc 4, CR6_GT, 152 */
		/* 82109030h case   29:*/		if ( !regs.CR[6].gt ) { return 0x821090C8;  }
		/* 82109030h case   29:*/		return 0x82109034;
		  /* 82109034h */ case   30:  		/* mr R7, R14 */
		/* 82109034h case   30:*/		regs.R7 = regs.R14;
		/* 82109034h case   30:*/		return 0x82109038;
		  /* 82109038h */ case   31:  		/* mr R9, R14 */
		/* 82109038h case   31:*/		regs.R9 = regs.R14;
		/* 82109038h case   31:*/		return 0x8210903C;
		  /* 8210903Ch */ case   32:  		/* lwz R11, <#[R31 + 16]> */
		/* 8210903Ch case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8210903Ch case   32:*/		return 0x82109040;
		  /* 82109040h */ case   33:  		/* lwz R10, <#[R16 + 20]> */
		/* 82109040h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000014) );
		/* 82109040h case   33:*/		return 0x82109044;
		  /* 82109044h */ case   34:  		/* lwzx R6, <#[R9 + R11]> */
		/* 82109044h case   34:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82109044h case   34:*/		return 0x82109048;
		  /* 82109048h */ case   35:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 82109048h case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 82109048h case   35:*/		return 0x8210904C;
		  /* 8210904Ch */ case   36:  		/* lwzx R10, <#[R6 + R10]> */
		/* 8210904Ch case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 8210904Ch case   36:*/		return 0x82109050;
		  /* 82109050h */ case   37:  		/* lwz R6, <#[R10 + 20]> */
		/* 82109050h case   37:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000014) );
		/* 82109050h case   37:*/		return 0x82109054;
		  /* 82109054h */ case   38:  		/* cmpwi CR6, R6, -1 */
		/* 82109054h case   38:*/		cpu::op::cmpwi<6>(regs,regs.R6,0xFFFFFFFF);
		/* 82109054h case   38:*/		return 0x82109058;
		  /* 82109058h */ case   39:  		/* bc 4, CR6_EQ, 16 */
		/* 82109058h case   39:*/		if ( !regs.CR[6].eq ) { return 0x82109068;  }
		/* 82109058h case   39:*/		return 0x8210905C;
		  /* 8210905Ch */ case   40:  		/* lwz R10, <#[R10 + 24]> */
		/* 8210905Ch case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 8210905Ch case   40:*/		return 0x82109060;
		  /* 82109060h */ case   41:  		/* cmpwi CR6, R10, 0 */
		/* 82109060h case   41:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82109060h case   41:*/		return 0x82109064;
		  /* 82109064h */ case   42:  		/* bc 12, CR6_EQ, 80 */
		/* 82109064h case   42:*/		if ( regs.CR[6].eq ) { return 0x821090B4;  }
		/* 82109064h case   42:*/		return 0x82109068;
	}
	return 0x82109068;
} // Block from 82108FBCh-82109068h (43 instructions)

//////////////////////////////////////////////////////
// Block at 82109068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109068);
		  /* 82109068h */ case    0:  		/* lwzx R6, <#[R9 + R11]> */
		/* 82109068h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82109068h case    0:*/		return 0x8210906C;
		  /* 8210906Ch */ case    1:  		/* mr R10, R14 */
		/* 8210906Ch case    1:*/		regs.R10 = regs.R14;
		/* 8210906Ch case    1:*/		return 0x82109070;
		  /* 82109070h */ case    2:  		/* cmplwi CR6, R26, 0 */
		/* 82109070h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82109070h case    2:*/		return 0x82109074;
		  /* 82109074h */ case    3:  		/* stwx R6, <#[R7 + R11]> */
		/* 82109074h case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82109074h case    3:*/		return 0x82109078;
		  /* 82109078h */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 82109078h case    4:*/		if ( regs.CR[6].eq ) { return 0x821090AC;  }
		/* 82109078h case    4:*/		return 0x8210907C;
		  /* 8210907Ch */ case    5:  		/* mtspr CTR, R26 */
		/* 8210907Ch case    5:*/		regs.CTR = regs.R26;
		/* 8210907Ch case    5:*/		return 0x82109080;
		  /* 82109080h */ case    6:  		/* lwz R11, <#[R31 + 12]> */
		/* 82109080h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109080h case    6:*/		return 0x82109084;
		  /* 82109084h */ case    7:  		/* lwz R6, <#[R31 + 8]> */
		/* 82109084h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 82109084h case    7:*/		return 0x82109088;
		  /* 82109088h */ case    8:  		/* mullw R11, R10, R11 */
		/* 82109088h case    8:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82109088h case    8:*/		return 0x8210908C;
		  /* 8210908Ch */ case    9:  		/* add R5, R11, R8 */
		/* 8210908Ch case    9:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R8);
		/* 8210908Ch case    9:*/		return 0x82109090;
		  /* 82109090h */ case   10:  		/* add R11, R11, R27 */
		/* 82109090h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 82109090h case   10:*/		return 0x82109094;
		  /* 82109094h */ case   11:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82109094h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82109094h case   11:*/		return 0x82109098;
		  /* 82109098h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109098h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109098h case   12:*/		return 0x8210909C;
		  /* 8210909Ch */ case   13:  		/* addi R10, R10, 1 */
		/* 8210909Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210909Ch case   13:*/		return 0x821090A0;
		  /* 821090A0h */ case   14:  		/* lwzx R5, <#[R5 + R6]> */
		/* 821090A0h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 821090A0h case   14:*/		return 0x821090A4;
		  /* 821090A4h */ case   15:  		/* stwx R5, <#[R11 + R6]> */
		/* 821090A4h case   15:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 821090A4h case   15:*/		return 0x821090A8;
		  /* 821090A8h */ case   16:  		/* bc 16, CR0_LT, -40 */
		/* 821090A8h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82109080;  }
		/* 821090A8h case   16:*/		return 0x821090AC;
	}
	return 0x821090AC;
} // Block from 82109068h-821090ACh (17 instructions)

//////////////////////////////////////////////////////
// Block at 821090ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821090AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821090AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821090AC);
		  /* 821090ACh */ case    0:  		/* addi R27, R27, 1 */
		/* 821090ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821090ACh case    0:*/		return 0x821090B0;
		  /* 821090B0h */ case    1:  		/* addi R7, R7, 4 */
		/* 821090B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 821090B0h case    1:*/		return 0x821090B4;
	}
	return 0x821090B4;
} // Block from 821090ACh-821090B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821090B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821090B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821090B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821090B4);
		  /* 821090B4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821090B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821090B4h case    0:*/		return 0x821090B8;
		  /* 821090B8h */ case    1:  		/* addi R8, R8, 1 */
		/* 821090B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821090B8h case    1:*/		return 0x821090BC;
		  /* 821090BCh */ case    2:  		/* addi R9, R9, 4 */
		/* 821090BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821090BCh case    2:*/		return 0x821090C0;
		  /* 821090C0h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 821090C0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 821090C0h case    3:*/		return 0x821090C4;
		  /* 821090C4h */ case    4:  		/* bc 12, CR6_LT, -136 */
		/* 821090C4h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210903C;  }
		/* 821090C4h case    4:*/		return 0x821090C8;
	}
	return 0x821090C8;
} // Block from 821090B4h-821090C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821090C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821090C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821090C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821090C8);
		  /* 821090C8h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821090C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821090C8h case    0:*/		return 0x821090CC;
		  /* 821090CCh */ case    1:  		/* cmplw CR6, R27, R11 */
		/* 821090CCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 821090CCh case    1:*/		return 0x821090D0;
		  /* 821090D0h */ case    2:  		/* bc 12, CR6_EQ, 976 */
		/* 821090D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x821094A0;  }
		/* 821090D0h case    2:*/		return 0x821090D4;
		  /* 821090D4h */ case    3:  		/* mr R30, R14 */
		/* 821090D4h case    3:*/		regs.R30 = regs.R14;
		/* 821090D4h case    3:*/		return 0x821090D8;
		  /* 821090D8h */ case    4:  		/* cmplwi CR6, R26, 0 */
		/* 821090D8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821090D8h case    4:*/		return 0x821090DC;
		  /* 821090DCh */ case    5:  		/* bc 12, CR6_EQ, 60 */
		/* 821090DCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82109118;  }
		/* 821090DCh case    5:*/		return 0x821090E0;
		  /* 821090E0h */ case    6:  		/* rlwinm R28, R27, 2, 0, 29 */
		/* 821090E0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R27);
		/* 821090E0h case    6:*/		return 0x821090E4;
		  /* 821090E4h */ case    7:  		/* mr R29, R14 */
		/* 821090E4h case    7:*/		regs.R29 = regs.R14;
		/* 821090E4h case    7:*/		return 0x821090E8;
		  /* 821090E8h */ case    8:  		/* lwz R10, <#[R31 + 12]> */
		/* 821090E8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 821090E8h case    8:*/		return 0x821090EC;
		  /* 821090ECh */ case    9:  		/* mr R5, R28 */
		/* 821090ECh case    9:*/		regs.R5 = regs.R28;
		/* 821090ECh case    9:*/		return 0x821090F0;
		  /* 821090F0h */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 821090F0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821090F0h case   10:*/		return 0x821090F4;
		  /* 821090F4h */ case   11:  		/* mullw R10, R30, R10 */
		/* 821090F4h case   11:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R30,regs.R10);
		/* 821090F4h case   11:*/		return 0x821090F8;
		  /* 821090F8h */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821090F8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821090F8h case   12:*/		return 0x821090FC;
		  /* 821090FCh */ case   13:  		/* add R3, R29, R11 */
		/* 821090FCh case   13:*/		cpu::op::add<0>(regs,&regs.R3,regs.R29,regs.R11);
		/* 821090FCh case   13:*/		return 0x82109100;
	}
	return 0x82109100;
} // Block from 821090C8h-82109100h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82109100h
// Function '?MergeInstructions@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109100);
		  /* 82109100h */ case    0:  		/* add R4, R10, R11 */
		/* 82109100h case    0:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 82109100h case    0:*/		return 0x82109104;
		  /* 82109104h */ case    1:  		/* bl -489300 */
		/* 82109104h case    1:*/		regs.LR = 0x82109108; return 0x820919B0;
		/* 82109104h case    1:*/		return 0x82109108;
		  /* 82109108h */ case    2:  		/* addi R30, R30, 1 */
		/* 82109108h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82109108h case    2:*/		return 0x8210910C;
		  /* 8210910Ch */ case    3:  		/* add R29, R29, R28 */
		/* 8210910Ch case    3:*/		cpu::op::add<0>(regs,&regs.R29,regs.R29,regs.R28);
		/* 8210910Ch case    3:*/		return 0x82109110;
		  /* 82109110h */ case    4:  		/* cmplw CR6, R30, R26 */
		/* 82109110h case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R26);
		/* 82109110h case    4:*/		return 0x82109114;
		  /* 82109114h */ case    5:  		/* bc 12, CR6_LT, -44 */
		/* 82109114h case    5:*/		if ( regs.CR[6].lt ) { return 0x821090E8;  }
		/* 82109114h case    5:*/		return 0x82109118;
	}
	return 0x82109118;
} // Block from 82109100h-82109118h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82109118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109118);
		  /* 82109118h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 82109118h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82109118h case    0:*/		return 0x8210911C;
		  /* 8210911Ch */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 8210911Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8210914C;  }
		/* 8210911Ch case    1:*/		return 0x82109120;
		  /* 82109120h */ case    2:  		/* lwz R10, <#[R31]> */
		/* 82109120h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82109120h case    2:*/		return 0x82109124;
		  /* 82109124h */ case    3:  		/* mr R11, R27 */
		/* 82109124h case    3:*/		regs.R11 = regs.R27;
		/* 82109124h case    3:*/		return 0x82109128;
		  /* 82109128h */ case    4:  		/* rlwimi R11, R10, 0, 0, 11 */
		/* 82109128h case    4:*/		cpu::op::rlwimi<0,0,0,11>(regs,&regs.R11,regs.R10);
		/* 82109128h case    4:*/		return 0x8210912C;
		  /* 8210912Ch */ case    5:  		/* b 36 */
		/* 8210912Ch case    5:*/		return 0x82109150;
		/* 8210912Ch case    5:*/		return 0x82109130;
	}
	return 0x82109130;
} // Block from 82109118h-82109130h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82109130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109130);
		  /* 82109130h */ case    0:  		/* fcmpu CR6, FR0, FR31 */
		/* 82109130h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 82109130h case    0:*/		return 0x82109134;
		  /* 82109134h */ case    1:  		/* bc 12, CR6_EQ, -424 */
		/* 82109134h case    1:*/		if ( regs.CR[6].eq ) { return 0x82108F8C;  }
		/* 82109134h case    1:*/		return 0x82109138;
	}
	return 0x82109138;
} // Block from 82109130h-82109138h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82109138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109138);
		  /* 82109138h */ case    0:  		/* lwz R11, <#[R16 + 20]> */
		/* 82109138h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000014) );
		/* 82109138h case    0:*/		return 0x8210913C;
		  /* 8210913Ch */ case    1:  		/* lwzx R11, <#[R8 + R11]> */
		/* 8210913Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210913Ch case    1:*/		return 0x82109140;
		  /* 82109140h */ case    2:  		/* lwz R10, <#[R11 + 24]> */
		/* 82109140h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 82109140h case    2:*/		return 0x82109144;
		  /* 82109144h */ case    3:  		/* lwz R11, <#[R11 + 20]> */
		/* 82109144h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82109144h case    3:*/		return 0x82109148;
		  /* 82109148h */ case    4:  		/* b -436 */
		/* 82109148h case    4:*/		return 0x82108F94;
		/* 82109148h case    4:*/		return 0x8210914C;
	}
	return 0x8210914C;
} // Block from 82109138h-8210914Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210914Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210914C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210914C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210914C);
		  /* 8210914Ch */ case    0:  		/* mr R11, R14 */
		/* 8210914Ch case    0:*/		regs.R11 = regs.R14;
		/* 8210914Ch case    0:*/		return 0x82109150;
	}
	return 0x82109150;
} // Block from 8210914Ch-82109150h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82109150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109150);
		  /* 82109150h */ case    0:  		/* mullw R10, R26, R27 */
		/* 82109150h case    0:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R26,regs.R27);
		/* 82109150h case    0:*/		return 0x82109154;
		  /* 82109154h */ case    1:  		/* stw R27, <#[R31 + 12]> */
		/* 82109154h case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109154h case    1:*/		return 0x82109158;
		  /* 82109158h */ case    2:  		/* stw R10, <#[R31 + 4]> */
		/* 82109158h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82109158h case    2:*/		return 0x8210915C;
		  /* 8210915Ch */ case    3:  		/* b 828 */
		/* 8210915Ch case    3:*/		return 0x82109498;
		/* 8210915Ch case    3:*/		return 0x82109160;
	}
	return 0x82109160;
} // Block from 82109150h-82109160h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82109160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109160);
		  /* 82109160h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82109160h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109160h case    0:*/		return 0x82109164;
		  /* 82109164h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82109164h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82109164h case    1:*/		return 0x82109168;
		  /* 82109168h */ case    2:  		/* bc 12, CR6_EQ, 824 */
		/* 82109168h case    2:*/		if ( regs.CR[6].eq ) { return 0x821094A0;  }
		/* 82109168h case    2:*/		return 0x8210916C;
		  /* 8210916Ch */ case    3:  		/* lwz R9, <#[R31 + 16]> */
		/* 8210916Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 8210916Ch case    3:*/		return 0x82109170;
		  /* 82109170h */ case    4:  		/* mr R5, R14 */
		/* 82109170h case    4:*/		regs.R5 = regs.R14;
		/* 82109170h case    4:*/		return 0x82109174;
		  /* 82109174h */ case    5:  		/* lwz R8, <#[R16 + 20]> */
		/* 82109174h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R16 + 0x00000014) );
		/* 82109174h case    5:*/		return 0x82109178;
		  /* 82109178h */ case    6:  		/* mr R6, R14 */
		/* 82109178h case    6:*/		regs.R6 = regs.R14;
		/* 82109178h case    6:*/		return 0x8210917C;
		  /* 8210917Ch */ case    7:  		/* lwz R7, <#[R31 + 12]> */
		/* 8210917Ch case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210917Ch case    7:*/		return 0x82109180;
		  /* 82109180h */ case    8:  		/* mr R11, R14 */
		/* 82109180h case    8:*/		regs.R11 = regs.R14;
		/* 82109180h case    8:*/		return 0x82109184;
		  /* 82109184h */ case    9:  		/* lwzx R10, <#[R11 + R9]> */
		/* 82109184h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82109184h case    9:*/		return 0x82109188;
		  /* 82109188h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82109188h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82109188h case   10:*/		return 0x8210918C;
		  /* 8210918Ch */ case   11:  		/* lwzx R10, <#[R10 + R8]> */
		/* 8210918Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 8210918Ch case   11:*/		return 0x82109190;
		  /* 82109190h */ case   12:  		/* lwz R4, <#[R10 + 20]> */
		/* 82109190h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000014) );
		/* 82109190h case   12:*/		return 0x82109194;
		  /* 82109194h */ case   13:  		/* cmpwi CR6, R4, -1 */
		/* 82109194h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 82109194h case   13:*/		return 0x82109198;
		  /* 82109198h */ case   14:  		/* bc 4, CR6_EQ, 16 */
		/* 82109198h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821091A8;  }
		/* 82109198h case   14:*/		return 0x8210919C;
		  /* 8210919Ch */ case   15:  		/* lwz R10, <#[R10 + 24]> */
		/* 8210919Ch case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 8210919Ch case   15:*/		return 0x821091A0;
		  /* 821091A0h */ case   16:  		/* cmpwi CR6, R10, 0 */
		/* 821091A0h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 821091A0h case   16:*/		return 0x821091A4;
		  /* 821091A4h */ case   17:  		/* bc 12, CR6_EQ, 8 */
		/* 821091A4h case   17:*/		if ( regs.CR[6].eq ) { return 0x821091AC;  }
		/* 821091A4h case   17:*/		return 0x821091A8;
	}
	return 0x821091A8;
} // Block from 82109160h-821091A8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821091A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821091A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821091A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821091A8);
		  /* 821091A8h */ case    0:  		/* addi R5, R5, 1 */
		/* 821091A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 821091A8h case    0:*/		return 0x821091AC;
	}
	return 0x821091AC;
} // Block from 821091A8h-821091ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821091ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821091AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821091AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821091AC);
		  /* 821091ACh */ case    0:  		/* addi R6, R6, 1 */
		/* 821091ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821091ACh case    0:*/		return 0x821091B0;
		  /* 821091B0h */ case    1:  		/* addi R11, R11, 4 */
		/* 821091B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821091B0h case    1:*/		return 0x821091B4;
		  /* 821091B4h */ case    2:  		/* cmplw CR6, R6, R7 */
		/* 821091B4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 821091B4h case    2:*/		return 0x821091B8;
		  /* 821091B8h */ case    3:  		/* bc 12, CR6_LT, -52 */
		/* 821091B8h case    3:*/		if ( regs.CR[6].lt ) { return 0x82109184;  }
		/* 821091B8h case    3:*/		return 0x821091BC;
		  /* 821091BCh */ case    4:  		/* cmplwi CR6, R5, 0 */
		/* 821091BCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821091BCh case    4:*/		return 0x821091C0;
		  /* 821091C0h */ case    5:  		/* bc 4, CR6_EQ, 736 */
		/* 821091C0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821094A0;  }
		/* 821091C0h case    5:*/		return 0x821091C4;
		  /* 821091C4h */ case    6:  		/* stw R14, <#[R31]> */
		/* 821091C4h case    6:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R31 + 0x00000000) );
		/* 821091C4h case    6:*/		return 0x821091C8;
		  /* 821091C8h */ case    7:  		/* stw R14, <#[R31 + 4]> */
		/* 821091C8h case    7:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R31 + 0x00000004) );
		/* 821091C8h case    7:*/		return 0x821091CC;
		  /* 821091CCh */ case    8:  		/* stw R14, <#[R31 + 12]> */
		/* 821091CCh case    8:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R31 + 0x0000000C) );
		/* 821091CCh case    8:*/		return 0x821091D0;
		  /* 821091D0h */ case    9:  		/* b 716 */
		/* 821091D0h case    9:*/		return 0x8210949C;
		/* 821091D0h case    9:*/		return 0x821091D4;
	}
	return 0x821091D4;
} // Block from 821091ACh-821091D4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821091D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821091D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821091D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821091D4);
		  /* 821091D4h */ case    0:  		/* lwz R10, <#[R31 + 12]> */
		/* 821091D4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 821091D4h case    0:*/		return 0x821091D8;
		  /* 821091D8h */ case    1:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 821091D8h case    1:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 821091D8h case    1:*/		return 0x821091DC;
		  /* 821091DCh */ case    2:  		/* lwz R9, <#[R31 + 4]> */
		/* 821091DCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 821091DCh case    2:*/		return 0x821091E0;
		  /* 821091E0h */ case    3:  		/* mr R27, R14 */
		/* 821091E0h case    3:*/		regs.R27 = regs.R14;
		/* 821091E0h case    3:*/		return 0x821091E4;
		  /* 821091E4h */ case    4:  		/* mr R4, R14 */
		/* 821091E4h case    4:*/		regs.R4 = regs.R14;
		/* 821091E4h case    4:*/		return 0x821091E8;
		  /* 821091E8h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 821091E8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821091E8h case    5:*/		return 0x821091EC;
		  /* 821091ECh */ case    6:  		/* divwu R26, R9, R11 */
		/* 821091ECh case    6:*/		cpu::op::divwu<0>(regs,&regs.R26,regs.R9,regs.R11);
		/* 821091ECh case    6:*/		return 0x821091F0;
		  /* 821091F0h */ case    7:  		/* twi 6, R11, 0 */
		/* 821091F0h case    7:*/		cpu::op::tw<6>(regs, 0x821091F0, regs.R11, 0x00000000);
		/* 821091F0h case    7:*/		return 0x821091F4;
		  /* 821091F4h */ case    8:  		/* bc 4, CR6_GT, 288 */
		/* 821091F4h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82109314;  }
		/* 821091F4h case    8:*/		return 0x821091F8;
		  /* 821091F8h */ case    9:  		/* mr R3, R14 */
		/* 821091F8h case    9:*/		regs.R3 = regs.R14;
		/* 821091F8h case    9:*/		return 0x821091FC;
		  /* 821091FCh */ case   10:  		/* mr R5, R14 */
		/* 821091FCh case   10:*/		regs.R5 = regs.R14;
		/* 821091FCh case   10:*/		return 0x82109200;
		  /* 82109200h */ case   11:  		/* lwz R6, <#[R31 + 16]> */
		/* 82109200h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 82109200h case   11:*/		return 0x82109204;
		  /* 82109204h */ case   12:  		/* lwz R11, <#[R16 + 20]> */
		/* 82109204h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000014) );
		/* 82109204h case   12:*/		return 0x82109208;
		  /* 82109208h */ case   13:  		/* lwzx R10, <#[R5 + R6]> */
		/* 82109208h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 82109208h case   13:*/		return 0x8210920C;
		  /* 8210920Ch */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210920Ch case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210920Ch case   14:*/		return 0x82109210;
		  /* 82109210h */ case   15:  		/* lwzx R7, <#[R10 + R11]> */
		/* 82109210h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82109210h case   15:*/		return 0x82109214;
		  /* 82109214h */ case   16:  		/* lwz R10, <#[R7 + 20]> */
		/* 82109214h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000014) );
		/* 82109214h case   16:*/		return 0x82109218;
		  /* 82109218h */ case   17:  		/* cmpwi CR6, R10, -1 */
		/* 82109218h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82109218h case   17:*/		return 0x8210921C;
		  /* 8210921Ch */ case   18:  		/* bc 4, CR6_EQ, 16 */
		/* 8210921Ch case   18:*/		if ( !regs.CR[6].eq ) { return 0x8210922C;  }
		/* 8210921Ch case   18:*/		return 0x82109220;
		  /* 82109220h */ case   19:  		/* lwz R10, <#[R7 + 24]> */
		/* 82109220h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000018) );
		/* 82109220h case   19:*/		return 0x82109224;
		  /* 82109224h */ case   20:  		/* cmpwi CR6, R10, 0 */
		/* 82109224h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82109224h case   20:*/		return 0x82109228;
		  /* 82109228h */ case   21:  		/* bc 12, CR6_EQ, 216 */
		/* 82109228h case   21:*/		if ( regs.CR[6].eq ) { return 0x82109300;  }
		/* 82109228h case   21:*/		return 0x8210922C;
	}
	return 0x8210922C;
} // Block from 821091D4h-8210922Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 8210922Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210922C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210922C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210922C);
		  /* 8210922Ch */ case    0:  		/* lwz R9, <#[R31 + 8]> */
		/* 8210922Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8210922Ch case    0:*/		return 0x82109230;
		  /* 82109230h */ case    1:  		/* lwz R10, <#[R31 + 12]> */
		/* 82109230h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109230h case    1:*/		return 0x82109234;
		  /* 82109234h */ case    2:  		/* add R10, R4, R10 */
		/* 82109234h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R4,regs.R10);
		/* 82109234h case    2:*/		return 0x82109238;
		  /* 82109238h */ case    3:  		/* lwzx R8, <#[R5 + R9]> */
		/* 82109238h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 82109238h case    3:*/		return 0x8210923C;
		  /* 8210923Ch */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210923Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210923Ch case    4:*/		return 0x82109240;
		  /* 82109240h */ case    5:  		/* rlwinm R30, R8, 2, 0, 29 */
		/* 82109240h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R8);
		/* 82109240h case    5:*/		return 0x82109244;
		  /* 82109244h */ case    6:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82109244h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82109244h case    6:*/		return 0x82109248;
		  /* 82109248h */ case    7:  		/* lwzx R9, <#[R30 + R11]> */
		/* 82109248h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82109248h case    7:*/		return 0x8210924C;
		  /* 8210924Ch */ case    8:  		/* lwz R30, <#[R9 + 20]> */
		/* 8210924Ch case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000014) );
		/* 8210924Ch case    8:*/		return 0x82109250;
		  /* 82109250h */ case    9:  		/* cmpwi CR6, R30, -1 */
		/* 82109250h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 82109250h case    9:*/		return 0x82109254;
		  /* 82109254h */ case   10:  		/* bc 4, CR6_EQ, 44 */
		/* 82109254h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82109280;  }
		/* 82109254h case   10:*/		return 0x82109258;
		  /* 82109258h */ case   11:  		/* lwz R30, <#[R9 + 24]> */
		/* 82109258h case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000018) );
		/* 82109258h case   11:*/		return 0x8210925C;
		  /* 8210925Ch */ case   12:  		/* cmpwi CR6, R30, 0 */
		/* 8210925Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8210925Ch case   12:*/		return 0x82109260;
		  /* 82109260h */ case   13:  		/* bc 4, CR6_EQ, 32 */
		/* 82109260h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82109280;  }
		/* 82109260h case   13:*/		return 0x82109264;
		  /* 82109264h */ case   14:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 82109264h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 82109264h case   14:*/		return 0x82109268;
		  /* 82109268h */ case   15:  		/* lwz R8, <#[R16 + 136]> */
		/* 82109268h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R16 + 0x00000088) );
		/* 82109268h case   15:*/		return 0x8210926C;
		  /* 8210926Ch */ case   16:  		/* li R25, 1 */
		/* 8210926Ch case   16:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8210926Ch case   16:*/		return 0x82109270;
		  /* 82109270h */ case   17:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82109270h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82109270h case   17:*/		return 0x82109274;
		  /* 82109274h */ case   18:  		/* stw R8, <#[R11 + 4]> */
		/* 82109274h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82109274h case   18:*/		return 0x82109278;
		  /* 82109278h */ case   19:  		/* stw R10, <#[R7 + 48]> */
		/* 82109278h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000030) );
		/* 82109278h case   19:*/		return 0x8210927C;
		  /* 8210927Ch */ case   20:  		/* b 132 */
		/* 8210927Ch case   20:*/		return 0x82109300;
		/* 8210927Ch case   20:*/		return 0x82109280;
	}
	return 0x82109280;
} // Block from 8210922Ch-82109280h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82109280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109280);
		  /* 82109280h */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82109280h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82109280h case    0:*/		return 0x82109284;
		  /* 82109284h */ case    1:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82109284h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82109284h case    1:*/		return 0x82109288;
		  /* 82109288h */ case    2:  		/* lwz R10, <#[R11 + 20]> */
		/* 82109288h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82109288h case    2:*/		return 0x8210928C;
		  /* 8210928Ch */ case    3:  		/* cmpwi CR6, R10, -1 */
		/* 8210928Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210928Ch case    3:*/		return 0x82109290;
		  /* 82109290h */ case    4:  		/* bc 4, CR6_EQ, 36 */
		/* 82109290h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821092B4;  }
		/* 82109290h case    4:*/		return 0x82109294;
		  /* 82109294h */ case    5:  		/* lwz R11, <#[R11 + 24]> */
		/* 82109294h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82109294h case    5:*/		return 0x82109298;
		  /* 82109298h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82109298h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82109298h case    6:*/		return 0x8210929C;
		  /* 8210929Ch */ case    7:  		/* bc 4, CR6_EQ, 24 */
		/* 8210929Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x821092B4;  }
		/* 8210929Ch case    7:*/		return 0x821092A0;
		  /* 821092A0h */ case    8:  		/* lwz R11, <#[R16 + 136]> */
		/* 821092A0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000088) );
		/* 821092A0h case    8:*/		return 0x821092A4;
		  /* 821092A4h */ case    9:  		/* li R25, 1 */
		/* 821092A4h case    9:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 821092A4h case    9:*/		return 0x821092A8;
		  /* 821092A8h */ case   10:  		/* stw R11, <#[R9 + 4]> */
		/* 821092A8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 821092A8h case   10:*/		return 0x821092AC;
		  /* 821092ACh */ case   11:  		/* stw R8, <#[R7 + 48]> */
		/* 821092ACh case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000030) );
		/* 821092ACh case   11:*/		return 0x821092B0;
		  /* 821092B0h */ case   12:  		/* b 80 */
		/* 821092B0h case   12:*/		return 0x82109300;
		/* 821092B0h case   12:*/		return 0x821092B4;
	}
	return 0x821092B4;
} // Block from 82109280h-821092B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821092B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821092B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821092B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821092B4);
		  /* 821092B4h */ case    0:  		/* lwzx R10, <#[R5 + R6]> */
		/* 821092B4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 821092B4h case    0:*/		return 0x821092B8;
		  /* 821092B8h */ case    1:  		/* mr R11, R14 */
		/* 821092B8h case    1:*/		regs.R11 = regs.R14;
		/* 821092B8h case    1:*/		return 0x821092BC;
		  /* 821092BCh */ case    2:  		/* cmplwi CR6, R26, 0 */
		/* 821092BCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821092BCh case    2:*/		return 0x821092C0;
		  /* 821092C0h */ case    3:  		/* stwx R10, <#[R3 + R6]> */
		/* 821092C0h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + regs.R6 + 0x00000000) );
		/* 821092C0h case    3:*/		return 0x821092C4;
		  /* 821092C4h */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 821092C4h case    4:*/		if ( regs.CR[6].eq ) { return 0x821092F8;  }
		/* 821092C4h case    4:*/		return 0x821092C8;
		  /* 821092C8h */ case    5:  		/* mtspr CTR, R26 */
		/* 821092C8h case    5:*/		regs.CTR = regs.R26;
		/* 821092C8h case    5:*/		return 0x821092CC;
		  /* 821092CCh */ case    6:  		/* lwz R10, <#[R31 + 12]> */
		/* 821092CCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 821092CCh case    6:*/		return 0x821092D0;
		  /* 821092D0h */ case    7:  		/* lwz R9, <#[R31 + 8]> */
		/* 821092D0h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821092D0h case    7:*/		return 0x821092D4;
		  /* 821092D4h */ case    8:  		/* mullw R10, R11, R10 */
		/* 821092D4h case    8:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 821092D4h case    8:*/		return 0x821092D8;
		  /* 821092D8h */ case    9:  		/* add R8, R10, R4 */
		/* 821092D8h case    9:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R4);
		/* 821092D8h case    9:*/		return 0x821092DC;
		  /* 821092DCh */ case   10:  		/* add R10, R10, R27 */
		/* 821092DCh case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R27);
		/* 821092DCh case   10:*/		return 0x821092E0;
		  /* 821092E0h */ case   11:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 821092E0h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 821092E0h case   11:*/		return 0x821092E4;
		  /* 821092E4h */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821092E4h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821092E4h case   12:*/		return 0x821092E8;
		  /* 821092E8h */ case   13:  		/* addi R11, R11, 1 */
		/* 821092E8h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821092E8h case   13:*/		return 0x821092EC;
		  /* 821092ECh */ case   14:  		/* lwzx R8, <#[R8 + R9]> */
		/* 821092ECh case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 821092ECh case   14:*/		return 0x821092F0;
		  /* 821092F0h */ case   15:  		/* stwx R8, <#[R10 + R9]> */
		/* 821092F0h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821092F0h case   15:*/		return 0x821092F4;
		  /* 821092F4h */ case   16:  		/* bc 16, CR0_LT, -40 */
		/* 821092F4h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821092CC;  }
		/* 821092F4h case   16:*/		return 0x821092F8;
	}
	return 0x821092F8;
} // Block from 821092B4h-821092F8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821092F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821092F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821092F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821092F8);
		  /* 821092F8h */ case    0:  		/* addi R27, R27, 1 */
		/* 821092F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821092F8h case    0:*/		return 0x821092FC;
		  /* 821092FCh */ case    1:  		/* addi R3, R3, 4 */
		/* 821092FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 821092FCh case    1:*/		return 0x82109300;
	}
	return 0x82109300;
} // Block from 821092F8h-82109300h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82109300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109300);
		  /* 82109300h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82109300h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109300h case    0:*/		return 0x82109304;
		  /* 82109304h */ case    1:  		/* addi R4, R4, 1 */
		/* 82109304h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82109304h case    1:*/		return 0x82109308;
		  /* 82109308h */ case    2:  		/* addi R5, R5, 4 */
		/* 82109308h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 82109308h case    2:*/		return 0x8210930C;
		  /* 8210930Ch */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 8210930Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8210930Ch case    3:*/		return 0x82109310;
		  /* 82109310h */ case    4:  		/* bc 12, CR6_LT, -272 */
		/* 82109310h case    4:*/		if ( regs.CR[6].lt ) { return 0x82109200;  }
		/* 82109310h case    4:*/		return 0x82109314;
	}
	return 0x82109314;
} // Block from 82109300h-82109314h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82109314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109314);
		  /* 82109314h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82109314h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109314h case    0:*/		return 0x82109318;
		  /* 82109318h */ case    1:  		/* cmplw CR6, R27, R11 */
		/* 82109318h case    1:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82109318h case    1:*/		return 0x8210931C;
		  /* 8210931Ch */ case    2:  		/* bc 12, CR6_EQ, 388 */
		/* 8210931Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821094A0;  }
		/* 8210931Ch case    2:*/		return 0x82109320;
		  /* 82109320h */ case    3:  		/* mr R30, R14 */
		/* 82109320h case    3:*/		regs.R30 = regs.R14;
		/* 82109320h case    3:*/		return 0x82109324;
		  /* 82109324h */ case    4:  		/* cmplwi CR6, R26, 0 */
		/* 82109324h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82109324h case    4:*/		return 0x82109328;
		  /* 82109328h */ case    5:  		/* bc 12, CR6_EQ, -528 */
		/* 82109328h case    5:*/		if ( regs.CR[6].eq ) { return 0x82109118;  }
		/* 82109328h case    5:*/		return 0x8210932C;
		  /* 8210932Ch */ case    6:  		/* rlwinm R28, R27, 2, 0, 29 */
		/* 8210932Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R27);
		/* 8210932Ch case    6:*/		return 0x82109330;
		  /* 82109330h */ case    7:  		/* mr R29, R14 */
		/* 82109330h case    7:*/		regs.R29 = regs.R14;
		/* 82109330h case    7:*/		return 0x82109334;
		  /* 82109334h */ case    8:  		/* lwz R10, <#[R31 + 12]> */
		/* 82109334h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109334h case    8:*/		return 0x82109338;
		  /* 82109338h */ case    9:  		/* mr R5, R28 */
		/* 82109338h case    9:*/		regs.R5 = regs.R28;
		/* 82109338h case    9:*/		return 0x8210933C;
		  /* 8210933Ch */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210933Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210933Ch case   10:*/		return 0x82109340;
		  /* 82109340h */ case   11:  		/* mullw R10, R30, R10 */
		/* 82109340h case   11:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R30,regs.R10);
		/* 82109340h case   11:*/		return 0x82109344;
		  /* 82109344h */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82109344h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82109344h case   12:*/		return 0x82109348;
		  /* 82109348h */ case   13:  		/* add R3, R11, R29 */
		/* 82109348h case   13:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 82109348h case   13:*/		return 0x8210934C;
		  /* 8210934Ch */ case   14:  		/* add R4, R10, R11 */
		/* 8210934Ch case   14:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8210934Ch case   14:*/		return 0x82109350;
		  /* 82109350h */ case   15:  		/* bl -489888 */
		/* 82109350h case   15:*/		regs.LR = 0x82109354; return 0x820919B0;
		/* 82109350h case   15:*/		return 0x82109354;
		  /* 82109354h */ case   16:  		/* addi R30, R30, 1 */
		/* 82109354h case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82109354h case   16:*/		return 0x82109358;
		  /* 82109358h */ case   17:  		/* add R29, R28, R29 */
		/* 82109358h case   17:*/		cpu::op::add<0>(regs,&regs.R29,regs.R28,regs.R29);
		/* 82109358h case   17:*/		return 0x8210935C;
		  /* 8210935Ch */ case   18:  		/* cmplw CR6, R30, R26 */
		/* 8210935Ch case   18:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R26);
		/* 8210935Ch case   18:*/		return 0x82109360;
		  /* 82109360h */ case   19:  		/* bc 12, CR6_LT, -44 */
		/* 82109360h case   19:*/		if ( regs.CR[6].lt ) { return 0x82109334;  }
		/* 82109360h case   19:*/		return 0x82109364;
		  /* 82109364h */ case   20:  		/* b -588 */
		/* 82109364h case   20:*/		return 0x82109118;
		/* 82109364h case   20:*/		return 0x82109368;
	}
	return 0x82109368;
} // Block from 82109314h-82109368h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82109368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109368);
		  /* 82109368h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82109368h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109368h case    0:*/		return 0x8210936C;
		  /* 8210936Ch */ case    1:  		/* mr R8, R14 */
		/* 8210936Ch case    1:*/		regs.R8 = regs.R14;
		/* 8210936Ch case    1:*/		return 0x82109370;
		  /* 82109370h */ case    2:  		/* mr R6, R14 */
		/* 82109370h case    2:*/		regs.R6 = regs.R14;
		/* 82109370h case    2:*/		return 0x82109374;
		  /* 82109374h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82109374h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82109374h case    3:*/		return 0x82109378;
		  /* 82109378h */ case    4:  		/* bc 4, CR6_GT, 244 */
		/* 82109378h case    4:*/		if ( !regs.CR[6].gt ) { return 0x8210946C;  }
		/* 82109378h case    4:*/		return 0x8210937C;
		  /* 8210937Ch */ case    5:  		/* mr R7, R14 */
		/* 8210937Ch case    5:*/		regs.R7 = regs.R14;
		/* 8210937Ch case    5:*/		return 0x82109380;
		  /* 82109380h */ case    6:  		/* mr R11, R14 */
		/* 82109380h case    6:*/		regs.R11 = regs.R14;
		/* 82109380h case    6:*/		return 0x82109384;
		  /* 82109384h */ case    7:  		/* lwz R10, <#[R31 + 8]> */
		/* 82109384h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82109384h case    7:*/		return 0x82109388;
		  /* 82109388h */ case    8:  		/* lwz R4, <#[R31 + 16]> */
		/* 82109388h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 82109388h case    8:*/		return 0x8210938C;
		  /* 8210938Ch */ case    9:  		/* lwz R9, <#[R16 + 20]> */
		/* 8210938Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R16 + 0x00000014) );
		/* 8210938Ch case    9:*/		return 0x82109390;
		  /* 82109390h */ case   10:  		/* lwz R5, <#[R16 + 16]> */
		/* 82109390h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R16 + 0x00000010) );
		/* 82109390h case   10:*/		return 0x82109394;
		  /* 82109394h */ case   11:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82109394h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82109394h case   11:*/		return 0x82109398;
		  /* 82109398h */ case   12:  		/* lwzx R4, <#[R4 + R11]> */
		/* 82109398h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 82109398h case   12:*/		return 0x8210939C;
		  /* 8210939Ch */ case   13:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210939Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210939Ch case   13:*/		return 0x821093A0;
		  /* 821093A0h */ case   14:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 821093A0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 821093A0h case   14:*/		return 0x821093A4;
		  /* 821093A4h */ case   15:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821093A4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821093A4h case   15:*/		return 0x821093A8;
		  /* 821093A8h */ case   16:  		/* lwzx R9, <#[R4 + R9]> */
		/* 821093A8h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + regs.R9 + 0x00000000) );
		/* 821093A8h case   16:*/		return 0x821093AC;
		  /* 821093ACh */ case   17:  		/* lwz R4, <#[R10 + 4]> */
		/* 821093ACh case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 821093ACh case   17:*/		return 0x821093B0;
		  /* 821093B0h */ case   18:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 821093B0h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 821093B0h case   18:*/		return 0x821093B4;
		  /* 821093B4h */ case   19:  		/* lwzx R5, <#[R4 + R5]> */
		/* 821093B4h case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + regs.R5 + 0x00000000) );
		/* 821093B4h case   19:*/		return 0x821093B8;
		  /* 821093B8h */ case   20:  		/* lwz R5, <#[R5 + 4]> */
		/* 821093B8h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000004) );
		/* 821093B8h case   20:*/		return 0x821093BC;
		  /* 821093BCh */ case   21:  		/* rlwinm. R5, R5, 0, 23, 23 */
		/* 821093BCh case   21:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R5,regs.R5);
		/* 821093BCh case   21:*/		return 0x821093C0;
		  /* 821093C0h */ case   22:  		/* bc 12, CR0_EQ, 60 */
		/* 821093C0h case   22:*/		if ( regs.CR[0].eq ) { return 0x821093FC;  }
		/* 821093C0h case   22:*/		return 0x821093C4;
		  /* 821093C4h */ case   23:  		/* lwz R5, <#[R10 + 8]> */
		/* 821093C4h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000008) );
		/* 821093C4h case   23:*/		return 0x821093C8;
		  /* 821093C8h */ case   24:  		/* cmpwi CR6, R5, -1 */
		/* 821093C8h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 821093C8h case   24:*/		return 0x821093CC;
		  /* 821093CCh */ case   25:  		/* bc 4, CR6_EQ, 48 */
		/* 821093CCh case   25:*/		if ( !regs.CR[6].eq ) { return 0x821093FC;  }
		/* 821093CCh case   25:*/		return 0x821093D0;
		  /* 821093D0h */ case   26:  		/* lwz R5, <#[R9]> */
		/* 821093D0h case   26:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000000) );
		/* 821093D0h case   26:*/		return 0x821093D4;
		  /* 821093D4h */ case   27:  		/* ori R5, R5, 128 */
		/* 821093D4h case   27:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x80);
		/* 821093D4h case   27:*/		return 0x821093D8;
		  /* 821093D8h */ case   28:  		/* stw R5, <#[R9]> */
		/* 821093D8h case   28:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R9 + 0x00000000) );
		/* 821093D8h case   28:*/		return 0x821093DC;
		  /* 821093DCh */ case   29:  		/* lfd FR0, <#[R10 + 32]> */
		/* 821093DCh case   29:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 821093DCh case   29:*/		return 0x821093E0;
		  /* 821093E0h */ case   30:  		/* fcmpu CR6, FR0, FR31 */
		/* 821093E0h case   30:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 821093E0h case   30:*/		return 0x821093E4;
		  /* 821093E4h */ case   31:  		/* bc 12, CR6_EQ, 12 */
		/* 821093E4h case   31:*/		if ( regs.CR[6].eq ) { return 0x821093F0;  }
		/* 821093E4h case   31:*/		return 0x821093E8;
		  /* 821093E8h */ case   32:  		/* fmr FR0, FR30 */
		/* 821093E8h case   32:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR30);
		/* 821093E8h case   32:*/		return 0x821093EC;
		  /* 821093ECh */ case   33:  		/* b 8 */
		/* 821093ECh case   33:*/		return 0x821093F4;
		/* 821093ECh case   33:*/		return 0x821093F0;
	}
	return 0x821093F0;
} // Block from 82109368h-821093F0h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821093F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821093F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821093F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821093F0);
		  /* 821093F0h */ case    0:  		/* fmr FR0, FR31 */
		/* 821093F0h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR31);
		/* 821093F0h case    0:*/		return 0x821093F4;
	}
	return 0x821093F4;
} // Block from 821093F0h-821093F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821093F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821093F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821093F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821093F4);
		  /* 821093F4h */ case    0:  		/* stfd FR0, <#[R9 + 32]> */
		/* 821093F4h case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R9 + 0x00000020) );
		/* 821093F4h case    0:*/		return 0x821093F8;
		  /* 821093F8h */ case    1:  		/* b 52 */
		/* 821093F8h case    1:*/		return 0x8210942C;
		/* 821093F8h case    1:*/		return 0x821093FC;
	}
	return 0x821093FC;
} // Block from 821093F4h-821093FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821093FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821093FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821093FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821093FC);
		  /* 821093FCh */ case    0:  		/* lwz R10, <#[R10]> */
		/* 821093FCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821093FCh case    0:*/		return 0x82109400;
		  /* 82109400h */ case    1:  		/* rlwinm. R5, R10, 0, 29, 29 */
		/* 82109400h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R5,regs.R10);
		/* 82109400h case    1:*/		return 0x82109404;
		  /* 82109404h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 82109404h case    2:*/		if ( regs.CR[0].eq ) { return 0x82109420;  }
		/* 82109404h case    2:*/		return 0x82109408;
		  /* 82109408h */ case    3:  		/* rlwinm. R10, R10, 0, 28, 28 */
		/* 82109408h case    3:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R10);
		/* 82109408h case    3:*/		return 0x8210940C;
		  /* 8210940Ch */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 8210940Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82109420;  }
		/* 8210940Ch case    4:*/		return 0x82109410;
		  /* 82109410h */ case    5:  		/* lwz R10, <#[R9]> */
		/* 82109410h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82109410h case    5:*/		return 0x82109414;
		  /* 82109414h */ case    6:  		/* stfd FR31, <#[R9 + 32]> */
		/* 82109414h case    6:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R9 + 0x00000020) );
		/* 82109414h case    6:*/		return 0x82109418;
		  /* 82109418h */ case    7:  		/* ori R10, R10, 128 */
		/* 82109418h case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x80);
		/* 82109418h case    7:*/		return 0x8210941C;
		  /* 8210941Ch */ case    8:  		/* b 12 */
		/* 8210941Ch case    8:*/		return 0x82109428;
		/* 8210941Ch case    8:*/		return 0x82109420;
	}
	return 0x82109420;
} // Block from 821093FCh-82109420h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82109420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109420);
		  /* 82109420h */ case    0:  		/* lwz R10, <#[R9]> */
		/* 82109420h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82109420h case    0:*/		return 0x82109424;
		  /* 82109424h */ case    1:  		/* rlwinm R10, R10, 0, 25, 23 */
		/* 82109424h case    1:*/		cpu::op::rlwinm<0,0,25,23>(regs,&regs.R10,regs.R10);
		/* 82109424h case    1:*/		return 0x82109428;
	}
	return 0x82109428;
} // Block from 82109420h-82109428h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82109428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109428);
		  /* 82109428h */ case    0:  		/* stw R10, <#[R9]> */
		/* 82109428h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82109428h case    0:*/		return 0x8210942C;
	}
	return 0x8210942C;
} // Block from 82109428h-8210942Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210942Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210942C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210942C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210942C);
		  /* 8210942Ch */ case    0:  		/* lwz R10, <#[R9]> */
		/* 8210942Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8210942Ch case    0:*/		return 0x82109430;
		  /* 82109430h */ case    1:  		/* rlwinm. R10, R10, 0, 24, 24 */
		/* 82109430h case    1:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R10);
		/* 82109430h case    1:*/		return 0x82109434;
		  /* 82109434h */ case    2:  		/* bc 4, CR0_EQ, 36 */
		/* 82109434h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82109458;  }
		/* 82109434h case    2:*/		return 0x82109438;
		  /* 82109438h */ case    3:  		/* lwz R10, <#[R31 + 16]> */
		/* 82109438h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82109438h case    3:*/		return 0x8210943C;
		  /* 8210943Ch */ case    4:  		/* addi R8, R8, 1 */
		/* 8210943Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210943Ch case    4:*/		return 0x82109440;
		  /* 82109440h */ case    5:  		/* lwzx R9, <#[R10 + R11]> */
		/* 82109440h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82109440h case    5:*/		return 0x82109444;
		  /* 82109444h */ case    6:  		/* stwx R9, <#[R10 + R7]> */
		/* 82109444h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82109444h case    6:*/		return 0x82109448;
		  /* 82109448h */ case    7:  		/* lwz R10, <#[R31 + 8]> */
		/* 82109448h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82109448h case    7:*/		return 0x8210944C;
		  /* 8210944Ch */ case    8:  		/* lwzx R9, <#[R10 + R11]> */
		/* 8210944Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210944Ch case    8:*/		return 0x82109450;
		  /* 82109450h */ case    9:  		/* stwx R9, <#[R10 + R7]> */
		/* 82109450h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 82109450h case    9:*/		return 0x82109454;
		  /* 82109454h */ case   10:  		/* addi R7, R7, 4 */
		/* 82109454h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82109454h case   10:*/		return 0x82109458;
	}
	return 0x82109458;
} // Block from 8210942Ch-82109458h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82109458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109458);
		  /* 82109458h */ case    0:  		/* lwz R10, <#[R31 + 12]> */
		/* 82109458h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109458h case    0:*/		return 0x8210945C;
		  /* 8210945Ch */ case    1:  		/* addi R6, R6, 1 */
		/* 8210945Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210945Ch case    1:*/		return 0x82109460;
		  /* 82109460h */ case    2:  		/* addi R11, R11, 4 */
		/* 82109460h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82109460h case    2:*/		return 0x82109464;
		  /* 82109464h */ case    3:  		/* cmplw CR6, R6, R10 */
		/* 82109464h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82109464h case    3:*/		return 0x82109468;
		  /* 82109468h */ case    4:  		/* bc 12, CR6_LT, -228 */
		/* 82109468h case    4:*/		if ( regs.CR[6].lt ) { return 0x82109384;  }
		/* 82109468h case    4:*/		return 0x8210946C;
	}
	return 0x8210946C;
} // Block from 82109458h-8210946Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210946Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210946C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210946C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210946C);
		  /* 8210946Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210946Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210946Ch case    0:*/		return 0x82109470;
		  /* 82109470h */ case    1:  		/* cmplw CR6, R8, R11 */
		/* 82109470h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82109470h case    1:*/		return 0x82109474;
		  /* 82109474h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 82109474h case    2:*/		if ( regs.CR[6].eq ) { return 0x821094A0;  }
		/* 82109474h case    2:*/		return 0x82109478;
		  /* 82109478h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 82109478h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82109478h case    3:*/		return 0x8210947C;
		  /* 8210947Ch */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 8210947Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8210948C;  }
		/* 8210947Ch case    4:*/		return 0x82109480;
		  /* 82109480h */ case    5:  		/* rlwinm R11, R8, 0, 12, 31 */
		/* 82109480h case    5:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R8);
		/* 82109480h case    5:*/		return 0x82109484;
		  /* 82109484h */ case    6:  		/* oris R11, R11, 4336 */
		/* 82109484h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10F0);
		/* 82109484h case    6:*/		return 0x82109488;
		  /* 82109488h */ case    7:  		/* b 8 */
		/* 82109488h case    7:*/		return 0x82109490;
		/* 82109488h case    7:*/		return 0x8210948C;
	}
	return 0x8210948C;
} // Block from 8210946Ch-8210948Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8210948Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210948C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210948C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210948C);
		  /* 8210948Ch */ case    0:  		/* mr R11, R14 */
		/* 8210948Ch case    0:*/		regs.R11 = regs.R14;
		/* 8210948Ch case    0:*/		return 0x82109490;
	}
	return 0x82109490;
} // Block from 8210948Ch-82109490h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82109490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109490);
		  /* 82109490h */ case    0:  		/* stw R8, <#[R31 + 4]> */
		/* 82109490h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 82109490h case    0:*/		return 0x82109494;
		  /* 82109494h */ case    1:  		/* stw R8, <#[R31 + 12]> */
		/* 82109494h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109494h case    1:*/		return 0x82109498;
	}
	return 0x82109498;
} // Block from 82109490h-82109498h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82109498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109498);
		  /* 82109498h */ case    0:  		/* stw R11, <#[R31]> */
		/* 82109498h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82109498h case    0:*/		return 0x8210949C;
	}
	return 0x8210949C;
} // Block from 82109498h-8210949Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210949Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210949C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210949C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210949C);
		  /* 8210949Ch */ case    0:  		/* li R15, 1 */
		/* 8210949Ch case    0:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 8210949Ch case    0:*/		return 0x821094A0;
	}
	return 0x821094A0;
} // Block from 8210949Ch-821094A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821094A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821094A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821094A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821094A0);
		  /* 821094A0h */ case    0:  		/* lwz R11, <#[R16 + 12]> */
		/* 821094A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x0000000C) );
		/* 821094A0h case    0:*/		return 0x821094A4;
		  /* 821094A4h */ case    1:  		/* addi R24, R24, 1 */
		/* 821094A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 821094A4h case    1:*/		return 0x821094A8;
		  /* 821094A8h */ case    2:  		/* cmplw CR6, R24, R11 */
		/* 821094A8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 821094A8h case    2:*/		return 0x821094AC;
		  /* 821094ACh */ case    3:  		/* bc 12, CR6_LT, -1428 */
		/* 821094ACh case    3:*/		if ( regs.CR[6].lt ) { return 0x82108F18;  }
		/* 821094ACh case    3:*/		return 0x821094B0;
		  /* 821094B0h */ case    4:  		/* cmpwi CR6, R25, 0 */
		/* 821094B0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 821094B0h case    4:*/		return 0x821094B4;
		  /* 821094B4h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 821094B4h case    5:*/		if ( regs.CR[6].eq ) { return 0x821094C0;  }
		/* 821094B4h case    5:*/		return 0x821094B8;
		  /* 821094B8h */ case    6:  		/* mr R3, R16 */
		/* 821094B8h case    6:*/		regs.R3 = regs.R16;
		/* 821094B8h case    6:*/		return 0x821094BC;
		  /* 821094BCh */ case    7:  		/* bl -12444 */
		/* 821094BCh case    7:*/		regs.LR = 0x821094C0; return 0x82106420;
		/* 821094BCh case    7:*/		return 0x821094C0;
	}
	return 0x821094C0;
} // Block from 821094A0h-821094C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821094C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821094C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821094C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821094C0);
		  /* 821094C0h */ case    0:  		/* cntlzw R11, R15 */
		/* 821094C0h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R15);
		/* 821094C0h case    0:*/		return 0x821094C4;
		  /* 821094C4h */ case    1:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 821094C4h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 821094C4h case    1:*/		return 0x821094C8;
		  /* 821094C8h */ case    2:  		/* addi R1, R1, 256 */
		/* 821094C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 821094C8h case    2:*/		return 0x821094CC;
		  /* 821094CCh */ case    3:  		/* lfd FR30, <#[R1 - 168]> */
		/* 821094CCh case    3:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 821094CCh case    3:*/		return 0x821094D0;
		  /* 821094D0h */ case    4:  		/* lfd FR31, <#[R1 - 160]> */
		/* 821094D0h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 821094D0h case    4:*/		return 0x821094D4;
		  /* 821094D4h */ case    5:  		/* b -492132 */
		/* 821094D4h case    5:*/		return 0x82091270;
		/* 821094D4h case    5:*/		return 0x821094D8;
	}
	return 0x821094D8;
} // Block from 821094C0h-821094D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821094D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821094D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821094D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821094D8);
		  /* 821094D8h */ case    0:  		/* mfspr R12, LR */
		/* 821094D8h case    0:*/		regs.R12 = regs.LR;
		/* 821094D8h case    0:*/		return 0x821094DC;
		  /* 821094DCh */ case    1:  		/* bl -492212 */
		/* 821094DCh case    1:*/		regs.LR = 0x821094E0; return 0x82091228;
		/* 821094DCh case    1:*/		return 0x821094E0;
		  /* 821094E0h */ case    2:  		/* stwu R1, <#[R1 - 352]> */
		/* 821094E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEA0);
		/* 821094E0h case    2:*/		return 0x821094E4;
		  /* 821094E4h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 821094E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821094E4h case    3:*/		return 0x821094E8;
		  /* 821094E8h */ case    4:  		/* mr R26, R3 */
		/* 821094E8h case    4:*/		regs.R26 = regs.R3;
		/* 821094E8h case    4:*/		return 0x821094EC;
		  /* 821094ECh */ case    5:  		/* li R23, -1 */
		/* 821094ECh case    5:*/		cpu::op::li<0>(regs,&regs.R23,0xFFFFFFFF);
		/* 821094ECh case    5:*/		return 0x821094F0;
		  /* 821094F0h */ case    6:  		/* li R17, 1 */
		/* 821094F0h case    6:*/		cpu::op::li<0>(regs,&regs.R17,0x1);
		/* 821094F0h case    6:*/		return 0x821094F4;
		  /* 821094F4h */ case    7:  		/* li R18, 0 */
		/* 821094F4h case    7:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 821094F4h case    7:*/		return 0x821094F8;
		  /* 821094F8h */ case    8:  		/* li R8, 0 */
		/* 821094F8h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821094F8h case    8:*/		return 0x821094FC;
		  /* 821094FCh */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 821094FCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821094FCh case    9:*/		return 0x82109500;
		  /* 82109500h */ case   10:  		/* bc 4, CR6_GT, 116 */
		/* 82109500h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82109574;  }
		/* 82109500h case   10:*/		return 0x82109504;
		  /* 82109504h */ case   11:  		/* li R9, 0 */
		/* 82109504h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82109504h case   11:*/		return 0x82109508;
		  /* 82109508h */ case   12:  		/* lwz R11, <#[R26 + 20]> */
		/* 82109508h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82109508h case   12:*/		return 0x8210950C;
		  /* 8210950Ch */ case   13:  		/* lwz R10, <#[R26 + 16]> */
		/* 8210950Ch case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 8210950Ch case   13:*/		return 0x82109510;
		  /* 82109510h */ case   14:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82109510h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82109510h case   14:*/		return 0x82109514;
		  /* 82109514h */ case   15:  		/* lwz R7, <#[R11 + 4]> */
		/* 82109514h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82109514h case   15:*/		return 0x82109518;
		  /* 82109518h */ case   16:  		/* lwz R6, <#[R11 + 20]> */
		/* 82109518h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000014) );
		/* 82109518h case   16:*/		return 0x8210951C;
		  /* 8210951Ch */ case   17:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8210951Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8210951Ch case   17:*/		return 0x82109520;
		  /* 82109520h */ case   18:  		/* lwz R5, <#[R11 + 24]> */
		/* 82109520h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000018) );
		/* 82109520h case   18:*/		return 0x82109524;
		  /* 82109524h */ case   19:  		/* lwzx R10, <#[R7 + R10]> */
		/* 82109524h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 82109524h case   19:*/		return 0x82109528;
		  /* 82109528h */ case   20:  		/* stw R6, <#[R11 + 48]> */
		/* 82109528h case   20:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000030) );
		/* 82109528h case   20:*/		return 0x8210952C;
		  /* 8210952Ch */ case   21:  		/* stw R5, <#[R11 + 64]> */
		/* 8210952Ch case   21:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000040) );
		/* 8210952Ch case   21:*/		return 0x82109530;
		  /* 82109530h */ case   22:  		/* lwz R10, <#[R10 + 4]> */
		/* 82109530h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82109530h case   22:*/		return 0x82109534;
		  /* 82109534h */ case   23:  		/* rlwinm. R7, R10, 0, 27, 27 */
		/* 82109534h case   23:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R7,regs.R10);
		/* 82109534h case   23:*/		return 0x82109538;
		  /* 82109538h */ case   24:  		/* bc 12, CR0_EQ, 12 */
		/* 82109538h case   24:*/		if ( regs.CR[0].eq ) { return 0x82109544;  }
		/* 82109538h case   24:*/		return 0x8210953C;
		  /* 8210953Ch */ case   25:  		/* stw R17, <#[R11 + 24]> */
		/* 8210953Ch case   25:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R11 + 0x00000018) );
		/* 8210953Ch case   25:*/		return 0x82109540;
		  /* 82109540h */ case   26:  		/* b 28 */
		/* 82109540h case   26:*/		return 0x8210955C;
		/* 82109540h case   26:*/		return 0x82109544;
	}
	return 0x82109544;
} // Block from 821094D8h-82109544h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82109544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109544);
		  /* 82109544h */ case    0:  		/* lis R12, 1 */
		/* 82109544h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0x1);
		/* 82109544h case    0:*/		return 0x82109548;
		  /* 82109548h */ case    1:  		/* ori R12, R12, 4136 */
		/* 82109548h case    1:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x1028);
		/* 82109548h case    1:*/		return 0x8210954C;
		  /* 8210954Ch */ case    2:  		/* and. R10, R10, R12 */
		/* 8210954Ch case    2:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R12);
		/* 8210954Ch case    2:*/		return 0x82109550;
		  /* 82109550h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82109550h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82109560;  }
		/* 82109550h case    3:*/		return 0x82109554;
		  /* 82109554h */ case    4:  		/* li R10, 0 */
		/* 82109554h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82109554h case    4:*/		return 0x82109558;
		  /* 82109558h */ case    5:  		/* stw R10, <#[R11 + 24]> */
		/* 82109558h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 82109558h case    5:*/		return 0x8210955C;
	}
	return 0x8210955C;
} // Block from 82109544h-8210955Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210955Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210955C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210955C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210955C);
		  /* 8210955Ch */ case    0:  		/* stw R23, <#[R11 + 20]> */
		/* 8210955Ch case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000014) );
		/* 8210955Ch case    0:*/		return 0x82109560;
	}
	return 0x82109560;
} // Block from 8210955Ch-82109560h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82109560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109560);
		  /* 82109560h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 82109560h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82109560h case    0:*/		return 0x82109564;
		  /* 82109564h */ case    1:  		/* addi R8, R8, 1 */
		/* 82109564h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82109564h case    1:*/		return 0x82109568;
		  /* 82109568h */ case    2:  		/* addi R9, R9, 4 */
		/* 82109568h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82109568h case    2:*/		return 0x8210956C;
		  /* 8210956Ch */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8210956Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210956Ch case    3:*/		return 0x82109570;
		  /* 82109570h */ case    4:  		/* bc 12, CR6_LT, -104 */
		/* 82109570h case    4:*/		if ( regs.CR[6].lt ) { return 0x82109508;  }
		/* 82109570h case    4:*/		return 0x82109574;
	}
	return 0x82109574;
} // Block from 82109560h-82109574h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82109574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109574);
		  /* 82109574h */ case    0:  		/* lwz R25, <#[R26 + 12]> */
		/* 82109574h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R26 + 0x0000000C) );
		/* 82109574h case    0:*/		return 0x82109578;
		  /* 82109578h */ case    1:  		/* lis R22, 8304 */
		/* 82109578h case    1:*/		cpu::op::lis<0>(regs,&regs.R22,0x2070);
		/* 82109578h case    1:*/		return 0x8210957C;
		  /* 8210957Ch */ case    2:  		/* lis R19, 8320 */
		/* 8210957Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R19,0x2080);
		/* 8210957Ch case    2:*/		return 0x82109580;
		  /* 82109580h */ case    3:  		/* lis R20, 4432 */
		/* 82109580h case    3:*/		cpu::op::lis<0>(regs,&regs.R20,0x1150);
		/* 82109580h case    3:*/		return 0x82109584;
		  /* 82109584h */ case    4:  		/* lis R21, 4384 */
		/* 82109584h case    4:*/		cpu::op::lis<0>(regs,&regs.R21,0x1120);
		/* 82109584h case    4:*/		return 0x82109588;
		  /* 82109588h */ case    5:  		/* cmplwi CR6, R25, 0 */
		/* 82109588h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82109588h case    5:*/		return 0x8210958C;
		  /* 8210958Ch */ case    6:  		/* bc 12, CR6_EQ, 1004 */
		/* 8210958Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82109978;  }
		/* 8210958Ch case    6:*/		return 0x82109590;
		  /* 82109590h */ case    7:  		/* rlwinm R24, R25, 2, 0, 29 */
		/* 82109590h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R25);
		/* 82109590h case    7:*/		return 0x82109594;
		  /* 82109594h */ case    8:  		/* lwz R11, <#[R26 + 24]> */
		/* 82109594h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 82109594h case    8:*/		return 0x82109598;
		  /* 82109598h */ case    9:  		/* addi R24, R24, -4 */
		/* 82109598h case    9:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0xFFFFFFFC);
		/* 82109598h case    9:*/		return 0x8210959C;
		  /* 8210959Ch */ case   10:  		/* addi R25, R25, -1 */
		/* 8210959Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xFFFFFFFF);
		/* 8210959Ch case   10:*/		return 0x821095A0;
		  /* 821095A0h */ case   11:  		/* lwzx R31, <#[R11 + R24]> */
		/* 821095A0h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 821095A0h case   11:*/		return 0x821095A4;
		  /* 821095A4h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 821095A4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821095A4h case   12:*/		return 0x821095A8;
		  /* 821095A8h */ case   13:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 821095A8h case   13:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821095A8h case   13:*/		return 0x821095AC;
		  /* 821095ACh */ case   14:  		/* bc 12, CR0_EQ, 964 */
		/* 821095ACh case   14:*/		if ( regs.CR[0].eq ) { return 0x82109970;  }
		/* 821095ACh case   14:*/		return 0x821095B0;
		  /* 821095B0h */ case   15:  		/* lwz R11, <#[R31 + 12]> */
		/* 821095B0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821095B0h case   15:*/		return 0x821095B4;
		  /* 821095B4h */ case   16:  		/* mr R30, R17 */
		/* 821095B4h case   16:*/		regs.R30 = regs.R17;
		/* 821095B4h case   16:*/		return 0x821095B8;
		  /* 821095B8h */ case   17:  		/* cmplwi CR6, R11, 1 */
		/* 821095B8h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821095B8h case   17:*/		return 0x821095BC;
		  /* 821095BCh */ case   18:  		/* bc 4, CR6_GT, 68 */
		/* 821095BCh case   18:*/		if ( !regs.CR[6].gt ) { return 0x82109600;  }
		/* 821095BCh case   18:*/		return 0x821095C0;
		  /* 821095C0h */ case   19:  		/* li R29, 4 */
		/* 821095C0h case   19:*/		cpu::op::li<0>(regs,&regs.R29,0x4);
		/* 821095C0h case   19:*/		return 0x821095C4;
		  /* 821095C4h */ case   20:  		/* lwz R11, <#[R31 + 16]> */
		/* 821095C4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821095C4h case   20:*/		return 0x821095C8;
		  /* 821095C8h */ case   21:  		/* mr R3, R26 */
		/* 821095C8h case   21:*/		regs.R3 = regs.R26;
		/* 821095C8h case   21:*/		return 0x821095CC;
		  /* 821095CCh */ case   22:  		/* lwz R10, <#[R26 + 20]> */
		/* 821095CCh case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 821095CCh case   22:*/		return 0x821095D0;
		  /* 821095D0h */ case   23:  		/* lwzx R9, <#[R29 + R11]> */
		/* 821095D0h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 821095D0h case   23:*/		return 0x821095D4;
		  /* 821095D4h */ case   24:  		/* lwz R11, <#[R11]> */
		/* 821095D4h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821095D4h case   24:*/		return 0x821095D8;
		  /* 821095D8h */ case   25:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821095D8h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821095D8h case   25:*/		return 0x821095DC;
		  /* 821095DCh */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821095DCh case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821095DCh case   26:*/		return 0x821095E0;
		  /* 821095E0h */ case   27:  		/* lwzx R5, <#[R9 + R10]> */
		/* 821095E0h case   27:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821095E0h case   27:*/		return 0x821095E4;
		  /* 821095E4h */ case   28:  		/* lwzx R4, <#[R11 + R10]> */
		/* 821095E4h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821095E4h case   28:*/		return 0x821095E8;
		  /* 821095E8h */ case   29:  		/* bl -29304 */
		/* 821095E8h case   29:*/		regs.LR = 0x821095EC; return 0x82102370;
		/* 821095E8h case   29:*/		return 0x821095EC;
		  /* 821095ECh */ case   30:  		/* lwz R11, <#[R31 + 12]> */
		/* 821095ECh case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821095ECh case   30:*/		return 0x821095F0;
		  /* 821095F0h */ case   31:  		/* addi R30, R30, 1 */
		/* 821095F0h case   31:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 821095F0h case   31:*/		return 0x821095F4;
		  /* 821095F4h */ case   32:  		/* addi R29, R29, 4 */
		/* 821095F4h case   32:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 821095F4h case   32:*/		return 0x821095F8;
		  /* 821095F8h */ case   33:  		/* cmplw CR6, R30, R11 */
		/* 821095F8h case   33:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 821095F8h case   33:*/		return 0x821095FC;
		  /* 821095FCh */ case   34:  		/* bc 12, CR6_LT, -56 */
		/* 821095FCh case   34:*/		if ( regs.CR[6].lt ) { return 0x821095C4;  }
		/* 821095FCh case   34:*/		return 0x82109600;
	}
	return 0x82109600;
} // Block from 82109574h-82109600h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82109600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109600);
		  /* 82109600h */ case    0:  		/* mr R9, R17 */
		/* 82109600h case    0:*/		regs.R9 = regs.R17;
		/* 82109600h case    0:*/		return 0x82109604;
		  /* 82109604h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 82109604h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82109604h case    1:*/		return 0x82109608;
		  /* 82109608h */ case    2:  		/* bc 4, CR6_GT, 108 */
		/* 82109608h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82109674;  }
		/* 82109608h case    2:*/		return 0x8210960C;
		  /* 8210960Ch */ case    3:  		/* li R10, 4 */
		/* 8210960Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 8210960Ch case    3:*/		return 0x82109610;
		  /* 82109610h */ case    4:  		/* lwz R11, <#[R31 + 16]> */
		/* 82109610h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82109610h case    4:*/		return 0x82109614;
		  /* 82109614h */ case    5:  		/* addi R9, R9, 1 */
		/* 82109614h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82109614h case    5:*/		return 0x82109618;
		  /* 82109618h */ case    6:  		/* lwz R8, <#[R26 + 20]> */
		/* 82109618h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 82109618h case    6:*/		return 0x8210961C;
		  /* 8210961Ch */ case    7:  		/* lwz R7, <#[R11]> */
		/* 8210961Ch case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8210961Ch case    7:*/		return 0x82109620;
		  /* 82109620h */ case    8:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82109620h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82109620h case    8:*/		return 0x82109624;
		  /* 82109624h */ case    9:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82109624h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82109624h case    9:*/		return 0x82109628;
		  /* 82109628h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109628h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109628h case   10:*/		return 0x8210962C;
		  /* 8210962Ch */ case   11:  		/* lwzx R7, <#[R7 + R8]> */
		/* 8210962Ch case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8210962Ch case   11:*/		return 0x82109630;
		  /* 82109630h */ case   12:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82109630h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82109630h case   12:*/		return 0x82109634;
		  /* 82109634h */ case   13:  		/* lwz R8, <#[R7 + 20]> */
		/* 82109634h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000014) );
		/* 82109634h case   13:*/		return 0x82109638;
		  /* 82109638h */ case   14:  		/* stw R8, <#[R11 + 20]> */
		/* 82109638h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 82109638h case   14:*/		return 0x8210963C;
		  /* 8210963Ch */ case   15:  		/* lwz R11, <#[R31 + 16]> */
		/* 8210963Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8210963Ch case   15:*/		return 0x82109640;
		  /* 82109640h */ case   16:  		/* lwz R8, <#[R26 + 20]> */
		/* 82109640h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 82109640h case   16:*/		return 0x82109644;
		  /* 82109644h */ case   17:  		/* lwzx R7, <#[R10 + R11]> */
		/* 82109644h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82109644h case   17:*/		return 0x82109648;
		  /* 82109648h */ case   18:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82109648h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82109648h case   18:*/		return 0x8210964C;
		  /* 8210964Ch */ case   19:  		/* lwz R11, <#[R11]> */
		/* 8210964Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210964Ch case   19:*/		return 0x82109650;
		  /* 82109650h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109650h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109650h case   20:*/		return 0x82109654;
		  /* 82109654h */ case   21:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82109654h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82109654h case   21:*/		return 0x82109658;
		  /* 82109658h */ case   22:  		/* addi R10, R10, 4 */
		/* 82109658h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82109658h case   22:*/		return 0x8210965C;
		  /* 8210965Ch */ case   23:  		/* lwz R11, <#[R11 + 24]> */
		/* 8210965Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8210965Ch case   23:*/		return 0x82109660;
		  /* 82109660h */ case   24:  		/* lwzx R8, <#[R7 + R8]> */
		/* 82109660h case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 82109660h case   24:*/		return 0x82109664;
		  /* 82109664h */ case   25:  		/* stw R11, <#[R8 + 24]> */
		/* 82109664h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000018) );
		/* 82109664h case   25:*/		return 0x82109668;
		  /* 82109668h */ case   26:  		/* lwz R11, <#[R31 + 12]> */
		/* 82109668h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109668h case   26:*/		return 0x8210966C;
		  /* 8210966Ch */ case   27:  		/* cmplw CR6, R9, R11 */
		/* 8210966Ch case   27:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8210966Ch case   27:*/		return 0x82109670;
		  /* 82109670h */ case   28:  		/* bc 12, CR6_LT, -96 */
		/* 82109670h case   28:*/		if ( regs.CR[6].lt ) { return 0x82109610;  }
		/* 82109670h case   28:*/		return 0x82109674;
	}
	return 0x82109674;
} // Block from 82109600h-82109674h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82109674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109674);
		  /* 82109674h */ case    0:  		/* lwz R10, <#[R31]> */
		/* 82109674h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82109674h case    0:*/		return 0x82109678;
		  /* 82109678h */ case    1:  		/* rlwinm R9, R10, 0, 0, 11 */
		/* 82109678h case    1:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R9,regs.R10);
		/* 82109678h case    1:*/		return 0x8210967C;
		  /* 8210967Ch */ case    2:  		/* cmplw CR6, R9, R22 */
		/* 8210967Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R22);
		/* 8210967Ch case    2:*/		return 0x82109680;
		  /* 82109680h */ case    3:  		/* bc 12, CR6_EQ, 604 */
		/* 82109680h case    3:*/		if ( regs.CR[6].eq ) { return 0x821098DC;  }
		/* 82109680h case    3:*/		return 0x82109684;
		  /* 82109684h */ case    4:  		/* cmplw CR6, R9, R19 */
		/* 82109684h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R19);
		/* 82109684h case    4:*/		return 0x82109688;
		  /* 82109688h */ case    5:  		/* bc 12, CR6_EQ, 596 */
		/* 82109688h case    5:*/		if ( regs.CR[6].eq ) { return 0x821098DC;  }
		/* 82109688h case    5:*/		return 0x8210968C;
		  /* 8210968Ch */ case    6:  		/* cmplw CR6, R9, R20 */
		/* 8210968Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R20);
		/* 8210968Ch case    6:*/		return 0x82109690;
		  /* 82109690h */ case    7:  		/* bc 12, CR6_EQ, 588 */
		/* 82109690h case    7:*/		if ( regs.CR[6].eq ) { return 0x821098DC;  }
		/* 82109690h case    7:*/		return 0x82109694;
		  /* 82109694h */ case    8:  		/* cmplw CR6, R9, R21 */
		/* 82109694h case    8:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R21);
		/* 82109694h case    8:*/		return 0x82109698;
		  /* 82109698h */ case    9:  		/* bc 4, CR6_EQ, 180 */
		/* 82109698h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8210974C;  }
		/* 82109698h case    9:*/		return 0x8210969C;
		  /* 8210969Ch */ case   10:  		/* lwz R9, <#[R31 + 4]> */
		/* 8210969Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 8210969Ch case   10:*/		return 0x821096A0;
		  /* 821096A0h */ case   11:  		/* rlwinm R10, R10, 0, 12, 31 */
		/* 821096A0h case   11:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R10,regs.R10);
		/* 821096A0h case   11:*/		return 0x821096A4;
		  /* 821096A4h */ case   12:  		/* li R30, 0 */
		/* 821096A4h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821096A4h case   12:*/		return 0x821096A8;
		  /* 821096A8h */ case   13:  		/* divwu R27, R9, R10 */
		/* 821096A8h case   13:*/		cpu::op::divwu<0>(regs,&regs.R27,regs.R9,regs.R10);
		/* 821096A8h case   13:*/		return 0x821096AC;
		  /* 821096ACh */ case   14:  		/* twi 6, R10, 0 */
		/* 821096ACh case   14:*/		cpu::op::tw<6>(regs, 0x821096AC, regs.R10, 0x00000000);
		/* 821096ACh case   14:*/		return 0x821096B0;
		  /* 821096B0h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821096B0h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821096B0h case   15:*/		return 0x821096B4;
		  /* 821096B4h */ case   16:  		/* bc 12, CR6_EQ, 700 */
		/* 821096B4h case   16:*/		if ( regs.CR[6].eq ) { return 0x82109970;  }
		/* 821096B4h case   16:*/		return 0x821096B8;
		  /* 821096B8h */ case   17:  		/* li R29, 0 */
		/* 821096B8h case   17:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821096B8h case   17:*/		return 0x821096BC;
		  /* 821096BCh */ case   18:  		/* cmplwi CR6, R27, 0 */
		/* 821096BCh case   18:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821096BCh case   18:*/		return 0x821096C0;
		  /* 821096C0h */ case   19:  		/* bc 12, CR6_EQ, 120 */
		/* 821096C0h case   19:*/		if ( regs.CR[6].eq ) { return 0x82109738;  }
		/* 821096C0h case   19:*/		return 0x821096C4;
		  /* 821096C4h */ case   20:  		/* lwz R11, <#[R31 + 12]> */
		/* 821096C4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821096C4h case   20:*/		return 0x821096C8;
		  /* 821096C8h */ case   21:  		/* lwz R10, <#[R31 + 8]> */
		/* 821096C8h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821096C8h case   21:*/		return 0x821096CC;
		  /* 821096CCh */ case   22:  		/* mullw R11, R29, R11 */
		/* 821096CCh case   22:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 821096CCh case   22:*/		return 0x821096D0;
		  /* 821096D0h */ case   23:  		/* add R11, R11, R30 */
		/* 821096D0h case   23:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 821096D0h case   23:*/		return 0x821096D4;
		  /* 821096D4h */ case   24:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821096D4h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821096D4h case   24:*/		return 0x821096D8;
		  /* 821096D8h */ case   25:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821096D8h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821096D8h case   25:*/		return 0x821096DC;
		  /* 821096DCh */ case   26:  		/* cmpwi CR6, R11, -1 */
		/* 821096DCh case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821096DCh case   26:*/		return 0x821096E0;
		  /* 821096E0h */ case   27:  		/* bc 12, CR6_EQ, 76 */
		/* 821096E0h case   27:*/		if ( regs.CR[6].eq ) { return 0x8210972C;  }
		/* 821096E0h case   27:*/		return 0x821096E4;
		  /* 821096E4h */ case   28:  		/* rlwinm R28, R30, 2, 0, 29 */
		/* 821096E4h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R30);
		/* 821096E4h case   28:*/		return 0x821096E8;
		  /* 821096E8h */ case   29:  		/* lwz R10, <#[R31 + 16]> */
		/* 821096E8h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 821096E8h case   29:*/		return 0x821096EC;
		  /* 821096ECh */ case   30:  		/* rlwinm R16, R11, 2, 0, 29 */
		/* 821096ECh case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R16,regs.R11);
		/* 821096ECh case   30:*/		return 0x821096F0;
		  /* 821096F0h */ case   31:  		/* lwz R11, <#[R26 + 20]> */
		/* 821096F0h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 821096F0h case   31:*/		return 0x821096F4;
		  /* 821096F4h */ case   32:  		/* mr R3, R26 */
		/* 821096F4h case   32:*/		regs.R3 = regs.R26;
		/* 821096F4h case   32:*/		return 0x821096F8;
	}
	return 0x821096F8;
} // Block from 82109674h-821096F8h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821096F8h
// Function '?SimplifyPredicates@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821096F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821096F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821096F8);
		  /* 821096F8h */ case    0:  		/* lwzx R10, <#[R28 + R10]> */
		/* 821096F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + regs.R10 + 0x00000000) );
		/* 821096F8h case    0:*/		return 0x821096FC;
		  /* 821096FCh */ case    1:  		/* lwzx R4, <#[R16 + R11]> */
		/* 821096FCh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R16 + regs.R11 + 0x00000000) );
		/* 821096FCh case    1:*/		return 0x82109700;
		  /* 82109700h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82109700h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82109700h case    2:*/		return 0x82109704;
		  /* 82109704h */ case    3:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82109704h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82109704h case    3:*/		return 0x82109708;
		  /* 82109708h */ case    4:  		/* lwz R10, <#[R10 + 20]> */
		/* 82109708h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 82109708h case    4:*/		return 0x8210970C;
		  /* 8210970Ch */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210970Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210970Ch case    5:*/		return 0x82109710;
		  /* 82109710h */ case    6:  		/* lwzx R5, <#[R10 + R11]> */
		/* 82109710h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82109710h case    6:*/		return 0x82109714;
		  /* 82109714h */ case    7:  		/* bl -29604 */
		/* 82109714h case    7:*/		regs.LR = 0x82109718; return 0x82102370;
		/* 82109714h case    7:*/		return 0x82109718;
		  /* 82109718h */ case    8:  		/* lwz R11, <#[R26 + 20]> */
		/* 82109718h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82109718h case    8:*/		return 0x8210971C;
		  /* 8210971Ch */ case    9:  		/* lwzx R11, <#[R16 + R11]> */
		/* 8210971Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + regs.R11 + 0x00000000) );
		/* 8210971Ch case    9:*/		return 0x82109720;
		  /* 82109720h */ case   10:  		/* lwz R11, <#[R11 + 8]> */
		/* 82109720h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82109720h case   10:*/		return 0x82109724;
		  /* 82109724h */ case   11:  		/* cmpwi CR6, R11, -1 */
		/* 82109724h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109724h case   11:*/		return 0x82109728;
		  /* 82109728h */ case   12:  		/* bc 4, CR6_EQ, -64 */
		/* 82109728h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821096E8;  }
		/* 82109728h case   12:*/		return 0x8210972C;
	}
	return 0x8210972C;
} // Block from 821096F8h-8210972Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8210972Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210972C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210972C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210972C);
		  /* 8210972Ch */ case    0:  		/* addi R29, R29, 1 */
		/* 8210972Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8210972Ch case    0:*/		return 0x82109730;
		  /* 82109730h */ case    1:  		/* cmplw CR6, R29, R27 */
		/* 82109730h case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R27);
		/* 82109730h case    1:*/		return 0x82109734;
		  /* 82109734h */ case    2:  		/* bc 12, CR6_LT, -112 */
		/* 82109734h case    2:*/		if ( regs.CR[6].lt ) { return 0x821096C4;  }
		/* 82109734h case    2:*/		return 0x82109738;
	}
	return 0x82109738;
} // Block from 8210972Ch-82109738h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82109738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109738);
		  /* 82109738h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82109738h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109738h case    0:*/		return 0x8210973C;
		  /* 8210973Ch */ case    1:  		/* addi R30, R30, 1 */
		/* 8210973Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8210973Ch case    1:*/		return 0x82109740;
		  /* 82109740h */ case    2:  		/* cmplw CR6, R30, R11 */
		/* 82109740h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82109740h case    2:*/		return 0x82109744;
		  /* 82109744h */ case    3:  		/* bc 12, CR6_LT, -140 */
		/* 82109744h case    3:*/		if ( regs.CR[6].lt ) { return 0x821096B8;  }
		/* 82109744h case    3:*/		return 0x82109748;
		  /* 82109748h */ case    4:  		/* b 552 */
		/* 82109748h case    4:*/		return 0x82109970;
		/* 82109748h case    4:*/		return 0x8210974C;
	}
	return 0x8210974C;
} // Block from 82109738h-8210974Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210974Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210974C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210974C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210974C);
		  /* 8210974Ch */ case    0:  		/* rlwinm R9, R10, 0, 0, 3 */
		/* 8210974Ch case    0:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R9,regs.R10);
		/* 8210974Ch case    0:*/		return 0x82109750;
		  /* 82109750h */ case    1:  		/* lis R8, 4096 */
		/* 82109750h case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0x1000);
		/* 82109750h case    1:*/		return 0x82109754;
		  /* 82109754h */ case    2:  		/* cmplw CR6, R9, R8 */
		/* 82109754h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82109754h case    2:*/		return 0x82109758;
		  /* 82109758h */ case    3:  		/* bc 12, CR6_LT, 180 */
		/* 82109758h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210980C;  }
		/* 82109758h case    3:*/		return 0x8210975C;
		  /* 8210975Ch */ case    4:  		/* lis R8, 16384 */
		/* 8210975Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0x4000);
		/* 8210975Ch case    4:*/		return 0x82109760;
		  /* 82109760h */ case    5:  		/* cmplw CR6, R9, R8 */
		/* 82109760h case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 82109760h case    5:*/		return 0x82109764;
		  /* 82109764h */ case    6:  		/* bc 12, CR6_GT, 168 */
		/* 82109764h case    6:*/		if ( regs.CR[6].gt ) { return 0x8210980C;  }
		/* 82109764h case    6:*/		return 0x82109768;
		  /* 82109768h */ case    7:  		/* lwz R9, <#[R31 + 4]> */
		/* 82109768h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 82109768h case    7:*/		return 0x8210976C;
		  /* 8210976Ch */ case    8:  		/* rlwinm R10, R10, 0, 12, 31 */
		/* 8210976Ch case    8:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R10,regs.R10);
		/* 8210976Ch case    8:*/		return 0x82109770;
		  /* 82109770h */ case    9:  		/* li R30, 0 */
		/* 82109770h case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82109770h case    9:*/		return 0x82109774;
		  /* 82109774h */ case   10:  		/* divwu R27, R9, R10 */
		/* 82109774h case   10:*/		cpu::op::divwu<0>(regs,&regs.R27,regs.R9,regs.R10);
		/* 82109774h case   10:*/		return 0x82109778;
		  /* 82109778h */ case   11:  		/* twi 6, R10, 0 */
		/* 82109778h case   11:*/		cpu::op::tw<6>(regs, 0x82109778, regs.R10, 0x00000000);
		/* 82109778h case   11:*/		return 0x8210977C;
		  /* 8210977Ch */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8210977Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210977Ch case   12:*/		return 0x82109780;
		  /* 82109780h */ case   13:  		/* bc 12, CR6_EQ, 496 */
		/* 82109780h case   13:*/		if ( regs.CR[6].eq ) { return 0x82109970;  }
		/* 82109780h case   13:*/		return 0x82109784;
		  /* 82109784h */ case   14:  		/* li R29, 0 */
		/* 82109784h case   14:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82109784h case   14:*/		return 0x82109788;
		  /* 82109788h */ case   15:  		/* cmplwi CR6, R27, 0 */
		/* 82109788h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82109788h case   15:*/		return 0x8210978C;
		  /* 8210978Ch */ case   16:  		/* bc 12, CR6_EQ, 108 */
		/* 8210978Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x821097F8;  }
		/* 8210978Ch case   16:*/		return 0x82109790;
		  /* 82109790h */ case   17:  		/* lwz R11, <#[R31 + 12]> */
		/* 82109790h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109790h case   17:*/		return 0x82109794;
		  /* 82109794h */ case   18:  		/* lwz R10, <#[R31 + 8]> */
		/* 82109794h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82109794h case   18:*/		return 0x82109798;
		  /* 82109798h */ case   19:  		/* mullw R11, R29, R11 */
		/* 82109798h case   19:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82109798h case   19:*/		return 0x8210979C;
		  /* 8210979Ch */ case   20:  		/* add R11, R11, R30 */
		/* 8210979Ch case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8210979Ch case   20:*/		return 0x821097A0;
		  /* 821097A0h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821097A0h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821097A0h case   21:*/		return 0x821097A4;
		  /* 821097A4h */ case   22:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821097A4h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821097A4h case   22:*/		return 0x821097A8;
		  /* 821097A8h */ case   23:  		/* cmpwi CR6, R11, -1 */
		/* 821097A8h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821097A8h case   23:*/		return 0x821097AC;
		  /* 821097ACh */ case   24:  		/* bc 12, CR6_EQ, 64 */
		/* 821097ACh case   24:*/		if ( regs.CR[6].eq ) { return 0x821097EC;  }
		/* 821097ACh case   24:*/		return 0x821097B0;
		  /* 821097B0h */ case   25:  		/* rlwinm R28, R30, 2, 0, 29 */
		/* 821097B0h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R30);
		/* 821097B0h case   25:*/		return 0x821097B4;
		  /* 821097B4h */ case   26:  		/* lwz R10, <#[R31 + 16]> */
		/* 821097B4h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 821097B4h case   26:*/		return 0x821097B8;
		  /* 821097B8h */ case   27:  		/* rlwinm R16, R11, 2, 0, 29 */
		/* 821097B8h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R16,regs.R11);
		/* 821097B8h case   27:*/		return 0x821097BC;
		  /* 821097BCh */ case   28:  		/* lwz R11, <#[R26 + 20]> */
		/* 821097BCh case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 821097BCh case   28:*/		return 0x821097C0;
		  /* 821097C0h */ case   29:  		/* mr R3, R26 */
		/* 821097C0h case   29:*/		regs.R3 = regs.R26;
		/* 821097C0h case   29:*/		return 0x821097C4;
		  /* 821097C4h */ case   30:  		/* lwzx R10, <#[R28 + R10]> */
		/* 821097C4h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + regs.R10 + 0x00000000) );
		/* 821097C4h case   30:*/		return 0x821097C8;
		  /* 821097C8h */ case   31:  		/* lwzx R4, <#[R16 + R11]> */
		/* 821097C8h case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R16 + regs.R11 + 0x00000000) );
		/* 821097C8h case   31:*/		return 0x821097CC;
		  /* 821097CCh */ case   32:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821097CCh case   32:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821097CCh case   32:*/		return 0x821097D0;
		  /* 821097D0h */ case   33:  		/* lwzx R5, <#[R10 + R11]> */
		/* 821097D0h case   33:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821097D0h case   33:*/		return 0x821097D4;
		  /* 821097D4h */ case   34:  		/* bl -29796 */
		/* 821097D4h case   34:*/		regs.LR = 0x821097D8; return 0x82102370;
		/* 821097D4h case   34:*/		return 0x821097D8;
		  /* 821097D8h */ case   35:  		/* lwz R11, <#[R26 + 20]> */
		/* 821097D8h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 821097D8h case   35:*/		return 0x821097DC;
		  /* 821097DCh */ case   36:  		/* lwzx R11, <#[R16 + R11]> */
		/* 821097DCh case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + regs.R11 + 0x00000000) );
		/* 821097DCh case   36:*/		return 0x821097E0;
		  /* 821097E0h */ case   37:  		/* lwz R11, <#[R11 + 8]> */
		/* 821097E0h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821097E0h case   37:*/		return 0x821097E4;
		  /* 821097E4h */ case   38:  		/* cmpwi CR6, R11, -1 */
		/* 821097E4h case   38:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 821097E4h case   38:*/		return 0x821097E8;
		  /* 821097E8h */ case   39:  		/* bc 4, CR6_EQ, -52 */
		/* 821097E8h case   39:*/		if ( !regs.CR[6].eq ) { return 0x821097B4;  }
		/* 821097E8h case   39:*/		return 0x821097EC;
	}
	return 0x821097EC;
} // Block from 8210974Ch-821097ECh (40 instructions)

//////////////////////////////////////////////////////
// Block at 821097ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821097EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821097EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821097EC);
		  /* 821097ECh */ case    0:  		/* addi R29, R29, 1 */
		/* 821097ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821097ECh case    0:*/		return 0x821097F0;
		  /* 821097F0h */ case    1:  		/* cmplw CR6, R29, R27 */
		/* 821097F0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R27);
		/* 821097F0h case    1:*/		return 0x821097F4;
		  /* 821097F4h */ case    2:  		/* bc 12, CR6_LT, -100 */
		/* 821097F4h case    2:*/		if ( regs.CR[6].lt ) { return 0x82109790;  }
		/* 821097F4h case    2:*/		return 0x821097F8;
	}
	return 0x821097F8;
} // Block from 821097ECh-821097F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821097F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821097F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821097F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821097F8);
		  /* 821097F8h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821097F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821097F8h case    0:*/		return 0x821097FC;
		  /* 821097FCh */ case    1:  		/* addi R30, R30, 1 */
		/* 821097FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 821097FCh case    1:*/		return 0x82109800;
		  /* 82109800h */ case    2:  		/* cmplw CR6, R30, R11 */
		/* 82109800h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82109800h case    2:*/		return 0x82109804;
		  /* 82109804h */ case    3:  		/* bc 12, CR6_LT, -128 */
		/* 82109804h case    3:*/		if ( regs.CR[6].lt ) { return 0x82109784;  }
		/* 82109804h case    3:*/		return 0x82109808;
		  /* 82109808h */ case    4:  		/* b 360 */
		/* 82109808h case    4:*/		return 0x82109970;
		/* 82109808h case    4:*/		return 0x8210980C;
	}
	return 0x8210980C;
} // Block from 821097F8h-8210980Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210980Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210980C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210980C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210980C);
		  /* 8210980Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8210980Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210980Ch case    0:*/		return 0x82109810;
		  /* 82109810h */ case    1:  		/* lwz R11, <#[R31 + 4]> */
		/* 82109810h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82109810h case    1:*/		return 0x82109814;
		  /* 82109814h */ case    2:  		/* bc 12, CR6_EQ, 112 */
		/* 82109814h case    2:*/		if ( regs.CR[6].eq ) { return 0x82109884;  }
		/* 82109814h case    2:*/		return 0x82109818;
		  /* 82109818h */ case    3:  		/* li R29, 0 */
		/* 82109818h case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82109818h case    3:*/		return 0x8210981C;
		  /* 8210981Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8210981Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210981Ch case    4:*/		return 0x82109820;
		  /* 82109820h */ case    5:  		/* bc 4, CR6_GT, 336 */
		/* 82109820h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82109970;  }
		/* 82109820h case    5:*/		return 0x82109824;
		  /* 82109824h */ case    6:  		/* li R30, 0 */
		/* 82109824h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82109824h case    6:*/		return 0x82109828;
		  /* 82109828h */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 82109828h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82109828h case    7:*/		return 0x8210982C;
		  /* 8210982Ch */ case    8:  		/* lwzx R11, <#[R30 + R11]> */
		/* 8210982Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8210982Ch case    8:*/		return 0x82109830;
		  /* 82109830h */ case    9:  		/* b 52 */
		/* 82109830h case    9:*/		return 0x82109864;
		/* 82109830h case    9:*/		return 0x82109834;
		  /* 82109834h */ case   10:  		/* lwz R10, <#[R31 + 16]> */
		/* 82109834h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82109834h case   10:*/		return 0x82109838;
		  /* 82109838h */ case   11:  		/* rlwinm R28, R11, 2, 0, 29 */
		/* 82109838h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R11);
		/* 82109838h case   11:*/		return 0x8210983C;
		  /* 8210983Ch */ case   12:  		/* lwz R11, <#[R26 + 20]> */
		/* 8210983Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 8210983Ch case   12:*/		return 0x82109840;
		  /* 82109840h */ case   13:  		/* mr R3, R26 */
		/* 82109840h case   13:*/		regs.R3 = regs.R26;
		/* 82109840h case   13:*/		return 0x82109844;
		  /* 82109844h */ case   14:  		/* lwz R10, <#[R10]> */
		/* 82109844h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82109844h case   14:*/		return 0x82109848;
		  /* 82109848h */ case   15:  		/* lwzx R4, <#[R28 + R11]> */
		/* 82109848h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 82109848h case   15:*/		return 0x8210984C;
		  /* 8210984Ch */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210984Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210984Ch case   16:*/		return 0x82109850;
		  /* 82109850h */ case   17:  		/* lwzx R5, <#[R10 + R11]> */
		/* 82109850h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82109850h case   17:*/		return 0x82109854;
		  /* 82109854h */ case   18:  		/* bl -29924 */
		/* 82109854h case   18:*/		regs.LR = 0x82109858; return 0x82102370;
		/* 82109854h case   18:*/		return 0x82109858;
		  /* 82109858h */ case   19:  		/* lwz R11, <#[R26 + 20]> */
		/* 82109858h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82109858h case   19:*/		return 0x8210985C;
		  /* 8210985Ch */ case   20:  		/* lwzx R11, <#[R28 + R11]> */
		/* 8210985Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 8210985Ch case   20:*/		return 0x82109860;
		  /* 82109860h */ case   21:  		/* lwz R11, <#[R11 + 8]> */
		/* 82109860h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82109860h case   21:*/		return 0x82109864;
	}
	return 0x82109864;
} // Block from 8210980Ch-82109864h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82109864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109864);
		  /* 82109864h */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 82109864h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109864h case    0:*/		return 0x82109868;
		  /* 82109868h */ case    1:  		/* bc 4, CR6_EQ, -52 */
		/* 82109868h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82109834;  }
		/* 82109868h case    1:*/		return 0x8210986C;
		  /* 8210986Ch */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 8210986Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8210986Ch case    2:*/		return 0x82109870;
		  /* 82109870h */ case    3:  		/* addi R29, R29, 1 */
		/* 82109870h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82109870h case    3:*/		return 0x82109874;
		  /* 82109874h */ case    4:  		/* addi R30, R30, 4 */
		/* 82109874h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82109874h case    4:*/		return 0x82109878;
		  /* 82109878h */ case    5:  		/* cmplw CR6, R29, R11 */
		/* 82109878h case    5:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82109878h case    5:*/		return 0x8210987C;
		  /* 8210987Ch */ case    6:  		/* bc 12, CR6_LT, -84 */
		/* 8210987Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x82109828;  }
		/* 8210987Ch case    6:*/		return 0x82109880;
		  /* 82109880h */ case    7:  		/* b 240 */
		/* 82109880h case    7:*/		return 0x82109970;
		/* 82109880h case    7:*/		return 0x82109884;
	}
	return 0x82109884;
} // Block from 82109864h-82109884h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82109884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109884);
		  /* 82109884h */ case    0:  		/* li R10, 0 */
		/* 82109884h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82109884h case    0:*/		return 0x82109888;
		  /* 82109888h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82109888h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82109888h case    1:*/		return 0x8210988C;
		  /* 8210988Ch */ case    2:  		/* bc 4, CR6_GT, 228 */
		/* 8210988Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x82109970;  }
		/* 8210988Ch case    2:*/		return 0x82109890;
		  /* 82109890h */ case    3:  		/* li R11, 0 */
		/* 82109890h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82109890h case    3:*/		return 0x82109894;
		  /* 82109894h */ case    4:  		/* lwz R9, <#[R31 + 8]> */
		/* 82109894h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82109894h case    4:*/		return 0x82109898;
		  /* 82109898h */ case    5:  		/* addi R10, R10, 1 */
		/* 82109898h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82109898h case    5:*/		return 0x8210989C;
		  /* 8210989Ch */ case    6:  		/* lwz R8, <#[R26 + 20]> */
		/* 8210989Ch case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 8210989Ch case    6:*/		return 0x821098A0;
		  /* 821098A0h */ case    7:  		/* lwzx R9, <#[R11 + R9]> */
		/* 821098A0h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821098A0h case    7:*/		return 0x821098A4;
		  /* 821098A4h */ case    8:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821098A4h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821098A4h case    8:*/		return 0x821098A8;
		  /* 821098A8h */ case    9:  		/* lwzx R9, <#[R9 + R8]> */
		/* 821098A8h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 821098A8h case    9:*/		return 0x821098AC;
		  /* 821098ACh */ case   10:  		/* stw R23, <#[R9 + 20]> */
		/* 821098ACh case   10:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R9 + 0x00000014) );
		/* 821098ACh case   10:*/		return 0x821098B0;
		  /* 821098B0h */ case   11:  		/* lwz R8, <#[R26 + 20]> */
		/* 821098B0h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 821098B0h case   11:*/		return 0x821098B4;
		  /* 821098B4h */ case   12:  		/* lwz R9, <#[R31 + 8]> */
		/* 821098B4h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821098B4h case   12:*/		return 0x821098B8;
		  /* 821098B8h */ case   13:  		/* lwzx R9, <#[R11 + R9]> */
		/* 821098B8h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821098B8h case   13:*/		return 0x821098BC;
		  /* 821098BCh */ case   14:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 821098BCh case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 821098BCh case   14:*/		return 0x821098C0;
		  /* 821098C0h */ case   15:  		/* lwzx R9, <#[R9 + R8]> */
		/* 821098C0h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 821098C0h case   15:*/		return 0x821098C4;
		  /* 821098C4h */ case   16:  		/* addi R11, R11, 4 */
		/* 821098C4h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821098C4h case   16:*/		return 0x821098C8;
		  /* 821098C8h */ case   17:  		/* stw R17, <#[R9 + 24]> */
		/* 821098C8h case   17:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R9 + 0x00000018) );
		/* 821098C8h case   17:*/		return 0x821098CC;
		  /* 821098CCh */ case   18:  		/* lwz R9, <#[R31 + 4]> */
		/* 821098CCh case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 821098CCh case   18:*/		return 0x821098D0;
		  /* 821098D0h */ case   19:  		/* cmplw CR6, R10, R9 */
		/* 821098D0h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821098D0h case   19:*/		return 0x821098D4;
		  /* 821098D4h */ case   20:  		/* bc 12, CR6_LT, -64 */
		/* 821098D4h case   20:*/		if ( regs.CR[6].lt ) { return 0x82109894;  }
		/* 821098D4h case   20:*/		return 0x821098D8;
		  /* 821098D8h */ case   21:  		/* b 152 */
		/* 821098D8h case   21:*/		return 0x82109970;
		/* 821098D8h case   21:*/		return 0x821098DC;
	}
	return 0x821098DC;
} // Block from 82109884h-821098DCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 821098DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821098DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821098DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821098DC);
		  /* 821098DCh */ case    0:  		/* li R29, 0 */
		/* 821098DCh case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821098DCh case    0:*/		return 0x821098E0;
		  /* 821098E0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821098E0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821098E0h case    1:*/		return 0x821098E4;
		  /* 821098E4h */ case    2:  		/* bc 12, CR6_EQ, 140 */
		/* 821098E4h case    2:*/		if ( regs.CR[6].eq ) { return 0x82109970;  }
		/* 821098E4h case    2:*/		return 0x821098E8;
		  /* 821098E8h */ case    3:  		/* li R30, 0 */
		/* 821098E8h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821098E8h case    3:*/		return 0x821098EC;
		  /* 821098ECh */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 821098ECh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821098ECh case    4:*/		return 0x821098F0;
		  /* 821098F0h */ case    5:  		/* mr R3, R26 */
		/* 821098F0h case    5:*/		regs.R3 = regs.R26;
		/* 821098F0h case    5:*/		return 0x821098F4;
		  /* 821098F4h */ case    6:  		/* lwz R10, <#[R26 + 20]> */
		/* 821098F4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 821098F4h case    6:*/		return 0x821098F8;
		  /* 821098F8h */ case    7:  		/* lwz R9, <#[R31 + 16]> */
		/* 821098F8h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 821098F8h case    7:*/		return 0x821098FC;
		  /* 821098FCh */ case    8:  		/* lwzx R11, <#[R30 + R11]> */
		/* 821098FCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 821098FCh case    8:*/		return 0x82109900;
		  /* 82109900h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109900h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109900h case    9:*/		return 0x82109904;
		  /* 82109904h */ case   10:  		/* lwzx R9, <#[R30 + R9]> */
		/* 82109904h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 82109904h case   10:*/		return 0x82109908;
		  /* 82109908h */ case   11:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82109908h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82109908h case   11:*/		return 0x8210990C;
		  /* 8210990Ch */ case   12:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210990Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210990Ch case   12:*/		return 0x82109910;
		  /* 82109910h */ case   13:  		/* lwzx R4, <#[R9 + R10]> */
		/* 82109910h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82109910h case   13:*/		return 0x82109914;
		  /* 82109914h */ case   14:  		/* lwz R11, <#[R11 + 20]> */
		/* 82109914h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82109914h case   14:*/		return 0x82109918;
		  /* 82109918h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109918h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109918h case   15:*/		return 0x8210991C;
		  /* 8210991Ch */ case   16:  		/* lwzx R5, <#[R11 + R10]> */
		/* 8210991Ch case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210991Ch case   16:*/		return 0x82109920;
		  /* 82109920h */ case   17:  		/* bl -30128 */
		/* 82109920h case   17:*/		regs.LR = 0x82109924; return 0x82102370;
		/* 82109920h case   17:*/		return 0x82109924;
		  /* 82109924h */ case   18:  		/* lwz R11, <#[R31 + 8]> */
		/* 82109924h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82109924h case   18:*/		return 0x82109928;
		  /* 82109928h */ case   19:  		/* mr R3, R26 */
		/* 82109928h case   19:*/		regs.R3 = regs.R26;
		/* 82109928h case   19:*/		return 0x8210992C;
		  /* 8210992Ch */ case   20:  		/* lwz R10, <#[R26 + 20]> */
		/* 8210992Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 8210992Ch case   20:*/		return 0x82109930;
		  /* 82109930h */ case   21:  		/* lwz R9, <#[R31 + 16]> */
		/* 82109930h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82109930h case   21:*/		return 0x82109934;
		  /* 82109934h */ case   22:  		/* lwzx R11, <#[R30 + R11]> */
		/* 82109934h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 82109934h case   22:*/		return 0x82109938;
		  /* 82109938h */ case   23:  		/* lwzx R9, <#[R30 + R9]> */
		/* 82109938h case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + regs.R9 + 0x00000000) );
		/* 82109938h case   23:*/		return 0x8210993C;
		  /* 8210993Ch */ case   24:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210993Ch case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210993Ch case   24:*/		return 0x82109940;
		  /* 82109940h */ case   25:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82109940h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82109940h case   25:*/		return 0x82109944;
		  /* 82109944h */ case   26:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82109944h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82109944h case   26:*/		return 0x82109948;
		  /* 82109948h */ case   27:  		/* lwzx R5, <#[R9 + R10]> */
		/* 82109948h case   27:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82109948h case   27:*/		return 0x8210994C;
		  /* 8210994Ch */ case   28:  		/* lwz R11, <#[R11 + 20]> */
		/* 8210994Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8210994Ch case   28:*/		return 0x82109950;
		  /* 82109950h */ case   29:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109950h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109950h case   29:*/		return 0x82109954;
		  /* 82109954h */ case   30:  		/* lwzx R4, <#[R11 + R10]> */
		/* 82109954h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82109954h case   30:*/		return 0x82109958;
		  /* 82109958h */ case   31:  		/* bl -30184 */
		/* 82109958h case   31:*/		regs.LR = 0x8210995C; return 0x82102370;
		/* 82109958h case   31:*/		return 0x8210995C;
		  /* 8210995Ch */ case   32:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210995Ch case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210995Ch case   32:*/		return 0x82109960;
		  /* 82109960h */ case   33:  		/* addi R29, R29, 1 */
		/* 82109960h case   33:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82109960h case   33:*/		return 0x82109964;
		  /* 82109964h */ case   34:  		/* addi R30, R30, 4 */
		/* 82109964h case   34:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82109964h case   34:*/		return 0x82109968;
		  /* 82109968h */ case   35:  		/* cmplw CR6, R29, R11 */
		/* 82109968h case   35:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82109968h case   35:*/		return 0x8210996C;
		  /* 8210996Ch */ case   36:  		/* bc 12, CR6_LT, -128 */
		/* 8210996Ch case   36:*/		if ( regs.CR[6].lt ) { return 0x821098EC;  }
		/* 8210996Ch case   36:*/		return 0x82109970;
	}
	return 0x82109970;
} // Block from 821098DCh-82109970h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82109970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109970);
		  /* 82109970h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 82109970h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82109970h case    0:*/		return 0x82109974;
		  /* 82109974h */ case    1:  		/* bc 4, CR6_EQ, -992 */
		/* 82109974h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82109594;  }
		/* 82109974h case    1:*/		return 0x82109978;
	}
	return 0x82109978;
} // Block from 82109970h-82109978h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82109978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109978);
		  /* 82109978h */ case    0:  		/* addi R3, R1, 80 */
		/* 82109978h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82109978h case    0:*/		return 0x8210997C;
		  /* 8210997Ch */ case    1:  		/* bl 1129028 */
		/* 8210997Ch case    1:*/		regs.LR = 0x82109980; return 0x8221D3C0;
		/* 8210997Ch case    1:*/		return 0x82109980;
		  /* 82109980h */ case    2:  		/* lwz R11, <#[R26 + 12]> */
		/* 82109980h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 82109980h case    2:*/		return 0x82109984;
		  /* 82109984h */ case    3:  		/* li R30, 0 */
		/* 82109984h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82109984h case    3:*/		return 0x82109988;
		  /* 82109988h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82109988h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82109988h case    4:*/		return 0x8210998C;
		  /* 8210998Ch */ case    5:  		/* bc 4, CR6_GT, 616 */
		/* 8210998Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x82109BF4;  }
		/* 8210998Ch case    5:*/		return 0x82109990;
		  /* 82109990h */ case    6:  		/* li R31, 0 */
		/* 82109990h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82109990h case    6:*/		return 0x82109994;
		  /* 82109994h */ case    7:  		/* lwz R11, <#[R26 + 24]> */
		/* 82109994h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 82109994h case    7:*/		return 0x82109998;
		  /* 82109998h */ case    8:  		/* lwzx R3, <#[R11 + R31]> */
		/* 82109998h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82109998h case    8:*/		return 0x8210999C;
		  /* 8210999Ch */ case    9:  		/* lwz R11, <#[R3]> */
		/* 8210999Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8210999Ch case    9:*/		return 0x821099A0;
		  /* 821099A0h */ case   10:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 821099A0h case   10:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 821099A0h case   10:*/		return 0x821099A4;
		  /* 821099A4h */ case   11:  		/* bc 12, CR0_EQ, 572 */
		/* 821099A4h case   11:*/		if ( regs.CR[0].eq ) { return 0x82109BE0;  }
		/* 821099A4h case   11:*/		return 0x821099A8;
		  /* 821099A8h */ case   12:  		/* lis R10, 4336 */
		/* 821099A8h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x10F0);
		/* 821099A8h case   12:*/		return 0x821099AC;
		  /* 821099ACh */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 821099ACh case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821099ACh case   13:*/		return 0x821099B0;
		  /* 821099B0h */ case   14:  		/* bc 12, CR6_EQ, 560 */
		/* 821099B0h case   14:*/		if ( regs.CR[6].eq ) { return 0x82109BE0;  }
		/* 821099B0h case   14:*/		return 0x821099B4;
		  /* 821099B4h */ case   15:  		/* cmplw CR6, R11, R22 */
		/* 821099B4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 821099B4h case   15:*/		return 0x821099B8;
		  /* 821099B8h */ case   16:  		/* bc 12, CR6_EQ, 552 */
		/* 821099B8h case   16:*/		if ( regs.CR[6].eq ) { return 0x82109BE0;  }
		/* 821099B8h case   16:*/		return 0x821099BC;
		  /* 821099BCh */ case   17:  		/* lis R10, 4368 */
		/* 821099BCh case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x1110);
		/* 821099BCh case   17:*/		return 0x821099C0;
		  /* 821099C0h */ case   18:  		/* cmplw CR6, R11, R10 */
		/* 821099C0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821099C0h case   18:*/		return 0x821099C4;
		  /* 821099C4h */ case   19:  		/* bc 12, CR6_EQ, 540 */
		/* 821099C4h case   19:*/		if ( regs.CR[6].eq ) { return 0x82109BE0;  }
		/* 821099C4h case   19:*/		return 0x821099C8;
		  /* 821099C8h */ case   20:  		/* cmplw CR6, R11, R21 */
		/* 821099C8h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R21);
		/* 821099C8h case   20:*/		return 0x821099CC;
		  /* 821099CCh */ case   21:  		/* bc 12, CR6_EQ, 532 */
		/* 821099CCh case   21:*/		if ( regs.CR[6].eq ) { return 0x82109BE0;  }
		/* 821099CCh case   21:*/		return 0x821099D0;
		  /* 821099D0h */ case   22:  		/* lis R10, 4400 */
		/* 821099D0h case   22:*/		cpu::op::lis<0>(regs,&regs.R10,0x1130);
		/* 821099D0h case   22:*/		return 0x821099D4;
		  /* 821099D4h */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 821099D4h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821099D4h case   23:*/		return 0x821099D8;
		  /* 821099D8h */ case   24:  		/* bc 12, CR6_EQ, 520 */
		/* 821099D8h case   24:*/		if ( regs.CR[6].eq ) { return 0x82109BE0;  }
		/* 821099D8h case   24:*/		return 0x821099DC;
		  /* 821099DCh */ case   25:  		/* lis R10, 4416 */
		/* 821099DCh case   25:*/		cpu::op::lis<0>(regs,&regs.R10,0x1140);
		/* 821099DCh case   25:*/		return 0x821099E0;
		  /* 821099E0h */ case   26:  		/* cmplw CR6, R11, R10 */
		/* 821099E0h case   26:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821099E0h case   26:*/		return 0x821099E4;
		  /* 821099E4h */ case   27:  		/* bc 12, CR6_EQ, 508 */
		/* 821099E4h case   27:*/		if ( regs.CR[6].eq ) { return 0x82109BE0;  }
		/* 821099E4h case   27:*/		return 0x821099E8;
		  /* 821099E8h */ case   28:  		/* cmplw CR6, R11, R19 */
		/* 821099E8h case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 821099E8h case   28:*/		return 0x821099EC;
		  /* 821099ECh */ case   29:  		/* bc 12, CR6_EQ, 500 */
		/* 821099ECh case   29:*/		if ( regs.CR[6].eq ) { return 0x82109BE0;  }
		/* 821099ECh case   29:*/		return 0x821099F0;
		  /* 821099F0h */ case   30:  		/* lis R10, 8336 */
		/* 821099F0h case   30:*/		cpu::op::lis<0>(regs,&regs.R10,0x2090);
		/* 821099F0h case   30:*/		return 0x821099F4;
		  /* 821099F4h */ case   31:  		/* cmplw CR6, R11, R10 */
		/* 821099F4h case   31:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821099F4h case   31:*/		return 0x821099F8;
		  /* 821099F8h */ case   32:  		/* bc 12, CR6_EQ, 488 */
		/* 821099F8h case   32:*/		if ( regs.CR[6].eq ) { return 0x82109BE0;  }
		/* 821099F8h case   32:*/		return 0x821099FC;
		  /* 821099FCh */ case   33:  		/* cmplw CR6, R11, R20 */
		/* 821099FCh case   33:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 821099FCh case   33:*/		return 0x82109A00;
		  /* 82109A00h */ case   34:  		/* bc 12, CR6_EQ, 480 */
		/* 82109A00h case   34:*/		if ( regs.CR[6].eq ) { return 0x82109BE0;  }
		/* 82109A00h case   34:*/		return 0x82109A04;
		  /* 82109A04h */ case   35:  		/* lwz R11, <#[R3 + 16]> */
		/* 82109A04h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82109A04h case   35:*/		return 0x82109A08;
		  /* 82109A08h */ case   36:  		/* lwz R8, <#[R26 + 20]> */
		/* 82109A08h case   36:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 82109A08h case   36:*/		return 0x82109A0C;
		  /* 82109A0Ch */ case   37:  		/* lwz R10, <#[R26 + 16]> */
		/* 82109A0Ch case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 82109A0Ch case   37:*/		return 0x82109A10;
		  /* 82109A10h */ case   38:  		/* lwz R11, <#[R11]> */
		/* 82109A10h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82109A10h case   38:*/		return 0x82109A14;
		  /* 82109A14h */ case   39:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109A14h case   39:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109A14h case   39:*/		return 0x82109A18;
		  /* 82109A18h */ case   40:  		/* lwzx R5, <#[R11 + R8]> */
		/* 82109A18h case   40:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82109A18h case   40:*/		return 0x82109A1C;
		  /* 82109A1Ch */ case   41:  		/* lwz R11, <#[R5 + 4]> */
		/* 82109A1Ch case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 82109A1Ch case   41:*/		return 0x82109A20;
		  /* 82109A20h */ case   42:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109A20h case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109A20h case   42:*/		return 0x82109A24;
		  /* 82109A24h */ case   43:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82109A24h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82109A24h case   43:*/		return 0x82109A28;
		  /* 82109A28h */ case   44:  		/* lwz R11, <#[R11 + 4]> */
		/* 82109A28h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82109A28h case   44:*/		return 0x82109A2C;
		  /* 82109A2Ch */ case   45:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 82109A2Ch case   45:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82109A2Ch case   45:*/		return 0x82109A30;
		  /* 82109A30h */ case   46:  		/* bc 4, CR0_EQ, 432 */
		/* 82109A30h case   46:*/		if ( !regs.CR[0].eq ) { return 0x82109BE0;  }
		/* 82109A30h case   46:*/		return 0x82109A34;
		  /* 82109A34h */ case   47:  		/* lwz R11, <#[R5 + 20]> */
		/* 82109A34h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000014) );
		/* 82109A34h case   47:*/		return 0x82109A38;
		  /* 82109A38h */ case   48:  		/* li R4, 0 */
		/* 82109A38h case   48:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82109A38h case   48:*/		return 0x82109A3C;
		  /* 82109A3Ch */ case   49:  		/* li R6, 0 */
		/* 82109A3Ch case   49:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82109A3Ch case   49:*/		return 0x82109A40;
		  /* 82109A40h */ case   50:  		/* li R10, 0 */
		/* 82109A40h case   50:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82109A40h case   50:*/		return 0x82109A44;
		  /* 82109A44h */ case   51:  		/* cmpwi CR6, R11, -1 */
		/* 82109A44h case   51:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109A44h case   51:*/		return 0x82109A48;
		  /* 82109A48h */ case   52:  		/* bc 12, CR6_EQ, 40 */
		/* 82109A48h case   52:*/		if ( regs.CR[6].eq ) { return 0x82109A70;  }
		/* 82109A48h case   52:*/		return 0x82109A4C;
		  /* 82109A4Ch */ case   53:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109A4Ch case   53:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109A4Ch case   53:*/		return 0x82109A50;
		  /* 82109A50h */ case   54:  		/* addi R10, R10, 1 */
		/* 82109A50h case   54:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82109A50h case   54:*/		return 0x82109A54;
		  /* 82109A54h */ case   55:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82109A54h case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82109A54h case   55:*/		return 0x82109A58;
		  /* 82109A58h */ case   56:  		/* lwz R11, <#[R11 + 20]> */
		/* 82109A58h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82109A58h case   56:*/		return 0x82109A5C;
		  /* 82109A5Ch */ case   57:  		/* cmpwi CR6, R11, -1 */
		/* 82109A5Ch case   57:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109A5Ch case   57:*/		return 0x82109A60;
		  /* 82109A60h */ case   58:  		/* bc 4, CR6_EQ, -20 */
		/* 82109A60h case   58:*/		if ( !regs.CR[6].eq ) { return 0x82109A4C;  }
		/* 82109A60h case   58:*/		return 0x82109A64;
		  /* 82109A64h */ case   59:  		/* cmplwi CR6, R10, 0 */
		/* 82109A64h case   59:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82109A64h case   59:*/		return 0x82109A68;
		  /* 82109A68h */ case   60:  		/* bc 12, CR6_EQ, 8 */
		/* 82109A68h case   60:*/		if ( regs.CR[6].eq ) { return 0x82109A70;  }
		/* 82109A68h case   60:*/		return 0x82109A6C;
		  /* 82109A6Ch */ case   61:  		/* mr R4, R10 */
		/* 82109A6Ch case   61:*/		regs.R4 = regs.R10;
		/* 82109A6Ch case   61:*/		return 0x82109A70;
	}
	return 0x82109A70;
} // Block from 82109978h-82109A70h (62 instructions)

//////////////////////////////////////////////////////
// Block at 82109A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109A70);
		  /* 82109A70h */ case    0:  		/* lwz R11, <#[R5 + 8]> */
		/* 82109A70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 82109A70h case    0:*/		return 0x82109A74;
		  /* 82109A74h */ case    1:  		/* b 68 */
		/* 82109A74h case    1:*/		return 0x82109AB8;
		/* 82109A74h case    1:*/		return 0x82109A78;
		  /* 82109A78h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109A78h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109A78h case    2:*/		return 0x82109A7C;
		  /* 82109A7Ch */ case    3:  		/* li R10, 0 */
		/* 82109A7Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82109A7Ch case    3:*/		return 0x82109A80;
		  /* 82109A80h */ case    4:  		/* lwzx R9, <#[R11 + R8]> */
		/* 82109A80h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82109A80h case    4:*/		return 0x82109A84;
		  /* 82109A84h */ case    5:  		/* lwz R11, <#[R9 + 20]> */
		/* 82109A84h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 82109A84h case    5:*/		return 0x82109A88;
		  /* 82109A88h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 82109A88h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109A88h case    6:*/		return 0x82109A8C;
		  /* 82109A8Ch */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 82109A8Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82109AB4;  }
		/* 82109A8Ch case    7:*/		return 0x82109A90;
		  /* 82109A90h */ case    8:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109A90h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109A90h case    8:*/		return 0x82109A94;
		  /* 82109A94h */ case    9:  		/* addi R10, R10, 1 */
		/* 82109A94h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82109A94h case    9:*/		return 0x82109A98;
		  /* 82109A98h */ case   10:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82109A98h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82109A98h case   10:*/		return 0x82109A9C;
		  /* 82109A9Ch */ case   11:  		/* lwz R11, <#[R11 + 20]> */
		/* 82109A9Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82109A9Ch case   11:*/		return 0x82109AA0;
		  /* 82109AA0h */ case   12:  		/* cmpwi CR6, R11, -1 */
		/* 82109AA0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109AA0h case   12:*/		return 0x82109AA4;
		  /* 82109AA4h */ case   13:  		/* bc 4, CR6_EQ, -20 */
		/* 82109AA4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82109A90;  }
		/* 82109AA4h case   13:*/		return 0x82109AA8;
		  /* 82109AA8h */ case   14:  		/* cmplw CR6, R6, R10 */
		/* 82109AA8h case   14:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82109AA8h case   14:*/		return 0x82109AAC;
		  /* 82109AACh */ case   15:  		/* bc 4, CR6_LT, 8 */
		/* 82109AACh case   15:*/		if ( !regs.CR[6].lt ) { return 0x82109AB4;  }
		/* 82109AACh case   15:*/		return 0x82109AB0;
		  /* 82109AB0h */ case   16:  		/* mr R6, R10 */
		/* 82109AB0h case   16:*/		regs.R6 = regs.R10;
		/* 82109AB0h case   16:*/		return 0x82109AB4;
	}
	return 0x82109AB4;
} // Block from 82109A70h-82109AB4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82109AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109AB4);
		  /* 82109AB4h */ case    0:  		/* lwz R11, <#[R9 + 8]> */
		/* 82109AB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82109AB4h case    0:*/		return 0x82109AB8;
	}
	return 0x82109AB8;
} // Block from 82109AB4h-82109AB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82109AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109AB8);
		  /* 82109AB8h */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 82109AB8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109AB8h case    0:*/		return 0x82109ABC;
		  /* 82109ABCh */ case    1:  		/* bc 4, CR6_EQ, -68 */
		/* 82109ABCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82109A78;  }
		/* 82109ABCh case    1:*/		return 0x82109AC0;
		  /* 82109AC0h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 82109AC0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82109AC0h case    2:*/		return 0x82109AC4;
		  /* 82109AC4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82109AC4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82109AC4h case    3:*/		return 0x82109AC8;
		  /* 82109AC8h */ case    4:  		/* bc 12, CR6_EQ, 100 */
		/* 82109AC8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82109B2C;  }
		/* 82109AC8h case    4:*/		return 0x82109ACC;
		  /* 82109ACCh */ case    5:  		/* lwz R7, <#[R3 + 8]> */
		/* 82109ACCh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000008) );
		/* 82109ACCh case    5:*/		return 0x82109AD0;
		  /* 82109AD0h */ case    6:  		/* mtspr CTR, R11 */
		/* 82109AD0h case    6:*/		regs.CTR = regs.R11;
		/* 82109AD0h case    6:*/		return 0x82109AD4;
		  /* 82109AD4h */ case    7:  		/* lwz R11, <#[R7]> */
		/* 82109AD4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82109AD4h case    7:*/		return 0x82109AD8;
		  /* 82109AD8h */ case    8:  		/* b 68 */
		/* 82109AD8h case    8:*/		return 0x82109B1C;
		/* 82109AD8h case    8:*/		return 0x82109ADC;
		  /* 82109ADCh */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109ADCh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109ADCh case    9:*/		return 0x82109AE0;
		  /* 82109AE0h */ case   10:  		/* li R10, 0 */
		/* 82109AE0h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82109AE0h case   10:*/		return 0x82109AE4;
		  /* 82109AE4h */ case   11:  		/* lwzx R9, <#[R11 + R8]> */
		/* 82109AE4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82109AE4h case   11:*/		return 0x82109AE8;
		  /* 82109AE8h */ case   12:  		/* lwz R11, <#[R9 + 20]> */
		/* 82109AE8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000014) );
		/* 82109AE8h case   12:*/		return 0x82109AEC;
		  /* 82109AECh */ case   13:  		/* cmpwi CR6, R11, -1 */
		/* 82109AECh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109AECh case   13:*/		return 0x82109AF0;
		  /* 82109AF0h */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 82109AF0h case   14:*/		if ( regs.CR[6].eq ) { return 0x82109B18;  }
		/* 82109AF0h case   14:*/		return 0x82109AF4;
		  /* 82109AF4h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109AF4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109AF4h case   15:*/		return 0x82109AF8;
		  /* 82109AF8h */ case   16:  		/* addi R10, R10, 1 */
		/* 82109AF8h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82109AF8h case   16:*/		return 0x82109AFC;
		  /* 82109AFCh */ case   17:  		/* lwzx R11, <#[R11 + R8]> */
		/* 82109AFCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82109AFCh case   17:*/		return 0x82109B00;
		  /* 82109B00h */ case   18:  		/* lwz R11, <#[R11 + 20]> */
		/* 82109B00h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82109B00h case   18:*/		return 0x82109B04;
		  /* 82109B04h */ case   19:  		/* cmpwi CR6, R11, -1 */
		/* 82109B04h case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109B04h case   19:*/		return 0x82109B08;
		  /* 82109B08h */ case   20:  		/* bc 4, CR6_EQ, -20 */
		/* 82109B08h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82109AF4;  }
		/* 82109B08h case   20:*/		return 0x82109B0C;
		  /* 82109B0Ch */ case   21:  		/* cmplw CR6, R6, R10 */
		/* 82109B0Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 82109B0Ch case   21:*/		return 0x82109B10;
		  /* 82109B10h */ case   22:  		/* bc 4, CR6_LT, 8 */
		/* 82109B10h case   22:*/		if ( !regs.CR[6].lt ) { return 0x82109B18;  }
		/* 82109B10h case   22:*/		return 0x82109B14;
		  /* 82109B14h */ case   23:  		/* mr R6, R10 */
		/* 82109B14h case   23:*/		regs.R6 = regs.R10;
		/* 82109B14h case   23:*/		return 0x82109B18;
	}
	return 0x82109B18;
} // Block from 82109AB8h-82109B18h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82109B18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109B18);
		  /* 82109B18h */ case    0:  		/* lwz R11, <#[R9 + 8]> */
		/* 82109B18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82109B18h case    0:*/		return 0x82109B1C;
	}
	return 0x82109B1C;
} // Block from 82109B18h-82109B1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82109B1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109B1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109B1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109B1C);
		  /* 82109B1Ch */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 82109B1Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109B1Ch case    0:*/		return 0x82109B20;
		  /* 82109B20h */ case    1:  		/* bc 4, CR6_EQ, -68 */
		/* 82109B20h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82109ADC;  }
		/* 82109B20h case    1:*/		return 0x82109B24;
		  /* 82109B24h */ case    2:  		/* addi R7, R7, 4 */
		/* 82109B24h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82109B24h case    2:*/		return 0x82109B28;
		  /* 82109B28h */ case    3:  		/* bc 16, CR0_LT, -84 */
		/* 82109B28h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82109AD4;  }
		/* 82109B28h case    3:*/		return 0x82109B2C;
	}
	return 0x82109B2C;
} // Block from 82109B1Ch-82109B2Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82109B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109B2C);
		  /* 82109B2Ch */ case    0:  		/* lwz R11, <#[R5 + 20]> */
		/* 82109B2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000014) );
		/* 82109B2Ch case    0:*/		return 0x82109B30;
		  /* 82109B30h */ case    1:  		/* cmplw CR6, R4, R6 */
		/* 82109B30h case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R6);
		/* 82109B30h case    1:*/		return 0x82109B34;
		  /* 82109B34h */ case    2:  		/* bc 4, CR6_GT, 172 */
		/* 82109B34h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82109BE0;  }
		/* 82109B34h case    2:*/		return 0x82109B38;
		  /* 82109B38h */ case    3:  		/* subf R10, R6, R4 */
		/* 82109B38h case    3:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R6,regs.R4);
		/* 82109B38h case    3:*/		return 0x82109B3C;
		  /* 82109B3Ch */ case    4:  		/* mtspr CTR, R10 */
		/* 82109B3Ch case    4:*/		regs.CTR = regs.R10;
		/* 82109B3Ch case    4:*/		return 0x82109B40;
		  /* 82109B40h */ case    5:  		/* lwz R10, <#[R26 + 20]> */
		/* 82109B40h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 82109B40h case    5:*/		return 0x82109B44;
		  /* 82109B44h */ case    6:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82109B44h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82109B44h case    6:*/		return 0x82109B48;
		  /* 82109B48h */ case    7:  		/* lwz R11, <#[R26 + 16]> */
		/* 82109B48h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 82109B48h case    7:*/		return 0x82109B4C;
		  /* 82109B4Ch */ case    8:  		/* lwzx R10, <#[R9 + R10]> */
		/* 82109B4Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82109B4Ch case    8:*/		return 0x82109B50;
		  /* 82109B50h */ case    9:  		/* lwz R10, <#[R10 + 4]> */
		/* 82109B50h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82109B50h case    9:*/		return 0x82109B54;
		  /* 82109B54h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82109B54h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82109B54h case   10:*/		return 0x82109B58;
		  /* 82109B58h */ case   11:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82109B58h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82109B58h case   11:*/		return 0x82109B5C;
		  /* 82109B5Ch */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 82109B5Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82109B5Ch case   12:*/		return 0x82109B60;
		  /* 82109B60h */ case   13:  		/* rlwinm. R11, R11, 0, 16, 16 */
		/* 82109B60h case   13:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R11);
		/* 82109B60h case   13:*/		return 0x82109B64;
		  /* 82109B64h */ case   14:  		/* bc 12, CR0_EQ, 108 */
		/* 82109B64h case   14:*/		if ( regs.CR[0].eq ) { return 0x82109BD0;  }
		/* 82109B64h case   14:*/		return 0x82109B68;
		  /* 82109B68h */ case   15:  		/* lwz R11, <#[R3 + 12]> */
		/* 82109B68h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82109B68h case   15:*/		return 0x82109B6C;
		  /* 82109B6Ch */ case   16:  		/* li R10, 0 */
		/* 82109B6Ch case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82109B6Ch case   16:*/		return 0x82109B70;
		  /* 82109B70h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 82109B70h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82109B70h case   17:*/		return 0x82109B74;
		  /* 82109B74h */ case   18:  		/* bc 4, CR6_GT, 92 */
		/* 82109B74h case   18:*/		if ( !regs.CR[6].gt ) { return 0x82109BD0;  }
		/* 82109B74h case   18:*/		return 0x82109B78;
		  /* 82109B78h */ case   19:  		/* li R11, 0 */
		/* 82109B78h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82109B78h case   19:*/		return 0x82109B7C;
		  /* 82109B7Ch */ case   20:  		/* lwz R8, <#[R3 + 16]> */
		/* 82109B7Ch case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000010) );
		/* 82109B7Ch case   20:*/		return 0x82109B80;
		  /* 82109B80h */ case   21:  		/* addi R10, R10, 1 */
		/* 82109B80h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82109B80h case   21:*/		return 0x82109B84;
		  /* 82109B84h */ case   22:  		/* lwz R7, <#[R26 + 20]> */
		/* 82109B84h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000014) );
		/* 82109B84h case   22:*/		return 0x82109B88;
		  /* 82109B88h */ case   23:  		/* lwzx R8, <#[R8 + R11]> */
		/* 82109B88h case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82109B88h case   23:*/		return 0x82109B8C;
		  /* 82109B8Ch */ case   24:  		/* lwzx R6, <#[R7 + R9]> */
		/* 82109B8Ch case   24:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 82109B8Ch case   24:*/		return 0x82109B90;
		  /* 82109B90h */ case   25:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82109B90h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82109B90h case   25:*/		return 0x82109B94;
		  /* 82109B94h */ case   26:  		/* lwz R6, <#[R6 + 24]> */
		/* 82109B94h case   26:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000018) );
		/* 82109B94h case   26:*/		return 0x82109B98;
		  /* 82109B98h */ case   27:  		/* lwzx R8, <#[R8 + R7]> */
		/* 82109B98h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 82109B98h case   27:*/		return 0x82109B9C;
		  /* 82109B9Ch */ case   28:  		/* stw R6, <#[R8 + 24]> */
		/* 82109B9Ch case   28:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R8 + 0x00000018) );
		/* 82109B9Ch case   28:*/		return 0x82109BA0;
		  /* 82109BA0h */ case   29:  		/* lwz R8, <#[R26 + 20]> */
		/* 82109BA0h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 82109BA0h case   29:*/		return 0x82109BA4;
		  /* 82109BA4h */ case   30:  		/* lwz R7, <#[R3 + 16]> */
		/* 82109BA4h case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000010) );
		/* 82109BA4h case   30:*/		return 0x82109BA8;
		  /* 82109BA8h */ case   31:  		/* lwzx R6, <#[R8 + R9]> */
		/* 82109BA8h case   31:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82109BA8h case   31:*/		return 0x82109BAC;
		  /* 82109BACh */ case   32:  		/* lwzx R7, <#[R7 + R11]> */
		/* 82109BACh case   32:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 82109BACh case   32:*/		return 0x82109BB0;
		  /* 82109BB0h */ case   33:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 82109BB0h case   33:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 82109BB0h case   33:*/		return 0x82109BB4;
		  /* 82109BB4h */ case   34:  		/* lwzx R8, <#[R7 + R8]> */
		/* 82109BB4h case   34:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 82109BB4h case   34:*/		return 0x82109BB8;
		  /* 82109BB8h */ case   35:  		/* addi R11, R11, 4 */
		/* 82109BB8h case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82109BB8h case   35:*/		return 0x82109BBC;
		  /* 82109BBCh */ case   36:  		/* lwz R6, <#[R6 + 20]> */
		/* 82109BBCh case   36:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000014) );
		/* 82109BBCh case   36:*/		return 0x82109BC0;
		  /* 82109BC0h */ case   37:  		/* stw R6, <#[R8 + 20]> */
		/* 82109BC0h case   37:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R8 + 0x00000014) );
		/* 82109BC0h case   37:*/		return 0x82109BC4;
		  /* 82109BC4h */ case   38:  		/* lwz R8, <#[R3 + 12]> */
		/* 82109BC4h case   38:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000000C) );
		/* 82109BC4h case   38:*/		return 0x82109BC8;
		  /* 82109BC8h */ case   39:  		/* cmplw CR6, R10, R8 */
		/* 82109BC8h case   39:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 82109BC8h case   39:*/		return 0x82109BCC;
		  /* 82109BCCh */ case   40:  		/* bc 12, CR6_LT, -80 */
		/* 82109BCCh case   40:*/		if ( regs.CR[6].lt ) { return 0x82109B7C;  }
		/* 82109BCCh case   40:*/		return 0x82109BD0;
	}
	return 0x82109BD0;
} // Block from 82109B2Ch-82109BD0h (41 instructions)

//////////////////////////////////////////////////////
// Block at 82109BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109BD0);
		  /* 82109BD0h */ case    0:  		/* lwz R11, <#[R26 + 20]> */
		/* 82109BD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 82109BD0h case    0:*/		return 0x82109BD4;
		  /* 82109BD4h */ case    1:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82109BD4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82109BD4h case    1:*/		return 0x82109BD8;
		  /* 82109BD8h */ case    2:  		/* lwz R11, <#[R11 + 20]> */
		/* 82109BD8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82109BD8h case    2:*/		return 0x82109BDC;
		  /* 82109BDCh */ case    3:  		/* bc 16, CR0_LT, -156 */
		/* 82109BDCh case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82109B40;  }
		/* 82109BDCh case    3:*/		return 0x82109BE0;
	}
	return 0x82109BE0;
} // Block from 82109BD0h-82109BE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82109BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109BE0);
		  /* 82109BE0h */ case    0:  		/* lwz R11, <#[R26 + 12]> */
		/* 82109BE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 82109BE0h case    0:*/		return 0x82109BE4;
		  /* 82109BE4h */ case    1:  		/* addi R30, R30, 1 */
		/* 82109BE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82109BE4h case    1:*/		return 0x82109BE8;
		  /* 82109BE8h */ case    2:  		/* addi R31, R31, 4 */
		/* 82109BE8h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82109BE8h case    2:*/		return 0x82109BEC;
		  /* 82109BECh */ case    3:  		/* cmplw CR6, R30, R11 */
		/* 82109BECh case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82109BECh case    3:*/		return 0x82109BF0;
		  /* 82109BF0h */ case    4:  		/* bc 12, CR6_LT, -604 */
		/* 82109BF0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82109994;  }
		/* 82109BF0h case    4:*/		return 0x82109BF4;
	}
	return 0x82109BF4;
} // Block from 82109BE0h-82109BF4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82109BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109BF4);
		  /* 82109BF4h */ case    0:  		/* lwz R7, <#[R26 + 8]> */
		/* 82109BF4h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000008) );
		/* 82109BF4h case    0:*/		return 0x82109BF8;
		  /* 82109BF8h */ case    1:  		/* li R9, 0 */
		/* 82109BF8h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82109BF8h case    1:*/		return 0x82109BFC;
		  /* 82109BFCh */ case    2:  		/* cmplwi CR6, R7, 0 */
		/* 82109BFCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82109BFCh case    2:*/		return 0x82109C00;
		  /* 82109C00h */ case    3:  		/* bc 12, CR6_EQ, 76 */
		/* 82109C00h case    3:*/		if ( regs.CR[6].eq ) { return 0x82109C4C;  }
		/* 82109C00h case    3:*/		return 0x82109C04;
		  /* 82109C04h */ case    4:  		/* lwz R8, <#[R26 + 20]> */
		/* 82109C04h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 82109C04h case    4:*/		return 0x82109C08;
		  /* 82109C08h */ case    5:  		/* li R10, 0 */
		/* 82109C08h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82109C08h case    5:*/		return 0x82109C0C;
		  /* 82109C0Ch */ case    6:  		/* lwzx R11, <#[R8 + R10]> */
		/* 82109C0Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82109C0Ch case    6:*/		return 0x82109C10;
		  /* 82109C10h */ case    7:  		/* lwz R6, <#[R11 + 48]> */
		/* 82109C10h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000030) );
		/* 82109C10h case    7:*/		return 0x82109C14;
		  /* 82109C14h */ case    8:  		/* lwz R5, <#[R11 + 20]> */
		/* 82109C14h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000014) );
		/* 82109C14h case    8:*/		return 0x82109C18;
		  /* 82109C18h */ case    9:  		/* cmplw CR6, R6, R5 */
		/* 82109C18h case    9:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 82109C18h case    9:*/		return 0x82109C1C;
		  /* 82109C1Ch */ case   10:  		/* bc 4, CR6_EQ, 20 */
		/* 82109C1Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x82109C30;  }
		/* 82109C1Ch case   10:*/		return 0x82109C20;
		  /* 82109C20h */ case   11:  		/* lwz R6, <#[R11 + 64]> */
		/* 82109C20h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000040) );
		/* 82109C20h case   11:*/		return 0x82109C24;
		  /* 82109C24h */ case   12:  		/* lwz R11, <#[R11 + 24]> */
		/* 82109C24h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82109C24h case   12:*/		return 0x82109C28;
		  /* 82109C28h */ case   13:  		/* cmplw CR6, R6, R11 */
		/* 82109C28h case   13:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 82109C28h case   13:*/		return 0x82109C2C;
		  /* 82109C2Ch */ case   14:  		/* bc 12, CR6_EQ, 8 */
		/* 82109C2Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x82109C34;  }
		/* 82109C2Ch case   14:*/		return 0x82109C30;
	}
	return 0x82109C30;
} // Block from 82109BF4h-82109C30h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82109C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109C30);
		  /* 82109C30h */ case    0:  		/* mr R18, R17 */
		/* 82109C30h case    0:*/		regs.R18 = regs.R17;
		/* 82109C30h case    0:*/		return 0x82109C34;
	}
	return 0x82109C34;
} // Block from 82109C30h-82109C34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82109C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109C34);
		  /* 82109C34h */ case    0:  		/* addi R9, R9, 1 */
		/* 82109C34h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82109C34h case    0:*/		return 0x82109C38;
		  /* 82109C38h */ case    1:  		/* addi R10, R10, 4 */
		/* 82109C38h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82109C38h case    1:*/		return 0x82109C3C;
		  /* 82109C3Ch */ case    2:  		/* cmplw CR6, R9, R7 */
		/* 82109C3Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 82109C3Ch case    2:*/		return 0x82109C40;
		  /* 82109C40h */ case    3:  		/* bc 12, CR6_LT, -52 */
		/* 82109C40h case    3:*/		if ( regs.CR[6].lt ) { return 0x82109C0C;  }
		/* 82109C40h case    3:*/		return 0x82109C44;
		  /* 82109C44h */ case    4:  		/* cmpwi CR6, R18, 0 */
		/* 82109C44h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R18,0x00000000);
		/* 82109C44h case    4:*/		return 0x82109C48;
		  /* 82109C48h */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 82109C48h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82109C64;  }
		/* 82109C48h case    5:*/		return 0x82109C4C;
	}
	return 0x82109C4C;
} // Block from 82109C34h-82109C4Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82109C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109C4C);
		  /* 82109C4Ch */ case    0:  		/* mr R31, R17 */
		/* 82109C4Ch case    0:*/		regs.R31 = regs.R17;
		/* 82109C4Ch case    0:*/		return 0x82109C50;
		  /* 82109C50h */ case    1:  		/* addi R3, R1, 80 */
		/* 82109C50h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82109C50h case    1:*/		return 0x82109C54;
		  /* 82109C54h */ case    2:  		/* bl 1128300 */
		/* 82109C54h case    2:*/		regs.LR = 0x82109C58; return 0x8221D3C0;
		/* 82109C54h case    2:*/		return 0x82109C58;
		  /* 82109C58h */ case    3:  		/* mr R3, R31 */
		/* 82109C58h case    3:*/		regs.R3 = regs.R31;
		/* 82109C58h case    3:*/		return 0x82109C5C;
		  /* 82109C5Ch */ case    4:  		/* addi R1, R1, 352 */
		/* 82109C5Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x160);
		/* 82109C5Ch case    4:*/		return 0x82109C60;
		  /* 82109C60h */ case    5:  		/* b -494056 */
		/* 82109C60h case    5:*/		return 0x82091278;
		/* 82109C60h case    5:*/		return 0x82109C64;
	}
	return 0x82109C64;
} // Block from 82109C4Ch-82109C64h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82109C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109C64);
		  /* 82109C64h */ case    0:  		/* mr R3, R26 */
		/* 82109C64h case    0:*/		regs.R3 = regs.R26;
		/* 82109C64h case    0:*/		return 0x82109C68;
		  /* 82109C68h */ case    1:  		/* bl -16592 */
		/* 82109C68h case    1:*/		regs.LR = 0x82109C6C; return 0x82105B98;
		/* 82109C68h case    1:*/		return 0x82109C6C;
		  /* 82109C6Ch */ case    2:  		/* lwz R31, <#[R26 + 12]> */
		/* 82109C6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x0000000C) );
		/* 82109C6Ch case    2:*/		return 0x82109C70;
		  /* 82109C70h */ case    3:  		/* mr R3, R17 */
		/* 82109C70h case    3:*/		regs.R3 = regs.R17;
		/* 82109C70h case    3:*/		return 0x82109C74;
		  /* 82109C74h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 82109C74h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82109C74h case    4:*/		return 0x82109C78;
		  /* 82109C78h */ case    5:  		/* bc 12, CR6_EQ, 300 */
		/* 82109C78h case    5:*/		if ( regs.CR[6].eq ) { return 0x82109DA4;  }
		/* 82109C78h case    5:*/		return 0x82109C7C;
		  /* 82109C7Ch */ case    6:  		/* rlwinm R30, R31, 2, 0, 29 */
		/* 82109C7Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R31);
		/* 82109C7Ch case    6:*/		return 0x82109C80;
		  /* 82109C80h */ case    7:  		/* lwz R11, <#[R26 + 24]> */
		/* 82109C80h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 82109C80h case    7:*/		return 0x82109C84;
		  /* 82109C84h */ case    8:  		/* addi R30, R30, -4 */
		/* 82109C84h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFC);
		/* 82109C84h case    8:*/		return 0x82109C88;
		  /* 82109C88h */ case    9:  		/* addi R31, R31, -1 */
		/* 82109C88h case    9:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82109C88h case    9:*/		return 0x82109C8C;
		  /* 82109C8Ch */ case   10:  		/* lwzx R5, <#[R11 + R30]> */
		/* 82109C8Ch case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82109C8Ch case   10:*/		return 0x82109C90;
		  /* 82109C90h */ case   11:  		/* lwz R11, <#[R5]> */
		/* 82109C90h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82109C90h case   11:*/		return 0x82109C94;
		  /* 82109C94h */ case   12:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 82109C94h case   12:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82109C94h case   12:*/		return 0x82109C98;
		  /* 82109C98h */ case   13:  		/* bc 12, CR0_EQ, 252 */
		/* 82109C98h case   13:*/		if ( regs.CR[0].eq ) { return 0x82109D94;  }
		/* 82109C98h case   13:*/		return 0x82109C9C;
		  /* 82109C9Ch */ case   14:  		/* lwz R6, <#[R5 + 12]> */
		/* 82109C9Ch case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + 0x0000000C) );
		/* 82109C9Ch case   14:*/		return 0x82109CA0;
		  /* 82109CA0h */ case   15:  		/* mr R4, R31 */
		/* 82109CA0h case   15:*/		regs.R4 = regs.R31;
		/* 82109CA0h case   15:*/		return 0x82109CA4;
		  /* 82109CA4h */ case   16:  		/* li R7, 0 */
		/* 82109CA4h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82109CA4h case   16:*/		return 0x82109CA8;
		  /* 82109CA8h */ case   17:  		/* cmplwi CR6, R6, 0 */
		/* 82109CA8h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82109CA8h case   17:*/		return 0x82109CAC;
		  /* 82109CACh */ case   18:  		/* bc 12, CR6_EQ, 80 */
		/* 82109CACh case   18:*/		if ( regs.CR[6].eq ) { return 0x82109CFC;  }
		/* 82109CACh case   18:*/		return 0x82109CB0;
		  /* 82109CB0h */ case   19:  		/* lwz R8, <#[R5 + 16]> */
		/* 82109CB0h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000010) );
		/* 82109CB0h case   19:*/		return 0x82109CB4;
		  /* 82109CB4h */ case   20:  		/* li R10, 0 */
		/* 82109CB4h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82109CB4h case   20:*/		return 0x82109CB8;
		  /* 82109CB8h */ case   21:  		/* lwz R9, <#[R26 + 20]> */
		/* 82109CB8h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000014) );
		/* 82109CB8h case   21:*/		return 0x82109CBC;
		  /* 82109CBCh */ case   22:  		/* lwzx R11, <#[R8 + R10]> */
		/* 82109CBCh case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82109CBCh case   22:*/		return 0x82109CC0;
		  /* 82109CC0h */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109CC0h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109CC0h case   23:*/		return 0x82109CC4;
		  /* 82109CC4h */ case   24:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82109CC4h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82109CC4h case   24:*/		return 0x82109CC8;
		  /* 82109CC8h */ case   25:  		/* lwz R11, <#[R11 + 20]> */
		/* 82109CC8h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82109CC8h case   25:*/		return 0x82109CCC;
		  /* 82109CCCh */ case   26:  		/* cmpwi CR6, R11, -1 */
		/* 82109CCCh case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109CCCh case   26:*/		return 0x82109CD0;
		  /* 82109CD0h */ case   27:  		/* bc 12, CR6_EQ, 28 */
		/* 82109CD0h case   27:*/		if ( regs.CR[6].eq ) { return 0x82109CEC;  }
		/* 82109CD0h case   27:*/		return 0x82109CD4;
		  /* 82109CD4h */ case   28:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109CD4h case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109CD4h case   28:*/		return 0x82109CD8;
		  /* 82109CD8h */ case   29:  		/* lwzx R11, <#[R11 + R9]> */
		/* 82109CD8h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82109CD8h case   29:*/		return 0x82109CDC;
		  /* 82109CDCh */ case   30:  		/* lwz R11, <#[R11 + 72]> */
		/* 82109CDCh case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82109CDCh case   30:*/		return 0x82109CE0;
		  /* 82109CE0h */ case   31:  		/* cmplw CR6, R4, R11 */
		/* 82109CE0h case   31:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82109CE0h case   31:*/		return 0x82109CE4;
		  /* 82109CE4h */ case   32:  		/* bc 4, CR6_LT, 8 */
		/* 82109CE4h case   32:*/		if ( !regs.CR[6].lt ) { return 0x82109CEC;  }
		/* 82109CE4h case   32:*/		return 0x82109CE8;
		  /* 82109CE8h */ case   33:  		/* mr R4, R11 */
		/* 82109CE8h case   33:*/		regs.R4 = regs.R11;
		/* 82109CE8h case   33:*/		return 0x82109CEC;
	}
	return 0x82109CEC;
} // Block from 82109C64h-82109CECh (34 instructions)

//////////////////////////////////////////////////////
// Block at 82109CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109CEC);
		  /* 82109CECh */ case    0:  		/* addi R7, R7, 1 */
		/* 82109CECh case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82109CECh case    0:*/		return 0x82109CF0;
		  /* 82109CF0h */ case    1:  		/* addi R10, R10, 4 */
		/* 82109CF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82109CF0h case    1:*/		return 0x82109CF4;
		  /* 82109CF4h */ case    2:  		/* cmplw CR6, R7, R6 */
		/* 82109CF4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 82109CF4h case    2:*/		return 0x82109CF8;
		  /* 82109CF8h */ case    3:  		/* bc 12, CR6_LT, -60 */
		/* 82109CF8h case    3:*/		if ( regs.CR[6].lt ) { return 0x82109CBC;  }
		/* 82109CF8h case    3:*/		return 0x82109CFC;
	}
	return 0x82109CFC;
} // Block from 82109CECh-82109CFCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82109CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109CFC);
		  /* 82109CFCh */ case    0:  		/* lwz R6, <#[R5 + 4]> */
		/* 82109CFCh case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + 0x00000004) );
		/* 82109CFCh case    0:*/		return 0x82109D00;
		  /* 82109D00h */ case    1:  		/* li R7, 0 */
		/* 82109D00h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82109D00h case    1:*/		return 0x82109D04;
		  /* 82109D04h */ case    2:  		/* cmplwi CR6, R6, 0 */
		/* 82109D04h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82109D04h case    2:*/		return 0x82109D08;
		  /* 82109D08h */ case    3:  		/* bc 12, CR6_EQ, 68 */
		/* 82109D08h case    3:*/		if ( regs.CR[6].eq ) { return 0x82109D4C;  }
		/* 82109D08h case    3:*/		return 0x82109D0C;
		  /* 82109D0Ch */ case    4:  		/* lwz R9, <#[R5 + 8]> */
		/* 82109D0Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000008) );
		/* 82109D0Ch case    4:*/		return 0x82109D10;
		  /* 82109D10h */ case    5:  		/* li R11, 0 */
		/* 82109D10h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82109D10h case    5:*/		return 0x82109D14;
		  /* 82109D14h */ case    6:  		/* lwz R8, <#[R26 + 20]> */
		/* 82109D14h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000014) );
		/* 82109D14h case    6:*/		return 0x82109D18;
		  /* 82109D18h */ case    7:  		/* lwzx R10, <#[R9 + R11]> */
		/* 82109D18h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82109D18h case    7:*/		return 0x82109D1C;
		  /* 82109D1Ch */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82109D1Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82109D1Ch case    8:*/		return 0x82109D20;
		  /* 82109D20h */ case    9:  		/* lwzx R10, <#[R10 + R8]> */
		/* 82109D20h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82109D20h case    9:*/		return 0x82109D24;
		  /* 82109D24h */ case   10:  		/* lwz R10, <#[R10 + 72]> */
		/* 82109D24h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000048) );
		/* 82109D24h case   10:*/		return 0x82109D28;
		  /* 82109D28h */ case   11:  		/* cmpwi CR6, R10, -1 */
		/* 82109D28h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 82109D28h case   11:*/		return 0x82109D2C;
		  /* 82109D2Ch */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 82109D2Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x82109D3C;  }
		/* 82109D2Ch case   12:*/		return 0x82109D30;
		  /* 82109D30h */ case   13:  		/* cmplw CR6, R4, R10 */
		/* 82109D30h case   13:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 82109D30h case   13:*/		return 0x82109D34;
		  /* 82109D34h */ case   14:  		/* bc 4, CR6_LT, 8 */
		/* 82109D34h case   14:*/		if ( !regs.CR[6].lt ) { return 0x82109D3C;  }
		/* 82109D34h case   14:*/		return 0x82109D38;
		  /* 82109D38h */ case   15:  		/* mr R4, R10 */
		/* 82109D38h case   15:*/		regs.R4 = regs.R10;
		/* 82109D38h case   15:*/		return 0x82109D3C;
	}
	return 0x82109D3C;
} // Block from 82109CFCh-82109D3Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 82109D3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109D3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109D3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109D3C);
		  /* 82109D3Ch */ case    0:  		/* addi R7, R7, 1 */
		/* 82109D3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82109D3Ch case    0:*/		return 0x82109D40;
		  /* 82109D40h */ case    1:  		/* addi R11, R11, 4 */
		/* 82109D40h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82109D40h case    1:*/		return 0x82109D44;
		  /* 82109D44h */ case    2:  		/* cmplw CR6, R7, R6 */
		/* 82109D44h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 82109D44h case    2:*/		return 0x82109D48;
		  /* 82109D48h */ case    3:  		/* bc 12, CR6_LT, -48 */
		/* 82109D48h case    3:*/		if ( regs.CR[6].lt ) { return 0x82109D18;  }
		/* 82109D48h case    3:*/		return 0x82109D4C;
	}
	return 0x82109D4C;
} // Block from 82109D3Ch-82109D4Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82109D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109D4C);
		  /* 82109D4Ch */ case    0:  		/* cmplw CR6, R31, R4 */
		/* 82109D4Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R4);
		/* 82109D4Ch case    0:*/		return 0x82109D50;
		  /* 82109D50h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 82109D50h case    1:*/		if ( regs.CR[6].eq ) { return 0x82109D94;  }
		/* 82109D50h case    1:*/		return 0x82109D54;
		  /* 82109D54h */ case    2:  		/* bc 4, CR6_LT, 40 */
		/* 82109D54h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82109D7C;  }
		/* 82109D54h case    2:*/		return 0x82109D58;
		  /* 82109D58h */ case    3:  		/* subf R10, R31, R4 */
		/* 82109D58h case    3:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R31,regs.R4);
		/* 82109D58h case    3:*/		return 0x82109D5C;
		  /* 82109D5Ch */ case    4:  		/* mr R11, R30 */
		/* 82109D5Ch case    4:*/		regs.R11 = regs.R30;
		/* 82109D5Ch case    4:*/		return 0x82109D60;
		  /* 82109D60h */ case    5:  		/* mtspr CTR, R10 */
		/* 82109D60h case    5:*/		regs.CTR = regs.R10;
		/* 82109D60h case    5:*/		return 0x82109D64;
		  /* 82109D64h */ case    6:  		/* lwz R10, <#[R26 + 24]> */
		/* 82109D64h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000018) );
		/* 82109D64h case    6:*/		return 0x82109D68;
		  /* 82109D68h */ case    7:  		/* add R10, R10, R11 */
		/* 82109D68h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82109D68h case    7:*/		return 0x82109D6C;
		  /* 82109D6Ch */ case    8:  		/* addi R11, R11, 4 */
		/* 82109D6Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82109D6Ch case    8:*/		return 0x82109D70;
		  /* 82109D70h */ case    9:  		/* lwz R9, <#[R10 + 4]> */
		/* 82109D70h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82109D70h case    9:*/		return 0x82109D74;
		  /* 82109D74h */ case   10:  		/* stw R9, <#[R10]> */
		/* 82109D74h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82109D74h case   10:*/		return 0x82109D78;
		  /* 82109D78h */ case   11:  		/* bc 16, CR0_LT, -20 */
		/* 82109D78h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82109D64;  }
		/* 82109D78h case   11:*/		return 0x82109D7C;
	}
	return 0x82109D7C;
} // Block from 82109D4Ch-82109D7Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 82109D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109D7C);
		  /* 82109D7Ch */ case    0:  		/* lwz R11, <#[R26 + 24]> */
		/* 82109D7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 82109D7Ch case    0:*/		return 0x82109D80;
		  /* 82109D80h */ case    1:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 82109D80h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 82109D80h case    1:*/		return 0x82109D84;
		  /* 82109D84h */ case    2:  		/* mr R3, R26 */
		/* 82109D84h case    2:*/		regs.R3 = regs.R26;
		/* 82109D84h case    2:*/		return 0x82109D88;
		  /* 82109D88h */ case    3:  		/* stwx R5, <#[R10 + R11]> */
		/* 82109D88h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82109D88h case    3:*/		return 0x82109D8C;
		  /* 82109D8Ch */ case    4:  		/* bl -16884 */
		/* 82109D8Ch case    4:*/		regs.LR = 0x82109D90; return 0x82105B98;
		/* 82109D8Ch case    4:*/		return 0x82109D90;
		  /* 82109D90h */ case    5:  		/* li R3, 0 */
		/* 82109D90h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82109D90h case    5:*/		return 0x82109D94;
	}
	return 0x82109D94;
} // Block from 82109D7Ch-82109D94h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82109D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109D94);
		  /* 82109D94h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82109D94h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82109D94h case    0:*/		return 0x82109D98;
		  /* 82109D98h */ case    1:  		/* bc 4, CR6_EQ, -280 */
		/* 82109D98h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82109C80;  }
		/* 82109D98h case    1:*/		return 0x82109D9C;
		  /* 82109D9Ch */ case    2:  		/* cmpwi CR6, R3, 0 */
		/* 82109D9Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82109D9Ch case    2:*/		return 0x82109DA0;
		  /* 82109DA0h */ case    3:  		/* bc 12, CR6_EQ, -308 */
		/* 82109DA0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82109C6C;  }
		/* 82109DA0h case    3:*/		return 0x82109DA4;
	}
	return 0x82109DA4;
} // Block from 82109D94h-82109DA4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82109DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109DA4);
		  /* 82109DA4h */ case    0:  		/* li R31, 0 */
		/* 82109DA4h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82109DA4h case    0:*/		return 0x82109DA8;
		  /* 82109DA8h */ case    1:  		/* b -344 */
		/* 82109DA8h case    1:*/		return 0x82109C50;
		/* 82109DA8h case    1:*/		return 0x82109DAC;
		  /* 82109DACh */ case    2:  		/* nop */
		/* 82109DACh case    2:*/		cpu::op::nop();
		/* 82109DACh case    2:*/		return 0x82109DB0;
	}
	return 0x82109DB0;
} // Block from 82109DA4h-82109DB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82109DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109DB0);
		  /* 82109DB0h */ case    0:  		/* mfspr R12, LR */
		/* 82109DB0h case    0:*/		regs.R12 = regs.LR;
		/* 82109DB0h case    0:*/		return 0x82109DB4;
		  /* 82109DB4h */ case    1:  		/* bl -494472 */
		/* 82109DB4h case    1:*/		regs.LR = 0x82109DB8; return 0x8209122C;
		/* 82109DB4h case    1:*/		return 0x82109DB8;
		  /* 82109DB8h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 82109DB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 82109DB8h case    2:*/		return 0x82109DBC;
		  /* 82109DBCh */ case    3:  		/* lwz R11, <#[R3 + 108]> */
		/* 82109DBCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 82109DBCh case    3:*/		return 0x82109DC0;
		  /* 82109DC0h */ case    4:  		/* mr R29, R3 */
		/* 82109DC0h case    4:*/		regs.R29 = regs.R3;
		/* 82109DC0h case    4:*/		return 0x82109DC4;
		  /* 82109DC4h */ case    5:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 82109DC4h case    5:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 82109DC4h case    5:*/		return 0x82109DC8;
		  /* 82109DC8h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 82109DC8h case    6:*/		if ( regs.CR[0].eq ) { return 0x82109DD4;  }
		/* 82109DC8h case    6:*/		return 0x82109DCC;
		  /* 82109DCCh */ case    7:  		/* li R3, 1 */
		/* 82109DCCh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82109DCCh case    7:*/		return 0x82109DD0;
		  /* 82109DD0h */ case    8:  		/* b 984 */
		/* 82109DD0h case    8:*/		return 0x8210A1A8;
		/* 82109DD0h case    8:*/		return 0x82109DD4;
	}
	return 0x82109DD4;
} // Block from 82109DB0h-82109DD4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82109DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109DD4);
		  /* 82109DD4h */ case    0:  		/* li R20, 0 */
		/* 82109DD4h case    0:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 82109DD4h case    0:*/		return 0x82109DD8;
		  /* 82109DD8h */ case    1:  		/* mr R3, R29 */
		/* 82109DD8h case    1:*/		regs.R3 = regs.R29;
		/* 82109DD8h case    1:*/		return 0x82109DDC;
		  /* 82109DDCh */ case    2:  		/* mr R19, R20 */
		/* 82109DDCh case    2:*/		regs.R19 = regs.R20;
		/* 82109DDCh case    2:*/		return 0x82109DE0;
		  /* 82109DE0h */ case    3:  		/* bl -16968 */
		/* 82109DE0h case    3:*/		regs.LR = 0x82109DE4; return 0x82105B98;
		/* 82109DE0h case    3:*/		return 0x82109DE4;
		  /* 82109DE4h */ case    4:  		/* lwz R18, <#[R29 + 12]> */
		/* 82109DE4h case    4:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R29 + 0x0000000C) );
		/* 82109DE4h case    4:*/		return 0x82109DE8;
		  /* 82109DE8h */ case    5:  		/* cmplwi CR6, R18, 0 */
		/* 82109DE8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82109DE8h case    5:*/		return 0x82109DEC;
		  /* 82109DECh */ case    6:  		/* bc 12, CR6_EQ, -32 */
		/* 82109DECh case    6:*/		if ( regs.CR[6].eq ) { return 0x82109DCC;  }
		/* 82109DECh case    6:*/		return 0x82109DF0;
		  /* 82109DF0h */ case    7:  		/* rlwinm R17, R18, 2, 0, 29 */
		/* 82109DF0h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R17,regs.R18);
		/* 82109DF0h case    7:*/		return 0x82109DF4;
		  /* 82109DF4h */ case    8:  		/* lwz R11, <#[R29 + 24]> */
		/* 82109DF4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 82109DF4h case    8:*/		return 0x82109DF8;
		  /* 82109DF8h */ case    9:  		/* addi R17, R17, -4 */
		/* 82109DF8h case    9:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0xFFFFFFFC);
		/* 82109DF8h case    9:*/		return 0x82109DFC;
		  /* 82109DFCh */ case   10:  		/* lis R10, 4096 */
		/* 82109DFCh case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 82109DFCh case   10:*/		return 0x82109E00;
		  /* 82109E00h */ case   11:  		/* addi R18, R18, -1 */
		/* 82109E00h case   11:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0xFFFFFFFF);
		/* 82109E00h case   11:*/		return 0x82109E04;
		  /* 82109E04h */ case   12:  		/* lwzx R30, <#[R17 + R11]> */
		/* 82109E04h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R17 + regs.R11 + 0x00000000) );
		/* 82109E04h case   12:*/		return 0x82109E08;
		  /* 82109E08h */ case   13:  		/* lwz R5, <#[R30]> */
		/* 82109E08h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000000) );
		/* 82109E08h case   13:*/		return 0x82109E0C;
		  /* 82109E0Ch */ case   14:  		/* rlwinm R11, R5, 0, 0, 11 */
		/* 82109E0Ch case   14:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R5);
		/* 82109E0Ch case   14:*/		return 0x82109E10;
		  /* 82109E10h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 82109E10h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82109E10h case   15:*/		return 0x82109E14;
		  /* 82109E14h */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 82109E14h case   16:*/		if ( regs.CR[6].eq ) { return 0x82109E24;  }
		/* 82109E14h case   16:*/		return 0x82109E18;
		  /* 82109E18h */ case   17:  		/* lis R10, 8304 */
		/* 82109E18h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x2070);
		/* 82109E18h case   17:*/		return 0x82109E1C;
		  /* 82109E1Ch */ case   18:  		/* cmplw CR6, R11, R10 */
		/* 82109E1Ch case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82109E1Ch case   18:*/		return 0x82109E20;
		  /* 82109E20h */ case   19:  		/* bc 4, CR6_EQ, 884 */
		/* 82109E20h case   19:*/		if ( !regs.CR[6].eq ) { return 0x8210A194;  }
		/* 82109E20h case   19:*/		return 0x82109E24;
	}
	return 0x82109E24;
} // Block from 82109DD4h-82109E24h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82109E24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109E24);
		  /* 82109E24h */ case    0:  		/* lwz R6, <#[R30 + 12]> */
		/* 82109E24h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x0000000C) );
		/* 82109E24h case    0:*/		return 0x82109E28;
		  /* 82109E28h */ case    1:  		/* mr R7, R20 */
		/* 82109E28h case    1:*/		regs.R7 = regs.R20;
		/* 82109E28h case    1:*/		return 0x82109E2C;
		  /* 82109E2Ch */ case    2:  		/* cmplwi CR6, R6, 0 */
		/* 82109E2Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82109E2Ch case    2:*/		return 0x82109E30;
		  /* 82109E30h */ case    3:  		/* bc 12, CR6_EQ, 76 */
		/* 82109E30h case    3:*/		if ( regs.CR[6].eq ) { return 0x82109E7C;  }
		/* 82109E30h case    3:*/		return 0x82109E34;
		  /* 82109E34h */ case    4:  		/* lwz R10, <#[R30 + 16]> */
		/* 82109E34h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 82109E34h case    4:*/		return 0x82109E38;
		  /* 82109E38h */ case    5:  		/* mr R11, R20 */
		/* 82109E38h case    5:*/		regs.R11 = regs.R20;
		/* 82109E38h case    5:*/		return 0x82109E3C;
		  /* 82109E3Ch */ case    6:  		/* lwz R9, <#[R29 + 20]> */
		/* 82109E3Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 82109E3Ch case    6:*/		return 0x82109E40;
		  /* 82109E40h */ case    7:  		/* lwz R8, <#[R29 + 16]> */
		/* 82109E40h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000010) );
		/* 82109E40h case    7:*/		return 0x82109E44;
		  /* 82109E44h */ case    8:  		/* lwzx R4, <#[R11 + R10]> */
		/* 82109E44h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82109E44h case    8:*/		return 0x82109E48;
		  /* 82109E48h */ case    9:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 82109E48h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 82109E48h case    9:*/		return 0x82109E4C;
		  /* 82109E4Ch */ case   10:  		/* lwzx R4, <#[R4 + R9]> */
		/* 82109E4Ch case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R9 + 0x00000000) );
		/* 82109E4Ch case   10:*/		return 0x82109E50;
		  /* 82109E50h */ case   11:  		/* lwz R4, <#[R4 + 4]> */
		/* 82109E50h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000004) );
		/* 82109E50h case   11:*/		return 0x82109E54;
		  /* 82109E54h */ case   12:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 82109E54h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 82109E54h case   12:*/		return 0x82109E58;
		  /* 82109E58h */ case   13:  		/* lwzx R4, <#[R4 + R8]> */
		/* 82109E58h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R8 + 0x00000000) );
		/* 82109E58h case   13:*/		return 0x82109E5C;
		  /* 82109E5Ch */ case   14:  		/* lwz R4, <#[R4 + 4]> */
		/* 82109E5Ch case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000004) );
		/* 82109E5Ch case   14:*/		return 0x82109E60;
		  /* 82109E60h */ case   15:  		/* rlwinm. R4, R4, 0, 26, 26 */
		/* 82109E60h case   15:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R4,regs.R4);
		/* 82109E60h case   15:*/		return 0x82109E64;
		  /* 82109E64h */ case   16:  		/* bc 12, CR0_EQ, 24 */
		/* 82109E64h case   16:*/		if ( regs.CR[0].eq ) { return 0x82109E7C;  }
		/* 82109E64h case   16:*/		return 0x82109E68;
		  /* 82109E68h */ case   17:  		/* lwz R4, <#[R30 + 12]> */
		/* 82109E68h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 82109E68h case   17:*/		return 0x82109E6C;
		  /* 82109E6Ch */ case   18:  		/* addi R7, R7, 1 */
		/* 82109E6Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82109E6Ch case   18:*/		return 0x82109E70;
		  /* 82109E70h */ case   19:  		/* addi R11, R11, 4 */
		/* 82109E70h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82109E70h case   19:*/		return 0x82109E74;
		  /* 82109E74h */ case   20:  		/* cmplw CR6, R7, R4 */
		/* 82109E74h case   20:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 82109E74h case   20:*/		return 0x82109E78;
		  /* 82109E78h */ case   21:  		/* bc 12, CR6_LT, -52 */
		/* 82109E78h case   21:*/		if ( regs.CR[6].lt ) { return 0x82109E44;  }
		/* 82109E78h case   21:*/		return 0x82109E7C;
	}
	return 0x82109E7C;
} // Block from 82109E24h-82109E7Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 82109E7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109E7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109E7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109E7C);
		  /* 82109E7Ch */ case    0:  		/* cmplw CR6, R7, R6 */
		/* 82109E7Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 82109E7Ch case    0:*/		return 0x82109E80;
		  /* 82109E80h */ case    1:  		/* bc 12, CR6_LT, 788 */
		/* 82109E80h case    1:*/		if ( regs.CR[6].lt ) { return 0x8210A194;  }
		/* 82109E80h case    1:*/		return 0x82109E84;
		  /* 82109E84h */ case    2:  		/* lwz R6, <#[R30 + 4]> */
		/* 82109E84h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000004) );
		/* 82109E84h case    2:*/		return 0x82109E88;
		  /* 82109E88h */ case    3:  		/* mr R7, R20 */
		/* 82109E88h case    3:*/		regs.R7 = regs.R20;
		/* 82109E88h case    3:*/		return 0x82109E8C;
		  /* 82109E8Ch */ case    4:  		/* cmplwi CR6, R6, 0 */
		/* 82109E8Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82109E8Ch case    4:*/		return 0x82109E90;
		  /* 82109E90h */ case    5:  		/* bc 12, CR6_EQ, 76 */
		/* 82109E90h case    5:*/		if ( regs.CR[6].eq ) { return 0x82109EDC;  }
		/* 82109E90h case    5:*/		return 0x82109E94;
		  /* 82109E94h */ case    6:  		/* lwz R10, <#[R30 + 8]> */
		/* 82109E94h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82109E94h case    6:*/		return 0x82109E98;
		  /* 82109E98h */ case    7:  		/* mr R11, R20 */
		/* 82109E98h case    7:*/		regs.R11 = regs.R20;
		/* 82109E98h case    7:*/		return 0x82109E9C;
		  /* 82109E9Ch */ case    8:  		/* lwz R9, <#[R29 + 20]> */
		/* 82109E9Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 82109E9Ch case    8:*/		return 0x82109EA0;
		  /* 82109EA0h */ case    9:  		/* lwz R8, <#[R29 + 16]> */
		/* 82109EA0h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000010) );
		/* 82109EA0h case    9:*/		return 0x82109EA4;
		  /* 82109EA4h */ case   10:  		/* lwzx R4, <#[R11 + R10]> */
		/* 82109EA4h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82109EA4h case   10:*/		return 0x82109EA8;
		  /* 82109EA8h */ case   11:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 82109EA8h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 82109EA8h case   11:*/		return 0x82109EAC;
		  /* 82109EACh */ case   12:  		/* lwzx R4, <#[R4 + R9]> */
		/* 82109EACh case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R9 + 0x00000000) );
		/* 82109EACh case   12:*/		return 0x82109EB0;
		  /* 82109EB0h */ case   13:  		/* lwz R4, <#[R4 + 4]> */
		/* 82109EB0h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000004) );
		/* 82109EB0h case   13:*/		return 0x82109EB4;
		  /* 82109EB4h */ case   14:  		/* rlwinm R4, R4, 2, 0, 29 */
		/* 82109EB4h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R4);
		/* 82109EB4h case   14:*/		return 0x82109EB8;
		  /* 82109EB8h */ case   15:  		/* lwzx R4, <#[R4 + R8]> */
		/* 82109EB8h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + regs.R8 + 0x00000000) );
		/* 82109EB8h case   15:*/		return 0x82109EBC;
		  /* 82109EBCh */ case   16:  		/* lwz R4, <#[R4 + 4]> */
		/* 82109EBCh case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000004) );
		/* 82109EBCh case   16:*/		return 0x82109EC0;
		  /* 82109EC0h */ case   17:  		/* rlwinm. R4, R4, 0, 30, 30 */
		/* 82109EC0h case   17:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R4,regs.R4);
		/* 82109EC0h case   17:*/		return 0x82109EC4;
		  /* 82109EC4h */ case   18:  		/* bc 12, CR0_EQ, 24 */
		/* 82109EC4h case   18:*/		if ( regs.CR[0].eq ) { return 0x82109EDC;  }
		/* 82109EC4h case   18:*/		return 0x82109EC8;
		  /* 82109EC8h */ case   19:  		/* lwz R4, <#[R30 + 4]> */
		/* 82109EC8h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000004) );
		/* 82109EC8h case   19:*/		return 0x82109ECC;
		  /* 82109ECCh */ case   20:  		/* addi R7, R7, 1 */
		/* 82109ECCh case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82109ECCh case   20:*/		return 0x82109ED0;
		  /* 82109ED0h */ case   21:  		/* addi R11, R11, 4 */
		/* 82109ED0h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82109ED0h case   21:*/		return 0x82109ED4;
		  /* 82109ED4h */ case   22:  		/* cmplw CR6, R7, R4 */
		/* 82109ED4h case   22:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R4);
		/* 82109ED4h case   22:*/		return 0x82109ED8;
		  /* 82109ED8h */ case   23:  		/* bc 12, CR6_LT, -52 */
		/* 82109ED8h case   23:*/		if ( regs.CR[6].lt ) { return 0x82109EA4;  }
		/* 82109ED8h case   23:*/		return 0x82109EDC;
	}
	return 0x82109EDC;
} // Block from 82109E7Ch-82109EDCh (24 instructions)

//////////////////////////////////////////////////////
// Block at 82109EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109EDC);
		  /* 82109EDCh */ case    0:  		/* cmplw CR6, R7, R6 */
		/* 82109EDCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 82109EDCh case    0:*/		return 0x82109EE0;
		  /* 82109EE0h */ case    1:  		/* bc 12, CR6_LT, 692 */
		/* 82109EE0h case    1:*/		if ( regs.CR[6].lt ) { return 0x8210A194;  }
		/* 82109EE0h case    1:*/		return 0x82109EE4;
		  /* 82109EE4h */ case    2:  		/* rlwinm R22, R5, 0, 12, 31 */
		/* 82109EE4h case    2:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R22,regs.R5);
		/* 82109EE4h case    2:*/		return 0x82109EE8;
		  /* 82109EE8h */ case    3:  		/* mr R24, R20 */
		/* 82109EE8h case    3:*/		regs.R24 = regs.R20;
		/* 82109EE8h case    3:*/		return 0x82109EEC;
		  /* 82109EECh */ case    4:  		/* divwu. R21, R6, R22 */
		/* 82109EECh case    4:*/		cpu::op::divwu<1>(regs,&regs.R21,regs.R6,regs.R22);
		/* 82109EECh case    4:*/		return 0x82109EF0;
		  /* 82109EF0h */ case    5:  		/* twi 6, R22, 0 */
		/* 82109EF0h case    5:*/		cpu::op::tw<6>(regs, 0x82109EF0, regs.R22, 0x00000000);
		/* 82109EF0h case    5:*/		return 0x82109EF4;
		  /* 82109EF4h */ case    6:  		/* bc 12, CR0_EQ, 412 */
		/* 82109EF4h case    6:*/		if ( regs.CR[0].eq ) { return 0x8210A090;  }
		/* 82109EF4h case    6:*/		return 0x82109EF8;
		  /* 82109EF8h */ case    7:  		/* mr R25, R20 */
		/* 82109EF8h case    7:*/		regs.R25 = regs.R20;
		/* 82109EF8h case    7:*/		return 0x82109EFC;
		  /* 82109EFCh */ case    8:  		/* rlwinm R23, R22, 2, 0, 29 */
		/* 82109EFCh case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R23,regs.R22);
		/* 82109EFCh case    8:*/		return 0x82109F00;
		  /* 82109F00h */ case    9:  		/* mr R26, R20 */
		/* 82109F00h case    9:*/		regs.R26 = regs.R20;
		/* 82109F00h case    9:*/		return 0x82109F04;
		  /* 82109F04h */ case   10:  		/* cmplwi CR6, R22, 0 */
		/* 82109F04h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 82109F04h case   10:*/		return 0x82109F08;
		  /* 82109F08h */ case   11:  		/* bc 12, CR6_EQ, 368 */
		/* 82109F08h case   11:*/		if ( regs.CR[6].eq ) { return 0x8210A078;  }
		/* 82109F08h case   11:*/		return 0x82109F0C;
		  /* 82109F0Ch */ case   12:  		/* mr R27, R20 */
		/* 82109F0Ch case   12:*/		regs.R27 = regs.R20;
		/* 82109F0Ch case   12:*/		return 0x82109F10;
		  /* 82109F10h */ case   13:  		/* mr R28, R25 */
		/* 82109F10h case   13:*/		regs.R28 = regs.R25;
		/* 82109F10h case   13:*/		return 0x82109F14;
		  /* 82109F14h */ case   14:  		/* lwz R11, <#[R30 + 8]> */
		/* 82109F14h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82109F14h case   14:*/		return 0x82109F18;
		  /* 82109F18h */ case   15:  		/* lwz R10, <#[R29 + 20]> */
		/* 82109F18h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 82109F18h case   15:*/		return 0x82109F1C;
		  /* 82109F1Ch */ case   16:  		/* lwz R9, <#[R29 + 24]> */
		/* 82109F1Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000018) );
		/* 82109F1Ch case   16:*/		return 0x82109F20;
		  /* 82109F20h */ case   17:  		/* lwzx R11, <#[R28 + R11]> */
		/* 82109F20h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 82109F20h case   17:*/		return 0x82109F24;
		  /* 82109F24h */ case   18:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109F24h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109F24h case   18:*/		return 0x82109F28;
		  /* 82109F28h */ case   19:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82109F28h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82109F28h case   19:*/		return 0x82109F2C;
		  /* 82109F2Ch */ case   20:  		/* lwz R11, <#[R11 + 72]> */
		/* 82109F2Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82109F2Ch case   20:*/		return 0x82109F30;
		  /* 82109F30h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109F30h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109F30h case   21:*/		return 0x82109F34;
		  /* 82109F34h */ case   22:  		/* lwzx R31, <#[R11 + R9]> */
		/* 82109F34h case   22:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82109F34h case   22:*/		return 0x82109F38;
		  /* 82109F38h */ case   23:  		/* mr R3, R31 */
		/* 82109F38h case   23:*/		regs.R3 = regs.R31;
		/* 82109F38h case   23:*/		return 0x82109F3C;
		  /* 82109F3Ch */ case   24:  		/* bl -57292 */
		/* 82109F3Ch case   24:*/		regs.LR = 0x82109F40; return 0x820FBF70;
		/* 82109F3Ch case   24:*/		return 0x82109F40;
		  /* 82109F40h */ case   25:  		/* lwz R11, <#[R31]> */
		/* 82109F40h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82109F40h case   25:*/		return 0x82109F44;
		  /* 82109F44h */ case   26:  		/* lis R10, 24640 */
		/* 82109F44h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0x6040);
		/* 82109F44h case   26:*/		return 0x82109F48;
		  /* 82109F48h */ case   27:  		/* rlwinm R11, R11, 0, 0, 11 */
		/* 82109F48h case   27:*/		cpu::op::rlwinm<0,0,0,11>(regs,&regs.R11,regs.R11);
		/* 82109F48h case   27:*/		return 0x82109F4C;
		  /* 82109F4Ch */ case   28:  		/* cmplw CR6, R11, R10 */
		/* 82109F4Ch case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82109F4Ch case   28:*/		return 0x82109F50;
		  /* 82109F50h */ case   29:  		/* bc 12, CR6_EQ, 32 */
		/* 82109F50h case   29:*/		if ( regs.CR[6].eq ) { return 0x82109F70;  }
		/* 82109F50h case   29:*/		return 0x82109F54;
		  /* 82109F54h */ case   30:  		/* lis R10, 24720 */
		/* 82109F54h case   30:*/		cpu::op::lis<0>(regs,&regs.R10,0x6090);
		/* 82109F54h case   30:*/		return 0x82109F58;
		  /* 82109F58h */ case   31:  		/* cmplw CR6, R11, R10 */
		/* 82109F58h case   31:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82109F58h case   31:*/		return 0x82109F5C;
		  /* 82109F5Ch */ case   32:  		/* bc 12, CR6_EQ, 20 */
		/* 82109F5Ch case   32:*/		if ( regs.CR[6].eq ) { return 0x82109F70;  }
		/* 82109F5Ch case   32:*/		return 0x82109F60;
		  /* 82109F60h */ case   33:  		/* lis R10, 24800 */
		/* 82109F60h case   33:*/		cpu::op::lis<0>(regs,&regs.R10,0x60E0);
		/* 82109F60h case   33:*/		return 0x82109F64;
		  /* 82109F64h */ case   34:  		/* mr R7, R20 */
		/* 82109F64h case   34:*/		regs.R7 = regs.R20;
		/* 82109F64h case   34:*/		return 0x82109F68;
		  /* 82109F68h */ case   35:  		/* cmplw CR6, R11, R10 */
		/* 82109F68h case   35:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82109F68h case   35:*/		return 0x82109F6C;
		  /* 82109F6Ch */ case   36:  		/* bc 4, CR6_EQ, 8 */
		/* 82109F6Ch case   36:*/		if ( !regs.CR[6].eq ) { return 0x82109F74;  }
		/* 82109F6Ch case   36:*/		return 0x82109F70;
	}
	return 0x82109F70;
} // Block from 82109EDCh-82109F70h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82109F70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109F70);
		  /* 82109F70h */ case    0:  		/* li R7, 1 */
		/* 82109F70h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82109F70h case    0:*/		return 0x82109F74;
	}
	return 0x82109F74;
} // Block from 82109F70h-82109F74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82109F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109F74);
		  /* 82109F74h */ case    0:  		/* lwz R5, <#[R30 + 16]> */
		/* 82109F74h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000010) );
		/* 82109F74h case    0:*/		return 0x82109F78;
		  /* 82109F78h */ case    1:  		/* lwz R11, <#[R31 + 16]> */
		/* 82109F78h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82109F78h case    1:*/		return 0x82109F7C;
		  /* 82109F7Ch */ case    2:  		/* lwz R10, <#[R29 + 20]> */
		/* 82109F7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 82109F7Ch case    2:*/		return 0x82109F80;
		  /* 82109F80h */ case    3:  		/* lwz R9, <#[R5]> */
		/* 82109F80h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 82109F80h case    3:*/		return 0x82109F84;
		  /* 82109F84h */ case    4:  		/* lwz R11, <#[R11]> */
		/* 82109F84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82109F84h case    4:*/		return 0x82109F88;
		  /* 82109F88h */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82109F88h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82109F88h case    5:*/		return 0x82109F8C;
		  /* 82109F8Ch */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109F8Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109F8Ch case    6:*/		return 0x82109F90;
		  /* 82109F90h */ case    7:  		/* lwzx R8, <#[R9 + R10]> */
		/* 82109F90h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82109F90h case    7:*/		return 0x82109F94;
		  /* 82109F94h */ case    8:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82109F94h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82109F94h case    8:*/		return 0x82109F98;
		  /* 82109F98h */ case    9:  		/* lwz R9, <#[R8 + 20]> */
		/* 82109F98h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000014) );
		/* 82109F98h case    9:*/		return 0x82109F9C;
		  /* 82109F9Ch */ case   10:  		/* lwz R11, <#[R10 + 20]> */
		/* 82109F9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 82109F9Ch case   10:*/		return 0x82109FA0;
		  /* 82109FA0h */ case   11:  		/* lwz R8, <#[R8 + 24]> */
		/* 82109FA0h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000018) );
		/* 82109FA0h case   11:*/		return 0x82109FA4;
		  /* 82109FA4h */ case   12:  		/* lwz R10, <#[R10 + 24]> */
		/* 82109FA4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 82109FA4h case   12:*/		return 0x82109FA8;
		  /* 82109FA8h */ case   13:  		/* cmplw CR6, R11, R9 */
		/* 82109FA8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82109FA8h case   13:*/		return 0x82109FAC;
		  /* 82109FACh */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 82109FACh case   14:*/		if ( !regs.CR[6].eq ) { return 0x82109FB8;  }
		/* 82109FACh case   14:*/		return 0x82109FB0;
		  /* 82109FB0h */ case   15:  		/* cmpw CR6, R10, R8 */
		/* 82109FB0h case   15:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R8);
		/* 82109FB0h case   15:*/		return 0x82109FB4;
		  /* 82109FB4h */ case   16:  		/* bc 12, CR6_EQ, 40 */
		/* 82109FB4h case   16:*/		if ( regs.CR[6].eq ) { return 0x82109FDC;  }
		/* 82109FB4h case   16:*/		return 0x82109FB8;
	}
	return 0x82109FB8;
} // Block from 82109F74h-82109FB8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82109FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109FB8);
		  /* 82109FB8h */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 82109FB8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82109FB8h case    0:*/		return 0x82109FBC;
		  /* 82109FBCh */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82109FBCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82109FD8;  }
		/* 82109FBCh case    1:*/		return 0x82109FC0;
		  /* 82109FC0h */ case    2:  		/* lwz R10, <#[R29 + 20]> */
		/* 82109FC0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 82109FC0h case    2:*/		return 0x82109FC4;
		  /* 82109FC4h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82109FC4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82109FC4h case    3:*/		return 0x82109FC8;
		  /* 82109FC8h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82109FC8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82109FC8h case    4:*/		return 0x82109FCC;
		  /* 82109FCCh */ case    5:  		/* lwz R10, <#[R11 + 24]> */
		/* 82109FCCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 82109FCCh case    5:*/		return 0x82109FD0;
		  /* 82109FD0h */ case    6:  		/* lwz R11, <#[R11 + 20]> */
		/* 82109FD0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 82109FD0h case    6:*/		return 0x82109FD4;
		  /* 82109FD4h */ case    7:  		/* b -44 */
		/* 82109FD4h case    7:*/		return 0x82109FA8;
		/* 82109FD4h case    7:*/		return 0x82109FD8;
	}
	return 0x82109FD8;
} // Block from 82109FB8h-82109FD8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82109FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109FD8);
		  /* 82109FD8h */ case    0:  		/* li R7, 1 */
		/* 82109FD8h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82109FD8h case    0:*/		return 0x82109FDC;
	}
	return 0x82109FDC;
} // Block from 82109FD8h-82109FDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82109FDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82109FDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82109FDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82109FDC);
		  /* 82109FDCh */ case    0:  		/* cmpwi CR6, R7, 0 */
		/* 82109FDCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 82109FDCh case    0:*/		return 0x82109FE0;
		  /* 82109FE0h */ case    1:  		/* bc 4, CR6_EQ, 144 */
		/* 82109FE0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210A070;  }
		/* 82109FE0h case    1:*/		return 0x82109FE4;
		  /* 82109FE4h */ case    2:  		/* lwz R6, <#[R31 + 12]> */
		/* 82109FE4h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000000C) );
		/* 82109FE4h case    2:*/		return 0x82109FE8;
		  /* 82109FE8h */ case    3:  		/* mr R8, R20 */
		/* 82109FE8h case    3:*/		regs.R8 = regs.R20;
		/* 82109FE8h case    3:*/		return 0x82109FEC;
		  /* 82109FECh */ case    4:  		/* cmplwi CR6, R6, 0 */
		/* 82109FECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82109FECh case    4:*/		return 0x82109FF0;
		  /* 82109FF0h */ case    5:  		/* bc 12, CR6_EQ, 100 */
		/* 82109FF0h case    5:*/		if ( regs.CR[6].eq ) { return 0x8210A054;  }
		/* 82109FF0h case    5:*/		return 0x82109FF4;
		  /* 82109FF4h */ case    6:  		/* lwz R7, <#[R31 + 16]> */
		/* 82109FF4h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 82109FF4h case    6:*/		return 0x82109FF8;
		  /* 82109FF8h */ case    7:  		/* mr R10, R20 */
		/* 82109FF8h case    7:*/		regs.R10 = regs.R20;
		/* 82109FF8h case    7:*/		return 0x82109FFC;
		  /* 82109FFCh */ case    8:  		/* lwz R9, <#[R29 + 20]> */
		/* 82109FFCh case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000014) );
		/* 82109FFCh case    8:*/		return 0x8210A000;
		  /* 8210A000h */ case    9:  		/* lwzx R11, <#[R10 + R7]> */
		/* 8210A000h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8210A000h case    9:*/		return 0x8210A004;
		  /* 8210A004h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210A004h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210A004h case   10:*/		return 0x8210A008;
		  /* 8210A008h */ case   11:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210A008h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210A008h case   11:*/		return 0x8210A00C;
		  /* 8210A00Ch */ case   12:  		/* lwz R4, <#[R11 + 92]> */
		/* 8210A00Ch case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000005C) );
		/* 8210A00Ch case   12:*/		return 0x8210A010;
		  /* 8210A010h */ case   13:  		/* cmplwi CR6, R4, 1 */
		/* 8210A010h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 8210A010h case   13:*/		return 0x8210A014;
		  /* 8210A014h */ case   14:  		/* bc 12, CR6_GT, 64 */
		/* 8210A014h case   14:*/		if ( regs.CR[6].gt ) { return 0x8210A054;  }
		/* 8210A014h case   14:*/		return 0x8210A018;
		  /* 8210A018h */ case   15:  		/* lwz R11, <#[R11 + 84]> */
		/* 8210A018h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000054) );
		/* 8210A018h case   15:*/		return 0x8210A01C;
		  /* 8210A01Ch */ case   16:  		/* cmplw CR6, R11, R18 */
		/* 8210A01Ch case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R18);
		/* 8210A01Ch case   16:*/		return 0x8210A020;
		  /* 8210A020h */ case   17:  		/* bc 4, CR6_EQ, 52 */
		/* 8210A020h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8210A054;  }
		/* 8210A020h case   17:*/		return 0x8210A024;
		  /* 8210A024h */ case   18:  		/* cmpwi CR6, R3, 0 */
		/* 8210A024h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8210A024h case   18:*/		return 0x8210A028;
		  /* 8210A028h */ case   19:  		/* bc 12, CR6_EQ, 28 */
		/* 8210A028h case   19:*/		if ( regs.CR[6].eq ) { return 0x8210A044;  }
		/* 8210A028h case   19:*/		return 0x8210A02C;
		  /* 8210A02Ch */ case   20:  		/* lwzx R11, <#[R27 + R5]> */
		/* 8210A02Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + regs.R5 + 0x00000000) );
		/* 8210A02Ch case   20:*/		return 0x8210A030;
		  /* 8210A030h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210A030h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210A030h case   21:*/		return 0x8210A034;
		  /* 8210A034h */ case   22:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210A034h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210A034h case   22:*/		return 0x8210A038;
		  /* 8210A038h */ case   23:  		/* lwz R11, <#[R11 + 16]> */
		/* 8210A038h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8210A038h case   23:*/		return 0x8210A03C;
		  /* 8210A03Ch */ case   24:  		/* cmplw CR6, R8, R11 */
		/* 8210A03Ch case   24:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210A03Ch case   24:*/		return 0x8210A040;
	}
	return 0x8210A040;
} // Block from 82109FDCh-8210A040h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8210A040h
// Function '?PropagatePredicates@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A040);
		  /* 8210A040h */ case    0:  		/* bc 4, CR6_EQ, 20 */
		/* 8210A040h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8210A054;  }
		/* 8210A040h case    0:*/		return 0x8210A044;
	}
	return 0x8210A044;
} // Block from 8210A040h-8210A044h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210A044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A044);
		  /* 8210A044h */ case    0:  		/* addi R8, R8, 1 */
		/* 8210A044h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210A044h case    0:*/		return 0x8210A048;
		  /* 8210A048h */ case    1:  		/* addi R10, R10, 4 */
		/* 8210A048h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210A048h case    1:*/		return 0x8210A04C;
		  /* 8210A04Ch */ case    2:  		/* cmplw CR6, R8, R6 */
		/* 8210A04Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R6);
		/* 8210A04Ch case    2:*/		return 0x8210A050;
		  /* 8210A050h */ case    3:  		/* bc 12, CR6_LT, -80 */
		/* 8210A050h case    3:*/		if ( regs.CR[6].lt ) { return 0x8210A000;  }
		/* 8210A050h case    3:*/		return 0x8210A054;
	}
	return 0x8210A054;
} // Block from 8210A044h-8210A054h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210A054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A054);
		  /* 8210A054h */ case    0:  		/* cmplw CR6, R8, R6 */
		/* 8210A054h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R6);
		/* 8210A054h case    0:*/		return 0x8210A058;
		  /* 8210A058h */ case    1:  		/* bc 12, CR6_LT, 24 */
		/* 8210A058h case    1:*/		if ( regs.CR[6].lt ) { return 0x8210A070;  }
		/* 8210A058h case    1:*/		return 0x8210A05C;
		  /* 8210A05Ch */ case    2:  		/* addi R26, R26, 1 */
		/* 8210A05Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8210A05Ch case    2:*/		return 0x8210A060;
		  /* 8210A060h */ case    3:  		/* addi R27, R27, 4 */
		/* 8210A060h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8210A060h case    3:*/		return 0x8210A064;
		  /* 8210A064h */ case    4:  		/* addi R28, R28, 4 */
		/* 8210A064h case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8210A064h case    4:*/		return 0x8210A068;
		  /* 8210A068h */ case    5:  		/* cmplw CR6, R26, R22 */
		/* 8210A068h case    5:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R22);
		/* 8210A068h case    5:*/		return 0x8210A06C;
		  /* 8210A06Ch */ case    6:  		/* bc 12, CR6_LT, -344 */
		/* 8210A06Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x82109F14;  }
		/* 8210A06Ch case    6:*/		return 0x8210A070;
	}
	return 0x8210A070;
} // Block from 8210A054h-8210A070h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210A070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A070);
		  /* 8210A070h */ case    0:  		/* cmplw CR6, R26, R22 */
		/* 8210A070h case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R22);
		/* 8210A070h case    0:*/		return 0x8210A074;
		  /* 8210A074h */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 8210A074h case    1:*/		if ( regs.CR[6].lt ) { return 0x8210A088;  }
		/* 8210A074h case    1:*/		return 0x8210A078;
	}
	return 0x8210A078;
} // Block from 8210A070h-8210A078h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210A078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A078);
		  /* 8210A078h */ case    0:  		/* addi R24, R24, 1 */
		/* 8210A078h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 8210A078h case    0:*/		return 0x8210A07C;
		  /* 8210A07Ch */ case    1:  		/* add R25, R23, R25 */
		/* 8210A07Ch case    1:*/		cpu::op::add<0>(regs,&regs.R25,regs.R23,regs.R25);
		/* 8210A07Ch case    1:*/		return 0x8210A080;
		  /* 8210A080h */ case    2:  		/* cmplw CR6, R24, R21 */
		/* 8210A080h case    2:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R21);
		/* 8210A080h case    2:*/		return 0x8210A084;
		  /* 8210A084h */ case    3:  		/* bc 12, CR6_LT, -388 */
		/* 8210A084h case    3:*/		if ( regs.CR[6].lt ) { return 0x82109F00;  }
		/* 8210A084h case    3:*/		return 0x8210A088;
	}
	return 0x8210A088;
} // Block from 8210A078h-8210A088h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210A088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A088);
		  /* 8210A088h */ case    0:  		/* cmplw CR6, R24, R21 */
		/* 8210A088h case    0:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R21);
		/* 8210A088h case    0:*/		return 0x8210A08C;
		  /* 8210A08Ch */ case    1:  		/* bc 12, CR6_LT, 264 */
		/* 8210A08Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x8210A194;  }
		/* 8210A08Ch case    1:*/		return 0x8210A090;
	}
	return 0x8210A090;
} // Block from 8210A088h-8210A090h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210A090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A090);
		  /* 8210A090h */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 8210A090h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210A090h case    0:*/		return 0x8210A094;
		  /* 8210A094h */ case    1:  		/* mr R3, R20 */
		/* 8210A094h case    1:*/		regs.R3 = regs.R20;
		/* 8210A094h case    1:*/		return 0x8210A098;
		  /* 8210A098h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210A098h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A098h case    2:*/		return 0x8210A09C;
		  /* 8210A09Ch */ case    3:  		/* bc 4, CR6_GT, 232 */
		/* 8210A09Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210A184;  }
		/* 8210A09Ch case    3:*/		return 0x8210A0A0;
		  /* 8210A0A0h */ case    4:  		/* mr R5, R20 */
		/* 8210A0A0h case    4:*/		regs.R5 = regs.R20;
		/* 8210A0A0h case    4:*/		return 0x8210A0A4;
		  /* 8210A0A4h */ case    5:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210A0A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210A0A4h case    5:*/		return 0x8210A0A8;
		  /* 8210A0A8h */ case    6:  		/* cmplwi CR6, R21, 0 */
		/* 8210A0A8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8210A0A8h case    6:*/		return 0x8210A0AC;
		  /* 8210A0ACh */ case    7:  		/* lwz R10, <#[R29 + 20]> */
		/* 8210A0ACh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000014) );
		/* 8210A0ACh case    7:*/		return 0x8210A0B0;
		  /* 8210A0B0h */ case    8:  		/* lwzx R11, <#[R11 + R5]> */
		/* 8210A0B0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8210A0B0h case    8:*/		return 0x8210A0B4;
		  /* 8210A0B4h */ case    9:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210A0B4h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210A0B4h case    9:*/		return 0x8210A0B8;
		  /* 8210A0B8h */ case   10:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8210A0B8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210A0B8h case   10:*/		return 0x8210A0BC;
		  /* 8210A0BCh */ case   11:  		/* bc 12, CR6_EQ, 172 */
		/* 8210A0BCh case   11:*/		if ( regs.CR[6].eq ) { return 0x8210A168;  }
		/* 8210A0BCh case   11:*/		return 0x8210A0C0;
		  /* 8210A0C0h */ case   12:  		/* mtspr CTR, R21 */
		/* 8210A0C0h case   12:*/		regs.CTR = regs.R21;
		/* 8210A0C0h case   12:*/		return 0x8210A0C4;
		  /* 8210A0C4h */ case   13:  		/* rlwinm R4, R22, 2, 0, 29 */
		/* 8210A0C4h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R22);
		/* 8210A0C4h case   13:*/		return 0x8210A0C8;
		  /* 8210A0C8h */ case   14:  		/* mr R6, R5 */
		/* 8210A0C8h case   14:*/		regs.R6 = regs.R5;
		/* 8210A0C8h case   14:*/		return 0x8210A0CC;
		  /* 8210A0CCh */ case   15:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210A0CCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210A0CCh case   15:*/		return 0x8210A0D0;
		  /* 8210A0D0h */ case   16:  		/* lwz R8, <#[R29 + 20]> */
		/* 8210A0D0h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000014) );
		/* 8210A0D0h case   16:*/		return 0x8210A0D4;
		  /* 8210A0D4h */ case   17:  		/* lwz R9, <#[R10]> */
		/* 8210A0D4h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8210A0D4h case   17:*/		return 0x8210A0D8;
		  /* 8210A0D8h */ case   18:  		/* rlwinm R9, R9, 0, 4, 6 */
		/* 8210A0D8h case   18:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R9,regs.R9);
		/* 8210A0D8h case   18:*/		return 0x8210A0DC;
		  /* 8210A0DCh */ case   19:  		/* lwzx R11, <#[R11 + R6]> */
		/* 8210A0DCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 8210A0DCh case   19:*/		return 0x8210A0E0;
		  /* 8210A0E0h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210A0E0h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210A0E0h case   20:*/		return 0x8210A0E4;
		  /* 8210A0E4h */ case   21:  		/* lwzx R11, <#[R11 + R8]> */
		/* 8210A0E4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210A0E4h case   21:*/		return 0x8210A0E8;
		  /* 8210A0E8h */ case   22:  		/* lwz R7, <#[R11]> */
		/* 8210A0E8h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A0E8h case   22:*/		return 0x8210A0EC;
		  /* 8210A0ECh */ case   23:  		/* rlwinm R8, R7, 0, 4, 6 */
		/* 8210A0ECh case   23:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R8,regs.R7);
		/* 8210A0ECh case   23:*/		return 0x8210A0F0;
		  /* 8210A0F0h */ case   24:  		/* rlwinm R7, R7, 0, 7, 3 */
		/* 8210A0F0h case   24:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R7,regs.R7);
		/* 8210A0F0h case   24:*/		return 0x8210A0F4;
		  /* 8210A0F4h */ case   25:  		/* cmplw CR6, R9, R8 */
		/* 8210A0F4h case   25:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8210A0F4h case   25:*/		return 0x8210A0F8;
		  /* 8210A0F8h */ case   26:  		/* stw R7, <#[R11]> */
		/* 8210A0F8h case   26:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A0F8h case   26:*/		return 0x8210A0FC;
		  /* 8210A0FCh */ case   27:  		/* bc 12, CR6_GT, 8 */
		/* 8210A0FCh case   27:*/		if ( regs.CR[6].gt ) { return 0x8210A104;  }
		/* 8210A0FCh case   27:*/		return 0x8210A100;
		  /* 8210A100h */ case   28:  		/* mr R9, R8 */
		/* 8210A100h case   28:*/		regs.R9 = regs.R8;
		/* 8210A100h case   28:*/		return 0x8210A104;
	}
	return 0x8210A104;
} // Block from 8210A090h-8210A104h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8210A104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A104);
		  /* 8210A104h */ case    0:  		/* or R9, R7, R9 */
		/* 8210A104h case    0:*/		cpu::op::or<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8210A104h case    0:*/		return 0x8210A108;
		  /* 8210A108h */ case    1:  		/* lwz R8, <#[R11 + 96]> */
		/* 8210A108h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000060) );
		/* 8210A108h case    1:*/		return 0x8210A10C;
		  /* 8210A10Ch */ case    2:  		/* stw R9, <#[R11]> */
		/* 8210A10Ch case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A10Ch case    2:*/		return 0x8210A110;
		  /* 8210A110h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 8210A110h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8210A110h case    3:*/		return 0x8210A114;
		  /* 8210A114h */ case    4:  		/* lwz R9, <#[R10 + 4]> */
		/* 8210A114h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8210A114h case    4:*/		return 0x8210A118;
		  /* 8210A118h */ case    5:  		/* stw R9, <#[R11 + 4]> */
		/* 8210A118h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8210A118h case    5:*/		return 0x8210A11C;
		  /* 8210A11Ch */ case    6:  		/* lwz R9, <#[R10 + 8]> */
		/* 8210A11Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 8210A11Ch case    6:*/		return 0x8210A120;
		  /* 8210A120h */ case    7:  		/* stw R9, <#[R11 + 8]> */
		/* 8210A120h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8210A120h case    7:*/		return 0x8210A124;
		  /* 8210A124h */ case    8:  		/* lwz R9, <#[R10 + 12]> */
		/* 8210A124h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210A124h case    8:*/		return 0x8210A128;
		  /* 8210A128h */ case    9:  		/* stw R9, <#[R11 + 12]> */
		/* 8210A128h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210A128h case    9:*/		return 0x8210A12C;
		  /* 8210A12Ch */ case   10:  		/* lwz R9, <#[R10 + 16]> */
		/* 8210A12Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 8210A12Ch case   10:*/		return 0x8210A130;
		  /* 8210A130h */ case   11:  		/* stw R9, <#[R11 + 16]> */
		/* 8210A130h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 8210A130h case   11:*/		return 0x8210A134;
		  /* 8210A134h */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 8210A134h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8210A148;  }
		/* 8210A134h case   12:*/		return 0x8210A138;
		  /* 8210A138h */ case   13:  		/* lwz R9, <#[R10 + 96]> */
		/* 8210A138h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000060) );
		/* 8210A138h case   13:*/		return 0x8210A13C;
		  /* 8210A13Ch */ case   14:  		/* stw R9, <#[R11 + 96]> */
		/* 8210A13Ch case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000060) );
		/* 8210A13Ch case   14:*/		return 0x8210A140;
		  /* 8210A140h */ case   15:  		/* lwz R9, <#[R10 + 100]> */
		/* 8210A140h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000064) );
		/* 8210A140h case   15:*/		return 0x8210A144;
		  /* 8210A144h */ case   16:  		/* stw R9, <#[R11 + 100]> */
		/* 8210A144h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000064) );
		/* 8210A144h case   16:*/		return 0x8210A148;
	}
	return 0x8210A148;
} // Block from 8210A104h-8210A148h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8210A148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A148);
		  /* 8210A148h */ case    0:  		/* lwz R9, <#[R10 + 104]> */
		/* 8210A148h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000068) );
		/* 8210A148h case    0:*/		return 0x8210A14C;
		  /* 8210A14Ch */ case    1:  		/* add R6, R6, R4 */
		/* 8210A14Ch case    1:*/		cpu::op::add<0>(regs,&regs.R6,regs.R6,regs.R4);
		/* 8210A14Ch case    1:*/		return 0x8210A150;
		  /* 8210A150h */ case    2:  		/* stw R9, <#[R11 + 104]> */
		/* 8210A150h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000068) );
		/* 8210A150h case    2:*/		return 0x8210A154;
		  /* 8210A154h */ case    3:  		/* lwz R9, <#[R10 + 108]> */
		/* 8210A154h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000006C) );
		/* 8210A154h case    3:*/		return 0x8210A158;
		  /* 8210A158h */ case    4:  		/* stw R9, <#[R11 + 108]> */
		/* 8210A158h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000006C) );
		/* 8210A158h case    4:*/		return 0x8210A15C;
		  /* 8210A15Ch */ case    5:  		/* lwz R9, <#[R10 + 112]> */
		/* 8210A15Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000070) );
		/* 8210A15Ch case    5:*/		return 0x8210A160;
		  /* 8210A160h */ case    6:  		/* stw R9, <#[R11 + 112]> */
		/* 8210A160h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000070) );
		/* 8210A160h case    6:*/		return 0x8210A164;
		  /* 8210A164h */ case    7:  		/* bc 16, CR0_LT, -152 */
		/* 8210A164h case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210A0CC;  }
		/* 8210A164h case    7:*/		return 0x8210A168;
	}
	return 0x8210A168;
} // Block from 8210A148h-8210A168h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8210A168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A168);
		  /* 8210A168h */ case    0:  		/* lwz R11, <#[R29 + 116]> */
		/* 8210A168h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000074) );
		/* 8210A168h case    0:*/		return 0x8210A16C;
		  /* 8210A16Ch */ case    1:  		/* addi R3, R3, 1 */
		/* 8210A16Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 8210A16Ch case    1:*/		return 0x8210A170;
		  /* 8210A170h */ case    2:  		/* addi R5, R5, 4 */
		/* 8210A170h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 8210A170h case    2:*/		return 0x8210A174;
		  /* 8210A174h */ case    3:  		/* stw R11, <#[R10 + 4]> */
		/* 8210A174h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8210A174h case    3:*/		return 0x8210A178;
		  /* 8210A178h */ case    4:  		/* lwz R11, <#[R30 + 12]> */
		/* 8210A178h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210A178h case    4:*/		return 0x8210A17C;
		  /* 8210A17Ch */ case    5:  		/* cmplw CR6, R3, R11 */
		/* 8210A17Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8210A17Ch case    5:*/		return 0x8210A180;
		  /* 8210A180h */ case    6:  		/* bc 12, CR6_LT, -220 */
		/* 8210A180h case    6:*/		if ( regs.CR[6].lt ) { return 0x8210A0A4;  }
		/* 8210A180h case    6:*/		return 0x8210A184;
	}
	return 0x8210A184;
} // Block from 8210A168h-8210A184h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8210A184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A184);
		  /* 8210A184h */ case    0:  		/* stw R20, <#[R30]> */
		/* 8210A184h case    0:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R30 + 0x00000000) );
		/* 8210A184h case    0:*/		return 0x8210A188;
		  /* 8210A188h */ case    1:  		/* li R19, 1 */
		/* 8210A188h case    1:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 8210A188h case    1:*/		return 0x8210A18C;
		  /* 8210A18Ch */ case    2:  		/* stw R20, <#[R30 + 4]> */
		/* 8210A18Ch case    2:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R30 + 0x00000004) );
		/* 8210A18Ch case    2:*/		return 0x8210A190;
		  /* 8210A190h */ case    3:  		/* stw R20, <#[R30 + 12]> */
		/* 8210A190h case    3:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210A190h case    3:*/		return 0x8210A194;
	}
	return 0x8210A194;
} // Block from 8210A184h-8210A194h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210A194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A194);
		  /* 8210A194h */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 8210A194h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 8210A194h case    0:*/		return 0x8210A198;
		  /* 8210A198h */ case    1:  		/* bc 4, CR6_EQ, -932 */
		/* 8210A198h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82109DF4;  }
		/* 8210A198h case    1:*/		return 0x8210A19C;
		  /* 8210A19Ch */ case    2:  		/* cmpwi CR6, R19, 0 */
		/* 8210A19Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 8210A19Ch case    2:*/		return 0x8210A1A0;
		  /* 8210A1A0h */ case    3:  		/* bc 12, CR6_EQ, -980 */
		/* 8210A1A0h case    3:*/		if ( regs.CR[6].eq ) { return 0x82109DCC;  }
		/* 8210A1A0h case    3:*/		return 0x8210A1A4;
		  /* 8210A1A4h */ case    4:  		/* li R3, 0 */
		/* 8210A1A4h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210A1A4h case    4:*/		return 0x8210A1A8;
	}
	return 0x8210A1A8;
} // Block from 8210A194h-8210A1A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210A1A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A1A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A1A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A1A8);
		  /* 8210A1A8h */ case    0:  		/* addi R1, R1, 208 */
		/* 8210A1A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 8210A1A8h case    0:*/		return 0x8210A1AC;
		  /* 8210A1ACh */ case    1:  		/* b -495408 */
		/* 8210A1ACh case    1:*/		return 0x8209127C;
		/* 8210A1ACh case    1:*/		return 0x8210A1B0;
	}
	return 0x8210A1B0;
} // Block from 8210A1A8h-8210A1B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210A1B0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A1B0);
		  /* 8210A1B0h */ case    0:  		/* mfspr R12, LR */
		/* 8210A1B0h case    0:*/		regs.R12 = regs.LR;
		/* 8210A1B0h case    0:*/		return 0x8210A1B4;
		  /* 8210A1B4h */ case    1:  		/* bl -495460 */
		/* 8210A1B4h case    1:*/		regs.LR = 0x8210A1B8; return 0x82091250;
		/* 8210A1B4h case    1:*/		return 0x8210A1B8;
		  /* 8210A1B8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8210A1B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8210A1B8h case    2:*/		return 0x8210A1BC;
		  /* 8210A1BCh */ case    3:  		/* mr R31, R3 */
		/* 8210A1BCh case    3:*/		regs.R31 = regs.R3;
		/* 8210A1BCh case    3:*/		return 0x8210A1C0;
		  /* 8210A1C0h */ case    4:  		/* li R30, 0 */
		/* 8210A1C0h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8210A1C0h case    4:*/		return 0x8210A1C4;
		  /* 8210A1C4h */ case    5:  		/* bl -17964 */
		/* 8210A1C4h case    5:*/		regs.LR = 0x8210A1C8; return 0x82105B98;
		/* 8210A1C4h case    5:*/		return 0x8210A1C8;
		  /* 8210A1C8h */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 8210A1C8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8210A1C8h case    6:*/		return 0x8210A1CC;
		  /* 8210A1CCh */ case    7:  		/* li R8, 0 */
		/* 8210A1CCh case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210A1CCh case    7:*/		return 0x8210A1D0;
		  /* 8210A1D0h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8210A1D0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A1D0h case    8:*/		return 0x8210A1D4;
		  /* 8210A1D4h */ case    9:  		/* bc 4, CR6_GT, 72 */
		/* 8210A1D4h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8210A21C;  }
		/* 8210A1D4h case    9:*/		return 0x8210A1D8;
		  /* 8210A1D8h */ case   10:  		/* li R9, 0 */
		/* 8210A1D8h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210A1D8h case   10:*/		return 0x8210A1DC;
		  /* 8210A1DCh */ case   11:  		/* lwz R11, <#[R31 + 16]> */
		/* 8210A1DCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8210A1DCh case   11:*/		return 0x8210A1E0;
		  /* 8210A1E0h */ case   12:  		/* lwzx R11, <#[R9 + R11]> */
		/* 8210A1E0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210A1E0h case   12:*/		return 0x8210A1E4;
		  /* 8210A1E4h */ case   13:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210A1E4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210A1E4h case   13:*/		return 0x8210A1E8;
		  /* 8210A1E8h */ case   14:  		/* rlwinm. R7, R10, 0, 21, 21 */
		/* 8210A1E8h case   14:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R7,regs.R10);
		/* 8210A1E8h case   14:*/		return 0x8210A1EC;
		  /* 8210A1ECh */ case   15:  		/* bc 12, CR0_EQ, 28 */
		/* 8210A1ECh case   15:*/		if ( regs.CR[0].eq ) { return 0x8210A208;  }
		/* 8210A1ECh case   15:*/		return 0x8210A1F0;
		  /* 8210A1F0h */ case   16:  		/* lwz R7, <#[R11 + 40]> */
		/* 8210A1F0h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000028) );
		/* 8210A1F0h case   16:*/		return 0x8210A1F4;
		  /* 8210A1F4h */ case   17:  		/* cmpwi CR6, R7, -1 */
		/* 8210A1F4h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 8210A1F4h case   17:*/		return 0x8210A1F8;
		  /* 8210A1F8h */ case   18:  		/* bc 4, CR6_EQ, 16 */
		/* 8210A1F8h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8210A208;  }
		/* 8210A1F8h case   18:*/		return 0x8210A1FC;
		  /* 8210A1FCh */ case   19:  		/* rlwinm R10, R10, 0, 22, 20 */
		/* 8210A1FCh case   19:*/		cpu::op::rlwinm<0,0,22,20>(regs,&regs.R10,regs.R10);
		/* 8210A1FCh case   19:*/		return 0x8210A200;
		  /* 8210A200h */ case   20:  		/* li R30, 1 */
		/* 8210A200h case   20:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8210A200h case   20:*/		return 0x8210A204;
		  /* 8210A204h */ case   21:  		/* stw R10, <#[R11 + 4]> */
		/* 8210A204h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210A204h case   21:*/		return 0x8210A208;
	}
	return 0x8210A208;
} // Block from 8210A1B0h-8210A208h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8210A208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A208);
		  /* 8210A208h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8210A208h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8210A208h case    0:*/		return 0x8210A20C;
		  /* 8210A20Ch */ case    1:  		/* addi R8, R8, 1 */
		/* 8210A20Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8210A20Ch case    1:*/		return 0x8210A210;
		  /* 8210A210h */ case    2:  		/* addi R9, R9, 4 */
		/* 8210A210h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8210A210h case    2:*/		return 0x8210A214;
		  /* 8210A214h */ case    3:  		/* cmplw CR6, R8, R11 */
		/* 8210A214h case    3:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8210A214h case    3:*/		return 0x8210A218;
		  /* 8210A218h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 8210A218h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210A1DC;  }
		/* 8210A218h case    4:*/		return 0x8210A21C;
	}
	return 0x8210A21C;
} // Block from 8210A208h-8210A21Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210A21Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A21C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A21C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A21C);
		  /* 8210A21Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210A21Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210A21Ch case    0:*/		return 0x8210A220;
		  /* 8210A220h */ case    1:  		/* li R6, 0 */
		/* 8210A220h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8210A220h case    1:*/		return 0x8210A224;
		  /* 8210A224h */ case    2:  		/* li R7, 0 */
		/* 8210A224h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210A224h case    2:*/		return 0x8210A228;
		  /* 8210A228h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8210A228h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A228h case    3:*/		return 0x8210A22C;
		  /* 8210A22Ch */ case    4:  		/* bc 4, CR6_GT, 168 */
		/* 8210A22Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x8210A2D4;  }
		/* 8210A22Ch case    4:*/		return 0x8210A230;
		  /* 8210A230h */ case    5:  		/* li R8, 0 */
		/* 8210A230h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8210A230h case    5:*/		return 0x8210A234;
		  /* 8210A234h */ case    6:  		/* lwz R11, <#[R31 + 20]> */
		/* 8210A234h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8210A234h case    6:*/		return 0x8210A238;
		  /* 8210A238h */ case    7:  		/* lwzx R11, <#[R11 + R8]> */
		/* 8210A238h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210A238h case    7:*/		return 0x8210A23C;
		  /* 8210A23Ch */ case    8:  		/* lwz R10, <#[R11 + 84]> */
		/* 8210A23Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000054) );
		/* 8210A23Ch case    8:*/		return 0x8210A240;
		  /* 8210A240h */ case    9:  		/* cmpwi CR6, R10, -1 */
		/* 8210A240h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210A240h case    9:*/		return 0x8210A244;
		  /* 8210A244h */ case   10:  		/* bc 4, CR6_EQ, 68 */
		/* 8210A244h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8210A288;  }
		/* 8210A244h case   10:*/		return 0x8210A248;
		  /* 8210A248h */ case   11:  		/* lwz R9, <#[R11]> */
		/* 8210A248h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A248h case   11:*/		return 0x8210A24C;
		  /* 8210A24Ch */ case   12:  		/* rlwinm. R10, R9, 0, 3, 3 */
		/* 8210A24Ch case   12:*/		cpu::op::rlwinm<1,0,3,3>(regs,&regs.R10,regs.R9);
		/* 8210A24Ch case   12:*/		return 0x8210A250;
		  /* 8210A250h */ case   13:  		/* bc 4, CR0_EQ, 40 */
		/* 8210A250h case   13:*/		if ( !regs.CR[0].eq ) { return 0x8210A278;  }
		/* 8210A250h case   13:*/		return 0x8210A254;
		  /* 8210A254h */ case   14:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210A254h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210A254h case   14:*/		return 0x8210A258;
		  /* 8210A258h */ case   15:  		/* lwz R5, <#[R31 + 16]> */
		/* 8210A258h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 8210A258h case   15:*/		return 0x8210A25C;
		  /* 8210A25Ch */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210A25Ch case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210A25Ch case   16:*/		return 0x8210A260;
		  /* 8210A260h */ case   17:  		/* lwzx R10, <#[R10 + R5]> */
		/* 8210A260h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8210A260h case   17:*/		return 0x8210A264;
		  /* 8210A264h */ case   18:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210A264h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210A264h case   18:*/		return 0x8210A268;
		  /* 8210A268h */ case   19:  		/* rlwinm. R5, R10, 0, 22, 23 */
		/* 8210A268h case   19:*/		cpu::op::rlwinm<1,0,22,23>(regs,&regs.R5,regs.R10);
		/* 8210A268h case   19:*/		return 0x8210A26C;
		  /* 8210A26Ch */ case   20:  		/* bc 12, CR0_EQ, 40 */
		/* 8210A26Ch case   20:*/		if ( regs.CR[0].eq ) { return 0x8210A294;  }
		/* 8210A26Ch case   20:*/		return 0x8210A270;
		  /* 8210A270h */ case   21:  		/* rlwinm. R10, R10, 0, 20, 20 */
		/* 8210A270h case   21:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R10);
		/* 8210A270h case   21:*/		return 0x8210A274;
		  /* 8210A274h */ case   22:  		/* bc 12, CR0_EQ, 32 */
		/* 8210A274h case   22:*/		if ( regs.CR[0].eq ) { return 0x8210A294;  }
		/* 8210A274h case   22:*/		return 0x8210A278;
	}
	return 0x8210A278;
} // Block from 8210A21Ch-8210A278h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8210A278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A278);
		  /* 8210A278h */ case    0:  		/* oris R10, R9, 4096 */
		/* 8210A278h case    0:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R9,0x1000);
		/* 8210A278h case    0:*/		return 0x8210A27C;
		  /* 8210A27Ch */ case    1:  		/* li R9, 1 */
		/* 8210A27Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8210A27Ch case    1:*/		return 0x8210A280;
		  /* 8210A280h */ case    2:  		/* stw R9, <#[R11 + 84]> */
		/* 8210A280h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000054) );
		/* 8210A280h case    2:*/		return 0x8210A284;
		  /* 8210A284h */ case    3:  		/* b 12 */
		/* 8210A284h case    3:*/		return 0x8210A290;
		/* 8210A284h case    3:*/		return 0x8210A288;
	}
	return 0x8210A288;
} // Block from 8210A278h-8210A288h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210A288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A288);
		  /* 8210A288h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 8210A288h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A288h case    0:*/		return 0x8210A28C;
		  /* 8210A28Ch */ case    1:  		/* rlwinm R10, R10, 0, 4, 2 */
		/* 8210A28Ch case    1:*/		cpu::op::rlwinm<0,0,4,2>(regs,&regs.R10,regs.R10);
		/* 8210A28Ch case    1:*/		return 0x8210A290;
	}
	return 0x8210A290;
} // Block from 8210A288h-8210A290h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210A290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A290);
		  /* 8210A290h */ case    0:  		/* stw R10, <#[R11]> */
		/* 8210A290h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A290h case    0:*/		return 0x8210A294;
	}
	return 0x8210A294;
} // Block from 8210A290h-8210A294h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210A294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A294);
		  /* 8210A294h */ case    0:  		/* lwz R10, <#[R11 + 84]> */
		/* 8210A294h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000054) );
		/* 8210A294h case    0:*/		return 0x8210A298;
		  /* 8210A298h */ case    1:  		/* cmpwi CR6, R10, -1 */
		/* 8210A298h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210A298h case    1:*/		return 0x8210A29C;
		  /* 8210A29Ch */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 8210A29Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8210A2B8;  }
		/* 8210A29Ch case    2:*/		return 0x8210A2A0;
		  /* 8210A2A0h */ case    3:  		/* lwz R10, <#[R11 + 72]> */
		/* 8210A2A0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000048) );
		/* 8210A2A0h case    3:*/		return 0x8210A2A4;
		  /* 8210A2A4h */ case    4:  		/* cmpwi CR6, R10, -1 */
		/* 8210A2A4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210A2A4h case    4:*/		return 0x8210A2A8;
		  /* 8210A2A8h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 8210A2A8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8210A2B8;  }
		/* 8210A2A8h case    5:*/		return 0x8210A2AC;
		  /* 8210A2ACh */ case    6:  		/* li R10, -1 */
		/* 8210A2ACh case    6:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8210A2ACh case    6:*/		return 0x8210A2B0;
		  /* 8210A2B0h */ case    7:  		/* stw R10, <#[R11 + 48]> */
		/* 8210A2B0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 8210A2B0h case    7:*/		return 0x8210A2B4;
		  /* 8210A2B4h */ case    8:  		/* b 12 */
		/* 8210A2B4h case    8:*/		return 0x8210A2C0;
		/* 8210A2B4h case    8:*/		return 0x8210A2B8;
	}
	return 0x8210A2B8;
} // Block from 8210A294h-8210A2B8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210A2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A2B8);
		  /* 8210A2B8h */ case    0:  		/* stw R6, <#[R11 + 48]> */
		/* 8210A2B8h case    0:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000030) );
		/* 8210A2B8h case    0:*/		return 0x8210A2BC;
		  /* 8210A2BCh */ case    1:  		/* addi R6, R6, 1 */
		/* 8210A2BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210A2BCh case    1:*/		return 0x8210A2C0;
	}
	return 0x8210A2C0;
} // Block from 8210A2B8h-8210A2C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210A2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A2C0);
		  /* 8210A2C0h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210A2C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210A2C0h case    0:*/		return 0x8210A2C4;
		  /* 8210A2C4h */ case    1:  		/* addi R7, R7, 1 */
		/* 8210A2C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210A2C4h case    1:*/		return 0x8210A2C8;
		  /* 8210A2C8h */ case    2:  		/* addi R8, R8, 4 */
		/* 8210A2C8h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8210A2C8h case    2:*/		return 0x8210A2CC;
		  /* 8210A2CCh */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 8210A2CCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 8210A2CCh case    3:*/		return 0x8210A2D0;
		  /* 8210A2D0h */ case    4:  		/* bc 12, CR6_LT, -156 */
		/* 8210A2D0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210A234;  }
		/* 8210A2D0h case    4:*/		return 0x8210A2D4;
	}
	return 0x8210A2D4;
} // Block from 8210A2C0h-8210A2D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210A2D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A2D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A2D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A2D4);
		  /* 8210A2D4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210A2D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210A2D4h case    0:*/		return 0x8210A2D8;
		  /* 8210A2D8h */ case    1:  		/* cmplw CR6, R6, R11 */
		/* 8210A2D8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 8210A2D8h case    1:*/		return 0x8210A2DC;
		  /* 8210A2DCh */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 8210A2DCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x8210A2EC;  }
		/* 8210A2DCh case    2:*/		return 0x8210A2E0;
		  /* 8210A2E0h */ case    3:  		/* cntlzw R11, R30 */
		/* 8210A2E0h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R30);
		/* 8210A2E0h case    3:*/		return 0x8210A2E4;
		  /* 8210A2E4h */ case    4:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 8210A2E4h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 8210A2E4h case    4:*/		return 0x8210A2E8;
		  /* 8210A2E8h */ case    5:  		/* b 164 */
		/* 8210A2E8h case    5:*/		return 0x8210A38C;
		/* 8210A2E8h case    5:*/		return 0x8210A2EC;
	}
	return 0x8210A2EC;
} // Block from 8210A2D4h-8210A2ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210A2ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A2EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A2EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A2EC);
		  /* 8210A2ECh */ case    0:  		/* mr R3, R31 */
		/* 8210A2ECh case    0:*/		regs.R3 = regs.R31;
		/* 8210A2ECh case    0:*/		return 0x8210A2F0;
		  /* 8210A2F0h */ case    1:  		/* bl -16080 */
		/* 8210A2F0h case    1:*/		regs.LR = 0x8210A2F4; return 0x82106420;
		/* 8210A2F0h case    1:*/		return 0x8210A2F4;
		  /* 8210A2F4h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210A2F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210A2F4h case    2:*/		return 0x8210A2F8;
		  /* 8210A2F8h */ case    3:  		/* li R29, 0 */
		/* 8210A2F8h case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210A2F8h case    3:*/		return 0x8210A2FC;
		  /* 8210A2FCh */ case    4:  		/* li R26, 0 */
		/* 8210A2FCh case    4:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210A2FCh case    4:*/		return 0x8210A300;
		  /* 8210A300h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8210A300h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A300h case    5:*/		return 0x8210A304;
		  /* 8210A304h */ case    6:  		/* bc 4, CR6_GT, 96 */
		/* 8210A304h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8210A364;  }
		/* 8210A304h case    6:*/		return 0x8210A308;
		  /* 8210A308h */ case    7:  		/* li R27, 0 */
		/* 8210A308h case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8210A308h case    7:*/		return 0x8210A30C;
		  /* 8210A30Ch */ case    8:  		/* li R28, 0 */
		/* 8210A30Ch case    8:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8210A30Ch case    8:*/		return 0x8210A310;
		  /* 8210A310h */ case    9:  		/* lwz R11, <#[R31 + 20]> */
		/* 8210A310h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8210A310h case    9:*/		return 0x8210A314;
		  /* 8210A314h */ case   10:  		/* lwzx R30, <#[R28 + R11]> */
		/* 8210A314h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 8210A314h case   10:*/		return 0x8210A318;
		  /* 8210A318h */ case   11:  		/* lwz R10, <#[R30 + 84]> */
		/* 8210A318h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000054) );
		/* 8210A318h case   11:*/		return 0x8210A31C;
		  /* 8210A31Ch */ case   12:  		/* cmpwi CR6, R10, -1 */
		/* 8210A31Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210A31Ch case   12:*/		return 0x8210A320;
		  /* 8210A320h */ case   13:  		/* bc 4, CR6_EQ, 36 */
		/* 8210A320h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8210A344;  }
		/* 8210A320h case   13:*/		return 0x8210A324;
		  /* 8210A324h */ case   14:  		/* lwz R10, <#[R30 + 72]> */
		/* 8210A324h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000048) );
		/* 8210A324h case   14:*/		return 0x8210A328;
		  /* 8210A328h */ case   15:  		/* cmpwi CR6, R10, -1 */
		/* 8210A328h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R10,0xFFFFFFFF);
		/* 8210A328h case   15:*/		return 0x8210A32C;
		  /* 8210A32Ch */ case   16:  		/* bc 4, CR6_EQ, 24 */
		/* 8210A32Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x8210A344;  }
		/* 8210A32Ch case   16:*/		return 0x8210A330;
		  /* 8210A330h */ case   17:  		/* mr R3, R30 */
		/* 8210A330h case   17:*/		regs.R3 = regs.R30;
		/* 8210A330h case   17:*/		return 0x8210A334;
		  /* 8210A334h */ case   18:  		/* bl 1126540 */
		/* 8210A334h case   18:*/		regs.LR = 0x8210A338; return 0x8221D3C0;
		/* 8210A334h case   18:*/		return 0x8210A338;
		  /* 8210A338h */ case   19:  		/* mr R3, R30 */
		/* 8210A338h case   19:*/		regs.R3 = regs.R30;
		/* 8210A338h case   19:*/		return 0x8210A33C;
		  /* 8210A33Ch */ case   20:  		/* bl -54716 */
		/* 8210A33Ch case   20:*/		regs.LR = 0x8210A340; return 0x820FCD80;
		/* 8210A33Ch case   20:*/		return 0x8210A340;
		  /* 8210A340h */ case   21:  		/* b 16 */
		/* 8210A340h case   21:*/		return 0x8210A350;
		/* 8210A340h case   21:*/		return 0x8210A344;
	}
	return 0x8210A344;
} // Block from 8210A2ECh-8210A344h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8210A344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A344);
		  /* 8210A344h */ case    0:  		/* stwx R30, <#[R27 + R11]> */
		/* 8210A344h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 8210A344h case    0:*/		return 0x8210A348;
		  /* 8210A348h */ case    1:  		/* addi R29, R29, 1 */
		/* 8210A348h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8210A348h case    1:*/		return 0x8210A34C;
		  /* 8210A34Ch */ case    2:  		/* addi R27, R27, 4 */
		/* 8210A34Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8210A34Ch case    2:*/		return 0x8210A350;
	}
	return 0x8210A350;
} // Block from 8210A344h-8210A350h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210A350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A350);
		  /* 8210A350h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210A350h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210A350h case    0:*/		return 0x8210A354;
		  /* 8210A354h */ case    1:  		/* addi R26, R26, 1 */
		/* 8210A354h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8210A354h case    1:*/		return 0x8210A358;
		  /* 8210A358h */ case    2:  		/* addi R28, R28, 4 */
		/* 8210A358h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8210A358h case    2:*/		return 0x8210A35C;
		  /* 8210A35Ch */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 8210A35Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 8210A35Ch case    3:*/		return 0x8210A360;
		  /* 8210A360h */ case    4:  		/* bc 12, CR6_LT, -80 */
		/* 8210A360h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210A310;  }
		/* 8210A360h case    4:*/		return 0x8210A364;
	}
	return 0x8210A364;
} // Block from 8210A350h-8210A364h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210A364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A364);
		  /* 8210A364h */ case    0:  		/* lwz R9, <#[R31 + 8]> */
		/* 8210A364h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8210A364h case    0:*/		return 0x8210A368;
		  /* 8210A368h */ case    1:  		/* rlwinm R11, R29, 2, 0, 29 */
		/* 8210A368h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R29);
		/* 8210A368h case    1:*/		return 0x8210A36C;
		  /* 8210A36Ch */ case    2:  		/* lwz R10, <#[R31 + 20]> */
		/* 8210A36Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 8210A36Ch case    2:*/		return 0x8210A370;
		  /* 8210A370h */ case    3:  		/* li R4, 0 */
		/* 8210A370h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8210A370h case    3:*/		return 0x8210A374;
		  /* 8210A374h */ case    4:  		/* subf R9, R29, R9 */
		/* 8210A374h case    4:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 8210A374h case    4:*/		return 0x8210A378;
		  /* 8210A378h */ case    5:  		/* add R3, R11, R10 */
		/* 8210A378h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8210A378h case    5:*/		return 0x8210A37C;
		  /* 8210A37Ch */ case    6:  		/* rlwinm R5, R9, 2, 0, 29 */
		/* 8210A37Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R9);
		/* 8210A37Ch case    6:*/		return 0x8210A380;
		  /* 8210A380h */ case    7:  		/* bl -495680 */
		/* 8210A380h case    7:*/		regs.LR = 0x8210A384; return 0x82091340;
		/* 8210A380h case    7:*/		return 0x8210A384;
		  /* 8210A384h */ case    8:  		/* stw R29, <#[R31 + 8]> */
		/* 8210A384h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 8210A384h case    8:*/		return 0x8210A388;
		  /* 8210A388h */ case    9:  		/* li R3, 0 */
		/* 8210A388h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210A388h case    9:*/		return 0x8210A38C;
	}
	return 0x8210A38C;
} // Block from 8210A364h-8210A38Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8210A38Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A38C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A38C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A38C);
		  /* 8210A38Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 8210A38Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8210A38Ch case    0:*/		return 0x8210A390;
		  /* 8210A390h */ case    1:  		/* b -495856 */
		/* 8210A390h case    1:*/		return 0x820912A0;
		/* 8210A390h case    1:*/		return 0x8210A394;
		  /* 8210A394h */ case    2:  		/* nop */
		/* 8210A394h case    2:*/		cpu::op::nop();
		/* 8210A394h case    2:*/		return 0x8210A398;
	}
	return 0x8210A398;
} // Block from 8210A38Ch-8210A398h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210A398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A398);
		  /* 8210A398h */ case    0:  		/* mfspr R12, LR */
		/* 8210A398h case    0:*/		regs.R12 = regs.LR;
		/* 8210A398h case    0:*/		return 0x8210A39C;
		  /* 8210A39Ch */ case    1:  		/* bl -495948 */
		/* 8210A39Ch case    1:*/		regs.LR = 0x8210A3A0; return 0x82091250;
		/* 8210A39Ch case    1:*/		return 0x8210A3A0;
		  /* 8210A3A0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8210A3A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8210A3A0h case    2:*/		return 0x8210A3A4;
		  /* 8210A3A4h */ case    3:  		/* mr R30, R3 */
		/* 8210A3A4h case    3:*/		regs.R30 = regs.R3;
		/* 8210A3A4h case    3:*/		return 0x8210A3A8;
		  /* 8210A3A8h */ case    4:  		/* bl -18448 */
		/* 8210A3A8h case    4:*/		regs.LR = 0x8210A3AC; return 0x82105B98;
		/* 8210A3A8h case    4:*/		return 0x8210A3AC;
		  /* 8210A3ACh */ case    5:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210A3ACh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210A3ACh case    5:*/		return 0x8210A3B0;
		  /* 8210A3B0h */ case    6:  		/* li R6, 0 */
		/* 8210A3B0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8210A3B0h case    6:*/		return 0x8210A3B4;
		  /* 8210A3B4h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8210A3B4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A3B4h case    7:*/		return 0x8210A3B8;
		  /* 8210A3B8h */ case    8:  		/* bc 4, CR6_GT, 116 */
		/* 8210A3B8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8210A42C;  }
		/* 8210A3B8h case    8:*/		return 0x8210A3BC;
		  /* 8210A3BCh */ case    9:  		/* li R7, 0 */
		/* 8210A3BCh case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210A3BCh case    9:*/		return 0x8210A3C0;
		  /* 8210A3C0h */ case   10:  		/* lwz R11, <#[R30 + 20]> */
		/* 8210A3C0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8210A3C0h case   10:*/		return 0x8210A3C4;
		  /* 8210A3C4h */ case   11:  		/* lwz R9, <#[R30 + 16]> */
		/* 8210A3C4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 8210A3C4h case   11:*/		return 0x8210A3C8;
		  /* 8210A3C8h */ case   12:  		/* lwzx R11, <#[R7 + R11]> */
		/* 8210A3C8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8210A3C8h case   12:*/		return 0x8210A3CC;
		  /* 8210A3CCh */ case   13:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210A3CCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210A3CCh case   13:*/		return 0x8210A3D0;
		  /* 8210A3D0h */ case   14:  		/* lwz R8, <#[R11]> */
		/* 8210A3D0h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A3D0h case   14:*/		return 0x8210A3D4;
		  /* 8210A3D4h */ case   15:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 8210A3D4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 8210A3D4h case   15:*/		return 0x8210A3D8;
		  /* 8210A3D8h */ case   16:  		/* rlwinm R10, R8, 0, 27, 25 */
		/* 8210A3D8h case   16:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R10,regs.R8);
		/* 8210A3D8h case   16:*/		return 0x8210A3DC;
		  /* 8210A3DCh */ case   17:  		/* lwzx R8, <#[R5 + R9]> */
		/* 8210A3DCh case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 8210A3DCh case   17:*/		return 0x8210A3E0;
		  /* 8210A3E0h */ case   18:  		/* stw R10, <#[R11]> */
		/* 8210A3E0h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A3E0h case   18:*/		return 0x8210A3E4;
		  /* 8210A3E4h */ case   19:  		/* lwz R9, <#[R8 + 4]> */
		/* 8210A3E4h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000004) );
		/* 8210A3E4h case   19:*/		return 0x8210A3E8;
		  /* 8210A3E8h */ case   20:  		/* rlwinm. R5, R9, 0, 27, 27 */
		/* 8210A3E8h case   20:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R5,regs.R9);
		/* 8210A3E8h case   20:*/		return 0x8210A3EC;
		  /* 8210A3ECh */ case   21:  		/* bc 12, CR0_EQ, 20 */
		/* 8210A3ECh case   21:*/		if ( regs.CR[0].eq ) { return 0x8210A400;  }
		/* 8210A3ECh case   21:*/		return 0x8210A3F0;
		  /* 8210A3F0h */ case   22:  		/* rlwinm. R9, R9, 0, 22, 22 */
		/* 8210A3F0h case   22:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R9,regs.R9);
		/* 8210A3F0h case   22:*/		return 0x8210A3F4;
		  /* 8210A3F4h */ case   23:  		/* bc 4, CR0_EQ, 12 */
		/* 8210A3F4h case   23:*/		if ( !regs.CR[0].eq ) { return 0x8210A400;  }
		/* 8210A3F4h case   23:*/		return 0x8210A3F8;
		  /* 8210A3F8h */ case   24:  		/* ori R10, R10, 32 */
		/* 8210A3F8h case   24:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x20);
		/* 8210A3F8h case   24:*/		return 0x8210A3FC;
		  /* 8210A3FCh */ case   25:  		/* stw R10, <#[R11]> */
		/* 8210A3FCh case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A3FCh case   25:*/		return 0x8210A400;
	}
	return 0x8210A400;
} // Block from 8210A398h-8210A400h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8210A400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A400);
		  /* 8210A400h */ case    0:  		/* lwz R10, <#[R8 + 4]> */
		/* 8210A400h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 8210A400h case    0:*/		return 0x8210A404;
		  /* 8210A404h */ case    1:  		/* rlwinm. R10, R10, 0, 20, 20 */
		/* 8210A404h case    1:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R10);
		/* 8210A404h case    1:*/		return 0x8210A408;
		  /* 8210A408h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8210A408h case    2:*/		if ( regs.CR[0].eq ) { return 0x8210A418;  }
		/* 8210A408h case    2:*/		return 0x8210A40C;
		  /* 8210A40Ch */ case    3:  		/* lwz R10, <#[R11]> */
		/* 8210A40Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A40Ch case    3:*/		return 0x8210A410;
		  /* 8210A410h */ case    4:  		/* ori R10, R10, 32 */
		/* 8210A410h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x20);
		/* 8210A410h case    4:*/		return 0x8210A414;
		  /* 8210A414h */ case    5:  		/* stw R10, <#[R11]> */
		/* 8210A414h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A414h case    5:*/		return 0x8210A418;
	}
	return 0x8210A418;
} // Block from 8210A400h-8210A418h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210A418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A418);
		  /* 8210A418h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210A418h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210A418h case    0:*/		return 0x8210A41C;
		  /* 8210A41Ch */ case    1:  		/* addi R6, R6, 1 */
		/* 8210A41Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210A41Ch case    1:*/		return 0x8210A420;
		  /* 8210A420h */ case    2:  		/* addi R7, R7, 4 */
		/* 8210A420h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210A420h case    2:*/		return 0x8210A424;
		  /* 8210A424h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 8210A424h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 8210A424h case    3:*/		return 0x8210A428;
		  /* 8210A428h */ case    4:  		/* bc 12, CR6_LT, -104 */
		/* 8210A428h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210A3C0;  }
		/* 8210A428h case    4:*/		return 0x8210A42C;
	}
	return 0x8210A42C;
} // Block from 8210A418h-8210A42Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210A42Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A42C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A42C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A42C);
		  /* 8210A42Ch */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 8210A42Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210A42Ch case    0:*/		return 0x8210A430;
		  /* 8210A430h */ case    1:  		/* li R26, 0 */
		/* 8210A430h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8210A430h case    1:*/		return 0x8210A434;
		  /* 8210A434h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210A434h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A434h case    2:*/		return 0x8210A438;
		  /* 8210A438h */ case    3:  		/* bc 4, CR6_GT, 744 */
		/* 8210A438h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210A720;  }
		/* 8210A438h case    3:*/		return 0x8210A43C;
		  /* 8210A43Ch */ case    4:  		/* li R27, 0 */
		/* 8210A43Ch case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8210A43Ch case    4:*/		return 0x8210A440;
		  /* 8210A440h */ case    5:  		/* lwz R11, <#[R30 + 24]> */
		/* 8210A440h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 8210A440h case    5:*/		return 0x8210A444;
		  /* 8210A444h */ case    6:  		/* lwzx R8, <#[R27 + R11]> */
		/* 8210A444h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + regs.R11 + 0x00000000) );
		/* 8210A444h case    6:*/		return 0x8210A448;
		  /* 8210A448h */ case    7:  		/* lwz R10, <#[R8]> */
		/* 8210A448h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8210A448h case    7:*/		return 0x8210A44C;
		  /* 8210A44Ch */ case    8:  		/* rlwinm. R11, R10, 0, 0, 11 */
		/* 8210A44Ch case    8:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R10);
		/* 8210A44Ch case    8:*/		return 0x8210A450;
		  /* 8210A450h */ case    9:  		/* bc 12, CR0_EQ, 700 */
		/* 8210A450h case    9:*/		if ( regs.CR[0].eq ) { return 0x8210A70C;  }
		/* 8210A450h case    9:*/		return 0x8210A454;
		  /* 8210A454h */ case   10:  		/* lis R9, 20496 */
		/* 8210A454h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0x5010);
		/* 8210A454h case   10:*/		return 0x8210A458;
		  /* 8210A458h */ case   11:  		/* cmplw CR6, R11, R9 */
		/* 8210A458h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210A458h case   11:*/		return 0x8210A45C;
		  /* 8210A45Ch */ case   12:  		/* bc 12, CR6_EQ, 616 */
		/* 8210A45Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x8210A6C4;  }
		/* 8210A45Ch case   12:*/		return 0x8210A460;
		  /* 8210A460h */ case   13:  		/* lis R9, 4352 */
		/* 8210A460h case   13:*/		cpu::op::lis<0>(regs,&regs.R9,0x1100);
		/* 8210A460h case   13:*/		return 0x8210A464;
		  /* 8210A464h */ case   14:  		/* cmplw CR6, R11, R9 */
		/* 8210A464h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210A464h case   14:*/		return 0x8210A468;
		  /* 8210A468h */ case   15:  		/* bc 12, CR6_EQ, 604 */
		/* 8210A468h case   15:*/		if ( regs.CR[6].eq ) { return 0x8210A6C4;  }
		/* 8210A468h case   15:*/		return 0x8210A46C;
		  /* 8210A46Ch */ case   16:  		/* lis R9, 4384 */
		/* 8210A46Ch case   16:*/		cpu::op::lis<0>(regs,&regs.R9,0x1120);
		/* 8210A46Ch case   16:*/		return 0x8210A470;
		  /* 8210A470h */ case   17:  		/* cmplw CR6, R11, R9 */
		/* 8210A470h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210A470h case   17:*/		return 0x8210A474;
		  /* 8210A474h */ case   18:  		/* bc 12, CR6_EQ, 592 */
		/* 8210A474h case   18:*/		if ( regs.CR[6].eq ) { return 0x8210A6C4;  }
		/* 8210A474h case   18:*/		return 0x8210A478;
		  /* 8210A478h */ case   19:  		/* rlwinm R10, R10, 0, 0, 3 */
		/* 8210A478h case   19:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R10);
		/* 8210A478h case   19:*/		return 0x8210A47C;
		  /* 8210A47Ch */ case   20:  		/* lis R9, 24576 */
		/* 8210A47Ch case   20:*/		cpu::op::lis<0>(regs,&regs.R9,0x6000);
		/* 8210A47Ch case   20:*/		return 0x8210A480;
		  /* 8210A480h */ case   21:  		/* cmplw CR6, R10, R9 */
		/* 8210A480h case   21:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210A480h case   21:*/		return 0x8210A484;
		  /* 8210A484h */ case   22:  		/* bc 12, CR6_EQ, 576 */
		/* 8210A484h case   22:*/		if ( regs.CR[6].eq ) { return 0x8210A6C4;  }
		/* 8210A484h case   22:*/		return 0x8210A488;
		  /* 8210A488h */ case   23:  		/* lis R10, 4336 */
		/* 8210A488h case   23:*/		cpu::op::lis<0>(regs,&regs.R10,0x10F0);
		/* 8210A488h case   23:*/		return 0x8210A48C;
		  /* 8210A48Ch */ case   24:  		/* cmplw CR6, R11, R10 */
		/* 8210A48Ch case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210A48Ch case   24:*/		return 0x8210A490;
		  /* 8210A490h */ case   25:  		/* bc 12, CR6_EQ, 488 */
		/* 8210A490h case   25:*/		if ( regs.CR[6].eq ) { return 0x8210A678;  }
		/* 8210A490h case   25:*/		return 0x8210A494;
		  /* 8210A494h */ case   26:  		/* lis R10, 4368 */
		/* 8210A494h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0x1110);
		/* 8210A494h case   26:*/		return 0x8210A498;
		  /* 8210A498h */ case   27:  		/* cmplw CR6, R11, R10 */
		/* 8210A498h case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210A498h case   27:*/		return 0x8210A49C;
		  /* 8210A49Ch */ case   28:  		/* bc 12, CR6_EQ, 476 */
		/* 8210A49Ch case   28:*/		if ( regs.CR[6].eq ) { return 0x8210A678;  }
		/* 8210A49Ch case   28:*/		return 0x8210A4A0;
		  /* 8210A4A0h */ case   29:  		/* lis R10, 4416 */
		/* 8210A4A0h case   29:*/		cpu::op::lis<0>(regs,&regs.R10,0x1140);
		/* 8210A4A0h case   29:*/		return 0x8210A4A4;
		  /* 8210A4A4h */ case   30:  		/* cmplw CR6, R11, R10 */
		/* 8210A4A4h case   30:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210A4A4h case   30:*/		return 0x8210A4A8;
		  /* 8210A4A8h */ case   31:  		/* bc 12, CR6_EQ, 464 */
		/* 8210A4A8h case   31:*/		if ( regs.CR[6].eq ) { return 0x8210A678;  }
		/* 8210A4A8h case   31:*/		return 0x8210A4AC;
		  /* 8210A4ACh */ case   32:  		/* lwz R6, <#[R8 + 12]> */
		/* 8210A4ACh case   32:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x0000000C) );
		/* 8210A4ACh case   32:*/		return 0x8210A4B0;
		  /* 8210A4B0h */ case   33:  		/* li R5, 0 */
		/* 8210A4B0h case   33:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8210A4B0h case   33:*/		return 0x8210A4B4;
		  /* 8210A4B4h */ case   34:  		/* cmplwi CR6, R6, 0 */
		/* 8210A4B4h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8210A4B4h case   34:*/		return 0x8210A4B8;
		  /* 8210A4B8h */ case   35:  		/* bc 12, CR6_EQ, 128 */
		/* 8210A4B8h case   35:*/		if ( regs.CR[6].eq ) { return 0x8210A538;  }
		/* 8210A4B8h case   35:*/		return 0x8210A4BC;
		  /* 8210A4BCh */ case   36:  		/* li R7, 0 */
		/* 8210A4BCh case   36:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210A4BCh case   36:*/		return 0x8210A4C0;
		  /* 8210A4C0h */ case   37:  		/* lwz R11, <#[R8 + 16]> */
		/* 8210A4C0h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 8210A4C0h case   37:*/		return 0x8210A4C4;
		  /* 8210A4C4h */ case   38:  		/* lwz R10, <#[R30 + 20]> */
		/* 8210A4C4h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 8210A4C4h case   38:*/		return 0x8210A4C8;
		  /* 8210A4C8h */ case   39:  		/* lwz R9, <#[R30 + 16]> */
		/* 8210A4C8h case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 8210A4C8h case   39:*/		return 0x8210A4CC;
		  /* 8210A4CCh */ case   40:  		/* lwzx R11, <#[R7 + R11]> */
		/* 8210A4CCh case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8210A4CCh case   40:*/		return 0x8210A4D0;
		  /* 8210A4D0h */ case   41:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210A4D0h case   41:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210A4D0h case   41:*/		return 0x8210A4D4;
		  /* 8210A4D4h */ case   42:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210A4D4h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210A4D4h case   42:*/		return 0x8210A4D8;
		  /* 8210A4D8h */ case   43:  		/* lwz R10, <#[R11 + 4]> */
		/* 8210A4D8h case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8210A4D8h case   43:*/		return 0x8210A4DC;
		  /* 8210A4DCh */ case   44:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210A4DCh case   44:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210A4DCh case   44:*/		return 0x8210A4E0;
		  /* 8210A4E0h */ case   45:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210A4E0h case   45:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210A4E0h case   45:*/		return 0x8210A4E4;
		  /* 8210A4E4h */ case   46:  		/* lwz R10, <#[R10 + 4]> */
		/* 8210A4E4h case   46:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8210A4E4h case   46:*/		return 0x8210A4E8;
		  /* 8210A4E8h */ case   47:  		/* rlwinm. R10, R10, 0, 19, 19 */
		/* 8210A4E8h case   47:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R10,regs.R10);
		/* 8210A4E8h case   47:*/		return 0x8210A4EC;
		  /* 8210A4ECh */ case   48:  		/* bc 12, CR0_EQ, 56 */
		/* 8210A4ECh case   48:*/		if ( regs.CR[0].eq ) { return 0x8210A524;  }
		/* 8210A4ECh case   48:*/		return 0x8210A4F0;
		  /* 8210A4F0h */ case   49:  		/* mr R3, R30 */
		/* 8210A4F0h case   49:*/		regs.R3 = regs.R30;
		/* 8210A4F0h case   49:*/		return 0x8210A4F4;
		  /* 8210A4F4h */ case   50:  		/* lwz R4, <#[R11 + 20]> */
		/* 8210A4F4h case   50:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000014) );
		/* 8210A4F4h case   50:*/		return 0x8210A4F8;
		  /* 8210A4F8h */ case   51:  		/* bl -49952 */
		/* 8210A4F8h case   51:*/		regs.LR = 0x8210A4FC; return 0x820FE1D8;
		/* 8210A4F8h case   51:*/		return 0x8210A4FC;
		  /* 8210A4FCh */ case   52:  		/* cmpwi CR0, R3, 0 */
		/* 8210A4FCh case   52:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210A4FCh case   52:*/		return 0x8210A500;
		  /* 8210A500h */ case   53:  		/* bc 12, CR0_EQ, 36 */
		/* 8210A500h case   53:*/		if ( regs.CR[0].eq ) { return 0x8210A524;  }
		/* 8210A500h case   53:*/		return 0x8210A504;
		  /* 8210A504h */ case   54:  		/* lwz R11, <#[R8 + 16]> */
		/* 8210A504h case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 8210A504h case   54:*/		return 0x8210A508;
		  /* 8210A508h */ case   55:  		/* lwz R10, <#[R30 + 20]> */
		/* 8210A508h case   55:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 8210A508h case   55:*/		return 0x8210A50C;
		  /* 8210A50Ch */ case   56:  		/* lwzx R11, <#[R7 + R11]> */
		/* 8210A50Ch case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 8210A50Ch case   56:*/		return 0x8210A510;
		  /* 8210A510h */ case   57:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210A510h case   57:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210A510h case   57:*/		return 0x8210A514;
		  /* 8210A514h */ case   58:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210A514h case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210A514h case   58:*/		return 0x8210A518;
		  /* 8210A518h */ case   59:  		/* lwz R10, <#[R11]> */
		/* 8210A518h case   59:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A518h case   59:*/		return 0x8210A51C;
		  /* 8210A51Ch */ case   60:  		/* ori R10, R10, 32 */
		/* 8210A51Ch case   60:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x20);
		/* 8210A51Ch case   60:*/		return 0x8210A520;
		  /* 8210A520h */ case   61:  		/* stw R10, <#[R11]> */
		/* 8210A520h case   61:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A520h case   61:*/		return 0x8210A524;
	}
	return 0x8210A524;
} // Block from 8210A42Ch-8210A524h (62 instructions)

//////////////////////////////////////////////////////
// Block at 8210A524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A524);
		  /* 8210A524h */ case    0:  		/* lwz R6, <#[R8 + 12]> */
		/* 8210A524h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x0000000C) );
		/* 8210A524h case    0:*/		return 0x8210A528;
		  /* 8210A528h */ case    1:  		/* addi R5, R5, 1 */
		/* 8210A528h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 8210A528h case    1:*/		return 0x8210A52C;
		  /* 8210A52Ch */ case    2:  		/* addi R7, R7, 4 */
		/* 8210A52Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210A52Ch case    2:*/		return 0x8210A530;
		  /* 8210A530h */ case    3:  		/* cmplw CR6, R5, R6 */
		/* 8210A530h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 8210A530h case    3:*/		return 0x8210A534;
		  /* 8210A534h */ case    4:  		/* bc 12, CR6_LT, -116 */
		/* 8210A534h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210A4C0;  }
		/* 8210A534h case    4:*/		return 0x8210A538;
	}
	return 0x8210A538;
} // Block from 8210A524h-8210A538h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210A538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A538);
		  /* 8210A538h */ case    0:  		/* lwz R11, <#[R8]> */
		/* 8210A538h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8210A538h case    0:*/		return 0x8210A53C;
		  /* 8210A53Ch */ case    1:  		/* lis R9, 4096 */
		/* 8210A53Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 8210A53Ch case    1:*/		return 0x8210A540;
		  /* 8210A540h */ case    2:  		/* rlwinm R10, R11, 0, 0, 3 */
		/* 8210A540h case    2:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R10,regs.R11);
		/* 8210A540h case    2:*/		return 0x8210A544;
		  /* 8210A544h */ case    3:  		/* cmplw CR6, R10, R9 */
		/* 8210A544h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210A544h case    3:*/		return 0x8210A548;
		  /* 8210A548h */ case    4:  		/* bc 12, CR6_LT, 168 */
		/* 8210A548h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210A5F0;  }
		/* 8210A548h case    4:*/		return 0x8210A54C;
		  /* 8210A54Ch */ case    5:  		/* lis R9, 16384 */
		/* 8210A54Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0x4000);
		/* 8210A54Ch case    5:*/		return 0x8210A550;
		  /* 8210A550h */ case    6:  		/* cmplw CR6, R10, R9 */
		/* 8210A550h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210A550h case    6:*/		return 0x8210A554;
		  /* 8210A554h */ case    7:  		/* bc 12, CR6_GT, 156 */
		/* 8210A554h case    7:*/		if ( regs.CR[6].gt ) { return 0x8210A5F0;  }
		/* 8210A554h case    7:*/		return 0x8210A558;
		  /* 8210A558h */ case    8:  		/* lwz R10, <#[R8 + 4]> */
		/* 8210A558h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 8210A558h case    8:*/		return 0x8210A55C;
		  /* 8210A55Ch */ case    9:  		/* rlwinm R11, R11, 0, 12, 31 */
		/* 8210A55Ch case    9:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R11,regs.R11);
		/* 8210A55Ch case    9:*/		return 0x8210A560;
		  /* 8210A560h */ case   10:  		/* li R5, 0 */
		/* 8210A560h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8210A560h case   10:*/		return 0x8210A564;
		  /* 8210A564h */ case   11:  		/* divwu R28, R10, R11 */
		/* 8210A564h case   11:*/		cpu::op::divwu<0>(regs,&regs.R28,regs.R10,regs.R11);
		/* 8210A564h case   11:*/		return 0x8210A568;
		  /* 8210A568h */ case   12:  		/* twi 6, R11, 0 */
		/* 8210A568h case   12:*/		cpu::op::tw<6>(regs, 0x8210A568, regs.R11, 0x00000000);
		/* 8210A568h case   12:*/		return 0x8210A56C;
		  /* 8210A56Ch */ case   13:  		/* cmplwi CR6, R6, 0 */
		/* 8210A56Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8210A56Ch case   13:*/		return 0x8210A570;
		  /* 8210A570h */ case   14:  		/* bc 12, CR6_EQ, 412 */
		/* 8210A570h case   14:*/		if ( regs.CR[6].eq ) { return 0x8210A70C;  }
		/* 8210A570h case   14:*/		return 0x8210A574;
		  /* 8210A574h */ case   15:  		/* li R29, 0 */
		/* 8210A574h case   15:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8210A574h case   15:*/		return 0x8210A578;
		  /* 8210A578h */ case   16:  		/* li R7, 0 */
		/* 8210A578h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210A578h case   16:*/		return 0x8210A57C;
		  /* 8210A57Ch */ case   17:  		/* cmplwi CR6, R28, 0 */
		/* 8210A57Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8210A57Ch case   17:*/		return 0x8210A580;
		  /* 8210A580h */ case   18:  		/* bc 12, CR6_EQ, 88 */
		/* 8210A580h case   18:*/		if ( regs.CR[6].eq ) { return 0x8210A5D8;  }
		/* 8210A580h case   18:*/		return 0x8210A584;
		  /* 8210A584h */ case   19:  		/* lwz R31, <#[R8 + 8]> */
		/* 8210A584h case   19:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R8 + 0x00000008) );
		/* 8210A584h case   19:*/		return 0x8210A588;
		  /* 8210A588h */ case   20:  		/* mullw R11, R6, R7 */
		/* 8210A588h case   20:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R6,regs.R7);
		/* 8210A588h case   20:*/		return 0x8210A58C;
		  /* 8210A58Ch */ case   21:  		/* add R11, R11, R5 */
		/* 8210A58Ch case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8210A58Ch case   21:*/		return 0x8210A590;
		  /* 8210A590h */ case   22:  		/* mr R3, R30 */
		/* 8210A590h case   22:*/		regs.R3 = regs.R30;
		/* 8210A590h case   22:*/		return 0x8210A594;
		  /* 8210A594h */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210A594h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210A594h case   23:*/		return 0x8210A598;
		  /* 8210A598h */ case   24:  		/* lwzx R4, <#[R11 + R31]> */
		/* 8210A598h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8210A598h case   24:*/		return 0x8210A59C;
		  /* 8210A59Ch */ case   25:  		/* bl -50116 */
		/* 8210A59Ch case   25:*/		regs.LR = 0x8210A5A0; return 0x820FE1D8;
		/* 8210A59Ch case   25:*/		return 0x8210A5A0;
		  /* 8210A5A0h */ case   26:  		/* cmpwi CR0, R3, 0 */
		/* 8210A5A0h case   26:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210A5A0h case   26:*/		return 0x8210A5A4;
		  /* 8210A5A4h */ case   27:  		/* bc 4, CR0_EQ, 20 */
		/* 8210A5A4h case   27:*/		if ( !regs.CR[0].eq ) { return 0x8210A5B8;  }
		/* 8210A5A4h case   27:*/		return 0x8210A5A8;
		  /* 8210A5A8h */ case   28:  		/* addi R7, R7, 1 */
		/* 8210A5A8h case   28:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210A5A8h case   28:*/		return 0x8210A5AC;
		  /* 8210A5ACh */ case   29:  		/* cmplw CR6, R7, R28 */
		/* 8210A5ACh case   29:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R28);
		/* 8210A5ACh case   29:*/		return 0x8210A5B0;
		  /* 8210A5B0h */ case   30:  		/* bc 12, CR6_LT, -40 */
		/* 8210A5B0h case   30:*/		if ( regs.CR[6].lt ) { return 0x8210A588;  }
		/* 8210A5B0h case   30:*/		return 0x8210A5B4;
		  /* 8210A5B4h */ case   31:  		/* b 36 */
		/* 8210A5B4h case   31:*/		return 0x8210A5D8;
		/* 8210A5B4h case   31:*/		return 0x8210A5B8;
	}
	return 0x8210A5B8;
} // Block from 8210A538h-8210A5B8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8210A5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A5B8);
		  /* 8210A5B8h */ case    0:  		/* lwz R11, <#[R8 + 16]> */
		/* 8210A5B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 8210A5B8h case    0:*/		return 0x8210A5BC;
		  /* 8210A5BCh */ case    1:  		/* lwz R10, <#[R30 + 20]> */
		/* 8210A5BCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 8210A5BCh case    1:*/		return 0x8210A5C0;
		  /* 8210A5C0h */ case    2:  		/* lwzx R11, <#[R11 + R29]> */
		/* 8210A5C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8210A5C0h case    2:*/		return 0x8210A5C4;
		  /* 8210A5C4h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210A5C4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210A5C4h case    3:*/		return 0x8210A5C8;
		  /* 8210A5C8h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8210A5C8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8210A5C8h case    4:*/		return 0x8210A5CC;
		  /* 8210A5CCh */ case    5:  		/* lwz R10, <#[R11]> */
		/* 8210A5CCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A5CCh case    5:*/		return 0x8210A5D0;
		  /* 8210A5D0h */ case    6:  		/* ori R10, R10, 32 */
		/* 8210A5D0h case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x20);
		/* 8210A5D0h case    6:*/		return 0x8210A5D4;
		  /* 8210A5D4h */ case    7:  		/* stw R10, <#[R11]> */
		/* 8210A5D4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8210A5D4h case    7:*/		return 0x8210A5D8;
	}
	return 0x8210A5D8;
} // Block from 8210A5B8h-8210A5D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8210A5D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A5D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A5D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A5D8);
		  /* 8210A5D8h */ case    0:  		/* lwz R6, <#[R8 + 12]> */
		/* 8210A5D8h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x0000000C) );
		/* 8210A5D8h case    0:*/		return 0x8210A5DC;
		  /* 8210A5DCh */ case    1:  		/* addi R5, R5, 1 */
		/* 8210A5DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 8210A5DCh case    1:*/		return 0x8210A5E0;
		  /* 8210A5E0h */ case    2:  		/* addi R29, R29, 4 */
		/* 8210A5E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8210A5E0h case    2:*/		return 0x8210A5E4;
		  /* 8210A5E4h */ case    3:  		/* cmplw CR6, R5, R6 */
		/* 8210A5E4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 8210A5E4h case    3:*/		return 0x8210A5E8;
		  /* 8210A5E8h */ case    4:  		/* bc 12, CR6_LT, -112 */
		/* 8210A5E8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210A578;  }
		/* 8210A5E8h case    4:*/		return 0x8210A5EC;
		  /* 8210A5ECh */ case    5:  		/* b 288 */
		/* 8210A5ECh case    5:*/		return 0x8210A70C;
		/* 8210A5ECh case    5:*/		return 0x8210A5F0;
	}
	return 0x8210A5F0;
} // Block from 8210A5D8h-8210A5F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210A5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A5F0);
		  /* 8210A5F0h */ case    0:  		/* lwz R29, <#[R8 + 4]> */
		/* 8210A5F0h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R8 + 0x00000004) );
		/* 8210A5F0h case    0:*/		return 0x8210A5F4;
		  /* 8210A5F4h */ case    1:  		/* li R5, 0 */
		/* 8210A5F4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8210A5F4h case    1:*/		return 0x8210A5F8;
		  /* 8210A5F8h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 8210A5F8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8210A5F8h case    2:*/		return 0x8210A5FC;
		  /* 8210A5FCh */ case    3:  		/* bc 12, CR6_EQ, 272 */
		/* 8210A5FCh case    3:*/		if ( regs.CR[6].eq ) { return 0x8210A70C;  }
		/* 8210A5FCh case    3:*/		return 0x8210A600;
		  /* 8210A600h */ case    4:  		/* lwz R31, <#[R8 + 8]> */
		/* 8210A600h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R8 + 0x00000008) );
		/* 8210A600h case    4:*/		return 0x8210A604;
		  /* 8210A604h */ case    5:  		/* li R7, 0 */
		/* 8210A604h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8210A604h case    5:*/		return 0x8210A608;
		  /* 8210A608h */ case    6:  		/* mr R3, R30 */
		/* 8210A608h case    6:*/		regs.R3 = regs.R30;
		/* 8210A608h case    6:*/		return 0x8210A60C;
		  /* 8210A60Ch */ case    7:  		/* lwzx R4, <#[R7 + R31]> */
		/* 8210A60Ch case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R7 + regs.R31 + 0x00000000) );
		/* 8210A60Ch case    7:*/		return 0x8210A610;
		  /* 8210A610h */ case    8:  		/* bl -50232 */
		/* 8210A610h case    8:*/		regs.LR = 0x8210A614; return 0x820FE1D8;
		/* 8210A610h case    8:*/		return 0x8210A614;
		  /* 8210A614h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 8210A614h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210A614h case    9:*/		return 0x8210A618;
		  /* 8210A618h */ case   10:  		/* bc 4, CR0_EQ, 24 */
		/* 8210A618h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8210A630;  }
		/* 8210A618h case   10:*/		return 0x8210A61C;
		  /* 8210A61Ch */ case   11:  		/* addi R5, R5, 1 */
		/* 8210A61Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 8210A61Ch case   11:*/		return 0x8210A620;
		  /* 8210A620h */ case   12:  		/* addi R7, R7, 4 */
		/* 8210A620h case   12:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210A620h case   12:*/		return 0x8210A624;
		  /* 8210A624h */ case   13:  		/* cmplw CR6, R5, R29 */
		/* 8210A624h case   13:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R29);
		/* 8210A624h case   13:*/		return 0x8210A628;
		  /* 8210A628h */ case   14:  		/* bc 12, CR6_LT, -32 */
		/* 8210A628h case   14:*/		if ( regs.CR[6].lt ) { return 0x8210A608;  }
		/* 8210A628h case   14:*/		return 0x8210A62C;
		  /* 8210A62Ch */ case   15:  		/* b 224 */
		/* 8210A62Ch case   15:*/		return 0x8210A70C;
		/* 8210A62Ch case   15:*/		return 0x8210A630;
	}
	return 0x8210A630;
} // Block from 8210A5F0h-8210A630h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210A630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A630);
		  /* 8210A630h */ case    0:  		/* li R10, 0 */
		/* 8210A630h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210A630h case    0:*/		return 0x8210A634;
		  /* 8210A634h */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 8210A634h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8210A634h case    1:*/		return 0x8210A638;
		  /* 8210A638h */ case    2:  		/* bc 12, CR6_EQ, 212 */
		/* 8210A638h case    2:*/		if ( regs.CR[6].eq ) { return 0x8210A70C;  }
		/* 8210A638h case    2:*/		return 0x8210A63C;
		  /* 8210A63Ch */ case    3:  		/* li R11, 0 */
		/* 8210A63Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210A63Ch case    3:*/		return 0x8210A640;
		  /* 8210A640h */ case    4:  		/* lwz R9, <#[R8 + 16]> */
		/* 8210A640h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000010) );
		/* 8210A640h case    4:*/		return 0x8210A644;
		  /* 8210A644h */ case    5:  		/* addi R10, R10, 1 */
		/* 8210A644h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210A644h case    5:*/		return 0x8210A648;
		  /* 8210A648h */ case    6:  		/* lwz R7, <#[R30 + 20]> */
		/* 8210A648h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000014) );
		/* 8210A648h case    6:*/		return 0x8210A64C;
		  /* 8210A64Ch */ case    7:  		/* lwzx R9, <#[R11 + R9]> */
		/* 8210A64Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210A64Ch case    7:*/		return 0x8210A650;
		  /* 8210A650h */ case    8:  		/* addi R11, R11, 4 */
		/* 8210A650h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210A650h case    8:*/		return 0x8210A654;
		  /* 8210A654h */ case    9:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210A654h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210A654h case    9:*/		return 0x8210A658;
		  /* 8210A658h */ case   10:  		/* lwzx R9, <#[R9 + R7]> */
		/* 8210A658h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 8210A658h case   10:*/		return 0x8210A65C;
		  /* 8210A65Ch */ case   11:  		/* lwz R7, <#[R9]> */
		/* 8210A65Ch case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8210A65Ch case   11:*/		return 0x8210A660;
		  /* 8210A660h */ case   12:  		/* ori R7, R7, 32 */
		/* 8210A660h case   12:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x20);
		/* 8210A660h case   12:*/		return 0x8210A664;
		  /* 8210A664h */ case   13:  		/* stw R7, <#[R9]> */
		/* 8210A664h case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8210A664h case   13:*/		return 0x8210A668;
		  /* 8210A668h */ case   14:  		/* lwz R9, <#[R8 + 12]> */
		/* 8210A668h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x0000000C) );
		/* 8210A668h case   14:*/		return 0x8210A66C;
		  /* 8210A66Ch */ case   15:  		/* cmplw CR6, R10, R9 */
		/* 8210A66Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210A66Ch case   15:*/		return 0x8210A670;
		  /* 8210A670h */ case   16:  		/* bc 12, CR6_LT, -48 */
		/* 8210A670h case   16:*/		if ( regs.CR[6].lt ) { return 0x8210A640;  }
		/* 8210A670h case   16:*/		return 0x8210A674;
		  /* 8210A674h */ case   17:  		/* b 152 */
		/* 8210A674h case   17:*/		return 0x8210A70C;
		/* 8210A674h case   17:*/		return 0x8210A678;
	}
	return 0x8210A678;
} // Block from 8210A630h-8210A678h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8210A678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A678);
		  /* 8210A678h */ case    0:  		/* lwz R11, <#[R8 + 12]> */
		/* 8210A678h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000000C) );
		/* 8210A678h case    0:*/		return 0x8210A67C;
		  /* 8210A67Ch */ case    1:  		/* li R10, 0 */
		/* 8210A67Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210A67Ch case    1:*/		return 0x8210A680;
		  /* 8210A680h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210A680h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A680h case    2:*/		return 0x8210A684;
		  /* 8210A684h */ case    3:  		/* bc 4, CR6_GT, 136 */
		/* 8210A684h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210A70C;  }
		/* 8210A684h case    3:*/		return 0x8210A688;
		  /* 8210A688h */ case    4:  		/* li R11, 0 */
		/* 8210A688h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210A688h case    4:*/		return 0x8210A68C;
		  /* 8210A68Ch */ case    5:  		/* lwz R9, <#[R8 + 16]> */
		/* 8210A68Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000010) );
		/* 8210A68Ch case    5:*/		return 0x8210A690;
		  /* 8210A690h */ case    6:  		/* addi R10, R10, 1 */
		/* 8210A690h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210A690h case    6:*/		return 0x8210A694;
		  /* 8210A694h */ case    7:  		/* lwz R7, <#[R30 + 20]> */
		/* 8210A694h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000014) );
		/* 8210A694h case    7:*/		return 0x8210A698;
		  /* 8210A698h */ case    8:  		/* lwzx R9, <#[R11 + R9]> */
		/* 8210A698h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210A698h case    8:*/		return 0x8210A69C;
		  /* 8210A69Ch */ case    9:  		/* addi R11, R11, 4 */
		/* 8210A69Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210A69Ch case    9:*/		return 0x8210A6A0;
		  /* 8210A6A0h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210A6A0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210A6A0h case   10:*/		return 0x8210A6A4;
		  /* 8210A6A4h */ case   11:  		/* lwzx R9, <#[R9 + R7]> */
		/* 8210A6A4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 8210A6A4h case   11:*/		return 0x8210A6A8;
		  /* 8210A6A8h */ case   12:  		/* lwz R7, <#[R9]> */
		/* 8210A6A8h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8210A6A8h case   12:*/		return 0x8210A6AC;
		  /* 8210A6ACh */ case   13:  		/* ori R7, R7, 32 */
		/* 8210A6ACh case   13:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x20);
		/* 8210A6ACh case   13:*/		return 0x8210A6B0;
		  /* 8210A6B0h */ case   14:  		/* stw R7, <#[R9]> */
		/* 8210A6B0h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8210A6B0h case   14:*/		return 0x8210A6B4;
		  /* 8210A6B4h */ case   15:  		/* lwz R9, <#[R8 + 12]> */
		/* 8210A6B4h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x0000000C) );
		/* 8210A6B4h case   15:*/		return 0x8210A6B8;
		  /* 8210A6B8h */ case   16:  		/* cmplw CR6, R10, R9 */
		/* 8210A6B8h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210A6B8h case   16:*/		return 0x8210A6BC;
		  /* 8210A6BCh */ case   17:  		/* bc 12, CR6_LT, -48 */
		/* 8210A6BCh case   17:*/		if ( regs.CR[6].lt ) { return 0x8210A68C;  }
		/* 8210A6BCh case   17:*/		return 0x8210A6C0;
		  /* 8210A6C0h */ case   18:  		/* b 76 */
		/* 8210A6C0h case   18:*/		return 0x8210A70C;
		/* 8210A6C0h case   18:*/		return 0x8210A6C4;
	}
	return 0x8210A6C4;
} // Block from 8210A678h-8210A6C4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8210A6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A6C4);
		  /* 8210A6C4h */ case    0:  		/* lwz R11, <#[R8 + 12]> */
		/* 8210A6C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000000C) );
		/* 8210A6C4h case    0:*/		return 0x8210A6C8;
		  /* 8210A6C8h */ case    1:  		/* li R10, 0 */
		/* 8210A6C8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8210A6C8h case    1:*/		return 0x8210A6CC;
		  /* 8210A6CCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210A6CCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A6CCh case    2:*/		return 0x8210A6D0;
		  /* 8210A6D0h */ case    3:  		/* bc 4, CR6_GT, 60 */
		/* 8210A6D0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210A70C;  }
		/* 8210A6D0h case    3:*/		return 0x8210A6D4;
		  /* 8210A6D4h */ case    4:  		/* li R11, 0 */
		/* 8210A6D4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210A6D4h case    4:*/		return 0x8210A6D8;
		  /* 8210A6D8h */ case    5:  		/* lwz R9, <#[R8 + 16]> */
		/* 8210A6D8h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000010) );
		/* 8210A6D8h case    5:*/		return 0x8210A6DC;
		  /* 8210A6DCh */ case    6:  		/* addi R10, R10, 1 */
		/* 8210A6DCh case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210A6DCh case    6:*/		return 0x8210A6E0;
		  /* 8210A6E0h */ case    7:  		/* lwz R7, <#[R30 + 20]> */
		/* 8210A6E0h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000014) );
		/* 8210A6E0h case    7:*/		return 0x8210A6E4;
		  /* 8210A6E4h */ case    8:  		/* lwzx R9, <#[R11 + R9]> */
		/* 8210A6E4h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210A6E4h case    8:*/		return 0x8210A6E8;
		  /* 8210A6E8h */ case    9:  		/* addi R11, R11, 4 */
		/* 8210A6E8h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210A6E8h case    9:*/		return 0x8210A6EC;
		  /* 8210A6ECh */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210A6ECh case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210A6ECh case   10:*/		return 0x8210A6F0;
		  /* 8210A6F0h */ case   11:  		/* lwzx R9, <#[R9 + R7]> */
		/* 8210A6F0h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 8210A6F0h case   11:*/		return 0x8210A6F4;
		  /* 8210A6F4h */ case   12:  		/* lwz R7, <#[R9]> */
		/* 8210A6F4h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8210A6F4h case   12:*/		return 0x8210A6F8;
		  /* 8210A6F8h */ case   13:  		/* ori R7, R7, 32 */
		/* 8210A6F8h case   13:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x20);
		/* 8210A6F8h case   13:*/		return 0x8210A6FC;
		  /* 8210A6FCh */ case   14:  		/* stw R7, <#[R9]> */
		/* 8210A6FCh case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8210A6FCh case   14:*/		return 0x8210A700;
		  /* 8210A700h */ case   15:  		/* lwz R9, <#[R8 + 12]> */
		/* 8210A700h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x0000000C) );
		/* 8210A700h case   15:*/		return 0x8210A704;
		  /* 8210A704h */ case   16:  		/* cmplw CR6, R10, R9 */
		/* 8210A704h case   16:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210A704h case   16:*/		return 0x8210A708;
		  /* 8210A708h */ case   17:  		/* bc 12, CR6_LT, -48 */
		/* 8210A708h case   17:*/		if ( regs.CR[6].lt ) { return 0x8210A6D8;  }
		/* 8210A708h case   17:*/		return 0x8210A70C;
	}
	return 0x8210A70C;
} // Block from 8210A6C4h-8210A70Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8210A70Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A70C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A70C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A70C);
		  /* 8210A70Ch */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 8210A70Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8210A70Ch case    0:*/		return 0x8210A710;
		  /* 8210A710h */ case    1:  		/* addi R26, R26, 1 */
		/* 8210A710h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8210A710h case    1:*/		return 0x8210A714;
		  /* 8210A714h */ case    2:  		/* addi R27, R27, 4 */
		/* 8210A714h case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8210A714h case    2:*/		return 0x8210A718;
		  /* 8210A718h */ case    3:  		/* cmplw CR6, R26, R11 */
		/* 8210A718h case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 8210A718h case    3:*/		return 0x8210A71C;
		  /* 8210A71Ch */ case    4:  		/* bc 12, CR6_LT, -732 */
		/* 8210A71Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8210A440;  }
		/* 8210A71Ch case    4:*/		return 0x8210A720;
	}
	return 0x8210A720;
} // Block from 8210A70Ch-8210A720h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210A720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A720);
		  /* 8210A720h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210A720h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210A720h case    0:*/		return 0x8210A724;
		  /* 8210A724h */ case    1:  		/* li R9, 0 */
		/* 8210A724h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8210A724h case    1:*/		return 0x8210A728;
		  /* 8210A728h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210A728h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A728h case    2:*/		return 0x8210A72C;
		  /* 8210A72Ch */ case    3:  		/* bc 4, CR6_GT, 76 */
		/* 8210A72Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210A778;  }
		/* 8210A72Ch case    3:*/		return 0x8210A730;
		  /* 8210A730h */ case    4:  		/* li R11, 0 */
		/* 8210A730h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8210A730h case    4:*/		return 0x8210A734;
		  /* 8210A734h */ case    5:  		/* lwz R10, <#[R30 + 20]> */
		/* 8210A734h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 8210A734h case    5:*/		return 0x8210A738;
		  /* 8210A738h */ case    6:  		/* lwz R8, <#[R30 + 16]> */
		/* 8210A738h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000010) );
		/* 8210A738h case    6:*/		return 0x8210A73C;
		  /* 8210A73Ch */ case    7:  		/* lwzx R10, <#[R10 + R11]> */
		/* 8210A73Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210A73Ch case    7:*/		return 0x8210A740;
		  /* 8210A740h */ case    8:  		/* lwz R7, <#[R10 + 4]> */
		/* 8210A740h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8210A740h case    8:*/		return 0x8210A744;
		  /* 8210A744h */ case    9:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8210A744h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8210A744h case    9:*/		return 0x8210A748;
		  /* 8210A748h */ case   10:  		/* lwzx R8, <#[R7 + R8]> */
		/* 8210A748h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8210A748h case   10:*/		return 0x8210A74C;
		  /* 8210A74Ch */ case   11:  		/* lwz R8, <#[R8 + 4]> */
		/* 8210A74Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 8210A74Ch case   11:*/		return 0x8210A750;
		  /* 8210A750h */ case   12:  		/* rlwinm. R8, R8, 0, 26, 26 */
		/* 8210A750h case   12:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R8,regs.R8);
		/* 8210A750h case   12:*/		return 0x8210A754;
		  /* 8210A754h */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 8210A754h case   13:*/		if ( regs.CR[0].eq ) { return 0x8210A764;  }
		/* 8210A754h case   13:*/		return 0x8210A758;
		  /* 8210A758h */ case   14:  		/* lwz R8, <#[R10]> */
		/* 8210A758h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8210A758h case   14:*/		return 0x8210A75C;
		  /* 8210A75Ch */ case   15:  		/* ori R8, R8, 32 */
		/* 8210A75Ch case   15:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x20);
		/* 8210A75Ch case   15:*/		return 0x8210A760;
		  /* 8210A760h */ case   16:  		/* stw R8, <#[R10]> */
		/* 8210A760h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8210A760h case   16:*/		return 0x8210A764;
	}
	return 0x8210A764;
} // Block from 8210A720h-8210A764h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8210A764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A764);
		  /* 8210A764h */ case    0:  		/* lwz R10, <#[R30 + 8]> */
		/* 8210A764h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8210A764h case    0:*/		return 0x8210A768;
		  /* 8210A768h */ case    1:  		/* addi R9, R9, 1 */
		/* 8210A768h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210A768h case    1:*/		return 0x8210A76C;
		  /* 8210A76Ch */ case    2:  		/* addi R11, R11, 4 */
		/* 8210A76Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210A76Ch case    2:*/		return 0x8210A770;
		  /* 8210A770h */ case    3:  		/* cmplw CR6, R9, R10 */
		/* 8210A770h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8210A770h case    3:*/		return 0x8210A774;
		  /* 8210A774h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 8210A774h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210A734;  }
		/* 8210A774h case    4:*/		return 0x8210A778;
	}
	return 0x8210A778;
} // Block from 8210A764h-8210A778h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210A778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A778);
		  /* 8210A778h */ case    0:  		/* li R3, 0 */
		/* 8210A778h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210A778h case    0:*/		return 0x8210A77C;
		  /* 8210A77Ch */ case    1:  		/* addi R1, R1, 144 */
		/* 8210A77Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8210A77Ch case    1:*/		return 0x8210A780;
		  /* 8210A780h */ case    2:  		/* b -496864 */
		/* 8210A780h case    2:*/		return 0x820912A0;
		/* 8210A780h case    2:*/		return 0x8210A784;
		  /* 8210A784h */ case    3:  		/* nop */
		/* 8210A784h case    3:*/		cpu::op::nop();
		/* 8210A784h case    3:*/		return 0x8210A788;
	}
	return 0x8210A788;
} // Block from 8210A778h-8210A788h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8210A788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A788);
		  /* 8210A788h */ case    0:  		/* mfspr R12, LR */
		/* 8210A788h case    0:*/		regs.R12 = regs.LR;
		/* 8210A788h case    0:*/		return 0x8210A78C;
		  /* 8210A78Ch */ case    1:  		/* bl -496968 */
		/* 8210A78Ch case    1:*/		regs.LR = 0x8210A790; return 0x82091244;
		/* 8210A78Ch case    1:*/		return 0x8210A790;
		  /* 8210A790h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8210A790h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8210A790h case    2:*/		return 0x8210A794;
		  /* 8210A794h */ case    3:  		/* mr R31, R3 */
		/* 8210A794h case    3:*/		regs.R31 = regs.R3;
		/* 8210A794h case    3:*/		return 0x8210A798;
		  /* 8210A798h */ case    4:  		/* bl -19456 */
		/* 8210A798h case    4:*/		regs.LR = 0x8210A79C; return 0x82105B98;
		/* 8210A798h case    4:*/		return 0x8210A79C;
		  /* 8210A79Ch */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210A79Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210A79Ch case    5:*/		return 0x8210A7A0;
		  /* 8210A7A0h */ case    6:  		/* li R23, 0 */
		/* 8210A7A0h case    6:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 8210A7A0h case    6:*/		return 0x8210A7A4;
		  /* 8210A7A4h */ case    7:  		/* mr R9, R23 */
		/* 8210A7A4h case    7:*/		regs.R9 = regs.R23;
		/* 8210A7A4h case    7:*/		return 0x8210A7A8;
		  /* 8210A7A8h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8210A7A8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A7A8h case    8:*/		return 0x8210A7AC;
		  /* 8210A7ACh */ case    9:  		/* bc 4, CR6_GT, 80 */
		/* 8210A7ACh case    9:*/		if ( !regs.CR[6].gt ) { return 0x8210A7FC;  }
		/* 8210A7ACh case    9:*/		return 0x8210A7B0;
		  /* 8210A7B0h */ case   10:  		/* mr R10, R23 */
		/* 8210A7B0h case   10:*/		regs.R10 = regs.R23;
		/* 8210A7B0h case   10:*/		return 0x8210A7B4;
		  /* 8210A7B4h */ case   11:  		/* li R8, -1 */
		/* 8210A7B4h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 8210A7B4h case   11:*/		return 0x8210A7B8;
		  /* 8210A7B8h */ case   12:  		/* lwz R11, <#[R31 + 20]> */
		/* 8210A7B8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8210A7B8h case   12:*/		return 0x8210A7BC;
		  /* 8210A7BCh */ case   13:  		/* lwz R7, <#[R31 + 16]> */
		/* 8210A7BCh case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000010) );
		/* 8210A7BCh case   13:*/		return 0x8210A7C0;
		  /* 8210A7C0h */ case   14:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8210A7C0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210A7C0h case   14:*/		return 0x8210A7C4;
		  /* 8210A7C4h */ case   15:  		/* lwz R6, <#[R11 + 4]> */
		/* 8210A7C4h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8210A7C4h case   15:*/		return 0x8210A7C8;
		  /* 8210A7C8h */ case   16:  		/* rlwinm R6, R6, 2, 0, 29 */
		/* 8210A7C8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R6);
		/* 8210A7C8h case   16:*/		return 0x8210A7CC;
		  /* 8210A7CCh */ case   17:  		/* lwzx R7, <#[R6 + R7]> */
		/* 8210A7CCh case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 8210A7CCh case   17:*/		return 0x8210A7D0;
		  /* 8210A7D0h */ case   18:  		/* stw R23, <#[R11 + 64]> */
		/* 8210A7D0h case   18:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000040) );
		/* 8210A7D0h case   18:*/		return 0x8210A7D4;
		  /* 8210A7D4h */ case   19:  		/* lwz R7, <#[R7 + 4]> */
		/* 8210A7D4h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 8210A7D4h case   19:*/		return 0x8210A7D8;
		  /* 8210A7D8h */ case   20:  		/* rlwinm. R7, R7, 0, 25, 25 */
		/* 8210A7D8h case   20:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R7,regs.R7);
		/* 8210A7D8h case   20:*/		return 0x8210A7DC;
		  /* 8210A7DCh */ case   21:  		/* bc 4, CR0_EQ, 12 */
		/* 8210A7DCh case   21:*/		if ( !regs.CR[0].eq ) { return 0x8210A7E8;  }
		/* 8210A7DCh case   21:*/		return 0x8210A7E0;
		  /* 8210A7E0h */ case   22:  		/* stw R8, <#[R11 + 12]> */
		/* 8210A7E0h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210A7E0h case   22:*/		return 0x8210A7E4;
		  /* 8210A7E4h */ case   23:  		/* stw R8, <#[R11 + 16]> */
		/* 8210A7E4h case   23:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 8210A7E4h case   23:*/		return 0x8210A7E8;
	}
	return 0x8210A7E8;
} // Block from 8210A788h-8210A7E8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8210A7E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A7E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A7E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A7E8);
		  /* 8210A7E8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8210A7E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8210A7E8h case    0:*/		return 0x8210A7EC;
		  /* 8210A7ECh */ case    1:  		/* addi R9, R9, 1 */
		/* 8210A7ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210A7ECh case    1:*/		return 0x8210A7F0;
		  /* 8210A7F0h */ case    2:  		/* addi R10, R10, 4 */
		/* 8210A7F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210A7F0h case    2:*/		return 0x8210A7F4;
		  /* 8210A7F4h */ case    3:  		/* cmplw CR6, R9, R11 */
		/* 8210A7F4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8210A7F4h case    3:*/		return 0x8210A7F8;
		  /* 8210A7F8h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 8210A7F8h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210A7B8;  }
		/* 8210A7F8h case    4:*/		return 0x8210A7FC;
	}
	return 0x8210A7FC;
} // Block from 8210A7E8h-8210A7FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210A7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A7FC);
		  /* 8210A7FCh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210A7FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210A7FCh case    0:*/		return 0x8210A800;
		  /* 8210A800h */ case    1:  		/* mr R10, R23 */
		/* 8210A800h case    1:*/		regs.R10 = regs.R23;
		/* 8210A800h case    1:*/		return 0x8210A804;
		  /* 8210A804h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210A804h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A804h case    2:*/		return 0x8210A808;
		  /* 8210A808h */ case    3:  		/* bc 4, CR6_GT, 52 */
		/* 8210A808h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210A83C;  }
		/* 8210A808h case    3:*/		return 0x8210A80C;
		  /* 8210A80Ch */ case    4:  		/* mr R11, R23 */
		/* 8210A80Ch case    4:*/		regs.R11 = regs.R23;
		/* 8210A80Ch case    4:*/		return 0x8210A810;
		  /* 8210A810h */ case    5:  		/* lwz R9, <#[R31 + 24]> */
		/* 8210A810h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8210A810h case    5:*/		return 0x8210A814;
		  /* 8210A814h */ case    6:  		/* addi R10, R10, 1 */
		/* 8210A814h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210A814h case    6:*/		return 0x8210A818;
		  /* 8210A818h */ case    7:  		/* lwzx R9, <#[R11 + R9]> */
		/* 8210A818h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210A818h case    7:*/		return 0x8210A81C;
		  /* 8210A81Ch */ case    8:  		/* stw R23, <#[R9 + 36]> */
		/* 8210A81Ch case    8:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R9 + 0x00000024) );
		/* 8210A81Ch case    8:*/		return 0x8210A820;
		  /* 8210A820h */ case    9:  		/* lwz R9, <#[R31 + 24]> */
		/* 8210A820h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8210A820h case    9:*/		return 0x8210A824;
		  /* 8210A824h */ case   10:  		/* lwzx R9, <#[R11 + R9]> */
		/* 8210A824h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210A824h case   10:*/		return 0x8210A828;
		  /* 8210A828h */ case   11:  		/* addi R11, R11, 4 */
		/* 8210A828h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210A828h case   11:*/		return 0x8210A82C;
		  /* 8210A82Ch */ case   12:  		/* stw R23, <#[R9 + 40]> */
		/* 8210A82Ch case   12:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R9 + 0x00000028) );
		/* 8210A82Ch case   12:*/		return 0x8210A830;
		  /* 8210A830h */ case   13:  		/* lwz R9, <#[R31 + 12]> */
		/* 8210A830h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210A830h case   13:*/		return 0x8210A834;
		  /* 8210A834h */ case   14:  		/* cmplw CR6, R10, R9 */
		/* 8210A834h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8210A834h case   14:*/		return 0x8210A838;
		  /* 8210A838h */ case   15:  		/* bc 12, CR6_LT, -40 */
		/* 8210A838h case   15:*/		if ( regs.CR[6].lt ) { return 0x8210A810;  }
		/* 8210A838h case   15:*/		return 0x8210A83C;
	}
	return 0x8210A83C;
} // Block from 8210A7FCh-8210A83Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8210A83Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A83C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A83C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A83C);
		  /* 8210A83Ch */ case    0:  		/* mr R3, R31 */
		/* 8210A83Ch case    0:*/		regs.R3 = regs.R31;
		/* 8210A83Ch case    0:*/		return 0x8210A840;
		  /* 8210A840h */ case    1:  		/* bl -19624 */
		/* 8210A840h case    1:*/		regs.LR = 0x8210A844; return 0x82105B98;
		/* 8210A840h case    1:*/		return 0x8210A844;
		  /* 8210A844h */ case    2:  		/* lwz R24, <#[R31 + 12]> */
		/* 8210A844h case    2:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210A844h case    2:*/		return 0x8210A848;
		  /* 8210A848h */ case    3:  		/* mr R25, R24 */
		/* 8210A848h case    3:*/		regs.R25 = regs.R24;
		/* 8210A848h case    3:*/		return 0x8210A84C;
		  /* 8210A84Ch */ case    4:  		/* cmplwi CR0, R24, 0 */
		/* 8210A84Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R24,0x00000000);
		/* 8210A84Ch case    4:*/		return 0x8210A850;
		  /* 8210A850h */ case    5:  		/* bc 12, CR0_EQ, 252 */
		/* 8210A850h case    5:*/		if ( regs.CR[0].eq ) { return 0x8210A94C;  }
		/* 8210A850h case    5:*/		return 0x8210A854;
		  /* 8210A854h */ case    6:  		/* rlwinm R26, R24, 2, 0, 29 */
		/* 8210A854h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R24);
		/* 8210A854h case    6:*/		return 0x8210A858;
		  /* 8210A858h */ case    7:  		/* lwz R11, <#[R31 + 24]> */
		/* 8210A858h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8210A858h case    7:*/		return 0x8210A85C;
		  /* 8210A85Ch */ case    8:  		/* addi R26, R26, -4 */
		/* 8210A85Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0xFFFFFFFC);
		/* 8210A85Ch case    8:*/		return 0x8210A860;
		  /* 8210A860h */ case    9:  		/* addi R25, R25, -1 */
		/* 8210A860h case    9:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xFFFFFFFF);
		/* 8210A860h case    9:*/		return 0x8210A864;
		  /* 8210A864h */ case   10:  		/* lwzx R4, <#[R26 + R11]> */
		/* 8210A864h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 8210A864h case   10:*/		return 0x8210A868;
		  /* 8210A868h */ case   11:  		/* lwz R11, <#[R4]> */
		/* 8210A868h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8210A868h case   11:*/		return 0x8210A86C;
		  /* 8210A86Ch */ case   12:  		/* rlwinm. R10, R11, 0, 0, 11 */
		/* 8210A86Ch case   12:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R10,regs.R11);
		/* 8210A86Ch case   12:*/		return 0x8210A870;
		  /* 8210A870h */ case   13:  		/* bc 12, CR0_EQ, 212 */
		/* 8210A870h case   13:*/		if ( regs.CR[0].eq ) { return 0x8210A944;  }
		/* 8210A870h case   13:*/		return 0x8210A874;
		  /* 8210A874h */ case   14:  		/* rlwinm R11, R11, 0, 0, 3 */
		/* 8210A874h case   14:*/		cpu::op::rlwinm<0,0,0,3>(regs,&regs.R11,regs.R11);
		/* 8210A874h case   14:*/		return 0x8210A878;
		  /* 8210A878h */ case   15:  		/* lwz R27, <#[R31 + 12]> */
		/* 8210A878h case   15:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210A878h case   15:*/		return 0x8210A87C;
		  /* 8210A87Ch */ case   16:  		/* lis R9, 4096 */
		/* 8210A87Ch case   16:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 8210A87Ch case   16:*/		return 0x8210A880;
		  /* 8210A880h */ case   17:  		/* cmplw CR6, R11, R9 */
		/* 8210A880h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210A880h case   17:*/		return 0x8210A884;
		  /* 8210A884h */ case   18:  		/* bc 12, CR6_LT, 28 */
		/* 8210A884h case   18:*/		if ( regs.CR[6].lt ) { return 0x8210A8A0;  }
		/* 8210A884h case   18:*/		return 0x8210A888;
		  /* 8210A888h */ case   19:  		/* lis R9, 16384 */
		/* 8210A888h case   19:*/		cpu::op::lis<0>(regs,&regs.R9,0x4000);
		/* 8210A888h case   19:*/		return 0x8210A88C;
		  /* 8210A88Ch */ case   20:  		/* cmplw CR6, R11, R9 */
		/* 8210A88Ch case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8210A88Ch case   20:*/		return 0x8210A890;
		  /* 8210A890h */ case   21:  		/* bc 12, CR6_GT, 16 */
		/* 8210A890h case   21:*/		if ( regs.CR[6].gt ) { return 0x8210A8A0;  }
		/* 8210A890h case   21:*/		return 0x8210A894;
		  /* 8210A894h */ case   22:  		/* mr R3, R31 */
		/* 8210A894h case   22:*/		regs.R3 = regs.R31;
		/* 8210A894h case   22:*/		return 0x8210A898;
		  /* 8210A898h */ case   23:  		/* bl -24304 */
		/* 8210A898h case   23:*/		regs.LR = 0x8210A89C; return 0x821049A8;
		/* 8210A898h case   23:*/		return 0x8210A89C;
		  /* 8210A89Ch */ case   24:  		/* b 32 */
		/* 8210A89Ch case   24:*/		return 0x8210A8BC;
		/* 8210A89Ch case   24:*/		return 0x8210A8A0;
	}
	return 0x8210A8A0;
} // Block from 8210A83Ch-8210A8A0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8210A8A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A8A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A8A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A8A0);
		  /* 8210A8A0h */ case    0:  		/* lis R11, 20480 */
		/* 8210A8A0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x5000);
		/* 8210A8A0h case    0:*/		return 0x8210A8A4;
		  /* 8210A8A4h */ case    1:  		/* mr R3, R31 */
		/* 8210A8A4h case    1:*/		regs.R3 = regs.R31;
		/* 8210A8A4h case    1:*/		return 0x8210A8A8;
		  /* 8210A8A8h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8210A8A8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8210A8A8h case    2:*/		return 0x8210A8AC;
		  /* 8210A8ACh */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8210A8ACh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8210A8B8;  }
		/* 8210A8ACh case    3:*/		return 0x8210A8B0;
		  /* 8210A8B0h */ case    4:  		/* bl -47088 */
		/* 8210A8B0h case    4:*/		regs.LR = 0x8210A8B4; return 0x820FF0C0;
		/* 8210A8B0h case    4:*/		return 0x8210A8B4;
		  /* 8210A8B4h */ case    5:  		/* b 8 */
		/* 8210A8B4h case    5:*/		return 0x8210A8BC;
		/* 8210A8B4h case    5:*/		return 0x8210A8B8;
	}
	return 0x8210A8B8;
} // Block from 8210A8A0h-8210A8B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210A8B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A8B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A8B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A8B8);
		  /* 8210A8B8h */ case    0:  		/* bl -22960 */
		/* 8210A8B8h case    0:*/		regs.LR = 0x8210A8BC; return 0x82104F08;
		/* 8210A8B8h case    0:*/		return 0x8210A8BC;
	}
	return 0x8210A8BC;
} // Block from 8210A8B8h-8210A8BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210A8BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A8BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A8BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A8BC);
		  /* 8210A8BCh */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 8210A8BCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210A8BCh case    0:*/		return 0x8210A8C0;
		  /* 8210A8C0h */ case    1:  		/* bc 12, CR0_LT, 564 */
		/* 8210A8C0h case    1:*/		if ( regs.CR[0].lt ) { return 0x8210AAF4;  }
		/* 8210A8C0h case    1:*/		return 0x8210A8C4;
		  /* 8210A8C4h */ case    2:  		/* lwz R30, <#[R31 + 12]> */
		/* 8210A8C4h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210A8C4h case    2:*/		return 0x8210A8C8;
		  /* 8210A8C8h */ case    3:  		/* mr R28, R27 */
		/* 8210A8C8h case    3:*/		regs.R28 = regs.R27;
		/* 8210A8C8h case    3:*/		return 0x8210A8CC;
		  /* 8210A8CCh */ case    4:  		/* cmplw CR6, R27, R30 */
		/* 8210A8CCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R30);
		/* 8210A8CCh case    4:*/		return 0x8210A8D0;
		  /* 8210A8D0h */ case    5:  		/* bc 4, CR6_LT, 48 */
		/* 8210A8D0h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8210A900;  }
		/* 8210A8D0h case    5:*/		return 0x8210A8D4;
		  /* 8210A8D4h */ case    6:  		/* rlwinm R29, R27, 2, 0, 29 */
		/* 8210A8D4h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R27);
		/* 8210A8D4h case    6:*/		return 0x8210A8D8;
		  /* 8210A8D8h */ case    7:  		/* lwz R11, <#[R31 + 24]> */
		/* 8210A8D8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8210A8D8h case    7:*/		return 0x8210A8DC;
		  /* 8210A8DCh */ case    8:  		/* mr R3, R31 */
		/* 8210A8DCh case    8:*/		regs.R3 = regs.R31;
		/* 8210A8DCh case    8:*/		return 0x8210A8E0;
		  /* 8210A8E0h */ case    9:  		/* lwzx R4, <#[R29 + R11]> */
		/* 8210A8E0h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8210A8E0h case    9:*/		return 0x8210A8E4;
		  /* 8210A8E4h */ case   10:  		/* bl -22460 */
		/* 8210A8E4h case   10:*/		regs.LR = 0x8210A8E8; return 0x82105128;
		/* 8210A8E4h case   10:*/		return 0x8210A8E8;
		  /* 8210A8E8h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 8210A8E8h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210A8E8h case   11:*/		return 0x8210A8EC;
		  /* 8210A8ECh */ case   12:  		/* bc 12, CR0_LT, 520 */
		/* 8210A8ECh case   12:*/		if ( regs.CR[0].lt ) { return 0x8210AAF4;  }
		/* 8210A8ECh case   12:*/		return 0x8210A8F0;
		  /* 8210A8F0h */ case   13:  		/* addi R28, R28, 1 */
		/* 8210A8F0h case   13:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8210A8F0h case   13:*/		return 0x8210A8F4;
		  /* 8210A8F4h */ case   14:  		/* addi R29, R29, 4 */
		/* 8210A8F4h case   14:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8210A8F4h case   14:*/		return 0x8210A8F8;
		  /* 8210A8F8h */ case   15:  		/* cmplw CR6, R28, R30 */
		/* 8210A8F8h case   15:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R30);
		/* 8210A8F8h case   15:*/		return 0x8210A8FC;
		  /* 8210A8FCh */ case   16:  		/* bc 12, CR6_LT, -36 */
		/* 8210A8FCh case   16:*/		if ( regs.CR[6].lt ) { return 0x8210A8D8;  }
		/* 8210A8FCh case   16:*/		return 0x8210A900;
	}
	return 0x8210A900;
} // Block from 8210A8BCh-8210A900h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8210A900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A900);
		  /* 8210A900h */ case    0:  		/* subf R11, R27, R30 */
		/* 8210A900h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R27,regs.R30);
		/* 8210A900h case    0:*/		return 0x8210A904;
		  /* 8210A904h */ case    1:  		/* rlwinm. R10, R11, 31, 1, 31 */
		/* 8210A904h case    1:*/		cpu::op::rlwinm<1,31,1,31>(regs,&regs.R10,regs.R11);
		/* 8210A904h case    1:*/		return 0x8210A908;
		  /* 8210A908h */ case    2:  		/* bc 12, CR0_EQ, 60 */
		/* 8210A908h case    2:*/		if ( regs.CR[0].eq ) { return 0x8210A944;  }
		/* 8210A908h case    2:*/		return 0x8210A90C;
		  /* 8210A90Ch */ case    3:  		/* mtspr CTR, R10 */
		/* 8210A90Ch case    3:*/		regs.CTR = regs.R10;
		/* 8210A90Ch case    3:*/		return 0x8210A910;
		  /* 8210A910h */ case    4:  		/* rlwinm R11, R27, 2, 0, 29 */
		/* 8210A910h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R27);
		/* 8210A910h case    4:*/		return 0x8210A914;
		  /* 8210A914h */ case    5:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 8210A914h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 8210A914h case    5:*/		return 0x8210A918;
	}
	return 0x8210A918;
} // Block from 8210A900h-8210A918h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210A918h
// Function '?CompactOutputs@CProgram@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A918);
		  /* 8210A918h */ case    0:  		/* lwz R9, <#[R31 + 24]> */
		/* 8210A918h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8210A918h case    0:*/		return 0x8210A91C;
		  /* 8210A91Ch */ case    1:  		/* add R8, R10, R9 */
		/* 8210A91Ch case    1:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R9);
		/* 8210A91Ch case    1:*/		return 0x8210A920;
		  /* 8210A920h */ case    2:  		/* lwzx R7, <#[R11 + R9]> */
		/* 8210A920h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210A920h case    2:*/		return 0x8210A924;
		  /* 8210A924h */ case    3:  		/* lwz R8, <#[R8 - 4]> */
		/* 8210A924h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0xFFFFFFFC) );
		/* 8210A924h case    3:*/		return 0x8210A928;
		  /* 8210A928h */ case    4:  		/* stwx R8, <#[R11 + R9]> */
		/* 8210A928h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210A928h case    4:*/		return 0x8210A92C;
		  /* 8210A92Ch */ case    5:  		/* addi R11, R11, 4 */
		/* 8210A92Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210A92Ch case    5:*/		return 0x8210A930;
		  /* 8210A930h */ case    6:  		/* lwz R9, <#[R31 + 24]> */
		/* 8210A930h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 8210A930h case    6:*/		return 0x8210A934;
		  /* 8210A934h */ case    7:  		/* add R9, R10, R9 */
		/* 8210A934h case    7:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 8210A934h case    7:*/		return 0x8210A938;
		  /* 8210A938h */ case    8:  		/* addi R10, R10, -4 */
		/* 8210A938h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 8210A938h case    8:*/		return 0x8210A93C;
		  /* 8210A93Ch */ case    9:  		/* stw R7, <#[R9 - 4]> */
		/* 8210A93Ch case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0xFFFFFFFC) );
		/* 8210A93Ch case    9:*/		return 0x8210A940;
		  /* 8210A940h */ case   10:  		/* bc 16, CR0_LT, -40 */
		/* 8210A940h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210A918;  }
		/* 8210A940h case   10:*/		return 0x8210A944;
	}
	return 0x8210A944;
} // Block from 8210A918h-8210A944h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8210A944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A944);
		  /* 8210A944h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 8210A944h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8210A944h case    0:*/		return 0x8210A948;
		  /* 8210A948h */ case    1:  		/* bc 4, CR6_EQ, -240 */
		/* 8210A948h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8210A858;  }
		/* 8210A948h case    1:*/		return 0x8210A94C;
	}
	return 0x8210A94C;
} // Block from 8210A944h-8210A94Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8210A94Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A94C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A94C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A94C);
		  /* 8210A94Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210A94Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210A94Ch case    0:*/		return 0x8210A950;
		  /* 8210A950h */ case    1:  		/* mr R10, R23 */
		/* 8210A950h case    1:*/		regs.R10 = regs.R23;
		/* 8210A950h case    1:*/		return 0x8210A954;
		  /* 8210A954h */ case    2:  		/* subf R11, R24, R11 */
		/* 8210A954h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 8210A954h case    2:*/		return 0x8210A958;
		  /* 8210A958h */ case    3:  		/* rlwinm. R11, R11, 31, 1, 31 */
		/* 8210A958h case    3:*/		cpu::op::rlwinm<1,31,1,31>(regs,&regs.R11,regs.R11);
		/* 8210A958h case    3:*/		return 0x8210A95C;
		  /* 8210A95Ch */ case    4:  		/* bc 12, CR0_EQ, 80 */
		/* 8210A95Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8210A9AC;  }
		/* 8210A95Ch case    4:*/		return 0x8210A960;
		  /* 8210A960h */ case    5:  		/* mtspr CTR, R11 */
		/* 8210A960h case    5:*/		regs.CTR = regs.R11;
		/* 8210A960h case    5:*/		return 0x8210A964;
		  /* 8210A964h */ case    6:  		/* rlwinm R11, R24, 2, 0, 29 */
		/* 8210A964h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R24);
		/* 8210A964h case    6:*/		return 0x8210A968;
		  /* 8210A968h */ case    7:  		/* lwz R9, <#[R31 + 12]> */
		/* 8210A968h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210A968h case    7:*/		return 0x8210A96C;
		  /* 8210A96Ch */ case    8:  		/* lwz R8, <#[R31 + 24]> */
		/* 8210A96Ch case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 8210A96Ch case    8:*/		return 0x8210A970;
		  /* 8210A970h */ case    9:  		/* subf R9, R10, R9 */
		/* 8210A970h case    9:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 8210A970h case    9:*/		return 0x8210A974;
		  /* 8210A974h */ case   10:  		/* addi R9, R9, -1 */
		/* 8210A974h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8210A974h case   10:*/		return 0x8210A978;
		  /* 8210A978h */ case   11:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210A978h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210A978h case   11:*/		return 0x8210A97C;
		  /* 8210A97Ch */ case   12:  		/* lwzx R7, <#[R8 + R11]> */
		/* 8210A97Ch case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210A97Ch case   12:*/		return 0x8210A980;
		  /* 8210A980h */ case   13:  		/* lwzx R9, <#[R9 + R8]> */
		/* 8210A980h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8210A980h case   13:*/		return 0x8210A984;
		  /* 8210A984h */ case   14:  		/* stwx R9, <#[R8 + R11]> */
		/* 8210A984h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8210A984h case   14:*/		return 0x8210A988;
		  /* 8210A988h */ case   15:  		/* addi R11, R11, 4 */
		/* 8210A988h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210A988h case   15:*/		return 0x8210A98C;
		  /* 8210A98Ch */ case   16:  		/* lwz R8, <#[R31 + 24]> */
		/* 8210A98Ch case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 8210A98Ch case   16:*/		return 0x8210A990;
		  /* 8210A990h */ case   17:  		/* lwz R9, <#[R31 + 12]> */
		/* 8210A990h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210A990h case   17:*/		return 0x8210A994;
		  /* 8210A994h */ case   18:  		/* subf R9, R10, R9 */
		/* 8210A994h case   18:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 8210A994h case   18:*/		return 0x8210A998;
		  /* 8210A998h */ case   19:  		/* addi R9, R9, -1 */
		/* 8210A998h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8210A998h case   19:*/		return 0x8210A99C;
		  /* 8210A99Ch */ case   20:  		/* addi R10, R10, 1 */
		/* 8210A99Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8210A99Ch case   20:*/		return 0x8210A9A0;
		  /* 8210A9A0h */ case   21:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8210A9A0h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8210A9A0h case   21:*/		return 0x8210A9A4;
		  /* 8210A9A4h */ case   22:  		/* stwx R7, <#[R9 + R8]> */
		/* 8210A9A4h case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8210A9A4h case   22:*/		return 0x8210A9A8;
		  /* 8210A9A8h */ case   23:  		/* bc 16, CR0_LT, -64 */
		/* 8210A9A8h case   23:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210A968;  }
		/* 8210A9A8h case   23:*/		return 0x8210A9AC;
	}
	return 0x8210A9AC;
} // Block from 8210A94Ch-8210A9ACh (24 instructions)

//////////////////////////////////////////////////////
// Block at 8210A9ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A9AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A9AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A9AC);
		  /* 8210A9ACh */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 8210A9ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8210A9ACh case    0:*/		return 0x8210A9B0;
		  /* 8210A9B0h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 8210A9B0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8210A9D0;  }
		/* 8210A9B0h case    1:*/		return 0x8210A9B4;
		  /* 8210A9B4h */ case    2:  		/* mtspr CTR, R24 */
		/* 8210A9B4h case    2:*/		regs.CTR = regs.R24;
		/* 8210A9B4h case    2:*/		return 0x8210A9B8;
		  /* 8210A9B8h */ case    3:  		/* mr R11, R23 */
		/* 8210A9B8h case    3:*/		regs.R11 = regs.R23;
		/* 8210A9B8h case    3:*/		return 0x8210A9BC;
		  /* 8210A9BCh */ case    4:  		/* lwz R10, <#[R31 + 24]> */
		/* 8210A9BCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 8210A9BCh case    4:*/		return 0x8210A9C0;
		  /* 8210A9C0h */ case    5:  		/* lwzx R10, <#[R10 + R11]> */
		/* 8210A9C0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210A9C0h case    5:*/		return 0x8210A9C4;
		  /* 8210A9C4h */ case    6:  		/* addi R11, R11, 4 */
		/* 8210A9C4h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210A9C4h case    6:*/		return 0x8210A9C8;
		  /* 8210A9C8h */ case    7:  		/* stw R23, <#[R10]> */
		/* 8210A9C8h case    7:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R10 + 0x00000000) );
		/* 8210A9C8h case    7:*/		return 0x8210A9CC;
		  /* 8210A9CCh */ case    8:  		/* bc 16, CR0_LT, -16 */
		/* 8210A9CCh case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8210A9BC;  }
		/* 8210A9CCh case    8:*/		return 0x8210A9D0;
	}
	return 0x8210A9D0;
} // Block from 8210A9ACh-8210A9D0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8210A9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A9D0);
		  /* 8210A9D0h */ case    0:  		/* mr R3, R31 */
		/* 8210A9D0h case    0:*/		regs.R3 = regs.R31;
		/* 8210A9D0h case    0:*/		return 0x8210A9D4;
		  /* 8210A9D4h */ case    1:  		/* bl -36212 */
		/* 8210A9D4h case    1:*/		regs.LR = 0x8210A9D8; return 0x82101C60;
		/* 8210A9D4h case    1:*/		return 0x8210A9D8;
		  /* 8210A9D8h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 8210A9D8h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8210A9D8h case    2:*/		return 0x8210A9DC;
		  /* 8210A9DCh */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 8210A9DCh case    3:*/		if ( regs.CR[0].eq ) { return 0x8210A9E8;  }
		/* 8210A9DCh case    3:*/		return 0x8210A9E0;
		  /* 8210A9E0h */ case    4:  		/* cmpwi CR6, R3, 0 */
		/* 8210A9E0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8210A9E0h case    4:*/		return 0x8210A9E4;
		  /* 8210A9E4h */ case    5:  		/* bc 12, CR6_LT, 272 */
		/* 8210A9E4h case    5:*/		if ( regs.CR[6].lt ) { return 0x8210AAF4;  }
		/* 8210A9E4h case    5:*/		return 0x8210A9E8;
	}
	return 0x8210A9E8;
} // Block from 8210A9D0h-8210A9E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8210A9E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210A9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210A9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210A9E8);
		  /* 8210A9E8h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8210A9E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8210A9E8h case    0:*/		return 0x8210A9EC;
		  /* 8210A9ECh */ case    1:  		/* mr R9, R23 */
		/* 8210A9ECh case    1:*/		regs.R9 = regs.R23;
		/* 8210A9ECh case    1:*/		return 0x8210A9F0;
		  /* 8210A9F0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210A9F0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210A9F0h case    2:*/		return 0x8210A9F4;
		  /* 8210A9F4h */ case    3:  		/* bc 4, CR6_GT, 52 */
		/* 8210A9F4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210AA28;  }
		/* 8210A9F4h case    3:*/		return 0x8210A9F8;
		  /* 8210A9F8h */ case    4:  		/* mr R11, R23 */
		/* 8210A9F8h case    4:*/		regs.R11 = regs.R23;
		/* 8210A9F8h case    4:*/		return 0x8210A9FC;
		  /* 8210A9FCh */ case    5:  		/* lwz R10, <#[R31 + 16]> */
		/* 8210A9FCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 8210A9FCh case    5:*/		return 0x8210AA00;
		  /* 8210AA00h */ case    6:  		/* lwzx R10, <#[R10 + R11]> */
		/* 8210AA00h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210AA00h case    6:*/		return 0x8210AA04;
		  /* 8210AA04h */ case    7:  		/* lwz R8, <#[R10 + 4]> */
		/* 8210AA04h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 8210AA04h case    7:*/		return 0x8210AA08;
		  /* 8210AA08h */ case    8:  		/* rlwinm. R8, R8, 0, 25, 25 */
		/* 8210AA08h case    8:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R8,regs.R8);
		/* 8210AA08h case    8:*/		return 0x8210AA0C;
		  /* 8210AA0Ch */ case    9:  		/* bc 4, CR0_EQ, 8 */
		/* 8210AA0Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x8210AA14;  }
		/* 8210AA0Ch case    9:*/		return 0x8210AA10;
		  /* 8210AA10h */ case   10:  		/* stw R23, <#[R10 + 16]> */
		/* 8210AA10h case   10:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R10 + 0x00000010) );
		/* 8210AA10h case   10:*/		return 0x8210AA14;
	}
	return 0x8210AA14;
} // Block from 8210A9E8h-8210AA14h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8210AA14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AA14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AA14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AA14);
		  /* 8210AA14h */ case    0:  		/* lwz R10, <#[R31 + 4]> */
		/* 8210AA14h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8210AA14h case    0:*/		return 0x8210AA18;
		  /* 8210AA18h */ case    1:  		/* addi R9, R9, 1 */
		/* 8210AA18h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8210AA18h case    1:*/		return 0x8210AA1C;
		  /* 8210AA1Ch */ case    2:  		/* addi R11, R11, 4 */
		/* 8210AA1Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210AA1Ch case    2:*/		return 0x8210AA20;
		  /* 8210AA20h */ case    3:  		/* cmplw CR6, R9, R10 */
		/* 8210AA20h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8210AA20h case    3:*/		return 0x8210AA24;
		  /* 8210AA24h */ case    4:  		/* bc 12, CR6_LT, -40 */
		/* 8210AA24h case    4:*/		if ( regs.CR[6].lt ) { return 0x8210A9FC;  }
		/* 8210AA24h case    4:*/		return 0x8210AA28;
	}
	return 0x8210AA28;
} // Block from 8210AA14h-8210AA28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210AA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AA28);
		  /* 8210AA28h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210AA28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210AA28h case    0:*/		return 0x8210AA2C;
		  /* 8210AA2Ch */ case    1:  		/* mr R6, R23 */
		/* 8210AA2Ch case    1:*/		regs.R6 = regs.R23;
		/* 8210AA2Ch case    1:*/		return 0x8210AA30;
		  /* 8210AA30h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8210AA30h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210AA30h case    2:*/		return 0x8210AA34;
		  /* 8210AA34h */ case    3:  		/* bc 4, CR6_GT, 188 */
		/* 8210AA34h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8210AAF0;  }
		/* 8210AA34h case    3:*/		return 0x8210AA38;
		  /* 8210AA38h */ case    4:  		/* mr R7, R23 */
		/* 8210AA38h case    4:*/		regs.R7 = regs.R23;
		/* 8210AA38h case    4:*/		return 0x8210AA3C;
		  /* 8210AA3Ch */ case    5:  		/* lwz R11, <#[R31 + 24]> */
		/* 8210AA3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8210AA3Ch case    5:*/		return 0x8210AA40;
		  /* 8210AA40h */ case    6:  		/* lwzx R9, <#[R11 + R7]> */
		/* 8210AA40h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8210AA40h case    6:*/		return 0x8210AA44;
		  /* 8210AA44h */ case    7:  		/* lwz R11, <#[R9]> */
		/* 8210AA44h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8210AA44h case    7:*/		return 0x8210AA48;
		  /* 8210AA48h */ case    8:  		/* rlwinm. R11, R11, 0, 0, 11 */
		/* 8210AA48h case    8:*/		cpu::op::rlwinm<1,0,0,11>(regs,&regs.R11,regs.R11);
		/* 8210AA48h case    8:*/		return 0x8210AA4C;
		  /* 8210AA4Ch */ case    9:  		/* bc 12, CR0_EQ, 144 */
		/* 8210AA4Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8210AADC;  }
		/* 8210AA4Ch case    9:*/		return 0x8210AA50;
		  /* 8210AA50h */ case   10:  		/* lwz R10, <#[R9 + 12]> */
		/* 8210AA50h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000000C) );
		/* 8210AA50h case   10:*/		return 0x8210AA54;
		  /* 8210AA54h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 8210AA54h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210AA54h case   11:*/		return 0x8210AA58;
		  /* 8210AA58h */ case   12:  		/* bc 12, CR6_EQ, 132 */
		/* 8210AA58h case   12:*/		if ( regs.CR[6].eq ) { return 0x8210AADC;  }
		/* 8210AA58h case   12:*/		return 0x8210AA5C;
		  /* 8210AA5Ch */ case   13:  		/* lwz R11, <#[R9 + 16]> */
		/* 8210AA5Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 8210AA5Ch case   13:*/		return 0x8210AA60;
		  /* 8210AA60h */ case   14:  		/* lwz R8, <#[R31 + 20]> */
		/* 8210AA60h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 8210AA60h case   14:*/		return 0x8210AA64;
		  /* 8210AA64h */ case   15:  		/* lwz R5, <#[R31 + 16]> */
		/* 8210AA64h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000010) );
		/* 8210AA64h case   15:*/		return 0x8210AA68;
		  /* 8210AA68h */ case   16:  		/* lwz R11, <#[R11]> */
		/* 8210AA68h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210AA68h case   16:*/		return 0x8210AA6C;
		  /* 8210AA6Ch */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210AA6Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210AA6Ch case   17:*/		return 0x8210AA70;
		  /* 8210AA70h */ case   18:  		/* lwzx R11, <#[R11 + R8]> */
		/* 8210AA70h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8210AA70h case   18:*/		return 0x8210AA74;
		  /* 8210AA74h */ case   19:  		/* lwz R11, <#[R11 + 4]> */
		/* 8210AA74h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8210AA74h case   19:*/		return 0x8210AA78;
		  /* 8210AA78h */ case   20:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210AA78h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210AA78h case   20:*/		return 0x8210AA7C;
		  /* 8210AA7Ch */ case   21:  		/* lwzx R8, <#[R11 + R5]> */
		/* 8210AA7Ch case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 8210AA7Ch case   21:*/		return 0x8210AA80;
		  /* 8210AA80h */ case   22:  		/* lwz R11, <#[R8 + 4]> */
		/* 8210AA80h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 8210AA80h case   22:*/		return 0x8210AA84;
		  /* 8210AA84h */ case   23:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 8210AA84h case   23:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 8210AA84h case   23:*/		return 0x8210AA88;
		  /* 8210AA88h */ case   24:  		/* bc 4, CR0_EQ, 84 */
		/* 8210AA88h case   24:*/		if ( !regs.CR[0].eq ) { return 0x8210AADC;  }
		/* 8210AA88h case   24:*/		return 0x8210AA8C;
		  /* 8210AA8Ch */ case   25:  		/* mr R11, R23 */
		/* 8210AA8Ch case   25:*/		regs.R11 = regs.R23;
		/* 8210AA8Ch case   25:*/		return 0x8210AA90;
		  /* 8210AA90h */ case   26:  		/* cmplwi CR6, R10, 0 */
		/* 8210AA90h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8210AA90h case   26:*/		return 0x8210AA94;
		  /* 8210AA94h */ case   27:  		/* bc 12, CR6_EQ, 60 */
		/* 8210AA94h case   27:*/		if ( regs.CR[6].eq ) { return 0x8210AAD0;  }
		/* 8210AA94h case   27:*/		return 0x8210AA98;
		  /* 8210AA98h */ case   28:  		/* mr R10, R23 */
		/* 8210AA98h case   28:*/		regs.R10 = regs.R23;
		/* 8210AA98h case   28:*/		return 0x8210AA9C;
		  /* 8210AA9Ch */ case   29:  		/* lwz R5, <#[R9 + 16]> */
		/* 8210AA9Ch case   29:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000010) );
		/* 8210AA9Ch case   29:*/		return 0x8210AAA0;
		  /* 8210AAA0h */ case   30:  		/* lwz R4, <#[R31 + 20]> */
		/* 8210AAA0h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 8210AAA0h case   30:*/		return 0x8210AAA4;
		  /* 8210AAA4h */ case   31:  		/* lwz R3, <#[R8 + 16]> */
		/* 8210AAA4h case   31:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + 0x00000010) );
		/* 8210AAA4h case   31:*/		return 0x8210AAA8;
		  /* 8210AAA8h */ case   32:  		/* lwzx R5, <#[R10 + R5]> */
		/* 8210AAA8h case   32:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8210AAA8h case   32:*/		return 0x8210AAAC;
		  /* 8210AAACh */ case   33:  		/* addi R10, R10, 4 */
		/* 8210AAACh case   33:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8210AAACh case   33:*/		return 0x8210AAB0;
		  /* 8210AAB0h */ case   34:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 8210AAB0h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 8210AAB0h case   34:*/		return 0x8210AAB4;
		  /* 8210AAB4h */ case   35:  		/* lwzx R5, <#[R5 + R4]> */
		/* 8210AAB4h case   35:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R4 + 0x00000000) );
		/* 8210AAB4h case   35:*/		return 0x8210AAB8;
		  /* 8210AAB8h */ case   36:  		/* stw R11, <#[R5 + 16]> */
		/* 8210AAB8h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000010) );
		/* 8210AAB8h case   36:*/		return 0x8210AABC;
		  /* 8210AABCh */ case   37:  		/* addi R11, R11, 1 */
		/* 8210AABCh case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210AABCh case   37:*/		return 0x8210AAC0;
		  /* 8210AAC0h */ case   38:  		/* stw R3, <#[R5 + 12]> */
		/* 8210AAC0h case   38:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R5 + 0x0000000C) );
		/* 8210AAC0h case   38:*/		return 0x8210AAC4;
		  /* 8210AAC4h */ case   39:  		/* lwz R5, <#[R9 + 12]> */
		/* 8210AAC4h case   39:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x0000000C) );
		/* 8210AAC4h case   39:*/		return 0x8210AAC8;
		  /* 8210AAC8h */ case   40:  		/* cmplw CR6, R11, R5 */
		/* 8210AAC8h case   40:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 8210AAC8h case   40:*/		return 0x8210AACC;
		  /* 8210AACCh */ case   41:  		/* bc 12, CR6_LT, -48 */
		/* 8210AACCh case   41:*/		if ( regs.CR[6].lt ) { return 0x8210AA9C;  }
		/* 8210AACCh case   41:*/		return 0x8210AAD0;
	}
	return 0x8210AAD0;
} // Block from 8210AA28h-8210AAD0h (42 instructions)

//////////////////////////////////////////////////////
// Block at 8210AAD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AAD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AAD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AAD0);
		  /* 8210AAD0h */ case    0:  		/* lwz R11, <#[R8 + 16]> */
		/* 8210AAD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 8210AAD0h case    0:*/		return 0x8210AAD4;
		  /* 8210AAD4h */ case    1:  		/* addi R11, R11, 1 */
		/* 8210AAD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8210AAD4h case    1:*/		return 0x8210AAD8;
		  /* 8210AAD8h */ case    2:  		/* stw R11, <#[R8 + 16]> */
		/* 8210AAD8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 8210AAD8h case    2:*/		return 0x8210AADC;
	}
	return 0x8210AADC;
} // Block from 8210AAD0h-8210AADCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210AADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AADC);
		  /* 8210AADCh */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8210AADCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8210AADCh case    0:*/		return 0x8210AAE0;
		  /* 8210AAE0h */ case    1:  		/* addi R6, R6, 1 */
		/* 8210AAE0h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8210AAE0h case    1:*/		return 0x8210AAE4;
		  /* 8210AAE4h */ case    2:  		/* addi R7, R7, 4 */
		/* 8210AAE4h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8210AAE4h case    2:*/		return 0x8210AAE8;
		  /* 8210AAE8h */ case    3:  		/* cmplw CR6, R6, R11 */
		/* 8210AAE8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 8210AAE8h case    3:*/		return 0x8210AAEC;
		  /* 8210AAECh */ case    4:  		/* bc 12, CR6_LT, -176 */
		/* 8210AAECh case    4:*/		if ( regs.CR[6].lt ) { return 0x8210AA3C;  }
		/* 8210AAECh case    4:*/		return 0x8210AAF0;
	}
	return 0x8210AAF0;
} // Block from 8210AADCh-8210AAF0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210AAF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AAF0);
		  /* 8210AAF0h */ case    0:  		/* li R3, 0 */
		/* 8210AAF0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8210AAF0h case    0:*/		return 0x8210AAF4;
	}
	return 0x8210AAF4;
} // Block from 8210AAF0h-8210AAF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8210AAF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AAF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AAF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AAF4);
		  /* 8210AAF4h */ case    0:  		/* addi R1, R1, 160 */
		/* 8210AAF4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8210AAF4h case    0:*/		return 0x8210AAF8;
		  /* 8210AAF8h */ case    1:  		/* b -497764 */
		/* 8210AAF8h case    1:*/		return 0x82091294;
		/* 8210AAF8h case    1:*/		return 0x8210AAFC;
		  /* 8210AAFCh */ case    2:  		/* nop */
		/* 8210AAFCh case    2:*/		cpu::op::nop();
		/* 8210AAFCh case    2:*/		return 0x8210AB00;
	}
	return 0x8210AB00;
} // Block from 8210AAF4h-8210AB00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8210AB00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AB00);
		  /* 8210AB00h */ case    0:  		/* mfspr R12, LR */
		/* 8210AB00h case    0:*/		regs.R12 = regs.LR;
		/* 8210AB00h case    0:*/		return 0x8210AB04;
		  /* 8210AB04h */ case    1:  		/* bl -497892 */
		/* 8210AB04h case    1:*/		regs.LR = 0x8210AB08; return 0x82091220;
		/* 8210AB04h case    1:*/		return 0x8210AB08;
		  /* 8210AB08h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 8210AB08h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8210AB08h case    2:*/		return 0x8210AB0C;
		  /* 8210AB0Ch */ case    3:  		/* stwu R1, <#[R1 - 400]> */
		/* 8210AB0Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE70);
		/* 8210AB0Ch case    3:*/		return 0x8210AB10;
		  /* 8210AB10h */ case    4:  		/* li R15, 0 */
		/* 8210AB10h case    4:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 8210AB10h case    4:*/		return 0x8210AB14;
		  /* 8210AB14h */ case    5:  		/* mr R23, R3 */
		/* 8210AB14h case    5:*/		regs.R23 = regs.R3;
		/* 8210AB14h case    5:*/		return 0x8210AB18;
		  /* 8210AB18h */ case    6:  		/* mr R20, R15 */
		/* 8210AB18h case    6:*/		regs.R20 = regs.R15;
		/* 8210AB18h case    6:*/		return 0x8210AB1C;
		  /* 8210AB1Ch */ case    7:  		/* bl -20356 */
		/* 8210AB1Ch case    7:*/		regs.LR = 0x8210AB20; return 0x82105B98;
		/* 8210AB1Ch case    7:*/		return 0x8210AB20;
		  /* 8210AB20h */ case    8:  		/* lwz R11, <#[R23 + 8]> */
		/* 8210AB20h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8210AB20h case    8:*/		return 0x8210AB24;
		  /* 8210AB24h */ case    9:  		/* mr R19, R15 */
		/* 8210AB24h case    9:*/		regs.R19 = regs.R15;
		/* 8210AB24h case    9:*/		return 0x8210AB28;
		  /* 8210AB28h */ case   10:  		/* mr R21, R15 */
		/* 8210AB28h case   10:*/		regs.R21 = regs.R15;
		/* 8210AB28h case   10:*/		return 0x8210AB2C;
		  /* 8210AB2Ch */ case   11:  		/* stw R15, <#[R1 + 80]> */
		/* 8210AB2Ch case   11:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000050) );
		/* 8210AB2Ch case   11:*/		return 0x8210AB30;
		  /* 8210AB30h */ case   12:  		/* mr R7, R15 */
		/* 8210AB30h case   12:*/		regs.R7 = regs.R15;
		/* 8210AB30h case   12:*/		return 0x8210AB34;
		  /* 8210AB34h */ case   13:  		/* stw R15, <#[R1 + 84]> */
		/* 8210AB34h case   13:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x00000054) );
		/* 8210AB34h case   13:*/		return 0x8210AB38;
		  /* 8210AB38h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 8210AB38h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210AB38h case   14:*/		return 0x8210AB3C;
		  /* 8210AB3Ch */ case   15:  		/* bc 4, CR6_GT, 72 */
		/* 8210AB3Ch case   15:*/		if ( !regs.CR[6].gt ) { return 0x8210AB84;  }
		/* 8210AB3Ch case   15:*/		return 0x8210AB40;
		  /* 8210AB40h */ case   16:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210AB40h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210AB40h case   16:*/		return 0x8210AB44;
		  /* 8210AB44h */ case   17:  		/* mr R11, R15 */
		/* 8210AB44h case   17:*/		regs.R11 = regs.R15;
		/* 8210AB44h case   17:*/		return 0x8210AB48;
		  /* 8210AB48h */ case   18:  		/* lwz R8, <#[R23 + 136]> */
		/* 8210AB48h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000088) );
		/* 8210AB48h case   18:*/		return 0x8210AB4C;
		  /* 8210AB4Ch */ case   19:  		/* lwz R6, <#[R23 + 8]> */
		/* 8210AB4Ch case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R23 + 0x00000008) );
		/* 8210AB4Ch case   19:*/		return 0x8210AB50;
		  /* 8210AB50h */ case   20:  		/* lwzx R10, <#[R9 + R11]> */
		/* 8210AB50h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210AB50h case   20:*/		return 0x8210AB54;
		  /* 8210AB54h */ case   21:  		/* lwz R5, <#[R10 + 4]> */
		/* 8210AB54h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000004) );
		/* 8210AB54h case   21:*/		return 0x8210AB58;
		  /* 8210AB58h */ case   22:  		/* cmplw CR6, R8, R5 */
		/* 8210AB58h case   22:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R5);
		/* 8210AB58h case   22:*/		return 0x8210AB5C;
		  /* 8210AB5Ch */ case   23:  		/* bc 4, CR6_EQ, 20 */
		/* 8210AB5Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x8210AB70;  }
		/* 8210AB5Ch case   23:*/		return 0x8210AB60;
		  /* 8210AB60h */ case   24:  		/* lwz R10, <#[R10 + 12]> */
		/* 8210AB60h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210AB60h case   24:*/		return 0x8210AB64;
		  /* 8210AB64h */ case   25:  		/* cmplw CR6, R19, R10 */
		/* 8210AB64h case   25:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R10);
		/* 8210AB64h case   25:*/		return 0x8210AB68;
		  /* 8210AB68h */ case   26:  		/* bc 12, CR6_GT, 8 */
		/* 8210AB68h case   26:*/		if ( regs.CR[6].gt ) { return 0x8210AB70;  }
		/* 8210AB68h case   26:*/		return 0x8210AB6C;
		  /* 8210AB6Ch */ case   27:  		/* addi R19, R10, 1 */
		/* 8210AB6Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R10,0x1);
		/* 8210AB6Ch case   27:*/		return 0x8210AB70;
	}
	return 0x8210AB70;
} // Block from 8210AB00h-8210AB70h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8210AB70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AB70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AB70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AB70);
		  /* 8210AB70h */ case    0:  		/* addi R7, R7, 1 */
		/* 8210AB70h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8210AB70h case    0:*/		return 0x8210AB74;
		  /* 8210AB74h */ case    1:  		/* addi R11, R11, 4 */
		/* 8210AB74h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8210AB74h case    1:*/		return 0x8210AB78;
		  /* 8210AB78h */ case    2:  		/* cmplw CR6, R7, R6 */
		/* 8210AB78h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8210AB78h case    2:*/		return 0x8210AB7C;
		  /* 8210AB7Ch */ case    3:  		/* bc 12, CR6_LT, -44 */
		/* 8210AB7Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8210AB50;  }
		/* 8210AB7Ch case    3:*/		return 0x8210AB80;
		  /* 8210AB80h */ case    4:  		/* stw R19, <#[R1 + 80]> */
		/* 8210AB80h case    4:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000050) );
		/* 8210AB80h case    4:*/		return 0x8210AB84;
	}
	return 0x8210AB84;
} // Block from 8210AB70h-8210AB84h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8210AB84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8210AB84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8210AB84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8210AB84);
		  /* 8210AB84h */ case    0:  		/* lis R10, -32256 */
		/* 8210AB84h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8210AB84h case    0:*/		return 0x8210AB88;
		  /* 8210AB88h */ case    1:  		/* lwz R11, <#[R23 + 108]> */
		/* 8210AB88h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000006C) );
		/* 8210AB88h case    1:*/		return 0x8210AB8C;
		  /* 8210AB8Ch */ case    2:  		/* li R18, -1 */
		/* 8210AB8Ch case    2:*/		cpu::op::li<0>(regs,&regs.R18,0xFFFFFFFF);
		/* 8210AB8Ch case    2:*/		return 0x8210AB90;
		  /* 8210AB90h */ case    3:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 8210AB90h case    3:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 8210AB90h case    3:*/		return 0x8210AB94;
		  /* 8210AB94h */ case    4:  		/* lfd FR31, <#[R10 + 1808]> */
		/* 8210AB94h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000710) );
		/* 8210AB94h case    4:*/		return 0x8210AB98;
		  /* 8210AB98h */ case    5:  		/* li R17, 1 */
		/* 8210AB98h case    5:*/		cpu::op::li<0>(regs,&regs.R17,0x1);
		/* 8210AB98h case    5:*/		return 0x8210AB9C;
		  /* 8210AB9Ch */ case    6:  		/* bc 4, CR0_EQ, 536 */
		/* 8210AB9Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x8210ADB4;  }
		/* 8210AB9Ch case    6:*/		return 0x8210ABA0;
		  /* 8210ABA0h */ case    7:  		/* lwz R11, <#[R23 + 12]> */
		/* 8210ABA0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 8210ABA0h case    7:*/		return 0x8210ABA4;
		  /* 8210ABA4h */ case    8:  		/* mr R25, R15 */
		/* 8210ABA4h case    8:*/		regs.R25 = regs.R15;
		/* 8210ABA4h case    8:*/		return 0x8210ABA8;
		  /* 8210ABA8h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8210ABA8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8210ABA8h case    9:*/		return 0x8210ABAC;
		  /* 8210ABACh */ case   10:  		/* bc 4, CR6_GT, 520 */
		/* 8210ABACh case   10:*/		if ( !regs.CR[6].gt ) { return 0x8210ADB4;  }
		/* 8210ABACh case   10:*/		return 0x8210ABB0;
		  /* 8210ABB0h */ case   11:  		/* mr R26, R15 */
		/* 8210ABB0h case   11:*/		regs.R26 = regs.R15;
		/* 8210ABB0h case   11:*/		return 0x8210ABB4;
		  /* 8210ABB4h */ case   12:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210ABB4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210ABB4h case   12:*/		return 0x8210ABB8;
		  /* 8210ABB8h */ case   13:  		/* lis R10, 20480 */
		/* 8210ABB8h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x5000);
		/* 8210ABB8h case   13:*/		return 0x8210ABBC;
		  /* 8210ABBCh */ case   14:  		/* ori R10, R10, 2 */
		/* 8210ABBCh case   14:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8210ABBCh case   14:*/		return 0x8210ABC0;
		  /* 8210ABC0h */ case   15:  		/* lwzx R30, <#[R11 + R26]> */
		/* 8210ABC0h case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 8210ABC0h case   15:*/		return 0x8210ABC4;
		  /* 8210ABC4h */ case   16:  		/* lwz R11, <#[R30]> */
		/* 8210ABC4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8210ABC4h case   16:*/		return 0x8210ABC8;
		  /* 8210ABC8h */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 8210ABC8h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8210ABC8h case   17:*/		return 0x8210ABCC;
		  /* 8210ABCCh */ case   18:  		/* bc 4, CR6_EQ, 452 */
		/* 8210ABCCh case   18:*/		if ( !regs.CR[6].eq ) { return 0x8210AD90;  }
		/* 8210ABCCh case   18:*/		return 0x8210ABD0;
		  /* 8210ABD0h */ case   19:  		/* lis R4, 8272 */
		/* 8210ABD0h case   19:*/		cpu::op::lis<0>(regs,&regs.R4,0x2050);
		/* 8210ABD0h case   19:*/		return 0x8210ABD4;
		  /* 8210ABD4h */ case   20:  		/* mr R6, R18 */
		/* 8210ABD4h case   20:*/		regs.R6 = regs.R18;
		/* 8210ABD4h case   20:*/		return 0x8210ABD8;
		  /* 8210ABD8h */ case   21:  		/* mr R5, R18 */
		/* 8210ABD8h case   21:*/		regs.R5 = regs.R18;
		/* 8210ABD8h case   21:*/		return 0x8210ABDC;
		  /* 8210ABDCh */ case   22:  		/* ori R4, R4, 2 */
		/* 8210ABDCh case   22:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x2);
		/* 8210ABDCh case   22:*/		return 0x8210ABE0;
		  /* 8210ABE0h */ case   23:  		/* mr R3, R23 */
		/* 8210ABE0h case   23:*/		regs.R3 = regs.R23;
		/* 8210ABE0h case   23:*/		return 0x8210ABE4;
		  /* 8210ABE4h */ case   24:  		/* bl -55580 */
		/* 8210ABE4h case   24:*/		regs.LR = 0x8210ABE8; return 0x820FD2C8;
		/* 8210ABE4h case   24:*/		return 0x8210ABE8;
		  /* 8210ABE8h */ case   25:  		/* mr R31, R3 */
		/* 8210ABE8h case   25:*/		regs.R31 = regs.R3;
		/* 8210ABE8h case   25:*/		return 0x8210ABEC;
		  /* 8210ABECh */ case   26:  		/* cmpwi CR6, R3, -1 */
		/* 8210ABECh case   26:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210ABECh case   26:*/		return 0x8210ABF0;
		  /* 8210ABF0h */ case   27:  		/* bc 12, CR6_EQ, 7592 */
		/* 8210ABF0h case   27:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210ABF0h case   27:*/		return 0x8210ABF4;
		  /* 8210ABF4h */ case   28:  		/* lis R4, 8256 */
		/* 8210ABF4h case   28:*/		cpu::op::lis<0>(regs,&regs.R4,0x2040);
		/* 8210ABF4h case   28:*/		return 0x8210ABF8;
		  /* 8210ABF8h */ case   29:  		/* mr R6, R18 */
		/* 8210ABF8h case   29:*/		regs.R6 = regs.R18;
		/* 8210ABF8h case   29:*/		return 0x8210ABFC;
		  /* 8210ABFCh */ case   30:  		/* mr R5, R18 */
		/* 8210ABFCh case   30:*/		regs.R5 = regs.R18;
		/* 8210ABFCh case   30:*/		return 0x8210AC00;
		  /* 8210AC00h */ case   31:  		/* ori R4, R4, 1 */
		/* 8210AC00h case   31:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x1);
		/* 8210AC00h case   31:*/		return 0x8210AC04;
		  /* 8210AC04h */ case   32:  		/* mr R3, R23 */
		/* 8210AC04h case   32:*/		regs.R3 = regs.R23;
		/* 8210AC04h case   32:*/		return 0x8210AC08;
		  /* 8210AC08h */ case   33:  		/* bl -55616 */
		/* 8210AC08h case   33:*/		regs.LR = 0x8210AC0C; return 0x820FD2C8;
		/* 8210AC08h case   33:*/		return 0x8210AC0C;
		  /* 8210AC0Ch */ case   34:  		/* cmpwi CR6, R3, -1 */
		/* 8210AC0Ch case   34:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 8210AC0Ch case   34:*/		return 0x8210AC10;
		  /* 8210AC10h */ case   35:  		/* bc 12, CR6_EQ, 7560 */
		/* 8210AC10h case   35:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210AC10h case   35:*/		return 0x8210AC14;
		  /* 8210AC14h */ case   36:  		/* lwz R11, <#[R23 + 24]> */
		/* 8210AC14h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000018) );
		/* 8210AC14h case   36:*/		return 0x8210AC18;
		  /* 8210AC18h */ case   37:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 8210AC18h case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 8210AC18h case   37:*/		return 0x8210AC1C;
		  /* 8210AC1Ch */ case   38:  		/* rlwinm R9, R3, 2, 0, 29 */
		/* 8210AC1Ch case   38:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R3);
		/* 8210AC1Ch case   38:*/		return 0x8210AC20;
		  /* 8210AC20h */ case   39:  		/* mr R4, R30 */
		/* 8210AC20h case   39:*/		regs.R4 = regs.R30;
		/* 8210AC20h case   39:*/		return 0x8210AC24;
		  /* 8210AC24h */ case   40:  		/* lwzx R29, <#[R10 + R11]> */
		/* 8210AC24h case   40:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8210AC24h case   40:*/		return 0x8210AC28;
		  /* 8210AC28h */ case   41:  		/* lwzx R28, <#[R9 + R11]> */
		/* 8210AC28h case   41:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8210AC28h case   41:*/		return 0x8210AC2C;
		  /* 8210AC2Ch */ case   42:  		/* mr R3, R29 */
		/* 8210AC2Ch case   42:*/		regs.R3 = regs.R29;
		/* 8210AC2Ch case   42:*/		return 0x8210AC30;
		  /* 8210AC30h */ case   43:  		/* bl -60736 */
		/* 8210AC30h case   43:*/		regs.LR = 0x8210AC34; return 0x820FBEF0;
		/* 8210AC30h case   43:*/		return 0x8210AC34;
		  /* 8210AC34h */ case   44:  		/* mr R4, R30 */
		/* 8210AC34h case   44:*/		regs.R4 = regs.R30;
		/* 8210AC34h case   44:*/		return 0x8210AC38;
		  /* 8210AC38h */ case   45:  		/* mr R3, R28 */
		/* 8210AC38h case   45:*/		regs.R3 = regs.R28;
		/* 8210AC38h case   45:*/		return 0x8210AC3C;
		  /* 8210AC3Ch */ case   46:  		/* bl -60748 */
		/* 8210AC3Ch case   46:*/		regs.LR = 0x8210AC40; return 0x820FBEF0;
		/* 8210AC3Ch case   46:*/		return 0x8210AC40;
		  /* 8210AC40h */ case   47:  		/* lwz R11, <#[R30 + 8]> */
		/* 8210AC40h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8210AC40h case   47:*/		return 0x8210AC44;
		  /* 8210AC44h */ case   48:  		/* lwz R10, <#[R29 + 8]> */
		/* 8210AC44h case   48:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8210AC44h case   48:*/		return 0x8210AC48;
		  /* 8210AC48h */ case   49:  		/* mr R27, R15 */
		/* 8210AC48h case   49:*/		regs.R27 = regs.R15;
		/* 8210AC48h case   49:*/		return 0x8210AC4C;
		  /* 8210AC4Ch */ case   50:  		/* mr R31, R15 */
		/* 8210AC4Ch case   50:*/		regs.R31 = regs.R15;
		/* 8210AC4Ch case   50:*/		return 0x8210AC50;
		  /* 8210AC50h */ case   51:  		/* lwz R9, <#[R11]> */
		/* 8210AC50h case   51:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8210AC50h case   51:*/		return 0x8210AC54;
		  /* 8210AC54h */ case   52:  		/* stw R9, <#[R10]> */
		/* 8210AC54h case   52:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8210AC54h case   52:*/		return 0x8210AC58;
		  /* 8210AC58h */ case   53:  		/* lwz R9, <#[R11 + 4]> */
		/* 8210AC58h case   53:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8210AC58h case   53:*/		return 0x8210AC5C;
		  /* 8210AC5Ch */ case   54:  		/* stw R9, <#[R10 + 4]> */
		/* 8210AC5Ch case   54:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8210AC5Ch case   54:*/		return 0x8210AC60;
		  /* 8210AC60h */ case   55:  		/* lwz R9, <#[R11 + 8]> */
		/* 8210AC60h case   55:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8210AC60h case   55:*/		return 0x8210AC64;
		  /* 8210AC64h */ case   56:  		/* stw R9, <#[R10 + 8]> */
		/* 8210AC64h case   56:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 8210AC64h case   56:*/		return 0x8210AC68;
		  /* 8210AC68h */ case   57:  		/* lwz R11, <#[R11 + 12]> */
		/* 8210AC68h case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8210AC68h case   57:*/		return 0x8210AC6C;
		  /* 8210AC6Ch */ case   58:  		/* stw R11, <#[R10 + 12]> */
		/* 8210AC6Ch case   58:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 8210AC6Ch case   58:*/		return 0x8210AC70;
		  /* 8210AC70h */ case   59:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210AC70h case   59:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210AC70h case   59:*/		return 0x8210AC74;
		  /* 8210AC74h */ case   60:  		/* lwz R10, <#[R28 + 16]> */
		/* 8210AC74h case   60:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 8210AC74h case   60:*/		return 0x8210AC78;
		  /* 8210AC78h */ case   61:  		/* lwz R11, <#[R11]> */
		/* 8210AC78h case   61:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210AC78h case   61:*/		return 0x8210AC7C;
		  /* 8210AC7Ch */ case   62:  		/* stw R11, <#[R10]> */
		/* 8210AC7Ch case   62:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8210AC7Ch case   62:*/		return 0x8210AC80;
		  /* 8210AC80h */ case   63:  		/* mr R6, R27 */
		/* 8210AC80h case   63:*/		regs.R6 = regs.R27;
		/* 8210AC80h case   63:*/		return 0x8210AC84;
		  /* 8210AC84h */ case   64:  		/* lwz R4, <#[R23 + 136]> */
		/* 8210AC84h case   64:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000088) );
		/* 8210AC84h case   64:*/		return 0x8210AC88;
		  /* 8210AC88h */ case   65:  		/* mr R5, R19 */
		/* 8210AC88h case   65:*/		regs.R5 = regs.R19;
		/* 8210AC88h case   65:*/		return 0x8210AC8C;
		  /* 8210AC8Ch */ case   66:  		/* fmr FR1, FR31 */
		/* 8210AC8Ch case   66:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8210AC8Ch case   66:*/		return 0x8210AC90;
		  /* 8210AC90h */ case   67:  		/* mr R3, R23 */
		/* 8210AC90h case   67:*/		regs.R3 = regs.R23;
		/* 8210AC90h case   67:*/		return 0x8210AC94;
		  /* 8210AC94h */ case   68:  		/* bl -55916 */
		/* 8210AC94h case   68:*/		regs.LR = 0x8210AC98; return 0x820FD228;
		/* 8210AC94h case   68:*/		return 0x8210AC98;
		  /* 8210AC98h */ case   69:  		/* lwz R11, <#[R28 + 8]> */
		/* 8210AC98h case   69:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8210AC98h case   69:*/		return 0x8210AC9C;
		  /* 8210AC9Ch */ case   70:  		/* stwx R3, <#[R31 + R11]> */
		/* 8210AC9Ch case   70:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8210AC9Ch case   70:*/		return 0x8210ACA0;
		  /* 8210ACA0h */ case   71:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210ACA0h case   71:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210ACA0h case   71:*/		return 0x8210ACA4;
		  /* 8210ACA4h */ case   72:  		/* stwx R3, <#[R11 + R31]> */
		/* 8210ACA4h case   72:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8210ACA4h case   72:*/		return 0x8210ACA8;
		  /* 8210ACA8h */ case   73:  		/* lwz R11, <#[R29 + 16]> */
		/* 8210ACA8h case   73:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 8210ACA8h case   73:*/		return 0x8210ACAC;
		  /* 8210ACACh */ case   74:  		/* lwzx R11, <#[R11 + R31]> */
		/* 8210ACACh case   74:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8210ACACh case   74:*/		return 0x8210ACB0;
		  /* 8210ACB0h */ case   75:  		/* cmpwi CR6, R11, -1 */
		/* 8210ACB0h case   75:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 8210ACB0h case   75:*/		return 0x8210ACB4;
		  /* 8210ACB4h */ case   76:  		/* bc 12, CR6_EQ, 7396 */
		/* 8210ACB4h case   76:*/		if ( regs.CR[6].eq ) { return 0x8210C998;  }
		/* 8210ACB4h case   76:*/		return 0x8210ACB8;
		  /* 8210ACB8h */ case   77:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210ACB8h case   77:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210ACB8h case   77:*/		return 0x8210ACBC;
		  /* 8210ACBCh */ case   78:  		/* addi R27, R27, 1 */
		/* 8210ACBCh case   78:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8210ACBCh case   78:*/		return 0x8210ACC0;
		  /* 8210ACC0h */ case   79:  		/* lwz R10, <#[R29 + 16]> */
		/* 8210ACC0h case   79:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 8210ACC0h case   79:*/		return 0x8210ACC4;
		  /* 8210ACC4h */ case   80:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210ACC4h case   80:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210ACC4h case   80:*/		return 0x8210ACC8;
		  /* 8210ACC8h */ case   81:  		/* lwz R11, <#[R11]> */
		/* 8210ACC8h case   81:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210ACC8h case   81:*/		return 0x8210ACCC;
		  /* 8210ACCCh */ case   82:  		/* lwzx R10, <#[R10 + R31]> */
		/* 8210ACCCh case   82:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 8210ACCCh case   82:*/		return 0x8210ACD0;
		  /* 8210ACD0h */ case   83:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210ACD0h case   83:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210ACD0h case   83:*/		return 0x8210ACD4;
		  /* 8210ACD4h */ case   84:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210ACD4h case   84:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210ACD4h case   84:*/		return 0x8210ACD8;
		  /* 8210ACD8h */ case   85:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210ACD8h case   85:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210ACD8h case   85:*/		return 0x8210ACDC;
		  /* 8210ACDCh */ case   86:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210ACDCh case   86:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210ACDCh case   86:*/		return 0x8210ACE0;
		  /* 8210ACE0h */ case   87:  		/* lwz R11, <#[R11 + 24]> */
		/* 8210ACE0h case   87:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8210ACE0h case   87:*/		return 0x8210ACE4;
		  /* 8210ACE4h */ case   88:  		/* stw R11, <#[R10 + 24]> */
		/* 8210ACE4h case   88:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 8210ACE4h case   88:*/		return 0x8210ACE8;
		  /* 8210ACE8h */ case   89:  		/* lwz R11, <#[R30 + 16]> */
		/* 8210ACE8h case   89:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8210ACE8h case   89:*/		return 0x8210ACEC;
		  /* 8210ACECh */ case   90:  		/* lwz R10, <#[R29 + 16]> */
		/* 8210ACECh case   90:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 8210ACECh case   90:*/		return 0x8210ACF0;
		  /* 8210ACF0h */ case   91:  		/* lwz R9, <#[R23 + 20]> */
		/* 8210ACF0h case   91:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 8210ACF0h case   91:*/		return 0x8210ACF4;
		  /* 8210ACF4h */ case   92:  		/* lwz R11, <#[R11]> */
		/* 8210ACF4h case   92:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8210ACF4h case   92:*/		return 0x8210ACF8;
		  /* 8210ACF8h */ case   93:  		/* lwzx R10, <#[R10 + R31]> */
		/* 8210ACF8h case   93:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 8210ACF8h case   93:*/		return 0x8210ACFC;
		  /* 8210ACFCh */ case   94:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8210ACFCh case   94:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8210ACFCh case   94:*/		return 0x8210AD00;
		  /* 8210AD00h */ case   95:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8210AD00h case   95:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8210AD00h case   95:*/		return 0x8210AD04;
		  /* 8210AD04h */ case   96:  		/* lwzx R10, <#[R10 + R9]> */
		/* 8210AD04h case   96:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8210AD04h case   96:*/		return 0x8210AD08;
		  /* 8210AD08h */ case   97:  		/* addi R31, R31, 4 */
		/* 8210AD08h case   97:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8210AD08h case   97:*/		return 0x8210AD0C;
		  /* 8210AD0Ch */ case   98:  		/* cmplwi CR6, R31, 8 */
		/* 8210AD0Ch case   98:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000008);
		/* 8210AD0Ch case   98:*/		return 0x8210AD10;
		  /* 8210AD10h */ case   99:  		/* lwzx R11, <#[R11 + R9]> */
		/* 8210AD10h case   99:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8210AD10h case   99:*/		return 0x8210AD14;
		  /* 8210AD14h */ case  100:  		/* lwz R11, <#[R11 + 20]> */
		/* 8210AD14h case  100:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8210AD14h case  100:*/		return 0x8210AD18;
	}
	return 0x8210AD18;
} // Block from 8210AB84h-8210AD18h (101 instructions)

