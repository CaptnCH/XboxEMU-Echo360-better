#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 8206AAC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AAC0);
		  /* 8206AAC0h */ case    0:  		/* addi R1, R1, 160 */
		/* 8206AAC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8206AAC0h case    0:*/		return 0x8206AAC4;
		  /* 8206AAC4h */ case    1:  		/* b 157652 */
		/* 8206AAC4h case    1:*/		return 0x82091298;
		/* 8206AAC4h case    1:*/		return 0x8206AAC8;
	}
	return 0x8206AAC8;
} // Block from 8206AAC0h-8206AAC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206AAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AAC8);
		  /* 8206AAC8h */ case    0:  		/* mfspr R12, LR */
		/* 8206AAC8h case    0:*/		regs.R12 = regs.LR;
		/* 8206AAC8h case    0:*/		return 0x8206AACC;
		  /* 8206AACCh */ case    1:  		/* bl 157576 */
		/* 8206AACCh case    1:*/		regs.LR = 0x8206AAD0; return 0x82091254;
		/* 8206AACCh case    1:*/		return 0x8206AAD0;
		  /* 8206AAD0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206AAD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206AAD0h case    2:*/		return 0x8206AAD4;
		  /* 8206AAD4h */ case    3:  		/* lis R11, -32216 */
		/* 8206AAD4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8206AAD4h case    3:*/		return 0x8206AAD8;
		  /* 8206AAD8h */ case    4:  		/* mr R31, R3 */
		/* 8206AAD8h case    4:*/		regs.R31 = regs.R3;
		/* 8206AAD8h case    4:*/		return 0x8206AADC;
		  /* 8206AADCh */ case    5:  		/* lwz R10, <#[R11 + 28688]> */
		/* 8206AADCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00007010) );
		/* 8206AADCh case    5:*/		return 0x8206AAE0;
		  /* 8206AAE0h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 8206AAE0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8206AAE0h case    6:*/		return 0x8206AAE4;
		  /* 8206AAE4h */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 8206AAE4h case    7:*/		if ( regs.CR[6].eq ) { return 0x8206AB04;  }
		/* 8206AAE4h case    7:*/		return 0x8206AAE8;
		  /* 8206AAE8h */ case    8:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 8206AAE8h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 8206AAE8h case    8:*/		return 0x8206AAEC;
		  /* 8206AAECh */ case    9:  		/* mtspr CTR, R11 */
		/* 8206AAECh case    9:*/		regs.CTR = regs.R11;
		/* 8206AAECh case    9:*/		return 0x8206AAF0;
		  /* 8206AAF0h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 8206AAF0h case   10:*/		if ( 1 ) { regs.LR = 0x8206AAF4; return (uint32)regs.CTR; }
		/* 8206AAF0h case   10:*/		return 0x8206AAF4;
		  /* 8206AAF4h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 8206AAF4h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206AAF4h case   11:*/		return 0x8206AAF8;
		  /* 8206AAF8h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 8206AAF8h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8206AB04;  }
		/* 8206AAF8h case   12:*/		return 0x8206AAFC;
		  /* 8206AAFCh */ case   13:  		/* li R3, 0 */
		/* 8206AAFCh case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8206AAFCh case   13:*/		return 0x8206AB00;
		  /* 8206AB00h */ case   14:  		/* b 176 */
		/* 8206AB00h case   14:*/		return 0x8206ABB0;
		/* 8206AB00h case   14:*/		return 0x8206AB04;
	}
	return 0x8206AB04;
} // Block from 8206AAC8h-8206AB04h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206AB04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AB04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AB04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AB04);
		  /* 8206AB04h */ case    0:  		/* lwz R10, <#[R31]> */
		/* 8206AB04h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8206AB04h case    0:*/		return 0x8206AB08;
		  /* 8206AB08h */ case    1:  		/* lis R4, 9344 */
		/* 8206AB08h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206AB08h case    1:*/		return 0x8206AB0C;
		  /* 8206AB0Ch */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206AB0Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206AB0Ch case    2:*/		return 0x8206AB10;
		  /* 8206AB10h */ case    3:  		/* rlwinm R10, R10, 0, 31, 31 */
		/* 8206AB10h case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8206AB10h case    3:*/		return 0x8206AB14;
		  /* 8206AB14h */ case    4:  		/* lwz R29, <#[R31 + 8]> */
		/* 8206AB14h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 8206AB14h case    4:*/		return 0x8206AB18;
		  /* 8206AB18h */ case    5:  		/* add R28, R11, R31 */
		/* 8206AB18h case    5:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R31);
		/* 8206AB18h case    5:*/		return 0x8206AB1C;
		  /* 8206AB1Ch */ case    6:  		/* subfic R10, R10, 0 */
		/* 8206AB1Ch case    6:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x0);
		/* 8206AB1Ch case    6:*/		return 0x8206AB20;
		  /* 8206AB20h */ case    7:  		/* subfe R10, R10, R10 */
		/* 8206AB20h case    7:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8206AB20h case    7:*/		return 0x8206AB24;
		  /* 8206AB24h */ case    8:  		/* andi. R10, R10, 832 */
		/* 8206AB24h case    8:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x340);
		/* 8206AB24h case    8:*/		return 0x8206AB28;
		  /* 8206AB28h */ case    9:  		/* addi R10, R10, 40 */
		/* 8206AB28h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x28);
		/* 8206AB28h case    9:*/		return 0x8206AB2C;
		  /* 8206AB2Ch */ case   10:  		/* add R3, R10, R11 */
		/* 8206AB2Ch case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8206AB2Ch case   10:*/		return 0x8206AB30;
		  /* 8206AB30h */ case   11:  		/* bl 120528 */
		/* 8206AB30h case   11:*/		regs.LR = 0x8206AB34; return 0x82088200;
		/* 8206AB30h case   11:*/		return 0x8206AB34;
		  /* 8206AB34h */ case   12:  		/* or. R30, R3, R3 */
		/* 8206AB34h case   12:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8206AB34h case   12:*/		return 0x8206AB38;
		  /* 8206AB38h */ case   13:  		/* bc 12, CR0_EQ, -60 */
		/* 8206AB38h case   13:*/		if ( regs.CR[0].eq ) { return 0x8206AAFC;  }
		/* 8206AB38h case   13:*/		return 0x8206AB3C;
		  /* 8206AB3Ch */ case   14:  		/* li R5, 872 */
		/* 8206AB3Ch case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x368);
		/* 8206AB3Ch case   14:*/		return 0x8206AB40;
		  /* 8206AB40h */ case   15:  		/* lwz R27, <#[R31 + 4]> */
		/* 8206AB40h case   15:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x00000004) );
		/* 8206AB40h case   15:*/		return 0x8206AB44;
		  /* 8206AB44h */ case   16:  		/* li R4, 0 */
		/* 8206AB44h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206AB44h case   16:*/		return 0x8206AB48;
		  /* 8206AB48h */ case   17:  		/* mr R3, R30 */
		/* 8206AB48h case   17:*/		regs.R3 = regs.R30;
		/* 8206AB48h case   17:*/		return 0x8206AB4C;
		  /* 8206AB4Ch */ case   18:  		/* bl 157684 */
		/* 8206AB4Ch case   18:*/		regs.LR = 0x8206AB50; return 0x82091340;
		/* 8206AB4Ch case   18:*/		return 0x8206AB50;
		  /* 8206AB50h */ case   19:  		/* mr R5, R27 */
		/* 8206AB50h case   19:*/		regs.R5 = regs.R27;
		/* 8206AB50h case   19:*/		return 0x8206AB54;
		  /* 8206AB54h */ case   20:  		/* mr R4, R31 */
		/* 8206AB54h case   20:*/		regs.R4 = regs.R31;
		/* 8206AB54h case   20:*/		return 0x8206AB58;
		  /* 8206AB58h */ case   21:  		/* addi R3, R30, 872 */
		/* 8206AB58h case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x368);
		/* 8206AB58h case   21:*/		return 0x8206AB5C;
		  /* 8206AB5Ch */ case   22:  		/* bl 119724 */
		/* 8206AB5Ch case   22:*/		regs.LR = 0x8206AB60; return 0x82087F08;
		/* 8206AB5Ch case   22:*/		return 0x8206AB60;
		  /* 8206AB60h */ case   23:  		/* lis R4, -19072 */
		/* 8206AB60h case   23:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB580);
		/* 8206AB60h case   23:*/		return 0x8206AB64;
		  /* 8206AB64h */ case   24:  		/* mr R3, R29 */
		/* 8206AB64h case   24:*/		regs.R3 = regs.R29;
		/* 8206AB64h case   24:*/		return 0x8206AB68;
		  /* 8206AB68h */ case   25:  		/* bl 120472 */
		/* 8206AB68h case   25:*/		regs.LR = 0x8206AB6C; return 0x82088200;
		/* 8206AB68h case   25:*/		return 0x8206AB6C;
		  /* 8206AB6Ch */ case   26:  		/* or. R31, R3, R3 */
		/* 8206AB6Ch case   26:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8206AB6Ch case   26:*/		return 0x8206AB70;
		  /* 8206AB70h */ case   27:  		/* bc 4, CR0_EQ, 20 */
		/* 8206AB70h case   27:*/		if ( !regs.CR[0].eq ) { return 0x8206AB84;  }
		/* 8206AB70h case   27:*/		return 0x8206AB74;
		  /* 8206AB74h */ case   28:  		/* lis R4, 9344 */
		/* 8206AB74h case   28:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206AB74h case   28:*/		return 0x8206AB78;
		  /* 8206AB78h */ case   29:  		/* mr R3, R30 */
		/* 8206AB78h case   29:*/		regs.R3 = regs.R30;
		/* 8206AB78h case   29:*/		return 0x8206AB7C;
		  /* 8206AB7Ch */ case   30:  		/* bl 120764 */
		/* 8206AB7Ch case   30:*/		regs.LR = 0x8206AB80; return 0x82088338;
		/* 8206AB7Ch case   30:*/		return 0x8206AB80;
		  /* 8206AB80h */ case   31:  		/* b -132 */
		/* 8206AB80h case   31:*/		return 0x8206AAFC;
		/* 8206AB80h case   31:*/		return 0x8206AB84;
	}
	return 0x8206AB84;
} // Block from 8206AB04h-8206AB84h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8206AB84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AB84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AB84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AB84);
		  /* 8206AB84h */ case    0:  		/* mr R5, R29 */
		/* 8206AB84h case    0:*/		regs.R5 = regs.R29;
		/* 8206AB84h case    0:*/		return 0x8206AB88;
		  /* 8206AB88h */ case    1:  		/* mr R4, R28 */
		/* 8206AB88h case    1:*/		regs.R4 = regs.R28;
		/* 8206AB88h case    1:*/		return 0x8206AB8C;
		  /* 8206AB8Ch */ case    2:  		/* mr R3, R31 */
		/* 8206AB8Ch case    2:*/		regs.R3 = regs.R31;
		/* 8206AB8Ch case    2:*/		return 0x8206AB90;
		  /* 8206AB90h */ case    3:  		/* bl 159264 */
		/* 8206AB90h case    3:*/		regs.LR = 0x8206AB94; return 0x820919B0;
		/* 8206AB90h case    3:*/		return 0x8206AB94;
		  /* 8206AB94h */ case    4:  		/* mr R4, R31 */
		/* 8206AB94h case    4:*/		regs.R4 = regs.R31;
		/* 8206AB94h case    4:*/		return 0x8206AB98;
		  /* 8206AB98h */ case    5:  		/* mr R3, R30 */
		/* 8206AB98h case    5:*/		regs.R3 = regs.R30;
		/* 8206AB98h case    5:*/		return 0x8206AB9C;
		  /* 8206AB9Ch */ case    6:  		/* bl -460 */
		/* 8206AB9Ch case    6:*/		regs.LR = 0x8206ABA0; return 0x8206A9D0;
		/* 8206AB9Ch case    6:*/		return 0x8206ABA0;
		  /* 8206ABA0h */ case    7:  		/* lwz R11, <#[R30]> */
		/* 8206ABA0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206ABA0h case    7:*/		return 0x8206ABA4;
		  /* 8206ABA4h */ case    8:  		/* mr R3, R30 */
		/* 8206ABA4h case    8:*/		regs.R3 = regs.R30;
		/* 8206ABA4h case    8:*/		return 0x8206ABA8;
		  /* 8206ABA8h */ case    9:  		/* oris R11, R11, 16 */
		/* 8206ABA8h case    9:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206ABA8h case    9:*/		return 0x8206ABAC;
		  /* 8206ABACh */ case   10:  		/* stw R11, <#[R30]> */
		/* 8206ABACh case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206ABACh case   10:*/		return 0x8206ABB0;
	}
	return 0x8206ABB0;
} // Block from 8206AB84h-8206ABB0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206ABB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206ABB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206ABB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206ABB0);
		  /* 8206ABB0h */ case    0:  		/* addi R1, R1, 128 */
		/* 8206ABB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206ABB0h case    0:*/		return 0x8206ABB4;
		  /* 8206ABB4h */ case    1:  		/* b 157424 */
		/* 8206ABB4h case    1:*/		return 0x820912A4;
		/* 8206ABB4h case    1:*/		return 0x8206ABB8;
	}
	return 0x8206ABB8;
} // Block from 8206ABB0h-8206ABB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206ABB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206ABB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206ABB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206ABB8);
		  /* 8206ABB8h */ case    0:  		/* mfspr R12, LR */
		/* 8206ABB8h case    0:*/		regs.R12 = regs.LR;
		/* 8206ABB8h case    0:*/		return 0x8206ABBC;
		  /* 8206ABBCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206ABBCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206ABBCh case    1:*/		return 0x8206ABC0;
		  /* 8206ABC0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8206ABC0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206ABC0h case    2:*/		return 0x8206ABC4;
		  /* 8206ABC4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8206ABC4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8206ABC4h case    3:*/		return 0x8206ABC8;
		  /* 8206ABC8h */ case    4:  		/* stw R4, <#[R3 + 12808]> */
		/* 8206ABC8h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003208) );
		/* 8206ABC8h case    4:*/		return 0x8206ABCC;
		  /* 8206ABCCh */ case    5:  		/* mr R11, R4 */
		/* 8206ABCCh case    5:*/		regs.R11 = regs.R4;
		/* 8206ABCCh case    5:*/		return 0x8206ABD0;
		  /* 8206ABD0h */ case    6:  		/* mr R31, R3 */
		/* 8206ABD0h case    6:*/		regs.R31 = regs.R3;
		/* 8206ABD0h case    6:*/		return 0x8206ABD4;
		  /* 8206ABD4h */ case    7:  		/* addi R4, R3, 12568 */
		/* 8206ABD4h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x3118);
		/* 8206ABD4h case    7:*/		return 0x8206ABD8;
		  /* 8206ABD8h */ case    8:  		/* mr R3, R11 */
		/* 8206ABD8h case    8:*/		regs.R3 = regs.R11;
		/* 8206ABD8h case    8:*/		return 0x8206ABDC;
		  /* 8206ABDCh */ case    9:  		/* bl -15068 */
		/* 8206ABDCh case    9:*/		regs.LR = 0x8206ABE0; return 0x82067100;
		/* 8206ABDCh case    9:*/		return 0x8206ABE0;
		  /* 8206ABE0h */ case   10:  		/* stw R4, <#[R31 + 12240]> */
		/* 8206ABE0h case   10:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x00002FD0) );
		/* 8206ABE0h case   10:*/		return 0x8206ABE4;
		  /* 8206ABE4h */ case   11:  		/* ld R11, <#[R31 + 16]> */
		/* 8206ABE4h case   11:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206ABE4h case   11:*/		return 0x8206ABE8;
		  /* 8206ABE8h */ case   12:  		/* oris R11, R11, 8 */
		/* 8206ABE8h case   12:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8206ABE8h case   12:*/		return 0x8206ABEC;
		  /* 8206ABECh */ case   13:  		/* std R11, <#[R31 + 16]> */
		/* 8206ABECh case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206ABECh case   13:*/		return 0x8206ABF0;
		  /* 8206ABF0h */ case   14:  		/* addi R1, R1, 96 */
		/* 8206ABF0h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206ABF0h case   14:*/		return 0x8206ABF4;
		  /* 8206ABF4h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206ABF4h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206ABF4h case   15:*/		return 0x8206ABF8;
		  /* 8206ABF8h */ case   16:  		/* mtspr LR, R12 */
		/* 8206ABF8h case   16:*/		regs.LR = regs.R12;
		/* 8206ABF8h case   16:*/		return 0x8206ABFC;
		  /* 8206ABFCh */ case   17:  		/* ld R31, <#[R1 - 16]> */
		/* 8206ABFCh case   17:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206ABFCh case   17:*/		return 0x8206AC00;
		  /* 8206AC00h */ case   18:  		/* bclr 20, CR0_LT */
		/* 8206AC00h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206AC00h case   18:*/		return 0x8206AC04;
	}
	return 0x8206AC04;
} // Block from 8206ABB8h-8206AC04h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206AC04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AC04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AC04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AC04);
		  /* 8206AC04h */ case    0:  		/* nop */
		/* 8206AC04h case    0:*/		cpu::op::nop();
		/* 8206AC04h case    0:*/		return 0x8206AC08;
	}
	return 0x8206AC08;
} // Block from 8206AC04h-8206AC08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206AC08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AC08);
		  /* 8206AC08h */ case    0:  		/* mfspr R12, LR */
		/* 8206AC08h case    0:*/		regs.R12 = regs.LR;
		/* 8206AC08h case    0:*/		return 0x8206AC0C;
		  /* 8206AC0Ch */ case    1:  		/* bl 157212 */
		/* 8206AC0Ch case    1:*/		regs.LR = 0x8206AC10; return 0x82091228;
		/* 8206AC0Ch case    1:*/		return 0x8206AC10;
		  /* 8206AC10h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 8206AC10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 8206AC10h case    2:*/		return 0x8206AC14;
		  /* 8206AC14h */ case    3:  		/* mr R25, R3 */
		/* 8206AC14h case    3:*/		regs.R25 = regs.R3;
		/* 8206AC14h case    3:*/		return 0x8206AC18;
		  /* 8206AC18h */ case    4:  		/* lwz R3, <#[R3 + 9568]> */
		/* 8206AC18h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00002560) );
		/* 8206AC18h case    4:*/		return 0x8206AC1C;
		  /* 8206AC1Ch */ case    5:  		/* mr R20, R4 */
		/* 8206AC1Ch case    5:*/		regs.R20 = regs.R4;
		/* 8206AC1Ch case    5:*/		return 0x8206AC20;
		  /* 8206AC20h */ case    6:  		/* cmpwi CR6, R3, 0 */
		/* 8206AC20h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8206AC20h case    6:*/		return 0x8206AC24;
		  /* 8206AC24h */ case    7:  		/* bc 12, CR6_LT, 1108 */
		/* 8206AC24h case    7:*/		if ( regs.CR[6].lt ) { return 0x8206B078;  }
		/* 8206AC24h case    7:*/		return 0x8206AC28;
		  /* 8206AC28h */ case    8:  		/* lwz R11, <#[R25 + 9564]> */
		/* 8206AC28h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000255C) );
		/* 8206AC28h case    8:*/		return 0x8206AC2C;
		  /* 8206AC2Ch */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 8206AC2Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206AC2Ch case    9:*/		return 0x8206AC30;
		  /* 8206AC30h */ case   10:  		/* bc 4, CR6_EQ, 1080 */
		/* 8206AC30h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8206B068;  }
		/* 8206AC30h case   10:*/		return 0x8206AC34;
		  /* 8206AC34h */ case   11:  		/* addi R31, R4, 20 */
		/* 8206AC34h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R4,0x14);
		/* 8206AC34h case   11:*/		return 0x8206AC38;
		  /* 8206AC38h */ case   12:  		/* lwz R17, <#[R4 + 24]> */
		/* 8206AC38h case   12:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R4 + 0x00000018) );
		/* 8206AC38h case   12:*/		return 0x8206AC3C;
		  /* 8206AC3Ch */ case   13:  		/* addi R30, R25, 9120 */
		/* 8206AC3Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R25,0x23A0);
		/* 8206AC3Ch case   13:*/		return 0x8206AC40;
		  /* 8206AC40h */ case   14:  		/* li R5, 20 */
		/* 8206AC40h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x14);
		/* 8206AC40h case   14:*/		return 0x8206AC44;
		  /* 8206AC44h */ case   15:  		/* mr R4, R30 */
		/* 8206AC44h case   15:*/		regs.R4 = regs.R30;
		/* 8206AC44h case   15:*/		return 0x8206AC48;
		  /* 8206AC48h */ case   16:  		/* mr R3, R31 */
		/* 8206AC48h case   16:*/		regs.R3 = regs.R31;
		/* 8206AC48h case   16:*/		return 0x8206AC4C;
		  /* 8206AC4Ch */ case   17:  		/* bl -13740 */
		/* 8206AC4Ch case   17:*/		regs.LR = 0x8206AC50; return 0x820676A0;
		/* 8206AC4Ch case   17:*/		return 0x8206AC50;
		  /* 8206AC50h */ case   18:  		/* lwz R11, <#[R25 + 9572]> */
		/* 8206AC50h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00002564) );
		/* 8206AC50h case   18:*/		return 0x8206AC54;
		  /* 8206AC54h */ case   19:  		/* li R18, 1 */
		/* 8206AC54h case   19:*/		cpu::op::li<0>(regs,&regs.R18,0x1);
		/* 8206AC54h case   19:*/		return 0x8206AC58;
		  /* 8206AC58h */ case   20:  		/* lwz R10, <#[R11 + 19892]> */
		/* 8206AC58h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206AC58h case   20:*/		return 0x8206AC5C;
		  /* 8206AC5Ch */ case   21:  		/* rlwinm. R10, R10, 26, 31, 31 */
		/* 8206AC5Ch case   21:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R10,regs.R10);
		/* 8206AC5Ch case   21:*/		return 0x8206AC60;
		  /* 8206AC60h */ case   22:  		/* lwz R16, <#[R20 + 24]> */
		/* 8206AC60h case   22:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R20 + 0x00000018) );
		/* 8206AC60h case   22:*/		return 0x8206AC64;
		  /* 8206AC64h */ case   23:  		/* bc 12, CR0_EQ, 400 */
		/* 8206AC64h case   23:*/		if ( regs.CR[0].eq ) { return 0x8206ADF4;  }
		/* 8206AC64h case   23:*/		return 0x8206AC68;
	}
	return 0x8206AC68;
} // Block from 8206AC08h-8206AC68h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8206AC68h
// Function '?AddFlow@CMicrocodeBuilder@D3D@@QAAKPATGPUFLOW_INSTRUCTION@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AC68);
		  /* 8206AC68h */ case    0:  		/* lwz R10, <#[R25 + 9560]> */
		/* 8206AC68h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00002558) );
		/* 8206AC68h case    0:*/		return 0x8206AC6C;
		  /* 8206AC6Ch */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 8206AC6Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8206AC6Ch case    1:*/		return 0x8206AC70;
		  /* 8206AC70h */ case    2:  		/* bc 12, CR6_EQ, 388 */
		/* 8206AC70h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206ADF4;  }
		/* 8206AC70h case    2:*/		return 0x8206AC74;
		  /* 8206AC74h */ case    3:  		/* lwz R10, <#[R11 + 19932]> */
		/* 8206AC74h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00004DDC) );
		/* 8206AC74h case    3:*/		return 0x8206AC78;
		  /* 8206AC78h */ case    4:  		/* cmpwi CR6, R10, 0 */
		/* 8206AC78h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8206AC78h case    4:*/		return 0x8206AC7C;
		  /* 8206AC7Ch */ case    5:  		/* bc 12, CR6_EQ, 376 */
		/* 8206AC7Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8206ADF4;  }
		/* 8206AC7Ch case    5:*/		return 0x8206AC80;
		  /* 8206AC80h */ case    6:  		/* li R19, 0 */
		/* 8206AC80h case    6:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8206AC80h case    6:*/		return 0x8206AC84;
		  /* 8206AC84h */ case    7:  		/* mr R21, R18 */
		/* 8206AC84h case    7:*/		regs.R21 = regs.R18;
		/* 8206AC84h case    7:*/		return 0x8206AC88;
		  /* 8206AC88h */ case    8:  		/* stw R19, <#[R11 + 19932]> */
		/* 8206AC88h case    8:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00004DDC) );
		/* 8206AC88h case    8:*/		return 0x8206AC8C;
		  /* 8206AC8Ch */ case    9:  		/* lwz R11, <#[R25 + 9572]> */
		/* 8206AC8Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00002564) );
		/* 8206AC8Ch case    9:*/		return 0x8206AC90;
		  /* 8206AC90h */ case   10:  		/* mr R26, R19 */
		/* 8206AC90h case   10:*/		regs.R26 = regs.R19;
		/* 8206AC90h case   10:*/		return 0x8206AC94;
		  /* 8206AC94h */ case   11:  		/* ld R22, <#[R30]> */
		/* 8206AC94h case   11:*/		cpu::mem::load64( regs, &regs.R22, (uint32)(regs.R30 + 0x00000000) );
		/* 8206AC94h case   11:*/		return 0x8206AC98;
		  /* 8206AC98h */ case   12:  		/* lwz R10, <#[R11 + 19892]> */
		/* 8206AC98h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206AC98h case   12:*/		return 0x8206AC9C;
		  /* 8206AC9Ch */ case   13:  		/* lwz R23, <#[R11 + 19936]> */
		/* 8206AC9Ch case   13:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x00004DE0) );
		/* 8206AC9Ch case   13:*/		return 0x8206ACA0;
		  /* 8206ACA0h */ case   14:  		/* rlwinm R24, R10, 6, 23, 23 */
		/* 8206ACA0h case   14:*/		cpu::op::rlwinm<0,6,23,23>(regs,&regs.R24,regs.R10);
		/* 8206ACA0h case   14:*/		return 0x8206ACA4;
		  /* 8206ACA4h */ case   15:  		/* rlwinm R11, R26, 0, 2, 31 */
		/* 8206ACA4h case   15:*/		cpu::op::rlwinm<0,0,2,31>(regs,&regs.R11,regs.R26);
		/* 8206ACA4h case   15:*/		return 0x8206ACA8;
		  /* 8206ACA8h */ case   16:  		/* rlwinm R10, R26, 2, 0, 29 */
		/* 8206ACA8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R26);
		/* 8206ACA8h case   16:*/		return 0x8206ACAC;
		  /* 8206ACACh */ case   17:  		/* subfic R11, R11, 63 */
		/* 8206ACACh case   17:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x3F);
		/* 8206ACACh case   17:*/		return 0x8206ACB0;
		  /* 8206ACB0h */ case   18:  		/* rldicl R11, R11, 0, 32 */
		/* 8206ACB0h case   18:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 8206ACB0h case   18:*/		return 0x8206ACB4;
		  /* 8206ACB4h */ case   19:  		/* sld R11, R18, R11 */
		/* 8206ACB4h case   19:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R18,regs.R11);
		/* 8206ACB4h case   19:*/		return 0x8206ACB8;
		  /* 8206ACB8h */ case   20:  		/* and R11, R11, R22 */
		/* 8206ACB8h case   20:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R22);
		/* 8206ACB8h case   20:*/		return 0x8206ACBC;
		  /* 8206ACBCh */ case   21:  		/* cmpdi CR6, R11, 0 */
		/* 8206ACBCh case   21:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x00000000);
		/* 8206ACBCh case   21:*/		return 0x8206ACC0;
		  /* 8206ACC0h */ case   22:  		/* bc 12, CR6_EQ, 388 */
		/* 8206ACC0h case   22:*/		if ( regs.CR[6].eq ) { return 0x8206AE44;  }
		/* 8206ACC0h case   22:*/		return 0x8206ACC4;
		  /* 8206ACC4h */ case   23:  		/* addi R11, R26, 1 */
		/* 8206ACC4h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1);
		/* 8206ACC4h case   23:*/		return 0x8206ACC8;
		  /* 8206ACC8h */ case   24:  		/* mr R28, R26 */
		/* 8206ACC8h case   24:*/		regs.R28 = regs.R26;
		/* 8206ACC8h case   24:*/		return 0x8206ACCC;
		  /* 8206ACCCh */ case   25:  		/* cmplwi CR6, R11, 64 */
		/* 8206ACCCh case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000040);
		/* 8206ACCCh case   25:*/		return 0x8206ACD0;
		  /* 8206ACD0h */ case   26:  		/* bc 4, CR6_LT, 76 */
		/* 8206ACD0h case   26:*/		if ( !regs.CR[6].lt ) { return 0x8206AD1C;  }
		/* 8206ACD0h case   26:*/		return 0x8206ACD4;
		  /* 8206ACD4h */ case   27:  		/* addi R10, R10, 4 */
		/* 8206ACD4h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8206ACD4h case   27:*/		return 0x8206ACD8;
		  /* 8206ACD8h */ case   28:  		/* rlwinm R9, R10, 30, 2, 31 */
		/* 8206ACD8h case   28:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R9,regs.R10);
		/* 8206ACD8h case   28:*/		return 0x8206ACDC;
		  /* 8206ACDCh */ case   29:  		/* subfic R9, R9, 63 */
		/* 8206ACDCh case   29:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R9,0x3F);
		/* 8206ACDCh case   29:*/		return 0x8206ACE0;
		  /* 8206ACE0h */ case   30:  		/* rldicl R9, R9, 0, 32 */
		/* 8206ACE0h case   30:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R9);
		/* 8206ACE0h case   30:*/		return 0x8206ACE4;
		  /* 8206ACE4h */ case   31:  		/* sld R9, R18, R9 */
		/* 8206ACE4h case   31:*/		cpu::op::sld<0>(regs,&regs.R9,regs.R18,regs.R9);
		/* 8206ACE4h case   31:*/		return 0x8206ACE8;
		  /* 8206ACE8h */ case   32:  		/* and R9, R9, R22 */
		/* 8206ACE8h case   32:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R22);
		/* 8206ACE8h case   32:*/		return 0x8206ACEC;
		  /* 8206ACECh */ case   33:  		/* cmpdi CR6, R9, 0 */
		/* 8206ACECh case   33:*/		cpu::op::cmpdi<6>(regs,regs.R9,0x00000000);
		/* 8206ACECh case   33:*/		return 0x8206ACF0;
		  /* 8206ACF0h */ case   34:  		/* bc 12, CR6_EQ, 44 */
		/* 8206ACF0h case   34:*/		if ( regs.CR[6].eq ) { return 0x8206AD1C;  }
		/* 8206ACF0h case   34:*/		return 0x8206ACF4;
		  /* 8206ACF4h */ case   35:  		/* lwz R9, <#[R25 + 9560]> */
		/* 8206ACF4h case   35:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00002558) );
		/* 8206ACF4h case   35:*/		return 0x8206ACF8;
		  /* 8206ACF8h */ case   36:  		/* cmpwi CR6, R9, 0 */
		/* 8206ACF8h case   36:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8206ACF8h case   36:*/		return 0x8206ACFC;
		  /* 8206ACFCh */ case   37:  		/* bc 4, CR6_EQ, 12 */
		/* 8206ACFCh case   37:*/		if ( !regs.CR[6].eq ) { return 0x8206AD08;  }
		/* 8206ACFCh case   37:*/		return 0x8206AD00;
		  /* 8206AD00h */ case   38:  		/* cmplw CR6, R11, R23 */
		/* 8206AD00h case   38:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 8206AD00h case   38:*/		return 0x8206AD04;
		  /* 8206AD04h */ case   39:  		/* bc 12, CR6_EQ, 24 */
		/* 8206AD04h case   39:*/		if ( regs.CR[6].eq ) { return 0x8206AD1C;  }
		/* 8206AD04h case   39:*/		return 0x8206AD08;
	}
	return 0x8206AD08;
} // Block from 8206AC68h-8206AD08h (40 instructions)

//////////////////////////////////////////////////////
// Block at 8206AD08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AD08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AD08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AD08);
		  /* 8206AD08h */ case    0:  		/* addi R11, R11, 1 */
		/* 8206AD08h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206AD08h case    0:*/		return 0x8206AD0C;
		  /* 8206AD0Ch */ case    1:  		/* addi R26, R26, 1 */
		/* 8206AD0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8206AD0Ch case    1:*/		return 0x8206AD10;
		  /* 8206AD10h */ case    2:  		/* addi R10, R10, 4 */
		/* 8206AD10h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8206AD10h case    2:*/		return 0x8206AD14;
		  /* 8206AD14h */ case    3:  		/* cmplwi CR6, R11, 64 */
		/* 8206AD14h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000040);
		/* 8206AD14h case    3:*/		return 0x8206AD18;
		  /* 8206AD18h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 8206AD18h case    4:*/		if ( regs.CR[6].lt ) { return 0x8206ACD8;  }
		/* 8206AD18h case    4:*/		return 0x8206AD1C;
	}
	return 0x8206AD1C;
} // Block from 8206AD08h-8206AD1Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206AD1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AD1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AD1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AD1C);
		  /* 8206AD1Ch */ case    0:  		/* rlwinm R11, R28, 2, 0, 29 */
		/* 8206AD1Ch case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R28);
		/* 8206AD1Ch case    0:*/		return 0x8206AD20;
		  /* 8206AD20h */ case    1:  		/* lwz R27, <#[R20 + 4]> */
		/* 8206AD20h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R20 + 0x00000004) );
		/* 8206AD20h case    1:*/		return 0x8206AD24;
		  /* 8206AD24h */ case    2:  		/* subf R10, R28, R26 */
		/* 8206AD24h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R28,regs.R26);
		/* 8206AD24h case    2:*/		return 0x8206AD28;
		  /* 8206AD28h */ case    3:  		/* add R30, R11, R24 */
		/* 8206AD28h case    3:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R24);
		/* 8206AD28h case    3:*/		return 0x8206AD2C;
		  /* 8206AD2Ch */ case    4:  		/* li R5, 2 */
		/* 8206AD2Ch case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8206AD2Ch case    4:*/		return 0x8206AD30;
		  /* 8206AD30h */ case    5:  		/* sth R30, <#[R1 + 80]> */
		/* 8206AD30h case    5:*/		cpu::mem::store16( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AD30h case    5:*/		return 0x8206AD34;
		  /* 8206AD34h */ case    6:  		/* addi R4, R1, 80 */
		/* 8206AD34h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206AD34h case    6:*/		return 0x8206AD38;
		  /* 8206AD38h */ case    7:  		/* mr R3, R31 */
		/* 8206AD38h case    7:*/		regs.R3 = regs.R31;
		/* 8206AD38h case    7:*/		return 0x8206AD3C;
		  /* 8206AD3Ch */ case    8:  		/* addi R29, R10, 1 */
		/* 8206AD3Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0x1);
		/* 8206AD3Ch case    8:*/		return 0x8206AD40;
		  /* 8206AD40h */ case    9:  		/* bl -13984 */
		/* 8206AD40h case    9:*/		regs.LR = 0x8206AD44; return 0x820676A0;
		/* 8206AD40h case    9:*/		return 0x8206AD44;
		  /* 8206AD44h */ case   10:  		/* rlwinm R11, R29, 4, 16, 27 */
		/* 8206AD44h case   10:*/		cpu::op::rlwinm<0,4,16,27>(regs,&regs.R11,regs.R29);
		/* 8206AD44h case   10:*/		return 0x8206AD48;
		  /* 8206AD48h */ case   11:  		/* li R5, 2 */
		/* 8206AD48h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8206AD48h case   11:*/		return 0x8206AD4C;
		  /* 8206AD4Ch */ case   12:  		/* sth R11, <#[R1 + 80]> */
		/* 8206AD4Ch case   12:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AD4Ch case   12:*/		return 0x8206AD50;
		  /* 8206AD50h */ case   13:  		/* addi R4, R1, 80 */
		/* 8206AD50h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206AD50h case   13:*/		return 0x8206AD54;
		  /* 8206AD54h */ case   14:  		/* mr R3, R31 */
		/* 8206AD54h case   14:*/		regs.R3 = regs.R31;
		/* 8206AD54h case   14:*/		return 0x8206AD58;
		  /* 8206AD58h */ case   15:  		/* bl -14008 */
		/* 8206AD58h case   15:*/		regs.LR = 0x8206AD5C; return 0x820676A0;
		/* 8206AD58h case   15:*/		return 0x8206AD5C;
		  /* 8206AD5Ch */ case   16:  		/* addi R11, R30, 48 */
		/* 8206AD5Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x30);
		/* 8206AD5Ch case   16:*/		return 0x8206AD60;
		  /* 8206AD60h */ case   17:  		/* rlwinm R5, R29, 6, 0, 25 */
		/* 8206AD60h case   17:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R5,regs.R29);
		/* 8206AD60h case   17:*/		return 0x8206AD64;
		  /* 8206AD64h */ case   18:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 8206AD64h case   18:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 8206AD64h case   18:*/		return 0x8206AD68;
		  /* 8206AD68h */ case   19:  		/* add R4, R11, R25 */
		/* 8206AD68h case   19:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R25);
		/* 8206AD68h case   19:*/		return 0x8206AD6C;
		  /* 8206AD6Ch */ case   20:  		/* lwz R11, <#[R25 + 9560]> */
		/* 8206AD6Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00002558) );
		/* 8206AD6Ch case   20:*/		return 0x8206AD70;
		  /* 8206AD70h */ case   21:  		/* cmpwi CR6, R11, 0 */
		/* 8206AD70h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206AD70h case   21:*/		return 0x8206AD74;
		  /* 8206AD74h */ case   22:  		/* bc 12, CR6_EQ, 140 */
		/* 8206AD74h case   22:*/		if ( regs.CR[6].eq ) { return 0x8206AE00;  }
		/* 8206AD74h case   22:*/		return 0x8206AD78;
		  /* 8206AD78h */ case   23:  		/* mr R3, R20 */
		/* 8206AD78h case   23:*/		regs.R3 = regs.R20;
		/* 8206AD78h case   23:*/		return 0x8206AD7C;
		  /* 8206AD7Ch */ case   24:  		/* bl -14044 */
		/* 8206AD7Ch case   24:*/		regs.LR = 0x8206AD80; return 0x820676A0;
		/* 8206AD7Ch case   24:*/		return 0x8206AD80;
		  /* 8206AD80h */ case   25:  		/* stw R27, <#[R1 + 80]> */
		/* 8206AD80h case   25:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AD80h case   25:*/		return 0x8206AD84;
		  /* 8206AD84h */ case   26:  		/* li R5, 4 */
		/* 8206AD84h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8206AD84h case   26:*/		return 0x8206AD88;
	}
	return 0x8206AD88;
} // Block from 8206AD1Ch-8206AD88h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8206AD88h
// Function '?FindCommonALULiteralConstants@CMicrocodeBuilder@D3D@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AD88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AD88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AD88);
		  /* 8206AD88h */ case    0:  		/* addi R4, R1, 80 */
		/* 8206AD88h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206AD88h case    0:*/		return 0x8206AD8C;
		  /* 8206AD8Ch */ case    1:  		/* mr R3, R31 */
		/* 8206AD8Ch case    1:*/		regs.R3 = regs.R31;
		/* 8206AD8Ch case    1:*/		return 0x8206AD90;
		  /* 8206AD90h */ case    2:  		/* bl -14064 */
		/* 8206AD90h case    2:*/		regs.LR = 0x8206AD94; return 0x820676A0;
		/* 8206AD90h case    2:*/		return 0x8206AD94;
		  /* 8206AD94h */ case    3:  		/* cmpwi CR6, R21, 0 */
		/* 8206AD94h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8206AD94h case    3:*/		return 0x8206AD98;
		  /* 8206AD98h */ case    4:  		/* bc 12, CR6_EQ, 172 */
		/* 8206AD98h case    4:*/		if ( regs.CR[6].eq ) { return 0x8206AE44;  }
		/* 8206AD98h case    4:*/		return 0x8206AD9C;
		  /* 8206AD9Ch */ case    5:  		/* cmplw CR6, R28, R23 */
		/* 8206AD9Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R23);
		/* 8206AD9Ch case    5:*/		return 0x8206ADA0;
		  /* 8206ADA0h */ case    6:  		/* mr R11, R28 */
		/* 8206ADA0h case    6:*/		regs.R11 = regs.R28;
		/* 8206ADA0h case    6:*/		return 0x8206ADA4;
		  /* 8206ADA4h */ case    7:  		/* bc 12, CR6_GT, 8 */
		/* 8206ADA4h case    7:*/		if ( regs.CR[6].gt ) { return 0x8206ADAC;  }
		/* 8206ADA4h case    7:*/		return 0x8206ADA8;
		  /* 8206ADA8h */ case    8:  		/* mr R11, R23 */
		/* 8206ADA8h case    8:*/		regs.R11 = regs.R23;
		/* 8206ADA8h case    8:*/		return 0x8206ADAC;
	}
	return 0x8206ADAC;
} // Block from 8206AD88h-8206ADACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206ADACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206ADAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206ADAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206ADAC);
		  /* 8206ADACh */ case    0:  		/* subf R9, R28, R11 */
		/* 8206ADACh case    0:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R28,regs.R11);
		/* 8206ADACh case    0:*/		return 0x8206ADB0;
		  /* 8206ADB0h */ case    1:  		/* add R10, R29, R28 */
		/* 8206ADB0h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R29,regs.R28);
		/* 8206ADB0h case    1:*/		return 0x8206ADB4;
		  /* 8206ADB4h */ case    2:  		/* rlwinm R9, R9, 6, 0, 25 */
		/* 8206ADB4h case    2:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R9,regs.R9);
		/* 8206ADB4h case    2:*/		return 0x8206ADB8;
		  /* 8206ADB8h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 8206ADB8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8206ADB8h case    3:*/		return 0x8206ADBC;
		  /* 8206ADBCh */ case    4:  		/* add R9, R9, R27 */
		/* 8206ADBCh case    4:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R27);
		/* 8206ADBCh case    4:*/		return 0x8206ADC0;
		  /* 8206ADC0h */ case    5:  		/* bc 4, CR6_LT, 132 */
		/* 8206ADC0h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8206AE44;  }
		/* 8206ADC0h case    5:*/		return 0x8206ADC4;
		  /* 8206ADC4h */ case    6:  		/* subf R10, R11, R10 */
		/* 8206ADC4h case    6:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8206ADC4h case    6:*/		return 0x8206ADC8;
		  /* 8206ADC8h */ case    7:  		/* mtspr CTR, R10 */
		/* 8206ADC8h case    7:*/		regs.CTR = regs.R10;
		/* 8206ADC8h case    7:*/		return 0x8206ADCC;
		  /* 8206ADCCh */ case    8:  		/* lwz R10, <#[R25 + 9572]> */
		/* 8206ADCCh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00002564) );
		/* 8206ADCCh case    8:*/		return 0x8206ADD0;
		  /* 8206ADD0h */ case    9:  		/* lwz R8, <#[R10 + 19936]> */
		/* 8206ADD0h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00004DE0) );
		/* 8206ADD0h case    9:*/		return 0x8206ADD4;
		  /* 8206ADD4h */ case   10:  		/* lwz R10, <#[R10 + 19940]> */
		/* 8206ADD4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00004DE4) );
		/* 8206ADD4h case   10:*/		return 0x8206ADD8;
		  /* 8206ADD8h */ case   11:  		/* subf R8, R8, R11 */
		/* 8206ADD8h case   11:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8206ADD8h case   11:*/		return 0x8206ADDC;
		  /* 8206ADDCh */ case   12:  		/* addi R11, R11, 1 */
		/* 8206ADDCh case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206ADDCh case   12:*/		return 0x8206ADE0;
		  /* 8206ADE0h */ case   13:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8206ADE0h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8206ADE0h case   13:*/		return 0x8206ADE4;
		  /* 8206ADE4h */ case   14:  		/* stwx R9, <#[R8 + R10]> */
		/* 8206ADE4h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8206ADE4h case   14:*/		return 0x8206ADE8;
		  /* 8206ADE8h */ case   15:  		/* addi R9, R9, 64 */
		/* 8206ADE8h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x40);
		/* 8206ADE8h case   15:*/		return 0x8206ADEC;
		  /* 8206ADECh */ case   16:  		/* bc 16, CR0_LT, -32 */
		/* 8206ADECh case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206ADCC;  }
		/* 8206ADECh case   16:*/		return 0x8206ADF0;
		  /* 8206ADF0h */ case   17:  		/* b 84 */
		/* 8206ADF0h case   17:*/		return 0x8206AE44;
		/* 8206ADF0h case   17:*/		return 0x8206ADF4;
	}
	return 0x8206ADF4;
} // Block from 8206ADACh-8206ADF4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206ADF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206ADF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206ADF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206ADF4);
		  /* 8206ADF4h */ case    0:  		/* li R19, 0 */
		/* 8206ADF4h case    0:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8206ADF4h case    0:*/		return 0x8206ADF8;
		  /* 8206ADF8h */ case    1:  		/* mr R21, R19 */
		/* 8206ADF8h case    1:*/		regs.R21 = regs.R19;
		/* 8206ADF8h case    1:*/		return 0x8206ADFC;
		  /* 8206ADFCh */ case    2:  		/* b -368 */
		/* 8206ADFCh case    2:*/		return 0x8206AC8C;
		/* 8206ADFCh case    2:*/		return 0x8206AE00;
	}
	return 0x8206AE00;
} // Block from 8206ADF4h-8206AE00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206AE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AE00);
		  /* 8206AE00h */ case    0:  		/* cmplw CR6, R28, R23 */
		/* 8206AE00h case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R23);
		/* 8206AE00h case    0:*/		return 0x8206AE04;
		  /* 8206AE04h */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 8206AE04h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8206AE18;  }
		/* 8206AE04h case    1:*/		return 0x8206AE08;
		  /* 8206AE08h */ case    2:  		/* mr R3, R20 */
		/* 8206AE08h case    2:*/		regs.R3 = regs.R20;
		/* 8206AE08h case    2:*/		return 0x8206AE0C;
		  /* 8206AE0Ch */ case    3:  		/* bl -14188 */
		/* 8206AE0Ch case    3:*/		regs.LR = 0x8206AE10; return 0x820676A0;
		/* 8206AE0Ch case    3:*/		return 0x8206AE10;
		  /* 8206AE10h */ case    4:  		/* stw R27, <#[R1 + 80]> */
		/* 8206AE10h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AE10h case    4:*/		return 0x8206AE14;
		  /* 8206AE14h */ case    5:  		/* b 32 */
		/* 8206AE14h case    5:*/		return 0x8206AE34;
		/* 8206AE14h case    5:*/		return 0x8206AE18;
	}
	return 0x8206AE18;
} // Block from 8206AE00h-8206AE18h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206AE18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AE18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AE18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AE18);
		  /* 8206AE18h */ case    0:  		/* lwz R11, <#[R25 + 9572]> */
		/* 8206AE18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00002564) );
		/* 8206AE18h case    0:*/		return 0x8206AE1C;
		  /* 8206AE1Ch */ case    1:  		/* lwz R10, <#[R11 + 19936]> */
		/* 8206AE1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00004DE0) );
		/* 8206AE1Ch case    1:*/		return 0x8206AE20;
		  /* 8206AE20h */ case    2:  		/* lwz R11, <#[R11 + 19940]> */
		/* 8206AE20h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DE4) );
		/* 8206AE20h case    2:*/		return 0x8206AE24;
		  /* 8206AE24h */ case    3:  		/* subf R10, R10, R28 */
		/* 8206AE24h case    3:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R28);
		/* 8206AE24h case    3:*/		return 0x8206AE28;
		  /* 8206AE28h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8206AE28h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8206AE28h case    4:*/		return 0x8206AE2C;
		  /* 8206AE2Ch */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8206AE2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8206AE2Ch case    5:*/		return 0x8206AE30;
		  /* 8206AE30h */ case    6:  		/* stw R11, <#[R1 + 80]> */
		/* 8206AE30h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AE30h case    6:*/		return 0x8206AE34;
	}
	return 0x8206AE34;
} // Block from 8206AE18h-8206AE34h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206AE34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AE34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AE34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AE34);
		  /* 8206AE34h */ case    0:  		/* li R5, 4 */
		/* 8206AE34h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8206AE34h case    0:*/		return 0x8206AE38;
		  /* 8206AE38h */ case    1:  		/* addi R4, R1, 80 */
		/* 8206AE38h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206AE38h case    1:*/		return 0x8206AE3C;
		  /* 8206AE3Ch */ case    2:  		/* mr R3, R31 */
		/* 8206AE3Ch case    2:*/		regs.R3 = regs.R31;
		/* 8206AE3Ch case    2:*/		return 0x8206AE40;
		  /* 8206AE40h */ case    3:  		/* bl -14240 */
		/* 8206AE40h case    3:*/		regs.LR = 0x8206AE44; return 0x820676A0;
		/* 8206AE40h case    3:*/		return 0x8206AE44;
	}
	return 0x8206AE44;
} // Block from 8206AE34h-8206AE44h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206AE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AE44);
		  /* 8206AE44h */ case    0:  		/* addi R26, R26, 1 */
		/* 8206AE44h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8206AE44h case    0:*/		return 0x8206AE48;
		  /* 8206AE48h */ case    1:  		/* cmplwi CR6, R26, 64 */
		/* 8206AE48h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000040);
		/* 8206AE48h case    1:*/		return 0x8206AE4C;
		  /* 8206AE4Ch */ case    2:  		/* bc 12, CR6_LT, -424 */
		/* 8206AE4Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x8206ACA4;  }
		/* 8206AE4Ch case    2:*/		return 0x8206AE50;
		  /* 8206AE50h */ case    3:  		/* stw R19, <#[R1 + 80]> */
		/* 8206AE50h case    3:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AE50h case    3:*/		return 0x8206AE54;
		  /* 8206AE54h */ case    4:  		/* li R5, 4 */
		/* 8206AE54h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8206AE54h case    4:*/		return 0x8206AE58;
		  /* 8206AE58h */ case    5:  		/* addi R4, R1, 80 */
		/* 8206AE58h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206AE58h case    5:*/		return 0x8206AE5C;
		  /* 8206AE5Ch */ case    6:  		/* mr R3, R31 */
		/* 8206AE5Ch case    6:*/		regs.R3 = regs.R31;
		/* 8206AE5Ch case    6:*/		return 0x8206AE60;
		  /* 8206AE60h */ case    7:  		/* bl -14272 */
		/* 8206AE60h case    7:*/		regs.LR = 0x8206AE64; return 0x820676A0;
		/* 8206AE60h case    7:*/		return 0x8206AE64;
		  /* 8206AE64h */ case    8:  		/* mr R30, R19 */
		/* 8206AE64h case    8:*/		regs.R30 = regs.R19;
		/* 8206AE64h case    8:*/		return 0x8206AE68;
		  /* 8206AE68h */ case    9:  		/* rlwinm R11, R30, 27, 5, 31 */
		/* 8206AE68h case    9:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R30);
		/* 8206AE68h case    9:*/		return 0x8206AE6C;
		  /* 8206AE6Ch */ case   10:  		/* rlwinm R10, R30, 0, 27, 31 */
		/* 8206AE6Ch case   10:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R30);
		/* 8206AE6Ch case   10:*/		return 0x8206AE70;
		  /* 8206AE70h */ case   11:  		/* addi R11, R11, 2302 */
		/* 8206AE70h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8FE);
		/* 8206AE70h case   11:*/		return 0x8206AE74;
		  /* 8206AE74h */ case   12:  		/* slw R10, R18, R10 */
		/* 8206AE74h case   12:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R18,regs.R10);
		/* 8206AE74h case   12:*/		return 0x8206AE78;
		  /* 8206AE78h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206AE78h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206AE78h case   13:*/		return 0x8206AE7C;
		  /* 8206AE7Ch */ case   14:  		/* lwzx R11, <#[R11 + R25]> */
		/* 8206AE7Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 8206AE7Ch case   14:*/		return 0x8206AE80;
		  /* 8206AE80h */ case   15:  		/* and. R11, R10, R11 */
		/* 8206AE80h case   15:*/		cpu::op::and<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206AE80h case   15:*/		return 0x8206AE84;
		  /* 8206AE84h */ case   16:  		/* bc 12, CR0_EQ, 136 */
		/* 8206AE84h case   16:*/		if ( regs.CR[0].eq ) { return 0x8206AF0C;  }
		/* 8206AE84h case   16:*/		return 0x8206AE88;
		  /* 8206AE88h */ case   17:  		/* addi R11, R30, 1 */
		/* 8206AE88h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 8206AE88h case   17:*/		return 0x8206AE8C;
		  /* 8206AE8Ch */ case   18:  		/* mr R10, R30 */
		/* 8206AE8Ch case   18:*/		regs.R10 = regs.R30;
		/* 8206AE8Ch case   18:*/		return 0x8206AE90;
		  /* 8206AE90h */ case   19:  		/* b 44 */
		/* 8206AE90h case   19:*/		return 0x8206AEBC;
		/* 8206AE90h case   19:*/		return 0x8206AE94;
		  /* 8206AE94h */ case   20:  		/* rlwinm R9, R11, 27, 5, 31 */
		/* 8206AE94h case   20:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R9,regs.R11);
		/* 8206AE94h case   20:*/		return 0x8206AE98;
		  /* 8206AE98h */ case   21:  		/* rlwinm R8, R11, 0, 27, 31 */
		/* 8206AE98h case   21:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R11);
		/* 8206AE98h case   21:*/		return 0x8206AE9C;
		  /* 8206AE9Ch */ case   22:  		/* addi R9, R9, 2302 */
		/* 8206AE9Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8FE);
		/* 8206AE9Ch case   22:*/		return 0x8206AEA0;
		  /* 8206AEA0h */ case   23:  		/* slw R8, R18, R8 */
		/* 8206AEA0h case   23:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R18,regs.R8);
		/* 8206AEA0h case   23:*/		return 0x8206AEA4;
		  /* 8206AEA4h */ case   24:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8206AEA4h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8206AEA4h case   24:*/		return 0x8206AEA8;
		  /* 8206AEA8h */ case   25:  		/* lwzx R9, <#[R9 + R25]> */
		/* 8206AEA8h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R25 + 0x00000000) );
		/* 8206AEA8h case   25:*/		return 0x8206AEAC;
		  /* 8206AEACh */ case   26:  		/* and. R9, R8, R9 */
		/* 8206AEACh case   26:*/		cpu::op::and<1>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8206AEACh case   26:*/		return 0x8206AEB0;
		  /* 8206AEB0h */ case   27:  		/* bc 12, CR0_EQ, 20 */
		/* 8206AEB0h case   27:*/		if ( regs.CR[0].eq ) { return 0x8206AEC4;  }
		/* 8206AEB0h case   27:*/		return 0x8206AEB4;
		  /* 8206AEB4h */ case   28:  		/* addi R30, R30, 1 */
		/* 8206AEB4h case   28:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8206AEB4h case   28:*/		return 0x8206AEB8;
		  /* 8206AEB8h */ case   29:  		/* addi R11, R11, 1 */
		/* 8206AEB8h case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206AEB8h case   29:*/		return 0x8206AEBC;
	}
	return 0x8206AEBC;
} // Block from 8206AE44h-8206AEBCh (30 instructions)

//////////////////////////////////////////////////////
// Block at 8206AEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AEBC);
		  /* 8206AEBCh */ case    0:  		/* cmplwi CR6, R11, 2280 */
		/* 8206AEBCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000008E8);
		/* 8206AEBCh case    0:*/		return 0x8206AEC0;
		  /* 8206AEC0h */ case    1:  		/* bc 12, CR6_LT, -44 */
		/* 8206AEC0h case    1:*/		if ( regs.CR[6].lt ) { return 0x8206AE94;  }
		/* 8206AEC0h case    1:*/		return 0x8206AEC4;
	}
	return 0x8206AEC4;
} // Block from 8206AEBCh-8206AEC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206AEC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AEC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AEC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AEC4);
		  /* 8206AEC4h */ case    0:  		/* rlwinm R9, R10, 2, 16, 29 */
		/* 8206AEC4h case    0:*/		cpu::op::rlwinm<0,2,16,29>(regs,&regs.R9,regs.R10);
		/* 8206AEC4h case    0:*/		return 0x8206AEC8;
		  /* 8206AEC8h */ case    1:  		/* subf R11, R10, R30 */
		/* 8206AEC8h case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R30);
		/* 8206AEC8h case    1:*/		return 0x8206AECC;
		  /* 8206AECCh */ case    2:  		/* sth R9, <#[R1 + 80]> */
		/* 8206AECCh case    2:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AECCh case    2:*/		return 0x8206AED0;
		  /* 8206AED0h */ case    3:  		/* li R5, 2 */
		/* 8206AED0h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8206AED0h case    3:*/		return 0x8206AED4;
		  /* 8206AED4h */ case    4:  		/* addi R4, R1, 80 */
		/* 8206AED4h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206AED4h case    4:*/		return 0x8206AED8;
		  /* 8206AED8h */ case    5:  		/* mr R3, R31 */
		/* 8206AED8h case    5:*/		regs.R3 = regs.R31;
		/* 8206AED8h case    5:*/		return 0x8206AEDC;
		  /* 8206AEDCh */ case    6:  		/* addi R29, R11, 1 */
		/* 8206AEDCh case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1);
		/* 8206AEDCh case    6:*/		return 0x8206AEE0;
		  /* 8206AEE0h */ case    7:  		/* rlwinm R28, R10, 2, 0, 29 */
		/* 8206AEE0h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R10);
		/* 8206AEE0h case    7:*/		return 0x8206AEE4;
		  /* 8206AEE4h */ case    8:  		/* bl -14404 */
		/* 8206AEE4h case    8:*/		regs.LR = 0x8206AEE8; return 0x820676A0;
		/* 8206AEE4h case    8:*/		return 0x8206AEE8;
		  /* 8206AEE8h */ case    9:  		/* sth R29, <#[R1 + 80]> */
		/* 8206AEE8h case    9:*/		cpu::mem::store16( regs, regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AEE8h case    9:*/		return 0x8206AEEC;
		  /* 8206AEECh */ case   10:  		/* li R5, 2 */
		/* 8206AEECh case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8206AEECh case   10:*/		return 0x8206AEF0;
		  /* 8206AEF0h */ case   11:  		/* addi R4, R1, 80 */
		/* 8206AEF0h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206AEF0h case   11:*/		return 0x8206AEF4;
		  /* 8206AEF4h */ case   12:  		/* mr R3, R31 */
		/* 8206AEF4h case   12:*/		regs.R3 = regs.R31;
		/* 8206AEF4h case   12:*/		return 0x8206AEF8;
		  /* 8206AEF8h */ case   13:  		/* bl -14424 */
		/* 8206AEF8h case   13:*/		regs.LR = 0x8206AEFC; return 0x820676A0;
		/* 8206AEF8h case   13:*/		return 0x8206AEFC;
		  /* 8206AEFCh */ case   14:  		/* rlwinm R5, R29, 2, 0, 29 */
		/* 8206AEFCh case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R29);
		/* 8206AEFCh case   14:*/		return 0x8206AF00;
		  /* 8206AF00h */ case   15:  		/* add R4, R28, R25 */
		/* 8206AF00h case   15:*/		cpu::op::add<0>(regs,&regs.R4,regs.R28,regs.R25);
		/* 8206AF00h case   15:*/		return 0x8206AF04;
		  /* 8206AF04h */ case   16:  		/* mr R3, R31 */
		/* 8206AF04h case   16:*/		regs.R3 = regs.R31;
		/* 8206AF04h case   16:*/		return 0x8206AF08;
		  /* 8206AF08h */ case   17:  		/* bl -14440 */
		/* 8206AF08h case   17:*/		regs.LR = 0x8206AF0C; return 0x820676A0;
		/* 8206AF08h case   17:*/		return 0x8206AF0C;
	}
	return 0x8206AF0C;
} // Block from 8206AEC4h-8206AF0Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206AF0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AF0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AF0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AF0C);
		  /* 8206AF0Ch */ case    0:  		/* addi R30, R30, 1 */
		/* 8206AF0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8206AF0Ch case    0:*/		return 0x8206AF10;
		  /* 8206AF10h */ case    1:  		/* cmplwi CR6, R30, 2280 */
		/* 8206AF10h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x000008E8);
		/* 8206AF10h case    1:*/		return 0x8206AF14;
		  /* 8206AF14h */ case    2:  		/* bc 12, CR6_LT, -172 */
		/* 8206AF14h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206AE68;  }
		/* 8206AF14h case    2:*/		return 0x8206AF18;
		  /* 8206AF18h */ case    3:  		/* stw R19, <#[R1 + 80]> */
		/* 8206AF18h case    3:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AF18h case    3:*/		return 0x8206AF1C;
		  /* 8206AF1Ch */ case    4:  		/* li R5, 4 */
		/* 8206AF1Ch case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8206AF1Ch case    4:*/		return 0x8206AF20;
		  /* 8206AF20h */ case    5:  		/* addi R4, R1, 80 */
		/* 8206AF20h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206AF20h case    5:*/		return 0x8206AF24;
		  /* 8206AF24h */ case    6:  		/* mr R3, R31 */
		/* 8206AF24h case    6:*/		regs.R3 = regs.R31;
		/* 8206AF24h case    6:*/		return 0x8206AF28;
		  /* 8206AF28h */ case    7:  		/* bl -14472 */
		/* 8206AF28h case    7:*/		regs.LR = 0x8206AF2C; return 0x820676A0;
		/* 8206AF28h case    7:*/		return 0x8206AF2C;
		  /* 8206AF2Ch */ case    8:  		/* mr R27, R19 */
		/* 8206AF2Ch case    8:*/		regs.R27 = regs.R19;
		/* 8206AF2Ch case    8:*/		return 0x8206AF30;
		  /* 8206AF30h */ case    9:  		/* addi R11, R27, 2382 */
		/* 8206AF30h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x94E);
		/* 8206AF30h case    9:*/		return 0x8206AF34;
		  /* 8206AF34h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206AF34h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206AF34h case   10:*/		return 0x8206AF38;
		  /* 8206AF38h */ case   11:  		/* lwzx R11, <#[R11 + R25]> */
		/* 8206AF38h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 8206AF38h case   11:*/		return 0x8206AF3C;
		  /* 8206AF3Ch */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8206AF3Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206AF3Ch case   12:*/		return 0x8206AF40;
		  /* 8206AF40h */ case   13:  		/* bc 12, CR6_EQ, 224 */
		/* 8206AF40h case   13:*/		if ( regs.CR[6].eq ) { return 0x8206B020;  }
		/* 8206AF40h case   13:*/		return 0x8206AF44;
		  /* 8206AF44h */ case   14:  		/* addi R11, R27, 1 */
		/* 8206AF44h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x1);
		/* 8206AF44h case   14:*/		return 0x8206AF48;
		  /* 8206AF48h */ case   15:  		/* mr R28, R27 */
		/* 8206AF48h case   15:*/		regs.R28 = regs.R27;
		/* 8206AF48h case   15:*/		return 0x8206AF4C;
		  /* 8206AF4Ch */ case   16:  		/* b 44 */
		/* 8206AF4Ch case   16:*/		return 0x8206AF78;
		/* 8206AF4Ch case   16:*/		return 0x8206AF50;
		  /* 8206AF50h */ case   17:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 8206AF50h case   17:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 8206AF50h case   17:*/		return 0x8206AF54;
		  /* 8206AF54h */ case   18:  		/* rlwinm R9, R11, 0, 27, 31 */
		/* 8206AF54h case   18:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R11);
		/* 8206AF54h case   18:*/		return 0x8206AF58;
	}
	return 0x8206AF58;
} // Block from 8206AF0Ch-8206AF58h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206AF58h
// Function '??1Pass@CMicrocodeBuilder@D3D@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AF58);
		  /* 8206AF58h */ case    0:  		/* addi R10, R10, 2382 */
		/* 8206AF58h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x94E);
		/* 8206AF58h case    0:*/		return 0x8206AF5C;
		  /* 8206AF5Ch */ case    1:  		/* slw R9, R18, R9 */
		/* 8206AF5Ch case    1:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R18,regs.R9);
		/* 8206AF5Ch case    1:*/		return 0x8206AF60;
		  /* 8206AF60h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8206AF60h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8206AF60h case    2:*/		return 0x8206AF64;
		  /* 8206AF64h */ case    3:  		/* lwzx R10, <#[R10 + R25]> */
		/* 8206AF64h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 8206AF64h case    3:*/		return 0x8206AF68;
		  /* 8206AF68h */ case    4:  		/* and. R10, R9, R10 */
		/* 8206AF68h case    4:*/		cpu::op::and<1>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8206AF68h case    4:*/		return 0x8206AF6C;
		  /* 8206AF6Ch */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 8206AF6Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8206AF80;  }
		/* 8206AF6Ch case    5:*/		return 0x8206AF70;
		  /* 8206AF70h */ case    6:  		/* addi R27, R27, 1 */
		/* 8206AF70h case    6:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8206AF70h case    6:*/		return 0x8206AF74;
		  /* 8206AF74h */ case    7:  		/* addi R11, R11, 1 */
		/* 8206AF74h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206AF74h case    7:*/		return 0x8206AF78;
	}
	return 0x8206AF78;
} // Block from 8206AF58h-8206AF78h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206AF78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AF78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AF78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AF78);
		  /* 8206AF78h */ case    0:  		/* cmplwi CR6, R11, 8 */
		/* 8206AF78h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000008);
		/* 8206AF78h case    0:*/		return 0x8206AF7C;
		  /* 8206AF7Ch */ case    1:  		/* bc 12, CR6_LT, -44 */
		/* 8206AF7Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x8206AF50;  }
		/* 8206AF7Ch case    1:*/		return 0x8206AF80;
	}
	return 0x8206AF80;
} // Block from 8206AF78h-8206AF80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206AF80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AF80);
		  /* 8206AF80h */ case    0:  		/* addi R10, R28, 2240 */
		/* 8206AF80h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x8C0);
		/* 8206AF80h case    0:*/		return 0x8206AF84;
		  /* 8206AF84h */ case    1:  		/* subf R11, R28, R27 */
		/* 8206AF84h case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R27);
		/* 8206AF84h case    1:*/		return 0x8206AF88;
		  /* 8206AF88h */ case    2:  		/* rlwinm R10, R10, 2, 16, 29 */
		/* 8206AF88h case    2:*/		cpu::op::rlwinm<0,2,16,29>(regs,&regs.R10,regs.R10);
		/* 8206AF88h case    2:*/		return 0x8206AF8C;
		  /* 8206AF8Ch */ case    3:  		/* li R5, 2 */
		/* 8206AF8Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8206AF8Ch case    3:*/		return 0x8206AF90;
		  /* 8206AF90h */ case    4:  		/* sth R10, <#[R1 + 80]> */
		/* 8206AF90h case    4:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AF90h case    4:*/		return 0x8206AF94;
		  /* 8206AF94h */ case    5:  		/* addi R4, R1, 80 */
		/* 8206AF94h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206AF94h case    5:*/		return 0x8206AF98;
		  /* 8206AF98h */ case    6:  		/* mr R3, R31 */
		/* 8206AF98h case    6:*/		regs.R3 = regs.R31;
		/* 8206AF98h case    6:*/		return 0x8206AF9C;
		  /* 8206AF9Ch */ case    7:  		/* addi R29, R11, 1 */
		/* 8206AF9Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1);
		/* 8206AF9Ch case    7:*/		return 0x8206AFA0;
		  /* 8206AFA0h */ case    8:  		/* bl -14592 */
		/* 8206AFA0h case    8:*/		regs.LR = 0x8206AFA4; return 0x820676A0;
		/* 8206AFA0h case    8:*/		return 0x8206AFA4;
		  /* 8206AFA4h */ case    9:  		/* rlwinm R11, R29, 1, 16, 30 */
		/* 8206AFA4h case    9:*/		cpu::op::rlwinm<0,1,16,30>(regs,&regs.R11,regs.R29);
		/* 8206AFA4h case    9:*/		return 0x8206AFA8;
		  /* 8206AFA8h */ case   10:  		/* li R5, 2 */
		/* 8206AFA8h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8206AFA8h case   10:*/		return 0x8206AFAC;
		  /* 8206AFACh */ case   11:  		/* sth R11, <#[R1 + 80]> */
		/* 8206AFACh case   11:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AFACh case   11:*/		return 0x8206AFB0;
		  /* 8206AFB0h */ case   12:  		/* addi R4, R1, 80 */
		/* 8206AFB0h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206AFB0h case   12:*/		return 0x8206AFB4;
		  /* 8206AFB4h */ case   13:  		/* mr R3, R31 */
		/* 8206AFB4h case   13:*/		regs.R3 = regs.R31;
		/* 8206AFB4h case   13:*/		return 0x8206AFB8;
		  /* 8206AFB8h */ case   14:  		/* bl -14616 */
		/* 8206AFB8h case   14:*/		regs.LR = 0x8206AFBC; return 0x820676A0;
		/* 8206AFB8h case   14:*/		return 0x8206AFBC;
		  /* 8206AFBCh */ case   15:  		/* mr R30, R19 */
		/* 8206AFBCh case   15:*/		regs.R30 = regs.R19;
		/* 8206AFBCh case   15:*/		return 0x8206AFC0;
		  /* 8206AFC0h */ case   16:  		/* cmplwi CR6, R29, 0 */
		/* 8206AFC0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8206AFC0h case   16:*/		return 0x8206AFC4;
		  /* 8206AFC4h */ case   17:  		/* bc 12, CR6_EQ, 92 */
		/* 8206AFC4h case   17:*/		if ( regs.CR[6].eq ) { return 0x8206B020;  }
		/* 8206AFC4h case   17:*/		return 0x8206AFC8;
		  /* 8206AFC8h */ case   18:  		/* addi R26, R28, 2382 */
		/* 8206AFC8h case   18:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R28,0x94E);
		/* 8206AFC8h case   18:*/		return 0x8206AFCC;
		  /* 8206AFCCh */ case   19:  		/* addi R28, R28, 2374 */
		/* 8206AFCCh case   19:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x946);
		/* 8206AFCCh case   19:*/		return 0x8206AFD0;
		  /* 8206AFD0h */ case   20:  		/* add R11, R26, R30 */
		/* 8206AFD0h case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R26,regs.R30);
		/* 8206AFD0h case   20:*/		return 0x8206AFD4;
		  /* 8206AFD4h */ case   21:  		/* li R5, 4 */
		/* 8206AFD4h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8206AFD4h case   21:*/		return 0x8206AFD8;
		  /* 8206AFD8h */ case   22:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206AFD8h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206AFD8h case   22:*/		return 0x8206AFDC;
		  /* 8206AFDCh */ case   23:  		/* addi R4, R1, 80 */
		/* 8206AFDCh case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206AFDCh case   23:*/		return 0x8206AFE0;
		  /* 8206AFE0h */ case   24:  		/* mr R3, R31 */
		/* 8206AFE0h case   24:*/		regs.R3 = regs.R31;
		/* 8206AFE0h case   24:*/		return 0x8206AFE4;
		  /* 8206AFE4h */ case   25:  		/* lwzx R11, <#[R11 + R25]> */
		/* 8206AFE4h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 8206AFE4h case   25:*/		return 0x8206AFE8;
		  /* 8206AFE8h */ case   26:  		/* nor R11, R11, R11 */
		/* 8206AFE8h case   26:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206AFE8h case   26:*/		return 0x8206AFEC;
		  /* 8206AFECh */ case   27:  		/* stw R11, <#[R1 + 80]> */
		/* 8206AFECh case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206AFECh case   27:*/		return 0x8206AFF0;
		  /* 8206AFF0h */ case   28:  		/* bl -14672 */
		/* 8206AFF0h case   28:*/		regs.LR = 0x8206AFF4; return 0x820676A0;
		/* 8206AFF0h case   28:*/		return 0x8206AFF4;
		  /* 8206AFF4h */ case   29:  		/* add R11, R28, R30 */
		/* 8206AFF4h case   29:*/		cpu::op::add<0>(regs,&regs.R11,regs.R28,regs.R30);
		/* 8206AFF4h case   29:*/		return 0x8206AFF8;
	}
	return 0x8206AFF8;
} // Block from 8206AF80h-8206AFF8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8206AFF8h
// Function 'XMicrocodeBuilder_Release'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AFF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AFF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AFF8);
		  /* 8206AFF8h */ case    0:  		/* li R5, 4 */
		/* 8206AFF8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8206AFF8h case    0:*/		return 0x8206AFFC;
		  /* 8206AFFCh */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206AFFCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206AFFCh case    1:*/		return 0x8206B000;
		  /* 8206B000h */ case    2:  		/* addi R4, R1, 80 */
		/* 8206B000h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206B000h case    2:*/		return 0x8206B004;
		  /* 8206B004h */ case    3:  		/* mr R3, R31 */
		/* 8206B004h case    3:*/		regs.R3 = regs.R31;
		/* 8206B004h case    3:*/		return 0x8206B008;
		  /* 8206B008h */ case    4:  		/* lwzx R11, <#[R11 + R25]> */
		/* 8206B008h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 8206B008h case    4:*/		return 0x8206B00C;
		  /* 8206B00Ch */ case    5:  		/* stw R11, <#[R1 + 80]> */
		/* 8206B00Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206B00Ch case    5:*/		return 0x8206B010;
		  /* 8206B010h */ case    6:  		/* bl -14704 */
		/* 8206B010h case    6:*/		regs.LR = 0x8206B014; return 0x820676A0;
		/* 8206B010h case    6:*/		return 0x8206B014;
		  /* 8206B014h */ case    7:  		/* addi R30, R30, 1 */
		/* 8206B014h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8206B014h case    7:*/		return 0x8206B018;
		  /* 8206B018h */ case    8:  		/* cmplw CR6, R30, R29 */
		/* 8206B018h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 8206B018h case    8:*/		return 0x8206B01C;
		  /* 8206B01Ch */ case    9:  		/* bc 12, CR6_LT, -76 */
		/* 8206B01Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x8206AFD0;  }
		/* 8206B01Ch case    9:*/		return 0x8206B020;
	}
	return 0x8206B020;
} // Block from 8206AFF8h-8206B020h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206B020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B020);
		  /* 8206B020h */ case    0:  		/* addi R27, R27, 1 */
		/* 8206B020h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8206B020h case    0:*/		return 0x8206B024;
		  /* 8206B024h */ case    1:  		/* cmplwi CR6, R27, 8 */
		/* 8206B024h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000008);
		/* 8206B024h case    1:*/		return 0x8206B028;
		  /* 8206B028h */ case    2:  		/* bc 12, CR6_LT, -248 */
		/* 8206B028h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206AF30;  }
		/* 8206B028h case    2:*/		return 0x8206B02C;
		  /* 8206B02Ch */ case    3:  		/* stw R19, <#[R1 + 80]> */
		/* 8206B02Ch case    3:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000050) );
		/* 8206B02Ch case    3:*/		return 0x8206B030;
		  /* 8206B030h */ case    4:  		/* li R5, 4 */
		/* 8206B030h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8206B030h case    4:*/		return 0x8206B034;
		  /* 8206B034h */ case    5:  		/* addi R4, R1, 80 */
		/* 8206B034h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206B034h case    5:*/		return 0x8206B038;
		  /* 8206B038h */ case    6:  		/* mr R3, R31 */
		/* 8206B038h case    6:*/		regs.R3 = regs.R31;
		/* 8206B038h case    6:*/		return 0x8206B03C;
		  /* 8206B03Ch */ case    7:  		/* bl -14748 */
		/* 8206B03Ch case    7:*/		regs.LR = 0x8206B040; return 0x820676A0;
		/* 8206B03Ch case    7:*/		return 0x8206B040;
		  /* 8206B040h */ case    8:  		/* addi R11, R17, 16 */
		/* 8206B040h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R17,0x10);
		/* 8206B040h case    8:*/		return 0x8206B044;
		  /* 8206B044h */ case    9:  		/* li R5, 4 */
		/* 8206B044h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8206B044h case    9:*/		return 0x8206B048;
		  /* 8206B048h */ case   10:  		/* addi R4, R1, 80 */
		/* 8206B048h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206B048h case   10:*/		return 0x8206B04C;
		  /* 8206B04Ch */ case   11:  		/* mr R3, R31 */
		/* 8206B04Ch case   11:*/		regs.R3 = regs.R31;
		/* 8206B04Ch case   11:*/		return 0x8206B050;
		  /* 8206B050h */ case   12:  		/* lwz R30, <#[R31 + 4]> */
		/* 8206B050h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8206B050h case   12:*/		return 0x8206B054;
		  /* 8206B054h */ case   13:  		/* stw R11, <#[R31 + 4]> */
		/* 8206B054h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206B054h case   13:*/		return 0x8206B058;
		  /* 8206B058h */ case   14:  		/* subf R11, R16, R30 */
		/* 8206B058h case   14:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R16,regs.R30);
		/* 8206B058h case   14:*/		return 0x8206B05C;
		  /* 8206B05Ch */ case   15:  		/* stw R11, <#[R1 + 80]> */
		/* 8206B05Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206B05Ch case   15:*/		return 0x8206B060;
		  /* 8206B060h */ case   16:  		/* bl -14784 */
		/* 8206B060h case   16:*/		regs.LR = 0x8206B064; return 0x820676A0;
		/* 8206B060h case   16:*/		return 0x8206B064;
		  /* 8206B064h */ case   17:  		/* stw R30, <#[R31 + 4]> */
		/* 8206B064h case   17:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8206B064h case   17:*/		return 0x8206B068;
	}
	return 0x8206B068;
} // Block from 8206B020h-8206B068h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206B068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B068);
		  /* 8206B068h */ case    0:  		/* lwz R3, <#[R20 + 16]> */
		/* 8206B068h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R20 + 0x00000010) );
		/* 8206B068h case    0:*/		return 0x8206B06C;
		  /* 8206B06Ch */ case    1:  		/* cmpwi CR6, R3, 0 */
		/* 8206B06Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8206B06Ch case    1:*/		return 0x8206B070;
		  /* 8206B070h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 8206B070h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206B078;  }
		/* 8206B070h case    2:*/		return 0x8206B074;
		  /* 8206B074h */ case    3:  		/* lwz R3, <#[R20 + 36]> */
		/* 8206B074h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R20 + 0x00000024) );
		/* 8206B074h case    3:*/		return 0x8206B078;
	}
	return 0x8206B078;
} // Block from 8206B068h-8206B078h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206B078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B078);
		  /* 8206B078h */ case    0:  		/* addi R1, R1, 224 */
		/* 8206B078h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 8206B078h case    0:*/		return 0x8206B07C;
		  /* 8206B07Ch */ case    1:  		/* b 156156 */
		/* 8206B07Ch case    1:*/		return 0x82091278;
		/* 8206B07Ch case    1:*/		return 0x8206B080;
	}
	return 0x8206B080;
} // Block from 8206B078h-8206B080h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206B080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B080);
		  /* 8206B080h */ case    0:  		/* mfspr R12, LR */
		/* 8206B080h case    0:*/		regs.R12 = regs.LR;
		/* 8206B080h case    0:*/		return 0x8206B084;
		  /* 8206B084h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206B084h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206B084h case    1:*/		return 0x8206B088;
		  /* 8206B088h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8206B088h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206B088h case    2:*/		return 0x8206B08C;
		  /* 8206B08Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8206B08Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206B08Ch case    3:*/		return 0x8206B090;
		  /* 8206B090h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206B090h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206B090h case    4:*/		return 0x8206B094;
		  /* 8206B094h */ case    5:  		/* mr R31, R3 */
		/* 8206B094h case    5:*/		regs.R31 = regs.R3;
		/* 8206B094h case    5:*/		return 0x8206B098;
		  /* 8206B098h */ case    6:  		/* li R30, 0 */
		/* 8206B098h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8206B098h case    6:*/		return 0x8206B09C;
		  /* 8206B09Ch */ case    7:  		/* li R5, 32 */
		/* 8206B09Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206B09Ch case    7:*/		return 0x8206B0A0;
		  /* 8206B0A0h */ case    8:  		/* stw R30, <#[R3 + 80]> */
		/* 8206B0A0h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000050) );
		/* 8206B0A0h case    8:*/		return 0x8206B0A4;
		  /* 8206B0A4h */ case    9:  		/* li R4, 0 */
		/* 8206B0A4h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206B0A4h case    9:*/		return 0x8206B0A8;
		  /* 8206B0A8h */ case   10:  		/* addi R3, R3, 128 */
		/* 8206B0A8h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x80);
		/* 8206B0A8h case   10:*/		return 0x8206B0AC;
		  /* 8206B0ACh */ case   11:  		/* stw R30, <#[R31 + 88]> */
		/* 8206B0ACh case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000058) );
		/* 8206B0ACh case   11:*/		return 0x8206B0B0;
		  /* 8206B0B0h */ case   12:  		/* stw R30, <#[R31 + 92]> */
		/* 8206B0B0h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000005C) );
		/* 8206B0B0h case   12:*/		return 0x8206B0B4;
		  /* 8206B0B4h */ case   13:  		/* stb R30, <#[R31 + 124]> */
		/* 8206B0B4h case   13:*/		cpu::mem::store8( regs, regs.R30, (uint32)(regs.R31 + 0x0000007C) );
		/* 8206B0B4h case   13:*/		return 0x8206B0B8;
		  /* 8206B0B8h */ case   14:  		/* bl 156296 */
		/* 8206B0B8h case   14:*/		regs.LR = 0x8206B0BC; return 0x82091340;
		/* 8206B0B8h case   14:*/		return 0x8206B0BC;
		  /* 8206B0BCh */ case   15:  		/* li R5, 32 */
		/* 8206B0BCh case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206B0BCh case   15:*/		return 0x8206B0C0;
		  /* 8206B0C0h */ case   16:  		/* li R4, 0 */
		/* 8206B0C0h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206B0C0h case   16:*/		return 0x8206B0C4;
		  /* 8206B0C4h */ case   17:  		/* addi R3, R31, 160 */
		/* 8206B0C4h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xA0);
		/* 8206B0C4h case   17:*/		return 0x8206B0C8;
	}
	return 0x8206B0C8;
} // Block from 8206B080h-8206B0C8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206B0C8h
// Function 'XMicrocodeBuilder_Initialize'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B0C8);
		  /* 8206B0C8h */ case    0:  		/* bl 156280 */
		/* 8206B0C8h case    0:*/		regs.LR = 0x8206B0CC; return 0x82091340;
		/* 8206B0C8h case    0:*/		return 0x8206B0CC;
		  /* 8206B0CCh */ case    1:  		/* li R5, 32 */
		/* 8206B0CCh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206B0CCh case    1:*/		return 0x8206B0D0;
	}
	return 0x8206B0D0;
} // Block from 8206B0C8h-8206B0D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206B0D0h
// Function 'XMicrocodeBuilder_StartPass'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B0D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B0D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B0D0);
		  /* 8206B0D0h */ case    0:  		/* li R4, 0 */
		/* 8206B0D0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206B0D0h case    0:*/		return 0x8206B0D4;
		  /* 8206B0D4h */ case    1:  		/* addi R3, R31, 192 */
		/* 8206B0D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xC0);
		/* 8206B0D4h case    1:*/		return 0x8206B0D8;
		  /* 8206B0D8h */ case    2:  		/* bl 156264 */
		/* 8206B0D8h case    2:*/		regs.LR = 0x8206B0DC; return 0x82091340;
		/* 8206B0D8h case    2:*/		return 0x8206B0DC;
		  /* 8206B0DCh */ case    3:  		/* li R5, 32 */
		/* 8206B0DCh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206B0DCh case    3:*/		return 0x8206B0E0;
		  /* 8206B0E0h */ case    4:  		/* li R4, 0 */
		/* 8206B0E0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206B0E0h case    4:*/		return 0x8206B0E4;
		  /* 8206B0E4h */ case    5:  		/* addi R3, R31, 224 */
		/* 8206B0E4h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xE0);
		/* 8206B0E4h case    5:*/		return 0x8206B0E8;
		  /* 8206B0E8h */ case    6:  		/* bl 156248 */
		/* 8206B0E8h case    6:*/		regs.LR = 0x8206B0EC; return 0x82091340;
		/* 8206B0E8h case    6:*/		return 0x8206B0EC;
		  /* 8206B0ECh */ case    7:  		/* stw R30, <#[R31 + 256]> */
		/* 8206B0ECh case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000100) );
		/* 8206B0ECh case    7:*/		return 0x8206B0F0;
	}
	return 0x8206B0F0;
} // Block from 8206B0D0h-8206B0F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206B0F0h
// Function 'XMicrocodeBuilder_EndPass'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B0F0);
		  /* 8206B0F0h */ case    0:  		/* stw R30, <#[R31 + 260]> */
		/* 8206B0F0h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000104) );
		/* 8206B0F0h case    0:*/		return 0x8206B0F4;
		  /* 8206B0F4h */ case    1:  		/* stw R30, <#[R31 + 264]> */
		/* 8206B0F4h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000108) );
		/* 8206B0F4h case    1:*/		return 0x8206B0F8;
		  /* 8206B0F8h */ case    2:  		/* stw R30, <#[R31 + 120]> */
		/* 8206B0F8h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000078) );
		/* 8206B0F8h case    2:*/		return 0x8206B0FC;
		  /* 8206B0FCh */ case    3:  		/* stw R30, <#[R31 + 4]> */
		/* 8206B0FCh case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8206B0FCh case    3:*/		return 0x8206B100;
		  /* 8206B100h */ case    4:  		/* stw R30, <#[R31 + 316]> */
		/* 8206B100h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000013C) );
		/* 8206B100h case    4:*/		return 0x8206B104;
		  /* 8206B104h */ case    5:  		/* stw R30, <#[R31 + 336]> */
		/* 8206B104h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000150) );
		/* 8206B104h case    5:*/		return 0x8206B108;
	}
	return 0x8206B108;
} // Block from 8206B0F0h-8206B108h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206B108h
// Function 'XMicrocodeBuilder_SetProgramControl'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B108);
		  /* 8206B108h */ case    0:  		/* stw R30, <#[R31 + 320]> */
		/* 8206B108h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000140) );
		/* 8206B108h case    0:*/		return 0x8206B10C;
		  /* 8206B10Ch */ case    1:  		/* stw R30, <#[R31 + 324]> */
		/* 8206B10Ch case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000144) );
		/* 8206B10Ch case    1:*/		return 0x8206B110;
		  /* 8206B110h */ case    2:  		/* stw R30, <#[R31 + 328]> */
		/* 8206B110h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000148) );
		/* 8206B110h case    2:*/		return 0x8206B114;
		  /* 8206B114h */ case    3:  		/* stw R30, <#[R31 + 332]> */
		/* 8206B114h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000014C) );
		/* 8206B114h case    3:*/		return 0x8206B118;
		  /* 8206B118h */ case    4:  		/* stw R30, <#[R31 + 84]> */
		/* 8206B118h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000054) );
		/* 8206B118h case    4:*/		return 0x8206B11C;
		  /* 8206B11Ch */ case    5:  		/* stw R30, <#[R31 + 340]> */
		/* 8206B11Ch case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000154) );
		/* 8206B11Ch case    5:*/		return 0x8206B120;
		  /* 8206B120h */ case    6:  		/* stw R30, <#[R31 + 344]> */
		/* 8206B120h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000158) );
		/* 8206B120h case    6:*/		return 0x8206B124;
		  /* 8206B124h */ case    7:  		/* stw R30, <#[R31 + 348]> */
		/* 8206B124h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000015C) );
		/* 8206B124h case    7:*/		return 0x8206B128;
	}
	return 0x8206B128;
} // Block from 8206B108h-8206B128h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206B128h
// Function 'XMicrocodeBuilder_SetPDBHint'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B128);
		  /* 8206B128h */ case    0:  		/* addi R1, R1, 112 */
		/* 8206B128h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206B128h case    0:*/		return 0x8206B12C;
		  /* 8206B12Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206B12Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206B12Ch case    1:*/		return 0x8206B130;
		  /* 8206B130h */ case    2:  		/* mtspr LR, R12 */
		/* 8206B130h case    2:*/		regs.LR = regs.R12;
		/* 8206B130h case    2:*/		return 0x8206B134;
		  /* 8206B134h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8206B134h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206B134h case    3:*/		return 0x8206B138;
		  /* 8206B138h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8206B138h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206B138h case    4:*/		return 0x8206B13C;
		  /* 8206B13Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8206B13Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206B13Ch case    5:*/		return 0x8206B140;
	}
	return 0x8206B140;
} // Block from 8206B128h-8206B140h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206B140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B140);
		  /* 8206B140h */ case    0:  		/* mfspr R12, LR */
		/* 8206B140h case    0:*/		regs.R12 = regs.LR;
		/* 8206B140h case    0:*/		return 0x8206B144;
		  /* 8206B144h */ case    1:  		/* bl 155884 */
		/* 8206B144h case    1:*/		regs.LR = 0x8206B148; return 0x82091230;
		/* 8206B144h case    1:*/		return 0x8206B148;
		  /* 8206B148h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 8206B148h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 8206B148h case    2:*/		return 0x8206B14C;
		  /* 8206B14Ch */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8206B14Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206B14Ch case    3:*/		return 0x8206B150;
	}
	return 0x8206B150;
} // Block from 8206B140h-8206B150h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206B150h
// Function 'XMicrocodeBuilder_SetPDBBuilder'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B150);
		  /* 8206B150h */ case    0:  		/* li R18, 1 */
		/* 8206B150h case    0:*/		cpu::op::li<0>(regs,&regs.R18,0x1);
		/* 8206B150h case    0:*/		return 0x8206B154;
		  /* 8206B154h */ case    1:  		/* mr R27, R3 */
		/* 8206B154h case    1:*/		regs.R27 = regs.R3;
		/* 8206B154h case    1:*/		return 0x8206B158;
		  /* 8206B158h */ case    2:  		/* stw R18, <#[R3 + 84]> */
		/* 8206B158h case    2:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x00000054) );
		/* 8206B158h case    2:*/		return 0x8206B15C;
		  /* 8206B15Ch */ case    3:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206B15Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206B15Ch case    3:*/		return 0x8206B160;
		  /* 8206B160h */ case    4:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 8206B160h case    4:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8206B160h case    4:*/		return 0x8206B164;
		  /* 8206B164h */ case    5:  		/* bc 4, CR0_EQ, 1300 */
		/* 8206B164h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8206B678;  }
		/* 8206B164h case    5:*/		return 0x8206B168;
		  /* 8206B168h */ case    6:  		/* lwz R11, <#[R3 + 304]> */
		/* 8206B168h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000130) );
		/* 8206B168h case    6:*/		return 0x8206B16C;
		  /* 8206B16Ch */ case    7:  		/* addi R19, R3, 304 */
		/* 8206B16Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R3,0x130);
		/* 8206B16Ch case    7:*/		return 0x8206B170;
		  /* 8206B170h */ case    8:  		/* lwz R10, <#[R3 + 308]> */
		/* 8206B170h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000134) );
		/* 8206B170h case    8:*/		return 0x8206B174;
		  /* 8206B174h */ case    9:  		/* extsw R31, R11 */
		/* 8206B174h case    9:*/		cpu::op::extsw<0>(regs,&regs.R31,regs.R11);
		/* 8206B174h case    9:*/		return 0x8206B178;
		  /* 8206B178h */ case   10:  		/* b 92 */
		/* 8206B178h case   10:*/		return 0x8206B1D4;
		/* 8206B178h case   10:*/		return 0x8206B17C;
		  /* 8206B17Ch */ case   11:  		/* lwz R11, <#[R31]> */
		/* 8206B17Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206B17Ch case   11:*/		return 0x8206B180;
		  /* 8206B180h */ case   12:  		/* rlwinm R10, R11, 24, 28, 31 */
		/* 8206B180h case   12:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R10,regs.R11);
		/* 8206B180h case   12:*/		return 0x8206B184;
		  /* 8206B184h */ case   13:  		/* rlwinm R9, R11, 20, 12, 31 */
		/* 8206B184h case   13:*/		cpu::op::rlwinm<0,20,12,31>(regs,&regs.R9,regs.R11);
		/* 8206B184h case   13:*/		return 0x8206B188;
		  /* 8206B188h */ case   14:  		/* add R10, R10, R27 */
		/* 8206B188h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R27);
		/* 8206B188h case   14:*/		return 0x8206B18C;
		  /* 8206B18Ch */ case   15:  		/* rlwinm R8, R11, 20, 28, 31 */
		/* 8206B18Ch case   15:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R8,regs.R11);
		/* 8206B18Ch case   15:*/		return 0x8206B190;
		  /* 8206B190h */ case   16:  		/* lbz R10, <#[R10 + 320]> */
		/* 8206B190h case   16:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000140) );
		/* 8206B190h case   16:*/		return 0x8206B194;
		  /* 8206B194h */ case   17:  		/* and R10, R10, R9 */
		/* 8206B194h case   17:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8206B194h case   17:*/		return 0x8206B198;
		  /* 8206B198h */ case   18:  		/* rlwinm R10, R10, 0, 28, 31 */
		/* 8206B198h case   18:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R10);
		/* 8206B198h case   18:*/		return 0x8206B19C;
		  /* 8206B19Ch */ case   19:  		/* cmplw CR6, R10, R8 */
		/* 8206B19Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8206B19Ch case   19:*/		return 0x8206B1A0;
		  /* 8206B1A0h */ case   20:  		/* bc 12, CR6_EQ, 40 */
		/* 8206B1A0h case   20:*/		if ( regs.CR[6].eq ) { return 0x8206B1C8;  }
		/* 8206B1A0h case   20:*/		return 0x8206B1A4;
		  /* 8206B1A4h */ case   21:  		/* cmplwi CR6, R10, 0 */
		/* 8206B1A4h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8206B1A4h case   21:*/		return 0x8206B1A8;
		  /* 8206B1A8h */ case   22:  		/* bc 12, CR6_EQ, 16 */
		/* 8206B1A8h case   22:*/		if ( regs.CR[6].eq ) { return 0x8206B1B8;  }
		/* 8206B1A8h case   22:*/		return 0x8206B1AC;
		  /* 8206B1ACh */ case   23:  		/* rlwimi R11, R10, 12, 16, 19 */
		/* 8206B1ACh case   23:*/		cpu::op::rlwimi<0,12,16,19>(regs,&regs.R11,regs.R10);
		/* 8206B1ACh case   23:*/		return 0x8206B1B0;
		  /* 8206B1B0h */ case   24:  		/* stw R11, <#[R31]> */
		/* 8206B1B0h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206B1B0h case   24:*/		return 0x8206B1B4;
		  /* 8206B1B4h */ case   25:  		/* b 20 */
		/* 8206B1B4h case   25:*/		return 0x8206B1C8;
		/* 8206B1B4h case   25:*/		return 0x8206B1B8;
	}
	return 0x8206B1B8;
} // Block from 8206B150h-8206B1B8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8206B1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B1B8);
		  /* 8206B1B8h */ case    0:  		/* mr R4, R31 */
		/* 8206B1B8h case    0:*/		regs.R4 = regs.R31;
		/* 8206B1B8h case    0:*/		return 0x8206B1BC;
		  /* 8206B1BCh */ case    1:  		/* mr R3, R19 */
		/* 8206B1BCh case    1:*/		regs.R3 = regs.R19;
		/* 8206B1BCh case    1:*/		return 0x8206B1C0;
		  /* 8206B1C0h */ case    2:  		/* bl -11216 */
		/* 8206B1C0h case    2:*/		regs.LR = 0x8206B1C4; return 0x820685F0;
		/* 8206B1C0h case    2:*/		return 0x8206B1C4;
		  /* 8206B1C4h */ case    3:  		/* addi R31, R31, -4 */
		/* 8206B1C4h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFC);
		/* 8206B1C4h case    3:*/		return 0x8206B1C8;
	}
	return 0x8206B1C8;
} // Block from 8206B1B8h-8206B1C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206B1C8h
// Function 'XMicrocodeBuilder_DefineBooleanConstant'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B1C8);
		  /* 8206B1C8h */ case    0:  		/* lwz R10, <#[R19 + 4]> */
		/* 8206B1C8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000004) );
		/* 8206B1C8h case    0:*/		return 0x8206B1CC;
		  /* 8206B1CCh */ case    1:  		/* addi R31, R31, 4 */
		/* 8206B1CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8206B1CCh case    1:*/		return 0x8206B1D0;
		  /* 8206B1D0h */ case    2:  		/* lwz R11, <#[R19]> */
		/* 8206B1D0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8206B1D0h case    2:*/		return 0x8206B1D4;
	}
	return 0x8206B1D4;
} // Block from 8206B1C8h-8206B1D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206B1D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B1D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B1D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B1D4);
		  /* 8206B1D4h */ case    0:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8206B1D4h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8206B1D4h case    0:*/		return 0x8206B1D8;
		  /* 8206B1D8h */ case    1:  		/* add R11, R10, R11 */
		/* 8206B1D8h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206B1D8h case    1:*/		return 0x8206B1DC;
		  /* 8206B1DCh */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 8206B1DCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8206B1DCh case    2:*/		return 0x8206B1E0;
		  /* 8206B1E0h */ case    3:  		/* bc 12, CR6_LT, -100 */
		/* 8206B1E0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8206B17C;  }
		/* 8206B1E0h case    3:*/		return 0x8206B1E4;
		  /* 8206B1E4h */ case    4:  		/* lwz R10, <#[R27 + 296]> */
		/* 8206B1E4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000128) );
		/* 8206B1E4h case    4:*/		return 0x8206B1E8;
		  /* 8206B1E8h */ case    5:  		/* addi R23, R27, 292 */
		/* 8206B1E8h case    5:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R27,0x124);
		/* 8206B1E8h case    5:*/		return 0x8206B1EC;
		  /* 8206B1ECh */ case    6:  		/* lwz R11, <#[R27 + 292]> */
		/* 8206B1ECh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000124) );
		/* 8206B1ECh case    6:*/		return 0x8206B1F0;
		  /* 8206B1F0h */ case    7:  		/* li R20, 0 */
		/* 8206B1F0h case    7:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 8206B1F0h case    7:*/		return 0x8206B1F4;
		  /* 8206B1F4h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8206B1F4h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8206B1F4h case    8:*/		return 0x8206B1F8;
		  /* 8206B1F8h */ case    9:  		/* extsw R26, R11 */
		/* 8206B1F8h case    9:*/		cpu::op::extsw<0>(regs,&regs.R26,regs.R11);
		/* 8206B1F8h case    9:*/		return 0x8206B1FC;
		  /* 8206B1FCh */ case   10:  		/* li R22, 0 */
		/* 8206B1FCh case   10:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 8206B1FCh case   10:*/		return 0x8206B200;
		  /* 8206B200h */ case   11:  		/* add R11, R10, R11 */
		/* 8206B200h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206B200h case   11:*/		return 0x8206B204;
		  /* 8206B204h */ case   12:  		/* li R29, 0 */
		/* 8206B204h case   12:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8206B204h case   12:*/		return 0x8206B208;
		  /* 8206B208h */ case   13:  		/* li R28, 0 */
		/* 8206B208h case   13:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8206B208h case   13:*/		return 0x8206B20C;
		  /* 8206B20Ch */ case   14:  		/* b 816 */
		/* 8206B20Ch case   14:*/		return 0x8206B53C;
		/* 8206B20Ch case   14:*/		return 0x8206B210;
		  /* 8206B210h */ case   15:  		/* lwz R31, <#[R26]> */
		/* 8206B210h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000000) );
		/* 8206B210h case   15:*/		return 0x8206B214;
		  /* 8206B214h */ case   16:  		/* mr R3, R27 */
		/* 8206B214h case   16:*/		regs.R3 = regs.R27;
		/* 8206B214h case   16:*/		return 0x8206B218;
		  /* 8206B218h */ case   17:  		/* lwz R24, <#[R27 + 96]> */
		/* 8206B218h case   17:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R27 + 0x00000060) );
		/* 8206B218h case   17:*/		return 0x8206B21C;
		  /* 8206B21Ch */ case   18:  		/* rlwinm R30, R31, 0, 20, 31 */
		/* 8206B21Ch case   18:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R30,regs.R31);
		/* 8206B21Ch case   18:*/		return 0x8206B220;
		  /* 8206B220h */ case   19:  		/* mulli R11, R30, 12 */
		/* 8206B220h case   19:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R30,0xC);
		/* 8206B220h case   19:*/		return 0x8206B224;
		  /* 8206B224h */ case   20:  		/* mr R4, R30 */
		/* 8206B224h case   20:*/		regs.R4 = regs.R30;
		/* 8206B224h case   20:*/		return 0x8206B228;
		  /* 8206B228h */ case   21:  		/* add R21, R11, R24 */
		/* 8206B228h case   21:*/		cpu::op::add<0>(regs,&regs.R21,regs.R11,regs.R24);
		/* 8206B228h case   21:*/		return 0x8206B22C;
		  /* 8206B22Ch */ case   22:  		/* bl -6764 */
		/* 8206B22Ch case   22:*/		regs.LR = 0x8206B230; return 0x820697C0;
		/* 8206B22Ch case   22:*/		return 0x8206B230;
		  /* 8206B230h */ case   23:  		/* mr R25, R3 */
		/* 8206B230h case   23:*/		regs.R25 = regs.R3;
		/* 8206B230h case   23:*/		return 0x8206B234;
		  /* 8206B234h */ case   24:  		/* li R10, 0 */
		/* 8206B234h case   24:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8206B234h case   24:*/		return 0x8206B238;
		  /* 8206B238h */ case   25:  		/* cmplwi CR6, R29, 0 */
		/* 8206B238h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8206B238h case   25:*/		return 0x8206B23C;
		  /* 8206B23Ch */ case   26:  		/* bc 12, CR6_EQ, 668 */
		/* 8206B23Ch case   26:*/		if ( regs.CR[6].eq ) { return 0x8206B4D8;  }
		/* 8206B23Ch case   26:*/		return 0x8206B240;
		  /* 8206B240h */ case   27:  		/* lwz R11, <#[R26 - 4]> */
		/* 8206B240h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFFFFFC) );
		/* 8206B240h case   27:*/		return 0x8206B244;
		  /* 8206B244h */ case   28:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 8206B244h case   28:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 8206B244h case   28:*/		return 0x8206B248;
	}
	return 0x8206B248;
} // Block from 8206B1D4h-8206B248h (29 instructions)

//////////////////////////////////////////////////////
// Block at 8206B248h
// Function 'XMicrocodeBuilder_DefineIntegerConstant'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B248);
		  /* 8206B248h */ case    0:  		/* addi R11, R11, 1 */
		/* 8206B248h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206B248h case    0:*/		return 0x8206B24C;
		  /* 8206B24Ch */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 8206B24Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8206B24Ch case    1:*/		return 0x8206B250;
		  /* 8206B250h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 8206B250h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8206B26C;  }
		/* 8206B250h case    2:*/		return 0x8206B254;
		  /* 8206B254h */ case    3:  		/* lwz R11, <#[R28]> */
		/* 8206B254h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8206B254h case    3:*/		return 0x8206B258;
		  /* 8206B258h */ case    4:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8206B258h case    4:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8206B258h case    4:*/		return 0x8206B25C;
		  /* 8206B25Ch */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 8206B25Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x8206B26C;  }
		/* 8206B25Ch case    5:*/		return 0x8206B260;
		  /* 8206B260h */ case    6:  		/* rlwinm. R11, R31, 0, 9, 9 */
		/* 8206B260h case    6:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R31);
		/* 8206B260h case    6:*/		return 0x8206B264;
		  /* 8206B264h */ case    7:  		/* mr R11, R18 */
		/* 8206B264h case    7:*/		regs.R11 = regs.R18;
		/* 8206B264h case    7:*/		return 0x8206B268;
		  /* 8206B268h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 8206B268h case    8:*/		if ( regs.CR[0].eq ) { return 0x8206B270;  }
		/* 8206B268h case    8:*/		return 0x8206B26C;
	}
	return 0x8206B26C;
} // Block from 8206B248h-8206B26Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206B26Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B26C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B26C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B26C);
		  /* 8206B26Ch */ case    0:  		/* li R11, 0 */
		/* 8206B26Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206B26Ch case    0:*/		return 0x8206B270;
	}
	return 0x8206B270;
} // Block from 8206B26Ch-8206B270h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B270);
		  /* 8206B270h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8206B270h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8206B270h case    0:*/		return 0x8206B274;
		  /* 8206B274h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 8206B274h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206B2A8;  }
		/* 8206B274h case    1:*/		return 0x8206B278;
		  /* 8206B278h */ case    2:  		/* lwz R11, <#[R29]> */
		/* 8206B278h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8206B278h case    2:*/		return 0x8206B27C;
		  /* 8206B27Ch */ case    3:  		/* lwz R10, <#[R21]> */
		/* 8206B27Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000000) );
		/* 8206B27Ch case    3:*/		return 0x8206B280;
		  /* 8206B280h */ case    4:  		/* xor R9, R10, R11 */
		/* 8206B280h case    4:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 8206B280h case    4:*/		return 0x8206B284;
		  /* 8206B284h */ case    5:  		/* rlwinm. R9, R9, 0, 21, 26 */
		/* 8206B284h case    5:*/		cpu::op::rlwinm<1,0,21,26>(regs,&regs.R9,regs.R9);
		/* 8206B284h case    5:*/		return 0x8206B288;
		  /* 8206B288h */ case    6:  		/* bc 4, CR0_EQ, 32 */
		/* 8206B288h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8206B2A8;  }
		/* 8206B288h case    6:*/		return 0x8206B28C;
		  /* 8206B28Ch */ case    7:  		/* xor R9, R10, R11 */
		/* 8206B28Ch case    7:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 8206B28Ch case    7:*/		return 0x8206B290;
		  /* 8206B290h */ case    8:  		/* rlwinm. R9, R9, 0, 20, 20 */
		/* 8206B290h case    8:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R9);
		/* 8206B290h case    8:*/		return 0x8206B294;
		  /* 8206B294h */ case    9:  		/* bc 4, CR0_EQ, 20 */
		/* 8206B294h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8206B2A8;  }
		/* 8206B294h case    9:*/		return 0x8206B298;
		  /* 8206B298h */ case   10:  		/* xor R11, R10, R11 */
		/* 8206B298h case   10:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206B298h case   10:*/		return 0x8206B29C;
		  /* 8206B29Ch */ case   11:  		/* rlwinm. R11, R11, 0, 0, 1 */
		/* 8206B29Ch case   11:*/		cpu::op::rlwinm<1,0,0,1>(regs,&regs.R11,regs.R11);
		/* 8206B29Ch case   11:*/		return 0x8206B2A0;
		  /* 8206B2A0h */ case   12:  		/* mr R11, R18 */
		/* 8206B2A0h case   12:*/		regs.R11 = regs.R18;
		/* 8206B2A0h case   12:*/		return 0x8206B2A4;
		  /* 8206B2A4h */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 8206B2A4h case   13:*/		if ( regs.CR[0].eq ) { return 0x8206B2AC;  }
		/* 8206B2A4h case   13:*/		return 0x8206B2A8;
	}
	return 0x8206B2A8;
} // Block from 8206B270h-8206B2A8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206B2A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B2A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B2A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B2A8);
		  /* 8206B2A8h */ case    0:  		/* li R11, 0 */
		/* 8206B2A8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206B2A8h case    0:*/		return 0x8206B2AC;
	}
	return 0x8206B2AC;
} // Block from 8206B2A8h-8206B2ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B2ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B2AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B2AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B2AC);
		  /* 8206B2ACh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8206B2ACh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8206B2ACh case    0:*/		return 0x8206B2B0;
		  /* 8206B2B0h */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8206B2B0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206B2E0;  }
		/* 8206B2B0h case    1:*/		return 0x8206B2B4;
		  /* 8206B2B4h */ case    2:  		/* lwz R11, <#[R25]> */
		/* 8206B2B4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8206B2B4h case    2:*/		return 0x8206B2B8;
		  /* 8206B2B8h */ case    3:  		/* li R10, 2 */
		/* 8206B2B8h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 8206B2B8h case    3:*/		return 0x8206B2BC;
		  /* 8206B2BCh */ case    4:  		/* rlwinm R9, R11, 0, 20, 31 */
		/* 8206B2BCh case    4:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R9,regs.R11);
		/* 8206B2BCh case    4:*/		return 0x8206B2C0;
		  /* 8206B2C0h */ case    5:  		/* rlwinm R11, R11, 16, 16, 31 */
		/* 8206B2C0h case    5:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R11,regs.R11);
		/* 8206B2C0h case    5:*/		return 0x8206B2C4;
		  /* 8206B2C4h */ case    6:  		/* subf R9, R9, R30 */
		/* 8206B2C4h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R9,regs.R30);
		/* 8206B2C4h case    6:*/		return 0x8206B2C8;
	}
	return 0x8206B2C8;
} // Block from 8206B2ACh-8206B2C8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206B2C8h
// Function 'XMicrocodeBuilder_DefineFloatConstant'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B2C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B2C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B2C8);
		  /* 8206B2C8h */ case    0:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 8206B2C8h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 8206B2C8h case    0:*/		return 0x8206B2CC;
		  /* 8206B2CCh */ case    1:  		/* slw R10, R10, R9 */
		/* 8206B2CCh case    1:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8206B2CCh case    1:*/		return 0x8206B2D0;
		  /* 8206B2D0h */ case    2:  		/* and R11, R10, R11 */
		/* 8206B2D0h case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206B2D0h case    2:*/		return 0x8206B2D4;
		  /* 8206B2D4h */ case    3:  		/* rlwinm. R11, R11, 0, 20, 31 */
		/* 8206B2D4h case    3:*/		cpu::op::rlwinm<1,0,20,31>(regs,&regs.R11,regs.R11);
		/* 8206B2D4h case    3:*/		return 0x8206B2D8;
		  /* 8206B2D8h */ case    4:  		/* mr R11, R18 */
		/* 8206B2D8h case    4:*/		regs.R11 = regs.R18;
		/* 8206B2D8h case    4:*/		return 0x8206B2DC;
		  /* 8206B2DCh */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 8206B2DCh case    5:*/		if ( regs.CR[0].eq ) { return 0x8206B2E4;  }
		/* 8206B2DCh case    5:*/		return 0x8206B2E0;
	}
	return 0x8206B2E0;
} // Block from 8206B2C8h-8206B2E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206B2E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B2E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B2E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B2E0);
		  /* 8206B2E0h */ case    0:  		/* li R11, 0 */
		/* 8206B2E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206B2E0h case    0:*/		return 0x8206B2E4;
	}
	return 0x8206B2E4;
} // Block from 8206B2E0h-8206B2E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B2E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B2E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B2E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B2E4);
		  /* 8206B2E4h */ case    0:  		/* lwz R9, <#[R29 + 4]> */
		/* 8206B2E4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000004) );
		/* 8206B2E4h case    0:*/		return 0x8206B2E8;
		  /* 8206B2E8h */ case    1:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 8206B2E8h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 8206B2E8h case    1:*/		return 0x8206B2EC;
		  /* 8206B2ECh */ case    2:  		/* rlwinm. R11, R9, 1, 31, 31 */
		/* 8206B2ECh case    2:*/		cpu::op::rlwinm<1,1,31,31>(regs,&regs.R11,regs.R9);
		/* 8206B2ECh case    2:*/		return 0x8206B2F0;
		  /* 8206B2F0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8206B2F0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8206B300;  }
		/* 8206B2F0h case    3:*/		return 0x8206B2F4;
		  /* 8206B2F4h */ case    4:  		/* lwz R9, <#[R21 + 4]> */
		/* 8206B2F4h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R21 + 0x00000004) );
		/* 8206B2F4h case    4:*/		return 0x8206B2F8;
		  /* 8206B2F8h */ case    5:  		/* rlwinm. R9, R9, 0, 0, 0 */
		/* 8206B2F8h case    5:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R9);
		/* 8206B2F8h case    5:*/		return 0x8206B2FC;
		  /* 8206B2FCh */ case    6:  		/* bc 12, CR0_EQ, 64 */
		/* 8206B2FCh case    6:*/		if ( regs.CR[0].eq ) { return 0x8206B33C;  }
		/* 8206B2FCh case    6:*/		return 0x8206B300;
	}
	return 0x8206B300;
} // Block from 8206B2E4h-8206B300h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206B300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B300);
		  /* 8206B300h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8206B300h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8206B300h case    0:*/		return 0x8206B304;
		  /* 8206B304h */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8206B304h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206B334;  }
		/* 8206B304h case    1:*/		return 0x8206B308;
		  /* 8206B308h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8206B308h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206B308h case    2:*/		return 0x8206B30C;
		  /* 8206B30Ch */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 8206B30Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8206B334;  }
		/* 8206B30Ch case    3:*/		return 0x8206B310;
		  /* 8206B310h */ case    4:  		/* lwz R11, <#[R21 + 4]> */
		/* 8206B310h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 8206B310h case    4:*/		return 0x8206B314;
		  /* 8206B314h */ case    5:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 8206B314h case    5:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8206B314h case    5:*/		return 0x8206B318;
		  /* 8206B318h */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 8206B318h case    6:*/		if ( regs.CR[0].eq ) { return 0x8206B334;  }
		/* 8206B318h case    6:*/		return 0x8206B31C;
		  /* 8206B31Ch */ case    7:  		/* lwz R11, <#[R21 + 8]> */
		/* 8206B31Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 8206B31Ch case    7:*/		return 0x8206B320;
		  /* 8206B320h */ case    8:  		/* lwz R10, <#[R29 + 8]> */
		/* 8206B320h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8206B320h case    8:*/		return 0x8206B324;
		  /* 8206B324h */ case    9:  		/* xor R11, R11, R10 */
		/* 8206B324h case    9:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206B324h case    9:*/		return 0x8206B328;
		  /* 8206B328h */ case   10:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 8206B328h case   10:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8206B328h case   10:*/		return 0x8206B32C;
		  /* 8206B32Ch */ case   11:  		/* mr R11, R18 */
		/* 8206B32Ch case   11:*/		regs.R11 = regs.R18;
		/* 8206B32Ch case   11:*/		return 0x8206B330;
		  /* 8206B330h */ case   12:  		/* bc 12, CR0_EQ, 8 */
		/* 8206B330h case   12:*/		if ( regs.CR[0].eq ) { return 0x8206B338;  }
		/* 8206B330h case   12:*/		return 0x8206B334;
	}
	return 0x8206B334;
} // Block from 8206B300h-8206B334h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206B334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B334);
		  /* 8206B334h */ case    0:  		/* li R11, 0 */
		/* 8206B334h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206B334h case    0:*/		return 0x8206B338;
	}
	return 0x8206B338;
} // Block from 8206B334h-8206B338h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B338);
		  /* 8206B338h */ case    0:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 8206B338h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 8206B338h case    0:*/		return 0x8206B33C;
	}
	return 0x8206B33C;
} // Block from 8206B338h-8206B33Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B33Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B33C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B33C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B33C);
		  /* 8206B33Ch */ case    0:  		/* rlwinm. R11, R10, 0, 24, 31 */
		/* 8206B33Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R10);
		/* 8206B33Ch case    0:*/		return 0x8206B340;
		  /* 8206B340h */ case    1:  		/* bc 12, CR0_EQ, 408 */
		/* 8206B340h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206B4D8;  }
		/* 8206B340h case    1:*/		return 0x8206B344;
		  /* 8206B344h */ case    2:  		/* cmplw CR6, R22, R25 */
		/* 8206B344h case    2:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R25);
		/* 8206B344h case    2:*/		return 0x8206B348;
		  /* 8206B348h */ case    3:  		/* bc 12, CR6_EQ, 400 */
		/* 8206B348h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206B4D8;  }
		/* 8206B348h case    3:*/		return 0x8206B34C;
		  /* 8206B34Ch */ case    4:  		/* addi R11, R22, 8 */
		/* 8206B34Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R22,0x8);
		/* 8206B34Ch case    4:*/		return 0x8206B350;
		  /* 8206B350h */ case    5:  		/* cmplw CR6, R11, R25 */
		/* 8206B350h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 8206B350h case    5:*/		return 0x8206B354;
		  /* 8206B354h */ case    6:  		/* bc 4, CR6_EQ, 40 */
		/* 8206B354h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8206B37C;  }
		/* 8206B354h case    6:*/		return 0x8206B358;
		  /* 8206B358h */ case    7:  		/* lwz R11, <#[R25 + 4]> */
		/* 8206B358h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 8206B358h case    7:*/		return 0x8206B35C;
		  /* 8206B35Ch */ case    8:  		/* rlwinm R11, R11, 0, 16, 19 */
		/* 8206B35Ch case    8:*/		cpu::op::rlwinm<0,0,16,19>(regs,&regs.R11,regs.R11);
		/* 8206B35Ch case    8:*/		return 0x8206B360;
	}
	return 0x8206B360;
} // Block from 8206B33Ch-8206B360h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206B360h
// Function 'XMicrocodeBuilder_SetConstantTable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B360);
		  /* 8206B360h */ case    0:  		/* cmplwi CR6, R11, 4096 */
		/* 8206B360h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001000);
		/* 8206B360h case    0:*/		return 0x8206B364;
		  /* 8206B364h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8206B364h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8206B374;  }
		/* 8206B364h case    1:*/		return 0x8206B368;
		  /* 8206B368h */ case    2:  		/* lwz R11, <#[R25]> */
		/* 8206B368h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8206B368h case    2:*/		return 0x8206B36C;
		  /* 8206B36Ch */ case    3:  		/* rlwinm. R11, R11, 0, 16, 16 */
		/* 8206B36Ch case    3:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R11);
		/* 8206B36Ch case    3:*/		return 0x8206B370;
		  /* 8206B370h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 8206B370h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8206B37C;  }
		/* 8206B370h case    4:*/		return 0x8206B374;
	}
	return 0x8206B374;
} // Block from 8206B360h-8206B374h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206B374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B374);
		  /* 8206B374h */ case    0:  		/* mr R10, R18 */
		/* 8206B374h case    0:*/		regs.R10 = regs.R18;
		/* 8206B374h case    0:*/		return 0x8206B378;
		  /* 8206B378h */ case    1:  		/* b 8 */
		/* 8206B378h case    1:*/		return 0x8206B380;
		/* 8206B378h case    1:*/		return 0x8206B37C;
	}
	return 0x8206B37C;
} // Block from 8206B374h-8206B37Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206B37Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B37C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B37C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B37C);
		  /* 8206B37Ch */ case    0:  		/* li R10, 0 */
		/* 8206B37Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8206B37Ch case    0:*/		return 0x8206B380;
	}
	return 0x8206B380;
} // Block from 8206B37Ch-8206B380h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B380);
		  /* 8206B380h */ case    0:  		/* lwz R6, <#[R22 + 4]> */
		/* 8206B380h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R22 + 0x00000004) );
		/* 8206B380h case    0:*/		return 0x8206B384;
		  /* 8206B384h */ case    1:  		/* rlwinm R10, R10, 0, 24, 31 */
		/* 8206B384h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8206B384h case    1:*/		return 0x8206B388;
		  /* 8206B388h */ case    2:  		/* lwz R5, <#[R25 + 4]> */
		/* 8206B388h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R25 + 0x00000004) );
		/* 8206B388h case    2:*/		return 0x8206B38C;
		  /* 8206B38Ch */ case    3:  		/* rlwinm R11, R6, 20, 28, 31 */
		/* 8206B38Ch case    3:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R6);
		/* 8206B38Ch case    3:*/		return 0x8206B390;
		  /* 8206B390h */ case    4:  		/* rlwinm R8, R5, 20, 28, 31 */
		/* 8206B390h case    4:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R8,regs.R5);
		/* 8206B390h case    4:*/		return 0x8206B394;
		  /* 8206B394h */ case    5:  		/* slw R9, R18, R11 */
		/* 8206B394h case    5:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R18,regs.R11);
		/* 8206B394h case    5:*/		return 0x8206B398;
		  /* 8206B398h */ case    6:  		/* andi. R11, R9, 24600 */
		/* 8206B398h case    6:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R9,0x6018);
		/* 8206B398h case    6:*/		return 0x8206B39C;
		  /* 8206B39Ch */ case    7:  		/* slw R8, R18, R8 */
		/* 8206B39Ch case    7:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R18,regs.R8);
		/* 8206B39Ch case    7:*/		return 0x8206B3A0;
		  /* 8206B3A0h */ case    8:  		/* addic R7, R11, -1 */
		/* 8206B3A0h case    8:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R11,0xFFFFFFFF);
		/* 8206B3A0h case    8:*/		return 0x8206B3A4;
		  /* 8206B3A4h */ case    9:  		/* andi. R4, R8, 24600 */
		/* 8206B3A4h case    9:*/		cpu::op::andi<1>(regs,&regs.R4,regs.R8,0x6018);
		/* 8206B3A4h case    9:*/		return 0x8206B3A8;
		  /* 8206B3A8h */ case   10:  		/* subfe R11, R7, R11 */
		/* 8206B3A8h case   10:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8206B3A8h case   10:*/		return 0x8206B3AC;
		  /* 8206B3ACh */ case   11:  		/* addic R7, R4, -1 */
		/* 8206B3ACh case   11:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R4,0xFFFFFFFF);
		/* 8206B3ACh case   11:*/		return 0x8206B3B0;
		  /* 8206B3B0h */ case   12:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8206B3B0h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8206B3B0h case   12:*/		return 0x8206B3B4;
		  /* 8206B3B4h */ case   13:  		/* subfe R7, R7, R4 */
		/* 8206B3B4h case   13:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R7,regs.R4);
		/* 8206B3B4h case   13:*/		return 0x8206B3B8;
	}
	return 0x8206B3B8;
} // Block from 8206B380h-8206B3B8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206B3B8h
// Function 'XMicrocodeBuilder_DeclareInterpolatorSemantic'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B3B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B3B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B3B8);
		  /* 8206B3B8h */ case    0:  		/* bc 4, CR0_EQ, 12 */
		/* 8206B3B8h case    0:*/		if ( !regs.CR[0].eq ) { return 0x8206B3C4;  }
		/* 8206B3B8h case    0:*/		return 0x8206B3BC;
		  /* 8206B3BCh */ case    1:  		/* rlwinm. R4, R7, 0, 24, 31 */
		/* 8206B3BCh case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R4,regs.R7);
		/* 8206B3BCh case    1:*/		return 0x8206B3C0;
		  /* 8206B3C0h */ case    2:  		/* bc 12, CR0_EQ, 64 */
		/* 8206B3C0h case    2:*/		if ( regs.CR[0].eq ) { return 0x8206B400;  }
		/* 8206B3C0h case    2:*/		return 0x8206B3C4;
	}
	return 0x8206B3C4;
} // Block from 8206B3B8h-8206B3C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206B3C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B3C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B3C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B3C4);
		  /* 8206B3C4h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8206B3C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8206B3C4h case    0:*/		return 0x8206B3C8;
		  /* 8206B3C8h */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8206B3C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206B3F8;  }
		/* 8206B3C8h case    1:*/		return 0x8206B3CC;
		  /* 8206B3CCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8206B3CCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206B3CCh case    2:*/		return 0x8206B3D0;
		  /* 8206B3D0h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 8206B3D0h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206B3F8;  }
		/* 8206B3D0h case    3:*/		return 0x8206B3D4;
		  /* 8206B3D4h */ case    4:  		/* rlwinm. R11, R7, 0, 24, 31 */
		/* 8206B3D4h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R7);
		/* 8206B3D4h case    4:*/		return 0x8206B3D8;
		  /* 8206B3D8h */ case    5:  		/* bc 12, CR0_EQ, 32 */
		/* 8206B3D8h case    5:*/		if ( regs.CR[0].eq ) { return 0x8206B3F8;  }
		/* 8206B3D8h case    5:*/		return 0x8206B3DC;
		  /* 8206B3DCh */ case    6:  		/* xor R11, R6, R5 */
		/* 8206B3DCh case    6:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 8206B3DCh case    6:*/		return 0x8206B3E0;
		  /* 8206B3E0h */ case    7:  		/* rlwinm. R11, R11, 0, 21, 21 */
		/* 8206B3E0h case    7:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R11);
		/* 8206B3E0h case    7:*/		return 0x8206B3E4;
		  /* 8206B3E4h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 8206B3E4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8206B3F8;  }
		/* 8206B3E4h case    8:*/		return 0x8206B3E8;
		  /* 8206B3E8h */ case    9:  		/* xor R11, R6, R5 */
		/* 8206B3E8h case    9:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 8206B3E8h case    9:*/		return 0x8206B3EC;
		  /* 8206B3ECh */ case   10:  		/* rlwinm. R11, R11, 0, 22, 29 */
		/* 8206B3ECh case   10:*/		cpu::op::rlwinm<1,0,22,29>(regs,&regs.R11,regs.R11);
		/* 8206B3ECh case   10:*/		return 0x8206B3F0;
		  /* 8206B3F0h */ case   11:  		/* mr R11, R18 */
		/* 8206B3F0h case   11:*/		regs.R11 = regs.R18;
		/* 8206B3F0h case   11:*/		return 0x8206B3F4;
		  /* 8206B3F4h */ case   12:  		/* bc 12, CR0_EQ, 8 */
		/* 8206B3F4h case   12:*/		if ( regs.CR[0].eq ) { return 0x8206B3FC;  }
		/* 8206B3F4h case   12:*/		return 0x8206B3F8;
	}
	return 0x8206B3F8;
} // Block from 8206B3C4h-8206B3F8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206B3F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B3F8);
		  /* 8206B3F8h */ case    0:  		/* li R11, 0 */
		/* 8206B3F8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206B3F8h case    0:*/		return 0x8206B3FC;
	}
	return 0x8206B3FC;
} // Block from 8206B3F8h-8206B3FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B3FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B3FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B3FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B3FC);
		  /* 8206B3FCh */ case    0:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 8206B3FCh case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 8206B3FCh case    0:*/		return 0x8206B400;
	}
	return 0x8206B400;
} // Block from 8206B3FCh-8206B400h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B400);
		  /* 8206B400h */ case    0:  		/* rlwinm R11, R9, 0, 25, 26 */
		/* 8206B400h case    0:*/		cpu::op::rlwinm<0,0,25,26>(regs,&regs.R11,regs.R9);
		/* 8206B400h case    0:*/		return 0x8206B404;
		  /* 8206B404h */ case    1:  		/* rlwinm R9, R8, 0, 25, 26 */
		/* 8206B404h case    1:*/		cpu::op::rlwinm<0,0,25,26>(regs,&regs.R9,regs.R8);
		/* 8206B404h case    1:*/		return 0x8206B408;
		  /* 8206B408h */ case    2:  		/* addic R8, R11, -1 */
		/* 8206B408h case    2:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R11,0xFFFFFFFF);
		/* 8206B408h case    2:*/		return 0x8206B40C;
		  /* 8206B40Ch */ case    3:  		/* subfe R11, R8, R11 */
		/* 8206B40Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8206B40Ch case    3:*/		return 0x8206B410;
		  /* 8206B410h */ case    4:  		/* addic R8, R9, -1 */
		/* 8206B410h case    4:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 8206B410h case    4:*/		return 0x8206B414;
		  /* 8206B414h */ case    5:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8206B414h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8206B414h case    5:*/		return 0x8206B418;
		  /* 8206B418h */ case    6:  		/* subfe R9, R8, R9 */
		/* 8206B418h case    6:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8206B418h case    6:*/		return 0x8206B41C;
		  /* 8206B41Ch */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 8206B41Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x8206B428;  }
		/* 8206B41Ch case    7:*/		return 0x8206B420;
		  /* 8206B420h */ case    8:  		/* rlwinm. R8, R9, 0, 24, 31 */
		/* 8206B420h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R8,regs.R9);
		/* 8206B420h case    8:*/		return 0x8206B424;
		  /* 8206B424h */ case    9:  		/* bc 12, CR0_EQ, 72 */
		/* 8206B424h case    9:*/		if ( regs.CR[0].eq ) { return 0x8206B46C;  }
		/* 8206B424h case    9:*/		return 0x8206B428;
	}
	return 0x8206B428;
} // Block from 8206B400h-8206B428h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206B428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B428);
		  /* 8206B428h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8206B428h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8206B428h case    0:*/		return 0x8206B42C;
		  /* 8206B42Ch */ case    1:  		/* bc 12, CR0_EQ, 56 */
		/* 8206B42Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8206B464;  }
		/* 8206B42Ch case    1:*/		return 0x8206B430;
		  /* 8206B430h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8206B430h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206B430h case    2:*/		return 0x8206B434;
		  /* 8206B434h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 8206B434h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206B464;  }
		/* 8206B434h case    3:*/		return 0x8206B438;
		  /* 8206B438h */ case    4:  		/* rlwinm. R11, R9, 0, 24, 31 */
		/* 8206B438h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R9);
		/* 8206B438h case    4:*/		return 0x8206B43C;
		  /* 8206B43Ch */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 8206B43Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8206B464;  }
		/* 8206B43Ch case    5:*/		return 0x8206B440;
		  /* 8206B440h */ case    6:  		/* xor R11, R6, R5 */
		/* 8206B440h case    6:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 8206B440h case    6:*/		return 0x8206B444;
		  /* 8206B444h */ case    7:  		/* rlwinm. R11, R11, 0, 21, 21 */
		/* 8206B444h case    7:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R11);
		/* 8206B444h case    7:*/		return 0x8206B448;
		  /* 8206B448h */ case    8:  		/* bc 4, CR0_EQ, 28 */
		/* 8206B448h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8206B464;  }
		/* 8206B448h case    8:*/		return 0x8206B44C;
		  /* 8206B44Ch */ case    9:  		/* mr R4, R24 */
		/* 8206B44Ch case    9:*/		regs.R4 = regs.R24;
		/* 8206B44Ch case    9:*/		return 0x8206B450;
	}
	return 0x8206B450;
} // Block from 8206B428h-8206B450h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206B450h
// Function 'XMicrocodeBuilder_DeclareIndexSemantic'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B450);
		  /* 8206B450h */ case    0:  		/* mr R3, R22 */
		/* 8206B450h case    0:*/		regs.R3 = regs.R22;
		/* 8206B450h case    0:*/		return 0x8206B454;
		  /* 8206B454h */ case    1:  		/* bl -14876 */
		/* 8206B454h case    1:*/		regs.LR = 0x8206B458; return 0x82067A38;
		/* 8206B454h case    1:*/		return 0x8206B458;
		  /* 8206B458h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8206B458h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8206B458h case    2:*/		return 0x8206B45C;
		  /* 8206B45Ch */ case    3:  		/* mr R11, R18 */
		/* 8206B45Ch case    3:*/		regs.R11 = regs.R18;
		/* 8206B45Ch case    3:*/		return 0x8206B460;
		  /* 8206B460h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 8206B460h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8206B468;  }
		/* 8206B460h case    4:*/		return 0x8206B464;
	}
	return 0x8206B464;
} // Block from 8206B450h-8206B464h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206B464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B464);
		  /* 8206B464h */ case    0:  		/* li R11, 0 */
		/* 8206B464h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206B464h case    0:*/		return 0x8206B468;
	}
	return 0x8206B468;
} // Block from 8206B464h-8206B468h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B468);
		  /* 8206B468h */ case    0:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 8206B468h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 8206B468h case    0:*/		return 0x8206B46C;
	}
	return 0x8206B46C;
} // Block from 8206B468h-8206B46Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B46Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B46C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B46C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B46C);
		  /* 8206B46Ch */ case    0:  		/* rlwinm. R11, R10, 0, 24, 31 */
		/* 8206B46Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R10);
		/* 8206B46Ch case    0:*/		return 0x8206B470;
		  /* 8206B470h */ case    1:  		/* bc 12, CR0_EQ, 104 */
		/* 8206B470h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206B4D8;  }
		/* 8206B470h case    1:*/		return 0x8206B474;
		  /* 8206B474h */ case    2:  		/* lwz R11, <#[R27 + 108]> */
		/* 8206B474h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000006C) );
		/* 8206B474h case    2:*/		return 0x8206B478;
		  /* 8206B478h */ case    3:  		/* lwz R8, <#[R27 + 112]> */
		/* 8206B478h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000070) );
		/* 8206B478h case    3:*/		return 0x8206B47C;
		  /* 8206B47Ch */ case    4:  		/* rlwinm R9, R11, 0, 0, 31 */
		/* 8206B47Ch case    4:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R11);
		/* 8206B47Ch case    4:*/		return 0x8206B480;
		  /* 8206B480h */ case    5:  		/* rlwinm R8, R8, 3, 0, 28 */
		/* 8206B480h case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R8,regs.R8);
		/* 8206B480h case    5:*/		return 0x8206B484;
		  /* 8206B484h */ case    6:  		/* subf R7, R11, R25 */
		/* 8206B484h case    6:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R11,regs.R25);
		/* 8206B484h case    6:*/		return 0x8206B488;
		  /* 8206B488h */ case    7:  		/* add R9, R8, R9 */
		/* 8206B488h case    7:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8206B488h case    7:*/		return 0x8206B48C;
		  /* 8206B48Ch */ case    8:  		/* srawi R8, R7, 3 */
		/* 8206B48Ch case    8:*/		cpu::op::srawi<0,3>(regs,&regs.R8,regs.R7);
		/* 8206B48Ch case    8:*/		return 0x8206B490;
		  /* 8206B490h */ case    9:  		/* b 64 */
		/* 8206B490h case    9:*/		return 0x8206B4D0;
		/* 8206B490h case    9:*/		return 0x8206B494;
		  /* 8206B494h */ case   10:  		/* rlwinm. R7, R10, 0, 24, 31 */
		/* 8206B494h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R7,regs.R10);
		/* 8206B494h case   10:*/		return 0x8206B498;
		  /* 8206B498h */ case   11:  		/* bc 12, CR0_EQ, 64 */
		/* 8206B498h case   11:*/		if ( regs.CR[0].eq ) { return 0x8206B4D8;  }
		/* 8206B498h case   11:*/		return 0x8206B49C;
		  /* 8206B49Ch */ case   12:  		/* lwz R7, <#[R11 + 4]> */
		/* 8206B49Ch case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8206B49Ch case   12:*/		return 0x8206B4A0;
		  /* 8206B4A0h */ case   13:  		/* rlwinm R7, R7, 20, 28, 31 */
		/* 8206B4A0h case   13:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R7,regs.R7);
		/* 8206B4A0h case   13:*/		return 0x8206B4A4;
		  /* 8206B4A4h */ case   14:  		/* slw R7, R18, R7 */
		/* 8206B4A4h case   14:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R18,regs.R7);
		/* 8206B4A4h case   14:*/		return 0x8206B4A8;
		  /* 8206B4A8h */ case   15:  		/* andi. R7, R7, 2944 */
		/* 8206B4A8h case   15:*/		cpu::op::andi<1>(regs,&regs.R7,regs.R7,0xB80);
		/* 8206B4A8h case   15:*/		return 0x8206B4AC;
		  /* 8206B4ACh */ case   16:  		/* cmplwi CR0, R7, 0 */
		/* 8206B4ACh case   16:*/		cpu::op::cmplwi<0>(regs,regs.R7,0x00000000);
		/* 8206B4ACh case   16:*/		return 0x8206B4B0;
	}
	return 0x8206B4B0;
} // Block from 8206B46Ch-8206B4B0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8206B4B0h
// Function 'XMicrocodeBuilder_AddTFetch'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B4B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B4B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B4B0);
		  /* 8206B4B0h */ case    0:  		/* bc 12, CR0_EQ, 28 */
		/* 8206B4B0h case    0:*/		if ( regs.CR[0].eq ) { return 0x8206B4CC;  }
		/* 8206B4B0h case    0:*/		return 0x8206B4B4;
		  /* 8206B4B4h */ case    1:  		/* lwz R7, <#[R11]> */
		/* 8206B4B4h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8206B4B4h case    1:*/		return 0x8206B4B8;
		  /* 8206B4B8h */ case    2:  		/* rlwinm R7, R7, 0, 19, 31 */
		/* 8206B4B8h case    2:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R7,regs.R7);
		/* 8206B4B8h case    2:*/		return 0x8206B4BC;
		  /* 8206B4BCh */ case    3:  		/* subf R7, R7, R8 */
		/* 8206B4BCh case    3:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R7,regs.R8);
		/* 8206B4BCh case    3:*/		return 0x8206B4C0;
		  /* 8206B4C0h */ case    4:  		/* subfic R7, R7, 0 */
		/* 8206B4C0h case    4:*/		cpu::op::subfic<0>(regs,&regs.R7,regs.R7,0x0);
		/* 8206B4C0h case    4:*/		return 0x8206B4C4;
		  /* 8206B4C4h */ case    5:  		/* subfe R7, R7, R7 */
		/* 8206B4C4h case    5:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R7,regs.R7);
		/* 8206B4C4h case    5:*/		return 0x8206B4C8;
		  /* 8206B4C8h */ case    6:  		/* and R10, R7, R10 */
		/* 8206B4C8h case    6:*/		cpu::op::and<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 8206B4C8h case    6:*/		return 0x8206B4CC;
	}
	return 0x8206B4CC;
} // Block from 8206B4B0h-8206B4CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206B4CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B4CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B4CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B4CC);
		  /* 8206B4CCh */ case    0:  		/* addi R11, R11, 8 */
		/* 8206B4CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8206B4CCh case    0:*/		return 0x8206B4D0;
	}
	return 0x8206B4D0;
} // Block from 8206B4CCh-8206B4D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B4D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B4D0);
		  /* 8206B4D0h */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 8206B4D0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8206B4D0h case    0:*/		return 0x8206B4D4;
		  /* 8206B4D4h */ case    1:  		/* bc 12, CR6_LT, -64 */
		/* 8206B4D4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8206B494;  }
		/* 8206B4D4h case    1:*/		return 0x8206B4D8;
	}
	return 0x8206B4D8;
} // Block from 8206B4D0h-8206B4D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206B4D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B4D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B4D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B4D8);
		  /* 8206B4D8h */ case    0:  		/* rlwinm. R11, R20, 0, 24, 31 */
		/* 8206B4D8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R20);
		/* 8206B4D8h case    0:*/		return 0x8206B4DC;
		  /* 8206B4DCh */ case    1:  		/* bc 4, CR0_EQ, 40 */
		/* 8206B4DCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8206B504;  }
		/* 8206B4DCh case    1:*/		return 0x8206B4E0;
		  /* 8206B4E0h */ case    2:  		/* cmplwi CR6, R22, 0 */
		/* 8206B4E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8206B4E0h case    2:*/		return 0x8206B4E4;
		  /* 8206B4E4h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 8206B4E4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206B51C;  }
		/* 8206B4E4h case    3:*/		return 0x8206B4E8;
		  /* 8206B4E8h */ case    4:  		/* rlwinm. R11, R10, 0, 24, 31 */
		/* 8206B4E8h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R10);
		/* 8206B4E8h case    4:*/		return 0x8206B4EC;
		  /* 8206B4ECh */ case    5:  		/* bc 12, CR0_EQ, 48 */
		/* 8206B4ECh case    5:*/		if ( regs.CR[0].eq ) { return 0x8206B51C;  }
		/* 8206B4ECh case    5:*/		return 0x8206B4F0;
		  /* 8206B4F0h */ case    6:  		/* lwz R11, <#[R26 - 4]> */
		/* 8206B4F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFFFFFC) );
		/* 8206B4F0h case    6:*/		return 0x8206B4F4;
		  /* 8206B4F4h */ case    7:  		/* mr R20, R18 */
		/* 8206B4F4h case    7:*/		regs.R20 = regs.R18;
		/* 8206B4F4h case    7:*/		return 0x8206B4F8;
		  /* 8206B4F8h */ case    8:  		/* rlwimi R11, R18, 20, 10, 11 */
		/* 8206B4F8h case    8:*/		cpu::op::rlwimi<0,20,10,11>(regs,&regs.R11,regs.R18);
		/* 8206B4F8h case    8:*/		return 0x8206B4FC;
		  /* 8206B4FCh */ case    9:  		/* stw R11, <#[R26 - 4]> */
		/* 8206B4FCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0xFFFFFFFC) );
		/* 8206B4FCh case    9:*/		return 0x8206B500;
		  /* 8206B500h */ case   10:  		/* b 28 */
		/* 8206B500h case   10:*/		return 0x8206B51C;
		/* 8206B500h case   10:*/		return 0x8206B504;
	}
	return 0x8206B504;
} // Block from 8206B4D8h-8206B504h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206B504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B504);
		  /* 8206B504h */ case    0:  		/* rlwinm. R11, R10, 0, 24, 31 */
		/* 8206B504h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R10);
		/* 8206B504h case    0:*/		return 0x8206B508;
	}
	return 0x8206B508;
} // Block from 8206B504h-8206B508h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B508h
// Function 'XMicrocodeBuilder_AddVFetch'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B508);
		  /* 8206B508h */ case    0:  		/* bc 4, CR0_EQ, 20 */
		/* 8206B508h case    0:*/		if ( !regs.CR[0].eq ) { return 0x8206B51C;  }
		/* 8206B508h case    0:*/		return 0x8206B50C;
		  /* 8206B50Ch */ case    1:  		/* addi R4, R26, -4 */
		/* 8206B50Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0xFFFFFFFC);
		/* 8206B50Ch case    1:*/		return 0x8206B510;
		  /* 8206B510h */ case    2:  		/* mr R3, R27 */
		/* 8206B510h case    2:*/		regs.R3 = regs.R27;
		/* 8206B510h case    2:*/		return 0x8206B514;
		  /* 8206B514h */ case    3:  		/* bl -5108 */
		/* 8206B514h case    3:*/		regs.LR = 0x8206B518; return 0x8206A120;
		/* 8206B514h case    3:*/		return 0x8206B518;
		  /* 8206B518h */ case    4:  		/* li R20, 0 */
		/* 8206B518h case    4:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 8206B518h case    4:*/		return 0x8206B51C;
	}
	return 0x8206B51C;
} // Block from 8206B508h-8206B51Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206B51Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B51C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B51C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B51C);
		  /* 8206B51Ch */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 8206B51Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8206B51Ch case    0:*/		return 0x8206B520;
		  /* 8206B520h */ case    1:  		/* mr R28, R26 */
		/* 8206B520h case    1:*/		regs.R28 = regs.R26;
		/* 8206B520h case    1:*/		return 0x8206B524;
		  /* 8206B524h */ case    2:  		/* lwz R10, <#[R23]> */
		/* 8206B524h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000000) );
		/* 8206B524h case    2:*/		return 0x8206B528;
		  /* 8206B528h */ case    3:  		/* addi R26, R26, 4 */
		/* 8206B528h case    3:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8206B528h case    3:*/		return 0x8206B52C;
		  /* 8206B52Ch */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206B52Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206B52Ch case    4:*/		return 0x8206B530;
		  /* 8206B530h */ case    5:  		/* mr R22, R25 */
		/* 8206B530h case    5:*/		regs.R22 = regs.R25;
		/* 8206B530h case    5:*/		return 0x8206B534;
		  /* 8206B534h */ case    6:  		/* add R11, R11, R10 */
		/* 8206B534h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206B534h case    6:*/		return 0x8206B538;
		  /* 8206B538h */ case    7:  		/* mr R29, R21 */
		/* 8206B538h case    7:*/		regs.R29 = regs.R21;
		/* 8206B538h case    7:*/		return 0x8206B53C;
	}
	return 0x8206B53C;
} // Block from 8206B51Ch-8206B53Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206B53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B53C);
		  /* 8206B53Ch */ case    0:  		/* cmplw CR6, R26, R11 */
		/* 8206B53Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 8206B53Ch case    0:*/		return 0x8206B540;
		  /* 8206B540h */ case    1:  		/* bc 12, CR6_LT, -816 */
		/* 8206B540h case    1:*/		if ( regs.CR[6].lt ) { return 0x8206B210;  }
		/* 8206B540h case    1:*/		return 0x8206B544;
		  /* 8206B544h */ case    2:  		/* rlwinm. R10, R20, 0, 24, 31 */
		/* 8206B544h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R20);
		/* 8206B544h case    2:*/		return 0x8206B548;
		  /* 8206B548h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8206B548h case    3:*/		if ( regs.CR[0].eq ) { return 0x8206B558;  }
		/* 8206B548h case    3:*/		return 0x8206B54C;
		  /* 8206B54Ch */ case    4:  		/* addi R4, R11, -4 */
		/* 8206B54Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 8206B54Ch case    4:*/		return 0x8206B550;
		  /* 8206B550h */ case    5:  		/* mr R3, R27 */
		/* 8206B550h case    5:*/		regs.R3 = regs.R27;
		/* 8206B550h case    5:*/		return 0x8206B554;
		  /* 8206B554h */ case    6:  		/* bl -5172 */
		/* 8206B554h case    6:*/		regs.LR = 0x8206B558; return 0x8206A120;
		/* 8206B554h case    6:*/		return 0x8206B558;
	}
	return 0x8206B558;
} // Block from 8206B53Ch-8206B558h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206B558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B558);
		  /* 8206B558h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 8206B558h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8206B558h case    0:*/		return 0x8206B55C;
		  /* 8206B55Ch */ case    1:  		/* lwz R11, <#[R11 + 19896]> */
		/* 8206B55Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB8) );
		/* 8206B55Ch case    1:*/		return 0x8206B560;
		  /* 8206B560h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8206B560h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206B560h case    2:*/		return 0x8206B564;
		  /* 8206B564h */ case    3:  		/* bc 12, CR6_EQ, 276 */
		/* 8206B564h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206B678;  }
		/* 8206B564h case    3:*/		return 0x8206B568;
	}
	return 0x8206B568;
} // Block from 8206B558h-8206B568h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206B568h
// Function 'XMicrocodeBuilder_AddVFetchWithSemantic'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B568);
		  /* 8206B568h */ case    0:  		/* lwz R31, <#[R19]> */
		/* 8206B568h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R19 + 0x00000000) );
		/* 8206B568h case    0:*/		return 0x8206B56C;
		  /* 8206B56Ch */ case    1:  		/* b 48 */
		/* 8206B56Ch case    1:*/		return 0x8206B59C;
		/* 8206B56Ch case    1:*/		return 0x8206B570;
		  /* 8206B570h */ case    2:  		/* lwz R11, <#[R27]> */
		/* 8206B570h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8206B570h case    2:*/		return 0x8206B574;
		  /* 8206B574h */ case    3:  		/* lwz R10, <#[R31]> */
		/* 8206B574h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8206B574h case    3:*/		return 0x8206B578;
		  /* 8206B578h */ case    4:  		/* rlwinm R6, R10, 20, 28, 31 */
		/* 8206B578h case    4:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R6,regs.R10);
		/* 8206B578h case    4:*/		return 0x8206B57C;
		  /* 8206B57Ch */ case    5:  		/* rlwinm R5, R10, 0, 24, 31 */
		/* 8206B57Ch case    5:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R5,regs.R10);
		/* 8206B57Ch case    5:*/		return 0x8206B580;
	}
	return 0x8206B580;
} // Block from 8206B568h-8206B580h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206B580h
// Function 'XMicrocodeBuilder_AddALU'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B580);
		  /* 8206B580h */ case    0:  		/* lwz R3, <#[R11 + 19896]> */
		/* 8206B580h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00004DB8) );
		/* 8206B580h case    0:*/		return 0x8206B584;
		  /* 8206B584h */ case    1:  		/* rlwinm R4, R10, 24, 28, 31 */
		/* 8206B584h case    1:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R4,regs.R10);
		/* 8206B584h case    1:*/		return 0x8206B588;
		  /* 8206B588h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8206B588h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206B588h case    2:*/		return 0x8206B58C;
		  /* 8206B58Ch */ case    3:  		/* lwz R11, <#[R11 + 24]> */
		/* 8206B58Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8206B58Ch case    3:*/		return 0x8206B590;
		  /* 8206B590h */ case    4:  		/* mtspr CTR, R11 */
		/* 8206B590h case    4:*/		regs.CTR = regs.R11;
		/* 8206B590h case    4:*/		return 0x8206B594;
		  /* 8206B594h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 8206B594h case    5:*/		if ( 1 ) { regs.LR = 0x8206B598; return (uint32)regs.CTR; }
		/* 8206B594h case    5:*/		return 0x8206B598;
	}
	return 0x8206B598;
} // Block from 8206B580h-8206B598h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206B598h
// Function 'XMicrocodeBuilder_AddFlow'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B598);
		  /* 8206B598h */ case    0:  		/* addi R31, R31, 4 */
		/* 8206B598h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8206B598h case    0:*/		return 0x8206B59C;
	}
	return 0x8206B59C;
} // Block from 8206B598h-8206B59Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B59Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B59C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B59C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B59C);
		  /* 8206B59Ch */ case    0:  		/* lwz R11, <#[R19 + 4]> */
		/* 8206B59Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8206B59Ch case    0:*/		return 0x8206B5A0;
	}
	return 0x8206B5A0;
} // Block from 8206B59Ch-8206B5A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B5A0h
// Function 'XMicrocodeBuilder_AddDebuggerHint'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B5A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B5A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B5A0);
		  /* 8206B5A0h */ case    0:  		/* lwz R10, <#[R19]> */
		/* 8206B5A0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000000) );
		/* 8206B5A0h case    0:*/		return 0x8206B5A4;
		  /* 8206B5A4h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206B5A4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206B5A4h case    1:*/		return 0x8206B5A8;
		  /* 8206B5A8h */ case    2:  		/* add R11, R11, R10 */
		/* 8206B5A8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206B5A8h case    2:*/		return 0x8206B5AC;
		  /* 8206B5ACh */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 8206B5ACh case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8206B5ACh case    3:*/		return 0x8206B5B0;
		  /* 8206B5B0h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 8206B5B0h case    4:*/		if ( regs.CR[6].lt ) { return 0x8206B570;  }
		/* 8206B5B0h case    4:*/		return 0x8206B5B4;
		  /* 8206B5B4h */ case    5:  		/* lwz R31, <#[R23]> */
		/* 8206B5B4h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R23 + 0x00000000) );
		/* 8206B5B4h case    5:*/		return 0x8206B5B8;
		  /* 8206B5B8h */ case    6:  		/* b 168 */
		/* 8206B5B8h case    6:*/		return 0x8206B660;
		/* 8206B5B8h case    6:*/		return 0x8206B5BC;
		  /* 8206B5BCh */ case    7:  		/* lwz R11, <#[R27 + 260]> */
		/* 8206B5BCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000104) );
		/* 8206B5BCh case    7:*/		return 0x8206B5C0;
		  /* 8206B5C0h */ case    8:  		/* li R10, 12 */
		/* 8206B5C0h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0xC);
		/* 8206B5C0h case    8:*/		return 0x8206B5C4;
		  /* 8206B5C4h */ case    9:  		/* lwz R9, <#[R27 + 256]> */
		/* 8206B5C4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000100) );
		/* 8206B5C4h case    9:*/		return 0x8206B5C8;
		  /* 8206B5C8h */ case   10:  		/* addi R5, R1, 80 */
		/* 8206B5C8h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8206B5C8h case   10:*/		return 0x8206B5CC;
		  /* 8206B5CCh */ case   11:  		/* lwz R8, <#[R31]> */
		/* 8206B5CCh case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8206B5CCh case   11:*/		return 0x8206B5D0;
		  /* 8206B5D0h */ case   12:  		/* mr R3, R27 */
		/* 8206B5D0h case   12:*/		regs.R3 = regs.R27;
		/* 8206B5D0h case   12:*/		return 0x8206B5D4;
		  /* 8206B5D4h */ case   13:  		/* subf R9, R9, R11 */
		/* 8206B5D4h case   13:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8206B5D4h case   13:*/		return 0x8206B5D8;
		  /* 8206B5D8h */ case   14:  		/* rlwinm R11, R8, 0, 20, 31 */
		/* 8206B5D8h case   14:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R8);
		/* 8206B5D8h case   14:*/		return 0x8206B5DC;
		  /* 8206B5DCh */ case   15:  		/* divw R30, R9, R10 */
		/* 8206B5DCh case   15:*/		cpu::op::divw<0>(regs,&regs.R30,regs.R9,regs.R10);
		/* 8206B5DCh case   15:*/		return 0x8206B5E0;
		  /* 8206B5E0h */ case   16:  		/* add R4, R11, R30 */
		/* 8206B5E0h case   16:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 8206B5E0h case   16:*/		return 0x8206B5E4;
		  /* 8206B5E4h */ case   17:  		/* bl -7364 */
		/* 8206B5E4h case   17:*/		regs.LR = 0x8206B5E8; return 0x82069920;
		/* 8206B5E4h case   17:*/		return 0x8206B5E8;
		  /* 8206B5E8h */ case   18:  		/* lwz R6, <#[R3 + 4]> */
		/* 8206B5E8h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000004) );
		/* 8206B5E8h case   18:*/		return 0x8206B5EC;
		  /* 8206B5ECh */ case   19:  		/* lwz R11, <#[R31]> */
		/* 8206B5ECh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206B5ECh case   19:*/		return 0x8206B5F0;
		  /* 8206B5F0h */ case   20:  		/* rlwinm R8, R6, 0, 23, 25 */
		/* 8206B5F0h case   20:*/		cpu::op::rlwinm<0,0,23,25>(regs,&regs.R8,regs.R6);
		/* 8206B5F0h case   20:*/		return 0x8206B5F4;
		  /* 8206B5F4h */ case   21:  		/* rlwinm R9, R6, 0, 20, 22 */
		/* 8206B5F4h case   21:*/		cpu::op::rlwinm<0,0,20,22>(regs,&regs.R9,regs.R6);
		/* 8206B5F4h case   21:*/		return 0x8206B5F8;
		  /* 8206B5F8h */ case   22:  		/* rlwinm R7, R6, 0, 26, 28 */
		/* 8206B5F8h case   22:*/		cpu::op::rlwinm<0,0,26,28>(regs,&regs.R7,regs.R6);
		/* 8206B5F8h case   22:*/		return 0x8206B5FC;
		  /* 8206B5FCh */ case   23:  		/* add R9, R9, R8 */
		/* 8206B5FCh case   23:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8206B5FCh case   23:*/		return 0x8206B600;
		  /* 8206B600h */ case   24:  		/* rlwinm R10, R11, 12, 30, 31 */
		/* 8206B600h case   24:*/		cpu::op::rlwinm<0,12,30,31>(regs,&regs.R10,regs.R11);
		/* 8206B600h case   24:*/		return 0x8206B604;
		  /* 8206B604h */ case   25:  		/* rlwinm R8, R6, 0, 29, 31 */
		/* 8206B604h case   25:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R8,regs.R6);
		/* 8206B604h case   25:*/		return 0x8206B608;
		  /* 8206B608h */ case   26:  		/* add R9, R9, R7 */
		/* 8206B608h case   26:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8206B608h case   26:*/		return 0x8206B60C;
		  /* 8206B60Ch */ case   27:  		/* cmplwi CR6, R10, 2 */
		/* 8206B60Ch case   27:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 8206B60Ch case   27:*/		return 0x8206B610;
		  /* 8206B610h */ case   28:  		/* add R6, R9, R8 */
		/* 8206B610h case   28:*/		cpu::op::add<0>(regs,&regs.R6,regs.R9,regs.R8);
		/* 8206B610h case   28:*/		return 0x8206B614;
		  /* 8206B614h */ case   29:  		/* bc 12, CR6_EQ, 16 */
		/* 8206B614h case   29:*/		if ( regs.CR[6].eq ) { return 0x8206B624;  }
		/* 8206B614h case   29:*/		return 0x8206B618;
		  /* 8206B618h */ case   30:  		/* cmplwi CR6, R10, 3 */
		/* 8206B618h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 8206B618h case   30:*/		return 0x8206B61C;
		  /* 8206B61Ch */ case   31:  		/* li R8, 0 */
		/* 8206B61Ch case   31:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8206B61Ch case   31:*/		return 0x8206B620;
		  /* 8206B620h */ case   32:  		/* bc 4, CR6_EQ, 8 */
		/* 8206B620h case   32:*/		if ( !regs.CR[6].eq ) { return 0x8206B628;  }
		/* 8206B620h case   32:*/		return 0x8206B624;
	}
	return 0x8206B624;
} // Block from 8206B5A0h-8206B624h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8206B624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B624);
		  /* 8206B624h */ case    0:  		/* mr R8, R18 */
		/* 8206B624h case    0:*/		regs.R8 = regs.R18;
		/* 8206B624h case    0:*/		return 0x8206B628;
	}
	return 0x8206B628;
} // Block from 8206B624h-8206B628h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B628);
		  /* 8206B628h */ case    0:  		/* lwz R5, <#[R27]> */
		/* 8206B628h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x00000000) );
		/* 8206B628h case    0:*/		return 0x8206B62C;
		  /* 8206B62Ch */ case    1:  		/* rlwinm R10, R11, 24, 24, 27 */
		/* 8206B62Ch case    1:*/		cpu::op::rlwinm<0,24,24,27>(regs,&regs.R10,regs.R11);
		/* 8206B62Ch case    1:*/		return 0x8206B630;
		  /* 8206B630h */ case    2:  		/* lwz R4, <#[R3]> */
		/* 8206B630h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 8206B630h case    2:*/		return 0x8206B634;
		  /* 8206B634h */ case    3:  		/* rlwinm R9, R11, 16, 28, 31 */
		/* 8206B634h case    3:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R9,regs.R11);
		/* 8206B634h case    3:*/		return 0x8206B638;
		  /* 8206B638h */ case    4:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 8206B638h case    4:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 8206B638h case    4:*/		return 0x8206B63C;
		  /* 8206B63Ch */ case    5:  		/* add R7, R10, R9 */
		/* 8206B63Ch case    5:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R9);
		/* 8206B63Ch case    5:*/		return 0x8206B640;
		  /* 8206B640h */ case    6:  		/* lwz R3, <#[R5 + 19896]> */
		/* 8206B640h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R5 + 0x00004DB8) );
		/* 8206B640h case    6:*/		return 0x8206B644;
		  /* 8206B644h */ case    7:  		/* rlwinm R5, R4, 20, 26, 31 */
		/* 8206B644h case    7:*/		cpu::op::rlwinm<0,20,26,31>(regs,&regs.R5,regs.R4);
		/* 8206B644h case    7:*/		return 0x8206B648;
		  /* 8206B648h */ case    8:  		/* add R4, R11, R30 */
		/* 8206B648h case    8:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R30);
		/* 8206B648h case    8:*/		return 0x8206B64C;
		  /* 8206B64Ch */ case    9:  		/* lwz R11, <#[R3]> */
		/* 8206B64Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206B64Ch case    9:*/		return 0x8206B650;
		  /* 8206B650h */ case   10:  		/* lwz R11, <#[R11 + 20]> */
		/* 8206B650h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8206B650h case   10:*/		return 0x8206B654;
		  /* 8206B654h */ case   11:  		/* mtspr CTR, R11 */
		/* 8206B654h case   11:*/		regs.CTR = regs.R11;
		/* 8206B654h case   11:*/		return 0x8206B658;
		  /* 8206B658h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 8206B658h case   12:*/		if ( 1 ) { regs.LR = 0x8206B65C; return (uint32)regs.CTR; }
		/* 8206B658h case   12:*/		return 0x8206B65C;
		  /* 8206B65Ch */ case   13:  		/* addi R31, R31, 4 */
		/* 8206B65Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8206B65Ch case   13:*/		return 0x8206B660;
	}
	return 0x8206B660;
} // Block from 8206B628h-8206B660h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206B660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B660);
		  /* 8206B660h */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 8206B660h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8206B660h case    0:*/		return 0x8206B664;
		  /* 8206B664h */ case    1:  		/* lwz R10, <#[R23]> */
		/* 8206B664h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000000) );
		/* 8206B664h case    1:*/		return 0x8206B668;
	}
	return 0x8206B668;
} // Block from 8206B660h-8206B668h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206B668h
// Function 'XMicrocodeBuilder_SetSerialize'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B668);
		  /* 8206B668h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206B668h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206B668h case    0:*/		return 0x8206B66C;
		  /* 8206B66Ch */ case    1:  		/* add R11, R11, R10 */
		/* 8206B66Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206B66Ch case    1:*/		return 0x8206B670;
		  /* 8206B670h */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 8206B670h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8206B670h case    2:*/		return 0x8206B674;
		  /* 8206B674h */ case    3:  		/* bc 12, CR6_LT, -184 */
		/* 8206B674h case    3:*/		if ( regs.CR[6].lt ) { return 0x8206B5BC;  }
		/* 8206B674h case    3:*/		return 0x8206B678;
	}
	return 0x8206B678;
} // Block from 8206B668h-8206B678h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206B678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B678);
		  /* 8206B678h */ case    0:  		/* addi R1, R1, 208 */
		/* 8206B678h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 8206B678h case    0:*/		return 0x8206B67C;
		  /* 8206B67Ch */ case    1:  		/* b 154628 */
		/* 8206B67Ch case    1:*/		return 0x82091280;
		/* 8206B67Ch case    1:*/		return 0x8206B680;
	}
	return 0x8206B680;
} // Block from 8206B678h-8206B680h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206B680h
// Function 'XMicrocodeBuilder_GetNextFlowAddress'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B680);
		  /* 8206B680h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8206B680h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206B680h case    0:*/		return 0x8206B684;
		  /* 8206B684h */ case    1:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206B684h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206B684h case    1:*/		return 0x8206B688;
		  /* 8206B688h */ case    2:  		/* nor R11, R11, R11 */
		/* 8206B688h case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206B688h case    2:*/		return 0x8206B68C;
		  /* 8206B68Ch */ case    3:  		/* rlwinm. R11, R11, 28, 31, 31 */
		/* 8206B68Ch case    3:*/		cpu::op::rlwinm<1,28,31,31>(regs,&regs.R11,regs.R11);
		/* 8206B68Ch case    3:*/		return 0x8206B690;
		  /* 8206B690h */ case    4:  		/* bc 12, CR0_EQ, 68 */
		/* 8206B690h case    4:*/		if ( regs.CR[0].eq ) { return 0x8206B6D4;  }
		/* 8206B690h case    4:*/		return 0x8206B694;
		  /* 8206B694h */ case    5:  		/* lwz R10, <#[R3 + 112]> */
		/* 8206B694h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000070) );
		/* 8206B694h case    5:*/		return 0x8206B698;
		  /* 8206B698h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 8206B698h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8206B698h case    6:*/		return 0x8206B69C;
		  /* 8206B69Ch */ case    7:  		/* bc 12, CR6_EQ, 56 */
		/* 8206B69Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8206B6D4;  }
		/* 8206B69Ch case    7:*/		return 0x8206B6A0;
		  /* 8206B6A0h */ case    8:  		/* lwz R11, <#[R3 + 108]> */
		/* 8206B6A0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 8206B6A0h case    8:*/		return 0x8206B6A4;
		  /* 8206B6A4h */ case    9:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 8206B6A4h case    9:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 8206B6A4h case    9:*/		return 0x8206B6A8;
		  /* 8206B6A8h */ case   10:  		/* add R11, R11, R10 */
		/* 8206B6A8h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206B6A8h case   10:*/		return 0x8206B6AC;
		  /* 8206B6ACh */ case   11:  		/* addic. R11, R11, -8 */
		/* 8206B6ACh case   11:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFF8);
		/* 8206B6ACh case   11:*/		return 0x8206B6B0;
		  /* 8206B6B0h */ case   12:  		/* bc 12, CR0_EQ, 36 */
		/* 8206B6B0h case   12:*/		if ( regs.CR[0].eq ) { return 0x8206B6D4;  }
		/* 8206B6B0h case   12:*/		return 0x8206B6B4;
		  /* 8206B6B4h */ case   13:  		/* lwz R10, <#[R11 + 4]> */
		/* 8206B6B4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8206B6B4h case   13:*/		return 0x8206B6B8;
		  /* 8206B6B8h */ case   14:  		/* li R11, 1 */
		/* 8206B6B8h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206B6B8h case   14:*/		return 0x8206B6BC;
		  /* 8206B6BCh */ case   15:  		/* rlwinm R10, R10, 20, 28, 31 */
		/* 8206B6BCh case   15:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R10,regs.R10);
		/* 8206B6BCh case   15:*/		return 0x8206B6C0;
		  /* 8206B6C0h */ case   16:  		/* slw R10, R11, R10 */
		/* 8206B6C0h case   16:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8206B6C0h case   16:*/		return 0x8206B6C4;
		  /* 8206B6C4h */ case   17:  		/* andi. R10, R10, 24702 */
		/* 8206B6C4h case   17:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x607E);
		/* 8206B6C4h case   17:*/		return 0x8206B6C8;
		  /* 8206B6C8h */ case   18:  		/* cmplwi CR0, R10, 0 */
		/* 8206B6C8h case   18:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8206B6C8h case   18:*/		return 0x8206B6CC;
		  /* 8206B6CCh */ case   19:  		/* bc 12, CR0_EQ, 8 */
		/* 8206B6CCh case   19:*/		if ( regs.CR[0].eq ) { return 0x8206B6D4;  }
		/* 8206B6CCh case   19:*/		return 0x8206B6D0;
		  /* 8206B6D0h */ case   20:  		/* stw R11, <#[R3 + 120]> */
		/* 8206B6D0h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000078) );
		/* 8206B6D0h case   20:*/		return 0x8206B6D4;
	}
	return 0x8206B6D4;
} // Block from 8206B680h-8206B6D4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8206B6D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B6D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B6D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B6D4);
		  /* 8206B6D4h */ case    0:  		/* lwz R3, <#[R3 + 112]> */
		/* 8206B6D4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000070) );
		/* 8206B6D4h case    0:*/		return 0x8206B6D8;
		  /* 8206B6D8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206B6D8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206B6D8h case    1:*/		return 0x8206B6DC;
	}
	return 0x8206B6DC;
} // Block from 8206B6D4h-8206B6DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206B6DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B6DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B6DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B6DC);
		  /* 8206B6DCh */ case    0:  		/* nop */
		/* 8206B6DCh case    0:*/		cpu::op::nop();
		/* 8206B6DCh case    0:*/		return 0x8206B6E0;
	}
	return 0x8206B6E0;
} // Block from 8206B6DCh-8206B6E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B6E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B6E0);
		  /* 8206B6E0h */ case    0:  		/* mfspr R12, LR */
		/* 8206B6E0h case    0:*/		regs.R12 = regs.LR;
		/* 8206B6E0h case    0:*/		return 0x8206B6E4;
		  /* 8206B6E4h */ case    1:  		/* bl 154488 */
		/* 8206B6E4h case    1:*/		regs.LR = 0x8206B6E8; return 0x8209125C;
		/* 8206B6E4h case    1:*/		return 0x8206B6E8;
		  /* 8206B6E8h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 8206B6E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 8206B6E8h case    2:*/		return 0x8206B6EC;
		  /* 8206B6ECh */ case    3:  		/* lwz R31, <#[R3 + 308]> */
		/* 8206B6ECh case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000134) );
		/* 8206B6ECh case    3:*/		return 0x8206B6F0;
		  /* 8206B6F0h */ case    4:  		/* mr R30, R3 */
		/* 8206B6F0h case    4:*/		regs.R30 = regs.R3;
		/* 8206B6F0h case    4:*/		return 0x8206B6F4;
		  /* 8206B6F4h */ case    5:  		/* mr R29, R4 */
		/* 8206B6F4h case    5:*/		regs.R29 = regs.R4;
		/* 8206B6F4h case    5:*/		return 0x8206B6F8;
		  /* 8206B6F8h */ case    6:  		/* li R5, 104 */
		/* 8206B6F8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x68);
		/* 8206B6F8h case    6:*/		return 0x8206B6FC;
		  /* 8206B6FCh */ case    7:  		/* li R4, 0 */
		/* 8206B6FCh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206B6FCh case    7:*/		return 0x8206B700;
		  /* 8206B700h */ case    8:  		/* addi R3, R1, 80 */
		/* 8206B700h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8206B700h case    8:*/		return 0x8206B704;
		  /* 8206B704h */ case    9:  		/* bl 154684 */
		/* 8206B704h case    9:*/		regs.LR = 0x8206B708; return 0x82091340;
		/* 8206B704h case    9:*/		return 0x8206B708;
		  /* 8206B708h */ case   10:  		/* li R5, 64 */
		/* 8206B708h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x40);
		/* 8206B708h case   10:*/		return 0x8206B70C;
		  /* 8206B70Ch */ case   11:  		/* li R4, 255 */
		/* 8206B70Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 8206B70Ch case   11:*/		return 0x8206B710;
		  /* 8206B710h */ case   12:  		/* addi R3, R1, 88 */
		/* 8206B710h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 8206B710h case   12:*/		return 0x8206B714;
		  /* 8206B714h */ case   13:  		/* bl 154668 */
		/* 8206B714h case   13:*/		regs.LR = 0x8206B718; return 0x82091340;
		/* 8206B714h case   13:*/		return 0x8206B718;
	}
	return 0x8206B718;
} // Block from 8206B6E0h-8206B718h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206B718h
// Function 'XMicrocodeBuilder_GetNextFlowAddressWithoutSerializing'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B718);
		  /* 8206B718h */ case    0:  		/* stw R31, <#[R1 + 84]> */
		/* 8206B718h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 8206B718h case    0:*/		return 0x8206B71C;
		  /* 8206B71Ch */ case    1:  		/* stw R29, <#[R1 + 80]> */
		/* 8206B71Ch case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 8206B71Ch case    1:*/		return 0x8206B720;
		  /* 8206B720h */ case    2:  		/* li R9, 0 */
		/* 8206B720h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8206B720h case    2:*/		return 0x8206B724;
		  /* 8206B724h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 8206B724h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8206B724h case    3:*/		return 0x8206B728;
		  /* 8206B728h */ case    4:  		/* bc 12, CR6_EQ, 88 */
		/* 8206B728h case    4:*/		if ( regs.CR[6].eq ) { return 0x8206B780;  }
		/* 8206B728h case    4:*/		return 0x8206B72C;
		  /* 8206B72Ch */ case    5:  		/* mr R8, R29 */
		/* 8206B72Ch case    5:*/		regs.R8 = regs.R29;
		/* 8206B72Ch case    5:*/		return 0x8206B730;
		  /* 8206B730h */ case    6:  		/* li R10, 4 */
		/* 8206B730h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 8206B730h case    6:*/		return 0x8206B734;
		  /* 8206B734h */ case    7:  		/* lwz R6, <#[R8]> */
		/* 8206B734h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000000) );
		/* 8206B734h case    7:*/		return 0x8206B738;
		  /* 8206B738h */ case    8:  		/* li R11, 0 */
		/* 8206B738h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206B738h case    8:*/		return 0x8206B73C;
		  /* 8206B73Ch */ case    9:  		/* rlwinm R7, R6, 24, 28, 31 */
		/* 8206B73Ch case    9:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R7,regs.R6);
		/* 8206B73Ch case    9:*/		return 0x8206B740;
		  /* 8206B740h */ case   10:  		/* rlwinm R6, R6, 20, 28, 31 */
		/* 8206B740h case   10:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R6,regs.R6);
		/* 8206B740h case   10:*/		return 0x8206B744;
		  /* 8206B744h */ case   11:  		/* mtspr CTR, R10 */
		/* 8206B744h case   11:*/		regs.CTR = regs.R10;
		/* 8206B744h case   11:*/		return 0x8206B748;
		  /* 8206B748h */ case   12:  		/* li R10, 1 */
		/* 8206B748h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8206B748h case   12:*/		return 0x8206B74C;
		  /* 8206B74Ch */ case   13:  		/* slw R10, R10, R11 */
		/* 8206B74Ch case   13:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8206B74Ch case   13:*/		return 0x8206B750;
		  /* 8206B750h */ case   14:  		/* and. R10, R10, R6 */
		/* 8206B750h case   14:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R6);
		/* 8206B750h case   14:*/		return 0x8206B754;
		  /* 8206B754h */ case   15:  		/* bc 12, CR0_EQ, 20 */
		/* 8206B754h case   15:*/		if ( regs.CR[0].eq ) { return 0x8206B768;  }
		/* 8206B754h case   15:*/		return 0x8206B758;
		  /* 8206B758h */ case   16:  		/* rlwinm R10, R7, 2, 0, 29 */
		/* 8206B758h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 8206B758h case   16:*/		return 0x8206B75C;
		  /* 8206B75Ch */ case   17:  		/* addi R5, R1, 88 */
		/* 8206B75Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 8206B75Ch case   17:*/		return 0x8206B760;
		  /* 8206B760h */ case   18:  		/* add R10, R10, R11 */
		/* 8206B760h case   18:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8206B760h case   18:*/		return 0x8206B764;
		  /* 8206B764h */ case   19:  		/* stbx R9, <#[R10 + R5]> */
		/* 8206B764h case   19:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8206B764h case   19:*/		return 0x8206B768;
	}
	return 0x8206B768;
} // Block from 8206B718h-8206B768h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8206B768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B768);
		  /* 8206B768h */ case    0:  		/* addi R11, R11, 1 */
		/* 8206B768h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206B768h case    0:*/		return 0x8206B76C;
		  /* 8206B76Ch */ case    1:  		/* bc 16, CR0_LT, -36 */
		/* 8206B76Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206B748;  }
		/* 8206B76Ch case    1:*/		return 0x8206B770;
		  /* 8206B770h */ case    2:  		/* addi R9, R9, 1 */
		/* 8206B770h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8206B770h case    2:*/		return 0x8206B774;
		  /* 8206B774h */ case    3:  		/* addi R8, R8, 4 */
		/* 8206B774h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8206B774h case    3:*/		return 0x8206B778;
		  /* 8206B778h */ case    4:  		/* cmplw CR6, R9, R31 */
		/* 8206B778h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 8206B778h case    4:*/		return 0x8206B77C;
		  /* 8206B77Ch */ case    5:  		/* bc 12, CR6_LT, -76 */
		/* 8206B77Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8206B730;  }
		/* 8206B77Ch case    5:*/		return 0x8206B780;
	}
	return 0x8206B780;
} // Block from 8206B768h-8206B780h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206B780h
// Function 'XMicrocodeBuilder_GetNextALUAddress'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B780);
		  /* 8206B780h */ case    0:  		/* lis R11, -32250 */
		/* 8206B780h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8206);
		/* 8206B780h case    0:*/		return 0x8206B784;
		  /* 8206B784h */ case    1:  		/* addi R7, R1, 80 */
		/* 8206B784h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 8206B784h case    1:*/		return 0x8206B788;
		  /* 8206B788h */ case    2:  		/* addi R6, R11, 31880 */
		/* 8206B788h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x7C88);
		/* 8206B788h case    2:*/		return 0x8206B78C;
		  /* 8206B78Ch */ case    3:  		/* li R5, 1 */
		/* 8206B78Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206B78Ch case    3:*/		return 0x8206B790;
		  /* 8206B790h */ case    4:  		/* li R4, 0 */
		/* 8206B790h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206B790h case    4:*/		return 0x8206B794;
		  /* 8206B794h */ case    5:  		/* mr R3, R30 */
		/* 8206B794h case    5:*/		regs.R3 = regs.R30;
		/* 8206B794h case    5:*/		return 0x8206B798;
	}
	return 0x8206B798;
} // Block from 8206B780h-8206B798h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206B798h
// Function 'XMicrocodeBuilder_GetCurrentFlowAddressWithoutSerializing'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B798);
		  /* 8206B798h */ case    0:  		/* bl -6880 */
		/* 8206B798h case    0:*/		regs.LR = 0x8206B79C; return 0x82069CB8;
		/* 8206B798h case    0:*/		return 0x8206B79C;
		  /* 8206B79Ch */ case    1:  		/* li R10, 0 */
		/* 8206B79Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8206B79Ch case    1:*/		return 0x8206B7A0;
		  /* 8206B7A0h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 8206B7A0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8206B7A0h case    2:*/		return 0x8206B7A4;
		  /* 8206B7A4h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 8206B7A4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206B7CC;  }
		/* 8206B7A4h case    3:*/		return 0x8206B7A8;
		  /* 8206B7A8h */ case    4:  		/* addi R9, R1, 150 */
		/* 8206B7A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x96);
		/* 8206B7A8h case    4:*/		return 0x8206B7AC;
		  /* 8206B7ACh */ case    5:  		/* mtspr CTR, R31 */
		/* 8206B7ACh case    5:*/		regs.CTR = regs.R31;
		/* 8206B7ACh case    5:*/		return 0x8206B7B0;
	}
	return 0x8206B7B0;
} // Block from 8206B798h-8206B7B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206B7B0h
// Function 'XMicrocodeBuilder_GetFlow'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B7B0);
		  /* 8206B7B0h */ case    0:  		/* addi R11, R29, -4 */
		/* 8206B7B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFC);
		/* 8206B7B0h case    0:*/		return 0x8206B7B4;
		  /* 8206B7B4h */ case    1:  		/* lwz R7, <#[R11 + 4]> */
		/* 8206B7B4h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 8206B7B4h case    1:*/		return 0x8206B7B8;
		  /* 8206B7B8h */ case    2:  		/* lhzu R8, <#[R9 + 2]> */
		/* 8206B7B8h case    2:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000002) );
		regs.R9 = (uint32)(regs.R9 + 0x00000002);
		/* 8206B7B8h case    2:*/		return 0x8206B7BC;
		  /* 8206B7BCh */ case    3:  		/* rlwimi R7, R10, 16, 4, 15 */
		/* 8206B7BCh case    3:*/		cpu::op::rlwimi<0,16,4,15>(regs,&regs.R7,regs.R10);
		/* 8206B7BCh case    3:*/		return 0x8206B7C0;
		  /* 8206B7C0h */ case    4:  		/* add R10, R8, R10 */
		/* 8206B7C0h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8206B7C0h case    4:*/		return 0x8206B7C4;
		  /* 8206B7C4h */ case    5:  		/* stwu R7, <#[R11 + 4]> */
		/* 8206B7C4h case    5:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206B7C4h case    5:*/		return 0x8206B7C8;
		  /* 8206B7C8h */ case    6:  		/* bc 16, CR0_LT, -20 */
		/* 8206B7C8h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206B7B4;  }
		/* 8206B7C8h case    6:*/		return 0x8206B7CC;
	}
	return 0x8206B7CC;
} // Block from 8206B7B0h-8206B7CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206B7CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B7CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B7CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B7CC);
		  /* 8206B7CCh */ case    0:  		/* addi R1, R1, 224 */
		/* 8206B7CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 8206B7CCh case    0:*/		return 0x8206B7D0;
		  /* 8206B7D0h */ case    1:  		/* b 154332 */
		/* 8206B7D0h case    1:*/		return 0x820912AC;
		/* 8206B7D0h case    1:*/		return 0x8206B7D4;
		  /* 8206B7D4h */ case    2:  		/* nop */
		/* 8206B7D4h case    2:*/		cpu::op::nop();
		/* 8206B7D4h case    2:*/		return 0x8206B7D8;
	}
	return 0x8206B7D8;
} // Block from 8206B7CCh-8206B7D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206B7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B7D8);
		  /* 8206B7D8h */ case    0:  		/* mfspr R12, LR */
		/* 8206B7D8h case    0:*/		regs.R12 = regs.LR;
		/* 8206B7D8h case    0:*/		return 0x8206B7DC;
		  /* 8206B7DCh */ case    1:  		/* bl 154220 */
		/* 8206B7DCh case    1:*/		regs.LR = 0x8206B7E0; return 0x82091248;
		/* 8206B7DCh case    1:*/		return 0x8206B7E0;
	}
	return 0x8206B7E0;
} // Block from 8206B7D8h-8206B7E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206B7E0h
// Function 'XMicrocodeBuilder_GetALU'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B7E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B7E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B7E0);
		  /* 8206B7E0h */ case    0:  		/* stwu R1, <#[R1 - 208]> */
		/* 8206B7E0h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 8206B7E0h case    0:*/		return 0x8206B7E4;
		  /* 8206B7E4h */ case    1:  		/* mr R31, R3 */
		/* 8206B7E4h case    1:*/		regs.R31 = regs.R3;
		/* 8206B7E4h case    1:*/		return 0x8206B7E8;
		  /* 8206B7E8h */ case    2:  		/* lwz R11, <#[R5 + 4]> */
		/* 8206B7E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 8206B7E8h case    2:*/		return 0x8206B7EC;
		  /* 8206B7ECh */ case    3:  		/* lwz R8, <#[R5 + 8]> */
		/* 8206B7ECh case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000008) );
		/* 8206B7ECh case    3:*/		return 0x8206B7F0;
		  /* 8206B7F0h */ case    4:  		/* mr R24, R4 */
		/* 8206B7F0h case    4:*/		regs.R24 = regs.R4;
		/* 8206B7F0h case    4:*/		return 0x8206B7F4;
		  /* 8206B7F4h */ case    5:  		/* addi R11, R11, 31 */
		/* 8206B7F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 8206B7F4h case    5:*/		return 0x8206B7F8;
	}
	return 0x8206B7F8;
} // Block from 8206B7E0h-8206B7F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206B7F8h
// Function 'XMicrocodeBuilder_GetLastExecALUCount'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B7F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B7F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B7F8);
		  /* 8206B7F8h */ case    0:  		/* mr R3, R5 */
		/* 8206B7F8h case    0:*/		regs.R3 = regs.R5;
		/* 8206B7F8h case    0:*/		return 0x8206B7FC;
		  /* 8206B7FCh */ case    1:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 8206B7FCh case    1:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 8206B7FCh case    1:*/		return 0x8206B800;
		  /* 8206B800h */ case    2:  		/* lwz R7, <#[R31 + 112]> */
		/* 8206B800h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000070) );
		/* 8206B800h case    2:*/		return 0x8206B804;
		  /* 8206B804h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 8206B804h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8206B804h case    3:*/		return 0x8206B808;
		  /* 8206B808h */ case    4:  		/* lwz R10, <#[R31 + 100]> */
		/* 8206B808h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000064) );
		/* 8206B808h case    4:*/		return 0x8206B80C;
		  /* 8206B80Ch */ case    5:  		/* addi R9, R7, 1 */
		/* 8206B80Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R7,0x1);
		/* 8206B80Ch case    5:*/		return 0x8206B810;
		  /* 8206B810h */ case    6:  		/* stw R11, <#[R5 + 4]> */
		/* 8206B810h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 8206B810h case    6:*/		return 0x8206B814;
		  /* 8206B814h */ case    7:  		/* rlwinm R26, R9, 31, 1, 31 */
		/* 8206B814h case    7:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R26,regs.R9);
		/* 8206B814h case    7:*/		return 0x8206B818;
		  /* 8206B818h */ case    8:  		/* add R10, R10, R26 */
		/* 8206B818h case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R26);
		/* 8206B818h case    8:*/		return 0x8206B81C;
		  /* 8206B81Ch */ case    9:  		/* addi R10, R10, 1 */
		/* 8206B81Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8206B81Ch case    9:*/		return 0x8206B820;
		  /* 8206B820h */ case   10:  		/* mulli R27, R10, 12 */
		/* 8206B820h case   10:*/		cpu::op::mulli<0>(regs,&regs.R27,regs.R10,0xC);
		/* 8206B820h case   10:*/		return 0x8206B824;
		  /* 8206B824h */ case   11:  		/* bc 4, CR6_EQ, 20 */
		/* 8206B824h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8206B838;  }
		/* 8206B824h case   11:*/		return 0x8206B828;
		  /* 8206B828h */ case   12:  		/* mr R5, R27 */
		/* 8206B828h case   12:*/		regs.R5 = regs.R27;
		/* 8206B828h case   12:*/		return 0x8206B82C;
		  /* 8206B82Ch */ case   13:  		/* li R4, 0 */
		/* 8206B82Ch case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206B82Ch case   13:*/		return 0x8206B830;
		  /* 8206B830h */ case   14:  		/* bl -16784 */
		/* 8206B830h case   14:*/		regs.LR = 0x8206B834; return 0x820676A0;
		/* 8206B830h case   14:*/		return 0x8206B834;
		  /* 8206B834h */ case   15:  		/* b 904 */
		/* 8206B834h case   15:*/		return 0x8206BBBC;
		/* 8206B834h case   15:*/		return 0x8206B838;
	}
	return 0x8206B838;
} // Block from 8206B7F8h-8206B838h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206B838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B838);
		  /* 8206B838h */ case    0:  		/* stw R11, <#[R24]> */
		/* 8206B838h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8206B838h case    0:*/		return 0x8206B83C;
		  /* 8206B83Ch */ case    1:  		/* stw R27, <#[R24 + 4]> */
		/* 8206B83Ch case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R24 + 0x00000004) );
		/* 8206B83Ch case    1:*/		return 0x8206B840;
		  /* 8206B840h */ case    2:  		/* lwz R9, <#[R3]> */
		/* 8206B840h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8206B840h case    2:*/		return 0x8206B844;
		  /* 8206B844h */ case    3:  		/* lwz R8, <#[R3 + 12]> */
		/* 8206B844h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000000C) );
		/* 8206B844h case    3:*/		return 0x8206B848;
		  /* 8206B848h */ case    4:  		/* lwz R10, <#[R3 + 4]> */
		/* 8206B848h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8206B848h case    4:*/		return 0x8206B84C;
		  /* 8206B84Ch */ case    5:  		/* add R11, R10, R27 */
		/* 8206B84Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R27);
		/* 8206B84Ch case    5:*/		return 0x8206B850;
		  /* 8206B850h */ case    6:  		/* add R10, R10, R9 */
		/* 8206B850h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8206B850h case    6:*/		return 0x8206B854;
		  /* 8206B854h */ case    7:  		/* stw R11, <#[R3 + 4]> */
		/* 8206B854h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8206B854h case    7:*/		return 0x8206B858;
		  /* 8206B858h */ case    8:  		/* cmplw CR6, R11, R8 */
		/* 8206B858h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8206B858h case    8:*/		return 0x8206B85C;
		  /* 8206B85Ch */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 8206B85Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x8206B864;  }
		/* 8206B85Ch case    9:*/		return 0x8206B860;
		  /* 8206B860h */ case   10:  		/* stw R11, <#[R3 + 12]> */
		/* 8206B860h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8206B860h case   10:*/		return 0x8206B864;
	}
	return 0x8206B864;
} // Block from 8206B838h-8206B864h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206B864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B864);
		  /* 8206B864h */ case    0:  		/* lwz R8, <#[R3 + 8]> */
		/* 8206B864h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 8206B864h case    0:*/		return 0x8206B868;
		  /* 8206B868h */ case    1:  		/* li R29, 0 */
		/* 8206B868h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8206B868h case    1:*/		return 0x8206B86C;
		  /* 8206B86Ch */ case    2:  		/* lwz R9, <#[R31 + 108]> */
		/* 8206B86Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000006C) );
		/* 8206B86Ch case    2:*/		return 0x8206B870;
	}
	return 0x8206B870;
} // Block from 8206B864h-8206B870h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206B870h
// Function 'XMicrocodeBuilder_Finish'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B870);
		  /* 8206B870h */ case    0:  		/* li R25, 1 */
		/* 8206B870h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8206B870h case    0:*/		return 0x8206B874;
		  /* 8206B874h */ case    1:  		/* subfc R8, R11, R8 */
		/* 8206B874h case    1:*/		cpu::op::subfc<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 8206B874h case    1:*/		return 0x8206B878;
		  /* 8206B878h */ case    2:  		/* mr R5, R29 */
		/* 8206B878h case    2:*/		regs.R5 = regs.R29;
		/* 8206B878h case    2:*/		return 0x8206B87C;
		  /* 8206B87Ch */ case    3:  		/* addze R6, R11 */
		/* 8206B87Ch case    3:*/		cpu::op::addze<0>(regs,&regs.R6,regs.R11);
		/* 8206B87Ch case    3:*/		return 0x8206B880;
		  /* 8206B880h */ case    4:  		/* cmplwi CR6, R7, 0 */
		/* 8206B880h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8206B880h case    4:*/		return 0x8206B884;
		  /* 8206B884h */ case    5:  		/* subf R11, R6, R11 */
		/* 8206B884h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 8206B884h case    5:*/		return 0x8206B888;
		  /* 8206B888h */ case    6:  		/* and R28, R11, R10 */
		/* 8206B888h case    6:*/		cpu::op::and<0>(regs,&regs.R28,regs.R11,regs.R10);
		/* 8206B888h case    6:*/		return 0x8206B88C;
		  /* 8206B88Ch */ case    7:  		/* mr R30, R28 */
		/* 8206B88Ch case    7:*/		regs.R30 = regs.R28;
		/* 8206B88Ch case    7:*/		return 0x8206B890;
		  /* 8206B890h */ case    8:  		/* bc 12, CR6_EQ, 196 */
		/* 8206B890h case    8:*/		if ( regs.CR[6].eq ) { return 0x8206B954;  }
		/* 8206B890h case    8:*/		return 0x8206B894;
		  /* 8206B894h */ case    9:  		/* addi R11, R7, -1 */
		/* 8206B894h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R7,0xFFFFFFFF);
		/* 8206B894h case    9:*/		return 0x8206B898;
		  /* 8206B898h */ case   10:  		/* addi R6, R9, -8 */
		/* 8206B898h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R9,0xFFFFFFF8);
		/* 8206B898h case   10:*/		return 0x8206B89C;
		  /* 8206B89Ch */ case   11:  		/* rlwinm R11, R11, 31, 1, 31 */
		/* 8206B89Ch case   11:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R11,regs.R11);
		/* 8206B89Ch case   11:*/		return 0x8206B8A0;
		  /* 8206B8A0h */ case   12:  		/* addi R11, R11, 1 */
		/* 8206B8A0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206B8A0h case   12:*/		return 0x8206B8A4;
		  /* 8206B8A4h */ case   13:  		/* mtspr CTR, R11 */
		/* 8206B8A4h case   13:*/		regs.CTR = regs.R11;
		/* 8206B8A4h case   13:*/		return 0x8206B8A8;
		  /* 8206B8A8h */ case   14:  		/* ld R11, <#[R6 + 8]> */
		/* 8206B8A8h case   14:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 8206B8A8h case   14:*/		return 0x8206B8AC;
		  /* 8206B8ACh */ case   15:  		/* addi R6, R6, 8 */
		/* 8206B8ACh case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x8);
		/* 8206B8ACh case   15:*/		return 0x8206B8B0;
		  /* 8206B8B0h */ case   16:  		/* std R11, <#[R1 + 80]> */
		/* 8206B8B0h case   16:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206B8B0h case   16:*/		return 0x8206B8B4;
		  /* 8206B8B4h */ case   17:  		/* lwz R8, <#[R1 + 84]> */
		/* 8206B8B4h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 8206B8B4h case   17:*/		return 0x8206B8B8;
		  /* 8206B8B8h */ case   18:  		/* rlwinm R11, R8, 20, 28, 31 */
		/* 8206B8B8h case   18:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R8);
		/* 8206B8B8h case   18:*/		return 0x8206B8BC;
		  /* 8206B8BCh */ case   19:  		/* slw R11, R25, R11 */
		/* 8206B8BCh case   19:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R25,regs.R11);
		/* 8206B8BCh case   19:*/		return 0x8206B8C0;
		  /* 8206B8C0h */ case   20:  		/* andi. R11, R11, 24702 */
		/* 8206B8C0h case   20:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x607E);
		/* 8206B8C0h case   20:*/		return 0x8206B8C4;
		  /* 8206B8C4h */ case   21:  		/* cmplwi CR0, R11, 0 */
		/* 8206B8C4h case   21:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8206B8C4h case   21:*/		return 0x8206B8C8;
	}
	return 0x8206B8C8;
} // Block from 8206B870h-8206B8C8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8206B8C8h
// Function 'XMicrocodeBuilder_GetMicrocodeSize'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B8C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B8C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B8C8);
		  /* 8206B8C8h */ case    0:  		/* bc 12, CR0_EQ, 20 */
		/* 8206B8C8h case    0:*/		if ( regs.CR[0].eq ) { return 0x8206B8DC;  }
		/* 8206B8C8h case    0:*/		return 0x8206B8CC;
		  /* 8206B8CCh */ case    1:  		/* lwz R11, <#[R1 + 80]> */
		/* 8206B8CCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206B8CCh case    1:*/		return 0x8206B8D0;
		  /* 8206B8D0h */ case    2:  		/* add R4, R11, R26 */
		/* 8206B8D0h case    2:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R26);
		/* 8206B8D0h case    2:*/		return 0x8206B8D4;
		  /* 8206B8D4h */ case    3:  		/* rlwimi R4, R11, 0, 0, 19 */
		/* 8206B8D4h case    3:*/		cpu::op::rlwimi<0,0,0,19>(regs,&regs.R4,regs.R11);
		/* 8206B8D4h case    3:*/		return 0x8206B8D8;
		  /* 8206B8D8h */ case    4:  		/* b 8 */
		/* 8206B8D8h case    4:*/		return 0x8206B8E0;
		/* 8206B8D8h case    4:*/		return 0x8206B8DC;
	}
	return 0x8206B8DC;
} // Block from 8206B8C8h-8206B8DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206B8DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B8DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B8DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B8DC);
		  /* 8206B8DCh */ case    0:  		/* lwz R4, <#[R1 + 80]> */
		/* 8206B8DCh case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8206B8DCh case    0:*/		return 0x8206B8E0;
	}
	return 0x8206B8E0;
} // Block from 8206B8DCh-8206B8E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B8E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B8E0);
		  /* 8206B8E0h */ case    0:  		/* addi R11, R5, 1 */
		/* 8206B8E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x1);
		/* 8206B8E0h case    0:*/		return 0x8206B8E4;
		  /* 8206B8E4h */ case    1:  		/* cmplw CR6, R11, R7 */
		/* 8206B8E4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8206B8E4h case    1:*/		return 0x8206B8E8;
		  /* 8206B8E8h */ case    2:  		/* bc 4, CR6_LT, 52 */
		/* 8206B8E8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8206B91C;  }
		/* 8206B8E8h case    2:*/		return 0x8206B8EC;
		  /* 8206B8ECh */ case    3:  		/* ldu R11, <#[R6 + 8]> */
		/* 8206B8ECh case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		regs.R6 = (uint32)(regs.R6 + 0x00000008);
		/* 8206B8ECh case    3:*/		return 0x8206B8F0;
		  /* 8206B8F0h */ case    4:  		/* std R11, <#[R1 + 80]> */
		/* 8206B8F0h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206B8F0h case    4:*/		return 0x8206B8F4;
		  /* 8206B8F4h */ case    5:  		/* lwz R10, <#[R1 + 84]> */
		/* 8206B8F4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8206B8F4h case    5:*/		return 0x8206B8F8;
		  /* 8206B8F8h */ case    6:  		/* rlwinm R11, R10, 20, 28, 31 */
		/* 8206B8F8h case    6:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R10);
		/* 8206B8F8h case    6:*/		return 0x8206B8FC;
		  /* 8206B8FCh */ case    7:  		/* slw R11, R25, R11 */
		/* 8206B8FCh case    7:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R25,regs.R11);
		/* 8206B8FCh case    7:*/		return 0x8206B900;
		  /* 8206B900h */ case    8:  		/* andi. R11, R11, 24702 */
		/* 8206B900h case    8:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x607E);
		/* 8206B900h case    8:*/		return 0x8206B904;
		  /* 8206B904h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 8206B904h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8206B904h case    9:*/		return 0x8206B908;
		  /* 8206B908h */ case   10:  		/* bc 12, CR0_EQ, 32 */
		/* 8206B908h case   10:*/		if ( regs.CR[0].eq ) { return 0x8206B928;  }
		/* 8206B908h case   10:*/		return 0x8206B90C;
		  /* 8206B90Ch */ case   11:  		/* lwz R9, <#[R1 + 80]> */
		/* 8206B90Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8206B90Ch case   11:*/		return 0x8206B910;
		  /* 8206B910h */ case   12:  		/* add R11, R9, R26 */
		/* 8206B910h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R26);
		/* 8206B910h case   12:*/		return 0x8206B914;
		  /* 8206B914h */ case   13:  		/* rlwimi R11, R9, 0, 0, 19 */
		/* 8206B914h case   13:*/		cpu::op::rlwimi<0,0,0,19>(regs,&regs.R11,regs.R9);
		/* 8206B914h case   13:*/		return 0x8206B918;
		  /* 8206B918h */ case   14:  		/* b 20 */
		/* 8206B918h case   14:*/		return 0x8206B92C;
		/* 8206B918h case   14:*/		return 0x8206B91C;
	}
	return 0x8206B91C;
} // Block from 8206B8E0h-8206B91Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206B91Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B91C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B91C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B91C);
		  /* 8206B91Ch */ case    0:  		/* mr R11, R29 */
		/* 8206B91Ch case    0:*/		regs.R11 = regs.R29;
		/* 8206B91Ch case    0:*/		return 0x8206B920;
		  /* 8206B920h */ case    1:  		/* mr R10, R29 */
		/* 8206B920h case    1:*/		regs.R10 = regs.R29;
		/* 8206B920h case    1:*/		return 0x8206B924;
		  /* 8206B924h */ case    2:  		/* b 8 */
		/* 8206B924h case    2:*/		return 0x8206B92C;
		/* 8206B924h case    2:*/		return 0x8206B928;
	}
	return 0x8206B928;
} // Block from 8206B91Ch-8206B928h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206B928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B928);
		  /* 8206B928h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 8206B928h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206B928h case    0:*/		return 0x8206B92C;
	}
	return 0x8206B92C;
} // Block from 8206B928h-8206B92Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B92Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B92C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B92C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B92C);
		  /* 8206B92Ch */ case    0:  		/* rlwinm R9, R11, 16, 16, 31 */
		/* 8206B92Ch case    0:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R9,regs.R11);
		/* 8206B92Ch case    0:*/		return 0x8206B930;
		  /* 8206B930h */ case    1:  		/* stw R4, <#[R30]> */
		/* 8206B930h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 8206B930h case    1:*/		return 0x8206B934;
		  /* 8206B934h */ case    2:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 8206B934h case    2:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 8206B934h case    2:*/		return 0x8206B938;
		  /* 8206B938h */ case    3:  		/* rlwimi R8, R11, 16, 0, 15 */
		/* 8206B938h case    3:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R8,regs.R11);
		/* 8206B938h case    3:*/		return 0x8206B93C;
		  /* 8206B93Ch */ case    4:  		/* or R11, R9, R10 */
		/* 8206B93Ch case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 8206B93Ch case    4:*/		return 0x8206B940;
		  /* 8206B940h */ case    5:  		/* stw R8, <#[R30 + 4]> */
		/* 8206B940h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		/* 8206B940h case    5:*/		return 0x8206B944;
		  /* 8206B944h */ case    6:  		/* addi R5, R5, 2 */
		/* 8206B944h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x2);
		/* 8206B944h case    6:*/		return 0x8206B948;
		  /* 8206B948h */ case    7:  		/* stw R11, <#[R30 + 8]> */
		/* 8206B948h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8206B948h case    7:*/		return 0x8206B94C;
		  /* 8206B94Ch */ case    8:  		/* addi R30, R30, 12 */
		/* 8206B94Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xC);
		/* 8206B94Ch case    8:*/		return 0x8206B950;
		  /* 8206B950h */ case    9:  		/* bc 16, CR0_LT, -168 */
		/* 8206B950h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206B8A8;  }
		/* 8206B950h case    9:*/		return 0x8206B954;
	}
	return 0x8206B954;
} // Block from 8206B92Ch-8206B954h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206B954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B954);
		  /* 8206B954h */ case    0:  		/* lwz R11, <#[R31 + 100]> */
		/* 8206B954h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8206B954h case    0:*/		return 0x8206B958;
	}
	return 0x8206B958;
} // Block from 8206B954h-8206B958h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206B958h
// Function 'XMicrocodeBuilder_GetMicrocode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B958);
		  /* 8206B958h */ case    0:  		/* mr R3, R30 */
		/* 8206B958h case    0:*/		regs.R3 = regs.R30;
		/* 8206B958h case    0:*/		return 0x8206B95C;
		  /* 8206B95Ch */ case    1:  		/* lwz R4, <#[R31 + 96]> */
		/* 8206B95Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000060) );
		/* 8206B95Ch case    1:*/		return 0x8206B960;
		  /* 8206B960h */ case    2:  		/* mulli R5, R11, 12 */
		/* 8206B960h case    2:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R11,0xC);
		/* 8206B960h case    2:*/		return 0x8206B964;
		  /* 8206B964h */ case    3:  		/* bl 155724 */
		/* 8206B964h case    3:*/		regs.LR = 0x8206B968; return 0x820919B0;
		/* 8206B964h case    3:*/		return 0x8206B968;
		  /* 8206B968h */ case    4:  		/* lwz R9, <#[R31 + 340]> */
		/* 8206B968h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000154) );
		/* 8206B968h case    4:*/		return 0x8206B96C;
		  /* 8206B96Ch */ case    5:  		/* stw R28, <#[R31 + 256]> */
		/* 8206B96Ch case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000100) );
		/* 8206B96Ch case    5:*/		return 0x8206B970;
		  /* 8206B970h */ case    6:  		/* stw R30, <#[R31 + 260]> */
		/* 8206B970h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000104) );
		/* 8206B970h case    6:*/		return 0x8206B974;
		  /* 8206B974h */ case    7:  		/* lis R11, -32249 */
		/* 8206B974h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8207);
		/* 8206B974h case    7:*/		return 0x8206B978;
		  /* 8206B978h */ case    8:  		/* li R10, -1 */
		/* 8206B978h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8206B978h case    8:*/		return 0x8206B97C;
		  /* 8206B97Ch */ case    9:  		/* addi R6, R11, -26040 */
		/* 8206B97Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFF9A48);
		/* 8206B97Ch case    9:*/		return 0x8206B980;
		  /* 8206B980h */ case   10:  		/* addi R7, R1, 96 */
		/* 8206B980h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 8206B980h case   10:*/		return 0x8206B984;
		  /* 8206B984h */ case   11:  		/* li R5, 1 */
		/* 8206B984h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206B984h case   11:*/		return 0x8206B988;
		  /* 8206B988h */ case   12:  		/* li R4, 1 */
		/* 8206B988h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8206B988h case   12:*/		return 0x8206B98C;
		  /* 8206B98Ch */ case   13:  		/* mr R3, R31 */
		/* 8206B98Ch case   13:*/		regs.R3 = regs.R31;
		/* 8206B98Ch case   13:*/		return 0x8206B990;
		  /* 8206B990h */ case   14:  		/* lwz R11, <#[R31 + 100]> */
		/* 8206B990h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8206B990h case   14:*/		return 0x8206B994;
		  /* 8206B994h */ case   15:  		/* mulli R11, R11, 12 */
		/* 8206B994h case   15:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8206B994h case   15:*/		return 0x8206B998;
		  /* 8206B998h */ case   16:  		/* add R11, R11, R30 */
		/* 8206B998h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8206B998h case   16:*/		return 0x8206B99C;
		  /* 8206B99Ch */ case   17:  		/* stw R11, <#[R31 + 264]> */
		/* 8206B99Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000108) );
		/* 8206B99Ch case   17:*/		return 0x8206B9A0;
		  /* 8206B9A0h */ case   18:  		/* stw R9, <#[R11]> */
		/* 8206B9A0h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8206B9A0h case   18:*/		return 0x8206B9A4;
		  /* 8206B9A4h */ case   19:  		/* lwz R9, <#[R31 + 344]> */
		/* 8206B9A4h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000158) );
		/* 8206B9A4h case   19:*/		return 0x8206B9A8;
		  /* 8206B9A8h */ case   20:  		/* stw R9, <#[R11 + 4]> */
		/* 8206B9A8h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8206B9A8h case   20:*/		return 0x8206B9AC;
		  /* 8206B9ACh */ case   21:  		/* lwz R9, <#[R31 + 348]> */
		/* 8206B9ACh case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000015C) );
		/* 8206B9ACh case   21:*/		return 0x8206B9B0;
		  /* 8206B9B0h */ case   22:  		/* stw R9, <#[R11 + 8]> */
		/* 8206B9B0h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8206B9B0h case   22:*/		return 0x8206B9B4;
		  /* 8206B9B4h */ case   23:  		/* stw R27, <#[R24 + 4]> */
		/* 8206B9B4h case   23:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R24 + 0x00000004) );
		/* 8206B9B4h case   23:*/		return 0x8206B9B8;
		  /* 8206B9B8h */ case   24:  		/* lwz R11, <#[R31]> */
		/* 8206B9B8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206B9B8h case   24:*/		return 0x8206B9BC;
		  /* 8206B9BCh */ case   25:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206B9BCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206B9BCh case   25:*/		return 0x8206B9C0;
		  /* 8206B9C0h */ case   26:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 8206B9C0h case   26:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8206B9C0h case   26:*/		return 0x8206B9C4;
		  /* 8206B9C4h */ case   27:  		/* stw R29, <#[R1 + 96]> */
		/* 8206B9C4h case   27:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000060) );
		/* 8206B9C4h case   27:*/		return 0x8206B9C8;
		  /* 8206B9C8h */ case   28:  		/* stw R10, <#[R1 + 100]> */
		/* 8206B9C8h case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 8206B9C8h case   28:*/		return 0x8206B9CC;
		  /* 8206B9CCh */ case   29:  		/* stw R11, <#[R1 + 104]> */
		/* 8206B9CCh case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 8206B9CCh case   29:*/		return 0x8206B9D0;
		  /* 8206B9D0h */ case   30:  		/* stw R29, <#[R1 + 108]> */
		/* 8206B9D0h case   30:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206B9D0h case   30:*/		return 0x8206B9D4;
		  /* 8206B9D4h */ case   31:  		/* stw R29, <#[R1 + 112]> */
		/* 8206B9D4h case   31:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000070) );
		/* 8206B9D4h case   31:*/		return 0x8206B9D8;
		  /* 8206B9D8h */ case   32:  		/* stw R29, <#[R1 + 116]> */
		/* 8206B9D8h case   32:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000074) );
		/* 8206B9D8h case   32:*/		return 0x8206B9DC;
		  /* 8206B9DCh */ case   33:  		/* stw R29, <#[R1 + 120]> */
		/* 8206B9DCh case   33:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000078) );
		/* 8206B9DCh case   33:*/		return 0x8206B9E0;
		  /* 8206B9E0h */ case   34:  		/* bl -7464 */
		/* 8206B9E0h case   34:*/		regs.LR = 0x8206B9E4; return 0x82069CB8;
		/* 8206B9E0h case   34:*/		return 0x8206B9E4;
		  /* 8206B9E4h */ case   35:  		/* lwz R11, <#[R1 + 120]> */
		/* 8206B9E4h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 8206B9E4h case   35:*/		return 0x8206B9E8;
		  /* 8206B9E8h */ case   36:  		/* cmpwi CR6, R11, 0 */
		/* 8206B9E8h case   36:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206B9E8h case   36:*/		return 0x8206B9EC;
		  /* 8206B9ECh */ case   37:  		/* bc 12, CR6_EQ, 12 */
		/* 8206B9ECh case   37:*/		if ( regs.CR[6].eq ) { return 0x8206B9F8;  }
		/* 8206B9ECh case   37:*/		return 0x8206B9F0;
		  /* 8206B9F0h */ case   38:  		/* lwz R11, <#[R31]> */
		/* 8206B9F0h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206B9F0h case   38:*/		return 0x8206B9F4;
		  /* 8206B9F4h */ case   39:  		/* stw R25, <#[R11 + 19952]> */
		/* 8206B9F4h case   39:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00004DF0) );
		/* 8206B9F4h case   39:*/		return 0x8206B9F8;
	}
	return 0x8206B9F8;
} // Block from 8206B958h-8206B9F8h (40 instructions)

//////////////////////////////////////////////////////
// Block at 8206B9F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206B9F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206B9F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206B9F8);
		  /* 8206B9F8h */ case    0:  		/* lwz R10, <#[R1 + 96]> */
		/* 8206B9F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 8206B9F8h case    0:*/		return 0x8206B9FC;
		  /* 8206B9FCh */ case    1:  		/* mr R11, R29 */
		/* 8206B9FCh case    1:*/		regs.R11 = regs.R29;
		/* 8206B9FCh case    1:*/		return 0x8206BA00;
		  /* 8206BA00h */ case    2:  		/* stw R10, <#[R24 + 16]> */
		/* 8206BA00h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R24 + 0x00000010) );
		/* 8206BA00h case    2:*/		return 0x8206BA04;
		  /* 8206BA04h */ case    3:  		/* lwz R10, <#[R31]> */
		/* 8206BA04h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8206BA04h case    3:*/		return 0x8206BA08;
		  /* 8206BA08h */ case    4:  		/* lwz R10, <#[R10 + 19892]> */
		/* 8206BA08h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00004DB4) );
		/* 8206BA08h case    4:*/		return 0x8206BA0C;
		  /* 8206BA0Ch */ case    5:  		/* rlwinm. R9, R10, 29, 31, 31 */
		/* 8206BA0Ch case    5:*/		cpu::op::rlwinm<1,29,31,31>(regs,&regs.R9,regs.R10);
		/* 8206BA0Ch case    5:*/		return 0x8206BA10;
		  /* 8206BA10h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 8206BA10h case    6:*/		if ( regs.CR[0].eq ) { return 0x8206BA24;  }
		/* 8206BA10h case    6:*/		return 0x8206BA14;
		  /* 8206BA14h */ case    7:  		/* rlwinm. R11, R10, 30, 31, 31 */
		/* 8206BA14h case    7:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R10);
		/* 8206BA14h case    7:*/		return 0x8206BA18;
		  /* 8206BA18h */ case    8:  		/* lis R11, 2 */
		/* 8206BA18h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0x2);
		/* 8206BA18h case    8:*/		return 0x8206BA1C;
		  /* 8206BA1Ch */ case    9:  		/* bc 4, CR0_EQ, 8 */
		/* 8206BA1Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x8206BA24;  }
		/* 8206BA1Ch case    9:*/		return 0x8206BA20;
		  /* 8206BA20h */ case   10:  		/* lis R11, 4 */
		/* 8206BA20h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0x4);
		/* 8206BA20h case   10:*/		return 0x8206BA24;
	}
	return 0x8206BA24;
} // Block from 8206B9F8h-8206BA24h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206BA24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BA24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BA24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BA24);
		  /* 8206BA24h */ case    0:  		/* rlwinm. R10, R10, 30, 31, 31 */
		/* 8206BA24h case    0:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R10,regs.R10);
		/* 8206BA24h case    0:*/		return 0x8206BA28;
		  /* 8206BA28h */ case    1:  		/* mr R7, R29 */
		/* 8206BA28h case    1:*/		regs.R7 = regs.R29;
		/* 8206BA28h case    1:*/		return 0x8206BA2C;
		  /* 8206BA2Ch */ case    2:  		/* bc 12, CR0_EQ, 128 */
		/* 8206BA2Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8206BAAC;  }
		/* 8206BA2Ch case    2:*/		return 0x8206BA30;
	}
	return 0x8206BA30;
} // Block from 8206BA24h-8206BA30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206BA30h
// Function '?PseudoConstructor@CMicrocodeBuilder@D3D@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BA30);
		  /* 8206BA30h */ case    0:  		/* lwz R10, <#[R31 + 272]> */
		/* 8206BA30h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000110) );
		/* 8206BA30h case    0:*/		return 0x8206BA34;
		  /* 8206BA34h */ case    1:  		/* lwz R9, <#[R31 + 268]> */
		/* 8206BA34h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000010C) );
		/* 8206BA34h case    1:*/		return 0x8206BA38;
		  /* 8206BA38h */ case    2:  		/* rlwimi R11, R10, 5, 22, 26 */
		/* 8206BA38h case    2:*/		cpu::op::rlwimi<0,5,22,26>(regs,&regs.R11,regs.R10);
		/* 8206BA38h case    2:*/		return 0x8206BA3C;
		  /* 8206BA3Ch */ case    3:  		/* rlwinm. R10, R11, 0, 22, 26 */
		/* 8206BA3Ch case    3:*/		cpu::op::rlwinm<1,0,22,26>(regs,&regs.R10,regs.R11);
		/* 8206BA3Ch case    3:*/		return 0x8206BA40;
		  /* 8206BA40h */ case    4:  		/* bc 12, CR0_EQ, 228 */
		/* 8206BA40h case    4:*/		if ( regs.CR[0].eq ) { return 0x8206BB24;  }
		/* 8206BA40h case    4:*/		return 0x8206BA44;
		  /* 8206BA44h */ case    5:  		/* lis R10, -32217 */
		/* 8206BA44h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 8206BA44h case    5:*/		return 0x8206BA48;
		  /* 8206BA48h */ case    6:  		/* addi R6, R10, 1652 */
		/* 8206BA48h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x674);
		/* 8206BA48h case    6:*/		return 0x8206BA4C;
		  /* 8206BA4Ch */ case    7:  		/* lwz R10, <#[R9]> */
		/* 8206BA4Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8206BA4Ch case    7:*/		return 0x8206BA50;
		  /* 8206BA50h */ case    8:  		/* rlwinm R5, R7, 0, 16, 31 */
		/* 8206BA50h case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R5,regs.R7);
		/* 8206BA50h case    8:*/		return 0x8206BA54;
		  /* 8206BA54h */ case    9:  		/* rlwinm R8, R10, 16, 28, 31 */
		/* 8206BA54h case    9:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R8,regs.R10);
		/* 8206BA54h case    9:*/		return 0x8206BA58;
		  /* 8206BA58h */ case   10:  		/* rlwinm R10, R10, 12, 28, 31 */
		/* 8206BA58h case   10:*/		cpu::op::rlwinm<0,12,28,31>(regs,&regs.R10,regs.R10);
		/* 8206BA58h case   10:*/		return 0x8206BA5C;
		  /* 8206BA5Ch */ case   11:  		/* slw R10, R25, R10 */
		/* 8206BA5Ch case   11:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R25,regs.R10);
		/* 8206BA5Ch case   11:*/		return 0x8206BA60;
		  /* 8206BA60h */ case   12:  		/* lbzx R8, <#[R8 + R6]> */
		/* 8206BA60h case   12:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 8206BA60h case   12:*/		return 0x8206BA64;
		  /* 8206BA64h */ case   13:  		/* or R10, R10, R5 */
		/* 8206BA64h case   13:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 8206BA64h case   13:*/		return 0x8206BA68;
		  /* 8206BA68h */ case   14:  		/* rlwinm R8, R8, 10, 0, 31 */
		/* 8206BA68h case   14:*/		cpu::op::rlwinm<0,10,0,31>(regs,&regs.R8,regs.R8);
		/* 8206BA68h case   14:*/		return 0x8206BA6C;
		  /* 8206BA6Ch */ case   15:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 8206BA6Ch case   15:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 8206BA6Ch case   15:*/		return 0x8206BA70;
		  /* 8206BA70h */ case   16:  		/* add R8, R8, R11 */
		/* 8206BA70h case   16:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8206BA70h case   16:*/		return 0x8206BA74;
		  /* 8206BA74h */ case   17:  		/* cmplw CR6, R10, R5 */
		/* 8206BA74h case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R5);
		/* 8206BA74h case   17:*/		return 0x8206BA78;
		  /* 8206BA78h */ case   18:  		/* rlwimi R8, R11, 0, 22, 14 */
		/* 8206BA78h case   18:*/		cpu::op::rlwimi<0,0,22,14>(regs,&regs.R8,regs.R11);
		/* 8206BA78h case   18:*/		return 0x8206BA7C;
		  /* 8206BA7Ch */ case   19:  		/* mr R11, R8 */
		/* 8206BA7Ch case   19:*/		regs.R11 = regs.R8;
		/* 8206BA7Ch case   19:*/		return 0x8206BA80;
		  /* 8206BA80h */ case   20:  		/* bc 12, CR6_EQ, 20 */
		/* 8206BA80h case   20:*/		if ( regs.CR[6].eq ) { return 0x8206BA94;  }
		/* 8206BA80h case   20:*/		return 0x8206BA84;
		  /* 8206BA84h */ case   21:  		/* addi R8, R8, 1 */
		/* 8206BA84h case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8206BA84h case   21:*/		return 0x8206BA88;
		  /* 8206BA88h */ case   22:  		/* mr R7, R10 */
		/* 8206BA88h case   22:*/		regs.R7 = regs.R10;
		/* 8206BA88h case   22:*/		return 0x8206BA8C;
		  /* 8206BA8Ch */ case   23:  		/* rlwimi R8, R11, 0, 0, 26 */
		/* 8206BA8Ch case   23:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R8,regs.R11);
		/* 8206BA8Ch case   23:*/		return 0x8206BA90;
		  /* 8206BA90h */ case   24:  		/* mr R11, R8 */
		/* 8206BA90h case   24:*/		regs.R11 = regs.R8;
		/* 8206BA90h case   24:*/		return 0x8206BA94;
	}
	return 0x8206BA94;
} // Block from 8206BA30h-8206BA94h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8206BA94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BA94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BA94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BA94);
		  /* 8206BA94h */ case    0:  		/* addi R29, R29, 1 */
		/* 8206BA94h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8206BA94h case    0:*/		return 0x8206BA98;
		  /* 8206BA98h */ case    1:  		/* rlwinm R10, R11, 27, 27, 31 */
		/* 8206BA98h case    1:*/		cpu::op::rlwinm<0,27,27,31>(regs,&regs.R10,regs.R11);
		/* 8206BA98h case    1:*/		return 0x8206BA9C;
		  /* 8206BA9Ch */ case    2:  		/* addi R9, R9, 4 */
		/* 8206BA9Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8206BA9Ch case    2:*/		return 0x8206BAA0;
		  /* 8206BAA0h */ case    3:  		/* cmplw CR6, R29, R10 */
		/* 8206BAA0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 8206BAA0h case    3:*/		return 0x8206BAA4;
		  /* 8206BAA4h */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 8206BAA4h case    4:*/		if ( regs.CR[6].lt ) { return 0x8206BA4C;  }
		/* 8206BAA4h case    4:*/		return 0x8206BAA8;
		  /* 8206BAA8h */ case    5:  		/* b 124 */
		/* 8206BAA8h case    5:*/		return 0x8206BB24;
		/* 8206BAA8h case    5:*/		return 0x8206BAAC;
	}
	return 0x8206BAAC;
} // Block from 8206BA94h-8206BAACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206BAACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BAAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BAAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BAAC);
		  /* 8206BAACh */ case    0:  		/* lwz R10, <#[R31 + 308]> */
		/* 8206BAACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000134) );
		/* 8206BAACh case    0:*/		return 0x8206BAB0;
		  /* 8206BAB0h */ case    1:  		/* lwz R9, <#[R31 + 304]> */
		/* 8206BAB0h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000130) );
		/* 8206BAB0h case    1:*/		return 0x8206BAB4;
		  /* 8206BAB4h */ case    2:  		/* rlwimi R11, R10, 5, 22, 26 */
		/* 8206BAB4h case    2:*/		cpu::op::rlwimi<0,5,22,26>(regs,&regs.R11,regs.R10);
		/* 8206BAB4h case    2:*/		return 0x8206BAB8;
		  /* 8206BAB8h */ case    3:  		/* rlwinm. R10, R11, 0, 22, 26 */
		/* 8206BAB8h case    3:*/		cpu::op::rlwinm<1,0,22,26>(regs,&regs.R10,regs.R11);
		/* 8206BAB8h case    3:*/		return 0x8206BABC;
		  /* 8206BABCh */ case    4:  		/* bc 12, CR0_EQ, 104 */
		/* 8206BABCh case    4:*/		if ( regs.CR[0].eq ) { return 0x8206BB24;  }
		/* 8206BABCh case    4:*/		return 0x8206BAC0;
		  /* 8206BAC0h */ case    5:  		/* lis R10, -32217 */
		/* 8206BAC0h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 8206BAC0h case    5:*/		return 0x8206BAC4;
		  /* 8206BAC4h */ case    6:  		/* addi R6, R10, 1652 */
		/* 8206BAC4h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x674);
		/* 8206BAC4h case    6:*/		return 0x8206BAC8;
		  /* 8206BAC8h */ case    7:  		/* lwz R10, <#[R9]> */
		/* 8206BAC8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8206BAC8h case    7:*/		return 0x8206BACC;
		  /* 8206BACCh */ case    8:  		/* rlwinm R5, R7, 0, 16, 31 */
		/* 8206BACCh case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R5,regs.R7);
		/* 8206BACCh case    8:*/		return 0x8206BAD0;
		  /* 8206BAD0h */ case    9:  		/* rlwinm R8, R10, 20, 28, 31 */
		/* 8206BAD0h case    9:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R8,regs.R10);
		/* 8206BAD0h case    9:*/		return 0x8206BAD4;
		  /* 8206BAD4h */ case   10:  		/* rlwinm R10, R10, 24, 28, 31 */
		/* 8206BAD4h case   10:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R10,regs.R10);
		/* 8206BAD4h case   10:*/		return 0x8206BAD8;
		  /* 8206BAD8h */ case   11:  		/* slw R10, R25, R10 */
		/* 8206BAD8h case   11:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R25,regs.R10);
		/* 8206BAD8h case   11:*/		return 0x8206BADC;
		  /* 8206BADCh */ case   12:  		/* lbzx R8, <#[R8 + R6]> */
		/* 8206BADCh case   12:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R8 + regs.R6 + 0x00000000) );
		/* 8206BADCh case   12:*/		return 0x8206BAE0;
		  /* 8206BAE0h */ case   13:  		/* or R10, R10, R5 */
		/* 8206BAE0h case   13:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 8206BAE0h case   13:*/		return 0x8206BAE4;
		  /* 8206BAE4h */ case   14:  		/* rlwinm R8, R8, 10, 0, 31 */
		/* 8206BAE4h case   14:*/		cpu::op::rlwinm<0,10,0,31>(regs,&regs.R8,regs.R8);
		/* 8206BAE4h case   14:*/		return 0x8206BAE8;
	}
	return 0x8206BAE8;
} // Block from 8206BAACh-8206BAE8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206BAE8h
// Function '?Initialize@CMicrocodeBuilder@D3D@@QAAXK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BAE8);
		  /* 8206BAE8h */ case    0:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 8206BAE8h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 8206BAE8h case    0:*/		return 0x8206BAEC;
		  /* 8206BAECh */ case    1:  		/* add R8, R8, R11 */
		/* 8206BAECh case    1:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 8206BAECh case    1:*/		return 0x8206BAF0;
		  /* 8206BAF0h */ case    2:  		/* cmplw CR6, R10, R5 */
		/* 8206BAF0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R5);
		/* 8206BAF0h case    2:*/		return 0x8206BAF4;
		  /* 8206BAF4h */ case    3:  		/* rlwimi R8, R11, 0, 22, 14 */
		/* 8206BAF4h case    3:*/		cpu::op::rlwimi<0,0,22,14>(regs,&regs.R8,regs.R11);
		/* 8206BAF4h case    3:*/		return 0x8206BAF8;
		  /* 8206BAF8h */ case    4:  		/* mr R11, R8 */
		/* 8206BAF8h case    4:*/		regs.R11 = regs.R8;
		/* 8206BAF8h case    4:*/		return 0x8206BAFC;
		  /* 8206BAFCh */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 8206BAFCh case    5:*/		if ( regs.CR[6].eq ) { return 0x8206BB10;  }
		/* 8206BAFCh case    5:*/		return 0x8206BB00;
		  /* 8206BB00h */ case    6:  		/* addi R8, R8, 1 */
		/* 8206BB00h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8206BB00h case    6:*/		return 0x8206BB04;
		  /* 8206BB04h */ case    7:  		/* mr R7, R10 */
		/* 8206BB04h case    7:*/		regs.R7 = regs.R10;
		/* 8206BB04h case    7:*/		return 0x8206BB08;
		  /* 8206BB08h */ case    8:  		/* rlwimi R8, R11, 0, 0, 26 */
		/* 8206BB08h case    8:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R8,regs.R11);
		/* 8206BB08h case    8:*/		return 0x8206BB0C;
		  /* 8206BB0Ch */ case    9:  		/* mr R11, R8 */
		/* 8206BB0Ch case    9:*/		regs.R11 = regs.R8;
		/* 8206BB0Ch case    9:*/		return 0x8206BB10;
	}
	return 0x8206BB10;
} // Block from 8206BAE8h-8206BB10h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206BB10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BB10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BB10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BB10);
		  /* 8206BB10h */ case    0:  		/* addi R29, R29, 1 */
		/* 8206BB10h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8206BB10h case    0:*/		return 0x8206BB14;
		  /* 8206BB14h */ case    1:  		/* rlwinm R10, R11, 27, 27, 31 */
		/* 8206BB14h case    1:*/		cpu::op::rlwinm<0,27,27,31>(regs,&regs.R10,regs.R11);
		/* 8206BB14h case    1:*/		return 0x8206BB18;
		  /* 8206BB18h */ case    2:  		/* addi R9, R9, 4 */
		/* 8206BB18h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8206BB18h case    2:*/		return 0x8206BB1C;
		  /* 8206BB1Ch */ case    3:  		/* cmplw CR6, R29, R10 */
		/* 8206BB1Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 8206BB1Ch case    3:*/		return 0x8206BB20;
		  /* 8206BB20h */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 8206BB20h case    4:*/		if ( regs.CR[6].lt ) { return 0x8206BAC8;  }
		/* 8206BB20h case    4:*/		return 0x8206BB24;
	}
	return 0x8206BB24;
} // Block from 8206BB10h-8206BB24h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206BB24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BB24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BB24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BB24);
		  /* 8206BB24h */ case    0:  		/* stw R11, <#[R24 + 20]> */
		/* 8206BB24h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000014) );
		/* 8206BB24h case    0:*/		return 0x8206BB28;
		  /* 8206BB28h */ case    1:  		/* lwz R11, <#[R31]> */
		/* 8206BB28h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206BB28h case    1:*/		return 0x8206BB2C;
		  /* 8206BB2Ch */ case    2:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206BB2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206BB2Ch case    2:*/		return 0x8206BB30;
		  /* 8206BB30h */ case    3:  		/* rlwinm. R10, R11, 30, 31, 31 */
		/* 8206BB30h case    3:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R10,regs.R11);
		/* 8206BB30h case    3:*/		return 0x8206BB34;
		  /* 8206BB34h */ case    4:  		/* nor R11, R11, R11 */
		/* 8206BB34h case    4:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206BB34h case    4:*/		return 0x8206BB38;
		  /* 8206BB38h */ case    5:  		/* bc 12, CR0_EQ, 60 */
		/* 8206BB38h case    5:*/		if ( regs.CR[0].eq ) { return 0x8206BB74;  }
		/* 8206BB38h case    5:*/		return 0x8206BB3C;
		  /* 8206BB3Ch */ case    6:  		/* rlwinm. R11, R11, 25, 31, 31 */
		/* 8206BB3Ch case    6:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R11,regs.R11);
		/* 8206BB3Ch case    6:*/		return 0x8206BB40;
		  /* 8206BB40h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8206BB40h case    7:*/		if ( regs.CR[0].eq ) { return 0x8206BB4C;  }
		/* 8206BB40h case    7:*/		return 0x8206BB44;
		  /* 8206BB44h */ case    8:  		/* lwz R11, <#[R1 + 112]> */
		/* 8206BB44h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8206BB44h case    8:*/		return 0x8206BB48;
		  /* 8206BB48h */ case    9:  		/* b 12 */
		/* 8206BB48h case    9:*/		return 0x8206BB54;
		/* 8206BB48h case    9:*/		return 0x8206BB4C;
	}
	return 0x8206BB4C;
} // Block from 8206BB24h-8206BB4Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206BB4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BB4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BB4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BB4C);
		  /* 8206BB4Ch */ case    0:  		/* lwz R11, <#[R31 + 88]> */
		/* 8206BB4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8206BB4Ch case    0:*/		return 0x8206BB50;
		  /* 8206BB50h */ case    1:  		/* rlwinm R11, R11, 15, 31, 31 */
		/* 8206BB50h case    1:*/		cpu::op::rlwinm<0,15,31,31>(regs,&regs.R11,regs.R11);
		/* 8206BB50h case    1:*/		return 0x8206BB54;
	}
	return 0x8206BB54;
} // Block from 8206BB4Ch-8206BB54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206BB54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BB54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BB54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BB54);
		  /* 8206BB54h */ case    0:  		/* lwz R10, <#[R31 + 88]> */
		/* 8206BB54h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000058) );
		/* 8206BB54h case    0:*/		return 0x8206BB58;
		  /* 8206BB58h */ case    1:  		/* lwz R9, <#[R31 + 336]> */
		/* 8206BB58h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000150) );
		/* 8206BB58h case    1:*/		return 0x8206BB5C;
		  /* 8206BB5Ch */ case    2:  		/* lwz R8, <#[R31 + 92]> */
		/* 8206BB5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000005C) );
		/* 8206BB5Ch case    2:*/		return 0x8206BB60;
		  /* 8206BB60h */ case    3:  		/* rlwimi R10, R11, 17, 14, 14 */
		/* 8206BB60h case    3:*/		cpu::op::rlwimi<0,17,14,14>(regs,&regs.R10,regs.R11);
		/* 8206BB60h case    3:*/		return 0x8206BB64;
		  /* 8206BB64h */ case    4:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 8206BB64h case    4:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 8206BB64h case    4:*/		return 0x8206BB68;
		  /* 8206BB68h */ case    5:  		/* andis. R10, R10, 30734 */
		/* 8206BB68h case    5:*/		cpu::op::andis<1>(regs,&regs.R10,regs.R10,0x780E);
		/* 8206BB68h case    5:*/		return 0x8206BB6C;
		  /* 8206BB6Ch */ case    6:  		/* andi. R11, R8, 65294 */
		/* 8206BB6Ch case    6:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R8,0xFF0E);
		/* 8206BB6Ch case    6:*/		return 0x8206BB70;
		  /* 8206BB70h */ case    7:  		/* b 68 */
		/* 8206BB70h case    7:*/		return 0x8206BBB4;
		/* 8206BB70h case    7:*/		return 0x8206BB74;
	}
	return 0x8206BB74;
} // Block from 8206BB54h-8206BB74h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206BB74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BB74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BB74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BB74);
		  /* 8206BB74h */ case    0:  		/* rlwinm. R10, R11, 25, 31, 31 */
		/* 8206BB74h case    0:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R10,regs.R11);
		/* 8206BB74h case    0:*/		return 0x8206BB78;
		  /* 8206BB78h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8206BB78h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206BB84;  }
		/* 8206BB78h case    1:*/		return 0x8206BB7C;
		  /* 8206BB7Ch */ case    2:  		/* lwz R11, <#[R1 + 112]> */
		/* 8206BB7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8206BB7Ch case    2:*/		return 0x8206BB80;
		  /* 8206BB80h */ case    3:  		/* b 12 */
		/* 8206BB80h case    3:*/		return 0x8206BB8C;
		/* 8206BB80h case    3:*/		return 0x8206BB84;
	}
	return 0x8206BB84;
} // Block from 8206BB74h-8206BB84h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206BB84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BB84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BB84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BB84);
		  /* 8206BB84h */ case    0:  		/* lhz R11, <#[R31 + 88]> */
		/* 8206BB84h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000058) );
		/* 8206BB84h case    0:*/		return 0x8206BB88;
		  /* 8206BB88h */ case    1:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 8206BB88h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8206BB88h case    1:*/		return 0x8206BB8C;
	}
	return 0x8206BB8C;
} // Block from 8206BB84h-8206BB8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206BB8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BB8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BB8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BB8C);
		  /* 8206BB8Ch */ case    0:  		/* lwz R9, <#[R31 + 88]> */
		/* 8206BB8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000058) );
		/* 8206BB8Ch case    0:*/		return 0x8206BB90;
		  /* 8206BB90h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 8206BB90h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8206BB90h case    1:*/		return 0x8206BB94;
		  /* 8206BB94h */ case    2:  		/* rlwimi R9, R11, 16, 15, 15 */
		/* 8206BB94h case    2:*/		cpu::op::rlwimi<0,16,15,15>(regs,&regs.R9,regs.R11);
		/* 8206BB94h case    2:*/		return 0x8206BB98;
		  /* 8206BB98h */ case    3:  		/* andis. R10, R9, 34801 */
		/* 8206BB98h case    3:*/		cpu::op::andis<1>(regs,&regs.R10,regs.R9,0x87F1);
		/* 8206BB98h case    3:*/		return 0x8206BB9C;
		  /* 8206BB9Ch */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 8206BB9Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8206BBA8;  }
		/* 8206BB9Ch case    4:*/		return 0x8206BBA0;
		  /* 8206BBA0h */ case    5:  		/* lwz R11, <#[R1 + 116]> */
		/* 8206BBA0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 8206BBA0h case    5:*/		return 0x8206BBA4;
		  /* 8206BBA4h */ case    6:  		/* b 12 */
		/* 8206BBA4h case    6:*/		return 0x8206BBB0;
		/* 8206BBA4h case    6:*/		return 0x8206BBA8;
	}
	return 0x8206BBA8;
} // Block from 8206BB8Ch-8206BBA8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206BBA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BBA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BBA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BBA8);
		  /* 8206BBA8h */ case    0:  		/* lwz R11, <#[R31 + 92]> */
		/* 8206BBA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 8206BBA8h case    0:*/		return 0x8206BBAC;
		  /* 8206BBACh */ case    1:  		/* rlwinm R11, R11, 14, 31, 31 */
		/* 8206BBACh case    1:*/		cpu::op::rlwinm<0,14,31,31>(regs,&regs.R11,regs.R11);
		/* 8206BBACh case    1:*/		return 0x8206BBB0;
	}
	return 0x8206BBB0;
} // Block from 8206BBA8h-8206BBB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206BBB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BBB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BBB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BBB0);
		  /* 8206BBB0h */ case    0:  		/* rlwinm R11, R11, 18, 13, 13 */
		/* 8206BBB0h case    0:*/		cpu::op::rlwinm<0,18,13,13>(regs,&regs.R11,regs.R11);
		/* 8206BBB0h case    0:*/		return 0x8206BBB4;
	}
	return 0x8206BBB4;
} // Block from 8206BBB0h-8206BBB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206BBB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BBB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BBB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BBB4);
		  /* 8206BBB4h */ case    0:  		/* stw R10, <#[R24 + 8]> */
		/* 8206BBB4h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R24 + 0x00000008) );
		/* 8206BBB4h case    0:*/		return 0x8206BBB8;
		  /* 8206BBB8h */ case    1:  		/* stw R11, <#[R24 + 12]> */
		/* 8206BBB8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 8206BBB8h case    1:*/		return 0x8206BBBC;
	}
	return 0x8206BBBC;
} // Block from 8206BBB4h-8206BBBCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206BBBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BBBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BBBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BBBC);
		  /* 8206BBBCh */ case    0:  		/* addi R1, R1, 208 */
		/* 8206BBBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 8206BBBCh case    0:*/		return 0x8206BBC0;
		  /* 8206BBC0h */ case    1:  		/* b 153304 */
		/* 8206BBC0h case    1:*/		return 0x82091298;
		/* 8206BBC0h case    1:*/		return 0x8206BBC4;
		  /* 8206BBC4h */ case    2:  		/* nop */
		/* 8206BBC4h case    2:*/		cpu::op::nop();
		/* 8206BBC4h case    2:*/		return 0x8206BBC8;
	}
	return 0x8206BBC8;
} // Block from 8206BBBCh-8206BBC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206BBC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BBC8);
		  /* 8206BBC8h */ case    0:  		/* mfspr R12, LR */
		/* 8206BBC8h case    0:*/		regs.R12 = regs.LR;
		/* 8206BBC8h case    0:*/		return 0x8206BBCC;
		  /* 8206BBCCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206BBCCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206BBCCh case    1:*/		return 0x8206BBD0;
		  /* 8206BBD0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8206BBD0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206BBD0h case    2:*/		return 0x8206BBD4;
		  /* 8206BBD4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8206BBD4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8206BBD4h case    3:*/		return 0x8206BBD8;
		  /* 8206BBD8h */ case    4:  		/* mr R31, R3 */
		/* 8206BBD8h case    4:*/		regs.R31 = regs.R3;
		/* 8206BBD8h case    4:*/		return 0x8206BBDC;
		  /* 8206BBDCh */ case    5:  		/* lwz R3, <#[R3 + 304]> */
		/* 8206BBDCh case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000130) );
		/* 8206BBDCh case    5:*/		return 0x8206BBE0;
		  /* 8206BBE0h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 8206BBE0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8206BBE0h case    6:*/		return 0x8206BBE4;
		  /* 8206BBE4h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 8206BBE4h case    7:*/		if ( regs.CR[6].eq ) { return 0x8206BBF0;  }
		/* 8206BBE4h case    7:*/		return 0x8206BBE8;
		  /* 8206BBE8h */ case    8:  		/* lis R4, 9344 */
		/* 8206BBE8h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206BBE8h case    8:*/		return 0x8206BBEC;
		  /* 8206BBECh */ case    9:  		/* bl 116556 */
		/* 8206BBECh case    9:*/		regs.LR = 0x8206BBF0; return 0x82088338;
		/* 8206BBECh case    9:*/		return 0x8206BBF0;
	}
	return 0x8206BBF0;
} // Block from 8206BBC8h-8206BBF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206BBF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BBF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BBF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BBF0);
		  /* 8206BBF0h */ case    0:  		/* lwz R3, <#[R31 + 292]> */
		/* 8206BBF0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000124) );
		/* 8206BBF0h case    0:*/		return 0x8206BBF4;
		  /* 8206BBF4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8206BBF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8206BBF4h case    1:*/		return 0x8206BBF8;
		  /* 8206BBF8h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8206BBF8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206BC04;  }
		/* 8206BBF8h case    2:*/		return 0x8206BBFC;
		  /* 8206BBFCh */ case    3:  		/* lis R4, 9344 */
		/* 8206BBFCh case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206BBFCh case    3:*/		return 0x8206BC00;
		  /* 8206BC00h */ case    4:  		/* bl 116536 */
		/* 8206BC00h case    4:*/		regs.LR = 0x8206BC04; return 0x82088338;
		/* 8206BC00h case    4:*/		return 0x8206BC04;
	}
	return 0x8206BC04;
} // Block from 8206BBF0h-8206BC04h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206BC04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BC04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BC04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BC04);
		  /* 8206BC04h */ case    0:  		/* lwz R3, <#[R31 + 280]> */
		/* 8206BC04h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000118) );
		/* 8206BC04h case    0:*/		return 0x8206BC08;
		  /* 8206BC08h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8206BC08h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8206BC08h case    1:*/		return 0x8206BC0C;
		  /* 8206BC0Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8206BC0Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8206BC18;  }
		/* 8206BC0Ch case    2:*/		return 0x8206BC10;
		  /* 8206BC10h */ case    3:  		/* lis R4, 9344 */
		/* 8206BC10h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206BC10h case    3:*/		return 0x8206BC14;
		  /* 8206BC14h */ case    4:  		/* bl 116516 */
		/* 8206BC14h case    4:*/		regs.LR = 0x8206BC18; return 0x82088338;
		/* 8206BC14h case    4:*/		return 0x8206BC18;
	}
	return 0x8206BC18;
} // Block from 8206BC04h-8206BC18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206BC18h
// Function '?GetMicrocode@CMicrocodeBuilder@D3D@@QAAJPAVSink@12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BC18);
		  /* 8206BC18h */ case    0:  		/* lwz R3, <#[R31 + 268]> */
		/* 8206BC18h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000010C) );
		/* 8206BC18h case    0:*/		return 0x8206BC1C;
		  /* 8206BC1Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8206BC1Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8206BC1Ch case    1:*/		return 0x8206BC20;
		  /* 8206BC20h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8206BC20h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206BC2C;  }
		/* 8206BC20h case    2:*/		return 0x8206BC24;
		  /* 8206BC24h */ case    3:  		/* lis R4, 9344 */
		/* 8206BC24h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206BC24h case    3:*/		return 0x8206BC28;
		  /* 8206BC28h */ case    4:  		/* bl 116496 */
		/* 8206BC28h case    4:*/		regs.LR = 0x8206BC2C; return 0x82088338;
		/* 8206BC28h case    4:*/		return 0x8206BC2C;
	}
	return 0x8206BC2C;
} // Block from 8206BC18h-8206BC2Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206BC2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BC2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BC2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BC2C);
		  /* 8206BC2Ch */ case    0:  		/* lwz R3, <#[R31 + 108]> */
		/* 8206BC2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000006C) );
		/* 8206BC2Ch case    0:*/		return 0x8206BC30;
		  /* 8206BC30h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8206BC30h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8206BC30h case    1:*/		return 0x8206BC34;
		  /* 8206BC34h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8206BC34h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206BC40;  }
		/* 8206BC34h case    2:*/		return 0x8206BC38;
		  /* 8206BC38h */ case    3:  		/* lis R4, 9344 */
		/* 8206BC38h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206BC38h case    3:*/		return 0x8206BC3C;
		  /* 8206BC3Ch */ case    4:  		/* bl 116476 */
		/* 8206BC3Ch case    4:*/		regs.LR = 0x8206BC40; return 0x82088338;
		/* 8206BC3Ch case    4:*/		return 0x8206BC40;
	}
	return 0x8206BC40;
} // Block from 8206BC2Ch-8206BC40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206BC40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BC40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BC40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BC40);
		  /* 8206BC40h */ case    0:  		/* lwz R3, <#[R31 + 96]> */
		/* 8206BC40h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000060) );
		/* 8206BC40h case    0:*/		return 0x8206BC44;
		  /* 8206BC44h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8206BC44h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8206BC44h case    1:*/		return 0x8206BC48;
		  /* 8206BC48h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8206BC48h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206BC54;  }
		/* 8206BC48h case    2:*/		return 0x8206BC4C;
		  /* 8206BC4Ch */ case    3:  		/* lis R4, 9344 */
		/* 8206BC4Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206BC4Ch case    3:*/		return 0x8206BC50;
		  /* 8206BC50h */ case    4:  		/* bl 116456 */
		/* 8206BC50h case    4:*/		regs.LR = 0x8206BC54; return 0x82088338;
		/* 8206BC50h case    4:*/		return 0x8206BC54;
	}
	return 0x8206BC54;
} // Block from 8206BC40h-8206BC54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206BC54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BC54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BC54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BC54);
		  /* 8206BC54h */ case    0:  		/* addi R1, R1, 96 */
		/* 8206BC54h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206BC54h case    0:*/		return 0x8206BC58;
		  /* 8206BC58h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206BC58h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206BC58h case    1:*/		return 0x8206BC5C;
		  /* 8206BC5Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8206BC5Ch case    2:*/		regs.LR = regs.R12;
		/* 8206BC5Ch case    2:*/		return 0x8206BC60;
		  /* 8206BC60h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8206BC60h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206BC60h case    3:*/		return 0x8206BC64;
		  /* 8206BC64h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8206BC64h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206BC64h case    4:*/		return 0x8206BC68;
	}
	return 0x8206BC68;
} // Block from 8206BC54h-8206BC68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206BC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BC68);
		  /* 8206BC68h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8206BC68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206BC68h case    0:*/		return 0x8206BC6C;
		  /* 8206BC6Ch */ case    1:  		/* subfic R10, R4, 63 */
		/* 8206BC6Ch case    1:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R4,0x3F);
		/* 8206BC6Ch case    1:*/		return 0x8206BC70;
		  /* 8206BC70h */ case    2:  		/* li R8, 1 */
		/* 8206BC70h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8206BC70h case    2:*/		return 0x8206BC74;
		  /* 8206BC74h */ case    3:  		/* mulli R11, R11, 9936 */
		/* 8206BC74h case    3:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206BC74h case    3:*/		return 0x8206BC78;
		  /* 8206BC78h */ case    4:  		/* add R11, R11, R3 */
		/* 8206BC78h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206BC78h case    4:*/		return 0x8206BC7C;
		  /* 8206BC7Ch */ case    5:  		/* rldicl R10, R10, 0, 32 */
		/* 8206BC7Ch case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 8206BC7Ch case    5:*/		return 0x8206BC80;
		  /* 8206BC80h */ case    6:  		/* li R9, 0 */
		/* 8206BC80h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8206BC80h case    6:*/		return 0x8206BC84;
		  /* 8206BC84h */ case    7:  		/* sld R7, R8, R10 */
		/* 8206BC84h case    7:*/		cpu::op::sld<0>(regs,&regs.R7,regs.R8,regs.R10);
		/* 8206BC84h case    7:*/		return 0x8206BC88;
		  /* 8206BC88h */ case    8:  		/* ld R6, <#[R11 + 9496]> */
		/* 8206BC88h case    8:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R11 + 0x00002518) );
		/* 8206BC88h case    8:*/		return 0x8206BC8C;
		  /* 8206BC8Ch */ case    9:  		/* addi R4, R4, 2248 */
		/* 8206BC8Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x8C8);
		/* 8206BC8Ch case    9:*/		return 0x8206BC90;
		  /* 8206BC90h */ case   10:  		/* stw R9, <#[R11 + 9932]> */
		/* 8206BC90h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x000026CC) );
		/* 8206BC90h case   10:*/		return 0x8206BC94;
		  /* 8206BC94h */ case   11:  		/* addi R10, R11, 368 */
		/* 8206BC94h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x170);
		/* 8206BC94h case   11:*/		return 0x8206BC98;
		  /* 8206BC98h */ case   12:  		/* or R9, R7, R6 */
		/* 8206BC98h case   12:*/		cpu::op::or<0>(regs,&regs.R9,regs.R7,regs.R6);
		/* 8206BC98h case   12:*/		return 0x8206BC9C;
		  /* 8206BC9Ch */ case   13:  		/* rlwinm R7, R4, 2, 0, 29 */
		/* 8206BC9Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R4);
		/* 8206BC9Ch case   13:*/		return 0x8206BCA0;
		  /* 8206BCA0h */ case   14:  		/* std R9, <#[R11 + 9496]> */
		/* 8206BCA0h case   14:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R11 + 0x00002518) );
		/* 8206BCA0h case   14:*/		return 0x8206BCA4;
		  /* 8206BCA4h */ case   15:  		/* addi R11, R10, 9208 */
		/* 8206BCA4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x23F8);
		/* 8206BCA4h case   15:*/		return 0x8206BCA8;
		  /* 8206BCA8h */ case   16:  		/* rlwinm R9, R7, 27, 5, 29 */
		/* 8206BCA8h case   16:*/		cpu::op::rlwinm<0,27,5,29>(regs,&regs.R9,regs.R7);
		/* 8206BCA8h case   16:*/		return 0x8206BCAC;
		  /* 8206BCACh */ case   17:  		/* rlwinm R6, R7, 30, 27, 31 */
		/* 8206BCACh case   17:*/		cpu::op::rlwinm<0,30,27,31>(regs,&regs.R6,regs.R7);
		/* 8206BCACh case   17:*/		return 0x8206BCB0;
		  /* 8206BCB0h */ case   18:  		/* slw R8, R8, R6 */
		/* 8206BCB0h case   18:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 8206BCB0h case   18:*/		return 0x8206BCB4;
		  /* 8206BCB4h */ case   19:  		/* lwzx R6, <#[R9 + R11]> */
		/* 8206BCB4h case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8206BCB4h case   19:*/		return 0x8206BCB8;
		  /* 8206BCB8h */ case   20:  		/* or R8, R8, R6 */
		/* 8206BCB8h case   20:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 8206BCB8h case   20:*/		return 0x8206BCBC;
		  /* 8206BCBCh */ case   21:  		/* stwx R8, <#[R9 + R11]> */
		/* 8206BCBCh case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8206BCBCh case   21:*/		return 0x8206BCC0;
		  /* 8206BCC0h */ case   22:  		/* lbz R11, <#[R5 + 7]> */
		/* 8206BCC0h case   22:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000007) );
		/* 8206BCC0h case   22:*/		return 0x8206BCC4;
		  /* 8206BCC4h */ case   23:  		/* lbz R9, <#[R5 + 3]> */
		/* 8206BCC4h case   23:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000003) );
		/* 8206BCC4h case   23:*/		return 0x8206BCC8;
		  /* 8206BCC8h */ case   24:  		/* lbz R8, <#[R5 + 11]> */
		/* 8206BCC8h case   24:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R5 + 0x0000000B) );
		/* 8206BCC8h case   24:*/		return 0x8206BCCC;
		  /* 8206BCCCh */ case   25:  		/* rlwinm R8, R8, 8, 0, 31 */
		/* 8206BCCCh case   25:*/		cpu::op::rlwinm<0,8,0,31>(regs,&regs.R8,regs.R8);
		/* 8206BCCCh case   25:*/		return 0x8206BCD0;
		  /* 8206BCD0h */ case   26:  		/* or R11, R8, R11 */
		/* 8206BCD0h case   26:*/		cpu::op::or<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8206BCD0h case   26:*/		return 0x8206BCD4;
		  /* 8206BCD4h */ case   27:  		/* rlwinm R11, R11, 8, 0, 23 */
		/* 8206BCD4h case   27:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R11,regs.R11);
		/* 8206BCD4h case   27:*/		return 0x8206BCD8;
		  /* 8206BCD8h */ case   28:  		/* or R11, R11, R9 */
		/* 8206BCD8h case   28:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8206BCD8h case   28:*/		return 0x8206BCDC;
		  /* 8206BCDCh */ case   29:  		/* stwx R11, <#[R7 + R10]> */
		/* 8206BCDCh case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8206BCDCh case   29:*/		return 0x8206BCE0;
		  /* 8206BCE0h */ case   30:  		/* bclr 20, CR0_LT */
		/* 8206BCE0h case   30:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206BCE0h case   30:*/		return 0x8206BCE4;
	}
	return 0x8206BCE4;
} // Block from 8206BC68h-8206BCE4h (31 instructions)

//////////////////////////////////////////////////////
// Block at 8206BCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BCE4);
		  /* 8206BCE4h */ case    0:  		/* nop */
		/* 8206BCE4h case    0:*/		cpu::op::nop();
		/* 8206BCE4h case    0:*/		return 0x8206BCE8;
		  /* 8206BCE8h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8206BCE8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206BCE8h case    1:*/		return 0x8206BCEC;
		  /* 8206BCECh */ case    2:  		/* mulli R11, R11, 9936 */
		/* 8206BCECh case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206BCECh case    2:*/		return 0x8206BCF0;
		  /* 8206BCF0h */ case    3:  		/* add R11, R11, R3 */
		/* 8206BCF0h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206BCF0h case    3:*/		return 0x8206BCF4;
		  /* 8206BCF4h */ case    4:  		/* addi R3, R11, 16 */
		/* 8206BCF4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206BCF4h case    4:*/		return 0x8206BCF8;
		  /* 8206BCF8h */ case    5:  		/* b -1656 */
		/* 8206BCF8h case    5:*/		return 0x8206B680;
		/* 8206BCF8h case    5:*/		return 0x8206BCFC;
		  /* 8206BCFCh */ case    6:  		/* nop */
		/* 8206BCFCh case    6:*/		cpu::op::nop();
		/* 8206BCFCh case    6:*/		return 0x8206BD00;
	}
	return 0x8206BD00;
} // Block from 8206BCE4h-8206BD00h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206BD00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BD00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BD00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BD00);
		  /* 8206BD00h */ case    0:  		/* mfspr R12, LR */
		/* 8206BD00h case    0:*/		regs.R12 = regs.LR;
		/* 8206BD00h case    0:*/		return 0x8206BD04;
		  /* 8206BD04h */ case    1:  		/* bl 152916 */
		/* 8206BD04h case    1:*/		regs.LR = 0x8206BD08; return 0x82091258;
		/* 8206BD04h case    1:*/		return 0x8206BD08;
		  /* 8206BD08h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206BD08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206BD08h case    2:*/		return 0x8206BD0C;
		  /* 8206BD0Ch */ case    3:  		/* li R30, 0 */
		/* 8206BD0Ch case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8206BD0Ch case    3:*/		return 0x8206BD10;
		  /* 8206BD10h */ case    4:  		/* mr R31, R3 */
		/* 8206BD10h case    4:*/		regs.R31 = regs.R3;
		/* 8206BD10h case    4:*/		return 0x8206BD14;
		  /* 8206BD14h */ case    5:  		/* addi R29, R3, 16 */
		/* 8206BD14h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R3,0x10);
		/* 8206BD14h case    5:*/		return 0x8206BD18;
		  /* 8206BD18h */ case    6:  		/* stw R30, <#[R3 + 19900]> */
		/* 8206BD18h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00004DBC) );
		/* 8206BD18h case    6:*/		return 0x8206BD1C;
		  /* 8206BD1Ch */ case    7:  		/* li R28, 2 */
		/* 8206BD1Ch case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x2);
		/* 8206BD1Ch case    7:*/		return 0x8206BD20;
		  /* 8206BD20h */ case    8:  		/* stw R30, <#[R3 + 19892]> */
		/* 8206BD20h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00004DB4) );
		/* 8206BD20h case    8:*/		return 0x8206BD24;
		  /* 8206BD24h */ case    9:  		/* mr R3, R29 */
		/* 8206BD24h case    9:*/		regs.R3 = regs.R29;
		/* 8206BD24h case    9:*/		return 0x8206BD28;
		  /* 8206BD28h */ case   10:  		/* bl -3240 */
		/* 8206BD28h case   10:*/		regs.LR = 0x8206BD2C; return 0x8206B080;
		/* 8206BD28h case   10:*/		return 0x8206BD2C;
		  /* 8206BD2Ch */ case   11:  		/* li R11, 1 */
		/* 8206BD2Ch case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206BD2Ch case   11:*/		return 0x8206BD30;
		  /* 8206BD30h */ case   12:  		/* addic. R28, R28, -1 */
		/* 8206BD30h case   12:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R28,0xFFFFFFFF);
		/* 8206BD30h case   12:*/		return 0x8206BD34;
		  /* 8206BD34h */ case   13:  		/* stw R11, <#[R29 + 9916]> */
		/* 8206BD34h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x000026BC) );
		/* 8206BD34h case   13:*/		return 0x8206BD38;
		  /* 8206BD38h */ case   14:  		/* addi R29, R29, 9936 */
		/* 8206BD38h case   14:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x26D0);
		/* 8206BD38h case   14:*/		return 0x8206BD3C;
		  /* 8206BD3Ch */ case   15:  		/* bc 4, CR0_EQ, -24 */
		/* 8206BD3Ch case   15:*/		if ( !regs.CR[0].eq ) { return 0x8206BD24;  }
		/* 8206BD3Ch case   15:*/		return 0x8206BD40;
		  /* 8206BD40h */ case   16:  		/* lwz R3, <#[R31 + 19896]> */
		/* 8206BD40h case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00004DB8) );
		/* 8206BD40h case   16:*/		return 0x8206BD44;
		  /* 8206BD44h */ case   17:  		/* cmplwi CR6, R3, 0 */
		/* 8206BD44h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8206BD44h case   17:*/		return 0x8206BD48;
		  /* 8206BD48h */ case   18:  		/* bc 12, CR6_EQ, 24 */
		/* 8206BD48h case   18:*/		if ( regs.CR[6].eq ) { return 0x8206BD60;  }
		/* 8206BD48h case   18:*/		return 0x8206BD4C;
		  /* 8206BD4Ch */ case   19:  		/* lwz R11, <#[R3]> */
		/* 8206BD4Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206BD4Ch case   19:*/		return 0x8206BD50;
		  /* 8206BD50h */ case   20:  		/* lwz R11, <#[R11 + 4]> */
		/* 8206BD50h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8206BD50h case   20:*/		return 0x8206BD54;
		  /* 8206BD54h */ case   21:  		/* mtspr CTR, R11 */
		/* 8206BD54h case   21:*/		regs.CTR = regs.R11;
		/* 8206BD54h case   21:*/		return 0x8206BD58;
		  /* 8206BD58h */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 8206BD58h case   22:*/		if ( 1 ) { regs.LR = 0x8206BD5C; return (uint32)regs.CTR; }
		/* 8206BD58h case   22:*/		return 0x8206BD5C;
		  /* 8206BD5Ch */ case   23:  		/* stw R30, <#[R31 + 19896]> */
		/* 8206BD5Ch case   23:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00004DB8) );
		/* 8206BD5Ch case   23:*/		return 0x8206BD60;
	}
	return 0x8206BD60;
} // Block from 8206BD00h-8206BD60h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8206BD60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BD60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BD60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BD60);
		  /* 8206BD60h */ case    0:  		/* li R11, -1 */
		/* 8206BD60h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8206BD60h case    0:*/		return 0x8206BD64;
		  /* 8206BD64h */ case    1:  		/* stw R30, <#[R31 + 19904]> */
		/* 8206BD64h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00004DC0) );
		/* 8206BD64h case    1:*/		return 0x8206BD68;
		  /* 8206BD68h */ case    2:  		/* stw R30, <#[R31 + 19932]> */
		/* 8206BD68h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00004DDC) );
		/* 8206BD68h case    2:*/		return 0x8206BD6C;
		  /* 8206BD6Ch */ case    3:  		/* stw R11, <#[R31 + 19936]> */
		/* 8206BD6Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00004DE0) );
		/* 8206BD6Ch case    3:*/		return 0x8206BD70;
		  /* 8206BD70h */ case    4:  		/* stw R30, <#[R31 + 19944]> */
		/* 8206BD70h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00004DE8) );
		/* 8206BD70h case    4:*/		return 0x8206BD74;
		  /* 8206BD74h */ case    5:  		/* stw R30, <#[R31 + 19952]> */
		/* 8206BD74h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00004DF0) );
		/* 8206BD74h case    5:*/		return 0x8206BD78;
		  /* 8206BD78h */ case    6:  		/* addi R1, R1, 128 */
		/* 8206BD78h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206BD78h case    6:*/		return 0x8206BD7C;
		  /* 8206BD7Ch */ case    7:  		/* b 152876 */
		/* 8206BD7Ch case    7:*/		return 0x820912A8;
		/* 8206BD7Ch case    7:*/		return 0x8206BD80;
	}
	return 0x8206BD80;
} // Block from 8206BD60h-8206BD80h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206BD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BD80);
		  /* 8206BD80h */ case    0:  		/* mfspr R12, LR */
		/* 8206BD80h case    0:*/		regs.R12 = regs.LR;
		/* 8206BD80h case    0:*/		return 0x8206BD84;
		  /* 8206BD84h */ case    1:  		/* bl 152780 */
		/* 8206BD84h case    1:*/		regs.LR = 0x8206BD88; return 0x82091250;
		/* 8206BD84h case    1:*/		return 0x8206BD88;
		  /* 8206BD88h */ case    2:  		/* stwu R1, <#[R1 - 944]> */
		/* 8206BD88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFC50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFC50);
		/* 8206BD88h case    2:*/		return 0x8206BD8C;
		  /* 8206BD8Ch */ case    3:  		/* lwz R9, <#[R4 + 28]> */
		/* 8206BD8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x0000001C) );
		/* 8206BD8Ch case    3:*/		return 0x8206BD90;
		  /* 8206BD90h */ case    4:  		/* mr R30, R3 */
		/* 8206BD90h case    4:*/		regs.R30 = regs.R3;
		/* 8206BD90h case    4:*/		return 0x8206BD94;
		  /* 8206BD94h */ case    5:  		/* mr R26, R4 */
		/* 8206BD94h case    5:*/		regs.R26 = regs.R4;
		/* 8206BD94h case    5:*/		return 0x8206BD98;
		  /* 8206BD98h */ case    6:  		/* addi R31, R4, 20 */
		/* 8206BD98h case    6:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R4,0x14);
		/* 8206BD98h case    6:*/		return 0x8206BD9C;
		  /* 8206BD9Ch */ case    7:  		/* cmplwi CR6, R9, 0 */
		/* 8206BD9Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8206BD9Ch case    7:*/		return 0x8206BDA0;
		  /* 8206BDA0h */ case    8:  		/* bc 4, CR6_EQ, 96 */
		/* 8206BDA0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8206BE00;  }
		/* 8206BDA0h case    8:*/		return 0x8206BDA4;
		  /* 8206BDA4h */ case    9:  		/* mr R5, R4 */
		/* 8206BDA4h case    9:*/		regs.R5 = regs.R4;
		/* 8206BDA4h case    9:*/		return 0x8206BDA8;
		  /* 8206BDA8h */ case   10:  		/* li R4, 0 */
		/* 8206BDA8h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206BDA8h case   10:*/		return 0x8206BDAC;
		  /* 8206BDACh */ case   11:  		/* bl -1492 */
		/* 8206BDACh case   11:*/		regs.LR = 0x8206BDB0; return 0x8206B7D8;
		/* 8206BDACh case   11:*/		return 0x8206BDB0;
		  /* 8206BDB0h */ case   12:  		/* lwz R11, <#[R30]> */
		/* 8206BDB0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206BDB0h case   12:*/		return 0x8206BDB4;
		  /* 8206BDB4h */ case   13:  		/* li R4, 0 */
		/* 8206BDB4h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206BDB4h case   13:*/		return 0x8206BDB8;
		  /* 8206BDB8h */ case   14:  		/* mr R3, R31 */
		/* 8206BDB8h case   14:*/		regs.R3 = regs.R31;
		/* 8206BDB8h case   14:*/		return 0x8206BDBC;
		  /* 8206BDBCh */ case   15:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206BDBCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206BDBCh case   15:*/		return 0x8206BDC0;
		  /* 8206BDC0h */ case   16:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 8206BDC0h case   16:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8206BDC0h case   16:*/		return 0x8206BDC4;
		  /* 8206BDC4h */ case   17:  		/* bc 12, CR0_EQ, 16 */
		/* 8206BDC4h case   17:*/		if ( regs.CR[0].eq ) { return 0x8206BDD4;  }
		/* 8206BDC4h case   17:*/		return 0x8206BDC8;
		  /* 8206BDC8h */ case   18:  		/* lwz R11, <#[R30 + 272]> */
		/* 8206BDC8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000110) );
		/* 8206BDC8h case   18:*/		return 0x8206BDCC;
		  /* 8206BDCCh */ case   19:  		/* addi R11, R11, 8 */
		/* 8206BDCCh case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8206BDCCh case   19:*/		return 0x8206BDD0;
		  /* 8206BDD0h */ case   20:  		/* b 36 */
		/* 8206BDD0h case   20:*/		return 0x8206BDF4;
		/* 8206BDD0h case   20:*/		return 0x8206BDD4;
	}
	return 0x8206BDD4;
} // Block from 8206BD80h-8206BDD4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8206BDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BDD4);
		  /* 8206BDD4h */ case    0:  		/* lwz R10, <#[R30 + 316]> */
		/* 8206BDD4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000013C) );
		/* 8206BDD4h case    0:*/		return 0x8206BDD8;
		  /* 8206BDD8h */ case    1:  		/* lwz R11, <#[R30 + 308]> */
		/* 8206BDD8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000134) );
		/* 8206BDD8h case    1:*/		return 0x8206BDDC;
		  /* 8206BDDCh */ case    2:  		/* lwz R9, <#[R30 + 296]> */
		/* 8206BDDCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000128) );
		/* 8206BDDCh case    2:*/		return 0x8206BDE0;
		  /* 8206BDE0h */ case    3:  		/* add R11, R10, R11 */
		/* 8206BDE0h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206BDE0h case    3:*/		return 0x8206BDE4;
		  /* 8206BDE4h */ case    4:  		/* lwz R10, <#[R30 + 284]> */
		/* 8206BDE4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000011C) );
		/* 8206BDE4h case    4:*/		return 0x8206BDE8;
		  /* 8206BDE8h */ case    5:  		/* add R11, R11, R9 */
		/* 8206BDE8h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8206BDE8h case    5:*/		return 0x8206BDEC;
		  /* 8206BDECh */ case    6:  		/* add R11, R11, R10 */
		/* 8206BDECh case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206BDECh case    6:*/		return 0x8206BDF0;
	}
	return 0x8206BDF0;
} // Block from 8206BDD4h-8206BDF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206BDF0h
// Function 'XCreateMicrocodeBuilder'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BDF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BDF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BDF0);
		  /* 8206BDF0h */ case    0:  		/* addi R11, R11, 9 */
		/* 8206BDF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x9);
		/* 8206BDF0h case    0:*/		return 0x8206BDF4;
	}
	return 0x8206BDF4;
} // Block from 8206BDF0h-8206BDF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206BDF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BDF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BDF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BDF4);
		  /* 8206BDF4h */ case    0:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 8206BDF4h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8206BDF4h case    0:*/		return 0x8206BDF8;
		  /* 8206BDF8h */ case    1:  		/* bl -18264 */
		/* 8206BDF8h case    1:*/		regs.LR = 0x8206BDFC; return 0x820676A0;
		/* 8206BDF8h case    1:*/		return 0x8206BDFC;
		  /* 8206BDFCh */ case    2:  		/* b 2104 */
		/* 8206BDFCh case    2:*/		return 0x8206C634;
		/* 8206BDFCh case    2:*/		return 0x8206BE00;
	}
	return 0x8206BE00;
} // Block from 8206BDF4h-8206BE00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206BE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BE00);
		  /* 8206BE00h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8206BE00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206BE00h case    0:*/		return 0x8206BE04;
		  /* 8206BE04h */ case    1:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206BE04h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206BE04h case    1:*/		return 0x8206BE08;
		  /* 8206BE08h */ case    2:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 8206BE08h case    2:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8206BE08h case    2:*/		return 0x8206BE0C;
		  /* 8206BE0Ch */ case    3:  		/* bc 12, CR0_EQ, 988 */
		/* 8206BE0Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8206C1E8;  }
		/* 8206BE0Ch case    3:*/		return 0x8206BE10;
		  /* 8206BE10h */ case    4:  		/* lwz R11, <#[R30 + 272]> */
		/* 8206BE10h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000110) );
		/* 8206BE10h case    4:*/		return 0x8206BE14;
		  /* 8206BE14h */ case    5:  		/* li R8, 0 */
		/* 8206BE14h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8206BE14h case    5:*/		return 0x8206BE18;
		  /* 8206BE18h */ case    6:  		/* lwz R9, <#[R30 + 268]> */
		/* 8206BE18h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000010C) );
		/* 8206BE18h case    6:*/		return 0x8206BE1C;
		  /* 8206BE1Ch */ case    7:  		/* addi R28, R30, 268 */
		/* 8206BE1Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R30,0x10C);
		/* 8206BE1Ch case    7:*/		return 0x8206BE20;
		  /* 8206BE20h */ case    8:  		/* rlwinm R7, R11, 2, 0, 29 */
		/* 8206BE20h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R11);
		/* 8206BE20h case    8:*/		return 0x8206BE24;
		  /* 8206BE24h */ case    9:  		/* extsw R11, R9 */
		/* 8206BE24h case    9:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R9);
		/* 8206BE24h case    9:*/		return 0x8206BE28;
		  /* 8206BE28h */ case   10:  		/* li R10, 0 */
		/* 8206BE28h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8206BE28h case   10:*/		return 0x8206BE2C;
		  /* 8206BE2Ch */ case   11:  		/* add R9, R7, R9 */
		/* 8206BE2Ch case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8206BE2Ch case   11:*/		return 0x8206BE30;
		  /* 8206BE30h */ case   12:  		/* b 80 */
		/* 8206BE30h case   12:*/		return 0x8206BE80;
		/* 8206BE30h case   12:*/		return 0x8206BE34;
		  /* 8206BE34h */ case   13:  		/* lwz R7, <#[R11]> */
		/* 8206BE34h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8206BE34h case   13:*/		return 0x8206BE38;
		  /* 8206BE38h */ case   14:  		/* rlwinm R6, R8, 2, 0, 29 */
		/* 8206BE38h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R8);
		/* 8206BE38h case   14:*/		return 0x8206BE3C;
		  /* 8206BE3Ch */ case   15:  		/* lbz R5, <#[R11]> */
		/* 8206BE3Ch case   15:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 8206BE3Ch case   15:*/		return 0x8206BE40;
	}
	return 0x8206BE40;
} // Block from 8206BE00h-8206BE40h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206BE40h
// Function '?ForEachInstructionInAnExec@D3D@@YAJPATGPUFLOW_EXEC@@AAKPAKI2IKP6AJKKPATGPUSHADER_INSTRUCTION@@PAX@Z4@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BE40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BE40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BE40);
		  /* 8206BE40h */ case    0:  		/* addi R4, R1, 180 */
		/* 8206BE40h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xB4);
		/* 8206BE40h case    0:*/		return 0x8206BE44;
		  /* 8206BE44h */ case    1:  		/* rlwinm R8, R7, 17, 31, 31 */
		/* 8206BE44h case    1:*/		cpu::op::rlwinm<0,17,31,31>(regs,&regs.R8,regs.R7);
		/* 8206BE44h case    1:*/		return 0x8206BE48;
		  /* 8206BE48h */ case    2:  		/* rlwinm R5, R5, 13, 0, 31 */
		/* 8206BE48h case    2:*/		cpu::op::rlwinm<0,13,0,31>(regs,&regs.R5,regs.R5);
		/* 8206BE48h case    2:*/		return 0x8206BE4C;
		  /* 8206BE4Ch */ case    3:  		/* rlwinm R3, R7, 18, 24, 31 */
		/* 8206BE4Ch case    3:*/		cpu::op::rlwinm<0,18,24,31>(regs,&regs.R3,regs.R7);
		/* 8206BE4Ch case    3:*/		return 0x8206BE50;
		  /* 8206BE50h */ case    4:  		/* or R5, R5, R8 */
		/* 8206BE50h case    4:*/		cpu::op::or<0>(regs,&regs.R5,regs.R5,regs.R8);
		/* 8206BE50h case    4:*/		return 0x8206BE54;
		  /* 8206BE54h */ case    5:  		/* rlwinm R29, R7, 28, 16, 19 */
		/* 8206BE54h case    5:*/		cpu::op::rlwinm<0,28,16,19>(regs,&regs.R29,regs.R7);
		/* 8206BE54h case    5:*/		return 0x8206BE58;
		  /* 8206BE58h */ case    6:  		/* rlwimi R3, R5, 1, 0, 30 */
		/* 8206BE58h case    6:*/		cpu::op::rlwimi<0,1,0,30>(regs,&regs.R3,regs.R5);
		/* 8206BE58h case    6:*/		return 0x8206BE5C;
		  /* 8206BE5Ch */ case    7:  		/* add R10, R8, R10 */
		/* 8206BE5Ch case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8206BE5Ch case    7:*/		return 0x8206BE60;
		  /* 8206BE60h */ case    8:  		/* rlwinm R5, R3, 10, 0, 21 */
		/* 8206BE60h case    8:*/		cpu::op::rlwinm<0,10,0,21>(regs,&regs.R5,regs.R3);
		/* 8206BE60h case    8:*/		return 0x8206BE64;
		  /* 8206BE64h */ case    9:  		/* rlwinm R7, R7, 0, 8, 11 */
		/* 8206BE64h case    9:*/		cpu::op::rlwinm<0,0,8,11>(regs,&regs.R7,regs.R7);
		/* 8206BE64h case    9:*/		return 0x8206BE68;
		  /* 8206BE68h */ case   10:  		/* or R8, R5, R29 */
		/* 8206BE68h case   10:*/		cpu::op::or<0>(regs,&regs.R8,regs.R5,regs.R29);
		/* 8206BE68h case   10:*/		return 0x8206BE6C;
		  /* 8206BE6Ch */ case   11:  		/* addi R11, R11, 4 */
		/* 8206BE6Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206BE6Ch case   11:*/		return 0x8206BE70;
		  /* 8206BE70h */ case   12:  		/* or R8, R8, R7 */
		/* 8206BE70h case   12:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 8206BE70h case   12:*/		return 0x8206BE74;
		  /* 8206BE74h */ case   13:  		/* stwx R8, <#[R6 + R4]> */
		/* 8206BE74h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + regs.R4 + 0x00000000) );
		/* 8206BE74h case   13:*/		return 0x8206BE78;
		  /* 8206BE78h */ case   14:  		/* lwz R8, <#[R1 + 176]> */
		/* 8206BE78h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000B0) );
		/* 8206BE78h case   14:*/		return 0x8206BE7C;
		  /* 8206BE7Ch */ case   15:  		/* addi R8, R8, 1 */
		/* 8206BE7Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8206BE7Ch case   15:*/		return 0x8206BE80;
	}
	return 0x8206BE80;
} // Block from 8206BE40h-8206BE80h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206BE80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BE80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BE80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BE80);
		  /* 8206BE80h */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 8206BE80h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8206BE80h case    0:*/		return 0x8206BE84;
		  /* 8206BE84h */ case    1:  		/* stw R8, <#[R1 + 176]> */
		/* 8206BE84h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x000000B0) );
		/* 8206BE84h case    1:*/		return 0x8206BE88;
		  /* 8206BE88h */ case    2:  		/* bc 12, CR6_LT, -84 */
		/* 8206BE88h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206BE34;  }
		/* 8206BE88h case    2:*/		return 0x8206BE8C;
		  /* 8206BE8Ch */ case    3:  		/* lwz R11, <#[R30 + 272]> */
		/* 8206BE8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000110) );
		/* 8206BE8Ch case    3:*/		return 0x8206BE90;
		  /* 8206BE90h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 8206BE90h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8206BE90h case    4:*/		return 0x8206BE94;
		  /* 8206BE94h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 8206BE94h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206BEA0;  }
		/* 8206BE94h case    5:*/		return 0x8206BE98;
		  /* 8206BE98h */ case    6:  		/* li R11, 0 */
		/* 8206BE98h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206BE98h case    6:*/		return 0x8206BE9C;
		  /* 8206BE9Ch */ case    7:  		/* b 20 */
		/* 8206BE9Ch case    7:*/		return 0x8206BEB0;
		/* 8206BE9Ch case    7:*/		return 0x8206BEA0;
	}
	return 0x8206BEA0;
} // Block from 8206BE80h-8206BEA0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206BEA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BEA0);
		  /* 8206BEA0h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8206BEA0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8206BEA0h case    0:*/		return 0x8206BEA4;
		  /* 8206BEA4h */ case    1:  		/* li R11, 1 */
		/* 8206BEA4h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206BEA4h case    1:*/		return 0x8206BEA8;
		  /* 8206BEA8h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 8206BEA8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206BEB0;  }
		/* 8206BEA8h case    2:*/		return 0x8206BEAC;
		  /* 8206BEACh */ case    3:  		/* li R11, 2 */
		/* 8206BEACh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8206BEACh case    3:*/		return 0x8206BEB0;
	}
	return 0x8206BEB0;
} // Block from 8206BEA0h-8206BEB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206BEB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BEB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BEB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BEB0);
		  /* 8206BEB0h */ case    0:  		/* stw R11, <#[R30 + 336]> */
		/* 8206BEB0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000150) );
		/* 8206BEB0h case    0:*/		return 0x8206BEB4;
		  /* 8206BEB4h */ case    1:  		/* lwz R9, <#[R31]> */
		/* 8206BEB4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8206BEB4h case    1:*/		return 0x8206BEB8;
		  /* 8206BEB8h */ case    2:  		/* lwz R8, <#[R31 + 12]> */
		/* 8206BEB8h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206BEB8h case    2:*/		return 0x8206BEBC;
		  /* 8206BEBCh */ case    3:  		/* lwz R10, <#[R31 + 4]> */
		/* 8206BEBCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8206BEBCh case    3:*/		return 0x8206BEC0;
		  /* 8206BEC0h */ case    4:  		/* addi R11, R10, 32 */
		/* 8206BEC0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x20);
		/* 8206BEC0h case    4:*/		return 0x8206BEC4;
		  /* 8206BEC4h */ case    5:  		/* add R10, R9, R10 */
		/* 8206BEC4h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8206BEC4h case    5:*/		return 0x8206BEC8;
		  /* 8206BEC8h */ case    6:  		/* stw R11, <#[R31 + 4]> */
		/* 8206BEC8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206BEC8h case    6:*/		return 0x8206BECC;
		  /* 8206BECCh */ case    7:  		/* cmplw CR6, R11, R8 */
		/* 8206BECCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8206BECCh case    7:*/		return 0x8206BED0;
		  /* 8206BED0h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 8206BED0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8206BED8;  }
		/* 8206BED0h case    8:*/		return 0x8206BED4;
		  /* 8206BED4h */ case    9:  		/* stw R11, <#[R31 + 12]> */
		/* 8206BED4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206BED4h case    9:*/		return 0x8206BED8;
	}
	return 0x8206BED8;
} // Block from 8206BEB0h-8206BED8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206BED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BED8);
		  /* 8206BED8h */ case    0:  		/* lwz R9, <#[R31 + 8]> */
		/* 8206BED8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8206BED8h case    0:*/		return 0x8206BEDC;
		  /* 8206BEDCh */ case    1:  		/* mr R5, R26 */
		/* 8206BEDCh case    1:*/		regs.R5 = regs.R26;
		/* 8206BEDCh case    1:*/		return 0x8206BEE0;
		  /* 8206BEE0h */ case    2:  		/* mr R3, R30 */
		/* 8206BEE0h case    2:*/		regs.R3 = regs.R30;
		/* 8206BEE0h case    2:*/		return 0x8206BEE4;
		  /* 8206BEE4h */ case    3:  		/* subfc R9, R11, R9 */
		/* 8206BEE4h case    3:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8206BEE4h case    3:*/		return 0x8206BEE8;
		  /* 8206BEE8h */ case    4:  		/* addze R8, R11 */
		/* 8206BEE8h case    4:*/		cpu::op::addze<0>(regs,&regs.R8,regs.R11);
		/* 8206BEE8h case    4:*/		return 0x8206BEEC;
		  /* 8206BEECh */ case    5:  		/* subf R11, R8, R11 */
		/* 8206BEECh case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8206BEECh case    5:*/		return 0x8206BEF0;
		  /* 8206BEF0h */ case    6:  		/* and R29, R11, R10 */
		/* 8206BEF0h case    6:*/		cpu::op::and<0>(regs,&regs.R29,regs.R11,regs.R10);
		/* 8206BEF0h case    6:*/		return 0x8206BEF4;
		  /* 8206BEF4h */ case    7:  		/* mr R4, R29 */
		/* 8206BEF4h case    7:*/		regs.R4 = regs.R29;
		/* 8206BEF4h case    7:*/		return 0x8206BEF8;
		  /* 8206BEF8h */ case    8:  		/* bl -1824 */
		/* 8206BEF8h case    8:*/		regs.LR = 0x8206BEFC; return 0x8206B7D8;
		/* 8206BEF8h case    8:*/		return 0x8206BEFC;
		  /* 8206BEFCh */ case    9:  		/* lwz R11, <#[R30]> */
		/* 8206BEFCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206BEFCh case    9:*/		return 0x8206BF00;
		  /* 8206BF00h */ case   10:  		/* addi R3, R1, 176 */
		/* 8206BF00h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xB0);
		/* 8206BF00h case   10:*/		return 0x8206BF04;
		  /* 8206BF04h */ case   11:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206BF04h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206BF04h case   11:*/		return 0x8206BF08;
		  /* 8206BF08h */ case   12:  		/* rlwinm R4, R11, 29, 31, 31 */
		/* 8206BF08h case   12:*/		cpu::op::rlwinm<0,29,31,31>(regs,&regs.R4,regs.R11);
		/* 8206BF08h case   12:*/		return 0x8206BF0C;
		  /* 8206BF0Ch */ case   13:  		/* bl -10788 */
		/* 8206BF0Ch case   13:*/		regs.LR = 0x8206BF10; return 0x820694E8;
		/* 8206BF0Ch case   13:*/		return 0x8206BF10;
		  /* 8206BF10h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 8206BF10h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206BF10h case   14:*/		return 0x8206BF14;
		  /* 8206BF14h */ case   15:  		/* bc 4, CR0_EQ, 20 */
		/* 8206BF14h case   15:*/		if ( !regs.CR[0].eq ) { return 0x8206BF28;  }
		/* 8206BF14h case   15:*/		return 0x8206BF18;
		  /* 8206BF18h */ case   16:  		/* lis R11, -30602 */
		/* 8206BF18h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8876);
		/* 8206BF18h case   16:*/		return 0x8206BF1C;
		  /* 8206BF1Ch */ case   17:  		/* ori R11, R11, 2945 */
		/* 8206BF1Ch case   17:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xB81);
		/* 8206BF1Ch case   17:*/		return 0x8206BF20;
		  /* 8206BF20h */ case   18:  		/* stw R11, <#[R30 + 80]> */
		/* 8206BF20h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000050) );
		/* 8206BF20h case   18:*/		return 0x8206BF24;
		  /* 8206BF24h */ case   19:  		/* b 1808 */
		/* 8206BF24h case   19:*/		return 0x8206C634;
		/* 8206BF24h case   19:*/		return 0x8206BF28;
	}
	return 0x8206BF28;
} // Block from 8206BED8h-8206BF28h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8206BF28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BF28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BF28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BF28);
		  /* 8206BF28h */ case    0:  		/* lwz R11, <#[R30 + 272]> */
		/* 8206BF28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000110) );
		/* 8206BF28h case    0:*/		return 0x8206BF2C;
		  /* 8206BF2Ch */ case    1:  		/* lwz R10, <#[R31 + 4]> */
		/* 8206BF2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8206BF2Ch case    1:*/		return 0x8206BF30;
		  /* 8206BF30h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206BF30h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206BF30h case    2:*/		return 0x8206BF34;
		  /* 8206BF34h */ case    3:  		/* lwz R9, <#[R31]> */
		/* 8206BF34h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8206BF34h case    3:*/		return 0x8206BF38;
		  /* 8206BF38h */ case    4:  		/* lwz R8, <#[R31 + 12]> */
		/* 8206BF38h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206BF38h case    4:*/		return 0x8206BF3C;
		  /* 8206BF3Ch */ case    5:  		/* add R11, R11, R10 */
		/* 8206BF3Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206BF3Ch case    5:*/		return 0x8206BF40;
		  /* 8206BF40h */ case    6:  		/* add R10, R9, R10 */
		/* 8206BF40h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8206BF40h case    6:*/		return 0x8206BF44;
		  /* 8206BF44h */ case    7:  		/* stw R11, <#[R31 + 4]> */
		/* 8206BF44h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206BF44h case    7:*/		return 0x8206BF48;
		  /* 8206BF48h */ case    8:  		/* cmplw CR6, R11, R8 */
		/* 8206BF48h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8206BF48h case    8:*/		return 0x8206BF4C;
		  /* 8206BF4Ch */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 8206BF4Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x8206BF54;  }
		/* 8206BF4Ch case    9:*/		return 0x8206BF50;
		  /* 8206BF50h */ case   10:  		/* stw R11, <#[R31 + 12]> */
		/* 8206BF50h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206BF50h case   10:*/		return 0x8206BF54;
	}
	return 0x8206BF54;
} // Block from 8206BF28h-8206BF54h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206BF54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BF54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BF54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BF54);
		  /* 8206BF54h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206BF54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206BF54h case    0:*/		return 0x8206BF58;
		  /* 8206BF58h */ case    1:  		/* li R3, 0 */
		/* 8206BF58h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8206BF58h case    1:*/		return 0x8206BF5C;
		  /* 8206BF5Ch */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 8206BF5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8206BF5Ch case    2:*/		return 0x8206BF60;
		  /* 8206BF60h */ case    3:  		/* li R6, 0 */
		/* 8206BF60h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206BF60h case    3:*/		return 0x8206BF64;
		  /* 8206BF64h */ case    4:  		/* lwz R7, <#[R30 + 272]> */
		/* 8206BF64h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000110) );
		/* 8206BF64h case    4:*/		return 0x8206BF68;
		  /* 8206BF68h */ case    5:  		/* li R5, 0 */
		/* 8206BF68h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8206BF68h case    5:*/		return 0x8206BF6C;
		  /* 8206BF6Ch */ case    6:  		/* subfc R9, R11, R9 */
		/* 8206BF6Ch case    6:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8206BF6Ch case    6:*/		return 0x8206BF70;
		  /* 8206BF70h */ case    7:  		/* stw R3, <#[R1 + 84]> */
		/* 8206BF70h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8206BF70h case    7:*/		return 0x8206BF74;
		  /* 8206BF74h */ case    8:  		/* li R4, 0 */
		/* 8206BF74h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206BF74h case    8:*/		return 0x8206BF78;
		  /* 8206BF78h */ case    9:  		/* addze R31, R11 */
		/* 8206BF78h case    9:*/		cpu::op::addze<0>(regs,&regs.R31,regs.R11);
		/* 8206BF78h case    9:*/		return 0x8206BF7C;
		  /* 8206BF7Ch */ case   10:  		/* li R8, 0 */
		/* 8206BF7Ch case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8206BF7Ch case   10:*/		return 0x8206BF80;
		  /* 8206BF80h */ case   11:  		/* subf R11, R31, R11 */
		/* 8206BF80h case   11:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 8206BF80h case   11:*/		return 0x8206BF84;
		  /* 8206BF84h */ case   12:  		/* cmplwi CR6, R7, 0 */
		/* 8206BF84h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8206BF84h case   12:*/		return 0x8206BF88;
		  /* 8206BF88h */ case   13:  		/* and R9, R11, R10 */
		/* 8206BF88h case   13:*/		cpu::op::and<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 8206BF88h case   13:*/		return 0x8206BF8C;
		  /* 8206BF8Ch */ case   14:  		/* bc 4, CR6_GT, 128 */
		/* 8206BF8Ch case   14:*/		if ( !regs.CR[6].gt ) { return 0x8206C00C;  }
		/* 8206BF8Ch case   14:*/		return 0x8206BF90;
		  /* 8206BF90h */ case   15:  		/* addi R7, R1, 180 */
		/* 8206BF90h case   15:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xB4);
		/* 8206BF90h case   15:*/		return 0x8206BF94;
		  /* 8206BF94h */ case   16:  		/* lwz R10, <#[R7]> */
		/* 8206BF94h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 8206BF94h case   16:*/		return 0x8206BF98;
		  /* 8206BF98h */ case   17:  		/* mr R11, R10 */
		/* 8206BF98h case   17:*/		regs.R11 = regs.R10;
		/* 8206BF98h case   17:*/		return 0x8206BF9C;
		  /* 8206BF9Ch */ case   18:  		/* mr R3, R10 */
		/* 8206BF9Ch case   18:*/		regs.R3 = regs.R10;
		/* 8206BF9Ch case   18:*/		return 0x8206BFA0;
		  /* 8206BFA0h */ case   19:  		/* rlwimi R11, R10, 16, 16, 31 */
		/* 8206BFA0h case   19:*/		cpu::op::rlwimi<0,16,16,31>(regs,&regs.R11,regs.R10);
		/* 8206BFA0h case   19:*/		return 0x8206BFA4;
		  /* 8206BFA4h */ case   20:  		/* rlwimi R3, R11, 24, 20, 31 */
		/* 8206BFA4h case   20:*/		cpu::op::rlwimi<0,24,20,31>(regs,&regs.R3,regs.R11);
		/* 8206BFA4h case   20:*/		return 0x8206BFA8;
		  /* 8206BFA8h */ case   21:  		/* rlwinm R3, R3, 0, 16, 31 */
		/* 8206BFA8h case   21:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R3,regs.R3);
		/* 8206BFA8h case   21:*/		return 0x8206BFAC;
		  /* 8206BFACh */ case   22:  		/* rlwinm R11, R3, 24, 28, 31 */
		/* 8206BFACh case   22:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R11,regs.R3);
		/* 8206BFACh case   22:*/		return 0x8206BFB0;
		  /* 8206BFB0h */ case   23:  		/* stw R3, <#[R9]> */
		/* 8206BFB0h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R9 + 0x00000000) );
		/* 8206BFB0h case   23:*/		return 0x8206BFB4;
		  /* 8206BFB4h */ case   24:  		/* cmplw CR6, R11, R4 */
		/* 8206BFB4h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 8206BFB4h case   24:*/		return 0x8206BFB8;
		  /* 8206BFB8h */ case   25:  		/* bc 4, CR6_GT, 8 */
		/* 8206BFB8h case   25:*/		if ( !regs.CR[6].gt ) { return 0x8206BFC0;  }
		/* 8206BFB8h case   25:*/		return 0x8206BFBC;
		  /* 8206BFBCh */ case   26:  		/* mr R4, R11 */
		/* 8206BFBCh case   26:*/		regs.R4 = regs.R11;
		/* 8206BFBCh case   26:*/		return 0x8206BFC0;
	}
	return 0x8206BFC0;
} // Block from 8206BF54h-8206BFC0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8206BFC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BFC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BFC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BFC0);
		  /* 8206BFC0h */ case    0:  		/* lwz R3, <#[R1 + 84]> */
		/* 8206BFC0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8206BFC0h case    0:*/		return 0x8206BFC4;
		  /* 8206BFC4h */ case    1:  		/* cmplw CR6, R11, R3 */
		/* 8206BFC4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 8206BFC4h case    1:*/		return 0x8206BFC8;
		  /* 8206BFC8h */ case    2:  		/* bc 4, CR6_GT, 12 */
		/* 8206BFC8h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8206BFD4;  }
		/* 8206BFC8h case    2:*/		return 0x8206BFCC;
		  /* 8206BFCCh */ case    3:  		/* mr R3, R11 */
		/* 8206BFCCh case    3:*/		regs.R3 = regs.R11;
		/* 8206BFCCh case    3:*/		return 0x8206BFD0;
	}
	return 0x8206BFD0;
} // Block from 8206BFC0h-8206BFD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206BFD0h
// Function '?ForEachInstructionInActiveOrder@D3D@@YAJPAKI0I00KP6AJKKPATGPUSHADER_INSTRUCTION@@PAX@Z2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BFD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BFD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BFD0);
		  /* 8206BFD0h */ case    0:  		/* stw R11, <#[R1 + 84]> */
		/* 8206BFD0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8206BFD0h case    0:*/		return 0x8206BFD4;
	}
	return 0x8206BFD4;
} // Block from 8206BFD0h-8206BFD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206BFD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206BFD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206BFD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206BFD4);
		  /* 8206BFD4h */ case    0:  		/* nor R31, R10, R10 */
		/* 8206BFD4h case    0:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R10,regs.R10);
		/* 8206BFD4h case    0:*/		return 0x8206BFD8;
		  /* 8206BFD8h */ case    1:  		/* lwz R27, <#[R30 + 272]> */
		/* 8206BFD8h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R30 + 0x00000110) );
		/* 8206BFD8h case    1:*/		return 0x8206BFDC;
		  /* 8206BFDCh */ case    2:  		/* nor R10, R10, R10 */
		/* 8206BFDCh case    2:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8206BFDCh case    2:*/		return 0x8206BFE0;
		  /* 8206BFE0h */ case    3:  		/* rlwinm R31, R31, 21, 31, 31 */
		/* 8206BFE0h case    3:*/		cpu::op::rlwinm<0,21,31,31>(regs,&regs.R31,regs.R31);
		/* 8206BFE0h case    3:*/		return 0x8206BFE4;
		  /* 8206BFE4h */ case    4:  		/* rlwinm R10, R10, 22, 31, 31 */
		/* 8206BFE4h case    4:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R10,regs.R10);
		/* 8206BFE4h case    4:*/		return 0x8206BFE8;
		  /* 8206BFE8h */ case    5:  		/* slw R31, R31, R11 */
		/* 8206BFE8h case    5:*/		cpu::op::slw<0>(regs,&regs.R31,regs.R31,regs.R11);
		/* 8206BFE8h case    5:*/		return 0x8206BFEC;
		  /* 8206BFECh */ case    6:  		/* slw R11, R10, R11 */
		/* 8206BFECh case    6:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206BFECh case    6:*/		return 0x8206BFF0;
		  /* 8206BFF0h */ case    7:  		/* addi R8, R8, 1 */
		/* 8206BFF0h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8206BFF0h case    7:*/		return 0x8206BFF4;
		  /* 8206BFF4h */ case    8:  		/* or R6, R31, R6 */
		/* 8206BFF4h case    8:*/		cpu::op::or<0>(regs,&regs.R6,regs.R31,regs.R6);
		/* 8206BFF4h case    8:*/		return 0x8206BFF8;
		  /* 8206BFF8h */ case    9:  		/* or R5, R11, R5 */
		/* 8206BFF8h case    9:*/		cpu::op::or<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 8206BFF8h case    9:*/		return 0x8206BFFC;
		  /* 8206BFFCh */ case   10:  		/* addi R7, R7, 4 */
		/* 8206BFFCh case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8206BFFCh case   10:*/		return 0x8206C000;
		  /* 8206C000h */ case   11:  		/* addi R9, R9, 4 */
		/* 8206C000h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8206C000h case   11:*/		return 0x8206C004;
		  /* 8206C004h */ case   12:  		/* cmplw CR6, R8, R27 */
		/* 8206C004h case   12:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R27);
		/* 8206C004h case   12:*/		return 0x8206C008;
		  /* 8206C008h */ case   13:  		/* bc 12, CR6_LT, -116 */
		/* 8206C008h case   13:*/		if ( regs.CR[6].lt ) { return 0x8206BF94;  }
		/* 8206C008h case   13:*/		return 0x8206C00C;
	}
	return 0x8206C00C;
} // Block from 8206BFD4h-8206C00Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206C00Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C00C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C00C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C00C);
		  /* 8206C00Ch */ case    0:  		/* lwz R11, <#[R30 + 88]> */
		/* 8206C00Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000058) );
		/* 8206C00Ch case    0:*/		return 0x8206C010;
		  /* 8206C010h */ case    1:  		/* rlwinm R10, R11, 13, 31, 31 */
		/* 8206C010h case    1:*/		cpu::op::rlwinm<0,13,31,31>(regs,&regs.R10,regs.R11);
		/* 8206C010h case    1:*/		return 0x8206C014;
		  /* 8206C014h */ case    2:  		/* rlwinm R11, R11, 14, 31, 31 */
		/* 8206C014h case    2:*/		cpu::op::rlwinm<0,14,31,31>(regs,&regs.R11,regs.R11);
		/* 8206C014h case    2:*/		return 0x8206C018;
		  /* 8206C018h */ case    3:  		/* add R11, R10, R11 */
		/* 8206C018h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206C018h case    3:*/		return 0x8206C01C;
		  /* 8206C01Ch */ case    4:  		/* add R11, R11, R4 */
		/* 8206C01Ch case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 8206C01Ch case    4:*/		return 0x8206C020;
		  /* 8206C020h */ case    5:  		/* cmplwi CR6, R11, 15 */
		/* 8206C020h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 8206C020h case    5:*/		return 0x8206C024;
		  /* 8206C024h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 8206C024h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8206C02C;  }
		/* 8206C024h case    6:*/		return 0x8206C028;
		  /* 8206C028h */ case    7:  		/* li R11, 15 */
		/* 8206C028h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0xF);
		/* 8206C028h case    7:*/		return 0x8206C02C;
	}
	return 0x8206C02C;
} // Block from 8206C00Ch-8206C02Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206C02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C02C);
		  /* 8206C02Ch */ case    0:  		/* cmplw CR6, R11, R3 */
		/* 8206C02Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 8206C02Ch case    0:*/		return 0x8206C030;
		  /* 8206C030h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 8206C030h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8206C038;  }
		/* 8206C030h case    1:*/		return 0x8206C034;
		  /* 8206C034h */ case    2:  		/* stw R11, <#[R1 + 84]> */
		/* 8206C034h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8206C034h case    2:*/		return 0x8206C038;
	}
	return 0x8206C038;
} // Block from 8206C02Ch-8206C038h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206C038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C038);
		  /* 8206C038h */ case    0:  		/* li R11, 64 */
		/* 8206C038h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x40);
		/* 8206C038h case    0:*/		return 0x8206C03C;
		  /* 8206C03Ch */ case    1:  		/* sth R6, <#[R29 + 24]> */
		/* 8206C03Ch case    1:*/		cpu::mem::store16( regs, regs.R6, (uint32)(regs.R29 + 0x00000018) );
		/* 8206C03Ch case    1:*/		return 0x8206C040;
		  /* 8206C040h */ case    2:  		/* addi R10, R1, 364 */
		/* 8206C040h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x16C);
		/* 8206C040h case    2:*/		return 0x8206C044;
		  /* 8206C044h */ case    3:  		/* sth R5, <#[R29 + 26]> */
		/* 8206C044h case    3:*/		cpu::mem::store16( regs, regs.R5, (uint32)(regs.R29 + 0x0000001A) );
		/* 8206C044h case    3:*/		return 0x8206C048;
		  /* 8206C048h */ case    4:  		/* li R9, 0 */
		/* 8206C048h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8206C048h case    4:*/		return 0x8206C04C;
		  /* 8206C04Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 8206C04Ch case    5:*/		regs.CTR = regs.R11;
		/* 8206C04Ch case    5:*/		return 0x8206C050;
		  /* 8206C050h */ case    6:  		/* stwu R9, <#[R10 + 4]> */
		/* 8206C050h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8206C050h case    6:*/		return 0x8206C054;
		  /* 8206C054h */ case    7:  		/* addi R9, R9, 1 */
		/* 8206C054h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8206C054h case    7:*/		return 0x8206C058;
		  /* 8206C058h */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 8206C058h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206C050;  }
		/* 8206C058h case    8:*/		return 0x8206C05C;
		  /* 8206C05Ch */ case    9:  		/* lwz R11, <#[R1 + 176]> */
		/* 8206C05Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 8206C05Ch case    9:*/		return 0x8206C060;
		  /* 8206C060h */ case   10:  		/* addi R10, R1, 180 */
		/* 8206C060h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xB4);
		/* 8206C060h case   10:*/		return 0x8206C064;
		  /* 8206C064h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8206C064h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206C064h case   11:*/		return 0x8206C068;
		  /* 8206C068h */ case   12:  		/* bc 12, CR6_EQ, 36 */
		/* 8206C068h case   12:*/		if ( regs.CR[6].eq ) { return 0x8206C08C;  }
		/* 8206C068h case   12:*/		return 0x8206C06C;
		  /* 8206C06Ch */ case   13:  		/* mtspr CTR, R11 */
		/* 8206C06Ch case   13:*/		regs.CTR = regs.R11;
		/* 8206C06Ch case   13:*/		return 0x8206C070;
		  /* 8206C070h */ case   14:  		/* addi R11, R10, -4 */
		/* 8206C070h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFC);
		/* 8206C070h case   14:*/		return 0x8206C074;
		  /* 8206C074h */ case   15:  		/* lwzu R10, <#[R11 + 4]> */
		/* 8206C074h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206C074h case   15:*/		return 0x8206C078;
		  /* 8206C078h */ case   16:  		/* addi R9, R1, 368 */
		/* 8206C078h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x170);
		/* 8206C078h case   16:*/		return 0x8206C07C;
		  /* 8206C07Ch */ case   17:  		/* rlwinm R8, R10, 14, 26, 29 */
		/* 8206C07Ch case   17:*/		cpu::op::rlwinm<0,14,26,29>(regs,&regs.R8,regs.R10);
		/* 8206C07Ch case   17:*/		return 0x8206C080;
		  /* 8206C080h */ case   18:  		/* rlwinm R10, R10, 16, 28, 31 */
		/* 8206C080h case   18:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R10,regs.R10);
		/* 8206C080h case   18:*/		return 0x8206C084;
		  /* 8206C084h */ case   19:  		/* stwx R10, <#[R8 + R9]> */
		/* 8206C084h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8206C084h case   19:*/		return 0x8206C088;
		  /* 8206C088h */ case   20:  		/* bc 16, CR0_LT, -20 */
		/* 8206C088h case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206C074;  }
		/* 8206C088h case   20:*/		return 0x8206C08C;
	}
	return 0x8206C08C;
} // Block from 8206C038h-8206C08Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8206C08Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C08C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C08C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C08C);
		  /* 8206C08Ch */ case    0:  		/* lis R11, -32250 */
		/* 8206C08Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8206);
		/* 8206C08Ch case    0:*/		return 0x8206C090;
		  /* 8206C090h */ case    1:  		/* addi R7, R1, 368 */
		/* 8206C090h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x170);
		/* 8206C090h case    1:*/		return 0x8206C094;
		  /* 8206C094h */ case    2:  		/* addi R6, R11, 30624 */
		/* 8206C094h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x77A0);
		/* 8206C094h case    2:*/		return 0x8206C098;
		  /* 8206C098h */ case    3:  		/* li R5, 1 */
		/* 8206C098h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206C098h case    3:*/		return 0x8206C09C;
		  /* 8206C09Ch */ case    4:  		/* li R4, 0 */
		/* 8206C09Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206C09Ch case    4:*/		return 0x8206C0A0;
		  /* 8206C0A0h */ case    5:  		/* mr R3, R30 */
		/* 8206C0A0h case    5:*/		regs.R3 = regs.R30;
		/* 8206C0A0h case    5:*/		return 0x8206C0A4;
		  /* 8206C0A4h */ case    6:  		/* bl -9196 */
		/* 8206C0A4h case    6:*/		regs.LR = 0x8206C0A8; return 0x82069CB8;
		/* 8206C0A4h case    6:*/		return 0x8206C0A8;
		  /* 8206C0A8h */ case    7:  		/* lwz R11, <#[R30]> */
		/* 8206C0A8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206C0A8h case    7:*/		return 0x8206C0AC;
		  /* 8206C0ACh */ case    8:  		/* lwz R3, <#[R11 + 19896]> */
		/* 8206C0ACh case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00004DB8) );
		/* 8206C0ACh case    8:*/		return 0x8206C0B0;
		  /* 8206C0B0h */ case    9:  		/* cmpwi CR6, R3, 0 */
		/* 8206C0B0h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8206C0B0h case    9:*/		return 0x8206C0B4;
		  /* 8206C0B4h */ case   10:  		/* bc 12, CR6_EQ, 24 */
		/* 8206C0B4h case   10:*/		if ( regs.CR[6].eq ) { return 0x8206C0CC;  }
		/* 8206C0B4h case   10:*/		return 0x8206C0B8;
		  /* 8206C0B8h */ case   11:  		/* lwz R11, <#[R3]> */
		/* 8206C0B8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206C0B8h case   11:*/		return 0x8206C0BC;
		  /* 8206C0BCh */ case   12:  		/* addi R4, R1, 368 */
		/* 8206C0BCh case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x170);
		/* 8206C0BCh case   12:*/		return 0x8206C0C0;
		  /* 8206C0C0h */ case   13:  		/* lwz R11, <#[R11 + 16]> */
		/* 8206C0C0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8206C0C0h case   13:*/		return 0x8206C0C4;
		  /* 8206C0C4h */ case   14:  		/* mtspr CTR, R11 */
		/* 8206C0C4h case   14:*/		regs.CTR = regs.R11;
		/* 8206C0C4h case   14:*/		return 0x8206C0C8;
		  /* 8206C0C8h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 8206C0C8h case   15:*/		if ( 1 ) { regs.LR = 0x8206C0CC; return (uint32)regs.CTR; }
		/* 8206C0C8h case   15:*/		return 0x8206C0CC;
	}
	return 0x8206C0CC;
} // Block from 8206C08Ch-8206C0CCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206C0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C0CC);
		  /* 8206C0CCh */ case    0:  		/* lwz R11, <#[R30 + 88]> */
		/* 8206C0CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000058) );
		/* 8206C0CCh case    0:*/		return 0x8206C0D0;
		  /* 8206C0D0h */ case    1:  		/* rlwinm. R11, R11, 24, 26, 31 */
		/* 8206C0D0h case    1:*/		cpu::op::rlwinm<1,24,26,31>(regs,&regs.R11,regs.R11);
		/* 8206C0D0h case    1:*/		return 0x8206C0D4;
		  /* 8206C0D4h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8206C0D4h case    2:*/		if ( regs.CR[0].eq ) { return 0x8206C0E0;  }
		/* 8206C0D4h case    2:*/		return 0x8206C0D8;
		  /* 8206C0D8h */ case    3:  		/* stw R11, <#[R1 + 84]> */
		/* 8206C0D8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8206C0D8h case    3:*/		return 0x8206C0DC;
		  /* 8206C0DCh */ case    4:  		/* b 32 */
		/* 8206C0DCh case    4:*/		return 0x8206C0FC;
		/* 8206C0DCh case    4:*/		return 0x8206C0E0;
	}
	return 0x8206C0E0;
} // Block from 8206C0CCh-8206C0E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206C0E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C0E0);
		  /* 8206C0E0h */ case    0:  		/* lis R11, -32250 */
		/* 8206C0E0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8206);
		/* 8206C0E0h case    0:*/		return 0x8206C0E4;
		  /* 8206C0E4h */ case    1:  		/* addi R7, R1, 84 */
		/* 8206C0E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x54);
		/* 8206C0E4h case    1:*/		return 0x8206C0E8;
		  /* 8206C0E8h */ case    2:  		/* addi R6, R11, 31016 */
		/* 8206C0E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x7928);
		/* 8206C0E8h case    2:*/		return 0x8206C0EC;
		  /* 8206C0ECh */ case    3:  		/* li R5, 1 */
		/* 8206C0ECh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206C0ECh case    3:*/		return 0x8206C0F0;
		  /* 8206C0F0h */ case    4:  		/* li R4, 0 */
		/* 8206C0F0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206C0F0h case    4:*/		return 0x8206C0F4;
		  /* 8206C0F4h */ case    5:  		/* mr R3, R30 */
		/* 8206C0F4h case    5:*/		regs.R3 = regs.R30;
		/* 8206C0F4h case    5:*/		return 0x8206C0F8;
		  /* 8206C0F8h */ case    6:  		/* bl -9280 */
		/* 8206C0F8h case    6:*/		regs.LR = 0x8206C0FC; return 0x82069CB8;
		/* 8206C0F8h case    6:*/		return 0x8206C0FC;
	}
	return 0x8206C0FC;
} // Block from 8206C0E0h-8206C0FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206C0FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C0FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C0FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C0FC);
		  /* 8206C0FCh */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8206C0FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8206C0FCh case    0:*/		return 0x8206C100;
		  /* 8206C100h */ case    1:  		/* li R10, 0 */
		/* 8206C100h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8206C100h case    1:*/		return 0x8206C104;
		  /* 8206C104h */ case    2:  		/* lwz R9, <#[R1 + 84]> */
		/* 8206C104h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8206C104h case    2:*/		return 0x8206C108;
		  /* 8206C108h */ case    3:  		/* lis R8, -32250 */
		/* 8206C108h case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8206);
		/* 8206C108h case    3:*/		return 0x8206C10C;
		  /* 8206C10Ch */ case    4:  		/* addi R7, R1, 80 */
		/* 8206C10Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 8206C10Ch case    4:*/		return 0x8206C110;
		  /* 8206C110h */ case    5:  		/* rlwimi R11, R9, 8, 18, 23 */
		/* 8206C110h case    5:*/		cpu::op::rlwimi<0,8,18,23>(regs,&regs.R11,regs.R9);
		/* 8206C110h case    5:*/		return 0x8206C114;
		  /* 8206C114h */ case    6:  		/* addi R6, R8, 32080 */
		/* 8206C114h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R8,0x7D50);
		/* 8206C114h case    6:*/		return 0x8206C118;
		  /* 8206C118h */ case    7:  		/* stw R11, <#[R29 + 8]> */
		/* 8206C118h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8206C118h case    7:*/		return 0x8206C11C;
		  /* 8206C11Ch */ case    8:  		/* li R5, 1 */
		/* 8206C11Ch case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206C11Ch case    8:*/		return 0x8206C120;
		  /* 8206C120h */ case    9:  		/* stw R10, <#[R1 + 80]> */
		/* 8206C120h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8206C120h case    9:*/		return 0x8206C124;
		  /* 8206C124h */ case   10:  		/* li R4, 0 */
		/* 8206C124h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206C124h case   10:*/		return 0x8206C128;
		  /* 8206C128h */ case   11:  		/* mr R3, R30 */
		/* 8206C128h case   11:*/		regs.R3 = regs.R30;
		/* 8206C128h case   11:*/		return 0x8206C12C;
		  /* 8206C12Ch */ case   12:  		/* bl -9332 */
		/* 8206C12Ch case   12:*/		regs.LR = 0x8206C130; return 0x82069CB8;
		/* 8206C12Ch case   12:*/		return 0x8206C130;
		  /* 8206C130h */ case   13:  		/* lwz R10, <#[R1 + 80]> */
		/* 8206C130h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8206C130h case   13:*/		return 0x8206C134;
		  /* 8206C134h */ case   14:  		/* li R11, 1 */
		/* 8206C134h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206C134h case   14:*/		return 0x8206C138;
		  /* 8206C138h */ case   15:  		/* stw R10, <#[R29 + 28]> */
		/* 8206C138h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x0000001C) );
		/* 8206C138h case   15:*/		return 0x8206C13C;
		  /* 8206C13Ch */ case   16:  		/* lwz R10, <#[R1 + 80]> */
		/* 8206C13Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8206C13Ch case   16:*/		return 0x8206C140;
		  /* 8206C140h */ case   17:  		/* rlwinm. R9, R10, 0, 28, 28 */
		/* 8206C140h case   17:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R9,regs.R10);
		/* 8206C140h case   17:*/		return 0x8206C144;
		  /* 8206C144h */ case   18:  		/* bc 12, CR0_EQ, 12 */
		/* 8206C144h case   18:*/		if ( regs.CR[0].eq ) { return 0x8206C150;  }
		/* 8206C144h case   18:*/		return 0x8206C148;
		  /* 8206C148h */ case   19:  		/* li R11, 4 */
		/* 8206C148h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 8206C148h case   19:*/		return 0x8206C14C;
		  /* 8206C14Ch */ case   20:  		/* b 32 */
		/* 8206C14Ch case   20:*/		return 0x8206C16C;
		/* 8206C14Ch case   20:*/		return 0x8206C150;
	}
	return 0x8206C150;
} // Block from 8206C0FCh-8206C150h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8206C150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C150);
		  /* 8206C150h */ case    0:  		/* rlwinm. R9, R10, 0, 29, 29 */
		/* 8206C150h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R10);
		/* 8206C150h case    0:*/		return 0x8206C154;
		  /* 8206C154h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8206C154h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206C160;  }
		/* 8206C154h case    1:*/		return 0x8206C158;
		  /* 8206C158h */ case    2:  		/* li R11, 3 */
		/* 8206C158h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8206C158h case    2:*/		return 0x8206C15C;
		  /* 8206C15Ch */ case    3:  		/* b 16 */
		/* 8206C15Ch case    3:*/		return 0x8206C16C;
		/* 8206C15Ch case    3:*/		return 0x8206C160;
	}
	return 0x8206C160;
} // Block from 8206C150h-8206C160h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206C160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C160);
		  /* 8206C160h */ case    0:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 8206C160h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 8206C160h case    0:*/		return 0x8206C164;
		  /* 8206C164h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8206C164h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206C16C;  }
		/* 8206C164h case    1:*/		return 0x8206C168;
		  /* 8206C168h */ case    2:  		/* li R11, 2 */
		/* 8206C168h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8206C168h case    2:*/		return 0x8206C16C;
	}
	return 0x8206C16C;
} // Block from 8206C160h-8206C16Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206C16Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C16C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C16C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C16C);
		  /* 8206C16Ch */ case    0:  		/* lwz R10, <#[R29 + 8]> */
		/* 8206C16Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8206C16Ch case    0:*/		return 0x8206C170;
		  /* 8206C170h */ case    1:  		/* rlwimi R10, R11, 28, 1, 3 */
		/* 8206C170h case    1:*/		cpu::op::rlwimi<0,28,1,3>(regs,&regs.R10,regs.R11);
		/* 8206C170h case    1:*/		return 0x8206C174;
		  /* 8206C174h */ case    2:  		/* mr R11, R10 */
		/* 8206C174h case    2:*/		regs.R11 = regs.R10;
		/* 8206C174h case    2:*/		return 0x8206C178;
		  /* 8206C178h */ case    3:  		/* stw R10, <#[R29 + 8]> */
		/* 8206C178h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8206C178h case    3:*/		return 0x8206C17C;
		  /* 8206C17Ch */ case    4:  		/* lwz R10, <#[R1 + 80]> */
		/* 8206C17Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8206C17Ch case    4:*/		return 0x8206C180;
		  /* 8206C180h */ case    5:  		/* rlwimi R11, R10, 23, 4, 4 */
		/* 8206C180h case    5:*/		cpu::op::rlwimi<0,23,4,4>(regs,&regs.R11,regs.R10);
		/* 8206C180h case    5:*/		return 0x8206C184;
		  /* 8206C184h */ case    6:  		/* stw R11, <#[R29 + 8]> */
		/* 8206C184h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8206C184h case    6:*/		return 0x8206C188;
		  /* 8206C188h */ case    7:  		/* lwz R11, <#[R30]> */
		/* 8206C188h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206C188h case    7:*/		return 0x8206C18C;
		  /* 8206C18Ch */ case    8:  		/* lwz R11, <#[R11 + 19896]> */
		/* 8206C18Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB8) );
		/* 8206C18Ch case    8:*/		return 0x8206C190;
		  /* 8206C190h */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 8206C190h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206C190h case    9:*/		return 0x8206C194;
		  /* 8206C194h */ case   10:  		/* bc 12, CR6_EQ, 1156 */
		/* 8206C194h case   10:*/		if ( regs.CR[6].eq ) { return 0x8206C618;  }
		/* 8206C194h case   10:*/		return 0x8206C198;
		  /* 8206C198h */ case   11:  		/* lwz R31, <#[R28]> */
		/* 8206C198h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 8206C198h case   11:*/		return 0x8206C19C;
		  /* 8206C19Ch */ case   12:  		/* b 48 */
		/* 8206C19Ch case   12:*/		return 0x8206C1CC;
		/* 8206C19Ch case   12:*/		return 0x8206C1A0;
		  /* 8206C1A0h */ case   13:  		/* lwz R11, <#[R30]> */
		/* 8206C1A0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206C1A0h case   13:*/		return 0x8206C1A4;
		  /* 8206C1A4h */ case   14:  		/* lwz R10, <#[R31]> */
		/* 8206C1A4h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8206C1A4h case   14:*/		return 0x8206C1A8;
		  /* 8206C1A8h */ case   15:  		/* lbz R5, <#[R31]> */
		/* 8206C1A8h case   15:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000000) );
		/* 8206C1A8h case   15:*/		return 0x8206C1AC;
		  /* 8206C1ACh */ case   16:  		/* rlwinm R6, R10, 16, 28, 31 */
		/* 8206C1ACh case   16:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R6,regs.R10);
		/* 8206C1ACh case   16:*/		return 0x8206C1B0;
		  /* 8206C1B0h */ case   17:  		/* rlwinm R4, R10, 12, 28, 31 */
		/* 8206C1B0h case   17:*/		cpu::op::rlwinm<0,12,28,31>(regs,&regs.R4,regs.R10);
		/* 8206C1B0h case   17:*/		return 0x8206C1B4;
		  /* 8206C1B4h */ case   18:  		/* lwz R3, <#[R11 + 19896]> */
		/* 8206C1B4h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00004DB8) );
		/* 8206C1B4h case   18:*/		return 0x8206C1B8;
		  /* 8206C1B8h */ case   19:  		/* lwz R11, <#[R3]> */
		/* 8206C1B8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206C1B8h case   19:*/		return 0x8206C1BC;
		  /* 8206C1BCh */ case   20:  		/* lwz R11, <#[R11 + 24]> */
		/* 8206C1BCh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8206C1BCh case   20:*/		return 0x8206C1C0;
		  /* 8206C1C0h */ case   21:  		/* mtspr CTR, R11 */
		/* 8206C1C0h case   21:*/		regs.CTR = regs.R11;
		/* 8206C1C0h case   21:*/		return 0x8206C1C4;
		  /* 8206C1C4h */ case   22:  		/* bcctrl 20, CR0_LT */
		/* 8206C1C4h case   22:*/		if ( 1 ) { regs.LR = 0x8206C1C8; return (uint32)regs.CTR; }
		/* 8206C1C4h case   22:*/		return 0x8206C1C8;
		  /* 8206C1C8h */ case   23:  		/* addi R31, R31, 4 */
		/* 8206C1C8h case   23:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8206C1C8h case   23:*/		return 0x8206C1CC;
	}
	return 0x8206C1CC;
} // Block from 8206C16Ch-8206C1CCh (24 instructions)

//////////////////////////////////////////////////////
// Block at 8206C1CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C1CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C1CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C1CC);
		  /* 8206C1CCh */ case    0:  		/* lwz R10, <#[R28 + 4]> */
		/* 8206C1CCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 8206C1CCh case    0:*/		return 0x8206C1D0;
		  /* 8206C1D0h */ case    1:  		/* lwz R11, <#[R28]> */
		/* 8206C1D0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8206C1D0h case    1:*/		return 0x8206C1D4;
		  /* 8206C1D4h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8206C1D4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8206C1D4h case    2:*/		return 0x8206C1D8;
		  /* 8206C1D8h */ case    3:  		/* add R11, R10, R11 */
		/* 8206C1D8h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206C1D8h case    3:*/		return 0x8206C1DC;
		  /* 8206C1DCh */ case    4:  		/* cmplw CR6, R31, R11 */
		/* 8206C1DCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 8206C1DCh case    4:*/		return 0x8206C1E0;
		  /* 8206C1E0h */ case    5:  		/* bc 12, CR6_LT, -64 */
		/* 8206C1E0h case    5:*/		if ( regs.CR[6].lt ) { return 0x8206C1A0;  }
		/* 8206C1E0h case    5:*/		return 0x8206C1E4;
		  /* 8206C1E4h */ case    6:  		/* b 1076 */
		/* 8206C1E4h case    6:*/		return 0x8206C618;
		/* 8206C1E4h case    6:*/		return 0x8206C1E8;
	}
	return 0x8206C1E8;
} // Block from 8206C1CCh-8206C1E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206C1E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C1E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C1E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C1E8);
		  /* 8206C1E8h */ case    0:  		/* lwz R10, <#[R31 + 4]> */
		/* 8206C1E8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C1E8h case    0:*/		return 0x8206C1EC;
		  /* 8206C1ECh */ case    1:  		/* lwz R8, <#[R31]> */
		/* 8206C1ECh case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8206C1ECh case    1:*/		return 0x8206C1F0;
		  /* 8206C1F0h */ case    2:  		/* lwz R7, <#[R31 + 12]> */
		/* 8206C1F0h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206C1F0h case    2:*/		return 0x8206C1F4;
		  /* 8206C1F4h */ case    3:  		/* addi R11, R10, 36 */
		/* 8206C1F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x24);
		/* 8206C1F4h case    3:*/		return 0x8206C1F8;
		  /* 8206C1F8h */ case    4:  		/* add R10, R8, R10 */
		/* 8206C1F8h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8206C1F8h case    4:*/		return 0x8206C1FC;
		  /* 8206C1FCh */ case    5:  		/* stw R11, <#[R31 + 4]> */
		/* 8206C1FCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C1FCh case    5:*/		return 0x8206C200;
		  /* 8206C200h */ case    6:  		/* cmplw CR6, R11, R7 */
		/* 8206C200h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8206C200h case    6:*/		return 0x8206C204;
		  /* 8206C204h */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 8206C204h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8206C20C;  }
		/* 8206C204h case    7:*/		return 0x8206C208;
		  /* 8206C208h */ case    8:  		/* stw R11, <#[R31 + 12]> */
		/* 8206C208h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206C208h case    8:*/		return 0x8206C20C;
	}
	return 0x8206C20C;
} // Block from 8206C1E8h-8206C20Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206C20Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C20C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C20C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C20C);
		  /* 8206C20Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206C20Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C20Ch case    0:*/		return 0x8206C210;
		  /* 8206C210h */ case    1:  		/* mr R5, R26 */
		/* 8206C210h case    1:*/		regs.R5 = regs.R26;
		/* 8206C210h case    1:*/		return 0x8206C214;
		  /* 8206C214h */ case    2:  		/* mr R3, R30 */
		/* 8206C214h case    2:*/		regs.R3 = regs.R30;
		/* 8206C214h case    2:*/		return 0x8206C218;
		  /* 8206C218h */ case    3:  		/* subfc R9, R11, R9 */
		/* 8206C218h case    3:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8206C218h case    3:*/		return 0x8206C21C;
		  /* 8206C21Ch */ case    4:  		/* addze R8, R11 */
		/* 8206C21Ch case    4:*/		cpu::op::addze<0>(regs,&regs.R8,regs.R11);
		/* 8206C21Ch case    4:*/		return 0x8206C220;
		  /* 8206C220h */ case    5:  		/* subf R11, R8, R11 */
		/* 8206C220h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8206C220h case    5:*/		return 0x8206C224;
		  /* 8206C224h */ case    6:  		/* and R27, R11, R10 */
		/* 8206C224h case    6:*/		cpu::op::and<0>(regs,&regs.R27,regs.R11,regs.R10);
		/* 8206C224h case    6:*/		return 0x8206C228;
		  /* 8206C228h */ case    7:  		/* mr R4, R27 */
		/* 8206C228h case    7:*/		regs.R4 = regs.R27;
		/* 8206C228h case    7:*/		return 0x8206C22C;
		  /* 8206C22Ch */ case    8:  		/* bl -2644 */
		/* 8206C22Ch case    8:*/		regs.LR = 0x8206C230; return 0x8206B7D8;
		/* 8206C22Ch case    8:*/		return 0x8206C230;
		  /* 8206C230h */ case    9:  		/* lwz R11, <#[R30 + 284]> */
		/* 8206C230h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000011C) );
		/* 8206C230h case    9:*/		return 0x8206C234;
		  /* 8206C234h */ case   10:  		/* stw R11, <#[R27 + 24]> */
		/* 8206C234h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 8206C234h case   10:*/		return 0x8206C238;
		  /* 8206C238h */ case   11:  		/* lwz R11, <#[R30 + 296]> */
		/* 8206C238h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000128) );
		/* 8206C238h case   11:*/		return 0x8206C23C;
		  /* 8206C23Ch */ case   12:  		/* stw R11, <#[R27 + 28]> */
		/* 8206C23Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x0000001C) );
		/* 8206C23Ch case   12:*/		return 0x8206C240;
		  /* 8206C240h */ case   13:  		/* lwz R11, <#[R30 + 316]> */
		/* 8206C240h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000013C) );
		/* 8206C240h case   13:*/		return 0x8206C244;
		  /* 8206C244h */ case   14:  		/* stw R11, <#[R27 + 32]> */
		/* 8206C244h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000020) );
		/* 8206C244h case   14:*/		return 0x8206C248;
		  /* 8206C248h */ case   15:  		/* lwz R10, <#[R31 + 4]> */
		/* 8206C248h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C248h case   15:*/		return 0x8206C24C;
		  /* 8206C24Ch */ case   16:  		/* lwz R8, <#[R31 + 12]> */
		/* 8206C24Ch case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206C24Ch case   16:*/		return 0x8206C250;
		  /* 8206C250h */ case   17:  		/* lwz R9, <#[R31]> */
		/* 8206C250h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8206C250h case   17:*/		return 0x8206C254;
		  /* 8206C254h */ case   18:  		/* lwz R11, <#[R30 + 284]> */
		/* 8206C254h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000011C) );
		/* 8206C254h case   18:*/		return 0x8206C258;
		  /* 8206C258h */ case   19:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 8206C258h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8206C258h case   19:*/		return 0x8206C25C;
		  /* 8206C25Ch */ case   20:  		/* add R11, R10, R5 */
		/* 8206C25Ch case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R5);
		/* 8206C25Ch case   20:*/		return 0x8206C260;
		  /* 8206C260h */ case   21:  		/* add R10, R9, R10 */
		/* 8206C260h case   21:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8206C260h case   21:*/		return 0x8206C264;
		  /* 8206C264h */ case   22:  		/* stw R11, <#[R31 + 4]> */
		/* 8206C264h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C264h case   22:*/		return 0x8206C268;
		  /* 8206C268h */ case   23:  		/* cmplw CR6, R11, R8 */
		/* 8206C268h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8206C268h case   23:*/		return 0x8206C26C;
		  /* 8206C26Ch */ case   24:  		/* bc 4, CR6_GT, 8 */
		/* 8206C26Ch case   24:*/		if ( !regs.CR[6].gt ) { return 0x8206C274;  }
		/* 8206C26Ch case   24:*/		return 0x8206C270;
		  /* 8206C270h */ case   25:  		/* stw R11, <#[R31 + 12]> */
		/* 8206C270h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206C270h case   25:*/		return 0x8206C274;
	}
	return 0x8206C274;
} // Block from 8206C20Ch-8206C274h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8206C274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C274);
		  /* 8206C274h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206C274h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C274h case    0:*/		return 0x8206C278;
		  /* 8206C278h */ case    1:  		/* lwz R9, <#[R31 + 8]> */
		/* 8206C278h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8206C278h case    1:*/		return 0x8206C27C;
		  /* 8206C27Ch */ case    2:  		/* lwz R4, <#[R30 + 280]> */
		/* 8206C27Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000118) );
		/* 8206C27Ch case    2:*/		return 0x8206C280;
		  /* 8206C280h */ case    3:  		/* subfc R9, R11, R9 */
		/* 8206C280h case    3:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8206C280h case    3:*/		return 0x8206C284;
		  /* 8206C284h */ case    4:  		/* addze R8, R11 */
		/* 8206C284h case    4:*/		cpu::op::addze<0>(regs,&regs.R8,regs.R11);
		/* 8206C284h case    4:*/		return 0x8206C288;
		  /* 8206C288h */ case    5:  		/* subf R11, R8, R11 */
		/* 8206C288h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8206C288h case    5:*/		return 0x8206C28C;
		  /* 8206C28Ch */ case    6:  		/* and R3, R11, R10 */
		/* 8206C28Ch case    6:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8206C28Ch case    6:*/		return 0x8206C290;
		  /* 8206C290h */ case    7:  		/* bl 153376 */
		/* 8206C290h case    7:*/		regs.LR = 0x8206C294; return 0x820919B0;
		/* 8206C290h case    7:*/		return 0x8206C294;
		  /* 8206C294h */ case    8:  		/* lwz R11, <#[R30 + 296]> */
		/* 8206C294h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000128) );
		/* 8206C294h case    8:*/		return 0x8206C298;
		  /* 8206C298h */ case    9:  		/* lwz R10, <#[R31 + 4]> */
		/* 8206C298h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C298h case    9:*/		return 0x8206C29C;
		  /* 8206C29Ch */ case   10:  		/* lwz R9, <#[R31]> */
		/* 8206C29Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8206C29Ch case   10:*/		return 0x8206C2A0;
		  /* 8206C2A0h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206C2A0h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206C2A0h case   11:*/		return 0x8206C2A4;
		  /* 8206C2A4h */ case   12:  		/* add R7, R9, R10 */
		/* 8206C2A4h case   12:*/		cpu::op::add<0>(regs,&regs.R7,regs.R9,regs.R10);
		/* 8206C2A4h case   12:*/		return 0x8206C2A8;
		  /* 8206C2A8h */ case   13:  		/* add R11, R11, R10 */
		/* 8206C2A8h case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206C2A8h case   13:*/		return 0x8206C2AC;
		  /* 8206C2ACh */ case   14:  		/* stw R11, <#[R31 + 4]> */
		/* 8206C2ACh case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C2ACh case   14:*/		return 0x8206C2B0;
		  /* 8206C2B0h */ case   15:  		/* lwz R9, <#[R31 + 12]> */
		/* 8206C2B0h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206C2B0h case   15:*/		return 0x8206C2B4;
		  /* 8206C2B4h */ case   16:  		/* cmplw CR6, R11, R9 */
		/* 8206C2B4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8206C2B4h case   16:*/		return 0x8206C2B8;
		  /* 8206C2B8h */ case   17:  		/* bc 4, CR6_GT, 8 */
		/* 8206C2B8h case   17:*/		if ( !regs.CR[6].gt ) { return 0x8206C2C0;  }
		/* 8206C2B8h case   17:*/		return 0x8206C2BC;
		  /* 8206C2BCh */ case   18:  		/* stw R11, <#[R31 + 12]> */
		/* 8206C2BCh case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206C2BCh case   18:*/		return 0x8206C2C0;
	}
	return 0x8206C2C0;
} // Block from 8206C274h-8206C2C0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206C2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C2C0);
		  /* 8206C2C0h */ case    0:  		/* lwz R6, <#[R31 + 4]> */
		/* 8206C2C0h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C2C0h case    0:*/		return 0x8206C2C4;
		  /* 8206C2C4h */ case    1:  		/* li R5, 12 */
		/* 8206C2C4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0xC);
		/* 8206C2C4h case    1:*/		return 0x8206C2C8;
		  /* 8206C2C8h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8206C2C8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8206C2C8h case    2:*/		return 0x8206C2CC;
		  /* 8206C2CCh */ case    3:  		/* addi R11, R30, 292 */
		/* 8206C2CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x124);
		/* 8206C2CCh case    3:*/		return 0x8206C2D0;
		  /* 8206C2D0h */ case    4:  		/* lwz R9, <#[R30 + 296]> */
		/* 8206C2D0h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000128) );
		/* 8206C2D0h case    4:*/		return 0x8206C2D4;
		  /* 8206C2D4h */ case    5:  		/* subfc R4, R6, R10 */
		/* 8206C2D4h case    5:*/		cpu::op::subfc<0>(regs,&regs.R4,regs.R6,regs.R10);
		/* 8206C2D4h case    5:*/		return 0x8206C2D8;
		  /* 8206C2D8h */ case    6:  		/* lwz R8, <#[R30 + 292]> */
		/* 8206C2D8h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000124) );
		/* 8206C2D8h case    6:*/		return 0x8206C2DC;
		  /* 8206C2DCh */ case    7:  		/* lwz R3, <#[R30 + 260]> */
		/* 8206C2DCh case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000104) );
		/* 8206C2DCh case    7:*/		return 0x8206C2E0;
		  /* 8206C2E0h */ case    8:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8206C2E0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8206C2E0h case    8:*/		return 0x8206C2E4;
		  /* 8206C2E4h */ case    9:  		/* lwz R29, <#[R30 + 256]> */
		/* 8206C2E4h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000100) );
		/* 8206C2E4h case    9:*/		return 0x8206C2E8;
		  /* 8206C2E8h */ case   10:  		/* addze R28, R6 */
		/* 8206C2E8h case   10:*/		cpu::op::addze<0>(regs,&regs.R28,regs.R6);
		/* 8206C2E8h case   10:*/		return 0x8206C2EC;
		  /* 8206C2ECh */ case   11:  		/* extsw R10, R8 */
		/* 8206C2ECh case   11:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R8);
		/* 8206C2ECh case   11:*/		return 0x8206C2F0;
		  /* 8206C2F0h */ case   12:  		/* subf R4, R28, R6 */
		/* 8206C2F0h case   12:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R28,regs.R6);
		/* 8206C2F0h case   12:*/		return 0x8206C2F4;
		  /* 8206C2F4h */ case   13:  		/* subf R3, R29, R3 */
		/* 8206C2F4h case   13:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R29,regs.R3);
		/* 8206C2F4h case   13:*/		return 0x8206C2F8;
		  /* 8206C2F8h */ case   14:  		/* add R9, R9, R8 */
		/* 8206C2F8h case   14:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8206C2F8h case   14:*/		return 0x8206C2FC;
		  /* 8206C2FCh */ case   15:  		/* divw R6, R3, R5 */
		/* 8206C2FCh case   15:*/		cpu::op::divw<0>(regs,&regs.R6,regs.R3,regs.R5);
		/* 8206C2FCh case   15:*/		return 0x8206C300;
		  /* 8206C300h */ case   16:  		/* and R7, R4, R7 */
		/* 8206C300h case   16:*/		cpu::op::and<0>(regs,&regs.R7,regs.R4,regs.R7);
		/* 8206C300h case   16:*/		return 0x8206C304;
		  /* 8206C304h */ case   17:  		/* cmplw CR6, R10, R9 */
		/* 8206C304h case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8206C304h case   17:*/		return 0x8206C308;
		  /* 8206C308h */ case   18:  		/* bc 4, CR6_LT, 52 */
		/* 8206C308h case   18:*/		if ( !regs.CR[6].lt ) { return 0x8206C33C;  }
		/* 8206C308h case   18:*/		return 0x8206C30C;
		  /* 8206C30Ch */ case   19:  		/* addi R8, R7, -4 */
		/* 8206C30Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R7,0xFFFFFFFC);
		/* 8206C30Ch case   19:*/		return 0x8206C310;
		  /* 8206C310h */ case   20:  		/* lwz R9, <#[R10]> */
		/* 8206C310h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8206C310h case   20:*/		return 0x8206C314;
		  /* 8206C314h */ case   21:  		/* addi R10, R10, 4 */
		/* 8206C314h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8206C314h case   21:*/		return 0x8206C318;
		  /* 8206C318h */ case   22:  		/* add R7, R9, R6 */
		/* 8206C318h case   22:*/		cpu::op::add<0>(regs,&regs.R7,regs.R9,regs.R6);
		/* 8206C318h case   22:*/		return 0x8206C31C;
		  /* 8206C31Ch */ case   23:  		/* rlwimi R7, R9, 0, 0, 19 */
		/* 8206C31Ch case   23:*/		cpu::op::rlwimi<0,0,0,19>(regs,&regs.R7,regs.R9);
		/* 8206C31Ch case   23:*/		return 0x8206C320;
		  /* 8206C320h */ case   24:  		/* stwu R7, <#[R8 + 4]> */
		/* 8206C320h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 8206C320h case   24:*/		return 0x8206C324;
		  /* 8206C324h */ case   25:  		/* lwz R9, <#[R11 + 4]> */
		/* 8206C324h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8206C324h case   25:*/		return 0x8206C328;
		  /* 8206C328h */ case   26:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8206C328h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8206C328h case   26:*/		return 0x8206C32C;
		  /* 8206C32Ch */ case   27:  		/* lwz R7, <#[R11]> */
		/* 8206C32Ch case   27:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8206C32Ch case   27:*/		return 0x8206C330;
	}
	return 0x8206C330;
} // Block from 8206C2C0h-8206C330h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8206C330h
// Function 'XMicrocodeShaderForEachInstruction'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C330);
		  /* 8206C330h */ case    0:  		/* add R9, R9, R7 */
		/* 8206C330h case    0:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8206C330h case    0:*/		return 0x8206C334;
		  /* 8206C334h */ case    1:  		/* cmplw CR6, R10, R9 */
		/* 8206C334h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8206C334h case    1:*/		return 0x8206C338;
		  /* 8206C338h */ case    2:  		/* bc 12, CR6_LT, -40 */
		/* 8206C338h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206C310;  }
		/* 8206C338h case    2:*/		return 0x8206C33C;
	}
	return 0x8206C33C;
} // Block from 8206C330h-8206C33Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206C33Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C33C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C33C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C33C);
		  /* 8206C33Ch */ case    0:  		/* lwz R11, <#[R30 + 308]> */
		/* 8206C33Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000134) );
		/* 8206C33Ch case    0:*/		return 0x8206C340;
		  /* 8206C340h */ case    1:  		/* li R9, 0 */
		/* 8206C340h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8206C340h case    1:*/		return 0x8206C344;
		  /* 8206C344h */ case    2:  		/* lwz R8, <#[R30 + 304]> */
		/* 8206C344h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000130) );
		/* 8206C344h case    2:*/		return 0x8206C348;
		  /* 8206C348h */ case    3:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 8206C348h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 8206C348h case    3:*/		return 0x8206C34C;
		  /* 8206C34Ch */ case    4:  		/* extsw R11, R8 */
		/* 8206C34Ch case    4:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R8);
		/* 8206C34Ch case    4:*/		return 0x8206C350;
		  /* 8206C350h */ case    5:  		/* add R10, R10, R8 */
		/* 8206C350h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8206C350h case    5:*/		return 0x8206C354;
		  /* 8206C354h */ case    6:  		/* b 52 */
		/* 8206C354h case    6:*/		return 0x8206C388;
		/* 8206C354h case    6:*/		return 0x8206C358;
		  /* 8206C358h */ case    7:  		/* lwz R8, <#[R11]> */
		/* 8206C358h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8206C358h case    7:*/		return 0x8206C35C;
		  /* 8206C35Ch */ case    8:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8206C35Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8206C35Ch case    8:*/		return 0x8206C360;
		  /* 8206C360h */ case    9:  		/* addi R7, R1, 100 */
		/* 8206C360h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x64);
		/* 8206C360h case    9:*/		return 0x8206C364;
		  /* 8206C364h */ case   10:  		/* mr R6, R8 */
		/* 8206C364h case   10:*/		regs.R6 = regs.R8;
		/* 8206C364h case   10:*/		return 0x8206C368;
		  /* 8206C368h */ case   11:  		/* rlwinm R5, R8, 0, 16, 19 */
		/* 8206C368h case   11:*/		cpu::op::rlwinm<0,0,16,19>(regs,&regs.R5,regs.R8);
		/* 8206C368h case   11:*/		return 0x8206C36C;
		  /* 8206C36Ch */ case   12:  		/* rlwimi R6, R8, 12, 0, 19 */
		/* 8206C36Ch case   12:*/		cpu::op::rlwimi<0,12,0,19>(regs,&regs.R6,regs.R8);
		/* 8206C36Ch case   12:*/		return 0x8206C370;
		  /* 8206C370h */ case   13:  		/* addi R11, R11, 4 */
		/* 8206C370h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206C370h case   13:*/		return 0x8206C374;
		  /* 8206C374h */ case   14:  		/* rlwinm R8, R6, 12, 0, 11 */
		/* 8206C374h case   14:*/		cpu::op::rlwinm<0,12,0,11>(regs,&regs.R8,regs.R6);
		/* 8206C374h case   14:*/		return 0x8206C378;
		  /* 8206C378h */ case   15:  		/* or R8, R8, R5 */
		/* 8206C378h case   15:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R5);
		/* 8206C378h case   15:*/		return 0x8206C37C;
		  /* 8206C37Ch */ case   16:  		/* stwx R8, <#[R9 + R7]> */
		/* 8206C37Ch case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 8206C37Ch case   16:*/		return 0x8206C380;
		  /* 8206C380h */ case   17:  		/* lwz R9, <#[R1 + 96]> */
		/* 8206C380h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 8206C380h case   17:*/		return 0x8206C384;
		  /* 8206C384h */ case   18:  		/* addi R9, R9, 1 */
		/* 8206C384h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8206C384h case   18:*/		return 0x8206C388;
	}
	return 0x8206C388;
} // Block from 8206C33Ch-8206C388h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206C388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C388);
		  /* 8206C388h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 8206C388h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8206C388h case    0:*/		return 0x8206C38C;
		  /* 8206C38Ch */ case    1:  		/* stw R9, <#[R1 + 96]> */
		/* 8206C38Ch case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 8206C38Ch case    1:*/		return 0x8206C390;
		  /* 8206C390h */ case    2:  		/* bc 12, CR6_LT, -56 */
		/* 8206C390h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206C358;  }
		/* 8206C390h case    2:*/		return 0x8206C394;
		  /* 8206C394h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 8206C394h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206C394h case    3:*/		return 0x8206C398;
		  /* 8206C398h */ case    4:  		/* addi R3, R1, 96 */
		/* 8206C398h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8206C398h case    4:*/		return 0x8206C39C;
		  /* 8206C39Ch */ case    5:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206C39Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206C39Ch case    5:*/		return 0x8206C3A0;
		  /* 8206C3A0h */ case    6:  		/* rlwinm R4, R11, 29, 31, 31 */
		/* 8206C3A0h case    6:*/		cpu::op::rlwinm<0,29,31,31>(regs,&regs.R4,regs.R11);
		/* 8206C3A0h case    6:*/		return 0x8206C3A4;
		  /* 8206C3A4h */ case    7:  		/* bl -11964 */
		/* 8206C3A4h case    7:*/		regs.LR = 0x8206C3A8; return 0x820694E8;
		/* 8206C3A4h case    7:*/		return 0x8206C3A8;
		  /* 8206C3A8h */ case    8:  		/* lwz R11, <#[R30 + 308]> */
		/* 8206C3A8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000134) );
		/* 8206C3A8h case    8:*/		return 0x8206C3AC;
		  /* 8206C3ACh */ case    9:  		/* lwz R10, <#[R31 + 4]> */
		/* 8206C3ACh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C3ACh case    9:*/		return 0x8206C3B0;
		  /* 8206C3B0h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206C3B0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206C3B0h case   10:*/		return 0x8206C3B4;
		  /* 8206C3B4h */ case   11:  		/* lwz R9, <#[R31]> */
		/* 8206C3B4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8206C3B4h case   11:*/		return 0x8206C3B8;
		  /* 8206C3B8h */ case   12:  		/* lwz R8, <#[R31 + 12]> */
		/* 8206C3B8h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206C3B8h case   12:*/		return 0x8206C3BC;
		  /* 8206C3BCh */ case   13:  		/* add R11, R11, R10 */
		/* 8206C3BCh case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206C3BCh case   13:*/		return 0x8206C3C0;
		  /* 8206C3C0h */ case   14:  		/* add R9, R9, R10 */
		/* 8206C3C0h case   14:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8206C3C0h case   14:*/		return 0x8206C3C4;
		  /* 8206C3C4h */ case   15:  		/* stw R11, <#[R31 + 4]> */
		/* 8206C3C4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C3C4h case   15:*/		return 0x8206C3C8;
		  /* 8206C3C8h */ case   16:  		/* cmplw CR6, R11, R8 */
		/* 8206C3C8h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8206C3C8h case   16:*/		return 0x8206C3CC;
		  /* 8206C3CCh */ case   17:  		/* bc 4, CR6_GT, 8 */
		/* 8206C3CCh case   17:*/		if ( !regs.CR[6].gt ) { return 0x8206C3D4;  }
		/* 8206C3CCh case   17:*/		return 0x8206C3D0;
		  /* 8206C3D0h */ case   18:  		/* stw R11, <#[R31 + 12]> */
		/* 8206C3D0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206C3D0h case   18:*/		return 0x8206C3D4;
	}
	return 0x8206C3D4;
} // Block from 8206C388h-8206C3D4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206C3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C3D4);
		  /* 8206C3D4h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206C3D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C3D4h case    0:*/		return 0x8206C3D8;
		  /* 8206C3D8h */ case    1:  		/* li R10, 0 */
		/* 8206C3D8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8206C3D8h case    1:*/		return 0x8206C3DC;
		  /* 8206C3DCh */ case    2:  		/* lwz R8, <#[R31 + 8]> */
		/* 8206C3DCh case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 8206C3DCh case    2:*/		return 0x8206C3E0;
		  /* 8206C3E0h */ case    3:  		/* lwz R7, <#[R30 + 308]> */
		/* 8206C3E0h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000134) );
		/* 8206C3E0h case    3:*/		return 0x8206C3E4;
		  /* 8206C3E4h */ case    4:  		/* subfc R8, R11, R8 */
		/* 8206C3E4h case    4:*/		cpu::op::subfc<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 8206C3E4h case    4:*/		return 0x8206C3E8;
		  /* 8206C3E8h */ case    5:  		/* cmplwi CR6, R7, 0 */
		/* 8206C3E8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8206C3E8h case    5:*/		return 0x8206C3EC;
		  /* 8206C3ECh */ case    6:  		/* addze R7, R11 */
		/* 8206C3ECh case    6:*/		cpu::op::addze<0>(regs,&regs.R7,regs.R11);
		/* 8206C3ECh case    6:*/		return 0x8206C3F0;
		  /* 8206C3F0h */ case    7:  		/* subf R11, R7, R11 */
		/* 8206C3F0h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8206C3F0h case    7:*/		return 0x8206C3F4;
		  /* 8206C3F4h */ case    8:  		/* and R28, R11, R9 */
		/* 8206C3F4h case    8:*/		cpu::op::and<0>(regs,&regs.R28,regs.R11,regs.R9);
		/* 8206C3F4h case    8:*/		return 0x8206C3F8;
		  /* 8206C3F8h */ case    9:  		/* bc 4, CR6_GT, 56 */
		/* 8206C3F8h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8206C430;  }
		/* 8206C3F8h case    9:*/		return 0x8206C3FC;
		  /* 8206C3FCh */ case   10:  		/* addi R9, R1, 96 */
		/* 8206C3FCh case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 8206C3FCh case   10:*/		return 0x8206C400;
		  /* 8206C400h */ case   11:  		/* addi R8, R28, -4 */
		/* 8206C400h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R28,0xFFFFFFFC);
		/* 8206C400h case   11:*/		return 0x8206C404;
		  /* 8206C404h */ case   12:  		/* lwzu R11, <#[R9 + 4]> */
		/* 8206C404h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8206C404h case   12:*/		return 0x8206C408;
		  /* 8206C408h */ case   13:  		/* addi R10, R10, 1 */
		/* 8206C408h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8206C408h case   13:*/		return 0x8206C40C;
		  /* 8206C40Ch */ case   14:  		/* mr R7, R11 */
		/* 8206C40Ch case   14:*/		regs.R7 = regs.R11;
		/* 8206C40Ch case   14:*/		return 0x8206C410;
		  /* 8206C410h */ case   15:  		/* mr R6, R11 */
		/* 8206C410h case   15:*/		regs.R6 = regs.R11;
		/* 8206C410h case   15:*/		return 0x8206C414;
		  /* 8206C414h */ case   16:  		/* rlwimi R7, R11, 16, 16, 31 */
		/* 8206C414h case   16:*/		cpu::op::rlwimi<0,16,16,31>(regs,&regs.R7,regs.R11);
		/* 8206C414h case   16:*/		return 0x8206C418;
		  /* 8206C418h */ case   17:  		/* rlwimi R6, R7, 24, 20, 31 */
		/* 8206C418h case   17:*/		cpu::op::rlwimi<0,24,20,31>(regs,&regs.R6,regs.R7);
		/* 8206C418h case   17:*/		return 0x8206C41C;
		  /* 8206C41Ch */ case   18:  		/* rlwinm R11, R6, 0, 16, 31 */
		/* 8206C41Ch case   18:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R6);
		/* 8206C41Ch case   18:*/		return 0x8206C420;
		  /* 8206C420h */ case   19:  		/* stwu R11, <#[R8 + 4]> */
		/* 8206C420h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 8206C420h case   19:*/		return 0x8206C424;
		  /* 8206C424h */ case   20:  		/* lwz R11, <#[R30 + 308]> */
		/* 8206C424h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000134) );
		/* 8206C424h case   20:*/		return 0x8206C428;
		  /* 8206C428h */ case   21:  		/* cmplw CR6, R10, R11 */
		/* 8206C428h case   21:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8206C428h case   21:*/		return 0x8206C42C;
		  /* 8206C42Ch */ case   22:  		/* bc 12, CR6_LT, -40 */
		/* 8206C42Ch case   22:*/		if ( regs.CR[6].lt ) { return 0x8206C404;  }
		/* 8206C42Ch case   22:*/		return 0x8206C430;
	}
	return 0x8206C430;
} // Block from 8206C3D4h-8206C430h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8206C430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C430);
		  /* 8206C430h */ case    0:  		/* li R10, 64 */
		/* 8206C430h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x40);
		/* 8206C430h case    0:*/		return 0x8206C434;
		  /* 8206C434h */ case    1:  		/* addi R9, R1, 620 */
		/* 8206C434h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x26C);
		/* 8206C434h case    1:*/		return 0x8206C438;
		  /* 8206C438h */ case    2:  		/* li R11, 0 */
		/* 8206C438h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206C438h case    2:*/		return 0x8206C43C;
		  /* 8206C43Ch */ case    3:  		/* mtspr CTR, R10 */
		/* 8206C43Ch case    3:*/		regs.CTR = regs.R10;
		/* 8206C43Ch case    3:*/		return 0x8206C440;
		  /* 8206C440h */ case    4:  		/* stwu R11, <#[R9 + 4]> */
		/* 8206C440h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8206C440h case    4:*/		return 0x8206C444;
		  /* 8206C444h */ case    5:  		/* addi R11, R11, 1 */
		/* 8206C444h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206C444h case    5:*/		return 0x8206C448;
		  /* 8206C448h */ case    6:  		/* bc 16, CR0_LT, -8 */
		/* 8206C448h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206C440;  }
		/* 8206C448h case    6:*/		return 0x8206C44C;
		  /* 8206C44Ch */ case    7:  		/* lwz R11, <#[R1 + 96]> */
		/* 8206C44Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8206C44Ch case    7:*/		return 0x8206C450;
		  /* 8206C450h */ case    8:  		/* addi R10, R1, 100 */
		/* 8206C450h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x64);
		/* 8206C450h case    8:*/		return 0x8206C454;
		  /* 8206C454h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 8206C454h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206C454h case    9:*/		return 0x8206C458;
		  /* 8206C458h */ case   10:  		/* bc 12, CR6_EQ, 36 */
		/* 8206C458h case   10:*/		if ( regs.CR[6].eq ) { return 0x8206C47C;  }
		/* 8206C458h case   10:*/		return 0x8206C45C;
		  /* 8206C45Ch */ case   11:  		/* mtspr CTR, R11 */
		/* 8206C45Ch case   11:*/		regs.CTR = regs.R11;
		/* 8206C45Ch case   11:*/		return 0x8206C460;
		  /* 8206C460h */ case   12:  		/* addi R11, R10, -4 */
		/* 8206C460h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFC);
		/* 8206C460h case   12:*/		return 0x8206C464;
		  /* 8206C464h */ case   13:  		/* lwzu R10, <#[R11 + 4]> */
		/* 8206C464h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206C464h case   13:*/		return 0x8206C468;
		  /* 8206C468h */ case   14:  		/* addi R9, R1, 624 */
		/* 8206C468h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x270);
		/* 8206C468h case   14:*/		return 0x8206C46C;
		  /* 8206C46Ch */ case   15:  		/* rlwinm R8, R10, 14, 26, 29 */
		/* 8206C46Ch case   15:*/		cpu::op::rlwinm<0,14,26,29>(regs,&regs.R8,regs.R10);
		/* 8206C46Ch case   15:*/		return 0x8206C470;
		  /* 8206C470h */ case   16:  		/* rlwinm R10, R10, 16, 28, 31 */
		/* 8206C470h case   16:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R10,regs.R10);
		/* 8206C470h case   16:*/		return 0x8206C474;
		  /* 8206C474h */ case   17:  		/* stwx R10, <#[R8 + R9]> */
		/* 8206C474h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8206C474h case   17:*/		return 0x8206C478;
		  /* 8206C478h */ case   18:  		/* bc 16, CR0_LT, -20 */
		/* 8206C478h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206C464;  }
		/* 8206C478h case   18:*/		return 0x8206C47C;
	}
	return 0x8206C47C;
} // Block from 8206C430h-8206C47Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206C47Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C47C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C47C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C47C);
		  /* 8206C47Ch */ case    0:  		/* lis R11, -32250 */
		/* 8206C47Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8206);
		/* 8206C47Ch case    0:*/		return 0x8206C480;
		  /* 8206C480h */ case    1:  		/* addi R7, R1, 624 */
		/* 8206C480h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x270);
		/* 8206C480h case    1:*/		return 0x8206C484;
		  /* 8206C484h */ case    2:  		/* addi R6, R11, 30968 */
		/* 8206C484h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x78F8);
		/* 8206C484h case    2:*/		return 0x8206C488;
		  /* 8206C488h */ case    3:  		/* li R5, 1 */
		/* 8206C488h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206C488h case    3:*/		return 0x8206C48C;
		  /* 8206C48Ch */ case    4:  		/* li R4, 0 */
		/* 8206C48Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206C48Ch case    4:*/		return 0x8206C490;
		  /* 8206C490h */ case    5:  		/* mr R3, R30 */
		/* 8206C490h case    5:*/		regs.R3 = regs.R30;
		/* 8206C490h case    5:*/		return 0x8206C494;
		  /* 8206C494h */ case    6:  		/* bl -10204 */
		/* 8206C494h case    6:*/		regs.LR = 0x8206C498; return 0x82069CB8;
		/* 8206C494h case    6:*/		return 0x8206C498;
		  /* 8206C498h */ case    7:  		/* mr R4, R28 */
		/* 8206C498h case    7:*/		regs.R4 = regs.R28;
		/* 8206C498h case    7:*/		return 0x8206C49C;
		  /* 8206C49Ch */ case    8:  		/* mr R3, R30 */
		/* 8206C49Ch case    8:*/		regs.R3 = regs.R30;
		/* 8206C49Ch case    8:*/		return 0x8206C4A0;
		  /* 8206C4A0h */ case    9:  		/* bl -3520 */
		/* 8206C4A0h case    9:*/		regs.LR = 0x8206C4A4; return 0x8206B6E0;
		/* 8206C4A0h case    9:*/		return 0x8206C4A4;
		  /* 8206C4A4h */ case   10:  		/* lwz R11, <#[R30 + 316]> */
		/* 8206C4A4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000013C) );
		/* 8206C4A4h case   10:*/		return 0x8206C4A8;
	}
	return 0x8206C4A8;
} // Block from 8206C47Ch-8206C4A8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206C4A8h
// Function '?MicrocodeEnumerateLiterals@D3D@@YAJPBXPAXP6AJ1KKK0@ZK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C4A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C4A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C4A8);
		  /* 8206C4A8h */ case    0:  		/* lwz R10, <#[R31 + 4]> */
		/* 8206C4A8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C4A8h case    0:*/		return 0x8206C4AC;
		  /* 8206C4ACh */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206C4ACh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206C4ACh case    1:*/		return 0x8206C4B0;
		  /* 8206C4B0h */ case    2:  		/* lwz R9, <#[R31]> */
		/* 8206C4B0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8206C4B0h case    2:*/		return 0x8206C4B4;
		  /* 8206C4B4h */ case    3:  		/* lwz R8, <#[R31 + 12]> */
		/* 8206C4B4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206C4B4h case    3:*/		return 0x8206C4B8;
		  /* 8206C4B8h */ case    4:  		/* add R11, R11, R10 */
		/* 8206C4B8h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206C4B8h case    4:*/		return 0x8206C4BC;
		  /* 8206C4BCh */ case    5:  		/* add R10, R9, R10 */
		/* 8206C4BCh case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8206C4BCh case    5:*/		return 0x8206C4C0;
		  /* 8206C4C0h */ case    6:  		/* stw R11, <#[R31 + 4]> */
		/* 8206C4C0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C4C0h case    6:*/		return 0x8206C4C4;
		  /* 8206C4C4h */ case    7:  		/* cmplw CR6, R11, R8 */
		/* 8206C4C4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8206C4C4h case    7:*/		return 0x8206C4C8;
		  /* 8206C4C8h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 8206C4C8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8206C4D0;  }
		/* 8206C4C8h case    8:*/		return 0x8206C4CC;
		  /* 8206C4CCh */ case    9:  		/* stw R11, <#[R31 + 12]> */
		/* 8206C4CCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206C4CCh case    9:*/		return 0x8206C4D0;
	}
	return 0x8206C4D0;
} // Block from 8206C4A8h-8206C4D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206C4D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C4D0);
		  /* 8206C4D0h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206C4D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C4D0h case    0:*/		return 0x8206C4D4;
		  /* 8206C4D4h */ case    1:  		/* li R5, 112 */
		/* 8206C4D4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x70);
		/* 8206C4D4h case    1:*/		return 0x8206C4D8;
		  /* 8206C4D8h */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 8206C4D8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 8206C4D8h case    2:*/		return 0x8206C4DC;
		  /* 8206C4DCh */ case    3:  		/* li R4, 0 */
		/* 8206C4DCh case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206C4DCh case    3:*/		return 0x8206C4E0;
		  /* 8206C4E0h */ case    4:  		/* addi R3, R1, 256 */
		/* 8206C4E0h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x100);
		/* 8206C4E0h case    4:*/		return 0x8206C4E4;
		  /* 8206C4E4h */ case    5:  		/* subfc R9, R11, R9 */
		/* 8206C4E4h case    5:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8206C4E4h case    5:*/		return 0x8206C4E8;
		  /* 8206C4E8h */ case    6:  		/* addze R8, R11 */
		/* 8206C4E8h case    6:*/		cpu::op::addze<0>(regs,&regs.R8,regs.R11);
		/* 8206C4E8h case    6:*/		return 0x8206C4EC;
		  /* 8206C4ECh */ case    7:  		/* subf R11, R8, R11 */
		/* 8206C4ECh case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8206C4ECh case    7:*/		return 0x8206C4F0;
		  /* 8206C4F0h */ case    8:  		/* and R29, R11, R10 */
		/* 8206C4F0h case    8:*/		cpu::op::and<0>(regs,&regs.R29,regs.R11,regs.R10);
		/* 8206C4F0h case    8:*/		return 0x8206C4F4;
		  /* 8206C4F4h */ case    9:  		/* bl 151116 */
		/* 8206C4F4h case    9:*/		regs.LR = 0x8206C4F8; return 0x82091340;
		/* 8206C4F4h case    9:*/		return 0x8206C4F8;
		  /* 8206C4F8h */ case   10:  		/* li R5, 64 */
		/* 8206C4F8h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x40);
		/* 8206C4F8h case   10:*/		return 0x8206C4FC;
		  /* 8206C4FCh */ case   11:  		/* li R4, 255 */
		/* 8206C4FCh case   11:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 8206C4FCh case   11:*/		return 0x8206C500;
		  /* 8206C500h */ case   12:  		/* addi R3, R1, 272 */
		/* 8206C500h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x110);
		/* 8206C500h case   12:*/		return 0x8206C504;
		  /* 8206C504h */ case   13:  		/* bl 151100 */
		/* 8206C504h case   13:*/		regs.LR = 0x8206C508; return 0x82091340;
		/* 8206C504h case   13:*/		return 0x8206C508;
		  /* 8206C508h */ case   14:  		/* lwz R31, <#[R30 + 308]> */
		/* 8206C508h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000134) );
		/* 8206C508h case   14:*/		return 0x8206C50C;
		  /* 8206C50Ch */ case   15:  		/* lwz R11, <#[R30 + 316]> */
		/* 8206C50Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000013C) );
		/* 8206C50Ch case   15:*/		return 0x8206C510;
		  /* 8206C510h */ case   16:  		/* li R8, 0 */
		/* 8206C510h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8206C510h case   16:*/		return 0x8206C514;
		  /* 8206C514h */ case   17:  		/* stw R28, <#[R1 + 256]> */
		/* 8206C514h case   17:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000100) );
		/* 8206C514h case   17:*/		return 0x8206C518;
		  /* 8206C518h */ case   18:  		/* cmplwi CR6, R31, 0 */
		/* 8206C518h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8206C518h case   18:*/		return 0x8206C51C;
		  /* 8206C51Ch */ case   19:  		/* stw R29, <#[R1 + 264]> */
		/* 8206C51Ch case   19:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000108) );
		/* 8206C51Ch case   19:*/		return 0x8206C520;
		  /* 8206C520h */ case   20:  		/* stw R31, <#[R1 + 260]> */
		/* 8206C520h case   20:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000104) );
		/* 8206C520h case   20:*/		return 0x8206C524;
		  /* 8206C524h */ case   21:  		/* stw R11, <#[R1 + 268]> */
		/* 8206C524h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000010C) );
		/* 8206C524h case   21:*/		return 0x8206C528;
		  /* 8206C528h */ case   22:  		/* bc 12, CR6_EQ, 88 */
		/* 8206C528h case   22:*/		if ( regs.CR[6].eq ) { return 0x8206C580;  }
		/* 8206C528h case   22:*/		return 0x8206C52C;
		  /* 8206C52Ch */ case   23:  		/* mr R7, R28 */
		/* 8206C52Ch case   23:*/		regs.R7 = regs.R28;
		/* 8206C52Ch case   23:*/		return 0x8206C530;
		  /* 8206C530h */ case   24:  		/* li R10, 4 */
		/* 8206C530h case   24:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 8206C530h case   24:*/		return 0x8206C534;
		  /* 8206C534h */ case   25:  		/* lwz R6, <#[R7]> */
		/* 8206C534h case   25:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 8206C534h case   25:*/		return 0x8206C538;
		  /* 8206C538h */ case   26:  		/* li R11, 0 */
		/* 8206C538h case   26:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206C538h case   26:*/		return 0x8206C53C;
		  /* 8206C53Ch */ case   27:  		/* rlwinm R9, R6, 24, 28, 31 */
		/* 8206C53Ch case   27:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R9,regs.R6);
		/* 8206C53Ch case   27:*/		return 0x8206C540;
		  /* 8206C540h */ case   28:  		/* rlwinm R6, R6, 20, 28, 31 */
		/* 8206C540h case   28:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R6,regs.R6);
		/* 8206C540h case   28:*/		return 0x8206C544;
		  /* 8206C544h */ case   29:  		/* mtspr CTR, R10 */
		/* 8206C544h case   29:*/		regs.CTR = regs.R10;
		/* 8206C544h case   29:*/		return 0x8206C548;
		  /* 8206C548h */ case   30:  		/* li R10, 1 */
		/* 8206C548h case   30:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8206C548h case   30:*/		return 0x8206C54C;
		  /* 8206C54Ch */ case   31:  		/* slw R10, R10, R11 */
		/* 8206C54Ch case   31:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8206C54Ch case   31:*/		return 0x8206C550;
		  /* 8206C550h */ case   32:  		/* and. R10, R10, R6 */
		/* 8206C550h case   32:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R6);
		/* 8206C550h case   32:*/		return 0x8206C554;
		  /* 8206C554h */ case   33:  		/* bc 12, CR0_EQ, 20 */
		/* 8206C554h case   33:*/		if ( regs.CR[0].eq ) { return 0x8206C568;  }
		/* 8206C554h case   33:*/		return 0x8206C558;
		  /* 8206C558h */ case   34:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 8206C558h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 8206C558h case   34:*/		return 0x8206C55C;
		  /* 8206C55Ch */ case   35:  		/* addi R5, R1, 272 */
		/* 8206C55Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x110);
		/* 8206C55Ch case   35:*/		return 0x8206C560;
		  /* 8206C560h */ case   36:  		/* add R10, R10, R11 */
		/* 8206C560h case   36:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8206C560h case   36:*/		return 0x8206C564;
		  /* 8206C564h */ case   37:  		/* stbx R8, <#[R10 + R5]> */
		/* 8206C564h case   37:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8206C564h case   37:*/		return 0x8206C568;
	}
	return 0x8206C568;
} // Block from 8206C4D0h-8206C568h (38 instructions)

//////////////////////////////////////////////////////
// Block at 8206C568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C568);
		  /* 8206C568h */ case    0:  		/* addi R11, R11, 1 */
		/* 8206C568h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206C568h case    0:*/		return 0x8206C56C;
		  /* 8206C56Ch */ case    1:  		/* bc 16, CR0_LT, -36 */
		/* 8206C56Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206C548;  }
		/* 8206C56Ch case    1:*/		return 0x8206C570;
		  /* 8206C570h */ case    2:  		/* addi R8, R8, 1 */
		/* 8206C570h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8206C570h case    2:*/		return 0x8206C574;
		  /* 8206C574h */ case    3:  		/* addi R7, R7, 4 */
		/* 8206C574h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 8206C574h case    3:*/		return 0x8206C578;
		  /* 8206C578h */ case    4:  		/* cmplw CR6, R8, R31 */
		/* 8206C578h case    4:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R31);
		/* 8206C578h case    4:*/		return 0x8206C57C;
		  /* 8206C57Ch */ case    5:  		/* bc 12, CR6_LT, -76 */
		/* 8206C57Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8206C530;  }
		/* 8206C57Ch case    5:*/		return 0x8206C580;
	}
	return 0x8206C580;
} // Block from 8206C568h-8206C580h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206C580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C580);
		  /* 8206C580h */ case    0:  		/* lis R11, -32250 */
		/* 8206C580h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8206);
		/* 8206C580h case    0:*/		return 0x8206C584;
		  /* 8206C584h */ case    1:  		/* addi R7, R1, 256 */
		/* 8206C584h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x100);
		/* 8206C584h case    1:*/		return 0x8206C588;
		  /* 8206C588h */ case    2:  		/* addi R6, R11, 31664 */
		/* 8206C588h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x7BB0);
		/* 8206C588h case    2:*/		return 0x8206C58C;
		  /* 8206C58Ch */ case    3:  		/* li R5, 1 */
		/* 8206C58Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206C58Ch case    3:*/		return 0x8206C590;
		  /* 8206C590h */ case    4:  		/* li R4, 0 */
		/* 8206C590h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206C590h case    4:*/		return 0x8206C594;
		  /* 8206C594h */ case    5:  		/* mr R3, R30 */
		/* 8206C594h case    5:*/		regs.R3 = regs.R30;
		/* 8206C594h case    5:*/		return 0x8206C598;
		  /* 8206C598h */ case    6:  		/* bl -10464 */
		/* 8206C598h case    6:*/		regs.LR = 0x8206C59C; return 0x82069CB8;
		/* 8206C598h case    6:*/		return 0x8206C59C;
		  /* 8206C59Ch */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 8206C59Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8206C59Ch case    7:*/		return 0x8206C5A0;
		  /* 8206C5A0h */ case    8:  		/* bc 12, CR6_EQ, 60 */
		/* 8206C5A0h case    8:*/		if ( regs.CR[6].eq ) { return 0x8206C5DC;  }
		/* 8206C5A0h case    8:*/		return 0x8206C5A4;
		  /* 8206C5A4h */ case    9:  		/* addi R9, R1, 334 */
		/* 8206C5A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x14E);
		/* 8206C5A4h case    9:*/		return 0x8206C5A8;
		  /* 8206C5A8h */ case   10:  		/* mtspr CTR, R31 */
		/* 8206C5A8h case   10:*/		regs.CTR = regs.R31;
		/* 8206C5A8h case   10:*/		return 0x8206C5AC;
		  /* 8206C5ACh */ case   11:  		/* addi R10, R28, -4 */
		/* 8206C5ACh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0xFFFFFFFC);
		/* 8206C5ACh case   11:*/		return 0x8206C5B0;
		  /* 8206C5B0h */ case   12:  		/* lhzu R11, <#[R10 + 4]> */
		/* 8206C5B0h case   12:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8206C5B0h case   12:*/		return 0x8206C5B4;
		  /* 8206C5B4h */ case   13:  		/* lhzu R8, <#[R9 + 2]> */
		/* 8206C5B4h case   13:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000002) );
		regs.R9 = (uint32)(regs.R9 + 0x00000002);
		/* 8206C5B4h case   13:*/		return 0x8206C5B8;
		  /* 8206C5B8h */ case   14:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 8206C5B8h case   14:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 8206C5B8h case   14:*/		return 0x8206C5BC;
		  /* 8206C5BCh */ case   15:  		/* add R11, R11, R8 */
		/* 8206C5BCh case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8206C5BCh case   15:*/		return 0x8206C5C0;
		  /* 8206C5C0h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206C5C0h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206C5C0h case   16:*/		return 0x8206C5C4;
		  /* 8206C5C4h */ case   17:  		/* add R11, R11, R29 */
		/* 8206C5C4h case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8206C5C4h case   17:*/		return 0x8206C5C8;
		  /* 8206C5C8h */ case   18:  		/* addi R8, R11, -4 */
		/* 8206C5C8h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFFC);
		/* 8206C5C8h case   18:*/		return 0x8206C5CC;
		  /* 8206C5CCh */ case   19:  		/* lwz R8, <#[R11 - 4]> */
		/* 8206C5CCh case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8206C5CCh case   19:*/		return 0x8206C5D0;
		  /* 8206C5D0h */ case   20:  		/* ori R8, R8, 4096 */
		/* 8206C5D0h case   20:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1000);
		/* 8206C5D0h case   20:*/		return 0x8206C5D4;
		  /* 8206C5D4h */ case   21:  		/* stw R8, <#[R11 - 4]> */
		/* 8206C5D4h case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8206C5D4h case   21:*/		return 0x8206C5D8;
		  /* 8206C5D8h */ case   22:  		/* bc 16, CR0_LT, -40 */
		/* 8206C5D8h case   22:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206C5B0;  }
		/* 8206C5D8h case   22:*/		return 0x8206C5DC;
	}
	return 0x8206C5DC;
} // Block from 8206C580h-8206C5DCh (23 instructions)

//////////////////////////////////////////////////////
// Block at 8206C5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C5DC);
		  /* 8206C5DCh */ case    0:  		/* lwz R11, <#[R30 + 88]> */
		/* 8206C5DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000058) );
		/* 8206C5DCh case    0:*/		return 0x8206C5E0;
		  /* 8206C5E0h */ case    1:  		/* rlwinm. R11, R11, 0, 26, 31 */
		/* 8206C5E0h case    1:*/		cpu::op::rlwinm<1,0,26,31>(regs,&regs.R11,regs.R11);
		/* 8206C5E0h case    1:*/		return 0x8206C5E4;
		  /* 8206C5E4h */ case    2:  		/* stw R11, <#[R1 + 80]> */
		/* 8206C5E4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206C5E4h case    2:*/		return 0x8206C5E8;
		  /* 8206C5E8h */ case    3:  		/* bc 4, CR0_EQ, 36 */
		/* 8206C5E8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8206C60C;  }
		/* 8206C5E8h case    3:*/		return 0x8206C5EC;
		  /* 8206C5ECh */ case    4:  		/* lis R11, -32250 */
		/* 8206C5ECh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8206);
		/* 8206C5ECh case    4:*/		return 0x8206C5F0;
		  /* 8206C5F0h */ case    5:  		/* addi R7, R1, 80 */
		/* 8206C5F0h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 8206C5F0h case    5:*/		return 0x8206C5F4;
		  /* 8206C5F4h */ case    6:  		/* addi R6, R11, 31016 */
		/* 8206C5F4h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x7928);
		/* 8206C5F4h case    6:*/		return 0x8206C5F8;
		  /* 8206C5F8h */ case    7:  		/* li R5, 1 */
		/* 8206C5F8h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206C5F8h case    7:*/		return 0x8206C5FC;
		  /* 8206C5FCh */ case    8:  		/* li R4, 0 */
		/* 8206C5FCh case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206C5FCh case    8:*/		return 0x8206C600;
		  /* 8206C600h */ case    9:  		/* mr R3, R30 */
		/* 8206C600h case    9:*/		regs.R3 = regs.R30;
		/* 8206C600h case    9:*/		return 0x8206C604;
		  /* 8206C604h */ case   10:  		/* bl -10572 */
		/* 8206C604h case   10:*/		regs.LR = 0x8206C608; return 0x82069CB8;
		/* 8206C604h case   10:*/		return 0x8206C608;
		  /* 8206C608h */ case   11:  		/* lwz R11, <#[R1 + 80]> */
		/* 8206C608h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206C608h case   11:*/		return 0x8206C60C;
	}
	return 0x8206C60C;
} // Block from 8206C5DCh-8206C60Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206C60Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C60C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C60C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C60C);
		  /* 8206C60Ch */ case    0:  		/* lwz R10, <#[R27 + 8]> */
		/* 8206C60Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 8206C60Ch case    0:*/		return 0x8206C610;
		  /* 8206C610h */ case    1:  		/* rlwimi R11, R10, 0, 0, 25 */
		/* 8206C610h case    1:*/		cpu::op::rlwimi<0,0,0,25>(regs,&regs.R11,regs.R10);
		/* 8206C610h case    1:*/		return 0x8206C614;
		  /* 8206C614h */ case    2:  		/* stw R11, <#[R27 + 8]> */
		/* 8206C614h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8206C614h case    2:*/		return 0x8206C618;
	}
	return 0x8206C618;
} // Block from 8206C60Ch-8206C618h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206C618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C618);
		  /* 8206C618h */ case    0:  		/* lis R11, -32250 */
		/* 8206C618h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8206);
		/* 8206C618h case    0:*/		return 0x8206C61C;
		  /* 8206C61Ch */ case    1:  		/* lwz R7, <#[R30 + 256]> */
		/* 8206C61Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000100) );
		/* 8206C61Ch case    1:*/		return 0x8206C620;
		  /* 8206C620h */ case    2:  		/* li R5, 0 */
		/* 8206C620h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8206C620h case    2:*/		return 0x8206C624;
		  /* 8206C624h */ case    3:  		/* addi R6, R11, 31456 */
		/* 8206C624h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x7AE0);
		/* 8206C624h case    3:*/		return 0x8206C628;
		  /* 8206C628h */ case    4:  		/* li R4, 1 */
		/* 8206C628h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8206C628h case    4:*/		return 0x8206C62C;
		  /* 8206C62Ch */ case    5:  		/* mr R3, R30 */
		/* 8206C62Ch case    5:*/		regs.R3 = regs.R30;
		/* 8206C62Ch case    5:*/		return 0x8206C630;
		  /* 8206C630h */ case    6:  		/* bl -10616 */
		/* 8206C630h case    6:*/		regs.LR = 0x8206C634; return 0x82069CB8;
		/* 8206C630h case    6:*/		return 0x8206C634;
	}
	return 0x8206C634;
} // Block from 8206C618h-8206C634h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206C634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C634);
		  /* 8206C634h */ case    0:  		/* lwz R3, <#[R30 + 80]> */
		/* 8206C634h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000050) );
		/* 8206C634h case    0:*/		return 0x8206C638;
		  /* 8206C638h */ case    1:  		/* cmpwi CR6, R3, 0 */
		/* 8206C638h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8206C638h case    1:*/		return 0x8206C63C;
		  /* 8206C63Ch */ case    2:  		/* bc 12, CR6_LT, 20 */
		/* 8206C63Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x8206C650;  }
		/* 8206C63Ch case    2:*/		return 0x8206C640;
		  /* 8206C640h */ case    3:  		/* lwz R3, <#[R26 + 16]> */
		/* 8206C640h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000010) );
		/* 8206C640h case    3:*/		return 0x8206C644;
		  /* 8206C644h */ case    4:  		/* cmpwi CR6, R3, 0 */
		/* 8206C644h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8206C644h case    4:*/		return 0x8206C648;
		  /* 8206C648h */ case    5:  		/* bc 12, CR6_LT, 8 */
		/* 8206C648h case    5:*/		if ( regs.CR[6].lt ) { return 0x8206C650;  }
		/* 8206C648h case    5:*/		return 0x8206C64C;
		  /* 8206C64Ch */ case    6:  		/* lwz R3, <#[R26 + 36]> */
		/* 8206C64Ch case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000024) );
		/* 8206C64Ch case    6:*/		return 0x8206C650;
	}
	return 0x8206C650;
} // Block from 8206C634h-8206C650h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206C650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C650);
		  /* 8206C650h */ case    0:  		/* addi R1, R1, 944 */
		/* 8206C650h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x3B0);
		/* 8206C650h case    0:*/		return 0x8206C654;
		  /* 8206C654h */ case    1:  		/* b 150604 */
		/* 8206C654h case    1:*/		return 0x820912A0;
		/* 8206C654h case    1:*/		return 0x8206C658;
	}
	return 0x8206C658;
} // Block from 8206C650h-8206C658h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206C658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C658);
		  /* 8206C658h */ case    0:  		/* mfspr R12, LR */
		/* 8206C658h case    0:*/		regs.R12 = regs.LR;
		/* 8206C658h case    0:*/		return 0x8206C65C;
		  /* 8206C65Ch */ case    1:  		/* bl 150524 */
		/* 8206C65Ch case    1:*/		regs.LR = 0x8206C660; return 0x82091258;
		/* 8206C65Ch case    1:*/		return 0x8206C660;
		  /* 8206C660h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206C660h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206C660h case    2:*/		return 0x8206C664;
		  /* 8206C664h */ case    3:  		/* li R28, 1 */
		/* 8206C664h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 8206C664h case    3:*/		return 0x8206C668;
		  /* 8206C668h */ case    4:  		/* mr R29, R3 */
		/* 8206C668h case    4:*/		regs.R29 = regs.R3;
		/* 8206C668h case    4:*/		return 0x8206C66C;
		  /* 8206C66Ch */ case    5:  		/* li R30, 0 */
		/* 8206C66Ch case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8206C66Ch case    5:*/		return 0x8206C670;
		  /* 8206C670h */ case    6:  		/* stw R28, <#[R3 + 19888]> */
		/* 8206C670h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00004DB0) );
		/* 8206C670h case    6:*/		return 0x8206C674;
		  /* 8206C674h */ case    7:  		/* addi R31, R3, 9932 */
		/* 8206C674h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x26CC);
		/* 8206C674h case    7:*/		return 0x8206C678;
		  /* 8206C678h */ case    8:  		/* addi R3, R31, -9916 */
		/* 8206C678h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xFFFFD944);
		/* 8206C678h case    8:*/		return 0x8206C67C;
		  /* 8206C67Ch */ case    9:  		/* bl -5628 */
		/* 8206C67Ch case    9:*/		regs.LR = 0x8206C680; return 0x8206B080;
		/* 8206C67Ch case    9:*/		return 0x8206C680;
		  /* 8206C680h */ case   10:  		/* cntlzw R11, R30 */
		/* 8206C680h case   10:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R30);
		/* 8206C680h case   10:*/		return 0x8206C684;
		  /* 8206C684h */ case   11:  		/* addi R30, R30, 1 */
		/* 8206C684h case   11:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8206C684h case   11:*/		return 0x8206C688;
		  /* 8206C688h */ case   12:  		/* stw R28, <#[R31]> */
		/* 8206C688h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000000) );
		/* 8206C688h case   12:*/		return 0x8206C68C;
		  /* 8206C68Ch */ case   13:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8206C68Ch case   13:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8206C68Ch case   13:*/		return 0x8206C690;
		  /* 8206C690h */ case   14:  		/* cmplwi CR6, R30, 2 */
		/* 8206C690h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000002);
		/* 8206C690h case   14:*/		return 0x8206C694;
		  /* 8206C694h */ case   15:  		/* stw R11, <#[R31 - 4]> */
		/* 8206C694h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 8206C694h case   15:*/		return 0x8206C698;
		  /* 8206C698h */ case   16:  		/* addi R31, R31, 9936 */
		/* 8206C698h case   16:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x26D0);
		/* 8206C698h case   16:*/		return 0x8206C69C;
		  /* 8206C69Ch */ case   17:  		/* bc 12, CR6_LT, -36 */
		/* 8206C69Ch case   17:*/		if ( regs.CR[6].lt ) { return 0x8206C678;  }
		/* 8206C69Ch case   17:*/		return 0x8206C6A0;
		  /* 8206C6A0h */ case   18:  		/* mr R3, R29 */
		/* 8206C6A0h case   18:*/		regs.R3 = regs.R29;
		/* 8206C6A0h case   18:*/		return 0x8206C6A4;
		  /* 8206C6A4h */ case   19:  		/* bl -2468 */
		/* 8206C6A4h case   19:*/		regs.LR = 0x8206C6A8; return 0x8206BD00;
		/* 8206C6A4h case   19:*/		return 0x8206C6A8;
		  /* 8206C6A8h */ case   20:  		/* addi R1, R1, 128 */
		/* 8206C6A8h case   20:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206C6A8h case   20:*/		return 0x8206C6AC;
		  /* 8206C6ACh */ case   21:  		/* b 150524 */
		/* 8206C6ACh case   21:*/		return 0x820912A8;
		/* 8206C6ACh case   21:*/		return 0x8206C6B0;
	}
	return 0x8206C6B0;
} // Block from 8206C658h-8206C6B0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8206C6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C6B0);
		  /* 8206C6B0h */ case    0:  		/* mfspr R12, LR */
		/* 8206C6B0h case    0:*/		regs.R12 = regs.LR;
		/* 8206C6B0h case    0:*/		return 0x8206C6B4;
		  /* 8206C6B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206C6B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206C6B4h case    1:*/		return 0x8206C6B8;
		  /* 8206C6B8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8206C6B8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206C6B8h case    2:*/		return 0x8206C6BC;
		  /* 8206C6BCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8206C6BCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206C6BCh case    3:*/		return 0x8206C6C0;
		  /* 8206C6C0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206C6C0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206C6C0h case    4:*/		return 0x8206C6C4;
		  /* 8206C6C4h */ case    5:  		/* mr R31, R3 */
		/* 8206C6C4h case    5:*/		regs.R31 = regs.R3;
		/* 8206C6C4h case    5:*/		return 0x8206C6C8;
		  /* 8206C6C8h */ case    6:  		/* lwz R3, <#[R3 + 19896]> */
		/* 8206C6C8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00004DB8) );
		/* 8206C6C8h case    6:*/		return 0x8206C6CC;
		  /* 8206C6CCh */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 8206C6CCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8206C6CCh case    7:*/		return 0x8206C6D0;
		  /* 8206C6D0h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 8206C6D0h case    8:*/		if ( regs.CR[6].eq ) { return 0x8206C6EC;  }
		/* 8206C6D0h case    8:*/		return 0x8206C6D4;
		  /* 8206C6D4h */ case    9:  		/* lwz R11, <#[R3]> */
		/* 8206C6D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206C6D4h case    9:*/		return 0x8206C6D8;
		  /* 8206C6D8h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 8206C6D8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8206C6D8h case   10:*/		return 0x8206C6DC;
		  /* 8206C6DCh */ case   11:  		/* mtspr CTR, R11 */
		/* 8206C6DCh case   11:*/		regs.CTR = regs.R11;
		/* 8206C6DCh case   11:*/		return 0x8206C6E0;
		  /* 8206C6E0h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 8206C6E0h case   12:*/		if ( 1 ) { regs.LR = 0x8206C6E4; return (uint32)regs.CTR; }
		/* 8206C6E0h case   12:*/		return 0x8206C6E4;
		  /* 8206C6E4h */ case   13:  		/* li R11, 0 */
		/* 8206C6E4h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206C6E4h case   13:*/		return 0x8206C6E8;
		  /* 8206C6E8h */ case   14:  		/* stw R11, <#[R31 + 19896]> */
		/* 8206C6E8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00004DB8) );
		/* 8206C6E8h case   14:*/		return 0x8206C6EC;
	}
	return 0x8206C6EC;
} // Block from 8206C6B0h-8206C6ECh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206C6ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C6EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C6EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C6EC);
		  /* 8206C6ECh */ case    0:  		/* lwz R3, <#[R31 + 19940]> */
		/* 8206C6ECh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00004DE4) );
		/* 8206C6ECh case    0:*/		return 0x8206C6F0;
		  /* 8206C6F0h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8206C6F0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8206C6F0h case    1:*/		return 0x8206C6F4;
		  /* 8206C6F4h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8206C6F4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206C700;  }
		/* 8206C6F4h case    2:*/		return 0x8206C6F8;
		  /* 8206C6F8h */ case    3:  		/* lis R4, 9344 */
		/* 8206C6F8h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206C6F8h case    3:*/		return 0x8206C6FC;
		  /* 8206C6FCh */ case    4:  		/* bl 113724 */
		/* 8206C6FCh case    4:*/		regs.LR = 0x8206C700; return 0x82088338;
		/* 8206C6FCh case    4:*/		return 0x8206C700;
	}
	return 0x8206C700;
} // Block from 8206C6ECh-8206C700h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206C700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C700);
		  /* 8206C700h */ case    0:  		/* lwz R3, <#[R31 + 19920]> */
		/* 8206C700h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00004DD0) );
		/* 8206C700h case    0:*/		return 0x8206C704;
		  /* 8206C704h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8206C704h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8206C704h case    1:*/		return 0x8206C708;
		  /* 8206C708h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8206C708h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206C714;  }
		/* 8206C708h case    2:*/		return 0x8206C70C;
		  /* 8206C70Ch */ case    3:  		/* lis R4, 9344 */
		/* 8206C70Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206C70Ch case    3:*/		return 0x8206C710;
		  /* 8206C710h */ case    4:  		/* bl 113704 */
		/* 8206C710h case    4:*/		regs.LR = 0x8206C714; return 0x82088338;
		/* 8206C710h case    4:*/		return 0x8206C714;
	}
	return 0x8206C714;
} // Block from 8206C700h-8206C714h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206C714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C714);
		  /* 8206C714h */ case    0:  		/* lwz R3, <#[R31 + 19908]> */
		/* 8206C714h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00004DC4) );
		/* 8206C714h case    0:*/		return 0x8206C718;
		  /* 8206C718h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 8206C718h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8206C718h case    1:*/		return 0x8206C71C;
		  /* 8206C71Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8206C71Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8206C728;  }
		/* 8206C71Ch case    2:*/		return 0x8206C720;
	}
	return 0x8206C720;
} // Block from 8206C714h-8206C720h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206C720h
// Function 'XGMicrocodeEnumerateLiterals'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C720);
		  /* 8206C720h */ case    0:  		/* lis R4, 9344 */
		/* 8206C720h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206C720h case    0:*/		return 0x8206C724;
		  /* 8206C724h */ case    1:  		/* bl 113684 */
		/* 8206C724h case    1:*/		regs.LR = 0x8206C728; return 0x82088338;
		/* 8206C724h case    1:*/		return 0x8206C728;
	}
	return 0x8206C728;
} // Block from 8206C720h-8206C728h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206C728h
// Function '?push_back@?$D3DFastVector@TGPUSHADER_INSTRUCTION@@$1?MemAlloc@D3D@@YAPAXK@Z$1?MemFree@3@YAXPAX@Z@D3D@@QAAXABTGPUSHADER_INSTRUCTION@@AAJ@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C728);
		  /* 8206C728h */ case    0:  		/* addi R31, R31, 19888 */
		/* 8206C728h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4DB0);
		/* 8206C728h case    0:*/		return 0x8206C72C;
		  /* 8206C72Ch */ case    1:  		/* li R30, 1 */
		/* 8206C72Ch case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 8206C72Ch case    1:*/		return 0x8206C730;
		  /* 8206C730h */ case    2:  		/* addi R31, R31, -9936 */
		/* 8206C730h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFD930);
		/* 8206C730h case    2:*/		return 0x8206C734;
		  /* 8206C734h */ case    3:  		/* mr R3, R31 */
		/* 8206C734h case    3:*/		regs.R3 = regs.R31;
		/* 8206C734h case    3:*/		return 0x8206C738;
		  /* 8206C738h */ case    4:  		/* bl -2928 */
		/* 8206C738h case    4:*/		regs.LR = 0x8206C73C; return 0x8206BBC8;
		/* 8206C738h case    4:*/		return 0x8206C73C;
		  /* 8206C73Ch */ case    5:  		/* addic. R30, R30, -1 */
		/* 8206C73Ch case    5:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 8206C73Ch case    5:*/		return 0x8206C740;
		  /* 8206C740h */ case    6:  		/* bc 4, CR0_LT, -16 */
		/* 8206C740h case    6:*/		if ( !regs.CR[0].lt ) { return 0x8206C730;  }
		/* 8206C740h case    6:*/		return 0x8206C744;
		  /* 8206C744h */ case    7:  		/* addi R1, R1, 112 */
		/* 8206C744h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206C744h case    7:*/		return 0x8206C748;
		  /* 8206C748h */ case    8:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206C748h case    8:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206C748h case    8:*/		return 0x8206C74C;
		  /* 8206C74Ch */ case    9:  		/* mtspr LR, R12 */
		/* 8206C74Ch case    9:*/		regs.LR = regs.R12;
		/* 8206C74Ch case    9:*/		return 0x8206C750;
		  /* 8206C750h */ case   10:  		/* ld R30, <#[R1 - 24]> */
		/* 8206C750h case   10:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206C750h case   10:*/		return 0x8206C754;
		  /* 8206C754h */ case   11:  		/* ld R31, <#[R1 - 16]> */
		/* 8206C754h case   11:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206C754h case   11:*/		return 0x8206C758;
		  /* 8206C758h */ case   12:  		/* bclr 20, CR0_LT */
		/* 8206C758h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206C758h case   12:*/		return 0x8206C75C;
	}
	return 0x8206C75C;
} // Block from 8206C728h-8206C75Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206C75Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C75C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C75C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C75C);
		  /* 8206C75Ch */ case    0:  		/* nop */
		/* 8206C75Ch case    0:*/		cpu::op::nop();
		/* 8206C75Ch case    0:*/		return 0x8206C760;
	}
	return 0x8206C760;
} // Block from 8206C75Ch-8206C760h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206C760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C760);
		  /* 8206C760h */ case    0:  		/* mfspr R12, LR */
		/* 8206C760h case    0:*/		regs.R12 = regs.LR;
		/* 8206C760h case    0:*/		return 0x8206C764;
		  /* 8206C764h */ case    1:  		/* bl 150248 */
		/* 8206C764h case    1:*/		regs.LR = 0x8206C768; return 0x8209124C;
		/* 8206C764h case    1:*/		return 0x8206C768;
		  /* 8206C768h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 8206C768h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 8206C768h case    2:*/		return 0x8206C76C;
		  /* 8206C76Ch */ case    3:  		/* mr R30, R3 */
		/* 8206C76Ch case    3:*/		regs.R30 = regs.R3;
		/* 8206C76Ch case    3:*/		return 0x8206C770;
		  /* 8206C770h */ case    4:  		/* lwz R3, <#[R3 + 19900]> */
		/* 8206C770h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00004DBC) );
		/* 8206C770h case    4:*/		return 0x8206C774;
		  /* 8206C774h */ case    5:  		/* mr R26, R4 */
		/* 8206C774h case    5:*/		regs.R26 = regs.R4;
		/* 8206C774h case    5:*/		return 0x8206C778;
		  /* 8206C778h */ case    6:  		/* cmpwi CR6, R3, 0 */
		/* 8206C778h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8206C778h case    6:*/		return 0x8206C77C;
		  /* 8206C77Ch */ case    7:  		/* bc 12, CR6_LT, 444 */
		/* 8206C77Ch case    7:*/		if ( regs.CR[6].lt ) { return 0x8206C938;  }
		/* 8206C77Ch case    7:*/		return 0x8206C780;
		  /* 8206C780h */ case    8:  		/* lwz R11, <#[R30 + 19904]> */
		/* 8206C780h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00004DC0) );
		/* 8206C780h case    8:*/		return 0x8206C784;
		  /* 8206C784h */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 8206C784h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206C784h case    9:*/		return 0x8206C788;
		  /* 8206C788h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 8206C788h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8206C798;  }
		/* 8206C788h case   10:*/		return 0x8206C78C;
		  /* 8206C78Ch */ case   11:  		/* lis R3, -32768 */
		/* 8206C78Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8206C78Ch case   11:*/		return 0x8206C790;
		  /* 8206C790h */ case   12:  		/* ori R3, R3, 16389 */
		/* 8206C790h case   12:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8206C790h case   12:*/		return 0x8206C794;
		  /* 8206C794h */ case   13:  		/* b 420 */
		/* 8206C794h case   13:*/		return 0x8206C938;
		/* 8206C794h case   13:*/		return 0x8206C798;
	}
	return 0x8206C798;
} // Block from 8206C760h-8206C798h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206C798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C798);
		  /* 8206C798h */ case    0:  		/* addi R11, R1, 96 */
		/* 8206C798h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8206C798h case    0:*/		return 0x8206C79C;
		  /* 8206C79Ch */ case    1:  		/* lwz R10, <#[R30 + 19892]> */
		/* 8206C79Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00004DB4) );
		/* 8206C79Ch case    1:*/		return 0x8206C7A0;
		  /* 8206C7A0h */ case    2:  		/* li R29, 0 */
		/* 8206C7A0h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8206C7A0h case    2:*/		return 0x8206C7A4;
		  /* 8206C7A4h */ case    3:  		/* lwz R25, <#[R26 + 24]> */
		/* 8206C7A4h case    3:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R26 + 0x00000018) );
		/* 8206C7A4h case    3:*/		return 0x8206C7A8;
		  /* 8206C7A8h */ case    4:  		/* rlwinm R9, R10, 30, 31, 31 */
		/* 8206C7A8h case    4:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R9,regs.R10);
		/* 8206C7A8h case    4:*/		return 0x8206C7AC;
		  /* 8206C7ACh */ case    5:  		/* lis R8, 4138 */
		/* 8206C7ACh case    5:*/		cpu::op::lis<0>(regs,&regs.R8,0x102A);
		/* 8206C7ACh case    5:*/		return 0x8206C7B0;
		  /* 8206C7B0h */ case    6:  		/* cntlzw R9, R9 */
		/* 8206C7B0h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R9);
		/* 8206C7B0h case    6:*/		return 0x8206C7B4;
		  /* 8206C7B4h */ case    7:  		/* std R29, <#[R11]> */
		/* 8206C7B4h case    7:*/		cpu::mem::store64( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 8206C7B4h case    7:*/		return 0x8206C7B8;
		  /* 8206C7B8h */ case    8:  		/* ori R8, R8, 4352 */
		/* 8206C7B8h case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1100);
		/* 8206C7B8h case    8:*/		return 0x8206C7BC;
		  /* 8206C7BCh */ case    9:  		/* std R29, <#[R11 + 8]> */
		/* 8206C7BCh case    9:*/		cpu::mem::store64( regs, regs.R29, (uint32)(regs.R11 + 0x00000008) );
		/* 8206C7BCh case    9:*/		return 0x8206C7C0;
		  /* 8206C7C0h */ case   10:  		/* rlwinm R9, R9, 27, 31, 31 */
		/* 8206C7C0h case   10:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R9,regs.R9);
		/* 8206C7C0h case   10:*/		return 0x8206C7C4;
		  /* 8206C7C4h */ case   11:  		/* std R29, <#[R11 + 16]> */
		/* 8206C7C4h case   11:*/		cpu::mem::store64( regs, regs.R29, (uint32)(regs.R11 + 0x00000010) );
		/* 8206C7C4h case   11:*/		return 0x8206C7C8;
		  /* 8206C7C8h */ case   12:  		/* rlwimi R8, R10, 31, 26, 26 */
		/* 8206C7C8h case   12:*/		cpu::op::rlwimi<0,31,26,26>(regs,&regs.R8,regs.R10);
		/* 8206C7C8h case   12:*/		return 0x8206C7CC;
		  /* 8206C7CCh */ case   13:  		/* std R29, <#[R11 + 24]> */
		/* 8206C7CCh case   13:*/		cpu::mem::store64( regs, regs.R29, (uint32)(regs.R11 + 0x00000018) );
		/* 8206C7CCh case   13:*/		return 0x8206C7D0;
		  /* 8206C7D0h */ case   14:  		/* stw R29, <#[R11 + 32]> */
		/* 8206C7D0h case   14:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000020) );
		/* 8206C7D0h case   14:*/		return 0x8206C7D4;
		  /* 8206C7D4h */ case   15:  		/* or R11, R8, R9 */
		/* 8206C7D4h case   15:*/		cpu::op::or<0>(regs,&regs.R11,regs.R8,regs.R9);
		/* 8206C7D4h case   15:*/		return 0x8206C7D8;
		  /* 8206C7D8h */ case   16:  		/* addi R31, R26, 20 */
		/* 8206C7D8h case   16:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R26,0x14);
		/* 8206C7D8h case   16:*/		return 0x8206C7DC;
		  /* 8206C7DCh */ case   17:  		/* li R5, 36 */
		/* 8206C7DCh case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 8206C7DCh case   17:*/		return 0x8206C7E0;
		  /* 8206C7E0h */ case   18:  		/* addi R4, R1, 96 */
		/* 8206C7E0h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8206C7E0h case   18:*/		return 0x8206C7E4;
		  /* 8206C7E4h */ case   19:  		/* mr R3, R31 */
		/* 8206C7E4h case   19:*/		regs.R3 = regs.R31;
		/* 8206C7E4h case   19:*/		return 0x8206C7E8;
		  /* 8206C7E8h */ case   20:  		/* lwz R10, <#[R1 + 96]> */
		/* 8206C7E8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 8206C7E8h case   20:*/		return 0x8206C7EC;
		  /* 8206C7ECh */ case   21:  		/* andi. R10, R10, 222 */
		/* 8206C7ECh case   21:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0xDE);
		/* 8206C7ECh case   21:*/		return 0x8206C7F0;
		  /* 8206C7F0h */ case   22:  		/* or R11, R11, R10 */
		/* 8206C7F0h case   22:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206C7F0h case   22:*/		return 0x8206C7F4;
		  /* 8206C7F4h */ case   23:  		/* stw R11, <#[R1 + 96]> */
		/* 8206C7F4h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8206C7F4h case   23:*/		return 0x8206C7F8;
		  /* 8206C7F8h */ case   24:  		/* bl -20824 */
		/* 8206C7F8h case   24:*/		regs.LR = 0x8206C7FC; return 0x820676A0;
		/* 8206C7F8h case   24:*/		return 0x8206C7FC;
		  /* 8206C7FCh */ case   25:  		/* lwz R11, <#[R30 + 19924]> */
		/* 8206C7FCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00004DD4) );
		/* 8206C7FCh case   25:*/		return 0x8206C800;
	}
	return 0x8206C800;
} // Block from 8206C798h-8206C800h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8206C800h
// Function '?push_back@?$D3DFastVector@TGPUFLOW_INSTRUCTION@@$1?MemAlloc@D3D@@YAPAXK@Z$1?MemFree@3@YAXPAX@Z@D3D@@QAAXABTGPUFLOW_INSTRUCTION@@AAJ@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C800);
		  /* 8206C800h */ case    0:  		/* rlwinm. R5, R11, 2, 0, 29 */
		/* 8206C800h case    0:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8206C800h case    0:*/		return 0x8206C804;
		  /* 8206C804h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 8206C804h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206C820;  }
		/* 8206C804h case    1:*/		return 0x8206C808;
		  /* 8206C808h */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206C808h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C808h case    2:*/		return 0x8206C80C;
		  /* 8206C80Ch */ case    3:  		/* mr R3, R31 */
		/* 8206C80Ch case    3:*/		regs.R3 = regs.R31;
		/* 8206C80Ch case    3:*/		return 0x8206C810;
		  /* 8206C810h */ case    4:  		/* lwz R4, <#[R30 + 19920]> */
		/* 8206C810h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00004DD0) );
		/* 8206C810h case    4:*/		return 0x8206C814;
		  /* 8206C814h */ case    5:  		/* subf R11, R25, R11 */
		/* 8206C814h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R25,regs.R11);
		/* 8206C814h case    5:*/		return 0x8206C818;
		  /* 8206C818h */ case    6:  		/* stw R11, <#[R1 + 108]> */
		/* 8206C818h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206C818h case    6:*/		return 0x8206C81C;
		  /* 8206C81Ch */ case    7:  		/* bl -20860 */
		/* 8206C81Ch case    7:*/		regs.LR = 0x8206C820; return 0x820676A0;
		/* 8206C81Ch case    7:*/		return 0x8206C820;
	}
	return 0x8206C820;
} // Block from 8206C800h-8206C820h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206C820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C820);
		  /* 8206C820h */ case    0:  		/* lwz R11, <#[R30 + 19912]> */
		/* 8206C820h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00004DC8) );
		/* 8206C820h case    0:*/		return 0x8206C824;
		  /* 8206C824h */ case    1:  		/* rlwinm. R28, R11, 2, 0, 29 */
		/* 8206C824h case    1:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R28,regs.R11);
		/* 8206C824h case    1:*/		return 0x8206C828;
		  /* 8206C828h */ case    2:  		/* bc 12, CR0_EQ, 52 */
		/* 8206C828h case    2:*/		if ( regs.CR[0].eq ) { return 0x8206C85C;  }
		/* 8206C828h case    2:*/		return 0x8206C82C;
		  /* 8206C82Ch */ case    3:  		/* stw R28, <#[R1 + 80]> */
		/* 8206C82Ch case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 8206C82Ch case    3:*/		return 0x8206C830;
		  /* 8206C830h */ case    4:  		/* li R5, 4 */
		/* 8206C830h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8206C830h case    4:*/		return 0x8206C834;
		  /* 8206C834h */ case    5:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206C834h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C834h case    5:*/		return 0x8206C838;
		  /* 8206C838h */ case    6:  		/* addi R4, R1, 80 */
		/* 8206C838h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206C838h case    6:*/		return 0x8206C83C;
		  /* 8206C83Ch */ case    7:  		/* mr R3, R31 */
		/* 8206C83Ch case    7:*/		regs.R3 = regs.R31;
		/* 8206C83Ch case    7:*/		return 0x8206C840;
		  /* 8206C840h */ case    8:  		/* subf R11, R25, R11 */
		/* 8206C840h case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R25,regs.R11);
		/* 8206C840h case    8:*/		return 0x8206C844;
		  /* 8206C844h */ case    9:  		/* stw R11, <#[R1 + 112]> */
		/* 8206C844h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8206C844h case    9:*/		return 0x8206C848;
		  /* 8206C848h */ case   10:  		/* bl -20904 */
		/* 8206C848h case   10:*/		regs.LR = 0x8206C84C; return 0x820676A0;
		/* 8206C848h case   10:*/		return 0x8206C84C;
		  /* 8206C84Ch */ case   11:  		/* mr R5, R28 */
		/* 8206C84Ch case   11:*/		regs.R5 = regs.R28;
		/* 8206C84Ch case   11:*/		return 0x8206C850;
		  /* 8206C850h */ case   12:  		/* mr R3, R31 */
		/* 8206C850h case   12:*/		regs.R3 = regs.R31;
		/* 8206C850h case   12:*/		return 0x8206C854;
		  /* 8206C854h */ case   13:  		/* lwz R4, <#[R30 + 19908]> */
		/* 8206C854h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00004DC4) );
		/* 8206C854h case   13:*/		return 0x8206C858;
		  /* 8206C858h */ case   14:  		/* bl -20920 */
		/* 8206C858h case   14:*/		regs.LR = 0x8206C85C; return 0x820676A0;
		/* 8206C858h case   14:*/		return 0x8206C85C;
	}
	return 0x8206C85C;
} // Block from 8206C820h-8206C85Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206C85Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C85C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C85C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C85C);
		  /* 8206C85Ch */ case    0:  		/* mr R27, R29 */
		/* 8206C85Ch case    0:*/		regs.R27 = regs.R29;
		/* 8206C85Ch case    0:*/		return 0x8206C860;
		  /* 8206C860h */ case    1:  		/* addi R28, R1, 116 */
		/* 8206C860h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x74);
		/* 8206C860h case    1:*/		return 0x8206C864;
		  /* 8206C864h */ case    2:  		/* addi R29, R30, 368 */
		/* 8206C864h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x170);
		/* 8206C864h case    2:*/		return 0x8206C868;
		  /* 8206C868h */ case    3:  		/* lwz R11, <#[R29 + 9564]> */
		/* 8206C868h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000255C) );
		/* 8206C868h case    3:*/		return 0x8206C86C;
		  /* 8206C86Ch */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 8206C86Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206C86Ch case    4:*/		return 0x8206C870;
		  /* 8206C870h */ case    5:  		/* bc 4, CR6_EQ, 36 */
		/* 8206C870h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206C894;  }
		/* 8206C870h case    5:*/		return 0x8206C874;
		  /* 8206C874h */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206C874h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C874h case    6:*/		return 0x8206C878;
		  /* 8206C878h */ case    7:  		/* mr R4, R26 */
		/* 8206C878h case    7:*/		regs.R4 = regs.R26;
		/* 8206C878h case    7:*/		return 0x8206C87C;
		  /* 8206C87Ch */ case    8:  		/* mr R3, R29 */
		/* 8206C87Ch case    8:*/		regs.R3 = regs.R29;
		/* 8206C87Ch case    8:*/		return 0x8206C880;
		  /* 8206C880h */ case    9:  		/* stw R11, <#[R28]> */
		/* 8206C880h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8206C880h case    9:*/		return 0x8206C884;
		  /* 8206C884h */ case   10:  		/* bl -7292 */
		/* 8206C884h case   10:*/		regs.LR = 0x8206C888; return 0x8206AC08;
		/* 8206C884h case   10:*/		return 0x8206C888;
		  /* 8206C888h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 8206C888h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206C888h case   11:*/		return 0x8206C88C;
		  /* 8206C88Ch */ case   12:  		/* bc 4, CR0_LT, 8 */
		/* 8206C88Ch case   12:*/		if ( !regs.CR[0].lt ) { return 0x8206C894;  }
		/* 8206C88Ch case   12:*/		return 0x8206C890;
		  /* 8206C890h */ case   13:  		/* stw R3, <#[R30 + 19900]> */
		/* 8206C890h case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00004DBC) );
		/* 8206C890h case   13:*/		return 0x8206C894;
	}
	return 0x8206C894;
} // Block from 8206C85Ch-8206C894h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206C894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C894);
		  /* 8206C894h */ case    0:  		/* lwz R11, <#[R29 - 240]> */
		/* 8206C894h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFFFF10) );
		/* 8206C894h case    0:*/		return 0x8206C898;
		  /* 8206C898h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8206C898h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206C898h case    1:*/		return 0x8206C89C;
		  /* 8206C89Ch */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 8206C89Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8206C8C8;  }
		/* 8206C89Ch case    2:*/		return 0x8206C8A0;
		  /* 8206C8A0h */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206C8A0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C8A0h case    3:*/		return 0x8206C8A4;
		  /* 8206C8A4h */ case    4:  		/* addic R10, R27, -1 */
		/* 8206C8A4h case    4:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R27,0xFFFFFFFF);
		/* 8206C8A4h case    4:*/		return 0x8206C8A8;
		  /* 8206C8A8h */ case    5:  		/* mr R4, R26 */
		/* 8206C8A8h case    5:*/		regs.R4 = regs.R26;
		/* 8206C8A8h case    5:*/		return 0x8206C8AC;
		  /* 8206C8ACh */ case    6:  		/* subfe R5, R10, R27 */
		/* 8206C8ACh case    6:*/		cpu::op::subfe<0>(regs,&regs.R5,regs.R10,regs.R27);
		/* 8206C8ACh case    6:*/		return 0x8206C8B0;
		  /* 8206C8B0h */ case    7:  		/* addi R3, R29, -352 */
		/* 8206C8B0h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R29,0xFFFFFEA0);
		/* 8206C8B0h case    7:*/		return 0x8206C8B4;
		  /* 8206C8B4h */ case    8:  		/* stw R11, <#[R28 + 4]> */
		/* 8206C8B4h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8206C8B4h case    8:*/		return 0x8206C8B8;
		  /* 8206C8B8h */ case    9:  		/* bl -2872 */
		/* 8206C8B8h case    9:*/		regs.LR = 0x8206C8BC; return 0x8206BD80;
		/* 8206C8B8h case    9:*/		return 0x8206C8BC;
		  /* 8206C8BCh */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 8206C8BCh case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206C8BCh case   10:*/		return 0x8206C8C0;
		  /* 8206C8C0h */ case   11:  		/* bc 4, CR0_LT, 8 */
		/* 8206C8C0h case   11:*/		if ( !regs.CR[0].lt ) { return 0x8206C8C8;  }
		/* 8206C8C0h case   11:*/		return 0x8206C8C4;
		  /* 8206C8C4h */ case   12:  		/* stw R3, <#[R30 + 19900]> */
		/* 8206C8C4h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00004DBC) );
		/* 8206C8C4h case   12:*/		return 0x8206C8C8;
	}
	return 0x8206C8C8;
} // Block from 8206C894h-8206C8C8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206C8C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C8C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C8C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C8C8);
		  /* 8206C8C8h */ case    0:  		/* addi R27, R27, 1 */
		/* 8206C8C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8206C8C8h case    0:*/		return 0x8206C8CC;
		  /* 8206C8CCh */ case    1:  		/* addi R28, R28, 8 */
		/* 8206C8CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 8206C8CCh case    1:*/		return 0x8206C8D0;
	}
	return 0x8206C8D0;
} // Block from 8206C8C8h-8206C8D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206C8D0h
// Function '?push_back@?$D3DFastVector@T_UCODE_VSOUTPUTDECLARATION@@$1?MemAlloc@D3D@@YAPAXK@Z$1?MemFree@3@YAXPAX@Z@D3D@@QAAXABT_UCODE_VSOUTPUTDECLARATION@@AAJ@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C8D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C8D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C8D0);
		  /* 8206C8D0h */ case    0:  		/* addi R29, R29, 9936 */
		/* 8206C8D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x26D0);
		/* 8206C8D0h case    0:*/		return 0x8206C8D4;
		  /* 8206C8D4h */ case    1:  		/* cmplwi CR6, R27, 2 */
		/* 8206C8D4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000002);
		/* 8206C8D4h case    1:*/		return 0x8206C8D8;
		  /* 8206C8D8h */ case    2:  		/* bc 12, CR6_LT, -112 */
		/* 8206C8D8h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206C868;  }
		/* 8206C8D8h case    2:*/		return 0x8206C8DC;
		  /* 8206C8DCh */ case    3:  		/* lwz R11, <#[R30 + 19952]> */
		/* 8206C8DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00004DF0) );
		/* 8206C8DCh case    3:*/		return 0x8206C8E0;
		  /* 8206C8E0h */ case    4:  		/* li R5, 36 */
		/* 8206C8E0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 8206C8E0h case    4:*/		return 0x8206C8E4;
		  /* 8206C8E4h */ case    5:  		/* lwz R10, <#[R1 + 96]> */
		/* 8206C8E4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 8206C8E4h case    5:*/		return 0x8206C8E8;
		  /* 8206C8E8h */ case    6:  		/* addi R4, R1, 96 */
		/* 8206C8E8h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8206C8E8h case    6:*/		return 0x8206C8EC;
		  /* 8206C8ECh */ case    7:  		/* lwz R9, <#[R26 + 12]> */
		/* 8206C8ECh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x0000000C) );
		/* 8206C8ECh case    7:*/		return 0x8206C8F0;
		  /* 8206C8F0h */ case    8:  		/* mr R3, R31 */
		/* 8206C8F0h case    8:*/		regs.R3 = regs.R31;
		/* 8206C8F0h case    8:*/		return 0x8206C8F4;
		  /* 8206C8F4h */ case    9:  		/* lwz R8, <#[R31 + 12]> */
		/* 8206C8F4h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206C8F4h case    9:*/		return 0x8206C8F8;
		  /* 8206C8F8h */ case   10:  		/* rlwimi R10, R11, 4, 27, 27 */
		/* 8206C8F8h case   10:*/		cpu::op::rlwimi<0,4,27,27>(regs,&regs.R10,regs.R11);
		/* 8206C8F8h case   10:*/		return 0x8206C8FC;
		  /* 8206C8FCh */ case   11:  		/* lwz R29, <#[R31 + 4]> */
		/* 8206C8FCh case   11:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C8FCh case   11:*/		return 0x8206C900;
		  /* 8206C900h */ case   12:  		/* stw R25, <#[R31 + 4]> */
		/* 8206C900h case   12:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C900h case   12:*/		return 0x8206C904;
		  /* 8206C904h */ case   13:  		/* stw R10, <#[R1 + 96]> */
		/* 8206C904h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 8206C904h case   13:*/		return 0x8206C908;
		  /* 8206C908h */ case   14:  		/* stw R9, <#[R1 + 104]> */
		/* 8206C908h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000068) );
		/* 8206C908h case   14:*/		return 0x8206C90C;
		  /* 8206C90Ch */ case   15:  		/* stw R8, <#[R1 + 100]> */
		/* 8206C90Ch case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000064) );
		/* 8206C90Ch case   15:*/		return 0x8206C910;
		  /* 8206C910h */ case   16:  		/* bl -21104 */
		/* 8206C910h case   16:*/		regs.LR = 0x8206C914; return 0x820676A0;
		/* 8206C910h case   16:*/		return 0x8206C914;
		  /* 8206C914h */ case   17:  		/* stw R29, <#[R31 + 4]> */
		/* 8206C914h case   17:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C914h case   17:*/		return 0x8206C918;
		  /* 8206C918h */ case   18:  		/* lwz R11, <#[R26 + 16]> */
		/* 8206C918h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000010) );
		/* 8206C918h case   18:*/		return 0x8206C91C;
		  /* 8206C91Ch */ case   19:  		/* cmpwi CR6, R11, 0 */
		/* 8206C91Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206C91Ch case   19:*/		return 0x8206C920;
		  /* 8206C920h */ case   20:  		/* bc 12, CR6_LT, 16 */
		/* 8206C920h case   20:*/		if ( regs.CR[6].lt ) { return 0x8206C930;  }
		/* 8206C920h case   20:*/		return 0x8206C924;
		  /* 8206C924h */ case   21:  		/* lwz R11, <#[R26 + 36]> */
		/* 8206C924h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000024) );
		/* 8206C924h case   21:*/		return 0x8206C928;
		  /* 8206C928h */ case   22:  		/* cmpwi CR6, R11, 0 */
		/* 8206C928h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206C928h case   22:*/		return 0x8206C92C;
		  /* 8206C92Ch */ case   23:  		/* bc 4, CR6_LT, 8 */
		/* 8206C92Ch case   23:*/		if ( !regs.CR[6].lt ) { return 0x8206C934;  }
		/* 8206C92Ch case   23:*/		return 0x8206C930;
	}
	return 0x8206C930;
} // Block from 8206C8D0h-8206C930h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8206C930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C930);
		  /* 8206C930h */ case    0:  		/* stw R11, <#[R30 + 19900]> */
		/* 8206C930h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00004DBC) );
		/* 8206C930h case    0:*/		return 0x8206C934;
	}
	return 0x8206C934;
} // Block from 8206C930h-8206C934h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206C934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C934);
		  /* 8206C934h */ case    0:  		/* lwz R3, <#[R30 + 19900]> */
		/* 8206C934h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00004DBC) );
		/* 8206C934h case    0:*/		return 0x8206C938;
	}
	return 0x8206C938;
} // Block from 8206C934h-8206C938h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206C938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C938);
		  /* 8206C938h */ case    0:  		/* addi R1, R1, 208 */
		/* 8206C938h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 8206C938h case    0:*/		return 0x8206C93C;
		  /* 8206C93Ch */ case    1:  		/* b 149856 */
		/* 8206C93Ch case    1:*/		return 0x8209129C;
		/* 8206C93Ch case    1:*/		return 0x8206C940;
	}
	return 0x8206C940;
} // Block from 8206C938h-8206C940h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206C940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C940);
		  /* 8206C940h */ case    0:  		/* mfspr R12, LR */
		/* 8206C940h case    0:*/		regs.R12 = regs.LR;
		/* 8206C940h case    0:*/		return 0x8206C944;
		  /* 8206C944h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206C944h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206C944h case    1:*/		return 0x8206C948;
		  /* 8206C948h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8206C948h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206C948h case    2:*/		return 0x8206C94C;
		  /* 8206C94Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8206C94Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8206C94Ch case    3:*/		return 0x8206C950;
		  /* 8206C950h */ case    4:  		/* lis R4, 25728 */
		/* 8206C950h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x6480);
		/* 8206C950h case    4:*/		return 0x8206C954;
		  /* 8206C954h */ case    5:  		/* li R3, 19968 */
		/* 8206C954h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x4E00);
		/* 8206C954h case    5:*/		return 0x8206C958;
		  /* 8206C958h */ case    6:  		/* bl 112808 */
		/* 8206C958h case    6:*/		regs.LR = 0x8206C95C; return 0x82088200;
		/* 8206C958h case    6:*/		return 0x8206C95C;
		  /* 8206C95Ch */ case    7:  		/* or. R31, R3, R3 */
		/* 8206C95Ch case    7:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8206C95Ch case    7:*/		return 0x8206C960;
		  /* 8206C960h */ case    8:  		/* bc 4, CR0_EQ, 12 */
		/* 8206C960h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8206C96C;  }
		/* 8206C960h case    8:*/		return 0x8206C964;
		  /* 8206C964h */ case    9:  		/* li R3, 0 */
		/* 8206C964h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8206C964h case    9:*/		return 0x8206C968;
		  /* 8206C968h */ case   10:  		/* b 16 */
		/* 8206C968h case   10:*/		return 0x8206C978;
		/* 8206C968h case   10:*/		return 0x8206C96C;
	}
	return 0x8206C96C;
} // Block from 8206C940h-8206C96Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206C96Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C96C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C96C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C96C);
		  /* 8206C96Ch */ case    0:  		/* mr R3, R31 */
		/* 8206C96Ch case    0:*/		regs.R3 = regs.R31;
		/* 8206C96Ch case    0:*/		return 0x8206C970;
		  /* 8206C970h */ case    1:  		/* bl -792 */
		/* 8206C970h case    1:*/		regs.LR = 0x8206C974; return 0x8206C658;
		/* 8206C970h case    1:*/		return 0x8206C974;
		  /* 8206C974h */ case    2:  		/* mr R3, R31 */
		/* 8206C974h case    2:*/		regs.R3 = regs.R31;
		/* 8206C974h case    2:*/		return 0x8206C978;
	}
	return 0x8206C978;
} // Block from 8206C96Ch-8206C978h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206C978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C978);
		  /* 8206C978h */ case    0:  		/* addi R1, R1, 96 */
		/* 8206C978h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206C978h case    0:*/		return 0x8206C97C;
		  /* 8206C97Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206C97Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206C97Ch case    1:*/		return 0x8206C980;
		  /* 8206C980h */ case    2:  		/* mtspr LR, R12 */
		/* 8206C980h case    2:*/		regs.LR = regs.R12;
		/* 8206C980h case    2:*/		return 0x8206C984;
		  /* 8206C984h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8206C984h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206C984h case    3:*/		return 0x8206C988;
		  /* 8206C988h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8206C988h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206C988h case    4:*/		return 0x8206C98C;
	}
	return 0x8206C98C;
} // Block from 8206C978h-8206C98Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206C98Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C98C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C98C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C98C);
		  /* 8206C98Ch */ case    0:  		/* nop */
		/* 8206C98Ch case    0:*/		cpu::op::nop();
		/* 8206C98Ch case    0:*/		return 0x8206C990;
	}
	return 0x8206C990;
} // Block from 8206C98Ch-8206C990h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206C990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C990);
		  /* 8206C990h */ case    0:  		/* mfspr R12, LR */
		/* 8206C990h case    0:*/		regs.R12 = regs.LR;
		/* 8206C990h case    0:*/		return 0x8206C994;
		  /* 8206C994h */ case    1:  		/* bl 149704 */
		/* 8206C994h case    1:*/		regs.LR = 0x8206C998; return 0x8209125C;
		/* 8206C994h case    1:*/		return 0x8206C998;
	}
	return 0x8206C998;
} // Block from 8206C990h-8206C998h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206C998h
// Function '?resize@?$D3DFastVector@K@CMicrocodeBuilder@D3D@@QAAXKAAJ@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C998);
		  /* 8206C998h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206C998h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206C998h case    0:*/		return 0x8206C99C;
		  /* 8206C99Ch */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 8206C99Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8206C99Ch case    1:*/		return 0x8206C9A0;
		  /* 8206C9A0h */ case    2:  		/* mr R30, R4 */
		/* 8206C9A0h case    2:*/		regs.R30 = regs.R4;
		/* 8206C9A0h case    2:*/		return 0x8206C9A4;
		  /* 8206C9A4h */ case    3:  		/* lwz R10, <#[R3 + 8]> */
		/* 8206C9A4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8206C9A4h case    3:*/		return 0x8206C9A8;
		  /* 8206C9A8h */ case    4:  		/* mr R31, R3 */
		/* 8206C9A8h case    4:*/		regs.R31 = regs.R3;
		/* 8206C9A8h case    4:*/		return 0x8206C9AC;
		  /* 8206C9ACh */ case    5:  		/* addi R4, R11, 1 */
		/* 8206C9ACh case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1);
		/* 8206C9ACh case    5:*/		return 0x8206C9B0;
		  /* 8206C9B0h */ case    6:  		/* mr R29, R5 */
		/* 8206C9B0h case    6:*/		regs.R29 = regs.R5;
		/* 8206C9B0h case    6:*/		return 0x8206C9B4;
		  /* 8206C9B4h */ case    7:  		/* cmplw CR6, R4, R10 */
		/* 8206C9B4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 8206C9B4h case    7:*/		return 0x8206C9B8;
		  /* 8206C9B8h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 8206C9B8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8206C9C0;  }
		/* 8206C9B8h case    8:*/		return 0x8206C9BC;
		  /* 8206C9BCh */ case    9:  		/* bl -9148 */
		/* 8206C9BCh case    9:*/		regs.LR = 0x8206C9C0; return 0x8206A600;
		/* 8206C9BCh case    9:*/		return 0x8206C9C0;
	}
	return 0x8206C9C0;
} // Block from 8206C998h-8206C9C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206C9C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206C9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206C9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206C9C0);
		  /* 8206C9C0h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8206C9C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8206C9C0h case    0:*/		return 0x8206C9C4;
		  /* 8206C9C4h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8206C9C4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206C9C4h case    1:*/		return 0x8206C9C8;
		  /* 8206C9C8h */ case    2:  		/* bc 12, CR6_LT, 56 */
		/* 8206C9C8h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206CA00;  }
		/* 8206C9C8h case    2:*/		return 0x8206C9CC;
		  /* 8206C9CCh */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206C9CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C9CCh case    3:*/		return 0x8206C9D0;
		  /* 8206C9D0h */ case    4:  		/* lwz R10, <#[R31]> */
		/* 8206C9D0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8206C9D0h case    4:*/		return 0x8206C9D4;
		  /* 8206C9D4h */ case    5:  		/* lwz R9, <#[R30]> */
		/* 8206C9D4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8206C9D4h case    5:*/		return 0x8206C9D8;
		  /* 8206C9D8h */ case    6:  		/* mulli R11, R11, 12 */
		/* 8206C9D8h case    6:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8206C9D8h case    6:*/		return 0x8206C9DC;
		  /* 8206C9DCh */ case    7:  		/* stwx R9, <#[R11 + R10]> */
		/* 8206C9DCh case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8206C9DCh case    7:*/		return 0x8206C9E0;
		  /* 8206C9E0h */ case    8:  		/* lwz R9, <#[R30 + 4]> */
		/* 8206C9E0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000004) );
		/* 8206C9E0h case    8:*/		return 0x8206C9E4;
		  /* 8206C9E4h */ case    9:  		/* add R11, R11, R10 */
		/* 8206C9E4h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206C9E4h case    9:*/		return 0x8206C9E8;
		  /* 8206C9E8h */ case   10:  		/* stw R9, <#[R11 + 4]> */
		/* 8206C9E8h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8206C9E8h case   10:*/		return 0x8206C9EC;
		  /* 8206C9ECh */ case   11:  		/* lwz R10, <#[R30 + 8]> */
		/* 8206C9ECh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8206C9ECh case   11:*/		return 0x8206C9F0;
		  /* 8206C9F0h */ case   12:  		/* stw R10, <#[R11 + 8]> */
		/* 8206C9F0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8206C9F0h case   12:*/		return 0x8206C9F4;
		  /* 8206C9F4h */ case   13:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206C9F4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C9F4h case   13:*/		return 0x8206C9F8;
		  /* 8206C9F8h */ case   14:  		/* addi R11, R11, 1 */
		/* 8206C9F8h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206C9F8h case   14:*/		return 0x8206C9FC;
		  /* 8206C9FCh */ case   15:  		/* stw R11, <#[R31 + 4]> */
		/* 8206C9FCh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206C9FCh case   15:*/		return 0x8206CA00;
	}
	return 0x8206CA00;
} // Block from 8206C9C0h-8206CA00h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206CA00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CA00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CA00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CA00);
		  /* 8206CA00h */ case    0:  		/* addi R1, R1, 112 */
		/* 8206CA00h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206CA00h case    0:*/		return 0x8206CA04;
		  /* 8206CA04h */ case    1:  		/* b 149672 */
		/* 8206CA04h case    1:*/		return 0x820912AC;
		/* 8206CA04h case    1:*/		return 0x8206CA08;
	}
	return 0x8206CA08;
} // Block from 8206CA00h-8206CA08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206CA08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CA08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CA08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CA08);
		  /* 8206CA08h */ case    0:  		/* mfspr R12, LR */
		/* 8206CA08h case    0:*/		regs.R12 = regs.LR;
		/* 8206CA08h case    0:*/		return 0x8206CA0C;
		  /* 8206CA0Ch */ case    1:  		/* bl 149584 */
		/* 8206CA0Ch case    1:*/		regs.LR = 0x8206CA10; return 0x8209125C;
		/* 8206CA0Ch case    1:*/		return 0x8206CA10;
		  /* 8206CA10h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206CA10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206CA10h case    2:*/		return 0x8206CA14;
		  /* 8206CA14h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8206CA14h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8206CA14h case    3:*/		return 0x8206CA18;
		  /* 8206CA18h */ case    4:  		/* mr R30, R4 */
		/* 8206CA18h case    4:*/		regs.R30 = regs.R4;
		/* 8206CA18h case    4:*/		return 0x8206CA1C;
		  /* 8206CA1Ch */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 8206CA1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8206CA1Ch case    5:*/		return 0x8206CA20;
		  /* 8206CA20h */ case    6:  		/* mr R31, R3 */
		/* 8206CA20h case    6:*/		regs.R31 = regs.R3;
		/* 8206CA20h case    6:*/		return 0x8206CA24;
		  /* 8206CA24h */ case    7:  		/* addi R4, R11, 1 */
		/* 8206CA24h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1);
		/* 8206CA24h case    7:*/		return 0x8206CA28;
		  /* 8206CA28h */ case    8:  		/* mr R29, R5 */
		/* 8206CA28h case    8:*/		regs.R29 = regs.R5;
		/* 8206CA28h case    8:*/		return 0x8206CA2C;
		  /* 8206CA2Ch */ case    9:  		/* cmplw CR6, R4, R10 */
		/* 8206CA2Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 8206CA2Ch case    9:*/		return 0x8206CA30;
	}
	return 0x8206CA30;
} // Block from 8206CA08h-8206CA30h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206CA30h
// Function 'D3DDevice_BeginVertices'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CA30);
		  /* 8206CA30h */ case    0:  		/* bc 4, CR6_GT, 8 */
		/* 8206CA30h case    0:*/		if ( !regs.CR[6].gt ) { return 0x8206CA38;  }
		/* 8206CA30h case    0:*/		return 0x8206CA34;
		  /* 8206CA34h */ case    1:  		/* bl -9124 */
		/* 8206CA34h case    1:*/		regs.LR = 0x8206CA38; return 0x8206A690;
		/* 8206CA34h case    1:*/		return 0x8206CA38;
	}
	return 0x8206CA38;
} // Block from 8206CA30h-8206CA38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206CA38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CA38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CA38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CA38);
		  /* 8206CA38h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8206CA38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8206CA38h case    0:*/		return 0x8206CA3C;
		  /* 8206CA3Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8206CA3Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206CA3Ch case    1:*/		return 0x8206CA40;
		  /* 8206CA40h */ case    2:  		/* bc 12, CR6_LT, 48 */
		/* 8206CA40h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206CA70;  }
		/* 8206CA40h case    2:*/		return 0x8206CA44;
		  /* 8206CA44h */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206CA44h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206CA44h case    3:*/		return 0x8206CA48;
		  /* 8206CA48h */ case    4:  		/* lwz R10, <#[R31]> */
		/* 8206CA48h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8206CA48h case    4:*/		return 0x8206CA4C;
		  /* 8206CA4Ch */ case    5:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8206CA4Ch case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8206CA4Ch case    5:*/		return 0x8206CA50;
		  /* 8206CA50h */ case    6:  		/* lwz R9, <#[R30]> */
		/* 8206CA50h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8206CA50h case    6:*/		return 0x8206CA54;
		  /* 8206CA54h */ case    7:  		/* add R8, R11, R10 */
		/* 8206CA54h case    7:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R10);
		/* 8206CA54h case    7:*/		return 0x8206CA58;
		  /* 8206CA58h */ case    8:  		/* stwx R9, <#[R11 + R10]> */
		/* 8206CA58h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8206CA58h case    8:*/		return 0x8206CA5C;
		  /* 8206CA5Ch */ case    9:  		/* lwz R11, <#[R30 + 4]> */
		/* 8206CA5Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8206CA5Ch case    9:*/		return 0x8206CA60;
		  /* 8206CA60h */ case   10:  		/* stw R11, <#[R8 + 4]> */
		/* 8206CA60h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 8206CA60h case   10:*/		return 0x8206CA64;
		  /* 8206CA64h */ case   11:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206CA64h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206CA64h case   11:*/		return 0x8206CA68;
		  /* 8206CA68h */ case   12:  		/* addi R11, R11, 1 */
		/* 8206CA68h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206CA68h case   12:*/		return 0x8206CA6C;
		  /* 8206CA6Ch */ case   13:  		/* stw R11, <#[R31 + 4]> */
		/* 8206CA6Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206CA6Ch case   13:*/		return 0x8206CA70;
	}
	return 0x8206CA70;
} // Block from 8206CA38h-8206CA70h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206CA70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CA70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CA70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CA70);
		  /* 8206CA70h */ case    0:  		/* addi R1, R1, 112 */
		/* 8206CA70h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206CA70h case    0:*/		return 0x8206CA74;
		  /* 8206CA74h */ case    1:  		/* b 149560 */
		/* 8206CA74h case    1:*/		return 0x820912AC;
		/* 8206CA74h case    1:*/		return 0x8206CA78;
	}
	return 0x8206CA78;
} // Block from 8206CA70h-8206CA78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206CA78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CA78);
		  /* 8206CA78h */ case    0:  		/* mfspr R12, LR */
		/* 8206CA78h case    0:*/		regs.R12 = regs.LR;
		/* 8206CA78h case    0:*/		return 0x8206CA7C;
		  /* 8206CA7Ch */ case    1:  		/* bl 149472 */
		/* 8206CA7Ch case    1:*/		regs.LR = 0x8206CA80; return 0x8209125C;
		/* 8206CA7Ch case    1:*/		return 0x8206CA80;
		  /* 8206CA80h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206CA80h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206CA80h case    2:*/		return 0x8206CA84;
		  /* 8206CA84h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8206CA84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8206CA84h case    3:*/		return 0x8206CA88;
		  /* 8206CA88h */ case    4:  		/* mr R29, R4 */
		/* 8206CA88h case    4:*/		regs.R29 = regs.R4;
		/* 8206CA88h case    4:*/		return 0x8206CA8C;
		  /* 8206CA8Ch */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 8206CA8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8206CA8Ch case    5:*/		return 0x8206CA90;
		  /* 8206CA90h */ case    6:  		/* mr R31, R3 */
		/* 8206CA90h case    6:*/		regs.R31 = regs.R3;
		/* 8206CA90h case    6:*/		return 0x8206CA94;
		  /* 8206CA94h */ case    7:  		/* addi R4, R11, 1 */
		/* 8206CA94h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1);
		/* 8206CA94h case    7:*/		return 0x8206CA98;
		  /* 8206CA98h */ case    8:  		/* mr R30, R5 */
		/* 8206CA98h case    8:*/		regs.R30 = regs.R5;
		/* 8206CA98h case    8:*/		return 0x8206CA9C;
		  /* 8206CA9Ch */ case    9:  		/* cmplw CR6, R4, R10 */
		/* 8206CA9Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 8206CA9Ch case    9:*/		return 0x8206CAA0;
		  /* 8206CAA0h */ case   10:  		/* bc 4, CR6_GT, 8 */
		/* 8206CAA0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8206CAA8;  }
		/* 8206CAA0h case   10:*/		return 0x8206CAA4;
		  /* 8206CAA4h */ case   11:  		/* bl -9092 */
		/* 8206CAA4h case   11:*/		regs.LR = 0x8206CAA8; return 0x8206A720;
		/* 8206CAA4h case   11:*/		return 0x8206CAA8;
	}
	return 0x8206CAA8;
} // Block from 8206CA78h-8206CAA8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206CAA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CAA8);
		  /* 8206CAA8h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8206CAA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206CAA8h case    0:*/		return 0x8206CAAC;
		  /* 8206CAACh */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8206CAACh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206CAACh case    1:*/		return 0x8206CAB0;
		  /* 8206CAB0h */ case    2:  		/* bc 12, CR6_LT, 36 */
		/* 8206CAB0h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206CAD4;  }
		/* 8206CAB0h case    2:*/		return 0x8206CAB4;
		  /* 8206CAB4h */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206CAB4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206CAB4h case    3:*/		return 0x8206CAB8;
		  /* 8206CAB8h */ case    4:  		/* lwz R10, <#[R29]> */
		/* 8206CAB8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8206CAB8h case    4:*/		return 0x8206CABC;
		  /* 8206CABCh */ case    5:  		/* lwz R9, <#[R31]> */
		/* 8206CABCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8206CABCh case    5:*/		return 0x8206CAC0;
		  /* 8206CAC0h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206CAC0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206CAC0h case    6:*/		return 0x8206CAC4;
		  /* 8206CAC4h */ case    7:  		/* stwx R10, <#[R11 + R9]> */
		/* 8206CAC4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8206CAC4h case    7:*/		return 0x8206CAC8;
		  /* 8206CAC8h */ case    8:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206CAC8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206CAC8h case    8:*/		return 0x8206CACC;
		  /* 8206CACCh */ case    9:  		/* addi R11, R11, 1 */
		/* 8206CACCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206CACCh case    9:*/		return 0x8206CAD0;
		  /* 8206CAD0h */ case   10:  		/* stw R11, <#[R31 + 4]> */
		/* 8206CAD0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206CAD0h case   10:*/		return 0x8206CAD4;
	}
	return 0x8206CAD4;
} // Block from 8206CAA8h-8206CAD4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206CAD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CAD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CAD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CAD4);
		  /* 8206CAD4h */ case    0:  		/* addi R1, R1, 112 */
		/* 8206CAD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206CAD4h case    0:*/		return 0x8206CAD8;
		  /* 8206CAD8h */ case    1:  		/* b 149460 */
		/* 8206CAD8h case    1:*/		return 0x820912AC;
		/* 8206CAD8h case    1:*/		return 0x8206CADC;
		  /* 8206CADCh */ case    2:  		/* nop */
		/* 8206CADCh case    2:*/		cpu::op::nop();
		/* 8206CADCh case    2:*/		return 0x8206CAE0;
	}
	return 0x8206CAE0;
} // Block from 8206CAD4h-8206CAE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206CAE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CAE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CAE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CAE0);
		  /* 8206CAE0h */ case    0:  		/* mfspr R12, LR */
		/* 8206CAE0h case    0:*/		regs.R12 = regs.LR;
		/* 8206CAE0h case    0:*/		return 0x8206CAE4;
		  /* 8206CAE4h */ case    1:  		/* bl 149368 */
		/* 8206CAE4h case    1:*/		regs.LR = 0x8206CAE8; return 0x8209125C;
		/* 8206CAE4h case    1:*/		return 0x8206CAE8;
		  /* 8206CAE8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206CAE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206CAE8h case    2:*/		return 0x8206CAEC;
		  /* 8206CAECh */ case    3:  		/* mr R31, R3 */
		/* 8206CAECh case    3:*/		regs.R31 = regs.R3;
		/* 8206CAECh case    3:*/		return 0x8206CAF0;
		  /* 8206CAF0h */ case    4:  		/* mr R29, R4 */
		/* 8206CAF0h case    4:*/		regs.R29 = regs.R4;
		/* 8206CAF0h case    4:*/		return 0x8206CAF4;
		  /* 8206CAF4h */ case    5:  		/* bl -6772 */
		/* 8206CAF4h case    5:*/		regs.LR = 0x8206CAF8; return 0x8206B080;
		/* 8206CAF4h case    5:*/		return 0x8206CAF8;
		  /* 8206CAF8h */ case    6:  		/* li R30, 0 */
		/* 8206CAF8h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8206CAF8h case    6:*/		return 0x8206CAFC;
		  /* 8206CAFCh */ case    7:  		/* stw R29, <#[R31]> */
		/* 8206CAFCh case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 8206CAFCh case    7:*/		return 0x8206CB00;
		  /* 8206CB00h */ case    8:  		/* lwz R11, <#[R31 + 104]> */
		/* 8206CB00h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 8206CB00h case    8:*/		return 0x8206CB04;
		  /* 8206CB04h */ case    9:  		/* addi R3, R31, 96 */
		/* 8206CB04h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x60);
		/* 8206CB04h case    9:*/		return 0x8206CB08;
		  /* 8206CB08h */ case   10:  		/* stw R30, <#[R31 + 100]> */
		/* 8206CB08h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000064) );
		/* 8206CB08h case   10:*/		return 0x8206CB0C;
		  /* 8206CB0Ch */ case   11:  		/* cmplwi CR6, R11, 100 */
		/* 8206CB0Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000064);
		/* 8206CB0Ch case   11:*/		return 0x8206CB10;
		  /* 8206CB10h */ case   12:  		/* bc 4, CR6_LT, 16 */
		/* 8206CB10h case   12:*/		if ( !regs.CR[6].lt ) { return 0x8206CB20;  }
		/* 8206CB10h case   12:*/		return 0x8206CB14;
		  /* 8206CB14h */ case   13:  		/* addi R5, R31, 80 */
		/* 8206CB14h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206CB14h case   13:*/		return 0x8206CB18;
		  /* 8206CB18h */ case   14:  		/* li R4, 100 */
		/* 8206CB18h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x64);
		/* 8206CB18h case   14:*/		return 0x8206CB1C;
		  /* 8206CB1Ch */ case   15:  		/* bl -9500 */
		/* 8206CB1Ch case   15:*/		regs.LR = 0x8206CB20; return 0x8206A600;
		/* 8206CB1Ch case   15:*/		return 0x8206CB20;
	}
	return 0x8206CB20;
} // Block from 8206CAE0h-8206CB20h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206CB20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CB20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CB20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CB20);
		  /* 8206CB20h */ case    0:  		/* lwz R11, <#[R31 + 116]> */
		/* 8206CB20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000074) );
		/* 8206CB20h case    0:*/		return 0x8206CB24;
		  /* 8206CB24h */ case    1:  		/* addi R3, R31, 108 */
		/* 8206CB24h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x6C);
		/* 8206CB24h case    1:*/		return 0x8206CB28;
		  /* 8206CB28h */ case    2:  		/* stw R30, <#[R31 + 112]> */
		/* 8206CB28h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000070) );
		/* 8206CB28h case    2:*/		return 0x8206CB2C;
		  /* 8206CB2Ch */ case    3:  		/* cmplwi CR6, R11, 50 */
		/* 8206CB2Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000032);
		/* 8206CB2Ch case    3:*/		return 0x8206CB30;
		  /* 8206CB30h */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 8206CB30h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8206CB40;  }
		/* 8206CB30h case    4:*/		return 0x8206CB34;
		  /* 8206CB34h */ case    5:  		/* addi R5, R31, 80 */
		/* 8206CB34h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206CB34h case    5:*/		return 0x8206CB38;
		  /* 8206CB38h */ case    6:  		/* li R4, 50 */
		/* 8206CB38h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x32);
		/* 8206CB38h case    6:*/		return 0x8206CB3C;
		  /* 8206CB3Ch */ case    7:  		/* bl -9388 */
		/* 8206CB3Ch case    7:*/		regs.LR = 0x8206CB40; return 0x8206A690;
		/* 8206CB3Ch case    7:*/		return 0x8206CB40;
	}
	return 0x8206CB40;
} // Block from 8206CB20h-8206CB40h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206CB40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CB40);
		  /* 8206CB40h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8206CB40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206CB40h case    0:*/		return 0x8206CB44;
		  /* 8206CB44h */ case    1:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206CB44h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206CB44h case    1:*/		return 0x8206CB48;
		  /* 8206CB48h */ case    2:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 8206CB48h case    2:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8206CB48h case    2:*/		return 0x8206CB4C;
		  /* 8206CB4Ch */ case    3:  		/* bc 12, CR0_EQ, 40 */
		/* 8206CB4Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8206CB74;  }
		/* 8206CB4Ch case    3:*/		return 0x8206CB50;
		  /* 8206CB50h */ case    4:  		/* lwz R11, <#[R31 + 276]> */
		/* 8206CB50h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000114) );
		/* 8206CB50h case    4:*/		return 0x8206CB54;
		  /* 8206CB54h */ case    5:  		/* addi R3, R31, 268 */
		/* 8206CB54h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x10C);
		/* 8206CB54h case    5:*/		return 0x8206CB58;
		  /* 8206CB58h */ case    6:  		/* stw R30, <#[R31 + 272]> */
		/* 8206CB58h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000110) );
		/* 8206CB58h case    6:*/		return 0x8206CB5C;
		  /* 8206CB5Ch */ case    7:  		/* cmplwi CR6, R11, 16 */
		/* 8206CB5Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8206CB5Ch case    7:*/		return 0x8206CB60;
		  /* 8206CB60h */ case    8:  		/* bc 4, CR6_LT, 116 */
		/* 8206CB60h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8206CBD4;  }
		/* 8206CB60h case    8:*/		return 0x8206CB64;
		  /* 8206CB64h */ case    9:  		/* addi R5, R31, 80 */
		/* 8206CB64h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206CB64h case    9:*/		return 0x8206CB68;
		  /* 8206CB68h */ case   10:  		/* li R4, 16 */
		/* 8206CB68h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 8206CB68h case   10:*/		return 0x8206CB6C;
		  /* 8206CB6Ch */ case   11:  		/* bl -9292 */
		/* 8206CB6Ch case   11:*/		regs.LR = 0x8206CB70; return 0x8206A720;
		/* 8206CB6Ch case   11:*/		return 0x8206CB70;
		  /* 8206CB70h */ case   12:  		/* b 100 */
		/* 8206CB70h case   12:*/		return 0x8206CBD4;
		/* 8206CB70h case   12:*/		return 0x8206CB74;
	}
	return 0x8206CB74;
} // Block from 8206CB40h-8206CB74h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206CB74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CB74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CB74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CB74);
		  /* 8206CB74h */ case    0:  		/* lwz R11, <#[R31 + 288]> */
		/* 8206CB74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000120) );
		/* 8206CB74h case    0:*/		return 0x8206CB78;
		  /* 8206CB78h */ case    1:  		/* addi R3, R31, 280 */
		/* 8206CB78h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x118);
		/* 8206CB78h case    1:*/		return 0x8206CB7C;
		  /* 8206CB7Ch */ case    2:  		/* stw R30, <#[R31 + 284]> */
		/* 8206CB7Ch case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000011C) );
		/* 8206CB7Ch case    2:*/		return 0x8206CB80;
		  /* 8206CB80h */ case    3:  		/* cmplwi CR6, R11, 2 */
		/* 8206CB80h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 8206CB80h case    3:*/		return 0x8206CB84;
		  /* 8206CB84h */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 8206CB84h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8206CB94;  }
		/* 8206CB84h case    4:*/		return 0x8206CB88;
		  /* 8206CB88h */ case    5:  		/* addi R5, R31, 80 */
		/* 8206CB88h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206CB88h case    5:*/		return 0x8206CB8C;
		  /* 8206CB8Ch */ case    6:  		/* li R4, 2 */
		/* 8206CB8Ch case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8206CB8Ch case    6:*/		return 0x8206CB90;
		  /* 8206CB90h */ case    7:  		/* bl -9328 */
		/* 8206CB90h case    7:*/		regs.LR = 0x8206CB94; return 0x8206A720;
		/* 8206CB90h case    7:*/		return 0x8206CB94;
	}
	return 0x8206CB94;
} // Block from 8206CB74h-8206CB94h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206CB94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CB94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CB94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CB94);
		  /* 8206CB94h */ case    0:  		/* lwz R11, <#[R31 + 300]> */
		/* 8206CB94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000012C) );
		/* 8206CB94h case    0:*/		return 0x8206CB98;
		  /* 8206CB98h */ case    1:  		/* addi R3, R31, 292 */
		/* 8206CB98h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x124);
		/* 8206CB98h case    1:*/		return 0x8206CB9C;
		  /* 8206CB9Ch */ case    2:  		/* stw R30, <#[R31 + 296]> */
		/* 8206CB9Ch case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000128) );
		/* 8206CB9Ch case    2:*/		return 0x8206CBA0;
		  /* 8206CBA0h */ case    3:  		/* cmplwi CR6, R11, 16 */
		/* 8206CBA0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8206CBA0h case    3:*/		return 0x8206CBA4;
		  /* 8206CBA4h */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 8206CBA4h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8206CBB4;  }
		/* 8206CBA4h case    4:*/		return 0x8206CBA8;
		  /* 8206CBA8h */ case    5:  		/* addi R5, R31, 80 */
		/* 8206CBA8h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206CBA8h case    5:*/		return 0x8206CBAC;
		  /* 8206CBACh */ case    6:  		/* li R4, 16 */
		/* 8206CBACh case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 8206CBACh case    6:*/		return 0x8206CBB0;
		  /* 8206CBB0h */ case    7:  		/* bl -9360 */
		/* 8206CBB0h case    7:*/		regs.LR = 0x8206CBB4; return 0x8206A720;
		/* 8206CBB0h case    7:*/		return 0x8206CBB4;
	}
	return 0x8206CBB4;
} // Block from 8206CB94h-8206CBB4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206CBB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CBB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CBB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CBB4);
		  /* 8206CBB4h */ case    0:  		/* lwz R11, <#[R31 + 312]> */
		/* 8206CBB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000138) );
		/* 8206CBB4h case    0:*/		return 0x8206CBB8;
		  /* 8206CBB8h */ case    1:  		/* addi R3, R31, 304 */
		/* 8206CBB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x130);
		/* 8206CBB8h case    1:*/		return 0x8206CBBC;
		  /* 8206CBBCh */ case    2:  		/* stw R30, <#[R31 + 308]> */
		/* 8206CBBCh case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000134) );
		/* 8206CBBCh case    2:*/		return 0x8206CBC0;
		  /* 8206CBC0h */ case    3:  		/* cmplwi CR6, R11, 16 */
		/* 8206CBC0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8206CBC0h case    3:*/		return 0x8206CBC4;
		  /* 8206CBC4h */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 8206CBC4h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8206CBD4;  }
		/* 8206CBC4h case    4:*/		return 0x8206CBC8;
		  /* 8206CBC8h */ case    5:  		/* addi R5, R31, 80 */
		/* 8206CBC8h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206CBC8h case    5:*/		return 0x8206CBCC;
		  /* 8206CBCCh */ case    6:  		/* li R4, 16 */
		/* 8206CBCCh case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 8206CBCCh case    6:*/		return 0x8206CBD0;
		  /* 8206CBD0h */ case    7:  		/* bl -9392 */
		/* 8206CBD0h case    7:*/		regs.LR = 0x8206CBD4; return 0x8206A720;
		/* 8206CBD0h case    7:*/		return 0x8206CBD4;
	}
	return 0x8206CBD4;
} // Block from 8206CBB4h-8206CBD4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206CBD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CBD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CBD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CBD4);
		  /* 8206CBD4h */ case    0:  		/* addi R1, R1, 112 */
		/* 8206CBD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206CBD4h case    0:*/		return 0x8206CBD8;
		  /* 8206CBD8h */ case    1:  		/* b 149204 */
		/* 8206CBD8h case    1:*/		return 0x820912AC;
		/* 8206CBD8h case    1:*/		return 0x8206CBDC;
		  /* 8206CBDCh */ case    2:  		/* nop */
		/* 8206CBDCh case    2:*/		cpu::op::nop();
		/* 8206CBDCh case    2:*/		return 0x8206CBE0;
	}
	return 0x8206CBE0;
} // Block from 8206CBD4h-8206CBE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206CBE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CBE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CBE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CBE0);
		  /* 8206CBE0h */ case    0:  		/* mfspr R12, LR */
		/* 8206CBE0h case    0:*/		regs.R12 = regs.LR;
		/* 8206CBE0h case    0:*/		return 0x8206CBE4;
		  /* 8206CBE4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206CBE4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206CBE4h case    1:*/		return 0x8206CBE8;
		  /* 8206CBE8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8206CBE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8206CBE8h case    2:*/		return 0x8206CBEC;
		  /* 8206CBECh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8206CBECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206CBECh case    3:*/		return 0x8206CBF0;
		  /* 8206CBF0h */ case    4:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206CBF0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206CBF0h case    4:*/		return 0x8206CBF4;
		  /* 8206CBF4h */ case    5:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 8206CBF4h case    5:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8206CBF4h case    5:*/		return 0x8206CBF8;
		  /* 8206CBF8h */ case    6:  		/* bc 12, CR0_EQ, 64 */
		/* 8206CBF8h case    6:*/		if ( regs.CR[0].eq ) { return 0x8206CC38;  }
		/* 8206CBF8h case    6:*/		return 0x8206CBFC;
		  /* 8206CBFCh */ case    7:  		/* rlwinm R10, R6, 17, 0, 14 */
		/* 8206CBFCh case    7:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R10,regs.R6);
		/* 8206CBFCh case    7:*/		return 0x8206CC00;
		  /* 8206CC00h */ case    8:  		/* rlwinm R11, R6, 0, 23, 23 */
		/* 8206CC00h case    8:*/		cpu::op::rlwinm<0,0,23,23>(regs,&regs.R11,regs.R6);
		/* 8206CC00h case    8:*/		return 0x8206CC04;
		  /* 8206CC04h */ case    9:  		/* rlwimi R5, R4, 4, 24, 27 */
		/* 8206CC04h case    9:*/		cpu::op::rlwimi<0,4,24,27>(regs,&regs.R5,regs.R4);
		/* 8206CC04h case    9:*/		return 0x8206CC08;
		  /* 8206CC08h */ case   10:  		/* or R11, R11, R10 */
		/* 8206CC08h case   10:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206CC08h case   10:*/		return 0x8206CC0C;
		  /* 8206CC0Ch */ case   11:  		/* rlwinm R10, R6, 0, 22, 22 */
		/* 8206CC0Ch case   11:*/		cpu::op::rlwinm<0,0,22,22>(regs,&regs.R10,regs.R6);
		/* 8206CC0Ch case   11:*/		return 0x8206CC10;
		  /* 8206CC10h */ case   12:  		/* rlwimi R11, R5, 9, 15, 22 */
		/* 8206CC10h case   12:*/		cpu::op::rlwimi<0,9,15,22>(regs,&regs.R11,regs.R5);
		/* 8206CC10h case   12:*/		return 0x8206CC14;
		  /* 8206CC14h */ case   13:  		/* addi R5, R3, 80 */
		/* 8206CC14h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R3,0x50);
		/* 8206CC14h case   13:*/		return 0x8206CC18;
		  /* 8206CC18h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206CC18h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206CC18h case   14:*/		return 0x8206CC1C;
		  /* 8206CC1Ch */ case   15:  		/* addi R4, R1, 80 */
		/* 8206CC1Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206CC1Ch case   15:*/		return 0x8206CC20;
		  /* 8206CC20h */ case   16:  		/* or R11, R11, R10 */
		/* 8206CC20h case   16:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206CC20h case   16:*/		return 0x8206CC24;
		  /* 8206CC24h */ case   17:  		/* addi R3, R3, 268 */
		/* 8206CC24h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x10C);
		/* 8206CC24h case   17:*/		return 0x8206CC28;
		  /* 8206CC28h */ case   18:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8206CC28h case   18:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8206CC28h case   18:*/		return 0x8206CC2C;
		  /* 8206CC2Ch */ case   19:  		/* stw R11, <#[R1 + 80]> */
		/* 8206CC2Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206CC2Ch case   19:*/		return 0x8206CC30;
		  /* 8206CC30h */ case   20:  		/* bl -440 */
		/* 8206CC30h case   20:*/		regs.LR = 0x8206CC34; return 0x8206CA78;
		/* 8206CC30h case   20:*/		return 0x8206CC34;
		  /* 8206CC34h */ case   21:  		/* b 36 */
		/* 8206CC34h case   21:*/		return 0x8206CC58;
		/* 8206CC34h case   21:*/		return 0x8206CC38;
	}
	return 0x8206CC38;
} // Block from 8206CBE0h-8206CC38h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8206CC38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CC38);
		  /* 8206CC38h */ case    0:  		/* rlwimi R4, R5, 4, 24, 27 */
		/* 8206CC38h case    0:*/		cpu::op::rlwimi<0,4,24,27>(regs,&regs.R4,regs.R5);
		/* 8206CC38h case    0:*/		return 0x8206CC3C;
		  /* 8206CC3Ch */ case    1:  		/* addi R5, R3, 80 */
		/* 8206CC3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R3,0x50);
		/* 8206CC3Ch case    1:*/		return 0x8206CC40;
		  /* 8206CC40h */ case    2:  		/* rlwinm R11, R4, 0, 24, 31 */
		/* 8206CC40h case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R4);
		/* 8206CC40h case    2:*/		return 0x8206CC44;
		  /* 8206CC44h */ case    3:  		/* addi R4, R1, 80 */
		/* 8206CC44h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206CC44h case    3:*/		return 0x8206CC48;
		  /* 8206CC48h */ case    4:  		/* rlwimi R6, R11, 8, 0, 23 */
		/* 8206CC48h case    4:*/		cpu::op::rlwimi<0,8,0,23>(regs,&regs.R6,regs.R11);
		/* 8206CC48h case    4:*/		return 0x8206CC4C;
		  /* 8206CC4Ch */ case    5:  		/* addi R3, R3, 304 */
		/* 8206CC4Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x130);
		/* 8206CC4Ch case    5:*/		return 0x8206CC50;
		  /* 8206CC50h */ case    6:  		/* stw R6, <#[R1 + 80]> */
		/* 8206CC50h case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8206CC50h case    6:*/		return 0x8206CC54;
		  /* 8206CC54h */ case    7:  		/* bl -476 */
		/* 8206CC54h case    7:*/		regs.LR = 0x8206CC58; return 0x8206CA78;
		/* 8206CC54h case    7:*/		return 0x8206CC58;
	}
	return 0x8206CC58;
} // Block from 8206CC38h-8206CC58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206CC58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CC58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CC58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CC58);
		  /* 8206CC58h */ case    0:  		/* addi R1, R1, 96 */
		/* 8206CC58h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206CC58h case    0:*/		return 0x8206CC5C;
		  /* 8206CC5Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206CC5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206CC5Ch case    1:*/		return 0x8206CC60;
		  /* 8206CC60h */ case    2:  		/* mtspr LR, R12 */
		/* 8206CC60h case    2:*/		regs.LR = regs.R12;
		/* 8206CC60h case    2:*/		return 0x8206CC64;
		  /* 8206CC64h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8206CC64h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206CC64h case    3:*/		return 0x8206CC68;
	}
	return 0x8206CC68;
} // Block from 8206CC58h-8206CC68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206CC68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CC68);
		  /* 8206CC68h */ case    0:  		/* mfspr R12, LR */
		/* 8206CC68h case    0:*/		regs.R12 = regs.LR;
		/* 8206CC68h case    0:*/		return 0x8206CC6C;
		  /* 8206CC6Ch */ case    1:  		/* bl 148928 */
		/* 8206CC6Ch case    1:*/		regs.LR = 0x8206CC70; return 0x8209122C;
		/* 8206CC6Ch case    1:*/		return 0x8206CC70;
		  /* 8206CC70h */ case    2:  		/* stwu R1, <#[R1 - 320]> */
		/* 8206CC70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEC0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEC0);
		/* 8206CC70h case    2:*/		return 0x8206CC74;
		  /* 8206CC74h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8206CC74h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206CC74h case    3:*/		return 0x8206CC78;
		  /* 8206CC78h */ case    4:  		/* mr R31, R3 */
		/* 8206CC78h case    4:*/		regs.R31 = regs.R3;
		/* 8206CC78h case    4:*/		return 0x8206CC7C;
		  /* 8206CC7Ch */ case    5:  		/* mr R30, R4 */
		/* 8206CC7Ch case    5:*/		regs.R30 = regs.R4;
		/* 8206CC7Ch case    5:*/		return 0x8206CC80;
		  /* 8206CC80h */ case    6:  		/* mr R17, R5 */
		/* 8206CC80h case    6:*/		regs.R17 = regs.R5;
		/* 8206CC80h case    6:*/		return 0x8206CC84;
		  /* 8206CC84h */ case    7:  		/* mr R25, R6 */
		/* 8206CC84h case    7:*/		regs.R25 = regs.R6;
		/* 8206CC84h case    7:*/		return 0x8206CC88;
		  /* 8206CC88h */ case    8:  		/* mr R19, R7 */
		/* 8206CC88h case    8:*/		regs.R19 = regs.R7;
		/* 8206CC88h case    8:*/		return 0x8206CC8C;
		  /* 8206CC8Ch */ case    9:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206CC8Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206CC8Ch case    9:*/		return 0x8206CC90;
		  /* 8206CC90h */ case   10:  		/* nor R11, R11, R11 */
		/* 8206CC90h case   10:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206CC90h case   10:*/		return 0x8206CC94;
		  /* 8206CC94h */ case   11:  		/* rlwinm. R11, R11, 28, 31, 31 */
		/* 8206CC94h case   11:*/		cpu::op::rlwinm<1,28,31,31>(regs,&regs.R11,regs.R11);
		/* 8206CC94h case   11:*/		return 0x8206CC98;
		  /* 8206CC98h */ case   12:  		/* bc 12, CR0_EQ, 1812 */
		/* 8206CC98h case   12:*/		if ( regs.CR[0].eq ) { return 0x8206D3AC;  }
		/* 8206CC98h case   12:*/		return 0x8206CC9C;
		  /* 8206CC9Ch */ case   13:  		/* lwz R11, <#[R3 + 112]> */
		/* 8206CC9Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000070) );
		/* 8206CC9Ch case   13:*/		return 0x8206CCA0;
		  /* 8206CCA0h */ case   14:  		/* li R21, 0 */
		/* 8206CCA0h case   14:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8206CCA0h case   14:*/		return 0x8206CCA4;
		  /* 8206CCA4h */ case   15:  		/* li R18, 1 */
		/* 8206CCA4h case   15:*/		cpu::op::li<0>(regs,&regs.R18,0x1);
		/* 8206CCA4h case   15:*/		return 0x8206CCA8;
		  /* 8206CCA8h */ case   16:  		/* cmplwi CR0, R11, 0 */
		/* 8206CCA8h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8206CCA8h case   16:*/		return 0x8206CCAC;
		  /* 8206CCACh */ case   17:  		/* bc 12, CR0_EQ, 52 */
		/* 8206CCACh case   17:*/		if ( regs.CR[0].eq ) { return 0x8206CCE0;  }
		/* 8206CCACh case   17:*/		return 0x8206CCB0;
		  /* 8206CCB0h */ case   18:  		/* lwz R10, <#[R3 + 108]> */
		/* 8206CCB0h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000006C) );
		/* 8206CCB0h case   18:*/		return 0x8206CCB4;
		  /* 8206CCB4h */ case   19:  		/* rlwinm R9, R11, 3, 0, 28 */
		/* 8206CCB4h case   19:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R11);
		/* 8206CCB4h case   19:*/		return 0x8206CCB8;
		  /* 8206CCB8h */ case   20:  		/* add R10, R9, R10 */
		/* 8206CCB8h case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8206CCB8h case   20:*/		return 0x8206CCBC;
		  /* 8206CCBCh */ case   21:  		/* addic. R10, R10, -8 */
		/* 8206CCBCh case   21:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0xFFFFFFF8);
		/* 8206CCBCh case   21:*/		return 0x8206CCC0;
		  /* 8206CCC0h */ case   22:  		/* bc 12, CR0_EQ, 32 */
		/* 8206CCC0h case   22:*/		if ( regs.CR[0].eq ) { return 0x8206CCE0;  }
		/* 8206CCC0h case   22:*/		return 0x8206CCC4;
		  /* 8206CCC4h */ case   23:  		/* lwz R10, <#[R10 + 4]> */
		/* 8206CCC4h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8206CCC4h case   23:*/		return 0x8206CCC8;
		  /* 8206CCC8h */ case   24:  		/* rlwinm R10, R10, 20, 28, 31 */
		/* 8206CCC8h case   24:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R10,regs.R10);
		/* 8206CCC8h case   24:*/		return 0x8206CCCC;
		  /* 8206CCCCh */ case   25:  		/* slw R10, R18, R10 */
		/* 8206CCCCh case   25:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R18,regs.R10);
		/* 8206CCCCh case   25:*/		return 0x8206CCD0;
		  /* 8206CCD0h */ case   26:  		/* andi. R10, R10, 24702 */
		/* 8206CCD0h case   26:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x607E);
		/* 8206CCD0h case   26:*/		return 0x8206CCD4;
		  /* 8206CCD4h */ case   27:  		/* cmplwi CR0, R10, 0 */
		/* 8206CCD4h case   27:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8206CCD4h case   27:*/		return 0x8206CCD8;
		  /* 8206CCD8h */ case   28:  		/* mr R10, R18 */
		/* 8206CCD8h case   28:*/		regs.R10 = regs.R18;
		/* 8206CCD8h case   28:*/		return 0x8206CCDC;
		  /* 8206CCDCh */ case   29:  		/* bc 4, CR0_EQ, 8 */
		/* 8206CCDCh case   29:*/		if ( !regs.CR[0].eq ) { return 0x8206CCE4;  }
		/* 8206CCDCh case   29:*/		return 0x8206CCE0;
	}
	return 0x8206CCE0;
} // Block from 8206CC68h-8206CCE0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8206CCE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CCE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CCE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CCE0);
		  /* 8206CCE0h */ case    0:  		/* mr R10, R21 */
		/* 8206CCE0h case    0:*/		regs.R10 = regs.R21;
		/* 8206CCE0h case    0:*/		return 0x8206CCE4;
	}
	return 0x8206CCE4;
} // Block from 8206CCE0h-8206CCE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206CCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CCE4);
		  /* 8206CCE4h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8206CCE4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8206CCE4h case    0:*/		return 0x8206CCE8;
		  /* 8206CCE8h */ case    1:  		/* addi R26, R31, 108 */
		/* 8206CCE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R31,0x6C);
		/* 8206CCE8h case    1:*/		return 0x8206CCEC;
		  /* 8206CCECh */ case    2:  		/* bc 4, CR0_EQ, 32 */
		/* 8206CCECh case    2:*/		if ( !regs.CR[0].eq ) { return 0x8206CD0C;  }
		/* 8206CCECh case    2:*/		return 0x8206CCF0;
		  /* 8206CCF0h */ case    3:  		/* lwz R11, <#[R31 + 100]> */
		/* 8206CCF0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8206CCF0h case    3:*/		return 0x8206CCF4;
		  /* 8206CCF4h */ case    4:  		/* li R10, 4096 */
		/* 8206CCF4h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x1000);
		/* 8206CCF4h case    4:*/		return 0x8206CCF8;
		  /* 8206CCF8h */ case    5:  		/* addi R5, R31, 80 */
		/* 8206CCF8h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206CCF8h case    5:*/		return 0x8206CCFC;
		  /* 8206CCFCh */ case    6:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 8206CCFCh case    6:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 8206CCFCh case    6:*/		return 0x8206CD00;
		  /* 8206CD00h */ case    7:  		/* stw R10, <#[R1 + 84]> */
		/* 8206CD00h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8206CD00h case    7:*/		return 0x8206CD04;
		  /* 8206CD04h */ case    8:  		/* stw R11, <#[R1 + 80]> */
		/* 8206CD04h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206CD04h case    8:*/		return 0x8206CD08;
		  /* 8206CD08h */ case    9:  		/* b 196 */
		/* 8206CD08h case    9:*/		return 0x8206CDCC;
		/* 8206CD08h case    9:*/		return 0x8206CD0C;
	}
	return 0x8206CD0C;
} // Block from 8206CCE4h-8206CD0Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206CD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CD0C);
		  /* 8206CD0Ch */ case    0:  		/* rlwinm R10, R11, 3, 0, 28 */
		/* 8206CD0Ch case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R11);
		/* 8206CD0Ch case    0:*/		return 0x8206CD10;
		  /* 8206CD10h */ case    1:  		/* lwz R11, <#[R31 + 108]> */
		/* 8206CD10h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 8206CD10h case    1:*/		return 0x8206CD14;
		  /* 8206CD14h */ case    2:  		/* add R11, R10, R11 */
		/* 8206CD14h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206CD14h case    2:*/		return 0x8206CD18;
		  /* 8206CD18h */ case    3:  		/* addi R10, R11, -8 */
		/* 8206CD18h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFF8);
		/* 8206CD18h case    3:*/		return 0x8206CD1C;
		  /* 8206CD1Ch */ case    4:  		/* lwz R11, <#[R11 - 8]> */
		/* 8206CD1Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 8206CD1Ch case    4:*/		return 0x8206CD20;
		  /* 8206CD20h */ case    5:  		/* rlwinm R11, R11, 0, 17, 19 */
		/* 8206CD20h case    5:*/		cpu::op::rlwinm<0,0,17,19>(regs,&regs.R11,regs.R11);
		/* 8206CD20h case    5:*/		return 0x8206CD24;
		  /* 8206CD24h */ case    6:  		/* cmplwi CR6, R11, 24576 */
		/* 8206CD24h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00006000);
		/* 8206CD24h case    6:*/		return 0x8206CD28;
		  /* 8206CD28h */ case    7:  		/* bc 4, CR6_LT, 16 */
		/* 8206CD28h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8206CD38;  }
		/* 8206CD28h case    7:*/		return 0x8206CD2C;
		  /* 8206CD2Ch */ case    8:  		/* lwz R11, <#[R31 + 120]> */
		/* 8206CD2Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000078) );
		/* 8206CD2Ch case    8:*/		return 0x8206CD30;
		  /* 8206CD30h */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 8206CD30h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206CD30h case    9:*/		return 0x8206CD34;
		  /* 8206CD34h */ case   10:  		/* bc 12, CR6_EQ, 164 */
		/* 8206CD34h case   10:*/		if ( regs.CR[6].eq ) { return 0x8206CDD8;  }
		/* 8206CD34h case   10:*/		return 0x8206CD38;
	}
	return 0x8206CD38;
} // Block from 8206CD0Ch-8206CD38h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206CD38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CD38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CD38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CD38);
		  /* 8206CD38h */ case    0:  		/* lwz R11, <#[R31 + 80]> */
		/* 8206CD38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8206CD38h case    0:*/		return 0x8206CD3C;
		  /* 8206CD3Ch */ case    1:  		/* addi R5, R31, 80 */
		/* 8206CD3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206CD3Ch case    1:*/		return 0x8206CD40;
		  /* 8206CD40h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8206CD40h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206CD40h case    2:*/		return 0x8206CD44;
		  /* 8206CD44h */ case    3:  		/* bc 12, CR6_LT, 1640 */
		/* 8206CD44h case    3:*/		if ( regs.CR[6].lt ) { return 0x8206D3AC;  }
		/* 8206CD44h case    3:*/		return 0x8206CD48;
		  /* 8206CD48h */ case    4:  		/* lwz R11, <#[R10 + 4]> */
		/* 8206CD48h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8206CD48h case    4:*/		return 0x8206CD4C;
		  /* 8206CD4Ch */ case    5:  		/* lwz R8, <#[R31 + 120]> */
		/* 8206CD4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000078) );
		/* 8206CD4Ch case    5:*/		return 0x8206CD50;
		  /* 8206CD50h */ case    6:  		/* rlwinm R9, R11, 20, 28, 31 */
		/* 8206CD50h case    6:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R9,regs.R11);
		/* 8206CD50h case    6:*/		return 0x8206CD54;
		  /* 8206CD54h */ case    7:  		/* cmpwi CR6, R8, 0 */
		/* 8206CD54h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 8206CD54h case    7:*/		return 0x8206CD58;
		  /* 8206CD58h */ case    8:  		/* mr R8, R9 */
		/* 8206CD58h case    8:*/		regs.R8 = regs.R9;
		/* 8206CD58h case    8:*/		return 0x8206CD5C;
		  /* 8206CD5Ch */ case    9:  		/* bc 4, CR6_EQ, 24 */
		/* 8206CD5Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8206CD74;  }
		/* 8206CD5Ch case    9:*/		return 0x8206CD60;
		  /* 8206CD60h */ case   10:  		/* lis R7, -32256 */
		/* 8206CD60h case   10:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8200);
		/* 8206CD60h case   10:*/		return 0x8206CD64;
		  /* 8206CD64h */ case   11:  		/* rlwinm R9, R9, 0, 24, 31 */
		/* 8206CD64h case   11:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R9);
		/* 8206CD64h case   11:*/		return 0x8206CD68;
		  /* 8206CD68h */ case   12:  		/* addi R7, R7, 3572 */
		/* 8206CD68h case   12:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xDF4);
		/* 8206CD68h case   12:*/		return 0x8206CD6C;
		  /* 8206CD6Ch */ case   13:  		/* lbzx R9, <#[R9 + R7]> */
		/* 8206CD6Ch case   13:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 8206CD6Ch case   13:*/		return 0x8206CD70;
		  /* 8206CD70h */ case   14:  		/* b 20 */
		/* 8206CD70h case   14:*/		return 0x8206CD84;
		/* 8206CD70h case   14:*/		return 0x8206CD74;
	}
	return 0x8206CD74;
} // Block from 8206CD38h-8206CD74h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206CD74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CD74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CD74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CD74);
		  /* 8206CD74h */ case    0:  		/* lis R8, -32256 */
		/* 8206CD74h case    0:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 8206CD74h case    0:*/		return 0x8206CD78;
		  /* 8206CD78h */ case    1:  		/* rlwinm R7, R9, 0, 24, 31 */
		/* 8206CD78h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R7,regs.R9);
		/* 8206CD78h case    1:*/		return 0x8206CD7C;
		  /* 8206CD7Ch */ case    2:  		/* addi R8, R8, 3572 */
		/* 8206CD7Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xDF4);
		/* 8206CD7Ch case    2:*/		return 0x8206CD80;
		  /* 8206CD80h */ case    3:  		/* lbzx R8, <#[R7 + R8]> */
		/* 8206CD80h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8206CD80h case    3:*/		return 0x8206CD84;
	}
	return 0x8206CD84;
} // Block from 8206CD74h-8206CD84h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206CD84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CD84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CD84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CD84);
		  /* 8206CD84h */ case    0:  		/* rlwinm R9, R9, 0, 24, 31 */
		/* 8206CD84h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R9,regs.R9);
		/* 8206CD84h case    0:*/		return 0x8206CD88;
		  /* 8206CD88h */ case    1:  		/* rlwinm R8, R8, 0, 24, 31 */
		/* 8206CD88h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R8,regs.R8);
		/* 8206CD88h case    1:*/		return 0x8206CD8C;
		  /* 8206CD8Ch */ case    2:  		/* rlwimi R11, R9, 12, 16, 19 */
		/* 8206CD8Ch case    2:*/		cpu::op::rlwimi<0,12,16,19>(regs,&regs.R11,regs.R9);
		/* 8206CD8Ch case    2:*/		return 0x8206CD90;
		  /* 8206CD90h */ case    3:  		/* stw R11, <#[R10 + 4]> */
		/* 8206CD90h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8206CD90h case    3:*/		return 0x8206CD94;
		  /* 8206CD94h */ case    4:  		/* ld R11, <#[R10]> */
		/* 8206CD94h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8206CD94h case    4:*/		return 0x8206CD98;
		  /* 8206CD98h */ case    5:  		/* lwz R10, <#[R31 + 100]> */
		/* 8206CD98h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000064) );
		/* 8206CD98h case    5:*/		return 0x8206CD9C;
		  /* 8206CD9Ch */ case    6:  		/* std R11, <#[R1 + 80]> */
		/* 8206CD9Ch case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206CD9Ch case    6:*/		return 0x8206CDA0;
		  /* 8206CDA0h */ case    7:  		/* lwz R11, <#[R1 + 84]> */
		/* 8206CDA0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8206CDA0h case    7:*/		return 0x8206CDA4;
		  /* 8206CDA4h */ case    8:  		/* lwz R9, <#[R1 + 80]> */
		/* 8206CDA4h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8206CDA4h case    8:*/		return 0x8206CDA8;
		  /* 8206CDA8h */ case    9:  		/* rlwimi R10, R9, 0, 0, 19 */
		/* 8206CDA8h case    9:*/		cpu::op::rlwimi<0,0,0,19>(regs,&regs.R10,regs.R9);
		/* 8206CDA8h case    9:*/		return 0x8206CDAC;
		  /* 8206CDACh */ case   10:  		/* rlwimi R11, R8, 12, 16, 19 */
		/* 8206CDACh case   10:*/		cpu::op::rlwimi<0,12,16,19>(regs,&regs.R11,regs.R8);
		/* 8206CDACh case   10:*/		return 0x8206CDB0;
		  /* 8206CDB0h */ case   11:  		/* rlwinm R10, R10, 0, 20, 16 */
		/* 8206CDB0h case   11:*/		cpu::op::rlwinm<0,0,20,16>(regs,&regs.R10,regs.R10);
		/* 8206CDB0h case   11:*/		return 0x8206CDB4;
		  /* 8206CDB4h */ case   12:  		/* rlwinm R11, R11, 0, 21, 19 */
		/* 8206CDB4h case   12:*/		cpu::op::rlwinm<0,0,21,19>(regs,&regs.R11,regs.R11);
		/* 8206CDB4h case   12:*/		return 0x8206CDB8;
		  /* 8206CDB8h */ case   13:  		/* rlwinm R10, R10, 0, 16, 3 */
		/* 8206CDB8h case   13:*/		cpu::op::rlwinm<0,0,16,3>(regs,&regs.R10,regs.R10);
		/* 8206CDB8h case   13:*/		return 0x8206CDBC;
		  /* 8206CDBCh */ case   14:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 8206CDBCh case   14:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 8206CDBCh case   14:*/		return 0x8206CDC0;
		  /* 8206CDC0h */ case   15:  		/* rlwinm R10, R10, 0, 4, 31 */
		/* 8206CDC0h case   15:*/		cpu::op::rlwinm<0,0,4,31>(regs,&regs.R10,regs.R10);
		/* 8206CDC0h case   15:*/		return 0x8206CDC4;
		  /* 8206CDC4h */ case   16:  		/* stw R11, <#[R1 + 84]> */
		/* 8206CDC4h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8206CDC4h case   16:*/		return 0x8206CDC8;
		  /* 8206CDC8h */ case   17:  		/* stw R10, <#[R1 + 80]> */
		/* 8206CDC8h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8206CDC8h case   17:*/		return 0x8206CDCC;
	}
	return 0x8206CDCC;
} // Block from 8206CD84h-8206CDCCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206CDCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CDCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CDCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CDCC);
		  /* 8206CDCCh */ case    0:  		/* addi R4, R1, 80 */
		/* 8206CDCCh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206CDCCh case    0:*/		return 0x8206CDD0;
		  /* 8206CDD0h */ case    1:  		/* mr R3, R26 */
		/* 8206CDD0h case    1:*/		regs.R3 = regs.R26;
		/* 8206CDD0h case    1:*/		return 0x8206CDD4;
		  /* 8206CDD4h */ case    2:  		/* bl -972 */
		/* 8206CDD4h case    2:*/		regs.LR = 0x8206CDD8; return 0x8206CA08;
		/* 8206CDD4h case    2:*/		return 0x8206CDD8;
	}
	return 0x8206CDD8;
} // Block from 8206CDCCh-8206CDD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206CDD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CDD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CDD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CDD8);
		  /* 8206CDD8h */ case    0:  		/* lwz R11, <#[R31 + 80]> */
		/* 8206CDD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 8206CDD8h case    0:*/		return 0x8206CDDC;
		  /* 8206CDDCh */ case    1:  		/* stw R21, <#[R31 + 120]> */
		/* 8206CDDCh case    1:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000078) );
		/* 8206CDDCh case    1:*/		return 0x8206CDE0;
		  /* 8206CDE0h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8206CDE0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206CDE0h case    2:*/		return 0x8206CDE4;
		  /* 8206CDE4h */ case    3:  		/* bc 12, CR6_LT, 1480 */
		/* 8206CDE4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8206D3AC;  }
		/* 8206CDE4h case    3:*/		return 0x8206CDE8;
		  /* 8206CDE8h */ case    4:  		/* lwz R10, <#[R26 + 4]> */
		/* 8206CDE8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 8206CDE8h case    4:*/		return 0x8206CDEC;
		  /* 8206CDECh */ case    5:  		/* rlwinm. R22, R30, 0, 24, 31 */
		/* 8206CDECh case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R22,regs.R30);
		/* 8206CDECh case    5:*/		return 0x8206CDF0;
		  /* 8206CDF0h */ case    6:  		/* lwz R11, <#[R26]> */
		/* 8206CDF0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8206CDF0h case    6:*/		return 0x8206CDF4;
		  /* 8206CDF4h */ case    7:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 8206CDF4h case    7:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 8206CDF4h case    7:*/		return 0x8206CDF8;
		  /* 8206CDF8h */ case    8:  		/* lwz R9, <#[R31 + 112]> */
		/* 8206CDF8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000070) );
		/* 8206CDF8h case    8:*/		return 0x8206CDFC;
		  /* 8206CDFCh */ case    9:  		/* add R23, R10, R11 */
		/* 8206CDFCh case    9:*/		cpu::op::add<0>(regs,&regs.R23,regs.R10,regs.R11);
		/* 8206CDFCh case    9:*/		return 0x8206CE00;
		  /* 8206CE00h */ case   10:  		/* addi R27, R9, -1 */
		/* 8206CE00h case   10:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R9,0xFFFFFFFF);
		/* 8206CE00h case   10:*/		return 0x8206CE04;
		  /* 8206CE04h */ case   11:  		/* lwz R10, <#[R23 - 8]> */
		/* 8206CE04h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0xFFFFFFF8) );
		/* 8206CE04h case   11:*/		return 0x8206CE08;
		  /* 8206CE08h */ case   12:  		/* rlwinm R11, R10, 0, 0, 19 */
		/* 8206CE08h case   12:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R10);
		/* 8206CE08h case   12:*/		return 0x8206CE0C;
		  /* 8206CE0Ch */ case   13:  		/* mr R9, R10 */
		/* 8206CE0Ch case   13:*/		regs.R9 = regs.R10;
		/* 8206CE0Ch case   13:*/		return 0x8206CE10;
		  /* 8206CE10h */ case   14:  		/* addi R11, R11, 4096 */
		/* 8206CE10h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 8206CE10h case   14:*/		return 0x8206CE14;
		  /* 8206CE14h */ case   15:  		/* rlwinm R20, R10, 20, 29, 31 */
		/* 8206CE14h case   15:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R20,regs.R10);
		/* 8206CE14h case   15:*/		return 0x8206CE18;
		  /* 8206CE18h */ case   16:  		/* rlwimi R11, R10, 0, 20, 16 */
		/* 8206CE18h case   16:*/		cpu::op::rlwimi<0,0,20,16>(regs,&regs.R11,regs.R10);
		/* 8206CE18h case   16:*/		return 0x8206CE1C;
		  /* 8206CE1Ch */ case   17:  		/* stw R11, <#[R23 - 8]> */
		/* 8206CE1Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0xFFFFFFF8) );
		/* 8206CE1Ch case   17:*/		return 0x8206CE20;
		  /* 8206CE20h */ case   18:  		/* bc 12, CR0_EQ, 28 */
		/* 8206CE20h case   18:*/		if ( regs.CR[0].eq ) { return 0x8206CE3C;  }
		/* 8206CE20h case   18:*/		return 0x8206CE24;
		  /* 8206CE24h */ case   19:  		/* rlwinm R10, R20, 1, 0, 30 */
		/* 8206CE24h case   19:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R20);
		/* 8206CE24h case   19:*/		return 0x8206CE28;
		  /* 8206CE28h */ case   20:  		/* slw R10, R18, R10 */
		/* 8206CE28h case   20:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R18,regs.R10);
		/* 8206CE28h case   20:*/		return 0x8206CE2C;
		  /* 8206CE2Ch */ case   21:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 8206CE2Ch case   21:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 8206CE2Ch case   21:*/		return 0x8206CE30;
		  /* 8206CE30h */ case   22:  		/* or R10, R10, R11 */
		/* 8206CE30h case   22:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8206CE30h case   22:*/		return 0x8206CE34;
		  /* 8206CE34h */ case   23:  		/* rlwimi R10, R11, 0, 16, 3 */
		/* 8206CE34h case   23:*/		cpu::op::rlwimi<0,0,16,3>(regs,&regs.R10,regs.R11);
		/* 8206CE34h case   23:*/		return 0x8206CE38;
		  /* 8206CE38h */ case   24:  		/* stw R10, <#[R23 - 8]> */
		/* 8206CE38h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R23 + 0xFFFFFFF8) );
		/* 8206CE38h case   24:*/		return 0x8206CE3C;
	}
	return 0x8206CE3C;
} // Block from 8206CDD8h-8206CE3Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8206CE3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CE3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CE3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CE3C);
		  /* 8206CE3Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8206CE3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206CE3Ch case    0:*/		return 0x8206CE40;
		  /* 8206CE40h */ case    1:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206CE40h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206CE40h case    1:*/		return 0x8206CE44;
		  /* 8206CE44h */ case    2:  		/* nor R11, R11, R11 */
		/* 8206CE44h case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206CE44h case    2:*/		return 0x8206CE48;
		  /* 8206CE48h */ case    3:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 8206CE48h case    3:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8206CE48h case    3:*/		return 0x8206CE4C;
		  /* 8206CE4Ch */ case    4:  		/* bc 12, CR0_EQ, 1308 */
		/* 8206CE4Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8206D368;  }
		/* 8206CE4Ch case    4:*/		return 0x8206CE50;
		  /* 8206CE50h */ case    5:  		/* addi R11, R1, 96 */
		/* 8206CE50h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8206CE50h case    5:*/		return 0x8206CE54;
		  /* 8206CE54h */ case    6:  		/* lwz R10, <#[R31 + 4]> */
		/* 8206CE54h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8206CE54h case    6:*/		return 0x8206CE58;
		  /* 8206CE58h */ case    7:  		/* addi R9, R1, 128 */
		/* 8206CE58h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 8206CE58h case    7:*/		return 0x8206CE5C;
		  /* 8206CE5Ch */ case    8:  		/* mr R24, R21 */
		/* 8206CE5Ch case    8:*/		regs.R24 = regs.R21;
		/* 8206CE5Ch case    8:*/		return 0x8206CE60;
		  /* 8206CE60h */ case    9:  		/* cmpwi CR6, R10, 0 */
		/* 8206CE60h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8206CE60h case    9:*/		return 0x8206CE64;
		  /* 8206CE64h */ case   10:  		/* std R21, <#[R11]> */
		/* 8206CE64h case   10:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R11 + 0x00000000) );
		/* 8206CE64h case   10:*/		return 0x8206CE68;
		  /* 8206CE68h */ case   11:  		/* std R21, <#[R9]> */
		/* 8206CE68h case   11:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R9 + 0x00000000) );
		/* 8206CE68h case   11:*/		return 0x8206CE6C;
		  /* 8206CE6Ch */ case   12:  		/* std R21, <#[R11 + 8]> */
		/* 8206CE6Ch case   12:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R11 + 0x00000008) );
		/* 8206CE6Ch case   12:*/		return 0x8206CE70;
		  /* 8206CE70h */ case   13:  		/* std R21, <#[R9 + 8]> */
		/* 8206CE70h case   13:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R9 + 0x00000008) );
		/* 8206CE70h case   13:*/		return 0x8206CE74;
		  /* 8206CE74h */ case   14:  		/* std R21, <#[R11 + 16]> */
		/* 8206CE74h case   14:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R11 + 0x00000010) );
		/* 8206CE74h case   14:*/		return 0x8206CE78;
		  /* 8206CE78h */ case   15:  		/* std R21, <#[R9 + 16]> */
		/* 8206CE78h case   15:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R9 + 0x00000010) );
		/* 8206CE78h case   15:*/		return 0x8206CE7C;
		  /* 8206CE7Ch */ case   16:  		/* std R21, <#[R11 + 24]> */
		/* 8206CE7Ch case   16:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R11 + 0x00000018) );
		/* 8206CE7Ch case   16:*/		return 0x8206CE80;
		  /* 8206CE80h */ case   17:  		/* std R21, <#[R9 + 24]> */
		/* 8206CE80h case   17:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R9 + 0x00000018) );
		/* 8206CE80h case   17:*/		return 0x8206CE84;
		  /* 8206CE84h */ case   18:  		/* bc 12, CR6_EQ, 120 */
		/* 8206CE84h case   18:*/		if ( regs.CR[6].eq ) { return 0x8206CEFC;  }
		/* 8206CE84h case   18:*/		return 0x8206CE88;
		  /* 8206CE88h */ case   19:  		/* cmplwi CR6, R22, 0 */
		/* 8206CE88h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8206CE88h case   19:*/		return 0x8206CE8C;
		  /* 8206CE8Ch */ case   20:  		/* bc 12, CR6_EQ, 28 */
		/* 8206CE8Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x8206CEA8;  }
		/* 8206CE8Ch case   20:*/		return 0x8206CE90;
		  /* 8206CE90h */ case   21:  		/* lwz R11, <#[R19]> */
		/* 8206CE90h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8206CE90h case   21:*/		return 0x8206CE94;
		  /* 8206CE94h */ case   22:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 8206CE94h case   22:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8206CE94h case   22:*/		return 0x8206CE98;
		  /* 8206CE98h */ case   23:  		/* bc 4, CR0_EQ, 16 */
		/* 8206CE98h case   23:*/		if ( !regs.CR[0].eq ) { return 0x8206CEA8;  }
		/* 8206CE98h case   23:*/		return 0x8206CE9C;
		  /* 8206CE9Ch */ case   24:  		/* lwz R11, <#[R19 + 4]> */
		/* 8206CE9Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8206CE9Ch case   24:*/		return 0x8206CEA0;
		  /* 8206CEA0h */ case   25:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8206CEA0h case   25:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8206CEA0h case   25:*/		return 0x8206CEA4;
		  /* 8206CEA4h */ case   26:  		/* bc 4, CR0_EQ, 88 */
		/* 8206CEA4h case   26:*/		if ( !regs.CR[0].eq ) { return 0x8206CEFC;  }
		/* 8206CEA4h case   26:*/		return 0x8206CEA8;
	}
	return 0x8206CEA8;
} // Block from 8206CE3Ch-8206CEA8h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8206CEA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CEA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CEA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CEA8);
		  /* 8206CEA8h */ case    0:  		/* li R9, 8 */
		/* 8206CEA8h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 8206CEA8h case    0:*/		return 0x8206CEAC;
		  /* 8206CEACh */ case    1:  		/* addi R11, R31, 128 */
		/* 8206CEACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x80);
		/* 8206CEACh case    1:*/		return 0x8206CEB0;
		  /* 8206CEB0h */ case    2:  		/* addi R10, R31, 12 */
		/* 8206CEB0h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xC);
		/* 8206CEB0h case    2:*/		return 0x8206CEB4;
		  /* 8206CEB4h */ case    3:  		/* addi R11, R11, -4 */
		/* 8206CEB4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8206CEB4h case    3:*/		return 0x8206CEB8;
		  /* 8206CEB8h */ case    4:  		/* mtspr CTR, R9 */
		/* 8206CEB8h case    4:*/		regs.CTR = regs.R9;
		/* 8206CEB8h case    4:*/		return 0x8206CEBC;
		  /* 8206CEBCh */ case    5:  		/* lwzu R9, <#[R10 + 4]> */
		/* 8206CEBCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8206CEBCh case    5:*/		return 0x8206CEC0;
		  /* 8206CEC0h */ case    6:  		/* lwz R8, <#[R11 + 4]> */
		/* 8206CEC0h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8206CEC0h case    6:*/		return 0x8206CEC4;
		  /* 8206CEC4h */ case    7:  		/* or R9, R9, R8 */
		/* 8206CEC4h case    7:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8206CEC4h case    7:*/		return 0x8206CEC8;
		  /* 8206CEC8h */ case    8:  		/* stwu R9, <#[R11 + 4]> */
		/* 8206CEC8h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206CEC8h case    8:*/		return 0x8206CECC;
		  /* 8206CECCh */ case    9:  		/* bc 16, CR0_LT, -16 */
		/* 8206CECCh case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206CEBC;  }
		/* 8206CECCh case    9:*/		return 0x8206CED0;
		  /* 8206CED0h */ case   10:  		/* li R9, 8 */
		/* 8206CED0h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 8206CED0h case   10:*/		return 0x8206CED4;
		  /* 8206CED4h */ case   11:  		/* addi R11, R31, 192 */
		/* 8206CED4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xC0);
		/* 8206CED4h case   11:*/		return 0x8206CED8;
		  /* 8206CED8h */ case   12:  		/* addi R10, R31, 44 */
		/* 8206CED8h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x2C);
		/* 8206CED8h case   12:*/		return 0x8206CEDC;
		  /* 8206CEDCh */ case   13:  		/* addi R11, R11, -4 */
		/* 8206CEDCh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8206CEDCh case   13:*/		return 0x8206CEE0;
		  /* 8206CEE0h */ case   14:  		/* mtspr CTR, R9 */
		/* 8206CEE0h case   14:*/		regs.CTR = regs.R9;
		/* 8206CEE0h case   14:*/		return 0x8206CEE4;
		  /* 8206CEE4h */ case   15:  		/* lwzu R9, <#[R10 + 4]> */
		/* 8206CEE4h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8206CEE4h case   15:*/		return 0x8206CEE8;
		  /* 8206CEE8h */ case   16:  		/* lwz R8, <#[R11 + 4]> */
		/* 8206CEE8h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8206CEE8h case   16:*/		return 0x8206CEEC;
		  /* 8206CEECh */ case   17:  		/* or R9, R9, R8 */
		/* 8206CEECh case   17:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8206CEECh case   17:*/		return 0x8206CEF0;
	}
	return 0x8206CEF0;
} // Block from 8206CEA8h-8206CEF0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206CEF0h
// Function 'D3DDevice_DrawIndexedVertices'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CEF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CEF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CEF0);
		  /* 8206CEF0h */ case    0:  		/* stwu R9, <#[R11 + 4]> */
		/* 8206CEF0h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206CEF0h case    0:*/		return 0x8206CEF4;
		  /* 8206CEF4h */ case    1:  		/* bc 16, CR0_LT, -16 */
		/* 8206CEF4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206CEE4;  }
		/* 8206CEF4h case    1:*/		return 0x8206CEF8;
		  /* 8206CEF8h */ case    2:  		/* stw R21, <#[R31 + 4]> */
		/* 8206CEF8h case    2:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000004) );
		/* 8206CEF8h case    2:*/		return 0x8206CEFC;
	}
	return 0x8206CEFC;
} // Block from 8206CEF0h-8206CEFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206CEFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CEFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CEFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CEFC);
		  /* 8206CEFCh */ case    0:  		/* cmplwi CR6, R22, 0 */
		/* 8206CEFCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8206CEFCh case    0:*/		return 0x8206CF00;
		  /* 8206CF00h */ case    1:  		/* bc 12, CR6_EQ, 692 */
		/* 8206CF00h case    1:*/		if ( regs.CR[6].eq ) { return 0x8206D1B4;  }
		/* 8206CF00h case    1:*/		return 0x8206CF04;
		  /* 8206CF04h */ case    2:  		/* lwz R29, <#[R19]> */
		/* 8206CF04h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R19 + 0x00000000) );
		/* 8206CF04h case    2:*/		return 0x8206CF08;
		  /* 8206CF08h */ case    3:  		/* rlwinm. R11, R29, 0, 13, 13 */
		/* 8206CF08h case    3:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R11,regs.R29);
		/* 8206CF08h case    3:*/		return 0x8206CF0C;
		  /* 8206CF0Ch */ case    4:  		/* rlwinm R28, R29, 0, 27, 31 */
		/* 8206CF0Ch case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R28,regs.R29);
		/* 8206CF0Ch case    4:*/		return 0x8206CF10;
		  /* 8206CF10h */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 8206CF10h case    5:*/		if ( regs.CR[0].eq ) { return 0x8206CF38;  }
		/* 8206CF10h case    5:*/		return 0x8206CF14;
		  /* 8206CF14h */ case    6:  		/* mr R30, R21 */
		/* 8206CF14h case    6:*/		regs.R30 = regs.R21;
		/* 8206CF14h case    6:*/		return 0x8206CF18;
		  /* 8206CF18h */ case    7:  		/* mr R5, R19 */
		/* 8206CF18h case    7:*/		regs.R5 = regs.R19;
		/* 8206CF18h case    7:*/		return 0x8206CF1C;
		  /* 8206CF1Ch */ case    8:  		/* mr R4, R30 */
		/* 8206CF1Ch case    8:*/		regs.R4 = regs.R30;
		/* 8206CF1Ch case    8:*/		return 0x8206CF20;
		  /* 8206CF20h */ case    9:  		/* addi R3, R1, 128 */
		/* 8206CF20h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8206CF20h case    9:*/		return 0x8206CF24;
		  /* 8206CF24h */ case   10:  		/* bl -12428 */
		/* 8206CF24h case   10:*/		regs.LR = 0x8206CF28; return 0x82069E98;
		/* 8206CF24h case   10:*/		return 0x8206CF28;
		  /* 8206CF28h */ case   11:  		/* addi R30, R30, 1 */
		/* 8206CF28h case   11:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8206CF28h case   11:*/		return 0x8206CF2C;
		  /* 8206CF2Ch */ case   12:  		/* cmplwi CR6, R30, 64 */
		/* 8206CF2Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000040);
		/* 8206CF2Ch case   12:*/		return 0x8206CF30;
		  /* 8206CF30h */ case   13:  		/* bc 12, CR6_LT, -24 */
		/* 8206CF30h case   13:*/		if ( regs.CR[6].lt ) { return 0x8206CF18;  }
		/* 8206CF30h case   13:*/		return 0x8206CF34;
		  /* 8206CF34h */ case   14:  		/* b 20 */
		/* 8206CF34h case   14:*/		return 0x8206CF48;
		/* 8206CF34h case   14:*/		return 0x8206CF38;
	}
	return 0x8206CF38;
} // Block from 8206CEFCh-8206CF38h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206CF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CF38);
		  /* 8206CF38h */ case    0:  		/* mr R5, R19 */
		/* 8206CF38h case    0:*/		regs.R5 = regs.R19;
		/* 8206CF38h case    0:*/		return 0x8206CF3C;
		  /* 8206CF3Ch */ case    1:  		/* rlwinm R4, R29, 20, 26, 31 */
		/* 8206CF3Ch case    1:*/		cpu::op::rlwinm<0,20,26,31>(regs,&regs.R4,regs.R29);
		/* 8206CF3Ch case    1:*/		return 0x8206CF40;
		  /* 8206CF40h */ case    2:  		/* addi R3, R1, 128 */
		/* 8206CF40h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8206CF40h case    2:*/		return 0x8206CF44;
		  /* 8206CF44h */ case    3:  		/* bl -12460 */
		/* 8206CF44h case    3:*/		regs.LR = 0x8206CF48; return 0x82069E98;
		/* 8206CF44h case    3:*/		return 0x8206CF48;
	}
	return 0x8206CF48;
} // Block from 8206CF38h-8206CF48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206CF48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CF48);
		  /* 8206CF48h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8206CF48h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8206CF48h case    0:*/		return 0x8206CF4C;
		  /* 8206CF4Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8206CF4Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8206CF5C;  }
		/* 8206CF4Ch case    1:*/		return 0x8206CF50;
		  /* 8206CF50h */ case    2:  		/* lwz R11, <#[R19 + 4]> */
		/* 8206CF50h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8206CF50h case    2:*/		return 0x8206CF54;
		  /* 8206CF54h */ case    3:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8206CF54h case    3:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8206CF54h case    3:*/		return 0x8206CF58;
		  /* 8206CF58h */ case    4:  		/* bc 4, CR0_EQ, 76 */
		/* 8206CF58h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8206CFA4;  }
		/* 8206CF58h case    4:*/		return 0x8206CF5C;
	}
	return 0x8206CF5C;
} // Block from 8206CF48h-8206CF5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206CF5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CF5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CF5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CF5C);
		  /* 8206CF5Ch */ case    0:  		/* rlwinm. R11, R29, 0, 20, 20 */
		/* 8206CF5Ch case    0:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R29);
		/* 8206CF5Ch case    0:*/		return 0x8206CF60;
		  /* 8206CF60h */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8206CF60h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206CF90;  }
		/* 8206CF60h case    1:*/		return 0x8206CF64;
		  /* 8206CF64h */ case    2:  		/* mr R30, R21 */
		/* 8206CF64h case    2:*/		regs.R30 = regs.R21;
		/* 8206CF64h case    2:*/		return 0x8206CF68;
		  /* 8206CF68h */ case    3:  		/* rlwinm R29, R17, 0, 24, 31 */
		/* 8206CF68h case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R29,regs.R17);
		/* 8206CF68h case    3:*/		return 0x8206CF6C;
		  /* 8206CF6Ch */ case    4:  		/* mr R6, R19 */
		/* 8206CF6Ch case    4:*/		regs.R6 = regs.R19;
		/* 8206CF6Ch case    4:*/		return 0x8206CF70;
		  /* 8206CF70h */ case    5:  		/* mr R5, R29 */
		/* 8206CF70h case    5:*/		regs.R5 = regs.R29;
		/* 8206CF70h case    5:*/		return 0x8206CF74;
		  /* 8206CF74h */ case    6:  		/* mr R4, R30 */
		/* 8206CF74h case    6:*/		regs.R4 = regs.R30;
		/* 8206CF74h case    6:*/		return 0x8206CF78;
		  /* 8206CF78h */ case    7:  		/* addi R3, R1, 96 */
		/* 8206CF78h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8206CF78h case    7:*/		return 0x8206CF7C;
		  /* 8206CF7Ch */ case    8:  		/* bl -12316 */
		/* 8206CF7Ch case    8:*/		regs.LR = 0x8206CF80; return 0x82069F60;
		/* 8206CF7Ch case    8:*/		return 0x8206CF80;
		  /* 8206CF80h */ case    9:  		/* addi R30, R30, 1 */
		/* 8206CF80h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8206CF80h case    9:*/		return 0x8206CF84;
		  /* 8206CF84h */ case   10:  		/* cmplwi CR6, R30, 64 */
		/* 8206CF84h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000040);
		/* 8206CF84h case   10:*/		return 0x8206CF88;
		  /* 8206CF88h */ case   11:  		/* bc 12, CR6_LT, -28 */
		/* 8206CF88h case   11:*/		if ( regs.CR[6].lt ) { return 0x8206CF6C;  }
		/* 8206CF88h case   11:*/		return 0x8206CF8C;
		  /* 8206CF8Ch */ case   12:  		/* b 24 */
		/* 8206CF8Ch case   12:*/		return 0x8206CFA4;
		/* 8206CF8Ch case   12:*/		return 0x8206CF90;
	}
	return 0x8206CF90;
} // Block from 8206CF5Ch-8206CF90h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206CF90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CF90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CF90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CF90);
		  /* 8206CF90h */ case    0:  		/* mr R6, R19 */
		/* 8206CF90h case    0:*/		regs.R6 = regs.R19;
		/* 8206CF90h case    0:*/		return 0x8206CF94;
		  /* 8206CF94h */ case    1:  		/* rlwinm R5, R17, 0, 24, 31 */
		/* 8206CF94h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R5,regs.R17);
		/* 8206CF94h case    1:*/		return 0x8206CF98;
		  /* 8206CF98h */ case    2:  		/* rlwinm R4, R29, 27, 26, 31 */
		/* 8206CF98h case    2:*/		cpu::op::rlwinm<0,27,26,31>(regs,&regs.R4,regs.R29);
		/* 8206CF98h case    2:*/		return 0x8206CF9C;
		  /* 8206CF9Ch */ case    3:  		/* addi R3, R1, 96 */
		/* 8206CF9Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 8206CF9Ch case    3:*/		return 0x8206CFA0;
		  /* 8206CFA0h */ case    4:  		/* bl -12352 */
		/* 8206CFA0h case    4:*/		regs.LR = 0x8206CFA4; return 0x82069F60;
		/* 8206CFA0h case    4:*/		return 0x8206CFA4;
	}
	return 0x8206CFA4;
} // Block from 8206CF90h-8206CFA4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206CFA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CFA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CFA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CFA4);
		  /* 8206CFA4h */ case    0:  		/* lbz R11, <#[R31 + 124]> */
		/* 8206CFA4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000007C) );
		/* 8206CFA4h case    0:*/		return 0x8206CFA8;
		  /* 8206CFA8h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8206CFA8h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8206CFA8h case    1:*/		return 0x8206CFAC;
		  /* 8206CFACh */ case    2:  		/* bc 12, CR0_EQ, 220 */
		/* 8206CFACh case    2:*/		if ( regs.CR[0].eq ) { return 0x8206D088;  }
		/* 8206CFACh case    2:*/		return 0x8206CFB0;
		  /* 8206CFB0h */ case    3:  		/* cmplwi CR6, R28, 24 */
		/* 8206CFB0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000018);
		/* 8206CFB0h case    3:*/		return 0x8206CFB4;
		  /* 8206CFB4h */ case    4:  		/* bc 12, CR6_LT, 20 */
		/* 8206CFB4h case    4:*/		if ( regs.CR[6].lt ) { return 0x8206CFC8;  }
		/* 8206CFB4h case    4:*/		return 0x8206CFB8;
		  /* 8206CFB8h */ case    5:  		/* cmplwi CR6, R28, 26 */
		/* 8206CFB8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x0000001A);
		/* 8206CFB8h case    5:*/		return 0x8206CFBC;
		  /* 8206CFBCh */ case    6:  		/* bc 12, CR6_GT, 12 */
		/* 8206CFBCh case    6:*/		if ( regs.CR[6].gt ) { return 0x8206CFC8;  }
		/* 8206CFBCh case    6:*/		return 0x8206CFC0;
		  /* 8206CFC0h */ case    7:  		/* mr R24, R18 */
		/* 8206CFC0h case    7:*/		regs.R24 = regs.R18;
		/* 8206CFC0h case    7:*/		return 0x8206CFC4;
		  /* 8206CFC4h */ case    8:  		/* b 196 */
		/* 8206CFC4h case    8:*/		return 0x8206D088;
		/* 8206CFC4h case    8:*/		return 0x8206CFC8;
	}
	return 0x8206CFC8;
} // Block from 8206CFA4h-8206CFC8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206CFC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206CFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206CFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206CFC8);
		  /* 8206CFC8h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8206CFC8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8206CFC8h case    0:*/		return 0x8206CFCC;
		  /* 8206CFCCh */ case    1:  		/* bc 4, CR6_EQ, 188 */
		/* 8206CFCCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8206D088;  }
		/* 8206CFCCh case    1:*/		return 0x8206CFD0;
		  /* 8206CFD0h */ case    2:  		/* rlwinm. R11, R17, 0, 24, 31 */
		/* 8206CFD0h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R17);
		/* 8206CFD0h case    2:*/		return 0x8206CFD4;
		  /* 8206CFD4h */ case    3:  		/* bc 12, CR0_EQ, 180 */
		/* 8206CFD4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8206D088;  }
		/* 8206CFD4h case    3:*/		return 0x8206CFD8;
		  /* 8206CFD8h */ case    4:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 8206CFD8h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 8206CFD8h case    4:*/		return 0x8206CFDC;
		  /* 8206CFDCh */ case    5:  		/* bc 4, CR0_EQ, 172 */
		/* 8206CFDCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x8206D088;  }
		/* 8206CFDCh case    5:*/		return 0x8206CFE0;
		  /* 8206CFE0h */ case    6:  		/* lwz R11, <#[R19 + 4]> */
		/* 8206CFE0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 8206CFE0h case    6:*/		return 0x8206CFE4;
		  /* 8206CFE4h */ case    7:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8206CFE4h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8206CFE4h case    7:*/		return 0x8206CFE8;
		  /* 8206CFE8h */ case    8:  		/* bc 4, CR0_EQ, 40 */
		/* 8206CFE8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8206D010;  }
		/* 8206CFE8h case    8:*/		return 0x8206CFEC;
		  /* 8206CFECh */ case    9:  		/* addi R3, R31, 16 */
		/* 8206CFECh case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x10);
		/* 8206CFECh case    9:*/		return 0x8206CFF0;
		  /* 8206CFF0h */ case   10:  		/* stw R27, <#[R31 + 8]> */
		/* 8206CFF0h case   10:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000008) );
		/* 8206CFF0h case   10:*/		return 0x8206CFF4;
		  /* 8206CFF4h */ case   11:  		/* addi R4, R1, 96 */
		/* 8206CFF4h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8206CFF4h case   11:*/		return 0x8206CFF8;
		  /* 8206CFF8h */ case   12:  		/* stw R20, <#[R31 + 12]> */
		/* 8206CFF8h case   12:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206CFF8h case   12:*/		return 0x8206CFFC;
		  /* 8206CFFCh */ case   13:  		/* li R5, 32 */
		/* 8206CFFCh case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206CFFCh case   13:*/		return 0x8206D000;
		  /* 8206D000h */ case   14:  		/* stw R18, <#[R31 + 4]> */
		/* 8206D000h case   14:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R31 + 0x00000004) );
		/* 8206D000h case   14:*/		return 0x8206D004;
		  /* 8206D004h */ case   15:  		/* bl 149932 */
		/* 8206D004h case   15:*/		regs.LR = 0x8206D008; return 0x820919B0;
		/* 8206D004h case   15:*/		return 0x8206D008;
		  /* 8206D008h */ case   16:  		/* addi R3, R31, 48 */
		/* 8206D008h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x30);
		/* 8206D008h case   16:*/		return 0x8206D00C;
		  /* 8206D00Ch */ case   17:  		/* b 112 */
		/* 8206D00Ch case   17:*/		return 0x8206D07C;
		/* 8206D00Ch case   17:*/		return 0x8206D010;
	}
	return 0x8206D010;
} // Block from 8206CFC8h-8206D010h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206D010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D010);
		  /* 8206D010h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206D010h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206D010h case    0:*/		return 0x8206D014;
		  /* 8206D014h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8206D014h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206D014h case    1:*/		return 0x8206D018;
		  /* 8206D018h */ case    2:  		/* bc 12, CR6_EQ, 112 */
		/* 8206D018h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206D088;  }
		/* 8206D018h case    2:*/		return 0x8206D01C;
		  /* 8206D01Ch */ case    3:  		/* li R10, 8 */
		/* 8206D01Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206D01Ch case    3:*/		return 0x8206D020;
		  /* 8206D020h */ case    4:  		/* addi R11, R1, 92 */
		/* 8206D020h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x5C);
		/* 8206D020h case    4:*/		return 0x8206D024;
		  /* 8206D024h */ case    5:  		/* addi R3, R31, 16 */
		/* 8206D024h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x10);
		/* 8206D024h case    5:*/		return 0x8206D028;
		  /* 8206D028h */ case    6:  		/* addi R9, R3, -4 */
		/* 8206D028h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0xFFFFFFFC);
		/* 8206D028h case    6:*/		return 0x8206D02C;
		  /* 8206D02Ch */ case    7:  		/* mtspr CTR, R10 */
		/* 8206D02Ch case    7:*/		regs.CTR = regs.R10;
		/* 8206D02Ch case    7:*/		return 0x8206D030;
		  /* 8206D030h */ case    8:  		/* lwz R8, <#[R11 + 4]> */
		/* 8206D030h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8206D030h case    8:*/		return 0x8206D034;
		  /* 8206D034h */ case    9:  		/* lwzu R10, <#[R9 + 4]> */
		/* 8206D034h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8206D034h case    9:*/		return 0x8206D038;
		  /* 8206D038h */ case   10:  		/* or R10, R10, R8 */
		/* 8206D038h case   10:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8206D038h case   10:*/		return 0x8206D03C;
		  /* 8206D03Ch */ case   11:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206D03Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206D03Ch case   11:*/		return 0x8206D040;
		  /* 8206D040h */ case   12:  		/* bc 16, CR0_LT, -16 */
		/* 8206D040h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206D030;  }
		/* 8206D040h case   12:*/		return 0x8206D044;
		  /* 8206D044h */ case   13:  		/* li R10, 8 */
		/* 8206D044h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206D044h case   13:*/		return 0x8206D048;
		  /* 8206D048h */ case   14:  		/* addi R11, R1, 124 */
		/* 8206D048h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x7C);
		/* 8206D048h case   14:*/		return 0x8206D04C;
		  /* 8206D04Ch */ case   15:  		/* addi R30, R31, 48 */
		/* 8206D04Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x30);
		/* 8206D04Ch case   15:*/		return 0x8206D050;
		  /* 8206D050h */ case   16:  		/* addi R9, R30, -4 */
		/* 8206D050h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0xFFFFFFFC);
		/* 8206D050h case   16:*/		return 0x8206D054;
		  /* 8206D054h */ case   17:  		/* mtspr CTR, R10 */
		/* 8206D054h case   17:*/		regs.CTR = regs.R10;
		/* 8206D054h case   17:*/		return 0x8206D058;
		  /* 8206D058h */ case   18:  		/* lwz R8, <#[R11 + 4]> */
		/* 8206D058h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8206D058h case   18:*/		return 0x8206D05C;
		  /* 8206D05Ch */ case   19:  		/* lwzu R10, <#[R9 + 4]> */
		/* 8206D05Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8206D05Ch case   19:*/		return 0x8206D060;
		  /* 8206D060h */ case   20:  		/* or R10, R10, R8 */
		/* 8206D060h case   20:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8206D060h case   20:*/		return 0x8206D064;
		  /* 8206D064h */ case   21:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206D064h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206D064h case   21:*/		return 0x8206D068;
		  /* 8206D068h */ case   22:  		/* bc 16, CR0_LT, -16 */
		/* 8206D068h case   22:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206D058;  }
		/* 8206D068h case   22:*/		return 0x8206D06C;
		  /* 8206D06Ch */ case   23:  		/* addi R4, R1, 96 */
		/* 8206D06Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8206D06Ch case   23:*/		return 0x8206D070;
		  /* 8206D070h */ case   24:  		/* li R5, 32 */
		/* 8206D070h case   24:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206D070h case   24:*/		return 0x8206D074;
		  /* 8206D074h */ case   25:  		/* bl 149820 */
		/* 8206D074h case   25:*/		regs.LR = 0x8206D078; return 0x820919B0;
		/* 8206D074h case   25:*/		return 0x8206D078;
		  /* 8206D078h */ case   26:  		/* mr R3, R30 */
		/* 8206D078h case   26:*/		regs.R3 = regs.R30;
		/* 8206D078h case   26:*/		return 0x8206D07C;
	}
	return 0x8206D07C;
} // Block from 8206D010h-8206D07Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8206D07Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D07C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D07C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D07C);
		  /* 8206D07Ch */ case    0:  		/* li R5, 32 */
		/* 8206D07Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206D07Ch case    0:*/		return 0x8206D080;
		  /* 8206D080h */ case    1:  		/* addi R4, R1, 128 */
		/* 8206D080h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 8206D080h case    1:*/		return 0x8206D084;
		  /* 8206D084h */ case    2:  		/* bl 149804 */
		/* 8206D084h case    2:*/		regs.LR = 0x8206D088; return 0x820919B0;
		/* 8206D084h case    2:*/		return 0x8206D088;
	}
	return 0x8206D088;
} // Block from 8206D07Ch-8206D088h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206D088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D088);
		  /* 8206D088h */ case    0:  		/* addi R30, R31, 192 */
		/* 8206D088h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0xC0);
		/* 8206D088h case    0:*/		return 0x8206D08C;
		  /* 8206D08Ch */ case    1:  		/* addi R3, R1, 160 */
		/* 8206D08Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 8206D08Ch case    1:*/		return 0x8206D090;
		  /* 8206D090h */ case    2:  		/* li R5, 32 */
		/* 8206D090h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206D090h case    2:*/		return 0x8206D094;
		  /* 8206D094h */ case    3:  		/* mr R4, R30 */
		/* 8206D094h case    3:*/		regs.R4 = regs.R30;
		/* 8206D094h case    3:*/		return 0x8206D098;
		  /* 8206D098h */ case    4:  		/* bl 149784 */
		/* 8206D098h case    4:*/		regs.LR = 0x8206D09C; return 0x820919B0;
		/* 8206D098h case    4:*/		return 0x8206D09C;
		  /* 8206D09Ch */ case    5:  		/* li R10, 8 */
		/* 8206D09Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206D09Ch case    5:*/		return 0x8206D0A0;
		  /* 8206D0A0h */ case    6:  		/* addi R11, R1, 156 */
		/* 8206D0A0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x9C);
		/* 8206D0A0h case    6:*/		return 0x8206D0A4;
		  /* 8206D0A4h */ case    7:  		/* addi R29, R31, 224 */
		/* 8206D0A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0xE0);
		/* 8206D0A4h case    7:*/		return 0x8206D0A8;
		  /* 8206D0A8h */ case    8:  		/* addi R9, R29, -4 */
		/* 8206D0A8h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R29,0xFFFFFFFC);
		/* 8206D0A8h case    8:*/		return 0x8206D0AC;
		  /* 8206D0ACh */ case    9:  		/* mtspr CTR, R10 */
		/* 8206D0ACh case    9:*/		regs.CTR = regs.R10;
		/* 8206D0ACh case    9:*/		return 0x8206D0B0;
		  /* 8206D0B0h */ case   10:  		/* lwz R8, <#[R11 + 4]> */
		/* 8206D0B0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8206D0B0h case   10:*/		return 0x8206D0B4;
		  /* 8206D0B4h */ case   11:  		/* lwzu R10, <#[R9 + 4]> */
		/* 8206D0B4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8206D0B4h case   11:*/		return 0x8206D0B8;
		  /* 8206D0B8h */ case   12:  		/* or R10, R10, R8 */
		/* 8206D0B8h case   12:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8206D0B8h case   12:*/		return 0x8206D0BC;
		  /* 8206D0BCh */ case   13:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206D0BCh case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206D0BCh case   13:*/		return 0x8206D0C0;
		  /* 8206D0C0h */ case   14:  		/* bc 16, CR0_LT, -16 */
		/* 8206D0C0h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206D0B0;  }
		/* 8206D0C0h case   14:*/		return 0x8206D0C4;
		  /* 8206D0C4h */ case   15:  		/* li R10, 8 */
		/* 8206D0C4h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206D0C4h case   15:*/		return 0x8206D0C8;
		  /* 8206D0C8h */ case   16:  		/* mr R11, R21 */
		/* 8206D0C8h case   16:*/		regs.R11 = regs.R21;
		/* 8206D0C8h case   16:*/		return 0x8206D0CC;
		  /* 8206D0CCh */ case   17:  		/* mtspr CTR, R10 */
		/* 8206D0CCh case   17:*/		regs.CTR = regs.R10;
		/* 8206D0CCh case   17:*/		return 0x8206D0D0;
		  /* 8206D0D0h */ case   18:  		/* addi R10, R1, 160 */
		/* 8206D0D0h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 8206D0D0h case   18:*/		return 0x8206D0D4;
		  /* 8206D0D4h */ case   19:  		/* addi R9, R1, 96 */
		/* 8206D0D4h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 8206D0D4h case   19:*/		return 0x8206D0D8;
		  /* 8206D0D8h */ case   20:  		/* add R10, R11, R10 */
		/* 8206D0D8h case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8206D0D8h case   20:*/		return 0x8206D0DC;
		  /* 8206D0DCh */ case   21:  		/* lwzx R9, <#[R11 + R9]> */
		/* 8206D0DCh case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8206D0DCh case   21:*/		return 0x8206D0E0;
		  /* 8206D0E0h */ case   22:  		/* addi R11, R11, 4 */
		/* 8206D0E0h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206D0E0h case   22:*/		return 0x8206D0E4;
		  /* 8206D0E4h */ case   23:  		/* lwz R8, <#[R10]> */
		/* 8206D0E4h case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8206D0E4h case   23:*/		return 0x8206D0E8;
		  /* 8206D0E8h */ case   24:  		/* and R9, R9, R8 */
		/* 8206D0E8h case   24:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8206D0E8h case   24:*/		return 0x8206D0EC;
		  /* 8206D0ECh */ case   25:  		/* stw R9, <#[R10]> */
		/* 8206D0ECh case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8206D0ECh case   25:*/		return 0x8206D0F0;
		  /* 8206D0F0h */ case   26:  		/* bc 16, CR0_LT, -32 */
		/* 8206D0F0h case   26:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206D0D0;  }
		/* 8206D0F0h case   26:*/		return 0x8206D0F4;
		  /* 8206D0F4h */ case   27:  		/* addi R3, R1, 160 */
		/* 8206D0F4h case   27:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 8206D0F4h case   27:*/		return 0x8206D0F8;
		  /* 8206D0F8h */ case   28:  		/* bl -19072 */
		/* 8206D0F8h case   28:*/		regs.LR = 0x8206D0FC; return 0x82068678;
		/* 8206D0F8h case   28:*/		return 0x8206D0FC;
		  /* 8206D0FCh */ case   29:  		/* cmplwi CR6, R3, 256 */
		/* 8206D0FCh case   29:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000100);
		/* 8206D0FCh case   29:*/		return 0x8206D100;
		  /* 8206D100h */ case   30:  		/* bc 12, CR6_LT, 192 */
		/* 8206D100h case   30:*/		if ( regs.CR[6].lt ) { return 0x8206D1C0;  }
		/* 8206D100h case   30:*/		return 0x8206D104;
		  /* 8206D104h */ case   31:  		/* rlwinm. R11, R17, 0, 24, 31 */
		/* 8206D104h case   31:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R17);
		/* 8206D104h case   31:*/		return 0x8206D108;
		  /* 8206D108h */ case   32:  		/* addi R3, R1, 160 */
		/* 8206D108h case   32:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 8206D108h case   32:*/		return 0x8206D10C;
		  /* 8206D10Ch */ case   33:  		/* li R5, 32 */
		/* 8206D10Ch case   33:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206D10Ch case   33:*/		return 0x8206D110;
		  /* 8206D110h */ case   34:  		/* bc 12, CR0_EQ, 52 */
		/* 8206D110h case   34:*/		if ( regs.CR[0].eq ) { return 0x8206D144;  }
		/* 8206D110h case   34:*/		return 0x8206D114;
		  /* 8206D114h */ case   35:  		/* addi R4, R31, 160 */
		/* 8206D114h case   35:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xA0);
		/* 8206D114h case   35:*/		return 0x8206D118;
		  /* 8206D118h */ case   36:  		/* bl 149656 */
		/* 8206D118h case   36:*/		regs.LR = 0x8206D11C; return 0x820919B0;
		/* 8206D118h case   36:*/		return 0x8206D11C;
		  /* 8206D11Ch */ case   37:  		/* li R10, 8 */
		/* 8206D11Ch case   37:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206D11Ch case   37:*/		return 0x8206D120;
		  /* 8206D120h */ case   38:  		/* addi R11, R1, 156 */
		/* 8206D120h case   38:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x9C);
		/* 8206D120h case   38:*/		return 0x8206D124;
		  /* 8206D124h */ case   39:  		/* addi R9, R29, -4 */
		/* 8206D124h case   39:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R29,0xFFFFFFFC);
		/* 8206D124h case   39:*/		return 0x8206D128;
		  /* 8206D128h */ case   40:  		/* mtspr CTR, R10 */
		/* 8206D128h case   40:*/		regs.CTR = regs.R10;
		/* 8206D128h case   40:*/		return 0x8206D12C;
		  /* 8206D12Ch */ case   41:  		/* lwz R8, <#[R11 + 4]> */
		/* 8206D12Ch case   41:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8206D12Ch case   41:*/		return 0x8206D130;
		  /* 8206D130h */ case   42:  		/* lwzu R10, <#[R9 + 4]> */
		/* 8206D130h case   42:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8206D130h case   42:*/		return 0x8206D134;
		  /* 8206D134h */ case   43:  		/* or R10, R10, R8 */
		/* 8206D134h case   43:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8206D134h case   43:*/		return 0x8206D138;
		  /* 8206D138h */ case   44:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206D138h case   44:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206D138h case   44:*/		return 0x8206D13C;
		  /* 8206D13Ch */ case   45:  		/* bc 16, CR0_LT, -16 */
		/* 8206D13Ch case   45:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206D12C;  }
		/* 8206D13Ch case   45:*/		return 0x8206D140;
		  /* 8206D140h */ case   46:  		/* b 48 */
		/* 8206D140h case   46:*/		return 0x8206D170;
		/* 8206D140h case   46:*/		return 0x8206D144;
	}
	return 0x8206D144;
} // Block from 8206D088h-8206D144h (47 instructions)

//////////////////////////////////////////////////////
// Block at 8206D144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D144);
		  /* 8206D144h */ case    0:  		/* addi R4, R31, 128 */
		/* 8206D144h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x80);
		/* 8206D144h case    0:*/		return 0x8206D148;
		  /* 8206D148h */ case    1:  		/* bl 149608 */
		/* 8206D148h case    1:*/		regs.LR = 0x8206D14C; return 0x820919B0;
		/* 8206D148h case    1:*/		return 0x8206D14C;
		  /* 8206D14Ch */ case    2:  		/* li R10, 8 */
		/* 8206D14Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206D14Ch case    2:*/		return 0x8206D150;
		  /* 8206D150h */ case    3:  		/* addi R11, R1, 156 */
		/* 8206D150h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x9C);
		/* 8206D150h case    3:*/		return 0x8206D154;
		  /* 8206D154h */ case    4:  		/* addi R9, R30, -4 */
		/* 8206D154h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0xFFFFFFFC);
		/* 8206D154h case    4:*/		return 0x8206D158;
		  /* 8206D158h */ case    5:  		/* mtspr CTR, R10 */
		/* 8206D158h case    5:*/		regs.CTR = regs.R10;
		/* 8206D158h case    5:*/		return 0x8206D15C;
		  /* 8206D15Ch */ case    6:  		/* lwz R8, <#[R11 + 4]> */
		/* 8206D15Ch case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8206D15Ch case    6:*/		return 0x8206D160;
		  /* 8206D160h */ case    7:  		/* lwzu R10, <#[R9 + 4]> */
		/* 8206D160h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8206D160h case    7:*/		return 0x8206D164;
		  /* 8206D164h */ case    8:  		/* or R10, R10, R8 */
		/* 8206D164h case    8:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8206D164h case    8:*/		return 0x8206D168;
		  /* 8206D168h */ case    9:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206D168h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206D168h case    9:*/		return 0x8206D16C;
		  /* 8206D16Ch */ case   10:  		/* bc 16, CR0_LT, -16 */
		/* 8206D16Ch case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206D15C;  }
		/* 8206D16Ch case   10:*/		return 0x8206D170;
	}
	return 0x8206D170;
} // Block from 8206D144h-8206D170h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206D170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D170);
		  /* 8206D170h */ case    0:  		/* li R10, 8 */
		/* 8206D170h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206D170h case    0:*/		return 0x8206D174;
		  /* 8206D174h */ case    1:  		/* mr R11, R21 */
		/* 8206D174h case    1:*/		regs.R11 = regs.R21;
		/* 8206D174h case    1:*/		return 0x8206D178;
		  /* 8206D178h */ case    2:  		/* mtspr CTR, R10 */
		/* 8206D178h case    2:*/		regs.CTR = regs.R10;
		/* 8206D178h case    2:*/		return 0x8206D17C;
		  /* 8206D17Ch */ case    3:  		/* addi R10, R1, 160 */
		/* 8206D17Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 8206D17Ch case    3:*/		return 0x8206D180;
		  /* 8206D180h */ case    4:  		/* addi R9, R1, 128 */
		/* 8206D180h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 8206D180h case    4:*/		return 0x8206D184;
		  /* 8206D184h */ case    5:  		/* add R10, R11, R10 */
		/* 8206D184h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8206D184h case    5:*/		return 0x8206D188;
		  /* 8206D188h */ case    6:  		/* lwzx R9, <#[R11 + R9]> */
		/* 8206D188h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 8206D188h case    6:*/		return 0x8206D18C;
		  /* 8206D18Ch */ case    7:  		/* addi R11, R11, 4 */
		/* 8206D18Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206D18Ch case    7:*/		return 0x8206D190;
		  /* 8206D190h */ case    8:  		/* lwz R8, <#[R10]> */
		/* 8206D190h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8206D190h case    8:*/		return 0x8206D194;
		  /* 8206D194h */ case    9:  		/* and R9, R9, R8 */
		/* 8206D194h case    9:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8206D194h case    9:*/		return 0x8206D198;
		  /* 8206D198h */ case   10:  		/* stw R9, <#[R10]> */
		/* 8206D198h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8206D198h case   10:*/		return 0x8206D19C;
		  /* 8206D19Ch */ case   11:  		/* bc 16, CR0_LT, -32 */
		/* 8206D19Ch case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206D17C;  }
		/* 8206D19Ch case   11:*/		return 0x8206D1A0;
		  /* 8206D1A0h */ case   12:  		/* addi R3, R1, 160 */
		/* 8206D1A0h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 8206D1A0h case   12:*/		return 0x8206D1A4;
		  /* 8206D1A4h */ case   13:  		/* bl -19244 */
		/* 8206D1A4h case   13:*/		regs.LR = 0x8206D1A8; return 0x82068678;
		/* 8206D1A4h case   13:*/		return 0x8206D1A8;
		  /* 8206D1A8h */ case   14:  		/* cmplwi CR6, R3, 256 */
		/* 8206D1A8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000100);
		/* 8206D1A8h case   14:*/		return 0x8206D1AC;
		  /* 8206D1ACh */ case   15:  		/* bc 4, CR6_LT, 24 */
		/* 8206D1ACh case   15:*/		if ( !regs.CR[6].lt ) { return 0x8206D1C4;  }
		/* 8206D1ACh case   15:*/		return 0x8206D1B0;
		  /* 8206D1B0h */ case   16:  		/* b 16 */
		/* 8206D1B0h case   16:*/		return 0x8206D1C0;
		/* 8206D1B0h case   16:*/		return 0x8206D1B4;
	}
	return 0x8206D1B4;
} // Block from 8206D170h-8206D1B4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8206D1B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D1B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D1B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D1B4);
		  /* 8206D1B4h */ case    0:  		/* lbz R11, <#[R31 + 124]> */
		/* 8206D1B4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000007C) );
		/* 8206D1B4h case    0:*/		return 0x8206D1B8;
		  /* 8206D1B8h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8206D1B8h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8206D1B8h case    1:*/		return 0x8206D1BC;
		  /* 8206D1BCh */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 8206D1BCh case    2:*/		if ( regs.CR[0].eq ) { return 0x8206D1C4;  }
		/* 8206D1BCh case    2:*/		return 0x8206D1C0;
	}
	return 0x8206D1C0;
} // Block from 8206D1B4h-8206D1C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206D1C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D1C0);
		  /* 8206D1C0h */ case    0:  		/* mr R24, R18 */
		/* 8206D1C0h case    0:*/		regs.R24 = regs.R18;
		/* 8206D1C0h case    0:*/		return 0x8206D1C4;
	}
	return 0x8206D1C4;
} // Block from 8206D1C0h-8206D1C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206D1C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D1C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D1C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D1C4);
		  /* 8206D1C4h */ case    0:  		/* rlwinm. R11, R24, 0, 24, 31 */
		/* 8206D1C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R24);
		/* 8206D1C4h case    0:*/		return 0x8206D1C8;
		  /* 8206D1C8h */ case    1:  		/* bc 12, CR0_EQ, 192 */
		/* 8206D1C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206D288;  }
		/* 8206D1C8h case    1:*/		return 0x8206D1CC;
		  /* 8206D1CCh */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206D1CCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206D1CCh case    2:*/		return 0x8206D1D0;
		  /* 8206D1D0h */ case    3:  		/* li R9, 2 */
		/* 8206D1D0h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 8206D1D0h case    3:*/		return 0x8206D1D4;
		  /* 8206D1D4h */ case    4:  		/* addi R3, R31, 128 */
		/* 8206D1D4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x80);
		/* 8206D1D4h case    4:*/		return 0x8206D1D8;
		  /* 8206D1D8h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 8206D1D8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206D1D8h case    5:*/		return 0x8206D1DC;
		  /* 8206D1DCh */ case    6:  		/* li R5, 32 */
		/* 8206D1DCh case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206D1DCh case    6:*/		return 0x8206D1E0;
		  /* 8206D1E0h */ case    7:  		/* bc 12, CR6_EQ, 80 */
		/* 8206D1E0h case    7:*/		if ( regs.CR[6].eq ) { return 0x8206D230;  }
		/* 8206D1E0h case    7:*/		return 0x8206D1E4;
		  /* 8206D1E4h */ case    8:  		/* lwz R10, <#[R31 + 8]> */
		/* 8206D1E4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8206D1E4h case    8:*/		return 0x8206D1E8;
		  /* 8206D1E8h */ case    9:  		/* addi R4, R31, 16 */
		/* 8206D1E8h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 8206D1E8h case    9:*/		return 0x8206D1EC;
		  /* 8206D1ECh */ case   10:  		/* lwz R8, <#[R31 + 12]> */
		/* 8206D1ECh case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206D1ECh case   10:*/		return 0x8206D1F0;
		  /* 8206D1F0h */ case   11:  		/* lwz R11, <#[R26]> */
		/* 8206D1F0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8206D1F0h case   11:*/		return 0x8206D1F4;
		  /* 8206D1F4h */ case   12:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 8206D1F4h case   12:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 8206D1F4h case   12:*/		return 0x8206D1F8;
		  /* 8206D1F8h */ case   13:  		/* rlwinm R8, R8, 1, 0, 30 */
		/* 8206D1F8h case   13:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R8);
		/* 8206D1F8h case   13:*/		return 0x8206D1FC;
		  /* 8206D1FCh */ case   14:  		/* slw R9, R9, R8 */
		/* 8206D1FCh case   14:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8206D1FCh case   14:*/		return 0x8206D200;
		  /* 8206D200h */ case   15:  		/* lwzx R8, <#[R10 + R11]> */
		/* 8206D200h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8206D200h case   15:*/		return 0x8206D204;
		  /* 8206D204h */ case   16:  		/* rlwinm R9, R9, 16, 0, 15 */
		/* 8206D204h case   16:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R9,regs.R9);
		/* 8206D204h case   16:*/		return 0x8206D208;
		  /* 8206D208h */ case   17:  		/* or R9, R9, R8 */
		/* 8206D208h case   17:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8206D208h case   17:*/		return 0x8206D20C;
		  /* 8206D20Ch */ case   18:  		/* rlwimi R9, R8, 0, 16, 3 */
		/* 8206D20Ch case   18:*/		cpu::op::rlwimi<0,0,16,3>(regs,&regs.R9,regs.R8);
		/* 8206D20Ch case   18:*/		return 0x8206D210;
		  /* 8206D210h */ case   19:  		/* stwx R9, <#[R10 + R11]> */
		/* 8206D210h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8206D210h case   19:*/		return 0x8206D214;
		  /* 8206D214h */ case   20:  		/* stw R21, <#[R31 + 4]> */
		/* 8206D214h case   20:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000004) );
		/* 8206D214h case   20:*/		return 0x8206D218;
		  /* 8206D218h */ case   21:  		/* bl 149400 */
		/* 8206D218h case   21:*/		regs.LR = 0x8206D21C; return 0x820919B0;
		/* 8206D218h case   21:*/		return 0x8206D21C;
		  /* 8206D21Ch */ case   22:  		/* addi R3, R31, 192 */
		/* 8206D21Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xC0);
		/* 8206D21Ch case   22:*/		return 0x8206D220;
		  /* 8206D220h */ case   23:  		/* addi R4, R31, 48 */
		/* 8206D220h case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x30);
		/* 8206D220h case   23:*/		return 0x8206D224;
		  /* 8206D224h */ case   24:  		/* li R5, 32 */
		/* 8206D224h case   24:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206D224h case   24:*/		return 0x8206D228;
		  /* 8206D228h */ case   25:  		/* bl 149384 */
		/* 8206D228h case   25:*/		regs.LR = 0x8206D22C; return 0x820919B0;
		/* 8206D228h case   25:*/		return 0x8206D22C;
		  /* 8206D22Ch */ case   26:  		/* b 56 */
		/* 8206D22Ch case   26:*/		return 0x8206D264;
		/* 8206D22Ch case   26:*/		return 0x8206D230;
	}
	return 0x8206D230;
} // Block from 8206D1C4h-8206D230h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8206D230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D230);
		  /* 8206D230h */ case    0:  		/* rlwinm R11, R20, 1, 0, 30 */
		/* 8206D230h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R20);
		/* 8206D230h case    0:*/		return 0x8206D234;
		  /* 8206D234h */ case    1:  		/* lwz R10, <#[R23 - 8]> */
		/* 8206D234h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0xFFFFFFF8) );
		/* 8206D234h case    1:*/		return 0x8206D238;
		  /* 8206D238h */ case    2:  		/* li R4, 0 */
		/* 8206D238h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206D238h case    2:*/		return 0x8206D23C;
		  /* 8206D23Ch */ case    3:  		/* slw R11, R9, R11 */
		/* 8206D23Ch case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8206D23Ch case    3:*/		return 0x8206D240;
		  /* 8206D240h */ case    4:  		/* rlwinm R11, R11, 16, 0, 15 */
		/* 8206D240h case    4:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R11,regs.R11);
		/* 8206D240h case    4:*/		return 0x8206D244;
		  /* 8206D244h */ case    5:  		/* or R11, R11, R10 */
		/* 8206D244h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206D244h case    5:*/		return 0x8206D248;
		  /* 8206D248h */ case    6:  		/* rlwimi R11, R10, 0, 16, 3 */
		/* 8206D248h case    6:*/		cpu::op::rlwimi<0,0,16,3>(regs,&regs.R11,regs.R10);
		/* 8206D248h case    6:*/		return 0x8206D24C;
		  /* 8206D24Ch */ case    7:  		/* stw R11, <#[R23 - 8]> */
		/* 8206D24Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0xFFFFFFF8) );
		/* 8206D24Ch case    7:*/		return 0x8206D250;
		  /* 8206D250h */ case    8:  		/* bl 147696 */
		/* 8206D250h case    8:*/		regs.LR = 0x8206D254; return 0x82091340;
		/* 8206D250h case    8:*/		return 0x8206D254;
		  /* 8206D254h */ case    9:  		/* addi R3, R31, 192 */
		/* 8206D254h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xC0);
		/* 8206D254h case    9:*/		return 0x8206D258;
		  /* 8206D258h */ case   10:  		/* li R5, 32 */
		/* 8206D258h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206D258h case   10:*/		return 0x8206D25C;
		  /* 8206D25Ch */ case   11:  		/* li R4, 0 */
		/* 8206D25Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206D25Ch case   11:*/		return 0x8206D260;
		  /* 8206D260h */ case   12:  		/* bl 147680 */
		/* 8206D260h case   12:*/		regs.LR = 0x8206D264; return 0x82091340;
		/* 8206D260h case   12:*/		return 0x8206D264;
	}
	return 0x8206D264;
} // Block from 8206D230h-8206D264h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206D264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D264);
		  /* 8206D264h */ case    0:  		/* addi R3, R31, 160 */
		/* 8206D264h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xA0);
		/* 8206D264h case    0:*/		return 0x8206D268;
		  /* 8206D268h */ case    1:  		/* stb R21, <#[R31 + 124]> */
		/* 8206D268h case    1:*/		cpu::mem::store8( regs, regs.R21, (uint32)(regs.R31 + 0x0000007C) );
		/* 8206D268h case    1:*/		return 0x8206D26C;
		  /* 8206D26Ch */ case    2:  		/* li R5, 32 */
		/* 8206D26Ch case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206D26Ch case    2:*/		return 0x8206D270;
		  /* 8206D270h */ case    3:  		/* li R4, 0 */
		/* 8206D270h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206D270h case    3:*/		return 0x8206D274;
		  /* 8206D274h */ case    4:  		/* bl 147660 */
		/* 8206D274h case    4:*/		regs.LR = 0x8206D278; return 0x82091340;
		/* 8206D274h case    4:*/		return 0x8206D278;
		  /* 8206D278h */ case    5:  		/* addi R3, R31, 224 */
		/* 8206D278h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xE0);
		/* 8206D278h case    5:*/		return 0x8206D27C;
		  /* 8206D27Ch */ case    6:  		/* li R5, 32 */
		/* 8206D27Ch case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206D27Ch case    6:*/		return 0x8206D280;
		  /* 8206D280h */ case    7:  		/* li R4, 0 */
		/* 8206D280h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206D280h case    7:*/		return 0x8206D284;
		  /* 8206D284h */ case    8:  		/* bl 147644 */
		/* 8206D284h case    8:*/		regs.LR = 0x8206D288; return 0x82091340;
		/* 8206D284h case    8:*/		return 0x8206D288;
	}
	return 0x8206D288;
} // Block from 8206D264h-8206D288h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206D288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D288);
		  /* 8206D288h */ case    0:  		/* cmplwi CR6, R22, 0 */
		/* 8206D288h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8206D288h case    0:*/		return 0x8206D28C;
		  /* 8206D28Ch */ case    1:  		/* bc 12, CR6_EQ, 220 */
		/* 8206D28Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8206D368;  }
		/* 8206D28Ch case    1:*/		return 0x8206D290;
		  /* 8206D290h */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206D290h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206D290h case    2:*/		return 0x8206D294;
		  /* 8206D294h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 8206D294h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206D294h case    3:*/		return 0x8206D298;
		  /* 8206D298h */ case    4:  		/* bc 4, CR6_EQ, 208 */
		/* 8206D298h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8206D368;  }
		/* 8206D298h case    4:*/		return 0x8206D29C;
		  /* 8206D29Ch */ case    5:  		/* lwz R11, <#[R19]> */
		/* 8206D29Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 8206D29Ch case    5:*/		return 0x8206D2A0;
		  /* 8206D2A0h */ case    6:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8206D2A0h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8206D2A0h case    6:*/		return 0x8206D2A4;
		  /* 8206D2A4h */ case    7:  		/* cmplwi CR6, R11, 24 */
		/* 8206D2A4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 8206D2A4h case    7:*/		return 0x8206D2A8;
		  /* 8206D2A8h */ case    8:  		/* bc 12, CR6_LT, 12 */
		/* 8206D2A8h case    8:*/		if ( regs.CR[6].lt ) { return 0x8206D2B4;  }
		/* 8206D2A8h case    8:*/		return 0x8206D2AC;
		  /* 8206D2ACh */ case    9:  		/* cmplwi CR6, R11, 26 */
		/* 8206D2ACh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001A);
		/* 8206D2ACh case    9:*/		return 0x8206D2B0;
		  /* 8206D2B0h */ case   10:  		/* bc 4, CR6_GT, 8 */
		/* 8206D2B0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x8206D2B8;  }
		/* 8206D2B0h case   10:*/		return 0x8206D2B4;
	}
	return 0x8206D2B4;
} // Block from 8206D288h-8206D2B4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206D2B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D2B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D2B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D2B4);
		  /* 8206D2B4h */ case    0:  		/* stb R18, <#[R31 + 124]> */
		/* 8206D2B4h case    0:*/		cpu::mem::store8( regs, regs.R18, (uint32)(regs.R31 + 0x0000007C) );
		/* 8206D2B4h case    0:*/		return 0x8206D2B8;
	}
	return 0x8206D2B8;
} // Block from 8206D2B4h-8206D2B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206D2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D2B8);
		  /* 8206D2B8h */ case    0:  		/* li R10, 8 */
		/* 8206D2B8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206D2B8h case    0:*/		return 0x8206D2BC;
		  /* 8206D2BCh */ case    1:  		/* rlwinm. R11, R17, 0, 24, 31 */
		/* 8206D2BCh case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R17);
		/* 8206D2BCh case    1:*/		return 0x8206D2C0;
		  /* 8206D2C0h */ case    2:  		/* addi R9, R1, 96 */
		/* 8206D2C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 8206D2C0h case    2:*/		return 0x8206D2C4;
		  /* 8206D2C4h */ case    3:  		/* mtspr CTR, R10 */
		/* 8206D2C4h case    3:*/		regs.CTR = regs.R10;
		/* 8206D2C4h case    3:*/		return 0x8206D2C8;
		  /* 8206D2C8h */ case    4:  		/* bc 12, CR0_EQ, 84 */
		/* 8206D2C8h case    4:*/		if ( regs.CR[0].eq ) { return 0x8206D31C;  }
		/* 8206D2C8h case    4:*/		return 0x8206D2CC;
		  /* 8206D2CCh */ case    5:  		/* addi R11, R31, 128 */
		/* 8206D2CCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x80);
		/* 8206D2CCh case    5:*/		return 0x8206D2D0;
		  /* 8206D2D0h */ case    6:  		/* subf R9, R11, R9 */
		/* 8206D2D0h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8206D2D0h case    6:*/		return 0x8206D2D4;
		  /* 8206D2D4h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 8206D2D4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D2D4h case    7:*/		return 0x8206D2D8;
		  /* 8206D2D8h */ case    8:  		/* lwzx R8, <#[R9 + R11]> */
		/* 8206D2D8h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8206D2D8h case    8:*/		return 0x8206D2DC;
		  /* 8206D2DCh */ case    9:  		/* or R10, R8, R10 */
		/* 8206D2DCh case    9:*/		cpu::op::or<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8206D2DCh case    9:*/		return 0x8206D2E0;
		  /* 8206D2E0h */ case   10:  		/* stw R10, <#[R11]> */
		/* 8206D2E0h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D2E0h case   10:*/		return 0x8206D2E4;
		  /* 8206D2E4h */ case   11:  		/* addi R11, R11, 4 */
		/* 8206D2E4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206D2E4h case   11:*/		return 0x8206D2E8;
		  /* 8206D2E8h */ case   12:  		/* bc 16, CR0_LT, -20 */
		/* 8206D2E8h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206D2D4;  }
		/* 8206D2E8h case   12:*/		return 0x8206D2EC;
		  /* 8206D2ECh */ case   13:  		/* li R10, 8 */
		/* 8206D2ECh case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206D2ECh case   13:*/		return 0x8206D2F0;
		  /* 8206D2F0h */ case   14:  		/* addi R11, R31, 192 */
		/* 8206D2F0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xC0);
		/* 8206D2F0h case   14:*/		return 0x8206D2F4;
		  /* 8206D2F4h */ case   15:  		/* addi R9, R1, 128 */
		/* 8206D2F4h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 8206D2F4h case   15:*/		return 0x8206D2F8;
		  /* 8206D2F8h */ case   16:  		/* subf R9, R11, R9 */
		/* 8206D2F8h case   16:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8206D2F8h case   16:*/		return 0x8206D2FC;
		  /* 8206D2FCh */ case   17:  		/* mtspr CTR, R10 */
		/* 8206D2FCh case   17:*/		regs.CTR = regs.R10;
		/* 8206D2FCh case   17:*/		return 0x8206D300;
		  /* 8206D300h */ case   18:  		/* lwz R10, <#[R11]> */
		/* 8206D300h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D300h case   18:*/		return 0x8206D304;
		  /* 8206D304h */ case   19:  		/* lwzx R8, <#[R9 + R11]> */
		/* 8206D304h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8206D304h case   19:*/		return 0x8206D308;
		  /* 8206D308h */ case   20:  		/* or R10, R8, R10 */
		/* 8206D308h case   20:*/		cpu::op::or<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8206D308h case   20:*/		return 0x8206D30C;
		  /* 8206D30Ch */ case   21:  		/* stw R10, <#[R11]> */
		/* 8206D30Ch case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D30Ch case   21:*/		return 0x8206D310;
		  /* 8206D310h */ case   22:  		/* addi R11, R11, 4 */
		/* 8206D310h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206D310h case   22:*/		return 0x8206D314;
		  /* 8206D314h */ case   23:  		/* bc 16, CR0_LT, -20 */
		/* 8206D314h case   23:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206D300;  }
		/* 8206D314h case   23:*/		return 0x8206D318;
		  /* 8206D318h */ case   24:  		/* b 80 */
		/* 8206D318h case   24:*/		return 0x8206D368;
		/* 8206D318h case   24:*/		return 0x8206D31C;
	}
	return 0x8206D31C;
} // Block from 8206D2B8h-8206D31Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8206D31Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D31C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D31C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D31C);
		  /* 8206D31Ch */ case    0:  		/* addi R11, R31, 160 */
		/* 8206D31Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xA0);
		/* 8206D31Ch case    0:*/		return 0x8206D320;
		  /* 8206D320h */ case    1:  		/* subf R9, R11, R9 */
		/* 8206D320h case    1:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8206D320h case    1:*/		return 0x8206D324;
		  /* 8206D324h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 8206D324h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D324h case    2:*/		return 0x8206D328;
		  /* 8206D328h */ case    3:  		/* lwzx R8, <#[R9 + R11]> */
		/* 8206D328h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8206D328h case    3:*/		return 0x8206D32C;
		  /* 8206D32Ch */ case    4:  		/* or R10, R8, R10 */
		/* 8206D32Ch case    4:*/		cpu::op::or<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8206D32Ch case    4:*/		return 0x8206D330;
		  /* 8206D330h */ case    5:  		/* stw R10, <#[R11]> */
		/* 8206D330h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D330h case    5:*/		return 0x8206D334;
		  /* 8206D334h */ case    6:  		/* addi R11, R11, 4 */
		/* 8206D334h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206D334h case    6:*/		return 0x8206D338;
		  /* 8206D338h */ case    7:  		/* bc 16, CR0_LT, -20 */
		/* 8206D338h case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206D324;  }
		/* 8206D338h case    7:*/		return 0x8206D33C;
		  /* 8206D33Ch */ case    8:  		/* li R10, 8 */
		/* 8206D33Ch case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206D33Ch case    8:*/		return 0x8206D340;
		  /* 8206D340h */ case    9:  		/* addi R11, R31, 224 */
		/* 8206D340h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xE0);
		/* 8206D340h case    9:*/		return 0x8206D344;
		  /* 8206D344h */ case   10:  		/* addi R9, R1, 128 */
		/* 8206D344h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 8206D344h case   10:*/		return 0x8206D348;
		  /* 8206D348h */ case   11:  		/* subf R9, R11, R9 */
		/* 8206D348h case   11:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8206D348h case   11:*/		return 0x8206D34C;
		  /* 8206D34Ch */ case   12:  		/* mtspr CTR, R10 */
		/* 8206D34Ch case   12:*/		regs.CTR = regs.R10;
		/* 8206D34Ch case   12:*/		return 0x8206D350;
		  /* 8206D350h */ case   13:  		/* lwz R10, <#[R11]> */
		/* 8206D350h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D350h case   13:*/		return 0x8206D354;
		  /* 8206D354h */ case   14:  		/* lwzx R8, <#[R9 + R11]> */
		/* 8206D354h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8206D354h case   14:*/		return 0x8206D358;
		  /* 8206D358h */ case   15:  		/* or R10, R8, R10 */
		/* 8206D358h case   15:*/		cpu::op::or<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8206D358h case   15:*/		return 0x8206D35C;
		  /* 8206D35Ch */ case   16:  		/* stw R10, <#[R11]> */
		/* 8206D35Ch case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D35Ch case   16:*/		return 0x8206D360;
		  /* 8206D360h */ case   17:  		/* addi R11, R11, 4 */
		/* 8206D360h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206D360h case   17:*/		return 0x8206D364;
		  /* 8206D364h */ case   18:  		/* bc 16, CR0_LT, -20 */
		/* 8206D364h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206D350;  }
		/* 8206D364h case   18:*/		return 0x8206D368;
	}
	return 0x8206D368;
} // Block from 8206D31Ch-8206D368h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206D368h
// Function '?DestroyResource@D3D@@YAXPAUD3DResource@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D368);
		  /* 8206D368h */ case    0:  		/* rlwinm. R11, R17, 0, 24, 31 */
		/* 8206D368h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R17);
		/* 8206D368h case    0:*/		return 0x8206D36C;
		  /* 8206D36Ch */ case    1:  		/* bc 12, CR0_EQ, 64 */
		/* 8206D36Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8206D3AC;  }
		/* 8206D36Ch case    1:*/		return 0x8206D370;
		  /* 8206D370h */ case    2:  		/* cmplwi CR6, R20, 4 */
		/* 8206D370h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000004);
		/* 8206D370h case    2:*/		return 0x8206D374;
		  /* 8206D374h */ case    3:  		/* bc 4, CR6_LT, 32 */
		/* 8206D374h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8206D394;  }
		/* 8206D374h case    3:*/		return 0x8206D378;
		  /* 8206D378h */ case    4:  		/* slw R11, R18, R20 */
		/* 8206D378h case    4:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R18,regs.R20);
		/* 8206D378h case    4:*/		return 0x8206D37C;
		  /* 8206D37Ch */ case    5:  		/* lwz R10, <#[R23 - 8]> */
		/* 8206D37Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0xFFFFFFF8) );
		/* 8206D37Ch case    5:*/		return 0x8206D380;
		  /* 8206D380h */ case    6:  		/* rlwinm R11, R11, 28, 0, 3 */
		/* 8206D380h case    6:*/		cpu::op::rlwinm<0,28,0,3>(regs,&regs.R11,regs.R11);
		/* 8206D380h case    6:*/		return 0x8206D384;
		  /* 8206D384h */ case    7:  		/* or R11, R11, R10 */
		/* 8206D384h case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206D384h case    7:*/		return 0x8206D388;
		  /* 8206D388h */ case    8:  		/* rlwimi R11, R10, 0, 4, 31 */
		/* 8206D388h case    8:*/		cpu::op::rlwimi<0,0,4,31>(regs,&regs.R11,regs.R10);
		/* 8206D388h case    8:*/		return 0x8206D38C;
		  /* 8206D38Ch */ case    9:  		/* stw R11, <#[R23 - 8]> */
		/* 8206D38Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0xFFFFFFF8) );
		/* 8206D38Ch case    9:*/		return 0x8206D390;
		  /* 8206D390h */ case   10:  		/* b 28 */
		/* 8206D390h case   10:*/		return 0x8206D3AC;
		/* 8206D390h case   10:*/		return 0x8206D394;
	}
	return 0x8206D394;
} // Block from 8206D368h-8206D394h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206D394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D394);
		  /* 8206D394h */ case    0:  		/* addi R11, R20, -4 */
		/* 8206D394h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R20,0xFFFFFFFC);
		/* 8206D394h case    0:*/		return 0x8206D398;
		  /* 8206D398h */ case    1:  		/* lwz R10, <#[R23 - 4]> */
		/* 8206D398h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0xFFFFFFFC) );
		/* 8206D398h case    1:*/		return 0x8206D39C;
		  /* 8206D39Ch */ case    2:  		/* slw R11, R18, R11 */
		/* 8206D39Ch case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R18,regs.R11);
		/* 8206D39Ch case    2:*/		return 0x8206D3A0;
		  /* 8206D3A0h */ case    3:  		/* or R11, R11, R10 */
		/* 8206D3A0h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206D3A0h case    3:*/		return 0x8206D3A4;
		  /* 8206D3A4h */ case    4:  		/* rlwimi R11, R10, 0, 0, 29 */
		/* 8206D3A4h case    4:*/		cpu::op::rlwimi<0,0,0,29>(regs,&regs.R11,regs.R10);
		/* 8206D3A4h case    4:*/		return 0x8206D3A8;
		  /* 8206D3A8h */ case    5:  		/* stw R11, <#[R23 - 4]> */
		/* 8206D3A8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0xFFFFFFFC) );
		/* 8206D3A8h case    5:*/		return 0x8206D3AC;
	}
	return 0x8206D3AC;
} // Block from 8206D394h-8206D3ACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206D3ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D3AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D3AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D3AC);
		  /* 8206D3ACh */ case    0:  		/* addi R1, R1, 320 */
		/* 8206D3ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x140);
		/* 8206D3ACh case    0:*/		return 0x8206D3B0;
		  /* 8206D3B0h */ case    1:  		/* b 147148 */
		/* 8206D3B0h case    1:*/		return 0x8209127C;
		/* 8206D3B0h case    1:*/		return 0x8206D3B4;
		  /* 8206D3B4h */ case    2:  		/* nop */
		/* 8206D3B4h case    2:*/		cpu::op::nop();
		/* 8206D3B4h case    2:*/		return 0x8206D3B8;
	}
	return 0x8206D3B8;
} // Block from 8206D3ACh-8206D3B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206D3B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D3B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D3B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D3B8);
		  /* 8206D3B8h */ case    0:  		/* mfspr R12, LR */
		/* 8206D3B8h case    0:*/		regs.R12 = regs.LR;
		/* 8206D3B8h case    0:*/		return 0x8206D3BC;
		  /* 8206D3BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206D3BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206D3BCh case    1:*/		return 0x8206D3C0;
		  /* 8206D3C0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8206D3C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8206D3C0h case    2:*/		return 0x8206D3C4;
		  /* 8206D3C4h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8206D3C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206D3C4h case    3:*/		return 0x8206D3C8;
		  /* 8206D3C8h */ case    4:  		/* mulli R11, R11, 9936 */
		/* 8206D3C8h case    4:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206D3C8h case    4:*/		return 0x8206D3CC;
		  /* 8206D3CCh */ case    5:  		/* add R11, R11, R3 */
		/* 8206D3CCh case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206D3CCh case    5:*/		return 0x8206D3D0;
		  /* 8206D3D0h */ case    6:  		/* addi R11, R11, 16 */
		/* 8206D3D0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206D3D0h case    6:*/		return 0x8206D3D4;
		  /* 8206D3D4h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 8206D3D4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D3D4h case    7:*/		return 0x8206D3D8;
		  /* 8206D3D8h */ case    8:  		/* lwz R10, <#[R10 + 19892]> */
		/* 8206D3D8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00004DB4) );
		/* 8206D3D8h case    8:*/		return 0x8206D3DC;
		  /* 8206D3DCh */ case    9:  		/* rlwinm. R10, R10, 30, 31, 31 */
		/* 8206D3DCh case    9:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R10,regs.R10);
		/* 8206D3DCh case    9:*/		return 0x8206D3E0;
		  /* 8206D3E0h */ case   10:  		/* bc 4, CR0_EQ, 36 */
		/* 8206D3E0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8206D404;  }
		/* 8206D3E0h case   10:*/		return 0x8206D3E4;
		  /* 8206D3E4h */ case   11:  		/* rlwimi R4, R5, 1, 27, 30 */
		/* 8206D3E4h case   11:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R4,regs.R5);
		/* 8206D3E4h case   11:*/		return 0x8206D3E8;
		  /* 8206D3E8h */ case   12:  		/* addi R5, R11, 80 */
		/* 8206D3E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x50);
		/* 8206D3E8h case   12:*/		return 0x8206D3EC;
		  /* 8206D3ECh */ case   13:  		/* rlwinm R10, R4, 0, 27, 31 */
		/* 8206D3ECh case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R4);
		/* 8206D3ECh case   13:*/		return 0x8206D3F0;
		  /* 8206D3F0h */ case   14:  		/* addi R4, R1, 80 */
		/* 8206D3F0h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206D3F0h case   14:*/		return 0x8206D3F4;
		  /* 8206D3F4h */ case   15:  		/* rlwimi R6, R10, 8, 0, 23 */
		/* 8206D3F4h case   15:*/		cpu::op::rlwimi<0,8,0,23>(regs,&regs.R6,regs.R10);
		/* 8206D3F4h case   15:*/		return 0x8206D3F8;
		  /* 8206D3F8h */ case   16:  		/* addi R3, R11, 280 */
		/* 8206D3F8h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x118);
		/* 8206D3F8h case   16:*/		return 0x8206D3FC;
		  /* 8206D3FCh */ case   17:  		/* stw R6, <#[R1 + 80]> */
		/* 8206D3FCh case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8206D3FCh case   17:*/		return 0x8206D400;
		  /* 8206D400h */ case   18:  		/* bl -2440 */
		/* 8206D400h case   18:*/		regs.LR = 0x8206D404; return 0x8206CA78;
		/* 8206D400h case   18:*/		return 0x8206D404;
	}
	return 0x8206D404;
} // Block from 8206D3B8h-8206D404h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206D404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D404);
		  /* 8206D404h */ case    0:  		/* addi R1, R1, 96 */
		/* 8206D404h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206D404h case    0:*/		return 0x8206D408;
		  /* 8206D408h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206D408h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206D408h case    1:*/		return 0x8206D40C;
		  /* 8206D40Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8206D40Ch case    2:*/		regs.LR = regs.R12;
		/* 8206D40Ch case    2:*/		return 0x8206D410;
		  /* 8206D410h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8206D410h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206D410h case    3:*/		return 0x8206D414;
	}
	return 0x8206D414;
} // Block from 8206D404h-8206D414h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206D414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D414);
		  /* 8206D414h */ case    0:  		/* nop */
		/* 8206D414h case    0:*/		cpu::op::nop();
		/* 8206D414h case    0:*/		return 0x8206D418;
	}
	return 0x8206D418;
} // Block from 8206D414h-8206D418h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206D418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D418);
		  /* 8206D418h */ case    0:  		/* mfspr R12, LR */
		/* 8206D418h case    0:*/		regs.R12 = regs.LR;
		/* 8206D418h case    0:*/		return 0x8206D41C;
		  /* 8206D41Ch */ case    1:  		/* bl 146988 */
		/* 8206D41Ch case    1:*/		regs.LR = 0x8206D420; return 0x82091248;
		/* 8206D41Ch case    1:*/		return 0x8206D420;
		  /* 8206D420h */ case    2:  		/* stwu R1, <#[R1 - 304]> */
		/* 8206D420h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFED0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFED0);
		/* 8206D420h case    2:*/		return 0x8206D424;
		  /* 8206D424h */ case    3:  		/* mr R31, R3 */
		/* 8206D424h case    3:*/		regs.R31 = regs.R3;
		/* 8206D424h case    3:*/		return 0x8206D428;
		  /* 8206D428h */ case    4:  		/* addi R27, R3, 368 */
		/* 8206D428h case    4:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R3,0x170);
		/* 8206D428h case    4:*/		return 0x8206D42C;
		  /* 8206D42Ch */ case    5:  		/* addi R26, R3, 10304 */
		/* 8206D42Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R3,0x2840);
		/* 8206D42Ch case    5:*/		return 0x8206D430;
		  /* 8206D430h */ case    6:  		/* li R28, 64 */
		/* 8206D430h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x40);
		/* 8206D430h case    6:*/		return 0x8206D434;
		  /* 8206D434h */ case    7:  		/* li R29, 0 */
		/* 8206D434h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8206D434h case    7:*/		return 0x8206D438;
		  /* 8206D438h */ case    8:  		/* li R25, 1 */
		/* 8206D438h case    8:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8206D438h case    8:*/		return 0x8206D43C;
		  /* 8206D43Ch */ case    9:  		/* subfic R30, R29, 63 */
		/* 8206D43Ch case    9:*/		cpu::op::subfic<0>(regs,&regs.R30,regs.R29,0x3F);
		/* 8206D43Ch case    9:*/		return 0x8206D440;
		  /* 8206D440h */ case   10:  		/* addi R7, R1, 84 */
		/* 8206D440h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x54);
		/* 8206D440h case   10:*/		return 0x8206D444;
		  /* 8206D444h */ case   11:  		/* rlwinm R24, R30, 2, 0, 29 */
		/* 8206D444h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R30);
		/* 8206D444h case   11:*/		return 0x8206D448;
		  /* 8206D448h */ case   12:  		/* addi R6, R1, 96 */
		/* 8206D448h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 8206D448h case   12:*/		return 0x8206D44C;
		  /* 8206D44Ch */ case   13:  		/* mr R5, R24 */
		/* 8206D44Ch case   13:*/		regs.R5 = regs.R24;
		/* 8206D44Ch case   13:*/		return 0x8206D450;
		  /* 8206D450h */ case   14:  		/* mr R4, R27 */
		/* 8206D450h case   14:*/		regs.R4 = regs.R27;
		/* 8206D450h case   14:*/		return 0x8206D454;
		  /* 8206D454h */ case   15:  		/* mr R3, R31 */
		/* 8206D454h case   15:*/		regs.R3 = regs.R31;
		/* 8206D454h case   15:*/		return 0x8206D458;
		  /* 8206D458h */ case   16:  		/* bl -12992 */
		/* 8206D458h case   16:*/		regs.LR = 0x8206D45C; return 0x8206A198;
		/* 8206D458h case   16:*/		return 0x8206D45C;
		  /* 8206D45Ch */ case   17:  		/* addi R7, R1, 80 */
		/* 8206D45Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 8206D45Ch case   17:*/		return 0x8206D460;
		  /* 8206D460h */ case   18:  		/* addi R6, R1, 160 */
		/* 8206D460h case   18:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xA0);
		/* 8206D460h case   18:*/		return 0x8206D464;
		  /* 8206D464h */ case   19:  		/* mr R5, R24 */
		/* 8206D464h case   19:*/		regs.R5 = regs.R24;
		/* 8206D464h case   19:*/		return 0x8206D468;
		  /* 8206D468h */ case   20:  		/* mr R4, R26 */
		/* 8206D468h case   20:*/		regs.R4 = regs.R26;
		/* 8206D468h case   20:*/		return 0x8206D46C;
		  /* 8206D46Ch */ case   21:  		/* mr R3, R31 */
		/* 8206D46Ch case   21:*/		regs.R3 = regs.R31;
		/* 8206D46Ch case   21:*/		return 0x8206D470;
		  /* 8206D470h */ case   22:  		/* bl -13016 */
		/* 8206D470h case   22:*/		regs.LR = 0x8206D474; return 0x8206A198;
		/* 8206D470h case   22:*/		return 0x8206D474;
		  /* 8206D474h */ case   23:  		/* lwz R3, <#[R1 + 84]> */
		/* 8206D474h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8206D474h case   23:*/		return 0x8206D478;
		  /* 8206D478h */ case   24:  		/* lwz R4, <#[R1 + 80]> */
		/* 8206D478h case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8206D478h case   24:*/		return 0x8206D47C;
		  /* 8206D47Ch */ case   25:  		/* or. R11, R4, R3 */
		/* 8206D47Ch case   25:*/		cpu::op::or<1>(regs,&regs.R11,regs.R4,regs.R3);
		/* 8206D47Ch case   25:*/		return 0x8206D480;
		  /* 8206D480h */ case   26:  		/* bc 12, CR0_EQ, 120 */
		/* 8206D480h case   26:*/		if ( regs.CR[0].eq ) { return 0x8206D4F8;  }
		/* 8206D480h case   26:*/		return 0x8206D484;
		  /* 8206D484h */ case   27:  		/* and. R5, R4, R3 */
		/* 8206D484h case   27:*/		cpu::op::and<1>(regs,&regs.R5,regs.R4,regs.R3);
		/* 8206D484h case   27:*/		return 0x8206D488;
		  /* 8206D488h */ case   28:  		/* bc 12, CR0_EQ, 100 */
		/* 8206D488h case   28:*/		if ( regs.CR[0].eq ) { return 0x8206D4EC;  }
		/* 8206D488h case   28:*/		return 0x8206D48C;
		  /* 8206D48Ch */ case   29:  		/* li R6, 0 */
		/* 8206D48Ch case   29:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206D48Ch case   29:*/		return 0x8206D490;
		  /* 8206D490h */ case   30:  		/* li R9, 0 */
		/* 8206D490h case   30:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8206D490h case   30:*/		return 0x8206D494;
		  /* 8206D494h */ case   31:  		/* slw R11, R25, R6 */
		/* 8206D494h case   31:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R25,regs.R6);
		/* 8206D494h case   31:*/		return 0x8206D498;
		  /* 8206D498h */ case   32:  		/* and. R11, R11, R5 */
		/* 8206D498h case   32:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8206D498h case   32:*/		return 0x8206D49C;
		  /* 8206D49Ch */ case   33:  		/* bc 12, CR0_EQ, 64 */
		/* 8206D49Ch case   33:*/		if ( regs.CR[0].eq ) { return 0x8206D4DC;  }
		/* 8206D49Ch case   33:*/		return 0x8206D4A0;
		  /* 8206D4A0h */ case   34:  		/* addi R11, R1, 96 */
		/* 8206D4A0h case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8206D4A0h case   34:*/		return 0x8206D4A4;
		  /* 8206D4A4h */ case   35:  		/* addi R10, R1, 160 */
		/* 8206D4A4h case   35:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xA0);
		/* 8206D4A4h case   35:*/		return 0x8206D4A8;
		  /* 8206D4A8h */ case   36:  		/* add R11, R9, R11 */
		/* 8206D4A8h case   36:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8206D4A8h case   36:*/		return 0x8206D4AC;
		  /* 8206D4ACh */ case   37:  		/* add R10, R9, R10 */
		/* 8206D4ACh case   37:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8206D4ACh case   37:*/		return 0x8206D4B0;
		  /* 8206D4B0h */ case   38:  		/* addi R8, R11, 16 */
		/* 8206D4B0h case   38:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x10);
		/* 8206D4B0h case   38:*/		return 0x8206D4B4;
		  /* 8206D4B4h */ case   39:  		/* lbz R7, <#[R11]> */
		/* 8206D4B4h case   39:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D4B4h case   39:*/		return 0x8206D4B8;
		  /* 8206D4B8h */ case   40:  		/* lbz R24, <#[R10]> */
		/* 8206D4B8h case   40:*/		cpu::mem::load8z( regs, &regs.R24, (uint32)(regs.R10 + 0x00000000) );
		/* 8206D4B8h case   40:*/		return 0x8206D4BC;
		  /* 8206D4BCh */ case   41:  		/* subf. R7, R24, R7 */
		/* 8206D4BCh case   41:*/		cpu::op::subf<1>(regs,&regs.R7,regs.R24,regs.R7);
		/* 8206D4BCh case   41:*/		return 0x8206D4C0;
		  /* 8206D4C0h */ case   42:  		/* bc 4, CR0_EQ, 20 */
		/* 8206D4C0h case   42:*/		if ( !regs.CR[0].eq ) { return 0x8206D4D4;  }
		/* 8206D4C0h case   42:*/		return 0x8206D4C4;
		  /* 8206D4C4h */ case   43:  		/* addi R11, R11, 1 */
		/* 8206D4C4h case   43:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206D4C4h case   43:*/		return 0x8206D4C8;
		  /* 8206D4C8h */ case   44:  		/* addi R10, R10, 1 */
		/* 8206D4C8h case   44:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8206D4C8h case   44:*/		return 0x8206D4CC;
		  /* 8206D4CCh */ case   45:  		/* cmpw CR6, R11, R8 */
		/* 8206D4CCh case   45:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8206D4CCh case   45:*/		return 0x8206D4D0;
		  /* 8206D4D0h */ case   46:  		/* bc 4, CR6_EQ, -28 */
		/* 8206D4D0h case   46:*/		if ( !regs.CR[6].eq ) { return 0x8206D4B4;  }
		/* 8206D4D0h case   46:*/		return 0x8206D4D4;
	}
	return 0x8206D4D4;
} // Block from 8206D418h-8206D4D4h (47 instructions)

//////////////////////////////////////////////////////
// Block at 8206D4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D4D4);
		  /* 8206D4D4h */ case    0:  		/* cmpwi CR0, R7, 0 */
		/* 8206D4D4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R7,0x00000000);
		/* 8206D4D4h case    0:*/		return 0x8206D4D8;
		  /* 8206D4D8h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 8206D4D8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8206D4EC;  }
		/* 8206D4D8h case    1:*/		return 0x8206D4DC;
	}
	return 0x8206D4DC;
} // Block from 8206D4D4h-8206D4DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206D4DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D4DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D4DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D4DC);
		  /* 8206D4DCh */ case    0:  		/* addi R9, R9, 16 */
		/* 8206D4DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x10);
		/* 8206D4DCh case    0:*/		return 0x8206D4E0;
		  /* 8206D4E0h */ case    1:  		/* addi R6, R6, 1 */
		/* 8206D4E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 8206D4E0h case    1:*/		return 0x8206D4E4;
		  /* 8206D4E4h */ case    2:  		/* cmplwi CR6, R9, 64 */
		/* 8206D4E4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000040);
		/* 8206D4E4h case    2:*/		return 0x8206D4E8;
		  /* 8206D4E8h */ case    3:  		/* bc 12, CR6_LT, -84 */
		/* 8206D4E8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8206D494;  }
		/* 8206D4E8h case    3:*/		return 0x8206D4EC;
	}
	return 0x8206D4EC;
} // Block from 8206D4DCh-8206D4ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206D4ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D4EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D4EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D4EC);
		  /* 8206D4ECh */ case    0:  		/* andc. R11, R4, R3 */
		/* 8206D4ECh case    0:*/		cpu::op::andc<1>(regs,&regs.R11,regs.R4,regs.R3);
		/* 8206D4ECh case    0:*/		return 0x8206D4F0;
		  /* 8206D4F0h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 8206D4F0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8206D504;  }
		/* 8206D4F0h case    1:*/		return 0x8206D4F4;
		  /* 8206D4F4h */ case    2:  		/* mr R28, R30 */
		/* 8206D4F4h case    2:*/		regs.R28 = regs.R30;
		/* 8206D4F4h case    2:*/		return 0x8206D4F8;
	}
	return 0x8206D4F8;
} // Block from 8206D4ECh-8206D4F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206D4F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D4F8);
		  /* 8206D4F8h */ case    0:  		/* addi R29, R29, 1 */
		/* 8206D4F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8206D4F8h case    0:*/		return 0x8206D4FC;
		  /* 8206D4FCh */ case    1:  		/* cmplwi CR6, R29, 64 */
		/* 8206D4FCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000040);
		/* 8206D4FCh case    1:*/		return 0x8206D500;
		  /* 8206D500h */ case    2:  		/* bc 12, CR6_LT, -196 */
		/* 8206D500h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206D43C;  }
		/* 8206D500h case    2:*/		return 0x8206D504;
	}
	return 0x8206D504;
} // Block from 8206D4F8h-8206D504h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206D504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D504);
		  /* 8206D504h */ case    0:  		/* subfic R29, R28, 64 */
		/* 8206D504h case    0:*/		cpu::op::subfic<0>(regs,&regs.R29,regs.R28,0x40);
		/* 8206D504h case    0:*/		return 0x8206D508;
		  /* 8206D508h */ case    1:  		/* stw R28, <#[R31 + 19936]> */
		/* 8206D508h case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00004DE0) );
		/* 8206D508h case    1:*/		return 0x8206D50C;
		  /* 8206D50Ch */ case    2:  		/* stw R25, <#[R31 + 19932]> */
		/* 8206D50Ch case    2:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00004DDC) );
		/* 8206D50Ch case    2:*/		return 0x8206D510;
		  /* 8206D510h */ case    3:  		/* addi R30, R31, 19940 */
		/* 8206D510h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x4DE4);
		/* 8206D510h case    3:*/		return 0x8206D514;
		  /* 8206D514h */ case    4:  		/* lwz R11, <#[R31 + 19948]> */
		/* 8206D514h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00004DEC) );
		/* 8206D514h case    4:*/		return 0x8206D518;
		  /* 8206D518h */ case    5:  		/* cmplw CR6, R29, R11 */
		/* 8206D518h case    5:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8206D518h case    5:*/		return 0x8206D51C;
		  /* 8206D51Ch */ case    6:  		/* bc 4, CR6_GT, 20 */
		/* 8206D51Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x8206D530;  }
		/* 8206D51Ch case    6:*/		return 0x8206D520;
		  /* 8206D520h */ case    7:  		/* addi R5, R31, 19900 */
		/* 8206D520h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x4DBC);
		/* 8206D520h case    7:*/		return 0x8206D524;
		  /* 8206D524h */ case    8:  		/* mr R4, R29 */
		/* 8206D524h case    8:*/		regs.R4 = regs.R29;
		/* 8206D524h case    8:*/		return 0x8206D528;
		  /* 8206D528h */ case    9:  		/* mr R3, R30 */
		/* 8206D528h case    9:*/		regs.R3 = regs.R30;
		/* 8206D528h case    9:*/		return 0x8206D52C;
		  /* 8206D52Ch */ case   10:  		/* bl -11788 */
		/* 8206D52Ch case   10:*/		regs.LR = 0x8206D530; return 0x8206A720;
		/* 8206D52Ch case   10:*/		return 0x8206D530;
	}
	return 0x8206D530;
} // Block from 8206D504h-8206D530h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206D530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D530);
		  /* 8206D530h */ case    0:  		/* stw R29, <#[R30 + 4]> */
		/* 8206D530h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000004) );
		/* 8206D530h case    0:*/		return 0x8206D534;
		  /* 8206D534h */ case    1:  		/* addi R1, R1, 304 */
		/* 8206D534h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x130);
		/* 8206D534h case    1:*/		return 0x8206D538;
		  /* 8206D538h */ case    2:  		/* b 146784 */
		/* 8206D538h case    2:*/		return 0x82091298;
		/* 8206D538h case    2:*/		return 0x8206D53C;
		  /* 8206D53Ch */ case    3:  		/* nop */
		/* 8206D53Ch case    3:*/		cpu::op::nop();
		/* 8206D53Ch case    3:*/		return 0x8206D540;
		  /* 8206D540h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8206D540h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206D540h case    4:*/		return 0x8206D544;
		  /* 8206D544h */ case    5:  		/* mulli R11, R11, 9936 */
		/* 8206D544h case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206D544h case    5:*/		return 0x8206D548;
		  /* 8206D548h */ case    6:  		/* add R11, R11, R3 */
		/* 8206D548h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206D548h case    6:*/		return 0x8206D54C;
		  /* 8206D54Ch */ case    7:  		/* addi R3, R11, 16 */
		/* 8206D54Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206D54Ch case    7:*/		return 0x8206D550;
		  /* 8206D550h */ case    8:  		/* b -9232 */
		/* 8206D550h case    8:*/		return 0x8206B140;
		/* 8206D550h case    8:*/		return 0x8206D554;
		  /* 8206D554h */ case    9:  		/* nop */
		/* 8206D554h case    9:*/		cpu::op::nop();
		/* 8206D554h case    9:*/		return 0x8206D558;
		  /* 8206D558h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 8206D558h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206D558h case   10:*/		return 0x8206D55C;
		  /* 8206D55Ch */ case   11:  		/* mulli R11, R11, 9936 */
		/* 8206D55Ch case   11:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206D55Ch case   11:*/		return 0x8206D560;
		  /* 8206D560h */ case   12:  		/* add R11, R11, R3 */
		/* 8206D560h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206D560h case   12:*/		return 0x8206D564;
		  /* 8206D564h */ case   13:  		/* addi R3, R11, 16 */
		/* 8206D564h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206D564h case   13:*/		return 0x8206D568;
		  /* 8206D568h */ case   14:  		/* b -2440 */
		/* 8206D568h case   14:*/		return 0x8206CBE0;
		/* 8206D568h case   14:*/		return 0x8206D56C;
		  /* 8206D56Ch */ case   15:  		/* nop */
		/* 8206D56Ch case   15:*/		cpu::op::nop();
		/* 8206D56Ch case   15:*/		return 0x8206D570;
		  /* 8206D570h */ case   16:  		/* b -440 */
		/* 8206D570h case   16:*/		return 0x8206D3B8;
		/* 8206D570h case   16:*/		return 0x8206D574;
		  /* 8206D574h */ case   17:  		/* nop */
		/* 8206D574h case   17:*/		cpu::op::nop();
		/* 8206D574h case   17:*/		return 0x8206D578;
	}
	return 0x8206D578;
} // Block from 8206D530h-8206D578h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206D578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D578);
		  /* 8206D578h */ case    0:  		/* mfspr R12, LR */
		/* 8206D578h case    0:*/		regs.R12 = regs.LR;
		/* 8206D578h case    0:*/		return 0x8206D57C;
		  /* 8206D57Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206D57Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206D57Ch case    1:*/		return 0x8206D580;
		  /* 8206D580h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8206D580h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206D580h case    2:*/		return 0x8206D584;
		  /* 8206D584h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8206D584h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206D584h case    3:*/		return 0x8206D588;
		  /* 8206D588h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206D588h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206D588h case    4:*/		return 0x8206D58C;
		  /* 8206D58Ch */ case    5:  		/* mr R31, R3 */
		/* 8206D58Ch case    5:*/		regs.R31 = regs.R3;
		/* 8206D58Ch case    5:*/		return 0x8206D590;
		  /* 8206D590h */ case    6:  		/* addi R11, R3, 19888 */
		/* 8206D590h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x4DB0);
		/* 8206D590h case    6:*/		return 0x8206D594;
		  /* 8206D594h */ case    7:  		/* mfmsr R9, MSR */
		/* 8206D594h case    7:*/		regs.R9 = regs.MSR;
		/* 8206D594h case    7:*/		return 0x8206D598;
		  /* 8206D598h */ case    8:  		/* mtmsrd MSR, R13 */
		/* 8206D598h case    8:*/		regs.MSR = regs.R13;
		/* 8206D598h case    8:*/		return 0x8206D59C;
		  /* 8206D59Ch */ case    9:  		/* lwarx R10, <#[R11]> */
		/* 8206D59Ch case    9:*/		cpu::mem::lwarx( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D59Ch case    9:*/		return 0x8206D5A0;
		  /* 8206D5A0h */ case   10:  		/* addi R10, R10, -1 */
		/* 8206D5A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8206D5A0h case   10:*/		return 0x8206D5A4;
		  /* 8206D5A4h */ case   11:  		/* stwcx. R10, <#[R11]> */
		/* 8206D5A4h case   11:*/		cpu::mem::stwcx( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D5A4h case   11:*/		return 0x8206D5A8;
		  /* 8206D5A8h */ case   12:  		/* mtmsrd MSR, R9 */
		/* 8206D5A8h case   12:*/		regs.MSR = regs.R9;
		/* 8206D5A8h case   12:*/		return 0x8206D5AC;
		  /* 8206D5ACh */ case   13:  		/* bc 4, CR0_EQ, -24 */
		/* 8206D5ACh case   13:*/		if ( !regs.CR[0].eq ) { return 0x8206D594;  }
		/* 8206D5ACh case   13:*/		return 0x8206D5B0;
		  /* 8206D5B0h */ case   14:  		/* mr R30, R10 */
		/* 8206D5B0h case   14:*/		regs.R30 = regs.R10;
		/* 8206D5B0h case   14:*/		return 0x8206D5B4;
		  /* 8206D5B4h */ case   15:  		/* cmpwi CR6, R10, 0 */
		/* 8206D5B4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8206D5B4h case   15:*/		return 0x8206D5B8;
		  /* 8206D5B8h */ case   16:  		/* bc 4, CR6_EQ, 24 */
		/* 8206D5B8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8206D5D0;  }
		/* 8206D5B8h case   16:*/		return 0x8206D5BC;
		  /* 8206D5BCh */ case   17:  		/* mr R3, R31 */
		/* 8206D5BCh case   17:*/		regs.R3 = regs.R31;
		/* 8206D5BCh case   17:*/		return 0x8206D5C0;
		  /* 8206D5C0h */ case   18:  		/* bl -3856 */
		/* 8206D5C0h case   18:*/		regs.LR = 0x8206D5C4; return 0x8206C6B0;
		/* 8206D5C0h case   18:*/		return 0x8206D5C4;
		  /* 8206D5C4h */ case   19:  		/* lis R4, 9344 */
		/* 8206D5C4h case   19:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206D5C4h case   19:*/		return 0x8206D5C8;
		  /* 8206D5C8h */ case   20:  		/* mr R3, R31 */
		/* 8206D5C8h case   20:*/		regs.R3 = regs.R31;
		/* 8206D5C8h case   20:*/		return 0x8206D5CC;
		  /* 8206D5CCh */ case   21:  		/* bl 109932 */
		/* 8206D5CCh case   21:*/		regs.LR = 0x8206D5D0; return 0x82088338;
		/* 8206D5CCh case   21:*/		return 0x8206D5D0;
	}
	return 0x8206D5D0;
} // Block from 8206D578h-8206D5D0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8206D5D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D5D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D5D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D5D0);
		  /* 8206D5D0h */ case    0:  		/* mr R3, R30 */
		/* 8206D5D0h case    0:*/		regs.R3 = regs.R30;
		/* 8206D5D0h case    0:*/		return 0x8206D5D4;
		  /* 8206D5D4h */ case    1:  		/* addi R1, R1, 112 */
		/* 8206D5D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206D5D4h case    1:*/		return 0x8206D5D8;
		  /* 8206D5D8h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206D5D8h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206D5D8h case    2:*/		return 0x8206D5DC;
		  /* 8206D5DCh */ case    3:  		/* mtspr LR, R12 */
		/* 8206D5DCh case    3:*/		regs.LR = regs.R12;
		/* 8206D5DCh case    3:*/		return 0x8206D5E0;
		  /* 8206D5E0h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 8206D5E0h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206D5E0h case    4:*/		return 0x8206D5E4;
		  /* 8206D5E4h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8206D5E4h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206D5E4h case    5:*/		return 0x8206D5E8;
		  /* 8206D5E8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8206D5E8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206D5E8h case    6:*/		return 0x8206D5EC;
	}
	return 0x8206D5EC;
} // Block from 8206D5D0h-8206D5ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206D5ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D5EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D5EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D5EC);
		  /* 8206D5ECh */ case    0:  		/* nop */
		/* 8206D5ECh case    0:*/		cpu::op::nop();
		/* 8206D5ECh case    0:*/		return 0x8206D5F0;
	}
	return 0x8206D5F0;
} // Block from 8206D5ECh-8206D5F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206D5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D5F0);
		  /* 8206D5F0h */ case    0:  		/* mfspr R12, LR */
		/* 8206D5F0h case    0:*/		regs.R12 = regs.LR;
		/* 8206D5F0h case    0:*/		return 0x8206D5F4;
		  /* 8206D5F4h */ case    1:  		/* bl 146532 */
		/* 8206D5F4h case    1:*/		regs.LR = 0x8206D5F8; return 0x82091258;
		/* 8206D5F4h case    1:*/		return 0x8206D5F8;
		  /* 8206D5F8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206D5F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206D5F8h case    2:*/		return 0x8206D5FC;
		  /* 8206D5FCh */ case    3:  		/* mr R31, R3 */
		/* 8206D5FCh case    3:*/		regs.R31 = regs.R3;
		/* 8206D5FCh case    3:*/		return 0x8206D600;
		  /* 8206D600h */ case    4:  		/* mr R28, R4 */
		/* 8206D600h case    4:*/		regs.R28 = regs.R4;
		/* 8206D600h case    4:*/		return 0x8206D604;
		  /* 8206D604h */ case    5:  		/* bl -6404 */
		/* 8206D604h case    5:*/		regs.LR = 0x8206D608; return 0x8206BD00;
		/* 8206D604h case    5:*/		return 0x8206D608;
		  /* 8206D608h */ case    6:  		/* addi R30, R31, 16 */
		/* 8206D608h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x10);
		/* 8206D608h case    6:*/		return 0x8206D60C;
		  /* 8206D60Ch */ case    7:  		/* stw R28, <#[R31 + 19892]> */
		/* 8206D60Ch case    7:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00004DB4) );
		/* 8206D60Ch case    7:*/		return 0x8206D610;
		  /* 8206D610h */ case    8:  		/* li R29, 2 */
		/* 8206D610h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x2);
		/* 8206D610h case    8:*/		return 0x8206D614;
		  /* 8206D614h */ case    9:  		/* mr R4, R31 */
		/* 8206D614h case    9:*/		regs.R4 = regs.R31;
		/* 8206D614h case    9:*/		return 0x8206D618;
		  /* 8206D618h */ case   10:  		/* mr R3, R30 */
		/* 8206D618h case   10:*/		regs.R3 = regs.R30;
		/* 8206D618h case   10:*/		return 0x8206D61C;
		  /* 8206D61Ch */ case   11:  		/* bl -2876 */
		/* 8206D61Ch case   11:*/		regs.LR = 0x8206D620; return 0x8206CAE0;
		/* 8206D61Ch case   11:*/		return 0x8206D620;
		  /* 8206D620h */ case   12:  		/* mr R4, R31 */
		/* 8206D620h case   12:*/		regs.R4 = regs.R31;
		/* 8206D620h case   12:*/		return 0x8206D624;
		  /* 8206D624h */ case   13:  		/* addi R3, R30, 352 */
		/* 8206D624h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x160);
		/* 8206D624h case   13:*/		return 0x8206D628;
		  /* 8206D628h */ case   14:  		/* bl -16464 */
		/* 8206D628h case   14:*/		regs.LR = 0x8206D62C; return 0x820695D8;
		/* 8206D628h case   14:*/		return 0x8206D62C;
		  /* 8206D62Ch */ case   15:  		/* addic. R29, R29, -1 */
		/* 8206D62Ch case   15:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 8206D62Ch case   15:*/		return 0x8206D630;
		  /* 8206D630h */ case   16:  		/* addi R30, R30, 9936 */
		/* 8206D630h case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x26D0);
		/* 8206D630h case   16:*/		return 0x8206D634;
		  /* 8206D634h */ case   17:  		/* bc 4, CR0_EQ, -32 */
		/* 8206D634h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8206D614;  }
		/* 8206D634h case   17:*/		return 0x8206D638;
		  /* 8206D638h */ case   18:  		/* li R11, 0 */
		/* 8206D638h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206D638h case   18:*/		return 0x8206D63C;
		  /* 8206D63Ch */ case   19:  		/* li R10, -1 */
		/* 8206D63Ch case   19:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8206D63Ch case   19:*/		return 0x8206D640;
		  /* 8206D640h */ case   20:  		/* stw R11, <#[R31 + 19912]> */
		/* 8206D640h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00004DC8) );
		/* 8206D640h case   20:*/		return 0x8206D644;
		  /* 8206D644h */ case   21:  		/* lwz R9, <#[R31 + 19892]> */
		/* 8206D644h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00004DB4) );
		/* 8206D644h case   21:*/		return 0x8206D648;
		  /* 8206D648h */ case   22:  		/* rlwinm R9, R9, 26, 31, 31 */
		/* 8206D648h case   22:*/		cpu::op::rlwinm<0,26,31,31>(regs,&regs.R9,regs.R9);
		/* 8206D648h case   22:*/		return 0x8206D64C;
		  /* 8206D64Ch */ case   23:  		/* subfic R9, R9, 0 */
		/* 8206D64Ch case   23:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R9,0x0);
		/* 8206D64Ch case   23:*/		return 0x8206D650;
		  /* 8206D650h */ case   24:  		/* stw R11, <#[R31 + 19924]> */
		/* 8206D650h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00004DD4) );
		/* 8206D650h case   24:*/		return 0x8206D654;
		  /* 8206D654h */ case   25:  		/* stw R11, <#[R31 + 19896]> */
		/* 8206D654h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00004DB8) );
		/* 8206D654h case   25:*/		return 0x8206D658;
		  /* 8206D658h */ case   26:  		/* subfe R11, R9, R9 */
		/* 8206D658h case   26:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R9);
		/* 8206D658h case   26:*/		return 0x8206D65C;
		  /* 8206D65Ch */ case   27:  		/* and R11, R11, R10 */
		/* 8206D65Ch case   27:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206D65Ch case   27:*/		return 0x8206D660;
	}
	return 0x8206D660;
} // Block from 8206D5F0h-8206D660h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8206D660h
// Function '?LockResource@D3D@@YAPAXPAUD3DResource@@_KW4_D3DBLOCKTYPE@@KKKKKKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D660);
		  /* 8206D660h */ case    0:  		/* stw R11, <#[R31]> */
		/* 8206D660h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206D660h case    0:*/		return 0x8206D664;
		  /* 8206D664h */ case    1:  		/* addi R1, R1, 128 */
		/* 8206D664h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206D664h case    1:*/		return 0x8206D668;
		  /* 8206D668h */ case    2:  		/* b 146496 */
		/* 8206D668h case    2:*/		return 0x820912A8;
		/* 8206D668h case    2:*/		return 0x8206D66C;
		  /* 8206D66Ch */ case    3:  		/* nop */
		/* 8206D66Ch case    3:*/		cpu::op::nop();
		/* 8206D66Ch case    3:*/		return 0x8206D670;
	}
	return 0x8206D670;
} // Block from 8206D660h-8206D670h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206D670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D670);
		  /* 8206D670h */ case    0:  		/* mfspr R12, LR */
		/* 8206D670h case    0:*/		regs.R12 = regs.LR;
		/* 8206D670h case    0:*/		return 0x8206D674;
		  /* 8206D674h */ case    1:  		/* bl 146400 */
		/* 8206D674h case    1:*/		regs.LR = 0x8206D678; return 0x82091254;
		/* 8206D674h case    1:*/		return 0x8206D678;
		  /* 8206D678h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206D678h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206D678h case    2:*/		return 0x8206D67C;
		  /* 8206D67Ch */ case    3:  		/* addi R11, R5, 3 */
		/* 8206D67Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x3);
		/* 8206D67Ch case    3:*/		return 0x8206D680;
		  /* 8206D680h */ case    4:  		/* lwz R10, <#[R3 + 19916]> */
		/* 8206D680h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00004DCC) );
		/* 8206D680h case    4:*/		return 0x8206D684;
		  /* 8206D684h */ case    5:  		/* mr R30, R3 */
		/* 8206D684h case    5:*/		regs.R30 = regs.R3;
		/* 8206D684h case    5:*/		return 0x8206D688;
		  /* 8206D688h */ case    6:  		/* rlwinm R29, R11, 30, 2, 31 */
		/* 8206D688h case    6:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R29,regs.R11);
		/* 8206D688h case    6:*/		return 0x8206D68C;
		  /* 8206D68Ch */ case    7:  		/* mr R27, R4 */
		/* 8206D68Ch case    7:*/		regs.R27 = regs.R4;
		/* 8206D68Ch case    7:*/		return 0x8206D690;
		  /* 8206D690h */ case    8:  		/* mr R28, R5 */
		/* 8206D690h case    8:*/		regs.R28 = regs.R5;
		/* 8206D690h case    8:*/		return 0x8206D694;
		  /* 8206D694h */ case    9:  		/* addi R31, R3, 19908 */
		/* 8206D694h case    9:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4DC4);
		/* 8206D694h case    9:*/		return 0x8206D698;
		  /* 8206D698h */ case   10:  		/* cmplw CR6, R29, R10 */
		/* 8206D698h case   10:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 8206D698h case   10:*/		return 0x8206D69C;
		  /* 8206D69Ch */ case   11:  		/* bc 4, CR6_GT, 20 */
		/* 8206D69Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x8206D6B0;  }
		/* 8206D69Ch case   11:*/		return 0x8206D6A0;
		  /* 8206D6A0h */ case   12:  		/* addi R5, R3, 19900 */
		/* 8206D6A0h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R3,0x4DBC);
		/* 8206D6A0h case   12:*/		return 0x8206D6A4;
		  /* 8206D6A4h */ case   13:  		/* mr R4, R29 */
		/* 8206D6A4h case   13:*/		regs.R4 = regs.R29;
		/* 8206D6A4h case   13:*/		return 0x8206D6A8;
		  /* 8206D6A8h */ case   14:  		/* mr R3, R31 */
		/* 8206D6A8h case   14:*/		regs.R3 = regs.R31;
		/* 8206D6A8h case   14:*/		return 0x8206D6AC;
		  /* 8206D6ACh */ case   15:  		/* bl -12172 */
		/* 8206D6ACh case   15:*/		regs.LR = 0x8206D6B0; return 0x8206A720;
		/* 8206D6ACh case   15:*/		return 0x8206D6B0;
	}
	return 0x8206D6B0;
} // Block from 8206D670h-8206D6B0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206D6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D6B0);
		  /* 8206D6B0h */ case    0:  		/* stw R29, <#[R31 + 4]> */
		/* 8206D6B0h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 8206D6B0h case    0:*/		return 0x8206D6B4;
		  /* 8206D6B4h */ case    1:  		/* lwz R11, <#[R30 + 19900]> */
		/* 8206D6B4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00004DBC) );
		/* 8206D6B4h case    1:*/		return 0x8206D6B8;
		  /* 8206D6B8h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8206D6B8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206D6B8h case    2:*/		return 0x8206D6BC;
		  /* 8206D6BCh */ case    3:  		/* bc 12, CR6_LT, 20 */
		/* 8206D6BCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8206D6D0;  }
		/* 8206D6BCh case    3:*/		return 0x8206D6C0;
		  /* 8206D6C0h */ case    4:  		/* mr R5, R28 */
		/* 8206D6C0h case    4:*/		regs.R5 = regs.R28;
		/* 8206D6C0h case    4:*/		return 0x8206D6C4;
		  /* 8206D6C4h */ case    5:  		/* lwz R3, <#[R31]> */
		/* 8206D6C4h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8206D6C4h case    5:*/		return 0x8206D6C8;
		  /* 8206D6C8h */ case    6:  		/* mr R4, R27 */
		/* 8206D6C8h case    6:*/		regs.R4 = regs.R27;
		/* 8206D6C8h case    6:*/		return 0x8206D6CC;
		  /* 8206D6CCh */ case    7:  		/* bl 148196 */
		/* 8206D6CCh case    7:*/		regs.LR = 0x8206D6D0; return 0x820919B0;
		/* 8206D6CCh case    7:*/		return 0x8206D6D0;
	}
	return 0x8206D6D0;
} // Block from 8206D6B0h-8206D6D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206D6D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D6D0);
		  /* 8206D6D0h */ case    0:  		/* addi R1, R1, 128 */
		/* 8206D6D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206D6D0h case    0:*/		return 0x8206D6D4;
		  /* 8206D6D4h */ case    1:  		/* b 146384 */
		/* 8206D6D4h case    1:*/		return 0x820912A4;
		/* 8206D6D4h case    1:*/		return 0x8206D6D8;
	}
	return 0x8206D6D8;
} // Block from 8206D6D0h-8206D6D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206D6D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D6D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D6D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D6D8);
		  /* 8206D6D8h */ case    0:  		/* mfspr R12, LR */
		/* 8206D6D8h case    0:*/		regs.R12 = regs.LR;
		/* 8206D6D8h case    0:*/		return 0x8206D6DC;
		  /* 8206D6DCh */ case    1:  		/* bl 146292 */
		/* 8206D6DCh case    1:*/		regs.LR = 0x8206D6E0; return 0x82091250;
		/* 8206D6DCh case    1:*/		return 0x8206D6E0;
		  /* 8206D6E0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8206D6E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8206D6E0h case    2:*/		return 0x8206D6E4;
		  /* 8206D6E4h */ case    3:  		/* mr R28, R5 */
		/* 8206D6E4h case    3:*/		regs.R28 = regs.R5;
		/* 8206D6E4h case    3:*/		return 0x8206D6E8;
		  /* 8206D6E8h */ case    4:  		/* lis R11, -32256 */
		/* 8206D6E8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8206D6E8h case    4:*/		return 0x8206D6EC;
		  /* 8206D6ECh */ case    5:  		/* mr R27, R3 */
		/* 8206D6ECh case    5:*/		regs.R27 = regs.R3;
		/* 8206D6ECh case    5:*/		return 0x8206D6F0;
		  /* 8206D6F0h */ case    6:  		/* mr R30, R4 */
		/* 8206D6F0h case    6:*/		regs.R30 = regs.R4;
		/* 8206D6F0h case    6:*/		return 0x8206D6F4;
		  /* 8206D6F4h */ case    7:  		/* li R5, 14 */
		/* 8206D6F4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0xE);
		/* 8206D6F4h case    7:*/		return 0x8206D6F8;
		  /* 8206D6F8h */ case    8:  		/* addi R4, R11, 3588 */
		/* 8206D6F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xE04);
		/* 8206D6F8h case    8:*/		return 0x8206D6FC;
		  /* 8206D6FCh */ case    9:  		/* mr R3, R28 */
		/* 8206D6FCh case    9:*/		regs.R3 = regs.R28;
		/* 8206D6FCh case    9:*/		return 0x8206D700;
		  /* 8206D700h */ case   10:  		/* bl 150640 */
		/* 8206D700h case   10:*/		regs.LR = 0x8206D704; return 0x82092370;
		/* 8206D700h case   10:*/		return 0x8206D704;
		  /* 8206D704h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 8206D704h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206D704h case   11:*/		return 0x8206D708;
		  /* 8206D708h */ case   12:  		/* bc 4, CR0_EQ, 8 */
		/* 8206D708h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8206D710;  }
		/* 8206D708h case   12:*/		return 0x8206D70C;
		  /* 8206D70Ch */ case   13:  		/* addi R28, R28, 10 */
		/* 8206D70Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0xA);
		/* 8206D70Ch case   13:*/		return 0x8206D710;
	}
	return 0x8206D710;
} // Block from 8206D6D8h-8206D710h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206D710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D710);
		  /* 8206D710h */ case    0:  		/* mr R11, R28 */
		/* 8206D710h case    0:*/		regs.R11 = regs.R28;
		/* 8206D710h case    0:*/		return 0x8206D714;
		  /* 8206D714h */ case    1:  		/* lbz R10, <#[R11]> */
		/* 8206D714h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D714h case    1:*/		return 0x8206D718;
		  /* 8206D718h */ case    2:  		/* addi R11, R11, 1 */
		/* 8206D718h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206D718h case    2:*/		return 0x8206D71C;
		  /* 8206D71Ch */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 8206D71Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8206D71Ch case    3:*/		return 0x8206D720;
		  /* 8206D720h */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 8206D720h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8206D714;  }
		/* 8206D720h case    4:*/		return 0x8206D724;
		  /* 8206D724h */ case    5:  		/* subf R11, R28, R11 */
		/* 8206D724h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 8206D724h case    5:*/		return 0x8206D728;
		  /* 8206D728h */ case    6:  		/* lwz R10, <#[R27 + 19928]> */
		/* 8206D728h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00004DD8) );
		/* 8206D728h case    6:*/		return 0x8206D72C;
		  /* 8206D72Ch */ case    7:  		/* addi R9, R1, 80 */
		/* 8206D72Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 8206D72Ch case    7:*/		return 0x8206D730;
		  /* 8206D730h */ case    8:  		/* addi R11, R11, -1 */
		/* 8206D730h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8206D730h case    8:*/		return 0x8206D734;
		  /* 8206D734h */ case    9:  		/* li R26, 0 */
		/* 8206D734h case    9:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8206D734h case    9:*/		return 0x8206D738;
		  /* 8206D738h */ case   10:  		/* rlwinm R29, R11, 0, 0, 31 */
		/* 8206D738h case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R29,regs.R11);
		/* 8206D738h case   10:*/		return 0x8206D73C;
		  /* 8206D73Ch */ case   11:  		/* addi R31, R27, 19920 */
		/* 8206D73Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R27,0x4DD0);
		/* 8206D73Ch case   11:*/		return 0x8206D740;
		  /* 8206D740h */ case   12:  		/* addi R11, R29, 3 */
		/* 8206D740h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x3);
		/* 8206D740h case   12:*/		return 0x8206D744;
		  /* 8206D744h */ case   13:  		/* std R26, <#[R9]> */
		/* 8206D744h case   13:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R9 + 0x00000000) );
		/* 8206D744h case   13:*/		return 0x8206D748;
		  /* 8206D748h */ case   14:  		/* stw R30, <#[R1 + 80]> */
		/* 8206D748h case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8206D748h case   14:*/		return 0x8206D74C;
		  /* 8206D74Ch */ case   15:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 8206D74Ch case   15:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 8206D74Ch case   15:*/		return 0x8206D750;
		  /* 8206D750h */ case   16:  		/* stw R29, <#[R1 + 84]> */
		/* 8206D750h case   16:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 8206D750h case   16:*/		return 0x8206D754;
		  /* 8206D754h */ case   17:  		/* addi R30, R11, 2 */
		/* 8206D754h case   17:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x2);
		/* 8206D754h case   17:*/		return 0x8206D758;
		  /* 8206D758h */ case   18:  		/* cmplw CR6, R30, R10 */
		/* 8206D758h case   18:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 8206D758h case   18:*/		return 0x8206D75C;
		  /* 8206D75Ch */ case   19:  		/* bc 4, CR6_GT, 20 */
		/* 8206D75Ch case   19:*/		if ( !regs.CR[6].gt ) { return 0x8206D770;  }
		/* 8206D75Ch case   19:*/		return 0x8206D760;
		  /* 8206D760h */ case   20:  		/* addi R5, R27, 19900 */
		/* 8206D760h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R27,0x4DBC);
		/* 8206D760h case   20:*/		return 0x8206D764;
		  /* 8206D764h */ case   21:  		/* mr R4, R30 */
		/* 8206D764h case   21:*/		regs.R4 = regs.R30;
		/* 8206D764h case   21:*/		return 0x8206D768;
		  /* 8206D768h */ case   22:  		/* mr R3, R31 */
		/* 8206D768h case   22:*/		regs.R3 = regs.R31;
		/* 8206D768h case   22:*/		return 0x8206D76C;
		  /* 8206D76Ch */ case   23:  		/* bl -12364 */
		/* 8206D76Ch case   23:*/		regs.LR = 0x8206D770; return 0x8206A720;
		/* 8206D76Ch case   23:*/		return 0x8206D770;
	}
	return 0x8206D770;
} // Block from 8206D710h-8206D770h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8206D770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D770);
		  /* 8206D770h */ case    0:  		/* stw R30, <#[R31 + 4]> */
		/* 8206D770h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 8206D770h case    0:*/		return 0x8206D774;
		  /* 8206D774h */ case    1:  		/* lwz R11, <#[R27 + 19900]> */
		/* 8206D774h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00004DBC) );
		/* 8206D774h case    1:*/		return 0x8206D778;
		  /* 8206D778h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8206D778h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206D778h case    2:*/		return 0x8206D77C;
		  /* 8206D77Ch */ case    3:  		/* bc 12, CR6_LT, 44 */
		/* 8206D77Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8206D7A8;  }
		/* 8206D77Ch case    3:*/		return 0x8206D780;
		  /* 8206D780h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 8206D780h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206D780h case    4:*/		return 0x8206D784;
		  /* 8206D784h */ case    5:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 8206D784h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 8206D784h case    5:*/		return 0x8206D788;
		  /* 8206D788h */ case    6:  		/* ld R9, <#[R1 + 80]> */
		/* 8206D788h case    6:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8206D788h case    6:*/		return 0x8206D78C;
		  /* 8206D78Ch */ case    7:  		/* mr R5, R29 */
		/* 8206D78Ch case    7:*/		regs.R5 = regs.R29;
		/* 8206D78Ch case    7:*/		return 0x8206D790;
		  /* 8206D790h */ case    8:  		/* add R10, R10, R11 */
		/* 8206D790h case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8206D790h case    8:*/		return 0x8206D794;
		  /* 8206D794h */ case    9:  		/* mr R4, R28 */
		/* 8206D794h case    9:*/		regs.R4 = regs.R28;
		/* 8206D794h case    9:*/		return 0x8206D798;
		  /* 8206D798h */ case   10:  		/* addi R3, R11, 8 */
		/* 8206D798h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x8);
		/* 8206D798h case   10:*/		return 0x8206D79C;
		  /* 8206D79Ch */ case   11:  		/* stw R26, <#[R10 - 4]> */
		/* 8206D79Ch case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R10 + 0xFFFFFFFC) );
		/* 8206D79Ch case   11:*/		return 0x8206D7A0;
		  /* 8206D7A0h */ case   12:  		/* std R9, <#[R11]> */
		/* 8206D7A0h case   12:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8206D7A0h case   12:*/		return 0x8206D7A4;
		  /* 8206D7A4h */ case   13:  		/* bl 147980 */
		/* 8206D7A4h case   13:*/		regs.LR = 0x8206D7A8; return 0x820919B0;
		/* 8206D7A4h case   13:*/		return 0x8206D7A8;
	}
	return 0x8206D7A8;
} // Block from 8206D770h-8206D7A8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206D7A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D7A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D7A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D7A8);
		  /* 8206D7A8h */ case    0:  		/* addi R1, R1, 144 */
		/* 8206D7A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8206D7A8h case    0:*/		return 0x8206D7AC;
		  /* 8206D7ACh */ case    1:  		/* b 146164 */
		/* 8206D7ACh case    1:*/		return 0x820912A0;
		/* 8206D7ACh case    1:*/		return 0x8206D7B0;
	}
	return 0x8206D7B0;
} // Block from 8206D7A8h-8206D7B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206D7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D7B0);
		  /* 8206D7B0h */ case    0:  		/* mfspr R12, LR */
		/* 8206D7B0h case    0:*/		regs.R12 = regs.LR;
		/* 8206D7B0h case    0:*/		return 0x8206D7B4;
		  /* 8206D7B4h */ case    1:  		/* bl 146084 */
		/* 8206D7B4h case    1:*/		regs.LR = 0x8206D7B8; return 0x82091258;
		/* 8206D7B4h case    1:*/		return 0x8206D7B8;
		  /* 8206D7B8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8206D7B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8206D7B8h case    2:*/		return 0x8206D7BC;
		  /* 8206D7BCh */ case    3:  		/* li R11, 0 */
		/* 8206D7BCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206D7BCh case    3:*/		return 0x8206D7C0;
		  /* 8206D7C0h */ case    4:  		/* lwz R10, <#[R3 + 19900]> */
		/* 8206D7C0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00004DBC) );
		/* 8206D7C0h case    4:*/		return 0x8206D7C4;
		  /* 8206D7C4h */ case    5:  		/* mr R30, R4 */
		/* 8206D7C4h case    5:*/		regs.R30 = regs.R4;
		/* 8206D7C4h case    5:*/		return 0x8206D7C8;
		  /* 8206D7C8h */ case    6:  		/* mr R28, R5 */
		/* 8206D7C8h case    6:*/		regs.R28 = regs.R5;
		/* 8206D7C8h case    6:*/		return 0x8206D7CC;
		  /* 8206D7CCh */ case    7:  		/* stw R11, <#[R1 + 80]> */
		/* 8206D7CCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206D7CCh case    7:*/		return 0x8206D7D0;
		  /* 8206D7D0h */ case    8:  		/* mr R31, R11 */
		/* 8206D7D0h case    8:*/		regs.R31 = regs.R11;
		/* 8206D7D0h case    8:*/		return 0x8206D7D4;
		  /* 8206D7D4h */ case    9:  		/* stw R11, <#[R1 + 84]> */
		/* 8206D7D4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8206D7D4h case    9:*/		return 0x8206D7D8;
		  /* 8206D7D8h */ case   10:  		/* mr R29, R11 */
		/* 8206D7D8h case   10:*/		regs.R29 = regs.R11;
		/* 8206D7D8h case   10:*/		return 0x8206D7DC;
		  /* 8206D7DCh */ case   11:  		/* stw R11, <#[R1 + 88]> */
		/* 8206D7DCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8206D7DCh case   11:*/		return 0x8206D7E0;
		  /* 8206D7E0h */ case   12:  		/* cmpwi CR6, R10, 0 */
		/* 8206D7E0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8206D7E0h case   12:*/		return 0x8206D7E4;
		  /* 8206D7E4h */ case   13:  		/* stw R11, <#[R1 + 92]> */
		/* 8206D7E4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206D7E4h case   13:*/		return 0x8206D7E8;
		  /* 8206D7E8h */ case   14:  		/* stw R11, <#[R1 + 96]> */
		/* 8206D7E8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8206D7E8h case   14:*/		return 0x8206D7EC;
		  /* 8206D7ECh */ case   15:  		/* stw R11, <#[R1 + 100]> */
		/* 8206D7ECh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8206D7ECh case   15:*/		return 0x8206D7F0;
		  /* 8206D7F0h */ case   16:  		/* stw R11, <#[R1 + 104]> */
		/* 8206D7F0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 8206D7F0h case   16:*/		return 0x8206D7F4;
		  /* 8206D7F4h */ case   17:  		/* stw R11, <#[R1 + 108]> */
		/* 8206D7F4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206D7F4h case   17:*/		return 0x8206D7F8;
		  /* 8206D7F8h */ case   18:  		/* stw R11, <#[R1 + 112]> */
		/* 8206D7F8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8206D7F8h case   18:*/		return 0x8206D7FC;
		  /* 8206D7FCh */ case   19:  		/* stw R11, <#[R1 + 116]> */
		/* 8206D7FCh case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 8206D7FCh case   19:*/		return 0x8206D800;
		  /* 8206D800h */ case   20:  		/* bc 12, CR6_LT, 28 */
		/* 8206D800h case   20:*/		if ( regs.CR[6].lt ) { return 0x8206D81C;  }
		/* 8206D800h case   20:*/		return 0x8206D804;
		  /* 8206D804h */ case   21:  		/* addi R4, R1, 80 */
		/* 8206D804h case   21:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206D804h case   21:*/		return 0x8206D808;
		  /* 8206D808h */ case   22:  		/* bl -4264 */
		/* 8206D808h case   22:*/		regs.LR = 0x8206D80C; return 0x8206C760;
		/* 8206D808h case   22:*/		return 0x8206D80C;
		  /* 8206D80Ch */ case   23:  		/* cmpwi CR0, R3, 0 */
		/* 8206D80Ch case   23:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206D80Ch case   23:*/		return 0x8206D810;
		  /* 8206D810h */ case   24:  		/* bc 12, CR0_LT, 12 */
		/* 8206D810h case   24:*/		if ( regs.CR[0].lt ) { return 0x8206D81C;  }
		/* 8206D810h case   24:*/		return 0x8206D814;
		  /* 8206D814h */ case   25:  		/* lwz R31, <#[R1 + 112]> */
		/* 8206D814h case   25:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000070) );
		/* 8206D814h case   25:*/		return 0x8206D818;
		  /* 8206D818h */ case   26:  		/* lwz R29, <#[R1 + 92]> */
		/* 8206D818h case   26:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206D818h case   26:*/		return 0x8206D81C;
	}
	return 0x8206D81C;
} // Block from 8206D7B0h-8206D81Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8206D81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D81C);
		  /* 8206D81Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8206D81Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8206D81Ch case    0:*/		return 0x8206D820;
		  /* 8206D820h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 8206D820h case    1:*/		if ( regs.CR[6].eq ) { return 0x8206D828;  }
		/* 8206D820h case    1:*/		return 0x8206D824;
		  /* 8206D824h */ case    2:  		/* stw R31, <#[R30]> */
		/* 8206D824h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 8206D824h case    2:*/		return 0x8206D828;
	}
	return 0x8206D828;
} // Block from 8206D81Ch-8206D828h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206D828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D828);
		  /* 8206D828h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8206D828h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8206D828h case    0:*/		return 0x8206D82C;
		  /* 8206D82Ch */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 8206D82Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8206D834;  }
		/* 8206D82Ch case    1:*/		return 0x8206D830;
		  /* 8206D830h */ case    2:  		/* stw R29, <#[R28]> */
		/* 8206D830h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R28 + 0x00000000) );
		/* 8206D830h case    2:*/		return 0x8206D834;
	}
	return 0x8206D834;
} // Block from 8206D828h-8206D834h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206D834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D834);
		  /* 8206D834h */ case    0:  		/* addi R1, R1, 160 */
		/* 8206D834h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8206D834h case    0:*/		return 0x8206D838;
		  /* 8206D838h */ case    1:  		/* b 146032 */
		/* 8206D838h case    1:*/		return 0x820912A8;
		/* 8206D838h case    1:*/		return 0x8206D83C;
		  /* 8206D83Ch */ case    2:  		/* nop */
		/* 8206D83Ch case    2:*/		cpu::op::nop();
		/* 8206D83Ch case    2:*/		return 0x8206D840;
	}
	return 0x8206D840;
} // Block from 8206D834h-8206D840h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206D840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D840);
		  /* 8206D840h */ case    0:  		/* mfspr R12, LR */
		/* 8206D840h case    0:*/		regs.R12 = regs.LR;
		/* 8206D840h case    0:*/		return 0x8206D844;
		  /* 8206D844h */ case    1:  		/* bl 145932 */
		/* 8206D844h case    1:*/		regs.LR = 0x8206D848; return 0x82091250;
		/* 8206D844h case    1:*/		return 0x8206D848;
		  /* 8206D848h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8206D848h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8206D848h case    2:*/		return 0x8206D84C;
		  /* 8206D84Ch */ case    3:  		/* mr R31, R3 */
		/* 8206D84Ch case    3:*/		regs.R31 = regs.R3;
		/* 8206D84Ch case    3:*/		return 0x8206D850;
		  /* 8206D850h */ case    4:  		/* lwz R3, <#[R3 + 19900]> */
		/* 8206D850h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00004DBC) );
		/* 8206D850h case    4:*/		return 0x8206D854;
		  /* 8206D854h */ case    5:  		/* mr R29, R4 */
		/* 8206D854h case    5:*/		regs.R29 = regs.R4;
		/* 8206D854h case    5:*/		return 0x8206D858;
		  /* 8206D858h */ case    6:  		/* mr R28, R5 */
		/* 8206D858h case    6:*/		regs.R28 = regs.R5;
		/* 8206D858h case    6:*/		return 0x8206D85C;
		  /* 8206D85Ch */ case    7:  		/* mr R26, R6 */
		/* 8206D85Ch case    7:*/		regs.R26 = regs.R6;
		/* 8206D85Ch case    7:*/		return 0x8206D860;
		  /* 8206D860h */ case    8:  		/* cmpwi CR6, R3, 0 */
		/* 8206D860h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 8206D860h case    8:*/		return 0x8206D864;
		  /* 8206D864h */ case    9:  		/* bc 12, CR6_LT, 172 */
		/* 8206D864h case    9:*/		if ( regs.CR[6].lt ) { return 0x8206D910;  }
		/* 8206D864h case    9:*/		return 0x8206D868;
		  /* 8206D868h */ case   10:  		/* li R11, 0 */
		/* 8206D868h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206D868h case   10:*/		return 0x8206D86C;
		  /* 8206D86Ch */ case   11:  		/* addi R4, R1, 80 */
		/* 8206D86Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206D86Ch case   11:*/		return 0x8206D870;
		  /* 8206D870h */ case   12:  		/* stw R11, <#[R1 + 80]> */
		/* 8206D870h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206D870h case   12:*/		return 0x8206D874;
		  /* 8206D874h */ case   13:  		/* mr R3, R31 */
		/* 8206D874h case   13:*/		regs.R3 = regs.R31;
		/* 8206D874h case   13:*/		return 0x8206D878;
		  /* 8206D878h */ case   14:  		/* stw R11, <#[R1 + 84]> */
		/* 8206D878h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8206D878h case   14:*/		return 0x8206D87C;
		  /* 8206D87Ch */ case   15:  		/* stw R11, <#[R1 + 88]> */
		/* 8206D87Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8206D87Ch case   15:*/		return 0x8206D880;
		  /* 8206D880h */ case   16:  		/* stw R11, <#[R1 + 92]> */
		/* 8206D880h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206D880h case   16:*/		return 0x8206D884;
		  /* 8206D884h */ case   17:  		/* stw R11, <#[R1 + 96]> */
		/* 8206D884h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8206D884h case   17:*/		return 0x8206D888;
		  /* 8206D888h */ case   18:  		/* stw R11, <#[R1 + 100]> */
		/* 8206D888h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8206D888h case   18:*/		return 0x8206D88C;
		  /* 8206D88Ch */ case   19:  		/* stw R11, <#[R1 + 104]> */
		/* 8206D88Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 8206D88Ch case   19:*/		return 0x8206D890;
		  /* 8206D890h */ case   20:  		/* stw R11, <#[R1 + 108]> */
		/* 8206D890h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206D890h case   20:*/		return 0x8206D894;
		  /* 8206D894h */ case   21:  		/* stw R11, <#[R1 + 112]> */
		/* 8206D894h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8206D894h case   21:*/		return 0x8206D898;
		  /* 8206D898h */ case   22:  		/* stw R11, <#[R1 + 116]> */
		/* 8206D898h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 8206D898h case   22:*/		return 0x8206D89C;
		  /* 8206D89Ch */ case   23:  		/* bl -4412 */
		/* 8206D89Ch case   23:*/		regs.LR = 0x8206D8A0; return 0x8206C760;
		/* 8206D89Ch case   23:*/		return 0x8206D8A0;
		  /* 8206D8A0h */ case   24:  		/* stw R3, <#[R31 + 19900]> */
		/* 8206D8A0h case   24:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00004DBC) );
		/* 8206D8A0h case   24:*/		return 0x8206D8A4;
		  /* 8206D8A4h */ case   25:  		/* cmpwi CR0, R3, 0 */
		/* 8206D8A4h case   25:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206D8A4h case   25:*/		return 0x8206D8A8;
		  /* 8206D8A8h */ case   26:  		/* bc 12, CR0_LT, 104 */
		/* 8206D8A8h case   26:*/		if ( regs.CR[0].lt ) { return 0x8206D910;  }
		/* 8206D8A8h case   26:*/		return 0x8206D8AC;
		  /* 8206D8ACh */ case   27:  		/* lwz R5, <#[R1 + 92]> */
		/* 8206D8ACh case   27:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206D8ACh case   27:*/		return 0x8206D8B0;
		  /* 8206D8B0h */ case   28:  		/* lwz R30, <#[R1 + 112]> */
		/* 8206D8B0h case   28:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000070) );
		/* 8206D8B0h case   28:*/		return 0x8206D8B4;
		  /* 8206D8B4h */ case   29:  		/* add R27, R5, R30 */
		/* 8206D8B4h case   29:*/		cpu::op::add<0>(regs,&regs.R27,regs.R5,regs.R30);
		/* 8206D8B4h case   29:*/		return 0x8206D8B8;
		  /* 8206D8B8h */ case   30:  		/* cmplw CR6, R27, R28 */
		/* 8206D8B8h case   30:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R28);
		/* 8206D8B8h case   30:*/		return 0x8206D8BC;
		  /* 8206D8BCh */ case   31:  		/* bc 4, CR6_GT, 16 */
		/* 8206D8BCh case   31:*/		if ( !regs.CR[6].gt ) { return 0x8206D8CC;  }
		/* 8206D8BCh case   31:*/		return 0x8206D8C0;
		  /* 8206D8C0h */ case   32:  		/* lis R3, -32761 */
		/* 8206D8C0h case   32:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 8206D8C0h case   32:*/		return 0x8206D8C4;
		  /* 8206D8C4h */ case   33:  		/* ori R3, R3, 14 */
		/* 8206D8C4h case   33:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 8206D8C4h case   33:*/		return 0x8206D8C8;
		  /* 8206D8C8h */ case   34:  		/* b 72 */
		/* 8206D8C8h case   34:*/		return 0x8206D910;
		/* 8206D8C8h case   34:*/		return 0x8206D8CC;
	}
	return 0x8206D8CC;
} // Block from 8206D840h-8206D8CCh (35 instructions)

//////////////////////////////////////////////////////
// Block at 8206D8CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D8CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D8CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D8CC);
		  /* 8206D8CCh */ case    0:  		/* add R4, R30, R29 */
		/* 8206D8CCh case    0:*/		cpu::op::add<0>(regs,&regs.R4,regs.R30,regs.R29);
		/* 8206D8CCh case    0:*/		return 0x8206D8D0;
		  /* 8206D8D0h */ case    1:  		/* addi R3, R1, 80 */
		/* 8206D8D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8206D8D0h case    1:*/		return 0x8206D8D4;
		  /* 8206D8D4h */ case    2:  		/* bl -25228 */
		/* 8206D8D4h case    2:*/		regs.LR = 0x8206D8D8; return 0x82067648;
		/* 8206D8D4h case    2:*/		return 0x8206D8D8;
		  /* 8206D8D8h */ case    3:  		/* mr R5, R30 */
		/* 8206D8D8h case    3:*/		regs.R5 = regs.R30;
		/* 8206D8D8h case    3:*/		return 0x8206D8DC;
		  /* 8206D8DCh */ case    4:  		/* mr R4, R29 */
		/* 8206D8DCh case    4:*/		regs.R4 = regs.R29;
		/* 8206D8DCh case    4:*/		return 0x8206D8E0;
		  /* 8206D8E0h */ case    5:  		/* addi R3, R1, 100 */
		/* 8206D8E0h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 8206D8E0h case    5:*/		return 0x8206D8E4;
		  /* 8206D8E4h */ case    6:  		/* bl -25244 */
		/* 8206D8E4h case    6:*/		regs.LR = 0x8206D8E8; return 0x82067648;
		/* 8206D8E4h case    6:*/		return 0x8206D8E8;
		  /* 8206D8E8h */ case    7:  		/* addi R4, R1, 80 */
		/* 8206D8E8h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206D8E8h case    7:*/		return 0x8206D8EC;
		  /* 8206D8ECh */ case    8:  		/* mr R3, R31 */
		/* 8206D8ECh case    8:*/		regs.R3 = regs.R31;
		/* 8206D8ECh case    8:*/		return 0x8206D8F0;
		  /* 8206D8F0h */ case    9:  		/* bl -4496 */
		/* 8206D8F0h case    9:*/		regs.LR = 0x8206D8F4; return 0x8206C760;
		/* 8206D8F0h case    9:*/		return 0x8206D8F4;
		  /* 8206D8F4h */ case   10:  		/* stw R3, <#[R31 + 19900]> */
		/* 8206D8F4h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00004DBC) );
		/* 8206D8F4h case   10:*/		return 0x8206D8F8;
	}
	return 0x8206D8F8;
} // Block from 8206D8CCh-8206D8F8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206D8F8h
// Function '?UnlockResource@D3D@@YAXPAUD3DResource@@KK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D8F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D8F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D8F8);
		  /* 8206D8F8h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 8206D8F8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206D8F8h case    0:*/		return 0x8206D8FC;
		  /* 8206D8FCh */ case    1:  		/* bc 12, CR0_LT, 16 */
		/* 8206D8FCh case    1:*/		if ( regs.CR[0].lt ) { return 0x8206D90C;  }
		/* 8206D8FCh case    1:*/		return 0x8206D900;
		  /* 8206D900h */ case    2:  		/* cmplwi CR6, R26, 0 */
		/* 8206D900h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8206D900h case    2:*/		return 0x8206D904;
		  /* 8206D904h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 8206D904h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206D90C;  }
		/* 8206D904h case    3:*/		return 0x8206D908;
		  /* 8206D908h */ case    4:  		/* stw R27, <#[R26]> */
		/* 8206D908h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R26 + 0x00000000) );
		/* 8206D908h case    4:*/		return 0x8206D90C;
	}
	return 0x8206D90C;
} // Block from 8206D8F8h-8206D90Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206D90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D90C);
		  /* 8206D90Ch */ case    0:  		/* lwz R3, <#[R31 + 19900]> */
		/* 8206D90Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00004DBC) );
		/* 8206D90Ch case    0:*/		return 0x8206D910;
	}
	return 0x8206D910;
} // Block from 8206D90Ch-8206D910h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206D910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D910);
		  /* 8206D910h */ case    0:  		/* addi R1, R1, 176 */
		/* 8206D910h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8206D910h case    0:*/		return 0x8206D914;
		  /* 8206D914h */ case    1:  		/* b 145804 */
		/* 8206D914h case    1:*/		return 0x820912A0;
		/* 8206D914h case    1:*/		return 0x8206D918;
	}
	return 0x8206D918;
} // Block from 8206D910h-8206D918h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206D918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D918);
		  /* 8206D918h */ case    0:  		/* mfspr R12, LR */
		/* 8206D918h case    0:*/		regs.R12 = regs.LR;
		/* 8206D918h case    0:*/		return 0x8206D91C;
		  /* 8206D91Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206D91Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206D91Ch case    1:*/		return 0x8206D920;
		  /* 8206D920h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8206D920h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206D920h case    2:*/		return 0x8206D924;
		  /* 8206D924h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8206D924h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206D924h case    3:*/		return 0x8206D928;
		  /* 8206D928h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206D928h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206D928h case    4:*/		return 0x8206D92C;
		  /* 8206D92Ch */ case    5:  		/* mr R30, R4 */
		/* 8206D92Ch case    5:*/		regs.R30 = regs.R4;
		/* 8206D92Ch case    5:*/		return 0x8206D930;
		  /* 8206D930h */ case    6:  		/* mr R7, R4 */
		/* 8206D930h case    6:*/		regs.R7 = regs.R4;
		/* 8206D930h case    6:*/		return 0x8206D934;
		  /* 8206D934h */ case    7:  		/* li R6, 0 */
		/* 8206D934h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206D934h case    7:*/		return 0x8206D938;
		  /* 8206D938h */ case    8:  		/* li R5, 0 */
		/* 8206D938h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8206D938h case    8:*/		return 0x8206D93C;
		  /* 8206D93Ch */ case    9:  		/* li R4, 1 */
		/* 8206D93Ch case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8206D93Ch case    9:*/		return 0x8206D940;
		  /* 8206D940h */ case   10:  		/* mr R31, R3 */
		/* 8206D940h case   10:*/		regs.R31 = regs.R3;
		/* 8206D940h case   10:*/		return 0x8206D944;
		  /* 8206D944h */ case   11:  		/* bl -3292 */
		/* 8206D944h case   11:*/		regs.LR = 0x8206D948; return 0x8206CC68;
		/* 8206D944h case   11:*/		return 0x8206D948;
		  /* 8206D948h */ case   12:  		/* addi R5, R31, 80 */
		/* 8206D948h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206D948h case   12:*/		return 0x8206D94C;
		  /* 8206D94Ch */ case   13:  		/* mr R4, R30 */
		/* 8206D94Ch case   13:*/		regs.R4 = regs.R30;
		/* 8206D94Ch case   13:*/		return 0x8206D950;
		  /* 8206D950h */ case   14:  		/* addi R3, R31, 96 */
		/* 8206D950h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x60);
		/* 8206D950h case   14:*/		return 0x8206D954;
		  /* 8206D954h */ case   15:  		/* bl -4036 */
		/* 8206D954h case   15:*/		regs.LR = 0x8206D958; return 0x8206C990;
		/* 8206D954h case   15:*/		return 0x8206D958;
		  /* 8206D958h */ case   16:  		/* lwz R11, <#[R31 + 100]> */
		/* 8206D958h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8206D958h case   16:*/		return 0x8206D95C;
		  /* 8206D95Ch */ case   17:  		/* addi R3, R11, -1 */
		/* 8206D95Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 8206D95Ch case   17:*/		return 0x8206D960;
		  /* 8206D960h */ case   18:  		/* addi R1, R1, 112 */
		/* 8206D960h case   18:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206D960h case   18:*/		return 0x8206D964;
		  /* 8206D964h */ case   19:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206D964h case   19:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206D964h case   19:*/		return 0x8206D968;
		  /* 8206D968h */ case   20:  		/* mtspr LR, R12 */
		/* 8206D968h case   20:*/		regs.LR = regs.R12;
		/* 8206D968h case   20:*/		return 0x8206D96C;
		  /* 8206D96Ch */ case   21:  		/* ld R30, <#[R1 - 24]> */
		/* 8206D96Ch case   21:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206D96Ch case   21:*/		return 0x8206D970;
		  /* 8206D970h */ case   22:  		/* ld R31, <#[R1 - 16]> */
		/* 8206D970h case   22:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206D970h case   22:*/		return 0x8206D974;
		  /* 8206D974h */ case   23:  		/* bclr 20, CR0_LT */
		/* 8206D974h case   23:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206D974h case   23:*/		return 0x8206D978;
	}
	return 0x8206D978;
} // Block from 8206D918h-8206D978h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8206D978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D978);
		  /* 8206D978h */ case    0:  		/* mfspr R12, LR */
		/* 8206D978h case    0:*/		regs.R12 = regs.LR;
		/* 8206D978h case    0:*/		return 0x8206D97C;
		  /* 8206D97Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206D97Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206D97Ch case    1:*/		return 0x8206D980;
		  /* 8206D980h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8206D980h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206D980h case    2:*/		return 0x8206D984;
		  /* 8206D984h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8206D984h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206D984h case    3:*/		return 0x8206D988;
		  /* 8206D988h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206D988h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206D988h case    4:*/		return 0x8206D98C;
		  /* 8206D98Ch */ case    5:  		/* cntlzw R11, R5 */
		/* 8206D98Ch case    5:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R5);
		/* 8206D98Ch case    5:*/		return 0x8206D990;
		  /* 8206D990h */ case    6:  		/* mr R30, R4 */
		/* 8206D990h case    6:*/		regs.R30 = regs.R4;
		/* 8206D990h case    6:*/		return 0x8206D994;
		  /* 8206D994h */ case    7:  		/* mr R7, R4 */
		/* 8206D994h case    7:*/		regs.R7 = regs.R4;
		/* 8206D994h case    7:*/		return 0x8206D998;
		  /* 8206D998h */ case    8:  		/* li R6, 0 */
		/* 8206D998h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206D998h case    8:*/		return 0x8206D99C;
		  /* 8206D99Ch */ case    9:  		/* rlwinm R5, R11, 27, 31, 31 */
		/* 8206D99Ch case    9:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R5,regs.R11);
		/* 8206D99Ch case    9:*/		return 0x8206D9A0;
		  /* 8206D9A0h */ case   10:  		/* li R4, 1 */
		/* 8206D9A0h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8206D9A0h case   10:*/		return 0x8206D9A4;
		  /* 8206D9A4h */ case   11:  		/* mr R31, R3 */
		/* 8206D9A4h case   11:*/		regs.R31 = regs.R3;
		/* 8206D9A4h case   11:*/		return 0x8206D9A8;
		  /* 8206D9A8h */ case   12:  		/* bl -3392 */
		/* 8206D9A8h case   12:*/		regs.LR = 0x8206D9AC; return 0x8206CC68;
		/* 8206D9A8h case   12:*/		return 0x8206D9AC;
		  /* 8206D9ACh */ case   13:  		/* addi R5, R31, 80 */
		/* 8206D9ACh case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206D9ACh case   13:*/		return 0x8206D9B0;
		  /* 8206D9B0h */ case   14:  		/* mr R4, R30 */
		/* 8206D9B0h case   14:*/		regs.R4 = regs.R30;
		/* 8206D9B0h case   14:*/		return 0x8206D9B4;
		  /* 8206D9B4h */ case   15:  		/* addi R3, R31, 96 */
		/* 8206D9B4h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x60);
		/* 8206D9B4h case   15:*/		return 0x8206D9B8;
		  /* 8206D9B8h */ case   16:  		/* bl -4136 */
		/* 8206D9B8h case   16:*/		regs.LR = 0x8206D9BC; return 0x8206C990;
		/* 8206D9B8h case   16:*/		return 0x8206D9BC;
		  /* 8206D9BCh */ case   17:  		/* lwz R11, <#[R31 + 100]> */
		/* 8206D9BCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8206D9BCh case   17:*/		return 0x8206D9C0;
	}
	return 0x8206D9C0;
} // Block from 8206D978h-8206D9C0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206D9C0h
// Function '?InvalidateCaches@D3D@@YAXPAVCDevice@1@KK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D9C0);
		  /* 8206D9C0h */ case    0:  		/* addi R3, R11, -1 */
		/* 8206D9C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 8206D9C0h case    0:*/		return 0x8206D9C4;
		  /* 8206D9C4h */ case    1:  		/* addi R1, R1, 112 */
		/* 8206D9C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206D9C4h case    1:*/		return 0x8206D9C8;
		  /* 8206D9C8h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206D9C8h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206D9C8h case    2:*/		return 0x8206D9CC;
		  /* 8206D9CCh */ case    3:  		/* mtspr LR, R12 */
		/* 8206D9CCh case    3:*/		regs.LR = regs.R12;
		/* 8206D9CCh case    3:*/		return 0x8206D9D0;
		  /* 8206D9D0h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 8206D9D0h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206D9D0h case    4:*/		return 0x8206D9D4;
		  /* 8206D9D4h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8206D9D4h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206D9D4h case    5:*/		return 0x8206D9D8;
		  /* 8206D9D8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 8206D9D8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206D9D8h case    6:*/		return 0x8206D9DC;
	}
	return 0x8206D9DC;
} // Block from 8206D9C0h-8206D9DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206D9DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D9DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D9DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D9DC);
		  /* 8206D9DCh */ case    0:  		/* nop */
		/* 8206D9DCh case    0:*/		cpu::op::nop();
		/* 8206D9DCh case    0:*/		return 0x8206D9E0;
	}
	return 0x8206D9E0;
} // Block from 8206D9DCh-8206D9E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206D9E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206D9E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206D9E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206D9E0);
		  /* 8206D9E0h */ case    0:  		/* mfspr R12, LR */
		/* 8206D9E0h case    0:*/		regs.R12 = regs.LR;
		/* 8206D9E0h case    0:*/		return 0x8206D9E4;
		  /* 8206D9E4h */ case    1:  		/* bl 145524 */
		/* 8206D9E4h case    1:*/		regs.LR = 0x8206D9E8; return 0x82091258;
		/* 8206D9E4h case    1:*/		return 0x8206D9E8;
		  /* 8206D9E8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206D9E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206D9E8h case    2:*/		return 0x8206D9EC;
		  /* 8206D9ECh */ case    3:  		/* cntlzw R11, R6 */
		/* 8206D9ECh case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R6);
		/* 8206D9ECh case    3:*/		return 0x8206D9F0;
		  /* 8206D9F0h */ case    4:  		/* mr R29, R4 */
		/* 8206D9F0h case    4:*/		regs.R29 = regs.R4;
		/* 8206D9F0h case    4:*/		return 0x8206D9F4;
		  /* 8206D9F4h */ case    5:  		/* mr R30, R5 */
		/* 8206D9F4h case    5:*/		regs.R30 = regs.R5;
		/* 8206D9F4h case    5:*/		return 0x8206D9F8;
		  /* 8206D9F8h */ case    6:  		/* mr R28, R6 */
		/* 8206D9F8h case    6:*/		regs.R28 = regs.R6;
		/* 8206D9F8h case    6:*/		return 0x8206D9FC;
		  /* 8206D9FCh */ case    7:  		/* mr R7, R4 */
		/* 8206D9FCh case    7:*/		regs.R7 = regs.R4;
		/* 8206D9FCh case    7:*/		return 0x8206DA00;
		  /* 8206DA00h */ case    8:  		/* li R6, 1 */
		/* 8206DA00h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8206DA00h case    8:*/		return 0x8206DA04;
		  /* 8206DA04h */ case    9:  		/* rlwinm R5, R11, 27, 31, 31 */
		/* 8206DA04h case    9:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R5,regs.R11);
		/* 8206DA04h case    9:*/		return 0x8206DA08;
		  /* 8206DA08h */ case   10:  		/* li R4, 1 */
		/* 8206DA08h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8206DA08h case   10:*/		return 0x8206DA0C;
		  /* 8206DA0Ch */ case   11:  		/* mr R31, R3 */
		/* 8206DA0Ch case   11:*/		regs.R31 = regs.R3;
		/* 8206DA0Ch case   11:*/		return 0x8206DA10;
		  /* 8206DA10h */ case   12:  		/* bl -3496 */
		/* 8206DA10h case   12:*/		regs.LR = 0x8206DA14; return 0x8206CC68;
		/* 8206DA10h case   12:*/		return 0x8206DA14;
		  /* 8206DA14h */ case   13:  		/* mr R11, R30 */
		/* 8206DA14h case   13:*/		regs.R11 = regs.R30;
		/* 8206DA14h case   13:*/		return 0x8206DA18;
		  /* 8206DA18h */ case   14:  		/* mr R10, R30 */
		/* 8206DA18h case   14:*/		regs.R10 = regs.R30;
		/* 8206DA18h case   14:*/		return 0x8206DA1C;
		  /* 8206DA1Ch */ case   15:  		/* rlwimi R11, R28, 6, 25, 25 */
		/* 8206DA1Ch case   15:*/		cpu::op::rlwimi<0,6,25,25>(regs,&regs.R11,regs.R28);
		/* 8206DA1Ch case   15:*/		return 0x8206DA20;
		  /* 8206DA20h */ case   16:  		/* addi R30, R31, 80 */
		/* 8206DA20h case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x50);
		/* 8206DA20h case   16:*/		return 0x8206DA24;
		  /* 8206DA24h */ case   17:  		/* andi. R11, R11, 79 */
		/* 8206DA24h case   17:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x4F);
		/* 8206DA24h case   17:*/		return 0x8206DA28;
		  /* 8206DA28h */ case   18:  		/* rlwimi R10, R11, 8, 0, 23 */
		/* 8206DA28h case   18:*/		cpu::op::rlwimi<0,8,0,23>(regs,&regs.R10,regs.R11);
		/* 8206DA28h case   18:*/		return 0x8206DA2C;
		  /* 8206DA2Ch */ case   19:  		/* lwz R11, <#[R31 + 100]> */
		/* 8206DA2Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8206DA2Ch case   19:*/		return 0x8206DA30;
		  /* 8206DA30h */ case   20:  		/* mr R5, R30 */
		/* 8206DA30h case   20:*/		regs.R5 = regs.R30;
		/* 8206DA30h case   20:*/		return 0x8206DA34;
		  /* 8206DA34h */ case   21:  		/* rlwimi R11, R10, 8, 0, 19 */
		/* 8206DA34h case   21:*/		cpu::op::rlwimi<0,8,0,19>(regs,&regs.R11,regs.R10);
		/* 8206DA34h case   21:*/		return 0x8206DA38;
		  /* 8206DA38h */ case   22:  		/* addi R4, R1, 80 */
		/* 8206DA38h case   22:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206DA38h case   22:*/		return 0x8206DA3C;
		  /* 8206DA3Ch */ case   23:  		/* stw R11, <#[R1 + 80]> */
		/* 8206DA3Ch case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206DA3Ch case   23:*/		return 0x8206DA40;
		  /* 8206DA40h */ case   24:  		/* addi R3, R31, 292 */
		/* 8206DA40h case   24:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x124);
		/* 8206DA40h case   24:*/		return 0x8206DA44;
		  /* 8206DA44h */ case   25:  		/* bl -4044 */
		/* 8206DA44h case   25:*/		regs.LR = 0x8206DA48; return 0x8206CA78;
		/* 8206DA44h case   25:*/		return 0x8206DA48;
		  /* 8206DA48h */ case   26:  		/* mr R5, R30 */
		/* 8206DA48h case   26:*/		regs.R5 = regs.R30;
		/* 8206DA48h case   26:*/		return 0x8206DA4C;
		  /* 8206DA4Ch */ case   27:  		/* mr R4, R29 */
		/* 8206DA4Ch case   27:*/		regs.R4 = regs.R29;
		/* 8206DA4Ch case   27:*/		return 0x8206DA50;
		  /* 8206DA50h */ case   28:  		/* addi R3, R31, 96 */
		/* 8206DA50h case   28:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x60);
		/* 8206DA50h case   28:*/		return 0x8206DA54;
		  /* 8206DA54h */ case   29:  		/* bl -4292 */
		/* 8206DA54h case   29:*/		regs.LR = 0x8206DA58; return 0x8206C990;
		/* 8206DA54h case   29:*/		return 0x8206DA58;
		  /* 8206DA58h */ case   30:  		/* lwz R11, <#[R31 + 100]> */
		/* 8206DA58h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8206DA58h case   30:*/		return 0x8206DA5C;
		  /* 8206DA5Ch */ case   31:  		/* addi R3, R11, -1 */
		/* 8206DA5Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 8206DA5Ch case   31:*/		return 0x8206DA60;
		  /* 8206DA60h */ case   32:  		/* addi R1, R1, 128 */
		/* 8206DA60h case   32:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206DA60h case   32:*/		return 0x8206DA64;
		  /* 8206DA64h */ case   33:  		/* b 145476 */
		/* 8206DA64h case   33:*/		return 0x820912A8;
		/* 8206DA64h case   33:*/		return 0x8206DA68;
	}
	return 0x8206DA68;
} // Block from 8206D9E0h-8206DA68h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8206DA68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DA68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DA68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DA68);
		  /* 8206DA68h */ case    0:  		/* mfspr R12, LR */
		/* 8206DA68h case    0:*/		regs.R12 = regs.LR;
		/* 8206DA68h case    0:*/		return 0x8206DA6C;
		  /* 8206DA6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206DA6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DA6Ch case    1:*/		return 0x8206DA70;
		  /* 8206DA70h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8206DA70h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206DA70h case    2:*/		return 0x8206DA74;
		  /* 8206DA74h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8206DA74h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206DA74h case    3:*/		return 0x8206DA78;
		  /* 8206DA78h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206DA78h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206DA78h case    4:*/		return 0x8206DA7C;
		  /* 8206DA7Ch */ case    5:  		/* mr R30, R4 */
		/* 8206DA7Ch case    5:*/		regs.R30 = regs.R4;
		/* 8206DA7Ch case    5:*/		return 0x8206DA80;
	}
	return 0x8206DA80;
} // Block from 8206DA68h-8206DA80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206DA80h
// Function 'D3DResource_AddRef'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DA80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DA80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DA80);
		  /* 8206DA80h */ case    0:  		/* mr R7, R4 */
		/* 8206DA80h case    0:*/		regs.R7 = regs.R4;
		/* 8206DA80h case    0:*/		return 0x8206DA84;
		  /* 8206DA84h */ case    1:  		/* li R6, 0 */
		/* 8206DA84h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206DA84h case    1:*/		return 0x8206DA88;
		  /* 8206DA88h */ case    2:  		/* li R5, 0 */
		/* 8206DA88h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8206DA88h case    2:*/		return 0x8206DA8C;
		  /* 8206DA8Ch */ case    3:  		/* li R4, 0 */
		/* 8206DA8Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206DA8Ch case    3:*/		return 0x8206DA90;
		  /* 8206DA90h */ case    4:  		/* mr R31, R3 */
		/* 8206DA90h case    4:*/		regs.R31 = regs.R3;
		/* 8206DA90h case    4:*/		return 0x8206DA94;
		  /* 8206DA94h */ case    5:  		/* bl -3628 */
		/* 8206DA94h case    5:*/		regs.LR = 0x8206DA98; return 0x8206CC68;
		/* 8206DA94h case    5:*/		return 0x8206DA98;
		  /* 8206DA98h */ case    6:  		/* addi R5, R31, 80 */
		/* 8206DA98h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206DA98h case    6:*/		return 0x8206DA9C;
		  /* 8206DA9Ch */ case    7:  		/* mr R4, R30 */
		/* 8206DA9Ch case    7:*/		regs.R4 = regs.R30;
		/* 8206DA9Ch case    7:*/		return 0x8206DAA0;
		  /* 8206DAA0h */ case    8:  		/* addi R3, R31, 96 */
		/* 8206DAA0h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x60);
		/* 8206DAA0h case    8:*/		return 0x8206DAA4;
		  /* 8206DAA4h */ case    9:  		/* bl -4372 */
		/* 8206DAA4h case    9:*/		regs.LR = 0x8206DAA8; return 0x8206C990;
		/* 8206DAA4h case    9:*/		return 0x8206DAA8;
		  /* 8206DAA8h */ case   10:  		/* lwz R11, <#[R31]> */
		/* 8206DAA8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206DAA8h case   10:*/		return 0x8206DAAC;
		  /* 8206DAACh */ case   11:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206DAACh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206DAACh case   11:*/		return 0x8206DAB0;
		  /* 8206DAB0h */ case   12:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 8206DAB0h case   12:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 8206DAB0h case   12:*/		return 0x8206DAB4;
		  /* 8206DAB4h */ case   13:  		/* bc 4, CR0_EQ, 68 */
		/* 8206DAB4h case   13:*/		if ( !regs.CR[0].eq ) { return 0x8206DAF8;  }
		/* 8206DAB4h case   13:*/		return 0x8206DAB8;
		  /* 8206DAB8h */ case   14:  		/* addi R4, R1, 80 */
		/* 8206DAB8h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206DAB8h case   14:*/		return 0x8206DABC;
		  /* 8206DABCh */ case   15:  		/* mr R3, R30 */
		/* 8206DABCh case   15:*/		regs.R3 = regs.R30;
		/* 8206DABCh case   15:*/		return 0x8206DAC0;
		  /* 8206DAC0h */ case   16:  		/* bl -25496 */
		/* 8206DAC0h case   16:*/		regs.LR = 0x8206DAC4; return 0x82067728;
		/* 8206DAC0h case   16:*/		return 0x8206DAC4;
		  /* 8206DAC4h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 8206DAC4h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206DAC4h case   17:*/		return 0x8206DAC8;
		  /* 8206DAC8h */ case   18:  		/* bc 12, CR0_EQ, 48 */
		/* 8206DAC8h case   18:*/		if ( regs.CR[0].eq ) { return 0x8206DAF8;  }
		/* 8206DAC8h case   18:*/		return 0x8206DACC;
		  /* 8206DACCh */ case   19:  		/* lwz R11, <#[R31 + 316]> */
		/* 8206DACCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000013C) );
		/* 8206DACCh case   19:*/		return 0x8206DAD0;
		  /* 8206DAD0h */ case   20:  		/* lwz R9, <#[R1 + 80]> */
		/* 8206DAD0h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 8206DAD0h case   20:*/		return 0x8206DAD4;
		  /* 8206DAD4h */ case   21:  		/* addi R11, R11, 1 */
		/* 8206DAD4h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206DAD4h case   21:*/		return 0x8206DAD8;
		  /* 8206DAD8h */ case   22:  		/* stw R11, <#[R31 + 316]> */
		/* 8206DAD8h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000013C) );
		/* 8206DAD8h case   22:*/		return 0x8206DADC;
		  /* 8206DADCh */ case   23:  		/* lwz R11, <#[R30]> */
		/* 8206DADCh case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206DADCh case   23:*/		return 0x8206DAE0;
		  /* 8206DAE0h */ case   24:  		/* rlwinm R11, R11, 0, 26, 31 */
		/* 8206DAE0h case   24:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R11);
		/* 8206DAE0h case   24:*/		return 0x8206DAE4;
		  /* 8206DAE4h */ case   25:  		/* add R11, R11, R31 */
		/* 8206DAE4h case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8206DAE4h case   25:*/		return 0x8206DAE8;
		  /* 8206DAE8h */ case   26:  		/* addi R10, R11, 320 */
		/* 8206DAE8h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x140);
		/* 8206DAE8h case   26:*/		return 0x8206DAEC;
		  /* 8206DAECh */ case   27:  		/* lbz R10, <#[R11 + 320]> */
		/* 8206DAECh case   27:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000140) );
		/* 8206DAECh case   27:*/		return 0x8206DAF0;
		  /* 8206DAF0h */ case   28:  		/* or R10, R10, R9 */
		/* 8206DAF0h case   28:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8206DAF0h case   28:*/		return 0x8206DAF4;
		  /* 8206DAF4h */ case   29:  		/* stb R10, <#[R11 + 320]> */
		/* 8206DAF4h case   29:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000140) );
		/* 8206DAF4h case   29:*/		return 0x8206DAF8;
	}
	return 0x8206DAF8;
} // Block from 8206DA80h-8206DAF8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8206DAF8h
// Function 'D3DResource_Release'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DAF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DAF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DAF8);
		  /* 8206DAF8h */ case    0:  		/* lwz R11, <#[R31 + 100]> */
		/* 8206DAF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8206DAF8h case    0:*/		return 0x8206DAFC;
		  /* 8206DAFCh */ case    1:  		/* addi R3, R11, -1 */
		/* 8206DAFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 8206DAFCh case    1:*/		return 0x8206DB00;
		  /* 8206DB00h */ case    2:  		/* addi R1, R1, 112 */
		/* 8206DB00h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206DB00h case    2:*/		return 0x8206DB04;
		  /* 8206DB04h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206DB04h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DB04h case    3:*/		return 0x8206DB08;
		  /* 8206DB08h */ case    4:  		/* mtspr LR, R12 */
		/* 8206DB08h case    4:*/		regs.LR = regs.R12;
		/* 8206DB08h case    4:*/		return 0x8206DB0C;
		  /* 8206DB0Ch */ case    5:  		/* ld R30, <#[R1 - 24]> */
		/* 8206DB0Ch case    5:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206DB0Ch case    5:*/		return 0x8206DB10;
		  /* 8206DB10h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 8206DB10h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206DB10h case    6:*/		return 0x8206DB14;
		  /* 8206DB14h */ case    7:  		/* bclr 20, CR0_LT */
		/* 8206DB14h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206DB14h case    7:*/		return 0x8206DB18;
	}
	return 0x8206DB18;
} // Block from 8206DAF8h-8206DB18h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206DB18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DB18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DB18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DB18);
		  /* 8206DB18h */ case    0:  		/* mfspr R12, LR */
		/* 8206DB18h case    0:*/		regs.R12 = regs.LR;
		/* 8206DB18h case    0:*/		return 0x8206DB1C;
		  /* 8206DB1Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206DB1Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DB1Ch case    1:*/		return 0x8206DB20;
		  /* 8206DB20h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8206DB20h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206DB20h case    2:*/		return 0x8206DB24;
		  /* 8206DB24h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206DB24h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206DB24h case    3:*/		return 0x8206DB28;
		  /* 8206DB28h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8206DB28h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206DB28h case    4:*/		return 0x8206DB2C;
		  /* 8206DB2Ch */ case    5:  		/* mr R31, R3 */
		/* 8206DB2Ch case    5:*/		regs.R31 = regs.R3;
		/* 8206DB2Ch case    5:*/		return 0x8206DB30;
		  /* 8206DB30h */ case    6:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206DB30h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206DB30h case    6:*/		return 0x8206DB34;
		  /* 8206DB34h */ case    7:  		/* nor R11, R11, R11 */
		/* 8206DB34h case    7:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206DB34h case    7:*/		return 0x8206DB38;
		  /* 8206DB38h */ case    8:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 8206DB38h case    8:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8206DB38h case    8:*/		return 0x8206DB3C;
		  /* 8206DB3Ch */ case    9:  		/* bc 12, CR0_EQ, 88 */
		/* 8206DB3Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8206DB94;  }
		/* 8206DB3Ch case    9:*/		return 0x8206DB40;
		  /* 8206DB40h */ case   10:  		/* lbz R11, <#[R3 + 124]> */
		/* 8206DB40h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000007C) );
		/* 8206DB40h case   10:*/		return 0x8206DB44;
		  /* 8206DB44h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 8206DB44h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8206DB44h case   11:*/		return 0x8206DB48;
		  /* 8206DB48h */ case   12:  		/* bc 12, CR0_EQ, 76 */
		/* 8206DB48h case   12:*/		if ( regs.CR[0].eq ) { return 0x8206DB94;  }
		/* 8206DB48h case   12:*/		return 0x8206DB4C;
		  /* 8206DB4Ch */ case   13:  		/* addi R10, R1, 80 */
		/* 8206DB4Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 8206DB4Ch case   13:*/		return 0x8206DB50;
		  /* 8206DB50h */ case   14:  		/* li R11, 0 */
		/* 8206DB50h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206DB50h case   14:*/		return 0x8206DB54;
		  /* 8206DB54h */ case   15:  		/* li R9, 1 */
		/* 8206DB54h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8206DB54h case   15:*/		return 0x8206DB58;
		  /* 8206DB58h */ case   16:  		/* addi R4, R1, 80 */
		/* 8206DB58h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206DB58h case   16:*/		return 0x8206DB5C;
		  /* 8206DB5Ch */ case   17:  		/* std R11, <#[R10]> */
		/* 8206DB5Ch case   17:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8206DB5Ch case   17:*/		return 0x8206DB60;
		  /* 8206DB60h */ case   18:  		/* stw R11, <#[R10 + 8]> */
		/* 8206DB60h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8206DB60h case   18:*/		return 0x8206DB64;
		  /* 8206DB64h */ case   19:  		/* lwz R11, <#[R1 + 88]> */
		/* 8206DB64h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8206DB64h case   19:*/		return 0x8206DB68;
		  /* 8206DB68h */ case   20:  		/* lwz R10, <#[R1 + 80]> */
		/* 8206DB68h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8206DB68h case   20:*/		return 0x8206DB6C;
		  /* 8206DB6Ch */ case   21:  		/* rlwinm R10, R10, 0, 6, 31 */
		/* 8206DB6Ch case   21:*/		cpu::op::rlwinm<0,0,6,31>(regs,&regs.R10,regs.R10);
		/* 8206DB6Ch case   21:*/		return 0x8206DB70;
		  /* 8206DB70h */ case   22:  		/* rlwimi R11, R9, 25, 3, 7 */
		/* 8206DB70h case   22:*/		cpu::op::rlwimi<0,25,3,7>(regs,&regs.R11,regs.R9);
		/* 8206DB70h case   22:*/		return 0x8206DB74;
		  /* 8206DB74h */ case   23:  		/* oris R10, R10, 51200 */
		/* 8206DB74h case   23:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xC800);
		/* 8206DB74h case   23:*/		return 0x8206DB78;
	}
	return 0x8206DB78;
} // Block from 8206DB18h-8206DB78h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8206DB78h
// Function 'D3DResource_GetType'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DB78);
		  /* 8206DB78h */ case    0:  		/* stw R11, <#[R1 + 88]> */
		/* 8206DB78h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8206DB78h case    0:*/		return 0x8206DB7C;
		  /* 8206DB7Ch */ case    1:  		/* stw R10, <#[R1 + 80]> */
		/* 8206DB7Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8206DB7Ch case    1:*/		return 0x8206DB80;
		  /* 8206DB80h */ case    2:  		/* bl -280 */
		/* 8206DB80h case    2:*/		regs.LR = 0x8206DB84; return 0x8206DA68;
		/* 8206DB80h case    2:*/		return 0x8206DB84;
		  /* 8206DB84h */ case    3:  		/* mr R4, R3 */
		/* 8206DB84h case    3:*/		regs.R4 = regs.R3;
		/* 8206DB84h case    3:*/		return 0x8206DB88;
		  /* 8206DB88h */ case    4:  		/* li R5, 1 */
		/* 8206DB88h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206DB88h case    4:*/		return 0x8206DB8C;
		  /* 8206DB8Ch */ case    5:  		/* mr R3, R31 */
		/* 8206DB8Ch case    5:*/		regs.R3 = regs.R31;
		/* 8206DB8Ch case    5:*/		return 0x8206DB90;
		  /* 8206DB90h */ case    6:  		/* bl -17248 */
		/* 8206DB90h case    6:*/		regs.LR = 0x8206DB94; return 0x82069830;
		/* 8206DB90h case    6:*/		return 0x8206DB94;
	}
	return 0x8206DB94;
} // Block from 8206DB78h-8206DB94h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206DB94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DB94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DB94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DB94);
		  /* 8206DB94h */ case    0:  		/* addi R1, R1, 112 */
		/* 8206DB94h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206DB94h case    0:*/		return 0x8206DB98;
		  /* 8206DB98h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206DB98h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DB98h case    1:*/		return 0x8206DB9C;
		  /* 8206DB9Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8206DB9Ch case    2:*/		regs.LR = regs.R12;
		/* 8206DB9Ch case    2:*/		return 0x8206DBA0;
		  /* 8206DBA0h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8206DBA0h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206DBA0h case    3:*/		return 0x8206DBA4;
		  /* 8206DBA4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 8206DBA4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206DBA4h case    4:*/		return 0x8206DBA8;
	}
	return 0x8206DBA8;
} // Block from 8206DB94h-8206DBA8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206DBA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DBA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DBA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DBA8);
		  /* 8206DBA8h */ case    0:  		/* mfspr R12, LR */
		/* 8206DBA8h case    0:*/		regs.R12 = regs.LR;
		/* 8206DBA8h case    0:*/		return 0x8206DBAC;
		  /* 8206DBACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206DBACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DBACh case    1:*/		return 0x8206DBB0;
		  /* 8206DBB0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8206DBB0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206DBB0h case    2:*/		return 0x8206DBB4;
		  /* 8206DBB4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8206DBB4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8206DBB4h case    3:*/		return 0x8206DBB8;
		  /* 8206DBB8h */ case    4:  		/* lwz R11, <#[R3 + 19892]> */
		/* 8206DBB8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00004DB4) );
		/* 8206DBB8h case    4:*/		return 0x8206DBBC;
		  /* 8206DBBCh */ case    5:  		/* mr R31, R3 */
		/* 8206DBBCh case    5:*/		regs.R31 = regs.R3;
		/* 8206DBBCh case    5:*/		return 0x8206DBC0;
		  /* 8206DBC0h */ case    6:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8206DBC0h case    6:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8206DBC0h case    6:*/		return 0x8206DBC4;
		  /* 8206DBC4h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8206DBC4h case    7:*/		if ( regs.CR[0].eq ) { return 0x8206DBD0;  }
		/* 8206DBC4h case    7:*/		return 0x8206DBC8;
		  /* 8206DBC8h */ case    8:  		/* bl -1968 */
		/* 8206DBC8h case    8:*/		regs.LR = 0x8206DBCC; return 0x8206D418;
		/* 8206DBC8h case    8:*/		return 0x8206DBCC;
		  /* 8206DBCCh */ case    9:  		/* b 24 */
		/* 8206DBCCh case    9:*/		return 0x8206DBE4;
		/* 8206DBCCh case    9:*/		return 0x8206DBD0;
	}
	return 0x8206DBD0;
} // Block from 8206DBA8h-8206DBD0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206DBD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DBD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DBD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DBD0);
		  /* 8206DBD0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8206DBD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206DBD0h case    0:*/		return 0x8206DBD4;
		  /* 8206DBD4h */ case    1:  		/* mulli R11, R11, 9936 */
		/* 8206DBD4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206DBD4h case    1:*/		return 0x8206DBD8;
		  /* 8206DBD8h */ case    2:  		/* add R11, R11, R31 */
		/* 8206DBD8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8206DBD8h case    2:*/		return 0x8206DBDC;
		  /* 8206DBDCh */ case    3:  		/* addi R3, R11, 16 */
		/* 8206DBDCh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206DBDCh case    3:*/		return 0x8206DBE0;
		  /* 8206DBE0h */ case    4:  		/* bl -10912 */
		/* 8206DBE0h case    4:*/		regs.LR = 0x8206DBE4; return 0x8206B140;
		/* 8206DBE0h case    4:*/		return 0x8206DBE4;
	}
	return 0x8206DBE4;
} // Block from 8206DBD0h-8206DBE4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206DBE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DBE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DBE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DBE4);
		  /* 8206DBE4h */ case    0:  		/* li R11, 1 */
		/* 8206DBE4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206DBE4h case    0:*/		return 0x8206DBE8;
		  /* 8206DBE8h */ case    1:  		/* stw R11, <#[R31 + 19904]> */
		/* 8206DBE8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00004DC0) );
		/* 8206DBE8h case    1:*/		return 0x8206DBEC;
		  /* 8206DBECh */ case    2:  		/* addi R1, R1, 96 */
		/* 8206DBECh case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206DBECh case    2:*/		return 0x8206DBF0;
		  /* 8206DBF0h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206DBF0h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DBF0h case    3:*/		return 0x8206DBF4;
		  /* 8206DBF4h */ case    4:  		/* mtspr LR, R12 */
		/* 8206DBF4h case    4:*/		regs.LR = regs.R12;
		/* 8206DBF4h case    4:*/		return 0x8206DBF8;
		  /* 8206DBF8h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8206DBF8h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206DBF8h case    5:*/		return 0x8206DBFC;
		  /* 8206DBFCh */ case    6:  		/* bclr 20, CR0_LT */
		/* 8206DBFCh case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206DBFCh case    6:*/		return 0x8206DC00;
	}
	return 0x8206DC00;
} // Block from 8206DBE4h-8206DC00h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206DC00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DC00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DC00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DC00);
		  /* 8206DC00h */ case    0:  		/* b -1672 */
		/* 8206DC00h case    0:*/		return 0x8206D578;
		/* 8206DC00h case    0:*/		return 0x8206DC04;
		  /* 8206DC04h */ case    1:  		/* nop */
		/* 8206DC04h case    1:*/		cpu::op::nop();
		/* 8206DC04h case    1:*/		return 0x8206DC08;
	}
	return 0x8206DC08;
} // Block from 8206DC00h-8206DC08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206DC08h
// Function '?DoBeginExportNanVertex@@YAXPAUD3DDevice@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DC08);
		  /* 8206DC08h */ case    0:  		/* b -1560 */
		/* 8206DC08h case    0:*/		return 0x8206D5F0;
		/* 8206DC08h case    0:*/		return 0x8206DC0C;
		  /* 8206DC0Ch */ case    1:  		/* nop */
		/* 8206DC0Ch case    1:*/		cpu::op::nop();
		/* 8206DC0Ch case    1:*/		return 0x8206DC10;
		  /* 8206DC10h */ case    2:  		/* b -1440 */
		/* 8206DC10h case    2:*/		return 0x8206D670;
		/* 8206DC10h case    2:*/		return 0x8206DC14;
		  /* 8206DC14h */ case    3:  		/* nop */
		/* 8206DC14h case    3:*/		cpu::op::nop();
		/* 8206DC14h case    3:*/		return 0x8206DC18;
		  /* 8206DC18h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8206DC18h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206DC18h case    4:*/		return 0x8206DC1C;
		  /* 8206DC1Ch */ case    5:  		/* mulli R11, R11, 9936 */
		/* 8206DC1Ch case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206DC1Ch case    5:*/		return 0x8206DC20;
		  /* 8206DC20h */ case    6:  		/* add R11, R11, R3 */
		/* 8206DC20h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206DC20h case    6:*/		return 0x8206DC24;
		  /* 8206DC24h */ case    7:  		/* addi R3, R11, 16 */
		/* 8206DC24h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206DC24h case    7:*/		return 0x8206DC28;
		  /* 8206DC28h */ case    8:  		/* b -784 */
		/* 8206DC28h case    8:*/		return 0x8206D918;
		/* 8206DC28h case    8:*/		return 0x8206DC2C;
		  /* 8206DC2Ch */ case    9:  		/* nop */
		/* 8206DC2Ch case    9:*/		cpu::op::nop();
		/* 8206DC2Ch case    9:*/		return 0x8206DC30;
		  /* 8206DC30h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 8206DC30h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206DC30h case   10:*/		return 0x8206DC34;
		  /* 8206DC34h */ case   11:  		/* mulli R11, R11, 9936 */
		/* 8206DC34h case   11:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206DC34h case   11:*/		return 0x8206DC38;
		  /* 8206DC38h */ case   12:  		/* add R11, R11, R3 */
		/* 8206DC38h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206DC38h case   12:*/		return 0x8206DC3C;
		  /* 8206DC3Ch */ case   13:  		/* addi R3, R11, 16 */
		/* 8206DC3Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206DC3Ch case   13:*/		return 0x8206DC40;
		  /* 8206DC40h */ case   14:  		/* b -712 */
		/* 8206DC40h case   14:*/		return 0x8206D978;
		/* 8206DC40h case   14:*/		return 0x8206DC44;
		  /* 8206DC44h */ case   15:  		/* nop */
		/* 8206DC44h case   15:*/		cpu::op::nop();
		/* 8206DC44h case   15:*/		return 0x8206DC48;
		  /* 8206DC48h */ case   16:  		/* lwz R11, <#[R3]> */
		/* 8206DC48h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206DC48h case   16:*/		return 0x8206DC4C;
		  /* 8206DC4Ch */ case   17:  		/* mulli R11, R11, 9936 */
		/* 8206DC4Ch case   17:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206DC4Ch case   17:*/		return 0x8206DC50;
		  /* 8206DC50h */ case   18:  		/* add R11, R11, R3 */
		/* 8206DC50h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206DC50h case   18:*/		return 0x8206DC54;
		  /* 8206DC54h */ case   19:  		/* addi R3, R11, 16 */
		/* 8206DC54h case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206DC54h case   19:*/		return 0x8206DC58;
		  /* 8206DC58h */ case   20:  		/* b -632 */
		/* 8206DC58h case   20:*/		return 0x8206D9E0;
		/* 8206DC58h case   20:*/		return 0x8206DC5C;
		  /* 8206DC5Ch */ case   21:  		/* nop */
		/* 8206DC5Ch case   21:*/		cpu::op::nop();
		/* 8206DC5Ch case   21:*/		return 0x8206DC60;
		  /* 8206DC60h */ case   22:  		/* lwz R11, <#[R3]> */
		/* 8206DC60h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206DC60h case   22:*/		return 0x8206DC64;
		  /* 8206DC64h */ case   23:  		/* mulli R11, R11, 9936 */
		/* 8206DC64h case   23:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206DC64h case   23:*/		return 0x8206DC68;
		  /* 8206DC68h */ case   24:  		/* add R11, R11, R3 */
		/* 8206DC68h case   24:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206DC68h case   24:*/		return 0x8206DC6C;
		  /* 8206DC6Ch */ case   25:  		/* addi R3, R11, 16 */
		/* 8206DC6Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206DC6Ch case   25:*/		return 0x8206DC70;
		  /* 8206DC70h */ case   26:  		/* b -520 */
		/* 8206DC70h case   26:*/		return 0x8206DA68;
		/* 8206DC70h case   26:*/		return 0x8206DC74;
		  /* 8206DC74h */ case   27:  		/* nop */
		/* 8206DC74h case   27:*/		cpu::op::nop();
		/* 8206DC74h case   27:*/		return 0x8206DC78;
		  /* 8206DC78h */ case   28:  		/* b -1440 */
		/* 8206DC78h case   28:*/		return 0x8206D6D8;
		/* 8206DC78h case   28:*/		return 0x8206DC7C;
		  /* 8206DC7Ch */ case   29:  		/* nop */
		/* 8206DC7Ch case   29:*/		cpu::op::nop();
		/* 8206DC7Ch case   29:*/		return 0x8206DC80;
		  /* 8206DC80h */ case   30:  		/* b -216 */
		/* 8206DC80h case   30:*/		return 0x8206DBA8;
		/* 8206DC80h case   30:*/		return 0x8206DC84;
		  /* 8206DC84h */ case   31:  		/* nop */
		/* 8206DC84h case   31:*/		cpu::op::nop();
		/* 8206DC84h case   31:*/		return 0x8206DC88;
		  /* 8206DC88h */ case   32:  		/* b -1096 */
		/* 8206DC88h case   32:*/		return 0x8206D840;
		/* 8206DC88h case   32:*/		return 0x8206DC8C;
		  /* 8206DC8Ch */ case   33:  		/* nop */
		/* 8206DC8Ch case   33:*/		cpu::op::nop();
		/* 8206DC8Ch case   33:*/		return 0x8206DC90;
	}
	return 0x8206DC90;
} // Block from 8206DC08h-8206DC90h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8206DC90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DC90);
		  /* 8206DC90h */ case    0:  		/* mfspr R12, LR */
		/* 8206DC90h case    0:*/		regs.R12 = regs.LR;
		/* 8206DC90h case    0:*/		return 0x8206DC94;
		  /* 8206DC94h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206DC94h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DC94h case    1:*/		return 0x8206DC98;
		  /* 8206DC98h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8206DC98h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8206DC98h case    2:*/		return 0x8206DC9C;
		  /* 8206DC9Ch */ case    3:  		/* lwz R11, <#[R3 + 19900]> */
		/* 8206DC9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00004DBC) );
		/* 8206DC9Ch case    3:*/		return 0x8206DCA0;
		  /* 8206DCA0h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 8206DCA0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206DCA0h case    4:*/		return 0x8206DCA4;
		  /* 8206DCA4h */ case    5:  		/* bc 4, CR6_LT, 12 */
		/* 8206DCA4h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8206DCB0;  }
		/* 8206DCA4h case    5:*/		return 0x8206DCA8;
		  /* 8206DCA8h */ case    6:  		/* li R3, 0 */
		/* 8206DCA8h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8206DCA8h case    6:*/		return 0x8206DCAC;
		  /* 8206DCACh */ case    7:  		/* b 28 */
		/* 8206DCACh case    7:*/		return 0x8206DCC8;
		/* 8206DCACh case    7:*/		return 0x8206DCB0;
	}
	return 0x8206DCB0;
} // Block from 8206DC90h-8206DCB0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206DCB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DCB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DCB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DCB0);
		  /* 8206DCB0h */ case    0:  		/* addi R5, R1, 80 */
		/* 8206DCB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8206DCB0h case    0:*/		return 0x8206DCB4;
		  /* 8206DCB4h */ case    1:  		/* addi R4, R1, 84 */
		/* 8206DCB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 8206DCB4h case    1:*/		return 0x8206DCB8;
		  /* 8206DCB8h */ case    2:  		/* bl -1288 */
		/* 8206DCB8h case    2:*/		regs.LR = 0x8206DCBC; return 0x8206D7B0;
		/* 8206DCB8h case    2:*/		return 0x8206DCBC;
		  /* 8206DCBCh */ case    3:  		/* lwz R10, <#[R1 + 80]> */
		/* 8206DCBCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8206DCBCh case    3:*/		return 0x8206DCC0;
		  /* 8206DCC0h */ case    4:  		/* lwz R11, <#[R1 + 84]> */
		/* 8206DCC0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8206DCC0h case    4:*/		return 0x8206DCC4;
		  /* 8206DCC4h */ case    5:  		/* add R3, R11, R10 */
		/* 8206DCC4h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8206DCC4h case    5:*/		return 0x8206DCC8;
	}
	return 0x8206DCC8;
} // Block from 8206DCB0h-8206DCC8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206DCC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DCC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DCC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DCC8);
		  /* 8206DCC8h */ case    0:  		/* addi R1, R1, 96 */
		/* 8206DCC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206DCC8h case    0:*/		return 0x8206DCCC;
		  /* 8206DCCCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206DCCCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DCCCh case    1:*/		return 0x8206DCD0;
		  /* 8206DCD0h */ case    2:  		/* mtspr LR, R12 */
		/* 8206DCD0h case    2:*/		regs.LR = regs.R12;
		/* 8206DCD0h case    2:*/		return 0x8206DCD4;
		  /* 8206DCD4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8206DCD4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206DCD4h case    3:*/		return 0x8206DCD8;
	}
	return 0x8206DCD8;
} // Block from 8206DCC8h-8206DCD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206DCD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DCD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DCD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DCD8);
		  /* 8206DCD8h */ case    0:  		/* mfspr R12, LR */
		/* 8206DCD8h case    0:*/		regs.R12 = regs.LR;
		/* 8206DCD8h case    0:*/		return 0x8206DCDC;
		  /* 8206DCDCh */ case    1:  		/* bl 144756 */
		/* 8206DCDCh case    1:*/		regs.LR = 0x8206DCE0; return 0x82091250;
		/* 8206DCDCh case    1:*/		return 0x8206DCE0;
		  /* 8206DCE0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8206DCE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8206DCE0h case    2:*/		return 0x8206DCE4;
		  /* 8206DCE4h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8206DCE4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206DCE4h case    3:*/		return 0x8206DCE8;
		  /* 8206DCE8h */ case    4:  		/* li R27, 0 */
		/* 8206DCE8h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8206DCE8h case    4:*/		return 0x8206DCEC;
		  /* 8206DCECh */ case    5:  		/* mr R31, R3 */
		/* 8206DCECh case    5:*/		regs.R31 = regs.R3;
		/* 8206DCECh case    5:*/		return 0x8206DCF0;
		  /* 8206DCF0h */ case    6:  		/* stw R27, <#[R3 + 120]> */
		/* 8206DCF0h case    6:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000078) );
		/* 8206DCF0h case    6:*/		return 0x8206DCF4;
		  /* 8206DCF4h */ case    7:  		/* mr R30, R4 */
		/* 8206DCF4h case    7:*/		regs.R30 = regs.R4;
		/* 8206DCF4h case    7:*/		return 0x8206DCF8;
		  /* 8206DCF8h */ case    8:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206DCF8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206DCF8h case    8:*/		return 0x8206DCFC;
		  /* 8206DCFCh */ case    9:  		/* nor R11, R11, R11 */
		/* 8206DCFCh case    9:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206DCFCh case    9:*/		return 0x8206DD00;
		  /* 8206DD00h */ case   10:  		/* rlwinm. R11, R11, 28, 31, 31 */
		/* 8206DD00h case   10:*/		cpu::op::rlwinm<1,28,31,31>(regs,&regs.R11,regs.R11);
		/* 8206DD00h case   10:*/		return 0x8206DD04;
		  /* 8206DD04h */ case   11:  		/* bc 12, CR0_EQ, 192 */
		/* 8206DD04h case   11:*/		if ( regs.CR[0].eq ) { return 0x8206DDC4;  }
		/* 8206DD04h case   11:*/		return 0x8206DD08;
		  /* 8206DD08h */ case   12:  		/* lwz R11, <#[R4 + 4]> */
		/* 8206DD08h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8206DD08h case   12:*/		return 0x8206DD0C;
		  /* 8206DD0Ch */ case   13:  		/* li R10, 1 */
		/* 8206DD0Ch case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8206DD0Ch case   13:*/		return 0x8206DD10;
		  /* 8206DD10h */ case   14:  		/* rlwinm R28, R11, 20, 28, 31 */
		/* 8206DD10h case   14:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R28,regs.R11);
		/* 8206DD10h case   14:*/		return 0x8206DD14;
		  /* 8206DD14h */ case   15:  		/* slw R29, R10, R28 */
		/* 8206DD14h case   15:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R10,regs.R28);
		/* 8206DD14h case   15:*/		return 0x8206DD18;
		  /* 8206DD18h */ case   16:  		/* andi. R11, R29, 28664 */
		/* 8206DD18h case   16:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R29,0x6FF8);
		/* 8206DD18h case   16:*/		return 0x8206DD1C;
		  /* 8206DD1Ch */ case   17:  		/* cmplwi CR0, R11, 0 */
		/* 8206DD1Ch case   17:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8206DD1Ch case   17:*/		return 0x8206DD20;
		  /* 8206DD20h */ case   18:  		/* bc 12, CR0_EQ, 52 */
		/* 8206DD20h case   18:*/		if ( regs.CR[0].eq ) { return 0x8206DD54;  }
		/* 8206DD20h case   18:*/		return 0x8206DD24;
		  /* 8206DD24h */ case   19:  		/* lwz R26, <#[R3 + 100]> */
		/* 8206DD24h case   19:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R3 + 0x00000064) );
		/* 8206DD24h case   19:*/		return 0x8206DD28;
		  /* 8206DD28h */ case   20:  		/* bl -528 */
		/* 8206DD28h case   20:*/		regs.LR = 0x8206DD2C; return 0x8206DB18;
		/* 8206DD28h case   20:*/		return 0x8206DD2C;
		  /* 8206DD2Ch */ case   21:  		/* lwz R11, <#[R31 + 100]> */
		/* 8206DD2Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 8206DD2Ch case   21:*/		return 0x8206DD30;
		  /* 8206DD30h */ case   22:  		/* subf. R10, R26, R11 */
		/* 8206DD30h case   22:*/		cpu::op::subf<1>(regs,&regs.R10,regs.R26,regs.R11);
		/* 8206DD30h case   22:*/		return 0x8206DD34;
		  /* 8206DD34h */ case   23:  		/* bc 12, CR0_EQ, 32 */
		/* 8206DD34h case   23:*/		if ( regs.CR[0].eq ) { return 0x8206DD54;  }
		/* 8206DD34h case   23:*/		return 0x8206DD38;
		  /* 8206DD38h */ case   24:  		/* andi. R11, R29, 24702 */
		/* 8206DD38h case   24:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R29,0x607E);
		/* 8206DD38h case   24:*/		return 0x8206DD3C;
		  /* 8206DD3Ch */ case   25:  		/* cmplwi CR0, R11, 0 */
		/* 8206DD3Ch case   25:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8206DD3Ch case   25:*/		return 0x8206DD40;
		  /* 8206DD40h */ case   26:  		/* bc 12, CR0_EQ, 20 */
		/* 8206DD40h case   26:*/		if ( regs.CR[0].eq ) { return 0x8206DD54;  }
		/* 8206DD40h case   26:*/		return 0x8206DD44;
		  /* 8206DD44h */ case   27:  		/* lwz R11, <#[R30]> */
		/* 8206DD44h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8206DD44h case   27:*/		return 0x8206DD48;
		  /* 8206DD48h */ case   28:  		/* add R10, R11, R10 */
		/* 8206DD48h case   28:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8206DD48h case   28:*/		return 0x8206DD4C;
		  /* 8206DD4Ch */ case   29:  		/* rlwimi R10, R11, 0, 0, 19 */
		/* 8206DD4Ch case   29:*/		cpu::op::rlwimi<0,0,0,19>(regs,&regs.R10,regs.R11);
		/* 8206DD4Ch case   29:*/		return 0x8206DD50;
		  /* 8206DD50h */ case   30:  		/* stw R10, <#[R30]> */
		/* 8206DD50h case   30:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8206DD50h case   30:*/		return 0x8206DD54;
	}
	return 0x8206DD54;
} // Block from 8206DCD8h-8206DD54h (31 instructions)

//////////////////////////////////////////////////////
// Block at 8206DD54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DD54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DD54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DD54);
		  /* 8206DD54h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8206DD54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206DD54h case    0:*/		return 0x8206DD58;
		  /* 8206DD58h */ case    1:  		/* lwz R11, <#[R11 + 19892]> */
		/* 8206DD58h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 8206DD58h case    1:*/		return 0x8206DD5C;
		  /* 8206DD5Ch */ case    2:  		/* nor R11, R11, R11 */
		/* 8206DD5Ch case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206DD5Ch case    2:*/		return 0x8206DD60;
	}
	return 0x8206DD60;
} // Block from 8206DD54h-8206DD60h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206DD60h
// Function '?DoEndExport512Pixels@@YAXPAUD3DDevice@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DD60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DD60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DD60);
		  /* 8206DD60h */ case    0:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 8206DD60h case    0:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8206DD60h case    0:*/		return 0x8206DD64;
		  /* 8206DD64h */ case    1:  		/* bc 12, CR0_EQ, 96 */
		/* 8206DD64h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206DDC4;  }
		/* 8206DD64h case    1:*/		return 0x8206DD68;
		  /* 8206DD68h */ case    2:  		/* cmplwi CR6, R28, 12 */
		/* 8206DD68h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x0000000C);
		/* 8206DD68h case    2:*/		return 0x8206DD6C;
		  /* 8206DD6Ch */ case    3:  		/* bc 4, CR6_EQ, 88 */
		/* 8206DD6Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8206DDC4;  }
		/* 8206DD6Ch case    3:*/		return 0x8206DD70;
		  /* 8206DD70h */ case    4:  		/* lwz R11, <#[R30 + 4]> */
		/* 8206DD70h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8206DD70h case    4:*/		return 0x8206DD74;
		  /* 8206DD74h */ case    5:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 8206DD74h case    5:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 8206DD74h case    5:*/		return 0x8206DD78;
		  /* 8206DD78h */ case    6:  		/* bc 4, CR0_EQ, 76 */
		/* 8206DD78h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8206DDC4;  }
		/* 8206DD78h case    6:*/		return 0x8206DD7C;
		  /* 8206DD7Ch */ case    7:  		/* li R5, 32 */
		/* 8206DD7Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206DD7Ch case    7:*/		return 0x8206DD80;
		  /* 8206DD80h */ case    8:  		/* stw R27, <#[R31 + 4]> */
		/* 8206DD80h case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000004) );
		/* 8206DD80h case    8:*/		return 0x8206DD84;
		  /* 8206DD84h */ case    9:  		/* li R4, 0 */
		/* 8206DD84h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206DD84h case    9:*/		return 0x8206DD88;
		  /* 8206DD88h */ case   10:  		/* stb R27, <#[R31 + 124]> */
		/* 8206DD88h case   10:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R31 + 0x0000007C) );
		/* 8206DD88h case   10:*/		return 0x8206DD8C;
		  /* 8206DD8Ch */ case   11:  		/* addi R3, R31, 128 */
		/* 8206DD8Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x80);
		/* 8206DD8Ch case   11:*/		return 0x8206DD90;
		  /* 8206DD90h */ case   12:  		/* bl 144816 */
		/* 8206DD90h case   12:*/		regs.LR = 0x8206DD94; return 0x82091340;
		/* 8206DD90h case   12:*/		return 0x8206DD94;
		  /* 8206DD94h */ case   13:  		/* li R5, 32 */
		/* 8206DD94h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206DD94h case   13:*/		return 0x8206DD98;
		  /* 8206DD98h */ case   14:  		/* li R4, 0 */
		/* 8206DD98h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206DD98h case   14:*/		return 0x8206DD9C;
		  /* 8206DD9Ch */ case   15:  		/* addi R3, R31, 160 */
		/* 8206DD9Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xA0);
		/* 8206DD9Ch case   15:*/		return 0x8206DDA0;
		  /* 8206DDA0h */ case   16:  		/* bl 144800 */
		/* 8206DDA0h case   16:*/		regs.LR = 0x8206DDA4; return 0x82091340;
		/* 8206DDA0h case   16:*/		return 0x8206DDA4;
		  /* 8206DDA4h */ case   17:  		/* li R5, 32 */
		/* 8206DDA4h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206DDA4h case   17:*/		return 0x8206DDA8;
		  /* 8206DDA8h */ case   18:  		/* li R4, 0 */
		/* 8206DDA8h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206DDA8h case   18:*/		return 0x8206DDAC;
		  /* 8206DDACh */ case   19:  		/* addi R3, R31, 192 */
		/* 8206DDACh case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xC0);
		/* 8206DDACh case   19:*/		return 0x8206DDB0;
		  /* 8206DDB0h */ case   20:  		/* bl 144784 */
		/* 8206DDB0h case   20:*/		regs.LR = 0x8206DDB4; return 0x82091340;
		/* 8206DDB0h case   20:*/		return 0x8206DDB4;
		  /* 8206DDB4h */ case   21:  		/* li R5, 32 */
		/* 8206DDB4h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 8206DDB4h case   21:*/		return 0x8206DDB8;
		  /* 8206DDB8h */ case   22:  		/* li R4, 0 */
		/* 8206DDB8h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206DDB8h case   22:*/		return 0x8206DDBC;
		  /* 8206DDBCh */ case   23:  		/* addi R3, R31, 224 */
		/* 8206DDBCh case   23:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xE0);
		/* 8206DDBCh case   23:*/		return 0x8206DDC0;
		  /* 8206DDC0h */ case   24:  		/* bl 144768 */
		/* 8206DDC0h case   24:*/		regs.LR = 0x8206DDC4; return 0x82091340;
		/* 8206DDC0h case   24:*/		return 0x8206DDC4;
	}
	return 0x8206DDC4;
} // Block from 8206DD60h-8206DDC4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8206DDC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DDC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DDC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DDC4);
		  /* 8206DDC4h */ case    0:  		/* addi R5, R31, 80 */
		/* 8206DDC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x50);
		/* 8206DDC4h case    0:*/		return 0x8206DDC8;
		  /* 8206DDC8h */ case    1:  		/* mr R4, R30 */
		/* 8206DDC8h case    1:*/		regs.R4 = regs.R30;
		/* 8206DDC8h case    1:*/		return 0x8206DDCC;
		  /* 8206DDCCh */ case    2:  		/* addi R3, R31, 108 */
		/* 8206DDCCh case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x6C);
		/* 8206DDCCh case    2:*/		return 0x8206DDD0;
		  /* 8206DDD0h */ case    3:  		/* bl -5064 */
		/* 8206DDD0h case    3:*/		regs.LR = 0x8206DDD4; return 0x8206CA08;
		/* 8206DDD0h case    3:*/		return 0x8206DDD4;
		  /* 8206DDD4h */ case    4:  		/* lwz R11, <#[R31 + 112]> */
		/* 8206DDD4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000070) );
		/* 8206DDD4h case    4:*/		return 0x8206DDD8;
		  /* 8206DDD8h */ case    5:  		/* addi R3, R11, -1 */
		/* 8206DDD8h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 8206DDD8h case    5:*/		return 0x8206DDDC;
		  /* 8206DDDCh */ case    6:  		/* addi R1, R1, 144 */
		/* 8206DDDCh case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8206DDDCh case    6:*/		return 0x8206DDE0;
		  /* 8206DDE0h */ case    7:  		/* b 144576 */
		/* 8206DDE0h case    7:*/		return 0x820912A0;
		/* 8206DDE0h case    7:*/		return 0x8206DDE4;
		  /* 8206DDE4h */ case    8:  		/* nop */
		/* 8206DDE4h case    8:*/		cpu::op::nop();
		/* 8206DDE4h case    8:*/		return 0x8206DDE8;
		  /* 8206DDE8h */ case    9:  		/* lwz R11, <#[R3]> */
		/* 8206DDE8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206DDE8h case    9:*/		return 0x8206DDEC;
		  /* 8206DDECh */ case   10:  		/* mulli R11, R11, 9936 */
		/* 8206DDECh case   10:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206DDECh case   10:*/		return 0x8206DDF0;
		  /* 8206DDF0h */ case   11:  		/* add R11, R11, R3 */
		/* 8206DDF0h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206DDF0h case   11:*/		return 0x8206DDF4;
		  /* 8206DDF4h */ case   12:  		/* addi R3, R11, 16 */
		/* 8206DDF4h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206DDF4h case   12:*/		return 0x8206DDF8;
		  /* 8206DDF8h */ case   13:  		/* b -288 */
		/* 8206DDF8h case   13:*/		return 0x8206DCD8;
		/* 8206DDF8h case   13:*/		return 0x8206DDFC;
		  /* 8206DDFCh */ case   14:  		/* nop */
		/* 8206DDFCh case   14:*/		cpu::op::nop();
		/* 8206DDFCh case   14:*/		return 0x8206DE00;
	}
	return 0x8206DE00;
} // Block from 8206DDC4h-8206DE00h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206DE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DE00);
		  /* 8206DE00h */ case    0:  		/* mfspr R12, LR */
		/* 8206DE00h case    0:*/		regs.R12 = regs.LR;
		/* 8206DE00h case    0:*/		return 0x8206DE04;
		  /* 8206DE04h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206DE04h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DE04h case    1:*/		return 0x8206DE08;
		  /* 8206DE08h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8206DE08h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206DE08h case    2:*/		return 0x8206DE0C;
		  /* 8206DE0Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8206DE0Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8206DE0Ch case    3:*/		return 0x8206DE10;
		  /* 8206DE10h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8206DE10h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206DE10h case    4:*/		return 0x8206DE14;
		  /* 8206DE14h */ case    5:  		/* mulli R11, R11, 9936 */
		/* 8206DE14h case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206DE14h case    5:*/		return 0x8206DE18;
		  /* 8206DE18h */ case    6:  		/* add R11, R11, R3 */
		/* 8206DE18h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206DE18h case    6:*/		return 0x8206DE1C;
		  /* 8206DE1Ch */ case    7:  		/* addi R31, R11, 16 */
		/* 8206DE1Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x10);
		/* 8206DE1Ch case    7:*/		return 0x8206DE20;
		  /* 8206DE20h */ case    8:  		/* mr R3, R31 */
		/* 8206DE20h case    8:*/		regs.R3 = regs.R31;
		/* 8206DE20h case    8:*/		return 0x8206DE24;
		  /* 8206DE24h */ case    9:  		/* bl -780 */
		/* 8206DE24h case    9:*/		regs.LR = 0x8206DE28; return 0x8206DB18;
		/* 8206DE24h case    9:*/		return 0x8206DE28;
		  /* 8206DE28h */ case   10:  		/* mr R3, R31 */
		/* 8206DE28h case   10:*/		regs.R3 = regs.R31;
		/* 8206DE28h case   10:*/		return 0x8206DE2C;
		  /* 8206DE2Ch */ case   11:  		/* bl -10156 */
		/* 8206DE2Ch case   11:*/		regs.LR = 0x8206DE30; return 0x8206B680;
		/* 8206DE2Ch case   11:*/		return 0x8206DE30;
		  /* 8206DE30h */ case   12:  		/* addi R1, R1, 96 */
		/* 8206DE30h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206DE30h case   12:*/		return 0x8206DE34;
		  /* 8206DE34h */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206DE34h case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DE34h case   13:*/		return 0x8206DE38;
		  /* 8206DE38h */ case   14:  		/* mtspr LR, R12 */
		/* 8206DE38h case   14:*/		regs.LR = regs.R12;
		/* 8206DE38h case   14:*/		return 0x8206DE3C;
		  /* 8206DE3Ch */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 8206DE3Ch case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206DE3Ch case   15:*/		return 0x8206DE40;
		  /* 8206DE40h */ case   16:  		/* bclr 20, CR0_LT */
		/* 8206DE40h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206DE40h case   16:*/		return 0x8206DE44;
	}
	return 0x8206DE44;
} // Block from 8206DE00h-8206DE44h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8206DE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DE44);
		  /* 8206DE44h */ case    0:  		/* nop */
		/* 8206DE44h case    0:*/		cpu::op::nop();
		/* 8206DE44h case    0:*/		return 0x8206DE48;
		  /* 8206DE48h */ case    1:  		/* b -440 */
		/* 8206DE48h case    1:*/		return 0x8206DC90;
		/* 8206DE48h case    1:*/		return 0x8206DE4C;
		  /* 8206DE4Ch */ case    2:  		/* nop */
		/* 8206DE4Ch case    2:*/		cpu::op::nop();
		/* 8206DE4Ch case    2:*/		return 0x8206DE50;
		  /* 8206DE50h */ case    3:  		/* addi R11, R3, 1 */
		/* 8206DE50h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x1);
		/* 8206DE50h case    3:*/		return 0x8206DE54;
		  /* 8206DE54h */ case    4:  		/* li R10, 10 */
		/* 8206DE54h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0xA);
		/* 8206DE54h case    4:*/		return 0x8206DE58;
		  /* 8206DE58h */ case    5:  		/* divwu R10, R11, R10 */
		/* 8206DE58h case    5:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8206DE58h case    5:*/		return 0x8206DE5C;
		  /* 8206DE5Ch */ case    6:  		/* mulli R10, R10, 10 */
		/* 8206DE5Ch case    6:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xA);
		/* 8206DE5Ch case    6:*/		return 0x8206DE60;
		  /* 8206DE60h */ case    7:  		/* subf R3, R10, R11 */
		/* 8206DE60h case    7:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8206DE60h case    7:*/		return 0x8206DE64;
		  /* 8206DE64h */ case    8:  		/* bclr 20, CR0_LT */
		/* 8206DE64h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206DE64h case    8:*/		return 0x8206DE68;
	}
	return 0x8206DE68;
} // Block from 8206DE44h-8206DE68h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206DE68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DE68);
		  /* 8206DE68h */ case    0:  		/* mfspr R12, LR */
		/* 8206DE68h case    0:*/		regs.R12 = regs.LR;
		/* 8206DE68h case    0:*/		return 0x8206DE6C;
		  /* 8206DE6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206DE6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DE6Ch case    1:*/		return 0x8206DE70;
		  /* 8206DE70h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8206DE70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8206DE70h case    2:*/		return 0x8206DE74;
		  /* 8206DE74h */ case    3:  		/* lis R9, -32216 */
		/* 8206DE74h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8228);
		/* 8206DE74h case    3:*/		return 0x8206DE78;
		  /* 8206DE78h */ case    4:  		/* lwz R3, <#[R9 + 28700]> */
		/* 8206DE78h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x0000701C) );
		/* 8206DE78h case    4:*/		return 0x8206DE7C;
		  /* 8206DE7Ch */ case    5:  		/* bl -44 */
		/* 8206DE7Ch case    5:*/		regs.LR = 0x8206DE80; return 0x8206DE50;
		/* 8206DE7Ch case    5:*/		return 0x8206DE80;
		  /* 8206DE80h */ case    6:  		/* lis R11, -32216 */
		/* 8206DE80h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8206DE80h case    6:*/		return 0x8206DE84;
		  /* 8206DE84h */ case    7:  		/* stw R3, <#[R9 + 28700]> */
		/* 8206DE84h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R9 + 0x0000701C) );
		/* 8206DE84h case    7:*/		return 0x8206DE88;
		  /* 8206DE88h */ case    8:  		/* lwz R3, <#[R11 + 28704]> */
		/* 8206DE88h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00007020) );
		/* 8206DE88h case    8:*/		return 0x8206DE8C;
		  /* 8206DE8Ch */ case    9:  		/* addi R1, R1, 96 */
		/* 8206DE8Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206DE8Ch case    9:*/		return 0x8206DE90;
		  /* 8206DE90h */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206DE90h case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206DE90h case   10:*/		return 0x8206DE94;
		  /* 8206DE94h */ case   11:  		/* mtspr LR, R12 */
		/* 8206DE94h case   11:*/		regs.LR = regs.R12;
		/* 8206DE94h case   11:*/		return 0x8206DE98;
		  /* 8206DE98h */ case   12:  		/* bclr 20, CR0_LT */
		/* 8206DE98h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206DE98h case   12:*/		return 0x8206DE9C;
	}
	return 0x8206DE9C;
} // Block from 8206DE68h-8206DE9Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206DE9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DE9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DE9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DE9C);
		  /* 8206DE9Ch */ case    0:  		/* nop */
		/* 8206DE9Ch case    0:*/		cpu::op::nop();
		/* 8206DE9Ch case    0:*/		return 0x8206DEA0;
	}
	return 0x8206DEA0;
} // Block from 8206DE9Ch-8206DEA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206DEA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DEA0);
		  /* 8206DEA0h */ case    0:  		/* mfspr R12, LR */
		/* 8206DEA0h case    0:*/		regs.R12 = regs.LR;
		/* 8206DEA0h case    0:*/		return 0x8206DEA4;
		  /* 8206DEA4h */ case    1:  		/* bl 144312 */
		/* 8206DEA4h case    1:*/		regs.LR = 0x8206DEA8; return 0x8209125C;
		/* 8206DEA4h case    1:*/		return 0x8206DEA8;
		  /* 8206DEA8h */ case    2:  		/* stwu R1, <#[R1 - 1648]> */
		/* 8206DEA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF990) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF990);
		/* 8206DEA8h case    2:*/		return 0x8206DEAC;
		  /* 8206DEACh */ case    3:  		/* lis R11, 10280 */
		/* 8206DEACh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x2828);
		/* 8206DEACh case    3:*/		return 0x8206DEB0;
		  /* 8206DEB0h */ case    4:  		/* mr R31, R4 */
		/* 8206DEB0h case    4:*/		regs.R31 = regs.R4;
		/* 8206DEB0h case    4:*/		return 0x8206DEB4;
		  /* 8206DEB4h */ case    5:  		/* mr R29, R3 */
		/* 8206DEB4h case    5:*/		regs.R29 = regs.R3;
		/* 8206DEB4h case    5:*/		return 0x8206DEB8;
		  /* 8206DEB8h */ case    6:  		/* mr R4, R5 */
		/* 8206DEB8h case    6:*/		regs.R4 = regs.R5;
		/* 8206DEB8h case    6:*/		return 0x8206DEBC;
		  /* 8206DEBCh */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 8206DEBCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8206DEBCh case    7:*/		return 0x8206DEC0;
		  /* 8206DEC0h */ case    8:  		/* ori R30, R11, 310 */
		/* 8206DEC0h case    8:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R11,0x136);
		/* 8206DEC0h case    8:*/		return 0x8206DEC4;
		  /* 8206DEC4h */ case    9:  		/* bc 4, CR6_EQ, 48 */
		/* 8206DEC4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8206DEF4;  }
		/* 8206DEC4h case    9:*/		return 0x8206DEC8;
		  /* 8206DEC8h */ case   10:  		/* cmpwi CR6, R6, 0 */
		/* 8206DEC8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 8206DEC8h case   10:*/		return 0x8206DECC;
		  /* 8206DECCh */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 8206DECCh case   11:*/		if ( regs.CR[6].eq ) { return 0x8206DEF4;  }
		/* 8206DECCh case   11:*/		return 0x8206DED0;
		  /* 8206DED0h */ case   12:  		/* cmpw CR6, R31, R30 */
		/* 8206DED0h case   12:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R30);
		/* 8206DED0h case   12:*/		return 0x8206DED4;
		  /* 8206DED4h */ case   13:  		/* li R4, 1 */
		/* 8206DED4h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8206DED4h case   13:*/		return 0x8206DED8;
		  /* 8206DED8h */ case   14:  		/* addi R3, R1, 80 */
		/* 8206DED8h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8206DED8h case   14:*/		return 0x8206DEDC;
		  /* 8206DEDCh */ case   15:  		/* bc 4, CR6_EQ, 16 */
		/* 8206DEDCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x8206DEEC;  }
		/* 8206DEDCh case   15:*/		return 0x8206DEE0;
		  /* 8206DEE0h */ case   16:  		/* bl 29696 */
		/* 8206DEE0h case   16:*/		regs.LR = 0x8206DEE4; return 0x820752E0;
		/* 8206DEE0h case   16:*/		return 0x8206DEE4;
		  /* 8206DEE4h */ case   17:  		/* addi R4, R1, 80 */
		/* 8206DEE4h case   17:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206DEE4h case   17:*/		return 0x8206DEE8;
		  /* 8206DEE8h */ case   18:  		/* b 20 */
		/* 8206DEE8h case   18:*/		return 0x8206DEFC;
		/* 8206DEE8h case   18:*/		return 0x8206DEEC;
	}
	return 0x8206DEEC;
} // Block from 8206DEA0h-8206DEECh (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206DEECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DEEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DEEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DEEC);
		  /* 8206DEECh */ case    0:  		/* bl 29612 */
		/* 8206DEECh case    0:*/		regs.LR = 0x8206DEF0; return 0x82075298;
		/* 8206DEECh case    0:*/		return 0x8206DEF0;
		  /* 8206DEF0h */ case    1:  		/* addi R4, R1, 80 */
		/* 8206DEF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206DEF0h case    1:*/		return 0x8206DEF4;
	}
	return 0x8206DEF4;
} // Block from 8206DEECh-8206DEF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206DEF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DEF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DEF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DEF4);
		  /* 8206DEF4h */ case    0:  		/* cmpw CR6, R31, R30 */
		/* 8206DEF4h case    0:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R30);
		/* 8206DEF4h case    0:*/		return 0x8206DEF8;
		  /* 8206DEF8h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8206DEF8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8206DF08;  }
		/* 8206DEF8h case    1:*/		return 0x8206DEFC;
	}
	return 0x8206DEFC;
} // Block from 8206DEF4h-8206DEFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206DEFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DEFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DEFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DEFC);
		  /* 8206DEFCh */ case    0:  		/* mr R3, R29 */
		/* 8206DEFCh case    0:*/		regs.R3 = regs.R29;
		/* 8206DEFCh case    0:*/		return 0x8206DF00;
		  /* 8206DF00h */ case    1:  		/* bl 29288 */
		/* 8206DF00h case    1:*/		regs.LR = 0x8206DF04; return 0x82075168;
		/* 8206DF00h case    1:*/		return 0x8206DF04;
		  /* 8206DF04h */ case    2:  		/* b 12 */
		/* 8206DF04h case    2:*/		return 0x8206DF10;
		/* 8206DF04h case    2:*/		return 0x8206DF08;
	}
	return 0x8206DF08;
} // Block from 8206DEFCh-8206DF08h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206DF08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DF08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DF08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DF08);
		  /* 8206DF08h */ case    0:  		/* mr R3, R29 */
		/* 8206DF08h case    0:*/		regs.R3 = regs.R29;
		/* 8206DF08h case    0:*/		return 0x8206DF0C;
		  /* 8206DF0Ch */ case    1:  		/* bl 29036 */
		/* 8206DF0Ch case    1:*/		regs.LR = 0x8206DF10; return 0x82075078;
		/* 8206DF0Ch case    1:*/		return 0x8206DF10;
	}
	return 0x8206DF10;
} // Block from 8206DF08h-8206DF10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206DF10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DF10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DF10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DF10);
		  /* 8206DF10h */ case    0:  		/* addi R1, R1, 1648 */
		/* 8206DF10h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x670);
		/* 8206DF10h case    0:*/		return 0x8206DF14;
		  /* 8206DF14h */ case    1:  		/* b 144280 */
		/* 8206DF14h case    1:*/		return 0x820912AC;
		/* 8206DF14h case    1:*/		return 0x8206DF18;
	}
	return 0x8206DF18;
} // Block from 8206DF10h-8206DF18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206DF18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DF18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DF18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DF18);
		  /* 8206DF18h */ case    0:  		/* mfspr R12, LR */
		/* 8206DF18h case    0:*/		regs.R12 = regs.LR;
		/* 8206DF18h case    0:*/		return 0x8206DF1C;
		  /* 8206DF1Ch */ case    1:  		/* bl 144192 */
		/* 8206DF1Ch case    1:*/		regs.LR = 0x8206DF20; return 0x8209125C;
		/* 8206DF1Ch case    1:*/		return 0x8206DF20;
		  /* 8206DF20h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206DF20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206DF20h case    2:*/		return 0x8206DF24;
		  /* 8206DF24h */ case    3:  		/* addi R30, R3, 17120 */
		/* 8206DF24h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x42E0);
		/* 8206DF24h case    3:*/		return 0x8206DF28;
		  /* 8206DF28h */ case    4:  		/* mr R31, R3 */
		/* 8206DF28h case    4:*/		regs.R31 = regs.R3;
		/* 8206DF28h case    4:*/		return 0x8206DF2C;
		  /* 8206DF2Ch */ case    5:  		/* mr R3, R30 */
		/* 8206DF2Ch case    5:*/		regs.R3 = regs.R30;
		/* 8206DF2Ch case    5:*/		return 0x8206DF30;
		  /* 8206DF30h */ case    6:  		/* bl 2093048 */
		/* 8206DF30h case    6:*/		regs.LR = 0x8206DF34; return 0x8226CF28;
		/* 8206DF30h case    6:*/		return 0x8206DF34;
		  /* 8206DF34h */ case    7:  		/* lwz R11, <#[R31 + 16952]> */
		/* 8206DF34h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00004238) );
		/* 8206DF34h case    7:*/		return 0x8206DF38;
		  /* 8206DF38h */ case    8:  		/* mr R29, R3 */
		/* 8206DF38h case    8:*/		regs.R29 = regs.R3;
		/* 8206DF38h case    8:*/		return 0x8206DF3C;
		  /* 8206DF3Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 8206DF3Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206DF3Ch case    9:*/		return 0x8206DF40;
		  /* 8206DF40h */ case   10:  		/* stw R11, <#[R31 + 16952]> */
		/* 8206DF40h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00004238) );
		/* 8206DF40h case   10:*/		return 0x8206DF44;
		  /* 8206DF44h */ case   11:  		/* mftb R11, 12, 8 */
		/* 8206DF44h case   11:*/		cpu::op::mftb<0>(regs,&regs.R11,0xC,0x8);
		/* 8206DF44h case   11:*/		return 0x8206DF48;
		  /* 8206DF48h */ case   12:  		/* lwz R10, <#[R31 + 17112]> */
		/* 8206DF48h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000042D8) );
		/* 8206DF48h case   12:*/		return 0x8206DF4C;
		  /* 8206DF4Ch */ case   13:  		/* li R9, 0 */
		/* 8206DF4Ch case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8206DF4Ch case   13:*/		return 0x8206DF50;
		  /* 8206DF50h */ case   14:  		/* lwz R8, <#[R31 + 17108]> */
		/* 8206DF50h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x000042D4) );
		/* 8206DF50h case   14:*/		return 0x8206DF54;
		  /* 8206DF54h */ case   15:  		/* stw R11, <#[R31 + 16956]> */
		/* 8206DF54h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000423C) );
		/* 8206DF54h case   15:*/		return 0x8206DF58;
		  /* 8206DF58h */ case   16:  		/* cmplw CR6, R8, R10 */
		/* 8206DF58h case   16:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 8206DF58h case   16:*/		return 0x8206DF5C;
		  /* 8206DF5Ch */ case   17:  		/* bc 12, CR6_EQ, 132 */
		/* 8206DF5Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x8206DFE0;  }
		/* 8206DF5Ch case   17:*/		return 0x8206DF60;
		  /* 8206DF60h */ case   18:  		/* lwz R11, <#[R31 + 17108]> */
		/* 8206DF60h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000042D4) );
		/* 8206DF60h case   18:*/		return 0x8206DF64;
		  /* 8206DF64h */ case   19:  		/* lwz R8, <#[R31 + 16952]> */
		/* 8206DF64h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00004238) );
		/* 8206DF64h case   19:*/		return 0x8206DF68;
		  /* 8206DF68h */ case   20:  		/* rlwinm R11, R11, 3, 25, 28 */
		/* 8206DF68h case   20:*/		cpu::op::rlwinm<0,3,25,28>(regs,&regs.R11,regs.R11);
		/* 8206DF68h case   20:*/		return 0x8206DF6C;
		  /* 8206DF6Ch */ case   21:  		/* add R11, R11, R31 */
		/* 8206DF6Ch case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8206DF6Ch case   21:*/		return 0x8206DF70;
		  /* 8206DF70h */ case   22:  		/* addi R10, R11, 16980 */
		/* 8206DF70h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4254);
		/* 8206DF70h case   22:*/		return 0x8206DF74;
		  /* 8206DF74h */ case   23:  		/* lwz R10, <#[R11 + 16984]> */
		/* 8206DF74h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00004258) );
		/* 8206DF74h case   23:*/		return 0x8206DF78;
		  /* 8206DF78h */ case   24:  		/* lwz R11, <#[R11 + 16980]> */
		/* 8206DF78h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004254) );
		/* 8206DF78h case   24:*/		return 0x8206DF7C;
		  /* 8206DF7Ch */ case   25:  		/* cmplw CR6, R10, R8 */
		/* 8206DF7Ch case   25:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8206DF7Ch case   25:*/		return 0x8206DF80;
		  /* 8206DF80h */ case   26:  		/* bc 12, CR6_GT, 96 */
		/* 8206DF80h case   26:*/		if ( regs.CR[6].gt ) { return 0x8206DFE0;  }
		/* 8206DF80h case   26:*/		return 0x8206DF84;
		  /* 8206DF84h */ case   27:  		/* lwz R10, <#[R31 + 16976]> */
		/* 8206DF84h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00004250) );
		/* 8206DF84h case   27:*/		return 0x8206DF88;
		  /* 8206DF88h */ case   28:  		/* cmplwi CR6, R11, 0 */
		/* 8206DF88h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206DF88h case   28:*/		return 0x8206DF8C;
		  /* 8206DF8Ch */ case   29:  		/* lwz R8, <#[R31 + 16956]> */
		/* 8206DF8Ch case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000423C) );
		/* 8206DF8Ch case   29:*/		return 0x8206DF90;
		  /* 8206DF90h */ case   30:  		/* addi R10, R10, 1 */
		/* 8206DF90h case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8206DF90h case   30:*/		return 0x8206DF94;
		  /* 8206DF94h */ case   31:  		/* stw R10, <#[R31 + 16976]> */
		/* 8206DF94h case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00004250) );
		/* 8206DF94h case   31:*/		return 0x8206DF98;
		  /* 8206DF98h */ case   32:  		/* stw R8, <#[R31 + 16964]> */
		/* 8206DF98h case   32:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00004244) );
		/* 8206DF98h case   32:*/		return 0x8206DF9C;
		  /* 8206DF9Ch */ case   33:  		/* bc 4, CR6_EQ, 16 */
		/* 8206DF9Ch case   33:*/		if ( !regs.CR[6].eq ) { return 0x8206DFAC;  }
		/* 8206DF9Ch case   33:*/		return 0x8206DFA0;
		  /* 8206DFA0h */ case   34:  		/* lwz R11, <#[R31 + 11028]> */
		/* 8206DFA0h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B14) );
		/* 8206DFA0h case   34:*/		return 0x8206DFA4;
		  /* 8206DFA4h */ case   35:  		/* stw R9, <#[R11 + 4]> */
		/* 8206DFA4h case   35:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8206DFA4h case   35:*/		return 0x8206DFA8;
		  /* 8206DFA8h */ case   36:  		/* b 20 */
		/* 8206DFA8h case   36:*/		return 0x8206DFBC;
		/* 8206DFA8h case   36:*/		return 0x8206DFAC;
	}
	return 0x8206DFAC;
} // Block from 8206DF18h-8206DFACh (37 instructions)

//////////////////////////////////////////////////////
// Block at 8206DFACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DFAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DFAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DFAC);
		  /* 8206DFACh */ case    0:  		/* lis R10, 32712 */
		/* 8206DFACh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FC8);
		/* 8206DFACh case    0:*/		return 0x8206DFB0;
		  /* 8206DFB0h */ case    1:  		/* stw R11, <#[R10 + 24848]> */
		/* 8206DFB0h case    1:*/		regs.IO->MEM_WRITE( 0x8206DFB0, (uint32)(regs.R10 + 0x00006110), 4, &regs.R11 );
		/* 8206DFB0h case    1:*/		return 0x8206DFB4;
		  /* 8206DFB4h */ case    2:  		/* eieio */
		/* 8206DFB4h case    2:*/		cpu::op::eieio<0>(regs);
		/* 8206DFB4h case    2:*/		return 0x8206DFB8;
		  /* 8206DFB8h */ case    3:  		/* sync */
		/* 8206DFB8h case    3:*/		cpu::op::sync<0>(regs);
		/* 8206DFB8h case    3:*/		return 0x8206DFBC;
	}
	return 0x8206DFBC;
} // Block from 8206DFACh-8206DFBCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206DFBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DFBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DFBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DFBC);
		  /* 8206DFBCh */ case    0:  		/* mftb R10, 12, 8 */
		/* 8206DFBCh case    0:*/		cpu::op::mftb<0>(regs,&regs.R10,0xC,0x8);
		/* 8206DFBCh case    0:*/		return 0x8206DFC0;
		  /* 8206DFC0h */ case    1:  		/* lwz R11, <#[R31 + 17108]> */
		/* 8206DFC0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000042D4) );
		/* 8206DFC0h case    1:*/		return 0x8206DFC4;
		  /* 8206DFC4h */ case    2:  		/* stw R10, <#[R31 + 23788]> */
		/* 8206DFC4h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00005CEC) );
		/* 8206DFC4h case    2:*/		return 0x8206DFC8;
		  /* 8206DFC8h */ case    3:  		/* addi R11, R11, 1 */
		/* 8206DFC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206DFC8h case    3:*/		return 0x8206DFCC;
		  /* 8206DFCCh */ case    4:  		/* stw R11, <#[R31 + 17108]> */
		/* 8206DFCCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000042D4) );
		/* 8206DFCCh case    4:*/		return 0x8206DFD0;
		  /* 8206DFD0h */ case    5:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8206DFD0h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8206DFD0h case    5:*/		return 0x8206DFD4;
		  /* 8206DFD4h */ case    6:  		/* lwz R10, <#[R31 + 17112]> */
		/* 8206DFD4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000042D8) );
		/* 8206DFD4h case    6:*/		return 0x8206DFD8;
		  /* 8206DFD8h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 8206DFD8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8206DFD8h case    7:*/		return 0x8206DFDC;
		  /* 8206DFDCh */ case    8:  		/* bc 4, CR6_EQ, -124 */
		/* 8206DFDCh case    8:*/		if ( !regs.CR[6].eq ) { return 0x8206DF60;  }
		/* 8206DFDCh case    8:*/		return 0x8206DFE0;
	}
	return 0x8206DFE0;
} // Block from 8206DFBCh-8206DFE0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206DFE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206DFE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206DFE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206DFE0);
		  /* 8206DFE0h */ case    0:  		/* lwz R11, <#[R31 + 16948]> */
		/* 8206DFE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00004234) );
		/* 8206DFE0h case    0:*/		return 0x8206DFE4;
		  /* 8206DFE4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8206DFE4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206DFE4h case    1:*/		return 0x8206DFE8;
		  /* 8206DFE8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 8206DFE8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206E00C;  }
		/* 8206DFE8h case    2:*/		return 0x8206DFEC;
		  /* 8206DFECh */ case    3:  		/* lwz R10, <#[R31 + 16976]> */
		/* 8206DFECh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00004250) );
		/* 8206DFECh case    3:*/		return 0x8206DFF0;
		  /* 8206DFF0h */ case    4:  		/* addi R3, R1, 80 */
		/* 8206DFF0h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8206DFF0h case    4:*/		return 0x8206DFF4;
		  /* 8206DFF4h */ case    5:  		/* lwz R8, <#[R31 + 16952]> */
		/* 8206DFF4h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00004238) );
		/* 8206DFF4h case    5:*/		return 0x8206DFF8;
		  /* 8206DFF8h */ case    6:  		/* mtspr CTR, R11 */
		/* 8206DFF8h case    6:*/		regs.CTR = regs.R11;
		/* 8206DFF8h case    6:*/		return 0x8206DFFC;
		  /* 8206DFFCh */ case    7:  		/* stw R9, <#[R1 + 88]> */
		/* 8206DFFCh case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 8206DFFCh case    7:*/		return 0x8206E000;
		  /* 8206E000h */ case    8:  		/* stw R10, <#[R1 + 84]> */
		/* 8206E000h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 8206E000h case    8:*/		return 0x8206E004;
		  /* 8206E004h */ case    9:  		/* stw R8, <#[R1 + 80]> */
		/* 8206E004h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8206E004h case    9:*/		return 0x8206E008;
		  /* 8206E008h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 8206E008h case   10:*/		if ( 1 ) { regs.LR = 0x8206E00C; return (uint32)regs.CTR; }
		/* 8206E008h case   10:*/		return 0x8206E00C;
	}
	return 0x8206E00C;
} // Block from 8206DFE0h-8206E00Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206E00Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E00C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E00C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E00C);
		  /* 8206E00Ch */ case    0:  		/* li R5, 0 */
		/* 8206E00Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8206E00Ch case    0:*/		return 0x8206E010;
		  /* 8206E010h */ case    1:  		/* li R4, 1 */
		/* 8206E010h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8206E010h case    1:*/		return 0x8206E014;
		  /* 8206E014h */ case    2:  		/* addi R3, R31, 24460 */
		/* 8206E014h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x5F8C);
		/* 8206E014h case    2:*/		return 0x8206E018;
		  /* 8206E018h */ case    3:  		/* bl 2092800 */
		/* 8206E018h case    3:*/		regs.LR = 0x8206E01C; return 0x8226CF18;
		/* 8206E018h case    3:*/		return 0x8206E01C;
		  /* 8206E01Ch */ case    4:  		/* addi R3, R1, 80 */
		/* 8206E01Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8206E01Ch case    4:*/		return 0x8206E020;
		  /* 8206E020h */ case    5:  		/* bl 104848 */
		/* 8206E020h case    5:*/		regs.LR = 0x8206E024; return 0x820879B0;
		/* 8206E020h case    5:*/		return 0x8206E024;
		  /* 8206E024h */ case    6:  		/* ld R11, <#[R1 + 80]> */
		/* 8206E024h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206E024h case    6:*/		return 0x8206E028;
		  /* 8206E028h */ case    7:  		/* mr R4, R29 */
		/* 8206E028h case    7:*/		regs.R4 = regs.R29;
		/* 8206E028h case    7:*/		return 0x8206E02C;
		  /* 8206E02Ch */ case    8:  		/* sradi R11, R11, 10 */
		/* 8206E02Ch case    8:*/		cpu::op::sradi<0,10>(regs,&regs.R11,regs.R11);
		/* 8206E02Ch case    8:*/		return 0x8206E030;
		  /* 8206E030h */ case    9:  		/* mr R3, R30 */
		/* 8206E030h case    9:*/		regs.R3 = regs.R30;
		/* 8206E030h case    9:*/		return 0x8206E034;
		  /* 8206E034h */ case   10:  		/* stw R11, <#[R31 + 22084]> */
		/* 8206E034h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00005644) );
		/* 8206E034h case   10:*/		return 0x8206E038;
		  /* 8206E038h */ case   11:  		/* bl 2092752 */
		/* 8206E038h case   11:*/		regs.LR = 0x8206E03C; return 0x8226CF08;
		/* 8206E038h case   11:*/		return 0x8206E03C;
		  /* 8206E03Ch */ case   12:  		/* addi R1, R1, 128 */
		/* 8206E03Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206E03Ch case   12:*/		return 0x8206E040;
		  /* 8206E040h */ case   13:  		/* b 143980 */
		/* 8206E040h case   13:*/		return 0x820912AC;
		/* 8206E040h case   13:*/		return 0x8206E044;
		  /* 8206E044h */ case   14:  		/* nop */
		/* 8206E044h case   14:*/		cpu::op::nop();
		/* 8206E044h case   14:*/		return 0x8206E048;
	}
	return 0x8206E048;
} // Block from 8206E00Ch-8206E048h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206E048h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E048);
		  /* 8206E048h */ case    0:  		/* mfspr R12, LR */
		/* 8206E048h case    0:*/		regs.R12 = regs.LR;
		/* 8206E048h case    0:*/		return 0x8206E04C;
		  /* 8206E04Ch */ case    1:  		/* bl 143868 */
		/* 8206E04Ch case    1:*/		regs.LR = 0x8206E050; return 0x82091248;
		/* 8206E04Ch case    1:*/		return 0x8206E050;
		  /* 8206E050h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8206E050h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8206E050h case    2:*/		return 0x8206E054;
		  /* 8206E054h */ case    3:  		/* mr R30, R3 */
		/* 8206E054h case    3:*/		regs.R30 = regs.R3;
		/* 8206E054h case    3:*/		return 0x8206E058;
		  /* 8206E058h */ case    4:  		/* bl 2092704 */
		/* 8206E058h case    4:*/		regs.LR = 0x8206E05C; return 0x8226CEF8;
		/* 8206E058h case    4:*/		return 0x8206E05C;
		  /* 8206E05Ch */ case    5:  		/* cmpwi CR6, R3, 2 */
		/* 8206E05Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 8206E05Ch case    5:*/		return 0x8206E060;
		  /* 8206E060h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 8206E060h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8206E070;  }
		/* 8206E060h case    6:*/		return 0x8206E064;
		  /* 8206E064h */ case    7:  		/* lis R11, -32256 */
		/* 8206E064h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8206E064h case    7:*/		return 0x8206E068;
		  /* 8206E068h */ case    8:  		/* lwz R11, <#[R11 + 1452]> */
		/* 8206E068h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005AC) );
		/* 8206E068h case    8:*/		return 0x8206E06C;
		  /* 8206E06Ch */ case    9:  		/* b 12 */
		/* 8206E06Ch case    9:*/		return 0x8206E078;
		/* 8206E06Ch case    9:*/		return 0x8206E070;
	}
	return 0x8206E070;
} // Block from 8206E048h-8206E070h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206E070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E070);
		  /* 8206E070h */ case    0:  		/* lis R11, -32256 */
		/* 8206E070h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8206E070h case    0:*/		return 0x8206E074;
		  /* 8206E074h */ case    1:  		/* lwz R11, <#[R11 + 1456]> */
		/* 8206E074h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005B0) );
		/* 8206E074h case    1:*/		return 0x8206E078;
	}
	return 0x8206E078;
} // Block from 8206E070h-8206E078h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206E078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E078);
		  /* 8206E078h */ case    0:  		/* lwz R31, <#[R11]> */
		/* 8206E078h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 8206E078h case    0:*/		return 0x8206E07C;
		  /* 8206E07Ch */ case    1:  		/* addi R26, R31, 17120 */
		/* 8206E07Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R31,0x42E0);
		/* 8206E07Ch case    1:*/		return 0x8206E080;
		  /* 8206E080h */ case    2:  		/* mr R3, R26 */
		/* 8206E080h case    2:*/		regs.R3 = regs.R26;
		/* 8206E080h case    2:*/		return 0x8206E084;
		  /* 8206E084h */ case    3:  		/* bl 2092708 */
		/* 8206E084h case    3:*/		regs.LR = 0x8206E088; return 0x8226CF28;
		/* 8206E084h case    3:*/		return 0x8206E088;
		  /* 8206E088h */ case    4:  		/* lwz R10, <#[R31 + 16972]> */
		/* 8206E088h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000424C) );
		/* 8206E088h case    4:*/		return 0x8206E08C;
		  /* 8206E08Ch */ case    5:  		/* lwz R11, <#[R31 + 21964]> */
		/* 8206E08Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000055CC) );
		/* 8206E08Ch case    5:*/		return 0x8206E090;
		  /* 8206E090h */ case    6:  		/* rlwinm R29, R30, 24, 28, 31 */
		/* 8206E090h case    6:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R29,regs.R30);
		/* 8206E090h case    6:*/		return 0x8206E094;
		  /* 8206E094h */ case    7:  		/* addi R10, R10, 1 */
		/* 8206E094h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8206E094h case    7:*/		return 0x8206E098;
		  /* 8206E098h */ case    8:  		/* rlwinm R27, R30, 0, 24, 31 */
		/* 8206E098h case    8:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R27,regs.R30);
		/* 8206E098h case    8:*/		return 0x8206E09C;
		  /* 8206E09Ch */ case    9:  		/* mr R25, R3 */
		/* 8206E09Ch case    9:*/		regs.R25 = regs.R3;
		/* 8206E09Ch case    9:*/		return 0x8206E0A0;
		  /* 8206E0A0h */ case   10:  		/* stw R10, <#[R31 + 16972]> */
		/* 8206E0A0h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000424C) );
		/* 8206E0A0h case   10:*/		return 0x8206E0A4;
		  /* 8206E0A4h */ case   11:  		/* rlwinm R30, R30, 0, 0, 19 */
		/* 8206E0A4h case   11:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R30,regs.R30);
		/* 8206E0A4h case   11:*/		return 0x8206E0A8;
		  /* 8206E0A8h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 8206E0A8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206E0A8h case   12:*/		return 0x8206E0AC;
		  /* 8206E0ACh */ case   13:  		/* mr R28, R11 */
		/* 8206E0ACh case   13:*/		regs.R28 = regs.R11;
		/* 8206E0ACh case   13:*/		return 0x8206E0B0;
		  /* 8206E0B0h */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 8206E0B0h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8206E0B8;  }
		/* 8206E0B0h case   14:*/		return 0x8206E0B4;
		  /* 8206E0B4h */ case   15:  		/* li R28, 60 */
		/* 8206E0B4h case   15:*/		cpu::op::li<0>(regs,&regs.R28,0x3C);
		/* 8206E0B4h case   15:*/		return 0x8206E0B8;
	}
	return 0x8206E0B8;
} // Block from 8206E078h-8206E0B8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206E0B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E0B8);
		  /* 8206E0B8h */ case    0:  		/* mftb R11, 12, 8 */
		/* 8206E0B8h case    0:*/		cpu::op::mftb<0>(regs,&regs.R11,0xC,0x8);
		/* 8206E0B8h case    0:*/		return 0x8206E0BC;
		  /* 8206E0BCh */ case    1:  		/* lwz R10, <#[R31 + 16956]> */
		/* 8206E0BCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000423C) );
		/* 8206E0BCh case    1:*/		return 0x8206E0C0;
		  /* 8206E0C0h */ case    2:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8206E0C0h case    2:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8206E0C0h case    2:*/		return 0x8206E0C4;
		  /* 8206E0C4h */ case    3:  		/* subf R24, R10, R11 */
		/* 8206E0C4h case    3:*/		cpu::op::subf<0>(regs,&regs.R24,regs.R10,regs.R11);
		/* 8206E0C4h case    3:*/		return 0x8206E0C8;
		  /* 8206E0C8h */ case    4:  		/* bl 2092656 */
		/* 8206E0C8h case    4:*/		regs.LR = 0x8206E0CC; return 0x8226CF38;
		/* 8206E0C8h case    4:*/		return 0x8206E0CC;
		  /* 8206E0CCh */ case    5:  		/* rlwinm R11, R3, 0, 0, 31 */
		/* 8206E0CCh case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R3);
		/* 8206E0CCh case    5:*/		return 0x8206E0D0;
		  /* 8206E0D0h */ case    6:  		/* mulli R10, R24, 100 */
		/* 8206E0D0h case    6:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R24,0x64);
		/* 8206E0D0h case    6:*/		return 0x8206E0D4;
		  /* 8206E0D4h */ case    7:  		/* divwu R11, R11, R28 */
		/* 8206E0D4h case    7:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8206E0D4h case    7:*/		return 0x8206E0D8;
		  /* 8206E0D8h */ case    8:  		/* twi 6, R28, 0 */
		/* 8206E0D8h case    8:*/		cpu::op::tw<6>(regs, 0x8206E0D8, regs.R28, 0x00000000);
		/* 8206E0D8h case    8:*/		return 0x8206E0DC;
		  /* 8206E0DCh */ case    9:  		/* twi 6, R11, 0 */
		/* 8206E0DCh case    9:*/		cpu::op::tw<6>(regs, 0x8206E0DC, regs.R11, 0x00000000);
		/* 8206E0DCh case    9:*/		return 0x8206E0E0;
		  /* 8206E0E0h */ case   10:  		/* divwu R11, R10, R11 */
		/* 8206E0E0h case   10:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206E0E0h case   10:*/		return 0x8206E0E4;
		  /* 8206E0E4h */ case   11:  		/* addi R7, R11, 1 */
		/* 8206E0E4h case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x1);
		/* 8206E0E4h case   11:*/		return 0x8206E0E8;
	}
	return 0x8206E0E8;
} // Block from 8206E0B8h-8206E0E8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206E0E8h
// Function 'D3DDevice_BeginExport'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E0E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E0E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E0E8);
		  /* 8206E0E8h */ case    0:  		/* cmplwi CR6, R7, 100 */
		/* 8206E0E8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000064);
		/* 8206E0E8h case    0:*/		return 0x8206E0EC;
		  /* 8206E0ECh */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 8206E0ECh case    1:*/		if ( !regs.CR[6].gt ) { return 0x8206E0F4;  }
		/* 8206E0ECh case    1:*/		return 0x8206E0F0;
		  /* 8206E0F0h */ case    2:  		/* li R7, 100 */
		/* 8206E0F0h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x64);
		/* 8206E0F0h case    2:*/		return 0x8206E0F4;
	}
	return 0x8206E0F4;
} // Block from 8206E0E8h-8206E0F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206E0F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E0F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E0F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E0F4);
		  /* 8206E0F4h */ case    0:  		/* lwz R8, <#[R31 + 16960]> */
		/* 8206E0F4h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00004240) );
		/* 8206E0F4h case    0:*/		return 0x8206E0F8;
		  /* 8206E0F8h */ case    1:  		/* lwz R10, <#[R31 + 16952]> */
		/* 8206E0F8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00004238) );
		/* 8206E0F8h case    1:*/		return 0x8206E0FC;
		  /* 8206E0FCh */ case    2:  		/* add R11, R8, R29 */
		/* 8206E0FCh case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R29);
		/* 8206E0FCh case    2:*/		return 0x8206E100;
		  /* 8206E100h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 8206E100h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8206E100h case    3:*/		return 0x8206E104;
		  /* 8206E104h */ case    4:  		/* bc 12, CR6_GT, 28 */
		/* 8206E104h case    4:*/		if ( regs.CR[6].gt ) { return 0x8206E120;  }
		/* 8206E104h case    4:*/		return 0x8206E108;
		  /* 8206E108h */ case    5:  		/* mr R11, R10 */
		/* 8206E108h case    5:*/		regs.R11 = regs.R10;
		/* 8206E108h case    5:*/		return 0x8206E10C;
		  /* 8206E10Ch */ case    6:  		/* cmplwi CR6, R29, 0 */
		/* 8206E10Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8206E10Ch case    6:*/		return 0x8206E110;
		  /* 8206E110h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 8206E110h case    7:*/		if ( regs.CR[6].eq ) { return 0x8206E120;  }
		/* 8206E110h case    7:*/		return 0x8206E114;
		  /* 8206E114h */ case    8:  		/* cmplw CR6, R7, R27 */
		/* 8206E114h case    8:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R27);
		/* 8206E114h case    8:*/		return 0x8206E118;
		  /* 8206E118h */ case    9:  		/* bc 4, CR6_GT, 8 */
		/* 8206E118h case    9:*/		if ( !regs.CR[6].gt ) { return 0x8206E120;  }
		/* 8206E118h case    9:*/		return 0x8206E11C;
		  /* 8206E11Ch */ case   10:  		/* addi R11, R11, 1 */
		/* 8206E11Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206E11Ch case   10:*/		return 0x8206E120;
	}
	return 0x8206E120;
} // Block from 8206E0F4h-8206E120h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206E120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E120);
		  /* 8206E120h */ case    0:  		/* lwz R9, <#[R31 + 16944]> */
		/* 8206E120h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00004230) );
		/* 8206E120h case    0:*/		return 0x8206E124;
		  /* 8206E124h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 8206E124h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8206E124h case    1:*/		return 0x8206E128;
		  /* 8206E128h */ case    2:  		/* bc 12, CR6_EQ, 56 */
		/* 8206E128h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206E160;  }
		/* 8206E128h case    2:*/		return 0x8206E12C;
		  /* 8206E12Ch */ case    3:  		/* lwz R6, <#[R31 + 16972]> */
		/* 8206E12Ch case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000424C) );
		/* 8206E12Ch case    3:*/		return 0x8206E130;
		  /* 8206E130h */ case    4:  		/* addic R5, R30, -1 */
		/* 8206E130h case    4:*/		cpu::op::addic<0>(regs,&regs.R5,regs.R30,0xFFFFFFFF);
		/* 8206E130h case    4:*/		return 0x8206E134;
		  /* 8206E134h */ case    5:  		/* stw R11, <#[R1 + 100]> */
		/* 8206E134h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8206E134h case    5:*/		return 0x8206E138;
		  /* 8206E138h */ case    6:  		/* addi R3, R1, 80 */
		/* 8206E138h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8206E138h case    6:*/		return 0x8206E13C;
		  /* 8206E13Ch */ case    7:  		/* subfe R11, R5, R30 */
		/* 8206E13Ch case    7:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R5,regs.R30);
		/* 8206E13Ch case    7:*/		return 0x8206E140;
		  /* 8206E140h */ case    8:  		/* stw R10, <#[R1 + 88]> */
		/* 8206E140h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8206E140h case    8:*/		return 0x8206E144;
		  /* 8206E144h */ case    9:  		/* stw R8, <#[R1 + 92]> */
		/* 8206E144h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206E144h case    9:*/		return 0x8206E148;
		  /* 8206E148h */ case   10:  		/* mtspr CTR, R9 */
		/* 8206E148h case   10:*/		regs.CTR = regs.R9;
		/* 8206E148h case   10:*/		return 0x8206E14C;
		  /* 8206E14Ch */ case   11:  		/* stw R7, <#[R1 + 96]> */
		/* 8206E14Ch case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000060) );
		/* 8206E14Ch case   11:*/		return 0x8206E150;
		  /* 8206E150h */ case   12:  		/* stw R6, <#[R1 + 84]> */
		/* 8206E150h case   12:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8206E150h case   12:*/		return 0x8206E154;
		  /* 8206E154h */ case   13:  		/* stw R11, <#[R1 + 80]> */
		/* 8206E154h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206E154h case   13:*/		return 0x8206E158;
		  /* 8206E158h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 8206E158h case   14:*/		if ( 1 ) { regs.LR = 0x8206E15C; return (uint32)regs.CTR; }
		/* 8206E158h case   14:*/		return 0x8206E15C;
		  /* 8206E15Ch */ case   15:  		/* lwz R11, <#[R1 + 100]> */
		/* 8206E15Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8206E15Ch case   15:*/		return 0x8206E160;
	}
	return 0x8206E160;
} // Block from 8206E120h-8206E160h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206E160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E160);
		  /* 8206E160h */ case    0:  		/* lwz R10, <#[R31 + 16952]> */
		/* 8206E160h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00004238) );
		/* 8206E160h case    0:*/		return 0x8206E164;
		  /* 8206E164h */ case    1:  		/* stw R11, <#[R31 + 16960]> */
		/* 8206E164h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00004240) );
		/* 8206E164h case    1:*/		return 0x8206E168;
		  /* 8206E168h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8206E168h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8206E168h case    2:*/		return 0x8206E16C;
		  /* 8206E16Ch */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 8206E16Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8206E1A4;  }
		/* 8206E16Ch case    3:*/		return 0x8206E170;
		  /* 8206E170h */ case    4:  		/* lwz R10, <#[R31 + 16972]> */
		/* 8206E170h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000424C) );
		/* 8206E170h case    4:*/		return 0x8206E174;
		  /* 8206E174h */ case    5:  		/* cmplwi CR6, R10, 1 */
		/* 8206E174h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8206E174h case    5:*/		return 0x8206E178;
		  /* 8206E178h */ case    6:  		/* bc 12, CR6_EQ, 44 */
		/* 8206E178h case    6:*/		if ( regs.CR[6].eq ) { return 0x8206E1A4;  }
		/* 8206E178h case    6:*/		return 0x8206E17C;
		  /* 8206E17Ch */ case    7:  		/* lwz R10, <#[R31 + 17112]> */
		/* 8206E17Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000042D8) );
		/* 8206E17Ch case    7:*/		return 0x8206E180;
		  /* 8206E180h */ case    8:  		/* rlwinm R10, R10, 3, 25, 28 */
		/* 8206E180h case    8:*/		cpu::op::rlwinm<0,3,25,28>(regs,&regs.R10,regs.R10);
		/* 8206E180h case    8:*/		return 0x8206E184;
		  /* 8206E184h */ case    9:  		/* add R10, R10, R31 */
		/* 8206E184h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 8206E184h case    9:*/		return 0x8206E188;
		  /* 8206E188h */ case   10:  		/* addi R9, R10, 16980 */
		/* 8206E188h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4254);
		/* 8206E188h case   10:*/		return 0x8206E18C;
		  /* 8206E18Ch */ case   11:  		/* stw R11, <#[R10 + 16984]> */
		/* 8206E18Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00004258) );
		/* 8206E18Ch case   11:*/		return 0x8206E190;
		  /* 8206E190h */ case   12:  		/* stw R30, <#[R10 + 16980]> */
		/* 8206E190h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00004254) );
		/* 8206E190h case   12:*/		return 0x8206E194;
		  /* 8206E194h */ case   13:  		/* lwz R11, <#[R31 + 17112]> */
		/* 8206E194h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000042D8) );
		/* 8206E194h case   13:*/		return 0x8206E198;
		  /* 8206E198h */ case   14:  		/* addi R11, R11, 1 */
		/* 8206E198h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206E198h case   14:*/		return 0x8206E19C;
		  /* 8206E19Ch */ case   15:  		/* stw R11, <#[R31 + 17112]> */
		/* 8206E19Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000042D8) );
		/* 8206E19Ch case   15:*/		return 0x8206E1A0;
		  /* 8206E1A0h */ case   16:  		/* b 64 */
		/* 8206E1A0h case   16:*/		return 0x8206E1E0;
		/* 8206E1A0h case   16:*/		return 0x8206E1A4;
	}
	return 0x8206E1A4;
} // Block from 8206E160h-8206E1A4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8206E1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E1A4);
		  /* 8206E1A4h */ case    0:  		/* lwz R11, <#[R31 + 16976]> */
		/* 8206E1A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00004250) );
		/* 8206E1A4h case    0:*/		return 0x8206E1A8;
		  /* 8206E1A8h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 8206E1A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8206E1A8h case    1:*/		return 0x8206E1AC;
		  /* 8206E1ACh */ case    2:  		/* addi R11, R11, 1 */
		/* 8206E1ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206E1ACh case    2:*/		return 0x8206E1B0;
		  /* 8206E1B0h */ case    3:  		/* stw R11, <#[R31 + 16976]> */
		/* 8206E1B0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00004250) );
		/* 8206E1B0h case    3:*/		return 0x8206E1B4;
		  /* 8206E1B4h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 8206E1B4h case    4:*/		if ( regs.CR[6].eq ) { return 0x8206E1CC;  }
		/* 8206E1B4h case    4:*/		return 0x8206E1B8;
		  /* 8206E1B8h */ case    5:  		/* lis R11, 32712 */
		/* 8206E1B8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FC8);
		/* 8206E1B8h case    5:*/		return 0x8206E1BC;
		  /* 8206E1BCh */ case    6:  		/* stw R30, <#[R11 + 24848]> */
		/* 8206E1BCh case    6:*/		regs.IO->MEM_WRITE( 0x8206E1BC, (uint32)(regs.R11 + 0x00006110), 4, &regs.R30 );
		/* 8206E1BCh case    6:*/		return 0x8206E1C0;
		  /* 8206E1C0h */ case    7:  		/* eieio */
		/* 8206E1C0h case    7:*/		cpu::op::eieio<0>(regs);
		/* 8206E1C0h case    7:*/		return 0x8206E1C4;
		  /* 8206E1C4h */ case    8:  		/* sync */
		/* 8206E1C4h case    8:*/		cpu::op::sync<0>(regs);
		/* 8206E1C4h case    8:*/		return 0x8206E1C8;
		  /* 8206E1C8h */ case    9:  		/* b 16 */
		/* 8206E1C8h case    9:*/		return 0x8206E1D8;
		/* 8206E1C8h case    9:*/		return 0x8206E1CC;
	}
	return 0x8206E1CC;
} // Block from 8206E1A4h-8206E1CCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206E1CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E1CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E1CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E1CC);
		  /* 8206E1CCh */ case    0:  		/* lwz R11, <#[R31 + 11028]> */
		/* 8206E1CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B14) );
		/* 8206E1CCh case    0:*/		return 0x8206E1D0;
		  /* 8206E1D0h */ case    1:  		/* li R10, 0 */
		/* 8206E1D0h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8206E1D0h case    1:*/		return 0x8206E1D4;
		  /* 8206E1D4h */ case    2:  		/* stw R10, <#[R11 + 4]> */
		/* 8206E1D4h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8206E1D4h case    2:*/		return 0x8206E1D8;
	}
	return 0x8206E1D8;
} // Block from 8206E1CCh-8206E1D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206E1D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E1D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E1D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E1D8);
		  /* 8206E1D8h */ case    0:  		/* mftb R11, 12, 8 */
		/* 8206E1D8h case    0:*/		cpu::op::mftb<0>(regs,&regs.R11,0xC,0x8);
		/* 8206E1D8h case    0:*/		return 0x8206E1DC;
		  /* 8206E1DCh */ case    1:  		/* stw R11, <#[R31 + 23788]> */
		/* 8206E1DCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00005CEC) );
		/* 8206E1DCh case    1:*/		return 0x8206E1E0;
	}
	return 0x8206E1E0;
} // Block from 8206E1D8h-8206E1E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206E1E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E1E0);
		  /* 8206E1E0h */ case    0:  		/* mr R4, R25 */
		/* 8206E1E0h case    0:*/		regs.R4 = regs.R25;
		/* 8206E1E0h case    0:*/		return 0x8206E1E4;
		  /* 8206E1E4h */ case    1:  		/* mr R3, R26 */
		/* 8206E1E4h case    1:*/		regs.R3 = regs.R26;
		/* 8206E1E4h case    1:*/		return 0x8206E1E8;
		  /* 8206E1E8h */ case    2:  		/* bl 2092320 */
		/* 8206E1E8h case    2:*/		regs.LR = 0x8206E1EC; return 0x8226CF08;
		/* 8206E1E8h case    2:*/		return 0x8206E1EC;
		  /* 8206E1ECh */ case    3:  		/* addi R1, R1, 176 */
		/* 8206E1ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8206E1ECh case    3:*/		return 0x8206E1F0;
		  /* 8206E1F0h */ case    4:  		/* b 143528 */
		/* 8206E1F0h case    4:*/		return 0x82091298;
		/* 8206E1F0h case    4:*/		return 0x8206E1F4;
		  /* 8206E1F4h */ case    5:  		/* nop */
		/* 8206E1F4h case    5:*/		cpu::op::nop();
		/* 8206E1F4h case    5:*/		return 0x8206E1F8;
	}
	return 0x8206E1F8;
} // Block from 8206E1E0h-8206E1F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206E1F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E1F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E1F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E1F8);
		  /* 8206E1F8h */ case    0:  		/* mfspr R12, LR */
		/* 8206E1F8h case    0:*/		regs.R12 = regs.LR;
		/* 8206E1F8h case    0:*/		return 0x8206E1FC;
		  /* 8206E1FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206E1FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206E1FCh case    1:*/		return 0x8206E200;
		  /* 8206E200h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8206E200h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206E200h case    2:*/		return 0x8206E204;
		  /* 8206E204h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8206E204h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206E204h case    3:*/		return 0x8206E208;
	}
	return 0x8206E208;
} // Block from 8206E1F8h-8206E208h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206E208h
// Function 'D3DDevice_EndExport'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E208);
		  /* 8206E208h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206E208h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206E208h case    0:*/		return 0x8206E20C;
		  /* 8206E20Ch */ case    1:  		/* lwz R11, <#[R3 + 56]> */
		/* 8206E20Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 8206E20Ch case    1:*/		return 0x8206E210;
		  /* 8206E210h */ case    2:  		/* mr R31, R3 */
		/* 8206E210h case    2:*/		regs.R31 = regs.R3;
		/* 8206E210h case    2:*/		return 0x8206E214;
		  /* 8206E214h */ case    3:  		/* lwz R3, <#[R3 + 48]> */
		/* 8206E214h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 8206E214h case    3:*/		return 0x8206E218;
		  /* 8206E218h */ case    4:  		/* mr R30, R4 */
		/* 8206E218h case    4:*/		regs.R30 = regs.R4;
		/* 8206E218h case    4:*/		return 0x8206E21C;
		  /* 8206E21Ch */ case    5:  		/* cmplw CR6, R3, R11 */
		/* 8206E21Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8206E21Ch case    5:*/		return 0x8206E220;
		  /* 8206E220h */ case    6:  		/* bc 4, CR6_GT, 12 */
		/* 8206E220h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8206E22C;  }
		/* 8206E220h case    6:*/		return 0x8206E224;
		  /* 8206E224h */ case    7:  		/* mr R3, R31 */
		/* 8206E224h case    7:*/		regs.R3 = regs.R31;
		/* 8206E224h case    7:*/		return 0x8206E228;
		  /* 8206E228h */ case    8:  		/* bl 24288 */
		/* 8206E228h case    8:*/		regs.LR = 0x8206E22C; return 0x82074108;
		/* 8206E228h case    8:*/		return 0x8206E22C;
	}
	return 0x8206E22C;
} // Block from 8206E208h-8206E22Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206E22Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E22C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E22C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E22C);
		  /* 8206E22Ch */ case    0:  		/* lis R11, -16382 */
		/* 8206E22Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC002);
		/* 8206E22Ch case    0:*/		return 0x8206E230;
		  /* 8206E230h */ case    1:  		/* li R10, 6209 */
		/* 8206E230h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1841);
		/* 8206E230h case    1:*/		return 0x8206E234;
		  /* 8206E234h */ case    2:  		/* ori R11, R11, 8448 */
		/* 8206E234h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2100);
		/* 8206E234h case    2:*/		return 0x8206E238;
		  /* 8206E238h */ case    3:  		/* lis R9, 10280 */
		/* 8206E238h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x2828);
		/* 8206E238h case    3:*/		return 0x8206E23C;
		  /* 8206E23Ch */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206E23Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E23Ch case    4:*/		return 0x8206E240;
		  /* 8206E240h */ case    5:  		/* li R8, -1793 */
		/* 8206E240h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFF8FF);
		/* 8206E240h case    5:*/		return 0x8206E244;
		  /* 8206E244h */ case    6:  		/* ori R11, R9, 310 */
		/* 8206E244h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R9,0x136);
		/* 8206E244h case    6:*/		return 0x8206E248;
		  /* 8206E248h */ case    7:  		/* li R7, 6448 */
		/* 8206E248h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x1930);
		/* 8206E248h case    7:*/		return 0x8206E24C;
		  /* 8206E24Ch */ case    8:  		/* subf R9, R30, R11 */
		/* 8206E24Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R30,regs.R11);
		/* 8206E24Ch case    8:*/		return 0x8206E250;
		  /* 8206E250h */ case    9:  		/* subf R11, R30, R11 */
		/* 8206E250h case    9:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8206E250h case    9:*/		return 0x8206E254;
		  /* 8206E254h */ case   10:  		/* stwu R10, <#[R3 + 4]> */
		/* 8206E254h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E254h case   10:*/		return 0x8206E258;
		  /* 8206E258h */ case   11:  		/* cntlzw R9, R9 */
		/* 8206E258h case   11:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R9);
		/* 8206E258h case   11:*/		return 0x8206E25C;
		  /* 8206E25Ch */ case   12:  		/* addic R11, R11, -1 */
		/* 8206E25Ch case   12:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8206E25Ch case   12:*/		return 0x8206E260;
		  /* 8206E260h */ case   13:  		/* rlwinm R10, R9, 3, 23, 23 */
		/* 8206E260h case   13:*/		cpu::op::rlwinm<0,3,23,23>(regs,&regs.R10,regs.R9);
		/* 8206E260h case   13:*/		return 0x8206E264;
		  /* 8206E264h */ case   14:  		/* li R9, 3 */
		/* 8206E264h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 8206E264h case   14:*/		return 0x8206E268;
		  /* 8206E268h */ case   15:  		/* subfe R11, R11, R11 */
		/* 8206E268h case   15:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206E268h case   15:*/		return 0x8206E26C;
		  /* 8206E26Ch */ case   16:  		/* stwu R8, <#[R3 + 4]> */
		/* 8206E26Ch case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E26Ch case   16:*/		return 0x8206E270;
		  /* 8206E270h */ case   17:  		/* and R11, R11, R9 */
		/* 8206E270h case   17:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8206E270h case   17:*/		return 0x8206E274;
		  /* 8206E274h */ case   18:  		/* stwu R10, <#[R3 + 4]> */
		/* 8206E274h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E274h case   18:*/		return 0x8206E278;
		  /* 8206E278h */ case   19:  		/* stwu R7, <#[R3 + 4]> */
		/* 8206E278h case   19:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E278h case   19:*/		return 0x8206E27C;
		  /* 8206E27Ch */ case   20:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206E27Ch case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E27Ch case   20:*/		return 0x8206E280;
		  /* 8206E280h */ case   21:  		/* stw R3, <#[R31 + 48]> */
		/* 8206E280h case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206E280h case   21:*/		return 0x8206E284;
		  /* 8206E284h */ case   22:  		/* addi R1, R1, 112 */
		/* 8206E284h case   22:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206E284h case   22:*/		return 0x8206E288;
		  /* 8206E288h */ case   23:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206E288h case   23:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206E288h case   23:*/		return 0x8206E28C;
		  /* 8206E28Ch */ case   24:  		/* mtspr LR, R12 */
		/* 8206E28Ch case   24:*/		regs.LR = regs.R12;
		/* 8206E28Ch case   24:*/		return 0x8206E290;
		  /* 8206E290h */ case   25:  		/* ld R30, <#[R1 - 24]> */
		/* 8206E290h case   25:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206E290h case   25:*/		return 0x8206E294;
		  /* 8206E294h */ case   26:  		/* ld R31, <#[R1 - 16]> */
		/* 8206E294h case   26:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206E294h case   26:*/		return 0x8206E298;
		  /* 8206E298h */ case   27:  		/* bclr 20, CR0_LT */
		/* 8206E298h case   27:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206E298h case   27:*/		return 0x8206E29C;
	}
	return 0x8206E29C;
} // Block from 8206E22Ch-8206E29Ch (28 instructions)

//////////////////////////////////////////////////////
// Block at 8206E29Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E29C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E29C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E29C);
		  /* 8206E29Ch */ case    0:  		/* nop */
		/* 8206E29Ch case    0:*/		cpu::op::nop();
		/* 8206E29Ch case    0:*/		return 0x8206E2A0;
	}
	return 0x8206E2A0;
} // Block from 8206E29Ch-8206E2A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206E2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E2A0);
		  /* 8206E2A0h */ case    0:  		/* mfspr R12, LR */
		/* 8206E2A0h case    0:*/		regs.R12 = regs.LR;
		/* 8206E2A0h case    0:*/		return 0x8206E2A4;
		  /* 8206E2A4h */ case    1:  		/* bl 143256 */
		/* 8206E2A4h case    1:*/		regs.LR = 0x8206E2A8; return 0x8209123C;
		/* 8206E2A4h case    1:*/		return 0x8206E2A8;
		  /* 8206E2A8h */ case    2:  		/* stfd FR30, <#[R1 - 112]> */
		/* 8206E2A8h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFF90) );
		/* 8206E2A8h case    2:*/		return 0x8206E2AC;
		  /* 8206E2ACh */ case    3:  		/* stfd FR31, <#[R1 - 104]> */
		/* 8206E2ACh case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF98) );
		/* 8206E2ACh case    3:*/		return 0x8206E2B0;
		  /* 8206E2B0h */ case    4:  		/* stwu R1, <#[R1 - 656]> */
		/* 8206E2B0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFD70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFD70);
		/* 8206E2B0h case    4:*/		return 0x8206E2B4;
		  /* 8206E2B4h */ case    5:  		/* lwz R10, <#[R4 + 36]> */
		/* 8206E2B4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000024) );
		/* 8206E2B4h case    5:*/		return 0x8206E2B8;
		  /* 8206E2B8h */ case    6:  		/* lis R9, -32256 */
		/* 8206E2B8h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8206E2B8h case    6:*/		return 0x8206E2BC;
		  /* 8206E2BCh */ case    7:  		/* lis R8, -32256 */
		/* 8206E2BCh case    7:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 8206E2BCh case    7:*/		return 0x8206E2C0;
		  /* 8206E2C0h */ case    8:  		/* rlwinm R11, R10, 19, 19, 31 */
		/* 8206E2C0h case    8:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R11,regs.R10);
		/* 8206E2C0h case    8:*/		return 0x8206E2C4;
		  /* 8206E2C4h */ case    9:  		/* rlwinm R10, R10, 0, 19, 31 */
		/* 8206E2C4h case    9:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R10);
		/* 8206E2C4h case    9:*/		return 0x8206E2C8;
		  /* 8206E2C8h */ case   10:  		/* addi R11, R11, 1 */
		/* 8206E2C8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206E2C8h case   10:*/		return 0x8206E2CC;
		  /* 8206E2CCh */ case   11:  		/* addi R24, R10, 1 */
		/* 8206E2CCh case   11:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R10,0x1);
		/* 8206E2CCh case   11:*/		return 0x8206E2D0;
		  /* 8206E2D0h */ case   12:  		/* lfs FR0, <#[R9 + 4016]> */
		/* 8206E2D0h case   12:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000FB0) );
		/* 8206E2D0h case   12:*/		return 0x8206E2D4;
		  /* 8206E2D4h */ case   13:  		/* rldicl R10, R11, 0, 32 */
		/* 8206E2D4h case   13:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R11);
		/* 8206E2D4h case   13:*/		return 0x8206E2D8;
		  /* 8206E2D8h */ case   14:  		/* lfs FR13, <#[R8 + 1820]> */
		/* 8206E2D8h case   14:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R8 + 0x0000071C) );
		/* 8206E2D8h case   14:*/		return 0x8206E2DC;
		  /* 8206E2DCh */ case   15:  		/* cmplwi CR6, R11, 1470 */
		/* 8206E2DCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000005BE);
		/* 8206E2DCh case   15:*/		return 0x8206E2E0;
		  /* 8206E2E0h */ case   16:  		/* std R10, <#[R1 + 128]> */
		/* 8206E2E0h case   16:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 8206E2E0h case   16:*/		return 0x8206E2E4;
		  /* 8206E2E4h */ case   17:  		/* lfd FR12, <#[R1 + 128]> */
		/* 8206E2E4h case   17:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000080) );
		/* 8206E2E4h case   17:*/		return 0x8206E2E8;
		  /* 8206E2E8h */ case   18:  		/* fcfid FR12, FR12 */
		/* 8206E2E8h case   18:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 8206E2E8h case   18:*/		return 0x8206E2EC;
		  /* 8206E2ECh */ case   19:  		/* mr R31, R3 */
		/* 8206E2ECh case   19:*/		regs.R31 = regs.R3;
		/* 8206E2ECh case   19:*/		return 0x8206E2F0;
		  /* 8206E2F0h */ case   20:  		/* frsp FR12, FR12 */
		/* 8206E2F0h case   20:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 8206E2F0h case   20:*/		return 0x8206E2F4;
		  /* 8206E2F4h */ case   21:  		/* mr R23, R4 */
		/* 8206E2F4h case   21:*/		regs.R23 = regs.R4;
		/* 8206E2F4h case   21:*/		return 0x8206E2F8;
		  /* 8206E2F8h */ case   22:  		/* fmadds FR0, FR12, FR0, FR13 */
		/* 8206E2F8h case   22:*/		cpu::op::fmadds<0>(regs,&regs.FR0,regs.FR12,regs.FR0,regs.FR13);
		/* 8206E2F8h case   22:*/		return 0x8206E2FC;
		  /* 8206E2FCh */ case   23:  		/* fctidz FR0, FR0 */
		/* 8206E2FCh case   23:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 8206E2FCh case   23:*/		return 0x8206E300;
		  /* 8206E300h */ case   24:  		/* stfd FR0, <#[R1 + 128]> */
		/* 8206E300h case   24:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000080) );
		/* 8206E300h case   24:*/		return 0x8206E304;
		  /* 8206E304h */ case   25:  		/* lwz R10, <#[R1 + 132]> */
		/* 8206E304h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000084) );
		/* 8206E304h case   25:*/		return 0x8206E308;
		  /* 8206E308h */ case   26:  		/* rlwinm R28, R10, 1, 0, 30 */
		/* 8206E308h case   26:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R28,regs.R10);
		/* 8206E308h case   26:*/		return 0x8206E30C;
		  /* 8206E30Ch */ case   27:  		/* subf R11, R28, R11 */
		/* 8206E30Ch case   27:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 8206E30Ch case   27:*/		return 0x8206E310;
		  /* 8206E310h */ case   28:  		/* rlwinm R25, R11, 31, 1, 31 */
		/* 8206E310h case   28:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R25,regs.R11);
		/* 8206E310h case   28:*/		return 0x8206E314;
		  /* 8206E314h */ case   29:  		/* bc 4, CR6_LT, 12 */
		/* 8206E314h case   29:*/		if ( !regs.CR[6].lt ) { return 0x8206E320;  }
		/* 8206E314h case   29:*/		return 0x8206E318;
		  /* 8206E318h */ case   30:  		/* addi R25, R25, -3 */
		/* 8206E318h case   30:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xFFFFFFFD);
		/* 8206E318h case   30:*/		return 0x8206E31C;
		  /* 8206E31Ch */ case   31:  		/* addi R28, R28, 6 */
		/* 8206E31Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x6);
		/* 8206E31Ch case   31:*/		return 0x8206E320;
	}
	return 0x8206E320;
} // Block from 8206E2A0h-8206E320h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8206E320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E320);
		  /* 8206E320h */ case    0:  		/* lwz R11, <#[R31 + 11024]> */
		/* 8206E320h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 8206E320h case    0:*/		return 0x8206E324;
		  /* 8206E324h */ case    1:  		/* lwz R11, <#[R11 + 96]> */
		/* 8206E324h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 8206E324h case    1:*/		return 0x8206E328;
		  /* 8206E328h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8206E328h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206E328h case    2:*/		return 0x8206E32C;
		  /* 8206E32Ch */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 8206E32Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8206E35C;  }
		/* 8206E32Ch case    3:*/		return 0x8206E330;
		  /* 8206E330h */ case    4:  		/* lis R11, -32256 */
		/* 8206E330h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8206E330h case    4:*/		return 0x8206E334;
		  /* 8206E334h */ case    5:  		/* add R9, R25, R28 */
		/* 8206E334h case    5:*/		cpu::op::add<0>(regs,&regs.R9,regs.R25,regs.R28);
		/* 8206E334h case    5:*/		return 0x8206E338;
		  /* 8206E338h */ case    6:  		/* addi R5, R11, 3848 */
		/* 8206E338h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xF08);
		/* 8206E338h case    6:*/		return 0x8206E33C;
		  /* 8206E33Ch */ case    7:  		/* mr R8, R24 */
		/* 8206E33Ch case    7:*/		regs.R8 = regs.R24;
		/* 8206E33Ch case    7:*/		return 0x8206E340;
		  /* 8206E340h */ case    8:  		/* mr R7, R25 */
		/* 8206E340h case    8:*/		regs.R7 = regs.R25;
		/* 8206E340h case    8:*/		return 0x8206E344;
		  /* 8206E344h */ case    9:  		/* li R6, 0 */
		/* 8206E344h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206E344h case    9:*/		return 0x8206E348;
		  /* 8206E348h */ case   10:  		/* li R4, 256 */
		/* 8206E348h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 8206E348h case   10:*/		return 0x8206E34C;
		  /* 8206E34Ch */ case   11:  		/* addi R3, R1, 288 */
		/* 8206E34Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x120);
		/* 8206E34Ch case   11:*/		return 0x8206E350;
		  /* 8206E350h */ case   12:  		/* bl 2092024 */
		/* 8206E350h case   12:*/		regs.LR = 0x8206E354; return 0x8226CF48;
		/* 8206E350h case   12:*/		return 0x8206E354;
		  /* 8206E354h */ case   13:  		/* addi R3, R1, 288 */
		/* 8206E354h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x120);
		/* 8206E354h case   13:*/		return 0x8206E358;
		  /* 8206E358h */ case   14:  		/* bl 106496 */
		/* 8206E358h case   14:*/		regs.LR = 0x8206E35C; return 0x82088358;
		/* 8206E358h case   14:*/		return 0x8206E35C;
	}
	return 0x8206E35C;
} // Block from 8206E320h-8206E35Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206E35Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E35C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E35C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E35C);
		  /* 8206E35Ch */ case    0:  		/* addi R6, R1, 96 */
		/* 8206E35Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 8206E35Ch case    0:*/		return 0x8206E360;
		  /* 8206E360h */ case    1:  		/* addi R5, R1, 88 */
		/* 8206E360h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 8206E360h case    1:*/		return 0x8206E364;
		  /* 8206E364h */ case    2:  		/* addi R4, R1, 92 */
		/* 8206E364h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x5C);
		/* 8206E364h case    2:*/		return 0x8206E368;
		  /* 8206E368h */ case    3:  		/* mr R3, R31 */
		/* 8206E368h case    3:*/		regs.R3 = regs.R31;
		/* 8206E368h case    3:*/		return 0x8206E36C;
		  /* 8206E36Ch */ case    4:  		/* bl -20156 */
		/* 8206E36Ch case    4:*/		regs.LR = 0x8206E370; return 0x820694B0;
		/* 8206E36Ch case    4:*/		return 0x8206E370;
		  /* 8206E370h */ case    5:  		/* lwz R11, <#[R31 + 11024]> */
		/* 8206E370h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 8206E370h case    5:*/		return 0x8206E374;
		  /* 8206E374h */ case    6:  		/* lwz R10, <#[R1 + 112]> */
		/* 8206E374h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 8206E374h case    6:*/		return 0x8206E378;
		  /* 8206E378h */ case    7:  		/* lis R12, -9 */
		/* 8206E378h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFF7);
		/* 8206E378h case    7:*/		return 0x8206E37C;
		  /* 8206E37Ch */ case    8:  		/* addi R11, R11, 96 */
		/* 8206E37Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x60);
		/* 8206E37Ch case    8:*/		return 0x8206E380;
		  /* 8206E380h */ case    9:  		/* lwz R8, <#[R1 + 120]> */
		/* 8206E380h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000078) );
		/* 8206E380h case    9:*/		return 0x8206E384;
		  /* 8206E384h */ case   10:  		/* rlwinm R7, R10, 0, 2, 31 */
		/* 8206E384h case   10:*/		cpu::op::rlwinm<0,0,2,31>(regs,&regs.R7,regs.R10);
		/* 8206E384h case   10:*/		return 0x8206E388;
		  /* 8206E388h */ case   11:  		/* lwz R9, <#[R1 + 124]> */
		/* 8206E388h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000007C) );
		/* 8206E388h case   11:*/		return 0x8206E38C;
		  /* 8206E38Ch */ case   12:  		/* rlwinm R10, R11, 12, 20, 31 */
		/* 8206E38Ch case   12:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R11);
		/* 8206E38Ch case   12:*/		return 0x8206E390;
		  /* 8206E390h */ case   13:  		/* rlwinm R8, R8, 0, 12, 31 */
		/* 8206E390h case   13:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R8,regs.R8);
		/* 8206E390h case   13:*/		return 0x8206E394;
		  /* 8206E394h */ case   14:  		/* addi R10, R10, 512 */
		/* 8206E394h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 8206E394h case   14:*/		return 0x8206E398;
		  /* 8206E398h */ case   15:  		/* oris R8, R8, 19200 */
		/* 8206E398h case   15:*/		cpu::op::oris<0>(regs,&regs.R8,regs.R8,0x4B00);
		/* 8206E398h case   15:*/		return 0x8206E39C;
		  /* 8206E39Ch */ case   16:  		/* ori R12, R12, 58618 */
		/* 8206E39Ch case   16:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xE4FA);
		/* 8206E39Ch case   16:*/		return 0x8206E3A0;
		  /* 8206E3A0h */ case   17:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 8206E3A0h case   17:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 8206E3A0h case   17:*/		return 0x8206E3A4;
		  /* 8206E3A4h */ case   18:  		/* rlwinm R11, R11, 0, 3, 29 */
		/* 8206E3A4h case   18:*/		cpu::op::rlwinm<0,0,3,29>(regs,&regs.R11,regs.R11);
		/* 8206E3A4h case   18:*/		return 0x8206E3A8;
		  /* 8206E3A8h */ case   19:  		/* rlwinm R9, R9, 0, 9, 31 */
		/* 8206E3A8h case   19:*/		cpu::op::rlwinm<0,0,9,31>(regs,&regs.R9,regs.R9);
		/* 8206E3A8h case   19:*/		return 0x8206E3AC;
		  /* 8206E3ACh */ case   20:  		/* and R8, R8, R12 */
		/* 8206E3ACh case   20:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R12);
		/* 8206E3ACh case   20:*/		return 0x8206E3B0;
		  /* 8206E3B0h */ case   21:  		/* add R11, R10, R11 */
		/* 8206E3B0h case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206E3B0h case   21:*/		return 0x8206E3B4;
		  /* 8206E3B4h */ case   22:  		/* oris R10, R7, 16384 */
		/* 8206E3B4h case   22:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R7,0x4000);
		/* 8206E3B4h case   22:*/		return 0x8206E3B8;
		  /* 8206E3B8h */ case   23:  		/* oris R9, R9, 19200 */
		/* 8206E3B8h case   23:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x4B00);
		/* 8206E3B8h case   23:*/		return 0x8206E3BC;
		  /* 8206E3BCh */ case   24:  		/* lis R7, -32256 */
		/* 8206E3BCh case   24:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8200);
		/* 8206E3BCh case   24:*/		return 0x8206E3C0;
		  /* 8206E3C0h */ case   25:  		/* lis R6, -32256 */
		/* 8206E3C0h case   25:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8200);
		/* 8206E3C0h case   25:*/		return 0x8206E3C4;
		  /* 8206E3C4h */ case   26:  		/* oris R8, R8, 7 */
		/* 8206E3C4h case   26:*/		cpu::op::oris<0>(regs,&regs.R8,regs.R8,0x7);
		/* 8206E3C4h case   26:*/		return 0x8206E3C8;
		  /* 8206E3C8h */ case   27:  		/* li R26, 1 */
		/* 8206E3C8h case   27:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8206E3C8h case   27:*/		return 0x8206E3CC;
		  /* 8206E3CCh */ case   28:  		/* rlwimi R10, R11, 30, 2, 31 */
		/* 8206E3CCh case   28:*/		cpu::op::rlwimi<0,30,2,31>(regs,&regs.R10,regs.R11);
		/* 8206E3CCh case   28:*/		return 0x8206E3D0;
		  /* 8206E3D0h */ case   29:  		/* rlwimi R9, R26, 0, 9, 31 */
		/* 8206E3D0h case   29:*/		cpu::op::rlwimi<0,0,9,31>(regs,&regs.R9,regs.R26);
		/* 8206E3D0h case   29:*/		return 0x8206E3D4;
		  /* 8206E3D4h */ case   30:  		/* lfs FR31, <#[R7 + 1816]> */
		/* 8206E3D4h case   30:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R7 + 0x00000718) );
		/* 8206E3D4h case   30:*/		return 0x8206E3D8;
		  /* 8206E3D8h */ case   31:  		/* lis R11, 19200 */
		/* 8206E3D8h case   31:*/		cpu::op::lis<0>(regs,&regs.R11,0x4B00);
		/* 8206E3D8h case   31:*/		return 0x8206E3DC;
		  /* 8206E3DCh */ case   32:  		/* lfs FR30, <#[R6 + 1792]> */
		/* 8206E3DCh case   32:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R6 + 0x00000700) );
		/* 8206E3DCh case   32:*/		return 0x8206E3E0;
		  /* 8206E3E0h */ case   33:  		/* ori R8, R8, 9218 */
		/* 8206E3E0h case   33:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x2402);
		/* 8206E3E0h case   33:*/		return 0x8206E3E4;
		  /* 8206E3E4h */ case   34:  		/* stw R9, <#[R1 + 124]> */
		/* 8206E3E4h case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000007C) );
		/* 8206E3E4h case   34:*/		return 0x8206E3E8;
		  /* 8206E3E8h */ case   35:  		/* addi R4, R31, 13024 */
		/* 8206E3E8h case   35:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x32E0);
		/* 8206E3E8h case   35:*/		return 0x8206E3EC;
		  /* 8206E3ECh */ case   36:  		/* stw R11, <#[R1 + 116]> */
		/* 8206E3ECh case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 8206E3ECh case   36:*/		return 0x8206E3F0;
		  /* 8206E3F0h */ case   37:  		/* addi R3, R1, 208 */
		/* 8206E3F0h case   37:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xD0);
		/* 8206E3F0h case   37:*/		return 0x8206E3F4;
		  /* 8206E3F4h */ case   38:  		/* stw R8, <#[R1 + 120]> */
		/* 8206E3F4h case   38:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000078) );
		/* 8206E3F4h case   38:*/		return 0x8206E3F8;
		  /* 8206E3F8h */ case   39:  		/* li R5, 28 */
		/* 8206E3F8h case   39:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 8206E3F8h case   39:*/		return 0x8206E3FC;
		  /* 8206E3FCh */ case   40:  		/* stw R10, <#[R1 + 112]> */
		/* 8206E3FCh case   40:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 8206E3FCh case   40:*/		return 0x8206E400;
		  /* 8206E400h */ case   41:  		/* bl 144816 */
		/* 8206E400h case   41:*/		regs.LR = 0x8206E404; return 0x820919B0;
		/* 8206E400h case   41:*/		return 0x8206E404;
		  /* 8206E404h */ case   42:  		/* lwz R11, <#[R31 + 13052]> */
		/* 8206E404h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000032FC) );
		/* 8206E404h case   42:*/		return 0x8206E408;
		  /* 8206E408h */ case   43:  		/* addi R10, R1, 192 */
		/* 8206E408h case   43:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xC0);
		/* 8206E408h case   43:*/		return 0x8206E40C;
		  /* 8206E40Ch */ case   44:  		/* lwz R9, <#[R31 + 13056]> */
		/* 8206E40Ch case   44:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003300) );
		/* 8206E40Ch case   44:*/		return 0x8206E410;
		  /* 8206E410h */ case   45:  		/* lwz R8, <#[R31 + 13060]> */
		/* 8206E410h case   45:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00003304) );
		/* 8206E410h case   45:*/		return 0x8206E414;
		  /* 8206E414h */ case   46:  		/* mr R3, R31 */
		/* 8206E414h case   46:*/		regs.R3 = regs.R31;
		/* 8206E414h case   46:*/		return 0x8206E418;
		  /* 8206E418h */ case   47:  		/* lwz R7, <#[R31 + 13064]> */
		/* 8206E418h case   47:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00003308) );
		/* 8206E418h case   47:*/		return 0x8206E41C;
		  /* 8206E41Ch */ case   48:  		/* stw R11, <#[R10]> */
		/* 8206E41Ch case   48:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8206E41Ch case   48:*/		return 0x8206E420;
		  /* 8206E420h */ case   49:  		/* stw R9, <#[R10 + 4]> */
		/* 8206E420h case   49:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8206E420h case   49:*/		return 0x8206E424;
		  /* 8206E424h */ case   50:  		/* stw R8, <#[R10 + 8]> */
		/* 8206E424h case   50:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 8206E424h case   50:*/		return 0x8206E428;
		  /* 8206E428h */ case   51:  		/* stw R7, <#[R10 + 12]> */
		/* 8206E428h case   51:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x0000000C) );
		/* 8206E428h case   51:*/		return 0x8206E42C;
		  /* 8206E42Ch */ case   52:  		/* bl -39908 */
		/* 8206E42Ch case   52:*/		regs.LR = 0x8206E430; return 0x82064848;
		/* 8206E42Ch case   52:*/		return 0x8206E430;
		  /* 8206E430h */ case   53:  		/* addi R11, R1, 176 */
		/* 8206E430h case   53:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xB0);
		/* 8206E430h case   53:*/		return 0x8206E434;
		  /* 8206E434h */ case   54:  		/* li R27, 0 */
		/* 8206E434h case   54:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8206E434h case   54:*/		return 0x8206E438;
	}
	return 0x8206E438;
} // Block from 8206E35Ch-8206E438h (55 instructions)

//////////////////////////////////////////////////////
// Block at 8206E438h
// Function 'D3DDevice_InvalidateGpuCache'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E438);
		  /* 8206E438h */ case    0:  		/* mr R22, R3 */
		/* 8206E438h case    0:*/		regs.R22 = regs.R3;
		/* 8206E438h case    0:*/		return 0x8206E43C;
		  /* 8206E43Ch */ case    1:  		/* mr R30, R27 */
		/* 8206E43Ch case    1:*/		regs.R30 = regs.R27;
		/* 8206E43Ch case    1:*/		return 0x8206E440;
		  /* 8206E440h */ case    2:  		/* addi R29, R11, -4 */
		/* 8206E440h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFFFFC);
		/* 8206E440h case    2:*/		return 0x8206E444;
		  /* 8206E444h */ case    3:  		/* mr R4, R30 */
		/* 8206E444h case    3:*/		regs.R4 = regs.R30;
		/* 8206E444h case    3:*/		return 0x8206E448;
		  /* 8206E448h */ case    4:  		/* mr R3, R31 */
		/* 8206E448h case    4:*/		regs.R3 = regs.R31;
		/* 8206E448h case    4:*/		return 0x8206E44C;
		  /* 8206E44Ch */ case    5:  		/* bl -40012 */
		/* 8206E44Ch case    5:*/		regs.LR = 0x8206E450; return 0x82064800;
		/* 8206E44Ch case    5:*/		return 0x8206E450;
		  /* 8206E450h */ case    6:  		/* addi R30, R30, 1 */
		/* 8206E450h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8206E450h case    6:*/		return 0x8206E454;
		  /* 8206E454h */ case    7:  		/* stwu R3, <#[R29 + 4]> */
		/* 8206E454h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000004) );
		regs.R29 = (uint32)(regs.R29 + 0x00000004);
		/* 8206E454h case    7:*/		return 0x8206E458;
		  /* 8206E458h */ case    8:  		/* cmplwi CR6, R30, 4 */
		/* 8206E458h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000004);
		/* 8206E458h case    8:*/		return 0x8206E45C;
		  /* 8206E45Ch */ case    9:  		/* bc 12, CR6_LT, -24 */
		/* 8206E45Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x8206E444;  }
		/* 8206E45Ch case    9:*/		return 0x8206E460;
		  /* 8206E460h */ case   10:  		/* mr R3, R31 */
		/* 8206E460h case   10:*/		regs.R3 = regs.R31;
		/* 8206E460h case   10:*/		return 0x8206E464;
		  /* 8206E464h */ case   11:  		/* bl -44900 */
		/* 8206E464h case   11:*/		regs.LR = 0x8206E468; return 0x82063500;
		/* 8206E464h case   11:*/		return 0x8206E468;
		  /* 8206E468h */ case   12:  		/* stw R27, <#[R1 + 80]> */
		/* 8206E468h case   12:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000050) );
		/* 8206E468h case   12:*/		return 0x8206E46C;
		  /* 8206E46Ch */ case   13:  		/* stw R27, <#[R1 + 84]> */
		/* 8206E46Ch case   13:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 8206E46Ch case   13:*/		return 0x8206E470;
		  /* 8206E470h */ case   14:  		/* mr R21, R3 */
		/* 8206E470h case   14:*/		regs.R21 = regs.R3;
		/* 8206E470h case   14:*/		return 0x8206E474;
		  /* 8206E474h */ case   15:  		/* addi R4, R1, 80 */
		/* 8206E474h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8206E474h case   15:*/		return 0x8206E478;
		  /* 8206E478h */ case   16:  		/* mr R3, R31 */
		/* 8206E478h case   16:*/		regs.R3 = regs.R31;
		/* 8206E478h case   16:*/		return 0x8206E47C;
		  /* 8206E47Ch */ case   17:  		/* bl -21188 */
		/* 8206E47Ch case   17:*/		regs.LR = 0x8206E480; return 0x820691B8;
		/* 8206E47Ch case   17:*/		return 0x8206E480;
		  /* 8206E480h */ case   18:  		/* addi R4, R1, 84 */
		/* 8206E480h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 8206E480h case   18:*/		return 0x8206E484;
		  /* 8206E484h */ case   19:  		/* mr R3, R31 */
		/* 8206E484h case   19:*/		regs.R3 = regs.R31;
		/* 8206E484h case   19:*/		return 0x8206E488;
		  /* 8206E488h */ case   20:  		/* bl -21736 */
		/* 8206E488h case   20:*/		regs.LR = 0x8206E48C; return 0x82068FA0;
		/* 8206E488h case   20:*/		return 0x8206E48C;
		  /* 8206E48Ch */ case   21:  		/* addi R8, R1, 164 */
		/* 8206E48Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xA4);
		/* 8206E48Ch case   21:*/		return 0x8206E490;
		  /* 8206E490h */ case   22:  		/* li R11, 6 */
		/* 8206E490h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 8206E490h case   22:*/		return 0x8206E494;
		  /* 8206E494h */ case   23:  		/* stw R27, <#[R1 + 160]> */
		/* 8206E494h case   23:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x000000A0) );
		/* 8206E494h case   23:*/		return 0x8206E498;
		  /* 8206E498h */ case   24:  		/* addi R10, R1, 232 */
		/* 8206E498h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xE8);
		/* 8206E498h case   24:*/		return 0x8206E49C;
		  /* 8206E49Ch */ case   25:  		/* mr R9, R27 */
		/* 8206E49Ch case   25:*/		regs.R9 = regs.R27;
		/* 8206E49Ch case   25:*/		return 0x8206E4A0;
		  /* 8206E4A0h */ case   26:  		/* stw R27, <#[R8]> */
		/* 8206E4A0h case   26:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R8 + 0x00000000) );
		/* 8206E4A0h case   26:*/		return 0x8206E4A4;
		  /* 8206E4A4h */ case   27:  		/* stw R27, <#[R8 + 4]> */
		/* 8206E4A4h case   27:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R8 + 0x00000004) );
		/* 8206E4A4h case   27:*/		return 0x8206E4A8;
		  /* 8206E4A8h */ case   28:  		/* mtspr CTR, R11 */
		/* 8206E4A8h case   28:*/		regs.CTR = regs.R11;
		/* 8206E4A8h case   28:*/		return 0x8206E4AC;
		  /* 8206E4ACh */ case   29:  		/* stw R27, <#[R8 + 8]> */
		/* 8206E4ACh case   29:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R8 + 0x00000008) );
		/* 8206E4ACh case   29:*/		return 0x8206E4B0;
		  /* 8206E4B0h */ case   30:  		/* stdu R9, <#[R10 + 8]> */
		/* 8206E4B0h case   30:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 8206E4B0h case   30:*/		return 0x8206E4B4;
		  /* 8206E4B4h */ case   31:  		/* bc 16, CR0_LT, -4 */
		/* 8206E4B4h case   31:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206E4B0;  }
		/* 8206E4B4h case   31:*/		return 0x8206E4B8;
		  /* 8206E4B8h */ case   32:  		/* lis R5, 6184 */
		/* 8206E4B8h case   32:*/		cpu::op::lis<0>(regs,&regs.R5,0x1828);
		/* 8206E4B8h case   32:*/		return 0x8206E4BC;
		  /* 8206E4BCh */ case   33:  		/* addi R10, R1, 152 */
		/* 8206E4BCh case   33:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x98);
		/* 8206E4BCh case   33:*/		return 0x8206E4C0;
		  /* 8206E4C0h */ case   34:  		/* addi R9, R1, 128 */
		/* 8206E4C0h case   34:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 8206E4C0h case   34:*/		return 0x8206E4C4;
		  /* 8206E4C4h */ case   35:  		/* addi R8, R1, 240 */
		/* 8206E4C4h case   35:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xF0);
		/* 8206E4C4h case   35:*/		return 0x8206E4C8;
		  /* 8206E4C8h */ case   36:  		/* addi R7, R1, 160 */
		/* 8206E4C8h case   36:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xA0);
		/* 8206E4C8h case   36:*/		return 0x8206E4CC;
		  /* 8206E4CCh */ case   37:  		/* li R6, 0 */
		/* 8206E4CCh case   37:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206E4CCh case   37:*/		return 0x8206E4D0;
		  /* 8206E4D0h */ case   38:  		/* ori R5, R5, 390 */
		/* 8206E4D0h case   38:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x186);
		/* 8206E4D0h case   38:*/		return 0x8206E4D4;
		  /* 8206E4D4h */ case   39:  		/* mr R4, R28 */
		/* 8206E4D4h case   39:*/		regs.R4 = regs.R28;
		/* 8206E4D4h case   39:*/		return 0x8206E4D8;
		  /* 8206E4D8h */ case   40:  		/* mr R3, R24 */
		/* 8206E4D8h case   40:*/		regs.R3 = regs.R24;
		/* 8206E4D8h case   40:*/		return 0x8206E4DC;
		  /* 8206E4DCh */ case   41:  		/* bl -31308 */
		/* 8206E4DCh case   41:*/		regs.LR = 0x8206E4E0; return 0x82066A90;
		/* 8206E4DCh case   41:*/		return 0x8206E4E0;
		  /* 8206E4E0h */ case   42:  		/* addi R5, R1, 240 */
		/* 8206E4E0h case   42:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xF0);
		/* 8206E4E0h case   42:*/		return 0x8206E4E4;
		  /* 8206E4E4h */ case   43:  		/* li R4, 0 */
		/* 8206E4E4h case   43:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206E4E4h case   43:*/		return 0x8206E4E8;
		  /* 8206E4E8h */ case   44:  		/* mr R3, R31 */
		/* 8206E4E8h case   44:*/		regs.R3 = regs.R31;
		/* 8206E4E8h case   44:*/		return 0x8206E4EC;
		  /* 8206E4ECh */ case   45:  		/* bl -38452 */
		/* 8206E4ECh case   45:*/		regs.LR = 0x8206E4F0; return 0x82064EB8;
		/* 8206E4ECh case   45:*/		return 0x8206E4F0;
		  /* 8206E4F0h */ case   46:  		/* li R4, 0 */
		/* 8206E4F0h case   46:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206E4F0h case   46:*/		return 0x8206E4F4;
		  /* 8206E4F4h */ case   47:  		/* mr R3, R31 */
		/* 8206E4F4h case   47:*/		regs.R3 = regs.R31;
		/* 8206E4F4h case   47:*/		return 0x8206E4F8;
		  /* 8206E4F8h */ case   48:  		/* bl -37552 */
		/* 8206E4F8h case   48:*/		regs.LR = 0x8206E4FC; return 0x82065248;
		/* 8206E4F8h case   48:*/		return 0x8206E4FC;
		  /* 8206E4FCh */ case   49:  		/* li R4, 0 */
		/* 8206E4FCh case   49:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206E4FCh case   49:*/		return 0x8206E500;
		  /* 8206E500h */ case   50:  		/* mr R3, R31 */
		/* 8206E500h case   50:*/		regs.R3 = regs.R31;
		/* 8206E500h case   50:*/		return 0x8206E504;
		  /* 8206E504h */ case   51:  		/* bl -45124 */
		/* 8206E504h case   51:*/		regs.LR = 0x8206E508; return 0x820634C0;
		/* 8206E504h case   51:*/		return 0x8206E508;
		  /* 8206E508h */ case   52:  		/* li R11, 1 */
		/* 8206E508h case   52:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206E508h case   52:*/		return 0x8206E50C;
		  /* 8206E50Ch */ case   53:  		/* lfs FR0, <#[R1 + 112]> */
		/* 8206E50Ch case   53:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 8206E50Ch case   53:*/		return 0x8206E510;
		  /* 8206E510h */ case   54:  		/* li R6, 0 */
		/* 8206E510h case   54:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206E510h case   54:*/		return 0x8206E514;
		  /* 8206E514h */ case   55:  		/* lfs FR13, <#[R1 + 116]> */
		/* 8206E514h case   55:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000074) );
		/* 8206E514h case   55:*/		return 0x8206E518;
		  /* 8206E518h */ case   56:  		/* rldicr R11, R11, 63, 63 */
		/* 8206E518h case   56:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R11,regs.R11);
		/* 8206E518h case   56:*/		return 0x8206E51C;
		  /* 8206E51Ch */ case   57:  		/* lfs FR12, <#[R1 + 120]> */
		/* 8206E51Ch case   57:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000078) );
		/* 8206E51Ch case   57:*/		return 0x8206E520;
		  /* 8206E520h */ case   58:  		/* oris R6, R6, 32768 */
		/* 8206E520h case   58:*/		cpu::op::oris<0>(regs,&regs.R6,regs.R6,0x8000);
		/* 8206E520h case   58:*/		return 0x8206E524;
		  /* 8206E524h */ case   59:  		/* lfs FR11, <#[R1 + 124]> */
		/* 8206E524h case   59:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R1 + 0x0000007C) );
		/* 8206E524h case   59:*/		return 0x8206E528;
		  /* 8206E528h */ case   60:  		/* mr R5, R23 */
		/* 8206E528h case   60:*/		regs.R5 = regs.R23;
		/* 8206E528h case   60:*/		return 0x8206E52C;
		  /* 8206E52Ch */ case   61:  		/* stfs FR0, <#[R31 + 6016]> */
		/* 8206E52Ch case   61:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x00001780) );
		/* 8206E52Ch case   61:*/		return 0x8206E530;
		  /* 8206E530h */ case   62:  		/* li R4, 0 */
		/* 8206E530h case   62:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206E530h case   62:*/		return 0x8206E534;
		  /* 8206E534h */ case   63:  		/* stfs FR13, <#[R31 + 6020]> */
		/* 8206E534h case   63:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R31 + 0x00001784) );
		/* 8206E534h case   63:*/		return 0x8206E538;
		  /* 8206E538h */ case   64:  		/* mr R3, R31 */
		/* 8206E538h case   64:*/		regs.R3 = regs.R31;
		/* 8206E538h case   64:*/		return 0x8206E53C;
		  /* 8206E53Ch */ case   65:  		/* stfs FR12, <#[R31 + 6024]> */
		/* 8206E53Ch case   65:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R31 + 0x00001788) );
		/* 8206E53Ch case   65:*/		return 0x8206E540;
		  /* 8206E540h */ case   66:  		/* stfs FR11, <#[R31 + 6028]> */
		/* 8206E540h case   66:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R31 + 0x0000178C) );
		/* 8206E540h case   66:*/		return 0x8206E544;
		  /* 8206E544h */ case   67:  		/* ld R10, <#[R31 + 8]> */
		/* 8206E544h case   67:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8206E544h case   67:*/		return 0x8206E548;
		  /* 8206E548h */ case   68:  		/* or R10, R10, R11 */
		/* 8206E548h case   68:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8206E548h case   68:*/		return 0x8206E54C;
		  /* 8206E54Ch */ case   69:  		/* std R10, <#[R31 + 8]> */
		/* 8206E54Ch case   69:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8206E54Ch case   69:*/		return 0x8206E550;
		  /* 8206E550h */ case   70:  		/* stfs FR31, <#[R31 + 6032]> */
		/* 8206E550h case   70:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R31 + 0x00001790) );
		/* 8206E550h case   70:*/		return 0x8206E554;
		  /* 8206E554h */ case   71:  		/* stfs FR30, <#[R31 + 6036]> */
		/* 8206E554h case   71:*/		cpu::mem::store32f( regs, regs.FR30, (uint32)(regs.R31 + 0x00001794) );
		/* 8206E554h case   71:*/		return 0x8206E558;
		  /* 8206E558h */ case   72:  		/* stfs FR31, <#[R31 + 6040]> */
		/* 8206E558h case   72:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R31 + 0x00001798) );
		/* 8206E558h case   72:*/		return 0x8206E55C;
		  /* 8206E55Ch */ case   73:  		/* stfs FR31, <#[R31 + 6044]> */
		/* 8206E55Ch case   73:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R31 + 0x0000179C) );
		/* 8206E55Ch case   73:*/		return 0x8206E560;
		  /* 8206E560h */ case   74:  		/* ld R10, <#[R31 + 8]> */
		/* 8206E560h case   74:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8206E560h case   74:*/		return 0x8206E564;
		  /* 8206E564h */ case   75:  		/* or R11, R10, R11 */
		/* 8206E564h case   75:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206E564h case   75:*/		return 0x8206E568;
		  /* 8206E568h */ case   76:  		/* std R11, <#[R31 + 8]> */
		/* 8206E568h case   76:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8206E568h case   76:*/		return 0x8206E56C;
		  /* 8206E56Ch */ case   77:  		/* bl -30204 */
		/* 8206E56Ch case   77:*/		regs.LR = 0x8206E570; return 0x82066F70;
		/* 8206E56Ch case   77:*/		return 0x8206E570;
		  /* 8206E570h */ case   78:  		/* lwz R11, <#[R31 + 1152]> */
		/* 8206E570h case   78:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000480) );
		/* 8206E570h case   78:*/		return 0x8206E574;
		  /* 8206E574h */ case   79:  		/* lis R12, -9 */
		/* 8206E574h case   79:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFF7);
		/* 8206E574h case   79:*/		return 0x8206E578;
		  /* 8206E578h */ case   80:  		/* rlwimi R11, R26, 11, 19, 21 */
		/* 8206E578h case   80:*/		cpu::op::rlwimi<0,11,19,21>(regs,&regs.R11,regs.R26);
		/* 8206E578h case   80:*/		return 0x8206E57C;
		  /* 8206E57Ch */ case   81:  		/* ori R12, R12, 65535 */
		/* 8206E57Ch case   81:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFFFF);
		/* 8206E57Ch case   81:*/		return 0x8206E580;
		  /* 8206E580h */ case   82:  		/* stw R11, <#[R31 + 1152]> */
		/* 8206E580h case   82:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000480) );
		/* 8206E580h case   82:*/		return 0x8206E584;
		  /* 8206E584h */ case   83:  		/* li R4, 0 */
		/* 8206E584h case   83:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206E584h case   83:*/		return 0x8206E588;
		  /* 8206E588h */ case   84:  		/* ld R11, <#[R31 + 24]> */
		/* 8206E588h case   84:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8206E588h case   84:*/		return 0x8206E58C;
		  /* 8206E58Ch */ case   85:  		/* oris R11, R11, 32768 */
		/* 8206E58Ch case   85:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8206E58Ch case   85:*/		return 0x8206E590;
		  /* 8206E590h */ case   86:  		/* std R11, <#[R31 + 24]> */
		/* 8206E590h case   86:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8206E590h case   86:*/		return 0x8206E594;
		  /* 8206E594h */ case   87:  		/* lwz R11, <#[R31 + 1152]> */
		/* 8206E594h case   87:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000480) );
		/* 8206E594h case   87:*/		return 0x8206E598;
		  /* 8206E598h */ case   88:  		/* rlwimi R11, R26, 14, 16, 18 */
		/* 8206E598h case   88:*/		cpu::op::rlwimi<0,14,16,18>(regs,&regs.R11,regs.R26);
		/* 8206E598h case   88:*/		return 0x8206E59C;
		  /* 8206E59Ch */ case   89:  		/* stw R11, <#[R31 + 1152]> */
		/* 8206E59Ch case   89:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000480) );
		/* 8206E59Ch case   89:*/		return 0x8206E5A0;
		  /* 8206E5A0h */ case   90:  		/* ld R11, <#[R31 + 24]> */
		/* 8206E5A0h case   90:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8206E5A0h case   90:*/		return 0x8206E5A4;
		  /* 8206E5A4h */ case   91:  		/* oris R11, R11, 32768 */
		/* 8206E5A4h case   91:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8206E5A4h case   91:*/		return 0x8206E5A8;
		  /* 8206E5A8h */ case   92:  		/* std R11, <#[R31 + 24]> */
		/* 8206E5A8h case   92:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8206E5A8h case   92:*/		return 0x8206E5AC;
		  /* 8206E5ACh */ case   93:  		/* ld R11, <#[R31 + 16]> */
		/* 8206E5ACh case   93:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E5ACh case   93:*/		return 0x8206E5B0;
		  /* 8206E5B0h */ case   94:  		/* and R11, R11, R12 */
		/* 8206E5B0h case   94:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206E5B0h case   94:*/		return 0x8206E5B4;
		  /* 8206E5B4h */ case   95:  		/* lis R12, -17 */
		/* 8206E5B4h case   95:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFEF);
		/* 8206E5B4h case   95:*/		return 0x8206E5B8;
	}
	return 0x8206E5B8;
} // Block from 8206E438h-8206E5B8h (96 instructions)

//////////////////////////////////////////////////////
// Block at 8206E5B8h
// Function 'XGSurfaceSize'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E5B8);
		  /* 8206E5B8h */ case    0:  		/* std R11, <#[R31 + 16]> */
		/* 8206E5B8h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E5B8h case    0:*/		return 0x8206E5BC;
		  /* 8206E5BCh */ case    1:  		/* ori R12, R12, 65535 */
		/* 8206E5BCh case    1:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFFFF);
		/* 8206E5BCh case    1:*/		return 0x8206E5C0;
		  /* 8206E5C0h */ case    2:  		/* and R11, R11, R12 */
		/* 8206E5C0h case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206E5C0h case    2:*/		return 0x8206E5C4;
		  /* 8206E5C4h */ case    3:  		/* lis R12, -2 */
		/* 8206E5C4h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFFE);
		/* 8206E5C4h case    3:*/		return 0x8206E5C8;
		  /* 8206E5C8h */ case    4:  		/* std R11, <#[R31 + 16]> */
		/* 8206E5C8h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E5C8h case    4:*/		return 0x8206E5CC;
		  /* 8206E5CCh */ case    5:  		/* ori R12, R12, 65535 */
		/* 8206E5CCh case    5:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFFFF);
		/* 8206E5CCh case    5:*/		return 0x8206E5D0;
		  /* 8206E5D0h */ case    6:  		/* and R11, R11, R12 */
		/* 8206E5D0h case    6:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206E5D0h case    6:*/		return 0x8206E5D4;
		  /* 8206E5D4h */ case    7:  		/* li R12, -2 */
		/* 8206E5D4h case    7:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFFFFFE);
		/* 8206E5D4h case    7:*/		return 0x8206E5D8;
		  /* 8206E5D8h */ case    8:  		/* std R11, <#[R31 + 16]> */
		/* 8206E5D8h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E5D8h case    8:*/		return 0x8206E5DC;
		  /* 8206E5DCh */ case    9:  		/* rldicr R12, R12, 56, 63 */
		/* 8206E5DCh case    9:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 8206E5DCh case    9:*/		return 0x8206E5E0;
		  /* 8206E5E0h */ case   10:  		/* ld R11, <#[R31 + 32]> */
		/* 8206E5E0h case   10:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8206E5E0h case   10:*/		return 0x8206E5E4;
		  /* 8206E5E4h */ case   11:  		/* and R11, R11, R12 */
		/* 8206E5E4h case   11:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206E5E4h case   11:*/		return 0x8206E5E8;
		  /* 8206E5E8h */ case   12:  		/* lis R12, -1 */
		/* 8206E5E8h case   12:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFFF);
		/* 8206E5E8h case   12:*/		return 0x8206E5EC;
		  /* 8206E5ECh */ case   13:  		/* std R11, <#[R31 + 32]> */
		/* 8206E5ECh case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8206E5ECh case   13:*/		return 0x8206E5F0;
		  /* 8206E5F0h */ case   14:  		/* ld R11, <#[R31 + 16]> */
		/* 8206E5F0h case   14:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E5F0h case   14:*/		return 0x8206E5F4;
		  /* 8206E5F4h */ case   15:  		/* ori R12, R12, 32767 */
		/* 8206E5F4h case   15:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x7FFF);
		/* 8206E5F4h case   15:*/		return 0x8206E5F8;
		  /* 8206E5F8h */ case   16:  		/* and R11, R11, R12 */
		/* 8206E5F8h case   16:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206E5F8h case   16:*/		return 0x8206E5FC;
		  /* 8206E5FCh */ case   17:  		/* li R12, -16385 */
		/* 8206E5FCh case   17:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFFBFFF);
		/* 8206E5FCh case   17:*/		return 0x8206E600;
		  /* 8206E600h */ case   18:  		/* std R11, <#[R31 + 16]> */
		/* 8206E600h case   18:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E600h case   18:*/		return 0x8206E604;
		  /* 8206E604h */ case   19:  		/* mr R3, R31 */
		/* 8206E604h case   19:*/		regs.R3 = regs.R31;
		/* 8206E604h case   19:*/		return 0x8206E608;
		  /* 8206E608h */ case   20:  		/* and R11, R11, R12 */
		/* 8206E608h case   20:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206E608h case   20:*/		return 0x8206E60C;
		  /* 8206E60Ch */ case   21:  		/* li R12, -9 */
		/* 8206E60Ch case   21:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFFFFF7);
		/* 8206E60Ch case   21:*/		return 0x8206E610;
		  /* 8206E610h */ case   22:  		/* std R11, <#[R31 + 16]> */
		/* 8206E610h case   22:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E610h case   22:*/		return 0x8206E614;
		  /* 8206E614h */ case   23:  		/* and R11, R11, R12 */
		/* 8206E614h case   23:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206E614h case   23:*/		return 0x8206E618;
		  /* 8206E618h */ case   24:  		/* std R11, <#[R31 + 16]> */
		/* 8206E618h case   24:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E618h case   24:*/		return 0x8206E61C;
		  /* 8206E61Ch */ case   25:  		/* bl -22068 */
		/* 8206E61Ch case   25:*/		regs.LR = 0x8206E620; return 0x82068FE8;
		/* 8206E61Ch case   25:*/		return 0x8206E620;
		  /* 8206E620h */ case   26:  		/* lwz R3, <#[R31 + 48]> */
		/* 8206E620h case   26:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206E620h case   26:*/		return 0x8206E624;
		  /* 8206E624h */ case   27:  		/* lwz R11, <#[R31 + 56]> */
		/* 8206E624h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8206E624h case   27:*/		return 0x8206E628;
	}
	return 0x8206E628;
} // Block from 8206E5B8h-8206E628h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8206E628h
// Function '?BlockSizeOfGpuFormat@D3D@@YAXKPAK0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E628);
		  /* 8206E628h */ case    0:  		/* cmplw CR6, R3, R11 */
		/* 8206E628h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8206E628h case    0:*/		return 0x8206E62C;
		  /* 8206E62Ch */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 8206E62Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x8206E638;  }
		/* 8206E62Ch case    1:*/		return 0x8206E630;
		  /* 8206E630h */ case    2:  		/* mr R3, R31 */
		/* 8206E630h case    2:*/		regs.R3 = regs.R31;
		/* 8206E630h case    2:*/		return 0x8206E634;
		  /* 8206E634h */ case    3:  		/* bl 23252 */
		/* 8206E634h case    3:*/		regs.LR = 0x8206E638; return 0x82074108;
		/* 8206E634h case    3:*/		return 0x8206E638;
	}
	return 0x8206E638;
} // Block from 8206E628h-8206E638h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206E638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E638);
		  /* 8206E638h */ case    0:  		/* lis R11, -16384 */
		/* 8206E638h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 8206E638h case    0:*/		return 0x8206E63C;
		  /* 8206E63Ch */ case    1:  		/* li R10, 768 */
		/* 8206E63Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x300);
		/* 8206E63Ch case    1:*/		return 0x8206E640;
		  /* 8206E640h */ case    2:  		/* ori R11, R11, 15104 */
		/* 8206E640h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3B00);
		/* 8206E640h case    2:*/		return 0x8206E644;
		  /* 8206E644h */ case    3:  		/* lis R9, -16359 */
		/* 8206E644h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC019);
		/* 8206E644h case    3:*/		return 0x8206E648;
		  /* 8206E648h */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206E648h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E648h case    4:*/		return 0x8206E64C;
		  /* 8206E64Ch */ case    5:  		/* li R8, 24 */
		/* 8206E64Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x18);
		/* 8206E64Ch case    5:*/		return 0x8206E650;
		  /* 8206E650h */ case    6:  		/* ori R9, R9, 11008 */
		/* 8206E650h case    6:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x2B00);
		/* 8206E650h case    6:*/		return 0x8206E654;
		  /* 8206E654h */ case    7:  		/* lis R7, -32256 */
		/* 8206E654h case    7:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8200);
		/* 8206E654h case    7:*/		return 0x8206E658;
		  /* 8206E658h */ case    8:  		/* li R5, 96 */
		/* 8206E658h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x60);
		/* 8206E658h case    8:*/		return 0x8206E65C;
		  /* 8206E65Ch */ case    9:  		/* addi R29, R7, 3608 */
		/* 8206E65Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R7,0xE18);
		/* 8206E65Ch case    9:*/		return 0x8206E660;
		  /* 8206E660h */ case   10:  		/* stwu R10, <#[R3 + 4]> */
		/* 8206E660h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E660h case   10:*/		return 0x8206E664;
		  /* 8206E664h */ case   11:  		/* mr R11, R27 */
		/* 8206E664h case   11:*/		regs.R11 = regs.R27;
		/* 8206E664h case   11:*/		return 0x8206E668;
		  /* 8206E668h */ case   12:  		/* mr R4, R29 */
		/* 8206E668h case   12:*/		regs.R4 = regs.R29;
		/* 8206E668h case   12:*/		return 0x8206E66C;
		  /* 8206E66Ch */ case   13:  		/* stwu R9, <#[R3 + 4]> */
		/* 8206E66Ch case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E66Ch case   13:*/		return 0x8206E670;
		  /* 8206E670h */ case   14:  		/* stwu R27, <#[R3 + 4]> */
		/* 8206E670h case   14:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E670h case   14:*/		return 0x8206E674;
		  /* 8206E674h */ case   15:  		/* mr R30, R3 */
		/* 8206E674h case   15:*/		regs.R30 = regs.R3;
		/* 8206E674h case   15:*/		return 0x8206E678;
		  /* 8206E678h */ case   16:  		/* stwu R8, <#[R30 + 4]> */
		/* 8206E678h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206E678h case   16:*/		return 0x8206E67C;
		  /* 8206E67Ch */ case   17:  		/* addi R3, R30, 4 */
		/* 8206E67Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 8206E67Ch case   17:*/		return 0x8206E680;
		  /* 8206E680h */ case   18:  		/* bl 144176 */
		/* 8206E680h case   18:*/		regs.LR = 0x8206E684; return 0x820919B0;
		/* 8206E680h case   18:*/		return 0x8206E684;
		  /* 8206E684h */ case   19:  		/* addi R11, R30, 96 */
		/* 8206E684h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x60);
		/* 8206E684h case   19:*/		return 0x8206E688;
		  /* 8206E688h */ case   20:  		/* li R4, 44 */
		/* 8206E688h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x2C);
		/* 8206E688h case   20:*/		return 0x8206E68C;
		  /* 8206E68Ch */ case   21:  		/* stw R11, <#[R31 + 48]> */
		/* 8206E68Ch case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8206E68Ch case   21:*/		return 0x8206E690;
		  /* 8206E690h */ case   22:  		/* mr R3, R31 */
		/* 8206E690h case   22:*/		regs.R3 = regs.R31;
		/* 8206E690h case   22:*/		return 0x8206E694;
		  /* 8206E694h */ case   23:  		/* bl 23724 */
		/* 8206E694h case   23:*/		regs.LR = 0x8206E698; return 0x82074340;
		/* 8206E694h case   23:*/		return 0x8206E698;
		  /* 8206E698h */ case   24:  		/* lis R11, -16347 */
		/* 8206E698h case   24:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC025);
		/* 8206E698h case   24:*/		return 0x8206E69C;
		  /* 8206E69Ch */ case   25:  		/* li R10, 36 */
		/* 8206E69Ch case   25:*/		cpu::op::li<0>(regs,&regs.R10,0x24);
		/* 8206E69Ch case   25:*/		return 0x8206E6A0;
		  /* 8206E6A0h */ case   26:  		/* ori R11, R11, 11008 */
		/* 8206E6A0h case   26:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2B00);
		/* 8206E6A0h case   26:*/		return 0x8206E6A4;
		  /* 8206E6A4h */ case   27:  		/* addi R4, R29, 96 */
		/* 8206E6A4h case   27:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0x60);
		/* 8206E6A4h case   27:*/		return 0x8206E6A8;
		  /* 8206E6A8h */ case   28:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206E6A8h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E6A8h case   28:*/		return 0x8206E6AC;
		  /* 8206E6ACh */ case   29:  		/* li R5, 144 */
		/* 8206E6ACh case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x90);
		/* 8206E6ACh case   29:*/		return 0x8206E6B0;
		  /* 8206E6B0h */ case   30:  		/* stwu R26, <#[R3 + 4]> */
		/* 8206E6B0h case   30:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E6B0h case   30:*/		return 0x8206E6B4;
		  /* 8206E6B4h */ case   31:  		/* mr R30, R3 */
		/* 8206E6B4h case   31:*/		regs.R30 = regs.R3;
		/* 8206E6B4h case   31:*/		return 0x8206E6B8;
		  /* 8206E6B8h */ case   32:  		/* stwu R10, <#[R30 + 4]> */
		/* 8206E6B8h case   32:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206E6B8h case   32:*/		return 0x8206E6BC;
		  /* 8206E6BCh */ case   33:  		/* addi R3, R30, 4 */
		/* 8206E6BCh case   33:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 8206E6BCh case   33:*/		return 0x8206E6C0;
	}
	return 0x8206E6C0;
} // Block from 8206E638h-8206E6C0h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8206E6C0h
// Function '?GetMaxMipLevels@D3D@@YAKKKKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E6C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E6C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E6C0);
		  /* 8206E6C0h */ case    0:  		/* bl 144112 */
		/* 8206E6C0h case    0:*/		regs.LR = 0x8206E6C4; return 0x820919B0;
		/* 8206E6C0h case    0:*/		return 0x8206E6C4;
		  /* 8206E6C4h */ case    1:  		/* addi R11, R30, 144 */
		/* 8206E6C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x90);
		/* 8206E6C4h case    1:*/		return 0x8206E6C8;
		  /* 8206E6C8h */ case    2:  		/* lis R10, 1 */
		/* 8206E6C8h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 8206E6C8h case    2:*/		return 0x8206E6CC;
		  /* 8206E6CCh */ case    3:  		/* lis R9, 4097 */
		/* 8206E6CCh case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x1001);
		/* 8206E6CCh case    3:*/		return 0x8206E6D0;
		  /* 8206E6D0h */ case    4:  		/* ori R10, R10, 8576 */
		/* 8206E6D0h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2180);
		/* 8206E6D0h case    4:*/		return 0x8206E6D4;
		  /* 8206E6D4h */ case    5:  		/* ori R9, R9, 257 */
		/* 8206E6D4h case    5:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x101);
		/* 8206E6D4h case    5:*/		return 0x8206E6D8;
		  /* 8206E6D8h */ case    6:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206E6D8h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206E6D8h case    6:*/		return 0x8206E6DC;
		  /* 8206E6DCh */ case    7:  		/* li R10, 4 */
		/* 8206E6DCh case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 8206E6DCh case    7:*/		return 0x8206E6E0;
		  /* 8206E6E0h */ case    8:  		/* li R8, 8712 */
		/* 8206E6E0h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x2208);
		/* 8206E6E0h case    8:*/		return 0x8206E6E4;
		  /* 8206E6E4h */ case    9:  		/* li R7, 4 */
		/* 8206E6E4h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 8206E6E4h case    9:*/		return 0x8206E6E8;
		  /* 8206E6E8h */ case   10:  		/* li R6, 32 */
		/* 8206E6E8h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x20);
		/* 8206E6E8h case   10:*/		return 0x8206E6EC;
		  /* 8206E6ECh */ case   11:  		/* li R5, 3 */
		/* 8206E6ECh case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8206E6ECh case   11:*/		return 0x8206E6F0;
		  /* 8206E6F0h */ case   12:  		/* stwu R9, <#[R11 + 4]> */
		/* 8206E6F0h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206E6F0h case   12:*/		return 0x8206E6F4;
		  /* 8206E6F4h */ case   13:  		/* li R4, 8 */
		/* 8206E6F4h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 8206E6F4h case   13:*/		return 0x8206E6F8;
		  /* 8206E6F8h */ case   14:  		/* mr R3, R31 */
		/* 8206E6F8h case   14:*/		regs.R3 = regs.R31;
		/* 8206E6F8h case   14:*/		return 0x8206E6FC;
		  /* 8206E6FCh */ case   15:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206E6FCh case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206E6FCh case   15:*/		return 0x8206E700;
		  /* 8206E700h */ case   16:  		/* stwu R8, <#[R11 + 4]> */
		/* 8206E700h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206E700h case   16:*/		return 0x8206E704;
		  /* 8206E704h */ case   17:  		/* stwu R7, <#[R11 + 4]> */
		/* 8206E704h case   17:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206E704h case   17:*/		return 0x8206E708;
		  /* 8206E708h */ case   18:  		/* stw R11, <#[R31 + 48]> */
		/* 8206E708h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8206E708h case   18:*/		return 0x8206E70C;
		  /* 8206E70Ch */ case   19:  		/* bl 8860 */
		/* 8206E70Ch case   19:*/		regs.LR = 0x8206E710; return 0x820709A8;
		/* 8206E70Ch case   19:*/		return 0x8206E710;
		  /* 8206E710h */ case   20:  		/* add R11, R25, R28 */
		/* 8206E710h case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R25,regs.R28);
		/* 8206E710h case   20:*/		return 0x8206E714;
		  /* 8206E714h */ case   21:  		/* rldicl R9, R24, 0, 32 */
		/* 8206E714h case   21:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R24);
		/* 8206E714h case   21:*/		return 0x8206E718;
		  /* 8206E718h */ case   22:  		/* stfs FR31, <#[R3]> */
		/* 8206E718h case   22:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R3 + 0x00000000) );
		/* 8206E718h case   22:*/		return 0x8206E71C;
		  /* 8206E71Ch */ case   23:  		/* rldicl R11, R11, 0, 32 */
		/* 8206E71Ch case   23:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 8206E71Ch case   23:*/		return 0x8206E720;
		  /* 8206E720h */ case   24:  		/* stfs FR31, <#[R3 + 4]> */
		/* 8206E720h case   24:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R3 + 0x00000004) );
		/* 8206E720h case   24:*/		return 0x8206E724;
		  /* 8206E724h */ case   25:  		/* rldicl R8, R28, 0, 32 */
		/* 8206E724h case   25:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R28);
		/* 8206E724h case   25:*/		return 0x8206E728;
		  /* 8206E728h */ case   26:  		/* std R9, <#[R1 + 136]> */
		/* 8206E728h case   26:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000088) );
		/* 8206E728h case   26:*/		return 0x8206E72C;
		  /* 8206E72Ch */ case   27:  		/* lfd FR0, <#[R1 + 136]> */
		/* 8206E72Ch case   27:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000088) );
		/* 8206E72Ch case   27:*/		return 0x8206E730;
		  /* 8206E730h */ case   28:  		/* std R11, <#[R1 + 136]> */
		/* 8206E730h case   28:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 8206E730h case   28:*/		return 0x8206E734;
		  /* 8206E734h */ case   29:  		/* std R8, <#[R1 + 144]> */
		/* 8206E734h case   29:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000090) );
		/* 8206E734h case   29:*/		return 0x8206E738;
		  /* 8206E738h */ case   30:  		/* lfd FR13, <#[R1 + 144]> */
		/* 8206E738h case   30:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000090) );
		/* 8206E738h case   30:*/		return 0x8206E73C;
		  /* 8206E73Ch */ case   31:  		/* lfd FR12, <#[R1 + 136]> */
		/* 8206E73Ch case   31:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000088) );
		/* 8206E73Ch case   31:*/		return 0x8206E740;
		  /* 8206E740h */ case   32:  		/* rldicl R11, R25, 0, 32 */
		/* 8206E740h case   32:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R25);
		/* 8206E740h case   32:*/		return 0x8206E744;
		  /* 8206E744h */ case   33:  		/* stfs FR31, <#[R3 + 8]> */
		/* 8206E744h case   33:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R3 + 0x00000008) );
		/* 8206E744h case   33:*/		return 0x8206E748;
	}
	return 0x8206E748;
} // Block from 8206E6C0h-8206E748h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8206E748h
// Function '?AlignTextureDimensions@D3D@@YAKPAK00KKKH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E748);
		  /* 8206E748h */ case    0:  		/* mr R10, R3 */
		/* 8206E748h case    0:*/		regs.R10 = regs.R3;
		/* 8206E748h case    0:*/		return 0x8206E74C;
		  /* 8206E74Ch */ case    1:  		/* std R11, <#[R1 + 144]> */
		/* 8206E74Ch case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 8206E74Ch case    1:*/		return 0x8206E750;
		  /* 8206E750h */ case    2:  		/* stfs FR30, <#[R3 + 12]> */
		/* 8206E750h case    2:*/		cpu::mem::store32f( regs, regs.FR30, (uint32)(regs.R3 + 0x0000000C) );
		/* 8206E750h case    2:*/		return 0x8206E754;
		  /* 8206E754h */ case    3:  		/* stfs FR31, <#[R3 + 16]> */
		/* 8206E754h case    3:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R3 + 0x00000010) );
		/* 8206E754h case    3:*/		return 0x8206E758;
		  /* 8206E758h */ case    4:  		/* fcfid FR0, FR0 */
		/* 8206E758h case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8206E758h case    4:*/		return 0x8206E75C;
		  /* 8206E75Ch */ case    5:  		/* lfd FR11, <#[R1 + 144]> */
		/* 8206E75Ch case    5:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000090) );
		/* 8206E75Ch case    5:*/		return 0x8206E760;
		  /* 8206E760h */ case    6:  		/* fcfid FR13, FR13 */
		/* 8206E760h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 8206E760h case    6:*/		return 0x8206E764;
		  /* 8206E764h */ case    7:  		/* fcfid FR11, FR11 */
		/* 8206E764h case    7:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 8206E764h case    7:*/		return 0x8206E768;
		  /* 8206E768h */ case    8:  		/* stfs FR31, <#[R3 + 24]> */
		/* 8206E768h case    8:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R3 + 0x00000018) );
		/* 8206E768h case    8:*/		return 0x8206E76C;
		  /* 8206E76Ch */ case    9:  		/* stfs FR31, <#[R3 + 36]> */
		/* 8206E76Ch case    9:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R3 + 0x00000024) );
		/* 8206E76Ch case    9:*/		return 0x8206E770;
		  /* 8206E770h */ case   10:  		/* fcfid FR12, FR12 */
		/* 8206E770h case   10:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 8206E770h case   10:*/		return 0x8206E774;
		  /* 8206E774h */ case   11:  		/* stfs FR31, <#[R3 + 40]> */
		/* 8206E774h case   11:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R3 + 0x00000028) );
		/* 8206E774h case   11:*/		return 0x8206E778;
		  /* 8206E778h */ case   12:  		/* frsp FR11, FR11 */
		/* 8206E778h case   12:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR11);
		/* 8206E778h case   12:*/		return 0x8206E77C;
		  /* 8206E77Ch */ case   13:  		/* frsp FR0, FR0 */
		/* 8206E77Ch case   13:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8206E77Ch case   13:*/		return 0x8206E780;
		  /* 8206E780h */ case   14:  		/* stfs FR30, <#[R3 + 44]> */
		/* 8206E780h case   14:*/		cpu::mem::store32f( regs, regs.FR30, (uint32)(regs.R3 + 0x0000002C) );
		/* 8206E780h case   14:*/		return 0x8206E784;
		  /* 8206E784h */ case   15:  		/* frsp FR13, FR13 */
		/* 8206E784h case   15:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 8206E784h case   15:*/		return 0x8206E788;
		  /* 8206E788h */ case   16:  		/* stfs FR11, <#[R10 + 20]> */
		/* 8206E788h case   16:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R10 + 0x00000014) );
		/* 8206E788h case   16:*/		return 0x8206E78C;
		  /* 8206E78Ch */ case   17:  		/* frsp FR12, FR12 */
		/* 8206E78Ch case   17:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 8206E78Ch case   17:*/		return 0x8206E790;
		  /* 8206E790h */ case   18:  		/* stfs FR11, <#[R10 + 28]> */
		/* 8206E790h case   18:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R10 + 0x0000001C) );
		/* 8206E790h case   18:*/		return 0x8206E794;
		  /* 8206E794h */ case   19:  		/* stfs FR11, <#[R10 + 52]> */
		/* 8206E794h case   19:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R10 + 0x00000034) );
		/* 8206E794h case   19:*/		return 0x8206E798;
		  /* 8206E798h */ case   20:  		/* mr R3, R31 */
		/* 8206E798h case   20:*/		regs.R3 = regs.R31;
		/* 8206E798h case   20:*/		return 0x8206E79C;
		  /* 8206E79Ch */ case   21:  		/* stfs FR31, <#[R10 + 56]> */
		/* 8206E79Ch case   21:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R10 + 0x00000038) );
		/* 8206E79Ch case   21:*/		return 0x8206E7A0;
		  /* 8206E7A0h */ case   22:  		/* stfs FR11, <#[R10 + 60]> */
		/* 8206E7A0h case   22:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R10 + 0x0000003C) );
		/* 8206E7A0h case   22:*/		return 0x8206E7A4;
		  /* 8206E7A4h */ case   23:  		/* stfs FR31, <#[R10 + 72]> */
		/* 8206E7A4h case   23:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R10 + 0x00000048) );
		/* 8206E7A4h case   23:*/		return 0x8206E7A8;
		  /* 8206E7A8h */ case   24:  		/* stfs FR30, <#[R10 + 76]> */
		/* 8206E7A8h case   24:*/		cpu::mem::store32f( regs, regs.FR30, (uint32)(regs.R10 + 0x0000004C) );
		/* 8206E7A8h case   24:*/		return 0x8206E7AC;
		  /* 8206E7ACh */ case   25:  		/* stfs FR0, <#[R10 + 32]> */
		/* 8206E7ACh case   25:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 8206E7ACh case   25:*/		return 0x8206E7B0;
		  /* 8206E7B0h */ case   26:  		/* stfs FR0, <#[R10 + 48]> */
		/* 8206E7B0h case   26:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000030) );
		/* 8206E7B0h case   26:*/		return 0x8206E7B4;
		  /* 8206E7B4h */ case   27:  		/* stfs FR0, <#[R10 + 64]> */
		/* 8206E7B4h case   27:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000040) );
		/* 8206E7B4h case   27:*/		return 0x8206E7B8;
		  /* 8206E7B8h */ case   28:  		/* stfs FR13, <#[R10 + 68]> */
		/* 8206E7B8h case   28:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R10 + 0x00000044) );
		/* 8206E7B8h case   28:*/		return 0x8206E7BC;
		  /* 8206E7BCh */ case   29:  		/* stfs FR0, <#[R10 + 80]> */
		/* 8206E7BCh case   29:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000050) );
		/* 8206E7BCh case   29:*/		return 0x8206E7C0;
		  /* 8206E7C0h */ case   30:  		/* stfs FR12, <#[R10 + 84]> */
		/* 8206E7C0h case   30:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R10 + 0x00000054) );
		/* 8206E7C0h case   30:*/		return 0x8206E7C4;
		  /* 8206E7C4h */ case   31:  		/* stfs FR31, <#[R10 + 88]> */
		/* 8206E7C4h case   31:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R10 + 0x00000058) );
		/* 8206E7C4h case   31:*/		return 0x8206E7C8;
		  /* 8206E7C8h */ case   32:  		/* stfs FR11, <#[R10 + 92]> */
		/* 8206E7C8h case   32:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R10 + 0x0000005C) );
		/* 8206E7C8h case   32:*/		return 0x8206E7CC;
		  /* 8206E7CCh */ case   33:  		/* bl 8652 */
		/* 8206E7CCh case   33:*/		regs.LR = 0x8206E7D0; return 0x82070998;
		/* 8206E7CCh case   33:*/		return 0x8206E7D0;
		  /* 8206E7D0h */ case   34:  		/* ld R11, <#[R31 + 16]> */
		/* 8206E7D0h case   34:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E7D0h case   34:*/		return 0x8206E7D4;
		  /* 8206E7D4h */ case   35:  		/* li R12, 1 */
		/* 8206E7D4h case   35:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206E7D4h case   35:*/		return 0x8206E7D8;
		  /* 8206E7D8h */ case   36:  		/* lwz R4, <#[R1 + 80]> */
		/* 8206E7D8h case   36:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8206E7D8h case   36:*/		return 0x8206E7DC;
		  /* 8206E7DCh */ case   37:  		/* oris R11, R11, 8 */
		/* 8206E7DCh case   37:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8206E7DCh case   37:*/		return 0x8206E7E0;
		  /* 8206E7E0h */ case   38:  		/* rldicr R12, R12, 56, 63 */
		/* 8206E7E0h case   38:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 8206E7E0h case   38:*/		return 0x8206E7E4;
		  /* 8206E7E4h */ case   39:  		/* std R11, <#[R31 + 16]> */
		/* 8206E7E4h case   39:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E7E4h case   39:*/		return 0x8206E7E8;
		  /* 8206E7E8h */ case   40:  		/* oris R11, R11, 16 */
		/* 8206E7E8h case   40:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206E7E8h case   40:*/		return 0x8206E7EC;
		  /* 8206E7ECh */ case   41:  		/* cmplwi CR6, R4, 0 */
		/* 8206E7ECh case   41:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8206E7ECh case   41:*/		return 0x8206E7F0;
		  /* 8206E7F0h */ case   42:  		/* std R11, <#[R31 + 16]> */
		/* 8206E7F0h case   42:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E7F0h case   42:*/		return 0x8206E7F4;
		  /* 8206E7F4h */ case   43:  		/* oris R11, R11, 1 */
		/* 8206E7F4h case   43:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206E7F4h case   43:*/		return 0x8206E7F8;
		  /* 8206E7F8h */ case   44:  		/* std R11, <#[R31 + 16]> */
		/* 8206E7F8h case   44:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E7F8h case   44:*/		return 0x8206E7FC;
		  /* 8206E7FCh */ case   45:  		/* ld R11, <#[R31 + 32]> */
		/* 8206E7FCh case   45:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8206E7FCh case   45:*/		return 0x8206E800;
		  /* 8206E800h */ case   46:  		/* or R11, R11, R12 */
		/* 8206E800h case   46:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206E800h case   46:*/		return 0x8206E804;
		  /* 8206E804h */ case   47:  		/* std R11, <#[R31 + 32]> */
		/* 8206E804h case   47:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8206E804h case   47:*/		return 0x8206E808;
		  /* 8206E808h */ case   48:  		/* ld R11, <#[R31 + 16]> */
		/* 8206E808h case   48:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E808h case   48:*/		return 0x8206E80C;
		  /* 8206E80Ch */ case   49:  		/* ori R11, R11, 32768 */
		/* 8206E80Ch case   49:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8206E80Ch case   49:*/		return 0x8206E810;
		  /* 8206E810h */ case   50:  		/* std R11, <#[R31 + 16]> */
		/* 8206E810h case   50:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E810h case   50:*/		return 0x8206E814;
		  /* 8206E814h */ case   51:  		/* ori R11, R11, 16384 */
		/* 8206E814h case   51:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 8206E814h case   51:*/		return 0x8206E818;
		  /* 8206E818h */ case   52:  		/* std R11, <#[R31 + 16]> */
		/* 8206E818h case   52:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E818h case   52:*/		return 0x8206E81C;
		  /* 8206E81Ch */ case   53:  		/* ori R11, R11, 8 */
		/* 8206E81Ch case   53:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8206E81Ch case   53:*/		return 0x8206E820;
		  /* 8206E820h */ case   54:  		/* std R11, <#[R31 + 16]> */
		/* 8206E820h case   54:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206E820h case   54:*/		return 0x8206E824;
		  /* 8206E824h */ case   55:  		/* bc 12, CR6_EQ, 20 */
		/* 8206E824h case   55:*/		if ( regs.CR[6].eq ) { return 0x8206E838;  }
		/* 8206E824h case   55:*/		return 0x8206E828;
		  /* 8206E828h */ case   56:  		/* mr R3, R31 */
		/* 8206E828h case   56:*/		regs.R3 = regs.R31;
		/* 8206E828h case   56:*/		return 0x8206E82C;
		  /* 8206E82Ch */ case   57:  		/* bl -22596 */
		/* 8206E82Ch case   57:*/		regs.LR = 0x8206E830; return 0x82068FE8;
		/* 8206E82Ch case   57:*/		return 0x8206E830;
		  /* 8206E830h */ case   58:  		/* lwz R3, <#[R1 + 80]> */
		/* 8206E830h case   58:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 8206E830h case   58:*/		return 0x8206E834;
		  /* 8206E834h */ case   59:  		/* bl 14612 */
		/* 8206E834h case   59:*/		regs.LR = 0x8206E838; return 0x82072148;
		/* 8206E834h case   59:*/		return 0x8206E838;
	}
	return 0x8206E838;
} // Block from 8206E748h-8206E838h (60 instructions)

//////////////////////////////////////////////////////
// Block at 8206E838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E838);
		  /* 8206E838h */ case    0:  		/* lwz R4, <#[R1 + 84]> */
		/* 8206E838h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 8206E838h case    0:*/		return 0x8206E83C;
		  /* 8206E83Ch */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 8206E83Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8206E83Ch case    1:*/		return 0x8206E840;
		  /* 8206E840h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8206E840h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206E854;  }
		/* 8206E840h case    2:*/		return 0x8206E844;
		  /* 8206E844h */ case    3:  		/* mr R3, R31 */
		/* 8206E844h case    3:*/		regs.R3 = regs.R31;
		/* 8206E844h case    3:*/		return 0x8206E848;
		  /* 8206E848h */ case    4:  		/* bl -23144 */
		/* 8206E848h case    4:*/		regs.LR = 0x8206E84C; return 0x82068DE0;
		/* 8206E848h case    4:*/		return 0x8206E84C;
		  /* 8206E84Ch */ case    5:  		/* lwz R3, <#[R1 + 84]> */
		/* 8206E84Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8206E84Ch case    5:*/		return 0x8206E850;
		  /* 8206E850h */ case    6:  		/* bl 14584 */
		/* 8206E850h case    6:*/		regs.LR = 0x8206E854; return 0x82072148;
		/* 8206E850h case    6:*/		return 0x8206E854;
	}
	return 0x8206E854;
} // Block from 8206E838h-8206E854h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206E854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E854);
		  /* 8206E854h */ case    0:  		/* li R6, 0 */
		/* 8206E854h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206E854h case    0:*/		return 0x8206E858;
		  /* 8206E858h */ case    1:  		/* li R5, 0 */
		/* 8206E858h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8206E858h case    1:*/		return 0x8206E85C;
		  /* 8206E85Ch */ case    2:  		/* oris R6, R6, 32768 */
		/* 8206E85Ch case    2:*/		cpu::op::oris<0>(regs,&regs.R6,regs.R6,0x8000);
		/* 8206E85Ch case    2:*/		return 0x8206E860;
		  /* 8206E860h */ case    3:  		/* li R4, 0 */
		/* 8206E860h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206E860h case    3:*/		return 0x8206E864;
		  /* 8206E864h */ case    4:  		/* mr R3, R31 */
		/* 8206E864h case    4:*/		regs.R3 = regs.R31;
		/* 8206E864h case    4:*/		return 0x8206E868;
	}
	return 0x8206E868;
} // Block from 8206E854h-8206E868h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206E868h
// Function '?FindTextureSize@D3D@@YAKKKKKKKHHKHKPAK00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E868);
		  /* 8206E868h */ case    0:  		/* bl -30968 */
		/* 8206E868h case    0:*/		regs.LR = 0x8206E86C; return 0x82066F70;
		/* 8206E868h case    0:*/		return 0x8206E86C;
		  /* 8206E86Ch */ case    1:  		/* mr R4, R22 */
		/* 8206E86Ch case    1:*/		regs.R4 = regs.R22;
		/* 8206E86Ch case    1:*/		return 0x8206E870;
		  /* 8206E870h */ case    2:  		/* mr R3, R31 */
		/* 8206E870h case    2:*/		regs.R3 = regs.R31;
		/* 8206E870h case    2:*/		return 0x8206E874;
		  /* 8206E874h */ case    3:  		/* bl -38444 */
		/* 8206E874h case    3:*/		regs.LR = 0x8206E878; return 0x82065248;
		/* 8206E874h case    3:*/		return 0x8206E878;
		  /* 8206E878h */ case    4:  		/* cmplwi CR6, R22, 0 */
		/* 8206E878h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8206E878h case    4:*/		return 0x8206E87C;
		  /* 8206E87Ch */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8206E87Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8206E888;  }
		/* 8206E87Ch case    5:*/		return 0x8206E880;
		  /* 8206E880h */ case    6:  		/* mr R3, R22 */
		/* 8206E880h case    6:*/		regs.R3 = regs.R22;
		/* 8206E880h case    6:*/		return 0x8206E884;
		  /* 8206E884h */ case    7:  		/* bl 14532 */
		/* 8206E884h case    7:*/		regs.LR = 0x8206E888; return 0x82072148;
		/* 8206E884h case    7:*/		return 0x8206E888;
	}
	return 0x8206E888;
} // Block from 8206E868h-8206E888h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206E888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E888);
		  /* 8206E888h */ case    0:  		/* addi R29, R1, 176 */
		/* 8206E888h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R1,0xB0);
		/* 8206E888h case    0:*/		return 0x8206E88C;
		  /* 8206E88Ch */ case    1:  		/* lwz R30, <#[R29]> */
		/* 8206E88Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000000) );
		/* 8206E88Ch case    1:*/		return 0x8206E890;
		  /* 8206E890h */ case    2:  		/* mr R4, R27 */
		/* 8206E890h case    2:*/		regs.R4 = regs.R27;
		/* 8206E890h case    2:*/		return 0x8206E894;
		  /* 8206E894h */ case    3:  		/* mr R3, R31 */
		/* 8206E894h case    3:*/		regs.R3 = regs.R31;
		/* 8206E894h case    3:*/		return 0x8206E898;
		  /* 8206E898h */ case    4:  		/* mr R5, R30 */
		/* 8206E898h case    4:*/		regs.R5 = regs.R30;
		/* 8206E898h case    4:*/		return 0x8206E89C;
		  /* 8206E89Ch */ case    5:  		/* bl -39396 */
		/* 8206E89Ch case    5:*/		regs.LR = 0x8206E8A0; return 0x82064EB8;
		/* 8206E89Ch case    5:*/		return 0x8206E8A0;
		  /* 8206E8A0h */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 8206E8A0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8206E8A0h case    6:*/		return 0x8206E8A4;
		  /* 8206E8A4h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 8206E8A4h case    7:*/		if ( regs.CR[6].eq ) { return 0x8206E8B0;  }
		/* 8206E8A4h case    7:*/		return 0x8206E8A8;
		  /* 8206E8A8h */ case    8:  		/* mr R3, R30 */
		/* 8206E8A8h case    8:*/		regs.R3 = regs.R30;
		/* 8206E8A8h case    8:*/		return 0x8206E8AC;
		  /* 8206E8ACh */ case    9:  		/* bl 14492 */
		/* 8206E8ACh case    9:*/		regs.LR = 0x8206E8B0; return 0x82072148;
		/* 8206E8ACh case    9:*/		return 0x8206E8B0;
	}
	return 0x8206E8B0;
} // Block from 8206E888h-8206E8B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206E8B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E8B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E8B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E8B0);
		  /* 8206E8B0h */ case    0:  		/* addi R27, R27, 1 */
		/* 8206E8B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8206E8B0h case    0:*/		return 0x8206E8B4;
		  /* 8206E8B4h */ case    1:  		/* addi R29, R29, 4 */
		/* 8206E8B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8206E8B4h case    1:*/		return 0x8206E8B8;
		  /* 8206E8B8h */ case    2:  		/* cmplwi CR6, R27, 4 */
		/* 8206E8B8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000004);
		/* 8206E8B8h case    2:*/		return 0x8206E8BC;
		  /* 8206E8BCh */ case    3:  		/* bc 12, CR6_LT, -48 */
		/* 8206E8BCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8206E88C;  }
		/* 8206E8BCh case    3:*/		return 0x8206E8C0;
		  /* 8206E8C0h */ case    4:  		/* addi R4, R1, 208 */
		/* 8206E8C0h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xD0);
		/* 8206E8C0h case    4:*/		return 0x8206E8C4;
		  /* 8206E8C4h */ case    5:  		/* mr R3, R31 */
		/* 8206E8C4h case    5:*/		regs.R3 = regs.R31;
		/* 8206E8C4h case    5:*/		return 0x8206E8C8;
		  /* 8206E8C8h */ case    6:  		/* bl -39616 */
		/* 8206E8C8h case    6:*/		regs.LR = 0x8206E8CC; return 0x82064E08;
		/* 8206E8C8h case    6:*/		return 0x8206E8CC;
		  /* 8206E8CCh */ case    7:  		/* addi R4, R1, 192 */
		/* 8206E8CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xC0);
		/* 8206E8CCh case    7:*/		return 0x8206E8D0;
		  /* 8206E8D0h */ case    8:  		/* mr R3, R31 */
		/* 8206E8D0h case    8:*/		regs.R3 = regs.R31;
		/* 8206E8D0h case    8:*/		return 0x8206E8D4;
		  /* 8206E8D4h */ case    9:  		/* bl -41852 */
		/* 8206E8D4h case    9:*/		regs.LR = 0x8206E8D8; return 0x82064558;
		/* 8206E8D4h case    9:*/		return 0x8206E8D8;
		  /* 8206E8D8h */ case   10:  		/* mr R4, R21 */
		/* 8206E8D8h case   10:*/		regs.R4 = regs.R21;
		/* 8206E8D8h case   10:*/		return 0x8206E8DC;
		  /* 8206E8DCh */ case   11:  		/* mr R3, R31 */
		/* 8206E8DCh case   11:*/		regs.R3 = regs.R31;
		/* 8206E8DCh case   11:*/		return 0x8206E8E0;
		  /* 8206E8E0h */ case   12:  		/* bl -46112 */
		/* 8206E8E0h case   12:*/		regs.LR = 0x8206E8E4; return 0x820634C0;
		/* 8206E8E0h case   12:*/		return 0x8206E8E4;
		  /* 8206E8E4h */ case   13:  		/* mr R3, R31 */
		/* 8206E8E4h case   13:*/		regs.R3 = regs.R31;
		/* 8206E8E4h case   13:*/		return 0x8206E8E8;
		  /* 8206E8E8h */ case   14:  		/* lwz R6, <#[R1 + 96]> */
		/* 8206E8E8h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 8206E8E8h case   14:*/		return 0x8206E8EC;
		  /* 8206E8ECh */ case   15:  		/* lwz R5, <#[R1 + 88]> */
		/* 8206E8ECh case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 8206E8ECh case   15:*/		return 0x8206E8F0;
		  /* 8206E8F0h */ case   16:  		/* lwz R4, <#[R1 + 92]> */
		/* 8206E8F0h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206E8F0h case   16:*/		return 0x8206E8F4;
		  /* 8206E8F4h */ case   17:  		/* bl -21804 */
		/* 8206E8F4h case   17:*/		regs.LR = 0x8206E8F8; return 0x820693C8;
		/* 8206E8F4h case   17:*/		return 0x8206E8F8;
		  /* 8206E8F8h */ case   18:  		/* mr R3, R31 */
		/* 8206E8F8h case   18:*/		regs.R3 = regs.R31;
		/* 8206E8F8h case   18:*/		return 0x8206E8FC;
		  /* 8206E8FCh */ case   19:  		/* lwz R6, <#[R1 + 96]> */
		/* 8206E8FCh case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 8206E8FCh case   19:*/		return 0x8206E900;
		  /* 8206E900h */ case   20:  		/* lwz R5, <#[R1 + 88]> */
		/* 8206E900h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 8206E900h case   20:*/		return 0x8206E904;
		  /* 8206E904h */ case   21:  		/* lwz R4, <#[R1 + 92]> */
		/* 8206E904h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206E904h case   21:*/		return 0x8206E908;
		  /* 8206E908h */ case   22:  		/* bl -21824 */
		/* 8206E908h case   22:*/		regs.LR = 0x8206E90C; return 0x820693C8;
		/* 8206E908h case   22:*/		return 0x8206E90C;
		  /* 8206E90Ch */ case   23:  		/* addi R1, R1, 656 */
		/* 8206E90Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x290);
		/* 8206E90Ch case   23:*/		return 0x8206E910;
		  /* 8206E910h */ case   24:  		/* lfd FR30, <#[R1 - 112]> */
		/* 8206E910h case   24:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFF90) );
		/* 8206E910h case   24:*/		return 0x8206E914;
		  /* 8206E914h */ case   25:  		/* lfd FR31, <#[R1 - 104]> */
		/* 8206E914h case   25:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF98) );
		/* 8206E914h case   25:*/		return 0x8206E918;
		  /* 8206E918h */ case   26:  		/* b 141684 */
		/* 8206E918h case   26:*/		return 0x8209128C;
		/* 8206E918h case   26:*/		return 0x8206E91C;
		  /* 8206E91Ch */ case   27:  		/* nop */
		/* 8206E91Ch case   27:*/		cpu::op::nop();
		/* 8206E91Ch case   27:*/		return 0x8206E920;
	}
	return 0x8206E920;
} // Block from 8206E8B0h-8206E920h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8206E920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E920);
		  /* 8206E920h */ case    0:  		/* mfspr R12, LR */
		/* 8206E920h case    0:*/		regs.R12 = regs.LR;
		/* 8206E920h case    0:*/		return 0x8206E924;
		  /* 8206E924h */ case    1:  		/* bl 141620 */
		/* 8206E924h case    1:*/		regs.LR = 0x8206E928; return 0x82091258;
		/* 8206E924h case    1:*/		return 0x8206E928;
		  /* 8206E928h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206E928h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206E928h case    2:*/		return 0x8206E92C;
		  /* 8206E92Ch */ case    3:  		/* mr R29, R4 */
		/* 8206E92Ch case    3:*/		regs.R29 = regs.R4;
		/* 8206E92Ch case    3:*/		return 0x8206E930;
		  /* 8206E930h */ case    4:  		/* li R4, 1 */
		/* 8206E930h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8206E930h case    4:*/		return 0x8206E934;
		  /* 8206E934h */ case    5:  		/* mr R31, R3 */
		/* 8206E934h case    5:*/		regs.R31 = regs.R3;
		/* 8206E934h case    5:*/		return 0x8206E938;
		  /* 8206E938h */ case    6:  		/* bl 49408 */
		/* 8206E938h case    6:*/		regs.LR = 0x8206E93C; return 0x8207AA38;
		/* 8206E938h case    6:*/		return 0x8206E93C;
		  /* 8206E93Ch */ case    7:  		/* li R4, 0 */
		/* 8206E93Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206E93Ch case    7:*/		return 0x8206E940;
		  /* 8206E940h */ case    8:  		/* mr R3, R31 */
		/* 8206E940h case    8:*/		regs.R3 = regs.R31;
		/* 8206E940h case    8:*/		return 0x8206E944;
		  /* 8206E944h */ case    9:  		/* bl 36012 */
		/* 8206E944h case    9:*/		regs.LR = 0x8206E948; return 0x820775F0;
		/* 8206E944h case    9:*/		return 0x8206E948;
		  /* 8206E948h */ case   10:  		/* li R28, -1 */
		/* 8206E948h case   10:*/		cpu::op::li<0>(regs,&regs.R28,0xFFFFFFFF);
		/* 8206E948h case   10:*/		return 0x8206E94C;
		  /* 8206E94Ch */ case   11:  		/* cmplwi CR6, R29, 0 */
		/* 8206E94Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8206E94Ch case   11:*/		return 0x8206E950;
		  /* 8206E950h */ case   12:  		/* bc 4, CR6_EQ, 140 */
		/* 8206E950h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8206E9DC;  }
		/* 8206E950h case   12:*/		return 0x8206E954;
		  /* 8206E954h */ case   13:  		/* lwz R11, <#[R31 + 24584]> */
		/* 8206E954h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00006008) );
		/* 8206E954h case   13:*/		return 0x8206E958;
		  /* 8206E958h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 8206E958h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206E958h case   14:*/		return 0x8206E95C;
		  /* 8206E95Ch */ case   15:  		/* bc 4, CR6_EQ, 128 */
		/* 8206E95Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x8206E9DC;  }
		/* 8206E95Ch case   15:*/		return 0x8206E960;
		  /* 8206E960h */ case   16:  		/* lwz R11, <#[R31 + 56]> */
		/* 8206E960h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8206E960h case   16:*/		return 0x8206E964;
		  /* 8206E964h */ case   17:  		/* lwz R3, <#[R31 + 48]> */
		/* 8206E964h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206E964h case   17:*/		return 0x8206E968;
		  /* 8206E968h */ case   18:  		/* cmplw CR6, R3, R11 */
		/* 8206E968h case   18:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8206E968h case   18:*/		return 0x8206E96C;
		  /* 8206E96Ch */ case   19:  		/* bc 4, CR6_GT, 12 */
		/* 8206E96Ch case   19:*/		if ( !regs.CR[6].gt ) { return 0x8206E978;  }
		/* 8206E96Ch case   19:*/		return 0x8206E970;
		  /* 8206E970h */ case   20:  		/* mr R3, R31 */
		/* 8206E970h case   20:*/		regs.R3 = regs.R31;
		/* 8206E970h case   20:*/		return 0x8206E974;
		  /* 8206E974h */ case   21:  		/* bl 22420 */
		/* 8206E974h case   21:*/		regs.LR = 0x8206E978; return 0x82074108;
		/* 8206E974h case   21:*/		return 0x8206E978;
	}
	return 0x8206E978;
} // Block from 8206E920h-8206E978h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8206E978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E978);
		  /* 8206E978h */ case    0:  		/* li R11, 1401 */
		/* 8206E978h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x579);
		/* 8206E978h case    0:*/		return 0x8206E97C;
		  /* 8206E97Ch */ case    1:  		/* li R10, 1 */
		/* 8206E97Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8206E97Ch case    1:*/		return 0x8206E980;
		  /* 8206E980h */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206E980h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E980h case    2:*/		return 0x8206E984;
		  /* 8206E984h */ case    3:  		/* lis R11, -16380 */
		/* 8206E984h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC004);
		/* 8206E984h case    3:*/		return 0x8206E988;
		  /* 8206E988h */ case    4:  		/* li R9, 19 */
		/* 8206E988h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x13);
		/* 8206E988h case    4:*/		return 0x8206E98C;
		  /* 8206E98Ch */ case    5:  		/* ori R11, R11, 15360 */
		/* 8206E98Ch case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3C00);
		/* 8206E98Ch case    5:*/		return 0x8206E990;
		  /* 8206E990h */ case    6:  		/* li R8, 1 */
		/* 8206E990h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8206E990h case    6:*/		return 0x8206E994;
		  /* 8206E994h */ case    7:  		/* li R6, 256 */
		/* 8206E994h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x100);
		/* 8206E994h case    7:*/		return 0x8206E998;
		  /* 8206E998h */ case    8:  		/* stwu R10, <#[R3 + 4]> */
		/* 8206E998h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E998h case    8:*/		return 0x8206E99C;
		  /* 8206E99Ch */ case    9:  		/* mr R7, R28 */
		/* 8206E99Ch case    9:*/		regs.R7 = regs.R28;
		/* 8206E99Ch case    9:*/		return 0x8206E9A0;
		  /* 8206E9A0h */ case   10:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206E9A0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E9A0h case   10:*/		return 0x8206E9A4;
		  /* 8206E9A4h */ case   11:  		/* stwu R9, <#[R3 + 4]> */
		/* 8206E9A4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E9A4h case   11:*/		return 0x8206E9A8;
		  /* 8206E9A8h */ case   12:  		/* lwz R11, <#[R31 + 11028]> */
		/* 8206E9A8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B14) );
		/* 8206E9A8h case   12:*/		return 0x8206E9AC;
		  /* 8206E9ACh */ case   13:  		/* addi R11, R11, 4 */
		/* 8206E9ACh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206E9ACh case   13:*/		return 0x8206E9B0;
		  /* 8206E9B0h */ case   14:  		/* rlwinm R10, R11, 12, 20, 31 */
		/* 8206E9B0h case   14:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R11);
		/* 8206E9B0h case   14:*/		return 0x8206E9B4;
		  /* 8206E9B4h */ case   15:  		/* rlwinm R11, R11, 0, 3, 31 */
		/* 8206E9B4h case   15:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R11,regs.R11);
		/* 8206E9B4h case   15:*/		return 0x8206E9B8;
		  /* 8206E9B8h */ case   16:  		/* addi R10, R10, 512 */
		/* 8206E9B8h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 8206E9B8h case   16:*/		return 0x8206E9BC;
		  /* 8206E9BCh */ case   17:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 8206E9BCh case   17:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 8206E9BCh case   17:*/		return 0x8206E9C0;
		  /* 8206E9C0h */ case   18:  		/* add R11, R10, R11 */
		/* 8206E9C0h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206E9C0h case   18:*/		return 0x8206E9C4;
		  /* 8206E9C4h */ case   19:  		/* ori R11, R11, 2 */
		/* 8206E9C4h case   19:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8206E9C4h case   19:*/		return 0x8206E9C8;
		  /* 8206E9C8h */ case   20:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206E9C8h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E9C8h case   20:*/		return 0x8206E9CC;
		  /* 8206E9CCh */ case   21:  		/* stwu R8, <#[R3 + 4]> */
		/* 8206E9CCh case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E9CCh case   21:*/		return 0x8206E9D0;
		  /* 8206E9D0h */ case   22:  		/* stwu R28, <#[R3 + 4]> */
		/* 8206E9D0h case   22:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E9D0h case   22:*/		return 0x8206E9D4;
		  /* 8206E9D4h */ case   23:  		/* stwu R6, <#[R3 + 4]> */
		/* 8206E9D4h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206E9D4h case   23:*/		return 0x8206E9D8;
		  /* 8206E9D8h */ case   24:  		/* stw R3, <#[R31 + 48]> */
		/* 8206E9D8h case   24:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206E9D8h case   24:*/		return 0x8206E9DC;
	}
	return 0x8206E9DC;
} // Block from 8206E978h-8206E9DCh (25 instructions)

//////////////////////////////////////////////////////
// Block at 8206E9DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206E9DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206E9DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206E9DC);
		  /* 8206E9DCh */ case    0:  		/* lwz R11, <#[R31 + 14000]> */
		/* 8206E9DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000036B0) );
		/* 8206E9DCh case    0:*/		return 0x8206E9E0;
		  /* 8206E9E0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8206E9E0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206E9E0h case    1:*/		return 0x8206E9E4;
		  /* 8206E9E4h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 8206E9E4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206EA18;  }
		/* 8206E9E4h case    2:*/		return 0x8206E9E8;
		  /* 8206E9E8h */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 8206E9E8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8206E9E8h case    3:*/		return 0x8206E9EC;
		  /* 8206E9ECh */ case    4:  		/* bc 12, CR6_EQ, 44 */
		/* 8206E9ECh case    4:*/		if ( regs.CR[6].eq ) { return 0x8206EA18;  }
		/* 8206E9ECh case    4:*/		return 0x8206E9F0;
		  /* 8206E9F0h */ case    5:  		/* cmplwi CR6, R11, 2 */
		/* 8206E9F0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 8206E9F0h case    5:*/		return 0x8206E9F4;
		  /* 8206E9F4h */ case    6:  		/* bc 12, CR6_EQ, 28 */
		/* 8206E9F4h case    6:*/		if ( regs.CR[6].eq ) { return 0x8206EA10;  }
		/* 8206E9F4h case    6:*/		return 0x8206E9F8;
		  /* 8206E9F8h */ case    7:  		/* addi R11, R11, -4 */
		/* 8206E9F8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8206E9F8h case    7:*/		return 0x8206E9FC;
		  /* 8206E9FCh */ case    8:  		/* li R10, 3 */
		/* 8206E9FCh case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8206E9FCh case    8:*/		return 0x8206EA00;
		  /* 8206EA00h */ case    9:  		/* addic R11, R11, -1 */
		/* 8206EA00h case    9:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8206EA00h case    9:*/		return 0x8206EA04;
		  /* 8206EA04h */ case   10:  		/* subfe R11, R11, R11 */
		/* 8206EA04h case   10:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206EA04h case   10:*/		return 0x8206EA08;
		  /* 8206EA08h */ case   11:  		/* and R11, R11, R10 */
		/* 8206EA08h case   11:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206EA08h case   11:*/		return 0x8206EA0C;
		  /* 8206EA0Ch */ case   12:  		/* b 16 */
		/* 8206EA0Ch case   12:*/		return 0x8206EA1C;
		/* 8206EA0Ch case   12:*/		return 0x8206EA10;
	}
	return 0x8206EA10;
} // Block from 8206E9DCh-8206EA10h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206EA10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EA10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EA10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EA10);
		  /* 8206EA10h */ case    0:  		/* li R11, 2 */
		/* 8206EA10h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8206EA10h case    0:*/		return 0x8206EA14;
		  /* 8206EA14h */ case    1:  		/* b 8 */
		/* 8206EA14h case    1:*/		return 0x8206EA1C;
		/* 8206EA14h case    1:*/		return 0x8206EA18;
	}
	return 0x8206EA18;
} // Block from 8206EA10h-8206EA18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206EA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EA18);
		  /* 8206EA18h */ case    0:  		/* li R11, 1 */
		/* 8206EA18h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206EA18h case    0:*/		return 0x8206EA1C;
	}
	return 0x8206EA1C;
} // Block from 8206EA18h-8206EA1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206EA1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EA1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EA1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EA1C);
		  /* 8206EA1Ch */ case    0:  		/* lwz R10, <#[R31 + 12284]> */
		/* 8206EA1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002FFC) );
		/* 8206EA1Ch case    0:*/		return 0x8206EA20;
		  /* 8206EA20h */ case    1:  		/* rlwinm R11, R11, 8, 0, 23 */
		/* 8206EA20h case    1:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R11,regs.R11);
		/* 8206EA20h case    1:*/		return 0x8206EA24;
		  /* 8206EA24h */ case    2:  		/* lwz R4, <#[R31 + 48]> */
		/* 8206EA24h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000030) );
		/* 8206EA24h case    2:*/		return 0x8206EA28;
		  /* 8206EA28h */ case    3:  		/* rlwinm R10, R10, 9, 25, 31 */
		/* 8206EA28h case    3:*/		cpu::op::rlwinm<0,9,25,31>(regs,&regs.R10,regs.R10);
		/* 8206EA28h case    3:*/		return 0x8206EA2C;
		  /* 8206EA2Ch */ case    4:  		/* lwz R9, <#[R31 + 56]> */
		/* 8206EA2Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000038) );
		/* 8206EA2Ch case    4:*/		return 0x8206EA30;
		  /* 8206EA30h */ case    5:  		/* or R11, R10, R11 */
		/* 8206EA30h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206EA30h case    5:*/		return 0x8206EA34;
		  /* 8206EA34h */ case    6:  		/* cmplw CR6, R4, R9 */
		/* 8206EA34h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R9);
		/* 8206EA34h case    6:*/		return 0x8206EA38;
		  /* 8206EA38h */ case    7:  		/* or R30, R11, R29 */
		/* 8206EA38h case    7:*/		cpu::op::or<0>(regs,&regs.R30,regs.R11,regs.R29);
		/* 8206EA38h case    7:*/		return 0x8206EA3C;
		  /* 8206EA3Ch */ case    8:  		/* bc 4, CR6_GT, 16 */
		/* 8206EA3Ch case    8:*/		if ( !regs.CR[6].gt ) { return 0x8206EA4C;  }
		/* 8206EA3Ch case    8:*/		return 0x8206EA40;
		  /* 8206EA40h */ case    9:  		/* mr R3, R31 */
		/* 8206EA40h case    9:*/		regs.R3 = regs.R31;
		/* 8206EA40h case    9:*/		return 0x8206EA44;
		  /* 8206EA44h */ case   10:  		/* bl 22212 */
		/* 8206EA44h case   10:*/		regs.LR = 0x8206EA48; return 0x82074108;
		/* 8206EA44h case   10:*/		return 0x8206EA48;
		  /* 8206EA48h */ case   11:  		/* mr R4, R3 */
		/* 8206EA48h case   11:*/		regs.R4 = regs.R3;
		/* 8206EA48h case   11:*/		return 0x8206EA4C;
	}
	return 0x8206EA4C;
} // Block from 8206EA1Ch-8206EA4Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206EA4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EA4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EA4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EA4C);
		  /* 8206EA4Ch */ case    0:  		/* lis R11, -32249 */
		/* 8206EA4Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8207);
		/* 8206EA4Ch case    0:*/		return 0x8206EA50;
		  /* 8206EA50h */ case    1:  		/* mr R7, R30 */
		/* 8206EA50h case    1:*/		regs.R7 = regs.R30;
		/* 8206EA50h case    1:*/		return 0x8206EA54;
		  /* 8206EA54h */ case    2:  		/* addi R6, R11, -8120 */
		/* 8206EA54h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFE048);
		/* 8206EA54h case    2:*/		return 0x8206EA58;
		  /* 8206EA58h */ case    3:  		/* li R5, 0 */
		/* 8206EA58h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8206EA58h case    3:*/		return 0x8206EA5C;
		  /* 8206EA5Ch */ case    4:  		/* mr R3, R31 */
		/* 8206EA5Ch case    4:*/		regs.R3 = regs.R31;
		/* 8206EA5Ch case    4:*/		return 0x8206EA60;
		  /* 8206EA60h */ case    5:  		/* bl 19800 */
		/* 8206EA60h case    5:*/		regs.LR = 0x8206EA64; return 0x820737B8;
		/* 8206EA60h case    5:*/		return 0x8206EA64;
		  /* 8206EA64h */ case    6:  		/* cmplwi CR6, R29, 0 */
		/* 8206EA64h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8206EA64h case    6:*/		return 0x8206EA68;
		  /* 8206EA68h */ case    7:  		/* stw R3, <#[R31 + 48]> */
		/* 8206EA68h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206EA68h case    7:*/		return 0x8206EA6C;
		  /* 8206EA6Ch */ case    8:  		/* bc 4, CR6_EQ, 116 */
		/* 8206EA6Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x8206EAE0;  }
		/* 8206EA6Ch case    8:*/		return 0x8206EA70;
		  /* 8206EA70h */ case    9:  		/* lwz R11, <#[R31 + 24584]> */
		/* 8206EA70h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00006008) );
		/* 8206EA70h case    9:*/		return 0x8206EA74;
		  /* 8206EA74h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 8206EA74h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206EA74h case   10:*/		return 0x8206EA78;
		  /* 8206EA78h */ case   11:  		/* bc 4, CR6_EQ, 104 */
		/* 8206EA78h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8206EAE0;  }
		/* 8206EA78h case   11:*/		return 0x8206EA7C;
		  /* 8206EA7Ch */ case   12:  		/* lwz R11, <#[R31 + 56]> */
		/* 8206EA7Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8206EA7Ch case   12:*/		return 0x8206EA80;
		  /* 8206EA80h */ case   13:  		/* cmplw CR6, R3, R11 */
		/* 8206EA80h case   13:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8206EA80h case   13:*/		return 0x8206EA84;
		  /* 8206EA84h */ case   14:  		/* bc 4, CR6_GT, 12 */
		/* 8206EA84h case   14:*/		if ( !regs.CR[6].gt ) { return 0x8206EA90;  }
		/* 8206EA84h case   14:*/		return 0x8206EA88;
		  /* 8206EA88h */ case   15:  		/* mr R3, R31 */
		/* 8206EA88h case   15:*/		regs.R3 = regs.R31;
		/* 8206EA88h case   15:*/		return 0x8206EA8C;
		  /* 8206EA8Ch */ case   16:  		/* bl 22140 */
		/* 8206EA8Ch case   16:*/		regs.LR = 0x8206EA90; return 0x82074108;
		/* 8206EA8Ch case   16:*/		return 0x8206EA90;
	}
	return 0x8206EA90;
} // Block from 8206EA4Ch-8206EA90h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8206EA90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EA90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EA90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EA90);
		  /* 8206EA90h */ case    0:  		/* lis R11, -16380 */
		/* 8206EA90h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC004);
		/* 8206EA90h case    0:*/		return 0x8206EA94;
		  /* 8206EA94h */ case    1:  		/* li R10, 19 */
		/* 8206EA94h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x13);
		/* 8206EA94h case    1:*/		return 0x8206EA98;
		  /* 8206EA98h */ case    2:  		/* ori R11, R11, 15360 */
		/* 8206EA98h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3C00);
		/* 8206EA98h case    2:*/		return 0x8206EA9C;
		  /* 8206EA9Ch */ case    3:  		/* li R9, 0 */
		/* 8206EA9Ch case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8206EA9Ch case    3:*/		return 0x8206EAA0;
		  /* 8206EAA0h */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206EAA0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206EAA0h case    4:*/		return 0x8206EAA4;
		  /* 8206EAA4h */ case    5:  		/* li R8, 256 */
		/* 8206EAA4h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x100);
		/* 8206EAA4h case    5:*/		return 0x8206EAA8;
		  /* 8206EAA8h */ case    6:  		/* stwu R10, <#[R3 + 4]> */
		/* 8206EAA8h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206EAA8h case    6:*/		return 0x8206EAAC;
		  /* 8206EAACh */ case    7:  		/* lwz R11, <#[R31 + 11028]> */
		/* 8206EAACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B14) );
		/* 8206EAACh case    7:*/		return 0x8206EAB0;
		  /* 8206EAB0h */ case    8:  		/* addi R11, R11, 4 */
		/* 8206EAB0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206EAB0h case    8:*/		return 0x8206EAB4;
		  /* 8206EAB4h */ case    9:  		/* rlwinm R10, R11, 12, 20, 31 */
		/* 8206EAB4h case    9:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R11);
		/* 8206EAB4h case    9:*/		return 0x8206EAB8;
		  /* 8206EAB8h */ case   10:  		/* rlwinm R11, R11, 0, 3, 31 */
		/* 8206EAB8h case   10:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R11,regs.R11);
		/* 8206EAB8h case   10:*/		return 0x8206EABC;
		  /* 8206EABCh */ case   11:  		/* addi R10, R10, 512 */
		/* 8206EABCh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 8206EABCh case   11:*/		return 0x8206EAC0;
		  /* 8206EAC0h */ case   12:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 8206EAC0h case   12:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 8206EAC0h case   12:*/		return 0x8206EAC4;
		  /* 8206EAC4h */ case   13:  		/* add R11, R10, R11 */
		/* 8206EAC4h case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206EAC4h case   13:*/		return 0x8206EAC8;
		  /* 8206EAC8h */ case   14:  		/* ori R11, R11, 2 */
		/* 8206EAC8h case   14:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8206EAC8h case   14:*/		return 0x8206EACC;
		  /* 8206EACCh */ case   15:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206EACCh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206EACCh case   15:*/		return 0x8206EAD0;
		  /* 8206EAD0h */ case   16:  		/* stwu R9, <#[R3 + 4]> */
		/* 8206EAD0h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206EAD0h case   16:*/		return 0x8206EAD4;
		  /* 8206EAD4h */ case   17:  		/* stwu R28, <#[R3 + 4]> */
		/* 8206EAD4h case   17:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206EAD4h case   17:*/		return 0x8206EAD8;
		  /* 8206EAD8h */ case   18:  		/* stwu R8, <#[R3 + 4]> */
		/* 8206EAD8h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206EAD8h case   18:*/		return 0x8206EADC;
		  /* 8206EADCh */ case   19:  		/* stw R3, <#[R31 + 48]> */
		/* 8206EADCh case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206EADCh case   19:*/		return 0x8206EAE0;
	}
	return 0x8206EAE0;
} // Block from 8206EA90h-8206EAE0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8206EAE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EAE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EAE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EAE0);
		  /* 8206EAE0h */ case    0:  		/* li R4, 0 */
		/* 8206EAE0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206EAE0h case    0:*/		return 0x8206EAE4;
		  /* 8206EAE4h */ case    1:  		/* mr R3, R31 */
		/* 8206EAE4h case    1:*/		regs.R3 = regs.R31;
		/* 8206EAE4h case    1:*/		return 0x8206EAE8;
		  /* 8206EAE8h */ case    2:  		/* bl 48976 */
		/* 8206EAE8h case    2:*/		regs.LR = 0x8206EAEC; return 0x8207AA38;
		/* 8206EAE8h case    2:*/		return 0x8206EAEC;
		  /* 8206EAECh */ case    3:  		/* lbz R11, <#[R31 + 11069]> */
		/* 8206EAECh case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 8206EAECh case    3:*/		return 0x8206EAF0;
		  /* 8206EAF0h */ case    4:  		/* ori R11, R11, 16 */
		/* 8206EAF0h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206EAF0h case    4:*/		return 0x8206EAF4;
		  /* 8206EAF4h */ case    5:  		/* stb R11, <#[R31 + 11069]> */
		/* 8206EAF4h case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 8206EAF4h case    5:*/		return 0x8206EAF8;
		  /* 8206EAF8h */ case    6:  		/* addi R1, R1, 128 */
		/* 8206EAF8h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206EAF8h case    6:*/		return 0x8206EAFC;
		  /* 8206EAFCh */ case    7:  		/* b 141228 */
		/* 8206EAFCh case    7:*/		return 0x820912A8;
		/* 8206EAFCh case    7:*/		return 0x8206EB00;
	}
	return 0x8206EB00;
} // Block from 8206EAE0h-8206EB00h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206EB00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EB00);
		  /* 8206EB00h */ case    0:  		/* mfspr R12, LR */
		/* 8206EB00h case    0:*/		regs.R12 = regs.LR;
		/* 8206EB00h case    0:*/		return 0x8206EB04;
		  /* 8206EB04h */ case    1:  		/* bl 141144 */
		/* 8206EB04h case    1:*/		regs.LR = 0x8206EB08; return 0x8209125C;
		/* 8206EB04h case    1:*/		return 0x8206EB08;
		  /* 8206EB08h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206EB08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206EB08h case    2:*/		return 0x8206EB0C;
		  /* 8206EB0Ch */ case    3:  		/* rlwinm R11, R4, 12, 20, 31 */
		/* 8206EB0Ch case    3:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R4);
		/* 8206EB0Ch case    3:*/		return 0x8206EB10;
		  /* 8206EB10h */ case    4:  		/* lwz R9, <#[R3 + 24392]> */
		/* 8206EB10h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00005F48) );
		/* 8206EB10h case    4:*/		return 0x8206EB14;
		  /* 8206EB14h */ case    5:  		/* rlwinm R10, R4, 0, 3, 31 */
		/* 8206EB14h case    5:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R4);
		/* 8206EB14h case    5:*/		return 0x8206EB18;
		  /* 8206EB18h */ case    6:  		/* addi R11, R11, 512 */
		/* 8206EB18h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8206EB18h case    6:*/		return 0x8206EB1C;
		  /* 8206EB1Ch */ case    7:  		/* mr R31, R3 */
		/* 8206EB1Ch case    7:*/		regs.R31 = regs.R3;
		/* 8206EB1Ch case    7:*/		return 0x8206EB20;
		  /* 8206EB20h */ case    8:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 8206EB20h case    8:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 8206EB20h case    8:*/		return 0x8206EB24;
		  /* 8206EB24h */ case    9:  		/* mr R29, R5 */
		/* 8206EB24h case    9:*/		regs.R29 = regs.R5;
		/* 8206EB24h case    9:*/		return 0x8206EB28;
		  /* 8206EB28h */ case   10:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 8206EB28h case   10:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 8206EB28h case   10:*/		return 0x8206EB2C;
		  /* 8206EB2Ch */ case   11:  		/* add R30, R11, R10 */
		/* 8206EB2Ch case   11:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 8206EB2Ch case   11:*/		return 0x8206EB30;
		  /* 8206EB30h */ case   12:  		/* bc 4, CR0_EQ, 116 */
		/* 8206EB30h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8206EBA4;  }
		/* 8206EB30h case   12:*/		return 0x8206EB34;
		  /* 8206EB34h */ case   13:  		/* lwz R11, <#[R3 + 24584]> */
		/* 8206EB34h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00006008) );
		/* 8206EB34h case   13:*/		return 0x8206EB38;
		  /* 8206EB38h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 8206EB38h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206EB38h case   14:*/		return 0x8206EB3C;
		  /* 8206EB3Ch */ case   15:  		/* bc 12, CR6_GT, 104 */
		/* 8206EB3Ch case   15:*/		if ( regs.CR[6].gt ) { return 0x8206EBA4;  }
		/* 8206EB3Ch case   15:*/		return 0x8206EB40;
		  /* 8206EB40h */ case   16:  		/* lwz R10, <#[R3 + 56]> */
		/* 8206EB40h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000038) );
		/* 8206EB40h case   16:*/		return 0x8206EB44;
		  /* 8206EB44h */ case   17:  		/* lwz R11, <#[R3 + 48]> */
		/* 8206EB44h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 8206EB44h case   17:*/		return 0x8206EB48;
		  /* 8206EB48h */ case   18:  		/* cmplw CR6, R11, R10 */
		/* 8206EB48h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8206EB48h case   18:*/		return 0x8206EB4C;
		  /* 8206EB4Ch */ case   19:  		/* bc 4, CR6_GT, 12 */
		/* 8206EB4Ch case   19:*/		if ( !regs.CR[6].gt ) { return 0x8206EB58;  }
		/* 8206EB4Ch case   19:*/		return 0x8206EB50;
		  /* 8206EB50h */ case   20:  		/* bl 21944 */
		/* 8206EB50h case   20:*/		regs.LR = 0x8206EB54; return 0x82074108;
		/* 8206EB50h case   20:*/		return 0x8206EB54;
		  /* 8206EB54h */ case   21:  		/* mr R11, R3 */
		/* 8206EB54h case   21:*/		regs.R11 = regs.R3;
		/* 8206EB54h case   21:*/		return 0x8206EB58;
	}
	return 0x8206EB58;
} // Block from 8206EB00h-8206EB58h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8206EB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EB58);
		  /* 8206EB58h */ case    0:  		/* li R10, 6212 */
		/* 8206EB58h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1844);
		/* 8206EB58h case    0:*/		return 0x8206EB5C;
		  /* 8206EB5Ch */ case    1:  		/* mr R4, R29 */
		/* 8206EB5Ch case    1:*/		regs.R4 = regs.R29;
		/* 8206EB5Ch case    1:*/		return 0x8206EB60;
		  /* 8206EB60h */ case    2:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206EB60h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206EB60h case    2:*/		return 0x8206EB64;
		  /* 8206EB64h */ case    3:  		/* mr R3, R31 */
		/* 8206EB64h case    3:*/		regs.R3 = regs.R31;
		/* 8206EB64h case    3:*/		return 0x8206EB68;
		  /* 8206EB68h */ case    4:  		/* stwu R30, <#[R11 + 4]> */
		/* 8206EB68h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206EB68h case    4:*/		return 0x8206EB6C;
		  /* 8206EB6Ch */ case    5:  		/* stw R11, <#[R31 + 48]> */
		/* 8206EB6Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8206EB6Ch case    5:*/		return 0x8206EB70;
		  /* 8206EB70h */ case    6:  		/* bl -2424 */
		/* 8206EB70h case    6:*/		regs.LR = 0x8206EB74; return 0x8206E1F8;
		/* 8206EB70h case    6:*/		return 0x8206EB74;
		  /* 8206EB74h */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 8206EB74h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8206EB74h case    7:*/		return 0x8206EB78;
		  /* 8206EB78h */ case    8:  		/* bc 4, CR6_EQ, 52 */
		/* 8206EB78h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8206EBAC;  }
		/* 8206EB78h case    8:*/		return 0x8206EB7C;
		  /* 8206EB7Ch */ case    9:  		/* lis R11, 10280 */
		/* 8206EB7Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0x2828);
		/* 8206EB7Ch case    9:*/		return 0x8206EB80;
		  /* 8206EB80h */ case   10:  		/* li R4, 0 */
		/* 8206EB80h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206EB80h case   10:*/		return 0x8206EB84;
		  /* 8206EB84h */ case   11:  		/* ori R11, R11, 310 */
		/* 8206EB84h case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x136);
		/* 8206EB84h case   11:*/		return 0x8206EB88;
		  /* 8206EB88h */ case   12:  		/* mr R3, R31 */
		/* 8206EB88h case   12:*/		regs.R3 = regs.R31;
		/* 8206EB88h case   12:*/		return 0x8206EB8C;
		  /* 8206EB8Ch */ case   13:  		/* cmpw CR6, R29, R11 */
		/* 8206EB8Ch case   13:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 8206EB8Ch case   13:*/		return 0x8206EB90;
		  /* 8206EB90h */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 8206EB90h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8206EB9C;  }
		/* 8206EB90h case   14:*/		return 0x8206EB94;
		  /* 8206EB94h */ case   15:  		/* bl 26068 */
		/* 8206EB94h case   15:*/		regs.LR = 0x8206EB98; return 0x82075168;
		/* 8206EB94h case   15:*/		return 0x8206EB98;
		  /* 8206EB98h */ case   16:  		/* b 20 */
		/* 8206EB98h case   16:*/		return 0x8206EBAC;
		/* 8206EB98h case   16:*/		return 0x8206EB9C;
	}
	return 0x8206EB9C;
} // Block from 8206EB58h-8206EB9Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8206EB9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EB9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EB9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EB9C);
		  /* 8206EB9Ch */ case    0:  		/* bl 25820 */
		/* 8206EB9Ch case    0:*/		regs.LR = 0x8206EBA0; return 0x82075078;
		/* 8206EB9Ch case    0:*/		return 0x8206EBA0;
		  /* 8206EBA0h */ case    1:  		/* b 12 */
		/* 8206EBA0h case    1:*/		return 0x8206EBAC;
		/* 8206EBA0h case    1:*/		return 0x8206EBA4;
	}
	return 0x8206EBA4;
} // Block from 8206EB9Ch-8206EBA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206EBA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EBA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EBA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EBA4);
		  /* 8206EBA4h */ case    0:  		/* mr R3, R31 */
		/* 8206EBA4h case    0:*/		regs.R3 = regs.R31;
		/* 8206EBA4h case    0:*/		return 0x8206EBA8;
		  /* 8206EBA8h */ case    1:  		/* bl -648 */
		/* 8206EBA8h case    1:*/		regs.LR = 0x8206EBAC; return 0x8206E920;
		/* 8206EBA8h case    1:*/		return 0x8206EBAC;
	}
	return 0x8206EBAC;
} // Block from 8206EBA4h-8206EBACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206EBACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EBAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EBAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EBAC);
		  /* 8206EBACh */ case    0:  		/* addi R1, R1, 112 */
		/* 8206EBACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206EBACh case    0:*/		return 0x8206EBB0;
		  /* 8206EBB0h */ case    1:  		/* b 141052 */
		/* 8206EBB0h case    1:*/		return 0x820912AC;
		/* 8206EBB0h case    1:*/		return 0x8206EBB4;
		  /* 8206EBB4h */ case    2:  		/* nop */
		/* 8206EBB4h case    2:*/		cpu::op::nop();
		/* 8206EBB4h case    2:*/		return 0x8206EBB8;
	}
	return 0x8206EBB8;
} // Block from 8206EBACh-8206EBB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206EBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EBB8);
		  /* 8206EBB8h */ case    0:  		/* mfspr R12, LR */
		/* 8206EBB8h case    0:*/		regs.R12 = regs.LR;
		/* 8206EBB8h case    0:*/		return 0x8206EBBC;
		  /* 8206EBBCh */ case    1:  		/* bl 140900 */
		/* 8206EBBCh case    1:*/		regs.LR = 0x8206EBC0; return 0x82091220;
		/* 8206EBBCh case    1:*/		return 0x8206EBC0;
		  /* 8206EBC0h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 8206EBC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 8206EBC0h case    2:*/		return 0x8206EBC4;
		  /* 8206EBC4h */ case    3:  		/* rlwinm R11, R5, 12, 20, 31 */
		/* 8206EBC4h case    3:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R5);
		/* 8206EBC4h case    3:*/		return 0x8206EBC8;
		  /* 8206EBC8h */ case    4:  		/* mr R28, R9 */
		/* 8206EBC8h case    4:*/		regs.R28 = regs.R9;
		/* 8206EBC8h case    4:*/		return 0x8206EBCC;
		  /* 8206EBCCh */ case    5:  		/* lwz R9, <#[R3 + 24392]> */
		/* 8206EBCCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00005F48) );
		/* 8206EBCCh case    5:*/		return 0x8206EBD0;
		  /* 8206EBD0h */ case    6:  		/* addi R11, R11, 512 */
		/* 8206EBD0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8206EBD0h case    6:*/		return 0x8206EBD4;
		  /* 8206EBD4h */ case    7:  		/* mr R23, R10 */
		/* 8206EBD4h case    7:*/		regs.R23 = regs.R10;
		/* 8206EBD4h case    7:*/		return 0x8206EBD8;
		  /* 8206EBD8h */ case    8:  		/* rlwinm R10, R5, 0, 3, 31 */
		/* 8206EBD8h case    8:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R5);
		/* 8206EBD8h case    8:*/		return 0x8206EBDC;
		  /* 8206EBDCh */ case    9:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 8206EBDCh case    9:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 8206EBDCh case    9:*/		return 0x8206EBE0;
		  /* 8206EBE0h */ case   10:  		/* mr R31, R3 */
		/* 8206EBE0h case   10:*/		regs.R31 = regs.R3;
		/* 8206EBE0h case   10:*/		return 0x8206EBE4;
		  /* 8206EBE4h */ case   11:  		/* mr R26, R4 */
		/* 8206EBE4h case   11:*/		regs.R26 = regs.R4;
		/* 8206EBE4h case   11:*/		return 0x8206EBE8;
	}
	return 0x8206EBE8;
} // Block from 8206EBB8h-8206EBE8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206EBE8h
// Function '?GetTextureDimensions@D3D@@YAXPBUD3DBaseTexture@@PAK11@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EBE8);
		  /* 8206EBE8h */ case    0:  		/* mr R24, R6 */
		/* 8206EBE8h case    0:*/		regs.R24 = regs.R6;
		/* 8206EBE8h case    0:*/		return 0x8206EBEC;
		  /* 8206EBECh */ case    1:  		/* mr R30, R7 */
		/* 8206EBECh case    1:*/		regs.R30 = regs.R7;
		/* 8206EBECh case    1:*/		return 0x8206EBF0;
		  /* 8206EBF0h */ case    2:  		/* mr R29, R8 */
		/* 8206EBF0h case    2:*/		regs.R29 = regs.R8;
		/* 8206EBF0h case    2:*/		return 0x8206EBF4;
		  /* 8206EBF4h */ case    3:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 8206EBF4h case    3:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 8206EBF4h case    3:*/		return 0x8206EBF8;
		  /* 8206EBF8h */ case    4:  		/* add R25, R11, R10 */
		/* 8206EBF8h case    4:*/		cpu::op::add<0>(regs,&regs.R25,regs.R11,regs.R10);
		/* 8206EBF8h case    4:*/		return 0x8206EBFC;
		  /* 8206EBFCh */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 8206EBFCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x8206EC0C;  }
		/* 8206EBFCh case    5:*/		return 0x8206EC00;
		  /* 8206EC00h */ case    6:  		/* lwz R11, <#[R3 + 24584]> */
		/* 8206EC00h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00006008) );
		/* 8206EC00h case    6:*/		return 0x8206EC04;
		  /* 8206EC04h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 8206EC04h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206EC04h case    7:*/		return 0x8206EC08;
		  /* 8206EC08h */ case    8:  		/* bc 4, CR6_GT, 16 */
		/* 8206EC08h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8206EC18;  }
		/* 8206EC08h case    8:*/		return 0x8206EC0C;
	}
	return 0x8206EC0C;
} // Block from 8206EBE8h-8206EC0Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206EC0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EC0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EC0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EC0C);
		  /* 8206EC0Ch */ case    0:  		/* li R4, 0 */
		/* 8206EC0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206EC0Ch case    0:*/		return 0x8206EC10;
		  /* 8206EC10h */ case    1:  		/* mr R3, R31 */
		/* 8206EC10h case    1:*/		regs.R3 = regs.R31;
		/* 8206EC10h case    1:*/		return 0x8206EC14;
		  /* 8206EC14h */ case    2:  		/* bl -756 */
		/* 8206EC14h case    2:*/		regs.LR = 0x8206EC18; return 0x8206E920;
		/* 8206EC14h case    2:*/		return 0x8206EC18;
	}
	return 0x8206EC18;
} // Block from 8206EC0Ch-8206EC18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206EC18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EC18);
		  /* 8206EC18h */ case    0:  		/* rlwinm. R27, R26, 0, 29, 29 */
		/* 8206EC18h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R27,regs.R26);
		/* 8206EC18h case    0:*/		return 0x8206EC1C;
		  /* 8206EC1Ch */ case    1:  		/* bc 12, CR0_EQ, 200 */
		/* 8206EC1Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8206ECE4;  }
		/* 8206EC1Ch case    1:*/		return 0x8206EC20;
		  /* 8206EC20h */ case    2:  		/* lwz R11, <#[R31 + 56]> */
		/* 8206EC20h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8206EC20h case    2:*/		return 0x8206EC24;
		  /* 8206EC24h */ case    3:  		/* lwz R3, <#[R31 + 48]> */
		/* 8206EC24h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206EC24h case    3:*/		return 0x8206EC28;
		  /* 8206EC28h */ case    4:  		/* cmplw CR6, R3, R11 */
		/* 8206EC28h case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8206EC28h case    4:*/		return 0x8206EC2C;
		  /* 8206EC2Ch */ case    5:  		/* bc 4, CR6_GT, 12 */
		/* 8206EC2Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x8206EC38;  }
		/* 8206EC2Ch case    5:*/		return 0x8206EC30;
		  /* 8206EC30h */ case    6:  		/* mr R3, R31 */
		/* 8206EC30h case    6:*/		regs.R3 = regs.R31;
		/* 8206EC30h case    6:*/		return 0x8206EC34;
		  /* 8206EC34h */ case    7:  		/* bl 21716 */
		/* 8206EC34h case    7:*/		regs.LR = 0x8206EC38; return 0x82074108;
		/* 8206EC34h case    7:*/		return 0x8206EC38;
	}
	return 0x8206EC38;
} // Block from 8206EC18h-8206EC38h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206EC38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EC38);
		  /* 8206EC38h */ case    0:  		/* li R11, 6515 */
		/* 8206EC38h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1973);
		/* 8206EC38h case    0:*/		return 0x8206EC3C;
		  /* 8206EC3Ch */ case    1:  		/* lis R10, 1 */
		/* 8206EC3Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 8206EC3Ch case    1:*/		return 0x8206EC40;
		  /* 8206EC40h */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206EC40h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206EC40h case    2:*/		return 0x8206EC44;
		  /* 8206EC44h */ case    3:  		/* li R11, 6500 */
		/* 8206EC44h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1964);
		/* 8206EC44h case    3:*/		return 0x8206EC48;
		  /* 8206EC48h */ case    4:  		/* li R9, 1 */
		/* 8206EC48h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8206EC48h case    4:*/		return 0x8206EC4C;
		  /* 8206EC4Ch */ case    5:  		/* li R8, 6515 */
		/* 8206EC4Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x1973);
		/* 8206EC4Ch case    5:*/		return 0x8206EC50;
		  /* 8206EC50h */ case    6:  		/* li R22, 0 */
		/* 8206EC50h case    6:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 8206EC50h case    6:*/		return 0x8206EC54;
		  /* 8206EC54h */ case    7:  		/* lis R7, -16380 */
		/* 8206EC54h case    7:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFFC004);
		/* 8206EC54h case    7:*/		return 0x8206EC58;
		  /* 8206EC58h */ case    8:  		/* stwu R10, <#[R3 + 4]> */
		/* 8206EC58h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206EC58h case    8:*/		return 0x8206EC5C;
		  /* 8206EC5Ch */ case    9:  		/* li R21, 3 */
		/* 8206EC5Ch case    9:*/		cpu::op::li<0>(regs,&regs.R21,0x3);
		/* 8206EC5Ch case    9:*/		return 0x8206EC60;
		  /* 8206EC60h */ case   10:  		/* ori R10, R7, 15360 */
		/* 8206EC60h case   10:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R7,0x3C00);
		/* 8206EC60h case   10:*/		return 0x8206EC64;
		  /* 8206EC64h */ case   11:  		/* li R20, 6515 */
		/* 8206EC64h case   11:*/		cpu::op::li<0>(regs,&regs.R20,0x1973);
		/* 8206EC64h case   11:*/		return 0x8206EC68;
		  /* 8206EC68h */ case   12:  		/* li R19, 0 */
		/* 8206EC68h case   12:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8206EC68h case   12:*/		return 0x8206EC6C;
		  /* 8206EC6Ch */ case   13:  		/* li R18, 1 */
		/* 8206EC6Ch case   13:*/		cpu::op::li<0>(regs,&regs.R18,0x1);
		/* 8206EC6Ch case   13:*/		return 0x8206EC70;
		  /* 8206EC70h */ case   14:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206EC70h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206EC70h case   14:*/		return 0x8206EC74;
		  /* 8206EC74h */ case   15:  		/* li R7, 1 */
		/* 8206EC74h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8206EC74h case   15:*/		return 0x8206EC78;
		  /* 8206EC78h */ case   16:  		/* stw R7, <#[R1 + 80]> */
		/* 8206EC78h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8206EC78h case   16:*/		return 0x8206EC7C;
		  /* 8206EC7Ch */ case   17:  		/* li R17, 256 */
		/* 8206EC7Ch case   17:*/		cpu::op::li<0>(regs,&regs.R17,0x100);
		/* 8206EC7Ch case   17:*/		return 0x8206EC80;
	}
	return 0x8206EC80;
} // Block from 8206EC38h-8206EC80h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206EC80h
// Function '?GetGpuTextureDimensions@D3D@@YAXPBTGPUTEXTURE_FETCH_CONSTANT@@PAK11@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EC80);
		  /* 8206EC80h */ case    0:  		/* mr R14, R3 */
		/* 8206EC80h case    0:*/		regs.R14 = regs.R3;
		/* 8206EC80h case    0:*/		return 0x8206EC84;
		  /* 8206EC84h */ case    1:  		/* li R16, 6226 */
		/* 8206EC84h case    1:*/		cpu::op::li<0>(regs,&regs.R16,0x1852);
		/* 8206EC84h case    1:*/		return 0x8206EC88;
		  /* 8206EC88h */ case    2:  		/* li R11, 0 */
		/* 8206EC88h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206EC88h case    2:*/		return 0x8206EC8C;
		  /* 8206EC8Ch */ case    3:  		/* li R15, 6200 */
		/* 8206EC8Ch case    3:*/		cpu::op::li<0>(regs,&regs.R15,0x1838);
		/* 8206EC8Ch case    3:*/		return 0x8206EC90;
		  /* 8206EC90h */ case    4:  		/* li R7, 0 */
		/* 8206EC90h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8206EC90h case    4:*/		return 0x8206EC94;
		  /* 8206EC94h */ case    5:  		/* stwu R9, <#[R14 + 4]> */
		/* 8206EC94h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206EC94h case    5:*/		return 0x8206EC98;
		  /* 8206EC98h */ case    6:  		/* mr R6, R28 */
		/* 8206EC98h case    6:*/		regs.R6 = regs.R28;
		/* 8206EC98h case    6:*/		return 0x8206EC9C;
		  /* 8206EC9Ch */ case    7:  		/* mr R5, R29 */
		/* 8206EC9Ch case    7:*/		regs.R5 = regs.R29;
		/* 8206EC9Ch case    7:*/		return 0x8206ECA0;
		  /* 8206ECA0h */ case    8:  		/* mr R4, R30 */
		/* 8206ECA0h case    8:*/		regs.R4 = regs.R30;
		/* 8206ECA0h case    8:*/		return 0x8206ECA4;
		  /* 8206ECA4h */ case    9:  		/* mr R3, R31 */
		/* 8206ECA4h case    9:*/		regs.R3 = regs.R31;
		/* 8206ECA4h case    9:*/		return 0x8206ECA8;
		  /* 8206ECA8h */ case   10:  		/* stwu R8, <#[R14 + 4]> */
		/* 8206ECA8h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECA8h case   10:*/		return 0x8206ECAC;
		  /* 8206ECACh */ case   11:  		/* stwu R22, <#[R14 + 4]> */
		/* 8206ECACh case   11:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECACh case   11:*/		return 0x8206ECB0;
		  /* 8206ECB0h */ case   12:  		/* stwu R10, <#[R14 + 4]> */
		/* 8206ECB0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECB0h case   12:*/		return 0x8206ECB4;
		  /* 8206ECB4h */ case   13:  		/* stwu R21, <#[R14 + 4]> */
		/* 8206ECB4h case   13:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECB4h case   13:*/		return 0x8206ECB8;
		  /* 8206ECB8h */ case   14:  		/* stwu R20, <#[R14 + 4]> */
		/* 8206ECB8h case   14:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECB8h case   14:*/		return 0x8206ECBC;
		  /* 8206ECBCh */ case   15:  		/* stwu R19, <#[R14 + 4]> */
		/* 8206ECBCh case   15:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECBCh case   15:*/		return 0x8206ECC0;
		  /* 8206ECC0h */ case   16:  		/* stwu R18, <#[R14 + 4]> */
		/* 8206ECC0h case   16:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECC0h case   16:*/		return 0x8206ECC4;
		  /* 8206ECC4h */ case   17:  		/* stwu R17, <#[R14 + 4]> */
		/* 8206ECC4h case   17:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECC4h case   17:*/		return 0x8206ECC8;
		  /* 8206ECC8h */ case   18:  		/* stwu R16, <#[R14 + 4]> */
		/* 8206ECC8h case   18:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECC8h case   18:*/		return 0x8206ECCC;
		  /* 8206ECCCh */ case   19:  		/* stwu R11, <#[R14 + 4]> */
		/* 8206ECCCh case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECCCh case   19:*/		return 0x8206ECD0;
		  /* 8206ECD0h */ case   20:  		/* lwz R11, <#[R1 + 80]> */
		/* 8206ECD0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206ECD0h case   20:*/		return 0x8206ECD4;
		  /* 8206ECD4h */ case   21:  		/* stwu R15, <#[R14 + 4]> */
		/* 8206ECD4h case   21:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECD4h case   21:*/		return 0x8206ECD8;
		  /* 8206ECD8h */ case   22:  		/* stwu R11, <#[R14 + 4]> */
		/* 8206ECD8h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000004) );
		regs.R14 = (uint32)(regs.R14 + 0x00000004);
		/* 8206ECD8h case   22:*/		return 0x8206ECDC;
		  /* 8206ECDCh */ case   23:  		/* stw R14, <#[R31 + 48]> */
		/* 8206ECDCh case   23:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R31 + 0x00000030) );
		/* 8206ECDCh case   23:*/		return 0x8206ECE0;
		  /* 8206ECE0h */ case   24:  		/* bl 56336 */
		/* 8206ECE0h case   24:*/		regs.LR = 0x8206ECE4; return 0x8207C8F0;
		/* 8206ECE0h case   24:*/		return 0x8206ECE4;
	}
	return 0x8206ECE4;
} // Block from 8206EC80h-8206ECE4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8206ECE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206ECE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206ECE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206ECE4);
		  /* 8206ECE4h */ case    0:  		/* mr R4, R24 */
		/* 8206ECE4h case    0:*/		regs.R4 = regs.R24;
		/* 8206ECE4h case    0:*/		return 0x8206ECE8;
		  /* 8206ECE8h */ case    1:  		/* mr R3, R31 */
		/* 8206ECE8h case    1:*/		regs.R3 = regs.R31;
		/* 8206ECE8h case    1:*/		return 0x8206ECEC;
		  /* 8206ECECh */ case    2:  		/* bl -2804 */
		/* 8206ECECh case    2:*/		regs.LR = 0x8206ECF0; return 0x8206E1F8;
		/* 8206ECECh case    2:*/		return 0x8206ECF0;
		  /* 8206ECF0h */ case    3:  		/* lwz R3, <#[R31 + 48]> */
		/* 8206ECF0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206ECF0h case    3:*/		return 0x8206ECF4;
		  /* 8206ECF4h */ case    4:  		/* lwz R11, <#[R31 + 56]> */
		/* 8206ECF4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8206ECF4h case    4:*/		return 0x8206ECF8;
		  /* 8206ECF8h */ case    5:  		/* cmplw CR6, R3, R11 */
		/* 8206ECF8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8206ECF8h case    5:*/		return 0x8206ECFC;
		  /* 8206ECFCh */ case    6:  		/* bc 4, CR6_GT, 12 */
		/* 8206ECFCh case    6:*/		if ( !regs.CR[6].gt ) { return 0x8206ED08;  }
		/* 8206ECFCh case    6:*/		return 0x8206ED00;
		  /* 8206ED00h */ case    7:  		/* mr R3, R31 */
		/* 8206ED00h case    7:*/		regs.R3 = regs.R31;
		/* 8206ED00h case    7:*/		return 0x8206ED04;
		  /* 8206ED04h */ case    8:  		/* bl 21508 */
		/* 8206ED04h case    8:*/		regs.LR = 0x8206ED08; return 0x82074108;
		/* 8206ED04h case    8:*/		return 0x8206ED08;
	}
	return 0x8206ED08;
} // Block from 8206ECE4h-8206ED08h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206ED08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206ED08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206ED08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206ED08);
		  /* 8206ED08h */ case    0:  		/* li R11, 6212 */
		/* 8206ED08h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1844);
		/* 8206ED08h case    0:*/		return 0x8206ED0C;
		  /* 8206ED0Ch */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 8206ED0Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8206ED0Ch case    1:*/		return 0x8206ED10;
		  /* 8206ED10h */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206ED10h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206ED10h case    2:*/		return 0x8206ED14;
		  /* 8206ED14h */ case    3:  		/* stwu R25, <#[R3 + 4]> */
		/* 8206ED14h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206ED14h case    3:*/		return 0x8206ED18;
		  /* 8206ED18h */ case    4:  		/* mr R11, R3 */
		/* 8206ED18h case    4:*/		regs.R11 = regs.R3;
		/* 8206ED18h case    4:*/		return 0x8206ED1C;
		  /* 8206ED1Ch */ case    5:  		/* bc 12, CR6_EQ, 88 */
		/* 8206ED1Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8206ED74;  }
		/* 8206ED1Ch case    5:*/		return 0x8206ED20;
	}
	return 0x8206ED20;
} // Block from 8206ED08h-8206ED20h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206ED20h
// Function '?GetMipTailLevelOffsetCoords@D3D@@YAKKKKKKKKPAI00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206ED20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206ED20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206ED20);
		  /* 8206ED20h */ case    0:  		/* li R10, 6200 */
		/* 8206ED20h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1838);
		/* 8206ED20h case    0:*/		return 0x8206ED24;
		  /* 8206ED24h */ case    1:  		/* li R9, 0 */
		/* 8206ED24h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8206ED24h case    1:*/		return 0x8206ED28;
		  /* 8206ED28h */ case    2:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206ED28h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206ED28h case    2:*/		return 0x8206ED2C;
		  /* 8206ED2Ch */ case    3:  		/* lis R8, -16380 */
		/* 8206ED2Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFC004);
		/* 8206ED2Ch case    3:*/		return 0x8206ED30;
		  /* 8206ED30h */ case    4:  		/* li R7, 3 */
		/* 8206ED30h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8206ED30h case    4:*/		return 0x8206ED34;
		  /* 8206ED34h */ case    5:  		/* ori R10, R8, 15360 */
		/* 8206ED34h case    5:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R8,0x3C00);
		/* 8206ED34h case    5:*/		return 0x8206ED38;
		  /* 8206ED38h */ case    6:  		/* li R8, 6515 */
		/* 8206ED38h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x1973);
		/* 8206ED38h case    6:*/		return 0x8206ED3C;
		  /* 8206ED3Ch */ case    7:  		/* li R6, 0 */
		/* 8206ED3Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206ED3Ch case    7:*/		return 0x8206ED40;
		  /* 8206ED40h */ case    8:  		/* stwu R9, <#[R11 + 4]> */
		/* 8206ED40h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206ED40h case    8:*/		return 0x8206ED44;
		  /* 8206ED44h */ case    9:  		/* li R5, 1 */
		/* 8206ED44h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206ED44h case    9:*/		return 0x8206ED48;
		  /* 8206ED48h */ case   10:  		/* li R4, 256 */
		/* 8206ED48h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 8206ED48h case   10:*/		return 0x8206ED4C;
		  /* 8206ED4Ch */ case   11:  		/* li R3, 6226 */
		/* 8206ED4Ch case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x1852);
		/* 8206ED4Ch case   11:*/		return 0x8206ED50;
		  /* 8206ED50h */ case   12:  		/* li R9, 1 */
		/* 8206ED50h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8206ED50h case   12:*/		return 0x8206ED54;
		  /* 8206ED54h */ case   13:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206ED54h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206ED54h case   13:*/		return 0x8206ED58;
		  /* 8206ED58h */ case   14:  		/* stwu R7, <#[R11 + 4]> */
		/* 8206ED58h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206ED58h case   14:*/		return 0x8206ED5C;
		  /* 8206ED5Ch */ case   15:  		/* stwu R8, <#[R11 + 4]> */
		/* 8206ED5Ch case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206ED5Ch case   15:*/		return 0x8206ED60;
		  /* 8206ED60h */ case   16:  		/* stwu R6, <#[R11 + 4]> */
		/* 8206ED60h case   16:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206ED60h case   16:*/		return 0x8206ED64;
		  /* 8206ED64h */ case   17:  		/* stwu R5, <#[R11 + 4]> */
		/* 8206ED64h case   17:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206ED64h case   17:*/		return 0x8206ED68;
		  /* 8206ED68h */ case   18:  		/* stwu R4, <#[R11 + 4]> */
		/* 8206ED68h case   18:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206ED68h case   18:*/		return 0x8206ED6C;
		  /* 8206ED6Ch */ case   19:  		/* stwu R3, <#[R11 + 4]> */
		/* 8206ED6Ch case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206ED6Ch case   19:*/		return 0x8206ED70;
		  /* 8206ED70h */ case   20:  		/* stwu R9, <#[R11 + 4]> */
		/* 8206ED70h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206ED70h case   20:*/		return 0x8206ED74;
	}
	return 0x8206ED74;
} // Block from 8206ED20h-8206ED74h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8206ED74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206ED74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206ED74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206ED74);
		  /* 8206ED74h */ case    0:  		/* stw R11, <#[R31 + 48]> */
		/* 8206ED74h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8206ED74h case    0:*/		return 0x8206ED78;
		  /* 8206ED78h */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 8206ED78h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8206ED78h case    1:*/		return 0x8206ED7C;
		  /* 8206ED7Ch */ case    2:  		/* bc 4, CR6_EQ, 44 */
		/* 8206ED7Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8206EDA8;  }
		/* 8206ED7Ch case    2:*/		return 0x8206ED80;
		  /* 8206ED80h */ case    3:  		/* lis R11, 10280 */
		/* 8206ED80h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x2828);
		/* 8206ED80h case    3:*/		return 0x8206ED84;
		  /* 8206ED84h */ case    4:  		/* li R4, 0 */
		/* 8206ED84h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206ED84h case    4:*/		return 0x8206ED88;
		  /* 8206ED88h */ case    5:  		/* ori R11, R11, 310 */
		/* 8206ED88h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x136);
		/* 8206ED88h case    5:*/		return 0x8206ED8C;
		  /* 8206ED8Ch */ case    6:  		/* mr R3, R31 */
		/* 8206ED8Ch case    6:*/		regs.R3 = regs.R31;
		/* 8206ED8Ch case    6:*/		return 0x8206ED90;
		  /* 8206ED90h */ case    7:  		/* cmpw CR6, R24, R11 */
		/* 8206ED90h case    7:*/		cpu::op::cmpw<6>(regs,regs.R24,regs.R11);
		/* 8206ED90h case    7:*/		return 0x8206ED94;
		  /* 8206ED94h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 8206ED94h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8206EDA0;  }
		/* 8206ED94h case    8:*/		return 0x8206ED98;
		  /* 8206ED98h */ case    9:  		/* bl 25552 */
		/* 8206ED98h case    9:*/		regs.LR = 0x8206ED9C; return 0x82075168;
		/* 8206ED98h case    9:*/		return 0x8206ED9C;
		  /* 8206ED9Ch */ case   10:  		/* b 40 */
		/* 8206ED9Ch case   10:*/		return 0x8206EDC4;
		/* 8206ED9Ch case   10:*/		return 0x8206EDA0;
	}
	return 0x8206EDA0;
} // Block from 8206ED74h-8206EDA0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206EDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EDA0);
		  /* 8206EDA0h */ case    0:  		/* bl 25304 */
		/* 8206EDA0h case    0:*/		regs.LR = 0x8206EDA4; return 0x82075078;
		/* 8206EDA0h case    0:*/		return 0x8206EDA4;
		  /* 8206EDA4h */ case    1:  		/* b 32 */
		/* 8206EDA4h case    1:*/		return 0x8206EDC4;
		/* 8206EDA4h case    1:*/		return 0x8206EDA8;
	}
	return 0x8206EDA8;
} // Block from 8206EDA0h-8206EDA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206EDA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EDA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EDA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EDA8);
		  /* 8206EDA8h */ case    0:  		/* rlwinm. R11, R26, 0, 30, 30 */
		/* 8206EDA8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R26);
		/* 8206EDA8h case    0:*/		return 0x8206EDAC;
		  /* 8206EDACh */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8206EDACh case    1:*/		if ( regs.CR[0].eq ) { return 0x8206EDC4;  }
		/* 8206EDACh case    1:*/		return 0x8206EDB0;
		  /* 8206EDB0h */ case    2:  		/* li R6, 1 */
		/* 8206EDB0h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8206EDB0h case    2:*/		return 0x8206EDB4;
		  /* 8206EDB4h */ case    3:  		/* mr R5, R23 */
		/* 8206EDB4h case    3:*/		regs.R5 = regs.R23;
		/* 8206EDB4h case    3:*/		return 0x8206EDB8;
		  /* 8206EDB8h */ case    4:  		/* mr R4, R24 */
		/* 8206EDB8h case    4:*/		regs.R4 = regs.R24;
		/* 8206EDB8h case    4:*/		return 0x8206EDBC;
		  /* 8206EDBCh */ case    5:  		/* mr R3, R31 */
		/* 8206EDBCh case    5:*/		regs.R3 = regs.R31;
		/* 8206EDBCh case    5:*/		return 0x8206EDC0;
		  /* 8206EDC0h */ case    6:  		/* bl -3872 */
		/* 8206EDC0h case    6:*/		regs.LR = 0x8206EDC4; return 0x8206DEA0;
		/* 8206EDC0h case    6:*/		return 0x8206EDC4;
	}
	return 0x8206EDC4;
} // Block from 8206EDA8h-8206EDC4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206EDC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EDC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EDC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EDC4);
		  /* 8206EDC4h */ case    0:  		/* mr R3, R31 */
		/* 8206EDC4h case    0:*/		regs.R3 = regs.R31;
		/* 8206EDC4h case    0:*/		return 0x8206EDC8;
		  /* 8206EDC8h */ case    1:  		/* bl 21312 */
		/* 8206EDC8h case    1:*/		regs.LR = 0x8206EDCC; return 0x82074108;
		/* 8206EDC8h case    1:*/		return 0x8206EDCC;
		  /* 8206EDCCh */ case    2:  		/* addi R1, R1, 240 */
		/* 8206EDCCh case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 8206EDCCh case    2:*/		return 0x8206EDD0;
		  /* 8206EDD0h */ case    3:  		/* b 140448 */
		/* 8206EDD0h case    3:*/		return 0x82091270;
		/* 8206EDD0h case    3:*/		return 0x8206EDD4;
		  /* 8206EDD4h */ case    4:  		/* nop */
		/* 8206EDD4h case    4:*/		cpu::op::nop();
		/* 8206EDD4h case    4:*/		return 0x8206EDD8;
		  /* 8206EDD8h */ case    5:  		/* li R4, 0 */
		/* 8206EDD8h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206EDD8h case    5:*/		return 0x8206EDDC;
		  /* 8206EDDCh */ case    6:  		/* b -1212 */
		/* 8206EDDCh case    6:*/		return 0x8206E920;
		/* 8206EDDCh case    6:*/		return 0x8206EDE0;
	}
	return 0x8206EDE0;
} // Block from 8206EDC4h-8206EDE0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206EDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EDE0);
		  /* 8206EDE0h */ case    0:  		/* mfspr R12, LR */
		/* 8206EDE0h case    0:*/		regs.R12 = regs.LR;
		/* 8206EDE0h case    0:*/		return 0x8206EDE4;
		  /* 8206EDE4h */ case    1:  		/* bl 140368 */
		/* 8206EDE4h case    1:*/		regs.LR = 0x8206EDE8; return 0x82091234;
		/* 8206EDE4h case    1:*/		return 0x8206EDE8;
		  /* 8206EDE8h */ case    2:  		/* stwu R1, <#[R1 - 480]> */
		/* 8206EDE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE20);
		/* 8206EDE8h case    2:*/		return 0x8206EDEC;
		  /* 8206EDECh */ case    3:  		/* mr R31, R3 */
		/* 8206EDECh case    3:*/		regs.R31 = regs.R3;
		/* 8206EDECh case    3:*/		return 0x8206EDF0;
		  /* 8206EDF0h */ case    4:  		/* mr R28, R4 */
		/* 8206EDF0h case    4:*/		regs.R28 = regs.R4;
		/* 8206EDF0h case    4:*/		return 0x8206EDF4;
		  /* 8206EDF4h */ case    5:  		/* mr R21, R5 */
		/* 8206EDF4h case    5:*/		regs.R21 = regs.R5;
		/* 8206EDF4h case    5:*/		return 0x8206EDF8;
		  /* 8206EDF8h */ case    6:  		/* bl 2089216 */
		/* 8206EDF8h case    6:*/		regs.LR = 0x8206EDFC; return 0x8226CEF8;
		/* 8206EDF8h case    6:*/		return 0x8206EDFC;
		  /* 8206EDFCh */ case    7:  		/* addi R10, R3, -2 */
		/* 8206EDFCh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0xFFFFFFFE);
		/* 8206EDFCh case    7:*/		return 0x8206EE00;
		  /* 8206EE00h */ case    8:  		/* lwz R11, <#[R31 + 13992]> */
		/* 8206EE00h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000036A8) );
		/* 8206EE00h case    8:*/		return 0x8206EE04;
		  /* 8206EE04h */ case    9:  		/* addic R9, R10, -1 */
		/* 8206EE04h case    9:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 8206EE04h case    9:*/		return 0x8206EE08;
		  /* 8206EE08h */ case   10:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 8206EE08h case   10:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8206EE08h case   10:*/		return 0x8206EE0C;
		  /* 8206EE0Ch */ case   11:  		/* subfe R19, R9, R10 */
		/* 8206EE0Ch case   11:*/		cpu::op::subfe<0>(regs,&regs.R19,regs.R9,regs.R10);
		/* 8206EE0Ch case   11:*/		return 0x8206EE10;
		  /* 8206EE10h */ case   12:  		/* bc 12, CR0_EQ, 28 */
		/* 8206EE10h case   12:*/		if ( regs.CR[0].eq ) { return 0x8206EE2C;  }
		/* 8206EE10h case   12:*/		return 0x8206EE14;
		  /* 8206EE14h */ case   13:  		/* bl -4012 */
		/* 8206EE14h case   13:*/		regs.LR = 0x8206EE18; return 0x8206DE68;
		/* 8206EE14h case   13:*/		return 0x8206EE18;
		  /* 8206EE18h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 8206EE18h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206EE18h case   14:*/		return 0x8206EE1C;
		  /* 8206EE1Ch */ case   15:  		/* bc 12, CR0_EQ, 16 */
		/* 8206EE1Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x8206EE2C;  }
		/* 8206EE1Ch case   15:*/		return 0x8206EE20;
		  /* 8206EE20h */ case   16:  		/* mr R4, R28 */
		/* 8206EE20h case   16:*/		regs.R4 = regs.R28;
		/* 8206EE20h case   16:*/		return 0x8206EE24;
		  /* 8206EE24h */ case   17:  		/* mr R3, R31 */
		/* 8206EE24h case   17:*/		regs.R3 = regs.R31;
		/* 8206EE24h case   17:*/		return 0x8206EE28;
		  /* 8206EE28h */ case   18:  		/* bl -2952 */
		/* 8206EE28h case   18:*/		regs.LR = 0x8206EE2C; return 0x8206E2A0;
		/* 8206EE28h case   18:*/		return 0x8206EE2C;
	}
	return 0x8206EE2C;
} // Block from 8206EDE0h-8206EE2Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206EE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EE2C);
		  /* 8206EE2Ch */ case    0:  		/* lwz R11, <#[R31 + 16968]> */
		/* 8206EE2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00004248) );
		/* 8206EE2Ch case    0:*/		return 0x8206EE30;
		  /* 8206EE30h */ case    1:  		/* addi R4, R28, 28 */
		/* 8206EE30h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R28,0x1C);
		/* 8206EE30h case    1:*/		return 0x8206EE34;
		  /* 8206EE34h */ case    2:  		/* addi R3, R1, 128 */
		/* 8206EE34h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 8206EE34h case    2:*/		return 0x8206EE38;
		  /* 8206EE38h */ case    3:  		/* addi R11, R11, 1 */
		/* 8206EE38h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206EE38h case    3:*/		return 0x8206EE3C;
		  /* 8206EE3Ch */ case    4:  		/* li R5, 24 */
		/* 8206EE3Ch case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x18);
		/* 8206EE3Ch case    4:*/		return 0x8206EE40;
		  /* 8206EE40h */ case    5:  		/* stw R11, <#[R31 + 16968]> */
		/* 8206EE40h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00004248) );
		/* 8206EE40h case    5:*/		return 0x8206EE44;
		  /* 8206EE44h */ case    6:  		/* bl 142188 */
		/* 8206EE44h case    6:*/		regs.LR = 0x8206EE48; return 0x820919B0;
		/* 8206EE44h case    6:*/		return 0x8206EE48;
		  /* 8206EE48h */ case    7:  		/* lwz R10, <#[R31 + 14012]> */
		/* 8206EE48h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000036BC) );
		/* 8206EE48h case    7:*/		return 0x8206EE4C;
		  /* 8206EE4Ch */ case    8:  		/* lwz R30, <#[R1 + 132]> */
		/* 8206EE4Ch case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000084) );
		/* 8206EE4Ch case    8:*/		return 0x8206EE50;
		  /* 8206EE50h */ case    9:  		/* rlwinm R11, R30, 0, 26, 31 */
		/* 8206EE50h case    9:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R30);
		/* 8206EE50h case    9:*/		return 0x8206EE54;
		  /* 8206EE54h */ case   10:  		/* cmplwi CR6, R11, 50 */
		/* 8206EE54h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000032);
		/* 8206EE54h case   10:*/		return 0x8206EE58;
		  /* 8206EE58h */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 8206EE58h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8206EE64;  }
		/* 8206EE58h case   11:*/		return 0x8206EE5C;
		  /* 8206EE5Ch */ case   12:  		/* li R11, 3 */
		/* 8206EE5Ch case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8206EE5Ch case   12:*/		return 0x8206EE60;
		  /* 8206EE60h */ case   13:  		/* b 16 */
		/* 8206EE60h case   13:*/		return 0x8206EE70;
		/* 8206EE60h case   13:*/		return 0x8206EE64;
	}
	return 0x8206EE64;
} // Block from 8206EE2Ch-8206EE64h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206EE64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EE64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EE64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EE64);
		  /* 8206EE64h */ case    0:  		/* cmplwi CR6, R11, 7 */
		/* 8206EE64h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 8206EE64h case    0:*/		return 0x8206EE68;
		  /* 8206EE68h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8206EE68h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8206EE78;  }
		/* 8206EE68h case    1:*/		return 0x8206EE6C;
		  /* 8206EE6Ch */ case    2:  		/* li R11, 27 */
		/* 8206EE6Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1B);
		/* 8206EE6Ch case    2:*/		return 0x8206EE70;
	}
	return 0x8206EE70;
} // Block from 8206EE64h-8206EE70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206EE70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EE70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EE70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EE70);
		  /* 8206EE70h */ case    0:  		/* rlwimi R30, R11, 1, 26, 31 */
		/* 8206EE70h case    0:*/		cpu::op::rlwimi<0,1,26,31>(regs,&regs.R30,regs.R11);
		/* 8206EE70h case    0:*/		return 0x8206EE74;
		  /* 8206EE74h */ case    1:  		/* stw R30, <#[R1 + 132]> */
		/* 8206EE74h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000084) );
		/* 8206EE74h case    1:*/		return 0x8206EE78;
	}
	return 0x8206EE78;
} // Block from 8206EE70h-8206EE78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206EE78h
// Function '?GetLevelSize@D3D@@YAXPAUD3DBaseTexture@@KPAK1111@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EE78);
		  /* 8206EE78h */ case    0:  		/* rlwinm R29, R10, 15, 17, 31 */
		/* 8206EE78h case    0:*/		cpu::op::rlwinm<0,15,17,31>(regs,&regs.R29,regs.R10);
		/* 8206EE78h case    0:*/		return 0x8206EE7C;
		  /* 8206EE7Ch */ case    1:  		/* lwz R11, <#[R1 + 140]> */
		/* 8206EE7Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 8206EE7Ch case    1:*/		return 0x8206EE80;
		  /* 8206EE80h */ case    2:  		/* lwz R9, <#[R1 + 128]> */
		/* 8206EE80h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000080) );
		/* 8206EE80h case    2:*/		return 0x8206EE84;
		  /* 8206EE84h */ case    3:  		/* mr R8, R29 */
		/* 8206EE84h case    3:*/		regs.R8 = regs.R29;
		/* 8206EE84h case    3:*/		return 0x8206EE88;
		  /* 8206EE88h */ case    4:  		/* lbz R7, <#[R31 + 11072]> */
		/* 8206EE88h case    4:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R31 + 0x00002B40) );
		/* 8206EE88h case    4:*/		return 0x8206EE8C;
		  /* 8206EE8Ch */ case    5:  		/* rlwimi R9, R10, 25, 22, 29 */
		/* 8206EE8Ch case    5:*/		cpu::op::rlwimi<0,25,22,29>(regs,&regs.R9,regs.R10);
		/* 8206EE8Ch case    5:*/		return 0x8206EE90;
		  /* 8206EE90h */ case    6:  		/* rlwimi R8, R11, 0, 31, 18 */
		/* 8206EE90h case    6:*/		cpu::op::rlwimi<0,0,31,18>(regs,&regs.R8,regs.R11);
		/* 8206EE90h case    6:*/		return 0x8206EE94;
		  /* 8206EE94h */ case    7:  		/* rlwinm. R11, R7, 0, 25, 25 */
		/* 8206EE94h case    7:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R7);
		/* 8206EE94h case    7:*/		return 0x8206EE98;
		  /* 8206EE98h */ case    8:  		/* stw R9, <#[R1 + 128]> */
		/* 8206EE98h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000080) );
		/* 8206EE98h case    8:*/		return 0x8206EE9C;
		  /* 8206EE9Ch */ case    9:  		/* rlwimi R29, R8, 0, 0, 30 */
		/* 8206EE9Ch case    9:*/		cpu::op::rlwimi<0,0,0,30>(regs,&regs.R29,regs.R8);
		/* 8206EE9Ch case    9:*/		return 0x8206EEA0;
		  /* 8206EEA0h */ case   10:  		/* stw R29, <#[R1 + 140]> */
		/* 8206EEA0h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000008C) );
		/* 8206EEA0h case   10:*/		return 0x8206EEA4;
		  /* 8206EEA4h */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 8206EEA4h case   11:*/		if ( regs.CR[0].eq ) { return 0x8206EEB8;  }
		/* 8206EEA4h case   11:*/		return 0x8206EEA8;
		  /* 8206EEA8h */ case   12:  		/* mr R3, R31 */
		/* 8206EEA8h case   12:*/		regs.R3 = regs.R31;
		/* 8206EEA8h case   12:*/		return 0x8206EEAC;
		  /* 8206EEACh */ case   13:  		/* bl 57436 */
		/* 8206EEACh case   13:*/		regs.LR = 0x8206EEB0; return 0x8207CF08;
		/* 8206EEACh case   13:*/		return 0x8206EEB0;
		  /* 8206EEB0h */ case   14:  		/* lwz R29, <#[R1 + 140]> */
		/* 8206EEB0h case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000008C) );
		/* 8206EEB0h case   14:*/		return 0x8206EEB4;
		  /* 8206EEB4h */ case   15:  		/* lwz R30, <#[R1 + 132]> */
		/* 8206EEB4h case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000084) );
		/* 8206EEB4h case   15:*/		return 0x8206EEB8;
	}
	return 0x8206EEB8;
} // Block from 8206EE78h-8206EEB8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206EEB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EEB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EEB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EEB8);
		  /* 8206EEB8h */ case    0:  		/* addi R3, R31, 15248 */
		/* 8206EEB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x3B90);
		/* 8206EEB8h case    0:*/		return 0x8206EEBC;
		  /* 8206EEBCh */ case    1:  		/* li R5, 52 */
		/* 8206EEBCh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x34);
		/* 8206EEBCh case    1:*/		return 0x8206EEC0;
		  /* 8206EEC0h */ case    2:  		/* mr R4, R28 */
		/* 8206EEC0h case    2:*/		regs.R4 = regs.R28;
		/* 8206EEC0h case    2:*/		return 0x8206EEC4;
		  /* 8206EEC4h */ case    3:  		/* bl 142060 */
		/* 8206EEC4h case    3:*/		regs.LR = 0x8206EEC8; return 0x820919B0;
		/* 8206EEC4h case    3:*/		return 0x8206EEC8;
		  /* 8206EEC8h */ case    4:  		/* lwz R10, <#[R1 + 136]> */
		/* 8206EEC8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 8206EEC8h case    4:*/		return 0x8206EECC;
		  /* 8206EECCh */ case    5:  		/* rlwinm R11, R29, 2, 30, 30 */
		/* 8206EECCh case    5:*/		cpu::op::rlwinm<0,2,30,30>(regs,&regs.R11,regs.R29);
		/* 8206EECCh case    5:*/		return 0x8206EED0;
		  /* 8206EED0h */ case    6:  		/* lwz R9, <#[R31 + 14016]> */
		/* 8206EED0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000036C0) );
		/* 8206EED0h case    6:*/		return 0x8206EED4;
		  /* 8206EED4h */ case    7:  		/* rlwinm R7, R10, 0, 19, 31 */
		/* 8206EED4h case    7:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R7,regs.R10);
		/* 8206EED4h case    7:*/		return 0x8206EED8;
		  /* 8206EED8h */ case    8:  		/* lwz R5, <#[R31 + 22040]> */
		/* 8206EED8h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00005618) );
		/* 8206EED8h case    8:*/		return 0x8206EEDC;
		  /* 8206EEDCh */ case    9:  		/* addi R11, R11, 1 */
		/* 8206EEDCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206EEDCh case    9:*/		return 0x8206EEE0;
		  /* 8206EEE0h */ case   10:  		/* rlwinm R6, R10, 19, 19, 31 */
		/* 8206EEE0h case   10:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R6,regs.R10);
		/* 8206EEE0h case   10:*/		return 0x8206EEE4;
		  /* 8206EEE4h */ case   11:  		/* add R7, R7, R11 */
		/* 8206EEE4h case   11:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 8206EEE4h case   11:*/		return 0x8206EEE8;
		  /* 8206EEE8h */ case   12:  		/* rlwinm R8, R30, 0, 26, 31 */
		/* 8206EEE8h case   12:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R8,regs.R30);
		/* 8206EEE8h case   12:*/		return 0x8206EEEC;
		  /* 8206EEECh */ case   13:  		/* stw R9, <#[R1 + 104]> */
		/* 8206EEECh case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000068) );
		/* 8206EEECh case   13:*/		return 0x8206EEF0;
		  /* 8206EEF0h */ case   14:  		/* rlwinm R10, R30, 0, 0, 19 */
		/* 8206EEF0h case   14:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R10,regs.R30);
		/* 8206EEF0h case   14:*/		return 0x8206EEF4;
		  /* 8206EEF4h */ case   15:  		/* stw R7, <#[R1 + 96]> */
		/* 8206EEF4h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000060) );
		/* 8206EEF4h case   15:*/		return 0x8206EEF8;
		  /* 8206EEF8h */ case   16:  		/* add R11, R6, R11 */
		/* 8206EEF8h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 8206EEF8h case   16:*/		return 0x8206EEFC;
		  /* 8206EEFCh */ case   17:  		/* stw R8, <#[R1 + 112]> */
		/* 8206EEFCh case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000070) );
		/* 8206EEFCh case   17:*/		return 0x8206EF00;
		  /* 8206EF00h */ case   18:  		/* li R20, 0 */
		/* 8206EF00h case   18:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 8206EF00h case   18:*/		return 0x8206EF04;
		  /* 8206EF04h */ case   19:  		/* stw R10, <#[R1 + 108]> */
		/* 8206EF04h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206EF04h case   19:*/		return 0x8206EF08;
		  /* 8206EF08h */ case   20:  		/* stw R11, <#[R1 + 100]> */
		/* 8206EF08h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8206EF08h case   20:*/		return 0x8206EF0C;
		  /* 8206EF0Ch */ case   21:  		/* cmpwi CR6, R5, 0 */
		/* 8206EF0Ch case   21:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8206EF0Ch case   21:*/		return 0x8206EF10;
		  /* 8206EF10h */ case   22:  		/* mr R27, R20 */
		/* 8206EF10h case   22:*/		regs.R27 = regs.R20;
		/* 8206EF10h case   22:*/		return 0x8206EF14;
		  /* 8206EF14h */ case   23:  		/* mr R25, R9 */
		/* 8206EF14h case   23:*/		regs.R25 = regs.R9;
		/* 8206EF14h case   23:*/		return 0x8206EF18;
		  /* 8206EF18h */ case   24:  		/* mr R30, R10 */
		/* 8206EF18h case   24:*/		regs.R30 = regs.R10;
		/* 8206EF18h case   24:*/		return 0x8206EF1C;
		  /* 8206EF1Ch */ case   25:  		/* mr R24, R8 */
		/* 8206EF1Ch case   25:*/		regs.R24 = regs.R8;
		/* 8206EF1Ch case   25:*/		return 0x8206EF20;
		  /* 8206EF20h */ case   26:  		/* mr R23, R7 */
		/* 8206EF20h case   26:*/		regs.R23 = regs.R7;
		/* 8206EF20h case   26:*/		return 0x8206EF24;
		  /* 8206EF24h */ case   27:  		/* mr R22, R11 */
		/* 8206EF24h case   27:*/		regs.R22 = regs.R11;
		/* 8206EF24h case   27:*/		return 0x8206EF28;
		  /* 8206EF28h */ case   28:  		/* bc 12, CR6_EQ, 108 */
		/* 8206EF28h case   28:*/		if ( regs.CR[6].eq ) { return 0x8206EF94;  }
		/* 8206EF28h case   28:*/		return 0x8206EF2C;
		  /* 8206EF2Ch */ case   29:  		/* lwz R10, <#[R31 + 22032]> */
		/* 8206EF2Ch case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00005610) );
		/* 8206EF2Ch case   29:*/		return 0x8206EF30;
		  /* 8206EF30h */ case   30:  		/* lwz R11, <#[R31 + 22036]> */
		/* 8206EF30h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005614) );
		/* 8206EF30h case   30:*/		return 0x8206EF34;
		  /* 8206EF34h */ case   31:  		/* subf R10, R10, R11 */
		/* 8206EF34h case   31:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8206EF34h case   31:*/		return 0x8206EF38;
		  /* 8206EF38h */ case   32:  		/* cmplwi CR6, R10, 6 */
		/* 8206EF38h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000006);
		/* 8206EF38h case   32:*/		return 0x8206EF3C;
		  /* 8206EF3Ch */ case   33:  		/* bc 4, CR6_LT, 88 */
		/* 8206EF3Ch case   33:*/		if ( !regs.CR[6].lt ) { return 0x8206EF94;  }
		/* 8206EF3Ch case   33:*/		return 0x8206EF40;
		  /* 8206EF40h */ case   34:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 8206EF40h case   34:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 8206EF40h case   34:*/		return 0x8206EF44;
		  /* 8206EF44h */ case   35:  		/* lwz R10, <#[R31 + 11024]> */
		/* 8206EF44h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B10) );
		/* 8206EF44h case   35:*/		return 0x8206EF48;
		  /* 8206EF48h */ case   36:  		/* mr R3, R31 */
		/* 8206EF48h case   36:*/		regs.R3 = regs.R31;
		/* 8206EF48h case   36:*/		return 0x8206EF4C;
		  /* 8206EF4Ch */ case   37:  		/* addi R11, R11, 16 */
		/* 8206EF4Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206EF4Ch case   37:*/		return 0x8206EF50;
		  /* 8206EF50h */ case   38:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206EF50h case   38:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206EF50h case   38:*/		return 0x8206EF54;
		  /* 8206EF54h */ case   39:  		/* stwx R20, <#[R11 + R10]> */
		/* 8206EF54h case   39:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8206EF54h case   39:*/		return 0x8206EF58;
		  /* 8206EF58h */ case   40:  		/* lwz R10, <#[R31 + 11024]> */
		/* 8206EF58h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B10) );
		/* 8206EF58h case   40:*/		return 0x8206EF5C;
		  /* 8206EF5Ch */ case   41:  		/* lwz R11, <#[R31 + 22036]> */
		/* 8206EF5Ch case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005614) );
		/* 8206EF5Ch case   41:*/		return 0x8206EF60;
		  /* 8206EF60h */ case   42:  		/* addi R11, R11, 1 */
		/* 8206EF60h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206EF60h case   42:*/		return 0x8206EF64;
		  /* 8206EF64h */ case   43:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 8206EF64h case   43:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 8206EF64h case   43:*/		return 0x8206EF68;
		  /* 8206EF68h */ case   44:  		/* addi R11, R11, 16 */
		/* 8206EF68h case   44:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206EF68h case   44:*/		return 0x8206EF6C;
		  /* 8206EF6Ch */ case   45:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206EF6Ch case   45:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206EF6Ch case   45:*/		return 0x8206EF70;
		  /* 8206EF70h */ case   46:  		/* stwx R20, <#[R11 + R10]> */
		/* 8206EF70h case   46:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8206EF70h case   46:*/		return 0x8206EF74;
		  /* 8206EF74h */ case   47:  		/* lwz R11, <#[R31 + 22036]> */
		/* 8206EF74h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005614) );
		/* 8206EF74h case   47:*/		return 0x8206EF78;
		  /* 8206EF78h */ case   48:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 8206EF78h case   48:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 8206EF78h case   48:*/		return 0x8206EF7C;
		  /* 8206EF7Ch */ case   49:  		/* addi R10, R11, 16 */
		/* 8206EF7Ch case   49:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x10);
		/* 8206EF7Ch case   49:*/		return 0x8206EF80;
		  /* 8206EF80h */ case   50:  		/* lwz R11, <#[R31 + 11024]> */
		/* 8206EF80h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 8206EF80h case   50:*/		return 0x8206EF84;
		  /* 8206EF84h */ case   51:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8206EF84h case   51:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8206EF84h case   51:*/		return 0x8206EF88;
		  /* 8206EF88h */ case   52:  		/* add R4, R10, R11 */
		/* 8206EF88h case   52:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8206EF88h case   52:*/		return 0x8206EF8C;
		  /* 8206EF8Ch */ case   53:  		/* bl 47644 */
		/* 8206EF8Ch case   53:*/		regs.LR = 0x8206EF90; return 0x8207A9A8;
		/* 8206EF8Ch case   53:*/		return 0x8206EF90;
		  /* 8206EF90h */ case   54:  		/* li R27, 1 */
		/* 8206EF90h case   54:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8206EF90h case   54:*/		return 0x8206EF94;
	}
	return 0x8206EF94;
} // Block from 8206EEB8h-8206EF94h (55 instructions)

//////////////////////////////////////////////////////
// Block at 8206EF94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EF94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EF94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EF94);
		  /* 8206EF94h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 8206EF94h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8206EF94h case    0:*/		return 0x8206EF98;
		  /* 8206EF98h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 8206EF98h case    1:*/		if ( regs.CR[6].eq ) { return 0x8206EFD4;  }
		/* 8206EF98h case    1:*/		return 0x8206EF9C;
		  /* 8206EF9Ch */ case    2:  		/* addi R10, R31, 14044 */
		/* 8206EF9Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x36DC);
		/* 8206EF9Ch case    2:*/		return 0x8206EFA0;
		  /* 8206EFA0h */ case    3:  		/* mr R11, R21 */
		/* 8206EFA0h case    3:*/		regs.R11 = regs.R21;
		/* 8206EFA0h case    3:*/		return 0x8206EFA4;
		  /* 8206EFA4h */ case    4:  		/* addi R8, R21, 28 */
		/* 8206EFA4h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R21,0x1C);
		/* 8206EFA4h case    4:*/		return 0x8206EFA8;
		  /* 8206EFA8h */ case    5:  		/* lbz R9, <#[R11]> */
		/* 8206EFA8h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8206EFA8h case    5:*/		return 0x8206EFAC;
		  /* 8206EFACh */ case    6:  		/* lbz R7, <#[R10]> */
		/* 8206EFACh case    6:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 8206EFACh case    6:*/		return 0x8206EFB0;
		  /* 8206EFB0h */ case    7:  		/* subf. R9, R7, R9 */
		/* 8206EFB0h case    7:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8206EFB0h case    7:*/		return 0x8206EFB4;
		  /* 8206EFB4h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 8206EFB4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8206EFC8;  }
		/* 8206EFB4h case    8:*/		return 0x8206EFB8;
		  /* 8206EFB8h */ case    9:  		/* addi R11, R11, 1 */
		/* 8206EFB8h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206EFB8h case    9:*/		return 0x8206EFBC;
		  /* 8206EFBCh */ case   10:  		/* addi R10, R10, 1 */
		/* 8206EFBCh case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8206EFBCh case   10:*/		return 0x8206EFC0;
		  /* 8206EFC0h */ case   11:  		/* cmpw CR6, R11, R8 */
		/* 8206EFC0h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8206EFC0h case   11:*/		return 0x8206EFC4;
		  /* 8206EFC4h */ case   12:  		/* bc 4, CR6_EQ, -28 */
		/* 8206EFC4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8206EFA8;  }
		/* 8206EFC4h case   12:*/		return 0x8206EFC8;
	}
	return 0x8206EFC8;
} // Block from 8206EF94h-8206EFC8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206EFC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EFC8);
		  /* 8206EFC8h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 8206EFC8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 8206EFC8h case    0:*/		return 0x8206EFCC;
		  /* 8206EFCCh */ case    1:  		/* li R26, 1 */
		/* 8206EFCCh case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8206EFCCh case    1:*/		return 0x8206EFD0;
		  /* 8206EFD0h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 8206EFD0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8206EFD8;  }
		/* 8206EFD0h case    2:*/		return 0x8206EFD4;
	}
	return 0x8206EFD4;
} // Block from 8206EFC8h-8206EFD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206EFD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EFD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EFD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EFD4);
		  /* 8206EFD4h */ case    0:  		/* mr R26, R20 */
		/* 8206EFD4h case    0:*/		regs.R26 = regs.R20;
		/* 8206EFD4h case    0:*/		return 0x8206EFD8;
	}
	return 0x8206EFD8;
} // Block from 8206EFD4h-8206EFD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206EFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206EFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206EFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206EFD8);
		  /* 8206EFD8h */ case    0:  		/* cmpwi CR6, R19, 0 */
		/* 8206EFD8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 8206EFD8h case    0:*/		return 0x8206EFDC;
		  /* 8206EFDCh */ case    1:  		/* bc 12, CR6_EQ, 80 */
		/* 8206EFDCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8206F02C;  }
		/* 8206EFDCh case    1:*/		return 0x8206EFE0;
		  /* 8206EFE0h */ case    2:  		/* lis R11, -32216 */
		/* 8206EFE0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8206EFE0h case    2:*/		return 0x8206EFE4;
		  /* 8206EFE4h */ case    3:  		/* lwz R11, <#[R11 + 28696]> */
		/* 8206EFE4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00007018) );
		/* 8206EFE4h case    3:*/		return 0x8206EFE8;
		  /* 8206EFE8h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 8206EFE8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206EFE8h case    4:*/		return 0x8206EFEC;
		  /* 8206EFECh */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 8206EFECh case    5:*/		if ( regs.CR[6].eq ) { return 0x8206F00C;  }
		/* 8206EFECh case    5:*/		return 0x8206EFF0;
		  /* 8206EFF0h */ case    6:  		/* lwz R11, <#[R31 + 56]> */
		/* 8206EFF0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8206EFF0h case    6:*/		return 0x8206EFF4;
		  /* 8206EFF4h */ case    7:  		/* lwz R3, <#[R31 + 48]> */
		/* 8206EFF4h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206EFF4h case    7:*/		return 0x8206EFF8;
		  /* 8206EFF8h */ case    8:  		/* cmplw CR6, R3, R11 */
		/* 8206EFF8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8206EFF8h case    8:*/		return 0x8206EFFC;
		  /* 8206EFFCh */ case    9:  		/* bc 4, CR6_GT, 12 */
		/* 8206EFFCh case    9:*/		if ( !regs.CR[6].gt ) { return 0x8206F008;  }
		/* 8206EFFCh case    9:*/		return 0x8206F000;
		  /* 8206F000h */ case   10:  		/* mr R3, R31 */
		/* 8206F000h case   10:*/		regs.R3 = regs.R31;
		/* 8206F000h case   10:*/		return 0x8206F004;
		  /* 8206F004h */ case   11:  		/* bl 20740 */
		/* 8206F004h case   11:*/		regs.LR = 0x8206F008; return 0x82074108;
		/* 8206F004h case   11:*/		return 0x8206F008;
	}
	return 0x8206F008;
} // Block from 8206EFD8h-8206F008h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206F008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F008);
		  /* 8206F008h */ case    0:  		/* stw R3, <#[R31 + 48]> */
		/* 8206F008h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206F008h case    0:*/		return 0x8206F00C;
	}
	return 0x8206F00C;
} // Block from 8206F008h-8206F00Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206F00Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F00C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F00C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F00C);
		  /* 8206F00Ch */ case    0:  		/* cmpwi CR6, R26, 0 */
		/* 8206F00Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 8206F00Ch case    0:*/		return 0x8206F010;
		  /* 8206F010h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8206F010h case    1:*/		if ( regs.CR[6].eq ) { return 0x8206F020;  }
		/* 8206F010h case    1:*/		return 0x8206F014;
		  /* 8206F014h */ case    2:  		/* lwz R11, <#[R31 + 24368]> */
		/* 8206F014h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005F30) );
		/* 8206F014h case    2:*/		return 0x8206F018;
		  /* 8206F018h */ case    3:  		/* oris R11, R11, 16384 */
		/* 8206F018h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 8206F018h case    3:*/		return 0x8206F01C;
		  /* 8206F01Ch */ case    4:  		/* stw R11, <#[R31 + 24368]> */
		/* 8206F01Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00005F30) );
		/* 8206F01Ch case    4:*/		return 0x8206F020;
	}
	return 0x8206F020;
} // Block from 8206F00Ch-8206F020h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206F020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F020);
		  /* 8206F020h */ case    0:  		/* mr R4, R28 */
		/* 8206F020h case    0:*/		regs.R4 = regs.R28;
		/* 8206F020h case    0:*/		return 0x8206F024;
		  /* 8206F024h */ case    1:  		/* mr R3, R31 */
		/* 8206F024h case    1:*/		regs.R3 = regs.R31;
		/* 8206F024h case    1:*/		return 0x8206F028;
		  /* 8206F028h */ case    2:  		/* bl 74728 */
		/* 8206F028h case    2:*/		regs.LR = 0x8206F02C; return 0x82081410;
		/* 8206F028h case    2:*/		return 0x8206F02C;
	}
	return 0x8206F02C;
} // Block from 8206F020h-8206F02Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206F02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F02C);
		  /* 8206F02Ch */ case    0:  		/* addi R4, R1, 116 */
		/* 8206F02Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x74);
		/* 8206F02Ch case    0:*/		return 0x8206F030;
		  /* 8206F030h */ case    1:  		/* addi R3, R1, 208 */
		/* 8206F030h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xD0);
		/* 8206F030h case    1:*/		return 0x8206F034;
		  /* 8206F034h */ case    2:  		/* bl 2088788 */
		/* 8206F034h case    2:*/		regs.LR = 0x8206F038; return 0x8226CF88;
		/* 8206F034h case    2:*/		return 0x8206F038;
		  /* 8206F038h */ case    3:  		/* lwz R11, <#[R31 + 21940]> */
		/* 8206F038h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000055B4) );
		/* 8206F038h case    3:*/		return 0x8206F03C;
		  /* 8206F03Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206F03Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206F03Ch case    4:*/		return 0x8206F040;
		  /* 8206F040h */ case    5:  		/* bc 12, CR6_EQ, 68 */
		/* 8206F040h case    5:*/		if ( regs.CR[6].eq ) { return 0x8206F084;  }
		/* 8206F040h case    5:*/		return 0x8206F044;
		  /* 8206F044h */ case    6:  		/* lwz R11, <#[R1 + 116]> */
		/* 8206F044h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 8206F044h case    6:*/		return 0x8206F048;
		  /* 8206F048h */ case    7:  		/* lwz R10, <#[R31 + 11024]> */
		/* 8206F048h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B10) );
		/* 8206F048h case    7:*/		return 0x8206F04C;
		  /* 8206F04Ch */ case    8:  		/* stw R11, <#[R10 + 8]> */
		/* 8206F04Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8206F04Ch case    8:*/		return 0x8206F050;
		  /* 8206F050h */ case    9:  		/* lwz R3, <#[R31 + 48]> */
		/* 8206F050h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206F050h case    9:*/		return 0x8206F054;
		  /* 8206F054h */ case   10:  		/* lwz R11, <#[R31 + 56]> */
		/* 8206F054h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8206F054h case   10:*/		return 0x8206F058;
		  /* 8206F058h */ case   11:  		/* cmplw CR6, R3, R11 */
		/* 8206F058h case   11:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8206F058h case   11:*/		return 0x8206F05C;
		  /* 8206F05Ch */ case   12:  		/* bc 4, CR6_GT, 12 */
		/* 8206F05Ch case   12:*/		if ( !regs.CR[6].gt ) { return 0x8206F068;  }
		/* 8206F05Ch case   12:*/		return 0x8206F060;
		  /* 8206F060h */ case   13:  		/* mr R3, R31 */
		/* 8206F060h case   13:*/		regs.R3 = regs.R31;
		/* 8206F060h case   13:*/		return 0x8206F064;
		  /* 8206F064h */ case   14:  		/* bl 20644 */
		/* 8206F064h case   14:*/		regs.LR = 0x8206F068; return 0x82074108;
		/* 8206F064h case   14:*/		return 0x8206F068;
	}
	return 0x8206F068;
} // Block from 8206F02Ch-8206F068h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206F068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F068);
		  /* 8206F068h */ case    0:  		/* lis R11, -16384 */
		/* 8206F068h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 8206F068h case    0:*/		return 0x8206F06C;
		  /* 8206F06Ch */ case    1:  		/* mr R10, R20 */
		/* 8206F06Ch case    1:*/		regs.R10 = regs.R20;
		/* 8206F06Ch case    1:*/		return 0x8206F070;
		  /* 8206F070h */ case    2:  		/* ori R11, R11, 4096 */
		/* 8206F070h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 8206F070h case    2:*/		return 0x8206F074;
		  /* 8206F074h */ case    3:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206F074h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206F074h case    3:*/		return 0x8206F078;
		  /* 8206F078h */ case    4:  		/* stwu R20, <#[R3 + 4]> */
		/* 8206F078h case    4:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206F078h case    4:*/		return 0x8206F07C;
		  /* 8206F07Ch */ case    5:  		/* stw R3, <#[R31 + 48]> */
		/* 8206F07Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206F07Ch case    5:*/		return 0x8206F080;
		  /* 8206F080h */ case    6:  		/* b 244 */
		/* 8206F080h case    6:*/		return 0x8206F174;
		/* 8206F080h case    6:*/		return 0x8206F084;
	}
	return 0x8206F084;
} // Block from 8206F068h-8206F084h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206F084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F084);
		  /* 8206F084h */ case    0:  		/* lwz R11, <#[R31 + 24596]> */
		/* 8206F084h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00006014) );
		/* 8206F084h case    0:*/		return 0x8206F088;
		  /* 8206F088h */ case    1:  		/* lwz R10, <#[R1 + 256]> */
		/* 8206F088h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000100) );
		/* 8206F088h case    1:*/		return 0x8206F08C;
		  /* 8206F08Ch */ case    2:  		/* addic R9, R11, -1 */
		/* 8206F08Ch case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 8206F08Ch case    2:*/		return 0x8206F090;
		  /* 8206F090h */ case    3:  		/* cmplwi CR6, R10, 1280 */
		/* 8206F090h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000500);
		/* 8206F090h case    3:*/		return 0x8206F094;
		  /* 8206F094h */ case    4:  		/* subfe R10, R9, R11 */
		/* 8206F094h case    4:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R9,regs.R11);
		/* 8206F094h case    4:*/		return 0x8206F098;
		  /* 8206F098h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 8206F098h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206F0A8;  }
		/* 8206F098h case    5:*/		return 0x8206F09C;
		  /* 8206F09Ch */ case    6:  		/* lwz R11, <#[R1 + 260]> */
		/* 8206F09Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000104) );
		/* 8206F09Ch case    6:*/		return 0x8206F0A0;
		  /* 8206F0A0h */ case    7:  		/* cmplwi CR6, R11, 1470 */
		/* 8206F0A0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000005BE);
		/* 8206F0A0h case    7:*/		return 0x8206F0A4;
		  /* 8206F0A4h */ case    8:  		/* bc 12, CR6_EQ, 28 */
		/* 8206F0A4h case    8:*/		if ( regs.CR[6].eq ) { return 0x8206F0C0;  }
		/* 8206F0A4h case    8:*/		return 0x8206F0A8;
	}
	return 0x8206F0A8;
} // Block from 8206F084h-8206F0A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206F0A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F0A8);
		  /* 8206F0A8h */ case    0:  		/* lwz R11, <#[R31 + 14088]> */
		/* 8206F0A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003708) );
		/* 8206F0A8h case    0:*/		return 0x8206F0AC;
		  /* 8206F0ACh */ case    1:  		/* cmplwi CR6, R11, 1280 */
		/* 8206F0ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000500);
		/* 8206F0ACh case    1:*/		return 0x8206F0B0;
		  /* 8206F0B0h */ case    2:  		/* bc 4, CR6_EQ, 24 */
		/* 8206F0B0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8206F0C8;  }
		/* 8206F0B0h case    2:*/		return 0x8206F0B4;
		  /* 8206F0B4h */ case    3:  		/* lwz R11, <#[R31 + 14092]> */
		/* 8206F0B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000370C) );
		/* 8206F0B4h case    3:*/		return 0x8206F0B8;
		  /* 8206F0B8h */ case    4:  		/* cmplwi CR6, R11, 1470 */
		/* 8206F0B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000005BE);
		/* 8206F0B8h case    4:*/		return 0x8206F0BC;
		  /* 8206F0BCh */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 8206F0BCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206F0C8;  }
		/* 8206F0BCh case    5:*/		return 0x8206F0C0;
	}
	return 0x8206F0C0;
} // Block from 8206F0A8h-8206F0C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206F0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F0C0);
		  /* 8206F0C0h */ case    0:  		/* li R11, 1 */
		/* 8206F0C0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206F0C0h case    0:*/		return 0x8206F0C4;
		  /* 8206F0C4h */ case    1:  		/* b 8 */
		/* 8206F0C4h case    1:*/		return 0x8206F0CC;
		/* 8206F0C4h case    1:*/		return 0x8206F0C8;
	}
	return 0x8206F0C8;
} // Block from 8206F0C0h-8206F0C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206F0C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F0C8);
		  /* 8206F0C8h */ case    0:  		/* mr R11, R20 */
		/* 8206F0C8h case    0:*/		regs.R11 = regs.R20;
		/* 8206F0C8h case    0:*/		return 0x8206F0CC;
	}
	return 0x8206F0CC;
} // Block from 8206F0C8h-8206F0CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206F0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F0CC);
		  /* 8206F0CCh */ case    0:  		/* lwz R9, <#[R1 + 216]> */
		/* 8206F0CCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000D8) );
		/* 8206F0CCh case    0:*/		return 0x8206F0D0;
		  /* 8206F0D0h */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 8206F0D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8206F0D0h case    1:*/		return 0x8206F0D4;
		  /* 8206F0D4h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 8206F0D4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8206F0DC;  }
		/* 8206F0D4h case    2:*/		return 0x8206F0D8;
		  /* 8206F0D8h */ case    3:  		/* mr R11, R10 */
		/* 8206F0D8h case    3:*/		regs.R11 = regs.R10;
		/* 8206F0D8h case    3:*/		return 0x8206F0DC;
	}
	return 0x8206F0DC;
} // Block from 8206F0CCh-8206F0DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206F0DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F0DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F0DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F0DC);
		  /* 8206F0DCh */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 8206F0DCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8206F0DCh case    0:*/		return 0x8206F0E0;
		  /* 8206F0E0h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8206F0E0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8206F0F0;  }
		/* 8206F0E0h case    1:*/		return 0x8206F0E4;
		  /* 8206F0E4h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 8206F0E4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206F0E4h case    2:*/		return 0x8206F0E8;
		  /* 8206F0E8h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 8206F0E8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8206F0F8;  }
		/* 8206F0E8h case    3:*/		return 0x8206F0EC;
		  /* 8206F0ECh */ case    4:  		/* b 56 */
		/* 8206F0ECh case    4:*/		return 0x8206F124;
		/* 8206F0ECh case    4:*/		return 0x8206F0F0;
	}
	return 0x8206F0F0;
} // Block from 8206F0DCh-8206F0F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206F0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F0F0);
		  /* 8206F0F0h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 8206F0F0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206F0F0h case    0:*/		return 0x8206F0F4;
		  /* 8206F0F4h */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 8206F0F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8206F124;  }
		/* 8206F0F4h case    1:*/		return 0x8206F0F8;
	}
	return 0x8206F0F8;
} // Block from 8206F0F0h-8206F0F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206F0F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F0F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F0F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F0F8);
		  /* 8206F0F8h */ case    0:  		/* li R5, 148 */
		/* 8206F0F8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x94);
		/* 8206F0F8h case    0:*/		return 0x8206F0FC;
		  /* 8206F0FCh */ case    1:  		/* li R4, 0 */
		/* 8206F0FCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206F0FCh case    1:*/		return 0x8206F100;
		  /* 8206F100h */ case    2:  		/* addi R3, R1, 208 */
		/* 8206F100h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xD0);
		/* 8206F100h case    2:*/		return 0x8206F104;
		  /* 8206F104h */ case    3:  		/* bl 139836 */
		/* 8206F104h case    3:*/		regs.LR = 0x8206F108; return 0x82091340;
		/* 8206F104h case    3:*/		return 0x8206F108;
		  /* 8206F108h */ case    4:  		/* lwz R11, <#[R31 + 11024]> */
		/* 8206F108h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 8206F108h case    4:*/		return 0x8206F10C;
		  /* 8206F10Ch */ case    5:  		/* lwz R10, <#[R1 + 116]> */
		/* 8206F10Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 8206F10Ch case    5:*/		return 0x8206F110;
		  /* 8206F110h */ case    6:  		/* li R5, 56 */
		/* 8206F110h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x38);
		/* 8206F110h case    6:*/		return 0x8206F114;
		  /* 8206F114h */ case    7:  		/* li R4, 0 */
		/* 8206F114h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206F114h case    7:*/		return 0x8206F118;
		  /* 8206F118h */ case    8:  		/* addi R3, R31, 14072 */
		/* 8206F118h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x36F8);
		/* 8206F118h case    8:*/		return 0x8206F11C;
		  /* 8206F11Ch */ case    9:  		/* stw R10, <#[R11 + 8]> */
		/* 8206F11Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8206F11Ch case    9:*/		return 0x8206F120;
		  /* 8206F120h */ case   10:  		/* bl 139808 */
		/* 8206F120h case   10:*/		regs.LR = 0x8206F124; return 0x82091340;
		/* 8206F120h case   10:*/		return 0x8206F124;
	}
	return 0x8206F124;
} // Block from 8206F0F8h-8206F124h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206F124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F124);
		  /* 8206F124h */ case    0:  		/* li R4, 64 */
		/* 8206F124h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x40);
		/* 8206F124h case    0:*/		return 0x8206F128;
		  /* 8206F128h */ case    1:  		/* mr R3, R31 */
		/* 8206F128h case    1:*/		regs.R3 = regs.R31;
		/* 8206F128h case    1:*/		return 0x8206F12C;
		  /* 8206F12Ch */ case    2:  		/* bl 21012 */
		/* 8206F12Ch case    2:*/		regs.LR = 0x8206F130; return 0x82074340;
		/* 8206F12Ch case    2:*/		return 0x8206F130;
		  /* 8206F130h */ case    3:  		/* addi R9, R1, 100 */
		/* 8206F130h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x64);
		/* 8206F130h case    3:*/		return 0x8206F134;
		  /* 8206F134h */ case    4:  		/* addi R8, R1, 96 */
		/* 8206F134h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 8206F134h case    4:*/		return 0x8206F138;
		  /* 8206F138h */ case    5:  		/* lwz R11, <#[R31 + 11024]> */
		/* 8206F138h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 8206F138h case    5:*/		return 0x8206F13C;
		  /* 8206F13Ch */ case    6:  		/* mr R29, R3 */
		/* 8206F13Ch case    6:*/		regs.R29 = regs.R3;
		/* 8206F13Ch case    6:*/		return 0x8206F140;
		  /* 8206F140h */ case    7:  		/* stw R9, <#[R1 + 92]> */
		/* 8206F140h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206F140h case    7:*/		return 0x8206F144;
		  /* 8206F144h */ case    8:  		/* stw R8, <#[R1 + 84]> */
		/* 8206F144h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 8206F144h case    8:*/		return 0x8206F148;
		  /* 8206F148h */ case    9:  		/* addi R10, R1, 104 */
		/* 8206F148h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x68);
		/* 8206F148h case    9:*/		return 0x8206F14C;
		  /* 8206F14Ch */ case   10:  		/* addi R9, R1, 112 */
		/* 8206F14Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 8206F14Ch case   10:*/		return 0x8206F150;
		  /* 8206F150h */ case   11:  		/* lwz R7, <#[R1 + 116]> */
		/* 8206F150h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000074) );
		/* 8206F150h case   11:*/		return 0x8206F154;
		  /* 8206F154h */ case   12:  		/* addi R8, R1, 108 */
		/* 8206F154h case   12:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x6C);
		/* 8206F154h case   12:*/		return 0x8206F158;
		  /* 8206F158h */ case   13:  		/* addi R6, R1, 208 */
		/* 8206F158h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xD0);
		/* 8206F158h case   13:*/		return 0x8206F15C;
		  /* 8206F15Ch */ case   14:  		/* addi R5, R11, 8 */
		/* 8206F15Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x8);
		/* 8206F15Ch case   14:*/		return 0x8206F160;
		  /* 8206F160h */ case   15:  		/* addi R4, R1, 128 */
		/* 8206F160h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 8206F160h case   15:*/		return 0x8206F164;
		  /* 8206F164h */ case   16:  		/* addi R3, R3, 4 */
		/* 8206F164h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 8206F164h case   16:*/		return 0x8206F168;
		  /* 8206F168h */ case   17:  		/* bl 2088464 */
		/* 8206F168h case   17:*/		regs.LR = 0x8206F16C; return 0x8226CF78;
		/* 8206F168h case   17:*/		return 0x8206F16C;
		  /* 8206F16Ch */ case   18:  		/* addi R11, R29, 256 */
		/* 8206F16Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x100);
		/* 8206F16Ch case   18:*/		return 0x8206F170;
		  /* 8206F170h */ case   19:  		/* stw R11, <#[R31 + 48]> */
		/* 8206F170h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8206F170h case   19:*/		return 0x8206F174;
	}
	return 0x8206F174;
} // Block from 8206F124h-8206F174h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8206F174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F174);
		  /* 8206F174h */ case    0:  		/* lwz R11, <#[R1 + 212]> */
		/* 8206F174h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000D4) );
		/* 8206F174h case    0:*/		return 0x8206F178;
		  /* 8206F178h */ case    1:  		/* cmpwi CR6, R27, 0 */
		/* 8206F178h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8206F178h case    1:*/		return 0x8206F17C;
		  /* 8206F17Ch */ case    2:  		/* stw R11, <#[R31 + 23760]> */
		/* 8206F17Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00005CD0) );
		/* 8206F17Ch case    2:*/		return 0x8206F180;
		  /* 8206F180h */ case    3:  		/* bc 12, CR6_EQ, 52 */
		/* 8206F180h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206F1B4;  }
		/* 8206F180h case    3:*/		return 0x8206F184;
		  /* 8206F184h */ case    4:  		/* lwz R11, <#[R31 + 22036]> */
		/* 8206F184h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005614) );
		/* 8206F184h case    4:*/		return 0x8206F188;
		  /* 8206F188h */ case    5:  		/* mr R3, R31 */
		/* 8206F188h case    5:*/		regs.R3 = regs.R31;
		/* 8206F188h case    5:*/		return 0x8206F18C;
		  /* 8206F18Ch */ case    6:  		/* lwz R10, <#[R31 + 11024]> */
		/* 8206F18Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B10) );
		/* 8206F18Ch case    6:*/		return 0x8206F190;
		  /* 8206F190h */ case    7:  		/* addi R11, R11, 1 */
		/* 8206F190h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206F190h case    7:*/		return 0x8206F194;
		  /* 8206F194h */ case    8:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 8206F194h case    8:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 8206F194h case    8:*/		return 0x8206F198;
		  /* 8206F198h */ case    9:  		/* addi R11, R11, 16 */
		/* 8206F198h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206F198h case    9:*/		return 0x8206F19C;
		  /* 8206F19Ch */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206F19Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206F19Ch case   10:*/		return 0x8206F1A0;
		  /* 8206F1A0h */ case   11:  		/* add R4, R11, R10 */
		/* 8206F1A0h case   11:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 8206F1A0h case   11:*/		return 0x8206F1A4;
		  /* 8206F1A4h */ case   12:  		/* bl 47108 */
		/* 8206F1A4h case   12:*/		regs.LR = 0x8206F1A8; return 0x8207A9A8;
		/* 8206F1A4h case   12:*/		return 0x8206F1A8;
		  /* 8206F1A8h */ case   13:  		/* lwz R11, <#[R31 + 22036]> */
		/* 8206F1A8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005614) );
		/* 8206F1A8h case   13:*/		return 0x8206F1AC;
		  /* 8206F1ACh */ case   14:  		/* addi R11, R11, 2 */
		/* 8206F1ACh case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8206F1ACh case   14:*/		return 0x8206F1B0;
		  /* 8206F1B0h */ case   15:  		/* stw R11, <#[R31 + 22036]> */
		/* 8206F1B0h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00005614) );
		/* 8206F1B0h case   15:*/		return 0x8206F1B4;
	}
	return 0x8206F1B4;
} // Block from 8206F174h-8206F1B4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206F1B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F1B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F1B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F1B4);
		  /* 8206F1B4h */ case    0:  		/* lwz R11, <#[R1 + 216]> */
		/* 8206F1B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000D8) );
		/* 8206F1B4h case    0:*/		return 0x8206F1B8;
		  /* 8206F1B8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8206F1B8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206F1B8h case    1:*/		return 0x8206F1BC;
		  /* 8206F1BCh */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 8206F1BCh case    2:*/		if ( regs.CR[6].eq ) { return 0x8206F1C4;  }
		/* 8206F1BCh case    2:*/		return 0x8206F1C0;
		  /* 8206F1C0h */ case    3:  		/* stw R11, <#[R31 + 24388]> */
		/* 8206F1C0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00005F44) );
		/* 8206F1C0h case    3:*/		return 0x8206F1C4;
	}
	return 0x8206F1C4;
} // Block from 8206F1B4h-8206F1C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206F1C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F1C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F1C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F1C4);
		  /* 8206F1C4h */ case    0:  		/* lwz R29, <#[R31 + 17116]> */
		/* 8206F1C4h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x000042DC) );
		/* 8206F1C4h case    0:*/		return 0x8206F1C8;
		  /* 8206F1C8h */ case    1:  		/* stw R20, <#[R31 + 17116]> */
		/* 8206F1C8h case    1:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R31 + 0x000042DC) );
		/* 8206F1C8h case    1:*/		return 0x8206F1CC;
		  /* 8206F1CCh */ case    2:  		/* rlwinm. R11, R29, 0, 28, 28 */
		/* 8206F1CCh case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R29);
		/* 8206F1CCh case    2:*/		return 0x8206F1D0;
		  /* 8206F1D0h */ case    3:  		/* bc 12, CR0_EQ, 28 */
		/* 8206F1D0h case    3:*/		if ( regs.CR[0].eq ) { return 0x8206F1EC;  }
		/* 8206F1D0h case    3:*/		return 0x8206F1D4;
		  /* 8206F1D4h */ case    4:  		/* mr R5, R19 */
		/* 8206F1D4h case    4:*/		regs.R5 = regs.R19;
		/* 8206F1D4h case    4:*/		return 0x8206F1D8;
		  /* 8206F1D8h */ case    5:  		/* addi R4, R31, 13948 */
		/* 8206F1D8h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x367C);
		/* 8206F1D8h case    5:*/		return 0x8206F1DC;
		  /* 8206F1DCh */ case    6:  		/* mr R3, R31 */
		/* 8206F1DCh case    6:*/		regs.R3 = regs.R31;
		/* 8206F1DCh case    6:*/		return 0x8206F1E0;
		  /* 8206F1E0h */ case    7:  		/* bl 63936 */
		/* 8206F1E0h case    7:*/		regs.LR = 0x8206F1E4; return 0x8207EBA0;
		/* 8206F1E0h case    7:*/		return 0x8206F1E4;
		  /* 8206F1E4h */ case    8:  		/* mr R3, R31 */
		/* 8206F1E4h case    8:*/		regs.R3 = regs.R31;
		/* 8206F1E4h case    8:*/		return 0x8206F1E8;
		  /* 8206F1E8h */ case    9:  		/* bl 20256 */
		/* 8206F1E8h case    9:*/		regs.LR = 0x8206F1EC; return 0x82074108;
		/* 8206F1E8h case    9:*/		return 0x8206F1EC;
	}
	return 0x8206F1EC;
} // Block from 8206F1C4h-8206F1ECh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206F1ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F1EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F1EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F1EC);
		  /* 8206F1ECh */ case    0:  		/* cmpwi CR6, R26, 0 */
		/* 8206F1ECh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 8206F1ECh case    0:*/		return 0x8206F1F0;
		  /* 8206F1F0h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 8206F1F0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8206F210;  }
		/* 8206F1F0h case    1:*/		return 0x8206F1F4;
		  /* 8206F1F4h */ case    2:  		/* addi R3, R31, 14044 */
		/* 8206F1F4h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x36DC);
		/* 8206F1F4h case    2:*/		return 0x8206F1F8;
		  /* 8206F1F8h */ case    3:  		/* li R5, 28 */
		/* 8206F1F8h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 8206F1F8h case    3:*/		return 0x8206F1FC;
		  /* 8206F1FCh */ case    4:  		/* mr R4, R21 */
		/* 8206F1FCh case    4:*/		regs.R4 = regs.R21;
		/* 8206F1FCh case    4:*/		return 0x8206F200;
		  /* 8206F200h */ case    5:  		/* bl 141232 */
		/* 8206F200h case    5:*/		regs.LR = 0x8206F204; return 0x820919B0;
		/* 8206F200h case    5:*/		return 0x8206F204;
		  /* 8206F204h */ case    6:  		/* mr R4, R21 */
		/* 8206F204h case    6:*/		regs.R4 = regs.R21;
		/* 8206F204h case    6:*/		return 0x8206F208;
		  /* 8206F208h */ case    7:  		/* mr R3, R31 */
		/* 8206F208h case    7:*/		regs.R3 = regs.R31;
		/* 8206F208h case    7:*/		return 0x8206F20C;
		  /* 8206F20Ch */ case    8:  		/* bl 55572 */
		/* 8206F20Ch case    8:*/		regs.LR = 0x8206F210; return 0x8207CB20;
		/* 8206F20Ch case    8:*/		return 0x8206F210;
	}
	return 0x8206F210;
} // Block from 8206F1ECh-8206F210h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206F210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F210);
		  /* 8206F210h */ case    0:  		/* lwz R11, <#[R1 + 216]> */
		/* 8206F210h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000D8) );
		/* 8206F210h case    0:*/		return 0x8206F214;
		  /* 8206F214h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8206F214h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206F214h case    1:*/		return 0x8206F218;
		  /* 8206F218h */ case    2:  		/* bc 12, CR6_EQ, 208 */
		/* 8206F218h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206F2E8;  }
		/* 8206F218h case    2:*/		return 0x8206F21C;
		  /* 8206F21Ch */ case    3:  		/* lwz R11, <#[R1 + 104]> */
		/* 8206F21Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 8206F21Ch case    3:*/		return 0x8206F220;
		  /* 8206F220h */ case    4:  		/* cmplw CR6, R11, R25 */
		/* 8206F220h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 8206F220h case    4:*/		return 0x8206F224;
		  /* 8206F224h */ case    5:  		/* bc 4, CR6_EQ, 196 */
		/* 8206F224h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206F2E8;  }
		/* 8206F224h case    5:*/		return 0x8206F228;
		  /* 8206F228h */ case    6:  		/* lwz R11, <#[R1 + 112]> */
		/* 8206F228h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8206F228h case    6:*/		return 0x8206F22C;
		  /* 8206F22Ch */ case    7:  		/* addi R3, R31, 14072 */
		/* 8206F22Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x36F8);
		/* 8206F22Ch case    7:*/		return 0x8206F230;
		  /* 8206F230h */ case    8:  		/* mr R26, R20 */
		/* 8206F230h case    8:*/		regs.R26 = regs.R20;
		/* 8206F230h case    8:*/		return 0x8206F234;
		  /* 8206F234h */ case    9:  		/* mr R28, R3 */
		/* 8206F234h case    9:*/		regs.R28 = regs.R3;
		/* 8206F234h case    9:*/		return 0x8206F238;
		  /* 8206F238h */ case   10:  		/* cmplwi CR6, R11, 7 */
		/* 8206F238h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 8206F238h case   10:*/		return 0x8206F23C;
		  /* 8206F23Ch */ case   11:  		/* lis R27, 10280 */
		/* 8206F23Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R27,0x2828);
		/* 8206F23Ch case   11:*/		return 0x8206F240;
		  /* 8206F240h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 8206F240h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8206F24C;  }
		/* 8206F240h case   12:*/		return 0x8206F244;
		  /* 8206F244h */ case   13:  		/* ori R27, R27, 310 */
		/* 8206F244h case   13:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x136);
		/* 8206F244h case   13:*/		return 0x8206F248;
	}
	return 0x8206F248;
} // Block from 8206F210h-8206F248h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206F248h
// Function '?Get2DSurfaceDesc@D3D@@YAXPAUD3DBaseTexture@@IPAU_D3DSURFACE_DESC@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F248);
		  /* 8206F248h */ case    0:  		/* b 8 */
		/* 8206F248h case    0:*/		return 0x8206F250;
		/* 8206F248h case    0:*/		return 0x8206F24C;
	}
	return 0x8206F24C;
} // Block from 8206F248h-8206F24Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206F24Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F24C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F24C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F24C);
		  /* 8206F24Ch */ case    0:  		/* ori R27, R27, 262 */
		/* 8206F24Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x106);
		/* 8206F24Ch case    0:*/		return 0x8206F250;
	}
	return 0x8206F250;
} // Block from 8206F24Ch-8206F250h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206F250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F250);
		  /* 8206F250h */ case    0:  		/* lwz R11, <#[R1 + 236]> */
		/* 8206F250h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000EC) );
		/* 8206F250h case    0:*/		return 0x8206F254;
		  /* 8206F254h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8206F254h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206F254h case    1:*/		return 0x8206F258;
		  /* 8206F258h */ case    2:  		/* bc 12, CR6_EQ, 84 */
		/* 8206F258h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206F2AC;  }
		/* 8206F258h case    2:*/		return 0x8206F25C;
		  /* 8206F25Ch */ case    3:  		/* addi R11, R1, 240 */
		/* 8206F25Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xF0);
		/* 8206F25Ch case    3:*/		return 0x8206F260;
		  /* 8206F260h */ case    4:  		/* mr R10, R3 */
		/* 8206F260h case    4:*/		regs.R10 = regs.R3;
		/* 8206F260h case    4:*/		return 0x8206F264;
		  /* 8206F264h */ case    5:  		/* addi R8, R11, 56 */
		/* 8206F264h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x38);
		/* 8206F264h case    5:*/		return 0x8206F268;
		  /* 8206F268h */ case    6:  		/* lbz R9, <#[R11]> */
		/* 8206F268h case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8206F268h case    6:*/		return 0x8206F26C;
		  /* 8206F26Ch */ case    7:  		/* lbz R7, <#[R10]> */
		/* 8206F26Ch case    7:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 8206F26Ch case    7:*/		return 0x8206F270;
		  /* 8206F270h */ case    8:  		/* subf. R9, R7, R9 */
		/* 8206F270h case    8:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8206F270h case    8:*/		return 0x8206F274;
		  /* 8206F274h */ case    9:  		/* bc 4, CR0_EQ, 20 */
		/* 8206F274h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8206F288;  }
		/* 8206F274h case    9:*/		return 0x8206F278;
		  /* 8206F278h */ case   10:  		/* addi R11, R11, 1 */
		/* 8206F278h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206F278h case   10:*/		return 0x8206F27C;
		  /* 8206F27Ch */ case   11:  		/* addi R10, R10, 1 */
		/* 8206F27Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8206F27Ch case   11:*/		return 0x8206F280;
		  /* 8206F280h */ case   12:  		/* cmpw CR6, R11, R8 */
		/* 8206F280h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 8206F280h case   12:*/		return 0x8206F284;
		  /* 8206F284h */ case   13:  		/* bc 4, CR6_EQ, -28 */
		/* 8206F284h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8206F268;  }
		/* 8206F284h case   13:*/		return 0x8206F288;
	}
	return 0x8206F288;
} // Block from 8206F250h-8206F288h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206F288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F288);
		  /* 8206F288h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 8206F288h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 8206F288h case    0:*/		return 0x8206F28C;
		  /* 8206F28Ch */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 8206F28Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8206F2AC;  }
		/* 8206F28Ch case    1:*/		return 0x8206F290;
		  /* 8206F290h */ case    2:  		/* addi R4, R1, 240 */
		/* 8206F290h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xF0);
		/* 8206F290h case    2:*/		return 0x8206F294;
		  /* 8206F294h */ case    3:  		/* li R5, 56 */
		/* 8206F294h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x38);
		/* 8206F294h case    3:*/		return 0x8206F298;
		  /* 8206F298h */ case    4:  		/* bl 141080 */
		/* 8206F298h case    4:*/		regs.LR = 0x8206F29C; return 0x820919B0;
		/* 8206F298h case    4:*/		return 0x8206F29C;
		  /* 8206F29Ch */ case    5:  		/* lbz R11, <#[R31 + 11070]> */
		/* 8206F29Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3E) );
		/* 8206F29Ch case    5:*/		return 0x8206F2A0;
		  /* 8206F2A0h */ case    6:  		/* ori R11, R11, 16 */
		/* 8206F2A0h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206F2A0h case    6:*/		return 0x8206F2A4;
		  /* 8206F2A4h */ case    7:  		/* stb R11, <#[R31 + 11070]> */
		/* 8206F2A4h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002B3E) );
		/* 8206F2A4h case    7:*/		return 0x8206F2A8;
		  /* 8206F2A8h */ case    8:  		/* b 32 */
		/* 8206F2A8h case    8:*/		return 0x8206F2C8;
		/* 8206F2A8h case    8:*/		return 0x8206F2AC;
	}
	return 0x8206F2AC;
} // Block from 8206F288h-8206F2ACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206F2ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F2AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F2AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F2AC);
		  /* 8206F2ACh */ case    0:  		/* lbz R11, <#[R31 + 11070]> */
		/* 8206F2ACh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3E) );
		/* 8206F2ACh case    0:*/		return 0x8206F2B0;
		  /* 8206F2B0h */ case    1:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 8206F2B0h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8206F2B0h case    1:*/		return 0x8206F2B4;
		  /* 8206F2B4h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 8206F2B4h case    2:*/		if ( regs.CR[0].eq ) { return 0x8206F2CC;  }
		/* 8206F2B4h case    2:*/		return 0x8206F2B8;
		  /* 8206F2B8h */ case    3:  		/* lwz R11, <#[R1 + 352]> */
		/* 8206F2B8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000160) );
		/* 8206F2B8h case    3:*/		return 0x8206F2BC;
		  /* 8206F2BCh */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206F2BCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206F2BCh case    4:*/		return 0x8206F2C0;
		  /* 8206F2C0h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 8206F2C0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206F2CC;  }
		/* 8206F2C0h case    5:*/		return 0x8206F2C4;
		  /* 8206F2C4h */ case    6:  		/* addi R28, R31, 14128 */
		/* 8206F2C4h case    6:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x3730);
		/* 8206F2C4h case    6:*/		return 0x8206F2C8;
	}
	return 0x8206F2C8;
} // Block from 8206F2ACh-8206F2C8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206F2C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F2C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F2C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F2C8);
		  /* 8206F2C8h */ case    0:  		/* ori R29, R29, 4 */
		/* 8206F2C8h case    0:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8206F2C8h case    0:*/		return 0x8206F2CC;
	}
	return 0x8206F2CC;
} // Block from 8206F2C8h-8206F2CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206F2CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F2CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F2CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F2CC);
		  /* 8206F2CCh */ case    0:  		/* lbz R11, <#[R31 + 11071]> */
		/* 8206F2CCh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3F) );
		/* 8206F2CCh case    0:*/		return 0x8206F2D0;
		  /* 8206F2D0h */ case    1:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 8206F2D0h case    1:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 8206F2D0h case    1:*/		return 0x8206F2D4;
		  /* 8206F2D4h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 8206F2D4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8206F2DC;  }
		/* 8206F2D4h case    2:*/		return 0x8206F2D8;
		  /* 8206F2D8h */ case    3:  		/* ori R29, R29, 3 */
		/* 8206F2D8h case    3:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0x3);
		/* 8206F2D8h case    3:*/		return 0x8206F2DC;
	}
	return 0x8206F2DC;
} // Block from 8206F2CCh-8206F2DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206F2DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F2DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F2DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F2DC);
		  /* 8206F2DCh */ case    0:  		/* lwz R30, <#[R1 + 108]> */
		/* 8206F2DCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206F2DCh case    0:*/		return 0x8206F2E0;
		  /* 8206F2E0h */ case    1:  		/* ori R11, R11, 64 */
		/* 8206F2E0h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 8206F2E0h case    1:*/		return 0x8206F2E4;
		  /* 8206F2E4h */ case    2:  		/* b 100 */
		/* 8206F2E4h case    2:*/		return 0x8206F348;
		/* 8206F2E4h case    2:*/		return 0x8206F2E8;
	}
	return 0x8206F2E8;
} // Block from 8206F2DCh-8206F2E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206F2E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F2E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F2E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F2E8);
		  /* 8206F2E8h */ case    0:  		/* lbz R11, <#[R31 + 11070]> */
		/* 8206F2E8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3E) );
		/* 8206F2E8h case    0:*/		return 0x8206F2EC;
		  /* 8206F2ECh */ case    1:  		/* addi R28, R31, 14128 */
		/* 8206F2ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x3730);
		/* 8206F2ECh case    1:*/		return 0x8206F2F0;
		  /* 8206F2F0h */ case    2:  		/* lwz R27, <#[R31 + 14012]> */
		/* 8206F2F0h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x000036BC) );
		/* 8206F2F0h case    2:*/		return 0x8206F2F4;
		  /* 8206F2F4h */ case    3:  		/* addi R26, R31, 15408 */
		/* 8206F2F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R31,0x3C30);
		/* 8206F2F4h case    3:*/		return 0x8206F2F8;
		  /* 8206F2F8h */ case    4:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 8206F2F8h case    4:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8206F2F8h case    4:*/		return 0x8206F2FC;
		  /* 8206F2FCh */ case    5:  		/* stw R30, <#[R1 + 108]> */
		/* 8206F2FCh case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206F2FCh case    5:*/		return 0x8206F300;
		  /* 8206F300h */ case    6:  		/* stw R24, <#[R1 + 112]> */
		/* 8206F300h case    6:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000070) );
		/* 8206F300h case    6:*/		return 0x8206F304;
		  /* 8206F304h */ case    7:  		/* stw R23, <#[R1 + 96]> */
		/* 8206F304h case    7:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000060) );
		/* 8206F304h case    7:*/		return 0x8206F308;
		  /* 8206F308h */ case    8:  		/* stw R25, <#[R1 + 104]> */
		/* 8206F308h case    8:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000068) );
		/* 8206F308h case    8:*/		return 0x8206F30C;
		  /* 8206F30Ch */ case    9:  		/* stw R22, <#[R1 + 100]> */
		/* 8206F30Ch case    9:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000064) );
		/* 8206F30Ch case    9:*/		return 0x8206F310;
		  /* 8206F310h */ case   10:  		/* bc 12, CR0_EQ, 36 */
		/* 8206F310h case   10:*/		if ( regs.CR[0].eq ) { return 0x8206F334;  }
		/* 8206F310h case   10:*/		return 0x8206F314;
		  /* 8206F314h */ case   11:  		/* li R5, 56 */
		/* 8206F314h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x38);
		/* 8206F314h case   11:*/		return 0x8206F318;
		  /* 8206F318h */ case   12:  		/* li R4, 0 */
		/* 8206F318h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206F318h case   12:*/		return 0x8206F31C;
		  /* 8206F31Ch */ case   13:  		/* addi R3, R31, 14072 */
		/* 8206F31Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x36F8);
		/* 8206F31Ch case   13:*/		return 0x8206F320;
		  /* 8206F320h */ case   14:  		/* bl 139296 */
		/* 8206F320h case   14:*/		regs.LR = 0x8206F324; return 0x82091340;
		/* 8206F320h case   14:*/		return 0x8206F324;
		  /* 8206F324h */ case   15:  		/* lbz R11, <#[R31 + 11070]> */
		/* 8206F324h case   15:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3E) );
		/* 8206F324h case   15:*/		return 0x8206F328;
		  /* 8206F328h */ case   16:  		/* ori R29, R29, 4 */
		/* 8206F328h case   16:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8206F328h case   16:*/		return 0x8206F32C;
		  /* 8206F32Ch */ case   17:  		/* andi. R11, R11, 239 */
		/* 8206F32Ch case   17:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0xEF);
		/* 8206F32Ch case   17:*/		return 0x8206F330;
		  /* 8206F330h */ case   18:  		/* stb R11, <#[R31 + 11070]> */
		/* 8206F330h case   18:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002B3E) );
		/* 8206F330h case   18:*/		return 0x8206F334;
	}
	return 0x8206F334;
} // Block from 8206F2E8h-8206F334h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206F334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F334);
		  /* 8206F334h */ case    0:  		/* lbz R11, <#[R31 + 11071]> */
		/* 8206F334h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3F) );
		/* 8206F334h case    0:*/		return 0x8206F338;
		  /* 8206F338h */ case    1:  		/* rlwinm. R10, R11, 0, 25, 25 */
		/* 8206F338h case    1:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R11);
		/* 8206F338h case    1:*/		return 0x8206F33C;
		  /* 8206F33Ch */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 8206F33Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8206F344;  }
		/* 8206F33Ch case    2:*/		return 0x8206F340;
		  /* 8206F340h */ case    3:  		/* ori R29, R29, 3 */
		/* 8206F340h case    3:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0x3);
		/* 8206F340h case    3:*/		return 0x8206F344;
	}
	return 0x8206F344;
} // Block from 8206F334h-8206F344h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206F344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F344);
		  /* 8206F344h */ case    0:  		/* andi. R11, R11, 191 */
		/* 8206F344h case    0:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0xBF);
		/* 8206F344h case    0:*/		return 0x8206F348;
	}
	return 0x8206F348;
} // Block from 8206F344h-8206F348h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206F348h
// Function '?FindSurfaceWithinTexture@D3D@@YAXPAUD3DBaseTexture@@IIPAK1111111@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F348);
		  /* 8206F348h */ case    0:  		/* stb R11, <#[R31 + 11071]> */
		/* 8206F348h case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002B3F) );
		/* 8206F348h case    0:*/		return 0x8206F34C;
		  /* 8206F34Ch */ case    1:  		/* lis R11, -32216 */
		/* 8206F34Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8206F34Ch case    1:*/		return 0x8206F350;
		  /* 8206F350h */ case    2:  		/* lwz R11, <#[R11 + 28736]> */
		/* 8206F350h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00007040) );
		/* 8206F350h case    2:*/		return 0x8206F354;
		  /* 8206F354h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 8206F354h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206F354h case    3:*/		return 0x8206F358;
		  /* 8206F358h */ case    4:  		/* bc 4, CR6_EQ, 16 */
		/* 8206F358h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8206F368;  }
		/* 8206F358h case    4:*/		return 0x8206F35C;
		  /* 8206F35Ch */ case    5:  		/* lbz R11, <#[R31 + 11069]> */
		/* 8206F35Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 8206F35Ch case    5:*/		return 0x8206F360;
		  /* 8206F360h */ case    6:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8206F360h case    6:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8206F360h case    6:*/		return 0x8206F364;
		  /* 8206F364h */ case    7:  		/* bc 12, CR0_EQ, 8 */
		/* 8206F364h case    7:*/		if ( regs.CR[0].eq ) { return 0x8206F36C;  }
		/* 8206F364h case    7:*/		return 0x8206F368;
	}
	return 0x8206F368;
} // Block from 8206F348h-8206F368h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206F368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F368);
		  /* 8206F368h */ case    0:  		/* mr R29, R20 */
		/* 8206F368h case    0:*/		regs.R29 = regs.R20;
		/* 8206F368h case    0:*/		return 0x8206F36C;
	}
	return 0x8206F36C;
} // Block from 8206F368h-8206F36Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206F36Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F36C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F36C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F36C);
		  /* 8206F36Ch */ case    0:  		/* rlwinm R11, R30, 12, 20, 31 */
		/* 8206F36Ch case    0:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R30);
		/* 8206F36Ch case    0:*/		return 0x8206F370;
		  /* 8206F370h */ case    1:  		/* rlwinm R10, R30, 0, 3, 31 */
		/* 8206F370h case    1:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R30);
		/* 8206F370h case    1:*/		return 0x8206F374;
		  /* 8206F374h */ case    2:  		/* addi R11, R11, 512 */
		/* 8206F374h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8206F374h case    2:*/		return 0x8206F378;
		  /* 8206F378h */ case    3:  		/* cmplwi CR6, R29, 0 */
		/* 8206F378h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8206F378h case    3:*/		return 0x8206F37C;
		  /* 8206F37Ch */ case    4:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 8206F37Ch case    4:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 8206F37Ch case    4:*/		return 0x8206F380;
		  /* 8206F380h */ case    5:  		/* mr R3, R31 */
		/* 8206F380h case    5:*/		regs.R3 = regs.R31;
		/* 8206F380h case    5:*/		return 0x8206F384;
		  /* 8206F384h */ case    6:  		/* add R30, R11, R10 */
		/* 8206F384h case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 8206F384h case    6:*/		return 0x8206F388;
		  /* 8206F388h */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 8206F388h case    7:*/		if ( regs.CR[6].eq ) { return 0x8206F3B0;  }
		/* 8206F388h case    7:*/		return 0x8206F38C;
		  /* 8206F38Ch */ case    8:  		/* mr R10, R26 */
		/* 8206F38Ch case    8:*/		regs.R10 = regs.R26;
		/* 8206F38Ch case    8:*/		return 0x8206F390;
		  /* 8206F390h */ case    9:  		/* lwz R8, <#[R1 + 100]> */
		/* 8206F390h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000064) );
		/* 8206F390h case    9:*/		return 0x8206F394;
		  /* 8206F394h */ case   10:  		/* mr R9, R28 */
		/* 8206F394h case   10:*/		regs.R9 = regs.R28;
		/* 8206F394h case   10:*/		return 0x8206F398;
		  /* 8206F398h */ case   11:  		/* lwz R7, <#[R1 + 96]> */
		/* 8206F398h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000060) );
		/* 8206F398h case   11:*/		return 0x8206F39C;
		  /* 8206F39Ch */ case   12:  		/* mr R6, R27 */
		/* 8206F39Ch case   12:*/		regs.R6 = regs.R27;
		/* 8206F39Ch case   12:*/		return 0x8206F3A0;
		  /* 8206F3A0h */ case   13:  		/* mr R5, R30 */
		/* 8206F3A0h case   13:*/		regs.R5 = regs.R30;
		/* 8206F3A0h case   13:*/		return 0x8206F3A4;
		  /* 8206F3A4h */ case   14:  		/* mr R4, R29 */
		/* 8206F3A4h case   14:*/		regs.R4 = regs.R29;
		/* 8206F3A4h case   14:*/		return 0x8206F3A8;
		  /* 8206F3A8h */ case   15:  		/* bl -2032 */
		/* 8206F3A8h case   15:*/		regs.LR = 0x8206F3AC; return 0x8206EBB8;
		/* 8206F3A8h case   15:*/		return 0x8206F3AC;
		  /* 8206F3ACh */ case   16:  		/* b 16 */
		/* 8206F3ACh case   16:*/		return 0x8206F3BC;
		/* 8206F3ACh case   16:*/		return 0x8206F3B0;
	}
	return 0x8206F3B0;
} // Block from 8206F36Ch-8206F3B0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8206F3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F3B0);
		  /* 8206F3B0h */ case    0:  		/* mr R5, R27 */
		/* 8206F3B0h case    0:*/		regs.R5 = regs.R27;
		/* 8206F3B0h case    0:*/		return 0x8206F3B4;
		  /* 8206F3B4h */ case    1:  		/* mr R4, R30 */
		/* 8206F3B4h case    1:*/		regs.R4 = regs.R30;
		/* 8206F3B4h case    1:*/		return 0x8206F3B8;
		  /* 8206F3B8h */ case    2:  		/* bl -2232 */
		/* 8206F3B8h case    2:*/		regs.LR = 0x8206F3BC; return 0x8206EB00;
		/* 8206F3B8h case    2:*/		return 0x8206F3BC;
	}
	return 0x8206F3BC;
} // Block from 8206F3B0h-8206F3BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206F3BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F3BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F3BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F3BC);
		  /* 8206F3BCh */ case    0:  		/* mr R10, R28 */
		/* 8206F3BCh case    0:*/		regs.R10 = regs.R28;
		/* 8206F3BCh case    0:*/		return 0x8206F3C0;
		  /* 8206F3C0h */ case    1:  		/* lwz R9, <#[R1 + 100]> */
		/* 8206F3C0h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000064) );
		/* 8206F3C0h case    1:*/		return 0x8206F3C4;
		  /* 8206F3C4h */ case    2:  		/* mr R7, R27 */
		/* 8206F3C4h case    2:*/		regs.R7 = regs.R27;
		/* 8206F3C4h case    2:*/		return 0x8206F3C8;
		  /* 8206F3C8h */ case    3:  		/* lwz R8, <#[R1 + 96]> */
		/* 8206F3C8h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 8206F3C8h case    3:*/		return 0x8206F3CC;
		  /* 8206F3CCh */ case    4:  		/* mr R6, R30 */
		/* 8206F3CCh case    4:*/		regs.R6 = regs.R30;
		/* 8206F3CCh case    4:*/		return 0x8206F3D0;
		  /* 8206F3D0h */ case    5:  		/* lwz R5, <#[R1 + 104]> */
		/* 8206F3D0h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 8206F3D0h case    5:*/		return 0x8206F3D4;
		  /* 8206F3D4h */ case    6:  		/* mr R4, R29 */
		/* 8206F3D4h case    6:*/		regs.R4 = regs.R29;
		/* 8206F3D4h case    6:*/		return 0x8206F3D8;
		  /* 8206F3D8h */ case    7:  		/* stw R26, <#[R1 + 84]> */
		/* 8206F3D8h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000054) );
		/* 8206F3D8h case    7:*/		return 0x8206F3DC;
		  /* 8206F3DCh */ case    8:  		/* mr R3, R31 */
		/* 8206F3DCh case    8:*/		regs.R3 = regs.R31;
		/* 8206F3DCh case    8:*/		return 0x8206F3E0;
		  /* 8206F3E0h */ case    9:  		/* bl 45856 */
		/* 8206F3E0h case    9:*/		regs.LR = 0x8206F3E4; return 0x8207A700;
		/* 8206F3E0h case    9:*/		return 0x8206F3E4;
		  /* 8206F3E4h */ case   10:  		/* rlwinm. R11, R29, 0, 28, 28 */
		/* 8206F3E4h case   10:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R29);
		/* 8206F3E4h case   10:*/		return 0x8206F3E8;
		  /* 8206F3E8h */ case   11:  		/* bc 12, CR0_EQ, 124 */
		/* 8206F3E8h case   11:*/		if ( regs.CR[0].eq ) { return 0x8206F464;  }
		/* 8206F3E8h case   11:*/		return 0x8206F3EC;
		  /* 8206F3ECh */ case   12:  		/* cmpwi CR6, R19, 0 */
		/* 8206F3ECh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 8206F3ECh case   12:*/		return 0x8206F3F0;
		  /* 8206F3F0h */ case   13:  		/* bc 12, CR6_EQ, 116 */
		/* 8206F3F0h case   13:*/		if ( regs.CR[6].eq ) { return 0x8206F464;  }
		/* 8206F3F0h case   13:*/		return 0x8206F3F4;
		  /* 8206F3F4h */ case   14:  		/* lwz R3, <#[R31 + 48]> */
		/* 8206F3F4h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206F3F4h case   14:*/		return 0x8206F3F8;
		  /* 8206F3F8h */ case   15:  		/* lwz R11, <#[R31 + 56]> */
		/* 8206F3F8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8206F3F8h case   15:*/		return 0x8206F3FC;
		  /* 8206F3FCh */ case   16:  		/* cmplw CR6, R3, R11 */
		/* 8206F3FCh case   16:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8206F3FCh case   16:*/		return 0x8206F400;
		  /* 8206F400h */ case   17:  		/* bc 4, CR6_GT, 12 */
		/* 8206F400h case   17:*/		if ( !regs.CR[6].gt ) { return 0x8206F40C;  }
		/* 8206F400h case   17:*/		return 0x8206F404;
		  /* 8206F404h */ case   18:  		/* mr R3, R31 */
		/* 8206F404h case   18:*/		regs.R3 = regs.R31;
		/* 8206F404h case   18:*/		return 0x8206F408;
		  /* 8206F408h */ case   19:  		/* bl 19712 */
		/* 8206F408h case   19:*/		regs.LR = 0x8206F40C; return 0x82074108;
		/* 8206F408h case   19:*/		return 0x8206F40C;
	}
	return 0x8206F40C;
} // Block from 8206F3BCh-8206F40Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8206F40Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F40C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F40C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F40C);
		  /* 8206F40Ch */ case    0:  		/* lis R11, -16382 */
		/* 8206F40Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC002);
		/* 8206F40Ch case    0:*/		return 0x8206F410;
		  /* 8206F410h */ case    1:  		/* li R10, 7758 */
		/* 8206F410h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1E4E);
		/* 8206F410h case    1:*/		return 0x8206F414;
		  /* 8206F414h */ case    2:  		/* ori R11, R11, 8448 */
		/* 8206F414h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2100);
		/* 8206F414h case    2:*/		return 0x8206F418;
		  /* 8206F418h */ case    3:  		/* li R9, -2 */
		/* 8206F418h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFE);
		/* 8206F418h case    3:*/		return 0x8206F41C;
		  /* 8206F41Ch */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206F41Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206F41Ch case    4:*/		return 0x8206F420;
		  /* 8206F420h */ case    5:  		/* addi R8, R1, 184 */
		/* 8206F420h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xB8);
		/* 8206F420h case    5:*/		return 0x8206F424;
		  /* 8206F424h */ case    6:  		/* addi R4, R1, 160 */
		/* 8206F424h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0xA0);
		/* 8206F424h case    6:*/		return 0x8206F428;
		  /* 8206F428h */ case    7:  		/* mr R7, R3 */
		/* 8206F428h case    7:*/		regs.R7 = regs.R3;
		/* 8206F428h case    7:*/		return 0x8206F42C;
		  /* 8206F42Ch */ case    8:  		/* addi R3, R1, 184 */
		/* 8206F42Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xB8);
		/* 8206F42Ch case    8:*/		return 0x8206F430;
		  /* 8206F430h */ case    9:  		/* mr R11, R20 */
		/* 8206F430h case    9:*/		regs.R11 = regs.R20;
		/* 8206F430h case    9:*/		return 0x8206F434;
		  /* 8206F434h */ case   10:  		/* stwu R10, <#[R7 + 4]> */
		/* 8206F434h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 8206F434h case   10:*/		return 0x8206F438;
		  /* 8206F438h */ case   11:  		/* stwu R9, <#[R7 + 4]> */
		/* 8206F438h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 8206F438h case   11:*/		return 0x8206F43C;
		  /* 8206F43Ch */ case   12:  		/* stwu R20, <#[R7 + 4]> */
		/* 8206F43Ch case   12:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 8206F43Ch case   12:*/		return 0x8206F440;
		  /* 8206F440h */ case   13:  		/* std R20, <#[R8]> */
		/* 8206F440h case   13:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R8 + 0x00000000) );
		/* 8206F440h case   13:*/		return 0x8206F444;
		  /* 8206F444h */ case   14:  		/* stw R20, <#[R8 + 8]> */
		/* 8206F444h case   14:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R8 + 0x00000008) );
		/* 8206F444h case   14:*/		return 0x8206F448;
		  /* 8206F448h */ case   15:  		/* stw R7, <#[R31 + 48]> */
		/* 8206F448h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000030) );
		/* 8206F448h case   15:*/		return 0x8206F44C;
		  /* 8206F44Ch */ case   16:  		/* bl 2087708 */
		/* 8206F44Ch case   16:*/		regs.LR = 0x8206F450; return 0x8226CF68;
		/* 8206F44Ch case   16:*/		return 0x8206F450;
		  /* 8206F450h */ case   17:  		/* cmplwi CR0, R3, 0 */
		/* 8206F450h case   17:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8206F450h case   17:*/		return 0x8206F454;
		  /* 8206F454h */ case   18:  		/* bc 12, CR0_EQ, 16 */
		/* 8206F454h case   18:*/		if ( regs.CR[0].eq ) { return 0x8206F464;  }
		/* 8206F454h case   18:*/		return 0x8206F458;
		  /* 8206F458h */ case   19:  		/* li R3, 1 */
		/* 8206F458h case   19:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8206F458h case   19:*/		return 0x8206F45C;
		  /* 8206F45Ch */ case   20:  		/* lwz R4, <#[R1 + 160]> */
		/* 8206F45Ch case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000A0) );
		/* 8206F45Ch case   20:*/		return 0x8206F460;
		  /* 8206F460h */ case   21:  		/* bl 2087672 */
		/* 8206F460h case   21:*/		regs.LR = 0x8206F464; return 0x8226CF58;
		/* 8206F460h case   21:*/		return 0x8206F464;
	}
	return 0x8206F464;
} // Block from 8206F40Ch-8206F464h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8206F464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F464);
		  /* 8206F464h */ case    0:  		/* lwz R11, <#[R31 + 24584]> */
		/* 8206F464h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00006008) );
		/* 8206F464h case    0:*/		return 0x8206F468;
		  /* 8206F468h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8206F468h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206F468h case    1:*/		return 0x8206F46C;
		  /* 8206F46Ch */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 8206F46Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8206F480;  }
		/* 8206F46Ch case    2:*/		return 0x8206F470;
		  /* 8206F470h */ case    3:  		/* li R5, 1 */
		/* 8206F470h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206F470h case    3:*/		return 0x8206F474;
		  /* 8206F474h */ case    4:  		/* li R4, 64 */
		/* 8206F474h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x40);
		/* 8206F474h case    4:*/		return 0x8206F478;
		  /* 8206F478h */ case    5:  		/* mr R3, R31 */
		/* 8206F478h case    5:*/		regs.R3 = regs.R31;
		/* 8206F478h case    5:*/		return 0x8206F47C;
		  /* 8206F47Ch */ case    6:  		/* bl 58172 */
		/* 8206F47Ch case    6:*/		regs.LR = 0x8206F480; return 0x8207D7B8;
		/* 8206F47Ch case    6:*/		return 0x8206F480;
	}
	return 0x8206F480;
} // Block from 8206F464h-8206F480h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206F480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F480);
		  /* 8206F480h */ case    0:  		/* lwz R30, <#[R31 + 11036]> */
		/* 8206F480h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00002B1C) );
		/* 8206F480h case    0:*/		return 0x8206F484;
		  /* 8206F484h */ case    1:  		/* mr R3, R31 */
		/* 8206F484h case    1:*/		regs.R3 = regs.R31;
		/* 8206F484h case    1:*/		return 0x8206F488;
		  /* 8206F488h */ case    2:  		/* stw R30, <#[R31 + 11056]> */
		/* 8206F488h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00002B30) );
		/* 8206F488h case    2:*/		return 0x8206F48C;
		  /* 8206F48Ch */ case    3:  		/* bl 19580 */
		/* 8206F48Ch case    3:*/		regs.LR = 0x8206F490; return 0x82074108;
		/* 8206F48Ch case    3:*/		return 0x8206F490;
		  /* 8206F490h */ case    4:  		/* li R5, 0 */
		/* 8206F490h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8206F490h case    4:*/		return 0x8206F494;
		  /* 8206F494h */ case    5:  		/* li R4, 0 */
		/* 8206F494h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206F494h case    5:*/		return 0x8206F498;
		  /* 8206F498h */ case    6:  		/* mr R3, R31 */
		/* 8206F498h case    6:*/		regs.R3 = regs.R31;
		/* 8206F498h case    6:*/		return 0x8206F49C;
		  /* 8206F49Ch */ case    7:  		/* bl 57260 */
		/* 8206F49Ch case    7:*/		regs.LR = 0x8206F4A0; return 0x8207D448;
		/* 8206F49Ch case    7:*/		return 0x8206F4A0;
		  /* 8206F4A0h */ case    8:  		/* lwz R11, <#[R31 + 15316]> */
		/* 8206F4A0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003BD4) );
		/* 8206F4A0h case    8:*/		return 0x8206F4A4;
		  /* 8206F4A4h */ case    9:  		/* mr R3, R31 */
		/* 8206F4A4h case    9:*/		regs.R3 = regs.R31;
		/* 8206F4A4h case    9:*/		return 0x8206F4A8;
		  /* 8206F4A8h */ case   10:  		/* rlwinm R4, R11, 30, 2, 31 */
		/* 8206F4A8h case   10:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R4,regs.R11);
		/* 8206F4A8h case   10:*/		return 0x8206F4AC;
		  /* 8206F4ACh */ case   11:  		/* bl 15228 */
		/* 8206F4ACh case   11:*/		regs.LR = 0x8206F4B0; return 0x82073028;
		/* 8206F4ACh case   11:*/		return 0x8206F4B0;
		  /* 8206F4B0h */ case   12:  		/* li R7, 0 */
		/* 8206F4B0h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8206F4B0h case   12:*/		return 0x8206F4B4;
		  /* 8206F4B4h */ case   13:  		/* li R6, 0 */
		/* 8206F4B4h case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206F4B4h case   13:*/		return 0x8206F4B8;
		  /* 8206F4B8h */ case   14:  		/* lwz R4, <#[R31 + 15344]> */
		/* 8206F4B8h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00003BF0) );
		/* 8206F4B8h case   14:*/		return 0x8206F4BC;
		  /* 8206F4BCh */ case   15:  		/* li R5, 3 */
		/* 8206F4BCh case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8206F4BCh case   15:*/		return 0x8206F4C0;
		  /* 8206F4C0h */ case   16:  		/* mr R3, R31 */
		/* 8206F4C0h case   16:*/		regs.R3 = regs.R31;
		/* 8206F4C0h case   16:*/		return 0x8206F4C4;
		  /* 8206F4C4h */ case   17:  		/* bl 14436 */
		/* 8206F4C4h case   17:*/		regs.LR = 0x8206F4C8; return 0x82072D28;
		/* 8206F4C4h case   17:*/		return 0x8206F4C8;
		  /* 8206F4C8h */ case   18:  		/* lwz R11, <#[R31 + 24392]> */
		/* 8206F4C8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005F48) );
		/* 8206F4C8h case   18:*/		return 0x8206F4CC;
		  /* 8206F4CCh */ case   19:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 8206F4CCh case   19:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 8206F4CCh case   19:*/		return 0x8206F4D0;
		  /* 8206F4D0h */ case   20:  		/* bc 12, CR0_EQ, 68 */
		/* 8206F4D0h case   20:*/		if ( regs.CR[0].eq ) { return 0x8206F514;  }
		/* 8206F4D0h case   20:*/		return 0x8206F4D4;
		  /* 8206F4D4h */ case   21:  		/* li R5, 3 */
		/* 8206F4D4h case   21:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8206F4D4h case   21:*/		return 0x8206F4D8;
		  /* 8206F4D8h */ case   22:  		/* mr R4, R31 */
		/* 8206F4D8h case   22:*/		regs.R4 = regs.R31;
		/* 8206F4D8h case   22:*/		return 0x8206F4DC;
		  /* 8206F4DCh */ case   23:  		/* addi R3, R1, 160 */
		/* 8206F4DCh case   23:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 8206F4DCh case   23:*/		return 0x8206F4E0;
		  /* 8206F4E0h */ case   24:  		/* bl 54920 */
		/* 8206F4E0h case   24:*/		regs.LR = 0x8206F4E4; return 0x8207CB68;
		/* 8206F4E0h case   24:*/		return 0x8206F4E4;
		  /* 8206F4E4h */ case   25:  		/* addi R3, R1, 160 */
		/* 8206F4E4h case   25:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 8206F4E4h case   25:*/		return 0x8206F4E8;
		  /* 8206F4E8h */ case   26:  		/* bl 55160 */
		/* 8206F4E8h case   26:*/		regs.LR = 0x8206F4EC; return 0x8207CC60;
		/* 8206F4E8h case   26:*/		return 0x8206F4EC;
		  /* 8206F4ECh */ case   27:  		/* cmpwi CR0, R3, 0 */
		/* 8206F4ECh case   27:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206F4ECh case   27:*/		return 0x8206F4F0;
		  /* 8206F4F0h */ case   28:  		/* bc 12, CR0_EQ, 24 */
		/* 8206F4F0h case   28:*/		if ( regs.CR[0].eq ) { return 0x8206F508;  }
		/* 8206F4F0h case   28:*/		return 0x8206F4F4;
		  /* 8206F4F4h */ case   29:  		/* lwz R11, <#[R31 + 16976]> */
		/* 8206F4F4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00004250) );
		/* 8206F4F4h case   29:*/		return 0x8206F4F8;
		  /* 8206F4F8h */ case   30:  		/* lwz R10, <#[R31 + 16968]> */
		/* 8206F4F8h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00004248) );
		/* 8206F4F8h case   30:*/		return 0x8206F4FC;
		  /* 8206F4FCh */ case   31:  		/* subf R11, R11, R10 */
		/* 8206F4FCh case   31:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206F4FCh case   31:*/		return 0x8206F500;
		  /* 8206F500h */ case   32:  		/* cmplwi CR6, R11, 15 */
		/* 8206F500h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 8206F500h case   32:*/		return 0x8206F504;
		  /* 8206F504h */ case   33:  		/* bc 4, CR6_LT, -32 */
		/* 8206F504h case   33:*/		if ( !regs.CR[6].lt ) { return 0x8206F4E4;  }
		/* 8206F504h case   33:*/		return 0x8206F508;
	}
	return 0x8206F508;
} // Block from 8206F480h-8206F508h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8206F508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F508);
		  /* 8206F508h */ case    0:  		/* addi R3, R1, 160 */
		/* 8206F508h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 8206F508h case    0:*/		return 0x8206F50C;
		  /* 8206F50Ch */ case    1:  		/* bl 54924 */
		/* 8206F50Ch case    1:*/		regs.LR = 0x8206F510; return 0x8207CB98;
		/* 8206F50Ch case    1:*/		return 0x8206F510;
		  /* 8206F510h */ case    2:  		/* b 8 */
		/* 8206F510h case    2:*/		return 0x8206F518;
		/* 8206F510h case    2:*/		return 0x8206F514;
	}
	return 0x8206F514;
} // Block from 8206F508h-8206F514h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206F514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F514);
		  /* 8206F514h */ case    0:  		/* stw R30, <#[R31 + 15344]> */
		/* 8206F514h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00003BF0) );
		/* 8206F514h case    0:*/		return 0x8206F518;
	}
	return 0x8206F518;
} // Block from 8206F514h-8206F518h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206F518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F518);
		  /* 8206F518h */ case    0:  		/* lbz R11, <#[R31 + 11069]> */
		/* 8206F518h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 8206F518h case    0:*/		return 0x8206F51C;
		  /* 8206F51Ch */ case    1:  		/* mr R3, R31 */
		/* 8206F51Ch case    1:*/		regs.R3 = regs.R31;
		/* 8206F51Ch case    1:*/		return 0x8206F520;
		  /* 8206F520h */ case    2:  		/* andi. R11, R11, 239 */
		/* 8206F520h case    2:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0xEF);
		/* 8206F520h case    2:*/		return 0x8206F524;
		  /* 8206F524h */ case    3:  		/* stb R11, <#[R31 + 11069]> */
		/* 8206F524h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 8206F524h case    3:*/		return 0x8206F528;
		  /* 8206F528h */ case    4:  		/* bl 46568 */
		/* 8206F528h case    4:*/		regs.LR = 0x8206F52C; return 0x8207AB10;
		/* 8206F528h case    4:*/		return 0x8206F52C;
		  /* 8206F52Ch */ case    5:  		/* mr R3, R31 */
		/* 8206F52Ch case    5:*/		regs.R3 = regs.R31;
		/* 8206F52Ch case    5:*/		return 0x8206F530;
		  /* 8206F530h */ case    6:  		/* bl 54816 */
		/* 8206F530h case    6:*/		regs.LR = 0x8206F534; return 0x8207CB50;
		/* 8206F530h case    6:*/		return 0x8206F534;
		  /* 8206F534h */ case    7:  		/* li R4, 0 */
		/* 8206F534h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206F534h case    7:*/		return 0x8206F538;
		  /* 8206F538h */ case    8:  		/* mr R3, R31 */
		/* 8206F538h case    8:*/		regs.R3 = regs.R31;
		/* 8206F538h case    8:*/		return 0x8206F53C;
		  /* 8206F53Ch */ case    9:  		/* bl -43796 */
		/* 8206F53Ch case    9:*/		regs.LR = 0x8206F540; return 0x82064A28;
		/* 8206F53Ch case    9:*/		return 0x8206F540;
		  /* 8206F540h */ case   10:  		/* addi R1, R1, 480 */
		/* 8206F540h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1E0);
		/* 8206F540h case   10:*/		return 0x8206F544;
		  /* 8206F544h */ case   11:  		/* b 138560 */
		/* 8206F544h case   11:*/		return 0x82091284;
		/* 8206F544h case   11:*/		return 0x8206F548;
	}
	return 0x8206F548;
} // Block from 8206F518h-8206F548h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206F548h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F548);
		  /* 8206F548h */ case    0:  		/* mfspr R12, LR */
		/* 8206F548h case    0:*/		regs.R12 = regs.LR;
		/* 8206F548h case    0:*/		return 0x8206F54C;
		  /* 8206F54Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206F54Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206F54Ch case    1:*/		return 0x8206F550;
		  /* 8206F550h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8206F550h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206F550h case    2:*/		return 0x8206F554;
		  /* 8206F554h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8206F554h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206F554h case    3:*/		return 0x8206F558;
		  /* 8206F558h */ case    4:  		/* stwu R1, <#[R1 - 208]> */
		/* 8206F558h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 8206F558h case    4:*/		return 0x8206F55C;
		  /* 8206F55Ch */ case    5:  		/* mr R31, R3 */
		/* 8206F55Ch case    5:*/		regs.R31 = regs.R3;
		/* 8206F55Ch case    5:*/		return 0x8206F560;
		  /* 8206F560h */ case    6:  		/* addi R4, R3, 13024 */
		/* 8206F560h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x32E0);
		/* 8206F560h case    6:*/		return 0x8206F564;
		  /* 8206F564h */ case    7:  		/* addi R3, R1, 144 */
		/* 8206F564h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x90);
		/* 8206F564h case    7:*/		return 0x8206F568;
		  /* 8206F568h */ case    8:  		/* li R5, 28 */
		/* 8206F568h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 8206F568h case    8:*/		return 0x8206F56C;
		  /* 8206F56Ch */ case    9:  		/* bl 140356 */
		/* 8206F56Ch case    9:*/		regs.LR = 0x8206F570; return 0x820919B0;
		/* 8206F56Ch case    9:*/		return 0x8206F570;
		  /* 8206F570h */ case   10:  		/* lwz R11, <#[R31 + 13052]> */
		/* 8206F570h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000032FC) );
		/* 8206F570h case   10:*/		return 0x8206F574;
		  /* 8206F574h */ case   11:  		/* addi R10, R1, 128 */
		/* 8206F574h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8206F574h case   11:*/		return 0x8206F578;
		  /* 8206F578h */ case   12:  		/* lwz R9, <#[R31 + 13056]> */
		/* 8206F578h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003300) );
		/* 8206F578h case   12:*/		return 0x8206F57C;
		  /* 8206F57Ch */ case   13:  		/* lwz R8, <#[R31 + 13060]> */
		/* 8206F57Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00003304) );
		/* 8206F57Ch case   13:*/		return 0x8206F580;
		  /* 8206F580h */ case   14:  		/* li R4, 0 */
		/* 8206F580h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206F580h case   14:*/		return 0x8206F584;
		  /* 8206F584h */ case   15:  		/* lwz R7, <#[R31 + 13064]> */
		/* 8206F584h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00003308) );
		/* 8206F584h case   15:*/		return 0x8206F588;
		  /* 8206F588h */ case   16:  		/* mr R3, R31 */
		/* 8206F588h case   16:*/		regs.R3 = regs.R31;
		/* 8206F588h case   16:*/		return 0x8206F58C;
		  /* 8206F58Ch */ case   17:  		/* lwz R5, <#[R31 + 15236]> */
		/* 8206F58Ch case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00003B84) );
		/* 8206F58Ch case   17:*/		return 0x8206F590;
		  /* 8206F590h */ case   18:  		/* stw R11, <#[R10]> */
		/* 8206F590h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8206F590h case   18:*/		return 0x8206F594;
		  /* 8206F594h */ case   19:  		/* stw R9, <#[R10 + 4]> */
		/* 8206F594h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8206F594h case   19:*/		return 0x8206F598;
		  /* 8206F598h */ case   20:  		/* stw R8, <#[R10 + 8]> */
		/* 8206F598h case   20:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 8206F598h case   20:*/		return 0x8206F59C;
		  /* 8206F59Ch */ case   21:  		/* stw R7, <#[R10 + 12]> */
		/* 8206F59Ch case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x0000000C) );
		/* 8206F59Ch case   21:*/		return 0x8206F5A0;
		  /* 8206F5A0h */ case   22:  		/* bl -42728 */
		/* 8206F5A0h case   22:*/		regs.LR = 0x8206F5A4; return 0x82064EB8;
		/* 8206F5A0h case   22:*/		return 0x8206F5A4;
		  /* 8206F5A4h */ case   23:  		/* li R4, 0 */
		/* 8206F5A4h case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206F5A4h case   23:*/		return 0x8206F5A8;
		  /* 8206F5A8h */ case   24:  		/* mr R3, R31 */
		/* 8206F5A8h case   24:*/		regs.R3 = regs.R31;
		/* 8206F5A8h case   24:*/		return 0x8206F5AC;
		  /* 8206F5ACh */ case   25:  		/* bl -3212 */
		/* 8206F5ACh case   25:*/		regs.LR = 0x8206F5B0; return 0x8206E920;
		/* 8206F5ACh case   25:*/		return 0x8206F5B0;
		  /* 8206F5B0h */ case   26:  		/* lis R11, -32256 */
		/* 8206F5B0h case   26:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8206F5B0h case   26:*/		return 0x8206F5B4;
		  /* 8206F5B4h */ case   27:  		/* lis R9, -32256 */
		/* 8206F5B4h case   27:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8206F5B4h case   27:*/		return 0x8206F5B8;
		  /* 8206F5B8h */ case   28:  		/* lwz R6, <#[R31 + 15232]> */
		/* 8206F5B8h case   28:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00003B80) );
		/* 8206F5B8h case   28:*/		return 0x8206F5BC;
		  /* 8206F5BCh */ case   29:  		/* addi R7, R11, 4032 */
		/* 8206F5BCh case   29:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFC0);
		/* 8206F5BCh case   29:*/		return 0x8206F5C0;
		  /* 8206F5C0h */ case   30:  		/* addi R30, R1, 112 */
		/* 8206F5C0h case   30:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x70);
		/* 8206F5C0h case   30:*/		return 0x8206F5C4;
		  /* 8206F5C4h */ case   31:  		/* li R11, 0 */
		/* 8206F5C4h case   31:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206F5C4h case   31:*/		return 0x8206F5C8;
		  /* 8206F5C8h */ case   32:  		/* addi R10, R1, 112 */
		/* 8206F5C8h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8206F5C8h case   32:*/		return 0x8206F5CC;
		  /* 8206F5CCh */ case   33:  		/* lfs FR1, <#[R9 + 1792]> */
		/* 8206F5CCh case   33:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R9 + 0x00000700) );
		/* 8206F5CCh case   33:*/		return 0x8206F5D0;
		  /* 8206F5D0h */ case   34:  		/* li R9, 0 */
		/* 8206F5D0h case   34:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8206F5D0h case   34:*/		return 0x8206F5D4;
		  /* 8206F5D4h */ case   35:  		/* lvx VR63, <#[R7]> */
		/* 8206F5D4h case   35:*/		cpu::mem::lvx( regs, &regs.VR63, (uint32)(regs.R7 + 0x00000000) );
		/* 8206F5D4h case   35:*/		return 0x8206F5D8;
		  /* 8206F5D8h */ case   36:  		/* li R8, 0 */
		/* 8206F5D8h case   36:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8206F5D8h case   36:*/		return 0x8206F5DC;
		  /* 8206F5DCh */ case   37:  		/* li R7, 0 */
		/* 8206F5DCh case   37:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8206F5DCh case   37:*/		return 0x8206F5E0;
		  /* 8206F5E0h */ case   38:  		/* stw R11, <#[R1 + 100]> */
		/* 8206F5E0h case   38:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8206F5E0h case   38:*/		return 0x8206F5E4;
		  /* 8206F5E4h */ case   39:  		/* li R5, 0 */
		/* 8206F5E4h case   39:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8206F5E4h case   39:*/		return 0x8206F5E8;
		  /* 8206F5E8h */ case   40:  		/* stw R11, <#[R1 + 92]> */
		/* 8206F5E8h case   40:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206F5E8h case   40:*/		return 0x8206F5EC;
		  /* 8206F5ECh */ case   41:  		/* li R4, 0 */
		/* 8206F5ECh case   41:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206F5ECh case   41:*/		return 0x8206F5F0;
		  /* 8206F5F0h */ case   42:  		/* stvx VR63, <#[R30]> */
		/* 8206F5F0h case   42:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R30 + 0x00000000) );
		/* 8206F5F0h case   42:*/		return 0x8206F5F4;
		  /* 8206F5F4h */ case   43:  		/* mr R3, R31 */
		/* 8206F5F4h case   43:*/		regs.R3 = regs.R31;
		/* 8206F5F4h case   43:*/		return 0x8206F5F8;
		  /* 8206F5F8h */ case   44:  		/* bl 80528 */
		/* 8206F5F8h case   44:*/		regs.LR = 0x8206F5FC; return 0x82083088;
		/* 8206F5F8h case   44:*/		return 0x8206F5FC;
		  /* 8206F5FCh */ case   45:  		/* lbz R11, <#[R31 + 11072]> */
		/* 8206F5FCh case   45:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B40) );
		/* 8206F5FCh case   45:*/		return 0x8206F600;
		  /* 8206F600h */ case   46:  		/* rlwinm. R10, R11, 0, 0, 24 */
		/* 8206F600h case   46:*/		cpu::op::rlwinm<1,0,0,24>(regs,&regs.R10,regs.R11);
		/* 8206F600h case   46:*/		return 0x8206F604;
		  /* 8206F604h */ case   47:  		/* bc 4, CR0_EQ, 12 */
		/* 8206F604h case   47:*/		if ( !regs.CR[0].eq ) { return 0x8206F610;  }
		/* 8206F604h case   47:*/		return 0x8206F608;
		  /* 8206F608h */ case   48:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 8206F608h case   48:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 8206F608h case   48:*/		return 0x8206F60C;
		  /* 8206F60Ch */ case   49:  		/* bc 12, CR0_EQ, 12 */
		/* 8206F60Ch case   49:*/		if ( regs.CR[0].eq ) { return 0x8206F618;  }
		/* 8206F60Ch case   49:*/		return 0x8206F610;
	}
	return 0x8206F610;
} // Block from 8206F548h-8206F610h (50 instructions)

//////////////////////////////////////////////////////
// Block at 8206F610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F610);
		  /* 8206F610h */ case    0:  		/* mr R3, R31 */
		/* 8206F610h case    0:*/		regs.R3 = regs.R31;
		/* 8206F610h case    0:*/		return 0x8206F614;
		  /* 8206F614h */ case    1:  		/* bl 55540 */
		/* 8206F614h case    1:*/		regs.LR = 0x8206F618; return 0x8207CF08;
		/* 8206F614h case    1:*/		return 0x8206F618;
	}
	return 0x8206F618;
} // Block from 8206F610h-8206F618h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206F618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F618);
		  /* 8206F618h */ case    0:  		/* mr R3, R31 */
		/* 8206F618h case    0:*/		regs.R3 = regs.R31;
		/* 8206F618h case    0:*/		return 0x8206F61C;
		  /* 8206F61Ch */ case    1:  		/* bl 19180 */
		/* 8206F61Ch case    1:*/		regs.LR = 0x8206F620; return 0x82074108;
		/* 8206F61Ch case    1:*/		return 0x8206F620;
		  /* 8206F620h */ case    2:  		/* addi R4, R1, 144 */
		/* 8206F620h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 8206F620h case    2:*/		return 0x8206F624;
		  /* 8206F624h */ case    3:  		/* mr R3, R31 */
		/* 8206F624h case    3:*/		regs.R3 = regs.R31;
		/* 8206F624h case    3:*/		return 0x8206F628;
		  /* 8206F628h */ case    4:  		/* bl -43040 */
		/* 8206F628h case    4:*/		regs.LR = 0x8206F62C; return 0x82064E08;
		/* 8206F628h case    4:*/		return 0x8206F62C;
		  /* 8206F62Ch */ case    5:  		/* addi R4, R1, 128 */
		/* 8206F62Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 8206F62Ch case    5:*/		return 0x8206F630;
		  /* 8206F630h */ case    6:  		/* mr R3, R31 */
		/* 8206F630h case    6:*/		regs.R3 = regs.R31;
		/* 8206F630h case    6:*/		return 0x8206F634;
		  /* 8206F634h */ case    7:  		/* bl -45276 */
		/* 8206F634h case    7:*/		regs.LR = 0x8206F638; return 0x82064558;
		/* 8206F634h case    7:*/		return 0x8206F638;
		  /* 8206F638h */ case    8:  		/* addi R5, R31, 14044 */
		/* 8206F638h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x36DC);
		/* 8206F638h case    8:*/		return 0x8206F63C;
		  /* 8206F63Ch */ case    9:  		/* mr R3, R31 */
		/* 8206F63Ch case    9:*/		regs.R3 = regs.R31;
		/* 8206F63Ch case    9:*/		return 0x8206F640;
		  /* 8206F640h */ case   10:  		/* lwz R4, <#[R31 + 15232]> */
		/* 8206F640h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00003B80) );
		/* 8206F640h case   10:*/		return 0x8206F644;
		  /* 8206F644h */ case   11:  		/* bl -2148 */
		/* 8206F644h case   11:*/		regs.LR = 0x8206F648; return 0x8206EDE0;
		/* 8206F644h case   11:*/		return 0x8206F648;
		  /* 8206F648h */ case   12:  		/* addi R1, R1, 208 */
		/* 8206F648h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 8206F648h case   12:*/		return 0x8206F64C;
		  /* 8206F64Ch */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206F64Ch case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206F64Ch case   13:*/		return 0x8206F650;
		  /* 8206F650h */ case   14:  		/* mtspr LR, R12 */
		/* 8206F650h case   14:*/		regs.LR = regs.R12;
		/* 8206F650h case   14:*/		return 0x8206F654;
		  /* 8206F654h */ case   15:  		/* ld R30, <#[R1 - 24]> */
		/* 8206F654h case   15:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206F654h case   15:*/		return 0x8206F658;
		  /* 8206F658h */ case   16:  		/* ld R31, <#[R1 - 16]> */
		/* 8206F658h case   16:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206F658h case   16:*/		return 0x8206F65C;
		  /* 8206F65Ch */ case   17:  		/* bclr 20, CR0_LT */
		/* 8206F65Ch case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206F65Ch case   17:*/		return 0x8206F660;
	}
	return 0x8206F660;
} // Block from 8206F618h-8206F660h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206F660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F660);
		  /* 8206F660h */ case    0:  		/* mfspr R12, LR */
		/* 8206F660h case    0:*/		regs.R12 = regs.LR;
		/* 8206F660h case    0:*/		return 0x8206F664;
		  /* 8206F664h */ case    1:  		/* bl 138204 */
		/* 8206F664h case    1:*/		regs.LR = 0x8206F668; return 0x82091240;
		/* 8206F664h case    1:*/		return 0x8206F668;
		  /* 8206F668h */ case    2:  		/* stfd FR31, <#[R1 - 96]> */
		/* 8206F668h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 8206F668h case    2:*/		return 0x8206F66C;
		  /* 8206F66Ch */ case    3:  		/* stwu R1, <#[R1 - 192]> */
		/* 8206F66Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 8206F66Ch case    3:*/		return 0x8206F670;
		  /* 8206F670h */ case    4:  		/* lwz R11, <#[R3 + 56]> */
		/* 8206F670h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 8206F670h case    4:*/		return 0x8206F674;
		  /* 8206F674h */ case    5:  		/* mr R31, R3 */
		/* 8206F674h case    5:*/		regs.R31 = regs.R3;
		/* 8206F674h case    5:*/		return 0x8206F678;
		  /* 8206F678h */ case    6:  		/* lwz R30, <#[R3 + 48]> */
		/* 8206F678h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000030) );
		/* 8206F678h case    6:*/		return 0x8206F67C;
		  /* 8206F67Ch */ case    7:  		/* mr R27, R4 */
		/* 8206F67Ch case    7:*/		regs.R27 = regs.R4;
		/* 8206F67Ch case    7:*/		return 0x8206F680;
		  /* 8206F680h */ case    8:  		/* mr R25, R5 */
		/* 8206F680h case    8:*/		regs.R25 = regs.R5;
		/* 8206F680h case    8:*/		return 0x8206F684;
		  /* 8206F684h */ case    9:  		/* fmr FR31, FR1 */
		/* 8206F684h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 8206F684h case    9:*/		return 0x8206F688;
		  /* 8206F688h */ case   10:  		/* mr R29, R6 */
		/* 8206F688h case   10:*/		regs.R29 = regs.R6;
		/* 8206F688h case   10:*/		return 0x8206F68C;
		  /* 8206F68Ch */ case   11:  		/* mr R28, R8 */
		/* 8206F68Ch case   11:*/		regs.R28 = regs.R8;
		/* 8206F68Ch case   11:*/		return 0x8206F690;
		  /* 8206F690h */ case   12:  		/* mr R24, R9 */
		/* 8206F690h case   12:*/		regs.R24 = regs.R9;
		/* 8206F690h case   12:*/		return 0x8206F694;
		  /* 8206F694h */ case   13:  		/* mr R22, R10 */
		/* 8206F694h case   13:*/		regs.R22 = regs.R10;
		/* 8206F694h case   13:*/		return 0x8206F698;
		  /* 8206F698h */ case   14:  		/* addi R23, R3, 48 */
		/* 8206F698h case   14:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R3,0x30);
		/* 8206F698h case   14:*/		return 0x8206F69C;
		  /* 8206F69Ch */ case   15:  		/* cmplw CR6, R30, R11 */
		/* 8206F69Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8206F69Ch case   15:*/		return 0x8206F6A0;
		  /* 8206F6A0h */ case   16:  		/* bc 4, CR6_GT, 12 */
		/* 8206F6A0h case   16:*/		if ( !regs.CR[6].gt ) { return 0x8206F6AC;  }
		/* 8206F6A0h case   16:*/		return 0x8206F6A4;
		  /* 8206F6A4h */ case   17:  		/* bl 19044 */
		/* 8206F6A4h case   17:*/		regs.LR = 0x8206F6A8; return 0x82074108;
		/* 8206F6A4h case   17:*/		return 0x8206F6A8;
		  /* 8206F6A8h */ case   18:  		/* mr R30, R3 */
		/* 8206F6A8h case   18:*/		regs.R30 = regs.R3;
		/* 8206F6A8h case   18:*/		return 0x8206F6AC;
	}
	return 0x8206F6AC;
} // Block from 8206F660h-8206F6ACh (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206F6ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F6AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F6AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F6AC);
		  /* 8206F6ACh */ case    0:  		/* mulli R26, R27, 21 */
		/* 8206F6ACh case    0:*/		cpu::op::mulli<0>(regs,&regs.R26,regs.R27,0x15);
		/* 8206F6ACh case    0:*/		return 0x8206F6B0;
		  /* 8206F6B0h */ case    1:  		/* li R5, 4 */
		/* 8206F6B0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 8206F6B0h case    1:*/		return 0x8206F6B4;
		  /* 8206F6B4h */ case    2:  		/* mr R4, R26 */
		/* 8206F6B4h case    2:*/		regs.R4 = regs.R26;
		/* 8206F6B4h case    2:*/		return 0x8206F6B8;
		  /* 8206F6B8h */ case    3:  		/* mr R3, R31 */
		/* 8206F6B8h case    3:*/		regs.R3 = regs.R31;
		/* 8206F6B8h case    3:*/		return 0x8206F6BC;
		  /* 8206F6BCh */ case    4:  		/* bl 14468 */
		/* 8206F6BCh case    4:*/		regs.LR = 0x8206F6C0; return 0x82072F40;
		/* 8206F6BCh case    4:*/		return 0x8206F6C0;
		  /* 8206F6C0h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 8206F6C0h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8206F6C0h case    5:*/		return 0x8206F6C4;
		  /* 8206F6C4h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 8206F6C4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8206F6D0;  }
		/* 8206F6C4h case    6:*/		return 0x8206F6C8;
		  /* 8206F6C8h */ case    7:  		/* stw R30, <#[R23]> */
		/* 8206F6C8h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R23 + 0x00000000) );
		/* 8206F6C8h case    7:*/		return 0x8206F6CC;
		  /* 8206F6CCh */ case    8:  		/* b 576 */
		/* 8206F6CCh case    8:*/		return 0x8206F90C;
		/* 8206F6CCh case    8:*/		return 0x8206F6D0;
	}
	return 0x8206F6D0;
} // Block from 8206F6ACh-8206F6D0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206F6D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F6D0);
		  /* 8206F6D0h */ case    0:  		/* rlwinm R11, R3, 12, 20, 31 */
		/* 8206F6D0h case    0:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R3);
		/* 8206F6D0h case    0:*/		return 0x8206F6D4;
		  /* 8206F6D4h */ case    1:  		/* lwz R9, <#[R31 + 10688]> */
		/* 8206F6D4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000029C0) );
		/* 8206F6D4h case    1:*/		return 0x8206F6D8;
		  /* 8206F6D8h */ case    2:  		/* rlwinm R10, R3, 0, 3, 31 */
		/* 8206F6D8h case    2:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R3);
		/* 8206F6D8h case    2:*/		return 0x8206F6DC;
		  /* 8206F6DCh */ case    3:  		/* addi R11, R11, 512 */
		/* 8206F6DCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8206F6DCh case    3:*/		return 0x8206F6E0;
		  /* 8206F6E0h */ case    4:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 8206F6E0h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 8206F6E0h case    4:*/		return 0x8206F6E4;
		  /* 8206F6E4h */ case    5:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 8206F6E4h case    5:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 8206F6E4h case    5:*/		return 0x8206F6E8;
		  /* 8206F6E8h */ case    6:  		/* add R8, R11, R10 */
		/* 8206F6E8h case    6:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R10);
		/* 8206F6E8h case    6:*/		return 0x8206F6EC;
		  /* 8206F6ECh */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 8206F6ECh case    7:*/		if ( !regs.CR[0].eq ) { return 0x8206F6FC;  }
		/* 8206F6ECh case    7:*/		return 0x8206F6F0;
		  /* 8206F6F0h */ case    8:  		/* vspltisw VR63, 1 */
		/* 8206F6F0h case    8:*/		cpu::op::vspltisw<0,1>(regs,&regs.VR63);
		/* 8206F6F0h case    8:*/		return 0x8206F6F4;
		  /* 8206F6F4h */ case    9:  		/* vcsxwfp VR63, VR63, 1 */
		/* 8206F6F4h case    9:*/		cpu::op::vcsxwfp<0,1>(regs,&regs.VR63,regs.VR63);
		/* 8206F6F4h case    9:*/		return 0x8206F6F8;
		  /* 8206F6F8h */ case   10:  		/* b 8 */
		/* 8206F6F8h case   10:*/		return 0x8206F700;
		/* 8206F6F8h case   10:*/		return 0x8206F6FC;
	}
	return 0x8206F6FC;
} // Block from 8206F6D0h-8206F6FCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206F6FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F6FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F6FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F6FC);
		  /* 8206F6FCh */ case    0:  		/* vspltisw VR63, 0 */
		/* 8206F6FCh case    0:*/		cpu::op::vspltisw<0,0>(regs,&regs.VR63);
		/* 8206F6FCh case    0:*/		return 0x8206F700;
	}
	return 0x8206F700;
} // Block from 8206F6FCh-8206F700h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206F700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F700);
		  /* 8206F700h */ case    0:  		/* lfs FR0, <#[R29]> */
		/* 8206F700h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R29 + 0x00000000) );
		/* 8206F700h case    0:*/		return 0x8206F704;
		  /* 8206F704h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 8206F704h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8206F704h case    1:*/		return 0x8206F708;
		  /* 8206F708h */ case    2:  		/* lfs FR13, <#[R29 + 4]> */
		/* 8206F708h case    2:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R29 + 0x00000004) );
		/* 8206F708h case    2:*/		return 0x8206F70C;
		  /* 8206F70Ch */ case    3:  		/* lfs FR12, <#[R29 + 8]> */
		/* 8206F70Ch case    3:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R29 + 0x00000008) );
		/* 8206F70Ch case    3:*/		return 0x8206F710;
		  /* 8206F710h */ case    4:  		/* lfs FR11, <#[R29 + 12]> */
		/* 8206F710h case    4:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R29 + 0x0000000C) );
		/* 8206F710h case    4:*/		return 0x8206F714;
		  /* 8206F714h */ case    5:  		/* bc 12, CR6_EQ, 176 */
		/* 8206F714h case    5:*/		if ( regs.CR[6].eq ) { return 0x8206F7C4;  }
		/* 8206F714h case    5:*/		return 0x8206F718;
		  /* 8206F718h */ case    6:  		/* addi R11, R3, 12 */
		/* 8206F718h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xC);
		/* 8206F718h case    6:*/		return 0x8206F71C;
		  /* 8206F71Ch */ case    7:  		/* mtspr CTR, R27 */
		/* 8206F71Ch case    7:*/		regs.CTR = regs.R27;
		/* 8206F71Ch case    7:*/		return 0x8206F720;
		  /* 8206F720h */ case    8:  		/* mr R9, R25 */
		/* 8206F720h case    8:*/		regs.R9 = regs.R25;
		/* 8206F720h case    8:*/		return 0x8206F724;
		  /* 8206F724h */ case    9:  		/* li R7, 16 */
		/* 8206F724h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 8206F724h case    9:*/		return 0x8206F728;
		  /* 8206F728h */ case   10:  		/* lvlx VR62, <#[R9]> */
		/* 8206F728h case   10:*/		cpu::mem::lvlx( regs, &regs.VR62, (uint32)(regs.R9 + 0x00000000) );
		/* 8206F728h case   10:*/		return 0x8206F72C;
		  /* 8206F72Ch */ case   11:  		/* addi R10, R11, -12 */
		/* 8206F72Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFF4);
		/* 8206F72Ch case   11:*/		return 0x8206F730;
		  /* 8206F730h */ case   12:  		/* li R6, 4 */
		/* 8206F730h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8206F730h case   12:*/		return 0x8206F734;
		  /* 8206F734h */ case   13:  		/* li R5, 28 */
		/* 8206F734h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 8206F734h case   13:*/		return 0x8206F738;
		  /* 8206F738h */ case   14:  		/* li R4, 32 */
		/* 8206F738h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 8206F738h case   14:*/		return 0x8206F73C;
		  /* 8206F73Ch */ case   15:  		/* lvrx VR61, <#[R7 + R9]> */
		/* 8206F73Ch case   15:*/		cpu::mem::lvrx( regs, &regs.VR61, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 8206F73Ch case   15:*/		return 0x8206F740;
		  /* 8206F740h */ case   16:  		/* li R7, 56 */
		/* 8206F740h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x38);
		/* 8206F740h case   16:*/		return 0x8206F744;
		  /* 8206F744h */ case   17:  		/* vor VR62, VR62, VR61 */
		/* 8206F744h case   17:*/		cpu::op::vor<0>(regs,&regs.VR62,regs.VR62,regs.VR61);
		/* 8206F744h case   17:*/		return 0x8206F748;
		  /* 8206F748h */ case   18:  		/* li R3, 60 */
		/* 8206F748h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x3C);
		/* 8206F748h case   18:*/		return 0x8206F74C;
		  /* 8206F74Ch */ case   19:  		/* addi R9, R9, 16 */
		/* 8206F74Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x10);
		/* 8206F74Ch case   19:*/		return 0x8206F750;
		  /* 8206F750h */ case   20:  		/* vcsxwfp VR62, VR62, 0 */
		/* 8206F750h case   20:*/		cpu::op::vcsxwfp<0,0>(regs,&regs.VR62,regs.VR62);
		/* 8206F750h case   20:*/		return 0x8206F754;
		  /* 8206F754h */ case   21:  		/* vsubfp VR62, VR62, VR63 */
		/* 8206F754h case   21:*/		cpu::op::vsubfp<0>(regs,&regs.VR62,regs.VR62,regs.VR63);
		/* 8206F754h case   21:*/		return 0x8206F758;
		  /* 8206F758h */ case   22:  		/* vspltw VR61, VR62, 0 */
		/* 8206F758h case   22:*/		cpu::op::vspltw<0,0>(regs,&regs.VR61,regs.VR62);
		/* 8206F758h case   22:*/		return 0x8206F75C;
		  /* 8206F75Ch */ case   23:  		/* vspltw VR60, VR62, 1 */
		/* 8206F75Ch case   23:*/		cpu::op::vspltw<0,1>(regs,&regs.VR60,regs.VR62);
		/* 8206F75Ch case   23:*/		return 0x8206F760;
		  /* 8206F760h */ case   24:  		/* vspltw VR59, VR62, 2 */
		/* 8206F760h case   24:*/		cpu::op::vspltw<0,2>(regs,&regs.VR59,regs.VR62);
		/* 8206F760h case   24:*/		return 0x8206F764;
		  /* 8206F764h */ case   25:  		/* vspltw VR62, VR62, 3 */
		/* 8206F764h case   25:*/		cpu::op::vspltw<0,3>(regs,&regs.VR62,regs.VR62);
		/* 8206F764h case   25:*/		return 0x8206F768;
		  /* 8206F768h */ case   26:  		/* stvewx VR61, <#[R10]> */
		/* 8206F768h case   26:*/		cpu::mem::stvewx( regs, regs.VR61, (uint32)(regs.R10 + 0x00000000) );
		/* 8206F768h case   26:*/		return 0x8206F76C;
		  /* 8206F76Ch */ case   27:  		/* stvewx VR60, <#[R10 + R6]> */
		/* 8206F76Ch case   27:*/		cpu::mem::stvewx( regs, regs.VR60, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 8206F76Ch case   27:*/		return 0x8206F770;
		  /* 8206F770h */ case   28:  		/* stfs FR31, <#[R11 - 4]> */
		/* 8206F770h case   28:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8206F770h case   28:*/		return 0x8206F774;
		  /* 8206F774h */ case   29:  		/* stfs FR0, <#[R11]> */
		/* 8206F774h case   29:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 8206F774h case   29:*/		return 0x8206F778;
		  /* 8206F778h */ case   30:  		/* stfs FR13, <#[R11 + 4]> */
		/* 8206F778h case   30:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R11 + 0x00000004) );
		/* 8206F778h case   30:*/		return 0x8206F77C;
		  /* 8206F77Ch */ case   31:  		/* stfs FR12, <#[R11 + 8]> */
		/* 8206F77Ch case   31:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R11 + 0x00000008) );
		/* 8206F77Ch case   31:*/		return 0x8206F780;
		  /* 8206F780h */ case   32:  		/* stfs FR11, <#[R11 + 12]> */
		/* 8206F780h case   32:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R11 + 0x0000000C) );
		/* 8206F780h case   32:*/		return 0x8206F784;
		  /* 8206F784h */ case   33:  		/* stvewx VR59, <#[R10 + R5]> */
		/* 8206F784h case   33:*/		cpu::mem::stvewx( regs, regs.VR59, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 8206F784h case   33:*/		return 0x8206F788;
		  /* 8206F788h */ case   34:  		/* stvewx VR60, <#[R10 + R4]> */
		/* 8206F788h case   34:*/		cpu::mem::stvewx( regs, regs.VR60, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 8206F788h case   34:*/		return 0x8206F78C;
		  /* 8206F78Ch */ case   35:  		/* stfs FR31, <#[R11 + 24]> */
		/* 8206F78Ch case   35:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R11 + 0x00000018) );
		/* 8206F78Ch case   35:*/		return 0x8206F790;
		  /* 8206F790h */ case   36:  		/* stfs FR0, <#[R11 + 28]> */
		/* 8206F790h case   36:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x0000001C) );
		/* 8206F790h case   36:*/		return 0x8206F794;
		  /* 8206F794h */ case   37:  		/* stfs FR13, <#[R11 + 32]> */
		/* 8206F794h case   37:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R11 + 0x00000020) );
		/* 8206F794h case   37:*/		return 0x8206F798;
		  /* 8206F798h */ case   38:  		/* stfs FR12, <#[R11 + 36]> */
		/* 8206F798h case   38:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R11 + 0x00000024) );
		/* 8206F798h case   38:*/		return 0x8206F79C;
		  /* 8206F79Ch */ case   39:  		/* stfs FR11, <#[R11 + 40]> */
		/* 8206F79Ch case   39:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R11 + 0x00000028) );
		/* 8206F79Ch case   39:*/		return 0x8206F7A0;
		  /* 8206F7A0h */ case   40:  		/* stvewx VR59, <#[R10 + R7]> */
		/* 8206F7A0h case   40:*/		cpu::mem::stvewx( regs, regs.VR59, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 8206F7A0h case   40:*/		return 0x8206F7A4;
		  /* 8206F7A4h */ case   41:  		/* stvewx VR62, <#[R10 + R3]> */
		/* 8206F7A4h case   41:*/		cpu::mem::stvewx( regs, regs.VR62, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8206F7A4h case   41:*/		return 0x8206F7A8;
		  /* 8206F7A8h */ case   42:  		/* stfs FR31, <#[R11 + 52]> */
		/* 8206F7A8h case   42:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R11 + 0x00000034) );
		/* 8206F7A8h case   42:*/		return 0x8206F7AC;
		  /* 8206F7ACh */ case   43:  		/* stfs FR0, <#[R11 + 56]> */
		/* 8206F7ACh case   43:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000038) );
		/* 8206F7ACh case   43:*/		return 0x8206F7B0;
		  /* 8206F7B0h */ case   44:  		/* stfs FR13, <#[R11 + 60]> */
		/* 8206F7B0h case   44:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R11 + 0x0000003C) );
		/* 8206F7B0h case   44:*/		return 0x8206F7B4;
		  /* 8206F7B4h */ case   45:  		/* stfs FR12, <#[R11 + 64]> */
		/* 8206F7B4h case   45:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R11 + 0x00000040) );
		/* 8206F7B4h case   45:*/		return 0x8206F7B8;
		  /* 8206F7B8h */ case   46:  		/* stfs FR11, <#[R11 + 68]> */
		/* 8206F7B8h case   46:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R11 + 0x00000044) );
		/* 8206F7B8h case   46:*/		return 0x8206F7BC;
		  /* 8206F7BCh */ case   47:  		/* addi R11, R11, 84 */
		/* 8206F7BCh case   47:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x54);
		/* 8206F7BCh case   47:*/		return 0x8206F7C0;
		  /* 8206F7C0h */ case   48:  		/* bc 16, CR0_LT, -156 */
		/* 8206F7C0h case   48:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206F724;  }
		/* 8206F7C0h case   48:*/		return 0x8206F7C4;
	}
	return 0x8206F7C4;
} // Block from 8206F700h-8206F7C4h (49 instructions)

//////////////////////////////////////////////////////
// Block at 8206F7C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F7C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F7C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F7C4);
		  /* 8206F7C4h */ case    0:  		/* lis R11, 5 */
		/* 8206F7C4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x5);
		/* 8206F7C4h case    0:*/		return 0x8206F7C8;
	}
	return 0x8206F7C8;
} // Block from 8206F7C4h-8206F7C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206F7C8h
// Function '?SetTextureHeader@D3D@@YAXW4_D3DRESOURCETYPE@@IIIIKW4_D3DFORMAT@@W4MIPPACKINGTYPE@1@KHIPAUD3DBaseTexture@@PAK4@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F7C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F7C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F7C8);
		  /* 8206F7C8h */ case    0:  		/* ori R10, R8, 3 */
		/* 8206F7C8h case    0:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R8,0x3);
		/* 8206F7C8h case    0:*/		return 0x8206F7CC;
		  /* 8206F7CCh */ case    1:  		/* ori R11, R11, 18432 */
		/* 8206F7CCh case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4800);
		/* 8206F7CCh case    1:*/		return 0x8206F7D0;
		  /* 8206F7D0h */ case    2:  		/* lis R9, 4096 */
		/* 8206F7D0h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 8206F7D0h case    2:*/		return 0x8206F7D4;
		  /* 8206F7D4h */ case    3:  		/* stwu R11, <#[R30 + 4]> */
		/* 8206F7D4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F7D4h case    3:*/		return 0x8206F7D8;
		  /* 8206F7D8h */ case    4:  		/* li R11, 0 */
		/* 8206F7D8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206F7D8h case    4:*/		return 0x8206F7DC;
		  /* 8206F7DCh */ case    5:  		/* ori R9, R9, 2 */
		/* 8206F7DCh case    5:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x2);
		/* 8206F7DCh case    5:*/		return 0x8206F7E0;
		  /* 8206F7E0h */ case    6:  		/* li R8, 0 */
		/* 8206F7E0h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8206F7E0h case    6:*/		return 0x8206F7E4;
		  /* 8206F7E4h */ case    7:  		/* rlwimi R9, R26, 2, 6, 29 */
		/* 8206F7E4h case    7:*/		cpu::op::rlwimi<0,2,6,29>(regs,&regs.R9,regs.R26);
		/* 8206F7E4h case    7:*/		return 0x8206F7E8;
		  /* 8206F7E8h */ case    8:  		/* li R7, 0 */
		/* 8206F7E8h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8206F7E8h case    8:*/		return 0x8206F7EC;
		  /* 8206F7ECh */ case    9:  		/* stwu R10, <#[R30 + 4]> */
		/* 8206F7ECh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F7ECh case    9:*/		return 0x8206F7F0;
		  /* 8206F7F0h */ case   10:  		/* li R6, 0 */
		/* 8206F7F0h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206F7F0h case   10:*/		return 0x8206F7F4;
		  /* 8206F7F4h */ case   11:  		/* lis R10, 2 */
		/* 8206F7F4h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x2);
		/* 8206F7F4h case   11:*/		return 0x8206F7F8;
		  /* 8206F7F8h */ case   12:  		/* li R5, 0 */
		/* 8206F7F8h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8206F7F8h case   12:*/		return 0x8206F7FC;
		  /* 8206F7FCh */ case   13:  		/* ori R4, R10, 20480 */
		/* 8206F7FCh case   13:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R10,0x5000);
		/* 8206F7FCh case   13:*/		return 0x8206F800;
		  /* 8206F800h */ case   14:  		/* li R3, 0 */
		/* 8206F800h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8206F800h case   14:*/		return 0x8206F804;
		  /* 8206F804h */ case   15:  		/* stwu R9, <#[R30 + 4]> */
		/* 8206F804h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F804h case   15:*/		return 0x8206F808;
		  /* 8206F808h */ case   16:  		/* li R29, 0 */
		/* 8206F808h case   16:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8206F808h case   16:*/		return 0x8206F80C;
		  /* 8206F80Ch */ case   17:  		/* lis R10, 1 */
		/* 8206F80Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 8206F80Ch case   17:*/		return 0x8206F810;
		  /* 8206F810h */ case   18:  		/* li R9, 8961 */
		/* 8206F810h case   18:*/		cpu::op::li<0>(regs,&regs.R9,0x2301);
		/* 8206F810h case   18:*/		return 0x8206F814;
		  /* 8206F814h */ case   19:  		/* ori R26, R10, 8192 */
		/* 8206F814h case   19:*/		cpu::op::ori<0>(regs,&regs.R26,regs.R10,0x2000);
		/* 8206F814h case   19:*/		return 0x8206F818;
		  /* 8206F818h */ case   20:  		/* rlwinm. R10, R28, 16, 30, 31 */
		/* 8206F818h case   20:*/		cpu::op::rlwinm<1,16,30,31>(regs,&regs.R10,regs.R28);
		/* 8206F818h case   20:*/		return 0x8206F81C;
		  /* 8206F81Ch */ case   21:  		/* stwu R11, <#[R30 + 4]> */
		/* 8206F81Ch case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F81Ch case   21:*/		return 0x8206F820;
		  /* 8206F820h */ case   22:  		/* stwu R8, <#[R30 + 4]> */
		/* 8206F820h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F820h case   22:*/		return 0x8206F824;
		  /* 8206F824h */ case   23:  		/* stwu R7, <#[R30 + 4]> */
		/* 8206F824h case   23:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F824h case   23:*/		return 0x8206F828;
		  /* 8206F828h */ case   24:  		/* stwu R6, <#[R30 + 4]> */
		/* 8206F828h case   24:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F828h case   24:*/		return 0x8206F82C;
		  /* 8206F82Ch */ case   25:  		/* stwu R4, <#[R30 + 4]> */
		/* 8206F82Ch case   25:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F82Ch case   25:*/		return 0x8206F830;
		  /* 8206F830h */ case   26:  		/* stwu R5, <#[R30 + 4]> */
		/* 8206F830h case   26:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F830h case   26:*/		return 0x8206F834;
		  /* 8206F834h */ case   27:  		/* stwu R3, <#[R30 + 4]> */
		/* 8206F834h case   27:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F834h case   27:*/		return 0x8206F838;
		  /* 8206F838h */ case   28:  		/* stwu R29, <#[R30 + 4]> */
		/* 8206F838h case   28:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F838h case   28:*/		return 0x8206F83C;
		  /* 8206F83Ch */ case   29:  		/* stwu R26, <#[R30 + 4]> */
		/* 8206F83Ch case   29:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F83Ch case   29:*/		return 0x8206F840;
		  /* 8206F840h */ case   30:  		/* stwu R28, <#[R30 + 4]> */
		/* 8206F840h case   30:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F840h case   30:*/		return 0x8206F844;
		  /* 8206F844h */ case   31:  		/* stwu R24, <#[R30 + 4]> */
		/* 8206F844h case   31:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206F844h case   31:*/		return 0x8206F848;
		  /* 8206F848h */ case   32:  		/* mr R11, R30 */
		/* 8206F848h case   32:*/		regs.R11 = regs.R30;
		/* 8206F848h case   32:*/		return 0x8206F84C;
		  /* 8206F84Ch */ case   33:  		/* stwu R9, <#[R11 + 4]> */
		/* 8206F84Ch case   33:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206F84Ch case   33:*/		return 0x8206F850;
		  /* 8206F850h */ case   34:  		/* bc 4, CR0_EQ, 12 */
		/* 8206F850h case   34:*/		if ( !regs.CR[0].eq ) { return 0x8206F85C;  }
		/* 8206F850h case   34:*/		return 0x8206F854;
		  /* 8206F854h */ case   35:  		/* li R10, 0 */
		/* 8206F854h case   35:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8206F854h case   35:*/		return 0x8206F858;
		  /* 8206F858h */ case   36:  		/* b 28 */
		/* 8206F858h case   36:*/		return 0x8206F874;
		/* 8206F858h case   36:*/		return 0x8206F85C;
	}
	return 0x8206F85C;
} // Block from 8206F7C8h-8206F85Ch (37 instructions)

//////////////////////////////////////////////////////
// Block at 8206F85Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F85C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F85C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F85C);
		  /* 8206F85Ch */ case    0:  		/* cmplwi CR6, R10, 1 */
		/* 8206F85Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8206F85Ch case    0:*/		return 0x8206F860;
		  /* 8206F860h */ case    1:  		/* lis R10, 0 */
		/* 8206F860h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8206F860h case    1:*/		return 0x8206F864;
		  /* 8206F864h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 8206F864h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8206F870;  }
		/* 8206F864h case    2:*/		return 0x8206F868;
		  /* 8206F868h */ case    3:  		/* ori R10, R10, 32769 */
		/* 8206F868h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8001);
		/* 8206F868h case    3:*/		return 0x8206F86C;
		  /* 8206F86Ch */ case    4:  		/* b 8 */
		/* 8206F86Ch case    4:*/		return 0x8206F874;
		/* 8206F86Ch case    4:*/		return 0x8206F870;
	}
	return 0x8206F870;
} // Block from 8206F85Ch-8206F870h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206F870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F870);
		  /* 8206F870h */ case    0:  		/* ori R10, R10, 49155 */
		/* 8206F870h case    0:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xC003);
		/* 8206F870h case    0:*/		return 0x8206F874;
	}
	return 0x8206F874;
} // Block from 8206F870h-8206F874h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206F874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F874);
		  /* 8206F874h */ case    0:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206F874h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206F874h case    0:*/		return 0x8206F878;
		  /* 8206F878h */ case    1:  		/* li R10, 8704 */
		/* 8206F878h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x2200);
		/* 8206F878h case    1:*/		return 0x8206F87C;
		  /* 8206F87Ch */ case    2:  		/* li R9, 8712 */
		/* 8206F87Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x2208);
		/* 8206F87Ch case    2:*/		return 0x8206F880;
		  /* 8206F880h */ case    3:  		/* lwz R8, <#[R1 + 276]> */
		/* 8206F880h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000114) );
		/* 8206F880h case    3:*/		return 0x8206F884;
		  /* 8206F884h */ case    4:  		/* lis R7, -16384 */
		/* 8206F884h case    4:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFFC000);
		/* 8206F884h case    4:*/		return 0x8206F888;
		  /* 8206F888h */ case    5:  		/* lis R6, 3 */
		/* 8206F888h case    5:*/		cpu::op::lis<0>(regs,&regs.R6,0x3);
		/* 8206F888h case    5:*/		return 0x8206F88C;
		  /* 8206F88Ch */ case    6:  		/* ori R7, R7, 13825 */
		/* 8206F88Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x3601);
		/* 8206F88Ch case    6:*/		return 0x8206F890;
		  /* 8206F890h */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206F890h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206F890h case    7:*/		return 0x8206F894;
		  /* 8206F894h */ case    8:  		/* li R5, 17 */
		/* 8206F894h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x11);
		/* 8206F894h case    8:*/		return 0x8206F898;
		  /* 8206F898h */ case    9:  		/* mullw R10, R27, R6 */
		/* 8206F898h case    9:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R27,regs.R6);
		/* 8206F898h case    9:*/		return 0x8206F89C;
		  /* 8206F89Ch */ case   10:  		/* stwu R22, <#[R11 + 4]> */
		/* 8206F89Ch case   10:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206F89Ch case   10:*/		return 0x8206F8A0;
		  /* 8206F8A0h */ case   11:  		/* stwu R9, <#[R11 + 4]> */
		/* 8206F8A0h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206F8A0h case   11:*/		return 0x8206F8A4;
		  /* 8206F8A4h */ case   12:  		/* rlwimi R10, R5, 3, 16, 31 */
		/* 8206F8A4h case   12:*/		cpu::op::rlwimi<0,3,16,31>(regs,&regs.R10,regs.R5);
		/* 8206F8A4h case   12:*/		return 0x8206F8A8;
		  /* 8206F8A8h */ case   13:  		/* li R12, 1 */
		/* 8206F8A8h case   13:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206F8A8h case   13:*/		return 0x8206F8AC;
		  /* 8206F8ACh */ case   14:  		/* rldicr R12, R12, 57, 63 */
		/* 8206F8ACh case   14:*/		cpu::op::rldicr<0,57,63>(regs,&regs.R12,regs.R12);
		/* 8206F8ACh case   14:*/		return 0x8206F8B0;
		  /* 8206F8B0h */ case   15:  		/* stwu R8, <#[R11 + 4]> */
		/* 8206F8B0h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206F8B0h case   15:*/		return 0x8206F8B4;
		  /* 8206F8B4h */ case   16:  		/* stwu R7, <#[R11 + 4]> */
		/* 8206F8B4h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206F8B4h case   16:*/		return 0x8206F8B8;
		  /* 8206F8B8h */ case   17:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206F8B8h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206F8B8h case   17:*/		return 0x8206F8BC;
		  /* 8206F8BCh */ case   18:  		/* stw R11, <#[R23]> */
		/* 8206F8BCh case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8206F8BCh case   18:*/		return 0x8206F8C0;
		  /* 8206F8C0h */ case   19:  		/* ld R11, <#[R31 + 16]> */
		/* 8206F8C0h case   19:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206F8C0h case   19:*/		return 0x8206F8C4;
		  /* 8206F8C4h */ case   20:  		/* or R11, R11, R12 */
		/* 8206F8C4h case   20:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206F8C4h case   20:*/		return 0x8206F8C8;
		  /* 8206F8C8h */ case   21:  		/* li R12, 1 */
		/* 8206F8C8h case   21:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206F8C8h case   21:*/		return 0x8206F8CC;
		  /* 8206F8CCh */ case   22:  		/* std R11, <#[R31 + 16]> */
		/* 8206F8CCh case   22:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206F8CCh case   22:*/		return 0x8206F8D0;
		  /* 8206F8D0h */ case   23:  		/* rldicr R12, R12, 56, 63 */
		/* 8206F8D0h case   23:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 8206F8D0h case   23:*/		return 0x8206F8D4;
		  /* 8206F8D4h */ case   24:  		/* or R11, R11, R12 */
		/* 8206F8D4h case   24:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206F8D4h case   24:*/		return 0x8206F8D8;
		  /* 8206F8D8h */ case   25:  		/* li R12, 1 */
		/* 8206F8D8h case   25:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206F8D8h case   25:*/		return 0x8206F8DC;
		  /* 8206F8DCh */ case   26:  		/* std R11, <#[R31 + 16]> */
		/* 8206F8DCh case   26:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206F8DCh case   26:*/		return 0x8206F8E0;
		  /* 8206F8E0h */ case   27:  		/* ori R11, R11, 2048 */
		/* 8206F8E0h case   27:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 8206F8E0h case   27:*/		return 0x8206F8E4;
		  /* 8206F8E4h */ case   28:  		/* rldicr R12, R12, 36, 63 */
		/* 8206F8E4h case   28:*/		cpu::op::rldicr<0,36,63>(regs,&regs.R12,regs.R12);
		/* 8206F8E4h case   28:*/		return 0x8206F8E8;
		  /* 8206F8E8h */ case   29:  		/* std R11, <#[R31 + 16]> */
		/* 8206F8E8h case   29:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206F8E8h case   29:*/		return 0x8206F8EC;
		  /* 8206F8ECh */ case   30:  		/* ori R11, R11, 8 */
		/* 8206F8ECh case   30:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8206F8ECh case   30:*/		return 0x8206F8F0;
		  /* 8206F8F0h */ case   31:  		/* std R11, <#[R31 + 16]> */
		/* 8206F8F0h case   31:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206F8F0h case   31:*/		return 0x8206F8F4;
		  /* 8206F8F4h */ case   32:  		/* ld R11, <#[R31 + 24]> */
		/* 8206F8F4h case   32:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8206F8F4h case   32:*/		return 0x8206F8F8;
		  /* 8206F8F8h */ case   33:  		/* oris R11, R11, 32768 */
		/* 8206F8F8h case   33:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8206F8F8h case   33:*/		return 0x8206F8FC;
		  /* 8206F8FCh */ case   34:  		/* std R11, <#[R31 + 24]> */
		/* 8206F8FCh case   34:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8206F8FCh case   34:*/		return 0x8206F900;
		  /* 8206F900h */ case   35:  		/* ld R11, <#[R31 + 32]> */
		/* 8206F900h case   35:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8206F900h case   35:*/		return 0x8206F904;
		  /* 8206F904h */ case   36:  		/* or R11, R11, R12 */
		/* 8206F904h case   36:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206F904h case   36:*/		return 0x8206F908;
		  /* 8206F908h */ case   37:  		/* std R11, <#[R31 + 32]> */
		/* 8206F908h case   37:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8206F908h case   37:*/		return 0x8206F90C;
	}
	return 0x8206F90C;
} // Block from 8206F874h-8206F90Ch (38 instructions)

//////////////////////////////////////////////////////
// Block at 8206F90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F90C);
		  /* 8206F90Ch */ case    0:  		/* addi R1, R1, 192 */
		/* 8206F90Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 8206F90Ch case    0:*/		return 0x8206F910;
		  /* 8206F910h */ case    1:  		/* lfd FR31, <#[R1 - 96]> */
		/* 8206F910h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA0) );
		/* 8206F910h case    1:*/		return 0x8206F914;
		  /* 8206F914h */ case    2:  		/* b 137596 */
		/* 8206F914h case    2:*/		return 0x82091290;
		/* 8206F914h case    2:*/		return 0x8206F918;
	}
	return 0x8206F918;
} // Block from 8206F90Ch-8206F918h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206F918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F918);
		  /* 8206F918h */ case    0:  		/* mfspr R12, LR */
		/* 8206F918h case    0:*/		regs.R12 = regs.LR;
		/* 8206F918h case    0:*/		return 0x8206F91C;
		  /* 8206F91Ch */ case    1:  		/* bl 137504 */
		/* 8206F91Ch case    1:*/		regs.LR = 0x8206F920; return 0x8209123C;
		/* 8206F91Ch case    1:*/		return 0x8206F920;
		  /* 8206F920h */ case    2:  		/* stfd FR31, <#[R1 - 104]> */
		/* 8206F920h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF98) );
		/* 8206F920h case    2:*/		return 0x8206F924;
		  /* 8206F924h */ case    3:  		/* stwu R1, <#[R1 - 288]> */
		/* 8206F924h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 8206F924h case    3:*/		return 0x8206F928;
		  /* 8206F928h */ case    4:  		/* mr R22, R3 */
		/* 8206F928h case    4:*/		regs.R22 = regs.R3;
		/* 8206F928h case    4:*/		return 0x8206F92C;
		  /* 8206F92Ch */ case    5:  		/* fmr FR31, FR1 */
		/* 8206F92Ch case    5:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 8206F92Ch case    5:*/		return 0x8206F930;
		  /* 8206F930h */ case    6:  		/* mr R3, R4 */
		/* 8206F930h case    6:*/		regs.R3 = regs.R4;
		/* 8206F930h case    6:*/		return 0x8206F934;
		  /* 8206F934h */ case    7:  		/* mr R28, R5 */
		/* 8206F934h case    7:*/		regs.R28 = regs.R5;
		/* 8206F934h case    7:*/		return 0x8206F938;
		  /* 8206F938h */ case    8:  		/* mr R29, R6 */
		/* 8206F938h case    8:*/		regs.R29 = regs.R6;
		/* 8206F938h case    8:*/		return 0x8206F93C;
		  /* 8206F93Ch */ case    9:  		/* mr R21, R8 */
		/* 8206F93Ch case    9:*/		regs.R21 = regs.R8;
		/* 8206F93Ch case    9:*/		return 0x8206F940;
		  /* 8206F940h */ case   10:  		/* mr R23, R10 */
		/* 8206F940h case   10:*/		regs.R23 = regs.R10;
		/* 8206F940h case   10:*/		return 0x8206F944;
		  /* 8206F944h */ case   11:  		/* rlwinm. R11, R10, 16, 30, 31 */
		/* 8206F944h case   11:*/		cpu::op::rlwinm<1,16,30,31>(regs,&regs.R11,regs.R10);
		/* 8206F944h case   11:*/		return 0x8206F948;
		  /* 8206F948h */ case   12:  		/* li R27, 1 */
		/* 8206F948h case   12:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8206F948h case   12:*/		return 0x8206F94C;
		  /* 8206F94Ch */ case   13:  		/* bc 4, CR0_EQ, 12 */
		/* 8206F94Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x8206F958;  }
		/* 8206F94Ch case   13:*/		return 0x8206F950;
		  /* 8206F950h */ case   14:  		/* li R26, 1 */
		/* 8206F950h case   14:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8206F950h case   14:*/		return 0x8206F954;
		  /* 8206F954h */ case   15:  		/* b 20 */
		/* 8206F954h case   15:*/		return 0x8206F968;
		/* 8206F954h case   15:*/		return 0x8206F958;
	}
	return 0x8206F958;
} // Block from 8206F918h-8206F958h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206F958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F958);
		  /* 8206F958h */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 8206F958h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8206F958h case    0:*/		return 0x8206F95C;
		  /* 8206F95Ch */ case    1:  		/* li R26, 0 */
		/* 8206F95Ch case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8206F95Ch case    1:*/		return 0x8206F960;
		  /* 8206F960h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 8206F960h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206F968;  }
		/* 8206F960h case    2:*/		return 0x8206F964;
		  /* 8206F964h */ case    3:  		/* li R27, 0 */
		/* 8206F964h case    3:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8206F964h case    3:*/		return 0x8206F968;
	}
	return 0x8206F968;
} // Block from 8206F958h-8206F968h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206F968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206F968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206F968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206F968);
		  /* 8206F968h */ case    0:  		/* li R11, 40 */
		/* 8206F968h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x28);
		/* 8206F968h case    0:*/		return 0x8206F96C;
		  /* 8206F96Ch */ case    1:  		/* li R10, 8 */
		/* 8206F96Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206F96Ch case    1:*/		return 0x8206F970;
		  /* 8206F970h */ case    2:  		/* slw R11, R11, R27 */
		/* 8206F970h case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8206F970h case    2:*/		return 0x8206F974;
		  /* 8206F974h */ case    3:  		/* slw R10, R10, R26 */
		/* 8206F974h case    3:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R26);
		/* 8206F974h case    3:*/		return 0x8206F978;
		  /* 8206F978h */ case    4:  		/* add R9, R11, R3 */
		/* 8206F978h case    4:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R3);
		/* 8206F978h case    4:*/		return 0x8206F97C;
		  /* 8206F97Ch */ case    5:  		/* add R8, R10, R28 */
		/* 8206F97Ch case    5:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R28);
		/* 8206F97Ch case    5:*/		return 0x8206F980;
		  /* 8206F980h */ case    6:  		/* addi R4, R9, -1 */
		/* 8206F980h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0xFFFFFFFF);
		/* 8206F980h case    6:*/		return 0x8206F984;
		  /* 8206F984h */ case    7:  		/* addi R30, R8, -1 */
		/* 8206F984h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R8,0xFFFFFFFF);
		/* 8206F984h case    7:*/		return 0x8206F988;
		  /* 8206F988h */ case    8:  		/* rlwinm R6, R4, 1, 0, 31 */
		/* 8206F988h case    8:*/		cpu::op::rlwinm<0,1,0,31>(regs,&regs.R6,regs.R4);
		/* 8206F988h case    8:*/		return 0x8206F98C;
		  /* 8206F98Ch */ case    9:  		/* rlwinm R8, R29, 1, 0, 31 */
		/* 8206F98Ch case    9:*/		cpu::op::rlwinm<0,1,0,31>(regs,&regs.R8,regs.R29);
		/* 8206F98Ch case    9:*/		return 0x8206F990;
		  /* 8206F990h */ case   10:  		/* divw R4, R4, R11 */
		/* 8206F990h case   10:*/		cpu::op::divw<0>(regs,&regs.R4,regs.R4,regs.R11);
		/* 8206F990h case   10:*/		return 0x8206F994;
		  /* 8206F994h */ case   11:  		/* rlwinm R5, R30, 1, 0, 31 */
		/* 8206F994h case   11:*/		cpu::op::rlwinm<0,1,0,31>(regs,&regs.R5,regs.R30);
		/* 8206F994h case   11:*/		return 0x8206F998;
		  /* 8206F998h */ case   12:  		/* rlwinm R9, R7, 1, 0, 31 */
		/* 8206F998h case   12:*/		cpu::op::rlwinm<0,1,0,31>(regs,&regs.R9,regs.R7);
		/* 8206F998h case   12:*/		return 0x8206F99C;
		  /* 8206F99Ch */ case   13:  		/* divw R25, R29, R11 */
		/* 8206F99Ch case   13:*/		cpu::op::divw<0>(regs,&regs.R25,regs.R29,regs.R11);
		/* 8206F99Ch case   13:*/		return 0x8206F9A0;
		  /* 8206F9A0h */ case   14:  		/* addi R6, R6, -1 */
		/* 8206F9A0h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 8206F9A0h case   14:*/		return 0x8206F9A4;
		  /* 8206F9A4h */ case   15:  		/* addi R8, R8, -1 */
		/* 8206F9A4h case   15:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 8206F9A4h case   15:*/		return 0x8206F9A8;
		  /* 8206F9A8h */ case   16:  		/* mullw R31, R4, R11 */
		/* 8206F9A8h case   16:*/		cpu::op::mullw<0>(regs,&regs.R31,regs.R4,regs.R11);
		/* 8206F9A8h case   16:*/		return 0x8206F9AC;
		  /* 8206F9ACh */ case   17:  		/* addi R5, R5, -1 */
		/* 8206F9ACh case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 8206F9ACh case   17:*/		return 0x8206F9B0;
		  /* 8206F9B0h */ case   18:  		/* addi R9, R9, -1 */
		/* 8206F9B0h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8206F9B0h case   18:*/		return 0x8206F9B4;
		  /* 8206F9B4h */ case   19:  		/* divw R4, R30, R10 */
		/* 8206F9B4h case   19:*/		cpu::op::divw<0>(regs,&regs.R4,regs.R30,regs.R10);
		/* 8206F9B4h case   19:*/		return 0x8206F9B8;
		  /* 8206F9B8h */ case   20:  		/* mullw R30, R25, R11 */
		/* 8206F9B8h case   20:*/		cpu::op::mullw<0>(regs,&regs.R30,regs.R25,regs.R11);
		/* 8206F9B8h case   20:*/		return 0x8206F9BC;
		  /* 8206F9BCh */ case   21:  		/* andc R6, R11, R6 */
		/* 8206F9BCh case   21:*/		cpu::op::andc<0>(regs,&regs.R6,regs.R11,regs.R6);
		/* 8206F9BCh case   21:*/		return 0x8206F9C0;
		  /* 8206F9C0h */ case   22:  		/* andc R8, R11, R8 */
		/* 8206F9C0h case   22:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 8206F9C0h case   22:*/		return 0x8206F9C4;
		  /* 8206F9C4h */ case   23:  		/* twi 6, R11, 0 */
		/* 8206F9C4h case   23:*/		cpu::op::tw<6>(regs, 0x8206F9C4, regs.R11, 0x00000000);
		/* 8206F9C4h case   23:*/		return 0x8206F9C8;
		  /* 8206F9C8h */ case   24:  		/* twi 6, R11, 0 */
		/* 8206F9C8h case   24:*/		cpu::op::tw<6>(regs, 0x8206F9C8, regs.R11, 0x00000000);
		/* 8206F9C8h case   24:*/		return 0x8206F9CC;
		  /* 8206F9CCh */ case   25:  		/* andc R5, R10, R5 */
		/* 8206F9CCh case   25:*/		cpu::op::andc<0>(regs,&regs.R5,regs.R10,regs.R5);
		/* 8206F9CCh case   25:*/		return 0x8206F9D0;
		  /* 8206F9D0h */ case   26:  		/* divw R11, R7, R10 */
		/* 8206F9D0h case   26:*/		cpu::op::divw<0>(regs,&regs.R11,regs.R7,regs.R10);
		/* 8206F9D0h case   26:*/		return 0x8206F9D4;
		  /* 8206F9D4h */ case   27:  		/* andc R9, R10, R9 */
		/* 8206F9D4h case   27:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 8206F9D4h case   27:*/		return 0x8206F9D8;
		  /* 8206F9D8h */ case   28:  		/* twi 6, R10, 0 */
		/* 8206F9D8h case   28:*/		cpu::op::tw<6>(regs, 0x8206F9D8, regs.R10, 0x00000000);
		/* 8206F9D8h case   28:*/		return 0x8206F9DC;
		  /* 8206F9DCh */ case   29:  		/* twi 6, R10, 0 */
		/* 8206F9DCh case   29:*/		cpu::op::tw<6>(regs, 0x8206F9DC, regs.R10, 0x00000000);
		/* 8206F9DCh case   29:*/		return 0x8206F9E0;
		  /* 8206F9E0h */ case   30:  		/* twi 5, R6, -1 */
		/* 8206F9E0h case   30:*/		cpu::op::tw<5>(regs, 0x8206F9E0, regs.R6, 0xFFFFFFFF);
		/* 8206F9E0h case   30:*/		return 0x8206F9E4;
		  /* 8206F9E4h */ case   31:  		/* twi 5, R5, -1 */
		/* 8206F9E4h case   31:*/		cpu::op::tw<5>(regs, 0x8206F9E4, regs.R5, 0xFFFFFFFF);
		/* 8206F9E4h case   31:*/		return 0x8206F9E8;
		  /* 8206F9E8h */ case   32:  		/* mullw R25, R4, R10 */
		/* 8206F9E8h case   32:*/		cpu::op::mullw<0>(regs,&regs.R25,regs.R4,regs.R10);
		/* 8206F9E8h case   32:*/		return 0x8206F9EC;
		  /* 8206F9ECh */ case   33:  		/* twi 5, R8, -1 */
		/* 8206F9ECh case   33:*/		cpu::op::tw<5>(regs, 0x8206F9EC, regs.R8, 0xFFFFFFFF);
		/* 8206F9ECh case   33:*/		return 0x8206F9F0;
		  /* 8206F9F0h */ case   34:  		/* twi 5, R9, -1 */
		/* 8206F9F0h case   34:*/		cpu::op::tw<5>(regs, 0x8206F9F0, regs.R9, 0xFFFFFFFF);
		/* 8206F9F0h case   34:*/		return 0x8206F9F4;
		  /* 8206F9F4h */ case   35:  		/* mullw R24, R11, R10 */
		/* 8206F9F4h case   35:*/		cpu::op::mullw<0>(regs,&regs.R24,regs.R11,regs.R10);
		/* 8206F9F4h case   35:*/		return 0x8206F9F8;
		  /* 8206F9F8h */ case   36:  		/* cmpw CR6, R31, R30 */
		/* 8206F9F8h case   36:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R30);
		/* 8206F9F8h case   36:*/		return 0x8206F9FC;
		  /* 8206F9FCh */ case   37:  		/* bc 4, CR6_LT, 316 */
		/* 8206F9FCh case   37:*/		if ( !regs.CR[6].lt ) { return 0x8206FB38;  }
		/* 8206F9FCh case   37:*/		return 0x8206FA00;
		  /* 8206FA00h */ case   38:  		/* cmpw CR6, R25, R24 */
		/* 8206FA00h case   38:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R24);
		/* 8206FA00h case   38:*/		return 0x8206FA04;
		  /* 8206FA04h */ case   39:  		/* bc 4, CR6_LT, 308 */
		/* 8206FA04h case   39:*/		if ( !regs.CR[6].lt ) { return 0x8206FB38;  }
		/* 8206FA04h case   39:*/		return 0x8206FA08;
		  /* 8206FA08h */ case   40:  		/* lis R11, -32217 */
		/* 8206FA08h case   40:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 8206FA08h case   40:*/		return 0x8206FA0C;
		  /* 8206FA0Ch */ case   41:  		/* lwz R11, <#[R11 + 1668]> */
		/* 8206FA0Ch case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000684) );
		/* 8206FA0Ch case   41:*/		return 0x8206FA10;
		  /* 8206FA10h */ case   42:  		/* cmpwi CR6, R11, 0 */
		/* 8206FA10h case   42:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8206FA10h case   42:*/		return 0x8206FA14;
		  /* 8206FA14h */ case   43:  		/* bc 12, CR6_EQ, 292 */
		/* 8206FA14h case   43:*/		if ( regs.CR[6].eq ) { return 0x8206FB38;  }
		/* 8206FA14h case   43:*/		return 0x8206FA18;
		  /* 8206FA18h */ case   44:  		/* addi R11, R1, 112 */
		/* 8206FA18h case   44:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 8206FA18h case   44:*/		return 0x8206FA1C;
		  /* 8206FA1Ch */ case   45:  		/* cmpw CR6, R31, R3 */
		/* 8206FA1Ch case   45:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R3);
		/* 8206FA1Ch case   45:*/		return 0x8206FA20;
		  /* 8206FA20h */ case   46:  		/* bc 4, CR6_GT, 24 */
		/* 8206FA20h case   46:*/		if ( !regs.CR[6].gt ) { return 0x8206FA38;  }
		/* 8206FA20h case   46:*/		return 0x8206FA24;
		  /* 8206FA24h */ case   47:  		/* stw R3, <#[R1 + 112]> */
		/* 8206FA24h case   47:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 8206FA24h case   47:*/		return 0x8206FA28;
		  /* 8206FA28h */ case   48:  		/* addi R11, R1, 128 */
		/* 8206FA28h case   48:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8206FA28h case   48:*/		return 0x8206FA2C;
		  /* 8206FA2Ch */ case   49:  		/* stw R28, <#[R1 + 116]> */
		/* 8206FA2Ch case   49:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000074) );
		/* 8206FA2Ch case   49:*/		return 0x8206FA30;
		  /* 8206FA30h */ case   50:  		/* stw R31, <#[R1 + 120]> */
		/* 8206FA30h case   50:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000078) );
		/* 8206FA30h case   50:*/		return 0x8206FA34;
		  /* 8206FA34h */ case   51:  		/* stw R7, <#[R1 + 124]> */
		/* 8206FA34h case   51:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x0000007C) );
		/* 8206FA34h case   51:*/		return 0x8206FA38;
	}
	return 0x8206FA38;
} // Block from 8206F968h-8206FA38h (52 instructions)

//////////////////////////////////////////////////////
// Block at 8206FA38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FA38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FA38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FA38);
		  /* 8206FA38h */ case    0:  		/* cmpw CR6, R30, R29 */
		/* 8206FA38h case    0:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R29);
		/* 8206FA38h case    0:*/		return 0x8206FA3C;
		  /* 8206FA3Ch */ case    1:  		/* bc 4, CR6_LT, 24 */
		/* 8206FA3Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x8206FA54;  }
		/* 8206FA3Ch case    1:*/		return 0x8206FA40;
		  /* 8206FA40h */ case    2:  		/* stw R30, <#[R11]> */
		/* 8206FA40h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 8206FA40h case    2:*/		return 0x8206FA44;
		  /* 8206FA44h */ case    3:  		/* stw R28, <#[R11 + 4]> */
		/* 8206FA44h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 8206FA44h case    3:*/		return 0x8206FA48;
		  /* 8206FA48h */ case    4:  		/* stw R29, <#[R11 + 8]> */
		/* 8206FA48h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000008) );
		/* 8206FA48h case    4:*/		return 0x8206FA4C;
		  /* 8206FA4Ch */ case    5:  		/* stw R7, <#[R11 + 12]> */
		/* 8206FA4Ch case    5:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 8206FA4Ch case    5:*/		return 0x8206FA50;
		  /* 8206FA50h */ case    6:  		/* addi R11, R11, 16 */
		/* 8206FA50h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206FA50h case    6:*/		return 0x8206FA54;
	}
	return 0x8206FA54;
} // Block from 8206FA38h-8206FA54h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206FA54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FA54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FA54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FA54);
		  /* 8206FA54h */ case    0:  		/* cmpw CR6, R25, R28 */
		/* 8206FA54h case    0:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R28);
		/* 8206FA54h case    0:*/		return 0x8206FA58;
		  /* 8206FA58h */ case    1:  		/* bc 4, CR6_GT, 24 */
		/* 8206FA58h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8206FA70;  }
		/* 8206FA58h case    1:*/		return 0x8206FA5C;
		  /* 8206FA5Ch */ case    2:  		/* stw R31, <#[R11]> */
		/* 8206FA5Ch case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 8206FA5Ch case    2:*/		return 0x8206FA60;
		  /* 8206FA60h */ case    3:  		/* stw R28, <#[R11 + 4]> */
		/* 8206FA60h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 8206FA60h case    3:*/		return 0x8206FA64;
		  /* 8206FA64h */ case    4:  		/* stw R30, <#[R11 + 8]> */
		/* 8206FA64h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000008) );
		/* 8206FA64h case    4:*/		return 0x8206FA68;
		  /* 8206FA68h */ case    5:  		/* stw R25, <#[R11 + 12]> */
		/* 8206FA68h case    5:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x0000000C) );
		/* 8206FA68h case    5:*/		return 0x8206FA6C;
		  /* 8206FA6Ch */ case    6:  		/* addi R11, R11, 16 */
		/* 8206FA6Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206FA6Ch case    6:*/		return 0x8206FA70;
	}
	return 0x8206FA70;
} // Block from 8206FA54h-8206FA70h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206FA70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FA70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FA70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FA70);
		  /* 8206FA70h */ case    0:  		/* cmpw CR6, R24, R7 */
		/* 8206FA70h case    0:*/		cpu::op::cmpw<6>(regs,regs.R24,regs.R7);
		/* 8206FA70h case    0:*/		return 0x8206FA74;
		  /* 8206FA74h */ case    1:  		/* bc 4, CR6_LT, 24 */
		/* 8206FA74h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8206FA8C;  }
		/* 8206FA74h case    1:*/		return 0x8206FA78;
		  /* 8206FA78h */ case    2:  		/* stw R31, <#[R11]> */
		/* 8206FA78h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 8206FA78h case    2:*/		return 0x8206FA7C;
		  /* 8206FA7Ch */ case    3:  		/* stw R24, <#[R11 + 4]> */
		/* 8206FA7Ch case    3:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000004) );
		/* 8206FA7Ch case    3:*/		return 0x8206FA80;
		  /* 8206FA80h */ case    4:  		/* stw R30, <#[R11 + 8]> */
		/* 8206FA80h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000008) );
		/* 8206FA80h case    4:*/		return 0x8206FA84;
		  /* 8206FA84h */ case    5:  		/* stw R7, <#[R11 + 12]> */
		/* 8206FA84h case    5:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 8206FA84h case    5:*/		return 0x8206FA88;
		  /* 8206FA88h */ case    6:  		/* addi R11, R11, 16 */
		/* 8206FA88h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206FA88h case    6:*/		return 0x8206FA8C;
	}
	return 0x8206FA8C;
} // Block from 8206FA70h-8206FA8Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206FA8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FA8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FA8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FA8C);
		  /* 8206FA8Ch */ case    0:  		/* addi R10, R1, 112 */
		/* 8206FA8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8206FA8Ch case    0:*/		return 0x8206FA90;
		  /* 8206FA90h */ case    1:  		/* lwz R29, <#[R1 + 372]> */
		/* 8206FA90h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000174) );
		/* 8206FA90h case    1:*/		return 0x8206FA94;
		  /* 8206FA94h */ case    2:  		/* subf R11, R10, R11 */
		/* 8206FA94h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206FA94h case    2:*/		return 0x8206FA98;
		  /* 8206FA98h */ case    3:  		/* srawi. R4, R11, 4 */
		/* 8206FA98h case    3:*/		cpu::op::srawi<1,4>(regs,&regs.R4,regs.R11);
		/* 8206FA98h case    3:*/		return 0x8206FA9C;
		  /* 8206FA9Ch */ case    4:  		/* bc 12, CR0_EQ, 44 */
		/* 8206FA9Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8206FAC8;  }
		/* 8206FA9Ch case    4:*/		return 0x8206FAA0;
		  /* 8206FAA0h */ case    5:  		/* lwz R11, <#[R1 + 396]> */
		/* 8206FAA0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000018C) );
		/* 8206FAA0h case    5:*/		return 0x8206FAA4;
		  /* 8206FAA4h */ case    6:  		/* mr R9, R29 */
		/* 8206FAA4h case    6:*/		regs.R9 = regs.R29;
		/* 8206FAA4h case    6:*/		return 0x8206FAA8;
		  /* 8206FAA8h */ case    7:  		/* mr R8, R23 */
		/* 8206FAA8h case    7:*/		regs.R8 = regs.R23;
		/* 8206FAA8h case    7:*/		return 0x8206FAAC;
		  /* 8206FAACh */ case    8:  		/* lwz R10, <#[R1 + 380]> */
		/* 8206FAACh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000017C) );
		/* 8206FAACh case    8:*/		return 0x8206FAB0;
		  /* 8206FAB0h */ case    9:  		/* mr R6, R21 */
		/* 8206FAB0h case    9:*/		regs.R6 = regs.R21;
		/* 8206FAB0h case    9:*/		return 0x8206FAB4;
		  /* 8206FAB4h */ case   10:  		/* fmr FR1, FR31 */
		/* 8206FAB4h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8206FAB4h case   10:*/		return 0x8206FAB8;
		  /* 8206FAB8h */ case   11:  		/* addi R5, R1, 112 */
		/* 8206FAB8h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 8206FAB8h case   11:*/		return 0x8206FABC;
		  /* 8206FABCh */ case   12:  		/* mr R3, R22 */
		/* 8206FABCh case   12:*/		regs.R3 = regs.R22;
		/* 8206FABCh case   12:*/		return 0x8206FAC0;
	}
	return 0x8206FAC0;
} // Block from 8206FA8Ch-8206FAC0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206FAC0h
// Function '?SetSurfaceHeader@D3D@@YAXIIW4_D3DFORMAT@@W4_D3DMULTISAMPLE_TYPE@@PBU_D3DSURFACE_PARAMETERS@@PAUD3DSurface@@PAK4@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FAC0);
		  /* 8206FAC0h */ case    0:  		/* stw R11, <#[R1 + 84]> */
		/* 8206FAC0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8206FAC0h case    0:*/		return 0x8206FAC4;
		  /* 8206FAC4h */ case    1:  		/* bl -1124 */
		/* 8206FAC4h case    1:*/		regs.LR = 0x8206FAC8; return 0x8206F660;
		/* 8206FAC4h case    1:*/		return 0x8206FAC8;
	}
	return 0x8206FAC8;
} // Block from 8206FAC0h-8206FAC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206FAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FAC8);
		  /* 8206FAC8h */ case    0:  		/* li R11, 1 */
		/* 8206FAC8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206FAC8h case    0:*/		return 0x8206FACC;
		  /* 8206FACCh */ case    1:  		/* lwz R9, <#[R1 + 404]> */
		/* 8206FACCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000194) );
		/* 8206FACCh case    1:*/		return 0x8206FAD0;
		  /* 8206FAD0h */ case    2:  		/* sraw R8, R31, R27 */
		/* 8206FAD0h case    2:*/		cpu::op::sraw<0>(regs,&regs.R8,regs.R31,regs.R27);
		/* 8206FAD0h case    2:*/		return 0x8206FAD4;
		  /* 8206FAD4h */ case    3:  		/* lwz R10, <#[R1 + 388]> */
		/* 8206FAD4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000184) );
		/* 8206FAD4h case    3:*/		return 0x8206FAD8;
		  /* 8206FAD8h */ case    4:  		/* rlwimi R23, R11, 17, 14, 15 */
		/* 8206FAD8h case    4:*/		cpu::op::rlwimi<0,17,14,15>(regs,&regs.R23,regs.R11);
		/* 8206FAD8h case    4:*/		return 0x8206FADC;
		  /* 8206FADCh */ case    5:  		/* stw R9, <#[R1 + 84]> */
		/* 8206FADCh case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8206FADCh case    5:*/		return 0x8206FAE0;
		  /* 8206FAE0h */ case    6:  		/* sraw R11, R25, R26 */
		/* 8206FAE0h case    6:*/		cpu::op::sraw<0>(regs,&regs.R11,regs.R25,regs.R26);
		/* 8206FAE0h case    6:*/		return 0x8206FAE4;
		  /* 8206FAE4h */ case    7:  		/* stw R8, <#[R1 + 96]> */
		/* 8206FAE4h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 8206FAE4h case    7:*/		return 0x8206FAE8;
		  /* 8206FAE8h */ case    8:  		/* stw R11, <#[R1 + 100]> */
		/* 8206FAE8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8206FAE8h case    8:*/		return 0x8206FAEC;
		  /* 8206FAECh */ case    9:  		/* sraw R11, R30, R27 */
		/* 8206FAECh case    9:*/		cpu::op::sraw<0>(regs,&regs.R11,regs.R30,regs.R27);
		/* 8206FAECh case    9:*/		return 0x8206FAF0;
		  /* 8206FAF0h */ case   10:  		/* sraw R9, R24, R26 */
		/* 8206FAF0h case   10:*/		cpu::op::sraw<0>(regs,&regs.R9,regs.R24,regs.R26);
		/* 8206FAF0h case   10:*/		return 0x8206FAF4;
		  /* 8206FAF4h */ case   11:  		/* stw R11, <#[R1 + 104]> */
		/* 8206FAF4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 8206FAF4h case   11:*/		return 0x8206FAF8;
		  /* 8206FAF8h */ case   12:  		/* stw R9, <#[R1 + 108]> */
		/* 8206FAF8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206FAF8h case   12:*/		return 0x8206FAFC;
		  /* 8206FAFCh */ case   13:  		/* rlwinm R11, R23, 0, 18, 31 */
		/* 8206FAFCh case   13:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R11,regs.R23);
		/* 8206FAFCh case   13:*/		return 0x8206FB00;
		  /* 8206FB00h */ case   14:  		/* mr R9, R29 */
		/* 8206FB00h case   14:*/		regs.R9 = regs.R29;
		/* 8206FB00h case   14:*/		return 0x8206FB04;
		  /* 8206FB04h */ case   15:  		/* fmr FR1, FR31 */
		/* 8206FB04h case   15:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8206FB04h case   15:*/		return 0x8206FB08;
		  /* 8206FB08h */ case   16:  		/* srw R11, R11, R27 */
		/* 8206FB08h case   16:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8206FB08h case   16:*/		return 0x8206FB0C;
		  /* 8206FB0Ch */ case   17:  		/* rlwimi R11, R23, 0, 0, 17 */
		/* 8206FB0Ch case   17:*/		cpu::op::rlwimi<0,0,0,17>(regs,&regs.R11,regs.R23);
		/* 8206FB0Ch case   17:*/		return 0x8206FB10;
		  /* 8206FB10h */ case   18:  		/* mr R6, R21 */
		/* 8206FB10h case   18:*/		regs.R6 = regs.R21;
		/* 8206FB10h case   18:*/		return 0x8206FB14;
		  /* 8206FB14h */ case   19:  		/* mr R8, R11 */
		/* 8206FB14h case   19:*/		regs.R8 = regs.R11;
		/* 8206FB14h case   19:*/		return 0x8206FB18;
		  /* 8206FB18h */ case   20:  		/* rlwinm R11, R11, 14, 18, 31 */
		/* 8206FB18h case   20:*/		cpu::op::rlwinm<0,14,18,31>(regs,&regs.R11,regs.R11);
		/* 8206FB18h case   20:*/		return 0x8206FB1C;
		  /* 8206FB1Ch */ case   21:  		/* addi R5, R1, 96 */
		/* 8206FB1Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8206FB1Ch case   21:*/		return 0x8206FB20;
		  /* 8206FB20h */ case   22:  		/* srw R11, R11, R27 */
		/* 8206FB20h case   22:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8206FB20h case   22:*/		return 0x8206FB24;
		  /* 8206FB24h */ case   23:  		/* rlwimi R8, R11, 18, 0, 13 */
		/* 8206FB24h case   23:*/		cpu::op::rlwimi<0,18,0,13>(regs,&regs.R8,regs.R11);
		/* 8206FB24h case   23:*/		return 0x8206FB28;
		  /* 8206FB28h */ case   24:  		/* li R4, 1 */
		/* 8206FB28h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8206FB28h case   24:*/		return 0x8206FB2C;
		  /* 8206FB2Ch */ case   25:  		/* mr R3, R22 */
		/* 8206FB2Ch case   25:*/		regs.R3 = regs.R22;
		/* 8206FB2Ch case   25:*/		return 0x8206FB30;
		  /* 8206FB30h */ case   26:  		/* bl -1232 */
		/* 8206FB30h case   26:*/		regs.LR = 0x8206FB34; return 0x8206F660;
		/* 8206FB30h case   26:*/		return 0x8206FB34;
		  /* 8206FB34h */ case   27:  		/* b 64 */
		/* 8206FB34h case   27:*/		return 0x8206FB74;
		/* 8206FB34h case   27:*/		return 0x8206FB38;
	}
	return 0x8206FB38;
} // Block from 8206FAC8h-8206FB38h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8206FB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FB38);
		  /* 8206FB38h */ case    0:  		/* lwz R11, <#[R1 + 396]> */
		/* 8206FB38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000018C) );
		/* 8206FB38h case    0:*/		return 0x8206FB3C;
		  /* 8206FB3Ch */ case    1:  		/* mr R8, R23 */
		/* 8206FB3Ch case    1:*/		regs.R8 = regs.R23;
		/* 8206FB3Ch case    1:*/		return 0x8206FB40;
		  /* 8206FB40h */ case    2:  		/* stw R3, <#[R1 + 96]> */
		/* 8206FB40h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 8206FB40h case    2:*/		return 0x8206FB44;
		  /* 8206FB44h */ case    3:  		/* mr R6, R21 */
		/* 8206FB44h case    3:*/		regs.R6 = regs.R21;
		/* 8206FB44h case    3:*/		return 0x8206FB48;
		  /* 8206FB48h */ case    4:  		/* addi R5, R1, 96 */
		/* 8206FB48h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8206FB48h case    4:*/		return 0x8206FB4C;
		  /* 8206FB4Ch */ case    5:  		/* lwz R10, <#[R1 + 380]> */
		/* 8206FB4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000017C) );
		/* 8206FB4Ch case    5:*/		return 0x8206FB50;
		  /* 8206FB50h */ case    6:  		/* li R4, 1 */
		/* 8206FB50h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8206FB50h case    6:*/		return 0x8206FB54;
		  /* 8206FB54h */ case    7:  		/* lwz R9, <#[R1 + 372]> */
		/* 8206FB54h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000174) );
		/* 8206FB54h case    7:*/		return 0x8206FB58;
		  /* 8206FB58h */ case    8:  		/* mr R3, R22 */
		/* 8206FB58h case    8:*/		regs.R3 = regs.R22;
		/* 8206FB58h case    8:*/		return 0x8206FB5C;
		  /* 8206FB5Ch */ case    9:  		/* stw R28, <#[R1 + 100]> */
		/* 8206FB5Ch case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000064) );
		/* 8206FB5Ch case    9:*/		return 0x8206FB60;
		  /* 8206FB60h */ case   10:  		/* stw R11, <#[R1 + 84]> */
		/* 8206FB60h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8206FB60h case   10:*/		return 0x8206FB64;
		  /* 8206FB64h */ case   11:  		/* fmr FR1, FR31 */
		/* 8206FB64h case   11:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8206FB64h case   11:*/		return 0x8206FB68;
		  /* 8206FB68h */ case   12:  		/* stw R29, <#[R1 + 104]> */
		/* 8206FB68h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000068) );
		/* 8206FB68h case   12:*/		return 0x8206FB6C;
		  /* 8206FB6Ch */ case   13:  		/* stw R7, <#[R1 + 108]> */
		/* 8206FB6Ch case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206FB6Ch case   13:*/		return 0x8206FB70;
		  /* 8206FB70h */ case   14:  		/* bl -1296 */
		/* 8206FB70h case   14:*/		regs.LR = 0x8206FB74; return 0x8206F660;
		/* 8206FB70h case   14:*/		return 0x8206FB74;
	}
	return 0x8206FB74;
} // Block from 8206FB38h-8206FB74h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206FB74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FB74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FB74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FB74);
		  /* 8206FB74h */ case    0:  		/* addi R1, R1, 288 */
		/* 8206FB74h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 8206FB74h case    0:*/		return 0x8206FB78;
		  /* 8206FB78h */ case    1:  		/* lfd FR31, <#[R1 - 104]> */
		/* 8206FB78h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF98) );
		/* 8206FB78h case    1:*/		return 0x8206FB7C;
		  /* 8206FB7Ch */ case    2:  		/* b 136976 */
		/* 8206FB7Ch case    2:*/		return 0x8209128C;
		/* 8206FB7Ch case    2:*/		return 0x8206FB80;
	}
	return 0x8206FB80;
} // Block from 8206FB74h-8206FB80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206FB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FB80);
		  /* 8206FB80h */ case    0:  		/* mfspr R12, LR */
		/* 8206FB80h case    0:*/		regs.R12 = regs.LR;
		/* 8206FB80h case    0:*/		return 0x8206FB84;
		  /* 8206FB84h */ case    1:  		/* bl 136860 */
		/* 8206FB84h case    1:*/		regs.LR = 0x8206FB88; return 0x82091220;
		/* 8206FB84h case    1:*/		return 0x8206FB88;
		  /* 8206FB88h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 8206FB88h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8206FB88h case    2:*/		return 0x8206FB8C;
		  /* 8206FB8Ch */ case    3:  		/* stwu R1, <#[R1 - 304]> */
		/* 8206FB8Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFED0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFED0);
		/* 8206FB8Ch case    3:*/		return 0x8206FB90;
		  /* 8206FB90h */ case    4:  		/* li R27, 5 */
		/* 8206FB90h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x5);
		/* 8206FB90h case    4:*/		return 0x8206FB94;
		  /* 8206FB94h */ case    5:  		/* lwz R15, <#[R3 + 10368]> */
		/* 8206FB94h case    5:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R3 + 0x00002880) );
		/* 8206FB94h case    5:*/		return 0x8206FB98;
		  /* 8206FB98h */ case    6:  		/* mr R31, R3 */
		/* 8206FB98h case    6:*/		regs.R31 = regs.R3;
		/* 8206FB98h case    6:*/		return 0x8206FB9C;
		  /* 8206FB9Ch */ case    7:  		/* stw R6, <#[R1 + 348]> */
		/* 8206FB9Ch case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000015C) );
		/* 8206FB9Ch case    7:*/		return 0x8206FBA0;
		  /* 8206FBA0h */ case    8:  		/* mr R28, R4 */
		/* 8206FBA0h case    8:*/		regs.R28 = regs.R4;
		/* 8206FBA0h case    8:*/		return 0x8206FBA4;
		  /* 8206FBA4h */ case    9:  		/* stw R7, <#[R1 + 356]> */
		/* 8206FBA4h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000164) );
		/* 8206FBA4h case    9:*/		return 0x8206FBA8;
		  /* 8206FBA8h */ case   10:  		/* mr R25, R6 */
		/* 8206FBA8h case   10:*/		regs.R25 = regs.R6;
		/* 8206FBA8h case   10:*/		return 0x8206FBAC;
		  /* 8206FBACh */ case   11:  		/* stw R8, <#[R1 + 364]> */
		/* 8206FBACh case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000016C) );
		/* 8206FBACh case   11:*/		return 0x8206FBB0;
		  /* 8206FBB0h */ case   12:  		/* mr R26, R7 */
		/* 8206FBB0h case   12:*/		regs.R26 = regs.R7;
		/* 8206FBB0h case   12:*/		return 0x8206FBB4;
		  /* 8206FBB4h */ case   13:  		/* stw R9, <#[R1 + 372]> */
		/* 8206FBB4h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000174) );
		/* 8206FBB4h case   13:*/		return 0x8206FBB8;
		  /* 8206FBB8h */ case   14:  		/* mr R24, R8 */
		/* 8206FBB8h case   14:*/		regs.R24 = regs.R8;
		/* 8206FBB8h case   14:*/		return 0x8206FBBC;
		  /* 8206FBBCh */ case   15:  		/* fmr FR31, FR1 */
		/* 8206FBBCh case   15:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 8206FBBCh case   15:*/		return 0x8206FBC0;
		  /* 8206FBC0h */ case   16:  		/* mr R23, R9 */
		/* 8206FBC0h case   16:*/		regs.R23 = regs.R9;
		/* 8206FBC0h case   16:*/		return 0x8206FBC4;
		  /* 8206FBC4h */ case   17:  		/* mr R16, R10 */
		/* 8206FBC4h case   17:*/		regs.R16 = regs.R10;
		/* 8206FBC4h case   17:*/		return 0x8206FBC8;
		  /* 8206FBC8h */ case   18:  		/* li R21, 0 */
		/* 8206FBC8h case   18:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8206FBC8h case   18:*/		return 0x8206FBCC;
		  /* 8206FBCCh */ case   19:  		/* mr R14, R27 */
		/* 8206FBCCh case   19:*/		regs.R14 = regs.R27;
		/* 8206FBCCh case   19:*/		return 0x8206FBD0;
		  /* 8206FBD0h */ case   20:  		/* cmpwi CR6, R5, -1 */
		/* 8206FBD0h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 8206FBD0h case   20:*/		return 0x8206FBD4;
		  /* 8206FBD4h */ case   21:  		/* bc 12, CR6_EQ, 72 */
		/* 8206FBD4h case   21:*/		if ( regs.CR[6].eq ) { return 0x8206FC1C;  }
		/* 8206FBD4h case   21:*/		return 0x8206FBD8;
		  /* 8206FBD8h */ case   22:  		/* addi R11, R5, 3204 */
		/* 8206FBD8h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xC84);
		/* 8206FBD8h case   22:*/		return 0x8206FBDC;
		  /* 8206FBDCh */ case   23:  		/* lis R10, 10 */
		/* 8206FBDCh case   23:*/		cpu::op::lis<0>(regs,&regs.R10,0xA);
		/* 8206FBDCh case   23:*/		return 0x8206FBE0;
		  /* 8206FBE0h */ case   24:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206FBE0h case   24:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206FBE0h case   24:*/		return 0x8206FBE4;
		  /* 8206FBE4h */ case   25:  		/* li R14, 4 */
		/* 8206FBE4h case   25:*/		cpu::op::li<0>(regs,&regs.R14,0x4);
		/* 8206FBE4h case   25:*/		return 0x8206FBE8;
		  /* 8206FBE8h */ case   26:  		/* lwzx R11, <#[R11 + R3]> */
		/* 8206FBE8h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8206FBE8h case   26:*/		return 0x8206FBEC;
		  /* 8206FBECh */ case   27:  		/* lwz R21, <#[R11 + 28]> */
		/* 8206FBECh case   27:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R11 + 0x0000001C) );
		/* 8206FBECh case   27:*/		return 0x8206FBF0;
		  /* 8206FBF0h */ case   28:  		/* rlwinm R11, R21, 0, 12, 15 */
		/* 8206FBF0h case   28:*/		cpu::op::rlwinm<0,0,12,15>(regs,&regs.R11,regs.R21);
		/* 8206FBF0h case   28:*/		return 0x8206FBF4;
		  /* 8206FBF4h */ case   29:  		/* cmplw CR6, R11, R10 */
		/* 8206FBF4h case   29:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8206FBF4h case   29:*/		return 0x8206FBF8;
		  /* 8206FBF8h */ case   30:  		/* bc 4, CR6_EQ, 12 */
		/* 8206FBF8h case   30:*/		if ( !regs.CR[6].eq ) { return 0x8206FC04;  }
		/* 8206FBF8h case   30:*/		return 0x8206FBFC;
		  /* 8206FBFCh */ case   31:  		/* li R11, 1 */
		/* 8206FBFCh case   31:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206FBFCh case   31:*/		return 0x8206FC00;
		  /* 8206FC00h */ case   32:  		/* rlwimi R21, R11, 17, 12, 15 */
		/* 8206FC00h case   32:*/		cpu::op::rlwimi<0,17,12,15>(regs,&regs.R21,regs.R11);
		/* 8206FC00h case   32:*/		return 0x8206FC04;
	}
	return 0x8206FC04;
} // Block from 8206FB80h-8206FC04h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8206FC04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FC04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FC04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FC04);
		  /* 8206FC04h */ case    0:  		/* rlwinm R11, R21, 0, 12, 15 */
		/* 8206FC04h case    0:*/		cpu::op::rlwinm<0,0,12,15>(regs,&regs.R11,regs.R21);
		/* 8206FC04h case    0:*/		return 0x8206FC08;
		  /* 8206FC08h */ case    1:  		/* lis R10, 12 */
		/* 8206FC08h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xC);
		/* 8206FC08h case    1:*/		return 0x8206FC0C;
		  /* 8206FC0Ch */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8206FC0Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8206FC0Ch case    2:*/		return 0x8206FC10;
		  /* 8206FC10h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8206FC10h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8206FC1C;  }
		/* 8206FC10h case    3:*/		return 0x8206FC14;
		  /* 8206FC14h */ case    4:  		/* li R11, 3 */
		/* 8206FC14h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8206FC14h case    4:*/		return 0x8206FC18;
		  /* 8206FC18h */ case    5:  		/* rlwimi R21, R11, 16, 12, 15 */
		/* 8206FC18h case    5:*/		cpu::op::rlwimi<0,16,12,15>(regs,&regs.R21,regs.R11);
		/* 8206FC18h case    5:*/		return 0x8206FC1C;
	}
	return 0x8206FC1C;
} // Block from 8206FC04h-8206FC1Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206FC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FC1C);
		  /* 8206FC1Ch */ case    0:  		/* lwz R11, <#[R31 + 10560]> */
		/* 8206FC1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002940) );
		/* 8206FC1Ch case    0:*/		return 0x8206FC20;
		  /* 8206FC20h */ case    1:  		/* rlwinm. R10, R28, 0, 27, 27 */
		/* 8206FC20h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R28);
		/* 8206FC20h case    1:*/		return 0x8206FC24;
		  /* 8206FC24h */ case    2:  		/* li R19, 0 */
		/* 8206FC24h case    2:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8206FC24h case    2:*/		return 0x8206FC28;
		  /* 8206FC28h */ case    3:  		/* rlwinm R30, R11, 0, 0, 27 */
		/* 8206FC28h case    3:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R30,regs.R11);
		/* 8206FC28h case    3:*/		return 0x8206FC2C;
		  /* 8206FC2Ch */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 8206FC2Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8206FC38;  }
		/* 8206FC2Ch case    4:*/		return 0x8206FC30;
		  /* 8206FC30h */ case    5:  		/* li R19, 118 */
		/* 8206FC30h case    5:*/		cpu::op::li<0>(regs,&regs.R19,0x76);
		/* 8206FC30h case    5:*/		return 0x8206FC34;
		  /* 8206FC34h */ case    6:  		/* ori R30, R30, 1 */
		/* 8206FC34h case    6:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8206FC34h case    6:*/		return 0x8206FC38;
	}
	return 0x8206FC38;
} // Block from 8206FC1Ch-8206FC38h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206FC38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FC38);
		  /* 8206FC38h */ case    0:  		/* rlwinm. R11, R28, 0, 26, 26 */
		/* 8206FC38h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R28);
		/* 8206FC38h case    0:*/		return 0x8206FC3C;
		  /* 8206FC3Ch */ case    1:  		/* bc 12, CR0_EQ, 112 */
		/* 8206FC3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8206FCAC;  }
		/* 8206FC3Ch case    1:*/		return 0x8206FC40;
		  /* 8206FC40h */ case    2:  		/* lwz R29, <#[R1 + 396]> */
		/* 8206FC40h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000018C) );
		/* 8206FC40h case    2:*/		return 0x8206FC44;
		  /* 8206FC44h */ case    3:  		/* rlwinm. R11, R28, 0, 25, 25 */
		/* 8206FC44h case    3:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R28);
		/* 8206FC44h case    3:*/		return 0x8206FC48;
		  /* 8206FC48h */ case    4:  		/* ori R19, R19, 34561 */
		/* 8206FC48h case    4:*/		cpu::op::ori<0>(regs,&regs.R19,regs.R19,0x8701);
		/* 8206FC48h case    4:*/		return 0x8206FC4C;
		  /* 8206FC4Ch */ case    5:  		/* ori R30, R30, 4 */
		/* 8206FC4Ch case    5:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8206FC4Ch case    5:*/		return 0x8206FC50;
		  /* 8206FC50h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 8206FC50h case    6:*/		if ( regs.CR[0].eq ) { return 0x8206FC60;  }
		/* 8206FC50h case    6:*/		return 0x8206FC54;
		  /* 8206FC54h */ case    7:  		/* rlwimi R30, R29, 8, 16, 23 */
		/* 8206FC54h case    7:*/		cpu::op::rlwimi<0,8,16,23>(regs,&regs.R30,regs.R29);
		/* 8206FC54h case    7:*/		return 0x8206FC58;
		  /* 8206FC58h */ case    8:  		/* rlwinm R30, R30, 0, 27, 25 */
		/* 8206FC58h case    8:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R30,regs.R30);
		/* 8206FC58h case    8:*/		return 0x8206FC5C;
		  /* 8206FC5Ch */ case    9:  		/* b 20 */
		/* 8206FC5Ch case    9:*/		return 0x8206FC70;
		/* 8206FC5Ch case    9:*/		return 0x8206FC60;
	}
	return 0x8206FC60;
} // Block from 8206FC38h-8206FC60h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206FC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FC60);
		  /* 8206FC60h */ case    0:  		/* rlwinm. R11, R28, 0, 24, 24 */
		/* 8206FC60h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R28);
		/* 8206FC60h case    0:*/		return 0x8206FC64;
		  /* 8206FC64h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8206FC64h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206FC70;  }
		/* 8206FC64h case    1:*/		return 0x8206FC68;
		  /* 8206FC68h */ case    2:  		/* rlwimi R30, R29, 8, 16, 23 */
		/* 8206FC68h case    2:*/		cpu::op::rlwimi<0,8,16,23>(regs,&regs.R30,regs.R29);
		/* 8206FC68h case    2:*/		return 0x8206FC6C;
		  /* 8206FC6Ch */ case    3:  		/* ori R30, R30, 32 */
		/* 8206FC6Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x20);
		/* 8206FC6Ch case    3:*/		return 0x8206FC70;
	}
	return 0x8206FC70;
} // Block from 8206FC60h-8206FC70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206FC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FC70);
		  /* 8206FC70h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 8206FC70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8206FC70h case    0:*/		return 0x8206FC74;
		  /* 8206FC74h */ case    1:  		/* lwz R3, <#[R31 + 48]> */
		/* 8206FC74h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206FC74h case    1:*/		return 0x8206FC78;
		  /* 8206FC78h */ case    2:  		/* cmplw CR6, R3, R11 */
		/* 8206FC78h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8206FC78h case    2:*/		return 0x8206FC7C;
		  /* 8206FC7Ch */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 8206FC7Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x8206FC88;  }
		/* 8206FC7Ch case    3:*/		return 0x8206FC80;
		  /* 8206FC80h */ case    4:  		/* mr R3, R31 */
		/* 8206FC80h case    4:*/		regs.R3 = regs.R31;
		/* 8206FC80h case    4:*/		return 0x8206FC84;
		  /* 8206FC84h */ case    5:  		/* bl 17540 */
		/* 8206FC84h case    5:*/		regs.LR = 0x8206FC88; return 0x82074108;
		/* 8206FC84h case    5:*/		return 0x8206FC88;
	}
	return 0x8206FC88;
} // Block from 8206FC70h-8206FC88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206FC88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FC88);
		  /* 8206FC88h */ case    0:  		/* li R11, 8461 */
		/* 8206FC88h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x210D);
		/* 8206FC88h case    0:*/		return 0x8206FC8C;
		  /* 8206FC8Ch */ case    1:  		/* li R10, 255 */
		/* 8206FC8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFF);
		/* 8206FC8Ch case    1:*/		return 0x8206FC90;
		  /* 8206FC90h */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206FC90h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206FC90h case    2:*/		return 0x8206FC94;
		  /* 8206FC94h */ case    3:  		/* rlwimi R29, R10, 16, 0, 23 */
		/* 8206FC94h case    3:*/		cpu::op::rlwimi<0,16,0,23>(regs,&regs.R29,regs.R10);
		/* 8206FC94h case    3:*/		return 0x8206FC98;
		  /* 8206FC98h */ case    4:  		/* stwu R29, <#[R3 + 4]> */
		/* 8206FC98h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206FC98h case    4:*/		return 0x8206FC9C;
		  /* 8206FC9Ch */ case    5:  		/* stw R3, <#[R31 + 48]> */
		/* 8206FC9Ch case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206FC9Ch case    5:*/		return 0x8206FCA0;
		  /* 8206FCA0h */ case    6:  		/* ld R11, <#[R31 + 16]> */
		/* 8206FCA0h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206FCA0h case    6:*/		return 0x8206FCA4;
		  /* 8206FCA4h */ case    7:  		/* oris R11, R11, 4096 */
		/* 8206FCA4h case    7:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 8206FCA4h case    7:*/		return 0x8206FCA8;
		  /* 8206FCA8h */ case    8:  		/* std R11, <#[R31 + 16]> */
		/* 8206FCA8h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206FCA8h case    8:*/		return 0x8206FCAC;
	}
	return 0x8206FCAC;
} // Block from 8206FC88h-8206FCACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206FCACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FCAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FCAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FCAC);
		  /* 8206FCACh */ case    0:  		/* mr R5, R30 */
		/* 8206FCACh case    0:*/		regs.R5 = regs.R30;
		/* 8206FCACh case    0:*/		return 0x8206FCB0;
		  /* 8206FCB0h */ case    1:  		/* li R4, 256 */
		/* 8206FCB0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 8206FCB0h case    1:*/		return 0x8206FCB4;
		  /* 8206FCB4h */ case    2:  		/* mr R3, R31 */
		/* 8206FCB4h case    2:*/		regs.R3 = regs.R31;
		/* 8206FCB4h case    2:*/		return 0x8206FCB8;
		  /* 8206FCB8h */ case    3:  		/* bl 79568 */
		/* 8206FCB8h case    3:*/		regs.LR = 0x8206FCBC; return 0x82083388;
		/* 8206FCB8h case    3:*/		return 0x8206FCBC;
		  /* 8206FCBCh */ case    4:  		/* lwz R3, <#[R31 + 48]> */
		/* 8206FCBCh case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8206FCBCh case    4:*/		return 0x8206FCC0;
		  /* 8206FCC0h */ case    5:  		/* lwz R11, <#[R31 + 56]> */
		/* 8206FCC0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8206FCC0h case    5:*/		return 0x8206FCC4;
		  /* 8206FCC4h */ case    6:  		/* cmplw CR6, R3, R11 */
		/* 8206FCC4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8206FCC4h case    6:*/		return 0x8206FCC8;
		  /* 8206FCC8h */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 8206FCC8h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8206FCD4;  }
		/* 8206FCC8h case    7:*/		return 0x8206FCCC;
		  /* 8206FCCCh */ case    8:  		/* mr R3, R31 */
		/* 8206FCCCh case    8:*/		regs.R3 = regs.R31;
		/* 8206FCCCh case    8:*/		return 0x8206FCD0;
		  /* 8206FCD0h */ case    9:  		/* bl 17464 */
		/* 8206FCD0h case    9:*/		regs.LR = 0x8206FCD4; return 0x82074108;
		/* 8206FCD0h case    9:*/		return 0x8206FCD4;
	}
	return 0x8206FCD4;
} // Block from 8206FCACh-8206FCD4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206FCD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FCD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FCD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FCD4);
		  /* 8206FCD4h */ case    0:  		/* lis R11, 2 */
		/* 8206FCD4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x2);
		/* 8206FCD4h case    0:*/		return 0x8206FCD8;
		  /* 8206FCD8h */ case    1:  		/* li R10, 0 */
		/* 8206FCD8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8206FCD8h case    1:*/		return 0x8206FCDC;
		  /* 8206FCDCh */ case    2:  		/* ori R11, R11, 8320 */
		/* 8206FCDCh case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2080);
		/* 8206FCDCh case    2:*/		return 0x8206FCE0;
		  /* 8206FCE0h */ case    3:  		/* li R9, 0 */
		/* 8206FCE0h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8206FCE0h case    3:*/		return 0x8206FCE4;
		  /* 8206FCE4h */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 8206FCE4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206FCE4h case    4:*/		return 0x8206FCE8;
		  /* 8206FCE8h */ case    5:  		/* lis R11, 8192 */
		/* 8206FCE8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0x2000);
		/* 8206FCE8h case    5:*/		return 0x8206FCEC;
		  /* 8206FCECh */ case    6:  		/* rlwinm. R29, R28, 0, 26, 27 */
		/* 8206FCECh case    6:*/		cpu::op::rlwinm<1,0,26,27>(regs,&regs.R29,regs.R28);
		/* 8206FCECh case    6:*/		return 0x8206FCF0;
		  /* 8206FCF0h */ case    7:  		/* stwu R10, <#[R3 + 4]> */
		/* 8206FCF0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206FCF0h case    7:*/		return 0x8206FCF4;
		  /* 8206FCF4h */ case    8:  		/* ori R11, R11, 8192 */
		/* 8206FCF4h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 8206FCF4h case    8:*/		return 0x8206FCF8;
		  /* 8206FCF8h */ case    9:  		/* mr R17, R19 */
		/* 8206FCF8h case    9:*/		regs.R17 = regs.R19;
		/* 8206FCF8h case    9:*/		return 0x8206FCFC;
		  /* 8206FCFCh */ case   10:  		/* mr R18, R14 */
		/* 8206FCFCh case   10:*/		regs.R18 = regs.R14;
		/* 8206FCFCh case   10:*/		return 0x8206FD00;
		  /* 8206FD00h */ case   11:  		/* stwu R9, <#[R3 + 4]> */
		/* 8206FD00h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8206FD00h case   11:*/		return 0x8206FD04;
		  /* 8206FD04h */ case   12:  		/* mr R30, R3 */
		/* 8206FD04h case   12:*/		regs.R30 = regs.R3;
		/* 8206FD04h case   12:*/		return 0x8206FD08;
		  /* 8206FD08h */ case   13:  		/* stwu R11, <#[R30 + 4]> */
		/* 8206FD08h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206FD08h case   13:*/		return 0x8206FD0C;
		  /* 8206FD0Ch */ case   14:  		/* bc 4, CR0_EQ, 276 */
		/* 8206FD0Ch case   14:*/		if ( !regs.CR[0].eq ) { return 0x8206FE20;  }
		/* 8206FD0Ch case   14:*/		return 0x8206FD10;
		  /* 8206FD10h */ case   15:  		/* rlwinm R3, R21, 16, 28, 31 */
		/* 8206FD10h case   15:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R3,regs.R21);
		/* 8206FD10h case   15:*/		return 0x8206FD14;
		  /* 8206FD14h */ case   16:  		/* cmplwi CR6, R3, 5 */
		/* 8206FD14h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000005);
		/* 8206FD14h case   16:*/		return 0x8206FD18;
		  /* 8206FD18h */ case   17:  		/* bc 12, CR6_EQ, 264 */
		/* 8206FD18h case   17:*/		if ( regs.CR[6].eq ) { return 0x8206FE20;  }
		/* 8206FD18h case   17:*/		return 0x8206FD1C;
		  /* 8206FD1Ch */ case   18:  		/* cmplwi CR6, R3, 7 */
		/* 8206FD1Ch case   18:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000007);
		/* 8206FD1Ch case   18:*/		return 0x8206FD20;
		  /* 8206FD20h */ case   19:  		/* bc 12, CR6_EQ, 256 */
		/* 8206FD20h case   19:*/		if ( regs.CR[6].eq ) { return 0x8206FE20;  }
		/* 8206FD20h case   19:*/		return 0x8206FD24;
		  /* 8206FD24h */ case   20:  		/* cmplwi CR6, R3, 15 */
		/* 8206FD24h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000000F);
		/* 8206FD24h case   20:*/		return 0x8206FD28;
		  /* 8206FD28h */ case   21:  		/* bc 12, CR6_EQ, 248 */
		/* 8206FD28h case   21:*/		if ( regs.CR[6].eq ) { return 0x8206FE20;  }
		/* 8206FD28h case   21:*/		return 0x8206FD2C;
		  /* 8206FD2Ch */ case   22:  		/* rlwinm. R11, R15, 16, 30, 31 */
		/* 8206FD2Ch case   22:*/		cpu::op::rlwinm<1,16,30,31>(regs,&regs.R11,regs.R15);
		/* 8206FD2Ch case   22:*/		return 0x8206FD30;
	}
	return 0x8206FD30;
} // Block from 8206FCD4h-8206FD30h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8206FD30h
// Function 'D3DBaseTexture_GetLevelCount'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FD30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FD30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FD30);
		  /* 8206FD30h */ case    0:  		/* li R9, 16 */
		/* 8206FD30h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 8206FD30h case    0:*/		return 0x8206FD34;
		  /* 8206FD34h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 8206FD34h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8206FD44;  }
		/* 8206FD34h case    1:*/		return 0x8206FD38;
		  /* 8206FD38h */ case    2:  		/* li R11, 80 */
		/* 8206FD38h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x50);
		/* 8206FD38h case    2:*/		return 0x8206FD3C;
		  /* 8206FD3Ch */ case    3:  		/* mr R10, R9 */
		/* 8206FD3Ch case    3:*/		regs.R10 = regs.R9;
		/* 8206FD3Ch case    3:*/		return 0x8206FD40;
	}
	return 0x8206FD40;
} // Block from 8206FD30h-8206FD40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206FD40h
// Function 'D3DDevice_CreateTexture'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FD40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FD40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FD40);
		  /* 8206FD40h */ case    0:  		/* b 24 */
		/* 8206FD40h case    0:*/		return 0x8206FD58;
		/* 8206FD40h case    0:*/		return 0x8206FD44;
	}
	return 0x8206FD44;
} // Block from 8206FD40h-8206FD44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206FD44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FD44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FD44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FD44);
		  /* 8206FD44h */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 8206FD44h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8206FD44h case    0:*/		return 0x8206FD48;
		  /* 8206FD48h */ case    1:  		/* li R10, 8 */
		/* 8206FD48h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 8206FD48h case    1:*/		return 0x8206FD4C;
		  /* 8206FD4Ch */ case    2:  		/* li R11, 80 */
		/* 8206FD4Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x50);
		/* 8206FD4Ch case    2:*/		return 0x8206FD50;
		  /* 8206FD50h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 8206FD50h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206FD58;  }
		/* 8206FD50h case    3:*/		return 0x8206FD54;
		  /* 8206FD54h */ case    4:  		/* li R11, 40 */
		/* 8206FD54h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x28);
		/* 8206FD54h case    4:*/		return 0x8206FD58;
	}
	return 0x8206FD58;
} // Block from 8206FD44h-8206FD58h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206FD58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FD58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FD58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FD58);
		  /* 8206FD58h */ case    0:  		/* subf R8, R25, R24 */
		/* 8206FD58h case    0:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R25,regs.R24);
		/* 8206FD58h case    0:*/		return 0x8206FD5C;
		  /* 8206FD5Ch */ case    1:  		/* cmpw CR6, R8, R11 */
		/* 8206FD5Ch case    1:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R11);
		/* 8206FD5Ch case    1:*/		return 0x8206FD60;
		  /* 8206FD60h */ case    2:  		/* bc 12, CR6_LT, 192 */
		/* 8206FD60h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206FE20;  }
		/* 8206FD60h case    2:*/		return 0x8206FD64;
		  /* 8206FD64h */ case    3:  		/* subf R11, R26, R23 */
		/* 8206FD64h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R26,regs.R23);
		/* 8206FD64h case    3:*/		return 0x8206FD68;
		  /* 8206FD68h */ case    4:  		/* cmpw CR6, R11, R10 */
		/* 8206FD68h case    4:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8206FD68h case    4:*/		return 0x8206FD6C;
		  /* 8206FD6Ch */ case    5:  		/* bc 12, CR6_LT, 180 */
		/* 8206FD6Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8206FE20;  }
		/* 8206FD6Ch case    5:*/		return 0x8206FD70;
		  /* 8206FD70h */ case    6:  		/* lvlx VR63, <#[R16]> */
		/* 8206FD70h case    6:*/		cpu::mem::lvlx( regs, &regs.VR63, (uint32)(regs.R16 + 0x00000000) );
		/* 8206FD70h case    6:*/		return 0x8206FD74;
		  /* 8206FD74h */ case    7:  		/* addi R6, R1, 132 */
		/* 8206FD74h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x84);
		/* 8206FD74h case    7:*/		return 0x8206FD78;
		  /* 8206FD78h */ case    8:  		/* lvrx VR62, <#[R9 + R16]> */
		/* 8206FD78h case    8:*/		cpu::mem::lvrx( regs, &regs.VR62, (uint32)(regs.R9 + regs.R16 + 0x00000000) );
		/* 8206FD78h case    8:*/		return 0x8206FD7C;
		  /* 8206FD7Ch */ case    9:  		/* addi R5, R1, 128 */
		/* 8206FD7Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 8206FD7Ch case    9:*/		return 0x8206FD80;
		  /* 8206FD80h */ case   10:  		/* vor VR1, VR63, VR62 */
		/* 8206FD80h case   10:*/		cpu::op::vor<0>(regs,&regs.VR1,regs.VR63,regs.VR62);
		/* 8206FD80h case   10:*/		return 0x8206FD84;
		  /* 8206FD84h */ case   11:  		/* rlwinm R4, R21, 12, 26, 31 */
		/* 8206FD84h case   11:*/		cpu::op::rlwinm<0,12,26,31>(regs,&regs.R4,regs.R21);
		/* 8206FD84h case   11:*/		return 0x8206FD88;
		  /* 8206FD88h */ case   12:  		/* bl 72184 */
		/* 8206FD88h case   12:*/		regs.LR = 0x8206FD8C; return 0x82081780;
		/* 8206FD88h case   12:*/		return 0x8206FD8C;
		  /* 8206FD8Ch */ case   13:  		/* li R10, 8707 */
		/* 8206FD8Ch case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x2203);
		/* 8206FD8Ch case   13:*/		return 0x8206FD90;
		  /* 8206FD90h */ case   14:  		/* lwz R11, <#[R1 + 128]> */
		/* 8206FD90h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 8206FD90h case   14:*/		return 0x8206FD94;
		  /* 8206FD94h */ case   15:  		/* li R8, 0 */
		/* 8206FD94h case   15:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8206FD94h case   15:*/		return 0x8206FD98;
		  /* 8206FD98h */ case   16:  		/* stwu R10, <#[R30 + 4]> */
		/* 8206FD98h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206FD98h case   16:*/		return 0x8206FD9C;
		  /* 8206FD9Ch */ case   17:  		/* lis R9, -32256 */
		/* 8206FD9Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8206FD9Ch case   17:*/		return 0x8206FDA0;
		  /* 8206FDA0h */ case   18:  		/* rlwinm R5, R11, 24, 8, 31 */
		/* 8206FDA0h case   18:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R5,regs.R11);
		/* 8206FDA0h case   18:*/		return 0x8206FDA4;
		  /* 8206FDA4h */ case   19:  		/* li R7, 8194 */
		/* 8206FDA4h case   19:*/		cpu::op::li<0>(regs,&regs.R7,0x2002);
		/* 8206FDA4h case   19:*/		return 0x8206FDA8;
		  /* 8206FDA8h */ case   20:  		/* std R5, <#[R1 + 136]> */
		/* 8206FDA8h case   20:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000088) );
		/* 8206FDA8h case   20:*/		return 0x8206FDAC;
		  /* 8206FDACh */ case   21:  		/* lfd FR0, <#[R1 + 136]> */
		/* 8206FDACh case   21:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000088) );
		/* 8206FDACh case   21:*/		return 0x8206FDB0;
		  /* 8206FDB0h */ case   22:  		/* fcfid FR12, FR0 */
		/* 8206FDB0h case   22:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR0);
		/* 8206FDB0h case   22:*/		return 0x8206FDB4;
		  /* 8206FDB4h */ case   23:  		/* lis R10, -32256 */
		/* 8206FDB4h case   23:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8206FDB4h case   23:*/		return 0x8206FDB8;
		  /* 8206FDB8h */ case   24:  		/* stwu R8, <#[R30 + 4]> */
		/* 8206FDB8h case   24:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206FDB8h case   24:*/		return 0x8206FDBC;
		  /* 8206FDBCh */ case   25:  		/* lfd FR0, <#[R9 + 4248]> */
		/* 8206FDBCh case   25:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00001098) );
		/* 8206FDBCh case   25:*/		return 0x8206FDC0;
		  /* 8206FDC0h */ case   26:  		/* rlwinm R6, R21, 0, 20, 31 */
		/* 8206FDC0h case   26:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R6,regs.R21);
		/* 8206FDC0h case   26:*/		return 0x8206FDC4;
		  /* 8206FDC4h */ case   27:  		/* fsub FR0, FR12, FR0 */
		/* 8206FDC4h case   27:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 8206FDC4h case   27:*/		return 0x8206FDC8;
		  /* 8206FDC8h */ case   28:  		/* stwu R7, <#[R30 + 4]> */
		/* 8206FDC8h case   28:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206FDC8h case   28:*/		return 0x8206FDCC;
		  /* 8206FDCCh */ case   29:  		/* lfd FR13, <#[R10 + 4240]> */
		/* 8206FDCCh case   29:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00001090) );
		/* 8206FDCCh case   29:*/		return 0x8206FDD0;
		  /* 8206FDD0h */ case   30:  		/* li R4, 8461 */
		/* 8206FDD0h case   30:*/		cpu::op::li<0>(regs,&regs.R4,0x210D);
		/* 8206FDD0h case   30:*/		return 0x8206FDD4;
		  /* 8206FDD4h */ case   31:  		/* fmul FR0, FR0, FR13 */
		/* 8206FDD4h case   31:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 8206FDD4h case   31:*/		return 0x8206FDD8;
		  /* 8206FDD8h */ case   32:  		/* stwu R6, <#[R30 + 4]> */
		/* 8206FDD8h case   32:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206FDD8h case   32:*/		return 0x8206FDDC;
		  /* 8206FDDCh */ case   33:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8206FDDCh case   33:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8206FDDCh case   33:*/		return 0x8206FDE0;
		  /* 8206FDE0h */ case   34:  		/* li R12, 1 */
		/* 8206FDE0h case   34:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206FDE0h case   34:*/		return 0x8206FDE4;
		  /* 8206FDE4h */ case   35:  		/* frsp FR31, FR0 */
		/* 8206FDE4h case   35:*/		cpu::op::frsp<0>(regs,&regs.FR31,regs.FR0);
		/* 8206FDE4h case   35:*/		return 0x8206FDE8;
		  /* 8206FDE8h */ case   36:  		/* oris R11, R11, 255 */
		/* 8206FDE8h case   36:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0xFF);
		/* 8206FDE8h case   36:*/		return 0x8206FDEC;
		  /* 8206FDECh */ case   37:  		/* rldicr R12, R12, 55, 63 */
		/* 8206FDECh case   37:*/		cpu::op::rldicr<0,55,63>(regs,&regs.R12,regs.R12);
		/* 8206FDECh case   37:*/		return 0x8206FDF0;
		  /* 8206FDF0h */ case   38:  		/* lis R17, 0 */
		/* 8206FDF0h case   38:*/		cpu::op::lis<0>(regs,&regs.R17,0x0);
		/* 8206FDF0h case   38:*/		return 0x8206FDF4;
		  /* 8206FDF4h */ case   39:  		/* stwu R4, <#[R30 + 4]> */
		/* 8206FDF4h case   39:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206FDF4h case   39:*/		return 0x8206FDF8;
		  /* 8206FDF8h */ case   40:  		/* mr R18, R27 */
		/* 8206FDF8h case   40:*/		regs.R18 = regs.R27;
		/* 8206FDF8h case   40:*/		return 0x8206FDFC;
		  /* 8206FDFCh */ case   41:  		/* ori R17, R17, 34679 */
		/* 8206FDFCh case   41:*/		cpu::op::ori<0>(regs,&regs.R17,regs.R17,0x8777);
		/* 8206FDFCh case   41:*/		return 0x8206FE00;
		  /* 8206FE00h */ case   42:  		/* stwu R11, <#[R30 + 4]> */
		/* 8206FE00h case   42:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206FE00h case   42:*/		return 0x8206FE04;
		  /* 8206FE04h */ case   43:  		/* ld R11, <#[R31 + 16]> */
		/* 8206FE04h case   43:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206FE04h case   43:*/		return 0x8206FE08;
		  /* 8206FE08h */ case   44:  		/* ori R11, R11, 256 */
		/* 8206FE08h case   44:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 8206FE08h case   44:*/		return 0x8206FE0C;
		  /* 8206FE0Ch */ case   45:  		/* std R11, <#[R31 + 16]> */
		/* 8206FE0Ch case   45:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206FE0Ch case   45:*/		return 0x8206FE10;
		  /* 8206FE10h */ case   46:  		/* or R11, R11, R12 */
		/* 8206FE10h case   46:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206FE10h case   46:*/		return 0x8206FE14;
		  /* 8206FE14h */ case   47:  		/* std R11, <#[R31 + 16]> */
		/* 8206FE14h case   47:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206FE14h case   47:*/		return 0x8206FE18;
		  /* 8206FE18h */ case   48:  		/* oris R11, R11, 4096 */
		/* 8206FE18h case   48:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 8206FE18h case   48:*/		return 0x8206FE1C;
		  /* 8206FE1Ch */ case   49:  		/* std R11, <#[R31 + 16]> */
		/* 8206FE1Ch case   49:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206FE1Ch case   49:*/		return 0x8206FE20;
	}
	return 0x8206FE20;
} // Block from 8206FD58h-8206FE20h (50 instructions)

//////////////////////////////////////////////////////
// Block at 8206FE20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FE20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FE20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FE20);
		  /* 8206FE20h */ case    0:  		/* lbz R11, <#[R31 + 11071]> */
		/* 8206FE20h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3F) );
		/* 8206FE20h case    0:*/		return 0x8206FE24;
		  /* 8206FE24h */ case    1:  		/* stw R30, <#[R31 + 48]> */
		/* 8206FE24h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000030) );
		/* 8206FE24h case    1:*/		return 0x8206FE28;
		  /* 8206FE28h */ case    2:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8206FE28h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8206FE28h case    2:*/		return 0x8206FE2C;
		  /* 8206FE2Ch */ case    3:  		/* bc 4, CR0_EQ, 24 */
		/* 8206FE2Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8206FE44;  }
		/* 8206FE2Ch case    3:*/		return 0x8206FE30;
		  /* 8206FE30h */ case    4:  		/* lbz R11, <#[R31 + 11072]> */
		/* 8206FE30h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B40) );
		/* 8206FE30h case    4:*/		return 0x8206FE34;
		  /* 8206FE34h */ case    5:  		/* rlwinm. R10, R11, 0, 0, 24 */
		/* 8206FE34h case    5:*/		cpu::op::rlwinm<1,0,0,24>(regs,&regs.R10,regs.R11);
		/* 8206FE34h case    5:*/		return 0x8206FE38;
		  /* 8206FE38h */ case    6:  		/* bc 4, CR0_EQ, 12 */
		/* 8206FE38h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8206FE44;  }
		/* 8206FE38h case    6:*/		return 0x8206FE3C;
		  /* 8206FE3Ch */ case    7:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 8206FE3Ch case    7:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 8206FE3Ch case    7:*/		return 0x8206FE40;
	}
	return 0x8206FE40;
} // Block from 8206FE20h-8206FE40h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206FE40h
// Function 'D3DDevice_CreateSurface'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FE40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FE40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FE40);
		  /* 8206FE40h */ case    0:  		/* bc 12, CR0_EQ, 12 */
		/* 8206FE40h case    0:*/		if ( regs.CR[0].eq ) { return 0x8206FE4C;  }
		/* 8206FE40h case    0:*/		return 0x8206FE44;
	}
	return 0x8206FE44;
} // Block from 8206FE40h-8206FE44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206FE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FE44);
		  /* 8206FE44h */ case    0:  		/* mr R3, R31 */
		/* 8206FE44h case    0:*/		regs.R3 = regs.R31;
		/* 8206FE44h case    0:*/		return 0x8206FE48;
		  /* 8206FE48h */ case    1:  		/* bl 53440 */
		/* 8206FE48h case    1:*/		regs.LR = 0x8206FE4C; return 0x8207CF08;
		/* 8206FE48h case    1:*/		return 0x8206FE4C;
	}
	return 0x8206FE4C;
} // Block from 8206FE44h-8206FE4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206FE4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FE4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FE4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FE4C);
		  /* 8206FE4Ch */ case    0:  		/* lbz R10, <#[R31 + 11068]> */
		/* 8206FE4Ch case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B3C) );
		/* 8206FE4Ch case    0:*/		return 0x8206FE50;
		  /* 8206FE50h */ case    1:  		/* rlwinm. R11, R10, 0, 27, 27 */
		/* 8206FE50h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R10);
		/* 8206FE50h case    1:*/		return 0x8206FE54;
		  /* 8206FE54h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8206FE54h case    2:*/		if ( regs.CR[0].eq ) { return 0x8206FE60;  }
		/* 8206FE54h case    2:*/		return 0x8206FE58;
		  /* 8206FE58h */ case    3:  		/* li R11, 1 */
		/* 8206FE58h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206FE58h case    3:*/		return 0x8206FE5C;
		  /* 8206FE5Ch */ case    4:  		/* b 148 */
		/* 8206FE5Ch case    4:*/		return 0x8206FEF0;
		/* 8206FE5Ch case    4:*/		return 0x8206FE60;
	}
	return 0x8206FE60;
} // Block from 8206FE4Ch-8206FE60h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206FE60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FE60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FE60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FE60);
		  /* 8206FE60h */ case    0:  		/* rlwinm. R11, R10, 0, 26, 26 */
		/* 8206FE60h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R10);
		/* 8206FE60h case    0:*/		return 0x8206FE64;
		  /* 8206FE64h */ case    1:  		/* bc 12, CR0_EQ, 132 */
		/* 8206FE64h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206FEE8;  }
		/* 8206FE64h case    1:*/		return 0x8206FE68;
		  /* 8206FE68h */ case    2:  		/* lwz R11, <#[R31 + 12816]> */
		/* 8206FE68h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003210) );
		/* 8206FE68h case    2:*/		return 0x8206FE6C;
		  /* 8206FE6Ch */ case    3:  		/* lwz R9, <#[R31 + 13104]> */
		/* 8206FE6Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003330) );
		/* 8206FE6Ch case    3:*/		return 0x8206FE70;
		  /* 8206FE70h */ case    4:  		/* cmplw CR6, R9, R11 */
		/* 8206FE70h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8206FE70h case    4:*/		return 0x8206FE74;
		  /* 8206FE74h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8206FE74h case    5:*/		if ( regs.CR[6].eq ) { return 0x8206FE80;  }
		/* 8206FE74h case    5:*/		return 0x8206FE78;
		  /* 8206FE78h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8206FE78h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206FE78h case    6:*/		return 0x8206FE7C;
		  /* 8206FE7Ch */ case    7:  		/* bc 4, CR6_EQ, 108 */
		/* 8206FE7Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x8206FEE8;  }
		/* 8206FE7Ch case    7:*/		return 0x8206FE80;
	}
	return 0x8206FE80;
} // Block from 8206FE60h-8206FE80h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206FE80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FE80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FE80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FE80);
		  /* 8206FE80h */ case    0:  		/* lwz R11, <#[R31 + 12820]> */
		/* 8206FE80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003214) );
		/* 8206FE80h case    0:*/		return 0x8206FE84;
		  /* 8206FE84h */ case    1:  		/* lwz R9, <#[R31 + 13108]> */
		/* 8206FE84h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003334) );
		/* 8206FE84h case    1:*/		return 0x8206FE88;
		  /* 8206FE88h */ case    2:  		/* cmplw CR6, R9, R11 */
		/* 8206FE88h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8206FE88h case    2:*/		return 0x8206FE8C;
		  /* 8206FE8Ch */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8206FE8Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8206FE98;  }
		/* 8206FE8Ch case    3:*/		return 0x8206FE90;
		  /* 8206FE90h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206FE90h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206FE90h case    4:*/		return 0x8206FE94;
		  /* 8206FE94h */ case    5:  		/* bc 4, CR6_EQ, 84 */
		/* 8206FE94h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206FEE8;  }
		/* 8206FE94h case    5:*/		return 0x8206FE98;
	}
	return 0x8206FE98;
} // Block from 8206FE80h-8206FE98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206FE98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FE98);
		  /* 8206FE98h */ case    0:  		/* lwz R11, <#[R31 + 12824]> */
		/* 8206FE98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003218) );
		/* 8206FE98h case    0:*/		return 0x8206FE9C;
		  /* 8206FE9Ch */ case    1:  		/* lwz R9, <#[R31 + 13112]> */
		/* 8206FE9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003338) );
		/* 8206FE9Ch case    1:*/		return 0x8206FEA0;
		  /* 8206FEA0h */ case    2:  		/* cmplw CR6, R9, R11 */
		/* 8206FEA0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8206FEA0h case    2:*/		return 0x8206FEA4;
		  /* 8206FEA4h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8206FEA4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206FEB0;  }
		/* 8206FEA4h case    3:*/		return 0x8206FEA8;
		  /* 8206FEA8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206FEA8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206FEA8h case    4:*/		return 0x8206FEAC;
		  /* 8206FEACh */ case    5:  		/* bc 4, CR6_EQ, 60 */
		/* 8206FEACh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206FEE8;  }
		/* 8206FEACh case    5:*/		return 0x8206FEB0;
	}
	return 0x8206FEB0;
} // Block from 8206FE98h-8206FEB0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206FEB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FEB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FEB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FEB0);
		  /* 8206FEB0h */ case    0:  		/* lwz R11, <#[R31 + 12828]> */
		/* 8206FEB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000321C) );
		/* 8206FEB0h case    0:*/		return 0x8206FEB4;
		  /* 8206FEB4h */ case    1:  		/* lwz R9, <#[R31 + 13116]> */
		/* 8206FEB4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000333C) );
		/* 8206FEB4h case    1:*/		return 0x8206FEB8;
		  /* 8206FEB8h */ case    2:  		/* cmplw CR6, R9, R11 */
		/* 8206FEB8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8206FEB8h case    2:*/		return 0x8206FEBC;
		  /* 8206FEBCh */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8206FEBCh case    3:*/		if ( regs.CR[6].eq ) { return 0x8206FEC8;  }
		/* 8206FEBCh case    3:*/		return 0x8206FEC0;
		  /* 8206FEC0h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206FEC0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206FEC0h case    4:*/		return 0x8206FEC4;
		  /* 8206FEC4h */ case    5:  		/* bc 4, CR6_EQ, 36 */
		/* 8206FEC4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206FEE8;  }
		/* 8206FEC4h case    5:*/		return 0x8206FEC8;
	}
	return 0x8206FEC8;
} // Block from 8206FEB0h-8206FEC8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206FEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FEC8);
		  /* 8206FEC8h */ case    0:  		/* lwz R11, <#[R31 + 12832]> */
		/* 8206FEC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003220) );
		/* 8206FEC8h case    0:*/		return 0x8206FECC;
		  /* 8206FECCh */ case    1:  		/* lwz R9, <#[R31 + 13120]> */
		/* 8206FECCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003340) );
		/* 8206FECCh case    1:*/		return 0x8206FED0;
		  /* 8206FED0h */ case    2:  		/* cmplw CR6, R9, R11 */
		/* 8206FED0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8206FED0h case    2:*/		return 0x8206FED4;
		  /* 8206FED4h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8206FED4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206FEE0;  }
		/* 8206FED4h case    3:*/		return 0x8206FED8;
		  /* 8206FED8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206FED8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206FED8h case    4:*/		return 0x8206FEDC;
		  /* 8206FEDCh */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 8206FEDCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206FEE8;  }
		/* 8206FEDCh case    5:*/		return 0x8206FEE0;
	}
	return 0x8206FEE0;
} // Block from 8206FEC8h-8206FEE0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206FEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FEE0);
		  /* 8206FEE0h */ case    0:  		/* li R11, 1 */
		/* 8206FEE0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206FEE0h case    0:*/		return 0x8206FEE4;
		  /* 8206FEE4h */ case    1:  		/* b 8 */
		/* 8206FEE4h case    1:*/		return 0x8206FEEC;
		/* 8206FEE4h case    1:*/		return 0x8206FEE8;
	}
	return 0x8206FEE8;
} // Block from 8206FEE0h-8206FEE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206FEE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FEE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FEE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FEE8);
		  /* 8206FEE8h */ case    0:  		/* li R11, 0 */
		/* 8206FEE8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206FEE8h case    0:*/		return 0x8206FEEC;
	}
	return 0x8206FEEC;
} // Block from 8206FEE8h-8206FEECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206FEECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FEEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FEEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FEEC);
		  /* 8206FEECh */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8206FEECh case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8206FEECh case    0:*/		return 0x8206FEF0;
	}
	return 0x8206FEF0;
} // Block from 8206FEECh-8206FEF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206FEF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FEF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FEF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FEF0);
		  /* 8206FEF0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8206FEF0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8206FEF0h case    0:*/		return 0x8206FEF4;
		  /* 8206FEF4h */ case    1:  		/* bc 4, CR0_EQ, 64 */
		/* 8206FEF4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8206FF34;  }
		/* 8206FEF4h case    1:*/		return 0x8206FEF8;
		  /* 8206FEF8h */ case    2:  		/* mr R10, R15 */
		/* 8206FEF8h case    2:*/		regs.R10 = regs.R15;
		/* 8206FEF8h case    2:*/		return 0x8206FEFC;
		  /* 8206FEFCh */ case    3:  		/* stw R18, <#[R1 + 116]> */
		/* 8206FEFCh case    3:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000074) );
		/* 8206FEFCh case    3:*/		return 0x8206FF00;
		  /* 8206FF00h */ case    4:  		/* mr R8, R16 */
		/* 8206FF00h case    4:*/		regs.R8 = regs.R16;
		/* 8206FF00h case    4:*/		return 0x8206FF04;
		  /* 8206FF04h */ case    5:  		/* stw R14, <#[R1 + 108]> */
		/* 8206FF04h case    5:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206FF04h case    5:*/		return 0x8206FF08;
		  /* 8206FF08h */ case    6:  		/* mr R7, R23 */
		/* 8206FF08h case    6:*/		regs.R7 = regs.R23;
		/* 8206FF08h case    6:*/		return 0x8206FF0C;
		  /* 8206FF0Ch */ case    7:  		/* stw R17, <#[R1 + 100]> */
		/* 8206FF0Ch case    7:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x00000064) );
		/* 8206FF0Ch case    7:*/		return 0x8206FF10;
		  /* 8206FF10h */ case    8:  		/* mr R6, R24 */
		/* 8206FF10h case    8:*/		regs.R6 = regs.R24;
		/* 8206FF10h case    8:*/		return 0x8206FF14;
		  /* 8206FF14h */ case    9:  		/* stw R19, <#[R1 + 92]> */
		/* 8206FF14h case    9:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206FF14h case    9:*/		return 0x8206FF18;
		  /* 8206FF18h */ case   10:  		/* mr R5, R26 */
		/* 8206FF18h case   10:*/		regs.R5 = regs.R26;
		/* 8206FF18h case   10:*/		return 0x8206FF1C;
		  /* 8206FF1Ch */ case   11:  		/* stw R21, <#[R1 + 84]> */
		/* 8206FF1Ch case   11:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000054) );
		/* 8206FF1Ch case   11:*/		return 0x8206FF20;
		  /* 8206FF20h */ case   12:  		/* mr R4, R25 */
		/* 8206FF20h case   12:*/		regs.R4 = regs.R25;
		/* 8206FF20h case   12:*/		return 0x8206FF24;
		  /* 8206FF24h */ case   13:  		/* fmr FR1, FR31 */
		/* 8206FF24h case   13:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8206FF24h case   13:*/		return 0x8206FF28;
		  /* 8206FF28h */ case   14:  		/* mr R3, R31 */
		/* 8206FF28h case   14:*/		regs.R3 = regs.R31;
		/* 8206FF28h case   14:*/		return 0x8206FF2C;
		  /* 8206FF2Ch */ case   15:  		/* bl -1556 */
		/* 8206FF2Ch case   15:*/		regs.LR = 0x8206FF30; return 0x8206F918;
		/* 8206FF2Ch case   15:*/		return 0x8206FF30;
		  /* 8206FF30h */ case   16:  		/* b 480 */
		/* 8206FF30h case   16:*/		return 0x82070110;
		/* 8206FF30h case   16:*/		return 0x8206FF34;
	}
	return 0x8206FF34;
} // Block from 8206FEF0h-8206FF34h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8206FF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FF34);
		  /* 8206FF34h */ case    0:  		/* lbz R11, <#[R31 + 11071]> */
		/* 8206FF34h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3F) );
		/* 8206FF34h case    0:*/		return 0x8206FF38;
		  /* 8206FF38h */ case    1:  		/* lwz R20, <#[R31 + 13084]> */
		/* 8206FF38h case    1:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R31 + 0x0000331C) );
		/* 8206FF38h case    1:*/		return 0x8206FF3C;
		  /* 8206FF3Ch */ case    2:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 8206FF3Ch case    2:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 8206FF3Ch case    2:*/		return 0x8206FF40;
		  /* 8206FF40h */ case    3:  		/* bc 12, CR0_EQ, 180 */
		/* 8206FF40h case    3:*/		if ( regs.CR[0].eq ) { return 0x8206FFF4;  }
		/* 8206FF40h case    3:*/		return 0x8206FF44;
		  /* 8206FF44h */ case    4:  		/* rlwinm. R11, R10, 0, 25, 25 */
		/* 8206FF44h case    4:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R10);
		/* 8206FF44h case    4:*/		return 0x8206FF48;
		  /* 8206FF48h */ case    5:  		/* bc 12, CR0_EQ, 172 */
		/* 8206FF48h case    5:*/		if ( regs.CR[0].eq ) { return 0x8206FFF4;  }
		/* 8206FF48h case    5:*/		return 0x8206FF4C;
		  /* 8206FF4Ch */ case    6:  		/* lis R12, 5461 */
		/* 8206FF4Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R12,0x1555);
		/* 8206FF4Ch case    6:*/		return 0x8206FF50;
		  /* 8206FF50h */ case    7:  		/* ori R12, R12, 21845 */
		/* 8206FF50h case    7:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x5555);
		/* 8206FF50h case    7:*/		return 0x8206FF54;
		  /* 8206FF54h */ case    8:  		/* and. R30, R20, R12 */
		/* 8206FF54h case    8:*/		cpu::op::and<1>(regs,&regs.R30,regs.R20,regs.R12);
		/* 8206FF54h case    8:*/		return 0x8206FF58;
		  /* 8206FF58h */ case    9:  		/* bc 12, CR0_EQ, 156 */
		/* 8206FF58h case    9:*/		if ( regs.CR[0].eq ) { return 0x8206FFF4;  }
		/* 8206FF58h case    9:*/		return 0x8206FF5C;
		  /* 8206FF5Ch */ case   10:  		/* cmplwi CR6, R29, 0 */
		/* 8206FF5Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8206FF5Ch case   10:*/		return 0x8206FF60;
		  /* 8206FF60h */ case   11:  		/* bc 12, CR6_EQ, 136 */
		/* 8206FF60h case   11:*/		if ( regs.CR[6].eq ) { return 0x8206FFE8;  }
		/* 8206FF60h case   11:*/		return 0x8206FF64;
		  /* 8206FF64h */ case   12:  		/* lwz R11, <#[R31 + 48]> */
		/* 8206FF64h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8206FF64h case   12:*/		return 0x8206FF68;
		  /* 8206FF68h */ case   13:  		/* lwz R10, <#[R31 + 56]> */
		/* 8206FF68h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 8206FF68h case   13:*/		return 0x8206FF6C;
		  /* 8206FF6Ch */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 8206FF6Ch case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8206FF6Ch case   14:*/		return 0x8206FF70;
		  /* 8206FF70h */ case   15:  		/* bc 4, CR6_GT, 16 */
		/* 8206FF70h case   15:*/		if ( !regs.CR[6].gt ) { return 0x8206FF80;  }
		/* 8206FF70h case   15:*/		return 0x8206FF74;
		  /* 8206FF74h */ case   16:  		/* mr R3, R31 */
		/* 8206FF74h case   16:*/		regs.R3 = regs.R31;
		/* 8206FF74h case   16:*/		return 0x8206FF78;
		  /* 8206FF78h */ case   17:  		/* bl 16784 */
		/* 8206FF78h case   17:*/		regs.LR = 0x8206FF7C; return 0x82074108;
		/* 8206FF78h case   17:*/		return 0x8206FF7C;
		  /* 8206FF7Ch */ case   18:  		/* mr R11, R3 */
		/* 8206FF7Ch case   18:*/		regs.R11 = regs.R3;
		/* 8206FF7Ch case   18:*/		return 0x8206FF80;
	}
	return 0x8206FF80;
} // Block from 8206FF34h-8206FF80h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206FF80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FF80);
		  /* 8206FF80h */ case    0:  		/* lis R10, -16384 */
		/* 8206FF80h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC000);
		/* 8206FF80h case    0:*/		return 0x8206FF84;
		  /* 8206FF84h */ case    1:  		/* stw R27, <#[R1 + 116]> */
		/* 8206FF84h case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000074) );
		/* 8206FF84h case    1:*/		return 0x8206FF88;
		  /* 8206FF88h */ case    2:  		/* mr R9, R15 */
		/* 8206FF88h case    2:*/		regs.R9 = regs.R15;
		/* 8206FF88h case    2:*/		return 0x8206FF8C;
		  /* 8206FF8Ch */ case    3:  		/* stw R19, <#[R1 + 100]> */
		/* 8206FF8Ch case    3:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000064) );
		/* 8206FF8Ch case    3:*/		return 0x8206FF90;
		  /* 8206FF90h */ case    4:  		/* ori R10, R10, 24576 */
		/* 8206FF90h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x6000);
		/* 8206FF90h case    4:*/		return 0x8206FF94;
		  /* 8206FF94h */ case    5:  		/* stw R19, <#[R1 + 92]> */
		/* 8206FF94h case    5:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206FF94h case    5:*/		return 0x8206FF98;
	}
	return 0x8206FF98;
} // Block from 8206FF80h-8206FF98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206FF98h
// Function 'D3DDevice_SetTexture'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FF98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FF98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FF98);
		  /* 8206FF98h */ case    0:  		/* mr R8, R16 */
		/* 8206FF98h case    0:*/		regs.R8 = regs.R16;
		/* 8206FF98h case    0:*/		return 0x8206FF9C;
		  /* 8206FF9Ch */ case    1:  		/* stw R21, <#[R1 + 84]> */
		/* 8206FF9Ch case    1:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000054) );
		/* 8206FF9Ch case    1:*/		return 0x8206FFA0;
		  /* 8206FFA0h */ case    2:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206FFA0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206FFA0h case    2:*/		return 0x8206FFA4;
		  /* 8206FFA4h */ case    3:  		/* mr R3, R31 */
		/* 8206FFA4h case    3:*/		regs.R3 = regs.R31;
		/* 8206FFA4h case    3:*/		return 0x8206FFA8;
		  /* 8206FFA8h */ case    4:  		/* fmr FR1, FR31 */
		/* 8206FFA8h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8206FFA8h case    4:*/		return 0x8206FFAC;
		  /* 8206FFACh */ case    5:  		/* stw R27, <#[R1 + 108]> */
		/* 8206FFACh case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206FFACh case    5:*/		return 0x8206FFB0;
		  /* 8206FFB0h */ case    6:  		/* stwu R30, <#[R11 + 4]> */
		/* 8206FFB0h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206FFB0h case    6:*/		return 0x8206FFB4;
		  /* 8206FFB4h */ case    7:  		/* lwz R10, <#[R31 + 13548]> */
		/* 8206FFB4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000034EC) );
		/* 8206FFB4h case    7:*/		return 0x8206FFB8;
		  /* 8206FFB8h */ case    8:  		/* lwz R6, <#[R31 + 13552]> */
		/* 8206FFB8h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x000034F0) );
		/* 8206FFB8h case    8:*/		return 0x8206FFBC;
		  /* 8206FFBCh */ case    9:  		/* rlwimi R9, R10, 18, 0, 13 */
		/* 8206FFBCh case    9:*/		cpu::op::rlwimi<0,18,0,13>(regs,&regs.R9,regs.R10);
		/* 8206FFBCh case    9:*/		return 0x8206FFC0;
		  /* 8206FFC0h */ case   10:  		/* lwz R4, <#[R31 + 13368]> */
		/* 8206FFC0h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00003438) );
		/* 8206FFC0h case   10:*/		return 0x8206FFC4;
		  /* 8206FFC4h */ case   11:  		/* lwz R5, <#[R31 + 13372]> */
		/* 8206FFC4h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000343C) );
		/* 8206FFC4h case   11:*/		return 0x8206FFC8;
		  /* 8206FFC8h */ case   12:  		/* stw R11, <#[R31 + 48]> */
		/* 8206FFC8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8206FFC8h case   12:*/		return 0x8206FFCC;
		  /* 8206FFCCh */ case   13:  		/* rlwinm R10, R9, 0, 0, 17 */
		/* 8206FFCCh case   13:*/		cpu::op::rlwinm<0,0,0,17>(regs,&regs.R10,regs.R9);
		/* 8206FFCCh case   13:*/		return 0x8206FFD0;
		  /* 8206FFD0h */ case   14:  		/* subf R7, R5, R23 */
		/* 8206FFD0h case   14:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R5,regs.R23);
		/* 8206FFD0h case   14:*/		return 0x8206FFD4;
		  /* 8206FFD4h */ case   15:  		/* rlwimi R10, R6, 0, 18, 31 */
		/* 8206FFD4h case   15:*/		cpu::op::rlwimi<0,0,18,31>(regs,&regs.R10,regs.R6);
		/* 8206FFD4h case   15:*/		return 0x8206FFD8;
		  /* 8206FFD8h */ case   16:  		/* subf R6, R4, R24 */
		/* 8206FFD8h case   16:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R4,regs.R24);
		/* 8206FFD8h case   16:*/		return 0x8206FFDC;
		  /* 8206FFDCh */ case   17:  		/* subf R5, R5, R26 */
		/* 8206FFDCh case   17:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R5,regs.R26);
		/* 8206FFDCh case   17:*/		return 0x8206FFE0;
		  /* 8206FFE0h */ case   18:  		/* subf R4, R4, R25 */
		/* 8206FFE0h case   18:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R4,regs.R25);
		/* 8206FFE0h case   18:*/		return 0x8206FFE4;
		  /* 8206FFE4h */ case   19:  		/* bl -1740 */
		/* 8206FFE4h case   19:*/		regs.LR = 0x8206FFE8; return 0x8206F918;
		/* 8206FFE4h case   19:*/		return 0x8206FFE8;
	}
	return 0x8206FFE8;
} // Block from 8206FF98h-8206FFE8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8206FFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FFE8);
		  /* 8206FFE8h */ case    0:  		/* lis R12, -5462 */
		/* 8206FFE8h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFEAAA);
		/* 8206FFE8h case    0:*/		return 0x8206FFEC;
		  /* 8206FFECh */ case    1:  		/* ori R12, R12, 43690 */
		/* 8206FFECh case    1:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xAAAA);
		/* 8206FFECh case    1:*/		return 0x8206FFF0;
		  /* 8206FFF0h */ case    2:  		/* and R20, R20, R12 */
		/* 8206FFF0h case    2:*/		cpu::op::and<0>(regs,&regs.R20,regs.R20,regs.R12);
		/* 8206FFF0h case    2:*/		return 0x8206FFF4;
	}
	return 0x8206FFF4;
} // Block from 8206FFE8h-8206FFF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206FFF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206FFF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206FFF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206FFF4);
		  /* 8206FFF4h */ case    0:  		/* lwz R11, <#[R31 + 13124]> */
		/* 8206FFF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003344) );
		/* 8206FFF4h case    0:*/		return 0x8206FFF8;
		  /* 8206FFF8h */ case    1:  		/* li R22, 0 */
		/* 8206FFF8h case    1:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 8206FFF8h case    1:*/		return 0x8206FFFC;
		  /* 8206FFFCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8206FFFCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206FFFCh case    2:*/		return 0x82070000;
		  /* 82070000h */ case    3:  		/* bc 4, CR6_GT, 272 */
		/* 82070000h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82070110;  }
		/* 82070000h case    3:*/		return 0x82070004;
		  /* 82070004h */ case    4:  		/* li R23, 0 */
		/* 82070004h case    4:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82070004h case    4:*/		return 0x82070008;
		  /* 82070008h */ case    5:  		/* addi R28, R31, 13372 */
		/* 82070008h case    5:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x343C);
		/* 82070008h case    5:*/		return 0x8207000C;
		  /* 8207000Ch */ case    6:  		/* addi R24, R31, 13132 */
		/* 8207000Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R31,0x334C);
		/* 8207000Ch case    6:*/		return 0x82070010;
		  /* 82070010h */ case    7:  		/* b 12 */
		/* 82070010h case    7:*/		return 0x8207001C;
		/* 82070010h case    7:*/		return 0x82070014;
		  /* 82070014h */ case    8:  		/* lwz R25, <#[R1 + 348]> */
		/* 82070014h case    8:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x0000015C) );
		/* 82070014h case    8:*/		return 0x82070018;
		  /* 82070018h */ case    9:  		/* lwz R26, <#[R1 + 356]> */
		/* 82070018h case    9:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000164) );
		/* 82070018h case    9:*/		return 0x8207001C;
	}
	return 0x8207001C;
} // Block from 8206FFF4h-8207001Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8207001Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207001C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207001C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207001C);
		  /* 8207001Ch */ case    0:  		/* lwz R11, <#[R24 - 4]> */
		/* 8207001Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0xFFFFFFFC) );
		/* 8207001Ch case    0:*/		return 0x82070020;
		  /* 82070020h */ case    1:  		/* cmpw CR6, R25, R11 */
		/* 82070020h case    1:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R11);
		/* 82070020h case    1:*/		return 0x82070024;
		  /* 82070024h */ case    2:  		/* bc 12, CR6_GT, 8 */
		/* 82070024h case    2:*/		if ( regs.CR[6].gt ) { return 0x8207002C;  }
		/* 82070024h case    2:*/		return 0x82070028;
		  /* 82070028h */ case    3:  		/* mr R25, R11 */
		/* 82070028h case    3:*/		regs.R25 = regs.R11;
		/* 82070028h case    3:*/		return 0x8207002C;
	}
	return 0x8207002C;
} // Block from 8207001Ch-8207002Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8207002Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207002C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207002C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207002C);
		  /* 8207002Ch */ case    0:  		/* lwz R11, <#[R24]> */
		/* 8207002Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8207002Ch case    0:*/		return 0x82070030;
		  /* 82070030h */ case    1:  		/* cmpw CR6, R26, R11 */
		/* 82070030h case    1:*/		cpu::op::cmpw<6>(regs,regs.R26,regs.R11);
		/* 82070030h case    1:*/		return 0x82070034;
		  /* 82070034h */ case    2:  		/* bc 12, CR6_GT, 8 */
		/* 82070034h case    2:*/		if ( regs.CR[6].gt ) { return 0x8207003C;  }
		/* 82070034h case    2:*/		return 0x82070038;
		  /* 82070038h */ case    3:  		/* mr R26, R11 */
		/* 82070038h case    3:*/		regs.R26 = regs.R11;
		/* 82070038h case    3:*/		return 0x8207003C;
	}
	return 0x8207003C;
} // Block from 8207002Ch-8207003Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8207003Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207003C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207003C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207003C);
		  /* 8207003Ch */ case    0:  		/* lwz R11, <#[R24 + 4]> */
		/* 8207003Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8207003Ch case    0:*/		return 0x82070040;
		  /* 82070040h */ case    1:  		/* lwz R27, <#[R1 + 364]> */
		/* 82070040h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x0000016C) );
		/* 82070040h case    1:*/		return 0x82070044;
		  /* 82070044h */ case    2:  		/* cmpw CR6, R27, R11 */
		/* 82070044h case    2:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R11);
		/* 82070044h case    2:*/		return 0x82070048;
		  /* 82070048h */ case    3:  		/* bc 12, CR6_LT, 8 */
		/* 82070048h case    3:*/		if ( regs.CR[6].lt ) { return 0x82070050;  }
		/* 82070048h case    3:*/		return 0x8207004C;
		  /* 8207004Ch */ case    4:  		/* mr R27, R11 */
		/* 8207004Ch case    4:*/		regs.R27 = regs.R11;
		/* 8207004Ch case    4:*/		return 0x82070050;
	}
	return 0x82070050;
} // Block from 8207003Ch-82070050h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82070050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070050);
		  /* 82070050h */ case    0:  		/* lwz R29, <#[R24 + 8]> */
		/* 82070050h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R24 + 0x00000008) );
		/* 82070050h case    0:*/		return 0x82070054;
		  /* 82070054h */ case    1:  		/* lwz R11, <#[R1 + 372]> */
		/* 82070054h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000174) );
		/* 82070054h case    1:*/		return 0x82070058;
		  /* 82070058h */ case    2:  		/* cmpw CR6, R11, R29 */
		/* 82070058h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R29);
		/* 82070058h case    2:*/		return 0x8207005C;
		  /* 8207005Ch */ case    3:  		/* bc 4, CR6_LT, 8 */
		/* 8207005Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x82070064;  }
		/* 8207005Ch case    3:*/		return 0x82070060;
		  /* 82070060h */ case    4:  		/* mr R29, R11 */
		/* 82070060h case    4:*/		regs.R29 = regs.R11;
		/* 82070060h case    4:*/		return 0x82070064;
	}
	return 0x82070064;
} // Block from 82070050h-82070064h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82070064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070064);
		  /* 82070064h */ case    0:  		/* cmpw CR6, R25, R27 */
		/* 82070064h case    0:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R27);
		/* 82070064h case    0:*/		return 0x82070068;
		  /* 82070068h */ case    1:  		/* bc 4, CR6_LT, 140 */
		/* 82070068h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820700F4;  }
		/* 82070068h case    1:*/		return 0x8207006C;
		  /* 8207006Ch */ case    2:  		/* cmpw CR6, R26, R29 */
		/* 8207006Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R26,regs.R29);
		/* 8207006Ch case    2:*/		return 0x82070070;
		  /* 82070070h */ case    3:  		/* bc 4, CR6_LT, 132 */
		/* 82070070h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820700F4;  }
		/* 82070070h case    3:*/		return 0x82070074;
		  /* 82070074h */ case    4:  		/* li R11, 3 */
		/* 82070074h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 82070074h case    4:*/		return 0x82070078;
		  /* 82070078h */ case    5:  		/* slw R11, R11, R23 */
		/* 82070078h case    5:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R23);
		/* 82070078h case    5:*/		return 0x8207007C;
		  /* 8207007Ch */ case    6:  		/* and. R30, R11, R20 */
		/* 8207007Ch case    6:*/		cpu::op::and<1>(regs,&regs.R30,regs.R11,regs.R20);
		/* 8207007Ch case    6:*/		return 0x82070080;
		  /* 82070080h */ case    7:  		/* bc 12, CR0_EQ, 116 */
		/* 82070080h case    7:*/		if ( regs.CR[0].eq ) { return 0x820700F4;  }
		/* 82070080h case    7:*/		return 0x82070084;
		  /* 82070084h */ case    8:  		/* lwz R11, <#[R31 + 48]> */
		/* 82070084h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82070084h case    8:*/		return 0x82070088;
		  /* 82070088h */ case    9:  		/* lwz R10, <#[R31 + 56]> */
		/* 82070088h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 82070088h case    9:*/		return 0x8207008C;
		  /* 8207008Ch */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 8207008Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8207008Ch case   10:*/		return 0x82070090;
		  /* 82070090h */ case   11:  		/* bc 4, CR6_GT, 16 */
		/* 82070090h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820700A0;  }
		/* 82070090h case   11:*/		return 0x82070094;
		  /* 82070094h */ case   12:  		/* mr R3, R31 */
		/* 82070094h case   12:*/		regs.R3 = regs.R31;
		/* 82070094h case   12:*/		return 0x82070098;
		  /* 82070098h */ case   13:  		/* bl 16496 */
		/* 82070098h case   13:*/		regs.LR = 0x8207009C; return 0x82074108;
		/* 82070098h case   13:*/		return 0x8207009C;
		  /* 8207009Ch */ case   14:  		/* mr R11, R3 */
		/* 8207009Ch case   14:*/		regs.R11 = regs.R3;
		/* 8207009Ch case   14:*/		return 0x820700A0;
	}
	return 0x820700A0;
} // Block from 82070064h-820700A0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820700A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820700A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820700A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820700A0);
		  /* 820700A0h */ case    0:  		/* lis R9, -16384 */
		/* 820700A0h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC000);
		/* 820700A0h case    0:*/		return 0x820700A4;
		  /* 820700A4h */ case    1:  		/* stw R18, <#[R1 + 116]> */
		/* 820700A4h case    1:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000074) );
		/* 820700A4h case    1:*/		return 0x820700A8;
		  /* 820700A8h */ case    2:  		/* mr R10, R15 */
		/* 820700A8h case    2:*/		regs.R10 = regs.R15;
		/* 820700A8h case    2:*/		return 0x820700AC;
		  /* 820700ACh */ case    3:  		/* stw R14, <#[R1 + 108]> */
		/* 820700ACh case    3:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x0000006C) );
		/* 820700ACh case    3:*/		return 0x820700B0;
		  /* 820700B0h */ case    4:  		/* ori R9, R9, 24576 */
		/* 820700B0h case    4:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x6000);
		/* 820700B0h case    4:*/		return 0x820700B4;
		  /* 820700B4h */ case    5:  		/* stw R17, <#[R1 + 100]> */
		/* 820700B4h case    5:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x00000064) );
		/* 820700B4h case    5:*/		return 0x820700B8;
		  /* 820700B8h */ case    6:  		/* mr R8, R16 */
		/* 820700B8h case    6:*/		regs.R8 = regs.R16;
		/* 820700B8h case    6:*/		return 0x820700BC;
		  /* 820700BCh */ case    7:  		/* stw R19, <#[R1 + 92]> */
		/* 820700BCh case    7:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x0000005C) );
		/* 820700BCh case    7:*/		return 0x820700C0;
		  /* 820700C0h */ case    8:  		/* stwu R9, <#[R11 + 4]> */
		/* 820700C0h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820700C0h case    8:*/		return 0x820700C4;
		  /* 820700C4h */ case    9:  		/* mr R3, R31 */
		/* 820700C4h case    9:*/		regs.R3 = regs.R31;
		/* 820700C4h case    9:*/		return 0x820700C8;
		  /* 820700C8h */ case   10:  		/* stw R21, <#[R1 + 84]> */
		/* 820700C8h case   10:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x00000054) );
		/* 820700C8h case   10:*/		return 0x820700CC;
		  /* 820700CCh */ case   11:  		/* fmr FR1, FR31 */
		/* 820700CCh case   11:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820700CCh case   11:*/		return 0x820700D0;
		  /* 820700D0h */ case   12:  		/* stwu R30, <#[R11 + 4]> */
		/* 820700D0h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820700D0h case   12:*/		return 0x820700D4;
		  /* 820700D4h */ case   13:  		/* stw R11, <#[R31 + 48]> */
		/* 820700D4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820700D4h case   13:*/		return 0x820700D8;
		  /* 820700D8h */ case   14:  		/* lwz R9, <#[R28]> */
		/* 820700D8h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 820700D8h case   14:*/		return 0x820700DC;
		  /* 820700DCh */ case   15:  		/* subf R7, R9, R29 */
		/* 820700DCh case   15:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R9,regs.R29);
		/* 820700DCh case   15:*/		return 0x820700E0;
		  /* 820700E0h */ case   16:  		/* lwz R11, <#[R28 - 4]> */
		/* 820700E0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFFFFFC) );
		/* 820700E0h case   16:*/		return 0x820700E4;
		  /* 820700E4h */ case   17:  		/* subf R5, R9, R26 */
		/* 820700E4h case   17:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R9,regs.R26);
		/* 820700E4h case   17:*/		return 0x820700E8;
		  /* 820700E8h */ case   18:  		/* subf R6, R11, R27 */
		/* 820700E8h case   18:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R11,regs.R27);
		/* 820700E8h case   18:*/		return 0x820700EC;
		  /* 820700ECh */ case   19:  		/* subf R4, R11, R25 */
		/* 820700ECh case   19:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R11,regs.R25);
		/* 820700ECh case   19:*/		return 0x820700F0;
		  /* 820700F0h */ case   20:  		/* bl -2008 */
		/* 820700F0h case   20:*/		regs.LR = 0x820700F4; return 0x8206F918;
		/* 820700F0h case   20:*/		return 0x820700F4;
	}
	return 0x820700F4;
} // Block from 820700A0h-820700F4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820700F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820700F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820700F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820700F4);
		  /* 820700F4h */ case    0:  		/* lwz R11, <#[R31 + 13124]> */
		/* 820700F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003344) );
		/* 820700F4h case    0:*/		return 0x820700F8;
		  /* 820700F8h */ case    1:  		/* addi R22, R22, 1 */
		/* 820700F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 820700F8h case    1:*/		return 0x820700FC;
		  /* 820700FCh */ case    2:  		/* addi R24, R24, 16 */
		/* 820700FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x10);
		/* 820700FCh case    2:*/		return 0x82070100;
		  /* 82070100h */ case    3:  		/* addi R23, R23, 2 */
		/* 82070100h case    3:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x2);
		/* 82070100h case    3:*/		return 0x82070104;
		  /* 82070104h */ case    4:  		/* addi R28, R28, 8 */
		/* 82070104h case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 82070104h case    4:*/		return 0x82070108;
		  /* 82070108h */ case    5:  		/* cmplw CR6, R22, R11 */
		/* 82070108h case    5:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82070108h case    5:*/		return 0x8207010C;
		  /* 8207010Ch */ case    6:  		/* bc 12, CR6_LT, -248 */
		/* 8207010Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x82070014;  }
		/* 8207010Ch case    6:*/		return 0x82070110;
	}
	return 0x82070110;
} // Block from 820700F4h-82070110h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82070110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070110);
		  /* 82070110h */ case    0:  		/* addi R1, R1, 304 */
		/* 82070110h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x130);
		/* 82070110h case    0:*/		return 0x82070114;
		  /* 82070114h */ case    1:  		/* lfd FR31, <#[R1 - 160]> */
		/* 82070114h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 82070114h case    1:*/		return 0x82070118;
		  /* 82070118h */ case    2:  		/* b 135512 */
		/* 82070118h case    2:*/		return 0x82091270;
		/* 82070118h case    2:*/		return 0x8207011C;
		  /* 8207011Ch */ case    3:  		/* nop */
		/* 8207011Ch case    3:*/		cpu::op::nop();
		/* 8207011Ch case    3:*/		return 0x82070120;
	}
	return 0x82070120;
} // Block from 82070110h-82070120h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82070120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070120);
		  /* 82070120h */ case    0:  		/* mfspr R12, LR */
		/* 82070120h case    0:*/		regs.R12 = regs.LR;
		/* 82070120h case    0:*/		return 0x82070124;
		  /* 82070124h */ case    1:  		/* bl 135440 */
		/* 82070124h case    1:*/		regs.LR = 0x82070128; return 0x82091234;
		/* 82070124h case    1:*/		return 0x82070128;
	}
	return 0x82070128;
} // Block from 82070120h-82070128h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82070128h
// Function '?_ComputeDummyValue@@YAKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070128);
		  /* 82070128h */ case    0:  		/* stfd FR31, <#[R1 - 120]> */
		/* 82070128h case    0:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 82070128h case    0:*/		return 0x8207012C;
		  /* 8207012Ch */ case    1:  		/* stwu R1, <#[R1 - 256]> */
		/* 8207012Ch case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 8207012Ch case    1:*/		return 0x82070130;
		  /* 82070130h */ case    2:  		/* mr R31, R3 */
		/* 82070130h case    2:*/		regs.R31 = regs.R3;
		/* 82070130h case    2:*/		return 0x82070134;
		  /* 82070134h */ case    3:  		/* fmr FR31, FR1 */
		/* 82070134h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82070134h case    3:*/		return 0x82070138;
		  /* 82070138h */ case    4:  		/* mr R27, R4 */
		/* 82070138h case    4:*/		regs.R27 = regs.R4;
		/* 82070138h case    4:*/		return 0x8207013C;
		  /* 8207013Ch */ case    5:  		/* mr R23, R6 */
		/* 8207013Ch case    5:*/		regs.R23 = regs.R6;
		/* 8207013Ch case    5:*/		return 0x82070140;
	}
	return 0x82070140;
} // Block from 82070128h-82070140h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82070140h
// Function '?IsStereo3DValidationEnabled@@YAHXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070140);
		  /* 82070140h */ case    0:  		/* mr R22, R8 */
		/* 82070140h case    0:*/		regs.R22 = regs.R8;
		/* 82070140h case    0:*/		return 0x82070144;
		  /* 82070144h */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 82070144h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82070144h case    1:*/		return 0x82070148;
		  /* 82070148h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 82070148h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82070164;  }
		/* 82070148h case    2:*/		return 0x8207014C;
		  /* 8207014Ch */ case    3:  		/* lis R11, -32256 */
		/* 8207014Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8207014Ch case    3:*/		return 0x82070150;
		  /* 82070150h */ case    4:  		/* addi R10, R1, 112 */
		/* 82070150h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 82070150h case    4:*/		return 0x82070154;
		  /* 82070154h */ case    5:  		/* addi R11, R11, 1904 */
		/* 82070154h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x770);
		/* 82070154h case    5:*/		return 0x82070158;
		  /* 82070158h */ case    6:  		/* addi R23, R1, 112 */
		/* 82070158h case    6:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R1,0x70);
		/* 82070158h case    6:*/		return 0x8207015C;
		  /* 8207015Ch */ case    7:  		/* lvx VR63, <#[R11]> */
		/* 8207015Ch case    7:*/		cpu::mem::lvx( regs, &regs.VR63, (uint32)(regs.R11 + 0x00000000) );
		/* 8207015Ch case    7:*/		return 0x82070160;
		  /* 82070160h */ case    8:  		/* stvx VR63, <#[R10]> */
		/* 82070160h case    8:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R10 + 0x00000000) );
		/* 82070160h case    8:*/		return 0x82070164;
	}
	return 0x82070164;
} // Block from 82070140h-82070164h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82070164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070164);
		  /* 82070164h */ case    0:  		/* lwz R11, <#[R31 + 12832]> */
		/* 82070164h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003220) );
		/* 82070164h case    0:*/		return 0x82070168;
		  /* 82070168h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82070168h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82070168h case    1:*/		return 0x8207016C;
		  /* 8207016Ch */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 8207016Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82070178;  }
		/* 8207016Ch case    2:*/		return 0x82070170;
		  /* 82070170h */ case    3:  		/* rlwinm. R27, R27, 0, 28, 23 */
		/* 82070170h case    3:*/		cpu::op::rlwinm<1,0,28,23>(regs,&regs.R27,regs.R27);
		/* 82070170h case    3:*/		return 0x82070174;
		  /* 82070174h */ case    4:  		/* bc 12, CR0_EQ, 1568 */
		/* 82070174h case    4:*/		if ( regs.CR[0].eq ) { return 0x82070794;  }
		/* 82070174h case    4:*/		return 0x82070178;
	}
	return 0x82070178;
} // Block from 82070164h-82070178h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82070178h
// Function '?VerticalBlankInterrupt@D3D@@YAXPAVCDevice@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070178);
		  /* 82070178h */ case    0:  		/* lfs FR0, <#[R31 + 13024]> */
		/* 82070178h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x000032E0) );
		/* 82070178h case    0:*/		return 0x8207017C;
		  /* 8207017Ch */ case    1:  		/* lwz R11, <#[R5]> */
		/* 8207017Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8207017Ch case    1:*/		return 0x82070180;
		  /* 82070180h */ case    2:  		/* lfs FR13, <#[R31 + 13028]> */
		/* 82070180h case    2:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R31 + 0x000032E4) );
		/* 82070180h case    2:*/		return 0x82070184;
		  /* 82070184h */ case    3:  		/* fctiwz FR0, FR0 */
		/* 82070184h case    3:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82070184h case    3:*/		return 0x82070188;
		  /* 82070188h */ case    4:  		/* stfd FR0, <#[R1 + 96]> */
		/* 82070188h case    4:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 82070188h case    4:*/		return 0x8207018C;
		  /* 8207018Ch */ case    5:  		/* lwz R10, <#[R1 + 100]> */
		/* 8207018Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 8207018Ch case    5:*/		return 0x82070190;
		  /* 82070190h */ case    6:  		/* lfs FR12, <#[R31 + 13032]> */
		/* 82070190h case    6:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R31 + 0x000032E8) );
		/* 82070190h case    6:*/		return 0x82070194;
		  /* 82070194h */ case    7:  		/* fctiwz FR13, FR13 */
		/* 82070194h case    7:*/		cpu::op::fctiwz<0>(regs,&regs.FR13,regs.FR13);
		/* 82070194h case    7:*/		return 0x82070198;
		  /* 82070198h */ case    8:  		/* lfs FR11, <#[R31 + 13036]> */
		/* 82070198h case    8:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R31 + 0x000032EC) );
		/* 82070198h case    8:*/		return 0x8207019C;
		  /* 8207019Ch */ case    9:  		/* fctiwz FR12, FR12 */
		/* 8207019Ch case    9:*/		cpu::op::fctiwz<0>(regs,&regs.FR12,regs.FR12);
		/* 8207019Ch case    9:*/		return 0x820701A0;
		  /* 820701A0h */ case   10:  		/* stfd FR13, <#[R1 + 96]> */
		/* 820701A0h case   10:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000060) );
		/* 820701A0h case   10:*/		return 0x820701A4;
		  /* 820701A4h */ case   11:  		/* lwz R9, <#[R1 + 100]> */
		/* 820701A4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000064) );
		/* 820701A4h case   11:*/		return 0x820701A8;
		  /* 820701A8h */ case   12:  		/* fctiwz FR0, FR11 */
		/* 820701A8h case   12:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR11);
		/* 820701A8h case   12:*/		return 0x820701AC;
		  /* 820701ACh */ case   13:  		/* stfd FR12, <#[R1 + 104]> */
		/* 820701ACh case   13:*/		cpu::mem::store64f( regs, regs.FR12, (uint32)(regs.R1 + 0x00000068) );
		/* 820701ACh case   13:*/		return 0x820701B0;
		  /* 820701B0h */ case   14:  		/* stfd FR0, <#[R1 + 96]> */
		/* 820701B0h case   14:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 820701B0h case   14:*/		return 0x820701B4;
		  /* 820701B4h */ case   15:  		/* lwz R8, <#[R1 + 108]> */
		/* 820701B4h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000006C) );
		/* 820701B4h case   15:*/		return 0x820701B8;
		  /* 820701B8h */ case   16:  		/* lwz R7, <#[R1 + 100]> */
		/* 820701B8h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000064) );
		/* 820701B8h case   16:*/		return 0x820701BC;
		  /* 820701BCh */ case   17:  		/* cmpw CR6, R11, R10 */
		/* 820701BCh case   17:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820701BCh case   17:*/		return 0x820701C0;
		  /* 820701C0h */ case   18:  		/* mr R24, R11 */
		/* 820701C0h case   18:*/		regs.R24 = regs.R11;
		/* 820701C0h case   18:*/		return 0x820701C4;
		  /* 820701C4h */ case   19:  		/* bc 12, CR6_GT, 8 */
		/* 820701C4h case   19:*/		if ( regs.CR[6].gt ) { return 0x820701CC;  }
		/* 820701C4h case   19:*/		return 0x820701C8;
		  /* 820701C8h */ case   20:  		/* mr R24, R10 */
		/* 820701C8h case   20:*/		regs.R24 = regs.R10;
		/* 820701C8h case   20:*/		return 0x820701CC;
	}
	return 0x820701CC;
} // Block from 82070178h-820701CCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 820701CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820701CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820701CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820701CC);
		  /* 820701CCh */ case    0:  		/* lwz R11, <#[R5 + 4]> */
		/* 820701CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 820701CCh case    0:*/		return 0x820701D0;
		  /* 820701D0h */ case    1:  		/* cmpw CR6, R11, R9 */
		/* 820701D0h case    1:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 820701D0h case    1:*/		return 0x820701D4;
		  /* 820701D4h */ case    2:  		/* mr R25, R11 */
		/* 820701D4h case    2:*/		regs.R25 = regs.R11;
		/* 820701D4h case    2:*/		return 0x820701D8;
		  /* 820701D8h */ case    3:  		/* bc 12, CR6_GT, 8 */
		/* 820701D8h case    3:*/		if ( regs.CR[6].gt ) { return 0x820701E0;  }
		/* 820701D8h case    3:*/		return 0x820701DC;
		  /* 820701DCh */ case    4:  		/* mr R25, R9 */
		/* 820701DCh case    4:*/		regs.R25 = regs.R9;
		/* 820701DCh case    4:*/		return 0x820701E0;
	}
	return 0x820701E0;
} // Block from 820701CCh-820701E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820701E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820701E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820701E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820701E0);
		  /* 820701E0h */ case    0:  		/* lwz R11, <#[R5 + 8]> */
		/* 820701E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 820701E0h case    0:*/		return 0x820701E4;
		  /* 820701E4h */ case    1:  		/* add R10, R8, R10 */
		/* 820701E4h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 820701E4h case    1:*/		return 0x820701E8;
		  /* 820701E8h */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 820701E8h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820701E8h case    2:*/		return 0x820701EC;
		  /* 820701ECh */ case    3:  		/* mr R26, R11 */
		/* 820701ECh case    3:*/		regs.R26 = regs.R11;
		/* 820701ECh case    3:*/		return 0x820701F0;
		  /* 820701F0h */ case    4:  		/* bc 12, CR6_LT, 8 */
		/* 820701F0h case    4:*/		if ( regs.CR[6].lt ) { return 0x820701F8;  }
		/* 820701F0h case    4:*/		return 0x820701F4;
		  /* 820701F4h */ case    5:  		/* mr R26, R10 */
		/* 820701F4h case    5:*/		regs.R26 = regs.R10;
		/* 820701F4h case    5:*/		return 0x820701F8;
	}
	return 0x820701F8;
} // Block from 820701E0h-820701F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820701F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820701F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820701F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820701F8);
		  /* 820701F8h */ case    0:  		/* lwz R11, <#[R5 + 12]> */
		/* 820701F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000000C) );
		/* 820701F8h case    0:*/		return 0x820701FC;
		  /* 820701FCh */ case    1:  		/* add R10, R7, R9 */
		/* 820701FCh case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R7,regs.R9);
		/* 820701FCh case    1:*/		return 0x82070200;
		  /* 82070200h */ case    2:  		/* cmpw CR6, R11, R10 */
		/* 82070200h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82070200h case    2:*/		return 0x82070204;
		  /* 82070204h */ case    3:  		/* mr R28, R11 */
		/* 82070204h case    3:*/		regs.R28 = regs.R11;
		/* 82070204h case    3:*/		return 0x82070208;
		  /* 82070208h */ case    4:  		/* bc 12, CR6_LT, 8 */
		/* 82070208h case    4:*/		if ( regs.CR[6].lt ) { return 0x82070210;  }
		/* 82070208h case    4:*/		return 0x8207020C;
		  /* 8207020Ch */ case    5:  		/* mr R28, R10 */
		/* 8207020Ch case    5:*/		regs.R28 = regs.R10;
		/* 8207020Ch case    5:*/		return 0x82070210;
	}
	return 0x82070210;
} // Block from 820701F8h-82070210h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82070210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070210);
		  /* 82070210h */ case    0:  		/* lwz R11, <#[R31 + 12288]> */
		/* 82070210h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003000) );
		/* 82070210h case    0:*/		return 0x82070214;
		  /* 82070214h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82070214h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82070214h case    1:*/		return 0x82070218;
		  /* 82070218h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 82070218h case    2:*/		if ( regs.CR[6].eq ) { return 0x8207025C;  }
		/* 82070218h case    2:*/		return 0x8207021C;
		  /* 8207021Ch */ case    3:  		/* lwz R11, <#[R31 + 13052]> */
		/* 8207021Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000032FC) );
		/* 8207021Ch case    3:*/		return 0x82070220;
		  /* 82070220h */ case    4:  		/* cmpw CR6, R24, R11 */
		/* 82070220h case    4:*/		cpu::op::cmpw<6>(regs,regs.R24,regs.R11);
		/* 82070220h case    4:*/		return 0x82070224;
		  /* 82070224h */ case    5:  		/* bc 12, CR6_GT, 8 */
		/* 82070224h case    5:*/		if ( regs.CR[6].gt ) { return 0x8207022C;  }
		/* 82070224h case    5:*/		return 0x82070228;
		  /* 82070228h */ case    6:  		/* mr R24, R11 */
		/* 82070228h case    6:*/		regs.R24 = regs.R11;
		/* 82070228h case    6:*/		return 0x8207022C;
	}
	return 0x8207022C;
} // Block from 82070210h-8207022Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8207022Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207022C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207022C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207022C);
		  /* 8207022Ch */ case    0:  		/* lwz R11, <#[R31 + 13056]> */
		/* 8207022Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003300) );
		/* 8207022Ch case    0:*/		return 0x82070230;
		  /* 82070230h */ case    1:  		/* cmpw CR6, R25, R11 */
		/* 82070230h case    1:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R11);
		/* 82070230h case    1:*/		return 0x82070234;
		  /* 82070234h */ case    2:  		/* bc 12, CR6_GT, 8 */
		/* 82070234h case    2:*/		if ( regs.CR[6].gt ) { return 0x8207023C;  }
		/* 82070234h case    2:*/		return 0x82070238;
		  /* 82070238h */ case    3:  		/* mr R25, R11 */
		/* 82070238h case    3:*/		regs.R25 = regs.R11;
		/* 82070238h case    3:*/		return 0x8207023C;
	}
	return 0x8207023C;
} // Block from 8207022Ch-8207023Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8207023Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207023C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207023C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207023C);
		  /* 8207023Ch */ case    0:  		/* lwz R11, <#[R31 + 13060]> */
		/* 8207023Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003304) );
		/* 8207023Ch case    0:*/		return 0x82070240;
		  /* 82070240h */ case    1:  		/* cmpw CR6, R26, R11 */
		/* 82070240h case    1:*/		cpu::op::cmpw<6>(regs,regs.R26,regs.R11);
		/* 82070240h case    1:*/		return 0x82070244;
		  /* 82070244h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 82070244h case    2:*/		if ( regs.CR[6].lt ) { return 0x8207024C;  }
		/* 82070244h case    2:*/		return 0x82070248;
		  /* 82070248h */ case    3:  		/* mr R26, R11 */
		/* 82070248h case    3:*/		regs.R26 = regs.R11;
		/* 82070248h case    3:*/		return 0x8207024C;
	}
	return 0x8207024C;
} // Block from 8207023Ch-8207024Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8207024Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207024C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207024C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207024C);
		  /* 8207024Ch */ case    0:  		/* lwz R11, <#[R31 + 13064]> */
		/* 8207024Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003308) );
		/* 8207024Ch case    0:*/		return 0x82070250;
		  /* 82070250h */ case    1:  		/* cmpw CR6, R28, R11 */
		/* 82070250h case    1:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R11);
		/* 82070250h case    1:*/		return 0x82070254;
		  /* 82070254h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 82070254h case    2:*/		if ( regs.CR[6].lt ) { return 0x8207025C;  }
		/* 82070254h case    2:*/		return 0x82070258;
		  /* 82070258h */ case    3:  		/* mr R28, R11 */
		/* 82070258h case    3:*/		regs.R28 = regs.R11;
		/* 82070258h case    3:*/		return 0x8207025C;
	}
	return 0x8207025C;
} // Block from 8207024Ch-8207025Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8207025Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207025C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207025C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207025C);
		  /* 8207025Ch */ case    0:  		/* cmpw CR6, R26, R24 */
		/* 8207025Ch case    0:*/		cpu::op::cmpw<6>(regs,regs.R26,regs.R24);
		/* 8207025Ch case    0:*/		return 0x82070260;
		  /* 82070260h */ case    1:  		/* bc 4, CR6_GT, 1332 */
		/* 82070260h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82070794;  }
		/* 82070260h case    1:*/		return 0x82070264;
		  /* 82070264h */ case    2:  		/* cmpw CR6, R28, R25 */
		/* 82070264h case    2:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R25);
		/* 82070264h case    2:*/		return 0x82070268;
		  /* 82070268h */ case    3:  		/* bc 4, CR6_GT, 1324 */
		/* 82070268h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82070794;  }
		/* 82070268h case    3:*/		return 0x8207026C;
		  /* 8207026Ch */ case    4:  		/* ld R4, <#[R31 + 16]> */
		/* 8207026Ch case    4:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 8207026Ch case    4:*/		return 0x82070270;
		  /* 82070270h */ case    5:  		/* cmpldi CR6, R4, 0 */
		/* 82070270h case    5:*/		cpu::op::cmpldi<6>(regs,regs.R4,0x00000000);
		/* 82070270h case    5:*/		return 0x82070274;
		  /* 82070274h */ case    6:  		/* bc 12, CR6_EQ, 280 */
		/* 82070274h case    6:*/		if ( regs.CR[6].eq ) { return 0x8207038C;  }
		/* 82070274h case    6:*/		return 0x82070278;
		  /* 82070278h */ case    7:  		/* ld R11, <#[R31 + 40]> */
		/* 82070278h case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82070278h case    7:*/		return 0x8207027C;
		  /* 8207027Ch */ case    8:  		/* and R11, R11, R4 */
		/* 8207027Ch case    8:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 8207027Ch case    8:*/		return 0x82070280;
		  /* 82070280h */ case    9:  		/* cmpldi CR6, R11, 0 */
		/* 82070280h case    9:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070280h case    9:*/		return 0x82070284;
		  /* 82070284h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 82070284h case   10:*/		if ( regs.CR[6].eq ) { return 0x82070298;  }
		/* 82070284h case   10:*/		return 0x82070288;
		  /* 82070288h */ case   11:  		/* mr R3, R31 */
		/* 82070288h case   11:*/		regs.R3 = regs.R31;
		/* 82070288h case   11:*/		return 0x8207028C;
		  /* 8207028Ch */ case   12:  		/* lwz R5, <#[R31 + 10560]> */
		/* 8207028Ch case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00002940) );
		/* 8207028Ch case   12:*/		return 0x82070290;
		  /* 82070290h */ case   13:  		/* bl 78072 */
		/* 82070290h case   13:*/		regs.LR = 0x82070294; return 0x82083388;
		/* 82070290h case   13:*/		return 0x82070294;
		  /* 82070294h */ case   14:  		/* std R3, <#[R31 + 16]> */
		/* 82070294h case   14:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82070294h case   14:*/		return 0x82070298;
	}
	return 0x82070298;
} // Block from 8207025Ch-82070298h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82070298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070298);
		  /* 82070298h */ case    0:  		/* ld R11, <#[R31 + 16]> */
		/* 82070298h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070298h case    0:*/		return 0x8207029C;
		  /* 8207029Ch */ case    1:  		/* rldicl R10, R11, 0, 52 */
		/* 8207029Ch case    1:*/		cpu::op::rldicl<0,0,52>(regs,&regs.R10,regs.R11);
		/* 8207029Ch case    1:*/		return 0x820702A0;
		  /* 820702A0h */ case    2:  		/* cmpldi CR6, R10, 0 */
		/* 820702A0h case    2:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 820702A0h case    2:*/		return 0x820702A4;
		  /* 820702A4h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 820702A4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820702C8;  }
		/* 820702A4h case    3:*/		return 0x820702A8;
	}
	return 0x820702A8;
} // Block from 82070298h-820702A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820702A8h
// Function '?SwapCallback@D3D@@YAXK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820702A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820702A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820702A8);
		  /* 820702A8h */ case    0:  		/* addi R6, R31, 10548 */
		/* 820702A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2934);
		/* 820702A8h case    0:*/		return 0x820702AC;
		  /* 820702ACh */ case    1:  		/* li R5, 8704 */
		/* 820702ACh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x2200);
		/* 820702ACh case    1:*/		return 0x820702B0;
		  /* 820702B0h */ case    2:  		/* rldicr R4, R11, 52, 11 */
		/* 820702B0h case    2:*/		cpu::op::rldicr<0,52,11>(regs,&regs.R4,regs.R11);
		/* 820702B0h case    2:*/		return 0x820702B4;
		  /* 820702B4h */ case    3:  		/* mr R3, R31 */
		/* 820702B4h case    3:*/		regs.R3 = regs.R31;
		/* 820702B4h case    3:*/		return 0x820702B8;
		  /* 820702B8h */ case    4:  		/* bl 78944 */
		/* 820702B8h case    4:*/		regs.LR = 0x820702BC; return 0x82083718;
		/* 820702B8h case    4:*/		return 0x820702BC;
		  /* 820702BCh */ case    5:  		/* ld R11, <#[R31 + 16]> */
		/* 820702BCh case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820702BCh case    5:*/		return 0x820702C0;
		  /* 820702C0h */ case    6:  		/* rldicr R11, R11, 0, 51 */
		/* 820702C0h case    6:*/		cpu::op::rldicr<0,0,51>(regs,&regs.R11,regs.R11);
		/* 820702C0h case    6:*/		return 0x820702C4;
		  /* 820702C4h */ case    7:  		/* std R11, <#[R31 + 16]> */
		/* 820702C4h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820702C4h case    7:*/		return 0x820702C8;
	}
	return 0x820702C8;
} // Block from 820702A8h-820702C8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820702C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820702C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820702C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820702C8);
		  /* 820702C8h */ case    0:  		/* ld R11, <#[R31 + 16]> */
		/* 820702C8h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820702C8h case    0:*/		return 0x820702CC;
		  /* 820702CCh */ case    1:  		/* rlwinm R10, R11, 0, 15, 19 */
		/* 820702CCh case    1:*/		cpu::op::rlwinm<0,0,15,19>(regs,&regs.R10,regs.R11);
		/* 820702CCh case    1:*/		return 0x820702D0;
		  /* 820702D0h */ case    2:  		/* cmpldi CR6, R10, 0 */
		/* 820702D0h case    2:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 820702D0h case    2:*/		return 0x820702D4;
		  /* 820702D4h */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 820702D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82070300;  }
		/* 820702D4h case    3:*/		return 0x820702D8;
		  /* 820702D8h */ case    4:  		/* addi R6, R31, 10528 */
		/* 820702D8h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2920);
		/* 820702D8h case    4:*/		return 0x820702DC;
		  /* 820702DCh */ case    5:  		/* li R5, 8576 */
		/* 820702DCh case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x2180);
		/* 820702DCh case    5:*/		return 0x820702E0;
		  /* 820702E0h */ case    6:  		/* rldicr R4, R11, 47, 4 */
		/* 820702E0h case    6:*/		cpu::op::rldicr<0,47,4>(regs,&regs.R4,regs.R11);
		/* 820702E0h case    6:*/		return 0x820702E4;
		  /* 820702E4h */ case    7:  		/* mr R3, R31 */
		/* 820702E4h case    7:*/		regs.R3 = regs.R31;
		/* 820702E4h case    7:*/		return 0x820702E8;
		  /* 820702E8h */ case    8:  		/* bl 78896 */
		/* 820702E8h case    8:*/		regs.LR = 0x820702EC; return 0x82083718;
		/* 820702E8h case    8:*/		return 0x820702EC;
		  /* 820702ECh */ case    9:  		/* lis R12, -2 */
		/* 820702ECh case    9:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFFE);
		/* 820702ECh case    9:*/		return 0x820702F0;
		  /* 820702F0h */ case   10:  		/* ld R11, <#[R31 + 16]> */
		/* 820702F0h case   10:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820702F0h case   10:*/		return 0x820702F4;
		  /* 820702F4h */ case   11:  		/* ori R12, R12, 4095 */
		/* 820702F4h case   11:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFFF);
		/* 820702F4h case   11:*/		return 0x820702F8;
		  /* 820702F8h */ case   12:  		/* and R11, R11, R12 */
		/* 820702F8h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820702F8h case   12:*/		return 0x820702FC;
		  /* 820702FCh */ case   13:  		/* std R11, <#[R31 + 16]> */
		/* 820702FCh case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820702FCh case   13:*/		return 0x82070300;
	}
	return 0x82070300;
} // Block from 820702C8h-82070300h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82070300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070300);
		  /* 82070300h */ case    0:  		/* lis R12, 0 */
		/* 82070300h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0x0);
		/* 82070300h case    0:*/		return 0x82070304;
		  /* 82070304h */ case    1:  		/* ld R11, <#[R31 + 16]> */
		/* 82070304h case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070304h case    1:*/		return 0x82070308;
		  /* 82070308h */ case    2:  		/* ori R12, R12, 65535 */
		/* 82070308h case    2:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFFFF);
		/* 82070308h case    2:*/		return 0x8207030C;
		  /* 8207030Ch */ case    3:  		/* rldicr R12, R12, 42, 21 */
		/* 8207030Ch case    3:*/		cpu::op::rldicr<0,42,21>(regs,&regs.R12,regs.R12);
		/* 8207030Ch case    3:*/		return 0x82070310;
		  /* 82070310h */ case    4:  		/* and R10, R11, R12 */
		/* 82070310h case    4:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R12);
		/* 82070310h case    4:*/		return 0x82070314;
		  /* 82070314h */ case    5:  		/* cmpldi CR6, R10, 0 */
		/* 82070314h case    5:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 82070314h case    5:*/		return 0x82070318;
		  /* 82070318h */ case    6:  		/* bc 12, CR6_EQ, 48 */
		/* 82070318h case    6:*/		if ( regs.CR[6].eq ) { return 0x82070348;  }
		/* 82070318h case    6:*/		return 0x8207031C;
		  /* 8207031Ch */ case    7:  		/* addi R6, R31, 10368 */
		/* 8207031Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2880);
		/* 8207031Ch case    7:*/		return 0x82070320;
		  /* 82070320h */ case    8:  		/* li R5, 8192 */
		/* 82070320h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x2000);
		/* 82070320h case    8:*/		return 0x82070324;
		  /* 82070324h */ case    9:  		/* rldicr R4, R11, 6, 15 */
		/* 82070324h case    9:*/		cpu::op::rldicr<0,6,15>(regs,&regs.R4,regs.R11);
		/* 82070324h case    9:*/		return 0x82070328;
		  /* 82070328h */ case   10:  		/* mr R3, R31 */
		/* 82070328h case   10:*/		regs.R3 = regs.R31;
		/* 82070328h case   10:*/		return 0x8207032C;
		  /* 8207032Ch */ case   11:  		/* bl 78828 */
		/* 8207032Ch case   11:*/		regs.LR = 0x82070330; return 0x82083718;
		/* 8207032Ch case   11:*/		return 0x82070330;
		  /* 82070330h */ case   12:  		/* lis R12, -1 */
		/* 82070330h case   12:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFFF);
		/* 82070330h case   12:*/		return 0x82070334;
		  /* 82070334h */ case   13:  		/* ld R11, <#[R31 + 16]> */
		/* 82070334h case   13:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070334h case   13:*/		return 0x82070338;
		  /* 82070338h */ case   14:  		/* ori R12, R12, 0 */
		/* 82070338h case   14:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x0);
		/* 82070338h case   14:*/		return 0x8207033C;
		  /* 8207033Ch */ case   15:  		/* rldicr R12, R12, 42, 63 */
		/* 8207033Ch case   15:*/		cpu::op::rldicr<0,42,63>(regs,&regs.R12,regs.R12);
		/* 8207033Ch case   15:*/		return 0x82070340;
		  /* 82070340h */ case   16:  		/* and R11, R11, R12 */
		/* 82070340h case   16:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82070340h case   16:*/		return 0x82070344;
		  /* 82070344h */ case   17:  		/* std R11, <#[R31 + 16]> */
		/* 82070344h case   17:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070344h case   17:*/		return 0x82070348;
	}
	return 0x82070348;
} // Block from 82070300h-82070348h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82070348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070348);
		  /* 82070348h */ case    0:  		/* lis R12, -32 */
		/* 82070348h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFE0);
		/* 82070348h case    0:*/		return 0x8207034C;
		  /* 8207034Ch */ case    1:  		/* ld R11, <#[R31 + 16]> */
		/* 8207034Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8207034Ch case    1:*/		return 0x82070350;
		  /* 82070350h */ case    2:  		/* rldicl R12, R12, 0, 22 */
		/* 82070350h case    2:*/		cpu::op::rldicl<0,0,22>(regs,&regs.R12,regs.R12);
		/* 82070350h case    2:*/		return 0x82070354;
		  /* 82070354h */ case    3:  		/* and R10, R11, R12 */
		/* 82070354h case    3:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R12);
		/* 82070354h case    3:*/		return 0x82070358;
		  /* 82070358h */ case    4:  		/* cmpldi CR6, R10, 0 */
		/* 82070358h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 82070358h case    4:*/		return 0x8207035C;
		  /* 8207035Ch */ case    5:  		/* bc 12, CR6_EQ, 48 */
		/* 8207035Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8207038C;  }
		/* 8207035Ch case    5:*/		return 0x82070360;
		  /* 82070360h */ case    6:  		/* addi R6, R31, 10444 */
		/* 82070360h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x28CC);
		/* 82070360h case    6:*/		return 0x82070364;
		  /* 82070364h */ case    7:  		/* li R5, 8448 */
		/* 82070364h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x2100);
		/* 82070364h case    7:*/		return 0x82070368;
		  /* 82070368h */ case    8:  		/* rldicr R4, R11, 22, 20 */
		/* 82070368h case    8:*/		cpu::op::rldicr<0,22,20>(regs,&regs.R4,regs.R11);
		/* 82070368h case    8:*/		return 0x8207036C;
		  /* 8207036Ch */ case    9:  		/* mr R3, R31 */
		/* 8207036Ch case    9:*/		regs.R3 = regs.R31;
		/* 8207036Ch case    9:*/		return 0x82070370;
		  /* 82070370h */ case   10:  		/* bl 78760 */
		/* 82070370h case   10:*/		regs.LR = 0x82070374; return 0x82083718;
		/* 82070370h case   10:*/		return 0x82070374;
		  /* 82070374h */ case   11:  		/* lis R12, -32 */
		/* 82070374h case   11:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFE0);
		/* 82070374h case   11:*/		return 0x82070378;
		  /* 82070378h */ case   12:  		/* ld R11, <#[R31 + 16]> */
		/* 82070378h case   12:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070378h case   12:*/		return 0x8207037C;
		  /* 8207037Ch */ case   13:  		/* ori R12, R12, 0 */
		/* 8207037Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x0);
		/* 8207037Ch case   13:*/		return 0x82070380;
		  /* 82070380h */ case   14:  		/* rldicr R12, R12, 21, 63 */
		/* 82070380h case   14:*/		cpu::op::rldicr<0,21,63>(regs,&regs.R12,regs.R12);
		/* 82070380h case   14:*/		return 0x82070384;
		  /* 82070384h */ case   15:  		/* and R11, R11, R12 */
		/* 82070384h case   15:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82070384h case   15:*/		return 0x82070388;
		  /* 82070388h */ case   16:  		/* std R11, <#[R31 + 16]> */
		/* 82070388h case   16:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070388h case   16:*/		return 0x8207038C;
	}
	return 0x8207038C;
} // Block from 82070348h-8207038Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8207038Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207038C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207038C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207038C);
		  /* 8207038Ch */ case    0:  		/* ld R11, <#[R31 + 24]> */
		/* 8207038Ch case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8207038Ch case    0:*/		return 0x82070390;
		  /* 82070390h */ case    1:  		/* cmpldi CR6, R11, 0 */
		/* 82070390h case    1:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070390h case    1:*/		return 0x82070394;
		  /* 82070394h */ case    2:  		/* bc 12, CR6_EQ, 72 */
		/* 82070394h case    2:*/		if ( regs.CR[6].eq ) { return 0x820703DC;  }
		/* 82070394h case    2:*/		return 0x82070398;
		  /* 82070398h */ case    3:  		/* lis R12, 31 */
		/* 82070398h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0x1F);
		/* 82070398h case    3:*/		return 0x8207039C;
		  /* 8207039Ch */ case    4:  		/* ori R12, R12, 65535 */
		/* 8207039Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFFFF);
		/* 8207039Ch case    4:*/		return 0x820703A0;
		  /* 820703A0h */ case    5:  		/* rldicr R12, R12, 34, 29 */
		/* 820703A0h case    5:*/		cpu::op::rldicr<0,34,29>(regs,&regs.R12,regs.R12);
		/* 820703A0h case    5:*/		return 0x820703A4;
		  /* 820703A4h */ case    6:  		/* and R10, R11, R12 */
		/* 820703A4h case    6:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R12);
		/* 820703A4h case    6:*/		return 0x820703A8;
		  /* 820703A8h */ case    7:  		/* cmpldi CR6, R10, 0 */
		/* 820703A8h case    7:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 820703A8h case    7:*/		return 0x820703AC;
		  /* 820703ACh */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 820703ACh case    8:*/		if ( regs.CR[6].eq ) { return 0x820703DC;  }
		/* 820703ACh case    8:*/		return 0x820703B0;
		  /* 820703B0h */ case    9:  		/* addi R6, R31, 10596 */
		/* 820703B0h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2964);
		/* 820703B0h case    9:*/		return 0x820703B4;
		  /* 820703B4h */ case   10:  		/* li R5, 8832 */
		/* 820703B4h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x2280);
		/* 820703B4h case   10:*/		return 0x820703B8;
		  /* 820703B8h */ case   11:  		/* rldicr R4, R11, 9, 20 */
		/* 820703B8h case   11:*/		cpu::op::rldicr<0,9,20>(regs,&regs.R4,regs.R11);
		/* 820703B8h case   11:*/		return 0x820703BC;
		  /* 820703BCh */ case   12:  		/* mr R3, R31 */
		/* 820703BCh case   12:*/		regs.R3 = regs.R31;
		/* 820703BCh case   12:*/		return 0x820703C0;
		  /* 820703C0h */ case   13:  		/* bl 78680 */
		/* 820703C0h case   13:*/		regs.LR = 0x820703C4; return 0x82083718;
		/* 820703C0h case   13:*/		return 0x820703C4;
		  /* 820703C4h */ case   14:  		/* lis R12, -32 */
		/* 820703C4h case   14:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFE0);
		/* 820703C4h case   14:*/		return 0x820703C8;
		  /* 820703C8h */ case   15:  		/* ld R11, <#[R31 + 24]> */
		/* 820703C8h case   15:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820703C8h case   15:*/		return 0x820703CC;
		  /* 820703CCh */ case   16:  		/* ori R12, R12, 0 */
		/* 820703CCh case   16:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0x0);
		/* 820703CCh case   16:*/		return 0x820703D0;
		  /* 820703D0h */ case   17:  		/* rldicr R12, R12, 34, 63 */
		/* 820703D0h case   17:*/		cpu::op::rldicr<0,34,63>(regs,&regs.R12,regs.R12);
		/* 820703D0h case   17:*/		return 0x820703D4;
		  /* 820703D4h */ case   18:  		/* and R11, R11, R12 */
		/* 820703D4h case   18:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820703D4h case   18:*/		return 0x820703D8;
		  /* 820703D8h */ case   19:  		/* std R11, <#[R31 + 24]> */
		/* 820703D8h case   19:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820703D8h case   19:*/		return 0x820703DC;
	}
	return 0x820703DC;
} // Block from 8207038Ch-820703DCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 820703DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820703DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820703DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820703DC);
		  /* 820703DCh */ case    0:  		/* ld R11, <#[R31 + 32]> */
		/* 820703DCh case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820703DCh case    0:*/		return 0x820703E0;
		  /* 820703E0h */ case    1:  		/* cmpldi CR6, R11, 0 */
		/* 820703E0h case    1:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 820703E0h case    1:*/		return 0x820703E4;
		  /* 820703E4h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 820703E4h case    2:*/		if ( regs.CR[6].eq ) { return 0x82070414;  }
		/* 820703E4h case    2:*/		return 0x820703E8;
		  /* 820703E8h */ case    3:  		/* rldicl R10, R11, 0, 26 */
		/* 820703E8h case    3:*/		cpu::op::rldicl<0,0,26>(regs,&regs.R10,regs.R11);
		/* 820703E8h case    3:*/		return 0x820703EC;
		  /* 820703ECh */ case    4:  		/* cmpldi CR6, R10, 0 */
		/* 820703ECh case    4:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 820703ECh case    4:*/		return 0x820703F0;
		  /* 820703F0h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 820703F0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82070414;  }
		/* 820703F0h case    5:*/		return 0x820703F4;
		  /* 820703F4h */ case    6:  		/* addi R6, R31, 10680 */
		/* 820703F4h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x29B8);
		/* 820703F4h case    6:*/		return 0x820703F8;
		  /* 820703F8h */ case    7:  		/* li R5, 8960 */
		/* 820703F8h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x2300);
		/* 820703F8h case    7:*/		return 0x820703FC;
		  /* 820703FCh */ case    8:  		/* rldicr R4, R11, 26, 37 */
		/* 820703FCh case    8:*/		cpu::op::rldicr<0,26,37>(regs,&regs.R4,regs.R11);
		/* 820703FCh case    8:*/		return 0x82070400;
		  /* 82070400h */ case    9:  		/* mr R3, R31 */
		/* 82070400h case    9:*/		regs.R3 = regs.R31;
		/* 82070400h case    9:*/		return 0x82070404;
		  /* 82070404h */ case   10:  		/* bl 78612 */
		/* 82070404h case   10:*/		regs.LR = 0x82070408; return 0x82083718;
		/* 82070404h case   10:*/		return 0x82070408;
		  /* 82070408h */ case   11:  		/* ld R11, <#[R31 + 32]> */
		/* 82070408h case   11:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82070408h case   11:*/		return 0x8207040C;
		  /* 8207040Ch */ case   12:  		/* rldicr R11, R11, 0, 25 */
		/* 8207040Ch case   12:*/		cpu::op::rldicr<0,0,25>(regs,&regs.R11,regs.R11);
		/* 8207040Ch case   12:*/		return 0x82070410;
		  /* 82070410h */ case   13:  		/* std R11, <#[R31 + 32]> */
		/* 82070410h case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82070410h case   13:*/		return 0x82070414;
	}
	return 0x82070414;
} // Block from 820703DCh-82070414h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82070414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070414);
		  /* 82070414h */ case    0:  		/* lwz R11, <#[R31 + 48]> */
		/* 82070414h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82070414h case    0:*/		return 0x82070418;
		  /* 82070418h */ case    1:  		/* lwz R10, <#[R31 + 56]> */
		/* 82070418h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 82070418h case    1:*/		return 0x8207041C;
		  /* 8207041Ch */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8207041Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8207041Ch case    2:*/		return 0x82070420;
		  /* 82070420h */ case    3:  		/* bc 4, CR6_GT, 16 */
		/* 82070420h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82070430;  }
		/* 82070420h case    3:*/		return 0x82070424;
		  /* 82070424h */ case    4:  		/* mr R3, R31 */
		/* 82070424h case    4:*/		regs.R3 = regs.R31;
		/* 82070424h case    4:*/		return 0x82070428;
		  /* 82070428h */ case    5:  		/* bl 15584 */
		/* 82070428h case    5:*/		regs.LR = 0x8207042C; return 0x82074108;
		/* 82070428h case    5:*/		return 0x8207042C;
		  /* 8207042Ch */ case    6:  		/* mr R11, R3 */
		/* 8207042Ch case    6:*/		regs.R11 = regs.R3;
		/* 8207042Ch case    6:*/		return 0x82070430;
	}
	return 0x82070430;
} // Block from 82070414h-82070430h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82070430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070430);
		  /* 82070430h */ case    0:  		/* lbz R10, <#[R31 + 11068]> */
		/* 82070430h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B3C) );
		/* 82070430h case    0:*/		return 0x82070434;
		  /* 82070434h */ case    1:  		/* rlwinm. R10, R10, 0, 26, 26 */
		/* 82070434h case    1:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R10);
		/* 82070434h case    1:*/		return 0x82070438;
		  /* 82070438h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 82070438h case    2:*/		if ( regs.CR[0].eq ) { return 0x82070450;  }
		/* 82070438h case    2:*/		return 0x8207043C;
		  /* 8207043Ch */ case    3:  		/* lis R10, -16384 */
		/* 8207043Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC000);
		/* 8207043Ch case    3:*/		return 0x82070440;
		  /* 82070440h */ case    4:  		/* ori R10, R10, 24576 */
		/* 82070440h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x6000);
		/* 82070440h case    4:*/		return 0x82070444;
		  /* 82070444h */ case    5:  		/* stwu R10, <#[R11 + 4]> */
		/* 82070444h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82070444h case    5:*/		return 0x82070448;
		  /* 82070448h */ case    6:  		/* lwz R10, <#[R31 + 13084]> */
		/* 82070448h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000331C) );
		/* 82070448h case    6:*/		return 0x8207044C;
		  /* 8207044Ch */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 8207044Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8207044Ch case    7:*/		return 0x82070450;
	}
	return 0x82070450;
} // Block from 82070430h-82070450h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070450);
		  /* 82070450h */ case    0:  		/* lis R10, -16384 */
		/* 82070450h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC000);
		/* 82070450h case    0:*/		return 0x82070454;
		  /* 82070454h */ case    1:  		/* li R9, 768 */
		/* 82070454h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x300);
		/* 82070454h case    1:*/		return 0x82070458;
	}
	return 0x82070458;
} // Block from 82070450h-82070458h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82070458h
// Function '?SynchronizeToPresentationInterval@D3D@@YAXPAVCDevice@1@K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070458);
		  /* 82070458h */ case    0:  		/* ori R10, R10, 15104 */
		/* 82070458h case    0:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3B00);
		/* 82070458h case    0:*/		return 0x8207045C;
		  /* 8207045Ch */ case    1:  		/* lis R8, -16356 */
		/* 8207045Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFC01C);
		/* 8207045Ch case    1:*/		return 0x82070460;
		  /* 82070460h */ case    2:  		/* stwu R10, <#[R11 + 4]> */
		/* 82070460h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82070460h case    2:*/		return 0x82070464;
		  /* 82070464h */ case    3:  		/* li R7, 0 */
		/* 82070464h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82070464h case    3:*/		return 0x82070468;
		  /* 82070468h */ case    4:  		/* ori R8, R8, 11008 */
		/* 82070468h case    4:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x2B00);
		/* 82070468h case    4:*/		return 0x8207046C;
		  /* 8207046Ch */ case    5:  		/* li R6, 27 */
		/* 8207046Ch case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1B);
		/* 8207046Ch case    5:*/		return 0x82070470;
		  /* 82070470h */ case    6:  		/* lis R10, -32256 */
		/* 82070470h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82070470h case    6:*/		return 0x82070474;
		  /* 82070474h */ case    7:  		/* li R5, 108 */
		/* 82070474h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x6C);
		/* 82070474h case    7:*/		return 0x82070478;
		  /* 82070478h */ case    8:  		/* stwu R9, <#[R11 + 4]> */
		/* 82070478h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82070478h case    8:*/		return 0x8207047C;
		  /* 8207047Ch */ case    9:  		/* addi R29, R10, 4048 */
		/* 8207047Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0xFD0);
		/* 8207047Ch case    9:*/		return 0x82070480;
		  /* 82070480h */ case   10:  		/* addi R4, R29, 40 */
		/* 82070480h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0x28);
		/* 82070480h case   10:*/		return 0x82070484;
		  /* 82070484h */ case   11:  		/* stwu R8, <#[R11 + 4]> */
		/* 82070484h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82070484h case   11:*/		return 0x82070488;
		  /* 82070488h */ case   12:  		/* stwu R7, <#[R11 + 4]> */
		/* 82070488h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82070488h case   12:*/		return 0x8207048C;
		  /* 8207048Ch */ case   13:  		/* mr R30, R11 */
		/* 8207048Ch case   13:*/		regs.R30 = regs.R11;
		/* 8207048Ch case   13:*/		return 0x82070490;
		  /* 82070490h */ case   14:  		/* stwu R6, <#[R30 + 4]> */
		/* 82070490h case   14:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070490h case   14:*/		return 0x82070494;
		  /* 82070494h */ case   15:  		/* addi R3, R30, 4 */
		/* 82070494h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 82070494h case   15:*/		return 0x82070498;
		  /* 82070498h */ case   16:  		/* bl 136472 */
		/* 82070498h case   16:*/		regs.LR = 0x8207049C; return 0x820919B0;
		/* 82070498h case   16:*/		return 0x8207049C;
		  /* 8207049Ch */ case   17:  		/* lwz R11, <#[R31 + 56]> */
		/* 8207049Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8207049Ch case   17:*/		return 0x820704A0;
		  /* 820704A0h */ case   18:  		/* addi R3, R30, 108 */
		/* 820704A0h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x6C);
		/* 820704A0h case   18:*/		return 0x820704A4;
		  /* 820704A4h */ case   19:  		/* stw R3, <#[R31 + 48]> */
		/* 820704A4h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 820704A4h case   19:*/		return 0x820704A8;
		  /* 820704A8h */ case   20:  		/* cmplw CR6, R3, R11 */
		/* 820704A8h case   20:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820704A8h case   20:*/		return 0x820704AC;
		  /* 820704ACh */ case   21:  		/* bc 4, CR6_GT, 12 */
		/* 820704ACh case   21:*/		if ( !regs.CR[6].gt ) { return 0x820704B8;  }
		/* 820704ACh case   21:*/		return 0x820704B0;
		  /* 820704B0h */ case   22:  		/* mr R3, R31 */
		/* 820704B0h case   22:*/		regs.R3 = regs.R31;
		/* 820704B0h case   22:*/		return 0x820704B4;
		  /* 820704B4h */ case   23:  		/* bl 15444 */
		/* 820704B4h case   23:*/		regs.LR = 0x820704B8; return 0x82074108;
		/* 820704B4h case   23:*/		return 0x820704B8;
	}
	return 0x820704B8;
} // Block from 82070458h-820704B8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820704B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820704B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820704B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820704B8);
		  /* 820704B8h */ case    0:  		/* lis R11, -16374 */
		/* 820704B8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC00A);
		/* 820704B8h case    0:*/		return 0x820704BC;
		  /* 820704BCh */ case    1:  		/* li R10, 1 */
		/* 820704BCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820704BCh case    1:*/		return 0x820704C0;
		  /* 820704C0h */ case    2:  		/* ori R11, R11, 11008 */
		/* 820704C0h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2B00);
		/* 820704C0h case    2:*/		return 0x820704C4;
		  /* 820704C4h */ case    3:  		/* li R9, 9 */
		/* 820704C4h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x9);
		/* 820704C4h case    3:*/		return 0x820704C8;
		  /* 820704C8h */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 820704C8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820704C8h case    4:*/		return 0x820704CC;
		  /* 820704CCh */ case    5:  		/* mr R4, R29 */
		/* 820704CCh case    5:*/		regs.R4 = regs.R29;
		/* 820704CCh case    5:*/		return 0x820704D0;
		  /* 820704D0h */ case    6:  		/* li R5, 36 */
		/* 820704D0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 820704D0h case    6:*/		return 0x820704D4;
		  /* 820704D4h */ case    7:  		/* stwu R10, <#[R3 + 4]> */
		/* 820704D4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820704D4h case    7:*/		return 0x820704D8;
		  /* 820704D8h */ case    8:  		/* mr R30, R3 */
		/* 820704D8h case    8:*/		regs.R30 = regs.R3;
		/* 820704D8h case    8:*/		return 0x820704DC;
		  /* 820704DCh */ case    9:  		/* stwu R9, <#[R30 + 4]> */
		/* 820704DCh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 820704DCh case    9:*/		return 0x820704E0;
		  /* 820704E0h */ case   10:  		/* addi R3, R30, 4 */
		/* 820704E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 820704E0h case   10:*/		return 0x820704E4;
		  /* 820704E4h */ case   11:  		/* bl 136396 */
		/* 820704E4h case   11:*/		regs.LR = 0x820704E8; return 0x820919B0;
		/* 820704E4h case   11:*/		return 0x820704E8;
		  /* 820704E8h */ case   12:  		/* addi R11, R30, 36 */
		/* 820704E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x24);
		/* 820704E8h case   12:*/		return 0x820704EC;
		  /* 820704ECh */ case   13:  		/* lis R10, 1 */
		/* 820704ECh case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 820704ECh case   13:*/		return 0x820704F0;
		  /* 820704F0h */ case   14:  		/* lis R9, 4097 */
		/* 820704F0h case   14:*/		cpu::op::lis<0>(regs,&regs.R9,0x1001);
		/* 820704F0h case   14:*/		return 0x820704F4;
		  /* 820704F4h */ case   15:  		/* ori R10, R10, 8576 */
		/* 820704F4h case   15:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2180);
		/* 820704F4h case   15:*/		return 0x820704F8;
		  /* 820704F8h */ case   16:  		/* ori R9, R9, 1 */
		/* 820704F8h case   16:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820704F8h case   16:*/		return 0x820704FC;
		  /* 820704FCh */ case   17:  		/* stwu R10, <#[R11 + 4]> */
		/* 820704FCh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820704FCh case   17:*/		return 0x82070500;
		  /* 82070500h */ case   18:  		/* li R10, 0 */
		/* 82070500h case   18:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82070500h case   18:*/		return 0x82070504;
		  /* 82070504h */ case   19:  		/* stwu R9, <#[R11 + 4]> */
		/* 82070504h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82070504h case   19:*/		return 0x82070508;
		  /* 82070508h */ case   20:  		/* stwu R10, <#[R11 + 4]> */
		/* 82070508h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82070508h case   20:*/		return 0x8207050C;
		  /* 8207050Ch */ case   21:  		/* mr R3, R11 */
		/* 8207050Ch case   21:*/		regs.R3 = regs.R11;
		/* 8207050Ch case   21:*/		return 0x82070510;
		  /* 82070510h */ case   22:  		/* lwz R10, <#[R31 + 56]> */
		/* 82070510h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 82070510h case   22:*/		return 0x82070514;
		  /* 82070514h */ case   23:  		/* stw R11, <#[R31 + 48]> */
		/* 82070514h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82070514h case   23:*/		return 0x82070518;
		  /* 82070518h */ case   24:  		/* cmplw CR6, R11, R10 */
		/* 82070518h case   24:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82070518h case   24:*/		return 0x8207051C;
		  /* 8207051Ch */ case   25:  		/* bc 4, CR6_GT, 12 */
		/* 8207051Ch case   25:*/		if ( !regs.CR[6].gt ) { return 0x82070528;  }
		/* 8207051Ch case   25:*/		return 0x82070520;
		  /* 82070520h */ case   26:  		/* mr R3, R31 */
		/* 82070520h case   26:*/		regs.R3 = regs.R31;
		/* 82070520h case   26:*/		return 0x82070524;
		  /* 82070524h */ case   27:  		/* bl 15332 */
		/* 82070524h case   27:*/		regs.LR = 0x82070528; return 0x82074108;
		/* 82070524h case   27:*/		return 0x82070528;
	}
	return 0x82070528;
} // Block from 820704B8h-82070528h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82070528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070528);
		  /* 82070528h */ case    0:  		/* lis R11, 2 */
		/* 82070528h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x2);
		/* 82070528h case    0:*/		return 0x8207052C;
		  /* 8207052Ch */ case    1:  		/* lis R10, 0 */
		/* 8207052Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8207052Ch case    1:*/		return 0x82070530;
		  /* 82070530h */ case    2:  		/* ori R11, R11, 8448 */
		/* 82070530h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2100);
		/* 82070530h case    2:*/		return 0x82070534;
		  /* 82070534h */ case    3:  		/* ori R30, R10, 65535 */
		/* 82070534h case    3:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R10,0xFFFF);
		/* 82070534h case    3:*/		return 0x82070538;
		  /* 82070538h */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 82070538h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82070538h case    4:*/		return 0x8207053C;
		  /* 8207053Ch */ case    5:  		/* li R11, 0 */
		/* 8207053Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8207053Ch case    5:*/		return 0x82070540;
		  /* 82070540h */ case    6:  		/* li R9, 0 */
		/* 82070540h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82070540h case    6:*/		return 0x82070544;
		  /* 82070544h */ case    7:  		/* li R8, 8851 */
		/* 82070544h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x2293);
		/* 82070544h case    7:*/		return 0x82070548;
		  /* 82070548h */ case    8:  		/* li R7, 0 */
		/* 82070548h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82070548h case    8:*/		return 0x8207054C;
		  /* 8207054Ch */ case    9:  		/* lis R6, 2 */
		/* 8207054Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R6,0x2);
		/* 8207054Ch case    9:*/		return 0x82070550;
		  /* 82070550h */ case   10:  		/* stwu R30, <#[R3 + 4]> */
		/* 82070550h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82070550h case   10:*/		return 0x82070554;
		  /* 82070554h */ case   11:  		/* mr R10, R30 */
		/* 82070554h case   11:*/		regs.R10 = regs.R30;
		/* 82070554h case   11:*/		return 0x82070558;
		  /* 82070558h */ case   12:  		/* ori R6, R6, 8708 */
		/* 82070558h case   12:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x2204);
		/* 82070558h case   12:*/		return 0x8207055C;
		  /* 8207055Ch */ case   13:  		/* lis R10, 1 */
		/* 8207055Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 8207055Ch case   13:*/		return 0x82070560;
		  /* 82070560h */ case   14:  		/* lis R5, 1 */
		/* 82070560h case   14:*/		cpu::op::lis<0>(regs,&regs.R5,0x1);
		/* 82070560h case   14:*/		return 0x82070564;
		  /* 82070564h */ case   15:  		/* li R4, 768 */
		/* 82070564h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x300);
		/* 82070564h case   15:*/		return 0x82070568;
		  /* 82070568h */ case   16:  		/* stwu R11, <#[R3 + 4]> */
		/* 82070568h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82070568h case   16:*/		return 0x8207056C;
		  /* 8207056Ch */ case   17:  		/* li R29, 8978 */
		/* 8207056Ch case   17:*/		cpu::op::li<0>(regs,&regs.R29,0x2312);
		/* 8207056Ch case   17:*/		return 0x82070570;
		  /* 82070570h */ case   18:  		/* li R11, 8205 */
		/* 82070570h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x200D);
		/* 82070570h case   18:*/		return 0x82070574;
		  /* 82070574h */ case   19:  		/* li R20, 0 */
		/* 82070574h case   19:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 82070574h case   19:*/		return 0x82070578;
		  /* 82070578h */ case   20:  		/* li R12, 1 */
		/* 82070578h case   20:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82070578h case   20:*/		return 0x8207057C;
		  /* 8207057Ch */ case   21:  		/* mr R21, R30 */
		/* 8207057Ch case   21:*/		regs.R21 = regs.R30;
		/* 8207057Ch case   21:*/		return 0x82070580;
		  /* 82070580h */ case   22:  		/* stwu R9, <#[R3 + 4]> */
		/* 82070580h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82070580h case   22:*/		return 0x82070584;
		  /* 82070584h */ case   23:  		/* rldicr R12, R12, 41, 63 */
		/* 82070584h case   23:*/		cpu::op::rldicr<0,41,63>(regs,&regs.R12,regs.R12);
		/* 82070584h case   23:*/		return 0x82070588;
		  /* 82070588h */ case   24:  		/* rlwinm. R19, R27, 0, 28, 31 */
		/* 82070588h case   24:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R19,regs.R27);
		/* 82070588h case   24:*/		return 0x8207058C;
		  /* 8207058Ch */ case   25:  		/* stwu R8, <#[R3 + 4]> */
		/* 8207058Ch case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207058Ch case   25:*/		return 0x82070590;
		  /* 82070590h */ case   26:  		/* stwu R7, <#[R3 + 4]> */
		/* 82070590h case   26:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82070590h case   26:*/		return 0x82070594;
		  /* 82070594h */ case   27:  		/* stwu R6, <#[R3 + 4]> */
		/* 82070594h case   27:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82070594h case   27:*/		return 0x82070598;
		  /* 82070598h */ case   28:  		/* stwu R10, <#[R3 + 4]> */
		/* 82070598h case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82070598h case   28:*/		return 0x8207059C;
		  /* 8207059Ch */ case   29:  		/* stwu R5, <#[R3 + 4]> */
		/* 8207059Ch case   29:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207059Ch case   29:*/		return 0x820705A0;
		  /* 820705A0h */ case   30:  		/* stwu R4, <#[R3 + 4]> */
		/* 820705A0h case   30:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820705A0h case   30:*/		return 0x820705A4;
		  /* 820705A4h */ case   31:  		/* stwu R29, <#[R3 + 4]> */
		/* 820705A4h case   31:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820705A4h case   31:*/		return 0x820705A8;
		  /* 820705A8h */ case   32:  		/* stwu R30, <#[R3 + 4]> */
		/* 820705A8h case   32:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820705A8h case   32:*/		return 0x820705AC;
		  /* 820705ACh */ case   33:  		/* stwu R11, <#[R3 + 4]> */
		/* 820705ACh case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820705ACh case   33:*/		return 0x820705B0;
		  /* 820705B0h */ case   34:  		/* stwu R20, <#[R3 + 4]> */
		/* 820705B0h case   34:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820705B0h case   34:*/		return 0x820705B4;
		  /* 820705B4h */ case   35:  		/* ld R11, <#[R31 + 16]> */
		/* 820705B4h case   35:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820705B4h case   35:*/		return 0x820705B8;
		  /* 820705B8h */ case   36:  		/* or R11, R11, R12 */
		/* 820705B8h case   36:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820705B8h case   36:*/		return 0x820705BC;
		  /* 820705BCh */ case   37:  		/* li R12, 1 */
		/* 820705BCh case   37:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820705BCh case   37:*/		return 0x820705C0;
		  /* 820705C0h */ case   38:  		/* std R11, <#[R31 + 16]> */
		/* 820705C0h case   38:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820705C0h case   38:*/		return 0x820705C4;
		  /* 820705C4h */ case   39:  		/* rldicr R12, R12, 40, 63 */
		/* 820705C4h case   39:*/		cpu::op::rldicr<0,40,63>(regs,&regs.R12,regs.R12);
		/* 820705C4h case   39:*/		return 0x820705C8;
		  /* 820705C8h */ case   40:  		/* or R11, R11, R12 */
		/* 820705C8h case   40:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820705C8h case   40:*/		return 0x820705CC;
		  /* 820705CCh */ case   41:  		/* li R12, 1 */
		/* 820705CCh case   41:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820705CCh case   41:*/		return 0x820705D0;
		  /* 820705D0h */ case   42:  		/* std R11, <#[R31 + 16]> */
		/* 820705D0h case   42:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820705D0h case   42:*/		return 0x820705D4;
		  /* 820705D4h */ case   43:  		/* rldicr R12, R12, 39, 63 */
		/* 820705D4h case   43:*/		cpu::op::rldicr<0,39,63>(regs,&regs.R12,regs.R12);
		/* 820705D4h case   43:*/		return 0x820705D8;
		  /* 820705D8h */ case   44:  		/* or R11, R11, R12 */
		/* 820705D8h case   44:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820705D8h case   44:*/		return 0x820705DC;
		  /* 820705DCh */ case   45:  		/* li R12, 1 */
		/* 820705DCh case   45:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820705DCh case   45:*/		return 0x820705E0;
		  /* 820705E0h */ case   46:  		/* std R11, <#[R31 + 16]> */
		/* 820705E0h case   46:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820705E0h case   46:*/		return 0x820705E4;
		  /* 820705E4h */ case   47:  		/* rldicr R12, R12, 35, 63 */
		/* 820705E4h case   47:*/		cpu::op::rldicr<0,35,63>(regs,&regs.R12,regs.R12);
		/* 820705E4h case   47:*/		return 0x820705E8;
		  /* 820705E8h */ case   48:  		/* ld R11, <#[R31 + 24]> */
		/* 820705E8h case   48:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820705E8h case   48:*/		return 0x820705EC;
		  /* 820705ECh */ case   49:  		/* or R11, R11, R12 */
		/* 820705ECh case   49:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820705ECh case   49:*/		return 0x820705F0;
		  /* 820705F0h */ case   50:  		/* std R11, <#[R31 + 24]> */
		/* 820705F0h case   50:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820705F0h case   50:*/		return 0x820705F4;
		  /* 820705F4h */ case   51:  		/* li R12, 1 */
		/* 820705F4h case   51:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820705F4h case   51:*/		return 0x820705F8;
		  /* 820705F8h */ case   52:  		/* ld R11, <#[R31 + 16]> */
		/* 820705F8h case   52:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820705F8h case   52:*/		return 0x820705FC;
		  /* 820705FCh */ case   53:  		/* ori R11, R11, 128 */
		/* 820705FCh case   53:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 820705FCh case   53:*/		return 0x82070600;
		  /* 82070600h */ case   54:  		/* std R11, <#[R31 + 16]> */
		/* 82070600h case   54:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070600h case   54:*/		return 0x82070604;
		  /* 82070604h */ case   55:  		/* ori R11, R11, 64 */
		/* 82070604h case   55:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82070604h case   55:*/		return 0x82070608;
		  /* 82070608h */ case   56:  		/* rldicr R12, R12, 44, 63 */
		/* 82070608h case   56:*/		cpu::op::rldicr<0,44,63>(regs,&regs.R12,regs.R12);
		/* 82070608h case   56:*/		return 0x8207060C;
		  /* 8207060Ch */ case   57:  		/* std R11, <#[R31 + 16]> */
		/* 8207060Ch case   57:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8207060Ch case   57:*/		return 0x82070610;
		  /* 82070610h */ case   58:  		/* ori R11, R11, 32 */
		/* 82070610h case   58:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82070610h case   58:*/		return 0x82070614;
		  /* 82070614h */ case   59:  		/* std R11, <#[R31 + 16]> */
		/* 82070614h case   59:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070614h case   59:*/		return 0x82070618;
		  /* 82070618h */ case   60:  		/* ld R11, <#[R31 + 32]> */
		/* 82070618h case   60:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82070618h case   60:*/		return 0x8207061C;
		  /* 8207061Ch */ case   61:  		/* oris R11, R11, 8 */
		/* 8207061Ch case   61:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8207061Ch case   61:*/		return 0x82070620;
		  /* 82070620h */ case   62:  		/* std R11, <#[R31 + 32]> */
		/* 82070620h case   62:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82070620h case   62:*/		return 0x82070624;
		  /* 82070624h */ case   63:  		/* ld R11, <#[R31 + 16]> */
		/* 82070624h case   63:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070624h case   63:*/		return 0x82070628;
		  /* 82070628h */ case   64:  		/* or R11, R11, R12 */
		/* 82070628h case   64:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82070628h case   64:*/		return 0x8207062C;
		  /* 8207062Ch */ case   65:  		/* std R11, <#[R31 + 16]> */
		/* 8207062Ch case   65:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8207062Ch case   65:*/		return 0x82070630;
		  /* 82070630h */ case   66:  		/* oris R11, R11, 8 */
		/* 82070630h case   66:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82070630h case   66:*/		return 0x82070634;
		  /* 82070634h */ case   67:  		/* std R11, <#[R31 + 16]> */
		/* 82070634h case   67:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070634h case   67:*/		return 0x82070638;
	}
	return 0x82070638;
} // Block from 82070528h-82070638h (68 instructions)

//////////////////////////////////////////////////////
// Block at 82070638h
// Function '?SetupFormat@D3D@@YAXPAVCDevice@1@W4_D3DFORMAT@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070638);
		  /* 82070638h */ case    0:  		/* oris R11, R11, 16 */
		/* 82070638h case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82070638h case    0:*/		return 0x8207063C;
		  /* 8207063Ch */ case    1:  		/* std R11, <#[R31 + 16]> */
		/* 8207063Ch case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8207063Ch case    1:*/		return 0x82070640;
		  /* 82070640h */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 82070640h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82070640h case    2:*/		return 0x82070644;
		  /* 82070644h */ case    3:  		/* bc 4, CR0_EQ, 52 */
		/* 82070644h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82070678;  }
		/* 82070644h case    3:*/		return 0x82070648;
		  /* 82070648h */ case    4:  		/* mr R10, R23 */
		/* 82070648h case    4:*/		regs.R10 = regs.R23;
		/* 82070648h case    4:*/		return 0x8207064C;
		  /* 8207064Ch */ case    5:  		/* stw R22, <#[R1 + 92]> */
		/* 8207064Ch case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x0000005C) );
		/* 8207064Ch case    5:*/		return 0x82070650;
		  /* 82070650h */ case    6:  		/* mr R9, R28 */
		/* 82070650h case    6:*/		regs.R9 = regs.R28;
		/* 82070650h case    6:*/		return 0x82070654;
		  /* 82070654h */ case    7:  		/* fmr FR1, FR31 */
		/* 82070654h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82070654h case    7:*/		return 0x82070658;
		  /* 82070658h */ case    8:  		/* mr R8, R26 */
		/* 82070658h case    8:*/		regs.R8 = regs.R26;
		/* 82070658h case    8:*/		return 0x8207065C;
		  /* 8207065Ch */ case    9:  		/* mr R7, R25 */
		/* 8207065Ch case    9:*/		regs.R7 = regs.R25;
		/* 8207065Ch case    9:*/		return 0x82070660;
		  /* 82070660h */ case   10:  		/* mr R6, R24 */
		/* 82070660h case   10:*/		regs.R6 = regs.R24;
		/* 82070660h case   10:*/		return 0x82070664;
		  /* 82070664h */ case   11:  		/* li R5, -1 */
		/* 82070664h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 82070664h case   11:*/		return 0x82070668;
		  /* 82070668h */ case   12:  		/* mr R4, R27 */
		/* 82070668h case   12:*/		regs.R4 = regs.R27;
		/* 82070668h case   12:*/		return 0x8207066C;
		  /* 8207066Ch */ case   13:  		/* mr R3, R31 */
		/* 8207066Ch case   13:*/		regs.R3 = regs.R31;
		/* 8207066Ch case   13:*/		return 0x82070670;
		  /* 82070670h */ case   14:  		/* bl -2800 */
		/* 82070670h case   14:*/		regs.LR = 0x82070674; return 0x8206FB80;
		/* 82070670h case   14:*/		return 0x82070674;
		  /* 82070674h */ case   15:  		/* b 216 */
		/* 82070674h case   15:*/		return 0x8207074C;
		/* 82070674h case   15:*/		return 0x82070678;
	}
	return 0x82070678;
} // Block from 82070638h-82070678h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82070678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070678);
		  /* 82070678h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 82070678h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82070678h case    0:*/		return 0x8207067C;
		  /* 8207067Ch */ case    1:  		/* cmplw CR6, R3, R11 */
		/* 8207067Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8207067Ch case    1:*/		return 0x82070680;
		  /* 82070680h */ case    2:  		/* bc 4, CR6_GT, 12 */
		/* 82070680h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8207068C;  }
		/* 82070680h case    2:*/		return 0x82070684;
		  /* 82070684h */ case    3:  		/* mr R3, R31 */
		/* 82070684h case    3:*/		regs.R3 = regs.R31;
		/* 82070684h case    3:*/		return 0x82070688;
		  /* 82070688h */ case    4:  		/* bl 14976 */
		/* 82070688h case    4:*/		regs.LR = 0x8207068C; return 0x82074108;
		/* 82070688h case    4:*/		return 0x8207068C;
	}
	return 0x8207068C;
} // Block from 82070678h-8207068Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8207068Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207068C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207068C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207068C);
		  /* 8207068Ch */ case    0:  		/* li R11, 8452 */
		/* 8207068Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2104);
		/* 8207068Ch case    0:*/		return 0x82070690;
		  /* 82070690h */ case    1:  		/* mr R10, R30 */
		/* 82070690h case    1:*/		regs.R10 = regs.R30;
		/* 82070690h case    1:*/		return 0x82070694;
		  /* 82070694h */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 82070694h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82070694h case    2:*/		return 0x82070698;
		  /* 82070698h */ case    3:  		/* li R11, 8706 */
		/* 82070698h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x2202);
		/* 82070698h case    3:*/		return 0x8207069C;
		  /* 8207069Ch */ case    4:  		/* li R9, 0 */
		/* 8207069Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8207069Ch case    4:*/		return 0x820706A0;
		  /* 820706A0h */ case    5:  		/* li R8, 8705 */
		/* 820706A0h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x2201);
		/* 820706A0h case    5:*/		return 0x820706A4;
		  /* 820706A4h */ case    6:  		/* lis R7, 1 */
		/* 820706A4h case    6:*/		cpu::op::lis<0>(regs,&regs.R7,0x1);
		/* 820706A4h case    6:*/		return 0x820706A8;
		  /* 820706A8h */ case    7:  		/* li R12, 1 */
		/* 820706A8h case    7:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820706A8h case    7:*/		return 0x820706AC;
		  /* 820706ACh */ case    8:  		/* stwu R10, <#[R3 + 4]> */
		/* 820706ACh case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820706ACh case    8:*/		return 0x820706B0;
		  /* 820706B0h */ case    9:  		/* ori R7, R7, 1 */
		/* 820706B0h case    9:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820706B0h case    9:*/		return 0x820706B4;
		  /* 820706B4h */ case   10:  		/* rldicr R12, R12, 37, 63 */
		/* 820706B4h case   10:*/		cpu::op::rldicr<0,37,63>(regs,&regs.R12,regs.R12);
		/* 820706B4h case   10:*/		return 0x820706B8;
		  /* 820706B8h */ case   11:  		/* li R30, 0 */
		/* 820706B8h case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820706B8h case   11:*/		return 0x820706BC;
		  /* 820706BCh */ case   12:  		/* addi R29, R31, 12816 */
		/* 820706BCh case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x3210);
		/* 820706BCh case   12:*/		return 0x820706C0;
		  /* 820706C0h */ case   13:  		/* stwu R11, <#[R3 + 4]> */
		/* 820706C0h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820706C0h case   13:*/		return 0x820706C4;
		  /* 820706C4h */ case   14:  		/* stwu R9, <#[R3 + 4]> */
		/* 820706C4h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820706C4h case   14:*/		return 0x820706C8;
		  /* 820706C8h */ case   15:  		/* stwu R8, <#[R3 + 4]> */
		/* 820706C8h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820706C8h case   15:*/		return 0x820706CC;
		  /* 820706CCh */ case   16:  		/* stwu R7, <#[R3 + 4]> */
		/* 820706CCh case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820706CCh case   16:*/		return 0x820706D0;
		  /* 820706D0h */ case   17:  		/* stw R3, <#[R31 + 48]> */
		/* 820706D0h case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 820706D0h case   17:*/		return 0x820706D4;
		  /* 820706D4h */ case   18:  		/* ld R11, <#[R31 + 16]> */
		/* 820706D4h case   18:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820706D4h case   18:*/		return 0x820706D8;
		  /* 820706D8h */ case   19:  		/* or R11, R11, R12 */
		/* 820706D8h case   19:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820706D8h case   19:*/		return 0x820706DC;
		  /* 820706DCh */ case   20:  		/* std R11, <#[R31 + 16]> */
		/* 820706DCh case   20:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820706DCh case   20:*/		return 0x820706E0;
	}
	return 0x820706E0;
} // Block from 8207068Ch-820706E0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820706E0h
// Function '?SetupGamma@D3D@@YAXPAVCDevice@1@W4_D3DFORMAT@@PBU_D3DGAMMARAMP@@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820706E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820706E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820706E0);
		  /* 820706E0h */ case    0:  		/* ori R11, R11, 512 */
		/* 820706E0h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x200);
		/* 820706E0h case    0:*/		return 0x820706E4;
		  /* 820706E4h */ case    1:  		/* std R11, <#[R31 + 16]> */
		/* 820706E4h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820706E4h case    1:*/		return 0x820706E8;
		  /* 820706E8h */ case    2:  		/* ori R11, R11, 1024 */
		/* 820706E8h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 820706E8h case    2:*/		return 0x820706EC;
		  /* 820706ECh */ case    3:  		/* std R11, <#[R31 + 16]> */
		/* 820706ECh case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820706ECh case    3:*/		return 0x820706F0;
		  /* 820706F0h */ case    4:  		/* li R11, 1 */
		/* 820706F0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820706F0h case    4:*/		return 0x820706F4;
		  /* 820706F4h */ case    5:  		/* slw R11, R11, R30 */
		/* 820706F4h case    5:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820706F4h case    5:*/		return 0x820706F8;
		  /* 820706F8h */ case    6:  		/* and. R11, R11, R27 */
		/* 820706F8h case    6:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R27);
		/* 820706F8h case    6:*/		return 0x820706FC;
		  /* 820706FCh */ case    7:  		/* bc 12, CR0_EQ, 64 */
		/* 820706FCh case    7:*/		if ( regs.CR[0].eq ) { return 0x8207073C;  }
		/* 820706FCh case    7:*/		return 0x82070700;
		  /* 82070700h */ case    8:  		/* lwz R11, <#[R29]> */
		/* 82070700h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82070700h case    8:*/		return 0x82070704;
		  /* 82070704h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82070704h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82070704h case    9:*/		return 0x82070708;
		  /* 82070708h */ case   10:  		/* bc 12, CR6_EQ, 52 */
		/* 82070708h case   10:*/		if ( regs.CR[6].eq ) { return 0x8207073C;  }
		/* 82070708h case   10:*/		return 0x8207070C;
		  /* 8207070Ch */ case   11:  		/* mr R10, R23 */
		/* 8207070Ch case   11:*/		regs.R10 = regs.R23;
		/* 8207070Ch case   11:*/		return 0x82070710;
		  /* 82070710h */ case   12:  		/* stw R22, <#[R1 + 92]> */
		/* 82070710h case   12:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x0000005C) );
		/* 82070710h case   12:*/		return 0x82070714;
		  /* 82070714h */ case   13:  		/* mr R9, R28 */
		/* 82070714h case   13:*/		regs.R9 = regs.R28;
		/* 82070714h case   13:*/		return 0x82070718;
		  /* 82070718h */ case   14:  		/* fmr FR1, FR31 */
		/* 82070718h case   14:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82070718h case   14:*/		return 0x8207071C;
		  /* 8207071Ch */ case   15:  		/* mr R8, R26 */
		/* 8207071Ch case   15:*/		regs.R8 = regs.R26;
		/* 8207071Ch case   15:*/		return 0x82070720;
		  /* 82070720h */ case   16:  		/* mr R7, R25 */
		/* 82070720h case   16:*/		regs.R7 = regs.R25;
		/* 82070720h case   16:*/		return 0x82070724;
		  /* 82070724h */ case   17:  		/* mr R6, R24 */
		/* 82070724h case   17:*/		regs.R6 = regs.R24;
		/* 82070724h case   17:*/		return 0x82070728;
		  /* 82070728h */ case   18:  		/* mr R5, R30 */
		/* 82070728h case   18:*/		regs.R5 = regs.R30;
		/* 82070728h case   18:*/		return 0x8207072C;
		  /* 8207072Ch */ case   19:  		/* mr R4, R27 */
		/* 8207072Ch case   19:*/		regs.R4 = regs.R27;
		/* 8207072Ch case   19:*/		return 0x82070730;
		  /* 82070730h */ case   20:  		/* mr R3, R31 */
		/* 82070730h case   20:*/		regs.R3 = regs.R31;
		/* 82070730h case   20:*/		return 0x82070734;
		  /* 82070734h */ case   21:  		/* bl -2996 */
		/* 82070734h case   21:*/		regs.LR = 0x82070738; return 0x8206FB80;
		/* 82070734h case   21:*/		return 0x82070738;
		  /* 82070738h */ case   22:  		/* rlwinm R27, R27, 0, 28, 23 */
		/* 82070738h case   22:*/		cpu::op::rlwinm<0,0,28,23>(regs,&regs.R27,regs.R27);
		/* 82070738h case   22:*/		return 0x8207073C;
	}
	return 0x8207073C;
} // Block from 820706E0h-8207073Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8207073Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207073C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207073C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207073C);
		  /* 8207073Ch */ case    0:  		/* addi R30, R30, 1 */
		/* 8207073Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8207073Ch case    0:*/		return 0x82070740;
		  /* 82070740h */ case    1:  		/* addi R29, R29, 4 */
		/* 82070740h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82070740h case    1:*/		return 0x82070744;
		  /* 82070744h */ case    2:  		/* cmplwi CR6, R30, 4 */
		/* 82070744h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000004);
		/* 82070744h case    2:*/		return 0x82070748;
		  /* 82070748h */ case    3:  		/* bc 12, CR6_LT, -88 */
		/* 82070748h case    3:*/		if ( regs.CR[6].lt ) { return 0x820706F0;  }
		/* 82070748h case    3:*/		return 0x8207074C;
	}
	return 0x8207074C;
} // Block from 8207073Ch-8207074Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8207074Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207074C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207074C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207074C);
		  /* 8207074Ch */ case    0:  		/* lwz R11, <#[R31 + 10440]> */
		/* 8207074Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000028C8) );
		/* 8207074Ch case    0:*/		return 0x82070750;
		  /* 82070750h */ case    1:  		/* mr R3, R31 */
		/* 82070750h case    1:*/		regs.R3 = regs.R31;
		/* 82070750h case    1:*/		return 0x82070754;
		  /* 82070754h */ case    2:  		/* lwz R10, <#[R31 + 10436]> */
		/* 82070754h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000028C4) );
		/* 82070754h case    2:*/		return 0x82070758;
		  /* 82070758h */ case    3:  		/* rlwinm R9, R11, 1, 0, 30 */
		/* 82070758h case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R11);
		/* 82070758h case    3:*/		return 0x8207075C;
		  /* 8207075Ch */ case    4:  		/* rlwinm R11, R11, 17, 0, 14 */
		/* 8207075Ch case    4:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R11,regs.R11);
		/* 8207075Ch case    4:*/		return 0x82070760;
		  /* 82070760h */ case    5:  		/* rlwinm R8, R10, 1, 0, 30 */
		/* 82070760h case    5:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R10);
		/* 82070760h case    5:*/		return 0x82070764;
		  /* 82070764h */ case    6:  		/* srawi R7, R9, 17 */
		/* 82070764h case    6:*/		cpu::op::srawi<0,17>(regs,&regs.R7,regs.R9);
		/* 82070764h case    6:*/		return 0x82070768;
		  /* 82070768h */ case    7:  		/* rlwinm R10, R10, 17, 0, 14 */
		/* 82070768h case    7:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R10,regs.R10);
		/* 82070768h case    7:*/		return 0x8207076C;
		  /* 8207076Ch */ case    8:  		/* srawi R6, R11, 17 */
		/* 8207076Ch case    8:*/		cpu::op::srawi<0,17>(regs,&regs.R6,regs.R11);
		/* 8207076Ch case    8:*/		return 0x82070770;
		  /* 82070770h */ case    9:  		/* srawi R5, R8, 17 */
		/* 82070770h case    9:*/		cpu::op::srawi<0,17>(regs,&regs.R5,regs.R8);
		/* 82070770h case    9:*/		return 0x82070774;
		  /* 82070774h */ case   10:  		/* srawi R4, R10, 17 */
		/* 82070774h case   10:*/		cpu::op::srawi<0,17>(regs,&regs.R4,regs.R10);
		/* 82070774h case   10:*/		return 0x82070778;
		  /* 82070778h */ case   11:  		/* bl -59344 */
		/* 82070778h case   11:*/		regs.LR = 0x8207077C; return 0x82061FA8;
		/* 82070778h case   11:*/		return 0x8207077C;
		  /* 8207077Ch */ case   12:  		/* lbz R11, <#[R31 + 11069]> */
		/* 8207077Ch case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 8207077Ch case   12:*/		return 0x82070780;
		  /* 82070780h */ case   13:  		/* ori R11, R11, 4 */
		/* 82070780h case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82070780h case   13:*/		return 0x82070784;
		  /* 82070784h */ case   14:  		/* stb R11, <#[R31 + 11069]> */
		/* 82070784h case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 82070784h case   14:*/		return 0x82070788;
		  /* 82070788h */ case   15:  		/* ld R11, <#[R31 + 16]> */
		/* 82070788h case   15:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070788h case   15:*/		return 0x8207078C;
		  /* 8207078Ch */ case   16:  		/* oris R11, R11, 2 */
		/* 8207078Ch case   16:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8207078Ch case   16:*/		return 0x82070790;
		  /* 82070790h */ case   17:  		/* std R11, <#[R31 + 16]> */
		/* 82070790h case   17:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82070790h case   17:*/		return 0x82070794;
	}
	return 0x82070794;
} // Block from 8207074Ch-82070794h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82070794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070794);
		  /* 82070794h */ case    0:  		/* addi R1, R1, 256 */
		/* 82070794h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 82070794h case    0:*/		return 0x82070798;
		  /* 82070798h */ case    1:  		/* lfd FR31, <#[R1 - 120]> */
		/* 82070798h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF88) );
		/* 82070798h case    1:*/		return 0x8207079C;
		  /* 8207079Ch */ case    2:  		/* b 133864 */
		/* 8207079Ch case    2:*/		return 0x82091284;
		/* 8207079Ch case    2:*/		return 0x820707A0;
	}
	return 0x820707A0;
} // Block from 82070794h-820707A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820707A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820707A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820707A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820707A0);
		  /* 820707A0h */ case    0:  		/* mfspr R12, LR */
		/* 820707A0h case    0:*/		regs.R12 = regs.LR;
		/* 820707A0h case    0:*/		return 0x820707A4;
		  /* 820707A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820707A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820707A4h case    1:*/		return 0x820707A8;
		  /* 820707A8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820707A8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820707A8h case    2:*/		return 0x820707AC;
		  /* 820707ACh */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 820707ACh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820707ACh case    3:*/		return 0x820707B0;
		  /* 820707B0h */ case    4:  		/* cmplwi CR6, R5, 0 */
		/* 820707B0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820707B0h case    4:*/		return 0x820707B4;
		  /* 820707B4h */ case    5:  		/* bc 4, CR6_EQ, 252 */
		/* 820707B4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820708B0;  }
		/* 820707B4h case    5:*/		return 0x820707B8;
		  /* 820707B8h */ case    6:  		/* lwz R7, <#[R3 + 12816]> */
		/* 820707B8h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00003210) );
		/* 820707B8h case    6:*/		return 0x820707BC;
		  /* 820707BCh */ case    7:  		/* mr R11, R7 */
		/* 820707BCh case    7:*/		regs.R11 = regs.R7;
		/* 820707BCh case    7:*/		return 0x820707C0;
		  /* 820707C0h */ case    8:  		/* cmplwi CR0, R7, 0 */
		/* 820707C0h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R7,0x00000000);
		/* 820707C0h case    8:*/		return 0x820707C4;
		  /* 820707C4h */ case    9:  		/* bc 4, CR0_EQ, 8 */
		/* 820707C4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x820707CC;  }
		/* 820707C4h case    9:*/		return 0x820707C8;
		  /* 820707C8h */ case   10:  		/* lwz R11, <#[R3 + 12832]> */
		/* 820707C8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003220) );
		/* 820707C8h case   10:*/		return 0x820707CC;
	}
	return 0x820707CC;
} // Block from 820707A0h-820707CCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820707CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820707CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820707CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820707CC);
		  /* 820707CCh */ case    0:  		/* lwz R9, <#[R11 + 36]> */
		/* 820707CCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000024) );
		/* 820707CCh case    0:*/		return 0x820707D0;
		  /* 820707D0h */ case    1:  		/* li R5, 0 */
		/* 820707D0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820707D0h case    1:*/		return 0x820707D4;
		  /* 820707D4h */ case    2:  		/* lbz R11, <#[R3 + 11068]> */
		/* 820707D4h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B3C) );
		/* 820707D4h case    2:*/		return 0x820707D8;
		  /* 820707D8h */ case    3:  		/* rlwinm R10, R9, 14, 18, 31 */
		/* 820707D8h case    3:*/		cpu::op::rlwinm<0,14,18,31>(regs,&regs.R10,regs.R9);
		/* 820707D8h case    3:*/		return 0x820707DC;
		  /* 820707DCh */ case    4:  		/* stw R5, <#[R1 + 80]> */
		/* 820707DCh case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 820707DCh case    4:*/		return 0x820707E0;
	}
	return 0x820707E0;
} // Block from 820707CCh-820707E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820707E0h
// Function '?SimpleSwap@D3D@@YAXPAVCDevice@1@KW4_D3DFORMAT@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820707E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820707E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820707E0);
		  /* 820707E0h */ case    0:  		/* rlwinm R9, R9, 29, 17, 31 */
		/* 820707E0h case    0:*/		cpu::op::rlwinm<0,29,17,31>(regs,&regs.R9,regs.R9);
		/* 820707E0h case    0:*/		return 0x820707E4;
		  /* 820707E4h */ case    1:  		/* stw R5, <#[R1 + 84]> */
		/* 820707E4h case    1:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820707E4h case    1:*/		return 0x820707E8;
		  /* 820707E8h */ case    2:  		/* addi R10, R10, 1 */
		/* 820707E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820707E8h case    2:*/		return 0x820707EC;
		  /* 820707ECh */ case    3:  		/* addi R9, R9, 1 */
		/* 820707ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820707ECh case    3:*/		return 0x820707F0;
		  /* 820707F0h */ case    4:  		/* rlwinm. R31, R11, 0, 27, 27 */
		/* 820707F0h case    4:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R31,regs.R11);
		/* 820707F0h case    4:*/		return 0x820707F4;
		  /* 820707F4h */ case    5:  		/* stw R10, <#[R1 + 88]> */
		/* 820707F4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 820707F4h case    5:*/		return 0x820707F8;
		  /* 820707F8h */ case    6:  		/* stw R9, <#[R1 + 92]> */
		/* 820707F8h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 820707F8h case    6:*/		return 0x820707FC;
		  /* 820707FCh */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 820707FCh case    7:*/		if ( regs.CR[0].eq ) { return 0x82070808;  }
		/* 820707FCh case    7:*/		return 0x82070800;
		  /* 82070800h */ case    8:  		/* li R11, 1 */
		/* 82070800h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82070800h case    8:*/		return 0x82070804;
		  /* 82070804h */ case    9:  		/* b 144 */
		/* 82070804h case    9:*/		return 0x82070894;
		/* 82070804h case    9:*/		return 0x82070808;
	}
	return 0x82070808;
} // Block from 820707E0h-82070808h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82070808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070808);
		  /* 82070808h */ case    0:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82070808h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82070808h case    0:*/		return 0x8207080C;
		  /* 8207080Ch */ case    1:  		/* bc 12, CR0_EQ, 128 */
		/* 8207080Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8207088C;  }
		/* 8207080Ch case    1:*/		return 0x82070810;
		  /* 82070810h */ case    2:  		/* lwz R11, <#[R3 + 13104]> */
		/* 82070810h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003330) );
		/* 82070810h case    2:*/		return 0x82070814;
		  /* 82070814h */ case    3:  		/* cmplw CR6, R11, R7 */
		/* 82070814h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 82070814h case    3:*/		return 0x82070818;
		  /* 82070818h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82070818h case    4:*/		if ( regs.CR[6].eq ) { return 0x82070824;  }
		/* 82070818h case    4:*/		return 0x8207081C;
		  /* 8207081Ch */ case    5:  		/* cmplwi CR6, R7, 0 */
		/* 8207081Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8207081Ch case    5:*/		return 0x82070820;
		  /* 82070820h */ case    6:  		/* bc 4, CR6_EQ, 108 */
		/* 82070820h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8207088C;  }
		/* 82070820h case    6:*/		return 0x82070824;
	}
	return 0x82070824;
} // Block from 82070808h-82070824h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82070824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070824);
		  /* 82070824h */ case    0:  		/* lwz R11, <#[R3 + 12820]> */
		/* 82070824h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003214) );
		/* 82070824h case    0:*/		return 0x82070828;
		  /* 82070828h */ case    1:  		/* lwz R10, <#[R3 + 13108]> */
		/* 82070828h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00003334) );
		/* 82070828h case    1:*/		return 0x8207082C;
		  /* 8207082Ch */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8207082Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8207082Ch case    2:*/		return 0x82070830;
		  /* 82070830h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82070830h case    3:*/		if ( regs.CR[6].eq ) { return 0x8207083C;  }
		/* 82070830h case    3:*/		return 0x82070834;
		  /* 82070834h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82070834h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82070834h case    4:*/		return 0x82070838;
		  /* 82070838h */ case    5:  		/* bc 4, CR6_EQ, 84 */
		/* 82070838h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8207088C;  }
		/* 82070838h case    5:*/		return 0x8207083C;
	}
	return 0x8207083C;
} // Block from 82070824h-8207083Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8207083Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207083C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207083C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207083C);
		  /* 8207083Ch */ case    0:  		/* lwz R11, <#[R3 + 12824]> */
		/* 8207083Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003218) );
		/* 8207083Ch case    0:*/		return 0x82070840;
		  /* 82070840h */ case    1:  		/* lwz R10, <#[R3 + 13112]> */
		/* 82070840h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00003338) );
		/* 82070840h case    1:*/		return 0x82070844;
		  /* 82070844h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82070844h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82070844h case    2:*/		return 0x82070848;
		  /* 82070848h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82070848h case    3:*/		if ( regs.CR[6].eq ) { return 0x82070854;  }
		/* 82070848h case    3:*/		return 0x8207084C;
		  /* 8207084Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8207084Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8207084Ch case    4:*/		return 0x82070850;
		  /* 82070850h */ case    5:  		/* bc 4, CR6_EQ, 60 */
		/* 82070850h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8207088C;  }
		/* 82070850h case    5:*/		return 0x82070854;
	}
	return 0x82070854;
} // Block from 8207083Ch-82070854h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82070854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070854);
		  /* 82070854h */ case    0:  		/* lwz R11, <#[R3 + 12828]> */
		/* 82070854h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000321C) );
		/* 82070854h case    0:*/		return 0x82070858;
		  /* 82070858h */ case    1:  		/* lwz R10, <#[R3 + 13116]> */
		/* 82070858h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000333C) );
		/* 82070858h case    1:*/		return 0x8207085C;
		  /* 8207085Ch */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8207085Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8207085Ch case    2:*/		return 0x82070860;
		  /* 82070860h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82070860h case    3:*/		if ( regs.CR[6].eq ) { return 0x8207086C;  }
		/* 82070860h case    3:*/		return 0x82070864;
		  /* 82070864h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82070864h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82070864h case    4:*/		return 0x82070868;
		  /* 82070868h */ case    5:  		/* bc 4, CR6_EQ, 36 */
		/* 82070868h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8207088C;  }
		/* 82070868h case    5:*/		return 0x8207086C;
	}
	return 0x8207086C;
} // Block from 82070854h-8207086Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8207086Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207086C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207086C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207086C);
		  /* 8207086Ch */ case    0:  		/* lwz R11, <#[R3 + 12832]> */
		/* 8207086Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003220) );
		/* 8207086Ch case    0:*/		return 0x82070870;
		  /* 82070870h */ case    1:  		/* lwz R10, <#[R3 + 13120]> */
		/* 82070870h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00003340) );
		/* 82070870h case    1:*/		return 0x82070874;
		  /* 82070874h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82070874h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82070874h case    2:*/		return 0x82070878;
		  /* 82070878h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82070878h case    3:*/		if ( regs.CR[6].eq ) { return 0x82070884;  }
		/* 82070878h case    3:*/		return 0x8207087C;
		  /* 8207087Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8207087Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8207087Ch case    4:*/		return 0x82070880;
		  /* 82070880h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82070880h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8207088C;  }
		/* 82070880h case    5:*/		return 0x82070884;
	}
	return 0x82070884;
} // Block from 8207086Ch-82070884h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82070884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070884);
		  /* 82070884h */ case    0:  		/* li R11, 1 */
		/* 82070884h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82070884h case    0:*/		return 0x82070888;
		  /* 82070888h */ case    1:  		/* b 8 */
		/* 82070888h case    1:*/		return 0x82070890;
		/* 82070888h case    1:*/		return 0x8207088C;
	}
	return 0x8207088C;
} // Block from 82070884h-8207088Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8207088Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207088C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207088C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207088C);
		  /* 8207088Ch */ case    0:  		/* mr R11, R5 */
		/* 8207088Ch case    0:*/		regs.R11 = regs.R5;
		/* 8207088Ch case    0:*/		return 0x82070890;
	}
	return 0x82070890;
} // Block from 8207088Ch-82070890h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82070890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070890);
		  /* 82070890h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82070890h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82070890h case    0:*/		return 0x82070894;
	}
	return 0x82070894;
} // Block from 82070890h-82070894h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82070894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070894);
		  /* 82070894h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82070894h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82070894h case    0:*/		return 0x82070898;
	}
	return 0x82070898;
} // Block from 82070894h-82070898h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82070898h
// Function '?ComplexSwap@D3D@@YAXPAVCDevice@1@KKW4_D3DFORMAT@@KKPBU_D3DPRIVATE_SCALER_PARAMETERS@@PBU_D3DGAMMARAMP@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070898);
		  /* 82070898h */ case    0:  		/* bc 12, CR0_EQ, 20 */
		/* 82070898h case    0:*/		if ( regs.CR[0].eq ) { return 0x820708AC;  }
		/* 82070898h case    0:*/		return 0x8207089C;
		  /* 8207089Ch */ case    1:  		/* lwz R11, <#[R3 + 13556]> */
		/* 8207089Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000034F4) );
		/* 8207089Ch case    1:*/		return 0x820708A0;
		  /* 820708A0h */ case    2:  		/* lwz R10, <#[R3 + 13560]> */
		/* 820708A0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000034F8) );
		/* 820708A0h case    2:*/		return 0x820708A4;
		  /* 820708A4h */ case    3:  		/* stw R11, <#[R1 + 88]> */
		/* 820708A4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 820708A4h case    3:*/		return 0x820708A8;
		  /* 820708A8h */ case    4:  		/* stw R10, <#[R1 + 92]> */
		/* 820708A8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 820708A8h case    4:*/		return 0x820708AC;
	}
	return 0x820708AC;
} // Block from 82070898h-820708ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820708ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820708AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820708AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820708AC);
		  /* 820708ACh */ case    0:  		/* addi R5, R1, 80 */
		/* 820708ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820708ACh case    0:*/		return 0x820708B0;
	}
	return 0x820708B0;
} // Block from 820708ACh-820708B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820708B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820708B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820708B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820708B0);
		  /* 820708B0h */ case    0:  		/* rlwinm. R11, R4, 0, 27, 27 */
		/* 820708B0h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R4);
		/* 820708B0h case    0:*/		return 0x820708B4;
		  /* 820708B4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 820708B4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820708C0;  }
		/* 820708B4h case    1:*/		return 0x820708B8;
		  /* 820708B8h */ case    2:  		/* lis R11, -32256 */
		/* 820708B8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820708B8h case    2:*/		return 0x820708BC;
		  /* 820708BCh */ case    3:  		/* lfs FR1, <#[R11 + 1816]> */
		/* 820708BCh case    3:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000718) );
		/* 820708BCh case    3:*/		return 0x820708C0;
	}
	return 0x820708C0;
} // Block from 820708B0h-820708C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820708C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820708C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820708C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820708C0);
		  /* 820708C0h */ case    0:  		/* bl -1952 */
		/* 820708C0h case    0:*/		regs.LR = 0x820708C4; return 0x82070120;
		/* 820708C0h case    0:*/		return 0x820708C4;
		  /* 820708C4h */ case    1:  		/* addi R1, R1, 112 */
		/* 820708C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820708C4h case    1:*/		return 0x820708C8;
		  /* 820708C8h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820708C8h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820708C8h case    2:*/		return 0x820708CC;
		  /* 820708CCh */ case    3:  		/* mtspr LR, R12 */
		/* 820708CCh case    3:*/		regs.LR = regs.R12;
		/* 820708CCh case    3:*/		return 0x820708D0;
		  /* 820708D0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820708D0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820708D0h case    4:*/		return 0x820708D4;
		  /* 820708D4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820708D4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820708D4h case    5:*/		return 0x820708D8;
	}
	return 0x820708D8;
} // Block from 820708C0h-820708D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820708D8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820708D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820708D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820708D8);
		  /* 820708D8h */ case    0:  		/* mfspr R12, LR */
		/* 820708D8h case    0:*/		regs.R12 = regs.LR;
		/* 820708D8h case    0:*/		return 0x820708DC;
		  /* 820708DCh */ case    1:  		/* bl 133496 */
		/* 820708DCh case    1:*/		regs.LR = 0x820708E0; return 0x82091254;
		/* 820708DCh case    1:*/		return 0x820708E0;
		  /* 820708E0h */ case    2:  		/* stfd FR31, <#[R1 - 56]> */
		/* 820708E0h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 820708E0h case    2:*/		return 0x820708E4;
		  /* 820708E4h */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 820708E4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820708E4h case    3:*/		return 0x820708E8;
		  /* 820708E8h */ case    4:  		/* addi R11, R1, 212 */
		/* 820708E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD4);
		/* 820708E8h case    4:*/		return 0x820708EC;
		  /* 820708ECh */ case    5:  		/* stw R7, <#[R1 + 212]> */
		/* 820708ECh case    5:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x000000D4) );
		/* 820708ECh case    5:*/		return 0x820708F0;
		  /* 820708F0h */ case    6:  		/* mr R27, R9 */
		/* 820708F0h case    6:*/		regs.R27 = regs.R9;
		/* 820708F0h case    6:*/		return 0x820708F4;
		  /* 820708F4h */ case    7:  		/* fmr FR31, FR1 */
		/* 820708F4h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 820708F4h case    7:*/		return 0x820708F8;
		  /* 820708F8h */ case    8:  		/* lis R10, -32256 */
		/* 820708F8h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820708F8h case    8:*/		return 0x820708FC;
		  /* 820708FCh */ case    9:  		/* lis R9, -32256 */
		/* 820708FCh case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 820708FCh case    9:*/		return 0x82070900;
		  /* 82070900h */ case   10:  		/* addi R10, R10, 4224 */
		/* 82070900h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1080);
		/* 82070900h case   10:*/		return 0x82070904;
		  /* 82070904h */ case   11:  		/* lvlx VR63, <#[R11]> */
		/* 82070904h case   11:*/		cpu::mem::lvlx( regs, &regs.VR63, (uint32)(regs.R11 + 0x00000000) );
		/* 82070904h case   11:*/		return 0x82070908;
		  /* 82070908h */ case   12:  		/* vsldoi VR63, VR63, VR63, 4 */
		/* 82070908h case   12:*/		cpu::op::vsldoi<0,4>(regs,&regs.VR63,regs.VR63,regs.VR63);
		/* 82070908h case   12:*/		return 0x8207090C;
		  /* 8207090Ch */ case   13:  		/* addi R9, R9, 4208 */
		/* 8207090Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1070);
		/* 8207090Ch case   13:*/		return 0x82070910;
		  /* 82070910h */ case   14:  		/* vupkd3d128 VR12, VR63, 0 */
		/* 82070910h case   14:*/		cpu::op::vupkd3d128<0,0>(regs,&regs.VR12,regs.VR63);
		/* 82070910h case   14:*/		return 0x82070914;
		  /* 82070914h */ case   15:  		/* lvx VR0, <#[R10]> */
		/* 82070914h case   15:*/		cpu::mem::lvx( regs, &regs.VR0, (uint32)(regs.R10 + 0x00000000) );
		/* 82070914h case   15:*/		return 0x82070918;
		  /* 82070918h */ case   16:  		/* addi R11, R1, 80 */
		/* 82070918h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 82070918h case   16:*/		return 0x8207091C;
		  /* 8207091Ch */ case   17:  		/* mr R29, R3 */
		/* 8207091Ch case   17:*/		regs.R29 = regs.R3;
		/* 8207091Ch case   17:*/		return 0x82070920;
		  /* 82070920h */ case   18:  		/* mr R28, R6 */
		/* 82070920h case   18:*/		regs.R28 = regs.R6;
		/* 82070920h case   18:*/		return 0x82070924;
		  /* 82070924h */ case   19:  		/* cmplwi CR6, R5, 0 */
		/* 82070924h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82070924h case   19:*/		return 0x82070928;
		  /* 82070928h */ case   20:  		/* lvx VR13, <#[R9]> */
		/* 82070928h case   20:*/		cpu::mem::lvx( regs, &regs.VR13, (uint32)(regs.R9 + 0x00000000) );
		/* 82070928h case   20:*/		return 0x8207092C;
		  /* 8207092Ch */ case   21:  		/* vmaddfp VR0, VR0, VR12, VR13 */
		/* 8207092Ch case   21:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR0,regs.VR12,regs.VR13);
		/* 8207092Ch case   21:*/		return 0x82070930;
		  /* 82070930h */ case   22:  		/* stvx VR0, <#[R11]> */
		/* 82070930h case   22:*/		cpu::mem::stvx( regs, regs.VR0, (uint32)(regs.R11 + 0x00000000) );
		/* 82070930h case   22:*/		return 0x82070934;
		  /* 82070934h */ case   23:  		/* bc 4, CR6_EQ, 28 */
		/* 82070934h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82070950;  }
		/* 82070934h case   23:*/		return 0x82070938;
		  /* 82070938h */ case   24:  		/* mr R8, R27 */
		/* 82070938h case   24:*/		regs.R8 = regs.R27;
		/* 82070938h case   24:*/		return 0x8207093C;
		  /* 8207093Ch */ case   25:  		/* addi R6, R1, 80 */
		/* 8207093Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8207093Ch case   25:*/		return 0x82070940;
		  /* 82070940h */ case   26:  		/* li R5, 0 */
		/* 82070940h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82070940h case   26:*/		return 0x82070944;
		  /* 82070944h */ case   27:  		/* mr R4, R28 */
		/* 82070944h case   27:*/		regs.R4 = regs.R28;
		/* 82070944h case   27:*/		return 0x82070948;
		  /* 82070948h */ case   28:  		/* bl -424 */
		/* 82070948h case   28:*/		regs.LR = 0x8207094C; return 0x820707A0;
		/* 82070948h case   28:*/		return 0x8207094C;
		  /* 8207094Ch */ case   29:  		/* b 60 */
		/* 8207094Ch case   29:*/		return 0x82070988;
		/* 8207094Ch case   29:*/		return 0x82070950;
	}
	return 0x82070950;
} // Block from 820708D8h-82070950h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82070950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070950);
		  /* 82070950h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 82070950h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82070950h case    0:*/		return 0x82070954;
		  /* 82070954h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 82070954h case    1:*/		if ( regs.CR[6].eq ) { return 0x82070988;  }
		/* 82070954h case    1:*/		return 0x82070958;
		  /* 82070958h */ case    2:  		/* mr R30, R5 */
		/* 82070958h case    2:*/		regs.R30 = regs.R5;
		/* 82070958h case    2:*/		return 0x8207095C;
		  /* 8207095Ch */ case    3:  		/* mr R31, R4 */
		/* 8207095Ch case    3:*/		regs.R31 = regs.R4;
		/* 8207095Ch case    3:*/		return 0x82070960;
		  /* 82070960h */ case    4:  		/* mr R8, R27 */
		/* 82070960h case    4:*/		regs.R8 = regs.R27;
		/* 82070960h case    4:*/		return 0x82070964;
		  /* 82070964h */ case    5:  		/* fmr FR1, FR31 */
		/* 82070964h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82070964h case    5:*/		return 0x82070968;
		  /* 82070968h */ case    6:  		/* addi R6, R1, 80 */
		/* 82070968h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82070968h case    6:*/		return 0x8207096C;
		  /* 8207096Ch */ case    7:  		/* mr R5, R30 */
		/* 8207096Ch case    7:*/		regs.R5 = regs.R30;
		/* 8207096Ch case    7:*/		return 0x82070970;
		  /* 82070970h */ case    8:  		/* mr R4, R28 */
		/* 82070970h case    8:*/		regs.R4 = regs.R28;
		/* 82070970h case    8:*/		return 0x82070974;
		  /* 82070974h */ case    9:  		/* mr R3, R29 */
		/* 82070974h case    9:*/		regs.R3 = regs.R29;
		/* 82070974h case    9:*/		return 0x82070978;
		  /* 82070978h */ case   10:  		/* bl -472 */
		/* 82070978h case   10:*/		regs.LR = 0x8207097C; return 0x820707A0;
		/* 82070978h case   10:*/		return 0x8207097C;
		  /* 8207097Ch */ case   11:  		/* addic. R31, R31, -1 */
		/* 8207097Ch case   11:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 8207097Ch case   11:*/		return 0x82070980;
		  /* 82070980h */ case   12:  		/* addi R30, R30, 16 */
		/* 82070980h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x10);
		/* 82070980h case   12:*/		return 0x82070984;
		  /* 82070984h */ case   13:  		/* bc 4, CR0_EQ, -36 */
		/* 82070984h case   13:*/		if ( !regs.CR[0].eq ) { return 0x82070960;  }
		/* 82070984h case   13:*/		return 0x82070988;
	}
	return 0x82070988;
} // Block from 82070950h-82070988h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82070988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070988);
		  /* 82070988h */ case    0:  		/* addi R1, R1, 160 */
		/* 82070988h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82070988h case    0:*/		return 0x8207098C;
		  /* 8207098Ch */ case    1:  		/* lfd FR31, <#[R1 - 56]> */
		/* 8207098Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 8207098Ch case    1:*/		return 0x82070990;
		  /* 82070990h */ case    2:  		/* b 133396 */
		/* 82070990h case    2:*/		return 0x820912A4;
		/* 82070990h case    2:*/		return 0x82070994;
		  /* 82070994h */ case    3:  		/* nop */
		/* 82070994h case    3:*/		cpu::op::nop();
		/* 82070994h case    3:*/		return 0x82070998;
	}
	return 0x82070998;
} // Block from 82070988h-82070998h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82070998h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070998);
		  /* 82070998h */ case    0:  		/* lwz R11, <#[R3 + 13844]> */
		/* 82070998h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003614) );
		/* 82070998h case    0:*/		return 0x8207099C;
		  /* 8207099Ch */ case    1:  		/* stw R11, <#[R3 + 48]> */
		/* 8207099Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 8207099Ch case    1:*/		return 0x820709A0;
		  /* 820709A0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820709A0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820709A0h case    2:*/		return 0x820709A4;
	}
	return 0x820709A4;
} // Block from 82070998h-820709A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820709A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820709A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820709A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820709A4);
		  /* 820709A4h */ case    0:  		/* nop */
		/* 820709A4h case    0:*/		cpu::op::nop();
		/* 820709A4h case    0:*/		return 0x820709A8;
	}
	return 0x820709A8;
} // Block from 820709A4h-820709A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820709A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820709A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820709A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820709A8);
		  /* 820709A8h */ case    0:  		/* mfspr R12, LR */
		/* 820709A8h case    0:*/		regs.R12 = regs.LR;
		/* 820709A8h case    0:*/		return 0x820709AC;
		  /* 820709ACh */ case    1:  		/* bl 133268 */
		/* 820709ACh case    1:*/		regs.LR = 0x820709B0; return 0x82091240;
		/* 820709ACh case    1:*/		return 0x820709B0;
		  /* 820709B0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820709B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820709B0h case    2:*/		return 0x820709B4;
		  /* 820709B4h */ case    3:  		/* lbz R11, <#[R3 + 12264]> */
		/* 820709B4h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FE8) );
		/* 820709B4h case    3:*/		return 0x820709B8;
		  /* 820709B8h */ case    4:  		/* rlwinm R10, R6, 30, 24, 31 */
		/* 820709B8h case    4:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R10,regs.R6);
		/* 820709B8h case    4:*/		return 0x820709BC;
		  /* 820709BCh */ case    5:  		/* mullw R9, R5, R6 */
		/* 820709BCh case    5:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R5,regs.R6);
		/* 820709BCh case    5:*/		return 0x820709C0;
		  /* 820709C0h */ case    6:  		/* lbz R25, <#[R3 + 12904]> */
		/* 820709C0h case    6:*/		cpu::mem::load8z( regs, &regs.R25, (uint32)(regs.R3 + 0x00003268) );
		/* 820709C0h case    6:*/		return 0x820709C4;
		  /* 820709C4h */ case    7:  		/* stb R10, <#[R3 + 12904]> */
		/* 820709C4h case    7:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R3 + 0x00003268) );
		/* 820709C4h case    7:*/		return 0x820709C8;
		  /* 820709C8h */ case    8:  		/* mr R31, R3 */
		/* 820709C8h case    8:*/		regs.R31 = regs.R3;
		/* 820709C8h case    8:*/		return 0x820709CC;
		  /* 820709CCh */ case    9:  		/* mr R23, R4 */
		/* 820709CCh case    9:*/		regs.R23 = regs.R4;
		/* 820709CCh case    9:*/		return 0x820709D0;
		  /* 820709D0h */ case   10:  		/* mr R24, R5 */
		/* 820709D0h case   10:*/		regs.R24 = regs.R5;
		/* 820709D0h case   10:*/		return 0x820709D4;
		  /* 820709D4h */ case   11:  		/* rlwinm R22, R9, 30, 2, 31 */
		/* 820709D4h case   11:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R22,regs.R9);
		/* 820709D4h case   11:*/		return 0x820709D8;
		  /* 820709D8h */ case   12:  		/* cmplw CR6, R10, R11 */
		/* 820709D8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820709D8h case   12:*/		return 0x820709DC;
		  /* 820709DCh */ case   13:  		/* bc 12, CR6_EQ, 28 */
		/* 820709DCh case   13:*/		if ( regs.CR[6].eq ) { return 0x820709F8;  }
		/* 820709DCh case   13:*/		return 0x820709E0;
		  /* 820709E0h */ case   14:  		/* lwz R11, <#[R3 + 13072]> */
		/* 820709E0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003310) );
		/* 820709E0h case   14:*/		return 0x820709E4;
		  /* 820709E4h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 820709E4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820709E4h case   15:*/		return 0x820709E8;
		  /* 820709E8h */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 820709E8h case   16:*/		if ( regs.CR[6].eq ) { return 0x820709F8;  }
		/* 820709E8h case   16:*/		return 0x820709EC;
		  /* 820709ECh */ case   17:  		/* ld R11, <#[R3 + 16]> */
		/* 820709ECh case   17:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820709ECh case   17:*/		return 0x820709F0;
		  /* 820709F0h */ case   18:  		/* oris R11, R11, 8 */
		/* 820709F0h case   18:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820709F0h case   18:*/		return 0x820709F4;
		  /* 820709F4h */ case   19:  		/* std R11, <#[R3 + 16]> */
		/* 820709F4h case   19:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820709F4h case   19:*/		return 0x820709F8;
	}
	return 0x820709F8;
} // Block from 820709A8h-820709F8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820709F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820709F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820709F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820709F8);
		  /* 820709F8h */ case    0:  		/* ld R11, <#[R31 + 24]> */
		/* 820709F8h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820709F8h case    0:*/		return 0x820709FC;
		  /* 820709FCh */ case    1:  		/* li R26, 0 */
		/* 820709FCh case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820709FCh case    1:*/		return 0x82070A00;
		  /* 82070A00h */ case    2:  		/* rldicr R11, R11, 0, 62 */
		/* 82070A00h case    2:*/		cpu::op::rldicr<0,0,62>(regs,&regs.R11,regs.R11);
		/* 82070A00h case    2:*/		return 0x82070A04;
		  /* 82070A04h */ case    3:  		/* std R11, <#[R31 + 24]> */
		/* 82070A04h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82070A04h case    3:*/		return 0x82070A08;
		  /* 82070A08h */ case    4:  		/* mr R28, R11 */
		/* 82070A08h case    4:*/		regs.R28 = regs.R11;
		/* 82070A08h case    4:*/		return 0x82070A0C;
		  /* 82070A0Ch */ case    5:  		/* ld R4, <#[R31]> */
		/* 82070A0Ch case    5:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82070A0Ch case    5:*/		return 0x82070A10;
		  /* 82070A10h */ case    6:  		/* cmpldi CR6, R4, 0 */
		/* 82070A10h case    6:*/		cpu::op::cmpldi<6>(regs,regs.R4,0x00000000);
		/* 82070A10h case    6:*/		return 0x82070A14;
		  /* 82070A14h */ case    7:  		/* ld R27, <#[R31 + 32]> */
		/* 82070A14h case    7:*/		cpu::mem::load64( regs, &regs.R27, (uint32)(regs.R31 + 0x00000020) );
		/* 82070A14h case    7:*/		return 0x82070A18;
		  /* 82070A18h */ case    8:  		/* ld R30, <#[R31 + 16]> */
		/* 82070A18h case    8:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 82070A18h case    8:*/		return 0x82070A1C;
		  /* 82070A1Ch */ case    9:  		/* ld R29, <#[R31 + 8]> */
		/* 82070A1Ch case    9:*/		cpu::mem::load64( regs, &regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 82070A1Ch case    9:*/		return 0x82070A20;
		  /* 82070A20h */ case   10:  		/* bc 12, CR6_EQ, 24 */
		/* 82070A20h case   10:*/		if ( regs.CR[6].eq ) { return 0x82070A38;  }
		/* 82070A20h case   10:*/		return 0x82070A24;
		  /* 82070A24h */ case   11:  		/* addi R6, R31, 1920 */
		/* 82070A24h case   11:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x780);
		/* 82070A24h case   11:*/		return 0x82070A28;
		  /* 82070A28h */ case   12:  		/* li R5, 16384 */
		/* 82070A28h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x4000);
		/* 82070A28h case   12:*/		return 0x82070A2C;
		  /* 82070A2Ch */ case   13:  		/* mr R3, R31 */
		/* 82070A2Ch case   13:*/		regs.R3 = regs.R31;
		/* 82070A2Ch case   13:*/		return 0x82070A30;
		  /* 82070A30h */ case   14:  		/* bl 77952 */
		/* 82070A30h case   14:*/		regs.LR = 0x82070A34; return 0x82083AB0;
		/* 82070A30h case   14:*/		return 0x82070A34;
		  /* 82070A34h */ case   15:  		/* std R26, <#[R31]> */
		/* 82070A34h case   15:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R31 + 0x00000000) );
		/* 82070A34h case   15:*/		return 0x82070A38;
	}
	return 0x82070A38;
} // Block from 820709F8h-82070A38h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82070A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070A38);
		  /* 82070A38h */ case    0:  		/* cmpldi CR6, R29, 0 */
		/* 82070A38h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R29,0x00000000);
		/* 82070A38h case    0:*/		return 0x82070A3C;
		  /* 82070A3Ch */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82070A3Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82070A58;  }
		/* 82070A3Ch case    1:*/		return 0x82070A40;
		  /* 82070A40h */ case    2:  		/* addi R6, R31, 6016 */
		/* 82070A40h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x1780);
		/* 82070A40h case    2:*/		return 0x82070A44;
		  /* 82070A44h */ case    3:  		/* li R5, 17408 */
		/* 82070A44h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x4400);
		/* 82070A44h case    3:*/		return 0x82070A48;
		  /* 82070A48h */ case    4:  		/* mr R4, R29 */
		/* 82070A48h case    4:*/		regs.R4 = regs.R29;
		/* 82070A48h case    4:*/		return 0x82070A4C;
		  /* 82070A4Ch */ case    5:  		/* mr R3, R31 */
		/* 82070A4Ch case    5:*/		regs.R3 = regs.R31;
		/* 82070A4Ch case    5:*/		return 0x82070A50;
		  /* 82070A50h */ case    6:  		/* bl 77920 */
		/* 82070A50h case    6:*/		regs.LR = 0x82070A54; return 0x82083AB0;
		/* 82070A50h case    6:*/		return 0x82070A54;
		  /* 82070A54h */ case    7:  		/* std R26, <#[R31 + 8]> */
		/* 82070A54h case    7:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R31 + 0x00000008) );
		/* 82070A54h case    7:*/		return 0x82070A58;
	}
	return 0x82070A58;
} // Block from 82070A38h-82070A58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070A58);
		  /* 82070A58h */ case    0:  		/* cmpldi CR6, R30, 0 */
		/* 82070A58h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R30,0x00000000);
		/* 82070A58h case    0:*/		return 0x82070A5C;
		  /* 82070A5Ch */ case    1:  		/* bc 12, CR6_EQ, 220 */
		/* 82070A5Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82070B38;  }
		/* 82070A5Ch case    1:*/		return 0x82070A60;
		  /* 82070A60h */ case    2:  		/* rlwinm R11, R30, 0, 11, 14 */
		/* 82070A60h case    2:*/		cpu::op::rlwinm<0,0,11,14>(regs,&regs.R11,regs.R30);
		/* 82070A60h case    2:*/		return 0x82070A64;
		  /* 82070A64h */ case    3:  		/* cmpldi CR6, R11, 0 */
		/* 82070A64h case    3:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070A64h case    3:*/		return 0x82070A68;
		  /* 82070A68h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82070A68h case    4:*/		if ( regs.CR[6].eq ) { return 0x82070A7C;  }
		/* 82070A68h case    4:*/		return 0x82070A6C;
		  /* 82070A6Ch */ case    5:  		/* mr R4, R30 */
		/* 82070A6Ch case    5:*/		regs.R4 = regs.R30;
		/* 82070A6Ch case    5:*/		return 0x82070A70;
		  /* 82070A70h */ case    6:  		/* mr R3, R31 */
		/* 82070A70h case    6:*/		regs.R3 = regs.R31;
		/* 82070A70h case    6:*/		return 0x82070A74;
		  /* 82070A74h */ case    7:  		/* bl 81364 */
		/* 82070A74h case    7:*/		regs.LR = 0x82070A78; return 0x82084848;
		/* 82070A74h case    7:*/		return 0x82070A78;
		  /* 82070A78h */ case    8:  		/* mr R30, R3 */
		/* 82070A78h case    8:*/		regs.R30 = regs.R3;
		/* 82070A78h case    8:*/		return 0x82070A7C;
	}
	return 0x82070A7C;
} // Block from 82070A58h-82070A7Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82070A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070A7C);
		  /* 82070A7Ch */ case    0:  		/* ld R11, <#[R31 + 40]> */
		/* 82070A7Ch case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82070A7Ch case    0:*/		return 0x82070A80;
		  /* 82070A80h */ case    1:  		/* and R11, R11, R30 */
		/* 82070A80h case    1:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82070A80h case    1:*/		return 0x82070A84;
		  /* 82070A84h */ case    2:  		/* cmpldi CR6, R11, 0 */
		/* 82070A84h case    2:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070A84h case    2:*/		return 0x82070A88;
		  /* 82070A88h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82070A88h case    3:*/		if ( regs.CR[6].eq ) { return 0x82070AA0;  }
		/* 82070A88h case    3:*/		return 0x82070A8C;
		  /* 82070A8Ch */ case    4:  		/* mr R4, R30 */
		/* 82070A8Ch case    4:*/		regs.R4 = regs.R30;
		/* 82070A8Ch case    4:*/		return 0x82070A90;
		  /* 82070A90h */ case    5:  		/* lwz R5, <#[R31 + 10560]> */
		/* 82070A90h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00002940) );
		/* 82070A90h case    5:*/		return 0x82070A94;
		  /* 82070A94h */ case    6:  		/* mr R3, R31 */
		/* 82070A94h case    6:*/		regs.R3 = regs.R31;
		/* 82070A94h case    6:*/		return 0x82070A98;
		  /* 82070A98h */ case    7:  		/* bl 76016 */
		/* 82070A98h case    7:*/		regs.LR = 0x82070A9C; return 0x82083388;
		/* 82070A98h case    7:*/		return 0x82070A9C;
		  /* 82070A9Ch */ case    8:  		/* mr R30, R3 */
		/* 82070A9Ch case    8:*/		regs.R30 = regs.R3;
		/* 82070A9Ch case    8:*/		return 0x82070AA0;
	}
	return 0x82070AA0;
} // Block from 82070A7Ch-82070AA0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82070AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070AA0);
		  /* 82070AA0h */ case    0:  		/* rldicl R11, R30, 0, 52 */
		/* 82070AA0h case    0:*/		cpu::op::rldicl<0,0,52>(regs,&regs.R11,regs.R30);
		/* 82070AA0h case    0:*/		return 0x82070AA4;
		  /* 82070AA4h */ case    1:  		/* cmpldi CR6, R11, 0 */
		/* 82070AA4h case    1:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070AA4h case    1:*/		return 0x82070AA8;
	}
	return 0x82070AA8;
} // Block from 82070AA0h-82070AA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82070AA8h
// Function '?ValidateStereo3DBlankRegion@D3D@@YAXPAVCDevice@1@PAUD3DBaseTexture@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070AA8);
		  /* 82070AA8h */ case    0:  		/* bc 12, CR6_EQ, 24 */
		/* 82070AA8h case    0:*/		if ( regs.CR[6].eq ) { return 0x82070AC0;  }
		/* 82070AA8h case    0:*/		return 0x82070AAC;
		  /* 82070AACh */ case    1:  		/* addi R6, R31, 10548 */
		/* 82070AACh case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2934);
		/* 82070AACh case    1:*/		return 0x82070AB0;
		  /* 82070AB0h */ case    2:  		/* li R5, 8704 */
		/* 82070AB0h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x2200);
		/* 82070AB0h case    2:*/		return 0x82070AB4;
		  /* 82070AB4h */ case    3:  		/* rldicr R4, R30, 52, 11 */
		/* 82070AB4h case    3:*/		cpu::op::rldicr<0,52,11>(regs,&regs.R4,regs.R30);
		/* 82070AB4h case    3:*/		return 0x82070AB8;
		  /* 82070AB8h */ case    4:  		/* mr R3, R31 */
		/* 82070AB8h case    4:*/		regs.R3 = regs.R31;
		/* 82070AB8h case    4:*/		return 0x82070ABC;
		  /* 82070ABCh */ case    5:  		/* bl 76892 */
		/* 82070ABCh case    5:*/		regs.LR = 0x82070AC0; return 0x82083718;
		/* 82070ABCh case    5:*/		return 0x82070AC0;
	}
	return 0x82070AC0;
} // Block from 82070AA8h-82070AC0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82070AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070AC0);
		  /* 82070AC0h */ case    0:  		/* rlwinm R11, R30, 0, 15, 19 */
		/* 82070AC0h case    0:*/		cpu::op::rlwinm<0,0,15,19>(regs,&regs.R11,regs.R30);
		/* 82070AC0h case    0:*/		return 0x82070AC4;
		  /* 82070AC4h */ case    1:  		/* cmpldi CR6, R11, 0 */
		/* 82070AC4h case    1:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070AC4h case    1:*/		return 0x82070AC8;
		  /* 82070AC8h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82070AC8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82070AE0;  }
		/* 82070AC8h case    2:*/		return 0x82070ACC;
		  /* 82070ACCh */ case    3:  		/* addi R6, R31, 10528 */
		/* 82070ACCh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2920);
		/* 82070ACCh case    3:*/		return 0x82070AD0;
		  /* 82070AD0h */ case    4:  		/* li R5, 8576 */
		/* 82070AD0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x2180);
		/* 82070AD0h case    4:*/		return 0x82070AD4;
		  /* 82070AD4h */ case    5:  		/* rldicr R4, R30, 47, 4 */
		/* 82070AD4h case    5:*/		cpu::op::rldicr<0,47,4>(regs,&regs.R4,regs.R30);
		/* 82070AD4h case    5:*/		return 0x82070AD8;
		  /* 82070AD8h */ case    6:  		/* mr R3, R31 */
		/* 82070AD8h case    6:*/		regs.R3 = regs.R31;
		/* 82070AD8h case    6:*/		return 0x82070ADC;
		  /* 82070ADCh */ case    7:  		/* bl 76860 */
		/* 82070ADCh case    7:*/		regs.LR = 0x82070AE0; return 0x82083718;
		/* 82070ADCh case    7:*/		return 0x82070AE0;
	}
	return 0x82070AE0;
} // Block from 82070AC0h-82070AE0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070AE0);
		  /* 82070AE0h */ case    0:  		/* lis R12, 0 */
		/* 82070AE0h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0x0);
		/* 82070AE0h case    0:*/		return 0x82070AE4;
		  /* 82070AE4h */ case    1:  		/* ori R12, R12, 65535 */
		/* 82070AE4h case    1:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFFFF);
		/* 82070AE4h case    1:*/		return 0x82070AE8;
		  /* 82070AE8h */ case    2:  		/* rldicr R12, R12, 42, 21 */
		/* 82070AE8h case    2:*/		cpu::op::rldicr<0,42,21>(regs,&regs.R12,regs.R12);
		/* 82070AE8h case    2:*/		return 0x82070AEC;
		  /* 82070AECh */ case    3:  		/* and R11, R30, R12 */
		/* 82070AECh case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R30,regs.R12);
		/* 82070AECh case    3:*/		return 0x82070AF0;
		  /* 82070AF0h */ case    4:  		/* cmpldi CR6, R11, 0 */
		/* 82070AF0h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070AF0h case    4:*/		return 0x82070AF4;
		  /* 82070AF4h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 82070AF4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82070B0C;  }
		/* 82070AF4h case    5:*/		return 0x82070AF8;
		  /* 82070AF8h */ case    6:  		/* addi R6, R31, 10368 */
		/* 82070AF8h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2880);
		/* 82070AF8h case    6:*/		return 0x82070AFC;
		  /* 82070AFCh */ case    7:  		/* li R5, 8192 */
		/* 82070AFCh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x2000);
		/* 82070AFCh case    7:*/		return 0x82070B00;
		  /* 82070B00h */ case    8:  		/* rldicr R4, R30, 6, 15 */
		/* 82070B00h case    8:*/		cpu::op::rldicr<0,6,15>(regs,&regs.R4,regs.R30);
		/* 82070B00h case    8:*/		return 0x82070B04;
		  /* 82070B04h */ case    9:  		/* mr R3, R31 */
		/* 82070B04h case    9:*/		regs.R3 = regs.R31;
		/* 82070B04h case    9:*/		return 0x82070B08;
		  /* 82070B08h */ case   10:  		/* bl 76816 */
		/* 82070B08h case   10:*/		regs.LR = 0x82070B0C; return 0x82083718;
		/* 82070B08h case   10:*/		return 0x82070B0C;
	}
	return 0x82070B0C;
} // Block from 82070AE0h-82070B0Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82070B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070B0C);
		  /* 82070B0Ch */ case    0:  		/* lis R12, -32 */
		/* 82070B0Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFE0);
		/* 82070B0Ch case    0:*/		return 0x82070B10;
		  /* 82070B10h */ case    1:  		/* rldicl R12, R12, 0, 22 */
		/* 82070B10h case    1:*/		cpu::op::rldicl<0,0,22>(regs,&regs.R12,regs.R12);
		/* 82070B10h case    1:*/		return 0x82070B14;
		  /* 82070B14h */ case    2:  		/* and R11, R30, R12 */
		/* 82070B14h case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R30,regs.R12);
		/* 82070B14h case    2:*/		return 0x82070B18;
		  /* 82070B18h */ case    3:  		/* cmpldi CR6, R11, 0 */
		/* 82070B18h case    3:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070B18h case    3:*/		return 0x82070B1C;
		  /* 82070B1Ch */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82070B1Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82070B34;  }
		/* 82070B1Ch case    4:*/		return 0x82070B20;
		  /* 82070B20h */ case    5:  		/* addi R6, R31, 10444 */
		/* 82070B20h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x28CC);
		/* 82070B20h case    5:*/		return 0x82070B24;
		  /* 82070B24h */ case    6:  		/* li R5, 8448 */
		/* 82070B24h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x2100);
		/* 82070B24h case    6:*/		return 0x82070B28;
		  /* 82070B28h */ case    7:  		/* rldicr R4, R30, 22, 20 */
		/* 82070B28h case    7:*/		cpu::op::rldicr<0,22,20>(regs,&regs.R4,regs.R30);
		/* 82070B28h case    7:*/		return 0x82070B2C;
		  /* 82070B2Ch */ case    8:  		/* mr R3, R31 */
		/* 82070B2Ch case    8:*/		regs.R3 = regs.R31;
		/* 82070B2Ch case    8:*/		return 0x82070B30;
		  /* 82070B30h */ case    9:  		/* bl 76776 */
		/* 82070B30h case    9:*/		regs.LR = 0x82070B34; return 0x82083718;
		/* 82070B30h case    9:*/		return 0x82070B34;
	}
	return 0x82070B34;
} // Block from 82070B0Ch-82070B34h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82070B34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070B34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070B34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070B34);
		  /* 82070B34h */ case    0:  		/* std R26, <#[R31 + 16]> */
		/* 82070B34h case    0:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R31 + 0x00000010) );
		/* 82070B34h case    0:*/		return 0x82070B38;
	}
	return 0x82070B38;
} // Block from 82070B34h-82070B38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82070B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070B38);
		  /* 82070B38h */ case    0:  		/* cmpldi CR6, R28, 0 */
		/* 82070B38h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R28,0x00000000);
		/* 82070B38h case    0:*/		return 0x82070B3C;
		  /* 82070B3Ch */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 82070B3Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82070B88;  }
		/* 82070B3Ch case    1:*/		return 0x82070B40;
		  /* 82070B40h */ case    2:  		/* rldicl R11, R28, 0, 32 */
		/* 82070B40h case    2:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R28);
		/* 82070B40h case    2:*/		return 0x82070B44;
		  /* 82070B44h */ case    3:  		/* cmpldi CR6, R11, 0 */
		/* 82070B44h case    3:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070B44h case    3:*/		return 0x82070B48;
		  /* 82070B48h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82070B48h case    4:*/		if ( regs.CR[6].eq ) { return 0x82070B58;  }
		/* 82070B48h case    4:*/		return 0x82070B4C;
		  /* 82070B4Ch */ case    5:  		/* rldicr R4, R28, 32, 31 */
		/* 82070B4Ch case    5:*/		cpu::op::rldicr<0,32,31>(regs,&regs.R4,regs.R28);
		/* 82070B4Ch case    5:*/		return 0x82070B50;
		  /* 82070B50h */ case    6:  		/* mr R3, R31 */
		/* 82070B50h case    6:*/		regs.R3 = regs.R31;
		/* 82070B50h case    6:*/		return 0x82070B54;
		  /* 82070B54h */ case    7:  		/* bl 77316 */
		/* 82070B54h case    7:*/		regs.LR = 0x82070B58; return 0x82083958;
		/* 82070B54h case    7:*/		return 0x82070B58;
	}
	return 0x82070B58;
} // Block from 82070B38h-82070B58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070B58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070B58);
		  /* 82070B58h */ case    0:  		/* lis R12, 31 */
		/* 82070B58h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0x1F);
		/* 82070B58h case    0:*/		return 0x82070B5C;
		  /* 82070B5Ch */ case    1:  		/* ori R12, R12, 65535 */
		/* 82070B5Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFFFF);
		/* 82070B5Ch case    1:*/		return 0x82070B60;
		  /* 82070B60h */ case    2:  		/* rldicr R12, R12, 34, 29 */
		/* 82070B60h case    2:*/		cpu::op::rldicr<0,34,29>(regs,&regs.R12,regs.R12);
		/* 82070B60h case    2:*/		return 0x82070B64;
		  /* 82070B64h */ case    3:  		/* and R11, R28, R12 */
		/* 82070B64h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R28,regs.R12);
		/* 82070B64h case    3:*/		return 0x82070B68;
		  /* 82070B68h */ case    4:  		/* cmpldi CR6, R11, 0 */
		/* 82070B68h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070B68h case    4:*/		return 0x82070B6C;
		  /* 82070B6Ch */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 82070B6Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82070B84;  }
		/* 82070B6Ch case    5:*/		return 0x82070B70;
		  /* 82070B70h */ case    6:  		/* addi R6, R31, 10596 */
		/* 82070B70h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2964);
		/* 82070B70h case    6:*/		return 0x82070B74;
		  /* 82070B74h */ case    7:  		/* li R5, 8832 */
		/* 82070B74h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x2280);
		/* 82070B74h case    7:*/		return 0x82070B78;
		  /* 82070B78h */ case    8:  		/* rldicr R4, R28, 9, 20 */
		/* 82070B78h case    8:*/		cpu::op::rldicr<0,9,20>(regs,&regs.R4,regs.R28);
		/* 82070B78h case    8:*/		return 0x82070B7C;
		  /* 82070B7Ch */ case    9:  		/* mr R3, R31 */
		/* 82070B7Ch case    9:*/		regs.R3 = regs.R31;
		/* 82070B7Ch case    9:*/		return 0x82070B80;
		  /* 82070B80h */ case   10:  		/* bl 76696 */
		/* 82070B80h case   10:*/		regs.LR = 0x82070B84; return 0x82083718;
		/* 82070B80h case   10:*/		return 0x82070B84;
	}
	return 0x82070B84;
} // Block from 82070B58h-82070B84h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82070B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070B84);
		  /* 82070B84h */ case    0:  		/* std R26, <#[R31 + 24]> */
		/* 82070B84h case    0:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R31 + 0x00000018) );
		/* 82070B84h case    0:*/		return 0x82070B88;
	}
	return 0x82070B88;
} // Block from 82070B84h-82070B88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82070B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070B88);
		  /* 82070B88h */ case    0:  		/* cmpldi CR6, R27, 0 */
		/* 82070B88h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R27,0x00000000);
		/* 82070B88h case    0:*/		return 0x82070B8C;
		  /* 82070B8Ch */ case    1:  		/* bc 12, CR6_EQ, 192 */
		/* 82070B8Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82070C4C;  }
		/* 82070B8Ch case    1:*/		return 0x82070B90;
		  /* 82070B90h */ case    2:  		/* li R12, 255 */
		/* 82070B90h case    2:*/		cpu::op::li<0>(regs,&regs.R12,0xFF);
		/* 82070B90h case    2:*/		return 0x82070B94;
		  /* 82070B94h */ case    3:  		/* rldicr R12, R12, 38, 25 */
		/* 82070B94h case    3:*/		cpu::op::rldicr<0,38,25>(regs,&regs.R12,regs.R12);
		/* 82070B94h case    3:*/		return 0x82070B98;
		  /* 82070B98h */ case    4:  		/* and R11, R27, R12 */
		/* 82070B98h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R27,regs.R12);
		/* 82070B98h case    4:*/		return 0x82070B9C;
		  /* 82070B9Ch */ case    5:  		/* cmpldi CR6, R11, 0 */
		/* 82070B9Ch case    5:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070B9Ch case    5:*/		return 0x82070BA0;
		  /* 82070BA0h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 82070BA0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82070BB8;  }
		/* 82070BA0h case    6:*/		return 0x82070BA4;
		  /* 82070BA4h */ case    7:  		/* addi R6, R31, 10832 */
		/* 82070BA4h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2A50);
		/* 82070BA4h case    7:*/		return 0x82070BA8;
		  /* 82070BA8h */ case    8:  		/* li R5, 9088 */
		/* 82070BA8h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x2380);
		/* 82070BA8h case    8:*/		return 0x82070BAC;
		  /* 82070BACh */ case    9:  		/* rldicr R4, R27, 18, 7 */
		/* 82070BACh case    9:*/		cpu::op::rldicr<0,18,7>(regs,&regs.R4,regs.R27);
		/* 82070BACh case    9:*/		return 0x82070BB0;
		  /* 82070BB0h */ case   10:  		/* mr R3, R31 */
		/* 82070BB0h case   10:*/		regs.R3 = regs.R31;
		/* 82070BB0h case   10:*/		return 0x82070BB4;
		  /* 82070BB4h */ case   11:  		/* bl 76644 */
		/* 82070BB4h case   11:*/		regs.LR = 0x82070BB8; return 0x82083718;
		/* 82070BB4h case   11:*/		return 0x82070BB8;
	}
	return 0x82070BB8;
} // Block from 82070B88h-82070BB8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82070BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070BB8);
		  /* 82070BB8h */ case    0:  		/* li R12, 63 */
		/* 82070BB8h case    0:*/		cpu::op::li<0>(regs,&regs.R12,0x3F);
		/* 82070BB8h case    0:*/		return 0x82070BBC;
		  /* 82070BBCh */ case    1:  		/* rldicr R12, R12, 49, 14 */
		/* 82070BBCh case    1:*/		cpu::op::rldicr<0,49,14>(regs,&regs.R12,regs.R12);
		/* 82070BBCh case    1:*/		return 0x82070BC0;
		  /* 82070BC0h */ case    2:  		/* and R11, R27, R12 */
		/* 82070BC0h case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R27,regs.R12);
		/* 82070BC0h case    2:*/		return 0x82070BC4;
		  /* 82070BC4h */ case    3:  		/* cmpldi CR6, R11, 0 */
		/* 82070BC4h case    3:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070BC4h case    3:*/		return 0x82070BC8;
		  /* 82070BC8h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82070BC8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82070BD8;  }
		/* 82070BC8h case    4:*/		return 0x82070BCC;
		  /* 82070BCCh */ case    5:  		/* rldicr R4, R27, 9, 5 */
		/* 82070BCCh case    5:*/		cpu::op::rldicr<0,9,5>(regs,&regs.R4,regs.R27);
		/* 82070BCCh case    5:*/		return 0x82070BD0;
		  /* 82070BD0h */ case    6:  		/* mr R3, R31 */
		/* 82070BD0h case    6:*/		regs.R3 = regs.R31;
		/* 82070BD0h case    6:*/		return 0x82070BD4;
		  /* 82070BD4h */ case    7:  		/* bl 76804 */
		/* 82070BD4h case    7:*/		regs.LR = 0x82070BD8; return 0x820837D8;
		/* 82070BD4h case    7:*/		return 0x82070BD8;
	}
	return 0x82070BD8;
} // Block from 82070BB8h-82070BD8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070BD8);
		  /* 82070BD8h */ case    0:  		/* li R12, 1 */
		/* 82070BD8h case    0:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82070BD8h case    0:*/		return 0x82070BDC;
		  /* 82070BDCh */ case    1:  		/* rldicr R12, R12, 56, 63 */
		/* 82070BDCh case    1:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 82070BDCh case    1:*/		return 0x82070BE0;
		  /* 82070BE0h */ case    2:  		/* and R11, R27, R12 */
		/* 82070BE0h case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R27,regs.R12);
		/* 82070BE0h case    2:*/		return 0x82070BE4;
		  /* 82070BE4h */ case    3:  		/* cmpldi CR6, R11, 0 */
		/* 82070BE4h case    3:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070BE4h case    3:*/		return 0x82070BE8;
		  /* 82070BE8h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82070BE8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82070C00;  }
		/* 82070BE8h case    4:*/		return 0x82070BEC;
		  /* 82070BECh */ case    5:  		/* addi R6, R31, 10112 */
		/* 82070BECh case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2780);
		/* 82070BECh case    5:*/		return 0x82070BF0;
		  /* 82070BF0h */ case    6:  		/* li R5, 18688 */
		/* 82070BF0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x4900);
		/* 82070BF0h case    6:*/		return 0x82070BF4;
		  /* 82070BF4h */ case    7:  		/* lis R4, -256 */
		/* 82070BF4h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFFF00);
		/* 82070BF4h case    7:*/		return 0x82070BF8;
		  /* 82070BF8h */ case    8:  		/* mr R3, R31 */
		/* 82070BF8h case    8:*/		regs.R3 = regs.R31;
		/* 82070BF8h case    8:*/		return 0x82070BFC;
		  /* 82070BFCh */ case    9:  		/* bl 76572 */
		/* 82070BFCh case    9:*/		regs.LR = 0x82070C00; return 0x82083718;
		/* 82070BFCh case    9:*/		return 0x82070C00;
	}
	return 0x82070C00;
} // Block from 82070BD8h-82070C00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82070C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070C00);
		  /* 82070C00h */ case    0:  		/* rldicl R11, R27, 0, 26 */
		/* 82070C00h case    0:*/		cpu::op::rldicl<0,0,26>(regs,&regs.R11,regs.R27);
		/* 82070C00h case    0:*/		return 0x82070C04;
		  /* 82070C04h */ case    1:  		/* cmpldi CR6, R11, 0 */
		/* 82070C04h case    1:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070C04h case    1:*/		return 0x82070C08;
		  /* 82070C08h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82070C08h case    2:*/		if ( regs.CR[6].eq ) { return 0x82070C20;  }
		/* 82070C08h case    2:*/		return 0x82070C0C;
		  /* 82070C0Ch */ case    3:  		/* addi R6, R31, 10680 */
		/* 82070C0Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x29B8);
		/* 82070C0Ch case    3:*/		return 0x82070C10;
		  /* 82070C10h */ case    4:  		/* li R5, 8960 */
		/* 82070C10h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x2300);
		/* 82070C10h case    4:*/		return 0x82070C14;
		  /* 82070C14h */ case    5:  		/* rldicr R4, R27, 26, 37 */
		/* 82070C14h case    5:*/		cpu::op::rldicr<0,26,37>(regs,&regs.R4,regs.R27);
		/* 82070C14h case    5:*/		return 0x82070C18;
		  /* 82070C18h */ case    6:  		/* mr R3, R31 */
		/* 82070C18h case    6:*/		regs.R3 = regs.R31;
		/* 82070C18h case    6:*/		return 0x82070C1C;
		  /* 82070C1Ch */ case    7:  		/* bl 76540 */
		/* 82070C1Ch case    7:*/		regs.LR = 0x82070C20; return 0x82083718;
		/* 82070C1Ch case    7:*/		return 0x82070C20;
	}
	return 0x82070C20;
} // Block from 82070C00h-82070C20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070C20);
		  /* 82070C20h */ case    0:  		/* rldicr R11, R27, 0, 1 */
		/* 82070C20h case    0:*/		cpu::op::rldicr<0,0,1>(regs,&regs.R11,regs.R27);
		/* 82070C20h case    0:*/		return 0x82070C24;
		  /* 82070C24h */ case    1:  		/* cmpldi CR6, R11, 0 */
		/* 82070C24h case    1:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070C24h case    1:*/		return 0x82070C28;
		  /* 82070C28h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 82070C28h case    2:*/		if ( regs.CR[6].eq ) { return 0x82070C48;  }
		/* 82070C28h case    2:*/		return 0x82070C2C;
		  /* 82070C2Ch */ case    3:  		/* lbz R11, <#[R31 + 11072]> */
		/* 82070C2Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B40) );
		/* 82070C2Ch case    3:*/		return 0x82070C30;
		  /* 82070C30h */ case    4:  		/* rlwinm. R10, R11, 0, 0, 24 */
		/* 82070C30h case    4:*/		cpu::op::rlwinm<1,0,0,24>(regs,&regs.R10,regs.R11);
		/* 82070C30h case    4:*/		return 0x82070C34;
		  /* 82070C34h */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 82070C34h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82070C40;  }
		/* 82070C34h case    5:*/		return 0x82070C38;
		  /* 82070C38h */ case    6:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82070C38h case    6:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82070C38h case    6:*/		return 0x82070C3C;
		  /* 82070C3Ch */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 82070C3Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82070C48;  }
		/* 82070C3Ch case    7:*/		return 0x82070C40;
	}
	return 0x82070C40;
} // Block from 82070C20h-82070C40h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070C40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070C40);
		  /* 82070C40h */ case    0:  		/* mr R3, R31 */
		/* 82070C40h case    0:*/		regs.R3 = regs.R31;
		/* 82070C40h case    0:*/		return 0x82070C44;
		  /* 82070C44h */ case    1:  		/* bl 49860 */
		/* 82070C44h case    1:*/		regs.LR = 0x82070C48; return 0x8207CF08;
		/* 82070C44h case    1:*/		return 0x82070C48;
	}
	return 0x82070C48;
} // Block from 82070C40h-82070C48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82070C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070C48);
		  /* 82070C48h */ case    0:  		/* std R26, <#[R31 + 32]> */
		/* 82070C48h case    0:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R31 + 0x00000020) );
		/* 82070C48h case    0:*/		return 0x82070C4C;
	}
	return 0x82070C4C;
} // Block from 82070C48h-82070C4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82070C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070C4C);
		  /* 82070C4Ch */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 82070C4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82070C4Ch case    0:*/		return 0x82070C50;
		  /* 82070C50h */ case    1:  		/* lwz R30, <#[R31 + 48]> */
		/* 82070C50h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000030) );
		/* 82070C50h case    1:*/		return 0x82070C54;
		  /* 82070C54h */ case    2:  		/* stb R25, <#[R31 + 12904]> */
		/* 82070C54h case    2:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R31 + 0x00003268) );
		/* 82070C54h case    2:*/		return 0x82070C58;
		  /* 82070C58h */ case    3:  		/* cmplw CR6, R30, R11 */
		/* 82070C58h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82070C58h case    3:*/		return 0x82070C5C;
		  /* 82070C5Ch */ case    4:  		/* bc 4, CR6_GT, 16 */
		/* 82070C5Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x82070C6C;  }
		/* 82070C5Ch case    4:*/		return 0x82070C60;
		  /* 82070C60h */ case    5:  		/* mr R3, R31 */
		/* 82070C60h case    5:*/		regs.R3 = regs.R31;
		/* 82070C60h case    5:*/		return 0x82070C64;
		  /* 82070C64h */ case    6:  		/* bl 13476 */
		/* 82070C64h case    6:*/		regs.LR = 0x82070C68; return 0x82074108;
		/* 82070C64h case    6:*/		return 0x82070C68;
		  /* 82070C68h */ case    7:  		/* mr R30, R3 */
		/* 82070C68h case    7:*/		regs.R30 = regs.R3;
		/* 82070C68h case    7:*/		return 0x82070C6C;
	}
	return 0x82070C6C;
} // Block from 82070C4Ch-82070C6Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070C6C);
		  /* 82070C6Ch */ case    0:  		/* li R5, 16 */
		/* 82070C6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 82070C6Ch case    0:*/		return 0x82070C70;
		  /* 82070C70h */ case    1:  		/* mr R4, R22 */
		/* 82070C70h case    1:*/		regs.R4 = regs.R22;
		/* 82070C70h case    1:*/		return 0x82070C74;
		  /* 82070C74h */ case    2:  		/* mr R3, R31 */
		/* 82070C74h case    2:*/		regs.R3 = regs.R31;
		/* 82070C74h case    2:*/		return 0x82070C78;
		  /* 82070C78h */ case    3:  		/* bl 8904 */
		/* 82070C78h case    3:*/		regs.LR = 0x82070C7C; return 0x82072F40;
		/* 82070C78h case    3:*/		return 0x82070C7C;
		  /* 82070C7Ch */ case    4:  		/* or. R28, R3, R3 */
		/* 82070C7Ch case    4:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 82070C7Ch case    4:*/		return 0x82070C80;
		  /* 82070C80h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82070C80h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82070C90;  }
		/* 82070C80h case    5:*/		return 0x82070C84;
		  /* 82070C84h */ case    6:  		/* stw R30, <#[R31 + 48]> */
		/* 82070C84h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000030) );
		/* 82070C84h case    6:*/		return 0x82070C88;
		  /* 82070C88h */ case    7:  		/* li R3, 0 */
		/* 82070C88h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82070C88h case    7:*/		return 0x82070C8C;
		  /* 82070C8Ch */ case    8:  		/* b 464 */
		/* 82070C8Ch case    8:*/		return 0x82070E5C;
		/* 82070C8Ch case    8:*/		return 0x82070C90;
	}
	return 0x82070C90;
} // Block from 82070C6Ch-82070C90h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82070C90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070C90);
		  /* 82070C90h */ case    0:  		/* li R11, 8450 */
		/* 82070C90h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2102);
		/* 82070C90h case    0:*/		return 0x82070C94;
		  /* 82070C94h */ case    1:  		/* lis R10, 5 */
		/* 82070C94h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x5);
		/* 82070C94h case    1:*/		return 0x82070C98;
		  /* 82070C98h */ case    2:  		/* stwu R11, <#[R30 + 4]> */
		/* 82070C98h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070C98h case    2:*/		return 0x82070C9C;
		  /* 82070C9Ch */ case    3:  		/* rlwinm R11, R28, 12, 20, 31 */
		/* 82070C9Ch case    3:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R28);
		/* 82070C9Ch case    3:*/		return 0x82070CA0;
		  /* 82070CA0h */ case    4:  		/* ori R8, R10, 18618 */
		/* 82070CA0h case    4:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x48BA);
		/* 82070CA0h case    4:*/		return 0x82070CA4;
		  /* 82070CA4h */ case    5:  		/* addi R11, R11, 512 */
		/* 82070CA4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82070CA4h case    5:*/		return 0x82070CA8;
		  /* 82070CA8h */ case    6:  		/* rlwinm R10, R28, 0, 3, 31 */
		/* 82070CA8h case    6:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R28);
		/* 82070CA8h case    6:*/		return 0x82070CAC;
		  /* 82070CACh */ case    7:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82070CACh case    7:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82070CACh case    7:*/		return 0x82070CB0;
		  /* 82070CB0h */ case    8:  		/* stwu R26, <#[R30 + 4]> */
		/* 82070CB0h case    8:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070CB0h case    8:*/		return 0x82070CB4;
		  /* 82070CB4h */ case    9:  		/* mr R9, R26 */
		/* 82070CB4h case    9:*/		regs.R9 = regs.R26;
		/* 82070CB4h case    9:*/		return 0x82070CB8;
		  /* 82070CB8h */ case   10:  		/* add R11, R11, R10 */
		/* 82070CB8h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82070CB8h case   10:*/		return 0x82070CBC;
		  /* 82070CBCh */ case   11:  		/* lis R9, 4096 */
		/* 82070CBCh case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 82070CBCh case   11:*/		return 0x82070CC0;
		  /* 82070CC0h */ case   12:  		/* ori R11, R11, 3 */
		/* 82070CC0h case   12:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3);
		/* 82070CC0h case   12:*/		return 0x82070CC4;
		  /* 82070CC4h */ case   13:  		/* ori R10, R9, 2 */
		/* 82070CC4h case   13:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R9,0x2);
		/* 82070CC4h case   13:*/		return 0x82070CC8;
		  /* 82070CC8h */ case   14:  		/* stwu R8, <#[R30 + 4]> */
		/* 82070CC8h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070CC8h case   14:*/		return 0x82070CCC;
		  /* 82070CCCh */ case   15:  		/* lis R9, 2 */
		/* 82070CCCh case   15:*/		cpu::op::lis<0>(regs,&regs.R9,0x2);
		/* 82070CCCh case   15:*/		return 0x82070CD0;
		  /* 82070CD0h */ case   16:  		/* lwz R8, <#[R31 + 1896]> */
		/* 82070CD0h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000768) );
		/* 82070CD0h case   16:*/		return 0x82070CD4;
		  /* 82070CD4h */ case   17:  		/* rlwimi R10, R22, 2, 6, 29 */
		/* 82070CD4h case   17:*/		cpu::op::rlwimi<0,2,6,29>(regs,&regs.R10,regs.R22);
		/* 82070CD4h case   17:*/		return 0x82070CD8;
		  /* 82070CD8h */ case   18:  		/* ori R9, R9, 20480 */
		/* 82070CD8h case   18:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x5000);
		/* 82070CD8h case   18:*/		return 0x82070CDC;
		  /* 82070CDCh */ case   19:  		/* mr R7, R26 */
		/* 82070CDCh case   19:*/		regs.R7 = regs.R26;
		/* 82070CDCh case   19:*/		return 0x82070CE0;
		  /* 82070CE0h */ case   20:  		/* mr R6, R26 */
		/* 82070CE0h case   20:*/		regs.R6 = regs.R26;
		/* 82070CE0h case   20:*/		return 0x82070CE4;
		  /* 82070CE4h */ case   21:  		/* stwu R8, <#[R30 + 4]> */
		/* 82070CE4h case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070CE4h case   21:*/		return 0x82070CE8;
		  /* 82070CE8h */ case   22:  		/* lwz R8, <#[R31 + 1900]> */
		/* 82070CE8h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000076C) );
		/* 82070CE8h case   22:*/		return 0x82070CEC;
		  /* 82070CECh */ case   23:  		/* stwu R8, <#[R30 + 4]> */
		/* 82070CECh case   23:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070CECh case   23:*/		return 0x82070CF0;
		  /* 82070CF0h */ case   24:  		/* lwz R8, <#[R31 + 1904]> */
		/* 82070CF0h case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000770) );
		/* 82070CF0h case   24:*/		return 0x82070CF4;
		  /* 82070CF4h */ case   25:  		/* stwu R8, <#[R30 + 4]> */
		/* 82070CF4h case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070CF4h case   25:*/		return 0x82070CF8;
		  /* 82070CF8h */ case   26:  		/* lwz R8, <#[R31 + 1908]> */
		/* 82070CF8h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000774) );
		/* 82070CF8h case   26:*/		return 0x82070CFC;
		  /* 82070CFCh */ case   27:  		/* stwu R8, <#[R30 + 4]> */
		/* 82070CFCh case   27:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070CFCh case   27:*/		return 0x82070D00;
		  /* 82070D00h */ case   28:  		/* stwu R11, <#[R30 + 4]> */
		/* 82070D00h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070D00h case   28:*/		return 0x82070D04;
		  /* 82070D04h */ case   29:  		/* stwu R10, <#[R30 + 4]> */
		/* 82070D04h case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070D04h case   29:*/		return 0x82070D08;
		  /* 82070D08h */ case   30:  		/* stwu R9, <#[R30 + 4]> */
		/* 82070D08h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070D08h case   30:*/		return 0x82070D0C;
		  /* 82070D0Ch */ case   31:  		/* stwu R26, <#[R30 + 4]> */
		/* 82070D0Ch case   31:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070D0Ch case   31:*/		return 0x82070D10;
		  /* 82070D10h */ case   32:  		/* stwu R26, <#[R30 + 4]> */
		/* 82070D10h case   32:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070D10h case   32:*/		return 0x82070D14;
		  /* 82070D14h */ case   33:  		/* stwu R26, <#[R30 + 4]> */
		/* 82070D14h case   33:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070D14h case   33:*/		return 0x82070D18;
		  /* 82070D18h */ case   34:  		/* lbz R11, <#[R31 + 12563]> */
		/* 82070D18h case   34:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003113) );
		/* 82070D18h case   34:*/		return 0x82070D1C;
		  /* 82070D1Ch */ case   35:  		/* lbz R10, <#[R31 + 11068]> */
		/* 82070D1Ch case   35:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B3C) );
		/* 82070D1Ch case   35:*/		return 0x82070D20;
		  /* 82070D20h */ case   36:  		/* add R9, R11, R31 */
		/* 82070D20h case   36:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R31);
		/* 82070D20h case   36:*/		return 0x82070D24;
		  /* 82070D24h */ case   37:  		/* addic R8, R11, -1 */
		/* 82070D24h case   37:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R11,0xFFFFFFFF);
		/* 82070D24h case   37:*/		return 0x82070D28;
		  /* 82070D28h */ case   38:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82070D28h case   38:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82070D28h case   38:*/		return 0x82070D2C;
		  /* 82070D2Ch */ case   39:  		/* lbz R10, <#[R9 + 12498]> */
		/* 82070D2Ch case   39:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R9 + 0x000030D2) );
		/* 82070D2Ch case   39:*/		return 0x82070D30;
		  /* 82070D30h */ case   40:  		/* subfe R11, R8, R11 */
		/* 82070D30h case   40:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82070D30h case   40:*/		return 0x82070D34;
		  /* 82070D34h */ case   41:  		/* rlwimi R10, R11, 8, 23, 23 */
		/* 82070D34h case   41:*/		cpu::op::rlwimi<0,8,23,23>(regs,&regs.R10,regs.R11);
		/* 82070D34h case   41:*/		return 0x82070D38;
		  /* 82070D38h */ case   42:  		/* rlwinm R29, R10, 0, 23, 31 */
		/* 82070D38h case   42:*/		cpu::op::rlwinm<0,0,23,31>(regs,&regs.R29,regs.R10);
		/* 82070D38h case   42:*/		return 0x82070D3C;
		  /* 82070D3Ch */ case   43:  		/* rlwinm R29, R29, 0, 26, 23 */
		/* 82070D3Ch case   43:*/		cpu::op::rlwinm<0,0,26,23>(regs,&regs.R29,regs.R29);
		/* 82070D3Ch case   43:*/		return 0x82070D40;
		  /* 82070D40h */ case   44:  		/* bc 4, CR0_EQ, 52 */
		/* 82070D40h case   44:*/		if ( !regs.CR[0].eq ) { return 0x82070D74;  }
		/* 82070D40h case   44:*/		return 0x82070D44;
		  /* 82070D44h */ case   45:  		/* lis R11, -16383 */
		/* 82070D44h case   45:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC001);
		/* 82070D44h case   45:*/		return 0x82070D48;
		  /* 82070D48h */ case   46:  		/* rlwinm R10, R23, 0, 26, 31 */
		/* 82070D48h case   46:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R23);
		/* 82070D48h case   46:*/		return 0x82070D4C;
		  /* 82070D4Ch */ case   47:  		/* ori R11, R11, 8705 */
		/* 82070D4Ch case   47:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2201);
		/* 82070D4Ch case   47:*/		return 0x82070D50;
		  /* 82070D50h */ case   48:  		/* rlwinm R9, R24, 16, 0, 15 */
		/* 82070D50h case   48:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R9,regs.R24);
		/* 82070D50h case   48:*/		return 0x82070D54;
		  /* 82070D54h */ case   49:  		/* stwu R11, <#[R30 + 4]> */
		/* 82070D54h case   49:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070D54h case   49:*/		return 0x82070D58;
		  /* 82070D58h */ case   50:  		/* or R11, R10, R9 */
		/* 82070D58h case   50:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 82070D58h case   50:*/		return 0x82070D5C;
		  /* 82070D5Ch */ case   51:  		/* ori R11, R11, 128 */
		/* 82070D5Ch case   51:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 82070D5Ch case   51:*/		return 0x82070D60;
		  /* 82070D60h */ case   52:  		/* stwu R29, <#[R30 + 4]> */
		/* 82070D60h case   52:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82070D60h case   52:*/		return 0x82070D64;
		  /* 82070D64h */ case   53:  		/* mr R10, R30 */
		/* 82070D64h case   53:*/		regs.R10 = regs.R30;
		/* 82070D64h case   53:*/		return 0x82070D68;
		  /* 82070D68h */ case   54:  		/* stwu R11, <#[R10 + 4]> */
		/* 82070D68h case   54:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82070D68h case   54:*/		return 0x82070D6C;
		  /* 82070D6Ch */ case   55:  		/* mr R11, R10 */
		/* 82070D6Ch case   55:*/		regs.R11 = regs.R10;
		/* 82070D6Ch case   55:*/		return 0x82070D70;
		  /* 82070D70h */ case   56:  		/* b 208 */
		/* 82070D70h case   56:*/		return 0x82070E40;
		/* 82070D70h case   56:*/		return 0x82070D74;
	}
	return 0x82070D74;
} // Block from 82070C90h-82070D74h (57 instructions)

//////////////////////////////////////////////////////
// Block at 82070D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070D74);
		  /* 82070D74h */ case    0:  		/* lwz R11, <#[R31 + 13628]> */
		/* 82070D74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000353C) );
		/* 82070D74h case    0:*/		return 0x82070D78;
		  /* 82070D78h */ case    1:  		/* addi R3, R31, 13616 */
		/* 82070D78h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x3530);
		/* 82070D78h case    1:*/		return 0x82070D7C;
		  /* 82070D7Ch */ case    2:  		/* lwz R10, <#[R31 + 13632]> */
		/* 82070D7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003540) );
		/* 82070D7Ch case    2:*/		return 0x82070D80;
		  /* 82070D80h */ case    3:  		/* addi R9, R11, 16 */
		/* 82070D80h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x10);
		/* 82070D80h case    3:*/		return 0x82070D84;
		  /* 82070D84h */ case    4:  		/* cmplw CR6, R9, R10 */
		/* 82070D84h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82070D84h case    4:*/		return 0x82070D88;
		  /* 82070D88h */ case    5:  		/* bc 4, CR6_GT, 12 */
		/* 82070D88h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82070D94;  }
		/* 82070D88h case    5:*/		return 0x82070D8C;
		  /* 82070D8Ch */ case    6:  		/* bl 11436 */
		/* 82070D8Ch case    6:*/		regs.LR = 0x82070D90; return 0x82073A38;
		/* 82070D8Ch case    6:*/		return 0x82070D90;
		  /* 82070D90h */ case    7:  		/* mr R11, R3 */
		/* 82070D90h case    7:*/		regs.R11 = regs.R3;
		/* 82070D90h case    7:*/		return 0x82070D94;
	}
	return 0x82070D94;
} // Block from 82070D74h-82070D94h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070D94);
		  /* 82070D94h */ case    0:  		/* mr R10, R30 */
		/* 82070D94h case    0:*/		regs.R10 = regs.R30;
		/* 82070D94h case    0:*/		return 0x82070D98;
		  /* 82070D98h */ case    1:  		/* stw R30, <#[R11]> */
		/* 82070D98h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82070D98h case    1:*/		return 0x82070D9C;
		  /* 82070D9Ch */ case    2:  		/* lis R9, -16384 */
		/* 82070D9Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC000);
		/* 82070D9Ch case    2:*/		return 0x82070DA0;
		  /* 82070DA0h */ case    3:  		/* addi R8, R11, 16 */
		/* 82070DA0h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x10);
		/* 82070DA0h case    3:*/		return 0x82070DA4;
		  /* 82070DA4h */ case    4:  		/* ori R9, R9, 24576 */
		/* 82070DA4h case    4:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x6000);
		/* 82070DA4h case    4:*/		return 0x82070DA8;
		  /* 82070DA8h */ case    5:  		/* stw R8, <#[R31 + 13628]> */
		/* 82070DA8h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x0000353C) );
		/* 82070DA8h case    5:*/		return 0x82070DAC;
		  /* 82070DACh */ case    6:  		/* li R8, -1 */
		/* 82070DACh case    6:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 82070DACh case    6:*/		return 0x82070DB0;
		  /* 82070DB0h */ case    7:  		/* stwu R9, <#[R10 + 4]> */
		/* 82070DB0h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82070DB0h case    7:*/		return 0x82070DB4;
		  /* 82070DB4h */ case    8:  		/* rlwinm R6, R24, 16, 0, 15 */
		/* 82070DB4h case    8:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R6,regs.R24);
		/* 82070DB4h case    8:*/		return 0x82070DB8;
		  /* 82070DB8h */ case    9:  		/* rlwinm R7, R23, 0, 26, 31 */
		/* 82070DB8h case    9:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R7,regs.R23);
		/* 82070DB8h case    9:*/		return 0x82070DBC;
		  /* 82070DBCh */ case   10:  		/* lis R9, -16383 */
		/* 82070DBCh case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC001);
		/* 82070DBCh case   10:*/		return 0x82070DC0;
		  /* 82070DC0h */ case   11:  		/* or R7, R7, R6 */
		/* 82070DC0h case   11:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R6);
		/* 82070DC0h case   11:*/		return 0x82070DC4;
		  /* 82070DC4h */ case   12:  		/* ori R9, R9, 8705 */
		/* 82070DC4h case   12:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x2201);
		/* 82070DC4h case   12:*/		return 0x82070DC8;
		  /* 82070DC8h */ case   13:  		/* stwu R8, <#[R10 + 4]> */
		/* 82070DC8h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82070DC8h case   13:*/		return 0x82070DCC;
		  /* 82070DCCh */ case   14:  		/* ori R7, R7, 128 */
		/* 82070DCCh case   14:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x80);
		/* 82070DCCh case   14:*/		return 0x82070DD0;
		  /* 82070DD0h */ case   15:  		/* lis R5, -16384 */
		/* 82070DD0h case   15:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFFC000);
		/* 82070DD0h case   15:*/		return 0x82070DD4;
		  /* 82070DD4h */ case   16:  		/* mr R6, R10 */
		/* 82070DD4h case   16:*/		regs.R6 = regs.R10;
		/* 82070DD4h case   16:*/		return 0x82070DD8;
		  /* 82070DD8h */ case   17:  		/* ori R8, R5, 24576 */
		/* 82070DD8h case   17:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R5,0x6000);
		/* 82070DD8h case   17:*/		return 0x82070DDC;
		  /* 82070DDCh */ case   18:  		/* lis R5, -32768 */
		/* 82070DDCh case   18:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8000);
		/* 82070DDCh case   18:*/		return 0x82070DE0;
		  /* 82070DE0h */ case   19:  		/* lis R10, -16383 */
		/* 82070DE0h case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC001);
		/* 82070DE0h case   19:*/		return 0x82070DE4;
		  /* 82070DE4h */ case   20:  		/* addi R11, R11, 4 */
		/* 82070DE4h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82070DE4h case   20:*/		return 0x82070DE8;
		  /* 82070DE8h */ case   21:  		/* stwu R9, <#[R6 + 4]> */
		/* 82070DE8h case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82070DE8h case   21:*/		return 0x82070DEC;
		  /* 82070DECh */ case   22:  		/* ori R4, R10, 23041 */
		/* 82070DECh case   22:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R10,0x5A01);
		/* 82070DECh case   22:*/		return 0x82070DF0;
		  /* 82070DF0h */ case   23:  		/* rlwinm R10, R11, 12, 20, 31 */
		/* 82070DF0h case   23:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R11);
		/* 82070DF0h case   23:*/		return 0x82070DF4;
		  /* 82070DF4h */ case   24:  		/* rlwinm R11, R11, 0, 3, 30 */
		/* 82070DF4h case   24:*/		cpu::op::rlwinm<0,0,3,30>(regs,&regs.R11,regs.R11);
		/* 82070DF4h case   24:*/		return 0x82070DF8;
		  /* 82070DF8h */ case   25:  		/* addi R10, R10, 512 */
		/* 82070DF8h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 82070DF8h case   25:*/		return 0x82070DFC;
		  /* 82070DFCh */ case   26:  		/* li R9, 26 */
		/* 82070DFCh case   26:*/		cpu::op::li<0>(regs,&regs.R9,0x1A);
		/* 82070DFCh case   26:*/		return 0x82070E00;
		  /* 82070E00h */ case   27:  		/* stwu R29, <#[R6 + 4]> */
		/* 82070E00h case   27:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82070E00h case   27:*/		return 0x82070E04;
		  /* 82070E04h */ case   28:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 82070E04h case   28:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 82070E04h case   28:*/		return 0x82070E08;
		  /* 82070E08h */ case   29:  		/* lis R3, -16384 */
		/* 82070E08h case   29:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFFC000);
		/* 82070E08h case   29:*/		return 0x82070E0C;
		  /* 82070E0Ch */ case   30:  		/* add R11, R10, R11 */
		/* 82070E0Ch case   30:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82070E0Ch case   30:*/		return 0x82070E10;
		  /* 82070E10h */ case   31:  		/* ori R10, R3, 17921 */
		/* 82070E10h case   31:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R3,0x4601);
		/* 82070E10h case   31:*/		return 0x82070E14;
		  /* 82070E14h */ case   32:  		/* ori R11, R11, 1 */
		/* 82070E14h case   32:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82070E14h case   32:*/		return 0x82070E18;
		  /* 82070E18h */ case   33:  		/* stwu R7, <#[R6 + 4]> */
		/* 82070E18h case   33:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82070E18h case   33:*/		return 0x82070E1C;
		  /* 82070E1Ch */ case   34:  		/* li R3, 25 */
		/* 82070E1Ch case   34:*/		cpu::op::li<0>(regs,&regs.R3,0x19);
		/* 82070E1Ch case   34:*/		return 0x82070E20;
		  /* 82070E20h */ case   35:  		/* stwu R8, <#[R6 + 4]> */
		/* 82070E20h case   35:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82070E20h case   35:*/		return 0x82070E24;
		  /* 82070E24h */ case   36:  		/* stwu R5, <#[R6 + 4]> */
		/* 82070E24h case   36:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82070E24h case   36:*/		return 0x82070E28;
		  /* 82070E28h */ case   37:  		/* stwu R4, <#[R6 + 4]> */
		/* 82070E28h case   37:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82070E28h case   37:*/		return 0x82070E2C;
		  /* 82070E2Ch */ case   38:  		/* stwu R9, <#[R6 + 4]> */
		/* 82070E2Ch case   38:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82070E2Ch case   38:*/		return 0x82070E30;
		  /* 82070E30h */ case   39:  		/* stwu R11, <#[R6 + 4]> */
		/* 82070E30h case   39:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82070E30h case   39:*/		return 0x82070E34;
		  /* 82070E34h */ case   40:  		/* stwu R10, <#[R6 + 4]> */
		/* 82070E34h case   40:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82070E34h case   40:*/		return 0x82070E38;
		  /* 82070E38h */ case   41:  		/* mr R11, R6 */
		/* 82070E38h case   41:*/		regs.R11 = regs.R6;
		/* 82070E38h case   41:*/		return 0x82070E3C;
		  /* 82070E3Ch */ case   42:  		/* stwu R3, <#[R11 + 4]> */
		/* 82070E3Ch case   42:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82070E3Ch case   42:*/		return 0x82070E40;
	}
	return 0x82070E40;
} // Block from 82070D94h-82070E40h (43 instructions)

//////////////////////////////////////////////////////
// Block at 82070E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070E40);
		  /* 82070E40h */ case    0:  		/* ld R10, <#[R31 + 24]> */
		/* 82070E40h case    0:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82070E40h case    0:*/		return 0x82070E44;
		  /* 82070E44h */ case    1:  		/* mr R3, R28 */
		/* 82070E44h case    1:*/		regs.R3 = regs.R28;
		/* 82070E44h case    1:*/		return 0x82070E48;
		  /* 82070E48h */ case    2:  		/* ori R10, R10, 1 */
		/* 82070E48h case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82070E48h case    2:*/		return 0x82070E4C;
		  /* 82070E4Ch */ case    3:  		/* std R10, <#[R31 + 24]> */
		/* 82070E4Ch case    3:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82070E4Ch case    3:*/		return 0x82070E50;
		  /* 82070E50h */ case    4:  		/* stw R11, <#[R31 + 13844]> */
		/* 82070E50h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00003614) );
		/* 82070E50h case    4:*/		return 0x82070E54;
		  /* 82070E54h */ case    5:  		/* stw R28, <#[R31 + 13848]> */
		/* 82070E54h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00003618) );
		/* 82070E54h case    5:*/		return 0x82070E58;
		  /* 82070E58h */ case    6:  		/* stw R22, <#[R31 + 13856]> */
		/* 82070E58h case    6:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00003620) );
		/* 82070E58h case    6:*/		return 0x82070E5C;
	}
	return 0x82070E5C;
} // Block from 82070E40h-82070E5Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82070E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070E5C);
		  /* 82070E5Ch */ case    0:  		/* addi R1, R1, 176 */
		/* 82070E5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82070E5Ch case    0:*/		return 0x82070E60;
		  /* 82070E60h */ case    1:  		/* b 132144 */
		/* 82070E60h case    1:*/		return 0x82091290;
		/* 82070E60h case    1:*/		return 0x82070E64;
		  /* 82070E64h */ case    2:  		/* nop */
		/* 82070E64h case    2:*/		cpu::op::nop();
		/* 82070E64h case    2:*/		return 0x82070E68;
	}
	return 0x82070E68;
} // Block from 82070E5Ch-82070E68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82070E68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070E68);
		  /* 82070E68h */ case    0:  		/* mfspr R12, LR */
		/* 82070E68h case    0:*/		regs.R12 = regs.LR;
		/* 82070E68h case    0:*/		return 0x82070E6C;
		  /* 82070E6Ch */ case    1:  		/* bl 132032 */
		/* 82070E6Ch case    1:*/		regs.LR = 0x82070E70; return 0x8209122C;
		/* 82070E6Ch case    1:*/		return 0x82070E70;
		  /* 82070E70h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 82070E70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 82070E70h case    2:*/		return 0x82070E74;
		  /* 82070E74h */ case    3:  		/* mr R18, R4 */
		/* 82070E74h case    3:*/		regs.R18 = regs.R4;
		/* 82070E74h case    3:*/		return 0x82070E78;
		  /* 82070E78h */ case    4:  		/* ld R4, <#[R3]> */
		/* 82070E78h case    4:*/		cpu::mem::load64( regs, &regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 82070E78h case    4:*/		return 0x82070E7C;
		  /* 82070E7Ch */ case    5:  		/* ld R27, <#[R3 + 32]> */
		/* 82070E7Ch case    5:*/		cpu::mem::load64( regs, &regs.R27, (uint32)(regs.R3 + 0x00000020) );
		/* 82070E7Ch case    5:*/		return 0x82070E80;
		  /* 82070E80h */ case    6:  		/* mr R31, R3 */
		/* 82070E80h case    6:*/		regs.R31 = regs.R3;
		/* 82070E80h case    6:*/		return 0x82070E84;
		  /* 82070E84h */ case    7:  		/* ld R28, <#[R3 + 24]> */
		/* 82070E84h case    7:*/		cpu::mem::load64( regs, &regs.R28, (uint32)(regs.R3 + 0x00000018) );
		/* 82070E84h case    7:*/		return 0x82070E88;
		  /* 82070E88h */ case    8:  		/* mr R17, R5 */
		/* 82070E88h case    8:*/		regs.R17 = regs.R5;
		/* 82070E88h case    8:*/		return 0x82070E8C;
		  /* 82070E8Ch */ case    9:  		/* ld R30, <#[R3 + 16]> */
		/* 82070E8Ch case    9:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R3 + 0x00000010) );
		/* 82070E8Ch case    9:*/		return 0x82070E90;
		  /* 82070E90h */ case   10:  		/* mr R21, R6 */
		/* 82070E90h case   10:*/		regs.R21 = regs.R6;
		/* 82070E90h case   10:*/		return 0x82070E94;
		  /* 82070E94h */ case   11:  		/* ld R29, <#[R3 + 8]> */
		/* 82070E94h case   11:*/		cpu::mem::load64( regs, &regs.R29, (uint32)(regs.R3 + 0x00000008) );
		/* 82070E94h case   11:*/		return 0x82070E98;
		  /* 82070E98h */ case   12:  		/* mr R19, R7 */
		/* 82070E98h case   12:*/		regs.R19 = regs.R7;
		/* 82070E98h case   12:*/		return 0x82070E9C;
		  /* 82070E9Ch */ case   13:  		/* li R26, 0 */
		/* 82070E9Ch case   13:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82070E9Ch case   13:*/		return 0x82070EA0;
		  /* 82070EA0h */ case   14:  		/* cmpldi CR6, R4, 0 */
		/* 82070EA0h case   14:*/		cpu::op::cmpldi<6>(regs,regs.R4,0x00000000);
		/* 82070EA0h case   14:*/		return 0x82070EA4;
		  /* 82070EA4h */ case   15:  		/* bc 12, CR6_EQ, 20 */
		/* 82070EA4h case   15:*/		if ( regs.CR[6].eq ) { return 0x82070EB8;  }
		/* 82070EA4h case   15:*/		return 0x82070EA8;
		  /* 82070EA8h */ case   16:  		/* addi R6, R3, 1920 */
		/* 82070EA8h case   16:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R3,0x780);
		/* 82070EA8h case   16:*/		return 0x82070EAC;
		  /* 82070EACh */ case   17:  		/* li R5, 16384 */
		/* 82070EACh case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x4000);
		/* 82070EACh case   17:*/		return 0x82070EB0;
		  /* 82070EB0h */ case   18:  		/* bl 76800 */
		/* 82070EB0h case   18:*/		regs.LR = 0x82070EB4; return 0x82083AB0;
		/* 82070EB0h case   18:*/		return 0x82070EB4;
		  /* 82070EB4h */ case   19:  		/* std R26, <#[R31]> */
		/* 82070EB4h case   19:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R31 + 0x00000000) );
		/* 82070EB4h case   19:*/		return 0x82070EB8;
	}
	return 0x82070EB8;
} // Block from 82070E68h-82070EB8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82070EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070EB8);
		  /* 82070EB8h */ case    0:  		/* cmpldi CR6, R29, 0 */
		/* 82070EB8h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R29,0x00000000);
		/* 82070EB8h case    0:*/		return 0x82070EBC;
		  /* 82070EBCh */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82070EBCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82070ED8;  }
		/* 82070EBCh case    1:*/		return 0x82070EC0;
		  /* 82070EC0h */ case    2:  		/* addi R6, R31, 6016 */
		/* 82070EC0h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x1780);
		/* 82070EC0h case    2:*/		return 0x82070EC4;
		  /* 82070EC4h */ case    3:  		/* li R5, 17408 */
		/* 82070EC4h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x4400);
		/* 82070EC4h case    3:*/		return 0x82070EC8;
		  /* 82070EC8h */ case    4:  		/* mr R4, R29 */
		/* 82070EC8h case    4:*/		regs.R4 = regs.R29;
		/* 82070EC8h case    4:*/		return 0x82070ECC;
		  /* 82070ECCh */ case    5:  		/* mr R3, R31 */
		/* 82070ECCh case    5:*/		regs.R3 = regs.R31;
		/* 82070ECCh case    5:*/		return 0x82070ED0;
		  /* 82070ED0h */ case    6:  		/* bl 76768 */
		/* 82070ED0h case    6:*/		regs.LR = 0x82070ED4; return 0x82083AB0;
		/* 82070ED0h case    6:*/		return 0x82070ED4;
		  /* 82070ED4h */ case    7:  		/* std R26, <#[R31 + 8]> */
		/* 82070ED4h case    7:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R31 + 0x00000008) );
		/* 82070ED4h case    7:*/		return 0x82070ED8;
	}
	return 0x82070ED8;
} // Block from 82070EB8h-82070ED8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070ED8);
		  /* 82070ED8h */ case    0:  		/* cmpldi CR6, R30, 0 */
		/* 82070ED8h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R30,0x00000000);
		/* 82070ED8h case    0:*/		return 0x82070EDC;
		  /* 82070EDCh */ case    1:  		/* bc 12, CR6_EQ, 220 */
		/* 82070EDCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82070FB8;  }
		/* 82070EDCh case    1:*/		return 0x82070EE0;
		  /* 82070EE0h */ case    2:  		/* rlwinm R11, R30, 0, 11, 14 */
		/* 82070EE0h case    2:*/		cpu::op::rlwinm<0,0,11,14>(regs,&regs.R11,regs.R30);
		/* 82070EE0h case    2:*/		return 0x82070EE4;
		  /* 82070EE4h */ case    3:  		/* cmpldi CR6, R11, 0 */
		/* 82070EE4h case    3:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070EE4h case    3:*/		return 0x82070EE8;
		  /* 82070EE8h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82070EE8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82070EFC;  }
		/* 82070EE8h case    4:*/		return 0x82070EEC;
		  /* 82070EECh */ case    5:  		/* mr R4, R30 */
		/* 82070EECh case    5:*/		regs.R4 = regs.R30;
		/* 82070EECh case    5:*/		return 0x82070EF0;
		  /* 82070EF0h */ case    6:  		/* mr R3, R31 */
		/* 82070EF0h case    6:*/		regs.R3 = regs.R31;
		/* 82070EF0h case    6:*/		return 0x82070EF4;
		  /* 82070EF4h */ case    7:  		/* bl 80212 */
		/* 82070EF4h case    7:*/		regs.LR = 0x82070EF8; return 0x82084848;
		/* 82070EF4h case    7:*/		return 0x82070EF8;
		  /* 82070EF8h */ case    8:  		/* mr R30, R3 */
		/* 82070EF8h case    8:*/		regs.R30 = regs.R3;
		/* 82070EF8h case    8:*/		return 0x82070EFC;
	}
	return 0x82070EFC;
} // Block from 82070ED8h-82070EFCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82070EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070EFC);
		  /* 82070EFCh */ case    0:  		/* ld R11, <#[R31 + 40]> */
		/* 82070EFCh case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82070EFCh case    0:*/		return 0x82070F00;
		  /* 82070F00h */ case    1:  		/* and R11, R11, R30 */
		/* 82070F00h case    1:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82070F00h case    1:*/		return 0x82070F04;
		  /* 82070F04h */ case    2:  		/* cmpldi CR6, R11, 0 */
		/* 82070F04h case    2:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070F04h case    2:*/		return 0x82070F08;
		  /* 82070F08h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82070F08h case    3:*/		if ( regs.CR[6].eq ) { return 0x82070F20;  }
		/* 82070F08h case    3:*/		return 0x82070F0C;
		  /* 82070F0Ch */ case    4:  		/* mr R4, R30 */
		/* 82070F0Ch case    4:*/		regs.R4 = regs.R30;
		/* 82070F0Ch case    4:*/		return 0x82070F10;
		  /* 82070F10h */ case    5:  		/* lwz R5, <#[R31 + 10560]> */
		/* 82070F10h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00002940) );
		/* 82070F10h case    5:*/		return 0x82070F14;
		  /* 82070F14h */ case    6:  		/* mr R3, R31 */
		/* 82070F14h case    6:*/		regs.R3 = regs.R31;
		/* 82070F14h case    6:*/		return 0x82070F18;
		  /* 82070F18h */ case    7:  		/* bl 74864 */
		/* 82070F18h case    7:*/		regs.LR = 0x82070F1C; return 0x82083388;
		/* 82070F18h case    7:*/		return 0x82070F1C;
		  /* 82070F1Ch */ case    8:  		/* mr R30, R3 */
		/* 82070F1Ch case    8:*/		regs.R30 = regs.R3;
		/* 82070F1Ch case    8:*/		return 0x82070F20;
	}
	return 0x82070F20;
} // Block from 82070EFCh-82070F20h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82070F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070F20);
		  /* 82070F20h */ case    0:  		/* rldicl R11, R30, 0, 52 */
		/* 82070F20h case    0:*/		cpu::op::rldicl<0,0,52>(regs,&regs.R11,regs.R30);
		/* 82070F20h case    0:*/		return 0x82070F24;
		  /* 82070F24h */ case    1:  		/* cmpldi CR6, R11, 0 */
		/* 82070F24h case    1:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070F24h case    1:*/		return 0x82070F28;
		  /* 82070F28h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82070F28h case    2:*/		if ( regs.CR[6].eq ) { return 0x82070F40;  }
		/* 82070F28h case    2:*/		return 0x82070F2C;
		  /* 82070F2Ch */ case    3:  		/* addi R6, R31, 10548 */
		/* 82070F2Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2934);
		/* 82070F2Ch case    3:*/		return 0x82070F30;
		  /* 82070F30h */ case    4:  		/* li R5, 8704 */
		/* 82070F30h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x2200);
		/* 82070F30h case    4:*/		return 0x82070F34;
		  /* 82070F34h */ case    5:  		/* rldicr R4, R30, 52, 11 */
		/* 82070F34h case    5:*/		cpu::op::rldicr<0,52,11>(regs,&regs.R4,regs.R30);
		/* 82070F34h case    5:*/		return 0x82070F38;
		  /* 82070F38h */ case    6:  		/* mr R3, R31 */
		/* 82070F38h case    6:*/		regs.R3 = regs.R31;
		/* 82070F38h case    6:*/		return 0x82070F3C;
		  /* 82070F3Ch */ case    7:  		/* bl 75740 */
		/* 82070F3Ch case    7:*/		regs.LR = 0x82070F40; return 0x82083718;
		/* 82070F3Ch case    7:*/		return 0x82070F40;
	}
	return 0x82070F40;
} // Block from 82070F20h-82070F40h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070F40);
		  /* 82070F40h */ case    0:  		/* rlwinm R11, R30, 0, 15, 19 */
		/* 82070F40h case    0:*/		cpu::op::rlwinm<0,0,15,19>(regs,&regs.R11,regs.R30);
		/* 82070F40h case    0:*/		return 0x82070F44;
		  /* 82070F44h */ case    1:  		/* cmpldi CR6, R11, 0 */
		/* 82070F44h case    1:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070F44h case    1:*/		return 0x82070F48;
		  /* 82070F48h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82070F48h case    2:*/		if ( regs.CR[6].eq ) { return 0x82070F60;  }
		/* 82070F48h case    2:*/		return 0x82070F4C;
		  /* 82070F4Ch */ case    3:  		/* addi R6, R31, 10528 */
		/* 82070F4Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2920);
		/* 82070F4Ch case    3:*/		return 0x82070F50;
		  /* 82070F50h */ case    4:  		/* li R5, 8576 */
		/* 82070F50h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x2180);
		/* 82070F50h case    4:*/		return 0x82070F54;
		  /* 82070F54h */ case    5:  		/* rldicr R4, R30, 47, 4 */
		/* 82070F54h case    5:*/		cpu::op::rldicr<0,47,4>(regs,&regs.R4,regs.R30);
		/* 82070F54h case    5:*/		return 0x82070F58;
		  /* 82070F58h */ case    6:  		/* mr R3, R31 */
		/* 82070F58h case    6:*/		regs.R3 = regs.R31;
		/* 82070F58h case    6:*/		return 0x82070F5C;
		  /* 82070F5Ch */ case    7:  		/* bl 75708 */
		/* 82070F5Ch case    7:*/		regs.LR = 0x82070F60; return 0x82083718;
		/* 82070F5Ch case    7:*/		return 0x82070F60;
	}
	return 0x82070F60;
} // Block from 82070F40h-82070F60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070F60);
		  /* 82070F60h */ case    0:  		/* lis R12, 0 */
		/* 82070F60h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0x0);
		/* 82070F60h case    0:*/		return 0x82070F64;
		  /* 82070F64h */ case    1:  		/* ori R12, R12, 65535 */
		/* 82070F64h case    1:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFFFF);
		/* 82070F64h case    1:*/		return 0x82070F68;
		  /* 82070F68h */ case    2:  		/* rldicr R12, R12, 42, 21 */
		/* 82070F68h case    2:*/		cpu::op::rldicr<0,42,21>(regs,&regs.R12,regs.R12);
		/* 82070F68h case    2:*/		return 0x82070F6C;
		  /* 82070F6Ch */ case    3:  		/* and R11, R30, R12 */
		/* 82070F6Ch case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R30,regs.R12);
		/* 82070F6Ch case    3:*/		return 0x82070F70;
		  /* 82070F70h */ case    4:  		/* cmpldi CR6, R11, 0 */
		/* 82070F70h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070F70h case    4:*/		return 0x82070F74;
		  /* 82070F74h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 82070F74h case    5:*/		if ( regs.CR[6].eq ) { return 0x82070F8C;  }
		/* 82070F74h case    5:*/		return 0x82070F78;
		  /* 82070F78h */ case    6:  		/* addi R6, R31, 10368 */
		/* 82070F78h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2880);
		/* 82070F78h case    6:*/		return 0x82070F7C;
		  /* 82070F7Ch */ case    7:  		/* li R5, 8192 */
		/* 82070F7Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x2000);
		/* 82070F7Ch case    7:*/		return 0x82070F80;
		  /* 82070F80h */ case    8:  		/* rldicr R4, R30, 6, 15 */
		/* 82070F80h case    8:*/		cpu::op::rldicr<0,6,15>(regs,&regs.R4,regs.R30);
		/* 82070F80h case    8:*/		return 0x82070F84;
		  /* 82070F84h */ case    9:  		/* mr R3, R31 */
		/* 82070F84h case    9:*/		regs.R3 = regs.R31;
		/* 82070F84h case    9:*/		return 0x82070F88;
		  /* 82070F88h */ case   10:  		/* bl 75664 */
		/* 82070F88h case   10:*/		regs.LR = 0x82070F8C; return 0x82083718;
		/* 82070F88h case   10:*/		return 0x82070F8C;
	}
	return 0x82070F8C;
} // Block from 82070F60h-82070F8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82070F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070F8C);
		  /* 82070F8Ch */ case    0:  		/* lis R12, -32 */
		/* 82070F8Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFFE0);
		/* 82070F8Ch case    0:*/		return 0x82070F90;
		  /* 82070F90h */ case    1:  		/* rldicl R12, R12, 0, 22 */
		/* 82070F90h case    1:*/		cpu::op::rldicl<0,0,22>(regs,&regs.R12,regs.R12);
		/* 82070F90h case    1:*/		return 0x82070F94;
		  /* 82070F94h */ case    2:  		/* and R11, R30, R12 */
		/* 82070F94h case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R30,regs.R12);
		/* 82070F94h case    2:*/		return 0x82070F98;
		  /* 82070F98h */ case    3:  		/* cmpldi CR6, R11, 0 */
		/* 82070F98h case    3:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070F98h case    3:*/		return 0x82070F9C;
		  /* 82070F9Ch */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82070F9Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82070FB4;  }
		/* 82070F9Ch case    4:*/		return 0x82070FA0;
		  /* 82070FA0h */ case    5:  		/* addi R6, R31, 10444 */
		/* 82070FA0h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x28CC);
		/* 82070FA0h case    5:*/		return 0x82070FA4;
		  /* 82070FA4h */ case    6:  		/* li R5, 8448 */
		/* 82070FA4h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x2100);
		/* 82070FA4h case    6:*/		return 0x82070FA8;
		  /* 82070FA8h */ case    7:  		/* rldicr R4, R30, 22, 20 */
		/* 82070FA8h case    7:*/		cpu::op::rldicr<0,22,20>(regs,&regs.R4,regs.R30);
		/* 82070FA8h case    7:*/		return 0x82070FAC;
		  /* 82070FACh */ case    8:  		/* mr R3, R31 */
		/* 82070FACh case    8:*/		regs.R3 = regs.R31;
		/* 82070FACh case    8:*/		return 0x82070FB0;
		  /* 82070FB0h */ case    9:  		/* bl 75624 */
		/* 82070FB0h case    9:*/		regs.LR = 0x82070FB4; return 0x82083718;
		/* 82070FB0h case    9:*/		return 0x82070FB4;
	}
	return 0x82070FB4;
} // Block from 82070F8Ch-82070FB4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82070FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070FB4);
		  /* 82070FB4h */ case    0:  		/* std R26, <#[R31 + 16]> */
		/* 82070FB4h case    0:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R31 + 0x00000010) );
		/* 82070FB4h case    0:*/		return 0x82070FB8;
	}
	return 0x82070FB8;
} // Block from 82070FB4h-82070FB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82070FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070FB8);
		  /* 82070FB8h */ case    0:  		/* cmpldi CR6, R28, 0 */
		/* 82070FB8h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R28,0x00000000);
		/* 82070FB8h case    0:*/		return 0x82070FBC;
		  /* 82070FBCh */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 82070FBCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82071008;  }
		/* 82070FBCh case    1:*/		return 0x82070FC0;
		  /* 82070FC0h */ case    2:  		/* rldicl R11, R28, 0, 32 */
		/* 82070FC0h case    2:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R28);
		/* 82070FC0h case    2:*/		return 0x82070FC4;
		  /* 82070FC4h */ case    3:  		/* cmpldi CR6, R11, 0 */
		/* 82070FC4h case    3:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070FC4h case    3:*/		return 0x82070FC8;
		  /* 82070FC8h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82070FC8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82070FD8;  }
		/* 82070FC8h case    4:*/		return 0x82070FCC;
		  /* 82070FCCh */ case    5:  		/* rldicr R4, R28, 32, 31 */
		/* 82070FCCh case    5:*/		cpu::op::rldicr<0,32,31>(regs,&regs.R4,regs.R28);
		/* 82070FCCh case    5:*/		return 0x82070FD0;
		  /* 82070FD0h */ case    6:  		/* mr R3, R31 */
		/* 82070FD0h case    6:*/		regs.R3 = regs.R31;
		/* 82070FD0h case    6:*/		return 0x82070FD4;
		  /* 82070FD4h */ case    7:  		/* bl 76164 */
		/* 82070FD4h case    7:*/		regs.LR = 0x82070FD8; return 0x82083958;
		/* 82070FD4h case    7:*/		return 0x82070FD8;
	}
	return 0x82070FD8;
} // Block from 82070FB8h-82070FD8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82070FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82070FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82070FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82070FD8);
		  /* 82070FD8h */ case    0:  		/* lis R12, 31 */
		/* 82070FD8h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0x1F);
		/* 82070FD8h case    0:*/		return 0x82070FDC;
		  /* 82070FDCh */ case    1:  		/* ori R12, R12, 65535 */
		/* 82070FDCh case    1:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFFFF);
		/* 82070FDCh case    1:*/		return 0x82070FE0;
		  /* 82070FE0h */ case    2:  		/* rldicr R12, R12, 34, 29 */
		/* 82070FE0h case    2:*/		cpu::op::rldicr<0,34,29>(regs,&regs.R12,regs.R12);
		/* 82070FE0h case    2:*/		return 0x82070FE4;
		  /* 82070FE4h */ case    3:  		/* and R11, R28, R12 */
		/* 82070FE4h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R28,regs.R12);
		/* 82070FE4h case    3:*/		return 0x82070FE8;
		  /* 82070FE8h */ case    4:  		/* cmpldi CR6, R11, 0 */
		/* 82070FE8h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82070FE8h case    4:*/		return 0x82070FEC;
		  /* 82070FECh */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 82070FECh case    5:*/		if ( regs.CR[6].eq ) { return 0x82071004;  }
		/* 82070FECh case    5:*/		return 0x82070FF0;
		  /* 82070FF0h */ case    6:  		/* addi R6, R31, 10596 */
		/* 82070FF0h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2964);
		/* 82070FF0h case    6:*/		return 0x82070FF4;
		  /* 82070FF4h */ case    7:  		/* li R5, 8832 */
		/* 82070FF4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x2280);
		/* 82070FF4h case    7:*/		return 0x82070FF8;
		  /* 82070FF8h */ case    8:  		/* rldicr R4, R28, 9, 20 */
		/* 82070FF8h case    8:*/		cpu::op::rldicr<0,9,20>(regs,&regs.R4,regs.R28);
		/* 82070FF8h case    8:*/		return 0x82070FFC;
		  /* 82070FFCh */ case    9:  		/* mr R3, R31 */
		/* 82070FFCh case    9:*/		regs.R3 = regs.R31;
		/* 82070FFCh case    9:*/		return 0x82071000;
		  /* 82071000h */ case   10:  		/* bl 75544 */
		/* 82071000h case   10:*/		regs.LR = 0x82071004; return 0x82083718;
		/* 82071000h case   10:*/		return 0x82071004;
	}
	return 0x82071004;
} // Block from 82070FD8h-82071004h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82071004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071004);
		  /* 82071004h */ case    0:  		/* std R26, <#[R31 + 24]> */
		/* 82071004h case    0:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R31 + 0x00000018) );
		/* 82071004h case    0:*/		return 0x82071008;
	}
	return 0x82071008;
} // Block from 82071004h-82071008h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82071008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071008);
		  /* 82071008h */ case    0:  		/* cmpldi CR6, R27, 0 */
		/* 82071008h case    0:*/		cpu::op::cmpldi<6>(regs,regs.R27,0x00000000);
		/* 82071008h case    0:*/		return 0x8207100C;
		  /* 8207100Ch */ case    1:  		/* bc 12, CR6_EQ, 192 */
		/* 8207100Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820710CC;  }
		/* 8207100Ch case    1:*/		return 0x82071010;
		  /* 82071010h */ case    2:  		/* li R12, 255 */
		/* 82071010h case    2:*/		cpu::op::li<0>(regs,&regs.R12,0xFF);
		/* 82071010h case    2:*/		return 0x82071014;
		  /* 82071014h */ case    3:  		/* rldicr R12, R12, 38, 25 */
		/* 82071014h case    3:*/		cpu::op::rldicr<0,38,25>(regs,&regs.R12,regs.R12);
		/* 82071014h case    3:*/		return 0x82071018;
		  /* 82071018h */ case    4:  		/* and R11, R27, R12 */
		/* 82071018h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R27,regs.R12);
		/* 82071018h case    4:*/		return 0x8207101C;
		  /* 8207101Ch */ case    5:  		/* cmpldi CR6, R11, 0 */
		/* 8207101Ch case    5:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 8207101Ch case    5:*/		return 0x82071020;
		  /* 82071020h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 82071020h case    6:*/		if ( regs.CR[6].eq ) { return 0x82071038;  }
		/* 82071020h case    6:*/		return 0x82071024;
		  /* 82071024h */ case    7:  		/* addi R6, R31, 10832 */
		/* 82071024h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2A50);
		/* 82071024h case    7:*/		return 0x82071028;
		  /* 82071028h */ case    8:  		/* li R5, 9088 */
		/* 82071028h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x2380);
		/* 82071028h case    8:*/		return 0x8207102C;
		  /* 8207102Ch */ case    9:  		/* rldicr R4, R27, 18, 7 */
		/* 8207102Ch case    9:*/		cpu::op::rldicr<0,18,7>(regs,&regs.R4,regs.R27);
		/* 8207102Ch case    9:*/		return 0x82071030;
		  /* 82071030h */ case   10:  		/* mr R3, R31 */
		/* 82071030h case   10:*/		regs.R3 = regs.R31;
		/* 82071030h case   10:*/		return 0x82071034;
		  /* 82071034h */ case   11:  		/* bl 75492 */
		/* 82071034h case   11:*/		regs.LR = 0x82071038; return 0x82083718;
		/* 82071034h case   11:*/		return 0x82071038;
	}
	return 0x82071038;
} // Block from 82071008h-82071038h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82071038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071038);
		  /* 82071038h */ case    0:  		/* li R12, 63 */
		/* 82071038h case    0:*/		cpu::op::li<0>(regs,&regs.R12,0x3F);
		/* 82071038h case    0:*/		return 0x8207103C;
		  /* 8207103Ch */ case    1:  		/* rldicr R12, R12, 49, 14 */
		/* 8207103Ch case    1:*/		cpu::op::rldicr<0,49,14>(regs,&regs.R12,regs.R12);
		/* 8207103Ch case    1:*/		return 0x82071040;
		  /* 82071040h */ case    2:  		/* and R11, R27, R12 */
		/* 82071040h case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R27,regs.R12);
		/* 82071040h case    2:*/		return 0x82071044;
		  /* 82071044h */ case    3:  		/* cmpldi CR6, R11, 0 */
		/* 82071044h case    3:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82071044h case    3:*/		return 0x82071048;
		  /* 82071048h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82071048h case    4:*/		if ( regs.CR[6].eq ) { return 0x82071058;  }
		/* 82071048h case    4:*/		return 0x8207104C;
		  /* 8207104Ch */ case    5:  		/* rldicr R4, R27, 9, 5 */
		/* 8207104Ch case    5:*/		cpu::op::rldicr<0,9,5>(regs,&regs.R4,regs.R27);
		/* 8207104Ch case    5:*/		return 0x82071050;
		  /* 82071050h */ case    6:  		/* mr R3, R31 */
		/* 82071050h case    6:*/		regs.R3 = regs.R31;
		/* 82071050h case    6:*/		return 0x82071054;
		  /* 82071054h */ case    7:  		/* bl 75652 */
		/* 82071054h case    7:*/		regs.LR = 0x82071058; return 0x820837D8;
		/* 82071054h case    7:*/		return 0x82071058;
	}
	return 0x82071058;
} // Block from 82071038h-82071058h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82071058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071058);
		  /* 82071058h */ case    0:  		/* li R12, 1 */
		/* 82071058h case    0:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82071058h case    0:*/		return 0x8207105C;
		  /* 8207105Ch */ case    1:  		/* rldicr R12, R12, 56, 63 */
		/* 8207105Ch case    1:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 8207105Ch case    1:*/		return 0x82071060;
		  /* 82071060h */ case    2:  		/* and R11, R27, R12 */
		/* 82071060h case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R27,regs.R12);
		/* 82071060h case    2:*/		return 0x82071064;
		  /* 82071064h */ case    3:  		/* cmpldi CR6, R11, 0 */
		/* 82071064h case    3:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82071064h case    3:*/		return 0x82071068;
		  /* 82071068h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82071068h case    4:*/		if ( regs.CR[6].eq ) { return 0x82071080;  }
		/* 82071068h case    4:*/		return 0x8207106C;
		  /* 8207106Ch */ case    5:  		/* addi R6, R31, 10112 */
		/* 8207106Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2780);
		/* 8207106Ch case    5:*/		return 0x82071070;
		  /* 82071070h */ case    6:  		/* li R5, 18688 */
		/* 82071070h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x4900);
		/* 82071070h case    6:*/		return 0x82071074;
		  /* 82071074h */ case    7:  		/* lis R4, -256 */
		/* 82071074h case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFFF00);
		/* 82071074h case    7:*/		return 0x82071078;
		  /* 82071078h */ case    8:  		/* mr R3, R31 */
		/* 82071078h case    8:*/		regs.R3 = regs.R31;
		/* 82071078h case    8:*/		return 0x8207107C;
		  /* 8207107Ch */ case    9:  		/* bl 75420 */
		/* 8207107Ch case    9:*/		regs.LR = 0x82071080; return 0x82083718;
		/* 8207107Ch case    9:*/		return 0x82071080;
	}
	return 0x82071080;
} // Block from 82071058h-82071080h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82071080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071080);
		  /* 82071080h */ case    0:  		/* rldicl R11, R27, 0, 26 */
		/* 82071080h case    0:*/		cpu::op::rldicl<0,0,26>(regs,&regs.R11,regs.R27);
		/* 82071080h case    0:*/		return 0x82071084;
		  /* 82071084h */ case    1:  		/* cmpldi CR6, R11, 0 */
		/* 82071084h case    1:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 82071084h case    1:*/		return 0x82071088;
		  /* 82071088h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82071088h case    2:*/		if ( regs.CR[6].eq ) { return 0x820710A0;  }
		/* 82071088h case    2:*/		return 0x8207108C;
		  /* 8207108Ch */ case    3:  		/* addi R6, R31, 10680 */
		/* 8207108Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x29B8);
		/* 8207108Ch case    3:*/		return 0x82071090;
		  /* 82071090h */ case    4:  		/* li R5, 8960 */
		/* 82071090h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x2300);
		/* 82071090h case    4:*/		return 0x82071094;
		  /* 82071094h */ case    5:  		/* rldicr R4, R27, 26, 37 */
		/* 82071094h case    5:*/		cpu::op::rldicr<0,26,37>(regs,&regs.R4,regs.R27);
		/* 82071094h case    5:*/		return 0x82071098;
		  /* 82071098h */ case    6:  		/* mr R3, R31 */
		/* 82071098h case    6:*/		regs.R3 = regs.R31;
		/* 82071098h case    6:*/		return 0x8207109C;
		  /* 8207109Ch */ case    7:  		/* bl 75388 */
		/* 8207109Ch case    7:*/		regs.LR = 0x820710A0; return 0x82083718;
		/* 8207109Ch case    7:*/		return 0x820710A0;
	}
	return 0x820710A0;
} // Block from 82071080h-820710A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820710A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820710A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820710A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820710A0);
		  /* 820710A0h */ case    0:  		/* rldicr R11, R27, 0, 1 */
		/* 820710A0h case    0:*/		cpu::op::rldicr<0,0,1>(regs,&regs.R11,regs.R27);
		/* 820710A0h case    0:*/		return 0x820710A4;
		  /* 820710A4h */ case    1:  		/* cmpldi CR6, R11, 0 */
		/* 820710A4h case    1:*/		cpu::op::cmpldi<6>(regs,regs.R11,0x00000000);
		/* 820710A4h case    1:*/		return 0x820710A8;
		  /* 820710A8h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820710A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820710C8;  }
		/* 820710A8h case    2:*/		return 0x820710AC;
		  /* 820710ACh */ case    3:  		/* lbz R11, <#[R31 + 11072]> */
		/* 820710ACh case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B40) );
		/* 820710ACh case    3:*/		return 0x820710B0;
		  /* 820710B0h */ case    4:  		/* rlwinm. R10, R11, 0, 0, 24 */
		/* 820710B0h case    4:*/		cpu::op::rlwinm<1,0,0,24>(regs,&regs.R10,regs.R11);
		/* 820710B0h case    4:*/		return 0x820710B4;
		  /* 820710B4h */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 820710B4h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820710C0;  }
		/* 820710B4h case    5:*/		return 0x820710B8;
		  /* 820710B8h */ case    6:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 820710B8h case    6:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 820710B8h case    6:*/		return 0x820710BC;
		  /* 820710BCh */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 820710BCh case    7:*/		if ( regs.CR[0].eq ) { return 0x820710C8;  }
		/* 820710BCh case    7:*/		return 0x820710C0;
	}
	return 0x820710C0;
} // Block from 820710A0h-820710C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820710C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820710C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820710C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820710C0);
		  /* 820710C0h */ case    0:  		/* mr R3, R31 */
		/* 820710C0h case    0:*/		regs.R3 = regs.R31;
		/* 820710C0h case    0:*/		return 0x820710C4;
		  /* 820710C4h */ case    1:  		/* bl 48708 */
		/* 820710C4h case    1:*/		regs.LR = 0x820710C8; return 0x8207CF08;
		/* 820710C4h case    1:*/		return 0x820710C8;
	}
	return 0x820710C8;
} // Block from 820710C0h-820710C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820710C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820710C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820710C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820710C8);
		  /* 820710C8h */ case    0:  		/* std R26, <#[R31 + 32]> */
		/* 820710C8h case    0:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R31 + 0x00000020) );
		/* 820710C8h case    0:*/		return 0x820710CC;
	}
	return 0x820710CC;
} // Block from 820710C8h-820710CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820710CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820710CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820710CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820710CC);
		  /* 820710CCh */ case    0:  		/* lis R11, -32256 */
		/* 820710CCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820710CCh case    0:*/		return 0x820710D0;
		  /* 820710D0h */ case    1:  		/* lwz R24, <#[R31 + 12812]> */
		/* 820710D0h case    1:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R31 + 0x0000320C) );
		/* 820710D0h case    1:*/		return 0x820710D4;
		  /* 820710D4h */ case    2:  		/* addi R23, R31, 12498 */
		/* 820710D4h case    2:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R31,0x30D2);
		/* 820710D4h case    2:*/		return 0x820710D8;
		  /* 820710D8h */ case    3:  		/* rlwinm R22, R18, 0, 26, 31 */
		/* 820710D8h case    3:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R22,regs.R18);
		/* 820710D8h case    3:*/		return 0x820710DC;
		  /* 820710DCh */ case    4:  		/* addi R20, R11, 1568 */
		/* 820710DCh case    4:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R11,0x620);
		/* 820710DCh case    4:*/		return 0x820710E0;
		  /* 820710E0h */ case    5:  		/* lwz R3, <#[R31 + 48]> */
		/* 820710E0h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 820710E0h case    5:*/		return 0x820710E4;
		  /* 820710E4h */ case    6:  		/* lwz R11, <#[R31 + 56]> */
		/* 820710E4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820710E4h case    6:*/		return 0x820710E8;
		  /* 820710E8h */ case    7:  		/* cmplw CR6, R3, R11 */
		/* 820710E8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820710E8h case    7:*/		return 0x820710EC;
		  /* 820710ECh */ case    8:  		/* bc 4, CR6_GT, 12 */
		/* 820710ECh case    8:*/		if ( !regs.CR[6].gt ) { return 0x820710F8;  }
		/* 820710ECh case    8:*/		return 0x820710F0;
		  /* 820710F0h */ case    9:  		/* mr R3, R31 */
		/* 820710F0h case    9:*/		regs.R3 = regs.R31;
		/* 820710F0h case    9:*/		return 0x820710F4;
		  /* 820710F4h */ case   10:  		/* bl 12308 */
		/* 820710F4h case   10:*/		regs.LR = 0x820710F8; return 0x82074108;
		/* 820710F4h case   10:*/		return 0x820710F8;
	}
	return 0x820710F8;
} // Block from 820710CCh-820710F8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820710F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820710F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820710F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820710F8);
		  /* 820710F8h */ case    0:  		/* li R11, 8450 */
		/* 820710F8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2102);
		/* 820710F8h case    0:*/		return 0x820710FC;
		  /* 820710FCh */ case    1:  		/* mr R27, R19 */
		/* 820710FCh case    1:*/		regs.R27 = regs.R19;
		/* 820710FCh case    1:*/		return 0x82071100;
		  /* 82071100h */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 82071100h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071100h case    2:*/		return 0x82071104;
		  /* 82071104h */ case    3:  		/* cmplwi CR6, R19, 65535 */
		/* 82071104h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x0000FFFF);
		/* 82071104h case    3:*/		return 0x82071108;
		  /* 82071108h */ case    4:  		/* stwu R17, <#[R3 + 4]> */
		/* 82071108h case    4:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071108h case    4:*/		return 0x8207110C;
		  /* 8207110Ch */ case    5:  		/* mr R25, R3 */
		/* 8207110Ch case    5:*/		regs.R25 = regs.R3;
		/* 8207110Ch case    5:*/		return 0x82071110;
		  /* 82071110h */ case    6:  		/* bc 4, CR6_GT, 36 */
		/* 82071110h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82071134;  }
		/* 82071110h case    6:*/		return 0x82071114;
		  /* 82071114h */ case    7:  		/* rlwinm R11, R18, 3, 0, 28 */
		/* 82071114h case    7:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R18);
		/* 82071114h case    7:*/		return 0x82071118;
		  /* 82071118h */ case    8:  		/* lis R10, 0 */
		/* 82071118h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 82071118h case    8:*/		return 0x8207111C;
		  /* 8207111Ch */ case    9:  		/* ori R10, R10, 65535 */
		/* 8207111Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0xFFFF);
		/* 8207111Ch case    9:*/		return 0x82071120;
		  /* 82071120h */ case   10:  		/* lwzx R11, <#[R11 + R20]> */
		/* 82071120h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 82071120h case   10:*/		return 0x82071124;
		  /* 82071124h */ case   11:  		/* divwu R10, R10, R11 */
		/* 82071124h case   11:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82071124h case   11:*/		return 0x82071128;
		  /* 82071128h */ case   12:  		/* twi 6, R11, 0 */
		/* 82071128h case   12:*/		cpu::op::tw<6>(regs, 0x82071128, regs.R11, 0x00000000);
		/* 82071128h case   12:*/		return 0x8207112C;
		  /* 8207112Ch */ case   13:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 8207112Ch case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 8207112Ch case   13:*/		return 0x82071130;
		  /* 82071130h */ case   14:  		/* mullw R27, R10, R11 */
		/* 82071130h case   14:*/		cpu::op::mullw<0>(regs,&regs.R27,regs.R10,regs.R11);
		/* 82071130h case   14:*/		return 0x82071134;
	}
	return 0x82071134;
} // Block from 820710F8h-82071134h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82071134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071134);
		  /* 82071134h */ case    0:  		/* lwz R10, <#[R24 + 24]> */
		/* 82071134h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000018) );
		/* 82071134h case    0:*/		return 0x82071138;
		  /* 82071138h */ case    1:  		/* rlwinm R11, R21, 1, 0, 30 */
		/* 82071138h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R21);
		/* 82071138h case    1:*/		return 0x8207113C;
		  /* 8207113Ch */ case    2:  		/* lbz R8, <#[R31 + 12563]> */
		/* 8207113Ch case    2:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R31 + 0x00003113) );
		/* 8207113Ch case    2:*/		return 0x82071140;
		  /* 82071140h */ case    3:  		/* rlwinm R7, R27, 16, 0, 15 */
		/* 82071140h case    3:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R7,regs.R27);
		/* 82071140h case    3:*/		return 0x82071144;
		  /* 82071144h */ case    4:  		/* add R11, R11, R10 */
		/* 82071144h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82071144h case    4:*/		return 0x82071148;
		  /* 82071148h */ case    5:  		/* lwz R6, <#[R24]> */
		/* 82071148h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R24 + 0x00000000) );
		/* 82071148h case    5:*/		return 0x8207114C;
		  /* 8207114Ch */ case    6:  		/* addic R5, R8, -1 */
		/* 8207114Ch case    6:*/		cpu::op::addic<0>(regs,&regs.R5,regs.R8,0xFFFFFFFF);
		/* 8207114Ch case    6:*/		return 0x82071150;
		  /* 82071150h */ case    7:  		/* rlwinm R9, R11, 12, 20, 31 */
		/* 82071150h case    7:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R9,regs.R11);
		/* 82071150h case    7:*/		return 0x82071154;
		  /* 82071154h */ case    8:  		/* subfe R5, R5, R8 */
		/* 82071154h case    8:*/		cpu::op::subfe<0>(regs,&regs.R5,regs.R5,regs.R8);
		/* 82071154h case    8:*/		return 0x82071158;
		  /* 82071158h */ case    9:  		/* lbzx R4, <#[R23 + R8]> */
		/* 82071158h case    9:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R23 + regs.R8 + 0x00000000) );
		/* 82071158h case    9:*/		return 0x8207115C;
		  /* 8207115Ch */ case   10:  		/* addi R8, R9, 512 */
		/* 8207115Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x200);
		/* 8207115Ch case   10:*/		return 0x82071160;
		  /* 82071160h */ case   11:  		/* rlwinm R9, R11, 0, 3, 31 */
		/* 82071160h case   11:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R9,regs.R11);
		/* 82071160h case   11:*/		return 0x82071164;
		  /* 82071164h */ case   12:  		/* rlwimi R4, R5, 8, 23, 23 */
		/* 82071164h case   12:*/		cpu::op::rlwimi<0,8,23,23>(regs,&regs.R4,regs.R5);
		/* 82071164h case   12:*/		return 0x82071168;
		  /* 82071168h */ case   13:  		/* rlwinm R11, R6, 1, 0, 1 */
		/* 82071168h case   13:*/		cpu::op::rlwinm<0,1,0,1>(regs,&regs.R11,regs.R6);
		/* 82071168h case   13:*/		return 0x8207116C;
		  /* 8207116Ch */ case   14:  		/* rlwinm R8, R8, 0, 19, 19 */
		/* 8207116Ch case   14:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R8,regs.R8);
		/* 8207116Ch case   14:*/		return 0x82071170;
		  /* 82071170h */ case   15:  		/* rlwinm R5, R27, 0, 8, 31 */
		/* 82071170h case   15:*/		cpu::op::rlwinm<0,0,8,31>(regs,&regs.R5,regs.R27);
		/* 82071170h case   15:*/		return 0x82071174;
		  /* 82071174h */ case   16:  		/* rlwinm R6, R6, 0, 0, 0 */
		/* 82071174h case   16:*/		cpu::op::rlwinm<0,0,0,0>(regs,&regs.R6,regs.R6);
		/* 82071174h case   16:*/		return 0x82071178;
		  /* 82071178h */ case   17:  		/* andi. R26, R4, 319 */
		/* 82071178h case   17:*/		cpu::op::andi<1>(regs,&regs.R26,regs.R4,0x13F);
		/* 82071178h case   17:*/		return 0x8207117C;
		  /* 8207117Ch */ case   18:  		/* or R30, R7, R22 */
		/* 8207117Ch case   18:*/		cpu::op::or<0>(regs,&regs.R30,regs.R7,regs.R22);
		/* 8207117Ch case   18:*/		return 0x82071180;
		  /* 82071180h */ case   19:  		/* add R28, R8, R9 */
		/* 82071180h case   19:*/		cpu::op::add<0>(regs,&regs.R28,regs.R8,regs.R9);
		/* 82071180h case   19:*/		return 0x82071184;
		  /* 82071184h */ case   20:  		/* or R29, R5, R11 */
		/* 82071184h case   20:*/		cpu::op::or<0>(regs,&regs.R29,regs.R5,regs.R11);
		/* 82071184h case   20:*/		return 0x82071188;
		  /* 82071188h */ case   21:  		/* cmplwi CR0, R6, 0 */
		/* 82071188h case   21:*/		cpu::op::cmplwi<0>(regs,regs.R6,0x00000000);
		/* 82071188h case   21:*/		return 0x8207118C;
		  /* 8207118Ch */ case   22:  		/* bc 12, CR0_EQ, 44 */
		/* 8207118Ch case   22:*/		if ( regs.CR[0].eq ) { return 0x820711B8;  }
		/* 8207118Ch case   22:*/		return 0x82071190;
		  /* 82071190h */ case   23:  		/* rlwinm R9, R21, 2, 0, 29 */
		/* 82071190h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R21);
		/* 82071190h case   23:*/		return 0x82071194;
		  /* 82071194h */ case   24:  		/* rlwinm R8, R27, 1, 8, 30 */
		/* 82071194h case   24:*/		cpu::op::rlwinm<0,1,8,30>(regs,&regs.R8,regs.R27);
		/* 82071194h case   24:*/		return 0x82071198;
		  /* 82071198h */ case   25:  		/* add R10, R9, R10 */
		/* 82071198h case   25:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82071198h case   25:*/		return 0x8207119C;
		  /* 8207119Ch */ case   26:  		/* or R29, R8, R11 */
		/* 8207119Ch case   26:*/		cpu::op::or<0>(regs,&regs.R29,regs.R8,regs.R11);
		/* 8207119Ch case   26:*/		return 0x820711A0;
	}
	return 0x820711A0;
} // Block from 82071134h-820711A0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820711A0h
// Function 'D3DDevice_Swap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820711A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820711A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820711A0);
		  /* 820711A0h */ case    0:  		/* rlwinm R9, R10, 12, 20, 31 */
		/* 820711A0h case    0:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R9,regs.R10);
		/* 820711A0h case    0:*/		return 0x820711A4;
		  /* 820711A4h */ case    1:  		/* rlwinm R10, R10, 0, 3, 31 */
		/* 820711A4h case    1:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R10);
		/* 820711A4h case    1:*/		return 0x820711A8;
		  /* 820711A8h */ case    2:  		/* addi R11, R9, 512 */
		/* 820711A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x200);
		/* 820711A8h case    2:*/		return 0x820711AC;
		  /* 820711ACh */ case    3:  		/* ori R30, R30, 2048 */
		/* 820711ACh case    3:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x800);
		/* 820711ACh case    3:*/		return 0x820711B0;
		  /* 820711B0h */ case    4:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 820711B0h case    4:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 820711B0h case    4:*/		return 0x820711B4;
		  /* 820711B4h */ case    5:  		/* add R28, R11, R10 */
		/* 820711B4h case    5:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R10);
		/* 820711B4h case    5:*/		return 0x820711B8;
	}
	return 0x820711B8;
} // Block from 820711A0h-820711B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820711B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820711B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820711B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820711B8);
		  /* 820711B8h */ case    0:  		/* lbz R11, <#[R31 + 11068]> */
		/* 820711B8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3C) );
		/* 820711B8h case    0:*/		return 0x820711BC;
		  /* 820711BCh */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820711BCh case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820711BCh case    1:*/		return 0x820711C0;
		  /* 820711C0h */ case    2:  		/* bc 4, CR0_EQ, 40 */
		/* 820711C0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820711E8;  }
		/* 820711C0h case    2:*/		return 0x820711C4;
		  /* 820711C4h */ case    3:  		/* lis R11, -16381 */
		/* 820711C4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC003);
		/* 820711C4h case    3:*/		return 0x820711C8;
		  /* 820711C8h */ case    4:  		/* ori R11, R11, 8705 */
		/* 820711C8h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2201);
		/* 820711C8h case    4:*/		return 0x820711CC;
		  /* 820711CCh */ case    5:  		/* stwu R11, <#[R25 + 4]> */
		/* 820711CCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000004) );
		regs.R25 = (uint32)(regs.R25 + 0x00000004);
		/* 820711CCh case    5:*/		return 0x820711D0;
		  /* 820711D0h */ case    6:  		/* stwu R26, <#[R25 + 4]> */
		/* 820711D0h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R25 + 0x00000004) );
		regs.R25 = (uint32)(regs.R25 + 0x00000004);
		/* 820711D0h case    6:*/		return 0x820711D4;
		  /* 820711D4h */ case    7:  		/* stwu R30, <#[R25 + 4]> */
		/* 820711D4h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R25 + 0x00000004) );
		regs.R25 = (uint32)(regs.R25 + 0x00000004);
		/* 820711D4h case    7:*/		return 0x820711D8;
		  /* 820711D8h */ case    8:  		/* stwu R28, <#[R25 + 4]> */
		/* 820711D8h case    8:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R25 + 0x00000004) );
		regs.R25 = (uint32)(regs.R25 + 0x00000004);
		/* 820711D8h case    8:*/		return 0x820711DC;
		  /* 820711DCh */ case    9:  		/* mr R11, R25 */
		/* 820711DCh case    9:*/		regs.R11 = regs.R25;
		/* 820711DCh case    9:*/		return 0x820711E0;
		  /* 820711E0h */ case   10:  		/* stwu R29, <#[R11 + 4]> */
		/* 820711E0h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820711E0h case   10:*/		return 0x820711E4;
		  /* 820711E4h */ case   11:  		/* b 200 */
		/* 820711E4h case   11:*/		return 0x820712AC;
		/* 820711E4h case   11:*/		return 0x820711E8;
	}
	return 0x820711E8;
} // Block from 820711B8h-820711E8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820711E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820711E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820711E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820711E8);
		  /* 820711E8h */ case    0:  		/* lwz R11, <#[R31 + 13628]> */
		/* 820711E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000353C) );
		/* 820711E8h case    0:*/		return 0x820711EC;
		  /* 820711ECh */ case    1:  		/* addi R3, R31, 13616 */
		/* 820711ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x3530);
		/* 820711ECh case    1:*/		return 0x820711F0;
		  /* 820711F0h */ case    2:  		/* lwz R10, <#[R31 + 13632]> */
		/* 820711F0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003540) );
		/* 820711F0h case    2:*/		return 0x820711F4;
		  /* 820711F4h */ case    3:  		/* addi R9, R11, 16 */
		/* 820711F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x10);
		/* 820711F4h case    3:*/		return 0x820711F8;
		  /* 820711F8h */ case    4:  		/* cmplw CR6, R9, R10 */
		/* 820711F8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820711F8h case    4:*/		return 0x820711FC;
		  /* 820711FCh */ case    5:  		/* bc 4, CR6_GT, 12 */
		/* 820711FCh case    5:*/		if ( !regs.CR[6].gt ) { return 0x82071208;  }
		/* 820711FCh case    5:*/		return 0x82071200;
		  /* 82071200h */ case    6:  		/* bl 10296 */
		/* 82071200h case    6:*/		regs.LR = 0x82071204; return 0x82073A38;
		/* 82071200h case    6:*/		return 0x82071204;
		  /* 82071204h */ case    7:  		/* mr R11, R3 */
		/* 82071204h case    7:*/		regs.R11 = regs.R3;
		/* 82071204h case    7:*/		return 0x82071208;
	}
	return 0x82071208;
} // Block from 820711E8h-82071208h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82071208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071208);
		  /* 82071208h */ case    0:  		/* mr R10, R25 */
		/* 82071208h case    0:*/		regs.R10 = regs.R25;
		/* 82071208h case    0:*/		return 0x8207120C;
		  /* 8207120Ch */ case    1:  		/* stw R25, <#[R11]> */
		/* 8207120Ch case    1:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 8207120Ch case    1:*/		return 0x82071210;
		  /* 82071210h */ case    2:  		/* lis R9, -16384 */
		/* 82071210h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC000);
		/* 82071210h case    2:*/		return 0x82071214;
		  /* 82071214h */ case    3:  		/* addi R8, R11, 16 */
		/* 82071214h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x10);
		/* 82071214h case    3:*/		return 0x82071218;
		  /* 82071218h */ case    4:  		/* ori R9, R9, 24576 */
		/* 82071218h case    4:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x6000);
		/* 82071218h case    4:*/		return 0x8207121C;
		  /* 8207121Ch */ case    5:  		/* stw R8, <#[R31 + 13628]> */
		/* 8207121Ch case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x0000353C) );
		/* 8207121Ch case    5:*/		return 0x82071220;
		  /* 82071220h */ case    6:  		/* li R8, -1 */
		/* 82071220h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 82071220h case    6:*/		return 0x82071224;
		  /* 82071224h */ case    7:  		/* stwu R9, <#[R10 + 4]> */
		/* 82071224h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82071224h case    7:*/		return 0x82071228;
		  /* 82071228h */ case    8:  		/* lis R5, -16383 */
		/* 82071228h case    8:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFFC001);
		/* 82071228h case    8:*/		return 0x8207122C;
		  /* 8207122Ch */ case    9:  		/* lis R9, -16381 */
		/* 8207122Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC003);
		/* 8207122Ch case    9:*/		return 0x82071230;
		  /* 82071230h */ case   10:  		/* lis R7, -16384 */
		/* 82071230h case   10:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFFC000);
		/* 82071230h case   10:*/		return 0x82071234;
		  /* 82071234h */ case   11:  		/* ori R9, R9, 8705 */
		/* 82071234h case   11:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x2201);
		/* 82071234h case   11:*/		return 0x82071238;
		  /* 82071238h */ case   12:  		/* ori R7, R7, 24576 */
		/* 82071238h case   12:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x6000);
		/* 82071238h case   12:*/		return 0x8207123C;
		  /* 8207123Ch */ case   13:  		/* stwu R8, <#[R10 + 4]> */
		/* 8207123Ch case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8207123Ch case   13:*/		return 0x82071240;
		  /* 82071240h */ case   14:  		/* ori R8, R5, 23041 */
		/* 82071240h case   14:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R5,0x5A01);
		/* 82071240h case   14:*/		return 0x82071244;
		  /* 82071244h */ case   15:  		/* lis R6, -32768 */
		/* 82071244h case   15:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8000);
		/* 82071244h case   15:*/		return 0x82071248;
		  /* 82071248h */ case   16:  		/* mr R5, R10 */
		/* 82071248h case   16:*/		regs.R5 = regs.R10;
		/* 82071248h case   16:*/		return 0x8207124C;
		  /* 8207124Ch */ case   17:  		/* addi R11, R11, 4 */
		/* 8207124Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8207124Ch case   17:*/		return 0x82071250;
		  /* 82071250h */ case   18:  		/* li R4, 26 */
		/* 82071250h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x1A);
		/* 82071250h case   18:*/		return 0x82071254;
		  /* 82071254h */ case   19:  		/* rlwinm R10, R11, 12, 20, 31 */
		/* 82071254h case   19:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R11);
		/* 82071254h case   19:*/		return 0x82071258;
		  /* 82071258h */ case   20:  		/* rlwinm R11, R11, 0, 3, 30 */
		/* 82071258h case   20:*/		cpu::op::rlwinm<0,0,3,30>(regs,&regs.R11,regs.R11);
		/* 82071258h case   20:*/		return 0x8207125C;
		  /* 8207125Ch */ case   21:  		/* stwu R9, <#[R5 + 4]> */
		/* 8207125Ch case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 8207125Ch case   21:*/		return 0x82071260;
		  /* 82071260h */ case   22:  		/* addi R10, R10, 512 */
		/* 82071260h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 82071260h case   22:*/		return 0x82071264;
		  /* 82071264h */ case   23:  		/* lis R9, -16384 */
		/* 82071264h case   23:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC000);
		/* 82071264h case   23:*/		return 0x82071268;
		  /* 82071268h */ case   24:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 82071268h case   24:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 82071268h case   24:*/		return 0x8207126C;
		  /* 8207126Ch */ case   25:  		/* add R11, R10, R11 */
		/* 8207126Ch case   25:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8207126Ch case   25:*/		return 0x82071270;
		  /* 82071270h */ case   26:  		/* stwu R26, <#[R5 + 4]> */
		/* 82071270h case   26:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 82071270h case   26:*/		return 0x82071274;
		  /* 82071274h */ case   27:  		/* ori R10, R9, 17921 */
		/* 82071274h case   27:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R9,0x4601);
		/* 82071274h case   27:*/		return 0x82071278;
		  /* 82071278h */ case   28:  		/* ori R11, R11, 1 */
		/* 82071278h case   28:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82071278h case   28:*/		return 0x8207127C;
		  /* 8207127Ch */ case   29:  		/* li R9, 25 */
		/* 8207127Ch case   29:*/		cpu::op::li<0>(regs,&regs.R9,0x19);
		/* 8207127Ch case   29:*/		return 0x82071280;
		  /* 82071280h */ case   30:  		/* stwu R30, <#[R5 + 4]> */
		/* 82071280h case   30:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 82071280h case   30:*/		return 0x82071284;
		  /* 82071284h */ case   31:  		/* stwu R28, <#[R5 + 4]> */
		/* 82071284h case   31:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 82071284h case   31:*/		return 0x82071288;
		  /* 82071288h */ case   32:  		/* stwu R29, <#[R5 + 4]> */
		/* 82071288h case   32:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 82071288h case   32:*/		return 0x8207128C;
		  /* 8207128Ch */ case   33:  		/* stwu R7, <#[R5 + 4]> */
		/* 8207128Ch case   33:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 8207128Ch case   33:*/		return 0x82071290;
		  /* 82071290h */ case   34:  		/* stwu R6, <#[R5 + 4]> */
		/* 82071290h case   34:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 82071290h case   34:*/		return 0x82071294;
		  /* 82071294h */ case   35:  		/* stwu R8, <#[R5 + 4]> */
		/* 82071294h case   35:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 82071294h case   35:*/		return 0x82071298;
		  /* 82071298h */ case   36:  		/* stwu R4, <#[R5 + 4]> */
		/* 82071298h case   36:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 82071298h case   36:*/		return 0x8207129C;
		  /* 8207129Ch */ case   37:  		/* stwu R11, <#[R5 + 4]> */
		/* 8207129Ch case   37:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 8207129Ch case   37:*/		return 0x820712A0;
		  /* 820712A0h */ case   38:  		/* stwu R10, <#[R5 + 4]> */
		/* 820712A0h case   38:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 820712A0h case   38:*/		return 0x820712A4;
		  /* 820712A4h */ case   39:  		/* mr R11, R5 */
		/* 820712A4h case   39:*/		regs.R11 = regs.R5;
		/* 820712A4h case   39:*/		return 0x820712A8;
		  /* 820712A8h */ case   40:  		/* stwu R9, <#[R11 + 4]> */
		/* 820712A8h case   40:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820712A8h case   40:*/		return 0x820712AC;
	}
	return 0x820712AC;
} // Block from 82071208h-820712ACh (41 instructions)

//////////////////////////////////////////////////////
// Block at 820712ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820712AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820712AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820712AC);
		  /* 820712ACh */ case    0:  		/* subf. R10, R27, R19 */
		/* 820712ACh case    0:*/		cpu::op::subf<1>(regs,&regs.R10,regs.R27,regs.R19);
		/* 820712ACh case    0:*/		return 0x820712B0;
		  /* 820712B0h */ case    1:  		/* stw R11, <#[R31 + 48]> */
		/* 820712B0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820712B0h case    1:*/		return 0x820712B4;
		  /* 820712B4h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 820712B4h case    2:*/		if ( regs.CR[0].eq ) { return 0x820712D4;  }
		/* 820712B4h case    2:*/		return 0x820712B8;
		  /* 820712B8h */ case    3:  		/* addi R9, R20, 4 */
		/* 820712B8h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R20,0x4);
		/* 820712B8h case    3:*/		return 0x820712BC;
		  /* 820712BCh */ case    4:  		/* rlwinm R11, R18, 3, 0, 28 */
		/* 820712BCh case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R18);
		/* 820712BCh case    4:*/		return 0x820712C0;
		  /* 820712C0h */ case    5:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820712C0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820712C0h case    5:*/		return 0x820712C4;
		  /* 820712C4h */ case    6:  		/* subf R9, R11, R27 */
		/* 820712C4h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R27);
		/* 820712C4h case    6:*/		return 0x820712C8;
		  /* 820712C8h */ case    7:  		/* add R19, R11, R10 */
		/* 820712C8h case    7:*/		cpu::op::add<0>(regs,&regs.R19,regs.R11,regs.R10);
		/* 820712C8h case    7:*/		return 0x820712CC;
		  /* 820712CCh */ case    8:  		/* add R21, R9, R21 */
		/* 820712CCh case    8:*/		cpu::op::add<0>(regs,&regs.R21,regs.R9,regs.R21);
		/* 820712CCh case    8:*/		return 0x820712D0;
		  /* 820712D0h */ case    9:  		/* b -496 */
		/* 820712D0h case    9:*/		return 0x820710E0;
		/* 820712D0h case    9:*/		return 0x820712D4;
	}
	return 0x820712D4;
} // Block from 820712ACh-820712D4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820712D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820712D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820712D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820712D4);
		  /* 820712D4h */ case    0:  		/* addi R1, R1, 208 */
		/* 820712D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820712D4h case    0:*/		return 0x820712D8;
		  /* 820712D8h */ case    1:  		/* b 130980 */
		/* 820712D8h case    1:*/		return 0x8209127C;
		/* 820712D8h case    1:*/		return 0x820712DC;
		  /* 820712DCh */ case    2:  		/* nop */
		/* 820712DCh case    2:*/		cpu::op::nop();
		/* 820712DCh case    2:*/		return 0x820712E0;
	}
	return 0x820712E0;
} // Block from 820712D4h-820712E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820712E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820712E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820712E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820712E0);
		  /* 820712E0h */ case    0:  		/* lwz R10, <#[R3]> */
		/* 820712E0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820712E0h case    0:*/		return 0x820712E4;
		  /* 820712E4h */ case    1:  		/* rlwinm R11, R10, 0, 28, 31 */
		/* 820712E4h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R10);
		/* 820712E4h case    1:*/		return 0x820712E8;
		  /* 820712E8h */ case    2:  		/* cmplwi CR6, R11, 3 */
		/* 820712E8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820712E8h case    2:*/		return 0x820712EC;
		  /* 820712ECh */ case    3:  		/* bc 4, CR6_EQ, 80 */
		/* 820712ECh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8207133C;  }
		/* 820712ECh case    3:*/		return 0x820712F0;
		  /* 820712F0h */ case    4:  		/* lwz R10, <#[R3 + 48]> */
		/* 820712F0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000030) );
		/* 820712F0h case    4:*/		return 0x820712F4;
		  /* 820712F4h */ case    5:  		/* rlwinm R10, R10, 23, 30, 31 */
		/* 820712F4h case    5:*/		cpu::op::rlwinm<0,23,30,31>(regs,&regs.R10,regs.R10);
		/* 820712F4h case    5:*/		return 0x820712F8;
		  /* 820712F8h */ case    6:  		/* cmplwi CR6, R10, 3 */
		/* 820712F8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820712F8h case    6:*/		return 0x820712FC;
		  /* 820712FCh */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 820712FCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x82071308;  }
		/* 820712FCh case    7:*/		return 0x82071300;
		  /* 82071300h */ case    8:  		/* li R11, 18 */
		/* 82071300h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x12);
		/* 82071300h case    8:*/		return 0x82071304;
		  /* 82071304h */ case    9:  		/* b 96 */
		/* 82071304h case    9:*/		return 0x82071364;
		/* 82071304h case    9:*/		return 0x82071308;
	}
	return 0x82071308;
} // Block from 820712E0h-82071308h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82071308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071308);
		  /* 82071308h */ case    0:  		/* cmplwi CR6, R10, 2 */
		/* 82071308h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 82071308h case    0:*/		return 0x8207130C;
		  /* 8207130Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8207130Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82071318;  }
		/* 8207130Ch case    1:*/		return 0x82071310;
		  /* 82071310h */ case    2:  		/* li R11, 17 */
		/* 82071310h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x11);
		/* 82071310h case    2:*/		return 0x82071314;
		  /* 82071314h */ case    3:  		/* b 80 */
		/* 82071314h case    3:*/		return 0x82071364;
		/* 82071314h case    3:*/		return 0x82071318;
	}
	return 0x82071318;
} // Block from 82071308h-82071318h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82071318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071318);
		  /* 82071318h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 82071318h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82071318h case    0:*/		return 0x8207131C;
		  /* 8207131Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8207131Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82071328;  }
		/* 8207131Ch case    1:*/		return 0x82071320;
		  /* 82071320h */ case    2:  		/* li R11, 20 */
		/* 82071320h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x14);
		/* 82071320h case    2:*/		return 0x82071324;
		  /* 82071324h */ case    3:  		/* b 64 */
		/* 82071324h case    3:*/		return 0x82071364;
		/* 82071324h case    3:*/		return 0x82071328;
	}
	return 0x82071328;
} // Block from 82071318h-82071328h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82071328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071328);
		  /* 82071328h */ case    0:  		/* lwz R10, <#[R3 + 32]> */
		/* 82071328h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 82071328h case    0:*/		return 0x8207132C;
		  /* 8207132Ch */ case    1:  		/* rlwinm. R10, R10, 0, 21, 21 */
		/* 8207132Ch case    1:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R10);
		/* 8207132Ch case    1:*/		return 0x82071330;
		  /* 82071330h */ case    2:  		/* bc 12, CR0_EQ, 52 */
		/* 82071330h case    2:*/		if ( regs.CR[0].eq ) { return 0x82071364;  }
		/* 82071330h case    2:*/		return 0x82071334;
		  /* 82071334h */ case    3:  		/* li R11, 19 */
		/* 82071334h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x13);
		/* 82071334h case    3:*/		return 0x82071338;
		  /* 82071338h */ case    4:  		/* b 44 */
		/* 82071338h case    4:*/		return 0x82071364;
		/* 82071338h case    4:*/		return 0x8207133C;
	}
	return 0x8207133C;
} // Block from 82071328h-8207133Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8207133Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207133C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207133C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207133C);
		  /* 8207133Ch */ case    0:  		/* cmplwi CR6, R11, 4 */
		/* 8207133Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8207133Ch case    0:*/		return 0x82071340;
		  /* 82071340h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 82071340h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82071364;  }
		/* 82071340h case    1:*/		return 0x82071344;
		  /* 82071344h */ case    2:  		/* rlwinm. R10, R10, 0, 1, 1 */
		/* 82071344h case    2:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R10);
		/* 82071344h case    2:*/		return 0x82071348;
		  /* 82071348h */ case    3:  		/* bc 12, CR0_EQ, 28 */
		/* 82071348h case    3:*/		if ( regs.CR[0].eq ) { return 0x82071364;  }
		/* 82071348h case    3:*/		return 0x8207134C;
		  /* 8207134Ch */ case    4:  		/* lwz R10, <#[R3 + 24]> */
		/* 8207134Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 8207134Ch case    4:*/		return 0x82071350;
		  /* 82071350h */ case    5:  		/* lwz R10, <#[R10 + 48]> */
		/* 82071350h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 82071350h case    5:*/		return 0x82071354;
		  /* 82071354h */ case    6:  		/* rlwinm R10, R10, 0, 21, 22 */
		/* 82071354h case    6:*/		cpu::op::rlwinm<0,0,21,22>(regs,&regs.R10,regs.R10);
		/* 82071354h case    6:*/		return 0x82071358;
		  /* 82071358h */ case    7:  		/* cmplwi CR6, R10, 1024 */
		/* 82071358h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000400);
		/* 82071358h case    7:*/		return 0x8207135C;
		  /* 8207135Ch */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 8207135Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82071364;  }
		/* 8207135Ch case    8:*/		return 0x82071360;
		  /* 82071360h */ case    9:  		/* li R11, 16 */
		/* 82071360h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 82071360h case    9:*/		return 0x82071364;
	}
	return 0x82071364;
} // Block from 8207133Ch-82071364h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82071364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071364);
		  /* 82071364h */ case    0:  		/* mr R3, R11 */
		/* 82071364h case    0:*/		regs.R3 = regs.R11;
		/* 82071364h case    0:*/		return 0x82071368;
		  /* 82071368h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82071368h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82071368h case    1:*/		return 0x8207136C;
	}
	return 0x8207136C;
} // Block from 82071364h-8207136Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8207136Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207136C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207136C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207136C);
		  /* 8207136Ch */ case    0:  		/* nop */
		/* 8207136Ch case    0:*/		cpu::op::nop();
		/* 8207136Ch case    0:*/		return 0x82071370;
	}
	return 0x82071370;
} // Block from 8207136Ch-82071370h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82071370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071370);
		  /* 82071370h */ case    0:  		/* mfspr R12, LR */
		/* 82071370h case    0:*/		regs.R12 = regs.LR;
		/* 82071370h case    0:*/		return 0x82071374;
		  /* 82071374h */ case    1:  		/* bl 130788 */
		/* 82071374h case    1:*/		regs.LR = 0x82071378; return 0x82091258;
		/* 82071374h case    1:*/		return 0x82071378;
		  /* 82071378h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82071378h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82071378h case    2:*/		return 0x8207137C;
		  /* 8207137Ch */ case    3:  		/* lwz R7, <#[R3]> */
		/* 8207137Ch case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000000) );
		/* 8207137Ch case    3:*/		return 0x82071380;
		  /* 82071380h */ case    4:  		/* mr R30, R3 */
		/* 82071380h case    4:*/		regs.R30 = regs.R3;
		/* 82071380h case    4:*/		return 0x82071384;
		  /* 82071384h */ case    5:  		/* mr R31, R5 */
		/* 82071384h case    5:*/		regs.R31 = regs.R5;
		/* 82071384h case    5:*/		return 0x82071388;
		  /* 82071388h */ case    6:  		/* rlwinm R11, R7, 0, 20, 23 */
		/* 82071388h case    6:*/		cpu::op::rlwinm<0,0,20,23>(regs,&regs.R11,regs.R7);
		/* 82071388h case    6:*/		return 0x8207138C;
		  /* 8207138Ch */ case    7:  		/* cmplwi CR6, R11, 256 */
		/* 8207138Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000100);
		/* 8207138Ch case    7:*/		return 0x82071390;
		  /* 82071390h */ case    8:  		/* bc 4, CR6_EQ, 256 */
		/* 82071390h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82071490;  }
		/* 82071390h case    8:*/		return 0x82071394;
		  /* 82071394h */ case    9:  		/* lwz R11, <#[R3 + 20]> */
		/* 82071394h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82071394h case    9:*/		return 0x82071398;
		  /* 82071398h */ case   10:  		/* lis R29, -1 */
		/* 82071398h case   10:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFFFFFF);
		/* 82071398h case   10:*/		return 0x8207139C;
		  /* 8207139Ch */ case   11:  		/* lis R28, 16384 */
		/* 8207139Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R28,0x4000);
		/* 8207139Ch case   11:*/		return 0x820713A0;
		  /* 820713A0h */ case   12:  		/* cmplw CR6, R11, R29 */
		/* 820713A0h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 820713A0h case   12:*/		return 0x820713A4;
		  /* 820713A4h */ case   13:  		/* bc 12, CR6_EQ, 108 */
		/* 820713A4h case   13:*/		if ( regs.CR[6].eq ) { return 0x82071410;  }
		/* 820713A4h case   13:*/		return 0x820713A8;
		  /* 820713A8h */ case   14:  		/* rlwinm R10, R11, 16, 16, 31 */
		/* 820713A8h case   14:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R10,regs.R11);
		/* 820713A8h case   14:*/		return 0x820713AC;
		  /* 820713ACh */ case   15:  		/* rlwinm. R9, R11, 16, 16, 16 */
		/* 820713ACh case   15:*/		cpu::op::rlwinm<1,16,16,16>(regs,&regs.R9,regs.R11);
		/* 820713ACh case   15:*/		return 0x820713B0;
		  /* 820713B0h */ case   16:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 820713B0h case   16:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 820713B0h case   16:*/		return 0x820713B4;
		  /* 820713B4h */ case   17:  		/* rlwinm R8, R10, 4, 13, 27 */
		/* 820713B4h case   17:*/		cpu::op::rlwinm<0,4,13,27>(regs,&regs.R8,regs.R10);
		/* 820713B4h case   17:*/		return 0x820713B8;
		  /* 820713B8h */ case   18:  		/* bc 4, CR0_EQ, 8 */
		/* 820713B8h case   18:*/		if ( !regs.CR[0].eq ) { return 0x820713C0;  }
		/* 820713B8h case   18:*/		return 0x820713BC;
		  /* 820713BCh */ case   19:  		/* mr R8, R10 */
		/* 820713BCh case   19:*/		regs.R8 = regs.R10;
		/* 820713BCh case   19:*/		return 0x820713C0;
	}
	return 0x820713C0;
} // Block from 82071370h-820713C0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820713C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820713C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820713C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820713C0);
		  /* 820713C0h */ case    0:  		/* rlwinm. R10, R11, 0, 16, 16 */
		/* 820713C0h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R11);
		/* 820713C0h case    0:*/		return 0x820713C4;
		  /* 820713C4h */ case    1:  		/* rlwinm R9, R11, 4, 13, 27 */
		/* 820713C4h case    1:*/		cpu::op::rlwinm<0,4,13,27>(regs,&regs.R9,regs.R11);
		/* 820713C4h case    1:*/		return 0x820713C8;
		  /* 820713C8h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 820713C8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820713D0;  }
		/* 820713C8h case    2:*/		return 0x820713CC;
		  /* 820713CCh */ case    3:  		/* mr R9, R11 */
		/* 820713CCh case    3:*/		regs.R9 = regs.R11;
		/* 820713CCh case    3:*/		return 0x820713D0;
	}
	return 0x820713D0;
} // Block from 820713C0h-820713D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820713D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820713D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820713D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820713D0);
		  /* 820713D0h */ case    0:  		/* rlwinm. R11, R7, 0, 10, 10 */
		/* 820713D0h case    0:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R7);
		/* 820713D0h case    0:*/		return 0x820713D4;
		  /* 820713D4h */ case    1:  		/* stw R29, <#[R30 + 20]> */
		/* 820713D4h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000014) );
		/* 820713D4h case    1:*/		return 0x820713D8;
		  /* 820713D8h */ case    2:  		/* bc 4, CR0_EQ, 28 */
		/* 820713D8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820713F4;  }
		/* 820713D8h case    2:*/		return 0x820713DC;
		  /* 820713DCh */ case    3:  		/* rlwinm R11, R4, 12, 20, 31 */
		/* 820713DCh case    3:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R4);
		/* 820713DCh case    3:*/		return 0x820713E0;
		  /* 820713E0h */ case    4:  		/* rlwinm R10, R4, 0, 3, 31 */
		/* 820713E0h case    4:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R4);
		/* 820713E0h case    4:*/		return 0x820713E4;
		  /* 820713E4h */ case    5:  		/* addi R11, R11, 512 */
		/* 820713E4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 820713E4h case    5:*/		return 0x820713E8;
		  /* 820713E8h */ case    6:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 820713E8h case    6:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 820713E8h case    6:*/		return 0x820713EC;
		  /* 820713ECh */ case    7:  		/* add R11, R11, R10 */
		/* 820713ECh case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820713ECh case    7:*/		return 0x820713F0;
		  /* 820713F0h */ case    8:  		/* subf R4, R28, R11 */
		/* 820713F0h case    8:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R28,regs.R11);
		/* 820713F0h case    8:*/		return 0x820713F4;
	}
	return 0x820713F4;
} // Block from 820713D0h-820713F4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820713F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820713F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820713F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820713F4);
		  /* 820713F4h */ case    0:  		/* rlwinm R11, R4, 0, 0, 24 */
		/* 820713F4h case    0:*/		cpu::op::rlwinm<0,0,0,24>(regs,&regs.R11,regs.R4);
		/* 820713F4h case    0:*/		return 0x820713F8;
		  /* 820713F8h */ case    1:  		/* rlwinm R9, R9, 7, 0, 24 */
		/* 820713F8h case    1:*/		cpu::op::rlwinm<0,7,0,24>(regs,&regs.R9,regs.R9);
		/* 820713F8h case    1:*/		return 0x820713FC;
		  /* 820713FCh */ case    2:  		/* rlwinm R10, R8, 7, 0, 24 */
		/* 820713FCh case    2:*/		cpu::op::rlwinm<0,7,0,24>(regs,&regs.R10,regs.R8);
		/* 820713FCh case    2:*/		return 0x82071400;
		  /* 82071400h */ case    3:  		/* li R5, 0 */
		/* 82071400h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82071400h case    3:*/		return 0x82071404;
		  /* 82071404h */ case    4:  		/* add R4, R9, R11 */
		/* 82071404h case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R9,regs.R11);
		/* 82071404h case    4:*/		return 0x82071408;
		  /* 82071408h */ case    5:  		/* add R3, R10, R11 */
		/* 82071408h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82071408h case    5:*/		return 0x8207140C;
		  /* 8207140Ch */ case    6:  		/* bl 81340 */
		/* 8207140Ch case    6:*/		regs.LR = 0x82071410; return 0x820851C8;
		/* 8207140Ch case    6:*/		return 0x82071410;
	}
	return 0x82071410;
} // Block from 820713F4h-82071410h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82071410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071410);
		  /* 82071410h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82071410h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82071410h case    0:*/		return 0x82071414;
		  /* 82071414h */ case    1:  		/* bc 12, CR6_EQ, 124 */
		/* 82071414h case    1:*/		if ( regs.CR[6].eq ) { return 0x82071490;  }
		/* 82071414h case    1:*/		return 0x82071418;
		  /* 82071418h */ case    2:  		/* lwz R11, <#[R30 + 24]> */
		/* 82071418h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82071418h case    2:*/		return 0x8207141C;
		  /* 8207141Ch */ case    3:  		/* cmplw CR6, R11, R29 */
		/* 8207141Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8207141Ch case    3:*/		return 0x82071420;
		  /* 82071420h */ case    4:  		/* bc 12, CR6_EQ, 112 */
		/* 82071420h case    4:*/		if ( regs.CR[6].eq ) { return 0x82071490;  }
		/* 82071420h case    4:*/		return 0x82071424;
		  /* 82071424h */ case    5:  		/* rlwinm R10, R11, 16, 16, 31 */
		/* 82071424h case    5:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R10,regs.R11);
		/* 82071424h case    5:*/		return 0x82071428;
		  /* 82071428h */ case    6:  		/* rlwinm. R9, R11, 16, 16, 16 */
		/* 82071428h case    6:*/		cpu::op::rlwinm<1,16,16,16>(regs,&regs.R9,regs.R11);
		/* 82071428h case    6:*/		return 0x8207142C;
		  /* 8207142Ch */ case    7:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8207142Ch case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8207142Ch case    7:*/		return 0x82071430;
		  /* 82071430h */ case    8:  		/* rlwinm R8, R10, 4, 13, 27 */
		/* 82071430h case    8:*/		cpu::op::rlwinm<0,4,13,27>(regs,&regs.R8,regs.R10);
		/* 82071430h case    8:*/		return 0x82071434;
		  /* 82071434h */ case    9:  		/* bc 4, CR0_EQ, 8 */
		/* 82071434h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8207143C;  }
		/* 82071434h case    9:*/		return 0x82071438;
		  /* 82071438h */ case   10:  		/* mr R8, R10 */
		/* 82071438h case   10:*/		regs.R8 = regs.R10;
		/* 82071438h case   10:*/		return 0x8207143C;
	}
	return 0x8207143C;
} // Block from 82071410h-8207143Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8207143Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207143C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207143C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207143C);
		  /* 8207143Ch */ case    0:  		/* rlwinm. R10, R11, 0, 16, 16 */
		/* 8207143Ch case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R11);
		/* 8207143Ch case    0:*/		return 0x82071440;
		  /* 82071440h */ case    1:  		/* rlwinm R9, R11, 4, 13, 27 */
		/* 82071440h case    1:*/		cpu::op::rlwinm<0,4,13,27>(regs,&regs.R9,regs.R11);
		/* 82071440h case    1:*/		return 0x82071444;
		  /* 82071444h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 82071444h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8207144C;  }
		/* 82071444h case    2:*/		return 0x82071448;
		  /* 82071448h */ case    3:  		/* mr R9, R11 */
		/* 82071448h case    3:*/		regs.R9 = regs.R11;
		/* 82071448h case    3:*/		return 0x8207144C;
	}
	return 0x8207144C;
} // Block from 8207143Ch-8207144Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8207144Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207144C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207144C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207144C);
		  /* 8207144Ch */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8207144Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8207144Ch case    0:*/		return 0x82071450;
		  /* 82071450h */ case    1:  		/* stw R29, <#[R30 + 24]> */
		/* 82071450h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000018) );
		/* 82071450h case    1:*/		return 0x82071454;
		  /* 82071454h */ case    2:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 82071454h case    2:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 82071454h case    2:*/		return 0x82071458;
		  /* 82071458h */ case    3:  		/* bc 4, CR0_EQ, 28 */
		/* 82071458h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82071474;  }
		/* 82071458h case    3:*/		return 0x8207145C;
		  /* 8207145Ch */ case    4:  		/* rlwinm R11, R31, 12, 20, 31 */
		/* 8207145Ch case    4:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R31);
		/* 8207145Ch case    4:*/		return 0x82071460;
		  /* 82071460h */ case    5:  		/* rlwinm R10, R31, 0, 3, 31 */
		/* 82071460h case    5:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R31);
		/* 82071460h case    5:*/		return 0x82071464;
		  /* 82071464h */ case    6:  		/* addi R11, R11, 512 */
		/* 82071464h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82071464h case    6:*/		return 0x82071468;
		  /* 82071468h */ case    7:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82071468h case    7:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82071468h case    7:*/		return 0x8207146C;
		  /* 8207146Ch */ case    8:  		/* add R11, R11, R10 */
		/* 8207146Ch case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8207146Ch case    8:*/		return 0x82071470;
		  /* 82071470h */ case    9:  		/* subf R31, R28, R11 */
		/* 82071470h case    9:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R28,regs.R11);
		/* 82071470h case    9:*/		return 0x82071474;
	}
	return 0x82071474;
} // Block from 8207144Ch-82071474h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82071474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071474);
		  /* 82071474h */ case    0:  		/* rlwinm R11, R31, 0, 0, 24 */
		/* 82071474h case    0:*/		cpu::op::rlwinm<0,0,0,24>(regs,&regs.R11,regs.R31);
		/* 82071474h case    0:*/		return 0x82071478;
		  /* 82071478h */ case    1:  		/* rlwinm R9, R9, 7, 0, 24 */
		/* 82071478h case    1:*/		cpu::op::rlwinm<0,7,0,24>(regs,&regs.R9,regs.R9);
		/* 82071478h case    1:*/		return 0x8207147C;
		  /* 8207147Ch */ case    2:  		/* rlwinm R10, R8, 7, 0, 24 */
		/* 8207147Ch case    2:*/		cpu::op::rlwinm<0,7,0,24>(regs,&regs.R10,regs.R8);
		/* 8207147Ch case    2:*/		return 0x82071480;
		  /* 82071480h */ case    3:  		/* li R5, 0 */
		/* 82071480h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82071480h case    3:*/		return 0x82071484;
		  /* 82071484h */ case    4:  		/* add R4, R9, R11 */
		/* 82071484h case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R9,regs.R11);
		/* 82071484h case    4:*/		return 0x82071488;
		  /* 82071488h */ case    5:  		/* add R3, R10, R11 */
		/* 82071488h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82071488h case    5:*/		return 0x8207148C;
		  /* 8207148Ch */ case    6:  		/* bl 81212 */
		/* 8207148Ch case    6:*/		regs.LR = 0x82071490; return 0x820851C8;
		/* 8207148Ch case    6:*/		return 0x82071490;
	}
	return 0x82071490;
} // Block from 82071474h-82071490h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82071490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071490);
		  /* 82071490h */ case    0:  		/* sync */
		/* 82071490h case    0:*/		cpu::op::sync<0>(regs);
		/* 82071490h case    0:*/		return 0x82071494;
		  /* 82071494h */ case    1:  		/* li R11, -256 */
		/* 82071494h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFF00);
		/* 82071494h case    1:*/		return 0x82071498;
		  /* 82071498h */ case    2:  		/* mfmsr R8, MSR */
		/* 82071498h case    2:*/		regs.R8 = regs.MSR;
		/* 82071498h case    2:*/		return 0x8207149C;
		  /* 8207149Ch */ case    3:  		/* mtmsrd MSR, R13 */
		/* 8207149Ch case    3:*/		regs.MSR = regs.R13;
		/* 8207149Ch case    3:*/		return 0x820714A0;
		  /* 820714A0h */ case    4:  		/* lwarx R10, <#[R30]> */
		/* 820714A0h case    4:*/		cpu::mem::lwarx( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820714A0h case    4:*/		return 0x820714A4;
		  /* 820714A4h */ case    5:  		/* add R9, R11, R10 */
		/* 820714A4h case    5:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 820714A4h case    5:*/		return 0x820714A8;
		  /* 820714A8h */ case    6:  		/* stwcx. R9, <#[R30]> */
		/* 820714A8h case    6:*/		cpu::mem::stwcx( regs, regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 820714A8h case    6:*/		return 0x820714AC;
		  /* 820714ACh */ case    7:  		/* mtmsrd MSR, R8 */
		/* 820714ACh case    7:*/		regs.MSR = regs.R8;
		/* 820714ACh case    7:*/		return 0x820714B0;
		  /* 820714B0h */ case    8:  		/* bc 4, CR0_EQ, -24 */
		/* 820714B0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82071498;  }
		/* 820714B0h case    8:*/		return 0x820714B4;
		  /* 820714B4h */ case    9:  		/* addi R1, R1, 128 */
		/* 820714B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820714B4h case    9:*/		return 0x820714B8;
		  /* 820714B8h */ case   10:  		/* b 130544 */
		/* 820714B8h case   10:*/		return 0x820912A8;
		/* 820714B8h case   10:*/		return 0x820714BC;
		  /* 820714BCh */ case   11:  		/* nop */
		/* 820714BCh case   11:*/		cpu::op::nop();
		/* 820714BCh case   11:*/		return 0x820714C0;
		  /* 820714C0h */ case   12:  		/* lwz R11, <#[R3]> */
		/* 820714C0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820714C0h case   12:*/		return 0x820714C4;
		  /* 820714C4h */ case   13:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 820714C4h case   13:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 820714C4h case   13:*/		return 0x820714C8;
		  /* 820714C8h */ case   14:  		/* cmplwi CR6, R11, 1 */
		/* 820714C8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820714C8h case   14:*/		return 0x820714CC;
		  /* 820714CCh */ case   15:  		/* bc 4, CR6_EQ, 16 */
		/* 820714CCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x820714DC;  }
		/* 820714CCh case   15:*/		return 0x820714D0;
		  /* 820714D0h */ case   16:  		/* lwz R11, <#[R3 + 24]> */
		/* 820714D0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820714D0h case   16:*/		return 0x820714D4;
		  /* 820714D4h */ case   17:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 820714D4h case   17:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 820714D4h case   17:*/		return 0x820714D8;
		  /* 820714D8h */ case   18:  		/* b 40 */
		/* 820714D8h case   18:*/		return 0x82071500;
		/* 820714D8h case   18:*/		return 0x820714DC;
	}
	return 0x820714DC;
} // Block from 82071490h-820714DCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820714DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820714DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820714DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820714DC);
		  /* 820714DCh */ case    0:  		/* cmplwi CR6, R11, 3 */
		/* 820714DCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820714DCh case    0:*/		return 0x820714E0;
		  /* 820714E0h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820714E0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820714FC;  }
		/* 820714E0h case    1:*/		return 0x820714E4;
		  /* 820714E4h */ case    2:  		/* lwz R11, <#[R3 + 32]> */
		/* 820714E4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820714E4h case    2:*/		return 0x820714E8;
		  /* 820714E8h */ case    3:  		/* rlwinm. R11, R11, 0, 0, 19 */
		/* 820714E8h case    3:*/		cpu::op::rlwinm<1,0,0,19>(regs,&regs.R11,regs.R11);
		/* 820714E8h case    3:*/		return 0x820714EC;
		  /* 820714ECh */ case    4:  		/* bc 4, CR0_EQ, 20 */
		/* 820714ECh case    4:*/		if ( !regs.CR[0].eq ) { return 0x82071500;  }
		/* 820714ECh case    4:*/		return 0x820714F0;
		  /* 820714F0h */ case    5:  		/* lwz R11, <#[R3 + 48]> */
		/* 820714F0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820714F0h case    5:*/		return 0x820714F4;
		  /* 820714F4h */ case    6:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 820714F4h case    6:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 820714F4h case    6:*/		return 0x820714F8;
		  /* 820714F8h */ case    7:  		/* b 8 */
		/* 820714F8h case    7:*/		return 0x82071500;
		/* 820714F8h case    7:*/		return 0x820714FC;
	}
	return 0x820714FC;
} // Block from 820714DCh-820714FCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820714FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820714FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820714FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820714FC);
		  /* 820714FCh */ case    0:  		/* lwz R11, <#[R3 + 24]> */
		/* 820714FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820714FCh case    0:*/		return 0x82071500;
	}
	return 0x82071500;
} // Block from 820714FCh-82071500h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82071500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071500);
		  /* 82071500h */ case    0:  		/* rlwinm R9, R11, 12, 20, 31 */
		/* 82071500h case    0:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R9,regs.R11);
		/* 82071500h case    0:*/		return 0x82071504;
		  /* 82071504h */ case    1:  		/* rlwinm R10, R11, 0, 3, 31 */
		/* 82071504h case    1:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R11);
		/* 82071504h case    1:*/		return 0x82071508;
		  /* 82071508h */ case    2:  		/* addi R11, R9, 512 */
		/* 82071508h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x200);
		/* 82071508h case    2:*/		return 0x8207150C;
		  /* 8207150Ch */ case    3:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 8207150Ch case    3:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 8207150Ch case    3:*/		return 0x82071510;
		  /* 82071510h */ case    4:  		/* add R3, R11, R10 */
		/* 82071510h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82071510h case    4:*/		return 0x82071514;
		  /* 82071514h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82071514h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82071514h case    5:*/		return 0x82071518;
	}
	return 0x82071518;
} // Block from 82071500h-82071518h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82071518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071518);
		  /* 82071518h */ case    0:  		/* mfspr R12, LR */
		/* 82071518h case    0:*/		regs.R12 = regs.LR;
		/* 82071518h case    0:*/		return 0x8207151C;
		  /* 8207151Ch */ case    1:  		/* bl 130368 */
		/* 8207151Ch case    1:*/		regs.LR = 0x82071520; return 0x8209125C;
		/* 8207151Ch case    1:*/		return 0x82071520;
		  /* 82071520h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82071520h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82071520h case    2:*/		return 0x82071524;
		  /* 82071524h */ case    3:  		/* lwz R11, <#[R3 + 56]> */
		/* 82071524h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 82071524h case    3:*/		return 0x82071528;
		  /* 82071528h */ case    4:  		/* mr R31, R3 */
		/* 82071528h case    4:*/		regs.R31 = regs.R3;
		/* 82071528h case    4:*/		return 0x8207152C;
		  /* 8207152Ch */ case    5:  		/* lwz R3, <#[R3 + 48]> */
		/* 8207152Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 8207152Ch case    5:*/		return 0x82071530;
		  /* 82071530h */ case    6:  		/* mr R30, R4 */
		/* 82071530h case    6:*/		regs.R30 = regs.R4;
		/* 82071530h case    6:*/		return 0x82071534;
		  /* 82071534h */ case    7:  		/* mr R29, R5 */
		/* 82071534h case    7:*/		regs.R29 = regs.R5;
		/* 82071534h case    7:*/		return 0x82071538;
		  /* 82071538h */ case    8:  		/* cmplw CR6, R3, R11 */
		/* 82071538h case    8:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82071538h case    8:*/		return 0x8207153C;
		  /* 8207153Ch */ case    9:  		/* bc 4, CR6_GT, 12 */
		/* 8207153Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x82071548;  }
		/* 8207153Ch case    9:*/		return 0x82071540;
		  /* 82071540h */ case   10:  		/* mr R3, R31 */
		/* 82071540h case   10:*/		regs.R3 = regs.R31;
		/* 82071540h case   10:*/		return 0x82071544;
		  /* 82071544h */ case   11:  		/* bl 11204 */
		/* 82071544h case   11:*/		regs.LR = 0x82071548; return 0x82074108;
		/* 82071544h case   11:*/		return 0x82071548;
	}
	return 0x82071548;
} // Block from 82071518h-82071548h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82071548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071548);
		  /* 82071548h */ case    0:  		/* li R10, 2609 */
		/* 82071548h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0xA31);
		/* 82071548h case    0:*/		return 0x8207154C;
		  /* 8207154Ch */ case    1:  		/* rlwinm R11, R30, 12, 20, 31 */
		/* 8207154Ch case    1:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R30);
		/* 8207154Ch case    1:*/		return 0x82071550;
		  /* 82071550h */ case    2:  		/* stwu R10, <#[R3 + 4]> */
		/* 82071550h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071550h case    2:*/		return 0x82071554;
		  /* 82071554h */ case    3:  		/* lis R10, 768 */
		/* 82071554h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x300);
		/* 82071554h case    3:*/		return 0x82071558;
		  /* 82071558h */ case    4:  		/* addi R11, R11, 512 */
		/* 82071558h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82071558h case    4:*/		return 0x8207155C;
		  /* 8207155Ch */ case    5:  		/* ori R9, R10, 512 */
		/* 8207155Ch case    5:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R10,0x200);
		/* 8207155Ch case    5:*/		return 0x82071560;
		  /* 82071560h */ case    6:  		/* rlwinm R10, R11, 0, 19, 19 */
		/* 82071560h case    6:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R11);
		/* 82071560h case    6:*/		return 0x82071564;
		  /* 82071564h */ case    7:  		/* rlwinm R11, R30, 0, 3, 31 */
		/* 82071564h case    7:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R11,regs.R30);
		/* 82071564h case    7:*/		return 0x82071568;
		  /* 82071568h */ case    8:  		/* stwu R9, <#[R3 + 4]> */
		/* 82071568h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071568h case    8:*/		return 0x8207156C;
		  /* 8207156Ch */ case    9:  		/* lis R8, 1 */
		/* 8207156Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R8,0x1);
		/* 8207156Ch case    9:*/		return 0x82071570;
		  /* 82071570h */ case   10:  		/* add R11, R10, R11 */
		/* 82071570h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82071570h case   10:*/		return 0x82071574;
		  /* 82071574h */ case   11:  		/* ori R9, R8, 2607 */
		/* 82071574h case   11:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R8,0xA2F);
		/* 82071574h case   11:*/		return 0x82071578;
		  /* 82071578h */ case   12:  		/* add R10, R11, R29 */
		/* 82071578h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R29);
		/* 82071578h case   12:*/		return 0x8207157C;
		  /* 8207157Ch */ case   13:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 8207157Ch case   13:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 8207157Ch case   13:*/		return 0x82071580;
		  /* 82071580h */ case   14:  		/* addi R10, R10, 4095 */
		/* 82071580h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFF);
		/* 82071580h case   14:*/		return 0x82071584;
		  /* 82071584h */ case   15:  		/* stwu R9, <#[R3 + 4]> */
		/* 82071584h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071584h case   15:*/		return 0x82071588;
		  /* 82071588h */ case   16:  		/* lis R8, -16380 */
		/* 82071588h case   16:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFC004);
		/* 82071588h case   16:*/		return 0x8207158C;
		  /* 8207158Ch */ case   17:  		/* rlwinm R10, R10, 0, 0, 19 */
		/* 8207158Ch case   17:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R10,regs.R10);
		/* 8207158Ch case   17:*/		return 0x82071590;
		  /* 82071590h */ case   18:  		/* ori R9, R8, 15360 */
		/* 82071590h case   18:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R8,0x3C00);
		/* 82071590h case   18:*/		return 0x82071594;
		  /* 82071594h */ case   19:  		/* subf R10, R11, R10 */
		/* 82071594h case   19:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82071594h case   19:*/		return 0x82071598;
		  /* 82071598h */ case   20:  		/* li R8, 3 */
		/* 82071598h case   20:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 82071598h case   20:*/		return 0x8207159C;
		  /* 8207159Ch */ case   21:  		/* stwu R10, <#[R3 + 4]> */
		/* 8207159Ch case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207159Ch case   21:*/		return 0x820715A0;
		  /* 820715A0h */ case   22:  		/* li R7, 2609 */
		/* 820715A0h case   22:*/		cpu::op::li<0>(regs,&regs.R7,0xA31);
		/* 820715A0h case   22:*/		return 0x820715A4;
		  /* 820715A4h */ case   23:  		/* li R6, 0 */
		/* 820715A4h case   23:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820715A4h case   23:*/		return 0x820715A8;
		  /* 820715A8h */ case   24:  		/* lis R10, -32768 */
		/* 820715A8h case   24:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 820715A8h case   24:*/		return 0x820715AC;
		  /* 820715ACh */ case   25:  		/* li R5, 8 */
		/* 820715ACh case   25:*/		cpu::op::li<0>(regs,&regs.R5,0x8);
		/* 820715ACh case   25:*/		return 0x820715B0;
		  /* 820715B0h */ case   26:  		/* stwu R11, <#[R3 + 4]> */
		/* 820715B0h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820715B0h case   26:*/		return 0x820715B4;
		  /* 820715B4h */ case   27:  		/* stwu R9, <#[R3 + 4]> */
		/* 820715B4h case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820715B4h case   27:*/		return 0x820715B8;
		  /* 820715B8h */ case   28:  		/* stwu R8, <#[R3 + 4]> */
		/* 820715B8h case   28:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820715B8h case   28:*/		return 0x820715BC;
		  /* 820715BCh */ case   29:  		/* stwu R7, <#[R3 + 4]> */
		/* 820715BCh case   29:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820715BCh case   29:*/		return 0x820715C0;
		  /* 820715C0h */ case   30:  		/* stwu R6, <#[R3 + 4]> */
		/* 820715C0h case   30:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820715C0h case   30:*/		return 0x820715C4;
		  /* 820715C4h */ case   31:  		/* stwu R10, <#[R3 + 4]> */
		/* 820715C4h case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820715C4h case   31:*/		return 0x820715C8;
		  /* 820715C8h */ case   32:  		/* stwu R5, <#[R3 + 4]> */
		/* 820715C8h case   32:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820715C8h case   32:*/		return 0x820715CC;
		  /* 820715CCh */ case   33:  		/* stw R3, <#[R31 + 48]> */
		/* 820715CCh case   33:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 820715CCh case   33:*/		return 0x820715D0;
		  /* 820715D0h */ case   34:  		/* addi R1, R1, 112 */
		/* 820715D0h case   34:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820715D0h case   34:*/		return 0x820715D4;
		  /* 820715D4h */ case   35:  		/* b 130264 */
		/* 820715D4h case   35:*/		return 0x820912AC;
		/* 820715D4h case   35:*/		return 0x820715D8;
	}
	return 0x820715D8;
} // Block from 82071548h-820715D8h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820715D8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820715D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820715D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820715D8);
		  /* 820715D8h */ case    0:  		/* mfspr R12, LR */
		/* 820715D8h case    0:*/		regs.R12 = regs.LR;
		/* 820715D8h case    0:*/		return 0x820715DC;
		  /* 820715DCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820715DCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820715DCh case    1:*/		return 0x820715E0;
		  /* 820715E0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820715E0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820715E0h case    2:*/		return 0x820715E4;
		  /* 820715E4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820715E4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820715E4h case    3:*/		return 0x820715E8;
		  /* 820715E8h */ case    4:  		/* addi R11, R3, 4 */
		/* 820715E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x4);
		/* 820715E8h case    4:*/		return 0x820715EC;
		  /* 820715ECh */ case    5:  		/* mfmsr R9, MSR */
		/* 820715ECh case    5:*/		regs.R9 = regs.MSR;
		/* 820715ECh case    5:*/		return 0x820715F0;
		  /* 820715F0h */ case    6:  		/* mtmsrd MSR, R13 */
		/* 820715F0h case    6:*/		regs.MSR = regs.R13;
		/* 820715F0h case    6:*/		return 0x820715F4;
		  /* 820715F4h */ case    7:  		/* lwarx R10, <#[R11]> */
		/* 820715F4h case    7:*/		cpu::mem::lwarx( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820715F4h case    7:*/		return 0x820715F8;
		  /* 820715F8h */ case    8:  		/* addi R10, R10, 1 */
		/* 820715F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820715F8h case    8:*/		return 0x820715FC;
		  /* 820715FCh */ case    9:  		/* stwcx. R10, <#[R11]> */
		/* 820715FCh case    9:*/		cpu::mem::stwcx( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820715FCh case    9:*/		return 0x82071600;
		  /* 82071600h */ case   10:  		/* mtmsrd MSR, R9 */
		/* 82071600h case   10:*/		regs.MSR = regs.R9;
		/* 82071600h case   10:*/		return 0x82071604;
		  /* 82071604h */ case   11:  		/* bc 4, CR0_EQ, -24 */
		/* 82071604h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820715EC;  }
		/* 82071604h case   11:*/		return 0x82071608;
		  /* 82071608h */ case   12:  		/* mr R31, R10 */
		/* 82071608h case   12:*/		regs.R31 = regs.R10;
		/* 82071608h case   12:*/		return 0x8207160C;
		  /* 8207160Ch */ case   13:  		/* cmplwi CR6, R10, 1 */
		/* 8207160Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8207160Ch case   13:*/		return 0x82071610;
		  /* 82071610h */ case   14:  		/* bc 4, CR6_EQ, 36 */
		/* 82071610h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82071634;  }
		/* 82071610h case   14:*/		return 0x82071614;
		  /* 82071614h */ case   15:  		/* lwz R11, <#[R3]> */
		/* 82071614h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82071614h case   15:*/		return 0x82071618;
		  /* 82071618h */ case   16:  		/* rlwinm R10, R11, 0, 28, 31 */
		/* 82071618h case   16:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R11);
		/* 82071618h case   16:*/		return 0x8207161C;
		  /* 8207161Ch */ case   17:  		/* cmplwi CR6, R10, 4 */
		/* 8207161Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 8207161Ch case   17:*/		return 0x82071620;
		  /* 82071620h */ case   18:  		/* bc 4, CR6_EQ, 20 */
		/* 82071620h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82071634;  }
		/* 82071620h case   18:*/		return 0x82071624;
		  /* 82071624h */ case   19:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 82071624h case   19:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 82071624h case   19:*/		return 0x82071628;
		  /* 82071628h */ case   20:  		/* bc 12, CR0_EQ, 12 */
		/* 82071628h case   20:*/		if ( regs.CR[0].eq ) { return 0x82071634;  }
		/* 82071628h case   20:*/		return 0x8207162C;
		  /* 8207162Ch */ case   21:  		/* lwz R3, <#[R3 + 24]> */
		/* 8207162Ch case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000018) );
		/* 8207162Ch case   21:*/		return 0x82071630;
		  /* 82071630h */ case   22:  		/* bl -88 */
		/* 82071630h case   22:*/		regs.LR = 0x82071634; return 0x820715D8;
		/* 82071630h case   22:*/		return 0x82071634;
	}
	return 0x82071634;
} // Block from 820715D8h-82071634h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82071634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071634);
		  /* 82071634h */ case    0:  		/* mr R3, R31 */
		/* 82071634h case    0:*/		regs.R3 = regs.R31;
		/* 82071634h case    0:*/		return 0x82071638;
		  /* 82071638h */ case    1:  		/* addi R1, R1, 96 */
		/* 82071638h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82071638h case    1:*/		return 0x8207163C;
		  /* 8207163Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8207163Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8207163Ch case    2:*/		return 0x82071640;
		  /* 82071640h */ case    3:  		/* mtspr LR, R12 */
		/* 82071640h case    3:*/		regs.LR = regs.R12;
		/* 82071640h case    3:*/		return 0x82071644;
		  /* 82071644h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82071644h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82071644h case    4:*/		return 0x82071648;
		  /* 82071648h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82071648h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82071648h case    5:*/		return 0x8207164C;
	}
	return 0x8207164C;
} // Block from 82071634h-8207164Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8207164Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207164C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207164C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207164C);
		  /* 8207164Ch */ case    0:  		/* nop */
		/* 8207164Ch case    0:*/		cpu::op::nop();
		/* 8207164Ch case    0:*/		return 0x82071650;
	}
	return 0x82071650;
} // Block from 8207164Ch-82071650h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82071650h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071650);
		  /* 82071650h */ case    0:  		/* lwz R11, <#[R3 + 24]> */
		/* 82071650h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82071650h case    0:*/		return 0x82071654;
		  /* 82071654h */ case    1:  		/* li R5, 0 */
		/* 82071654h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82071654h case    1:*/		return 0x82071658;
		  /* 82071658h */ case    2:  		/* rlwinm R4, R11, 0, 0, 29 */
		/* 82071658h case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R4,regs.R11);
		/* 82071658h case    2:*/		return 0x8207165C;
		  /* 8207165Ch */ case    3:  		/* b -748 */
		/* 8207165Ch case    3:*/		return 0x82071370;
		/* 8207165Ch case    3:*/		return 0x82071660;
	}
	return 0x82071660;
} // Block from 82071650h-82071660h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82071660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071660);
		  /* 82071660h */ case    0:  		/* mfspr R12, LR */
		/* 82071660h case    0:*/		regs.R12 = regs.LR;
		/* 82071660h case    0:*/		return 0x82071664;
		  /* 82071664h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82071664h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82071664h case    1:*/		return 0x82071668;
		  /* 82071668h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82071668h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82071668h case    2:*/		return 0x8207166C;
		  /* 8207166Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8207166Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8207166Ch case    3:*/		return 0x82071670;
		  /* 82071670h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82071670h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82071670h case    4:*/		return 0x82071674;
		  /* 82071674h */ case    5:  		/* lis R11, -32216 */
		/* 82071674h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82071674h case    5:*/		return 0x82071678;
		  /* 82071678h */ case    6:  		/* mr R31, R3 */
		/* 82071678h case    6:*/		regs.R31 = regs.R3;
		/* 82071678h case    6:*/		return 0x8207167C;
		  /* 8207167Ch */ case    7:  		/* lwz R11, <#[R11 + 28720]> */
		/* 8207167Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00007030) );
		/* 8207167Ch case    7:*/		return 0x82071680;
		  /* 82071680h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 82071680h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82071680h case    8:*/		return 0x82071684;
		  /* 82071684h */ case    9:  		/* bc 4, CR6_EQ, 280 */
		/* 82071684h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8207179C;  }
		/* 82071684h case    9:*/		return 0x82071688;
		  /* 82071688h */ case   10:  		/* lwz R11, <#[R3 + 56]> */
		/* 82071688h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 82071688h case   10:*/		return 0x8207168C;
		  /* 8207168Ch */ case   11:  		/* lwz R3, <#[R3 + 48]> */
		/* 8207168Ch case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 8207168Ch case   11:*/		return 0x82071690;
		  /* 82071690h */ case   12:  		/* cmplw CR6, R3, R11 */
		/* 82071690h case   12:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82071690h case   12:*/		return 0x82071694;
		  /* 82071694h */ case   13:  		/* bc 4, CR6_GT, 12 */
		/* 82071694h case   13:*/		if ( !regs.CR[6].gt ) { return 0x820716A0;  }
		/* 82071694h case   13:*/		return 0x82071698;
		  /* 82071698h */ case   14:  		/* mr R3, R31 */
		/* 82071698h case   14:*/		regs.R3 = regs.R31;
		/* 82071698h case   14:*/		return 0x8207169C;
		  /* 8207169Ch */ case   15:  		/* bl 10860 */
		/* 8207169Ch case   15:*/		regs.LR = 0x820716A0; return 0x82074108;
		/* 8207169Ch case   15:*/		return 0x820716A0;
	}
	return 0x820716A0;
} // Block from 82071660h-820716A0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820716A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820716A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820716A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820716A0);
		  /* 820716A0h */ case    0:  		/* lis R11, 2 */
		/* 820716A0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x2);
		/* 820716A0h case    0:*/		return 0x820716A4;
		  /* 820716A4h */ case    1:  		/* li R10, 15 */
		/* 820716A4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xF);
		/* 820716A4h case    1:*/		return 0x820716A8;
		  /* 820716A8h */ case    2:  		/* ori R11, R11, 8448 */
		/* 820716A8h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2100);
		/* 820716A8h case    2:*/		return 0x820716AC;
		  /* 820716ACh */ case    3:  		/* li R9, 14 */
		/* 820716ACh case    3:*/		cpu::op::li<0>(regs,&regs.R9,0xE);
		/* 820716ACh case    3:*/		return 0x820716B0;
		  /* 820716B0h */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 820716B0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820716B0h case    4:*/		return 0x820716B4;
		  /* 820716B4h */ case    5:  		/* li R11, 16 */
		/* 820716B4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 820716B4h case    5:*/		return 0x820716B8;
		  /* 820716B8h */ case    6:  		/* lis R8, -16384 */
		/* 820716B8h case    6:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFC000);
		/* 820716B8h case    6:*/		return 0x820716BC;
		  /* 820716BCh */ case    7:  		/* li R7, 256 */
		/* 820716BCh case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x100);
		/* 820716BCh case    7:*/		return 0x820716C0;
		  /* 820716C0h */ case    8:  		/* ori R8, R8, 15104 */
		/* 820716C0h case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x3B00);
		/* 820716C0h case    8:*/		return 0x820716C4;
		  /* 820716C4h */ case    9:  		/* lis R6, -16368 */
		/* 820716C4h case    9:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFFC010);
		/* 820716C4h case    9:*/		return 0x820716C8;
		  /* 820716C8h */ case   10:  		/* stwu R10, <#[R3 + 4]> */
		/* 820716C8h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820716C8h case   10:*/		return 0x820716CC;
		  /* 820716CCh */ case   11:  		/* li R30, 0 */
		/* 820716CCh case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820716CCh case   11:*/		return 0x820716D0;
		  /* 820716D0h */ case   12:  		/* ori R10, R6, 11008 */
		/* 820716D0h case   12:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R6,0x2B00);
		/* 820716D0h case   12:*/		return 0x820716D4;
		  /* 820716D4h */ case   13:  		/* li R6, 15 */
		/* 820716D4h case   13:*/		cpu::op::li<0>(regs,&regs.R6,0xF);
		/* 820716D4h case   13:*/		return 0x820716D8;
		  /* 820716D8h */ case   14:  		/* lis R4, -32256 */
		/* 820716D8h case   14:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8200);
		/* 820716D8h case   14:*/		return 0x820716DC;
		  /* 820716DCh */ case   15:  		/* li R5, 60 */
		/* 820716DCh case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x3C);
		/* 820716DCh case   15:*/		return 0x820716E0;
		  /* 820716E0h */ case   16:  		/* stwu R9, <#[R3 + 4]> */
		/* 820716E0h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820716E0h case   16:*/		return 0x820716E4;
		  /* 820716E4h */ case   17:  		/* addi R4, R4, 4388 */
		/* 820716E4h case   17:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1124);
		/* 820716E4h case   17:*/		return 0x820716E8;
		  /* 820716E8h */ case   18:  		/* stwu R11, <#[R3 + 4]> */
		/* 820716E8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820716E8h case   18:*/		return 0x820716EC;
		  /* 820716ECh */ case   19:  		/* stwu R8, <#[R3 + 4]> */
		/* 820716ECh case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820716ECh case   19:*/		return 0x820716F0;
		  /* 820716F0h */ case   20:  		/* stwu R7, <#[R3 + 4]> */
		/* 820716F0h case   20:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820716F0h case   20:*/		return 0x820716F4;
		  /* 820716F4h */ case   21:  		/* stwu R10, <#[R3 + 4]> */
		/* 820716F4h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820716F4h case   21:*/		return 0x820716F8;
		  /* 820716F8h */ case   22:  		/* stwu R30, <#[R3 + 4]> */
		/* 820716F8h case   22:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820716F8h case   22:*/		return 0x820716FC;
		  /* 820716FCh */ case   23:  		/* mr R30, R3 */
		/* 820716FCh case   23:*/		regs.R30 = regs.R3;
		/* 820716FCh case   23:*/		return 0x82071700;
		  /* 82071700h */ case   24:  		/* stwu R6, <#[R30 + 4]> */
		/* 82071700h case   24:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82071700h case   24:*/		return 0x82071704;
		  /* 82071704h */ case   25:  		/* addi R3, R30, 4 */
		/* 82071704h case   25:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 82071704h case   25:*/		return 0x82071708;
		  /* 82071708h */ case   26:  		/* bl 131752 */
		/* 82071708h case   26:*/		regs.LR = 0x8207170C; return 0x820919B0;
		/* 82071708h case   26:*/		return 0x8207170C;
		  /* 8207170Ch */ case   27:  		/* addi R11, R30, 60 */
		/* 8207170Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x3C);
		/* 8207170Ch case   27:*/		return 0x82071710;
		  /* 82071710h */ case   28:  		/* lis R10, 1 */
		/* 82071710h case   28:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 82071710h case   28:*/		return 0x82071714;
		  /* 82071714h */ case   29:  		/* lis R9, 1792 */
		/* 82071714h case   29:*/		cpu::op::lis<0>(regs,&regs.R9,0x700);
		/* 82071714h case   29:*/		return 0x82071718;
		  /* 82071718h */ case   30:  		/* ori R10, R10, 8576 */
		/* 82071718h case   30:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2180);
		/* 82071718h case   30:*/		return 0x8207171C;
		  /* 8207171Ch */ case   31:  		/* li R8, 0 */
		/* 8207171Ch case   31:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8207171Ch case   31:*/		return 0x82071720;
		  /* 82071720h */ case   32:  		/* stwu R10, <#[R11 + 4]> */
		/* 82071720h case   32:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82071720h case   32:*/		return 0x82071724;
		  /* 82071724h */ case   33:  		/* li R10, 8712 */
		/* 82071724h case   33:*/		cpu::op::li<0>(regs,&regs.R10,0x2208);
		/* 82071724h case   33:*/		return 0x82071728;
		  /* 82071728h */ case   34:  		/* li R7, 4 */
		/* 82071728h case   34:*/		cpu::op::li<0>(regs,&regs.R7,0x4);
		/* 82071728h case   34:*/		return 0x8207172C;
		  /* 8207172Ch */ case   35:  		/* lis R6, -16384 */
		/* 8207172Ch case   35:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFFC000);
		/* 8207172Ch case   35:*/		return 0x82071730;
		  /* 82071730h */ case   36:  		/* lis R5, 1 */
		/* 82071730h case   36:*/		cpu::op::lis<0>(regs,&regs.R5,0x1);
		/* 82071730h case   36:*/		return 0x82071734;
		  /* 82071734h */ case   37:  		/* ori R6, R6, 13824 */
		/* 82071734h case   37:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x3600);
		/* 82071734h case   37:*/		return 0x82071738;
		  /* 82071738h */ case   38:  		/* stwu R9, <#[R11 + 4]> */
		/* 82071738h case   38:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82071738h case   38:*/		return 0x8207173C;
		  /* 8207173Ch */ case   39:  		/* ori R5, R5, 129 */
		/* 8207173Ch case   39:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x81);
		/* 8207173Ch case   39:*/		return 0x82071740;
		  /* 82071740h */ case   40:  		/* li R12, 1 */
		/* 82071740h case   40:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82071740h case   40:*/		return 0x82071744;
		  /* 82071744h */ case   41:  		/* rldicr R12, R12, 41, 63 */
		/* 82071744h case   41:*/		cpu::op::rldicr<0,41,63>(regs,&regs.R12,regs.R12);
		/* 82071744h case   41:*/		return 0x82071748;
		  /* 82071748h */ case   42:  		/* stwu R8, <#[R11 + 4]> */
		/* 82071748h case   42:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82071748h case   42:*/		return 0x8207174C;
		  /* 8207174Ch */ case   43:  		/* stwu R10, <#[R11 + 4]> */
		/* 8207174Ch case   43:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8207174Ch case   43:*/		return 0x82071750;
		  /* 82071750h */ case   44:  		/* stwu R7, <#[R11 + 4]> */
		/* 82071750h case   44:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82071750h case   44:*/		return 0x82071754;
		  /* 82071754h */ case   45:  		/* stwu R6, <#[R11 + 4]> */
		/* 82071754h case   45:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82071754h case   45:*/		return 0x82071758;
		  /* 82071758h */ case   46:  		/* stwu R5, <#[R11 + 4]> */
		/* 82071758h case   46:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82071758h case   46:*/		return 0x8207175C;
		  /* 8207175Ch */ case   47:  		/* ld R10, <#[R31 + 16]> */
		/* 8207175Ch case   47:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 8207175Ch case   47:*/		return 0x82071760;
		  /* 82071760h */ case   48:  		/* oris R10, R10, 8 */
		/* 82071760h case   48:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82071760h case   48:*/		return 0x82071764;
		  /* 82071764h */ case   49:  		/* std R10, <#[R31 + 16]> */
		/* 82071764h case   49:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071764h case   49:*/		return 0x82071768;
		  /* 82071768h */ case   50:  		/* or R10, R10, R12 */
		/* 82071768h case   50:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82071768h case   50:*/		return 0x8207176C;
		  /* 8207176Ch */ case   51:  		/* li R12, 1 */
		/* 8207176Ch case   51:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8207176Ch case   51:*/		return 0x82071770;
		  /* 82071770h */ case   52:  		/* std R10, <#[R31 + 16]> */
		/* 82071770h case   52:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071770h case   52:*/		return 0x82071774;
		  /* 82071774h */ case   53:  		/* rldicr R12, R12, 40, 63 */
		/* 82071774h case   53:*/		cpu::op::rldicr<0,40,63>(regs,&regs.R12,regs.R12);
		/* 82071774h case   53:*/		return 0x82071778;
		  /* 82071778h */ case   54:  		/* or R10, R10, R12 */
		/* 82071778h case   54:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82071778h case   54:*/		return 0x8207177C;
		  /* 8207177Ch */ case   55:  		/* li R12, 1 */
		/* 8207177Ch case   55:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8207177Ch case   55:*/		return 0x82071780;
		  /* 82071780h */ case   56:  		/* std R10, <#[R31 + 16]> */
		/* 82071780h case   56:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071780h case   56:*/		return 0x82071784;
		  /* 82071784h */ case   57:  		/* rldicr R12, R12, 39, 63 */
		/* 82071784h case   57:*/		cpu::op::rldicr<0,39,63>(regs,&regs.R12,regs.R12);
		/* 82071784h case   57:*/		return 0x82071788;
		  /* 82071788h */ case   58:  		/* or R10, R10, R12 */
		/* 82071788h case   58:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82071788h case   58:*/		return 0x8207178C;
		  /* 8207178Ch */ case   59:  		/* std R10, <#[R31 + 16]> */
		/* 8207178Ch case   59:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 8207178Ch case   59:*/		return 0x82071790;
		  /* 82071790h */ case   60:  		/* ori R10, R10, 8 */
		/* 82071790h case   60:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82071790h case   60:*/		return 0x82071794;
		  /* 82071794h */ case   61:  		/* std R10, <#[R31 + 16]> */
		/* 82071794h case   61:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071794h case   61:*/		return 0x82071798;
		  /* 82071798h */ case   62:  		/* stw R11, <#[R31 + 48]> */
		/* 82071798h case   62:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82071798h case   62:*/		return 0x8207179C;
	}
	return 0x8207179C;
} // Block from 820716A0h-8207179Ch (63 instructions)

//////////////////////////////////////////////////////
// Block at 8207179Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207179C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207179C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207179C);
		  /* 8207179Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8207179Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8207179Ch case    0:*/		return 0x820717A0;
		  /* 820717A0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820717A0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820717A0h case    1:*/		return 0x820717A4;
		  /* 820717A4h */ case    2:  		/* mtspr LR, R12 */
		/* 820717A4h case    2:*/		regs.LR = regs.R12;
		/* 820717A4h case    2:*/		return 0x820717A8;
		  /* 820717A8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820717A8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820717A8h case    3:*/		return 0x820717AC;
		  /* 820717ACh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820717ACh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820717ACh case    4:*/		return 0x820717B0;
		  /* 820717B0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820717B0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820717B0h case    5:*/		return 0x820717B4;
	}
	return 0x820717B4;
} // Block from 8207179Ch-820717B4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820717B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820717B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820717B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820717B4);
		  /* 820717B4h */ case    0:  		/* nop */
		/* 820717B4h case    0:*/		cpu::op::nop();
		/* 820717B4h case    0:*/		return 0x820717B8;
	}
	return 0x820717B8;
} // Block from 820717B4h-820717B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820717B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820717B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820717B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820717B8);
		  /* 820717B8h */ case    0:  		/* mfspr R12, LR */
		/* 820717B8h case    0:*/		regs.R12 = regs.LR;
		/* 820717B8h case    0:*/		return 0x820717BC;
		  /* 820717BCh */ case    1:  		/* bl 129636 */
		/* 820717BCh case    1:*/		regs.LR = 0x820717C0; return 0x82091220;
		/* 820717BCh case    1:*/		return 0x820717C0;
		  /* 820717C0h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 820717C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 820717C0h case    2:*/		return 0x820717C4;
		  /* 820717C4h */ case    3:  		/* lis R11, -32216 */
		/* 820717C4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 820717C4h case    3:*/		return 0x820717C8;
		  /* 820717C8h */ case    4:  		/* stw R3, <#[R1 + 260]> */
		/* 820717C8h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000104) );
		/* 820717C8h case    4:*/		return 0x820717CC;
		  /* 820717CCh */ case    5:  		/* mr R31, R3 */
		/* 820717CCh case    5:*/		regs.R31 = regs.R3;
		/* 820717CCh case    5:*/		return 0x820717D0;
		  /* 820717D0h */ case    6:  		/* lwz R11, <#[R11 + 28724]> */
		/* 820717D0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00007034) );
		/* 820717D0h case    6:*/		return 0x820717D4;
		  /* 820717D4h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820717D4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820717D4h case    7:*/		return 0x820717D8;
		  /* 820717D8h */ case    8:  		/* bc 4, CR6_EQ, 864 */
		/* 820717D8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82071B38;  }
		/* 820717D8h case    8:*/		return 0x820717DC;
		  /* 820717DCh */ case    9:  		/* lwz R3, <#[R3 + 48]> */
		/* 820717DCh case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 820717DCh case    9:*/		return 0x820717E0;
		  /* 820717E0h */ case   10:  		/* lwz R11, <#[R31 + 56]> */
		/* 820717E0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820717E0h case   10:*/		return 0x820717E4;
		  /* 820717E4h */ case   11:  		/* cmplw CR6, R3, R11 */
		/* 820717E4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820717E4h case   11:*/		return 0x820717E8;
		  /* 820717E8h */ case   12:  		/* bc 4, CR6_GT, 12 */
		/* 820717E8h case   12:*/		if ( !regs.CR[6].gt ) { return 0x820717F4;  }
		/* 820717E8h case   12:*/		return 0x820717EC;
		  /* 820717ECh */ case   13:  		/* mr R3, R31 */
		/* 820717ECh case   13:*/		regs.R3 = regs.R31;
		/* 820717ECh case   13:*/		return 0x820717F0;
		  /* 820717F0h */ case   14:  		/* bl 10520 */
		/* 820717F0h case   14:*/		regs.LR = 0x820717F4; return 0x82074108;
		/* 820717F0h case   14:*/		return 0x820717F4;
	}
	return 0x820717F4;
} // Block from 820717B8h-820717F4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820717F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820717F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820717F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820717F4);
		  /* 820717F4h */ case    0:  		/* lis R11, -16384 */
		/* 820717F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 820717F4h case    0:*/		return 0x820717F8;
		  /* 820717F8h */ case    1:  		/* li R10, 768 */
		/* 820717F8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x300);
		/* 820717F8h case    1:*/		return 0x820717FC;
		  /* 820717FCh */ case    2:  		/* ori R11, R11, 15104 */
		/* 820717FCh case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3B00);
		/* 820717FCh case    2:*/		return 0x82071800;
		  /* 82071800h */ case    3:  		/* lis R9, -16359 */
		/* 82071800h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC019);
		/* 82071800h case    3:*/		return 0x82071804;
		  /* 82071804h */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 82071804h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071804h case    4:*/		return 0x82071808;
		  /* 82071808h */ case    5:  		/* li R8, 0 */
		/* 82071808h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82071808h case    5:*/		return 0x8207180C;
		  /* 8207180Ch */ case    6:  		/* ori R9, R9, 11008 */
		/* 8207180Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x2B00);
		/* 8207180Ch case    6:*/		return 0x82071810;
		  /* 82071810h */ case    7:  		/* li R7, 24 */
		/* 82071810h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x18);
		/* 82071810h case    7:*/		return 0x82071814;
		  /* 82071814h */ case    8:  		/* lis R11, -32256 */
		/* 82071814h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82071814h case    8:*/		return 0x82071818;
		  /* 82071818h */ case    9:  		/* li R5, 96 */
		/* 82071818h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x60);
		/* 82071818h case    9:*/		return 0x8207181C;
		  /* 8207181Ch */ case   10:  		/* stwu R10, <#[R3 + 4]> */
		/* 8207181Ch case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207181Ch case   10:*/		return 0x82071820;
		  /* 82071820h */ case   11:  		/* addi R29, R11, 4256 */
		/* 82071820h case   11:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x10A0);
		/* 82071820h case   11:*/		return 0x82071824;
		  /* 82071824h */ case   12:  		/* mr R4, R29 */
		/* 82071824h case   12:*/		regs.R4 = regs.R29;
		/* 82071824h case   12:*/		return 0x82071828;
		  /* 82071828h */ case   13:  		/* stwu R9, <#[R3 + 4]> */
		/* 82071828h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071828h case   13:*/		return 0x8207182C;
		  /* 8207182Ch */ case   14:  		/* stwu R8, <#[R3 + 4]> */
		/* 8207182Ch case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207182Ch case   14:*/		return 0x82071830;
		  /* 82071830h */ case   15:  		/* mr R30, R3 */
		/* 82071830h case   15:*/		regs.R30 = regs.R3;
		/* 82071830h case   15:*/		return 0x82071834;
		  /* 82071834h */ case   16:  		/* stwu R7, <#[R30 + 4]> */
		/* 82071834h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82071834h case   16:*/		return 0x82071838;
		  /* 82071838h */ case   17:  		/* addi R3, R30, 4 */
		/* 82071838h case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 82071838h case   17:*/		return 0x8207183C;
		  /* 8207183Ch */ case   18:  		/* bl 131444 */
		/* 8207183Ch case   18:*/		regs.LR = 0x82071840; return 0x820919B0;
		/* 8207183Ch case   18:*/		return 0x82071840;
		  /* 82071840h */ case   19:  		/* lwz R10, <#[R31 + 56]> */
		/* 82071840h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 82071840h case   19:*/		return 0x82071844;
		  /* 82071844h */ case   20:  		/* addi R11, R30, 96 */
		/* 82071844h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x60);
		/* 82071844h case   20:*/		return 0x82071848;
		  /* 82071848h */ case   21:  		/* stw R11, <#[R31 + 48]> */
		/* 82071848h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82071848h case   21:*/		return 0x8207184C;
		  /* 8207184Ch */ case   22:  		/* mr R3, R11 */
		/* 8207184Ch case   22:*/		regs.R3 = regs.R11;
		/* 8207184Ch case   22:*/		return 0x82071850;
		  /* 82071850h */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 82071850h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82071850h case   23:*/		return 0x82071854;
		  /* 82071854h */ case   24:  		/* bc 4, CR6_GT, 12 */
		/* 82071854h case   24:*/		if ( !regs.CR[6].gt ) { return 0x82071860;  }
		/* 82071854h case   24:*/		return 0x82071858;
		  /* 82071858h */ case   25:  		/* mr R3, R31 */
		/* 82071858h case   25:*/		regs.R3 = regs.R31;
		/* 82071858h case   25:*/		return 0x8207185C;
		  /* 8207185Ch */ case   26:  		/* bl 10412 */
		/* 8207185Ch case   26:*/		regs.LR = 0x82071860; return 0x82074108;
		/* 8207185Ch case   26:*/		return 0x82071860;
	}
	return 0x82071860;
} // Block from 820717F4h-82071860h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82071860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071860);
		  /* 82071860h */ case    0:  		/* lis R11, -16374 */
		/* 82071860h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC00A);
		/* 82071860h case    0:*/		return 0x82071864;
		  /* 82071864h */ case    1:  		/* li R10, 1 */
		/* 82071864h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82071864h case    1:*/		return 0x82071868;
		  /* 82071868h */ case    2:  		/* ori R11, R11, 11008 */
		/* 82071868h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2B00);
		/* 82071868h case    2:*/		return 0x8207186C;
		  /* 8207186Ch */ case    3:  		/* li R9, 9 */
		/* 8207186Ch case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x9);
		/* 8207186Ch case    3:*/		return 0x82071870;
		  /* 82071870h */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 82071870h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071870h case    4:*/		return 0x82071874;
		  /* 82071874h */ case    5:  		/* addi R4, R29, 96 */
		/* 82071874h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0x60);
		/* 82071874h case    5:*/		return 0x82071878;
		  /* 82071878h */ case    6:  		/* li R5, 36 */
		/* 82071878h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 82071878h case    6:*/		return 0x8207187C;
		  /* 8207187Ch */ case    7:  		/* stwu R10, <#[R3 + 4]> */
		/* 8207187Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207187Ch case    7:*/		return 0x82071880;
		  /* 82071880h */ case    8:  		/* mr R30, R3 */
		/* 82071880h case    8:*/		regs.R30 = regs.R3;
		/* 82071880h case    8:*/		return 0x82071884;
		  /* 82071884h */ case    9:  		/* stwu R9, <#[R30 + 4]> */
		/* 82071884h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82071884h case    9:*/		return 0x82071888;
		  /* 82071888h */ case   10:  		/* addi R3, R30, 4 */
		/* 82071888h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 82071888h case   10:*/		return 0x8207188C;
		  /* 8207188Ch */ case   11:  		/* bl 131364 */
		/* 8207188Ch case   11:*/		regs.LR = 0x82071890; return 0x820919B0;
		/* 8207188Ch case   11:*/		return 0x82071890;
		  /* 82071890h */ case   12:  		/* lwz R11, <#[R31 + 56]> */
		/* 82071890h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82071890h case   12:*/		return 0x82071894;
		  /* 82071894h */ case   13:  		/* addi R3, R30, 36 */
		/* 82071894h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x24);
		/* 82071894h case   13:*/		return 0x82071898;
		  /* 82071898h */ case   14:  		/* stw R3, <#[R31 + 48]> */
		/* 82071898h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82071898h case   14:*/		return 0x8207189C;
		  /* 8207189Ch */ case   15:  		/* cmplw CR6, R3, R11 */
		/* 8207189Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8207189Ch case   15:*/		return 0x820718A0;
		  /* 820718A0h */ case   16:  		/* bc 4, CR6_GT, 12 */
		/* 820718A0h case   16:*/		if ( !regs.CR[6].gt ) { return 0x820718AC;  }
		/* 820718A0h case   16:*/		return 0x820718A4;
		  /* 820718A4h */ case   17:  		/* mr R3, R31 */
		/* 820718A4h case   17:*/		regs.R3 = regs.R31;
		/* 820718A4h case   17:*/		return 0x820718A8;
		  /* 820718A8h */ case   18:  		/* bl 10336 */
		/* 820718A8h case   18:*/		regs.LR = 0x820718AC; return 0x82074108;
		/* 820718A8h case   18:*/		return 0x820718AC;
	}
	return 0x820718AC;
} // Block from 82071860h-820718ACh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820718ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820718AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820718AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820718AC);
		  /* 820718ACh */ case    0:  		/* lis R11, 1 */
		/* 820718ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 820718ACh case    0:*/		return 0x820718B0;
		  /* 820718B0h */ case    1:  		/* lis R10, 4096 */
		/* 820718B0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x1000);
		/* 820718B0h case    1:*/		return 0x820718B4;
		  /* 820718B4h */ case    2:  		/* ori R11, R11, 8576 */
		/* 820718B4h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2180);
		/* 820718B4h case    2:*/		return 0x820718B8;
		  /* 820718B8h */ case    3:  		/* ori R10, R10, 1 */
		/* 820718B8h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820718B8h case    3:*/		return 0x820718BC;
		  /* 820718BCh */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 820718BCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820718BCh case    4:*/		return 0x820718C0;
		  /* 820718C0h */ case    5:  		/* li R8, 0 */
		/* 820718C0h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820718C0h case    5:*/		return 0x820718C4;
		  /* 820718C4h */ case    6:  		/* li R11, 0 */
		/* 820718C4h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820718C4h case    6:*/		return 0x820718C8;
		  /* 820718C8h */ case    7:  		/* stw R8, <#[R1 + 80]> */
		/* 820718C8h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 820718C8h case    7:*/		return 0x820718CC;
		  /* 820718CCh */ case    8:  		/* li R8, 8851 */
		/* 820718CCh case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x2293);
		/* 820718CCh case    8:*/		return 0x820718D0;
		  /* 820718D0h */ case    9:  		/* lis R9, 2 */
		/* 820718D0h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x2);
		/* 820718D0h case    9:*/		return 0x820718D4;
		  /* 820718D4h */ case   10:  		/* stw R8, <#[R1 + 84]> */
		/* 820718D4h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 820718D4h case   10:*/		return 0x820718D8;
		  /* 820718D8h */ case   11:  		/* lis R7, 0 */
		/* 820718D8h case   11:*/		cpu::op::lis<0>(regs,&regs.R7,0x0);
		/* 820718D8h case   11:*/		return 0x820718DC;
		  /* 820718DCh */ case   12:  		/* stwu R10, <#[R3 + 4]> */
		/* 820718DCh case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820718DCh case   12:*/		return 0x820718E0;
		  /* 820718E0h */ case   13:  		/* ori R9, R9, 8448 */
		/* 820718E0h case   13:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x2100);
		/* 820718E0h case   13:*/		return 0x820718E4;
		  /* 820718E4h */ case   14:  		/* ori R10, R7, 65535 */
		/* 820718E4h case   14:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R7,0xFFFF);
		/* 820718E4h case   14:*/		return 0x820718E8;
		  /* 820718E8h */ case   15:  		/* li R8, 0 */
		/* 820718E8h case   15:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820718E8h case   15:*/		return 0x820718EC;
		  /* 820718ECh */ case   16:  		/* li R7, 0 */
		/* 820718ECh case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820718ECh case   16:*/		return 0x820718F0;
		  /* 820718F0h */ case   17:  		/* lis R6, 2 */
		/* 820718F0h case   17:*/		cpu::op::lis<0>(regs,&regs.R6,0x2);
		/* 820718F0h case   17:*/		return 0x820718F4;
		  /* 820718F4h */ case   18:  		/* stwu R11, <#[R3 + 4]> */
		/* 820718F4h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820718F4h case   18:*/		return 0x820718F8;
		  /* 820718F8h */ case   19:  		/* lis R5, 1 */
		/* 820718F8h case   19:*/		cpu::op::lis<0>(regs,&regs.R5,0x1);
		/* 820718F8h case   19:*/		return 0x820718FC;
		  /* 820718FCh */ case   20:  		/* ori R6, R6, 8708 */
		/* 820718FCh case   20:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x2204);
		/* 820718FCh case   20:*/		return 0x82071900;
		  /* 82071900h */ case   21:  		/* lis R11, 1 */
		/* 82071900h case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 82071900h case   21:*/		return 0x82071904;
		  /* 82071904h */ case   22:  		/* li R4, 768 */
		/* 82071904h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x300);
		/* 82071904h case   22:*/		return 0x82071908;
		  /* 82071908h */ case   23:  		/* li R31, 8978 */
		/* 82071908h case   23:*/		cpu::op::li<0>(regs,&regs.R31,0x2312);
		/* 82071908h case   23:*/		return 0x8207190C;
		  /* 8207190Ch */ case   24:  		/* stwu R9, <#[R3 + 4]> */
		/* 8207190Ch case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207190Ch case   24:*/		return 0x82071910;
		  /* 82071910h */ case   25:  		/* lis R30, 0 */
		/* 82071910h case   25:*/		cpu::op::lis<0>(regs,&regs.R30,0x0);
		/* 82071910h case   25:*/		return 0x82071914;
		  /* 82071914h */ case   26:  		/* li R29, 8205 */
		/* 82071914h case   26:*/		cpu::op::li<0>(regs,&regs.R29,0x200D);
		/* 82071914h case   26:*/		return 0x82071918;
		  /* 82071918h */ case   27:  		/* ori R30, R30, 65535 */
		/* 82071918h case   27:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xFFFF);
		/* 82071918h case   27:*/		return 0x8207191C;
		  /* 8207191Ch */ case   28:  		/* li R9, 0 */
		/* 8207191Ch case   28:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8207191Ch case   28:*/		return 0x82071920;
		  /* 82071920h */ case   29:  		/* li R28, 8704 */
		/* 82071920h case   29:*/		cpu::op::li<0>(regs,&regs.R28,0x2200);
		/* 82071920h case   29:*/		return 0x82071924;
		  /* 82071924h */ case   30:  		/* stwu R10, <#[R3 + 4]> */
		/* 82071924h case   30:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071924h case   30:*/		return 0x82071928;
		  /* 82071928h */ case   31:  		/* li R23, 0 */
		/* 82071928h case   31:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82071928h case   31:*/		return 0x8207192C;
		  /* 8207192Ch */ case   32:  		/* li R10, 8707 */
		/* 8207192Ch case   32:*/		cpu::op::li<0>(regs,&regs.R10,0x2203);
		/* 8207192Ch case   32:*/		return 0x82071930;
		  /* 82071930h */ case   33:  		/* lwz R25, <#[R1 + 80]> */
		/* 82071930h case   33:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000050) );
		/* 82071930h case   33:*/		return 0x82071934;
		  /* 82071934h */ case   34:  		/* li R21, 0 */
		/* 82071934h case   34:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 82071934h case   34:*/		return 0x82071938;
		  /* 82071938h */ case   35:  		/* li R20, 8712 */
		/* 82071938h case   35:*/		cpu::op::li<0>(regs,&regs.R20,0x2208);
		/* 82071938h case   35:*/		return 0x8207193C;
		  /* 8207193Ch */ case   36:  		/* lwz R22, <#[R1 + 84]> */
		/* 8207193Ch case   36:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000054) );
		/* 8207193Ch case   36:*/		return 0x82071940;
		  /* 82071940h */ case   37:  		/* li R19, 4 */
		/* 82071940h case   37:*/		cpu::op::li<0>(regs,&regs.R19,0x4);
		/* 82071940h case   37:*/		return 0x82071944;
		  /* 82071944h */ case   38:  		/* stwu R8, <#[R3 + 4]> */
		/* 82071944h case   38:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071944h case   38:*/		return 0x82071948;
		  /* 82071948h */ case   39:  		/* li R18, 8452 */
		/* 82071948h case   39:*/		cpu::op::li<0>(regs,&regs.R18,0x2104);
		/* 82071948h case   39:*/		return 0x8207194C;
		  /* 8207194Ch */ case   40:  		/* li R17, 0 */
		/* 8207194Ch case   40:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 8207194Ch case   40:*/		return 0x82071950;
		  /* 82071950h */ case   41:  		/* li R8, 8832 */
		/* 82071950h case   41:*/		cpu::op::li<0>(regs,&regs.R8,0x2280);
		/* 82071950h case   41:*/		return 0x82071954;
		  /* 82071954h */ case   42:  		/* lis R27, 8 */
		/* 82071954h case   42:*/		cpu::op::lis<0>(regs,&regs.R27,0x8);
		/* 82071954h case   42:*/		return 0x82071958;
		  /* 82071958h */ case   43:  		/* li R16, 8962 */
		/* 82071958h case   43:*/		cpu::op::li<0>(regs,&regs.R16,0x2302);
		/* 82071958h case   43:*/		return 0x8207195C;
		  /* 8207195Ch */ case   44:  		/* stwu R25, <#[R3 + 4]> */
		/* 8207195Ch case   44:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207195Ch case   44:*/		return 0x82071960;
		  /* 82071960h */ case   45:  		/* ori R27, R27, 8 */
		/* 82071960h case   45:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x8);
		/* 82071960h case   45:*/		return 0x82071964;
		  /* 82071964h */ case   46:  		/* li R15, 4 */
		/* 82071964h case   46:*/		cpu::op::li<0>(regs,&regs.R15,0x4);
		/* 82071964h case   46:*/		return 0x82071968;
		  /* 82071968h */ case   47:  		/* lis R26, 2 */
		/* 82071968h case   47:*/		cpu::op::lis<0>(regs,&regs.R26,0x2);
		/* 82071968h case   47:*/		return 0x8207196C;
		  /* 8207196Ch */ case   48:  		/* li R14, 0 */
		/* 8207196Ch case   48:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 8207196Ch case   48:*/		return 0x82071970;
		  /* 82071970h */ case   49:  		/* ori R26, R26, 8320 */
		/* 82071970h case   49:*/		cpu::op::ori<0>(regs,&regs.R26,regs.R26,0x2080);
		/* 82071970h case   49:*/		return 0x82071974;
		  /* 82071974h */ case   50:  		/* stwu R22, <#[R3 + 4]> */
		/* 82071974h case   50:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071974h case   50:*/		return 0x82071978;
		  /* 82071978h */ case   51:  		/* li R25, 0 */
		/* 82071978h case   51:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82071978h case   51:*/		return 0x8207197C;
		  /* 8207197Ch */ case   52:  		/* lis R24, 16 */
		/* 8207197Ch case   52:*/		cpu::op::lis<0>(regs,&regs.R24,0x10);
		/* 8207197Ch case   52:*/		return 0x82071980;
		  /* 82071980h */ case   53:  		/* ori R24, R24, 16 */
		/* 82071980h case   53:*/		cpu::op::ori<0>(regs,&regs.R24,regs.R24,0x10);
		/* 82071980h case   53:*/		return 0x82071984;
		  /* 82071984h */ case   54:  		/* stwu R7, <#[R3 + 4]> */
		/* 82071984h case   54:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071984h case   54:*/		return 0x82071988;
		  /* 82071988h */ case   55:  		/* stwu R6, <#[R3 + 4]> */
		/* 82071988h case   55:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071988h case   55:*/		return 0x8207198C;
		  /* 8207198Ch */ case   56:  		/* stwu R5, <#[R3 + 4]> */
		/* 8207198Ch case   56:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207198Ch case   56:*/		return 0x82071990;
		  /* 82071990h */ case   57:  		/* stwu R11, <#[R3 + 4]> */
		/* 82071990h case   57:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071990h case   57:*/		return 0x82071994;
		  /* 82071994h */ case   58:  		/* stwu R4, <#[R3 + 4]> */
		/* 82071994h case   58:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071994h case   58:*/		return 0x82071998;
		  /* 82071998h */ case   59:  		/* stwu R31, <#[R3 + 4]> */
		/* 82071998h case   59:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071998h case   59:*/		return 0x8207199C;
		  /* 8207199Ch */ case   60:  		/* lwz R31, <#[R1 + 260]> */
		/* 8207199Ch case   60:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000104) );
		/* 8207199Ch case   60:*/		return 0x820719A0;
		  /* 820719A0h */ case   61:  		/* stwu R30, <#[R3 + 4]> */
		/* 820719A0h case   61:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719A0h case   61:*/		return 0x820719A4;
		  /* 820719A4h */ case   62:  		/* stwu R29, <#[R3 + 4]> */
		/* 820719A4h case   62:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719A4h case   62:*/		return 0x820719A8;
		  /* 820719A8h */ case   63:  		/* stwu R9, <#[R3 + 4]> */
		/* 820719A8h case   63:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719A8h case   63:*/		return 0x820719AC;
		  /* 820719ACh */ case   64:  		/* stwu R28, <#[R3 + 4]> */
		/* 820719ACh case   64:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719ACh case   64:*/		return 0x820719B0;
		  /* 820719B0h */ case   65:  		/* stwu R23, <#[R3 + 4]> */
		/* 820719B0h case   65:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719B0h case   65:*/		return 0x820719B4;
		  /* 820719B4h */ case   66:  		/* stwu R10, <#[R3 + 4]> */
		/* 820719B4h case   66:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719B4h case   66:*/		return 0x820719B8;
		  /* 820719B8h */ case   67:  		/* stwu R21, <#[R3 + 4]> */
		/* 820719B8h case   67:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719B8h case   67:*/		return 0x820719BC;
		  /* 820719BCh */ case   68:  		/* stwu R20, <#[R3 + 4]> */
		/* 820719BCh case   68:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719BCh case   68:*/		return 0x820719C0;
		  /* 820719C0h */ case   69:  		/* stwu R19, <#[R3 + 4]> */
		/* 820719C0h case   69:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719C0h case   69:*/		return 0x820719C4;
		  /* 820719C4h */ case   70:  		/* stwu R18, <#[R3 + 4]> */
		/* 820719C4h case   70:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719C4h case   70:*/		return 0x820719C8;
		  /* 820719C8h */ case   71:  		/* stwu R17, <#[R3 + 4]> */
		/* 820719C8h case   71:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719C8h case   71:*/		return 0x820719CC;
		  /* 820719CCh */ case   72:  		/* stwu R8, <#[R3 + 4]> */
		/* 820719CCh case   72:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719CCh case   72:*/		return 0x820719D0;
	}
	return 0x820719D0;
} // Block from 820718ACh-820719D0h (73 instructions)

//////////////////////////////////////////////////////
// Block at 820719D0h
// Function 'D3DDevice_Present'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820719D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820719D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820719D0);
		  /* 820719D0h */ case    0:  		/* stwu R27, <#[R3 + 4]> */
		/* 820719D0h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719D0h case    0:*/		return 0x820719D4;
		  /* 820719D4h */ case    1:  		/* stwu R16, <#[R3 + 4]> */
		/* 820719D4h case    1:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719D4h case    1:*/		return 0x820719D8;
		  /* 820719D8h */ case    2:  		/* stwu R15, <#[R3 + 4]> */
		/* 820719D8h case    2:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719D8h case    2:*/		return 0x820719DC;
		  /* 820719DCh */ case    3:  		/* stwu R26, <#[R3 + 4]> */
		/* 820719DCh case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719DCh case    3:*/		return 0x820719E0;
		  /* 820719E0h */ case    4:  		/* stwu R14, <#[R3 + 4]> */
		/* 820719E0h case    4:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719E0h case    4:*/		return 0x820719E4;
		  /* 820719E4h */ case    5:  		/* stwu R25, <#[R3 + 4]> */
		/* 820719E4h case    5:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820719E4h case    5:*/		return 0x820719E8;
		  /* 820719E8h */ case    6:  		/* mr R11, R3 */
		/* 820719E8h case    6:*/		regs.R11 = regs.R3;
		/* 820719E8h case    6:*/		return 0x820719EC;
		  /* 820719ECh */ case    7:  		/* stwu R24, <#[R11 + 4]> */
		/* 820719ECh case    7:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820719ECh case    7:*/		return 0x820719F0;
		  /* 820719F0h */ case    8:  		/* lwz R10, <#[R31 + 56]> */
		/* 820719F0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 820719F0h case    8:*/		return 0x820719F4;
		  /* 820719F4h */ case    9:  		/* mr R3, R11 */
		/* 820719F4h case    9:*/		regs.R3 = regs.R11;
		/* 820719F4h case    9:*/		return 0x820719F8;
		  /* 820719F8h */ case   10:  		/* stw R11, <#[R31 + 48]> */
		/* 820719F8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820719F8h case   10:*/		return 0x820719FC;
		  /* 820719FCh */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820719FCh case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820719FCh case   11:*/		return 0x82071A00;
		  /* 82071A00h */ case   12:  		/* bc 4, CR6_GT, 12 */
		/* 82071A00h case   12:*/		if ( !regs.CR[6].gt ) { return 0x82071A0C;  }
		/* 82071A00h case   12:*/		return 0x82071A04;
		  /* 82071A04h */ case   13:  		/* mr R3, R31 */
		/* 82071A04h case   13:*/		regs.R3 = regs.R31;
		/* 82071A04h case   13:*/		return 0x82071A08;
		  /* 82071A08h */ case   14:  		/* bl 9984 */
		/* 82071A08h case   14:*/		regs.LR = 0x82071A0C; return 0x82074108;
		/* 82071A08h case   14:*/		return 0x82071A0C;
	}
	return 0x82071A0C;
} // Block from 820719D0h-82071A0Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82071A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071A0C);
		  /* 82071A0Ch */ case    0:  		/* lis R11, -16384 */
		/* 82071A0Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 82071A0Ch case    0:*/		return 0x82071A10;
		  /* 82071A10h */ case    1:  		/* lis R10, 512 */
		/* 82071A10h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 82071A10h case    1:*/		return 0x82071A14;
		  /* 82071A14h */ case    2:  		/* ori R11, R11, 13824 */
		/* 82071A14h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3600);
		/* 82071A14h case    2:*/		return 0x82071A18;
		  /* 82071A18h */ case    3:  		/* ori R10, R10, 129 */
		/* 82071A18h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x81);
		/* 82071A18h case    3:*/		return 0x82071A1C;
		  /* 82071A1Ch */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 82071A1Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071A1Ch case    4:*/		return 0x82071A20;
		  /* 82071A20h */ case    5:  		/* li R12, 1 */
		/* 82071A20h case    5:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82071A20h case    5:*/		return 0x82071A24;
		  /* 82071A24h */ case    6:  		/* li R11, 1 */
		/* 82071A24h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82071A24h case    6:*/		return 0x82071A28;
		  /* 82071A28h */ case    7:  		/* mr R9, R3 */
		/* 82071A28h case    7:*/		regs.R9 = regs.R3;
		/* 82071A28h case    7:*/		return 0x82071A2C;
		  /* 82071A2Ch */ case    8:  		/* rldicr R12, R12, 41, 63 */
		/* 82071A2Ch case    8:*/		cpu::op::rldicr<0,41,63>(regs,&regs.R12,regs.R12);
		/* 82071A2Ch case    8:*/		return 0x82071A30;
		  /* 82071A30h */ case    9:  		/* rldicr R11, R11, 35, 63 */
		/* 82071A30h case    9:*/		cpu::op::rldicr<0,35,63>(regs,&regs.R11,regs.R11);
		/* 82071A30h case    9:*/		return 0x82071A34;
		  /* 82071A34h */ case   10:  		/* mr R3, R31 */
		/* 82071A34h case   10:*/		regs.R3 = regs.R31;
		/* 82071A34h case   10:*/		return 0x82071A38;
		  /* 82071A38h */ case   11:  		/* stwu R10, <#[R9 + 4]> */
		/* 82071A38h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 82071A38h case   11:*/		return 0x82071A3C;
		  /* 82071A3Ch */ case   12:  		/* stw R9, <#[R31 + 48]> */
		/* 82071A3Ch case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000030) );
		/* 82071A3Ch case   12:*/		return 0x82071A40;
		  /* 82071A40h */ case   13:  		/* ld R10, <#[R31 + 16]> */
		/* 82071A40h case   13:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071A40h case   13:*/		return 0x82071A44;
		  /* 82071A44h */ case   14:  		/* or R10, R10, R12 */
		/* 82071A44h case   14:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82071A44h case   14:*/		return 0x82071A48;
		  /* 82071A48h */ case   15:  		/* li R12, 1 */
		/* 82071A48h case   15:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82071A48h case   15:*/		return 0x82071A4C;
		  /* 82071A4Ch */ case   16:  		/* std R10, <#[R31 + 16]> */
		/* 82071A4Ch case   16:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071A4Ch case   16:*/		return 0x82071A50;
		  /* 82071A50h */ case   17:  		/* rldicr R12, R12, 40, 63 */
		/* 82071A50h case   17:*/		cpu::op::rldicr<0,40,63>(regs,&regs.R12,regs.R12);
		/* 82071A50h case   17:*/		return 0x82071A54;
		  /* 82071A54h */ case   18:  		/* or R10, R10, R12 */
		/* 82071A54h case   18:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82071A54h case   18:*/		return 0x82071A58;
		  /* 82071A58h */ case   19:  		/* li R12, 1 */
		/* 82071A58h case   19:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82071A58h case   19:*/		return 0x82071A5C;
		  /* 82071A5Ch */ case   20:  		/* std R10, <#[R31 + 16]> */
		/* 82071A5Ch case   20:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071A5Ch case   20:*/		return 0x82071A60;
		  /* 82071A60h */ case   21:  		/* rldicr R12, R12, 39, 63 */
		/* 82071A60h case   21:*/		cpu::op::rldicr<0,39,63>(regs,&regs.R12,regs.R12);
		/* 82071A60h case   21:*/		return 0x82071A64;
		  /* 82071A64h */ case   22:  		/* or R10, R10, R12 */
		/* 82071A64h case   22:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82071A64h case   22:*/		return 0x82071A68;
		  /* 82071A68h */ case   23:  		/* li R12, 1 */
		/* 82071A68h case   23:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82071A68h case   23:*/		return 0x82071A6C;
		  /* 82071A6Ch */ case   24:  		/* std R10, <#[R31 + 16]> */
		/* 82071A6Ch case   24:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071A6Ch case   24:*/		return 0x82071A70;
		  /* 82071A70h */ case   25:  		/* ld R10, <#[R31 + 24]> */
		/* 82071A70h case   25:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82071A70h case   25:*/		return 0x82071A74;
		  /* 82071A74h */ case   26:  		/* or R10, R10, R11 */
		/* 82071A74h case   26:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82071A74h case   26:*/		return 0x82071A78;
		  /* 82071A78h */ case   27:  		/* std R10, <#[R31 + 24]> */
		/* 82071A78h case   27:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82071A78h case   27:*/		return 0x82071A7C;
		  /* 82071A7Ch */ case   28:  		/* rldicr R12, R12, 44, 63 */
		/* 82071A7Ch case   28:*/		cpu::op::rldicr<0,44,63>(regs,&regs.R12,regs.R12);
		/* 82071A7Ch case   28:*/		return 0x82071A80;
		  /* 82071A80h */ case   29:  		/* ld R10, <#[R31 + 16]> */
		/* 82071A80h case   29:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071A80h case   29:*/		return 0x82071A84;
		  /* 82071A84h */ case   30:  		/* ori R10, R10, 128 */
		/* 82071A84h case   30:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x80);
		/* 82071A84h case   30:*/		return 0x82071A88;
		  /* 82071A88h */ case   31:  		/* std R10, <#[R31 + 16]> */
		/* 82071A88h case   31:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071A88h case   31:*/		return 0x82071A8C;
		  /* 82071A8Ch */ case   32:  		/* ori R10, R10, 64 */
		/* 82071A8Ch case   32:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x40);
		/* 82071A8Ch case   32:*/		return 0x82071A90;
		  /* 82071A90h */ case   33:  		/* std R10, <#[R31 + 16]> */
		/* 82071A90h case   33:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071A90h case   33:*/		return 0x82071A94;
		  /* 82071A94h */ case   34:  		/* ori R10, R10, 32 */
		/* 82071A94h case   34:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x20);
		/* 82071A94h case   34:*/		return 0x82071A98;
		  /* 82071A98h */ case   35:  		/* std R10, <#[R31 + 16]> */
		/* 82071A98h case   35:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071A98h case   35:*/		return 0x82071A9C;
		  /* 82071A9Ch */ case   36:  		/* ld R10, <#[R31 + 32]> */
		/* 82071A9Ch case   36:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 82071A9Ch case   36:*/		return 0x82071AA0;
		  /* 82071AA0h */ case   37:  		/* oris R10, R10, 8 */
		/* 82071AA0h case   37:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82071AA0h case   37:*/		return 0x82071AA4;
		  /* 82071AA4h */ case   38:  		/* std R10, <#[R31 + 32]> */
		/* 82071AA4h case   38:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 82071AA4h case   38:*/		return 0x82071AA8;
		  /* 82071AA8h */ case   39:  		/* ld R10, <#[R31 + 16]> */
		/* 82071AA8h case   39:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071AA8h case   39:*/		return 0x82071AAC;
		  /* 82071AACh */ case   40:  		/* or R10, R10, R12 */
		/* 82071AACh case   40:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82071AACh case   40:*/		return 0x82071AB0;
		  /* 82071AB0h */ case   41:  		/* std R10, <#[R31 + 16]> */
		/* 82071AB0h case   41:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071AB0h case   41:*/		return 0x82071AB4;
		  /* 82071AB4h */ case   42:  		/* oris R10, R10, 8 */
		/* 82071AB4h case   42:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82071AB4h case   42:*/		return 0x82071AB8;
		  /* 82071AB8h */ case   43:  		/* li R12, 1 */
		/* 82071AB8h case   43:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82071AB8h case   43:*/		return 0x82071ABC;
		  /* 82071ABCh */ case   44:  		/* std R10, <#[R31 + 16]> */
		/* 82071ABCh case   44:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071ABCh case   44:*/		return 0x82071AC0;
		  /* 82071AC0h */ case   45:  		/* oris R10, R10, 16 */
		/* 82071AC0h case   45:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x10);
		/* 82071AC0h case   45:*/		return 0x82071AC4;
		  /* 82071AC4h */ case   46:  		/* rldicr R12, R12, 37, 63 */
		/* 82071AC4h case   46:*/		cpu::op::rldicr<0,37,63>(regs,&regs.R12,regs.R12);
		/* 82071AC4h case   46:*/		return 0x82071AC8;
		  /* 82071AC8h */ case   47:  		/* std R10, <#[R31 + 16]> */
		/* 82071AC8h case   47:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071AC8h case   47:*/		return 0x82071ACC;
		  /* 82071ACCh */ case   48:  		/* ori R10, R10, 2048 */
		/* 82071ACCh case   48:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x800);
		/* 82071ACCh case   48:*/		return 0x82071AD0;
		  /* 82071AD0h */ case   49:  		/* std R10, <#[R31 + 16]> */
		/* 82071AD0h case   49:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071AD0h case   49:*/		return 0x82071AD4;
		  /* 82071AD4h */ case   50:  		/* ori R10, R10, 256 */
		/* 82071AD4h case   50:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x100);
		/* 82071AD4h case   50:*/		return 0x82071AD8;
		  /* 82071AD8h */ case   51:  		/* std R10, <#[R31 + 16]> */
		/* 82071AD8h case   51:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071AD8h case   51:*/		return 0x82071ADC;
		  /* 82071ADCh */ case   52:  		/* ori R10, R10, 8 */
		/* 82071ADCh case   52:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82071ADCh case   52:*/		return 0x82071AE0;
	}
	return 0x82071AE0;
} // Block from 82071A0Ch-82071AE0h (53 instructions)

//////////////////////////////////////////////////////
// Block at 82071AE0h
// Function 'D3DDevice_SetScreenExtentQueryMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071AE0);
		  /* 82071AE0h */ case    0:  		/* std R10, <#[R31 + 16]> */
		/* 82071AE0h case    0:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071AE0h case    0:*/		return 0x82071AE4;
		  /* 82071AE4h */ case    1:  		/* or R10, R10, R12 */
		/* 82071AE4h case    1:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82071AE4h case    1:*/		return 0x82071AE8;
		  /* 82071AE8h */ case    2:  		/* li R12, 1 */
		/* 82071AE8h case    2:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82071AE8h case    2:*/		return 0x82071AEC;
		  /* 82071AECh */ case    3:  		/* std R10, <#[R31 + 16]> */
		/* 82071AECh case    3:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82071AECh case    3:*/		return 0x82071AF0;
		  /* 82071AF0h */ case    4:  		/* rldicr R12, R12, 54, 63 */
		/* 82071AF0h case    4:*/		cpu::op::rldicr<0,54,63>(regs,&regs.R12,regs.R12);
		/* 82071AF0h case    4:*/		return 0x82071AF4;
		  /* 82071AF4h */ case    5:  		/* ld R10, <#[R31 + 24]> */
		/* 82071AF4h case    5:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82071AF4h case    5:*/		return 0x82071AF8;
		  /* 82071AF8h */ case    6:  		/* or R10, R10, R12 */
		/* 82071AF8h case    6:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82071AF8h case    6:*/		return 0x82071AFC;
		  /* 82071AFCh */ case    7:  		/* std R10, <#[R31 + 24]> */
		/* 82071AFCh case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82071AFCh case    7:*/		return 0x82071B00;
		  /* 82071B00h */ case    8:  		/* ld R10, <#[R31 + 32]> */
		/* 82071B00h case    8:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 82071B00h case    8:*/		return 0x82071B04;
		  /* 82071B04h */ case    9:  		/* or R11, R10, R11 */
		/* 82071B04h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82071B04h case    9:*/		return 0x82071B08;
		  /* 82071B08h */ case   10:  		/* std R11, <#[R31 + 32]> */
		/* 82071B08h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82071B08h case   10:*/		return 0x82071B0C;
		  /* 82071B0Ch */ case   11:  		/* lwz R11, <#[R31 + 10436]> */
		/* 82071B0Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000028C4) );
		/* 82071B0Ch case   11:*/		return 0x82071B10;
		  /* 82071B10h */ case   12:  		/* lwz R10, <#[R31 + 10440]> */
		/* 82071B10h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000028C8) );
		/* 82071B10h case   12:*/		return 0x82071B14;
		  /* 82071B14h */ case   13:  		/* rlwinm R9, R10, 1, 0, 30 */
		/* 82071B14h case   13:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R10);
		/* 82071B14h case   13:*/		return 0x82071B18;
		  /* 82071B18h */ case   14:  		/* rlwinm R10, R10, 17, 0, 14 */
		/* 82071B18h case   14:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R10,regs.R10);
		/* 82071B18h case   14:*/		return 0x82071B1C;
		  /* 82071B1Ch */ case   15:  		/* rlwinm R8, R11, 1, 0, 30 */
		/* 82071B1Ch case   15:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R11);
		/* 82071B1Ch case   15:*/		return 0x82071B20;
		  /* 82071B20h */ case   16:  		/* srawi R7, R9, 17 */
		/* 82071B20h case   16:*/		cpu::op::srawi<0,17>(regs,&regs.R7,regs.R9);
		/* 82071B20h case   16:*/		return 0x82071B24;
		  /* 82071B24h */ case   17:  		/* rlwinm R11, R11, 17, 0, 14 */
		/* 82071B24h case   17:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R11,regs.R11);
		/* 82071B24h case   17:*/		return 0x82071B28;
		  /* 82071B28h */ case   18:  		/* srawi R6, R10, 17 */
		/* 82071B28h case   18:*/		cpu::op::srawi<0,17>(regs,&regs.R6,regs.R10);
		/* 82071B28h case   18:*/		return 0x82071B2C;
		  /* 82071B2Ch */ case   19:  		/* srawi R5, R8, 17 */
		/* 82071B2Ch case   19:*/		cpu::op::srawi<0,17>(regs,&regs.R5,regs.R8);
		/* 82071B2Ch case   19:*/		return 0x82071B30;
		  /* 82071B30h */ case   20:  		/* srawi R4, R11, 17 */
		/* 82071B30h case   20:*/		cpu::op::srawi<0,17>(regs,&regs.R4,regs.R11);
		/* 82071B30h case   20:*/		return 0x82071B34;
		  /* 82071B34h */ case   21:  		/* bl -64396 */
		/* 82071B34h case   21:*/		regs.LR = 0x82071B38; return 0x82061FA8;
		/* 82071B34h case   21:*/		return 0x82071B38;
	}
	return 0x82071B38;
} // Block from 82071AE0h-82071B38h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82071B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071B38);
		  /* 82071B38h */ case    0:  		/* addi R1, R1, 240 */
		/* 82071B38h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 82071B38h case    0:*/		return 0x82071B3C;
		  /* 82071B3Ch */ case    1:  		/* b 128820 */
		/* 82071B3Ch case    1:*/		return 0x82091270;
		/* 82071B3Ch case    1:*/		return 0x82071B40;
	}
	return 0x82071B40;
} // Block from 82071B38h-82071B40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82071B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071B40);
		  /* 82071B40h */ case    0:  		/* mfspr R12, LR */
		/* 82071B40h case    0:*/		regs.R12 = regs.LR;
		/* 82071B40h case    0:*/		return 0x82071B44;
		  /* 82071B44h */ case    1:  		/* bl 128784 */
		/* 82071B44h case    1:*/		regs.LR = 0x82071B48; return 0x82091254;
		/* 82071B44h case    1:*/		return 0x82071B48;
		  /* 82071B48h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82071B48h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82071B48h case    2:*/		return 0x82071B4C;
		  /* 82071B4Ch */ case    3:  		/* lwz R8, <#[R3 + 48]> */
		/* 82071B4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000030) );
		/* 82071B4Ch case    3:*/		return 0x82071B50;
	}
	return 0x82071B50;
} // Block from 82071B40h-82071B50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82071B50h
// Function '?P_SPCE@D3D@@YAXPAUD3DDevice@@PBU_D3DPERFCOUNTER_EVENTS@@K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071B50);
		  /* 82071B50h */ case    0:  		/* mr R31, R3 */
		/* 82071B50h case    0:*/		regs.R31 = regs.R3;
		/* 82071B50h case    0:*/		return 0x82071B54;
		  /* 82071B54h */ case    1:  		/* lwz R11, <#[R3 + 56]> */
		/* 82071B54h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 82071B54h case    1:*/		return 0x82071B58;
		  /* 82071B58h */ case    2:  		/* mr R30, R4 */
		/* 82071B58h case    2:*/		regs.R30 = regs.R4;
		/* 82071B58h case    2:*/		return 0x82071B5C;
		  /* 82071B5Ch */ case    3:  		/* mr R29, R5 */
		/* 82071B5Ch case    3:*/		regs.R29 = regs.R5;
		/* 82071B5Ch case    3:*/		return 0x82071B60;
		  /* 82071B60h */ case    4:  		/* mr R28, R6 */
		/* 82071B60h case    4:*/		regs.R28 = regs.R6;
		/* 82071B60h case    4:*/		return 0x82071B64;
		  /* 82071B64h */ case    5:  		/* rlwinm R27, R6, 0, 30, 31 */
		/* 82071B64h case    5:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R27,regs.R6);
		/* 82071B64h case    5:*/		return 0x82071B68;
		  /* 82071B68h */ case    6:  		/* cmplw CR6, R8, R11 */
		/* 82071B68h case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82071B68h case    6:*/		return 0x82071B6C;
		  /* 82071B6Ch */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 82071B6Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x82071B78;  }
		/* 82071B6Ch case    7:*/		return 0x82071B70;
		  /* 82071B70h */ case    8:  		/* bl 9624 */
		/* 82071B70h case    8:*/		regs.LR = 0x82071B74; return 0x82074108;
		/* 82071B70h case    8:*/		return 0x82071B74;
		  /* 82071B74h */ case    9:  		/* mr R8, R3 */
		/* 82071B74h case    9:*/		regs.R8 = regs.R3;
		/* 82071B74h case    9:*/		return 0x82071B78;
	}
	return 0x82071B78;
} // Block from 82071B50h-82071B78h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82071B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071B78);
		  /* 82071B78h */ case    0:  		/* mr R3, R29 */
		/* 82071B78h case    0:*/		regs.R3 = regs.R29;
		/* 82071B78h case    0:*/		return 0x82071B7C;
		  /* 82071B7Ch */ case    1:  		/* bl -1724 */
		/* 82071B7Ch case    1:*/		regs.LR = 0x82071B80; return 0x820714C0;
		/* 82071B7Ch case    1:*/		return 0x82071B80;
		  /* 82071B80h */ case    2:  		/* addi R11, R30, 2598 */
		/* 82071B80h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xA26);
		/* 82071B80h case    2:*/		return 0x82071B84;
		  /* 82071B84h */ case    3:  		/* addi R10, R30, 12 */
		/* 82071B84h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xC);
		/* 82071B84h case    3:*/		return 0x82071B88;
		  /* 82071B88h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82071B88h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82071B88h case    4:*/		return 0x82071B8C;
		  /* 82071B8Ch */ case    5:  		/* li R9, 1 */
		/* 82071B8Ch case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82071B8Ch case    5:*/		return 0x82071B90;
		  /* 82071B90h */ case    6:  		/* rldicl R10, R10, 0, 32 */
		/* 82071B90h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 82071B90h case    6:*/		return 0x82071B94;
		  /* 82071B94h */ case    7:  		/* rldicr R9, R9, 63, 63 */
		/* 82071B94h case    7:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 82071B94h case    7:*/		return 0x82071B98;
		  /* 82071B98h */ case    8:  		/* li R7, 1480 */
		/* 82071B98h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x5C8);
		/* 82071B98h case    8:*/		return 0x82071B9C;
		  /* 82071B9Ch */ case    9:  		/* stwx R3, <#[R11 + R31]> */
		/* 82071B9Ch case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82071B9Ch case    9:*/		return 0x82071BA0;
		  /* 82071BA0h */ case   10:  		/* srd R11, R9, R10 */
		/* 82071BA0h case   10:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R9,regs.R10);
		/* 82071BA0h case   10:*/		return 0x82071BA4;
		  /* 82071BA4h */ case   11:  		/* lis R10, 2 */
		/* 82071BA4h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x2);
		/* 82071BA4h case   11:*/		return 0x82071BA8;
		  /* 82071BA8h */ case   12:  		/* ld R9, <#[R31 + 16]> */
		/* 82071BA8h case   12:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R31 + 0x00000010) );
		/* 82071BA8h case   12:*/		return 0x82071BAC;
		  /* 82071BACh */ case   13:  		/* or R11, R11, R9 */
		/* 82071BACh case   13:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82071BACh case   13:*/		return 0x82071BB0;
		  /* 82071BB0h */ case   14:  		/* std R11, <#[R31 + 16]> */
		/* 82071BB0h case   14:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82071BB0h case   14:*/		return 0x82071BB4;
		  /* 82071BB4h */ case   15:  		/* stwu R7, <#[R8 + 4]> */
		/* 82071BB4h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 82071BB4h case   15:*/		return 0x82071BB8;
		  /* 82071BB8h */ case   16:  		/* stwu R10, <#[R8 + 4]> */
		/* 82071BB8h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 82071BB8h case   16:*/		return 0x82071BBC;
		  /* 82071BBCh */ case   17:  		/* lwz R11, <#[R31 + 13904]> */
		/* 82071BBCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003650) );
		/* 82071BBCh case   17:*/		return 0x82071BC0;
		  /* 82071BC0h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 82071BC0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82071BC0h case   18:*/		return 0x82071BC4;
		  /* 82071BC4h */ case   19:  		/* mr R11, R8 */
		/* 82071BC4h case   19:*/		regs.R11 = regs.R8;
		/* 82071BC4h case   19:*/		return 0x82071BC8;
		  /* 82071BC8h */ case   20:  		/* bc 4, CR6_EQ, 72 */
		/* 82071BC8h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82071C10;  }
		/* 82071BC8h case   20:*/		return 0x82071BCC;
		  /* 82071BCCh */ case   21:  		/* cmplwi CR6, R28, 10 */
		/* 82071BCCh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x0000000A);
		/* 82071BCCh case   21:*/		return 0x82071BD0;
		  /* 82071BD0h */ case   22:  		/* mr R3, R31 */
		/* 82071BD0h case   22:*/		regs.R3 = regs.R31;
		/* 82071BD0h case   22:*/		return 0x82071BD4;
		  /* 82071BD4h */ case   23:  		/* bc 4, CR6_EQ, 24 */
		/* 82071BD4h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82071BEC;  }
		/* 82071BD4h case   23:*/		return 0x82071BD8;
		  /* 82071BD8h */ case   24:  		/* lis R10, -16384 */
		/* 82071BD8h case   24:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC000);
		/* 82071BD8h case   24:*/		return 0x82071BDC;
		  /* 82071BDCh */ case   25:  		/* li R9, 15 */
		/* 82071BDCh case   25:*/		cpu::op::li<0>(regs,&regs.R9,0xF);
		/* 82071BDCh case   25:*/		return 0x82071BE0;
		  /* 82071BE0h */ case   26:  		/* ori R10, R10, 17920 */
		/* 82071BE0h case   26:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4600);
		/* 82071BE0h case   26:*/		return 0x82071BE4;
		  /* 82071BE4h */ case   27:  		/* stwu R10, <#[R11 + 4]> */
		/* 82071BE4h case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82071BE4h case   27:*/		return 0x82071BE8;
		  /* 82071BE8h */ case   28:  		/* stwu R9, <#[R11 + 4]> */
		/* 82071BE8h case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82071BE8h case   28:*/		return 0x82071BEC;
	}
	return 0x82071BEC;
} // Block from 82071B78h-82071BECh (29 instructions)

//////////////////////////////////////////////////////
// Block at 82071BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071BEC);
		  /* 82071BECh */ case    0:  		/* stw R11, <#[R31 + 48]> */
		/* 82071BECh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82071BECh case    0:*/		return 0x82071BF0;
		  /* 82071BF0h */ case    1:  		/* bl -1424 */
		/* 82071BF0h case    1:*/		regs.LR = 0x82071BF4; return 0x82071660;
		/* 82071BF0h case    1:*/		return 0x82071BF4;
		  /* 82071BF4h */ case    2:  		/* lwz R10, <#[R31 + 56]> */
		/* 82071BF4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 82071BF4h case    2:*/		return 0x82071BF8;
		  /* 82071BF8h */ case    3:  		/* lwz R11, <#[R31 + 48]> */
		/* 82071BF8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82071BF8h case    3:*/		return 0x82071BFC;
		  /* 82071BFCh */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 82071BFCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82071BFCh case    4:*/		return 0x82071C00;
		  /* 82071C00h */ case    5:  		/* bc 4, CR6_GT, 16 */
		/* 82071C00h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82071C10;  }
		/* 82071C00h case    5:*/		return 0x82071C04;
		  /* 82071C04h */ case    6:  		/* mr R3, R31 */
		/* 82071C04h case    6:*/		regs.R3 = regs.R31;
		/* 82071C04h case    6:*/		return 0x82071C08;
		  /* 82071C08h */ case    7:  		/* bl 9472 */
		/* 82071C08h case    7:*/		regs.LR = 0x82071C0C; return 0x82074108;
		/* 82071C08h case    7:*/		return 0x82071C0C;
		  /* 82071C0Ch */ case    8:  		/* mr R11, R3 */
		/* 82071C0Ch case    8:*/		regs.R11 = regs.R3;
		/* 82071C0Ch case    8:*/		return 0x82071C10;
	}
	return 0x82071C10;
} // Block from 82071BECh-82071C10h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82071C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071C10);
		  /* 82071C10h */ case    0:  		/* lwz R10, <#[R31 + 13904]> */
		/* 82071C10h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003650) );
		/* 82071C10h case    0:*/		return 0x82071C14;
		  /* 82071C14h */ case    1:  		/* li R9, 0 */
		/* 82071C14h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82071C14h case    1:*/		return 0x82071C18;
		  /* 82071C18h */ case    2:  		/* stw R11, <#[R31 + 48]> */
		/* 82071C18h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82071C18h case    2:*/		return 0x82071C1C;
		  /* 82071C1Ch */ case    3:  		/* addi R11, R10, 1 */
		/* 82071C1Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 82071C1Ch case    3:*/		return 0x82071C20;
		  /* 82071C20h */ case    4:  		/* stw R27, <#[R31 + 13912]> */
		/* 82071C20h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00003658) );
		/* 82071C20h case    4:*/		return 0x82071C24;
		  /* 82071C24h */ case    5:  		/* stw R9, <#[R31 + 13908]> */
		/* 82071C24h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00003654) );
		/* 82071C24h case    5:*/		return 0x82071C28;
		  /* 82071C28h */ case    6:  		/* stw R11, <#[R31 + 13904]> */
		/* 82071C28h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00003650) );
		/* 82071C28h case    6:*/		return 0x82071C2C;
		  /* 82071C2Ch */ case    7:  		/* addi R1, R1, 128 */
		/* 82071C2Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82071C2Ch case    7:*/		return 0x82071C30;
		  /* 82071C30h */ case    8:  		/* b 128628 */
		/* 82071C30h case    8:*/		return 0x820912A4;
		/* 82071C30h case    8:*/		return 0x82071C34;
		  /* 82071C34h */ case    9:  		/* nop */
		/* 82071C34h case    9:*/		cpu::op::nop();
		/* 82071C34h case    9:*/		return 0x82071C38;
	}
	return 0x82071C38;
} // Block from 82071C10h-82071C38h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82071C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071C38);
		  /* 82071C38h */ case    0:  		/* mfspr R12, LR */
		/* 82071C38h case    0:*/		regs.R12 = regs.LR;
		/* 82071C38h case    0:*/		return 0x82071C3C;
		  /* 82071C3Ch */ case    1:  		/* bl 128536 */
		/* 82071C3Ch case    1:*/		regs.LR = 0x82071C40; return 0x82091254;
		/* 82071C3Ch case    1:*/		return 0x82071C40;
		  /* 82071C40h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 82071C40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 82071C40h case    2:*/		return 0x82071C44;
		  /* 82071C44h */ case    3:  		/* addi R11, R4, 2598 */
		/* 82071C44h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xA26);
		/* 82071C44h case    3:*/		return 0x82071C48;
		  /* 82071C48h */ case    4:  		/* mr R31, R3 */
		/* 82071C48h case    4:*/		regs.R31 = regs.R3;
		/* 82071C48h case    4:*/		return 0x82071C4C;
		  /* 82071C4Ch */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82071C4Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82071C4Ch case    5:*/		return 0x82071C50;
		  /* 82071C50h */ case    6:  		/* li R10, 0 */
		/* 82071C50h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82071C50h case    6:*/		return 0x82071C54;
		  /* 82071C54h */ case    7:  		/* mr R29, R4 */
		/* 82071C54h case    7:*/		regs.R29 = regs.R4;
		/* 82071C54h case    7:*/		return 0x82071C58;
		  /* 82071C58h */ case    8:  		/* mr R30, R5 */
		/* 82071C58h case    8:*/		regs.R30 = regs.R5;
		/* 82071C58h case    8:*/		return 0x82071C5C;
		  /* 82071C5Ch */ case    9:  		/* mr R28, R6 */
		/* 82071C5Ch case    9:*/		regs.R28 = regs.R6;
		/* 82071C5Ch case    9:*/		return 0x82071C60;
		  /* 82071C60h */ case   10:  		/* stwx R10, <#[R11 + R3]> */
		/* 82071C60h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82071C60h case   10:*/		return 0x82071C64;
		  /* 82071C64h */ case   11:  		/* lwz R3, <#[R3 + 48]> */
		/* 82071C64h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 82071C64h case   11:*/		return 0x82071C68;
		  /* 82071C68h */ case   12:  		/* lwz R11, <#[R31 + 56]> */
		/* 82071C68h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82071C68h case   12:*/		return 0x82071C6C;
		  /* 82071C6Ch */ case   13:  		/* cmplw CR6, R3, R11 */
		/* 82071C6Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82071C6Ch case   13:*/		return 0x82071C70;
		  /* 82071C70h */ case   14:  		/* bc 4, CR6_GT, 12 */
		/* 82071C70h case   14:*/		if ( !regs.CR[6].gt ) { return 0x82071C7C;  }
		/* 82071C70h case   14:*/		return 0x82071C74;
		  /* 82071C74h */ case   15:  		/* mr R3, R31 */
		/* 82071C74h case   15:*/		regs.R3 = regs.R31;
		/* 82071C74h case   15:*/		return 0x82071C78;
		  /* 82071C78h */ case   16:  		/* bl 9360 */
		/* 82071C78h case   16:*/		regs.LR = 0x82071C7C; return 0x82074108;
		/* 82071C78h case   16:*/		return 0x82071C7C;
	}
	return 0x82071C7C;
} // Block from 82071C38h-82071C7Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 82071C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071C7C);
		  /* 82071C7Ch */ case    0:  		/* addi R11, R29, 8198 */
		/* 82071C7Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x2006);
		/* 82071C7Ch case    0:*/		return 0x82071C80;
		  /* 82071C80h */ case    1:  		/* li R10, 0 */
		/* 82071C80h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82071C80h case    1:*/		return 0x82071C84;
		  /* 82071C84h */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 82071C84h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071C84h case    2:*/		return 0x82071C88;
		  /* 82071C88h */ case    3:  		/* stwu R10, <#[R3 + 4]> */
		/* 82071C88h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071C88h case    3:*/		return 0x82071C8C;
		  /* 82071C8Ch */ case    4:  		/* lwz R11, <#[R31 + 11036]> */
		/* 82071C8Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B1C) );
		/* 82071C8Ch case    4:*/		return 0x82071C90;
		  /* 82071C90h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82071C90h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82071C90h case    5:*/		return 0x82071C94;
		  /* 82071C94h */ case    6:  		/* stw R3, <#[R31 + 48]> */
		/* 82071C94h case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82071C94h case    6:*/		return 0x82071C98;
		  /* 82071C98h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 82071C98h case    7:*/		if ( regs.CR[6].eq ) { return 0x82071CA8;  }
		/* 82071C98h case    7:*/		return 0x82071C9C;
		  /* 82071C9Ch */ case    8:  		/* stw R11, <#[R30 + 8]> */
		/* 82071C9Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82071C9Ch case    8:*/		return 0x82071CA0;
		  /* 82071CA0h */ case    9:  		/* stw R11, <#[R30 + 12]> */
		/* 82071CA0h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82071CA0h case    9:*/		return 0x82071CA4;
		  /* 82071CA4h */ case   10:  		/* b 84 */
		/* 82071CA4h case   10:*/		return 0x82071CF8;
		/* 82071CA4h case   10:*/		return 0x82071CA8;
	}
	return 0x82071CA8;
} // Block from 82071C7Ch-82071CA8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82071CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071CA8);
		  /* 82071CA8h */ case    0:  		/* lwz R11, <#[R31 + 11040]> */
		/* 82071CA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B20) );
		/* 82071CA8h case    0:*/		return 0x82071CAC;
		  /* 82071CACh */ case    1:  		/* lwz R10, <#[R30]> */
		/* 82071CACh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82071CACh case    1:*/		return 0x82071CB0;
		  /* 82071CB0h */ case    2:  		/* and. R11, R11, R10 */
		/* 82071CB0h case    2:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82071CB0h case    2:*/		return 0x82071CB4;
		  /* 82071CB4h */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 82071CB4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82071CF8;  }
		/* 82071CB4h case    3:*/		return 0x82071CB8;
		  /* 82071CB8h */ case    4:  		/* lwz R11, <#[R31 + 13932]> */
		/* 82071CB8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000366C) );
		/* 82071CB8h case    4:*/		return 0x82071CBC;
		  /* 82071CBCh */ case    5:  		/* lwz R3, <#[R31 + 13928]> */
		/* 82071CBCh case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00003668) );
		/* 82071CBCh case    5:*/		return 0x82071CC0;
		  /* 82071CC0h */ case    6:  		/* cmplw CR6, R3, R11 */
		/* 82071CC0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82071CC0h case    6:*/		return 0x82071CC4;
		  /* 82071CC4h */ case    7:  		/* bc 12, CR6_LT, 12 */
		/* 82071CC4h case    7:*/		if ( regs.CR[6].lt ) { return 0x82071CD0;  }
		/* 82071CC4h case    7:*/		return 0x82071CC8;
		  /* 82071CC8h */ case    8:  		/* mr R3, R31 */
		/* 82071CC8h case    8:*/		regs.R3 = regs.R31;
		/* 82071CC8h case    8:*/		return 0x82071CCC;
		  /* 82071CCCh */ case    9:  		/* bl 11428 */
		/* 82071CCCh case    9:*/		regs.LR = 0x82071CD0; return 0x82074970;
		/* 82071CCCh case    9:*/		return 0x82071CD0;
	}
	return 0x82071CD0;
} // Block from 82071CA8h-82071CD0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82071CD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071CD0);
		  /* 82071CD0h */ case    0:  		/* li R10, -1 */
		/* 82071CD0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82071CD0h case    0:*/		return 0x82071CD4;
		  /* 82071CD4h */ case    1:  		/* lwz R11, <#[R1 + 144]> */
		/* 82071CD4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82071CD4h case    1:*/		return 0x82071CD8;
		  /* 82071CD8h */ case    2:  		/* addi R9, R3, 8 */
		/* 82071CD8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 82071CD8h case    2:*/		return 0x82071CDC;
		  /* 82071CDCh */ case    3:  		/* stw R10, <#[R1 + 148]> */
		/* 82071CDCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000094) );
		/* 82071CDCh case    3:*/		return 0x82071CE0;
		  /* 82071CE0h */ case    4:  		/* rlwimi R11, R30, 30, 2, 31 */
		/* 82071CE0h case    4:*/		cpu::op::rlwimi<0,30,2,31>(regs,&regs.R11,regs.R30);
		/* 82071CE0h case    4:*/		return 0x82071CE4;
		  /* 82071CE4h */ case    5:  		/* oris R11, R11, 16384 */
		/* 82071CE4h case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 82071CE4h case    5:*/		return 0x82071CE8;
		  /* 82071CE8h */ case    6:  		/* stw R11, <#[R1 + 144]> */
		/* 82071CE8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82071CE8h case    6:*/		return 0x82071CEC;
		  /* 82071CECh */ case    7:  		/* ld R11, <#[R1 + 144]> */
		/* 82071CECh case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82071CECh case    7:*/		return 0x82071CF0;
		  /* 82071CF0h */ case    8:  		/* std R11, <#[R3]> */
		/* 82071CF0h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82071CF0h case    8:*/		return 0x82071CF4;
		  /* 82071CF4h */ case    9:  		/* stw R9, <#[R31 + 13928]> */
		/* 82071CF4h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00003668) );
		/* 82071CF4h case    9:*/		return 0x82071CF8;
	}
	return 0x82071CF8;
} // Block from 82071CD0h-82071CF8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82071CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071CF8);
		  /* 82071CF8h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82071CF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82071CF8h case    0:*/		return 0x82071CFC;
		  /* 82071CFCh */ case    1:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 82071CFCh case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 82071CFCh case    1:*/		return 0x82071D00;
		  /* 82071D00h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 82071D00h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82071D00h case    2:*/		return 0x82071D04;
		  /* 82071D04h */ case    3:  		/* bc 4, CR6_EQ, 32 */
		/* 82071D04h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82071D24;  }
		/* 82071D04h case    3:*/		return 0x82071D08;
		  /* 82071D08h */ case    4:  		/* lwz R11, <#[R30 + 24]> */
		/* 82071D08h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82071D08h case    4:*/		return 0x82071D0C;
		  /* 82071D0Ch */ case    5:  		/* lwz R10, <#[R30 + 28]> */
		/* 82071D0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 82071D0Ch case    5:*/		return 0x82071D10;
		  /* 82071D10h */ case    6:  		/* rlwinm R9, R11, 0, 0, 29 */
		/* 82071D10h case    6:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R9,regs.R11);
		/* 82071D10h case    6:*/		return 0x82071D14;
		  /* 82071D14h */ case    7:  		/* rlwinm R5, R10, 0, 6, 29 */
		/* 82071D14h case    7:*/		cpu::op::rlwinm<0,0,6,29>(regs,&regs.R5,regs.R10);
		/* 82071D14h case    7:*/		return 0x82071D18;
		  /* 82071D18h */ case    8:  		/* rlwinm R11, R9, 12, 20, 31 */
		/* 82071D18h case    8:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R9);
		/* 82071D18h case    8:*/		return 0x82071D1C;
		  /* 82071D1Ch */ case    9:  		/* rlwinm R10, R9, 0, 3, 31 */
		/* 82071D1Ch case    9:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R9);
		/* 82071D1Ch case    9:*/		return 0x82071D20;
		  /* 82071D20h */ case   10:  		/* b 140 */
		/* 82071D20h case   10:*/		return 0x82071DAC;
		/* 82071D20h case   10:*/		return 0x82071D24;
	}
	return 0x82071D24;
} // Block from 82071CF8h-82071D24h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82071D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071D24);
		  /* 82071D24h */ case    0:  		/* cmplwi CR6, R11, 3 */
		/* 82071D24h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82071D24h case    0:*/		return 0x82071D28;
		  /* 82071D28h */ case    1:  		/* bc 4, CR6_EQ, 152 */
		/* 82071D28h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82071DC0;  }
		/* 82071D28h case    1:*/		return 0x82071D2C;
		  /* 82071D2Ch */ case    2:  		/* addi R10, R1, 116 */
		/* 82071D2Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x74);
		/* 82071D2Ch case    2:*/		return 0x82071D30;
		  /* 82071D30h */ case    3:  		/* lwz R11, <#[R30 + 32]> */
		/* 82071D30h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 82071D30h case    3:*/		return 0x82071D34;
		  /* 82071D34h */ case    4:  		/* addi R9, R1, 120 */
		/* 82071D34h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x78);
		/* 82071D34h case    4:*/		return 0x82071D38;
		  /* 82071D38h */ case    5:  		/* lwz R29, <#[R30 + 48]> */
		/* 82071D38h case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000030) );
		/* 82071D38h case    5:*/		return 0x82071D3C;
		  /* 82071D3Ch */ case    6:  		/* addi R8, R1, 124 */
		/* 82071D3Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x7C);
		/* 82071D3Ch case    6:*/		return 0x82071D40;
		  /* 82071D40h */ case    7:  		/* stw R10, <#[R1 + 100]> */
		/* 82071D40h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 82071D40h case    7:*/		return 0x82071D44;
		  /* 82071D44h */ case    8:  		/* stw R9, <#[R1 + 92]> */
		/* 82071D44h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 82071D44h case    8:*/		return 0x82071D48;
		  /* 82071D48h */ case    9:  		/* mr R3, R30 */
		/* 82071D48h case    9:*/		regs.R3 = regs.R30;
		/* 82071D48h case    9:*/		return 0x82071D4C;
		  /* 82071D4Ch */ case   10:  		/* stw R8, <#[R1 + 84]> */
		/* 82071D4Ch case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 82071D4Ch case   10:*/		return 0x82071D50;
		  /* 82071D50h */ case   11:  		/* addi R10, R1, 128 */
		/* 82071D50h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 82071D50h case   11:*/		return 0x82071D54;
		  /* 82071D54h */ case   12:  		/* addi R9, R1, 132 */
		/* 82071D54h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x84);
		/* 82071D54h case   12:*/		return 0x82071D58;
		  /* 82071D58h */ case   13:  		/* addi R8, R1, 112 */
		/* 82071D58h case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x70);
		/* 82071D58h case   13:*/		return 0x82071D5C;
		  /* 82071D5Ch */ case   14:  		/* addi R7, R1, 136 */
		/* 82071D5Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x88);
		/* 82071D5Ch case   14:*/		return 0x82071D60;
		  /* 82071D60h */ case   15:  		/* addi R6, R1, 144 */
		/* 82071D60h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 82071D60h case   15:*/		return 0x82071D64;
		  /* 82071D64h */ case   16:  		/* li R5, 0 */
		/* 82071D64h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82071D64h case   16:*/		return 0x82071D68;
		  /* 82071D68h */ case   17:  		/* li R4, 0 */
		/* 82071D68h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82071D68h case   17:*/		return 0x82071D6C;
		  /* 82071D6Ch */ case   18:  		/* rlwinm R27, R11, 0, 0, 19 */
		/* 82071D6Ch case   18:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R27,regs.R11);
		/* 82071D6Ch case   18:*/		return 0x82071D70;
		  /* 82071D70h */ case   19:  		/* rlwinm R30, R29, 0, 0, 19 */
		/* 82071D70h case   19:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R30,regs.R29);
		/* 82071D70h case   19:*/		return 0x82071D74;
		  /* 82071D74h */ case   20:  		/* bl -47812 */
		/* 82071D74h case   20:*/		regs.LR = 0x82071D78; return 0x820662B0;
		/* 82071D74h case   20:*/		return 0x82071D78;
		  /* 82071D78h */ case   21:  		/* rlwinm R11, R27, 12, 20, 31 */
		/* 82071D78h case   21:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R27);
		/* 82071D78h case   21:*/		return 0x82071D7C;
		  /* 82071D7Ch */ case   22:  		/* lwz R5, <#[R1 + 112]> */
		/* 82071D7Ch case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000070) );
		/* 82071D7Ch case   22:*/		return 0x82071D80;
		  /* 82071D80h */ case   23:  		/* rlwinm R10, R27, 0, 3, 31 */
		/* 82071D80h case   23:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R27);
		/* 82071D80h case   23:*/		return 0x82071D84;
		  /* 82071D84h */ case   24:  		/* addi R11, R11, 512 */
		/* 82071D84h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82071D84h case   24:*/		return 0x82071D88;
		  /* 82071D88h */ case   25:  		/* mr R3, R31 */
		/* 82071D88h case   25:*/		regs.R3 = regs.R31;
		/* 82071D88h case   25:*/		return 0x82071D8C;
		  /* 82071D8Ch */ case   26:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82071D8Ch case   26:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82071D8Ch case   26:*/		return 0x82071D90;
		  /* 82071D90h */ case   27:  		/* add R4, R11, R10 */
		/* 82071D90h case   27:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 82071D90h case   27:*/		return 0x82071D94;
		  /* 82071D94h */ case   28:  		/* bl -2172 */
		/* 82071D94h case   28:*/		regs.LR = 0x82071D98; return 0x82071518;
		/* 82071D94h case   28:*/		return 0x82071D98;
		  /* 82071D98h */ case   29:  		/* cmplwi CR6, R30, 0 */
		/* 82071D98h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82071D98h case   29:*/		return 0x82071D9C;
		  /* 82071D9Ch */ case   30:  		/* bc 12, CR6_EQ, 36 */
		/* 82071D9Ch case   30:*/		if ( regs.CR[6].eq ) { return 0x82071DC0;  }
		/* 82071D9Ch case   30:*/		return 0x82071DA0;
		  /* 82071DA0h */ case   31:  		/* lwz R5, <#[R1 + 112]> */
		/* 82071DA0h case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000070) );
		/* 82071DA0h case   31:*/		return 0x82071DA4;
		  /* 82071DA4h */ case   32:  		/* rlwinm R11, R30, 12, 20, 31 */
		/* 82071DA4h case   32:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R30);
		/* 82071DA4h case   32:*/		return 0x82071DA8;
		  /* 82071DA8h */ case   33:  		/* rlwinm R10, R30, 0, 3, 31 */
		/* 82071DA8h case   33:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R30);
		/* 82071DA8h case   33:*/		return 0x82071DAC;
	}
	return 0x82071DAC;
} // Block from 82071D24h-82071DACh (34 instructions)

//////////////////////////////////////////////////////
// Block at 82071DACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071DAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071DAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071DAC);
		  /* 82071DACh */ case    0:  		/* addi R11, R11, 512 */
		/* 82071DACh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82071DACh case    0:*/		return 0x82071DB0;
		  /* 82071DB0h */ case    1:  		/* mr R3, R31 */
		/* 82071DB0h case    1:*/		regs.R3 = regs.R31;
		/* 82071DB0h case    1:*/		return 0x82071DB4;
		  /* 82071DB4h */ case    2:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82071DB4h case    2:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82071DB4h case    2:*/		return 0x82071DB8;
		  /* 82071DB8h */ case    3:  		/* add R4, R11, R10 */
		/* 82071DB8h case    3:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 82071DB8h case    3:*/		return 0x82071DBC;
		  /* 82071DBCh */ case    4:  		/* bl -2212 */
		/* 82071DBCh case    4:*/		regs.LR = 0x82071DC0; return 0x82071518;
		/* 82071DBCh case    4:*/		return 0x82071DC0;
	}
	return 0x82071DC0;
} // Block from 82071DACh-82071DC0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82071DC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071DC0);
		  /* 82071DC0h */ case    0:  		/* lwz R11, <#[R31 + 13904]> */
		/* 82071DC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003650) );
		/* 82071DC0h case    0:*/		return 0x82071DC4;
		  /* 82071DC4h */ case    1:  		/* lwz R3, <#[R31 + 48]> */
		/* 82071DC4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82071DC4h case    1:*/		return 0x82071DC8;
		  /* 82071DC8h */ case    2:  		/* lwz R10, <#[R31 + 56]> */
		/* 82071DC8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 82071DC8h case    2:*/		return 0x82071DCC;
		  /* 82071DCCh */ case    3:  		/* addi R11, R11, -1 */
		/* 82071DCCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82071DCCh case    3:*/		return 0x82071DD0;
		  /* 82071DD0h */ case    4:  		/* cmplw CR6, R3, R10 */
		/* 82071DD0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 82071DD0h case    4:*/		return 0x82071DD4;
		  /* 82071DD4h */ case    5:  		/* stw R11, <#[R31 + 13904]> */
		/* 82071DD4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00003650) );
		/* 82071DD4h case    5:*/		return 0x82071DD8;
		  /* 82071DD8h */ case    6:  		/* bc 4, CR6_GT, 12 */
		/* 82071DD8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82071DE4;  }
		/* 82071DD8h case    6:*/		return 0x82071DDC;
		  /* 82071DDCh */ case    7:  		/* mr R3, R31 */
		/* 82071DDCh case    7:*/		regs.R3 = regs.R31;
		/* 82071DDCh case    7:*/		return 0x82071DE0;
		  /* 82071DE0h */ case    8:  		/* bl 9000 */
		/* 82071DE0h case    8:*/		regs.LR = 0x82071DE4; return 0x82074108;
		/* 82071DE0h case    8:*/		return 0x82071DE4;
	}
	return 0x82071DE4;
} // Block from 82071DC0h-82071DE4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82071DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071DE4);
		  /* 82071DE4h */ case    0:  		/* lis R11, -16384 */
		/* 82071DE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 82071DE4h case    0:*/		return 0x82071DE8;
		  /* 82071DE8h */ case    1:  		/* li R10, 6 */
		/* 82071DE8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x6);
		/* 82071DE8h case    1:*/		return 0x82071DEC;
		  /* 82071DECh */ case    2:  		/* ori R11, R11, 17920 */
		/* 82071DECh case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4600);
		/* 82071DECh case    2:*/		return 0x82071DF0;
		  /* 82071DF0h */ case    3:  		/* stwu R11, <#[R3 + 4]> */
		/* 82071DF0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071DF0h case    3:*/		return 0x82071DF4;
		  /* 82071DF4h */ case    4:  		/* stwu R10, <#[R3 + 4]> */
		/* 82071DF4h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071DF4h case    4:*/		return 0x82071DF8;
		  /* 82071DF8h */ case    5:  		/* lwz R11, <#[R31 + 13904]> */
		/* 82071DF8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003650) );
		/* 82071DF8h case    5:*/		return 0x82071DFC;
		  /* 82071DFCh */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82071DFCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82071DFCh case    6:*/		return 0x82071E00;
		  /* 82071E00h */ case    7:  		/* stw R3, <#[R31 + 48]> */
		/* 82071E00h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82071E00h case    7:*/		return 0x82071E04;
		  /* 82071E04h */ case    8:  		/* bc 4, CR6_EQ, 80 */
		/* 82071E04h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82071E54;  }
		/* 82071E04h case    8:*/		return 0x82071E08;
		  /* 82071E08h */ case    9:  		/* cmplwi CR6, R28, 1 */
		/* 82071E08h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000001);
		/* 82071E08h case    9:*/		return 0x82071E0C;
		  /* 82071E0Ch */ case   10:  		/* bc 12, CR6_EQ, 64 */
		/* 82071E0Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82071E4C;  }
		/* 82071E0Ch case   10:*/		return 0x82071E10;
		  /* 82071E10h */ case   11:  		/* lwz R11, <#[R31 + 56]> */
		/* 82071E10h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82071E10h case   11:*/		return 0x82071E14;
		  /* 82071E14h */ case   12:  		/* cmplw CR6, R3, R11 */
		/* 82071E14h case   12:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82071E14h case   12:*/		return 0x82071E18;
		  /* 82071E18h */ case   13:  		/* bc 4, CR6_GT, 12 */
		/* 82071E18h case   13:*/		if ( !regs.CR[6].gt ) { return 0x82071E24;  }
		/* 82071E18h case   13:*/		return 0x82071E1C;
		  /* 82071E1Ch */ case   14:  		/* mr R3, R31 */
		/* 82071E1Ch case   14:*/		regs.R3 = regs.R31;
		/* 82071E1Ch case   14:*/		return 0x82071E20;
		  /* 82071E20h */ case   15:  		/* bl 8936 */
		/* 82071E20h case   15:*/		regs.LR = 0x82071E24; return 0x82074108;
		/* 82071E20h case   15:*/		return 0x82071E24;
	}
	return 0x82071E24;
} // Block from 82071DE4h-82071E24h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82071E24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071E24);
		  /* 82071E24h */ case    0:  		/* li R11, 1480 */
		/* 82071E24h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x5C8);
		/* 82071E24h case    0:*/		return 0x82071E28;
		  /* 82071E28h */ case    1:  		/* lis R10, 2 */
		/* 82071E28h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x2);
		/* 82071E28h case    1:*/		return 0x82071E2C;
		  /* 82071E2Ch */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 82071E2Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071E2Ch case    2:*/		return 0x82071E30;
		  /* 82071E30h */ case    3:  		/* cmplwi CR6, R28, 2 */
		/* 82071E30h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000002);
		/* 82071E30h case    3:*/		return 0x82071E34;
		  /* 82071E34h */ case    4:  		/* stwu R10, <#[R3 + 4]> */
		/* 82071E34h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82071E34h case    4:*/		return 0x82071E38;
		  /* 82071E38h */ case    5:  		/* stw R3, <#[R31 + 48]> */
		/* 82071E38h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82071E38h case    5:*/		return 0x82071E3C;
		  /* 82071E3Ch */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 82071E3Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82071E5C;  }
		/* 82071E3Ch case    6:*/		return 0x82071E40;
		  /* 82071E40h */ case    7:  		/* mr R3, R31 */
		/* 82071E40h case    7:*/		regs.R3 = regs.R31;
		/* 82071E40h case    7:*/		return 0x82071E44;
		  /* 82071E44h */ case    8:  		/* bl -1676 */
		/* 82071E44h case    8:*/		regs.LR = 0x82071E48; return 0x820717B8;
		/* 82071E44h case    8:*/		return 0x82071E48;
		  /* 82071E48h */ case    9:  		/* b 20 */
		/* 82071E48h case    9:*/		return 0x82071E5C;
		/* 82071E48h case    9:*/		return 0x82071E4C;
	}
	return 0x82071E4C;
} // Block from 82071E24h-82071E4Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82071E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071E4C);
		  /* 82071E4Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82071E4Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82071E4Ch case    0:*/		return 0x82071E50;
		  /* 82071E50h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82071E50h case    1:*/		if ( regs.CR[6].eq ) { return 0x82071E5C;  }
		/* 82071E50h case    1:*/		return 0x82071E54;
	}
	return 0x82071E54;
} // Block from 82071E4Ch-82071E54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82071E54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071E54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071E54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071E54);
		  /* 82071E54h */ case    0:  		/* mr R3, R31 */
		/* 82071E54h case    0:*/		regs.R3 = regs.R31;
		/* 82071E54h case    0:*/		return 0x82071E58;
		  /* 82071E58h */ case    1:  		/* bl -2040 */
		/* 82071E58h case    1:*/		regs.LR = 0x82071E5C; return 0x82071660;
		/* 82071E58h case    1:*/		return 0x82071E5C;
	}
	return 0x82071E5C;
} // Block from 82071E54h-82071E5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82071E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071E5C);
		  /* 82071E5Ch */ case    0:  		/* lwz R3, <#[R31 + 48]> */
		/* 82071E5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82071E5Ch case    0:*/		return 0x82071E60;
		  /* 82071E60h */ case    1:  		/* lwz R11, <#[R31 + 56]> */
		/* 82071E60h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82071E60h case    1:*/		return 0x82071E64;
		  /* 82071E64h */ case    2:  		/* cmplw CR6, R3, R11 */
		/* 82071E64h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82071E64h case    2:*/		return 0x82071E68;
		  /* 82071E68h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 82071E68h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82071E74;  }
		/* 82071E68h case    3:*/		return 0x82071E6C;
		  /* 82071E6Ch */ case    4:  		/* mr R3, R31 */
		/* 82071E6Ch case    4:*/		regs.R3 = regs.R31;
		/* 82071E6Ch case    4:*/		return 0x82071E70;
		  /* 82071E70h */ case    5:  		/* bl 8856 */
		/* 82071E70h case    5:*/		regs.LR = 0x82071E74; return 0x82074108;
		/* 82071E70h case    5:*/		return 0x82071E74;
	}
	return 0x82071E74;
} // Block from 82071E5Ch-82071E74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82071E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071E74);
		  /* 82071E74h */ case    0:  		/* lwz R11, <#[R31 + 13904]> */
		/* 82071E74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003650) );
		/* 82071E74h case    0:*/		return 0x82071E78;
		  /* 82071E78h */ case    1:  		/* stw R3, <#[R31 + 48]> */
		/* 82071E78h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82071E78h case    1:*/		return 0x82071E7C;
		  /* 82071E7Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82071E7Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82071E7Ch case    2:*/		return 0x82071E80;
		  /* 82071E80h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 82071E80h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82071E90;  }
		/* 82071E80h case    3:*/		return 0x82071E84;
		  /* 82071E84h */ case    4:  		/* cmplwi CR6, R28, 1 */
		/* 82071E84h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000001);
		/* 82071E84h case    4:*/		return 0x82071E88;
		  /* 82071E88h */ case    5:  		/* li R11, 1 */
		/* 82071E88h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82071E88h case    5:*/		return 0x82071E8C;
		  /* 82071E8Ch */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 82071E8Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82071E94;  }
		/* 82071E8Ch case    6:*/		return 0x82071E90;
	}
	return 0x82071E90;
} // Block from 82071E74h-82071E90h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82071E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071E90);
		  /* 82071E90h */ case    0:  		/* li R11, 0 */
		/* 82071E90h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82071E90h case    0:*/		return 0x82071E94;
	}
	return 0x82071E94;
} // Block from 82071E90h-82071E94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82071E94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071E94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071E94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071E94);
		  /* 82071E94h */ case    0:  		/* stw R11, <#[R31 + 13908]> */
		/* 82071E94h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00003654) );
		/* 82071E94h case    0:*/		return 0x82071E98;
		  /* 82071E98h */ case    1:  		/* addi R1, R1, 208 */
		/* 82071E98h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 82071E98h case    1:*/		return 0x82071E9C;
		  /* 82071E9Ch */ case    2:  		/* b 128008 */
		/* 82071E9Ch case    2:*/		return 0x820912A4;
		/* 82071E9Ch case    2:*/		return 0x82071EA0;
	}
	return 0x82071EA0;
} // Block from 82071E94h-82071EA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82071EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071EA0);
		  /* 82071EA0h */ case    0:  		/* mfspr R12, LR */
		/* 82071EA0h case    0:*/		regs.R12 = regs.LR;
		/* 82071EA0h case    0:*/		return 0x82071EA4;
		  /* 82071EA4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82071EA4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82071EA4h case    1:*/		return 0x82071EA8;
		  /* 82071EA8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82071EA8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82071EA8h case    2:*/		return 0x82071EAC;
		  /* 82071EACh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82071EACh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82071EACh case    3:*/		return 0x82071EB0;
		  /* 82071EB0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82071EB0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82071EB0h case    4:*/		return 0x82071EB4;
		  /* 82071EB4h */ case    5:  		/* mr R31, R3 */
		/* 82071EB4h case    5:*/		regs.R31 = regs.R3;
		/* 82071EB4h case    5:*/		return 0x82071EB8;
		  /* 82071EB8h */ case    6:  		/* bl 2076736 */
		/* 82071EB8h case    6:*/		regs.LR = 0x82071EBC; return 0x8226CEF8;
		/* 82071EB8h case    6:*/		return 0x82071EBC;
		  /* 82071EBCh */ case    7:  		/* cmpwi CR6, R3, 2 */
		/* 82071EBCh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82071EBCh case    7:*/		return 0x82071EC0;
		  /* 82071EC0h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 82071EC0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82071ED0;  }
		/* 82071EC0h case    8:*/		return 0x82071EC4;
		  /* 82071EC4h */ case    9:  		/* lis R11, -32256 */
		/* 82071EC4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82071EC4h case    9:*/		return 0x82071EC8;
		  /* 82071EC8h */ case   10:  		/* lwz R11, <#[R11 + 1452]> */
		/* 82071EC8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005AC) );
		/* 82071EC8h case   10:*/		return 0x82071ECC;
		  /* 82071ECCh */ case   11:  		/* b 12 */
		/* 82071ECCh case   11:*/		return 0x82071ED8;
		/* 82071ECCh case   11:*/		return 0x82071ED0;
	}
	return 0x82071ED0;
} // Block from 82071EA0h-82071ED0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82071ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071ED0);
		  /* 82071ED0h */ case    0:  		/* lis R11, -32256 */
		/* 82071ED0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82071ED0h case    0:*/		return 0x82071ED4;
		  /* 82071ED4h */ case    1:  		/* lwz R11, <#[R11 + 1456]> */
		/* 82071ED4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005B0) );
		/* 82071ED4h case    1:*/		return 0x82071ED8;
	}
	return 0x82071ED8;
} // Block from 82071ED0h-82071ED8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82071ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071ED8);
		  /* 82071ED8h */ case    0:  		/* lwz R3, <#[R11]> */
		/* 82071ED8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 82071ED8h case    0:*/		return 0x82071EDC;
		  /* 82071EDCh */ case    1:  		/* lwz R11, <#[R31]> */
		/* 82071EDCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82071EDCh case    1:*/		return 0x82071EE0;
		  /* 82071EE0h */ case    2:  		/* rlwinm R10, R11, 0, 28, 31 */
		/* 82071EE0h case    2:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R11);
		/* 82071EE0h case    2:*/		return 0x82071EE4;
		  /* 82071EE4h */ case    3:  		/* addi R10, R10, -1 */
		/* 82071EE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82071EE4h case    3:*/		return 0x82071EE8;
		  /* 82071EE8h */ case    4:  		/* cmplwi CR6, R10, 11 */
		/* 82071EE8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000B);
		/* 82071EE8h case    4:*/		return 0x82071EEC;
		  /* 82071EECh */ case    5:  		/* bc 12, CR6_GT, 568 */
		/* 82071EECh case    5:*/		if ( regs.CR[6].gt ) { return 0x82072124;  }
		/* 82071EECh case    5:*/		return 0x82071EF0;
		  /* 82071EF0h */ case    6:  		/* lis R12, -32256 */
		/* 82071EF0h case    6:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8200);
		/* 82071EF0h case    6:*/		return 0x82071EF4;
		  /* 82071EF4h */ case    7:  		/* addi R12, R12, 4448 */
		/* 82071EF4h case    7:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x1160);
		/* 82071EF4h case    7:*/		return 0x82071EF8;
		  /* 82071EF8h */ case    8:  		/* lbzx R0, <#[R12 + R10]> */
		/* 82071EF8h case    8:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R10 + 0x00000000) );
		/* 82071EF8h case    8:*/		return 0x82071EFC;
		  /* 82071EFCh */ case    9:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 82071EFCh case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 82071EFCh case    9:*/		return 0x82071F00;
		  /* 82071F00h */ case   10:  		/* lis R12, -32249 */
		/* 82071F00h case   10:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8207);
		/* 82071F00h case   10:*/		return 0x82071F04;
		  /* 82071F04h */ case   11:  		/* ori R0, R0, 0 */
		/* 82071F04h case   11:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82071F04h case   11:*/		return 0x82071F08;
		  /* 82071F08h */ case   12:  		/* addi R12, R12, 7960 */
		/* 82071F08h case   12:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x1F18);
		/* 82071F08h case   12:*/		return 0x82071F0C;
		  /* 82071F0Ch */ case   13:  		/* add R12, R12, R0 */
		/* 82071F0Ch case   13:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82071F0Ch case   13:*/		return 0x82071F10;
		  /* 82071F10h */ case   14:  		/* mtspr CTR, R12 */
		/* 82071F10h case   14:*/		regs.CTR = regs.R12;
		/* 82071F10h case   14:*/		return 0x82071F14;
		  /* 82071F14h */ case   15:  		/* bcctr 20, CR0_LT */
		/* 82071F14h case   15:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82071F14h case   15:*/		return 0x82071F18;
		  /* 82071F18h */ case   16:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82071F18h case   16:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82071F18h case   16:*/		return 0x82071F1C;
		  /* 82071F1Ch */ case   17:  		/* bc 4, CR0_EQ, 520 */
		/* 82071F1Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x82072124;  }
		/* 82071F1Ch case   17:*/		return 0x82071F20;
		  /* 82071F20h */ case   18:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 82071F20h case   18:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 82071F20h case   18:*/		return 0x82071F24;
		  /* 82071F24h */ case   19:  		/* bc 12, CR0_EQ, 28 */
		/* 82071F24h case   19:*/		if ( regs.CR[0].eq ) { return 0x82071F40;  }
		/* 82071F24h case   19:*/		return 0x82071F28;
		  /* 82071F28h */ case   20:  		/* lwz R11, <#[R31 + 44]> */
		/* 82071F28h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82071F28h case   20:*/		return 0x82071F2C;
		  /* 82071F2Ch */ case   21:  		/* li R10, 5120 */
		/* 82071F2Ch case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x1400);
		/* 82071F2Ch case   21:*/		return 0x82071F30;
		  /* 82071F30h */ case   22:  		/* lwz R9, <#[R31 + 28]> */
		/* 82071F30h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000001C) );
		/* 82071F30h case   22:*/		return 0x82071F34;
		  /* 82071F34h */ case   23:  		/* divwu R4, R11, R10 */
		/* 82071F34h case   23:*/		cpu::op::divwu<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 82071F34h case   23:*/		return 0x82071F38;
		  /* 82071F38h */ case   24:  		/* rlwinm R3, R9, 0, 20, 31 */
		/* 82071F38h case   24:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R3,regs.R9);
		/* 82071F38h case   24:*/		return 0x82071F3C;
		  /* 82071F3Ch */ case   25:  		/* bl 21748 */
		/* 82071F3Ch case   25:*/		regs.LR = 0x82071F40; return 0x82077430;
		/* 82071F3Ch case   25:*/		return 0x82071F40;
	}
	return 0x82071F40;
} // Block from 82071ED8h-82071F40h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82071F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071F40);
		  /* 82071F40h */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 82071F40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82071F40h case    0:*/		return 0x82071F44;
		  /* 82071F44h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82071F44h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82071F44h case    1:*/		return 0x82071F48;
		  /* 82071F48h */ case    2:  		/* bc 12, CR0_EQ, 476 */
		/* 82071F48h case    2:*/		if ( regs.CR[0].eq ) { return 0x82072124;  }
		/* 82071F48h case    2:*/		return 0x82071F4C;
		  /* 82071F4Ch */ case    3:  		/* lis R10, -32216 */
		/* 82071F4Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 82071F4Ch case    3:*/		return 0x82071F50;
		  /* 82071F50h */ case    4:  		/* li R11, 0 */
		/* 82071F50h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82071F50h case    4:*/		return 0x82071F54;
		  /* 82071F54h */ case    5:  		/* stw R11, <#[R10 + 28680]> */
		/* 82071F54h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00007008) );
		/* 82071F54h case    5:*/		return 0x82071F58;
		  /* 82071F58h */ case    6:  		/* b 460 */
		/* 82071F58h case    6:*/		return 0x82072124;
		/* 82071F58h case    6:*/		return 0x82071F5C;
		  /* 82071F5Ch */ case    7:  		/* lwz R4, <#[R31 + 8]> */
		/* 82071F5Ch case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82071F5Ch case    7:*/		return 0x82071F60;
		  /* 82071F60h */ case    8:  		/* cmplwi CR6, R4, 0 */
		/* 82071F60h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82071F60h case    8:*/		return 0x82071F64;
		  /* 82071F64h */ case    9:  		/* bc 12, CR6_EQ, 28 */
		/* 82071F64h case    9:*/		if ( regs.CR[6].eq ) { return 0x82071F80;  }
		/* 82071F64h case    9:*/		return 0x82071F68;
		  /* 82071F68h */ case   10:  		/* cmplwi CR6, R3, 0 */
		/* 82071F68h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82071F68h case   10:*/		return 0x82071F6C;
		  /* 82071F6Ch */ case   11:  		/* bc 12, CR6_EQ, 20 */
		/* 82071F6Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82071F80;  }
		/* 82071F6Ch case   11:*/		return 0x82071F70;
		  /* 82071F70h */ case   12:  		/* li R7, 0 */
		/* 82071F70h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82071F70h case   12:*/		return 0x82071F74;
		  /* 82071F74h */ case   13:  		/* mr R6, R31 */
		/* 82071F74h case   13:*/		regs.R6 = regs.R31;
		/* 82071F74h case   13:*/		return 0x82071F78;
		  /* 82071F78h */ case   14:  		/* li R5, 13 */
		/* 82071F78h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0xD);
		/* 82071F78h case   14:*/		return 0x82071F7C;
		  /* 82071F7Ch */ case   15:  		/* bl 3500 */
		/* 82071F7Ch case   15:*/		regs.LR = 0x82071F80; return 0x82072D28;
		/* 82071F7Ch case   15:*/		return 0x82071F80;
	}
	return 0x82071F80;
} // Block from 82071F40h-82071F80h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82071F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071F80);
		  /* 82071F80h */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 82071F80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82071F80h case    0:*/		return 0x82071F84;
		  /* 82071F84h */ case    1:  		/* lis R4, -20096 */
		/* 82071F84h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB180);
		/* 82071F84h case    1:*/		return 0x82071F88;
		  /* 82071F88h */ case    2:  		/* lwz R10, <#[R31 + 48]> */
		/* 82071F88h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 82071F88h case    2:*/		return 0x82071F8C;
		  /* 82071F8Ch */ case    3:  		/* rlwinm R3, R11, 0, 0, 19 */
		/* 82071F8Ch case    3:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R3,regs.R11);
		/* 82071F8Ch case    3:*/		return 0x82071F90;
		  /* 82071F90h */ case    4:  		/* rlwinm R30, R10, 0, 0, 19 */
		/* 82071F90h case    4:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R30,regs.R10);
		/* 82071F90h case    4:*/		return 0x82071F94;
		  /* 82071F94h */ case    5:  		/* bl 91044 */
		/* 82071F94h case    5:*/		regs.LR = 0x82071F98; return 0x82088338;
		/* 82071F94h case    5:*/		return 0x82071F98;
		  /* 82071F98h */ case    6:  		/* mr R3, R30 */
		/* 82071F98h case    6:*/		regs.R3 = regs.R30;
		/* 82071F98h case    6:*/		return 0x82071F9C;
		  /* 82071F9Ch */ case    7:  		/* lis R4, -20096 */
		/* 82071F9Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB180);
		/* 82071F9Ch case    7:*/		return 0x82071FA0;
		  /* 82071FA0h */ case    8:  		/* bl 91032 */
		/* 82071FA0h case    8:*/		regs.LR = 0x82071FA4; return 0x82088338;
		/* 82071FA0h case    8:*/		return 0x82071FA4;
		  /* 82071FA4h */ case    9:  		/* b 384 */
		/* 82071FA4h case    9:*/		return 0x82072124;
		/* 82071FA4h case    9:*/		return 0x82071FA8;
		  /* 82071FA8h */ case   10:  		/* lwz R4, <#[R31 + 8]> */
		/* 82071FA8h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82071FA8h case   10:*/		return 0x82071FAC;
		  /* 82071FACh */ case   11:  		/* cmplwi CR6, R4, 0 */
		/* 82071FACh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82071FACh case   11:*/		return 0x82071FB0;
		  /* 82071FB0h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 82071FB0h case   12:*/		if ( regs.CR[6].eq ) { return 0x82071FCC;  }
		/* 82071FB0h case   12:*/		return 0x82071FB4;
		  /* 82071FB4h */ case   13:  		/* cmplwi CR6, R3, 0 */
		/* 82071FB4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82071FB4h case   13:*/		return 0x82071FB8;
		  /* 82071FB8h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 82071FB8h case   14:*/		if ( regs.CR[6].eq ) { return 0x82071FCC;  }
		/* 82071FB8h case   14:*/		return 0x82071FBC;
		  /* 82071FBCh */ case   15:  		/* li R7, 0 */
		/* 82071FBCh case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82071FBCh case   15:*/		return 0x82071FC0;
		  /* 82071FC0h */ case   16:  		/* mr R6, R31 */
		/* 82071FC0h case   16:*/		regs.R6 = regs.R31;
		/* 82071FC0h case   16:*/		return 0x82071FC4;
		  /* 82071FC4h */ case   17:  		/* li R5, 9 */
		/* 82071FC4h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x9);
		/* 82071FC4h case   17:*/		return 0x82071FC8;
		  /* 82071FC8h */ case   18:  		/* bl 3424 */
		/* 82071FC8h case   18:*/		regs.LR = 0x82071FCC; return 0x82072D28;
		/* 82071FC8h case   18:*/		return 0x82071FCC;
	}
	return 0x82071FCC;
} // Block from 82071F80h-82071FCCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 82071FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071FCC);
		  /* 82071FCCh */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 82071FCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82071FCCh case    0:*/		return 0x82071FD0;
		  /* 82071FD0h */ case    1:  		/* rlwinm R3, R11, 0, 0, 29 */
		/* 82071FD0h case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R3,regs.R11);
		/* 82071FD0h case    1:*/		return 0x82071FD4;
		  /* 82071FD4h */ case    2:  		/* b -56 */
		/* 82071FD4h case    2:*/		return 0x82071F9C;
		/* 82071FD4h case    2:*/		return 0x82071FD8;
		  /* 82071FD8h */ case    3:  		/* lwz R4, <#[R31 + 8]> */
		/* 82071FD8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82071FD8h case    3:*/		return 0x82071FDC;
		  /* 82071FDCh */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 82071FDCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82071FDCh case    4:*/		return 0x82071FE0;
		  /* 82071FE0h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 82071FE0h case    5:*/		if ( regs.CR[6].eq ) { return 0x82071FFC;  }
		/* 82071FE0h case    5:*/		return 0x82071FE4;
		  /* 82071FE4h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 82071FE4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82071FE4h case    6:*/		return 0x82071FE8;
		  /* 82071FE8h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82071FE8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82071FFC;  }
		/* 82071FE8h case    7:*/		return 0x82071FEC;
		  /* 82071FECh */ case    8:  		/* li R5, 11 */
		/* 82071FECh case    8:*/		cpu::op::li<0>(regs,&regs.R5,0xB);
		/* 82071FECh case    8:*/		return 0x82071FF0;
		  /* 82071FF0h */ case    9:  		/* li R7, 0 */
		/* 82071FF0h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82071FF0h case    9:*/		return 0x82071FF4;
		  /* 82071FF4h */ case   10:  		/* mr R6, R31 */
		/* 82071FF4h case   10:*/		regs.R6 = regs.R31;
		/* 82071FF4h case   10:*/		return 0x82071FF8;
		  /* 82071FF8h */ case   11:  		/* bl 3376 */
		/* 82071FF8h case   11:*/		regs.LR = 0x82071FFC; return 0x82072D28;
		/* 82071FF8h case   11:*/		return 0x82071FFC;
	}
	return 0x82071FFC;
} // Block from 82071FCCh-82071FFCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 82071FFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82071FFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82071FFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82071FFC);
		  /* 82071FFCh */ case    0:  		/* lwz R3, <#[R31 + 24]> */
		/* 82071FFCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 82071FFCh case    0:*/		return 0x82072000;
		  /* 82072000h */ case    1:  		/* b -100 */
		/* 82072000h case    1:*/		return 0x82071F9C;
		/* 82072000h case    1:*/		return 0x82072004;
		  /* 82072004h */ case    2:  		/* lwz R4, <#[R31 + 8]> */
		/* 82072004h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82072004h case    2:*/		return 0x82072008;
		  /* 82072008h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 82072008h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82072008h case    3:*/		return 0x8207200C;
		  /* 8207200Ch */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 8207200Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82072028;  }
		/* 8207200Ch case    4:*/		return 0x82072010;
		  /* 82072010h */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 82072010h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82072010h case    5:*/		return 0x82072014;
		  /* 82072014h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82072014h case    6:*/		if ( regs.CR[6].eq ) { return 0x82072028;  }
		/* 82072014h case    6:*/		return 0x82072018;
		  /* 82072018h */ case    7:  		/* li R7, 0 */
		/* 82072018h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82072018h case    7:*/		return 0x8207201C;
		  /* 8207201Ch */ case    8:  		/* mr R6, R31 */
		/* 8207201Ch case    8:*/		regs.R6 = regs.R31;
		/* 8207201Ch case    8:*/		return 0x82072020;
		  /* 82072020h */ case    9:  		/* li R5, 7 */
		/* 82072020h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x7);
		/* 82072020h case    9:*/		return 0x82072024;
		  /* 82072024h */ case   10:  		/* bl 3332 */
		/* 82072024h case   10:*/		regs.LR = 0x82072028; return 0x82072D28;
		/* 82072024h case   10:*/		return 0x82072028;
	}
	return 0x82072028;
} // Block from 82071FFCh-82072028h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82072028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072028);
		  /* 82072028h */ case    0:  		/* lwz R3, <#[R31 + 32]> */
		/* 82072028h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 82072028h case    0:*/		return 0x8207202C;
		  /* 8207202Ch */ case    1:  		/* b -144 */
		/* 8207202Ch case    1:*/		return 0x82071F9C;
		/* 8207202Ch case    1:*/		return 0x82072030;
		  /* 82072030h */ case    2:  		/* lwz R4, <#[R31 + 8]> */
		/* 82072030h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82072030h case    2:*/		return 0x82072034;
		  /* 82072034h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 82072034h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82072034h case    3:*/		return 0x82072038;
		  /* 82072038h */ case    4:  		/* bc 12, CR6_EQ, -60 */
		/* 82072038h case    4:*/		if ( regs.CR[6].eq ) { return 0x82071FFC;  }
		/* 82072038h case    4:*/		return 0x8207203C;
		  /* 8207203Ch */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 8207203Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8207203Ch case    5:*/		return 0x82072040;
		  /* 82072040h */ case    6:  		/* bc 12, CR6_EQ, -68 */
		/* 82072040h case    6:*/		if ( regs.CR[6].eq ) { return 0x82071FFC;  }
		/* 82072040h case    6:*/		return 0x82072044;
		  /* 82072044h */ case    7:  		/* li R5, 8 */
		/* 82072044h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x8);
		/* 82072044h case    7:*/		return 0x82072048;
		  /* 82072048h */ case    8:  		/* b -88 */
		/* 82072048h case    8:*/		return 0x82071FF0;
		/* 82072048h case    8:*/		return 0x8207204C;
		  /* 8207204Ch */ case    9:  		/* lwz R4, <#[R31 + 8]> */
		/* 8207204Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 8207204Ch case    9:*/		return 0x82072050;
		  /* 82072050h */ case   10:  		/* cmplwi CR6, R4, 0 */
		/* 82072050h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82072050h case   10:*/		return 0x82072054;
		  /* 82072054h */ case   11:  		/* bc 12, CR6_EQ, -88 */
		/* 82072054h case   11:*/		if ( regs.CR[6].eq ) { return 0x82071FFC;  }
		/* 82072054h case   11:*/		return 0x82072058;
		  /* 82072058h */ case   12:  		/* cmplwi CR6, R3, 0 */
		/* 82072058h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82072058h case   12:*/		return 0x8207205C;
		  /* 8207205Ch */ case   13:  		/* bc 12, CR6_EQ, -96 */
		/* 8207205Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82071FFC;  }
		/* 8207205Ch case   13:*/		return 0x82072060;
		  /* 82072060h */ case   14:  		/* li R5, 17 */
		/* 82072060h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x11);
		/* 82072060h case   14:*/		return 0x82072064;
		  /* 82072064h */ case   15:  		/* b -116 */
		/* 82072064h case   15:*/		return 0x82071FF0;
		/* 82072064h case   15:*/		return 0x82072068;
		  /* 82072068h */ case   16:  		/* lwz R4, <#[R31 + 8]> */
		/* 82072068h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82072068h case   16:*/		return 0x8207206C;
		  /* 8207206Ch */ case   17:  		/* cmplwi CR6, R4, 0 */
		/* 8207206Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8207206Ch case   17:*/		return 0x82072070;
		  /* 82072070h */ case   18:  		/* bc 12, CR6_EQ, 28 */
		/* 82072070h case   18:*/		if ( regs.CR[6].eq ) { return 0x8207208C;  }
		/* 82072070h case   18:*/		return 0x82072074;
		  /* 82072074h */ case   19:  		/* cmplwi CR6, R3, 0 */
		/* 82072074h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82072074h case   19:*/		return 0x82072078;
		  /* 82072078h */ case   20:  		/* bc 12, CR6_EQ, 20 */
		/* 82072078h case   20:*/		if ( regs.CR[6].eq ) { return 0x8207208C;  }
		/* 82072078h case   20:*/		return 0x8207207C;
		  /* 8207207Ch */ case   21:  		/* li R7, 0 */
		/* 8207207Ch case   21:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8207207Ch case   21:*/		return 0x82072080;
		  /* 82072080h */ case   22:  		/* mr R6, R31 */
		/* 82072080h case   22:*/		regs.R6 = regs.R31;
		/* 82072080h case   22:*/		return 0x82072084;
		  /* 82072084h */ case   23:  		/* li R5, 15 */
		/* 82072084h case   23:*/		cpu::op::li<0>(regs,&regs.R5,0xF);
		/* 82072084h case   23:*/		return 0x82072088;
		  /* 82072088h */ case   24:  		/* bl 3232 */
		/* 82072088h case   24:*/		regs.LR = 0x8207208C; return 0x82072D28;
		/* 82072088h case   24:*/		return 0x8207208C;
	}
	return 0x8207208C;
} // Block from 82072028h-8207208Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8207208Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207208C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207208C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207208C);
		  /* 8207208Ch */ case    0:  		/* mr R3, R31 */
		/* 8207208Ch case    0:*/		regs.R3 = regs.R31;
		/* 8207208Ch case    0:*/		return 0x82072090;
		  /* 82072090h */ case    1:  		/* bl 11064 */
		/* 82072090h case    1:*/		regs.LR = 0x82072094; return 0x82074BC8;
		/* 82072090h case    1:*/		return 0x82072094;
		  /* 82072094h */ case    2:  		/* b 144 */
		/* 82072094h case    2:*/		return 0x82072124;
		/* 82072094h case    2:*/		return 0x82072098;
		  /* 82072098h */ case    3:  		/* lwz R4, <#[R31 + 8]> */
		/* 82072098h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 82072098h case    3:*/		return 0x8207209C;
		  /* 8207209Ch */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 8207209Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8207209Ch case    4:*/		return 0x820720A0;
		  /* 820720A0h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 820720A0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820720BC;  }
		/* 820720A0h case    5:*/		return 0x820720A4;
		  /* 820720A4h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 820720A4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820720A4h case    6:*/		return 0x820720A8;
		  /* 820720A8h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820720A8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820720BC;  }
		/* 820720A8h case    7:*/		return 0x820720AC;
		  /* 820720ACh */ case    8:  		/* li R7, 0 */
		/* 820720ACh case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820720ACh case    8:*/		return 0x820720B0;
		  /* 820720B0h */ case    9:  		/* mr R6, R31 */
		/* 820720B0h case    9:*/		regs.R6 = regs.R31;
		/* 820720B0h case    9:*/		return 0x820720B4;
		  /* 820720B4h */ case   10:  		/* li R5, 21 */
		/* 820720B4h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x15);
		/* 820720B4h case   10:*/		return 0x820720B8;
		  /* 820720B8h */ case   11:  		/* bl 3184 */
		/* 820720B8h case   11:*/		regs.LR = 0x820720BC; return 0x82072D28;
		/* 820720B8h case   11:*/		return 0x820720BC;
	}
	return 0x820720BC;
} // Block from 8207208Ch-820720BCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820720BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820720BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820720BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820720BC);
		  /* 820720BCh */ case    0:  		/* mr R3, R31 */
		/* 820720BCh case    0:*/		regs.R3 = regs.R31;
		/* 820720BCh case    0:*/		return 0x820720C0;
		  /* 820720C0h */ case    1:  		/* bl 10040 */
		/* 820720C0h case    1:*/		regs.LR = 0x820720C4; return 0x820747F8;
		/* 820720C0h case    1:*/		return 0x820720C4;
		  /* 820720C4h */ case    2:  		/* b 96 */
		/* 820720C4h case    2:*/		return 0x82072124;
		/* 820720C4h case    2:*/		return 0x820720C8;
		  /* 820720C8h */ case    3:  		/* lwz R4, <#[R31 + 8]> */
		/* 820720C8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 820720C8h case    3:*/		return 0x820720CC;
		  /* 820720CCh */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 820720CCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820720CCh case    4:*/		return 0x820720D0;
		  /* 820720D0h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 820720D0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820720EC;  }
		/* 820720D0h case    5:*/		return 0x820720D4;
		  /* 820720D4h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 820720D4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820720D4h case    6:*/		return 0x820720D8;
		  /* 820720D8h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 820720D8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820720EC;  }
		/* 820720D8h case    7:*/		return 0x820720DC;
		  /* 820720DCh */ case    8:  		/* li R7, 0 */
		/* 820720DCh case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820720DCh case    8:*/		return 0x820720E0;
		  /* 820720E0h */ case    9:  		/* mr R6, R31 */
		/* 820720E0h case    9:*/		regs.R6 = regs.R31;
		/* 820720E0h case    9:*/		return 0x820720E4;
		  /* 820720E4h */ case   10:  		/* li R5, 23 */
		/* 820720E4h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x17);
		/* 820720E4h case   10:*/		return 0x820720E8;
		  /* 820720E8h */ case   11:  		/* bl 3136 */
		/* 820720E8h case   11:*/		regs.LR = 0x820720EC; return 0x82072D28;
		/* 820720E8h case   11:*/		return 0x820720EC;
	}
	return 0x820720EC;
} // Block from 820720BCh-820720ECh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820720ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820720EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820720EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820720EC);
		  /* 820720ECh */ case    0:  		/* mr R3, R31 */
		/* 820720ECh case    0:*/		regs.R3 = regs.R31;
		/* 820720ECh case    0:*/		return 0x820720F0;
		  /* 820720F0h */ case    1:  		/* bl 15072 */
		/* 820720F0h case    1:*/		regs.LR = 0x820720F4; return 0x82075BD0;
		/* 820720F0h case    1:*/		return 0x820720F4;
		  /* 820720F4h */ case    2:  		/* b 48 */
		/* 820720F4h case    2:*/		return 0x82072124;
		/* 820720F4h case    2:*/		return 0x820720F8;
		  /* 820720F8h */ case    3:  		/* lwz R4, <#[R31 + 8]> */
		/* 820720F8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 820720F8h case    3:*/		return 0x820720FC;
		  /* 820720FCh */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 820720FCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820720FCh case    4:*/		return 0x82072100;
		  /* 82072100h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 82072100h case    5:*/		if ( regs.CR[6].eq ) { return 0x8207211C;  }
		/* 82072100h case    5:*/		return 0x82072104;
		  /* 82072104h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 82072104h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82072104h case    6:*/		return 0x82072108;
		  /* 82072108h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82072108h case    7:*/		if ( regs.CR[6].eq ) { return 0x8207211C;  }
		/* 82072108h case    7:*/		return 0x8207210C;
		  /* 8207210Ch */ case    8:  		/* li R7, 0 */
		/* 8207210Ch case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8207210Ch case    8:*/		return 0x82072110;
		  /* 82072110h */ case    9:  		/* mr R6, R31 */
		/* 82072110h case    9:*/		regs.R6 = regs.R31;
		/* 82072110h case    9:*/		return 0x82072114;
		  /* 82072114h */ case   10:  		/* li R5, 25 */
		/* 82072114h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x19);
		/* 82072114h case   10:*/		return 0x82072118;
		  /* 82072118h */ case   11:  		/* bl 3088 */
		/* 82072118h case   11:*/		regs.LR = 0x8207211C; return 0x82072D28;
		/* 82072118h case   11:*/		return 0x8207211C;
	}
	return 0x8207211C;
} // Block from 820720ECh-8207211Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8207211Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207211C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207211C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207211C);
		  /* 8207211Ch */ case    0:  		/* mr R3, R31 */
		/* 8207211Ch case    0:*/		regs.R3 = regs.R31;
		/* 8207211Ch case    0:*/		return 0x82072120;
		  /* 82072120h */ case    1:  		/* bl 15096 */
		/* 82072120h case    1:*/		regs.LR = 0x82072124; return 0x82075C18;
		/* 82072120h case    1:*/		return 0x82072124;
	}
	return 0x82072124;
} // Block from 8207211Ch-82072124h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072124);
		  /* 82072124h */ case    0:  		/* lis R4, 9344 */
		/* 82072124h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 82072124h case    0:*/		return 0x82072128;
		  /* 82072128h */ case    1:  		/* mr R3, R31 */
		/* 82072128h case    1:*/		regs.R3 = regs.R31;
		/* 82072128h case    1:*/		return 0x8207212C;
		  /* 8207212Ch */ case    2:  		/* bl 90636 */
		/* 8207212Ch case    2:*/		regs.LR = 0x82072130; return 0x82088338;
		/* 8207212Ch case    2:*/		return 0x82072130;
		  /* 82072130h */ case    3:  		/* addi R1, R1, 112 */
		/* 82072130h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82072130h case    3:*/		return 0x82072134;
		  /* 82072134h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 82072134h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82072134h case    4:*/		return 0x82072138;
		  /* 82072138h */ case    5:  		/* mtspr LR, R12 */
		/* 82072138h case    5:*/		regs.LR = regs.R12;
		/* 82072138h case    5:*/		return 0x8207213C;
		  /* 8207213Ch */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 8207213Ch case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8207213Ch case    6:*/		return 0x82072140;
		  /* 82072140h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 82072140h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82072140h case    7:*/		return 0x82072144;
		  /* 82072144h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82072144h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82072144h case    8:*/		return 0x82072148;
	}
	return 0x82072148;
} // Block from 82072124h-82072148h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82072148h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072148);
		  /* 82072148h */ case    0:  		/* mfspr R12, LR */
		/* 82072148h case    0:*/		regs.R12 = regs.LR;
		/* 82072148h case    0:*/		return 0x8207214C;
		  /* 8207214Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8207214Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8207214Ch case    1:*/		return 0x82072150;
		  /* 82072150h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82072150h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82072150h case    2:*/		return 0x82072154;
		  /* 82072154h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82072154h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82072154h case    3:*/		return 0x82072158;
		  /* 82072158h */ case    4:  		/* mr R31, R3 */
		/* 82072158h case    4:*/		regs.R31 = regs.R3;
		/* 82072158h case    4:*/		return 0x8207215C;
		  /* 8207215Ch */ case    5:  		/* addi R11, R3, 4 */
		/* 8207215Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x4);
		/* 8207215Ch case    5:*/		return 0x82072160;
		  /* 82072160h */ case    6:  		/* mfmsr R9, MSR */
		/* 82072160h case    6:*/		regs.R9 = regs.MSR;
		/* 82072160h case    6:*/		return 0x82072164;
		  /* 82072164h */ case    7:  		/* mtmsrd MSR, R13 */
		/* 82072164h case    7:*/		regs.MSR = regs.R13;
		/* 82072164h case    7:*/		return 0x82072168;
		  /* 82072168h */ case    8:  		/* lwarx R10, <#[R11]> */
		/* 82072168h case    8:*/		cpu::mem::lwarx( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82072168h case    8:*/		return 0x8207216C;
		  /* 8207216Ch */ case    9:  		/* addi R10, R10, -1 */
		/* 8207216Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8207216Ch case    9:*/		return 0x82072170;
		  /* 82072170h */ case   10:  		/* stwcx. R10, <#[R11]> */
		/* 82072170h case   10:*/		cpu::mem::stwcx( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82072170h case   10:*/		return 0x82072174;
		  /* 82072174h */ case   11:  		/* mtmsrd MSR, R9 */
		/* 82072174h case   11:*/		regs.MSR = regs.R9;
		/* 82072174h case   11:*/		return 0x82072178;
		  /* 82072178h */ case   12:  		/* bc 4, CR0_EQ, -24 */
		/* 82072178h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82072160;  }
		/* 82072178h case   12:*/		return 0x8207217C;
		  /* 8207217Ch */ case   13:  		/* mr R3, R10 */
		/* 8207217Ch case   13:*/		regs.R3 = regs.R10;
		/* 8207217Ch case   13:*/		return 0x82072180;
		  /* 82072180h */ case   14:  		/* cmplwi CR6, R10, 0 */
		/* 82072180h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82072180h case   14:*/		return 0x82072184;
		  /* 82072184h */ case   15:  		/* bc 4, CR6_EQ, 48 */
		/* 82072184h case   15:*/		if ( !regs.CR[6].eq ) { return 0x820721B4;  }
		/* 82072184h case   15:*/		return 0x82072188;
		  /* 82072188h */ case   16:  		/* lwz R11, <#[R31]> */
		/* 82072188h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82072188h case   16:*/		return 0x8207218C;
		  /* 8207218Ch */ case   17:  		/* rlwinm R10, R11, 0, 28, 31 */
		/* 8207218Ch case   17:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R11);
		/* 8207218Ch case   17:*/		return 0x82072190;
		  /* 82072190h */ case   18:  		/* cmplwi CR6, R10, 4 */
		/* 82072190h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 82072190h case   18:*/		return 0x82072194;
		  /* 82072194h */ case   19:  		/* bc 4, CR6_EQ, 20 */
		/* 82072194h case   19:*/		if ( !regs.CR[6].eq ) { return 0x820721A8;  }
		/* 82072194h case   19:*/		return 0x82072198;
		  /* 82072198h */ case   20:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 82072198h case   20:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 82072198h case   20:*/		return 0x8207219C;
		  /* 8207219Ch */ case   21:  		/* bc 12, CR0_EQ, 12 */
		/* 8207219Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x820721A8;  }
		/* 8207219Ch case   21:*/		return 0x820721A0;
		  /* 820721A0h */ case   22:  		/* lwz R3, <#[R31 + 24]> */
		/* 820721A0h case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820721A0h case   22:*/		return 0x820721A4;
		  /* 820721A4h */ case   23:  		/* bl -92 */
		/* 820721A4h case   23:*/		regs.LR = 0x820721A8; return 0x82072148;
		/* 820721A4h case   23:*/		return 0x820721A8;
	}
	return 0x820721A8;
} // Block from 82072148h-820721A8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820721A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820721A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820721A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820721A8);
		  /* 820721A8h */ case    0:  		/* mr R3, R31 */
		/* 820721A8h case    0:*/		regs.R3 = regs.R31;
		/* 820721A8h case    0:*/		return 0x820721AC;
		  /* 820721ACh */ case    1:  		/* bl -780 */
		/* 820721ACh case    1:*/		regs.LR = 0x820721B0; return 0x82071EA0;
		/* 820721ACh case    1:*/		return 0x820721B0;
		  /* 820721B0h */ case    2:  		/* li R3, 0 */
		/* 820721B0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820721B0h case    2:*/		return 0x820721B4;
	}
	return 0x820721B4;
} // Block from 820721A8h-820721B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820721B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820721B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820721B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820721B4);
		  /* 820721B4h */ case    0:  		/* addi R1, R1, 96 */
		/* 820721B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820721B4h case    0:*/		return 0x820721B8;
		  /* 820721B8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820721B8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820721B8h case    1:*/		return 0x820721BC;
		  /* 820721BCh */ case    2:  		/* mtspr LR, R12 */
		/* 820721BCh case    2:*/		regs.LR = regs.R12;
		/* 820721BCh case    2:*/		return 0x820721C0;
		  /* 820721C0h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820721C0h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820721C0h case    3:*/		return 0x820721C4;
		  /* 820721C4h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820721C4h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820721C4h case    4:*/		return 0x820721C8;
	}
	return 0x820721C8;
} // Block from 820721B4h-820721C8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820721C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820721C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820721C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820721C8);
		  /* 820721C8h */ case    0:  		/* mfspr R12, LR */
		/* 820721C8h case    0:*/		regs.R12 = regs.LR;
		/* 820721C8h case    0:*/		return 0x820721CC;
		  /* 820721CCh */ case    1:  		/* bl 127120 */
		/* 820721CCh case    1:*/		regs.LR = 0x820721D0; return 0x8209125C;
		/* 820721CCh case    1:*/		return 0x820721D0;
		  /* 820721D0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820721D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820721D0h case    2:*/		return 0x820721D4;
		  /* 820721D4h */ case    3:  		/* lis R11, -32216 */
		/* 820721D4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 820721D4h case    3:*/		return 0x820721D8;
		  /* 820721D8h */ case    4:  		/* mr R30, R4 */
		/* 820721D8h case    4:*/		regs.R30 = regs.R4;
		/* 820721D8h case    4:*/		return 0x820721DC;
		  /* 820721DCh */ case    5:  		/* mr R29, R5 */
		/* 820721DCh case    5:*/		regs.R29 = regs.R5;
		/* 820721DCh case    5:*/		return 0x820721E0;
		  /* 820721E0h */ case    6:  		/* lwz R11, <#[R11 + 28728]> */
		/* 820721E0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00007038) );
		/* 820721E0h case    6:*/		return 0x820721E4;
		  /* 820721E4h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820721E4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820721E4h case    7:*/		return 0x820721E8;
	}
	return 0x820721E8;
} // Block from 820721C8h-820721E8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820721E8h
// Function '?P_QPC@D3D@@YAXPAUD3DDevice@@PAUD3DPerfCounters@@K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820721E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820721E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820721E8);
		  /* 820721E8h */ case    0:  		/* bc 4, CR6_EQ, 96 */
		/* 820721E8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82072248;  }
		/* 820721E8h case    0:*/		return 0x820721EC;
		  /* 820721ECh */ case    1:  		/* rlwinm. R11, R6, 0, 31, 31 */
		/* 820721ECh case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R6);
		/* 820721ECh case    1:*/		return 0x820721F0;
		  /* 820721F0h */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 820721F0h case    2:*/		if ( regs.CR[0].eq ) { return 0x82072218;  }
		/* 820721F0h case    2:*/		return 0x820721F4;
		  /* 820721F4h */ case    3:  		/* lbz R11, <#[R3 + 11072]> */
		/* 820721F4h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B40) );
		/* 820721F4h case    3:*/		return 0x820721F8;
		  /* 820721F8h */ case    4:  		/* li R12, 3 */
		/* 820721F8h case    4:*/		cpu::op::li<0>(regs,&regs.R12,0x3);
		/* 820721F8h case    4:*/		return 0x820721FC;
		  /* 820721FCh */ case    5:  		/* ori R11, R11, 192 */
		/* 820721FCh case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xC0);
		/* 820721FCh case    5:*/		return 0x82072200;
		  /* 82072200h */ case    6:  		/* rldicr R12, R12, 62, 1 */
		/* 82072200h case    6:*/		cpu::op::rldicr<0,62,1>(regs,&regs.R12,regs.R12);
		/* 82072200h case    6:*/		return 0x82072204;
		  /* 82072204h */ case    7:  		/* stb R11, <#[R3 + 11072]> */
		/* 82072204h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00002B40) );
		/* 82072204h case    7:*/		return 0x82072208;
		  /* 82072208h */ case    8:  		/* ld R11, <#[R3 + 32]> */
		/* 82072208h case    8:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82072208h case    8:*/		return 0x8207220C;
		  /* 8207220Ch */ case    9:  		/* or R11, R11, R12 */
		/* 8207220Ch case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8207220Ch case    9:*/		return 0x82072210;
		  /* 82072210h */ case   10:  		/* std R11, <#[R3 + 32]> */
		/* 82072210h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82072210h case   10:*/		return 0x82072214;
		  /* 82072214h */ case   11:  		/* b 280 */
		/* 82072214h case   11:*/		return 0x8207232C;
		/* 82072214h case   11:*/		return 0x82072218;
	}
	return 0x82072218;
} // Block from 820721E8h-82072218h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82072218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072218);
		  /* 82072218h */ case    0:  		/* bl 2075872 */
		/* 82072218h case    0:*/		regs.LR = 0x8207221C; return 0x8226CEF8;
		/* 82072218h case    0:*/		return 0x8207221C;
		  /* 8207221Ch */ case    1:  		/* cmpwi CR6, R3, 2 */
		/* 8207221Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 8207221Ch case    1:*/		return 0x82072220;
		  /* 82072220h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82072220h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82072230;  }
		/* 82072220h case    2:*/		return 0x82072224;
		  /* 82072224h */ case    3:  		/* lis R11, -32256 */
		/* 82072224h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82072224h case    3:*/		return 0x82072228;
		  /* 82072228h */ case    4:  		/* lwz R11, <#[R11 + 1452]> */
		/* 82072228h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005AC) );
		/* 82072228h case    4:*/		return 0x8207222C;
		  /* 8207222Ch */ case    5:  		/* b 12 */
		/* 8207222Ch case    5:*/		return 0x82072238;
		/* 8207222Ch case    5:*/		return 0x82072230;
	}
	return 0x82072230;
} // Block from 82072218h-82072230h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82072230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072230);
		  /* 82072230h */ case    0:  		/* lis R11, -32256 */
		/* 82072230h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82072230h case    0:*/		return 0x82072234;
		  /* 82072234h */ case    1:  		/* lwz R11, <#[R11 + 1456]> */
		/* 82072234h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005B0) );
		/* 82072234h case    1:*/		return 0x82072238;
	}
	return 0x82072238;
} // Block from 82072230h-82072238h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072238);
		  /* 82072238h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82072238h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82072238h case    0:*/		return 0x8207223C;
		  /* 8207223Ch */ case    1:  		/* li R10, 1 */
		/* 8207223Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8207223Ch case    1:*/		return 0x82072240;
		  /* 82072240h */ case    2:  		/* stw R10, <#[R11 + 12256]> */
		/* 82072240h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00002FE0) );
		/* 82072240h case    2:*/		return 0x82072244;
		  /* 82072244h */ case    3:  		/* b 232 */
		/* 82072244h case    3:*/		return 0x8207232C;
		/* 82072244h case    3:*/		return 0x82072248;
	}
	return 0x82072248;
} // Block from 82072238h-82072248h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82072248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072248);
		  /* 82072248h */ case    0:  		/* bl 2075824 */
		/* 82072248h case    0:*/		regs.LR = 0x8207224C; return 0x8226CEF8;
		/* 82072248h case    0:*/		return 0x8207224C;
		  /* 8207224Ch */ case    1:  		/* cmpwi CR6, R3, 2 */
		/* 8207224Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 8207224Ch case    1:*/		return 0x82072250;
		  /* 82072250h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82072250h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82072260;  }
		/* 82072250h case    2:*/		return 0x82072254;
		  /* 82072254h */ case    3:  		/* lis R11, -32256 */
		/* 82072254h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82072254h case    3:*/		return 0x82072258;
		  /* 82072258h */ case    4:  		/* lwz R11, <#[R11 + 1452]> */
		/* 82072258h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005AC) );
		/* 82072258h case    4:*/		return 0x8207225C;
		  /* 8207225Ch */ case    5:  		/* b 12 */
		/* 8207225Ch case    5:*/		return 0x82072268;
		/* 8207225Ch case    5:*/		return 0x82072260;
	}
	return 0x82072260;
} // Block from 82072248h-82072260h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82072260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072260);
		  /* 82072260h */ case    0:  		/* lis R11, -32256 */
		/* 82072260h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82072260h case    0:*/		return 0x82072264;
		  /* 82072264h */ case    1:  		/* lwz R11, <#[R11 + 1456]> */
		/* 82072264h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005B0) );
		/* 82072264h case    1:*/		return 0x82072268;
	}
	return 0x82072268;
} // Block from 82072260h-82072268h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072268);
		  /* 82072268h */ case    0:  		/* lwz R31, <#[R11]> */
		/* 82072268h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82072268h case    0:*/		return 0x8207226C;
		  /* 8207226Ch */ case    1:  		/* rlwinm R11, R30, 12, 20, 31 */
		/* 8207226Ch case    1:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R30);
		/* 8207226Ch case    1:*/		return 0x82072270;
		  /* 82072270h */ case    2:  		/* rlwinm R10, R30, 0, 3, 31 */
		/* 82072270h case    2:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R30);
		/* 82072270h case    2:*/		return 0x82072274;
		  /* 82072274h */ case    3:  		/* addi R11, R11, 512 */
		/* 82072274h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82072274h case    3:*/		return 0x82072278;
		  /* 82072278h */ case    4:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82072278h case    4:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82072278h case    4:*/		return 0x8207227C;
		  /* 8207227Ch */ case    5:  		/* add R30, R11, R10 */
		/* 8207227Ch case    5:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 8207227Ch case    5:*/		return 0x82072280;
		  /* 82072280h */ case    6:  		/* add R29, R30, R29 */
		/* 82072280h case    6:*/		cpu::op::add<0>(regs,&regs.R29,regs.R30,regs.R29);
		/* 82072280h case    6:*/		return 0x82072284;
		  /* 82072284h */ case    7:  		/* bl 90388 */
		/* 82072284h case    7:*/		regs.LR = 0x82072288; return 0x82088398;
		/* 82072284h case    7:*/		return 0x82072288;
		  /* 82072288h */ case    8:  		/* lwz R11, <#[R31 + 11016]> */
		/* 82072288h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B08) );
		/* 82072288h case    8:*/		return 0x8207228C;
		  /* 8207228Ch */ case    9:  		/* cmplw CR6, R11, R3 */
		/* 8207228Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 8207228Ch case    9:*/		return 0x82072290;
		  /* 82072290h */ case   10:  		/* bc 12, CR6_EQ, 24 */
		/* 82072290h case   10:*/		if ( regs.CR[6].eq ) { return 0x820722A8;  }
		/* 82072290h case   10:*/		return 0x82072294;
		  /* 82072294h */ case   11:  		/* mr R5, R29 */
		/* 82072294h case   11:*/		regs.R5 = regs.R29;
		/* 82072294h case   11:*/		return 0x82072298;
		  /* 82072298h */ case   12:  		/* mr R4, R30 */
		/* 82072298h case   12:*/		regs.R4 = regs.R30;
		/* 82072298h case   12:*/		return 0x8207229C;
		  /* 8207229Ch */ case   13:  		/* addi R3, R31, 12248 */
		/* 8207229Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x2FD8);
		/* 8207229Ch case   13:*/		return 0x820722A0;
		  /* 820722A0h */ case   14:  		/* bl 1792 */
		/* 820722A0h case   14:*/		regs.LR = 0x820722A4; return 0x820729A0;
		/* 820722A0h case   14:*/		return 0x820722A4;
		  /* 820722A4h */ case   15:  		/* b 136 */
		/* 820722A4h case   15:*/		return 0x8207232C;
		/* 820722A4h case   15:*/		return 0x820722A8;
	}
	return 0x820722A8;
} // Block from 82072268h-820722A8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820722A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820722A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820722A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820722A8);
		  /* 820722A8h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 820722A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820722A8h case    0:*/		return 0x820722AC;
		  /* 820722ACh */ case    1:  		/* lwz R3, <#[R31 + 48]> */
		/* 820722ACh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 820722ACh case    1:*/		return 0x820722B0;
		  /* 820722B0h */ case    2:  		/* cmplw CR6, R3, R11 */
		/* 820722B0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820722B0h case    2:*/		return 0x820722B4;
		  /* 820722B4h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 820722B4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820722C0;  }
		/* 820722B4h case    3:*/		return 0x820722B8;
		  /* 820722B8h */ case    4:  		/* mr R3, R31 */
		/* 820722B8h case    4:*/		regs.R3 = regs.R31;
		/* 820722B8h case    4:*/		return 0x820722BC;
		  /* 820722BCh */ case    5:  		/* bl 7756 */
		/* 820722BCh case    5:*/		regs.LR = 0x820722C0; return 0x82074108;
		/* 820722BCh case    5:*/		return 0x820722C0;
	}
	return 0x820722C0;
} // Block from 820722A8h-820722C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820722C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820722C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820722C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820722C0);
		  /* 820722C0h */ case    0:  		/* li R11, 2609 */
		/* 820722C0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xA31);
		/* 820722C0h case    0:*/		return 0x820722C4;
		  /* 820722C4h */ case    1:  		/* lis R10, 768 */
		/* 820722C4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x300);
		/* 820722C4h case    1:*/		return 0x820722C8;
		  /* 820722C8h */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 820722C8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820722C8h case    2:*/		return 0x820722CC;
		  /* 820722CCh */ case    3:  		/* lis R11, 1 */
		/* 820722CCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 820722CCh case    3:*/		return 0x820722D0;
		  /* 820722D0h */ case    4:  		/* addi R9, R29, 4095 */
		/* 820722D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R29,0xFFF);
		/* 820722D0h case    4:*/		return 0x820722D4;
		  /* 820722D4h */ case    5:  		/* ori R11, R11, 2607 */
		/* 820722D4h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xA2F);
		/* 820722D4h case    5:*/		return 0x820722D8;
		  /* 820722D8h */ case    6:  		/* rlwinm R8, R30, 0, 0, 19 */
		/* 820722D8h case    6:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R8,regs.R30);
		/* 820722D8h case    6:*/		return 0x820722DC;
		  /* 820722DCh */ case    7:  		/* rlwinm R9, R9, 0, 0, 19 */
		/* 820722DCh case    7:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R9,regs.R9);
		/* 820722DCh case    7:*/		return 0x820722E0;
		  /* 820722E0h */ case    8:  		/* stwu R10, <#[R3 + 4]> */
		/* 820722E0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820722E0h case    8:*/		return 0x820722E4;
		  /* 820722E4h */ case    9:  		/* lis R7, -16380 */
		/* 820722E4h case    9:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFFC004);
		/* 820722E4h case    9:*/		return 0x820722E8;
		  /* 820722E8h */ case   10:  		/* subf R10, R8, R9 */
		/* 820722E8h case   10:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R8,regs.R9);
		/* 820722E8h case   10:*/		return 0x820722EC;
		  /* 820722ECh */ case   11:  		/* ori R9, R7, 15360 */
		/* 820722ECh case   11:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R7,0x3C00);
		/* 820722ECh case   11:*/		return 0x820722F0;
		  /* 820722F0h */ case   12:  		/* li R7, 3 */
		/* 820722F0h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 820722F0h case   12:*/		return 0x820722F4;
		  /* 820722F4h */ case   13:  		/* li R6, 2609 */
		/* 820722F4h case   13:*/		cpu::op::li<0>(regs,&regs.R6,0xA31);
		/* 820722F4h case   13:*/		return 0x820722F8;
		  /* 820722F8h */ case   14:  		/* stwu R11, <#[R3 + 4]> */
		/* 820722F8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820722F8h case   14:*/		return 0x820722FC;
		  /* 820722FCh */ case   15:  		/* li R5, 0 */
		/* 820722FCh case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820722FCh case   15:*/		return 0x82072300;
		  /* 82072300h */ case   16:  		/* lis R4, -32768 */
		/* 82072300h case   16:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8000);
		/* 82072300h case   16:*/		return 0x82072304;
		  /* 82072304h */ case   17:  		/* li R11, 8 */
		/* 82072304h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 82072304h case   17:*/		return 0x82072308;
		  /* 82072308h */ case   18:  		/* stwu R10, <#[R3 + 4]> */
		/* 82072308h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82072308h case   18:*/		return 0x8207230C;
		  /* 8207230Ch */ case   19:  		/* stwu R8, <#[R3 + 4]> */
		/* 8207230Ch case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207230Ch case   19:*/		return 0x82072310;
		  /* 82072310h */ case   20:  		/* stwu R9, <#[R3 + 4]> */
		/* 82072310h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82072310h case   20:*/		return 0x82072314;
		  /* 82072314h */ case   21:  		/* stwu R7, <#[R3 + 4]> */
		/* 82072314h case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82072314h case   21:*/		return 0x82072318;
		  /* 82072318h */ case   22:  		/* stwu R6, <#[R3 + 4]> */
		/* 82072318h case   22:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82072318h case   22:*/		return 0x8207231C;
		  /* 8207231Ch */ case   23:  		/* stwu R5, <#[R3 + 4]> */
		/* 8207231Ch case   23:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207231Ch case   23:*/		return 0x82072320;
		  /* 82072320h */ case   24:  		/* stwu R4, <#[R3 + 4]> */
		/* 82072320h case   24:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82072320h case   24:*/		return 0x82072324;
		  /* 82072324h */ case   25:  		/* stwu R11, <#[R3 + 4]> */
		/* 82072324h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82072324h case   25:*/		return 0x82072328;
		  /* 82072328h */ case   26:  		/* stw R3, <#[R31 + 48]> */
		/* 82072328h case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82072328h case   26:*/		return 0x8207232C;
	}
	return 0x8207232C;
} // Block from 820722C0h-8207232Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8207232Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207232C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207232C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207232C);
		  /* 8207232Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8207232Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8207232Ch case    0:*/		return 0x82072330;
		  /* 82072330h */ case    1:  		/* b 126844 */
		/* 82072330h case    1:*/		return 0x820912AC;
		/* 82072330h case    1:*/		return 0x82072334;
		  /* 82072334h */ case    2:  		/* nop */
		/* 82072334h case    2:*/		cpu::op::nop();
		/* 82072334h case    2:*/		return 0x82072338;
	}
	return 0x82072338;
} // Block from 8207232Ch-82072338h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82072338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072338);
		  /* 82072338h */ case    0:  		/* mfspr R12, LR */
		/* 82072338h case    0:*/		regs.R12 = regs.LR;
		/* 82072338h case    0:*/		return 0x8207233C;
		  /* 8207233Ch */ case    1:  		/* bl 126716 */
		/* 8207233Ch case    1:*/		regs.LR = 0x82072340; return 0x82091238;
		/* 8207233Ch case    1:*/		return 0x82072340;
		  /* 82072340h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82072340h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82072340h case    2:*/		return 0x82072344;
		  /* 82072344h */ case    3:  		/* rldicl R11, R4, 32, 32 */
		/* 82072344h case    3:*/		cpu::op::rldicl<0,32,32>(regs,&regs.R11,regs.R4);
		/* 82072344h case    3:*/		return 0x82072348;
		  /* 82072348h */ case    4:  		/* mr R26, R3 */
		/* 82072348h case    4:*/		regs.R26 = regs.R3;
		/* 82072348h case    4:*/		return 0x8207234C;
		  /* 8207234Ch */ case    5:  		/* mr R30, R4 */
		/* 8207234Ch case    5:*/		regs.R30 = regs.R4;
		/* 8207234Ch case    5:*/		return 0x82072350;
		  /* 82072350h */ case    6:  		/* mr R27, R5 */
		/* 82072350h case    6:*/		regs.R27 = regs.R5;
		/* 82072350h case    6:*/		return 0x82072354;
		  /* 82072354h */ case    7:  		/* mr R20, R6 */
		/* 82072354h case    7:*/		regs.R20 = regs.R6;
		/* 82072354h case    7:*/		return 0x82072358;
		  /* 82072358h */ case    8:  		/* mr R21, R7 */
		/* 82072358h case    8:*/		regs.R21 = regs.R7;
		/* 82072358h case    8:*/		return 0x8207235C;
		  /* 8207235Ch */ case    9:  		/* mr R22, R8 */
		/* 8207235Ch case    9:*/		regs.R22 = regs.R8;
		/* 8207235Ch case    9:*/		return 0x82072360;
		  /* 82072360h */ case   10:  		/* mr R23, R9 */
		/* 82072360h case   10:*/		regs.R23 = regs.R9;
		/* 82072360h case   10:*/		return 0x82072364;
		  /* 82072364h */ case   11:  		/* mr R24, R10 */
		/* 82072364h case   11:*/		regs.R24 = regs.R10;
		/* 82072364h case   11:*/		return 0x82072368;
		  /* 82072368h */ case   12:  		/* cmpldi CR6, R4, 0 */
		/* 82072368h case   12:*/		cpu::op::cmpldi<6>(regs,regs.R4,0x00000000);
		/* 82072368h case   12:*/		return 0x8207236C;
		  /* 8207236Ch */ case   13:  		/* rlwinm R31, R11, 0, 27, 31 */
		/* 8207236Ch case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R31,regs.R11);
		/* 8207236Ch case   13:*/		return 0x82072370;
		  /* 82072370h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 82072370h case   14:*/		if ( regs.CR[6].eq ) { return 0x82072380;  }
		/* 82072370h case   14:*/		return 0x82072374;
		  /* 82072374h */ case   15:  		/* lwz R11, <#[R1 + 276]> */
		/* 82072374h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000114) );
		/* 82072374h case   15:*/		return 0x82072378;
		  /* 82072378h */ case   16:  		/* ori R25, R11, 2 */
		/* 82072378h case   16:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R11,0x2);
		/* 82072378h case   16:*/		return 0x8207237C;
		  /* 8207237Ch */ case   17:  		/* b 8 */
		/* 8207237Ch case   17:*/		return 0x82072384;
		/* 8207237Ch case   17:*/		return 0x82072380;
	}
	return 0x82072380;
} // Block from 82072338h-82072380h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82072380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072380);
		  /* 82072380h */ case    0:  		/* lwz R25, <#[R1 + 276]> */
		/* 82072380h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000114) );
		/* 82072380h case    0:*/		return 0x82072384;
	}
	return 0x82072384;
} // Block from 82072380h-82072384h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82072384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072384);
		  /* 82072384h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 82072384h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82072384h case    0:*/		return 0x82072388;
		  /* 82072388h */ case    1:  		/* mr R10, R26 */
		/* 82072388h case    1:*/		regs.R10 = regs.R26;
		/* 82072388h case    1:*/		return 0x8207238C;
		  /* 8207238Ch */ case    2:  		/* rlwinm R9, R11, 0, 28, 31 */
		/* 8207238Ch case    2:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R11);
		/* 8207238Ch case    2:*/		return 0x82072390;
		  /* 82072390h */ case    3:  		/* cmplwi CR6, R9, 4 */
		/* 82072390h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000004);
		/* 82072390h case    3:*/		return 0x82072394;
		  /* 82072394h */ case    4:  		/* bc 4, CR6_EQ, 28 */
		/* 82072394h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820723B0;  }
		/* 82072394h case    4:*/		return 0x82072398;
		  /* 82072398h */ case    5:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 82072398h case    5:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 82072398h case    5:*/		return 0x8207239C;
		  /* 8207239Ch */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 8207239Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820723B0;  }
		/* 8207239Ch case    6:*/		return 0x820723A0;
		  /* 820723A0h */ case    7:  		/* lwz R11, <#[R26 + 24]> */
		/* 820723A0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000018) );
		/* 820723A0h case    7:*/		return 0x820723A4;
		  /* 820723A4h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820723A4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820723A4h case    8:*/		return 0x820723A8;
		  /* 820723A8h */ case    9:  		/* bc 12, CR6_EQ, 8 */
		/* 820723A8h case    9:*/		if ( regs.CR[6].eq ) { return 0x820723B0;  }
		/* 820723A8h case    9:*/		return 0x820723AC;
		  /* 820723ACh */ case   10:  		/* mr R10, R11 */
		/* 820723ACh case   10:*/		regs.R10 = regs.R11;
		/* 820723ACh case   10:*/		return 0x820723B0;
	}
	return 0x820723B0;
} // Block from 82072384h-820723B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820723B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820723B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820723B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820723B0);
		  /* 820723B0h */ case    0:  		/* andi. R11, R25, 4112 */
		/* 820723B0h case    0:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R25,0x1010);
		/* 820723B0h case    0:*/		return 0x820723B4;
		  /* 820723B4h */ case    1:  		/* lis R29, -32256 */
		/* 820723B4h case    1:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8200);
		/* 820723B4h case    1:*/		return 0x820723B8;
		  /* 820723B8h */ case    2:  		/* lis R28, -32256 */
		/* 820723B8h case    2:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8200);
		/* 820723B8h case    2:*/		return 0x820723BC;
		  /* 820723BCh */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 820723BCh case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820723BCh case    3:*/		return 0x820723C0;
		  /* 820723C0h */ case    4:  		/* cmpldi CR6, R30, 0 */
		/* 820723C0h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R30,0x00000000);
		/* 820723C0h case    4:*/		return 0x820723C4;
		  /* 820723C4h */ case    5:  		/* bc 12, CR0_EQ, 64 */
		/* 820723C4h case    5:*/		if ( regs.CR[0].eq ) { return 0x82072404;  }
		/* 820723C4h case    5:*/		return 0x820723C8;
		  /* 820723C8h */ case    6:  		/* bc 12, CR6_EQ, 52 */
		/* 820723C8h case    6:*/		if ( regs.CR[6].eq ) { return 0x820723FC;  }
		/* 820723C8h case    6:*/		return 0x820723CC;
		  /* 820723CCh */ case    7:  		/* bl 2075436 */
		/* 820723CCh case    7:*/		regs.LR = 0x820723D0; return 0x8226CEF8;
		/* 820723CCh case    7:*/		return 0x820723D0;
		  /* 820723D0h */ case    8:  		/* cmpwi CR6, R3, 2 */
		/* 820723D0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 820723D0h case    8:*/		return 0x820723D4;
		  /* 820723D4h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 820723D4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820723E0;  }
		/* 820723D4h case    9:*/		return 0x820723D8;
		  /* 820723D8h */ case   10:  		/* lwz R11, <#[R28 + 1452]> */
		/* 820723D8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000005AC) );
		/* 820723D8h case   10:*/		return 0x820723DC;
		  /* 820723DCh */ case   11:  		/* b 8 */
		/* 820723DCh case   11:*/		return 0x820723E4;
		/* 820723DCh case   11:*/		return 0x820723E0;
	}
	return 0x820723E0;
} // Block from 820723B0h-820723E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820723E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820723E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820723E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820723E0);
		  /* 820723E0h */ case    0:  		/* lwz R11, <#[R29 + 1456]> */
		/* 820723E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000005B0) );
		/* 820723E0h case    0:*/		return 0x820723E4;
	}
	return 0x820723E4;
} // Block from 820723E0h-820723E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820723E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820723E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820723E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820723E4);
		  /* 820723E4h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 820723E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820723E4h case    0:*/		return 0x820723E8;
		  /* 820723E8h */ case    1:  		/* lwz R10, <#[R11 + 24408]> */
		/* 820723E8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00005F58) );
		/* 820723E8h case    1:*/		return 0x820723EC;
		  /* 820723ECh */ case    2:  		/* rlwinm R11, R31, 4, 0, 27 */
		/* 820723ECh case    2:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R31);
		/* 820723ECh case    2:*/		return 0x820723F0;
		  /* 820723F0h */ case    3:  		/* add R11, R10, R11 */
		/* 820723F0h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820723F0h case    3:*/		return 0x820723F4;
		  /* 820723F4h */ case    4:  		/* lwz R31, <#[R11 + 4]> */
		/* 820723F4h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 820723F4h case    4:*/		return 0x820723F8;
		  /* 820723F8h */ case    5:  		/* b 64 */
		/* 820723F8h case    5:*/		return 0x82072438;
		/* 820723F8h case    5:*/		return 0x820723FC;
	}
	return 0x820723FC;
} // Block from 820723E4h-820723FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820723FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820723FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820723FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820723FC);
		  /* 820723FCh */ case    0:  		/* lwz R31, <#[R10 + 12]> */
		/* 820723FCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x0000000C) );
		/* 820723FCh case    0:*/		return 0x82072400;
		  /* 82072400h */ case    1:  		/* b 56 */
		/* 82072400h case    1:*/		return 0x82072438;
		/* 82072400h case    1:*/		return 0x82072404;
	}
	return 0x82072404;
} // Block from 820723FCh-82072404h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072404);
		  /* 82072404h */ case    0:  		/* bc 12, CR6_EQ, 48 */
		/* 82072404h case    0:*/		if ( regs.CR[6].eq ) { return 0x82072434;  }
		/* 82072404h case    0:*/		return 0x82072408;
		  /* 82072408h */ case    1:  		/* bl 2075376 */
		/* 82072408h case    1:*/		regs.LR = 0x8207240C; return 0x8226CEF8;
		/* 82072408h case    1:*/		return 0x8207240C;
		  /* 8207240Ch */ case    2:  		/* cmpwi CR6, R3, 2 */
		/* 8207240Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 8207240Ch case    2:*/		return 0x82072410;
		  /* 82072410h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82072410h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8207241C;  }
		/* 82072410h case    3:*/		return 0x82072414;
		  /* 82072414h */ case    4:  		/* lwz R11, <#[R28 + 1452]> */
		/* 82072414h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000005AC) );
		/* 82072414h case    4:*/		return 0x82072418;
		  /* 82072418h */ case    5:  		/* b 8 */
		/* 82072418h case    5:*/		return 0x82072420;
		/* 82072418h case    5:*/		return 0x8207241C;
	}
	return 0x8207241C;
} // Block from 82072404h-8207241Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8207241Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207241C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207241C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207241C);
		  /* 8207241Ch */ case    0:  		/* lwz R11, <#[R29 + 1456]> */
		/* 8207241Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000005B0) );
		/* 8207241Ch case    0:*/		return 0x82072420;
	}
	return 0x82072420;
} // Block from 8207241Ch-82072420h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82072420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072420);
		  /* 82072420h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82072420h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82072420h case    0:*/		return 0x82072424;
		  /* 82072424h */ case    1:  		/* rlwinm R10, R31, 4, 0, 27 */
		/* 82072424h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R31);
		/* 82072424h case    1:*/		return 0x82072428;
		  /* 82072428h */ case    2:  		/* lwz R11, <#[R11 + 24408]> */
		/* 82072428h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00005F58) );
		/* 82072428h case    2:*/		return 0x8207242C;
		  /* 8207242Ch */ case    3:  		/* lwzx R31, <#[R11 + R10]> */
		/* 8207242Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8207242Ch case    3:*/		return 0x82072430;
		  /* 82072430h */ case    4:  		/* b 8 */
		/* 82072430h case    4:*/		return 0x82072438;
		/* 82072430h case    4:*/		return 0x82072434;
	}
	return 0x82072434;
} // Block from 82072420h-82072434h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82072434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072434);
		  /* 82072434h */ case    0:  		/* lwz R31, <#[R10 + 8]> */
		/* 82072434h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000008) );
		/* 82072434h case    0:*/		return 0x82072438;
	}
	return 0x82072438;
} // Block from 82072434h-82072438h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82072438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072438);
		  /* 82072438h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82072438h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82072438h case    0:*/		return 0x8207243C;
		  /* 8207243Ch */ case    1:  		/* bc 12, CR6_EQ, 76 */
		/* 8207243Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82072488;  }
		/* 8207243Ch case    1:*/		return 0x82072440;
		  /* 82072440h */ case    2:  		/* bl 2075320 */
		/* 82072440h case    2:*/		regs.LR = 0x82072444; return 0x8226CEF8;
		/* 82072440h case    2:*/		return 0x82072444;
		  /* 82072444h */ case    3:  		/* cmpwi CR6, R3, 2 */
		/* 82072444h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82072444h case    3:*/		return 0x82072448;
		  /* 82072448h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 82072448h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82072454;  }
		/* 82072448h case    4:*/		return 0x8207244C;
		  /* 8207244Ch */ case    5:  		/* lwz R11, <#[R28 + 1452]> */
		/* 8207244Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000005AC) );
		/* 8207244Ch case    5:*/		return 0x82072450;
		  /* 82072450h */ case    6:  		/* b 8 */
		/* 82072450h case    6:*/		return 0x82072458;
		/* 82072450h case    6:*/		return 0x82072454;
	}
	return 0x82072454;
} // Block from 82072438h-82072454h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82072454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072454);
		  /* 82072454h */ case    0:  		/* lwz R11, <#[R29 + 1456]> */
		/* 82072454h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000005B0) );
		/* 82072454h case    0:*/		return 0x82072458;
	}
	return 0x82072458;
} // Block from 82072454h-82072458h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82072458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072458);
		  /* 82072458h */ case    0:  		/* lwz R3, <#[R11]> */
		/* 82072458h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 82072458h case    0:*/		return 0x8207245C;
		  /* 8207245Ch */ case    1:  		/* cmpldi CR6, R30, 0 */
		/* 8207245Ch case    1:*/		cpu::op::cmpldi<6>(regs,regs.R30,0x00000000);
		/* 8207245Ch case    1:*/		return 0x82072460;
		  /* 82072460h */ case    2:  		/* li R7, 1 */
		/* 82072460h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82072460h case    2:*/		return 0x82072464;
		  /* 82072464h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82072464h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82072470;  }
		/* 82072464h case    3:*/		return 0x82072468;
		  /* 82072468h */ case    4:  		/* li R7, 0 */
		/* 82072468h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82072468h case    4:*/		return 0x8207246C;
		  /* 8207246Ch */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8207246Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82072478;  }
		/* 8207246Ch case    5:*/		return 0x82072470;
	}
	return 0x82072470;
} // Block from 82072458h-82072470h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82072470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072470);
		  /* 82072470h */ case    0:  		/* li R6, 0 */
		/* 82072470h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82072470h case    0:*/		return 0x82072474;
		  /* 82072474h */ case    1:  		/* b 8 */
		/* 82072474h case    1:*/		return 0x8207247C;
		/* 82072474h case    1:*/		return 0x82072478;
	}
	return 0x82072478;
} // Block from 82072470h-82072478h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072478);
		  /* 82072478h */ case    0:  		/* mr R6, R26 */
		/* 82072478h case    0:*/		regs.R6 = regs.R26;
		/* 82072478h case    0:*/		return 0x8207247C;
	}
	return 0x8207247C;
} // Block from 82072478h-8207247Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8207247Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207247C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207247C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207247C);
		  /* 8207247Ch */ case    0:  		/* mr R5, R27 */
		/* 8207247Ch case    0:*/		regs.R5 = regs.R27;
		/* 8207247Ch case    0:*/		return 0x82072480;
		  /* 82072480h */ case    1:  		/* mr R4, R31 */
		/* 82072480h case    1:*/		regs.R4 = regs.R31;
		/* 82072480h case    1:*/		return 0x82072484;
		  /* 82072484h */ case    2:  		/* bl 2212 */
		/* 82072484h case    2:*/		regs.LR = 0x82072488; return 0x82072D28;
		/* 82072484h case    2:*/		return 0x82072488;
	}
	return 0x82072488;
} // Block from 8207247Ch-82072488h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82072488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072488);
		  /* 82072488h */ case    0:  		/* li R11, 256 */
		/* 82072488h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x100);
		/* 82072488h case    0:*/		return 0x8207248C;
		  /* 8207248Ch */ case    1:  		/* mfmsr R8, MSR */
		/* 8207248Ch case    1:*/		regs.R8 = regs.MSR;
		/* 8207248Ch case    1:*/		return 0x82072490;
		  /* 82072490h */ case    2:  		/* mtmsrd MSR, R13 */
		/* 82072490h case    2:*/		regs.MSR = regs.R13;
		/* 82072490h case    2:*/		return 0x82072494;
		  /* 82072494h */ case    3:  		/* lwarx R10, <#[R26]> */
		/* 82072494h case    3:*/		cpu::mem::lwarx( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 82072494h case    3:*/		return 0x82072498;
		  /* 82072498h */ case    4:  		/* add R9, R11, R10 */
		/* 82072498h case    4:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 82072498h case    4:*/		return 0x8207249C;
		  /* 8207249Ch */ case    5:  		/* stwcx. R9, <#[R26]> */
		/* 8207249Ch case    5:*/		cpu::mem::stwcx( regs, regs.R9, (uint32)(regs.R26 + 0x00000000) );
		/* 8207249Ch case    5:*/		return 0x820724A0;
		  /* 820724A0h */ case    6:  		/* mtmsrd MSR, R8 */
		/* 820724A0h case    6:*/		regs.MSR = regs.R8;
		/* 820724A0h case    6:*/		return 0x820724A4;
		  /* 820724A4h */ case    7:  		/* bc 4, CR0_EQ, -24 */
		/* 820724A4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8207248C;  }
		/* 820724A4h case    7:*/		return 0x820724A8;
		  /* 820724A8h */ case    8:  		/* lwsync */
		/* 820724A8h case    8:*/		cpu::op::lwsync<0>(regs);
		/* 820724A8h case    8:*/		return 0x820724AC;
		  /* 820724ACh */ case    9:  		/* andi. R11, R25, 18 */
		/* 820724ACh case    9:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R25,0x12);
		/* 820724ACh case    9:*/		return 0x820724B0;
		  /* 820724B0h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 820724B0h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820724B0h case   10:*/		return 0x820724B4;
		  /* 820724B4h */ case   11:  		/* bc 4, CR0_EQ, 264 */
		/* 820724B4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820725BC;  }
		/* 820724B4h case   11:*/		return 0x820724B8;
		  /* 820724B8h */ case   12:  		/* bl 2075200 */
		/* 820724B8h case   12:*/		regs.LR = 0x820724BC; return 0x8226CEF8;
		/* 820724B8h case   12:*/		return 0x820724BC;
		  /* 820724BCh */ case   13:  		/* cmpwi CR6, R3, 2 */
		/* 820724BCh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 820724BCh case   13:*/		return 0x820724C0;
		  /* 820724C0h */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 820724C0h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820724CC;  }
		/* 820724C0h case   14:*/		return 0x820724C4;
		  /* 820724C4h */ case   15:  		/* lwz R11, <#[R28 + 1452]> */
		/* 820724C4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x000005AC) );
		/* 820724C4h case   15:*/		return 0x820724C8;
		  /* 820724C8h */ case   16:  		/* b 8 */
		/* 820724C8h case   16:*/		return 0x820724D0;
		/* 820724C8h case   16:*/		return 0x820724CC;
	}
	return 0x820724CC;
} // Block from 82072488h-820724CCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820724CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820724CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820724CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820724CC);
		  /* 820724CCh */ case    0:  		/* lwz R11, <#[R29 + 1456]> */
		/* 820724CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x000005B0) );
		/* 820724CCh case    0:*/		return 0x820724D0;
	}
	return 0x820724D0;
} // Block from 820724CCh-820724D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820724D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820724D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820724D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820724D0);
		  /* 820724D0h */ case    0:  		/* lwz R31, <#[R11]> */
		/* 820724D0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 820724D0h case    0:*/		return 0x820724D4;
		  /* 820724D4h */ case    1:  		/* lis R11, -32216 */
		/* 820724D4h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 820724D4h case    1:*/		return 0x820724D8;
		  /* 820724D8h */ case    2:  		/* lwz R11, <#[R11 + 28728]> */
		/* 820724D8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00007038) );
		/* 820724D8h case    2:*/		return 0x820724DC;
		  /* 820724DCh */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820724DCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820724DCh case    3:*/		return 0x820724E0;
		  /* 820724E0h */ case    4:  		/* bc 4, CR6_EQ, 28 */
		/* 820724E0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820724FC;  }
		/* 820724E0h case    4:*/		return 0x820724E4;
		  /* 820724E4h */ case    5:  		/* li R6, 0 */
		/* 820724E4h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820724E4h case    5:*/		return 0x820724E8;
		  /* 820724E8h */ case    6:  		/* li R5, 0 */
		/* 820724E8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820724E8h case    6:*/		return 0x820724EC;
		  /* 820724ECh */ case    7:  		/* li R4, 0 */
		/* 820724ECh case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820724ECh case    7:*/		return 0x820724F0;
		  /* 820724F0h */ case    8:  		/* mr R3, R31 */
		/* 820724F0h case    8:*/		regs.R3 = regs.R31;
		/* 820724F0h case    8:*/		return 0x820724F4;
		  /* 820724F4h */ case    9:  		/* bl -812 */
		/* 820724F4h case    9:*/		regs.LR = 0x820724F8; return 0x820721C8;
		/* 820724F4h case    9:*/		return 0x820724F8;
		  /* 820724F8h */ case   10:  		/* b 196 */
		/* 820724F8h case   10:*/		return 0x820725BC;
		/* 820724F8h case   10:*/		return 0x820724FC;
	}
	return 0x820724FC;
} // Block from 820724D0h-820724FCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820724FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820724FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820724FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820724FC);
		  /* 820724FCh */ case    0:  		/* rlwinm R11, R23, 12, 20, 31 */
		/* 820724FCh case    0:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R23);
		/* 820724FCh case    0:*/		return 0x82072500;
		  /* 82072500h */ case    1:  		/* rlwinm R10, R23, 0, 3, 31 */
		/* 82072500h case    1:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R23);
		/* 82072500h case    1:*/		return 0x82072504;
		  /* 82072504h */ case    2:  		/* addi R11, R11, 512 */
		/* 82072504h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82072504h case    2:*/		return 0x82072508;
		  /* 82072508h */ case    3:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82072508h case    3:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82072508h case    3:*/		return 0x8207250C;
		  /* 8207250Ch */ case    4:  		/* add R30, R11, R10 */
		/* 8207250Ch case    4:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 8207250Ch case    4:*/		return 0x82072510;
		  /* 82072510h */ case    5:  		/* add R29, R30, R24 */
		/* 82072510h case    5:*/		cpu::op::add<0>(regs,&regs.R29,regs.R30,regs.R24);
		/* 82072510h case    5:*/		return 0x82072514;
		  /* 82072514h */ case    6:  		/* bl 89732 */
		/* 82072514h case    6:*/		regs.LR = 0x82072518; return 0x82088398;
		/* 82072514h case    6:*/		return 0x82072518;
		  /* 82072518h */ case    7:  		/* lwz R11, <#[R31 + 11016]> */
		/* 82072518h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B08) );
		/* 82072518h case    7:*/		return 0x8207251C;
		  /* 8207251Ch */ case    8:  		/* cmplw CR6, R11, R3 */
		/* 8207251Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 8207251Ch case    8:*/		return 0x82072520;
		  /* 82072520h */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 82072520h case    9:*/		if ( regs.CR[6].eq ) { return 0x82072538;  }
		/* 82072520h case    9:*/		return 0x82072524;
		  /* 82072524h */ case   10:  		/* mr R5, R29 */
		/* 82072524h case   10:*/		regs.R5 = regs.R29;
		/* 82072524h case   10:*/		return 0x82072528;
		  /* 82072528h */ case   11:  		/* mr R4, R30 */
		/* 82072528h case   11:*/		regs.R4 = regs.R30;
		/* 82072528h case   11:*/		return 0x8207252C;
		  /* 8207252Ch */ case   12:  		/* addi R3, R31, 12248 */
		/* 8207252Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x2FD8);
		/* 8207252Ch case   12:*/		return 0x82072530;
		  /* 82072530h */ case   13:  		/* bl 1136 */
		/* 82072530h case   13:*/		regs.LR = 0x82072534; return 0x820729A0;
		/* 82072530h case   13:*/		return 0x82072534;
		  /* 82072534h */ case   14:  		/* b 136 */
		/* 82072534h case   14:*/		return 0x820725BC;
		/* 82072534h case   14:*/		return 0x82072538;
	}
	return 0x82072538;
} // Block from 820724FCh-82072538h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82072538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072538);
		  /* 82072538h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 82072538h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82072538h case    0:*/		return 0x8207253C;
		  /* 8207253Ch */ case    1:  		/* lwz R3, <#[R31 + 48]> */
		/* 8207253Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8207253Ch case    1:*/		return 0x82072540;
		  /* 82072540h */ case    2:  		/* cmplw CR6, R3, R11 */
		/* 82072540h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82072540h case    2:*/		return 0x82072544;
		  /* 82072544h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 82072544h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82072550;  }
		/* 82072544h case    3:*/		return 0x82072548;
		  /* 82072548h */ case    4:  		/* mr R3, R31 */
		/* 82072548h case    4:*/		regs.R3 = regs.R31;
		/* 82072548h case    4:*/		return 0x8207254C;
		  /* 8207254Ch */ case    5:  		/* bl 7100 */
		/* 8207254Ch case    5:*/		regs.LR = 0x82072550; return 0x82074108;
		/* 8207254Ch case    5:*/		return 0x82072550;
	}
	return 0x82072550;
} // Block from 82072538h-82072550h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82072550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072550);
		  /* 82072550h */ case    0:  		/* li R11, 2609 */
		/* 82072550h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xA31);
		/* 82072550h case    0:*/		return 0x82072554;
		  /* 82072554h */ case    1:  		/* lwz R10, <#[R1 + 284]> */
		/* 82072554h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000011C) );
		/* 82072554h case    1:*/		return 0x82072558;
		  /* 82072558h */ case    2:  		/* lis R9, 1 */
		/* 82072558h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0x1);
		/* 82072558h case    2:*/		return 0x8207255C;
		  /* 8207255Ch */ case    3:  		/* stwu R11, <#[R3 + 4]> */
		/* 8207255Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207255Ch case    3:*/		return 0x82072560;
		  /* 82072560h */ case    4:  		/* addi R11, R29, 4095 */
		/* 82072560h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFF);
		/* 82072560h case    4:*/		return 0x82072564;
		  /* 82072564h */ case    5:  		/* ori R9, R9, 2607 */
		/* 82072564h case    5:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0xA2F);
		/* 82072564h case    5:*/		return 0x82072568;
		  /* 82072568h */ case    6:  		/* rlwinm R8, R30, 0, 0, 19 */
		/* 82072568h case    6:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R8,regs.R30);
		/* 82072568h case    6:*/		return 0x8207256C;
		  /* 8207256Ch */ case    7:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 8207256Ch case    7:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 8207256Ch case    7:*/		return 0x82072570;
		  /* 82072570h */ case    8:  		/* lis R7, -16380 */
		/* 82072570h case    8:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFFC004);
		/* 82072570h case    8:*/		return 0x82072574;
		  /* 82072574h */ case    9:  		/* stwu R10, <#[R3 + 4]> */
		/* 82072574h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82072574h case    9:*/		return 0x82072578;
		  /* 82072578h */ case   10:  		/* subf R11, R8, R11 */
		/* 82072578h case   10:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82072578h case   10:*/		return 0x8207257C;
		  /* 8207257Ch */ case   11:  		/* ori R10, R7, 15360 */
		/* 8207257Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R7,0x3C00);
		/* 8207257Ch case   11:*/		return 0x82072580;
		  /* 82072580h */ case   12:  		/* li R7, 3 */
		/* 82072580h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 82072580h case   12:*/		return 0x82072584;
		  /* 82072584h */ case   13:  		/* li R6, 2609 */
		/* 82072584h case   13:*/		cpu::op::li<0>(regs,&regs.R6,0xA31);
		/* 82072584h case   13:*/		return 0x82072588;
		  /* 82072588h */ case   14:  		/* li R5, 0 */
		/* 82072588h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82072588h case   14:*/		return 0x8207258C;
		  /* 8207258Ch */ case   15:  		/* stwu R9, <#[R3 + 4]> */
		/* 8207258Ch case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207258Ch case   15:*/		return 0x82072590;
		  /* 82072590h */ case   16:  		/* lis R4, -32768 */
		/* 82072590h case   16:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8000);
		/* 82072590h case   16:*/		return 0x82072594;
		  /* 82072594h */ case   17:  		/* li R30, 8 */
		/* 82072594h case   17:*/		cpu::op::li<0>(regs,&regs.R30,0x8);
		/* 82072594h case   17:*/		return 0x82072598;
		  /* 82072598h */ case   18:  		/* stwu R11, <#[R3 + 4]> */
		/* 82072598h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82072598h case   18:*/		return 0x8207259C;
		  /* 8207259Ch */ case   19:  		/* stwu R8, <#[R3 + 4]> */
		/* 8207259Ch case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207259Ch case   19:*/		return 0x820725A0;
		  /* 820725A0h */ case   20:  		/* stwu R10, <#[R3 + 4]> */
		/* 820725A0h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820725A0h case   20:*/		return 0x820725A4;
		  /* 820725A4h */ case   21:  		/* stwu R7, <#[R3 + 4]> */
		/* 820725A4h case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820725A4h case   21:*/		return 0x820725A8;
		  /* 820725A8h */ case   22:  		/* stwu R6, <#[R3 + 4]> */
		/* 820725A8h case   22:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820725A8h case   22:*/		return 0x820725AC;
		  /* 820725ACh */ case   23:  		/* stwu R5, <#[R3 + 4]> */
		/* 820725ACh case   23:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820725ACh case   23:*/		return 0x820725B0;
		  /* 820725B0h */ case   24:  		/* stwu R4, <#[R3 + 4]> */
		/* 820725B0h case   24:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820725B0h case   24:*/		return 0x820725B4;
		  /* 820725B4h */ case   25:  		/* stwu R30, <#[R3 + 4]> */
		/* 820725B4h case   25:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820725B4h case   25:*/		return 0x820725B8;
		  /* 820725B8h */ case   26:  		/* stw R3, <#[R31 + 48]> */
		/* 820725B8h case   26:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 820725B8h case   26:*/		return 0x820725BC;
	}
	return 0x820725BC;
} // Block from 82072550h-820725BCh (27 instructions)

//////////////////////////////////////////////////////
// Block at 820725BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820725BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820725BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820725BC);
		  /* 820725BCh */ case    0:  		/* rlwinm. R6, R25, 0, 27, 27 */
		/* 820725BCh case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R6,regs.R25);
		/* 820725BCh case    0:*/		return 0x820725C0;
		  /* 820725C0h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820725C0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820725D0;  }
		/* 820725C0h case    1:*/		return 0x820725C4;
		  /* 820725C4h */ case    2:  		/* lwz R11, <#[R26]> */
		/* 820725C4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820725C4h case    2:*/		return 0x820725C8;
		  /* 820725C8h */ case    3:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 820725C8h case    3:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 820725C8h case    3:*/		return 0x820725CC;
		  /* 820725CCh */ case    4:  		/* bc 12, CR0_EQ, 208 */
		/* 820725CCh case    4:*/		if ( regs.CR[0].eq ) { return 0x8207269C;  }
		/* 820725CCh case    4:*/		return 0x820725D0;
	}
	return 0x820725D0;
} // Block from 820725BCh-820725D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820725D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820725D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820725D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820725D0);
		  /* 820725D0h */ case    0:  		/* rlwinm. R11, R25, 0, 31, 31 */
		/* 820725D0h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R25);
		/* 820725D0h case    0:*/		return 0x820725D4;
		  /* 820725D4h */ case    1:  		/* bc 4, CR0_EQ, 168 */
		/* 820725D4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8207267C;  }
		/* 820725D4h case    1:*/		return 0x820725D8;
		  /* 820725D8h */ case    2:  		/* cmplwi CR6, R20, 0 */
		/* 820725D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 820725D8h case    2:*/		return 0x820725DC;
		  /* 820725DCh */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820725DCh case    3:*/		if ( regs.CR[6].eq ) { return 0x820725F4;  }
		/* 820725DCh case    3:*/		return 0x820725E0;
		  /* 820725E0h */ case    4:  		/* cmplwi CR6, R22, 0 */
		/* 820725E0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820725E0h case    4:*/		return 0x820725E4;
		  /* 820725E4h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820725E4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820725F4;  }
		/* 820725E4h case    5:*/		return 0x820725E8;
		  /* 820725E8h */ case    6:  		/* rlwinm R11, R22, 0, 0, 24 */
		/* 820725E8h case    6:*/		cpu::op::rlwinm<0,0,0,24>(regs,&regs.R11,regs.R22);
		/* 820725E8h case    6:*/		return 0x820725EC;
		  /* 820725ECh */ case    7:  		/* addi R7, R26, 24 */
		/* 820725ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R26,0x18);
		/* 820725ECh case    7:*/		return 0x820725F0;
		  /* 820725F0h */ case    8:  		/* b 12 */
		/* 820725F0h case    8:*/		return 0x820725FC;
		/* 820725F0h case    8:*/		return 0x820725F4;
	}
	return 0x820725F4;
} // Block from 820725D0h-820725F4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820725F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820725F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820725F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820725F4);
		  /* 820725F4h */ case    0:  		/* rlwinm R11, R21, 0, 0, 24 */
		/* 820725F4h case    0:*/		cpu::op::rlwinm<0,0,0,24>(regs,&regs.R11,regs.R21);
		/* 820725F4h case    0:*/		return 0x820725F8;
		  /* 820725F8h */ case    1:  		/* addi R7, R26, 20 */
		/* 820725F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R26,0x14);
		/* 820725F8h case    1:*/		return 0x820725FC;
	}
	return 0x820725FC;
} // Block from 820725F4h-820725FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820725FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820725FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820725FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820725FC);
		  /* 820725FCh */ case    0:  		/* subf R11, R11, R23 */
		/* 820725FCh case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R23);
		/* 820725FCh case    0:*/		return 0x82072600;
		  /* 82072600h */ case    1:  		/* lwz R5, <#[R7]> */
		/* 82072600h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + 0x00000000) );
		/* 82072600h case    1:*/		return 0x82072604;
		  /* 82072604h */ case    2:  		/* add R10, R11, R24 */
		/* 82072604h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R24);
		/* 82072604h case    2:*/		return 0x82072608;
		  /* 82072608h */ case    3:  		/* rlwinm R8, R11, 25, 7, 31 */
		/* 82072608h case    3:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R8,regs.R11);
		/* 82072608h case    3:*/		return 0x8207260C;
		  /* 8207260Ch */ case    4:  		/* addi R11, R10, 127 */
		/* 8207260Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x7F);
		/* 8207260Ch case    4:*/		return 0x82072610;
		  /* 82072610h */ case    5:  		/* rlwinm. R4, R5, 16, 16, 16 */
		/* 82072610h case    5:*/		cpu::op::rlwinm<1,16,16,16>(regs,&regs.R4,regs.R5);
		/* 82072610h case    5:*/		return 0x82072614;
		  /* 82072614h */ case    6:  		/* rlwinm R9, R11, 25, 7, 31 */
		/* 82072614h case    6:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R9,regs.R11);
		/* 82072614h case    6:*/		return 0x82072618;
		  /* 82072618h */ case    7:  		/* rlwinm R11, R5, 16, 16, 31 */
		/* 82072618h case    7:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R11,regs.R5);
		/* 82072618h case    7:*/		return 0x8207261C;
		  /* 8207261Ch */ case    8:  		/* rlwinm R10, R5, 0, 16, 31 */
		/* 8207261Ch case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R5);
		/* 8207261Ch case    8:*/		return 0x82072620;
		  /* 82072620h */ case    9:  		/* bc 12, CR0_EQ, 8 */
		/* 82072620h case    9:*/		if ( regs.CR[0].eq ) { return 0x82072628;  }
		/* 82072620h case    9:*/		return 0x82072624;
		  /* 82072624h */ case   10:  		/* rlwinm R11, R11, 4, 13, 27 */
		/* 82072624h case   10:*/		cpu::op::rlwinm<0,4,13,27>(regs,&regs.R11,regs.R11);
		/* 82072624h case   10:*/		return 0x82072628;
	}
	return 0x82072628;
} // Block from 820725FCh-82072628h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82072628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072628);
		  /* 82072628h */ case    0:  		/* rlwinm. R5, R10, 0, 16, 16 */
		/* 82072628h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R5,regs.R10);
		/* 82072628h case    0:*/		return 0x8207262C;
		  /* 8207262Ch */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8207262Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82072634;  }
		/* 8207262Ch case    1:*/		return 0x82072630;
		  /* 82072630h */ case    2:  		/* rlwinm R10, R10, 4, 13, 27 */
		/* 82072630h case    2:*/		cpu::op::rlwinm<0,4,13,27>(regs,&regs.R10,regs.R10);
		/* 82072630h case    2:*/		return 0x82072634;
	}
	return 0x82072634;
} // Block from 82072628h-82072634h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82072634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072634);
		  /* 82072634h */ case    0:  		/* cmplw CR6, R9, R10 */
		/* 82072634h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82072634h case    0:*/		return 0x82072638;
		  /* 82072638h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 82072638h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82072640;  }
		/* 82072638h case    1:*/		return 0x8207263C;
		  /* 8207263Ch */ case    2:  		/* mr R10, R9 */
		/* 8207263Ch case    2:*/		regs.R10 = regs.R9;
		/* 8207263Ch case    2:*/		return 0x82072640;
	}
	return 0x82072640;
} // Block from 82072634h-82072640h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82072640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072640);
		  /* 82072640h */ case    0:  		/* cmplw CR6, R8, R11 */
		/* 82072640h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82072640h case    0:*/		return 0x82072644;
		  /* 82072644h */ case    1:  		/* bc 4, CR6_LT, 8 */
		/* 82072644h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8207264C;  }
		/* 82072644h case    1:*/		return 0x82072648;
		  /* 82072648h */ case    2:  		/* mr R11, R8 */
		/* 82072648h case    2:*/		regs.R11 = regs.R8;
		/* 82072648h case    2:*/		return 0x8207264C;
	}
	return 0x8207264C;
} // Block from 82072640h-8207264Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8207264Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207264C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207264C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207264C);
		  /* 8207264Ch */ case    0:  		/* cmplwi CR6, R11, 32767 */
		/* 8207264Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FFF);
		/* 8207264Ch case    0:*/		return 0x82072650;
		  /* 82072650h */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 82072650h case    1:*/		if ( regs.CR[6].lt ) { return 0x8207265C;  }
		/* 82072650h case    1:*/		return 0x82072654;
		  /* 82072654h */ case    2:  		/* addis R11, R11, 8 */
		/* 82072654h case    2:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82072654h case    2:*/		return 0x82072658;
		  /* 82072658h */ case    3:  		/* rlwinm R11, R11, 28, 4, 31 */
		/* 82072658h case    3:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R11,regs.R11);
		/* 82072658h case    3:*/		return 0x8207265C;
	}
	return 0x8207265C;
} // Block from 8207264Ch-8207265Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8207265Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207265C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207265C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207265C);
		  /* 8207265Ch */ case    0:  		/* cmplwi CR6, R10, 32767 */
		/* 8207265Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00007FFF);
		/* 8207265Ch case    0:*/		return 0x82072660;
		  /* 82072660h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 82072660h case    1:*/		if ( regs.CR[6].lt ) { return 0x82072670;  }
		/* 82072660h case    1:*/		return 0x82072664;
		  /* 82072664h */ case    2:  		/* addis R10, R10, 8 */
		/* 82072664h case    2:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82072664h case    2:*/		return 0x82072668;
		  /* 82072668h */ case    3:  		/* addi R10, R10, 15 */
		/* 82072668h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xF);
		/* 82072668h case    3:*/		return 0x8207266C;
		  /* 8207266Ch */ case    4:  		/* rlwinm R10, R10, 28, 4, 31 */
		/* 8207266Ch case    4:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R10,regs.R10);
		/* 8207266Ch case    4:*/		return 0x82072670;
	}
	return 0x82072670;
} // Block from 8207265Ch-82072670h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82072670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072670);
		  /* 82072670h */ case    0:  		/* rlwinm R11, R11, 16, 0, 15 */
		/* 82072670h case    0:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R11,regs.R11);
		/* 82072670h case    0:*/		return 0x82072674;
		  /* 82072674h */ case    1:  		/* or R11, R11, R10 */
		/* 82072674h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82072674h case    1:*/		return 0x82072678;
		  /* 82072678h */ case    2:  		/* stw R11, <#[R7]> */
		/* 82072678h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82072678h case    2:*/		return 0x8207267C;
	}
	return 0x8207267C;
} // Block from 82072670h-8207267Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8207267Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207267C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207267C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207267C);
		  /* 8207267Ch */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 8207267Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8207267Ch case    0:*/		return 0x82072680;
		  /* 82072680h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82072680h case    1:*/		if ( regs.CR[6].eq ) { return 0x8207269C;  }
		/* 82072680h case    1:*/		return 0x82072684;
		  /* 82072684h */ case    2:  		/* rlwinm R11, R23, 12, 20, 31 */
		/* 82072684h case    2:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R23);
		/* 82072684h case    2:*/		return 0x82072688;
		  /* 82072688h */ case    3:  		/* rlwinm R10, R23, 0, 3, 31 */
		/* 82072688h case    3:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R23);
		/* 82072688h case    3:*/		return 0x8207268C;
		  /* 8207268Ch */ case    4:  		/* addi R11, R11, 512 */
		/* 8207268Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8207268Ch case    4:*/		return 0x82072690;
		  /* 82072690h */ case    5:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82072690h case    5:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82072690h case    5:*/		return 0x82072694;
		  /* 82072694h */ case    6:  		/* add R11, R11, R10 */
		/* 82072694h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82072694h case    6:*/		return 0x82072698;
		  /* 82072698h */ case    7:  		/* addis R23, R11, -16384 */
		/* 82072698h case    7:*/		cpu::op::addis<0>(regs,&regs.R23,regs.R11,0xFFFFC000);
		/* 82072698h case    7:*/		return 0x8207269C;
	}
	return 0x8207269C;
} // Block from 8207267Ch-8207269Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8207269Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207269C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207269C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207269C);
		  /* 8207269Ch */ case    0:  		/* mr R3, R23 */
		/* 8207269Ch case    0:*/		regs.R3 = regs.R23;
		/* 8207269Ch case    0:*/		return 0x820726A0;
		  /* 820726A0h */ case    1:  		/* addi R1, R1, 192 */
		/* 820726A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820726A0h case    1:*/		return 0x820726A4;
		  /* 820726A4h */ case    2:  		/* b 125924 */
		/* 820726A4h case    2:*/		return 0x82091288;
		/* 820726A4h case    2:*/		return 0x820726A8;
	}
	return 0x820726A8;
} // Block from 8207269Ch-820726A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820726A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820726A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820726A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820726A8);
		  /* 820726A8h */ case    0:  		/* mfspr R12, LR */
		/* 820726A8h case    0:*/		regs.R12 = regs.LR;
		/* 820726A8h case    0:*/		return 0x820726AC;
		  /* 820726ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820726ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820726ACh case    1:*/		return 0x820726B0;
		  /* 820726B0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820726B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820726B0h case    2:*/		return 0x820726B4;
		  /* 820726B4h */ case    3:  		/* lwz R11, <#[R3 + 24]> */
		/* 820726B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820726B4h case    3:*/		return 0x820726B8;
		  /* 820726B8h */ case    4:  		/* lis R9, 768 */
		/* 820726B8h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0x300);
		/* 820726B8h case    4:*/		return 0x820726BC;
		  /* 820726BCh */ case    5:  		/* lwz R10, <#[R3 + 28]> */
		/* 820726BCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000001C) );
		/* 820726BCh case    5:*/		return 0x820726C0;
		  /* 820726C0h */ case    6:  		/* li R8, 0 */
		/* 820726C0h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820726C0h case    6:*/		return 0x820726C4;
		  /* 820726C4h */ case    7:  		/* rlwinm R7, R11, 0, 0, 29 */
		/* 820726C4h case    7:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R7,regs.R11);
		/* 820726C4h case    7:*/		return 0x820726C8;
		  /* 820726C8h */ case    8:  		/* stw R6, <#[R1 + 84]> */
		/* 820726C8h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 820726C8h case    8:*/		return 0x820726CC;
		  /* 820726CCh */ case    9:  		/* stw R9, <#[R1 + 92]> */
		/* 820726CCh case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 820726CCh case    9:*/		return 0x820726D0;
		  /* 820726D0h */ case   10:  		/* rlwinm R10, R10, 0, 6, 29 */
		/* 820726D0h case   10:*/		cpu::op::rlwinm<0,0,6,29>(regs,&regs.R10,regs.R10);
		/* 820726D0h case   10:*/		return 0x820726D4;
		  /* 820726D4h */ case   11:  		/* mr R9, R7 */
		/* 820726D4h case   11:*/		regs.R9 = regs.R7;
		/* 820726D4h case   11:*/		return 0x820726D8;
		  /* 820726D8h */ case   12:  		/* li R6, 0 */
		/* 820726D8h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820726D8h case   12:*/		return 0x820726DC;
		  /* 820726DCh */ case   13:  		/* li R5, 10 */
		/* 820726DCh case   13:*/		cpu::op::li<0>(regs,&regs.R5,0xA);
		/* 820726DCh case   13:*/		return 0x820726E0;
		  /* 820726E0h */ case   14:  		/* li R4, 0 */
		/* 820726E0h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820726E0h case   14:*/		return 0x820726E4;
		  /* 820726E4h */ case   15:  		/* bl -940 */
		/* 820726E4h case   15:*/		regs.LR = 0x820726E8; return 0x82072338;
		/* 820726E4h case   15:*/		return 0x820726E8;
		  /* 820726E8h */ case   16:  		/* addi R1, R1, 112 */
		/* 820726E8h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820726E8h case   16:*/		return 0x820726EC;
		  /* 820726ECh */ case   17:  		/* lwz R12, <#[R1 - 8]> */
		/* 820726ECh case   17:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820726ECh case   17:*/		return 0x820726F0;
		  /* 820726F0h */ case   18:  		/* mtspr LR, R12 */
		/* 820726F0h case   18:*/		regs.LR = regs.R12;
		/* 820726F0h case   18:*/		return 0x820726F4;
		  /* 820726F4h */ case   19:  		/* bclr 20, CR0_LT */
		/* 820726F4h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820726F4h case   19:*/		return 0x820726F8;
	}
	return 0x820726F8;
} // Block from 820726A8h-820726F8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820726F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820726F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820726F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820726F8);
		  /* 820726F8h */ case    0:  		/* lwz R10, <#[R3 + 17136]> */
		/* 820726F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000042F0) );
		/* 820726F8h case    0:*/		return 0x820726FC;
		  /* 820726FCh */ case    1:  		/* lbz R9, <#[R3 + 11069]> */
		/* 820726FCh case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R3 + 0x00002B3D) );
		/* 820726FCh case    1:*/		return 0x82072700;
		  /* 82072700h */ case    2:  		/* addi R11, R10, 4800 */
		/* 82072700h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x12C0);
		/* 82072700h case    2:*/		return 0x82072704;
		  /* 82072704h */ case    3:  		/* ori R9, R9, 32 */
		/* 82072704h case    3:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x20);
		/* 82072704h case    3:*/		return 0x82072708;
		  /* 82072708h */ case    4:  		/* addi R8, R11, -160 */
		/* 82072708h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFF60);
		/* 82072708h case    4:*/		return 0x8207270C;
		  /* 8207270Ch */ case    5:  		/* stw R11, <#[R3 + 52]> */
		/* 8207270Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000034) );
		/* 8207270Ch case    5:*/		return 0x82072710;
		  /* 82072710h */ case    6:  		/* stw R10, <#[R3 + 48]> */
		/* 82072710h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000030) );
		/* 82072710h case    6:*/		return 0x82072714;
		  /* 82072714h */ case    7:  		/* stw R8, <#[R3 + 56]> */
		/* 82072714h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000038) );
		/* 82072714h case    7:*/		return 0x82072718;
		  /* 82072718h */ case    8:  		/* stb R9, <#[R3 + 11069]> */
		/* 82072718h case    8:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R3 + 0x00002B3D) );
		/* 82072718h case    8:*/		return 0x8207271C;
		  /* 8207271Ch */ case    9:  		/* bclr 20, CR0_LT */
		/* 8207271Ch case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8207271Ch case    9:*/		return 0x82072720;
	}
	return 0x82072720;
} // Block from 820726F8h-82072720h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82072720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072720);
		  /* 82072720h */ case    0:  		/* mfspr R12, LR */
		/* 82072720h case    0:*/		regs.R12 = regs.LR;
		/* 82072720h case    0:*/		return 0x82072724;
		  /* 82072724h */ case    1:  		/* bl 125752 */
		/* 82072724h case    1:*/		regs.LR = 0x82072728; return 0x8209125C;
		/* 82072724h case    1:*/		return 0x82072728;
		  /* 82072728h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82072728h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82072728h case    2:*/		return 0x8207272C;
		  /* 8207272Ch */ case    3:  		/* lwz R11, <#[R3 + 11024]> */
		/* 8207272Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B10) );
		/* 8207272Ch case    3:*/		return 0x82072730;
		  /* 82072730h */ case    4:  		/* mr R31, R3 */
		/* 82072730h case    4:*/		regs.R31 = regs.R3;
		/* 82072730h case    4:*/		return 0x82072734;
		  /* 82072734h */ case    5:  		/* mr R29, R4 */
		/* 82072734h case    5:*/		regs.R29 = regs.R4;
		/* 82072734h case    5:*/		return 0x82072738;
		  /* 82072738h */ case    6:  		/* mr R30, R5 */
		/* 82072738h case    6:*/		regs.R30 = regs.R5;
		/* 82072738h case    6:*/		return 0x8207273C;
		  /* 8207273Ch */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 8207273Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8207273Ch case    7:*/		return 0x82072740;
		  /* 82072740h */ case    8:  		/* subf R10, R11, R5 */
		/* 82072740h case    8:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R5);
		/* 82072740h case    8:*/		return 0x82072744;
		  /* 82072744h */ case    9:  		/* rlwinm. R10, R10, 0, 30, 31 */
		/* 82072744h case    9:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R10,regs.R10);
		/* 82072744h case    9:*/		return 0x82072748;
		  /* 82072748h */ case   10:  		/* bc 12, CR0_EQ, 104 */
		/* 82072748h case   10:*/		if ( regs.CR[0].eq ) { return 0x820727B0;  }
		/* 82072748h case   10:*/		return 0x8207274C;
		  /* 8207274Ch */ case   11:  		/* cmplwi CR6, R10, 1 */
		/* 8207274Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8207274Ch case   11:*/		return 0x82072750;
		  /* 82072750h */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 82072750h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82072760;  }
		/* 82072750h case   12:*/		return 0x82072754;
		  /* 82072754h */ case   13:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 82072754h case   13:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 82072754h case   13:*/		return 0x82072758;
		  /* 82072758h */ case   14:  		/* cmplw CR6, R4, R11 */
		/* 82072758h case   14:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82072758h case   14:*/		return 0x8207275C;
		  /* 8207275Ch */ case   15:  		/* bc 4, CR6_GT, 84 */
		/* 8207275Ch case   15:*/		if ( !regs.CR[6].gt ) { return 0x820727B0;  }
		/* 8207275Ch case   15:*/		return 0x82072760;
	}
	return 0x82072760;
} // Block from 82072720h-82072760h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82072760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072760);
		  /* 82072760h */ case    0:  		/* li R5, 2 */
		/* 82072760h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82072760h case    0:*/		return 0x82072764;
		  /* 82072764h */ case    1:  		/* mr R4, R31 */
		/* 82072764h case    1:*/		regs.R4 = regs.R31;
		/* 82072764h case    1:*/		return 0x82072768;
		  /* 82072768h */ case    2:  		/* addi R3, R1, 80 */
		/* 82072768h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82072768h case    2:*/		return 0x8207276C;
		  /* 8207276Ch */ case    3:  		/* bl 41980 */
		/* 8207276Ch case    3:*/		regs.LR = 0x82072770; return 0x8207CB68;
		/* 8207276Ch case    3:*/		return 0x82072770;
		  /* 82072770h */ case    4:  		/* addi R3, R1, 80 */
		/* 82072770h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82072770h case    4:*/		return 0x82072774;
		  /* 82072774h */ case    5:  		/* bl 42220 */
		/* 82072774h case    5:*/		regs.LR = 0x82072778; return 0x8207CC60;
		/* 82072774h case    5:*/		return 0x82072778;
		  /* 82072778h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 82072778h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82072778h case    6:*/		return 0x8207277C;
		  /* 8207277Ch */ case    7:  		/* bc 12, CR0_EQ, 44 */
		/* 8207277Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820727A8;  }
		/* 8207277Ch case    7:*/		return 0x82072780;
		  /* 82072780h */ case    8:  		/* lwz R11, <#[R31 + 11024]> */
		/* 82072780h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 82072780h case    8:*/		return 0x82072784;
		  /* 82072784h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 82072784h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82072784h case    9:*/		return 0x82072788;
		  /* 82072788h */ case   10:  		/* subf R10, R11, R30 */
		/* 82072788h case   10:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R30);
		/* 82072788h case   10:*/		return 0x8207278C;
		  /* 8207278Ch */ case   11:  		/* rlwinm. R10, R10, 0, 30, 31 */
		/* 8207278Ch case   11:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R10,regs.R10);
		/* 8207278Ch case   11:*/		return 0x82072790;
		  /* 82072790h */ case   12:  		/* bc 12, CR0_EQ, 24 */
		/* 82072790h case   12:*/		if ( regs.CR[0].eq ) { return 0x820727A8;  }
		/* 82072790h case   12:*/		return 0x82072794;
		  /* 82072794h */ case   13:  		/* cmplwi CR6, R10, 1 */
		/* 82072794h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82072794h case   13:*/		return 0x82072798;
		  /* 82072798h */ case   14:  		/* bc 4, CR6_EQ, -40 */
		/* 82072798h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82072770;  }
		/* 82072798h case   14:*/		return 0x8207279C;
		  /* 8207279Ch */ case   15:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 8207279Ch case   15:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 8207279Ch case   15:*/		return 0x820727A0;
		  /* 820727A0h */ case   16:  		/* cmplw CR6, R29, R11 */
		/* 820727A0h case   16:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820727A0h case   16:*/		return 0x820727A4;
		  /* 820727A4h */ case   17:  		/* bc 12, CR6_GT, -52 */
		/* 820727A4h case   17:*/		if ( regs.CR[6].gt ) { return 0x82072770;  }
		/* 820727A4h case   17:*/		return 0x820727A8;
	}
	return 0x820727A8;
} // Block from 82072760h-820727A8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820727A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820727A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820727A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820727A8);
		  /* 820727A8h */ case    0:  		/* addi R3, R1, 80 */
		/* 820727A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820727A8h case    0:*/		return 0x820727AC;
		  /* 820727ACh */ case    1:  		/* bl 41964 */
		/* 820727ACh case    1:*/		regs.LR = 0x820727B0; return 0x8207CB98;
		/* 820727ACh case    1:*/		return 0x820727B0;
	}
	return 0x820727B0;
} // Block from 820727A8h-820727B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820727B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820727B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820727B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820727B0);
		  /* 820727B0h */ case    0:  		/* addi R1, R1, 144 */
		/* 820727B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820727B0h case    0:*/		return 0x820727B4;
		  /* 820727B4h */ case    1:  		/* b 125688 */
		/* 820727B4h case    1:*/		return 0x820912AC;
		/* 820727B4h case    1:*/		return 0x820727B8;
	}
	return 0x820727B8;
} // Block from 820727B0h-820727B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820727B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820727B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820727B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820727B8);
		  /* 820727B8h */ case    0:  		/* mfspr R12, LR */
		/* 820727B8h case    0:*/		regs.R12 = regs.LR;
		/* 820727B8h case    0:*/		return 0x820727BC;
		  /* 820727BCh */ case    1:  		/* bl 125600 */
		/* 820727BCh case    1:*/		regs.LR = 0x820727C0; return 0x8209125C;
		/* 820727BCh case    1:*/		return 0x820727C0;
		  /* 820727C0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820727C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820727C0h case    2:*/		return 0x820727C4;
		  /* 820727C4h */ case    3:  		/* lwz R11, <#[R3 + 15304]> */
		/* 820727C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003BC8) );
		/* 820727C4h case    3:*/		return 0x820727C8;
		  /* 820727C8h */ case    4:  		/* add R10, R4, R5 */
		/* 820727C8h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R4,regs.R5);
		/* 820727C8h case    4:*/		return 0x820727CC;
		  /* 820727CCh */ case    5:  		/* lwz R9, <#[R3 + 11024]> */
		/* 820727CCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00002B10) );
		/* 820727CCh case    5:*/		return 0x820727D0;
		  /* 820727D0h */ case    6:  		/* mr R29, R3 */
		/* 820727D0h case    6:*/		regs.R29 = regs.R3;
		/* 820727D0h case    6:*/		return 0x820727D4;
		  /* 820727D4h */ case    7:  		/* and R30, R10, R11 */
		/* 820727D4h case    7:*/		cpu::op::and<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 820727D4h case    7:*/		return 0x820727D8;
		  /* 820727D8h */ case    8:  		/* mr R31, R4 */
		/* 820727D8h case    8:*/		regs.R31 = regs.R4;
		/* 820727D8h case    8:*/		return 0x820727DC;
		  /* 820727DCh */ case    9:  		/* cmplw CR6, R4, R30 */
		/* 820727DCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R30);
		/* 820727DCh case    9:*/		return 0x820727E0;
		  /* 820727E0h */ case   10:  		/* lwz R11, <#[R9 + 60]> */
		/* 820727E0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000003C) );
		/* 820727E0h case   10:*/		return 0x820727E4;
		  /* 820727E4h */ case   11:  		/* bc 4, CR6_LT, 24 */
		/* 820727E4h case   11:*/		if ( !regs.CR[6].lt ) { return 0x820727FC;  }
		/* 820727E4h case   11:*/		return 0x820727E8;
		  /* 820727E8h */ case   12:  		/* cmplw CR6, R4, R11 */
		/* 820727E8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820727E8h case   12:*/		return 0x820727EC;
		  /* 820727ECh */ case   13:  		/* bc 4, CR6_LT, 108 */
		/* 820727ECh case   13:*/		if ( !regs.CR[6].lt ) { return 0x82072858;  }
		/* 820727ECh case   13:*/		return 0x820727F0;
		  /* 820727F0h */ case   14:  		/* cmplw CR6, R11, R30 */
		/* 820727F0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 820727F0h case   14:*/		return 0x820727F4;
		  /* 820727F4h */ case   15:  		/* bc 4, CR6_GT, 16 */
		/* 820727F4h case   15:*/		if ( !regs.CR[6].gt ) { return 0x82072804;  }
		/* 820727F4h case   15:*/		return 0x820727F8;
		  /* 820727F8h */ case   16:  		/* b 96 */
		/* 820727F8h case   16:*/		return 0x82072858;
		/* 820727F8h case   16:*/		return 0x820727FC;
	}
	return 0x820727FC;
} // Block from 820727B8h-820727FCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820727FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820727FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820727FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820727FC);
		  /* 820727FCh */ case    0:  		/* cmplw CR6, R31, R11 */
		/* 820727FCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820727FCh case    0:*/		return 0x82072800;
		  /* 82072800h */ case    1:  		/* bc 4, CR6_LT, -16 */
		/* 82072800h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820727F0;  }
		/* 82072800h case    1:*/		return 0x82072804;
	}
	return 0x82072804;
} // Block from 820727FCh-82072804h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072804);
		  /* 82072804h */ case    0:  		/* li R5, 1 */
		/* 82072804h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82072804h case    0:*/		return 0x82072808;
		  /* 82072808h */ case    1:  		/* mr R4, R29 */
		/* 82072808h case    1:*/		regs.R4 = regs.R29;
		/* 82072808h case    1:*/		return 0x8207280C;
		  /* 8207280Ch */ case    2:  		/* addi R3, R1, 80 */
		/* 8207280Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8207280Ch case    2:*/		return 0x82072810;
		  /* 82072810h */ case    3:  		/* bl 41816 */
		/* 82072810h case    3:*/		regs.LR = 0x82072814; return 0x8207CB68;
		/* 82072810h case    3:*/		return 0x82072814;
		  /* 82072814h */ case    4:  		/* addi R3, R1, 80 */
		/* 82072814h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82072814h case    4:*/		return 0x82072818;
		  /* 82072818h */ case    5:  		/* bl 42056 */
		/* 82072818h case    5:*/		regs.LR = 0x8207281C; return 0x8207CC60;
		/* 82072818h case    5:*/		return 0x8207281C;
		  /* 8207281Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 8207281Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8207281Ch case    6:*/		return 0x82072820;
		  /* 82072820h */ case    7:  		/* bc 12, CR0_EQ, 48 */
		/* 82072820h case    7:*/		if ( regs.CR[0].eq ) { return 0x82072850;  }
		/* 82072820h case    7:*/		return 0x82072824;
		  /* 82072824h */ case    8:  		/* lwz R11, <#[R29 + 11024]> */
		/* 82072824h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00002B10) );
		/* 82072824h case    8:*/		return 0x82072828;
		  /* 82072828h */ case    9:  		/* cmplw CR6, R31, R30 */
		/* 82072828h case    9:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 82072828h case    9:*/		return 0x8207282C;
		  /* 8207282Ch */ case   10:  		/* lwz R11, <#[R11 + 60]> */
		/* 8207282Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000003C) );
		/* 8207282Ch case   10:*/		return 0x82072830;
		  /* 82072830h */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 82072830h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82072840;  }
		/* 82072830h case   11:*/		return 0x82072834;
		  /* 82072834h */ case   12:  		/* cmplw CR6, R31, R11 */
		/* 82072834h case   12:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82072834h case   12:*/		return 0x82072838;
		  /* 82072838h */ case   13:  		/* bc 4, CR6_LT, 24 */
		/* 82072838h case   13:*/		if ( !regs.CR[6].lt ) { return 0x82072850;  }
		/* 82072838h case   13:*/		return 0x8207283C;
		  /* 8207283Ch */ case   14:  		/* b 12 */
		/* 8207283Ch case   14:*/		return 0x82072848;
		/* 8207283Ch case   14:*/		return 0x82072840;
	}
	return 0x82072840;
} // Block from 82072804h-82072840h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82072840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072840);
		  /* 82072840h */ case    0:  		/* cmplw CR6, R31, R11 */
		/* 82072840h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82072840h case    0:*/		return 0x82072844;
		  /* 82072844h */ case    1:  		/* bc 12, CR6_LT, -48 */
		/* 82072844h case    1:*/		if ( regs.CR[6].lt ) { return 0x82072814;  }
		/* 82072844h case    1:*/		return 0x82072848;
	}
	return 0x82072848;
} // Block from 82072840h-82072848h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072848);
		  /* 82072848h */ case    0:  		/* cmplw CR6, R11, R30 */
		/* 82072848h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 82072848h case    0:*/		return 0x8207284C;
		  /* 8207284Ch */ case    1:  		/* bc 4, CR6_GT, -56 */
		/* 8207284Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x82072814;  }
		/* 8207284Ch case    1:*/		return 0x82072850;
	}
	return 0x82072850;
} // Block from 82072848h-82072850h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072850);
		  /* 82072850h */ case    0:  		/* addi R3, R1, 80 */
		/* 82072850h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82072850h case    0:*/		return 0x82072854;
		  /* 82072854h */ case    1:  		/* bl 41796 */
		/* 82072854h case    1:*/		regs.LR = 0x82072858; return 0x8207CB98;
		/* 82072854h case    1:*/		return 0x82072858;
	}
	return 0x82072858;
} // Block from 82072850h-82072858h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072858);
		  /* 82072858h */ case    0:  		/* mr R3, R30 */
		/* 82072858h case    0:*/		regs.R3 = regs.R30;
		/* 82072858h case    0:*/		return 0x8207285C;
		  /* 8207285Ch */ case    1:  		/* addi R1, R1, 144 */
		/* 8207285Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8207285Ch case    1:*/		return 0x82072860;
		  /* 82072860h */ case    2:  		/* b 125516 */
		/* 82072860h case    2:*/		return 0x820912AC;
		/* 82072860h case    2:*/		return 0x82072864;
		  /* 82072864h */ case    3:  		/* nop */
		/* 82072864h case    3:*/		cpu::op::nop();
		/* 82072864h case    3:*/		return 0x82072868;
	}
	return 0x82072868;
} // Block from 82072858h-82072868h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82072868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072868);
		  /* 82072868h */ case    0:  		/* mfspr R12, LR */
		/* 82072868h case    0:*/		regs.R12 = regs.LR;
		/* 82072868h case    0:*/		return 0x8207286C;
		  /* 8207286Ch */ case    1:  		/* bl 125420 */
		/* 8207286Ch case    1:*/		regs.LR = 0x82072870; return 0x82091258;
		/* 8207286Ch case    1:*/		return 0x82072870;
		  /* 82072870h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82072870h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82072870h case    2:*/		return 0x82072874;
		  /* 82072874h */ case    3:  		/* mr R31, R3 */
		/* 82072874h case    3:*/		regs.R31 = regs.R3;
		/* 82072874h case    3:*/		return 0x82072878;
		  /* 82072878h */ case    4:  		/* lwz R3, <#[R3 + 21940]> */
		/* 82072878h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000055B4) );
		/* 82072878h case    4:*/		return 0x8207287C;
		  /* 8207287Ch */ case    5:  		/* stw R4, <#[R1 + 156]> */
		/* 8207287Ch case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000009C) );
		/* 8207287Ch case    5:*/		return 0x82072880;
		  /* 82072880h */ case    6:  		/* stw R5, <#[R1 + 164]> */
		/* 82072880h case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x000000A4) );
		/* 82072880h case    6:*/		return 0x82072884;
		  /* 82072884h */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 82072884h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82072884h case    7:*/		return 0x82072888;
		  /* 82072888h */ case    8:  		/* bc 12, CR6_EQ, 44 */
		/* 82072888h case    8:*/		if ( regs.CR[6].eq ) { return 0x820728B4;  }
		/* 82072888h case    8:*/		return 0x8207288C;
		  /* 8207288Ch */ case    9:  		/* lis R11, -32216 */
		/* 8207288Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8207288Ch case    9:*/		return 0x82072890;
		  /* 82072890h */ case   10:  		/* lwz R11, <#[R11 + 28740]> */
		/* 82072890h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00007044) );
		/* 82072890h case   10:*/		return 0x82072894;
		  /* 82072894h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 82072894h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82072894h case   11:*/		return 0x82072898;
		  /* 82072898h */ case   12:  		/* bc 4, CR6_EQ, 28 */
		/* 82072898h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820728B4;  }
		/* 82072898h case   12:*/		return 0x8207289C;
		  /* 8207289Ch */ case   13:  		/* lwz R11, <#[R3]> */
		/* 8207289Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8207289Ch case   13:*/		return 0x820728A0;
		  /* 820728A0h */ case   14:  		/* li R7, 0 */
		/* 820728A0h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820728A0h case   14:*/		return 0x820728A4;
		  /* 820728A4h */ case   15:  		/* li R6, 0 */
		/* 820728A4h case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820728A4h case   15:*/		return 0x820728A8;
		  /* 820728A8h */ case   16:  		/* lwz R11, <#[R11 + 24]> */
		/* 820728A8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820728A8h case   16:*/		return 0x820728AC;
		  /* 820728ACh */ case   17:  		/* mtspr CTR, R11 */
		/* 820728ACh case   17:*/		regs.CTR = regs.R11;
		/* 820728ACh case   17:*/		return 0x820728B0;
		  /* 820728B0h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 820728B0h case   18:*/		if ( 1 ) { regs.LR = 0x820728B4; return (uint32)regs.CTR; }
		/* 820728B0h case   18:*/		return 0x820728B4;
	}
	return 0x820728B4;
} // Block from 82072868h-820728B4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820728B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820728B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820728B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820728B4);
		  /* 820728B4h */ case    0:  		/* lwz R11, <#[R31 + 23768]> */
		/* 820728B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005CD8) );
		/* 820728B4h case    0:*/		return 0x820728B8;
		  /* 820728B8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820728B8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820728B8h case    1:*/		return 0x820728BC;
		  /* 820728BCh */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 820728BCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820728D8;  }
		/* 820728BCh case    2:*/		return 0x820728C0;
		  /* 820728C0h */ case    3:  		/* li R6, 0 */
		/* 820728C0h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820728C0h case    3:*/		return 0x820728C4;
		  /* 820728C4h */ case    4:  		/* mtspr CTR, R11 */
		/* 820728C4h case    4:*/		regs.CTR = regs.R11;
		/* 820728C4h case    4:*/		return 0x820728C8;
		  /* 820728C8h */ case    5:  		/* addi R5, R1, 164 */
		/* 820728C8h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xA4);
		/* 820728C8h case    5:*/		return 0x820728CC;
		  /* 820728CCh */ case    6:  		/* addi R4, R1, 156 */
		/* 820728CCh case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x9C);
		/* 820728CCh case    6:*/		return 0x820728D0;
		  /* 820728D0h */ case    7:  		/* li R3, 1 */
		/* 820728D0h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820728D0h case    7:*/		return 0x820728D4;
		  /* 820728D4h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820728D4h case    8:*/		if ( 1 ) { regs.LR = 0x820728D8; return (uint32)regs.CTR; }
		/* 820728D4h case    8:*/		return 0x820728D8;
	}
	return 0x820728D8;
} // Block from 820728B4h-820728D8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820728D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820728D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820728D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820728D8);
		  /* 820728D8h */ case    0:  		/* lwz R30, <#[R31 + 11088]> */
		/* 820728D8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00002B50) );
		/* 820728D8h case    0:*/		return 0x820728DC;
		  /* 820728DCh */ case    1:  		/* mr R3, R31 */
		/* 820728DCh case    1:*/		regs.R3 = regs.R31;
		/* 820728DCh case    1:*/		return 0x820728E0;
		  /* 820728E0h */ case    2:  		/* lwz R29, <#[R31 + 15304]> */
		/* 820728E0h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00003BC8) );
		/* 820728E0h case    2:*/		return 0x820728E4;
		  /* 820728E4h */ case    3:  		/* mr R4, R30 */
		/* 820728E4h case    3:*/		regs.R4 = regs.R30;
		/* 820728E4h case    3:*/		return 0x820728E8;
		  /* 820728E8h */ case    4:  		/* lwz R5, <#[R1 + 164]> */
		/* 820728E8h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000A4) );
		/* 820728E8h case    4:*/		return 0x820728EC;
		  /* 820728ECh */ case    5:  		/* lwz R28, <#[R31 + 15300]> */
		/* 820728ECh case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x00003BC4) );
		/* 820728ECh case    5:*/		return 0x820728F0;
		  /* 820728F0h */ case    6:  		/* bl -312 */
		/* 820728F0h case    6:*/		regs.LR = 0x820728F4; return 0x820727B8;
		/* 820728F0h case    6:*/		return 0x820728F4;
		  /* 820728F4h */ case    7:  		/* lwz R10, <#[R1 + 164]> */
		/* 820728F4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000000A4) );
		/* 820728F4h case    7:*/		return 0x820728F8;
		  /* 820728F8h */ case    8:  		/* li R11, 0 */
		/* 820728F8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820728F8h case    8:*/		return 0x820728FC;
		  /* 820728FCh */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 820728FCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820728FCh case    9:*/		return 0x82072900;
		  /* 82072900h */ case   10:  		/* bc 12, CR6_EQ, 52 */
		/* 82072900h case   10:*/		if ( regs.CR[6].eq ) { return 0x82072934;  }
		/* 82072900h case   10:*/		return 0x82072904;
		  /* 82072904h */ case   11:  		/* li R10, 0 */
		/* 82072904h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82072904h case   11:*/		return 0x82072908;
		  /* 82072908h */ case   12:  		/* lwz R9, <#[R1 + 156]> */
		/* 82072908h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000009C) );
		/* 82072908h case   12:*/		return 0x8207290C;
		  /* 8207290Ch */ case   13:  		/* rlwinm R8, R30, 2, 0, 29 */
		/* 8207290Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R30);
		/* 8207290Ch case   13:*/		return 0x82072910;
		  /* 82072910h */ case   14:  		/* addi R7, R30, 1 */
		/* 82072910h case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R30,0x1);
		/* 82072910h case   14:*/		return 0x82072914;
		  /* 82072914h */ case   15:  		/* addi R11, R11, 1 */
		/* 82072914h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82072914h case   15:*/		return 0x82072918;
		  /* 82072918h */ case   16:  		/* and R30, R7, R29 */
		/* 82072918h case   16:*/		cpu::op::and<0>(regs,&regs.R30,regs.R7,regs.R29);
		/* 82072918h case   16:*/		return 0x8207291C;
		  /* 8207291Ch */ case   17:  		/* lwzx R9, <#[R10 + R9]> */
		/* 8207291Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8207291Ch case   17:*/		return 0x82072920;
		  /* 82072920h */ case   18:  		/* addi R10, R10, 4 */
		/* 82072920h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82072920h case   18:*/		return 0x82072924;
		  /* 82072924h */ case   19:  		/* stwx R9, <#[R8 + R28]> */
		/* 82072924h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R28 + 0x00000000) );
		/* 82072924h case   19:*/		return 0x82072928;
		  /* 82072928h */ case   20:  		/* lwz R9, <#[R1 + 164]> */
		/* 82072928h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000A4) );
		/* 82072928h case   20:*/		return 0x8207292C;
		  /* 8207292Ch */ case   21:  		/* cmplw CR6, R11, R9 */
		/* 8207292Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8207292Ch case   21:*/		return 0x82072930;
		  /* 82072930h */ case   22:  		/* bc 12, CR6_LT, -40 */
		/* 82072930h case   22:*/		if ( regs.CR[6].lt ) { return 0x82072908;  }
		/* 82072930h case   22:*/		return 0x82072934;
	}
	return 0x82072934;
} // Block from 820728D8h-82072934h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82072934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072934);
		  /* 82072934h */ case    0:  		/* lwz R3, <#[R31 + 21940]> */
		/* 82072934h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000055B4) );
		/* 82072934h case    0:*/		return 0x82072938;
		  /* 82072938h */ case    1:  		/* stw R30, <#[R31 + 11088]> */
		/* 82072938h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00002B50) );
		/* 82072938h case    1:*/		return 0x8207293C;
		  /* 8207293Ch */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 8207293Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8207293Ch case    2:*/		return 0x82072940;
		  /* 82072940h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 82072940h case    3:*/		if ( regs.CR[6].eq ) { return 0x82072954;  }
		/* 82072940h case    3:*/		return 0x82072944;
		  /* 82072944h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 82072944h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82072944h case    4:*/		return 0x82072948;
		  /* 82072948h */ case    5:  		/* lwz R11, <#[R11 + 28]> */
		/* 82072948h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82072948h case    5:*/		return 0x8207294C;
		  /* 8207294Ch */ case    6:  		/* mtspr CTR, R11 */
		/* 8207294Ch case    6:*/		regs.CTR = regs.R11;
		/* 8207294Ch case    6:*/		return 0x82072950;
		  /* 82072950h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82072950h case    7:*/		if ( 1 ) { regs.LR = 0x82072954; return (uint32)regs.CTR; }
		/* 82072950h case    7:*/		return 0x82072954;
	}
	return 0x82072954;
} // Block from 82072934h-82072954h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82072954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072954);
		  /* 82072954h */ case    0:  		/* lwz R11, <#[R31 + 23768]> */
		/* 82072954h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005CD8) );
		/* 82072954h case    0:*/		return 0x82072958;
		  /* 82072958h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82072958h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82072958h case    1:*/		return 0x8207295C;
		  /* 8207295Ch */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 8207295Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82072978;  }
		/* 8207295Ch case    2:*/		return 0x82072960;
		  /* 82072960h */ case    3:  		/* li R6, 0 */
		/* 82072960h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82072960h case    3:*/		return 0x82072964;
		  /* 82072964h */ case    4:  		/* mtspr CTR, R11 */
		/* 82072964h case    4:*/		regs.CTR = regs.R11;
		/* 82072964h case    4:*/		return 0x82072968;
		  /* 82072968h */ case    5:  		/* li R5, 0 */
		/* 82072968h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82072968h case    5:*/		return 0x8207296C;
		  /* 8207296Ch */ case    6:  		/* li R4, 0 */
		/* 8207296Ch case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8207296Ch case    6:*/		return 0x82072970;
		  /* 82072970h */ case    7:  		/* li R3, 2 */
		/* 82072970h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82072970h case    7:*/		return 0x82072974;
		  /* 82072974h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 82072974h case    8:*/		if ( 1 ) { regs.LR = 0x82072978; return (uint32)regs.CTR; }
		/* 82072974h case    8:*/		return 0x82072978;
	}
	return 0x82072978;
} // Block from 82072954h-82072978h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82072978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072978);
		  /* 82072978h */ case    0:  		/* addi R1, R1, 128 */
		/* 82072978h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82072978h case    0:*/		return 0x8207297C;
		  /* 8207297Ch */ case    1:  		/* b 125228 */
		/* 8207297Ch case    1:*/		return 0x820912A8;
		/* 8207297Ch case    1:*/		return 0x82072980;
		  /* 82072980h */ case    2:  		/* stw R4, <#[R3 + 11088]> */
		/* 82072980h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00002B50) );
		/* 82072980h case    2:*/		return 0x82072984;
		  /* 82072984h */ case    3:  		/* sync */
		/* 82072984h case    3:*/		cpu::op::sync<0>(regs);
		/* 82072984h case    3:*/		return 0x82072988;
		  /* 82072988h */ case    4:  		/* lis R11, 32712 */
		/* 82072988h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FC8);
		/* 82072988h case    4:*/		return 0x8207298C;
		  /* 8207298Ch */ case    5:  		/* stw R4, <#[R11 + 1812]> */
		/* 8207298Ch case    5:*/		regs.IO->MEM_WRITE( 0x8207298C, (uint32)(regs.R11 + 0x00000714), 4, &regs.R4 );
		/* 8207298Ch case    5:*/		return 0x82072990;
		  /* 82072990h */ case    6:  		/* eieio */
		/* 82072990h case    6:*/		cpu::op::eieio<0>(regs);
		/* 82072990h case    6:*/		return 0x82072994;
		  /* 82072994h */ case    7:  		/* sync */
		/* 82072994h case    7:*/		cpu::op::sync<0>(regs);
		/* 82072994h case    7:*/		return 0x82072998;
		  /* 82072998h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82072998h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82072998h case    8:*/		return 0x8207299C;
	}
	return 0x8207299C;
} // Block from 82072978h-8207299Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8207299Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207299C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207299C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207299C);
		  /* 8207299Ch */ case    0:  		/* nop */
		/* 8207299Ch case    0:*/		cpu::op::nop();
		/* 8207299Ch case    0:*/		return 0x820729A0;
	}
	return 0x820729A0;
} // Block from 8207299Ch-820729A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820729A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820729A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820729A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820729A0);
		  /* 820729A0h */ case    0:  		/* ld R11, <#[R3]> */
		/* 820729A0h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820729A0h case    0:*/		return 0x820729A4;
		  /* 820729A4h */ case    1:  		/* rlwinm R10, R11, 0, 0, 31 */
		/* 820729A4h case    1:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R11);
		/* 820729A4h case    1:*/		return 0x820729A8;
		  /* 820729A8h */ case    2:  		/* cmplw CR6, R4, R10 */
		/* 820729A8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 820729A8h case    2:*/		return 0x820729AC;
		  /* 820729ACh */ case    3:  		/* bc 4, CR6_LT, 8 */
		/* 820729ACh case    3:*/		if ( !regs.CR[6].lt ) { return 0x820729B4;  }
		/* 820729ACh case    3:*/		return 0x820729B0;
		  /* 820729B0h */ case    4:  		/* mr R10, R4 */
		/* 820729B0h case    4:*/		regs.R10 = regs.R4;
		/* 820729B0h case    4:*/		return 0x820729B4;
	}
	return 0x820729B4;
} // Block from 820729A0h-820729B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820729B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820729B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820729B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820729B4);
		  /* 820729B4h */ case    0:  		/* rldicl R9, R11, 32, 32 */
		/* 820729B4h case    0:*/		cpu::op::rldicl<0,32,32>(regs,&regs.R9,regs.R11);
		/* 820729B4h case    0:*/		return 0x820729B8;
		  /* 820729B8h */ case    1:  		/* cmplw CR6, R5, R9 */
		/* 820729B8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R9);
		/* 820729B8h case    1:*/		return 0x820729BC;
		  /* 820729BCh */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 820729BCh case    2:*/		if ( !regs.CR[6].gt ) { return 0x820729C4;  }
		/* 820729BCh case    2:*/		return 0x820729C0;
		  /* 820729C0h */ case    3:  		/* mr R9, R5 */
		/* 820729C0h case    3:*/		regs.R9 = regs.R5;
		/* 820729C0h case    3:*/		return 0x820729C4;
	}
	return 0x820729C4;
} // Block from 820729B4h-820729C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820729C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820729C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820729C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820729C4);
		  /* 820729C4h */ case    0:  		/* rldicl R10, R10, 0, 32 */
		/* 820729C4h case    0:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 820729C4h case    0:*/		return 0x820729C8;
		  /* 820729C8h */ case    1:  		/* rldimi R10, R9, 32, 0 */
		/* 820729C8h case    1:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R9);
		/* 820729C8h case    1:*/		return 0x820729CC;
		  /* 820729CCh */ case    2:  		/* mfmsr R7, MSR */
		/* 820729CCh case    2:*/		regs.R7 = regs.MSR;
		/* 820729CCh case    2:*/		return 0x820729D0;
		  /* 820729D0h */ case    3:  		/* mtmsrd MSR, R13 */
		/* 820729D0h case    3:*/		regs.MSR = regs.R13;
		/* 820729D0h case    3:*/		return 0x820729D4;
		  /* 820729D4h */ case    4:  		/* ldarx R8, <#[R3]> */
		/* 820729D4h case    4:*/		cpu::mem::ldarx( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820729D4h case    4:*/		return 0x820729D8;
		  /* 820729D8h */ case    5:  		/* cmpd CR6, R8, R11 */
		/* 820729D8h case    5:*/		cpu::op::cmpd<6>(regs,regs.R8,regs.R11);
		/* 820729D8h case    5:*/		return 0x820729DC;
		  /* 820729DCh */ case    6:  		/* bc 4, CR6_EQ, 20 */
		/* 820729DCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x820729F0;  }
		/* 820729DCh case    6:*/		return 0x820729E0;
		  /* 820729E0h */ case    7:  		/* stdcx. R10, <#[R3]> */
		/* 820729E0h case    7:*/		cpu::mem::stdcx( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820729E0h case    7:*/		return 0x820729E4;
		  /* 820729E4h */ case    8:  		/* mtmsrd MSR, R7 */
		/* 820729E4h case    8:*/		regs.MSR = regs.R7;
		/* 820729E4h case    8:*/		return 0x820729E8;
		  /* 820729E8h */ case    9:  		/* bc 4, CR0_EQ, -28 */
		/* 820729E8h case    9:*/		if ( !regs.CR[0].eq ) { return 0x820729CC;  }
		/* 820729E8h case    9:*/		return 0x820729EC;
		  /* 820729ECh */ case   10:  		/* b 12 */
		/* 820729ECh case   10:*/		return 0x820729F8;
		/* 820729ECh case   10:*/		return 0x820729F0;
	}
	return 0x820729F0;
} // Block from 820729C4h-820729F0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820729F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820729F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820729F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820729F0);
		  /* 820729F0h */ case    0:  		/* stdcx. R8, <#[R3]> */
		/* 820729F0h case    0:*/		cpu::mem::stdcx( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820729F0h case    0:*/		return 0x820729F4;
		  /* 820729F4h */ case    1:  		/* mtmsrd MSR, R7 */
		/* 820729F4h case    1:*/		regs.MSR = regs.R7;
		/* 820729F4h case    1:*/		return 0x820729F8;
	}
	return 0x820729F8;
} // Block from 820729F0h-820729F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820729F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820729F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820729F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820729F8);
		  /* 820729F8h */ case    0:  		/* mr R10, R8 */
		/* 820729F8h case    0:*/		regs.R10 = regs.R8;
		/* 820729F8h case    0:*/		return 0x820729FC;
		  /* 820729FCh */ case    1:  		/* cmpld CR6, R8, R11 */
		/* 820729FCh case    1:*/		cpu::op::cmpld<6>(regs,regs.R8,regs.R11);
		/* 820729FCh case    1:*/		return 0x82072A00;
		  /* 82072A00h */ case    2:  		/* bc 4, CR6_EQ, -96 */
		/* 82072A00h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820729A0;  }
		/* 82072A00h case    2:*/		return 0x82072A04;
		  /* 82072A04h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82072A04h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82072A04h case    3:*/		return 0x82072A08;
	}
	return 0x82072A08;
} // Block from 820729F8h-82072A08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82072A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072A08);
		  /* 82072A08h */ case    0:  		/* li R10, -1 */
		/* 82072A08h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82072A08h case    0:*/		return 0x82072A0C;
		  /* 82072A0Ch */ case    1:  		/* ld R11, <#[R3]> */
		/* 82072A0Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82072A0Ch case    1:*/		return 0x82072A10;
		  /* 82072A10h */ case    2:  		/* rldicl R10, R10, 0, 32 */
		/* 82072A10h case    2:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 82072A10h case    2:*/		return 0x82072A14;
		  /* 82072A14h */ case    3:  		/* mfmsr R8, MSR */
		/* 82072A14h case    3:*/		regs.R8 = regs.MSR;
		/* 82072A14h case    3:*/		return 0x82072A18;
		  /* 82072A18h */ case    4:  		/* mtmsrd MSR, R13 */
		/* 82072A18h case    4:*/		regs.MSR = regs.R13;
		/* 82072A18h case    4:*/		return 0x82072A1C;
		  /* 82072A1Ch */ case    5:  		/* ldarx R9, <#[R3]> */
		/* 82072A1Ch case    5:*/		cpu::mem::ldarx( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82072A1Ch case    5:*/		return 0x82072A20;
		  /* 82072A20h */ case    6:  		/* cmpd CR6, R9, R11 */
		/* 82072A20h case    6:*/		cpu::op::cmpd<6>(regs,regs.R9,regs.R11);
		/* 82072A20h case    6:*/		return 0x82072A24;
		  /* 82072A24h */ case    7:  		/* bc 4, CR6_EQ, 20 */
		/* 82072A24h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82072A38;  }
		/* 82072A24h case    7:*/		return 0x82072A28;
		  /* 82072A28h */ case    8:  		/* stdcx. R10, <#[R3]> */
		/* 82072A28h case    8:*/		cpu::mem::stdcx( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82072A28h case    8:*/		return 0x82072A2C;
		  /* 82072A2Ch */ case    9:  		/* mtmsrd MSR, R8 */
		/* 82072A2Ch case    9:*/		regs.MSR = regs.R8;
		/* 82072A2Ch case    9:*/		return 0x82072A30;
		  /* 82072A30h */ case   10:  		/* bc 4, CR0_EQ, -28 */
		/* 82072A30h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82072A14;  }
		/* 82072A30h case   10:*/		return 0x82072A34;
		  /* 82072A34h */ case   11:  		/* b 12 */
		/* 82072A34h case   11:*/		return 0x82072A40;
		/* 82072A34h case   11:*/		return 0x82072A38;
	}
	return 0x82072A38;
} // Block from 82072A08h-82072A38h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82072A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072A38);
		  /* 82072A38h */ case    0:  		/* stdcx. R9, <#[R3]> */
		/* 82072A38h case    0:*/		cpu::mem::stdcx( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82072A38h case    0:*/		return 0x82072A3C;
		  /* 82072A3Ch */ case    1:  		/* mtmsrd MSR, R8 */
		/* 82072A3Ch case    1:*/		regs.MSR = regs.R8;
		/* 82072A3Ch case    1:*/		return 0x82072A40;
	}
	return 0x82072A40;
} // Block from 82072A38h-82072A40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072A40);
		  /* 82072A40h */ case    0:  		/* mr R10, R9 */
		/* 82072A40h case    0:*/		regs.R10 = regs.R9;
		/* 82072A40h case    0:*/		return 0x82072A44;
		  /* 82072A44h */ case    1:  		/* cmpld CR6, R9, R11 */
		/* 82072A44h case    1:*/		cpu::op::cmpld<6>(regs,regs.R9,regs.R11);
		/* 82072A44h case    1:*/		return 0x82072A48;
		  /* 82072A48h */ case    2:  		/* bc 4, CR6_EQ, -64 */
		/* 82072A48h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82072A08;  }
		/* 82072A48h case    2:*/		return 0x82072A4C;
		  /* 82072A4Ch */ case    3:  		/* mr R10, R11 */
		/* 82072A4Ch case    3:*/		regs.R10 = regs.R11;
		/* 82072A4Ch case    3:*/		return 0x82072A50;
		  /* 82072A50h */ case    4:  		/* rldicl R11, R11, 32, 32 */
		/* 82072A50h case    4:*/		cpu::op::rldicl<0,32,32>(regs,&regs.R11,regs.R11);
		/* 82072A50h case    4:*/		return 0x82072A54;
		  /* 82072A54h */ case    5:  		/* stw R10, <#[R4]> */
		/* 82072A54h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82072A54h case    5:*/		return 0x82072A58;
		  /* 82072A58h */ case    6:  		/* stw R11, <#[R5]> */
		/* 82072A58h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82072A58h case    6:*/		return 0x82072A5C;
		  /* 82072A5Ch */ case    7:  		/* bclr 20, CR0_LT */
		/* 82072A5Ch case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82072A5Ch case    7:*/		return 0x82072A60;
	}
	return 0x82072A60;
} // Block from 82072A40h-82072A60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82072A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072A60);
		  /* 82072A60h */ case    0:  		/* mfspr R12, LR */
		/* 82072A60h case    0:*/		regs.R12 = regs.LR;
		/* 82072A60h case    0:*/		return 0x82072A64;
		  /* 82072A64h */ case    1:  		/* bl 124920 */
		/* 82072A64h case    1:*/		regs.LR = 0x82072A68; return 0x8209125C;
		/* 82072A64h case    1:*/		return 0x82072A68;
		  /* 82072A68h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82072A68h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82072A68h case    2:*/		return 0x82072A6C;
		  /* 82072A6Ch */ case    3:  		/* mr R31, R4 */
		/* 82072A6Ch case    3:*/		regs.R31 = regs.R4;
		/* 82072A6Ch case    3:*/		return 0x82072A70;
		  /* 82072A70h */ case    4:  		/* cmplwi CR6, R3, 1 */
		/* 82072A70h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000001);
		/* 82072A70h case    4:*/		return 0x82072A74;
		  /* 82072A74h */ case    5:  		/* bc 4, CR6_EQ, 88 */
		/* 82072A74h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82072ACC;  }
		/* 82072A74h case    5:*/		return 0x82072A78;
		  /* 82072A78h */ case    6:  		/* lwz R11, <#[R4 + 11028]> */
		/* 82072A78h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00002B14) );
		/* 82072A78h case    6:*/		return 0x82072A7C;
		  /* 82072A7Ch */ case    7:  		/* lwz R10, <#[R11 + 16]> */
		/* 82072A7Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82072A7Ch case    7:*/		return 0x82072A80;
		  /* 82072A80h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 82072A80h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82072A80h case    8:*/		return 0x82072A84;
		  /* 82072A84h */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 82072A84h case    9:*/		if ( regs.CR[6].eq ) { return 0x82072A94;  }
		/* 82072A84h case    9:*/		return 0x82072A88;
		  /* 82072A88h */ case   10:  		/* lwz R3, <#[R11 + 20]> */
		/* 82072A88h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000014) );
		/* 82072A88h case   10:*/		return 0x82072A8C;
		  /* 82072A8Ch */ case   11:  		/* mtspr CTR, R10 */
		/* 82072A8Ch case   11:*/		regs.CTR = regs.R10;
		/* 82072A8Ch case   11:*/		return 0x82072A90;
		  /* 82072A90h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 82072A90h case   12:*/		if ( 1 ) { regs.LR = 0x82072A94; return (uint32)regs.CTR; }
		/* 82072A90h case   12:*/		return 0x82072A94;
	}
	return 0x82072A94;
} // Block from 82072A60h-82072A94h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82072A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072A94);
		  /* 82072A94h */ case    0:  		/* addi R30, R31, 11032 */
		/* 82072A94h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x2B18);
		/* 82072A94h case    0:*/		return 0x82072A98;
		  /* 82072A98h */ case    1:  		/* lbz R11, <#[R13 + 268]> */
		/* 82072A98h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R13 + 0x0000010C) );
		/* 82072A98h case    1:*/		return 0x82072A9C;
		  /* 82072A9Ch */ case    2:  		/* li R10, 1 */
		/* 82072A9Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82072A9Ch case    2:*/		return 0x82072AA0;
		  /* 82072AA0h */ case    3:  		/* lwz R31, <#[R31 + 11028]> */
		/* 82072AA0h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00002B14) );
		/* 82072AA0h case    3:*/		return 0x82072AA4;
		  /* 82072AA4h */ case    4:  		/* mr R3, R30 */
		/* 82072AA4h case    4:*/		regs.R3 = regs.R30;
		/* 82072AA4h case    4:*/		return 0x82072AA8;
		  /* 82072AA8h */ case    5:  		/* slw R29, R10, R11 */
		/* 82072AA8h case    5:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R10,regs.R11);
		/* 82072AA8h case    5:*/		return 0x82072AAC;
		  /* 82072AACh */ case    6:  		/* bl 2073852 */
		/* 82072AACh case    6:*/		regs.LR = 0x82072AB0; return 0x8226CFA8;
		/* 82072AACh case    6:*/		return 0x82072AB0;
		  /* 82072AB0h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82072AB0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82072AB0h case    7:*/		return 0x82072AB4;
		  /* 82072AB4h */ case    8:  		/* mr R3, R30 */
		/* 82072AB4h case    8:*/		regs.R3 = regs.R30;
		/* 82072AB4h case    8:*/		return 0x82072AB8;
		  /* 82072AB8h */ case    9:  		/* andc R11, R11, R29 */
		/* 82072AB8h case    9:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82072AB8h case    9:*/		return 0x82072ABC;
		  /* 82072ABCh */ case   10:  		/* rlwinm R11, R11, 0, 26, 31 */
		/* 82072ABCh case   10:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R11);
		/* 82072ABCh case   10:*/		return 0x82072AC0;
		  /* 82072AC0h */ case   11:  		/* stw R11, <#[R31]> */
		/* 82072AC0h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82072AC0h case   11:*/		return 0x82072AC4;
		  /* 82072AC4h */ case   12:  		/* bl 2073812 */
		/* 82072AC4h case   12:*/		regs.LR = 0x82072AC8; return 0x8226CF98;
		/* 82072AC4h case   12:*/		return 0x82072AC8;
		  /* 82072AC8h */ case   13:  		/* b 36 */
		/* 82072AC8h case   13:*/		return 0x82072AEC;
		/* 82072AC8h case   13:*/		return 0x82072ACC;
	}
	return 0x82072ACC;
} // Block from 82072A94h-82072ACCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 82072ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072ACC);
		  /* 82072ACCh */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 82072ACCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82072ACCh case    0:*/		return 0x82072AD0;
		  /* 82072AD0h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82072AD0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82072AEC;  }
		/* 82072AD0h case    1:*/		return 0x82072AD4;
		  /* 82072AD4h */ case    2:  		/* lis R11, 32712 */
		/* 82072AD4h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FC8);
		/* 82072AD4h case    2:*/		return 0x82072AD8;
		  /* 82072AD8h */ case    3:  		/* lwz R11, <#[R11 + 25924]> */
		/* 82072AD8h case    3:*/		regs.IO->MEM_READ( 0x82072AD8, (uint32)(regs.R11 + 0x00006544), 4, &regs.R11 );
		/* 82072AD8h case    3:*/		return 0x82072ADC;
		  /* 82072ADCh */ case    4:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82072ADCh case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82072ADCh case    4:*/		return 0x82072AE0;
		  /* 82072AE0h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 82072AE0h case    5:*/		if ( regs.CR[0].eq ) { return 0x82072AEC;  }
		/* 82072AE0h case    5:*/		return 0x82072AE4;
		  /* 82072AE4h */ case    6:  		/* mr R3, R31 */
		/* 82072AE4h case    6:*/		regs.R3 = regs.R31;
		/* 82072AE4h case    6:*/		return 0x82072AE8;
		  /* 82072AE8h */ case    7:  		/* bl -19408 */
		/* 82072AE8h case    7:*/		regs.LR = 0x82072AEC; return 0x8206DF18;
		/* 82072AE8h case    7:*/		return 0x82072AEC;
	}
	return 0x82072AEC;
} // Block from 82072ACCh-82072AECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 82072AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072AEC);
		  /* 82072AECh */ case    0:  		/* addi R1, R1, 112 */
		/* 82072AECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82072AECh case    0:*/		return 0x82072AF0;
		  /* 82072AF0h */ case    1:  		/* b 124860 */
		/* 82072AF0h case    1:*/		return 0x820912AC;
		/* 82072AF0h case    1:*/		return 0x82072AF4;
		  /* 82072AF4h */ case    2:  		/* nop */
		/* 82072AF4h case    2:*/		cpu::op::nop();
		/* 82072AF4h case    2:*/		return 0x82072AF8;
	}
	return 0x82072AF8;
} // Block from 82072AECh-82072AF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82072AF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072AF8);
		  /* 82072AF8h */ case    0:  		/* mfspr R12, LR */
		/* 82072AF8h case    0:*/		regs.R12 = regs.LR;
		/* 82072AF8h case    0:*/		return 0x82072AFC;
		  /* 82072AFCh */ case    1:  		/* bl 124768 */
		/* 82072AFCh case    1:*/		regs.LR = 0x82072B00; return 0x8209125C;
		/* 82072AFCh case    1:*/		return 0x82072B00;
		  /* 82072B00h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82072B00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82072B00h case    2:*/		return 0x82072B04;
		  /* 82072B04h */ case    3:  		/* lwz R11, <#[R5]> */
		/* 82072B04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82072B04h case    3:*/		return 0x82072B08;
		  /* 82072B08h */ case    4:  		/* mr R29, R5 */
		/* 82072B08h case    4:*/		regs.R29 = regs.R5;
		/* 82072B08h case    4:*/		return 0x82072B0C;
		  /* 82072B0Ch */ case    5:  		/* rlwinm. R10, R4, 0, 31, 31 */
		/* 82072B0Ch case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R4);
		/* 82072B0Ch case    5:*/		return 0x82072B10;
		  /* 82072B10h */ case    6:  		/* rlwinm R7, R11, 30, 2, 31 */
		/* 82072B10h case    6:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R7,regs.R11);
		/* 82072B10h case    6:*/		return 0x82072B14;
		  /* 82072B14h */ case    7:  		/* lwz R11, <#[R3 + 15320]> */
		/* 82072B14h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003BD8) );
		/* 82072B14h case    7:*/		return 0x82072B18;
		  /* 82072B18h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82072B18h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82072B18h case    8:*/		return 0x82072B1C;
		  /* 82072B1Ch */ case    9:  		/* bc 12, CR0_EQ, 220 */
		/* 82072B1Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82072BF8;  }
		/* 82072B1Ch case    9:*/		return 0x82072B20;
		  /* 82072B20h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 82072B20h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82072B2C;  }
		/* 82072B20h case   10:*/		return 0x82072B24;
		  /* 82072B24h */ case   11:  		/* lwz R11, <#[R3 + 52]> */
		/* 82072B24h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000034) );
		/* 82072B24h case   11:*/		return 0x82072B28;
		  /* 82072B28h */ case   12:  		/* addi R11, R11, 68 */
		/* 82072B28h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x44);
		/* 82072B28h case   12:*/		return 0x82072B2C;
	}
	return 0x82072B2C;
} // Block from 82072AF8h-82072B2Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82072B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072B2C);
		  /* 82072B2Ch */ case    0:  		/* add R10, R11, R6 */
		/* 82072B2Ch case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R6);
		/* 82072B2Ch case    0:*/		return 0x82072B30;
		  /* 82072B30h */ case    1:  		/* lwz R9, <#[R3 + 15312]> */
		/* 82072B30h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00003BD0) );
		/* 82072B30h case    1:*/		return 0x82072B34;
		  /* 82072B34h */ case    2:  		/* addi R11, R6, -1 */
		/* 82072B34h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0xFFFFFFFF);
		/* 82072B34h case    2:*/		return 0x82072B38;
		  /* 82072B38h */ case    3:  		/* lwz R5, <#[R3 + 15324]> */
		/* 82072B38h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00003BDC) );
		/* 82072B38h case    3:*/		return 0x82072B3C;
		  /* 82072B3Ch */ case    4:  		/* addi R8, R10, -1 */
		/* 82072B3Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFFF);
		/* 82072B3Ch case    4:*/		return 0x82072B40;
		  /* 82072B40h */ case    5:  		/* nor R11, R11, R11 */
		/* 82072B40h case    5:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82072B40h case    5:*/		return 0x82072B44;
		  /* 82072B44h */ case    6:  		/* rlwinm R10, R7, 2, 0, 29 */
		/* 82072B44h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 82072B44h case    6:*/		return 0x82072B48;
		  /* 82072B48h */ case    7:  		/* and R31, R8, R11 */
		/* 82072B48h case    7:*/		cpu::op::and<0>(regs,&regs.R31,regs.R8,regs.R11);
		/* 82072B48h case    7:*/		return 0x82072B4C;
		  /* 82072B4Ch */ case    8:  		/* add R4, R10, R31 */
		/* 82072B4Ch case    8:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R31);
		/* 82072B4Ch case    8:*/		return 0x82072B50;
		  /* 82072B50h */ case    9:  		/* cmplw CR6, R4, R9 */
		/* 82072B50h case    9:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R9);
		/* 82072B50h case    9:*/		return 0x82072B54;
		  /* 82072B54h */ case   10:  		/* bc 12, CR6_GT, 64 */
		/* 82072B54h case   10:*/		if ( regs.CR[6].gt ) { return 0x82072B94;  }
		/* 82072B54h case   10:*/		return 0x82072B58;
		  /* 82072B58h */ case   11:  		/* lwz R10, <#[R3 + 13600]> */
		/* 82072B58h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00003520) );
		/* 82072B58h case   11:*/		return 0x82072B5C;
		  /* 82072B5Ch */ case   12:  		/* cmplwi CR6, R10, 0 */
		/* 82072B5Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82072B5Ch case   12:*/		return 0x82072B60;
		  /* 82072B60h */ case   13:  		/* bc 12, CR6_EQ, 44 */
		/* 82072B60h case   13:*/		if ( regs.CR[6].eq ) { return 0x82072B8C;  }
		/* 82072B60h case   13:*/		return 0x82072B64;
		  /* 82072B64h */ case   14:  		/* lwz R11, <#[R3 + 13604]> */
		/* 82072B64h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003524) );
		/* 82072B64h case   14:*/		return 0x82072B68;
		  /* 82072B68h */ case   15:  		/* subf R11, R5, R11 */
		/* 82072B68h case   15:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 82072B68h case   15:*/		return 0x82072B6C;
		  /* 82072B6Ch */ case   16:  		/* cmpwi CR6, R11, -1 */
		/* 82072B6Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82072B6Ch case   16:*/		return 0x82072B70;
		  /* 82072B70h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 82072B70h case   17:*/		if ( regs.CR[6].eq ) { return 0x82072B84;  }
		/* 82072B70h case   17:*/		return 0x82072B74;
		  /* 82072B74h */ case   18:  		/* cmpwi CR6, R11, 0 */
		/* 82072B74h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82072B74h case   18:*/		return 0x82072B78;
		  /* 82072B78h */ case   19:  		/* bc 4, CR6_EQ, 20 */
		/* 82072B78h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82072B8C;  }
		/* 82072B78h case   19:*/		return 0x82072B7C;
		  /* 82072B7Ch */ case   20:  		/* cmplw CR6, R10, R4 */
		/* 82072B7Ch case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 82072B7Ch case   20:*/		return 0x82072B80;
		  /* 82072B80h */ case   21:  		/* bc 4, CR6_LT, 12 */
		/* 82072B80h case   21:*/		if ( !regs.CR[6].lt ) { return 0x82072B8C;  }
		/* 82072B80h case   21:*/		return 0x82072B84;
	}
	return 0x82072B84;
} // Block from 82072B2Ch-82072B84h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82072B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072B84);
		  /* 82072B84h */ case    0:  		/* li R3, 0 */
		/* 82072B84h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82072B84h case    0:*/		return 0x82072B88;
		  /* 82072B88h */ case    1:  		/* b 408 */
		/* 82072B88h case    1:*/		return 0x82072D20;
		/* 82072B88h case    1:*/		return 0x82072B8C;
	}
	return 0x82072B8C;
} // Block from 82072B84h-82072B8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072B8C);
		  /* 82072B8Ch */ case    0:  		/* stw R4, <#[R3 + 15320]> */
		/* 82072B8Ch case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003BD8) );
		/* 82072B8Ch case    0:*/		return 0x82072B90;
		  /* 82072B90h */ case    1:  		/* b 92 */
		/* 82072B90h case    1:*/		return 0x82072BEC;
		/* 82072B90h case    1:*/		return 0x82072B94;
	}
	return 0x82072B94;
} // Block from 82072B8Ch-82072B94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072B94);
		  /* 82072B94h */ case    0:  		/* lwz R9, <#[R3 + 15328]> */
		/* 82072B94h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00003BE0) );
		/* 82072B94h case    0:*/		return 0x82072B98;
		  /* 82072B98h */ case    1:  		/* lwz R8, <#[R3 + 13600]> */
		/* 82072B98h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00003520) );
		/* 82072B98h case    1:*/		return 0x82072B9C;
		  /* 82072B9Ch */ case    2:  		/* add R9, R9, R6 */
		/* 82072B9Ch case    2:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 82072B9Ch case    2:*/		return 0x82072BA0;
		  /* 82072BA0h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 82072BA0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82072BA0h case    3:*/		return 0x82072BA4;
		  /* 82072BA4h */ case    4:  		/* addi R9, R9, -1 */
		/* 82072BA4h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82072BA4h case    4:*/		return 0x82072BA8;
		  /* 82072BA8h */ case    5:  		/* and R31, R9, R11 */
		/* 82072BA8h case    5:*/		cpu::op::and<0>(regs,&regs.R31,regs.R9,regs.R11);
		/* 82072BA8h case    5:*/		return 0x82072BAC;
		  /* 82072BACh */ case    6:  		/* add R4, R10, R31 */
		/* 82072BACh case    6:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R31);
		/* 82072BACh case    6:*/		return 0x82072BB0;
		  /* 82072BB0h */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 82072BB0h case    7:*/		if ( regs.CR[6].eq ) { return 0x82072BD8;  }
		/* 82072BB0h case    7:*/		return 0x82072BB4;
		  /* 82072BB4h */ case    8:  		/* lwz R11, <#[R3 + 13604]> */
		/* 82072BB4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003524) );
		/* 82072BB4h case    8:*/		return 0x82072BB8;
		  /* 82072BB8h */ case    9:  		/* subf R11, R5, R11 */
		/* 82072BB8h case    9:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 82072BB8h case    9:*/		return 0x82072BBC;
		  /* 82072BBCh */ case   10:  		/* addi R11, R11, -1 */
		/* 82072BBCh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82072BBCh case   10:*/		return 0x82072BC0;
		  /* 82072BC0h */ case   11:  		/* cmpwi CR6, R11, -1 */
		/* 82072BC0h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82072BC0h case   11:*/		return 0x82072BC4;
		  /* 82072BC4h */ case   12:  		/* bc 12, CR6_EQ, -64 */
		/* 82072BC4h case   12:*/		if ( regs.CR[6].eq ) { return 0x82072B84;  }
		/* 82072BC4h case   12:*/		return 0x82072BC8;
		  /* 82072BC8h */ case   13:  		/* cmpwi CR6, R11, 0 */
		/* 82072BC8h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82072BC8h case   13:*/		return 0x82072BCC;
		  /* 82072BCCh */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 82072BCCh case   14:*/		if ( !regs.CR[6].eq ) { return 0x82072BD8;  }
		/* 82072BCCh case   14:*/		return 0x82072BD0;
		  /* 82072BD0h */ case   15:  		/* cmplw CR6, R8, R4 */
		/* 82072BD0h case   15:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R4);
		/* 82072BD0h case   15:*/		return 0x82072BD4;
		  /* 82072BD4h */ case   16:  		/* bc 12, CR6_LT, -80 */
		/* 82072BD4h case   16:*/		if ( regs.CR[6].lt ) { return 0x82072B84;  }
		/* 82072BD4h case   16:*/		return 0x82072BD8;
	}
	return 0x82072BD8;
} // Block from 82072B94h-82072BD8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82072BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072BD8);
		  /* 82072BD8h */ case    0:  		/* lwz R11, <#[R3 + 15332]> */
		/* 82072BD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003BE4) );
		/* 82072BD8h case    0:*/		return 0x82072BDC;
		  /* 82072BDCh */ case    1:  		/* cmplw CR6, R4, R11 */
		/* 82072BDCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82072BDCh case    1:*/		return 0x82072BE0;
		  /* 82072BE0h */ case    2:  		/* bc 12, CR6_GT, -92 */
		/* 82072BE0h case    2:*/		if ( regs.CR[6].gt ) { return 0x82072B84;  }
		/* 82072BE0h case    2:*/		return 0x82072BE4;
		  /* 82072BE4h */ case    3:  		/* addi R5, R5, 1 */
		/* 82072BE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82072BE4h case    3:*/		return 0x82072BE8;
		  /* 82072BE8h */ case    4:  		/* stw R4, <#[R3 + 15328]> */
		/* 82072BE8h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003BE0) );
		/* 82072BE8h case    4:*/		return 0x82072BEC;
	}
	return 0x82072BEC;
} // Block from 82072BD8h-82072BECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82072BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072BEC);
		  /* 82072BECh */ case    0:  		/* bl -1228 */
		/* 82072BECh case    0:*/		regs.LR = 0x82072BF0; return 0x82072720;
		/* 82072BECh case    0:*/		return 0x82072BF0;
		  /* 82072BF0h */ case    1:  		/* mr R3, R31 */
		/* 82072BF0h case    1:*/		regs.R3 = regs.R31;
		/* 82072BF0h case    1:*/		return 0x82072BF4;
		  /* 82072BF4h */ case    2:  		/* b 300 */
		/* 82072BF4h case    2:*/		return 0x82072D20;
		/* 82072BF4h case    2:*/		return 0x82072BF8;
	}
	return 0x82072BF8;
} // Block from 82072BECh-82072BF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82072BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072BF8);
		  /* 82072BF8h */ case    0:  		/* bc 4, CR6_EQ, 12 */
		/* 82072BF8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82072C04;  }
		/* 82072BF8h case    0:*/		return 0x82072BFC;
		  /* 82072BFCh */ case    1:  		/* lwz R11, <#[R3 + 48]> */
		/* 82072BFCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 82072BFCh case    1:*/		return 0x82072C00;
		  /* 82072C00h */ case    2:  		/* addi R11, R11, 4 */
		/* 82072C00h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82072C00h case    2:*/		return 0x82072C04;
	}
	return 0x82072C04;
} // Block from 82072BF8h-82072C04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82072C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072C04);
		  /* 82072C04h */ case    0:  		/* addi R11, R11, 31 */
		/* 82072C04h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 82072C04h case    0:*/		return 0x82072C08;
		  /* 82072C08h */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 82072C08h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82072C08h case    1:*/		return 0x82072C0C;
		  /* 82072C0Ch */ case    2:  		/* rlwinm R30, R11, 0, 0, 26 */
		/* 82072C0Ch case    2:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R30,regs.R11);
		/* 82072C0Ch case    2:*/		return 0x82072C10;
		  /* 82072C10h */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 82072C10h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82072C18;  }
		/* 82072C10h case    3:*/		return 0x82072C14;
		  /* 82072C14h */ case    4:  		/* li R7, 56 */
		/* 82072C14h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x38);
		/* 82072C14h case    4:*/		return 0x82072C18;
	}
	return 0x82072C18;
} // Block from 82072C04h-82072C18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82072C18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072C18);
		  /* 82072C18h */ case    0:  		/* lwz R11, <#[R3 + 15316]> */
		/* 82072C18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003BD4) );
		/* 82072C18h case    0:*/		return 0x82072C1C;
		  /* 82072C1Ch */ case    1:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 82072C1Ch case    1:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 82072C1Ch case    1:*/		return 0x82072C20;
		  /* 82072C20h */ case    2:  		/* cmplw CR6, R7, R11 */
		/* 82072C20h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 82072C20h case    2:*/		return 0x82072C24;
		  /* 82072C24h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 82072C24h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82072C2C;  }
		/* 82072C24h case    3:*/		return 0x82072C28;
		  /* 82072C28h */ case    4:  		/* mr R11, R7 */
		/* 82072C28h case    4:*/		regs.R11 = regs.R7;
		/* 82072C28h case    4:*/		return 0x82072C2C;
	}
	return 0x82072C2C;
} // Block from 82072C18h-82072C2Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82072C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072C2C);
		  /* 82072C2Ch */ case    0:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 82072C2Ch case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 82072C2Ch case    0:*/		return 0x82072C30;
		  /* 82072C30h */ case    1:  		/* lwz R11, <#[R3 + 15312]> */
		/* 82072C30h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003BD0) );
		/* 82072C30h case    1:*/		return 0x82072C34;
		  /* 82072C34h */ case    2:  		/* add R31, R8, R30 */
		/* 82072C34h case    2:*/		cpu::op::add<0>(regs,&regs.R31,regs.R8,regs.R30);
		/* 82072C34h case    2:*/		return 0x82072C38;
		  /* 82072C38h */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 82072C38h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82072C38h case    3:*/		return 0x82072C3C;
		  /* 82072C3Ch */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 82072C3Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x82072C44;  }
		/* 82072C3Ch case    4:*/		return 0x82072C40;
		  /* 82072C40h */ case    5:  		/* mr R31, R11 */
		/* 82072C40h case    5:*/		regs.R31 = regs.R11;
		/* 82072C40h case    5:*/		return 0x82072C44;
	}
	return 0x82072C44;
} // Block from 82072C2Ch-82072C44h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82072C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072C44);
		  /* 82072C44h */ case    0:  		/* subf R11, R30, R31 */
		/* 82072C44h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R31);
		/* 82072C44h case    0:*/		return 0x82072C48;
		  /* 82072C48h */ case    1:  		/* lwz R10, <#[R3 + 15308]> */
		/* 82072C48h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00003BCC) );
		/* 82072C48h case    1:*/		return 0x82072C4C;
		  /* 82072C4Ch */ case    2:  		/* lwz R6, <#[R3 + 15340]> */
		/* 82072C4Ch case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00003BEC) );
		/* 82072C4Ch case    2:*/		return 0x82072C50;
		  /* 82072C50h */ case    3:  		/* srawi R11, R11, 2 */
		/* 82072C50h case    3:*/		cpu::op::srawi<0,2>(regs,&regs.R11,regs.R11);
		/* 82072C50h case    3:*/		return 0x82072C54;
		  /* 82072C54h */ case    4:  		/* subfc R9, R7, R11 */
		/* 82072C54h case    4:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R7,regs.R11);
		/* 82072C54h case    4:*/		return 0x82072C58;
		  /* 82072C58h */ case    5:  		/* eqv R5, R7, R11 */
		/* 82072C58h case    5:*/		cpu::op::eqv<0>(regs,&regs.R5,regs.R7,regs.R11);
		/* 82072C58h case    5:*/		return 0x82072C5C;
		  /* 82072C5Ch */ case    6:  		/* lwz R11, <#[R3 + 15328]> */
		/* 82072C5Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003BE0) );
		/* 82072C5Ch case    6:*/		return 0x82072C60;
		  /* 82072C60h */ case    7:  		/* rlwinm R9, R5, 1, 31, 31 */
		/* 82072C60h case    7:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R9,regs.R5);
		/* 82072C60h case    7:*/		return 0x82072C64;
		  /* 82072C64h */ case    8:  		/* subf R5, R10, R11 */
		/* 82072C64h case    8:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 82072C64h case    8:*/		return 0x82072C68;
		  /* 82072C68h */ case    9:  		/* addze R9, R9 */
		/* 82072C68h case    9:*/		cpu::op::addze<0>(regs,&regs.R9,regs.R9);
		/* 82072C68h case    9:*/		return 0x82072C6C;
		  /* 82072C6Ch */ case   10:  		/* srawi R5, R5, 2 */
		/* 82072C6Ch case   10:*/		cpu::op::srawi<0,2>(regs,&regs.R5,regs.R5);
		/* 82072C6Ch case   10:*/		return 0x82072C70;
		  /* 82072C70h */ case   11:  		/* rlwinm R9, R9, 0, 31, 31 */
		/* 82072C70h case   11:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82072C70h case   11:*/		return 0x82072C74;
		  /* 82072C74h */ case   12:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 82072C74h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 82072C74h case   12:*/		return 0x82072C78;
		  /* 82072C78h */ case   13:  		/* cmplw CR6, R5, R6 */
		/* 82072C78h case   13:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 82072C78h case   13:*/		return 0x82072C7C;
		  /* 82072C7Ch */ case   14:  		/* bc 4, CR6_GT, 8 */
		/* 82072C7Ch case   14:*/		if ( !regs.CR[6].gt ) { return 0x82072C84;  }
		/* 82072C7Ch case   14:*/		return 0x82072C80;
		  /* 82072C80h */ case   15:  		/* li R9, 1 */
		/* 82072C80h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82072C80h case   15:*/		return 0x82072C84;
	}
	return 0x82072C84;
} // Block from 82072C44h-82072C84h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82072C84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072C84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072C84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072C84);
		  /* 82072C84h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 82072C84h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 82072C84h case    0:*/		return 0x82072C88;
		  /* 82072C88h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 82072C88h case    1:*/		if ( regs.CR[6].eq ) { return 0x82072CB4;  }
		/* 82072C88h case    1:*/		return 0x82072C8C;
		  /* 82072C8Ch */ case    2:  		/* addi R11, R11, 31 */
		/* 82072C8Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 82072C8Ch case    2:*/		return 0x82072C90;
		  /* 82072C90h */ case    3:  		/* lwz R9, <#[R3 + 15324]> */
		/* 82072C90h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00003BDC) );
		/* 82072C90h case    3:*/		return 0x82072C94;
		  /* 82072C94h */ case    4:  		/* lbz R6, <#[R3 + 11070]> */
		/* 82072C94h case    4:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R3 + 0x00002B3E) );
		/* 82072C94h case    4:*/		return 0x82072C98;
		  /* 82072C98h */ case    5:  		/* rlwinm R30, R11, 0, 0, 26 */
		/* 82072C98h case    5:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R30,regs.R11);
		/* 82072C98h case    5:*/		return 0x82072C9C;
		  /* 82072C9Ch */ case    6:  		/* stw R10, <#[R3 + 15328]> */
		/* 82072C9Ch case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00003BE0) );
		/* 82072C9Ch case    6:*/		return 0x82072CA0;
		  /* 82072CA0h */ case    7:  		/* addi R9, R9, 1 */
		/* 82072CA0h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82072CA0h case    7:*/		return 0x82072CA4;
		  /* 82072CA4h */ case    8:  		/* ori R11, R6, 4 */
		/* 82072CA4h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R6,0x4);
		/* 82072CA4h case    8:*/		return 0x82072CA8;
		  /* 82072CA8h */ case    9:  		/* stw R9, <#[R3 + 15324]> */
		/* 82072CA8h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00003BDC) );
		/* 82072CA8h case    9:*/		return 0x82072CAC;
		  /* 82072CACh */ case   10:  		/* add R31, R8, R30 */
		/* 82072CACh case   10:*/		cpu::op::add<0>(regs,&regs.R31,regs.R8,regs.R30);
		/* 82072CACh case   10:*/		return 0x82072CB0;
		  /* 82072CB0h */ case   11:  		/* stb R11, <#[R3 + 11070]> */
		/* 82072CB0h case   11:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00002B3E) );
		/* 82072CB0h case   11:*/		return 0x82072CB4;
	}
	return 0x82072CB4;
} // Block from 82072C84h-82072CB4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82072CB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072CB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072CB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072CB4);
		  /* 82072CB4h */ case    0:  		/* lwz R8, <#[R3 + 13600]> */
		/* 82072CB4h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00003520) );
		/* 82072CB4h case    0:*/		return 0x82072CB8;
		  /* 82072CB8h */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 82072CB8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82072CB8h case    1:*/		return 0x82072CBC;
		  /* 82072CBCh */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 82072CBCh case    2:*/		if ( regs.CR[6].eq ) { return 0x82072D00;  }
		/* 82072CBCh case    2:*/		return 0x82072CC0;
		  /* 82072CC0h */ case    3:  		/* lwz R11, <#[R3 + 13604]> */
		/* 82072CC0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003524) );
		/* 82072CC0h case    3:*/		return 0x82072CC4;
		  /* 82072CC4h */ case    4:  		/* lwz R10, <#[R3 + 15324]> */
		/* 82072CC4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00003BDC) );
		/* 82072CC4h case    4:*/		return 0x82072CC8;
		  /* 82072CC8h */ case    5:  		/* subf R9, R10, R11 */
		/* 82072CC8h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 82072CC8h case    5:*/		return 0x82072CCC;
		  /* 82072CCCh */ case    6:  		/* cmpwi CR6, R9, -1 */
		/* 82072CCCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82072CCCh case    6:*/		return 0x82072CD0;
		  /* 82072CD0h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82072CD0h case    7:*/		if ( regs.CR[6].eq ) { return 0x82072CE4;  }
		/* 82072CD0h case    7:*/		return 0x82072CD4;
		  /* 82072CD4h */ case    8:  		/* cmpwi CR6, R9, 0 */
		/* 82072CD4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 82072CD4h case    8:*/		return 0x82072CD8;
		  /* 82072CD8h */ case    9:  		/* bc 4, CR6_EQ, 40 */
		/* 82072CD8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82072D00;  }
		/* 82072CD8h case    9:*/		return 0x82072CDC;
		  /* 82072CDCh */ case   10:  		/* cmplw CR6, R8, R31 */
		/* 82072CDCh case   10:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R31);
		/* 82072CDCh case   10:*/		return 0x82072CE0;
		  /* 82072CE0h */ case   11:  		/* bc 4, CR6_LT, 32 */
		/* 82072CE0h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82072D00;  }
		/* 82072CE0h case   11:*/		return 0x82072CE4;
	}
	return 0x82072CE4;
} // Block from 82072CB4h-82072CE4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82072CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072CE4);
		  /* 82072CE4h */ case    0:  		/* mr R31, R8 */
		/* 82072CE4h case    0:*/		regs.R31 = regs.R8;
		/* 82072CE4h case    0:*/		return 0x82072CE8;
		  /* 82072CE8h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 82072CE8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82072CE8h case    1:*/		return 0x82072CEC;
		  /* 82072CECh */ case    2:  		/* bc 4, CR6_EQ, -360 */
		/* 82072CECh case    2:*/		if ( !regs.CR[6].eq ) { return 0x82072B84;  }
		/* 82072CECh case    2:*/		return 0x82072CF0;
		  /* 82072CF0h */ case    3:  		/* subf R11, R30, R8 */
		/* 82072CF0h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R8);
		/* 82072CF0h case    3:*/		return 0x82072CF4;
		  /* 82072CF4h */ case    4:  		/* srawi R11, R11, 2 */
		/* 82072CF4h case    4:*/		cpu::op::srawi<0,2>(regs,&regs.R11,regs.R11);
		/* 82072CF4h case    4:*/		return 0x82072CF8;
		  /* 82072CF8h */ case    5:  		/* cmpw CR6, R11, R7 */
		/* 82072CF8h case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R7);
		/* 82072CF8h case    5:*/		return 0x82072CFC;
		  /* 82072CFCh */ case    6:  		/* bc 12, CR6_LT, -376 */
		/* 82072CFCh case    6:*/		if ( regs.CR[6].lt ) { return 0x82072B84;  }
		/* 82072CFCh case    6:*/		return 0x82072D00;
	}
	return 0x82072D00;
} // Block from 82072CE4h-82072D00h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82072D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072D00);
		  /* 82072D00h */ case    0:  		/* mr R4, R31 */
		/* 82072D00h case    0:*/		regs.R4 = regs.R31;
		/* 82072D00h case    0:*/		return 0x82072D04;
		  /* 82072D04h */ case    1:  		/* lwz R5, <#[R3 + 15324]> */
		/* 82072D04h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00003BDC) );
		/* 82072D04h case    1:*/		return 0x82072D08;
		  /* 82072D08h */ case    2:  		/* bl -1512 */
		/* 82072D08h case    2:*/		regs.LR = 0x82072D0C; return 0x82072720;
		/* 82072D08h case    2:*/		return 0x82072D0C;
		  /* 82072D0Ch */ case    3:  		/* subf R11, R30, R31 */
		/* 82072D0Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R31);
		/* 82072D0Ch case    3:*/		return 0x82072D10;
		  /* 82072D10h */ case    4:  		/* mr R3, R30 */
		/* 82072D10h case    4:*/		regs.R3 = regs.R30;
		/* 82072D10h case    4:*/		return 0x82072D14;
		  /* 82072D14h */ case    5:  		/* srawi R11, R11, 2 */
		/* 82072D14h case    5:*/		cpu::op::srawi<0,2>(regs,&regs.R11,regs.R11);
		/* 82072D14h case    5:*/		return 0x82072D18;
		  /* 82072D18h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82072D18h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82072D18h case    6:*/		return 0x82072D1C;
		  /* 82072D1Ch */ case    7:  		/* stw R11, <#[R29]> */
		/* 82072D1Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82072D1Ch case    7:*/		return 0x82072D20;
	}
	return 0x82072D20;
} // Block from 82072D00h-82072D20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82072D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072D20);
		  /* 82072D20h */ case    0:  		/* addi R1, R1, 112 */
		/* 82072D20h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82072D20h case    0:*/		return 0x82072D24;
		  /* 82072D24h */ case    1:  		/* b 124296 */
		/* 82072D24h case    1:*/		return 0x820912AC;
		/* 82072D24h case    1:*/		return 0x82072D28;
	}
	return 0x82072D28;
} // Block from 82072D20h-82072D28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072D28h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072D28);
		  /* 82072D28h */ case    0:  		/* mfspr R12, LR */
		/* 82072D28h case    0:*/		regs.R12 = regs.LR;
		/* 82072D28h case    0:*/		return 0x82072D2C;
		  /* 82072D2Ch */ case    1:  		/* bl 124208 */
		/* 82072D2Ch case    1:*/		regs.LR = 0x82072D30; return 0x8209125C;
		/* 82072D2Ch case    1:*/		return 0x82072D30;
		  /* 82072D30h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82072D30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82072D30h case    2:*/		return 0x82072D34;
		  /* 82072D34h */ case    3:  		/* mr R31, R3 */
		/* 82072D34h case    3:*/		regs.R31 = regs.R3;
		/* 82072D34h case    3:*/		return 0x82072D38;
		  /* 82072D38h */ case    4:  		/* mr R30, R4 */
		/* 82072D38h case    4:*/		regs.R30 = regs.R4;
		/* 82072D38h case    4:*/		return 0x82072D3C;
		  /* 82072D3Ch */ case    5:  		/* mr R29, R5 */
		/* 82072D3Ch case    5:*/		regs.R29 = regs.R5;
		/* 82072D3Ch case    5:*/		return 0x82072D40;
		  /* 82072D40h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 82072D40h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82072D40h case    6:*/		return 0x82072D44;
		  /* 82072D44h */ case    7:  		/* bc 12, CR6_EQ, 168 */
		/* 82072D44h case    7:*/		if ( regs.CR[6].eq ) { return 0x82072DEC;  }
		/* 82072D44h case    7:*/		return 0x82072D48;
		  /* 82072D48h */ case    8:  		/* lwz R11, <#[R3 + 11024]> */
		/* 82072D48h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B10) );
		/* 82072D48h case    8:*/		return 0x82072D4C;
		  /* 82072D4Ch */ case    9:  		/* lwz R10, <#[R3 + 11036]> */
		/* 82072D4Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002B1C) );
		/* 82072D4Ch case    9:*/		return 0x82072D50;
		  /* 82072D50h */ case   10:  		/* subf R9, R4, R10 */
		/* 82072D50h case   10:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R4,regs.R10);
		/* 82072D50h case   10:*/		return 0x82072D54;
		  /* 82072D54h */ case   11:  		/* lwz R11, <#[R11]> */
		/* 82072D54h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82072D54h case   11:*/		return 0x82072D58;
		  /* 82072D58h */ case   12:  		/* subf R11, R11, R10 */
		/* 82072D58h case   12:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82072D58h case   12:*/		return 0x82072D5C;
		  /* 82072D5Ch */ case   13:  		/* cmplw CR6, R9, R11 */
		/* 82072D5Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82072D5Ch case   13:*/		return 0x82072D60;
		  /* 82072D60h */ case   14:  		/* bc 4, CR6_LT, 140 */
		/* 82072D60h case   14:*/		if ( !regs.CR[6].lt ) { return 0x82072DEC;  }
		/* 82072D60h case   14:*/		return 0x82072D64;
		  /* 82072D64h */ case   15:  		/* rlwinm. R11, R7, 0, 24, 31 */
		/* 82072D64h case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R7);
		/* 82072D64h case   15:*/		return 0x82072D68;
		  /* 82072D68h */ case   16:  		/* bc 4, CR0_EQ, 32 */
		/* 82072D68h case   16:*/		if ( !regs.CR[0].eq ) { return 0x82072D88;  }
		/* 82072D68h case   16:*/		return 0x82072D6C;
		  /* 82072D6Ch */ case   17:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 82072D6Ch case   17:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 82072D6Ch case   17:*/		return 0x82072D70;
		  /* 82072D70h */ case   18:  		/* cmplw CR6, R4, R11 */
		/* 82072D70h case   18:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82072D70h case   18:*/		return 0x82072D74;
		  /* 82072D74h */ case   19:  		/* bc 4, CR6_EQ, 20 */
		/* 82072D74h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82072D88;  }
		/* 82072D74h case   19:*/		return 0x82072D78;
		  /* 82072D78h */ case   20:  		/* lwz R11, <#[R3 + 13600]> */
		/* 82072D78h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003520) );
		/* 82072D78h case   20:*/		return 0x82072D7C;
		  /* 82072D7Ch */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 82072D7Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82072D7Ch case   21:*/		return 0x82072D80;
		  /* 82072D80h */ case   22:  		/* bc 4, CR6_EQ, 108 */
		/* 82072D80h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82072DEC;  }
		/* 82072D80h case   22:*/		return 0x82072D84;
		  /* 82072D84h */ case   23:  		/* bl 4996 */
		/* 82072D84h case   23:*/		regs.LR = 0x82072D88; return 0x82074108;
		/* 82072D84h case   23:*/		return 0x82072D88;
	}
	return 0x82072D88;
} // Block from 82072D28h-82072D88h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82072D88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072D88);
		  /* 82072D88h */ case    0:  		/* lwz R11, <#[R31 + 11024]> */
		/* 82072D88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 82072D88h case    0:*/		return 0x82072D8C;
		  /* 82072D8Ch */ case    1:  		/* lwz R10, <#[R31 + 11036]> */
		/* 82072D8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B1C) );
		/* 82072D8Ch case    1:*/		return 0x82072D90;
		  /* 82072D90h */ case    2:  		/* subf R9, R30, R10 */
		/* 82072D90h case    2:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R30,regs.R10);
		/* 82072D90h case    2:*/		return 0x82072D94;
		  /* 82072D94h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 82072D94h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82072D94h case    3:*/		return 0x82072D98;
		  /* 82072D98h */ case    4:  		/* subf R11, R11, R10 */
		/* 82072D98h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82072D98h case    4:*/		return 0x82072D9C;
		  /* 82072D9Ch */ case    5:  		/* cmplw CR6, R9, R11 */
		/* 82072D9Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82072D9Ch case    5:*/		return 0x82072DA0;
		  /* 82072DA0h */ case    6:  		/* bc 4, CR6_LT, 76 */
		/* 82072DA0h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82072DEC;  }
		/* 82072DA0h case    6:*/		return 0x82072DA4;
		  /* 82072DA4h */ case    7:  		/* mr R5, R29 */
		/* 82072DA4h case    7:*/		regs.R5 = regs.R29;
		/* 82072DA4h case    7:*/		return 0x82072DA8;
		  /* 82072DA8h */ case    8:  		/* mr R4, R31 */
		/* 82072DA8h case    8:*/		regs.R4 = regs.R31;
		/* 82072DA8h case    8:*/		return 0x82072DAC;
		  /* 82072DACh */ case    9:  		/* addi R3, R1, 80 */
		/* 82072DACh case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82072DACh case    9:*/		return 0x82072DB0;
		  /* 82072DB0h */ case   10:  		/* bl 40376 */
		/* 82072DB0h case   10:*/		regs.LR = 0x82072DB4; return 0x8207CB68;
		/* 82072DB0h case   10:*/		return 0x82072DB4;
		  /* 82072DB4h */ case   11:  		/* b 20 */
		/* 82072DB4h case   11:*/		return 0x82072DC8;
		/* 82072DB4h case   11:*/		return 0x82072DB8;
		  /* 82072DB8h */ case   12:  		/* addi R3, R1, 80 */
		/* 82072DB8h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82072DB8h case   12:*/		return 0x82072DBC;
		  /* 82072DBCh */ case   13:  		/* bl 40612 */
		/* 82072DBCh case   13:*/		regs.LR = 0x82072DC0; return 0x8207CC60;
		/* 82072DBCh case   13:*/		return 0x82072DC0;
		  /* 82072DC0h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 82072DC0h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82072DC0h case   14:*/		return 0x82072DC4;
		  /* 82072DC4h */ case   15:  		/* bc 12, CR0_EQ, 32 */
		/* 82072DC4h case   15:*/		if ( regs.CR[0].eq ) { return 0x82072DE4;  }
		/* 82072DC4h case   15:*/		return 0x82072DC8;
	}
	return 0x82072DC8;
} // Block from 82072D88h-82072DC8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82072DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072DC8);
		  /* 82072DC8h */ case    0:  		/* lwz R11, <#[R31 + 11024]> */
		/* 82072DC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 82072DC8h case    0:*/		return 0x82072DCC;
		  /* 82072DCCh */ case    1:  		/* lwz R10, <#[R31 + 11036]> */
		/* 82072DCCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B1C) );
		/* 82072DCCh case    1:*/		return 0x82072DD0;
		  /* 82072DD0h */ case    2:  		/* subf R9, R30, R10 */
		/* 82072DD0h case    2:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R30,regs.R10);
		/* 82072DD0h case    2:*/		return 0x82072DD4;
		  /* 82072DD4h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 82072DD4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82072DD4h case    3:*/		return 0x82072DD8;
		  /* 82072DD8h */ case    4:  		/* subf R11, R11, R10 */
		/* 82072DD8h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82072DD8h case    4:*/		return 0x82072DDC;
		  /* 82072DDCh */ case    5:  		/* cmplw CR6, R9, R11 */
		/* 82072DDCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82072DDCh case    5:*/		return 0x82072DE0;
		  /* 82072DE0h */ case    6:  		/* bc 12, CR6_LT, -40 */
		/* 82072DE0h case    6:*/		if ( regs.CR[6].lt ) { return 0x82072DB8;  }
		/* 82072DE0h case    6:*/		return 0x82072DE4;
	}
	return 0x82072DE4;
} // Block from 82072DC8h-82072DE4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82072DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072DE4);
		  /* 82072DE4h */ case    0:  		/* addi R3, R1, 80 */
		/* 82072DE4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82072DE4h case    0:*/		return 0x82072DE8;
		  /* 82072DE8h */ case    1:  		/* bl 40368 */
		/* 82072DE8h case    1:*/		regs.LR = 0x82072DEC; return 0x8207CB98;
		/* 82072DE8h case    1:*/		return 0x82072DEC;
	}
	return 0x82072DEC;
} // Block from 82072DE4h-82072DECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072DEC);
		  /* 82072DECh */ case    0:  		/* addi R1, R1, 144 */
		/* 82072DECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82072DECh case    0:*/		return 0x82072DF0;
		  /* 82072DF0h */ case    1:  		/* b 124092 */
		/* 82072DF0h case    1:*/		return 0x820912AC;
		/* 82072DF0h case    1:*/		return 0x82072DF4;
		  /* 82072DF4h */ case    2:  		/* nop */
		/* 82072DF4h case    2:*/		cpu::op::nop();
		/* 82072DF4h case    2:*/		return 0x82072DF8;
	}
	return 0x82072DF8;
} // Block from 82072DECh-82072DF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82072DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072DF8);
		  /* 82072DF8h */ case    0:  		/* mfspr R12, LR */
		/* 82072DF8h case    0:*/		regs.R12 = regs.LR;
		/* 82072DF8h case    0:*/		return 0x82072DFC;
		  /* 82072DFCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82072DFCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82072DFCh case    1:*/		return 0x82072E00;
		  /* 82072E00h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82072E00h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82072E00h case    2:*/		return 0x82072E04;
		  /* 82072E04h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82072E04h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82072E04h case    3:*/		return 0x82072E08;
		  /* 82072E08h */ case    4:  		/* mr R31, R3 */
		/* 82072E08h case    4:*/		regs.R31 = regs.R3;
		/* 82072E08h case    4:*/		return 0x82072E0C;
		  /* 82072E0Ch */ case    5:  		/* bl 2072812 */
		/* 82072E0Ch case    5:*/		regs.LR = 0x82072E10; return 0x8226CEF8;
		/* 82072E0Ch case    5:*/		return 0x82072E10;
		  /* 82072E10h */ case    6:  		/* cmpwi CR6, R3, 2 */
		/* 82072E10h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82072E10h case    6:*/		return 0x82072E14;
		  /* 82072E14h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 82072E14h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82072E24;  }
		/* 82072E14h case    7:*/		return 0x82072E18;
		  /* 82072E18h */ case    8:  		/* lis R11, -32256 */
		/* 82072E18h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82072E18h case    8:*/		return 0x82072E1C;
		  /* 82072E1Ch */ case    9:  		/* lwz R11, <#[R11 + 1452]> */
		/* 82072E1Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005AC) );
		/* 82072E1Ch case    9:*/		return 0x82072E20;
		  /* 82072E20h */ case   10:  		/* b 12 */
		/* 82072E20h case   10:*/		return 0x82072E2C;
		/* 82072E20h case   10:*/		return 0x82072E24;
	}
	return 0x82072E24;
} // Block from 82072DF8h-82072E24h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82072E24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072E24);
		  /* 82072E24h */ case    0:  		/* lis R11, -32256 */
		/* 82072E24h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82072E24h case    0:*/		return 0x82072E28;
		  /* 82072E28h */ case    1:  		/* lwz R11, <#[R11 + 1456]> */
		/* 82072E28h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005B0) );
		/* 82072E28h case    1:*/		return 0x82072E2C;
	}
	return 0x82072E2C;
} // Block from 82072E24h-82072E2Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82072E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072E2C);
		  /* 82072E2Ch */ case    0:  		/* li R7, 0 */
		/* 82072E2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82072E2Ch case    0:*/		return 0x82072E30;
		  /* 82072E30h */ case    1:  		/* lwz R3, <#[R11]> */
		/* 82072E30h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 82072E30h case    1:*/		return 0x82072E34;
		  /* 82072E34h */ case    2:  		/* li R6, 0 */
		/* 82072E34h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82072E34h case    2:*/		return 0x82072E38;
		  /* 82072E38h */ case    3:  		/* li R5, 6 */
		/* 82072E38h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x6);
		/* 82072E38h case    3:*/		return 0x82072E3C;
		  /* 82072E3Ch */ case    4:  		/* mr R4, R31 */
		/* 82072E3Ch case    4:*/		regs.R4 = regs.R31;
		/* 82072E3Ch case    4:*/		return 0x82072E40;
		  /* 82072E40h */ case    5:  		/* bl -280 */
		/* 82072E40h case    5:*/		regs.LR = 0x82072E44; return 0x82072D28;
		/* 82072E40h case    5:*/		return 0x82072E44;
		  /* 82072E44h */ case    6:  		/* addi R1, R1, 96 */
		/* 82072E44h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82072E44h case    6:*/		return 0x82072E48;
		  /* 82072E48h */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 82072E48h case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82072E48h case    7:*/		return 0x82072E4C;
		  /* 82072E4Ch */ case    8:  		/* mtspr LR, R12 */
		/* 82072E4Ch case    8:*/		regs.LR = regs.R12;
		/* 82072E4Ch case    8:*/		return 0x82072E50;
		  /* 82072E50h */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 82072E50h case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82072E50h case    9:*/		return 0x82072E54;
		  /* 82072E54h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82072E54h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82072E54h case   10:*/		return 0x82072E58;
	}
	return 0x82072E58;
} // Block from 82072E2Ch-82072E58h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82072E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072E58);
		  /* 82072E58h */ case    0:  		/* lwz R9, <#[R3 + 4]> */
		/* 82072E58h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 82072E58h case    0:*/		return 0x82072E5C;
		  /* 82072E5Ch */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 82072E5Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82072E5Ch case    1:*/		return 0x82072E60;
		  /* 82072E60h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 82072E60h case    2:*/		if ( regs.CR[6].eq ) { return 0x82072E90;  }
		/* 82072E60h case    2:*/		return 0x82072E64;
		  /* 82072E64h */ case    3:  		/* lwz R10, <#[R3 + 12]> */
		/* 82072E64h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 82072E64h case    3:*/		return 0x82072E68;
		  /* 82072E68h */ case    4:  		/* lis R8, -16384 */
		/* 82072E68h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFC000);
		/* 82072E68h case    4:*/		return 0x82072E6C;
		  /* 82072E6Ch */ case    5:  		/* rlwinm R11, R10, 12, 20, 31 */
		/* 82072E6Ch case    5:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R10);
		/* 82072E6Ch case    5:*/		return 0x82072E70;
		  /* 82072E70h */ case    6:  		/* rlwinm R10, R10, 0, 3, 31 */
		/* 82072E70h case    6:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R10);
		/* 82072E70h case    6:*/		return 0x82072E74;
		  /* 82072E74h */ case    7:  		/* addi R11, R11, 512 */
		/* 82072E74h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82072E74h case    7:*/		return 0x82072E78;
		  /* 82072E78h */ case    8:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82072E78h case    8:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82072E78h case    8:*/		return 0x82072E7C;
		  /* 82072E7Ch */ case    9:  		/* add R11, R11, R10 */
		/* 82072E7Ch case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82072E7Ch case    9:*/		return 0x82072E80;
		  /* 82072E80h */ case   10:  		/* addis R11, R11, -16384 */
		/* 82072E80h case   10:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0xFFFFC000);
		/* 82072E80h case   10:*/		return 0x82072E84;
		  /* 82072E84h */ case   11:  		/* stw R11, <#[R9]> */
		/* 82072E84h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 82072E84h case   11:*/		return 0x82072E88;
		  /* 82072E88h */ case   12:  		/* lwz R11, <#[R3 + 12]> */
		/* 82072E88h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82072E88h case   12:*/		return 0x82072E8C;
		  /* 82072E8Ch */ case   13:  		/* stw R8, <#[R11]> */
		/* 82072E8Ch case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82072E8Ch case   13:*/		return 0x82072E90;
	}
	return 0x82072E90;
} // Block from 82072E58h-82072E90h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82072E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072E90);
		  /* 82072E90h */ case    0:  		/* li R11, 0 */
		/* 82072E90h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82072E90h case    0:*/		return 0x82072E94;
		  /* 82072E94h */ case    1:  		/* stw R11, <#[R3 + 16]> */
		/* 82072E94h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82072E94h case    1:*/		return 0x82072E98;
		  /* 82072E98h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82072E98h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82072E98h case    2:*/		return 0x82072E9C;
	}
	return 0x82072E9C;
} // Block from 82072E90h-82072E9Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82072E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072E9C);
		  /* 82072E9Ch */ case    0:  		/* nop */
		/* 82072E9Ch case    0:*/		cpu::op::nop();
		/* 82072E9Ch case    0:*/		return 0x82072EA0;
	}
	return 0x82072EA0;
} // Block from 82072E9Ch-82072EA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82072EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072EA0);
		  /* 82072EA0h */ case    0:  		/* mfspr R12, LR */
		/* 82072EA0h case    0:*/		regs.R12 = regs.LR;
		/* 82072EA0h case    0:*/		return 0x82072EA4;
		  /* 82072EA4h */ case    1:  		/* bl 123832 */
		/* 82072EA4h case    1:*/		regs.LR = 0x82072EA8; return 0x8209125C;
		/* 82072EA4h case    1:*/		return 0x82072EA8;
		  /* 82072EA8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82072EA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82072EA8h case    2:*/		return 0x82072EAC;
		  /* 82072EACh */ case    3:  		/* rlwinm R10, R5, 12, 20, 31 */
		/* 82072EACh case    3:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R5);
		/* 82072EACh case    3:*/		return 0x82072EB0;
		  /* 82072EB0h */ case    4:  		/* lwz R30, <#[R3 + 12]> */
		/* 82072EB0h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 82072EB0h case    4:*/		return 0x82072EB4;
		  /* 82072EB4h */ case    5:  		/* rlwinm R9, R4, 12, 20, 31 */
		/* 82072EB4h case    5:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R9,regs.R4);
		/* 82072EB4h case    5:*/		return 0x82072EB8;
		  /* 82072EB8h */ case    6:  		/* addi R11, R10, 512 */
		/* 82072EB8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x200);
		/* 82072EB8h case    6:*/		return 0x82072EBC;
		  /* 82072EBCh */ case    7:  		/* rlwinm R10, R30, 12, 20, 31 */
		/* 82072EBCh case    7:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R30);
		/* 82072EBCh case    7:*/		return 0x82072EC0;
		  /* 82072EC0h */ case    8:  		/* rlwinm R7, R11, 0, 19, 19 */
		/* 82072EC0h case    8:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R7,regs.R11);
		/* 82072EC0h case    8:*/		return 0x82072EC4;
		  /* 82072EC4h */ case    9:  		/* rlwinm R8, R5, 0, 3, 31 */
		/* 82072EC4h case    9:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R8,regs.R5);
		/* 82072EC4h case    9:*/		return 0x82072EC8;
		  /* 82072EC8h */ case   10:  		/* addi R9, R9, 512 */
		/* 82072EC8h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x200);
		/* 82072EC8h case   10:*/		return 0x82072ECC;
		  /* 82072ECCh */ case   11:  		/* addi R10, R10, 512 */
		/* 82072ECCh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 82072ECCh case   11:*/		return 0x82072ED0;
		  /* 82072ED0h */ case   12:  		/* add R6, R7, R8 */
		/* 82072ED0h case   12:*/		cpu::op::add<0>(regs,&regs.R6,regs.R7,regs.R8);
		/* 82072ED0h case   12:*/		return 0x82072ED4;
		  /* 82072ED4h */ case   13:  		/* rlwinm R7, R9, 0, 19, 19 */
		/* 82072ED4h case   13:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R7,regs.R9);
		/* 82072ED4h case   13:*/		return 0x82072ED8;
		  /* 82072ED8h */ case   14:  		/* lis R11, 16384 */
		/* 82072ED8h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0x4000);
		/* 82072ED8h case   14:*/		return 0x82072EDC;
		  /* 82072EDCh */ case   15:  		/* rlwinm R9, R30, 0, 3, 31 */
		/* 82072EDCh case   15:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R9,regs.R30);
		/* 82072EDCh case   15:*/		return 0x82072EE0;
		  /* 82072EE0h */ case   16:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 82072EE0h case   16:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 82072EE0h case   16:*/		return 0x82072EE4;
		  /* 82072EE4h */ case   17:  		/* rlwinm R8, R4, 0, 3, 31 */
		/* 82072EE4h case   17:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R8,regs.R4);
		/* 82072EE4h case   17:*/		return 0x82072EE8;
		  /* 82072EE8h */ case   18:  		/* add R10, R10, R9 */
		/* 82072EE8h case   18:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82072EE8h case   18:*/		return 0x82072EEC;
		  /* 82072EECh */ case   19:  		/* subf R6, R11, R6 */
		/* 82072EECh case   19:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R11,regs.R6);
		/* 82072EECh case   19:*/		return 0x82072EF0;
		  /* 82072EF0h */ case   20:  		/* add R8, R7, R8 */
		/* 82072EF0h case   20:*/		cpu::op::add<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 82072EF0h case   20:*/		return 0x82072EF4;
		  /* 82072EF4h */ case   21:  		/* addi R9, R5, -4 */
		/* 82072EF4h case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R5,0xFFFFFFFC);
		/* 82072EF4h case   21:*/		return 0x82072EF8;
		  /* 82072EF8h */ case   22:  		/* stw R6, <#[R4]> */
		/* 82072EF8h case   22:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R4 + 0x00000000) );
		/* 82072EF8h case   22:*/		return 0x82072EFC;
		  /* 82072EFCh */ case   23:  		/* stw R4, <#[R3 + 4]> */
		/* 82072EFCh case   23:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82072EFCh case   23:*/		return 0x82072F00;
		  /* 82072F00h */ case   24:  		/* subf R29, R11, R8 */
		/* 82072F00h case   24:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R11,regs.R8);
		/* 82072F00h case   24:*/		return 0x82072F04;
		  /* 82072F04h */ case   25:  		/* stw R9, <#[R3 + 12]> */
		/* 82072F04h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 82072F04h case   25:*/		return 0x82072F08;
		  /* 82072F08h */ case   26:  		/* subf R31, R11, R10 */
		/* 82072F08h case   26:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R10);
		/* 82072F08h case   26:*/		return 0x82072F0C;
		  /* 82072F0Ch */ case   27:  		/* eieio */
		/* 82072F0Ch case   27:*/		cpu::op::eieio<0>(regs);
		/* 82072F0Ch case   27:*/		return 0x82072F10;
		  /* 82072F10h */ case   28:  		/* li R5, 0 */
		/* 82072F10h case   28:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82072F10h case   28:*/		return 0x82072F14;
		  /* 82072F14h */ case   29:  		/* mr R4, R6 */
		/* 82072F14h case   29:*/		regs.R4 = regs.R6;
		/* 82072F14h case   29:*/		return 0x82072F18;
		  /* 82072F18h */ case   30:  		/* mr R3, R29 */
		/* 82072F18h case   30:*/		regs.R3 = regs.R29;
		/* 82072F18h case   30:*/		return 0x82072F1C;
		  /* 82072F1Ch */ case   31:  		/* bl 74412 */
		/* 82072F1Ch case   31:*/		regs.LR = 0x82072F20; return 0x820851C8;
		/* 82072F1Ch case   31:*/		return 0x82072F20;
		  /* 82072F20h */ case   32:  		/* stw R29, <#[R30]> */
		/* 82072F20h case   32:*/		regs.IO->MEM_WRITE( 0x82072F20, (uint32)(regs.R30 + 0x00000000), 4, &regs.R29 );
		/* 82072F20h case   32:*/		return 0x82072F24;
		  /* 82072F24h */ case   33:  		/* eieio */
		/* 82072F24h case   33:*/		cpu::op::eieio<0>(regs);
		/* 82072F24h case   33:*/		return 0x82072F28;
		  /* 82072F28h */ case   34:  		/* addi R4, R31, 16 */
		/* 82072F28h case   34:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x10);
		/* 82072F28h case   34:*/		return 0x82072F2C;
		  /* 82072F2Ch */ case   35:  		/* li R5, 0 */
		/* 82072F2Ch case   35:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82072F2Ch case   35:*/		return 0x82072F30;
		  /* 82072F30h */ case   36:  		/* mr R3, R31 */
		/* 82072F30h case   36:*/		regs.R3 = regs.R31;
		/* 82072F30h case   36:*/		return 0x82072F34;
		  /* 82072F34h */ case   37:  		/* bl 74388 */
		/* 82072F34h case   37:*/		regs.LR = 0x82072F38; return 0x820851C8;
		/* 82072F34h case   37:*/		return 0x82072F38;
		  /* 82072F38h */ case   38:  		/* addi R1, R1, 112 */
		/* 82072F38h case   38:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82072F38h case   38:*/		return 0x82072F3C;
		  /* 82072F3Ch */ case   39:  		/* b 123760 */
		/* 82072F3Ch case   39:*/		return 0x820912AC;
		/* 82072F3Ch case   39:*/		return 0x82072F40;
	}
	return 0x82072F40;
} // Block from 82072EA0h-82072F40h (40 instructions)

//////////////////////////////////////////////////////
// Block at 82072F40h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072F40);
		  /* 82072F40h */ case    0:  		/* mfspr R12, LR */
		/* 82072F40h case    0:*/		regs.R12 = regs.LR;
		/* 82072F40h case    0:*/		return 0x82072F44;
		  /* 82072F44h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82072F44h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82072F44h case    1:*/		return 0x82072F48;
		  /* 82072F48h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82072F48h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82072F48h case    2:*/		return 0x82072F4C;
		  /* 82072F4Ch */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 82072F4Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82072F4Ch case    3:*/		return 0x82072F50;
		  /* 82072F50h */ case    4:  		/* lbz R11, <#[R3 + 11069]> */
		/* 82072F50h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B3D) );
		/* 82072F50h case    4:*/		return 0x82072F54;
		  /* 82072F54h */ case    5:  		/* mr R31, R3 */
		/* 82072F54h case    5:*/		regs.R31 = regs.R3;
		/* 82072F54h case    5:*/		return 0x82072F58;
		  /* 82072F58h */ case    6:  		/* mr R6, R5 */
		/* 82072F58h case    6:*/		regs.R6 = regs.R5;
		/* 82072F58h case    6:*/		return 0x82072F5C;
		  /* 82072F5Ch */ case    7:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82072F5Ch case    7:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82072F5Ch case    7:*/		return 0x82072F60;
		  /* 82072F60h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 82072F60h case    8:*/		if ( regs.CR[0].eq ) { return 0x82072F6C;  }
		/* 82072F60h case    8:*/		return 0x82072F64;
		  /* 82072F64h */ case    9:  		/* li R3, 0 */
		/* 82072F64h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82072F64h case    9:*/		return 0x82072F68;
		  /* 82072F68h */ case   10:  		/* b 172 */
		/* 82072F68h case   10:*/		return 0x82073014;
		/* 82072F68h case   10:*/		return 0x82072F6C;
	}
	return 0x82072F6C;
} // Block from 82072F40h-82072F6Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82072F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072F6C);
		  /* 82072F6Ch */ case    0:  		/* lwz R3, <#[R31 + 13920]> */
		/* 82072F6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00003660) );
		/* 82072F6Ch case    0:*/		return 0x82072F70;
		  /* 82072F70h */ case    1:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82072F70h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82072F70h case    1:*/		return 0x82072F74;
		  /* 82072F74h */ case    2:  		/* addi R5, R1, 80 */
		/* 82072F74h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82072F74h case    2:*/		return 0x82072F78;
		  /* 82072F78h */ case    3:  		/* stw R11, <#[R1 + 80]> */
		/* 82072F78h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82072F78h case    3:*/		return 0x82072F7C;
		  /* 82072F7Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 82072F7Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82072F7Ch case    4:*/		return 0x82072F80;
		  /* 82072F80h */ case    5:  		/* li R4, 1 */
		/* 82072F80h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82072F80h case    5:*/		return 0x82072F84;
		  /* 82072F84h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 82072F84h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82072F94;  }
		/* 82072F84h case    6:*/		return 0x82072F88;
		  /* 82072F88h */ case    7:  		/* mr R3, R31 */
		/* 82072F88h case    7:*/		regs.R3 = regs.R31;
		/* 82072F88h case    7:*/		return 0x82072F8C;
		  /* 82072F8Ch */ case    8:  		/* bl -1172 */
		/* 82072F8Ch case    8:*/		regs.LR = 0x82072F90; return 0x82072AF8;
		/* 82072F8Ch case    8:*/		return 0x82072F90;
		  /* 82072F90h */ case    9:  		/* b 32 */
		/* 82072F90h case    9:*/		return 0x82072FB0;
		/* 82072F90h case    9:*/		return 0x82072F94;
	}
	return 0x82072F94;
} // Block from 82072F6Ch-82072F94h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82072F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072F94);
		  /* 82072F94h */ case    0:  		/* lwz R11, <#[R3 + 152]> */
		/* 82072F94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000098) );
		/* 82072F94h case    0:*/		return 0x82072F98;
		  /* 82072F98h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82072F98h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82072F98h case    1:*/		return 0x82072F9C;
		  /* 82072F9Ch */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 82072F9Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82072FAC;  }
		/* 82072F9Ch case    2:*/		return 0x82072FA0;
		  /* 82072FA0h */ case    3:  		/* mr R3, R31 */
		/* 82072FA0h case    3:*/		regs.R3 = regs.R31;
		/* 82072FA0h case    3:*/		return 0x82072FA4;
		  /* 82072FA4h */ case    4:  		/* bl 6332 */
		/* 82072FA4h case    4:*/		regs.LR = 0x82072FA8; return 0x82074860;
		/* 82072FA4h case    4:*/		return 0x82072FA8;
		  /* 82072FA8h */ case    5:  		/* b 8 */
		/* 82072FA8h case    5:*/		return 0x82072FB0;
		/* 82072FA8h case    5:*/		return 0x82072FAC;
	}
	return 0x82072FAC;
} // Block from 82072F94h-82072FACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82072FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072FAC);
		  /* 82072FACh */ case    0:  		/* bl 6948 */
		/* 82072FACh case    0:*/		regs.LR = 0x82072FB0; return 0x82074AD0;
		/* 82072FACh case    0:*/		return 0x82072FB0;
	}
	return 0x82072FB0;
} // Block from 82072FACh-82072FB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82072FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82072FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82072FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82072FB0);
		  /* 82072FB0h */ case    0:  		/* lwz R11, <#[R31 + 15336]> */
		/* 82072FB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003BE8) );
		/* 82072FB0h case    0:*/		return 0x82072FB4;
		  /* 82072FB4h */ case    1:  		/* lwz R10, <#[R1 + 80]> */
		/* 82072FB4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82072FB4h case    1:*/		return 0x82072FB8;
		  /* 82072FB8h */ case    2:  		/* lwz R9, <#[R31 + 15340]> */
		/* 82072FB8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003BEC) );
		/* 82072FB8h case    2:*/		return 0x82072FBC;
		  /* 82072FBCh */ case    3:  		/* add R11, R11, R10 */
		/* 82072FBCh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82072FBCh case    3:*/		return 0x82072FC0;
		  /* 82072FC0h */ case    4:  		/* stw R11, <#[R31 + 15336]> */
		/* 82072FC0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00003BE8) );
		/* 82072FC0h case    4:*/		return 0x82072FC4;
		  /* 82072FC4h */ case    5:  		/* cmplw CR6, R11, R9 */
		/* 82072FC4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82072FC4h case    5:*/		return 0x82072FC8;
		  /* 82072FC8h */ case    6:  		/* bc 4, CR6_GT, 56 */
		/* 82072FC8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82073000;  }
		/* 82072FC8h case    6:*/		return 0x82072FCC;
		  /* 82072FCCh */ case    7:  		/* lwz R11, <#[R31 + 13600]> */
		/* 82072FCCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003520) );
		/* 82072FCCh case    7:*/		return 0x82072FD0;
		  /* 82072FD0h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 82072FD0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82072FD0h case    8:*/		return 0x82072FD4;
		  /* 82072FD4h */ case    9:  		/* bc 4, CR6_EQ, 44 */
		/* 82072FD4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82073000;  }
		/* 82072FD4h case    9:*/		return 0x82072FD8;
		  /* 82072FD8h */ case   10:  		/* lwz R11, <#[R31 + 48]> */
		/* 82072FD8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82072FD8h case   10:*/		return 0x82072FDC;
		  /* 82072FDCh */ case   11:  		/* lwz R10, <#[R31 + 15328]> */
		/* 82072FDCh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003BE0) );
		/* 82072FDCh case   11:*/		return 0x82072FE0;
		  /* 82072FE0h */ case   12:  		/* lwz R9, <#[R31 + 15308]> */
		/* 82072FE0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003BCC) );
		/* 82072FE0h case   12:*/		return 0x82072FE4;
		  /* 82072FE4h */ case   13:  		/* addi R8, R11, 160 */
		/* 82072FE4h case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xA0);
		/* 82072FE4h case   13:*/		return 0x82072FE8;
		  /* 82072FE8h */ case   14:  		/* stw R8, <#[R31 + 52]> */
		/* 82072FE8h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000034) );
		/* 82072FE8h case   14:*/		return 0x82072FEC;
		  /* 82072FECh */ case   15:  		/* cmplw CR6, R10, R9 */
		/* 82072FECh case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82072FECh case   15:*/		return 0x82072FF0;
		  /* 82072FF0h */ case   16:  		/* stw R11, <#[R31 + 56]> */
		/* 82072FF0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82072FF0h case   16:*/		return 0x82072FF4;
		  /* 82072FF4h */ case   17:  		/* bc 12, CR6_EQ, 12 */
		/* 82072FF4h case   17:*/		if ( regs.CR[6].eq ) { return 0x82073000;  }
		/* 82072FF4h case   17:*/		return 0x82072FF8;
		  /* 82072FF8h */ case   18:  		/* lwz R11, <#[R31 + 15312]> */
		/* 82072FF8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003BD0) );
		/* 82072FF8h case   18:*/		return 0x82072FFC;
		  /* 82072FFCh */ case   19:  		/* stw R11, <#[R31 + 15320]> */
		/* 82072FFCh case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00003BD8) );
		/* 82072FFCh case   19:*/		return 0x82073000;
	}
	return 0x82073000;
} // Block from 82072FB0h-82073000h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82073000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073000);
		  /* 82073000h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 82073000h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82073000h case    0:*/		return 0x82073004;
		  /* 82073004h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82073004h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82073014;  }
		/* 82073004h case    1:*/		return 0x82073008;
		  /* 82073008h */ case    2:  		/* lbz R11, <#[R31 + 11069]> */
		/* 82073008h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 82073008h case    2:*/		return 0x8207300C;
		  /* 8207300Ch */ case    3:  		/* ori R11, R11, 32 */
		/* 8207300Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 8207300Ch case    3:*/		return 0x82073010;
		  /* 82073010h */ case    4:  		/* stb R11, <#[R31 + 11069]> */
		/* 82073010h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 82073010h case    4:*/		return 0x82073014;
	}
	return 0x82073014;
} // Block from 82073000h-82073014h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82073014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073014);
		  /* 82073014h */ case    0:  		/* addi R1, R1, 112 */
		/* 82073014h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82073014h case    0:*/		return 0x82073018;
		  /* 82073018h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82073018h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82073018h case    1:*/		return 0x8207301C;
		  /* 8207301Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8207301Ch case    2:*/		regs.LR = regs.R12;
		/* 8207301Ch case    2:*/		return 0x82073020;
		  /* 82073020h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82073020h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82073020h case    3:*/		return 0x82073024;
		  /* 82073024h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82073024h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82073024h case    4:*/		return 0x82073028;
	}
	return 0x82073028;
} // Block from 82073014h-82073028h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82073028h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073028);
		  /* 82073028h */ case    0:  		/* mfspr R12, LR */
		/* 82073028h case    0:*/		regs.R12 = regs.LR;
		/* 82073028h case    0:*/		return 0x8207302C;
		  /* 8207302Ch */ case    1:  		/* bl 123440 */
		/* 8207302Ch case    1:*/		regs.LR = 0x82073030; return 0x8209125C;
		/* 8207302Ch case    1:*/		return 0x82073030;
		  /* 82073030h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82073030h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82073030h case    2:*/		return 0x82073034;
		  /* 82073034h */ case    3:  		/* lbz R11, <#[R3 + 11069]> */
		/* 82073034h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B3D) );
		/* 82073034h case    3:*/		return 0x82073038;
		  /* 82073038h */ case    4:  		/* mr R31, R3 */
		/* 82073038h case    4:*/		regs.R31 = regs.R3;
		/* 82073038h case    4:*/		return 0x8207303C;
		  /* 8207303Ch */ case    5:  		/* rlwinm. R10, R11, 0, 26, 26 */
		/* 8207303Ch case    5:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R11);
		/* 8207303Ch case    5:*/		return 0x82073040;
		  /* 82073040h */ case    6:  		/* bc 12, CR0_EQ, 48 */
		/* 82073040h case    6:*/		if ( regs.CR[0].eq ) { return 0x82073070;  }
		/* 82073040h case    6:*/		return 0x82073044;
		  /* 82073044h */ case    7:  		/* lwz R10, <#[R3 + 17136]> */
		/* 82073044h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000042F0) );
		/* 82073044h case    7:*/		return 0x82073048;
		  /* 82073048h */ case    8:  		/* mr R9, R11 */
		/* 82073048h case    8:*/		regs.R9 = regs.R11;
		/* 82073048h case    8:*/		return 0x8207304C;
		  /* 8207304Ch */ case    9:  		/* li R3, 0 */
		/* 8207304Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8207304Ch case    9:*/		return 0x82073050;
		  /* 82073050h */ case   10:  		/* addi R11, R10, 4800 */
		/* 82073050h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x12C0);
		/* 82073050h case   10:*/		return 0x82073054;
		  /* 82073054h */ case   11:  		/* ori R9, R9, 32 */
		/* 82073054h case   11:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x20);
		/* 82073054h case   11:*/		return 0x82073058;
		  /* 82073058h */ case   12:  		/* addi R8, R11, -160 */
		/* 82073058h case   12:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFF60);
		/* 82073058h case   12:*/		return 0x8207305C;
		  /* 8207305Ch */ case   13:  		/* stw R11, <#[R31 + 52]> */
		/* 8207305Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 8207305Ch case   13:*/		return 0x82073060;
		  /* 82073060h */ case   14:  		/* stw R10, <#[R31 + 48]> */
		/* 82073060h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 82073060h case   14:*/		return 0x82073064;
		  /* 82073064h */ case   15:  		/* stw R8, <#[R31 + 56]> */
		/* 82073064h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000038) );
		/* 82073064h case   15:*/		return 0x82073068;
		  /* 82073068h */ case   16:  		/* stb R9, <#[R31 + 11069]> */
		/* 82073068h case   16:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R31 + 0x00002B3D) );
		/* 82073068h case   16:*/		return 0x8207306C;
		  /* 8207306Ch */ case   17:  		/* b 288 */
		/* 8207306Ch case   17:*/		return 0x8207318C;
		/* 8207306Ch case   17:*/		return 0x82073070;
	}
	return 0x82073070;
} // Block from 82073028h-82073070h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82073070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073070);
		  /* 82073070h */ case    0:  		/* li R29, 0 */
		/* 82073070h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82073070h case    0:*/		return 0x82073074;
		  /* 82073074h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 82073074h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82073074h case    1:*/		return 0x82073078;
		  /* 82073078h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82073078h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82073084;  }
		/* 82073078h case    2:*/		return 0x8207307C;
		  /* 8207307Ch */ case    3:  		/* mr R11, R29 */
		/* 8207307Ch case    3:*/		regs.R11 = regs.R29;
		/* 8207307Ch case    3:*/		return 0x82073080;
		  /* 82073080h */ case    4:  		/* b 12 */
		/* 82073080h case    4:*/		return 0x8207308C;
		/* 82073080h case    4:*/		return 0x82073084;
	}
	return 0x82073084;
} // Block from 82073070h-82073084h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82073084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073084);
		  /* 82073084h */ case    0:  		/* addi R11, R4, 16 */
		/* 82073084h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x10);
		/* 82073084h case    0:*/		return 0x82073088;
		  /* 82073088h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82073088h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82073088h case    1:*/		return 0x8207308C;
	}
	return 0x8207308C;
} // Block from 82073084h-8207308Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8207308Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207308C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207308C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207308C);
		  /* 8207308Ch */ case    0:  		/* lwz R3, <#[R31 + 13920]> */
		/* 8207308Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00003660) );
		/* 8207308Ch case    0:*/		return 0x82073090;
		  /* 82073090h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82073090h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82073090h case    1:*/		return 0x82073094;
		  /* 82073094h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 82073094h case    2:*/		if ( regs.CR[6].eq ) { return 0x820730B4;  }
		/* 82073094h case    2:*/		return 0x82073098;
		  /* 82073098h */ case    3:  		/* lwz R10, <#[R3 + 172]> */
		/* 82073098h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000000AC) );
		/* 82073098h case    3:*/		return 0x8207309C;
		  /* 8207309Ch */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 8207309Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8207309Ch case    4:*/		return 0x820730A0;
		  /* 820730A0h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820730A0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820730B4;  }
		/* 820730A0h case    5:*/		return 0x820730A4;
		  /* 820730A4h */ case    6:  		/* lwz R10, <#[R31 + 15316]> */
		/* 820730A4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003BD4) );
		/* 820730A4h case    6:*/		return 0x820730A8;
		  /* 820730A8h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820730A8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820730A8h case    7:*/		return 0x820730AC;
		  /* 820730ACh */ case    8:  		/* bc 12, CR6_GT, 8 */
		/* 820730ACh case    8:*/		if ( regs.CR[6].gt ) { return 0x820730B4;  }
		/* 820730ACh case    8:*/		return 0x820730B0;
		  /* 820730B0h */ case    9:  		/* mr R11, R10 */
		/* 820730B0h case    9:*/		regs.R11 = regs.R10;
		/* 820730B0h case    9:*/		return 0x820730B4;
	}
	return 0x820730B4;
} // Block from 8207308Ch-820730B4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820730B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820730B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820730B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820730B4);
		  /* 820730B4h */ case    0:  		/* stw R11, <#[R1 + 80]> */
		/* 820730B4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820730B4h case    0:*/		return 0x820730B8;
		  /* 820730B8h */ case    1:  		/* cmplwi CR0, R3, 0 */
		/* 820730B8h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820730B8h case    1:*/		return 0x820730BC;
		  /* 820730BCh */ case    2:  		/* li R6, 32 */
		/* 820730BCh case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x20);
		/* 820730BCh case    2:*/		return 0x820730C0;
		  /* 820730C0h */ case    3:  		/* addi R5, R1, 80 */
		/* 820730C0h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820730C0h case    3:*/		return 0x820730C4;
		  /* 820730C4h */ case    4:  		/* li R4, 2 */
		/* 820730C4h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 820730C4h case    4:*/		return 0x820730C8;
		  /* 820730C8h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 820730C8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820730D8;  }
		/* 820730C8h case    5:*/		return 0x820730CC;
		  /* 820730CCh */ case    6:  		/* mr R3, R31 */
		/* 820730CCh case    6:*/		regs.R3 = regs.R31;
		/* 820730CCh case    6:*/		return 0x820730D0;
		  /* 820730D0h */ case    7:  		/* bl -1496 */
		/* 820730D0h case    7:*/		regs.LR = 0x820730D4; return 0x82072AF8;
		/* 820730D0h case    7:*/		return 0x820730D4;
		  /* 820730D4h */ case    8:  		/* b 32 */
		/* 820730D4h case    8:*/		return 0x820730F4;
		/* 820730D4h case    8:*/		return 0x820730D8;
	}
	return 0x820730D8;
} // Block from 820730B4h-820730D8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820730D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820730D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820730D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820730D8);
		  /* 820730D8h */ case    0:  		/* lwz R11, <#[R3 + 152]> */
		/* 820730D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000098) );
		/* 820730D8h case    0:*/		return 0x820730DC;
		  /* 820730DCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820730DCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820730DCh case    1:*/		return 0x820730E0;
		  /* 820730E0h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820730E0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820730F0;  }
		/* 820730E0h case    2:*/		return 0x820730E4;
		  /* 820730E4h */ case    3:  		/* mr R3, R31 */
		/* 820730E4h case    3:*/		regs.R3 = regs.R31;
		/* 820730E4h case    3:*/		return 0x820730E8;
		  /* 820730E8h */ case    4:  		/* bl 6008 */
		/* 820730E8h case    4:*/		regs.LR = 0x820730EC; return 0x82074860;
		/* 820730E8h case    4:*/		return 0x820730EC;
		  /* 820730ECh */ case    5:  		/* b 8 */
		/* 820730ECh case    5:*/		return 0x820730F4;
		/* 820730ECh case    5:*/		return 0x820730F0;
	}
	return 0x820730F0;
} // Block from 820730D8h-820730F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820730F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820730F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820730F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820730F0);
		  /* 820730F0h */ case    0:  		/* bl 6624 */
		/* 820730F0h case    0:*/		regs.LR = 0x820730F4; return 0x82074AD0;
		/* 820730F0h case    0:*/		return 0x820730F4;
	}
	return 0x820730F4;
} // Block from 820730F0h-820730F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820730F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820730F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820730F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820730F4);
		  /* 820730F4h */ case    0:  		/* mr R30, R3 */
		/* 820730F4h case    0:*/		regs.R30 = regs.R3;
		/* 820730F4h case    0:*/		return 0x820730F8;
		  /* 820730F8h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820730F8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820730F8h case    1:*/		return 0x820730FC;
		  /* 820730FCh */ case    2:  		/* bc 4, CR6_EQ, 40 */
		/* 820730FCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x82073124;  }
		/* 820730FCh case    2:*/		return 0x82073100;
		  /* 82073100h */ case    3:  		/* lwz R10, <#[R31 + 17136]> */
		/* 82073100h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000042F0) );
		/* 82073100h case    3:*/		return 0x82073104;
		  /* 82073104h */ case    4:  		/* lbz R9, <#[R31 + 11069]> */
		/* 82073104h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R31 + 0x00002B3D) );
		/* 82073104h case    4:*/		return 0x82073108;
		  /* 82073108h */ case    5:  		/* addi R11, R10, 4800 */
		/* 82073108h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x12C0);
		/* 82073108h case    5:*/		return 0x8207310C;
		  /* 8207310Ch */ case    6:  		/* ori R9, R9, 32 */
		/* 8207310Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x20);
		/* 8207310Ch case    6:*/		return 0x82073110;
		  /* 82073110h */ case    7:  		/* addi R8, R11, -160 */
		/* 82073110h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFF60);
		/* 82073110h case    7:*/		return 0x82073114;
		  /* 82073114h */ case    8:  		/* stw R10, <#[R31 + 48]> */
		/* 82073114h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 82073114h case    8:*/		return 0x82073118;
		  /* 82073118h */ case    9:  		/* stw R8, <#[R31 + 56]> */
		/* 82073118h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000038) );
		/* 82073118h case    9:*/		return 0x8207311C;
		  /* 8207311Ch */ case   10:  		/* stb R9, <#[R31 + 11069]> */
		/* 8207311Ch case   10:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R31 + 0x00002B3D) );
		/* 8207311Ch case   10:*/		return 0x82073120;
		  /* 82073120h */ case   11:  		/* b 52 */
		/* 82073120h case   11:*/		return 0x82073154;
		/* 82073120h case   11:*/		return 0x82073124;
	}
	return 0x82073124;
} // Block from 820730F4h-82073124h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82073124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073124);
		  /* 82073124h */ case    0:  		/* lwz R10, <#[R1 + 80]> */
		/* 82073124h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82073124h case    0:*/		return 0x82073128;
		  /* 82073128h */ case    1:  		/* addi R11, R30, -4 */
		/* 82073128h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFC);
		/* 82073128h case    1:*/		return 0x8207312C;
		  /* 8207312Ch */ case    2:  		/* stw R30, <#[R31 + 15332]> */
		/* 8207312Ch case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00003BE4) );
		/* 8207312Ch case    2:*/		return 0x82073130;
		  /* 82073130h */ case    3:  		/* rlwinm R10, R10, 30, 2, 31 */
		/* 82073130h case    3:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R10);
		/* 82073130h case    3:*/		return 0x82073134;
		  /* 82073134h */ case    4:  		/* stw R11, <#[R31 + 48]> */
		/* 82073134h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82073134h case    4:*/		return 0x82073138;
		  /* 82073138h */ case    5:  		/* stw R29, <#[R31 + 15320]> */
		/* 82073138h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00003BD8) );
		/* 82073138h case    5:*/		return 0x8207313C;
		  /* 8207313Ch */ case    6:  		/* addi R10, R10, -16 */
		/* 8207313Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFF0);
		/* 8207313Ch case    6:*/		return 0x82073140;
		  /* 82073140h */ case    7:  		/* stw R29, <#[R31 + 15336]> */
		/* 82073140h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00003BE8) );
		/* 82073140h case    7:*/		return 0x82073144;
		  /* 82073144h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82073144h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82073144h case    8:*/		return 0x82073148;
		  /* 82073148h */ case    9:  		/* add R11, R10, R11 */
		/* 82073148h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82073148h case    9:*/		return 0x8207314C;
		  /* 8207314Ch */ case   10:  		/* addi R10, R11, -160 */
		/* 8207314Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFF60);
		/* 8207314Ch case   10:*/		return 0x82073150;
		  /* 82073150h */ case   11:  		/* stw R10, <#[R31 + 56]> */
		/* 82073150h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 82073150h case   11:*/		return 0x82073154;
	}
	return 0x82073154;
} // Block from 82073124h-82073154h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82073154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073154);
		  /* 82073154h */ case    0:  		/* stw R11, <#[R31 + 52]> */
		/* 82073154h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000034) );
		/* 82073154h case    0:*/		return 0x82073158;
		  /* 82073158h */ case    1:  		/* lwz R11, <#[R31 + 24392]> */
		/* 82073158h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005F48) );
		/* 82073158h case    1:*/		return 0x8207315C;
		  /* 8207315Ch */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8207315Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8207315Ch case    2:*/		return 0x82073160;
		  /* 82073160h */ case    3:  		/* bc 4, CR0_EQ, 40 */
		/* 82073160h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82073188;  }
		/* 82073160h case    3:*/		return 0x82073164;
		  /* 82073164h */ case    4:  		/* lwz R4, <#[R31 + 15344]> */
		/* 82073164h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00003BF0) );
		/* 82073164h case    4:*/		return 0x82073168;
		  /* 82073168h */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 82073168h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82073168h case    5:*/		return 0x8207316C;
		  /* 8207316Ch */ case    6:  		/* bc 12, CR6_EQ, 28 */
		/* 8207316Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82073188;  }
		/* 8207316Ch case    6:*/		return 0x82073170;
		  /* 82073170h */ case    7:  		/* li R7, 0 */
		/* 82073170h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82073170h case    7:*/		return 0x82073174;
		  /* 82073174h */ case    8:  		/* li R6, 0 */
		/* 82073174h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82073174h case    8:*/		return 0x82073178;
		  /* 82073178h */ case    9:  		/* li R5, 3 */
		/* 82073178h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82073178h case    9:*/		return 0x8207317C;
		  /* 8207317Ch */ case   10:  		/* mr R3, R31 */
		/* 8207317Ch case   10:*/		regs.R3 = regs.R31;
		/* 8207317Ch case   10:*/		return 0x82073180;
		  /* 82073180h */ case   11:  		/* bl -1112 */
		/* 82073180h case   11:*/		regs.LR = 0x82073184; return 0x82072D28;
		/* 82073180h case   11:*/		return 0x82073184;
		  /* 82073184h */ case   12:  		/* stw R29, <#[R31 + 15344]> */
		/* 82073184h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00003BF0) );
		/* 82073184h case   12:*/		return 0x82073188;
	}
	return 0x82073188;
} // Block from 82073154h-82073188h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82073188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073188);
		  /* 82073188h */ case    0:  		/* mr R3, R30 */
		/* 82073188h case    0:*/		regs.R3 = regs.R30;
		/* 82073188h case    0:*/		return 0x8207318C;
	}
	return 0x8207318C;
} // Block from 82073188h-8207318Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8207318Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207318C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207318C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207318C);
		  /* 8207318Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8207318Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8207318Ch case    0:*/		return 0x82073190;
		  /* 82073190h */ case    1:  		/* b 123164 */
		/* 82073190h case    1:*/		return 0x820912AC;
		/* 82073190h case    1:*/		return 0x82073194;
		  /* 82073194h */ case    2:  		/* nop */
		/* 82073194h case    2:*/		cpu::op::nop();
		/* 82073194h case    2:*/		return 0x82073198;
	}
	return 0x82073198;
} // Block from 8207318Ch-82073198h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82073198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073198);
		  /* 82073198h */ case    0:  		/* mfspr R12, LR */
		/* 82073198h case    0:*/		regs.R12 = regs.LR;
		/* 82073198h case    0:*/		return 0x8207319C;
		  /* 8207319Ch */ case    1:  		/* bl 123032 */
		/* 8207319Ch case    1:*/		regs.LR = 0x820731A0; return 0x82091234;
		/* 8207319Ch case    1:*/		return 0x820731A0;
		  /* 820731A0h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 820731A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820731A0h case    2:*/		return 0x820731A4;
		  /* 820731A4h */ case    3:  		/* lbz R11, <#[R4]> */
		/* 820731A4h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820731A4h case    3:*/		return 0x820731A8;
		  /* 820731A8h */ case    4:  		/* mr R27, R3 */
		/* 820731A8h case    4:*/		regs.R27 = regs.R3;
		/* 820731A8h case    4:*/		return 0x820731AC;
		  /* 820731ACh */ case    5:  		/* lbz R10, <#[R3 + 11069]> */
		/* 820731ACh case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002B3D) );
		/* 820731ACh case    5:*/		return 0x820731B0;
		  /* 820731B0h */ case    6:  		/* mr R24, R4 */
		/* 820731B0h case    6:*/		regs.R24 = regs.R4;
		/* 820731B0h case    6:*/		return 0x820731B4;
		  /* 820731B4h */ case    7:  		/* addi R11, R11, -143 */
		/* 820731B4h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFF71);
		/* 820731B4h case    7:*/		return 0x820731B8;
		  /* 820731B8h */ case    8:  		/* lwz R29, <#[R3 + 15304]> */
		/* 820731B8h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00003BC8) );
		/* 820731B8h case    8:*/		return 0x820731BC;
		  /* 820731BCh */ case    9:  		/* lwz R28, <#[R3 + 15300]> */
		/* 820731BCh case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00003BC4) );
		/* 820731BCh case    9:*/		return 0x820731C0;
		  /* 820731C0h */ case   10:  		/* mr R25, R5 */
		/* 820731C0h case   10:*/		regs.R25 = regs.R5;
		/* 820731C0h case   10:*/		return 0x820731C4;
		  /* 820731C4h */ case   11:  		/* cntlzw R11, R11 */
		/* 820731C4h case   11:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820731C4h case   11:*/		return 0x820731C8;
		  /* 820731C8h */ case   12:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 820731C8h case   12:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 820731C8h case   12:*/		return 0x820731CC;
		  /* 820731CCh */ case   13:  		/* rlwinm R21, R11, 27, 31, 31 */
		/* 820731CCh case   13:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R21,regs.R11);
		/* 820731CCh case   13:*/		return 0x820731D0;
		  /* 820731D0h */ case   14:  		/* bc 12, CR0_EQ, 136 */
		/* 820731D0h case   14:*/		if ( regs.CR[0].eq ) { return 0x82073258;  }
		/* 820731D0h case   14:*/		return 0x820731D4;
		  /* 820731D4h */ case   15:  		/* lwz R11, <#[R3 + 21940]> */
		/* 820731D4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000055B4) );
		/* 820731D4h case   15:*/		return 0x820731D8;
		  /* 820731D8h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 820731D8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820731D8h case   16:*/		return 0x820731DC;
		  /* 820731DCh */ case   17:  		/* bc 12, CR6_EQ, 644 */
		/* 820731DCh case   17:*/		if ( regs.CR[6].eq ) { return 0x82073460;  }
		/* 820731DCh case   17:*/		return 0x820731E0;
		  /* 820731E0h */ case   18:  		/* cmplwi CR6, R5, 0 */
		/* 820731E0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820731E0h case   18:*/		return 0x820731E4;
		  /* 820731E4h */ case   19:  		/* bc 12, CR6_EQ, 636 */
		/* 820731E4h case   19:*/		if ( regs.CR[6].eq ) { return 0x82073460;  }
		/* 820731E4h case   19:*/		return 0x820731E8;
		  /* 820731E8h */ case   20:  		/* mr R31, R4 */
		/* 820731E8h case   20:*/		regs.R31 = regs.R4;
		/* 820731E8h case   20:*/		return 0x820731EC;
		  /* 820731ECh */ case   21:  		/* mr R30, R5 */
		/* 820731ECh case   21:*/		regs.R30 = regs.R5;
		/* 820731ECh case   21:*/		return 0x820731F0;
		  /* 820731F0h */ case   22:  		/* lis R19, 8192 */
		/* 820731F0h case   22:*/		cpu::op::lis<0>(regs,&regs.R19,0x2000);
		/* 820731F0h case   22:*/		return 0x820731F4;
		  /* 820731F4h */ case   23:  		/* lis R23, 16384 */
		/* 820731F4h case   23:*/		cpu::op::lis<0>(regs,&regs.R23,0x4000);
		/* 820731F4h case   23:*/		return 0x820731F8;
		  /* 820731F8h */ case   24:  		/* lis R20, 16640 */
		/* 820731F8h case   24:*/		cpu::op::lis<0>(regs,&regs.R20,0x4100);
		/* 820731F8h case   24:*/		return 0x820731FC;
		  /* 820731FCh */ case   25:  		/* lwz R11, <#[R31 + 4]> */
		/* 820731FCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820731FCh case   25:*/		return 0x82073200;
		  /* 82073200h */ case   26:  		/* lwz R10, <#[R31]> */
		/* 82073200h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82073200h case   26:*/		return 0x82073204;
		  /* 82073204h */ case   27:  		/* cmplw CR6, R11, R19 */
		/* 82073204h case   27:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 82073204h case   27:*/		return 0x82073208;
		  /* 82073208h */ case   28:  		/* rlwinm R5, R10, 0, 8, 31 */
		/* 82073208h case   28:*/		cpu::op::rlwinm<0,0,8,31>(regs,&regs.R5,regs.R10);
		/* 82073208h case   28:*/		return 0x8207320C;
		  /* 8207320Ch */ case   29:  		/* subf R4, R23, R11 */
		/* 8207320Ch case   29:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R23,regs.R11);
		/* 8207320Ch case   29:*/		return 0x82073210;
		  /* 82073210h */ case   30:  		/* bc 12, CR6_LT, 8 */
		/* 82073210h case   30:*/		if ( regs.CR[6].lt ) { return 0x82073218;  }
		/* 82073210h case   30:*/		return 0x82073214;
		  /* 82073214h */ case   31:  		/* subf R4, R20, R11 */
		/* 82073214h case   31:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R20,regs.R11);
		/* 82073214h case   31:*/		return 0x82073218;
	}
	return 0x82073218;
} // Block from 82073198h-82073218h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82073218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073218);
		  /* 82073218h */ case    0:  		/* lwz R3, <#[R27 + 21940]> */
		/* 82073218h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x000055B4) );
		/* 82073218h case    0:*/		return 0x8207321C;
		  /* 8207321Ch */ case    1:  		/* mr R7, R21 */
		/* 8207321Ch case    1:*/		regs.R7 = regs.R21;
		/* 8207321Ch case    1:*/		return 0x82073220;
		  /* 82073220h */ case    2:  		/* li R6, 1 */
		/* 82073220h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82073220h case    2:*/		return 0x82073224;
		  /* 82073224h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82073224h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82073224h case    3:*/		return 0x82073228;
		  /* 82073228h */ case    4:  		/* lwz R11, <#[R11 + 24]> */
		/* 82073228h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82073228h case    4:*/		return 0x8207322C;
		  /* 8207322Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 8207322Ch case    5:*/		regs.CTR = regs.R11;
		/* 8207322Ch case    5:*/		return 0x82073230;
		  /* 82073230h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82073230h case    6:*/		if ( 1 ) { regs.LR = 0x82073234; return (uint32)regs.CTR; }
		/* 82073230h case    6:*/		return 0x82073234;
		  /* 82073234h */ case    7:  		/* lwz R3, <#[R27 + 21940]> */
		/* 82073234h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x000055B4) );
		/* 82073234h case    7:*/		return 0x82073238;
		  /* 82073238h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 82073238h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82073238h case    8:*/		return 0x8207323C;
		  /* 8207323Ch */ case    9:  		/* lwz R11, <#[R11 + 28]> */
		/* 8207323Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8207323Ch case    9:*/		return 0x82073240;
		  /* 82073240h */ case   10:  		/* mtspr CTR, R11 */
		/* 82073240h case   10:*/		regs.CTR = regs.R11;
		/* 82073240h case   10:*/		return 0x82073244;
		  /* 82073244h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 82073244h case   11:*/		if ( 1 ) { regs.LR = 0x82073248; return (uint32)regs.CTR; }
		/* 82073244h case   11:*/		return 0x82073248;
		  /* 82073248h */ case   12:  		/* addic. R30, R30, -1 */
		/* 82073248h case   12:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 82073248h case   12:*/		return 0x8207324C;
		  /* 8207324Ch */ case   13:  		/* addi R31, R31, 8 */
		/* 8207324Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 8207324Ch case   13:*/		return 0x82073250;
		  /* 82073250h */ case   14:  		/* bc 4, CR0_EQ, -84 */
		/* 82073250h case   14:*/		if ( !regs.CR[0].eq ) { return 0x820731FC;  }
		/* 82073250h case   14:*/		return 0x82073254;
		  /* 82073254h */ case   15:  		/* b 524 */
		/* 82073254h case   15:*/		return 0x82073460;
		/* 82073254h case   15:*/		return 0x82073258;
	}
	return 0x82073258;
} // Block from 82073218h-82073258h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82073258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073258);
		  /* 82073258h */ case    0:  		/* lwz R4, <#[R27 + 11088]> */
		/* 82073258h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00002B50) );
		/* 82073258h case    0:*/		return 0x8207325C;
		  /* 8207325Ch */ case    1:  		/* cmpwi CR6, R21, 0 */
		/* 8207325Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8207325Ch case    1:*/		return 0x82073260;
		  /* 82073260h */ case    2:  		/* stw R4, <#[R1 + 80]> */
		/* 82073260h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 82073260h case    2:*/		return 0x82073264;
		  /* 82073264h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 82073264h case    3:*/		if ( regs.CR[6].eq ) { return 0x82073274;  }
		/* 82073264h case    3:*/		return 0x82073268;
		  /* 82073268h */ case    4:  		/* mulli R11, R25, 3 */
		/* 82073268h case    4:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R25,0x3);
		/* 82073268h case    4:*/		return 0x8207326C;
		  /* 8207326Ch */ case    5:  		/* addi R5, R11, 1 */
		/* 8207326Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 8207326Ch case    5:*/		return 0x82073270;
		  /* 82073270h */ case    6:  		/* b 8 */
		/* 82073270h case    6:*/		return 0x82073278;
		/* 82073270h case    6:*/		return 0x82073274;
	}
	return 0x82073274;
} // Block from 82073258h-82073274h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82073274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073274);
		  /* 82073274h */ case    0:  		/* mulli R5, R25, 3 */
		/* 82073274h case    0:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R25,0x3);
		/* 82073274h case    0:*/		return 0x82073278;
	}
	return 0x82073278;
} // Block from 82073274h-82073278h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82073278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073278);
		  /* 82073278h */ case    0:  		/* mr R3, R27 */
		/* 82073278h case    0:*/		regs.R3 = regs.R27;
		/* 82073278h case    0:*/		return 0x8207327C;
		  /* 8207327Ch */ case    1:  		/* bl -2756 */
		/* 8207327Ch case    1:*/		regs.LR = 0x82073280; return 0x820727B8;
		/* 8207327Ch case    1:*/		return 0x82073280;
		  /* 82073280h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 82073280h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82073280h case    2:*/		return 0x82073284;
		  /* 82073284h */ case    3:  		/* li R26, 0 */
		/* 82073284h case    3:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82073284h case    3:*/		return 0x82073288;
		  /* 82073288h */ case    4:  		/* cmplwi CR6, R25, 0 */
		/* 82073288h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82073288h case    4:*/		return 0x8207328C;
		  /* 8207328Ch */ case    5:  		/* bc 12, CR6_EQ, 380 */
		/* 8207328Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82073408;  }
		/* 8207328Ch case    5:*/		return 0x82073290;
		  /* 82073290h */ case    6:  		/* lis R19, 8192 */
		/* 82073290h case    6:*/		cpu::op::lis<0>(regs,&regs.R19,0x2000);
		/* 82073290h case    6:*/		return 0x82073294;
		  /* 82073294h */ case    7:  		/* lis R22, -32216 */
		/* 82073294h case    7:*/		cpu::op::lis<0>(regs,&regs.R22,0xFFFF8228);
		/* 82073294h case    7:*/		return 0x82073298;
		  /* 82073298h */ case    8:  		/* lis R23, 16384 */
		/* 82073298h case    8:*/		cpu::op::lis<0>(regs,&regs.R23,0x4000);
		/* 82073298h case    8:*/		return 0x8207329C;
		  /* 8207329Ch */ case    9:  		/* lis R20, 16640 */
		/* 8207329Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R20,0x4100);
		/* 8207329Ch case    9:*/		return 0x820732A0;
		  /* 820732A0h */ case   10:  		/* rlwinm R10, R26, 3, 0, 28 */
		/* 820732A0h case   10:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R26);
		/* 820732A0h case   10:*/		return 0x820732A4;
		  /* 820732A4h */ case   11:  		/* lwz R3, <#[R27 + 21940]> */
		/* 820732A4h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x000055B4) );
		/* 820732A4h case   11:*/		return 0x820732A8;
		  /* 820732A8h */ case   12:  		/* add R10, R10, R24 */
		/* 820732A8h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R24);
		/* 820732A8h case   12:*/		return 0x820732AC;
		  /* 820732ACh */ case   13:  		/* cmplwi CR6, R3, 0 */
		/* 820732ACh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820732ACh case   13:*/		return 0x820732B0;
		  /* 820732B0h */ case   14:  		/* lwz R9, <#[R10]> */
		/* 820732B0h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820732B0h case   14:*/		return 0x820732B4;
		  /* 820732B4h */ case   15:  		/* lwz R31, <#[R10 + 4]> */
		/* 820732B4h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 820732B4h case   15:*/		return 0x820732B8;
		  /* 820732B8h */ case   16:  		/* rlwinm R5, R9, 0, 8, 31 */
		/* 820732B8h case   16:*/		cpu::op::rlwinm<0,0,8,31>(regs,&regs.R5,regs.R9);
		/* 820732B8h case   16:*/		return 0x820732BC;
		  /* 820732BCh */ case   17:  		/* stw R5, <#[R1 + 84]> */
		/* 820732BCh case   17:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820732BCh case   17:*/		return 0x820732C0;
		  /* 820732C0h */ case   18:  		/* bc 12, CR6_EQ, 60 */
		/* 820732C0h case   18:*/		if ( regs.CR[6].eq ) { return 0x820732FC;  }
		/* 820732C0h case   18:*/		return 0x820732C4;
		  /* 820732C4h */ case   19:  		/* lwz R10, <#[R22 + 28740]> */
		/* 820732C4h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00007044) );
		/* 820732C4h case   19:*/		return 0x820732C8;
		  /* 820732C8h */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 820732C8h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820732C8h case   20:*/		return 0x820732CC;
		  /* 820732CCh */ case   21:  		/* bc 4, CR6_EQ, 48 */
		/* 820732CCh case   21:*/		if ( !regs.CR[6].eq ) { return 0x820732FC;  }
		/* 820732CCh case   21:*/		return 0x820732D0;
		  /* 820732D0h */ case   22:  		/* cmplw CR6, R31, R19 */
		/* 820732D0h case   22:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R19);
		/* 820732D0h case   22:*/		return 0x820732D4;
		  /* 820732D4h */ case   23:  		/* subf R4, R23, R31 */
		/* 820732D4h case   23:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R23,regs.R31);
		/* 820732D4h case   23:*/		return 0x820732D8;
		  /* 820732D8h */ case   24:  		/* bc 12, CR6_LT, 8 */
		/* 820732D8h case   24:*/		if ( regs.CR[6].lt ) { return 0x820732E0;  }
		/* 820732D8h case   24:*/		return 0x820732DC;
		  /* 820732DCh */ case   25:  		/* subf R4, R20, R31 */
		/* 820732DCh case   25:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R20,regs.R31);
		/* 820732DCh case   25:*/		return 0x820732E0;
	}
	return 0x820732E0;
} // Block from 82073278h-820732E0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820732E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820732E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820732E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820732E0);
		  /* 820732E0h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820732E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820732E0h case    0:*/		return 0x820732E4;
		  /* 820732E4h */ case    1:  		/* mr R7, R21 */
		/* 820732E4h case    1:*/		regs.R7 = regs.R21;
		/* 820732E4h case    1:*/		return 0x820732E8;
		  /* 820732E8h */ case    2:  		/* li R6, 1 */
		/* 820732E8h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820732E8h case    2:*/		return 0x820732EC;
		  /* 820732ECh */ case    3:  		/* lwz R11, <#[R11 + 24]> */
		/* 820732ECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820732ECh case    3:*/		return 0x820732F0;
		  /* 820732F0h */ case    4:  		/* mtspr CTR, R11 */
		/* 820732F0h case    4:*/		regs.CTR = regs.R11;
		/* 820732F0h case    4:*/		return 0x820732F4;
		  /* 820732F4h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820732F4h case    5:*/		if ( 1 ) { regs.LR = 0x820732F8; return (uint32)regs.CTR; }
		/* 820732F4h case    5:*/		return 0x820732F8;
		  /* 820732F8h */ case    6:  		/* lwz R11, <#[R1 + 80]> */
		/* 820732F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820732F8h case    6:*/		return 0x820732FC;
	}
	return 0x820732FC;
} // Block from 820732E0h-820732FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820732FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820732FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820732FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820732FC);
		  /* 820732FCh */ case    0:  		/* lwz R10, <#[R27 + 23768]> */
		/* 820732FCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00005CD8) );
		/* 820732FCh case    0:*/		return 0x82073300;
		  /* 82073300h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82073300h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82073300h case    1:*/		return 0x82073304;
		  /* 82073304h */ case    2:  		/* bc 12, CR6_EQ, 96 */
		/* 82073304h case    2:*/		if ( regs.CR[6].eq ) { return 0x82073364;  }
		/* 82073304h case    2:*/		return 0x82073308;
		  /* 82073308h */ case    3:  		/* cmplw CR6, R31, R19 */
		/* 82073308h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R19);
		/* 82073308h case    3:*/		return 0x8207330C;
		  /* 8207330Ch */ case    4:  		/* subf R30, R23, R31 */
		/* 8207330Ch case    4:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R23,regs.R31);
		/* 8207330Ch case    4:*/		return 0x82073310;
		  /* 82073310h */ case    5:  		/* bc 12, CR6_LT, 8 */
		/* 82073310h case    5:*/		if ( regs.CR[6].lt ) { return 0x82073318;  }
		/* 82073310h case    5:*/		return 0x82073314;
		  /* 82073314h */ case    6:  		/* subf R30, R20, R31 */
		/* 82073314h case    6:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R20,regs.R31);
		/* 82073314h case    6:*/		return 0x82073318;
	}
	return 0x82073318;
} // Block from 820732FCh-82073318h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82073318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073318);
		  /* 82073318h */ case    0:  		/* stw R30, <#[R1 + 88]> */
		/* 82073318h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000058) );
		/* 82073318h case    0:*/		return 0x8207331C;
		  /* 8207331Ch */ case    1:  		/* subfic R11, R21, 0 */
		/* 8207331Ch case    1:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R21,0x0);
		/* 8207331Ch case    1:*/		return 0x82073320;
		  /* 82073320h */ case    2:  		/* addi R5, R1, 84 */
		/* 82073320h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82073320h case    2:*/		return 0x82073324;
		  /* 82073324h */ case    3:  		/* mtspr CTR, R10 */
		/* 82073324h case    3:*/		regs.CTR = regs.R10;
		/* 82073324h case    3:*/		return 0x82073328;
		  /* 82073328h */ case    4:  		/* subfe R11, R11, R11 */
		/* 82073328h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82073328h case    4:*/		return 0x8207332C;
		  /* 8207332Ch */ case    5:  		/* addi R4, R1, 88 */
		/* 8207332Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 8207332Ch case    5:*/		return 0x82073330;
		  /* 82073330h */ case    6:  		/* and R11, R11, R23 */
		/* 82073330h case    6:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R23);
		/* 82073330h case    6:*/		return 0x82073334;
		  /* 82073334h */ case    7:  		/* li R3, 1 */
		/* 82073334h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82073334h case    7:*/		return 0x82073338;
		  /* 82073338h */ case    8:  		/* ori R6, R11, 1 */
		/* 82073338h case    8:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R11,0x1);
		/* 82073338h case    8:*/		return 0x8207333C;
		  /* 8207333Ch */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 8207333Ch case    9:*/		if ( 1 ) { regs.LR = 0x82073340; return (uint32)regs.CTR; }
		/* 8207333Ch case    9:*/		return 0x82073340;
		  /* 82073340h */ case   10:  		/* lwz R10, <#[R1 + 88]> */
		/* 82073340h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82073340h case   10:*/		return 0x82073344;
		  /* 82073344h */ case   11:  		/* lwz R11, <#[R1 + 80]> */
		/* 82073344h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82073344h case   11:*/		return 0x82073348;
		  /* 82073348h */ case   12:  		/* cmplw CR6, R30, R10 */
		/* 82073348h case   12:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 82073348h case   12:*/		return 0x8207334C;
		  /* 8207334Ch */ case   13:  		/* bc 12, CR6_EQ, 24 */
		/* 8207334Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82073364;  }
		/* 8207334Ch case   13:*/		return 0x82073350;
		  /* 82073350h */ case   14:  		/* rlwinm R9, R10, 12, 20, 31 */
		/* 82073350h case   14:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R9,regs.R10);
		/* 82073350h case   14:*/		return 0x82073354;
		  /* 82073354h */ case   15:  		/* rlwinm R10, R10, 0, 3, 31 */
		/* 82073354h case   15:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R10);
		/* 82073354h case   15:*/		return 0x82073358;
		  /* 82073358h */ case   16:  		/* addi R9, R9, 512 */
		/* 82073358h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x200);
		/* 82073358h case   16:*/		return 0x8207335C;
		  /* 8207335Ch */ case   17:  		/* rlwinm R9, R9, 0, 19, 19 */
		/* 8207335Ch case   17:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R9,regs.R9);
		/* 8207335Ch case   17:*/		return 0x82073360;
		  /* 82073360h */ case   18:  		/* add R31, R9, R10 */
		/* 82073360h case   18:*/		cpu::op::add<0>(regs,&regs.R31,regs.R9,regs.R10);
		/* 82073360h case   18:*/		return 0x82073364;
	}
	return 0x82073364;
} // Block from 82073318h-82073364h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82073364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073364);
		  /* 82073364h */ case    0:  		/* lwz R10, <#[R1 + 84]> */
		/* 82073364h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82073364h case    0:*/		return 0x82073368;
		  /* 82073368h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82073368h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82073368h case    1:*/		return 0x8207336C;
		  /* 8207336Ch */ case    2:  		/* bc 12, CR6_EQ, 144 */
		/* 8207336Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820733FC;  }
		/* 8207336Ch case    2:*/		return 0x82073370;
		  /* 82073370h */ case    3:  		/* cmpwi CR6, R21, 0 */
		/* 82073370h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 82073370h case    3:*/		return 0x82073374;
		  /* 82073374h */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 82073374h case    4:*/		if ( regs.CR[6].eq ) { return 0x820733A8;  }
		/* 82073374h case    4:*/		return 0x82073378;
		  /* 82073378h */ case    5:  		/* cmplwi CR6, R26, 0 */
		/* 82073378h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82073378h case    5:*/		return 0x8207337C;
		  /* 8207337Ch */ case    6:  		/* bc 4, CR6_EQ, 32 */
		/* 8207337Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x8207339C;  }
		/* 8207337Ch case    6:*/		return 0x82073380;
		  /* 82073380h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82073380h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82073380h case    7:*/		return 0x82073384;
		  /* 82073384h */ case    8:  		/* lis R10, -32768 */
		/* 82073384h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 82073384h case    8:*/		return 0x82073388;
		  /* 82073388h */ case    9:  		/* stwx R10, <#[R11 + R28]> */
		/* 82073388h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82073388h case    9:*/		return 0x8207338C;
		  /* 8207338Ch */ case   10:  		/* lwz R11, <#[R1 + 80]> */
		/* 8207338Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8207338Ch case   10:*/		return 0x82073390;
		  /* 82073390h */ case   11:  		/* addi R11, R11, 1 */
		/* 82073390h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82073390h case   11:*/		return 0x82073394;
		  /* 82073394h */ case   12:  		/* and R11, R11, R29 */
		/* 82073394h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82073394h case   12:*/		return 0x82073398;
		  /* 82073398h */ case   13:  		/* stw R11, <#[R1 + 80]> */
		/* 82073398h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82073398h case   13:*/		return 0x8207339C;
	}
	return 0x8207339C;
} // Block from 82073364h-8207339Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8207339Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207339C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207339C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207339C);
		  /* 8207339Ch */ case    0:  		/* lis R10, -16383 */
		/* 8207339Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC001);
		/* 8207339Ch case    0:*/		return 0x820733A0;
		  /* 820733A0h */ case    1:  		/* ori R10, R10, 14080 */
		/* 820733A0h case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3700);
		/* 820733A0h case    1:*/		return 0x820733A4;
		  /* 820733A4h */ case    2:  		/* b 12 */
		/* 820733A4h case    2:*/		return 0x820733B0;
		/* 820733A4h case    2:*/		return 0x820733A8;
	}
	return 0x820733A8;
} // Block from 8207339Ch-820733A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820733A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820733A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820733A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820733A8);
		  /* 820733A8h */ case    0:  		/* lis R10, -16383 */
		/* 820733A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC001);
		/* 820733A8h case    0:*/		return 0x820733AC;
		  /* 820733ACh */ case    1:  		/* ori R10, R10, 16128 */
		/* 820733ACh case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3F00);
		/* 820733ACh case    1:*/		return 0x820733B0;
	}
	return 0x820733B0;
} // Block from 820733A8h-820733B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820733B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820733B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820733B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820733B0);
		  /* 820733B0h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820733B0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820733B0h case    0:*/		return 0x820733B4;
		  /* 820733B4h */ case    1:  		/* stwx R10, <#[R11 + R28]> */
		/* 820733B4h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 820733B4h case    1:*/		return 0x820733B8;
		  /* 820733B8h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 820733B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820733B8h case    2:*/		return 0x820733BC;
		  /* 820733BCh */ case    3:  		/* addi R11, R11, 1 */
		/* 820733BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820733BCh case    3:*/		return 0x820733C0;
		  /* 820733C0h */ case    4:  		/* and R11, R11, R29 */
		/* 820733C0h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 820733C0h case    4:*/		return 0x820733C4;
		  /* 820733C4h */ case    5:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 820733C4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 820733C4h case    5:*/		return 0x820733C8;
		  /* 820733C8h */ case    6:  		/* stw R11, <#[R1 + 80]> */
		/* 820733C8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820733C8h case    6:*/		return 0x820733CC;
		  /* 820733CCh */ case    7:  		/* stwx R31, <#[R10 + R28]> */
		/* 820733CCh case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 820733CCh case    7:*/		return 0x820733D0;
		  /* 820733D0h */ case    8:  		/* lwz R10, <#[R1 + 84]> */
		/* 820733D0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 820733D0h case    8:*/		return 0x820733D4;
		  /* 820733D4h */ case    9:  		/* lwz R11, <#[R1 + 80]> */
		/* 820733D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820733D4h case    9:*/		return 0x820733D8;
		  /* 820733D8h */ case   10:  		/* addi R11, R11, 1 */
		/* 820733D8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820733D8h case   10:*/		return 0x820733DC;
		  /* 820733DCh */ case   11:  		/* and R11, R11, R29 */
		/* 820733DCh case   11:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 820733DCh case   11:*/		return 0x820733E0;
		  /* 820733E0h */ case   12:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 820733E0h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 820733E0h case   12:*/		return 0x820733E4;
		  /* 820733E4h */ case   13:  		/* stw R11, <#[R1 + 80]> */
		/* 820733E4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820733E4h case   13:*/		return 0x820733E8;
		  /* 820733E8h */ case   14:  		/* stwx R10, <#[R9 + R28]> */
		/* 820733E8h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R28 + 0x00000000) );
		/* 820733E8h case   14:*/		return 0x820733EC;
		  /* 820733ECh */ case   15:  		/* lwz R11, <#[R1 + 80]> */
		/* 820733ECh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820733ECh case   15:*/		return 0x820733F0;
		  /* 820733F0h */ case   16:  		/* addi R11, R11, 1 */
		/* 820733F0h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820733F0h case   16:*/		return 0x820733F4;
		  /* 820733F4h */ case   17:  		/* and R11, R11, R29 */
		/* 820733F4h case   17:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 820733F4h case   17:*/		return 0x820733F8;
		  /* 820733F8h */ case   18:  		/* stw R11, <#[R1 + 80]> */
		/* 820733F8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820733F8h case   18:*/		return 0x820733FC;
	}
	return 0x820733FC;
} // Block from 820733B0h-820733FCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820733FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820733FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820733FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820733FC);
		  /* 820733FCh */ case    0:  		/* addi R26, R26, 1 */
		/* 820733FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820733FCh case    0:*/		return 0x82073400;
		  /* 82073400h */ case    1:  		/* cmplw CR6, R26, R25 */
		/* 82073400h case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R25);
		/* 82073400h case    1:*/		return 0x82073404;
		  /* 82073404h */ case    2:  		/* bc 12, CR6_LT, -356 */
		/* 82073404h case    2:*/		if ( regs.CR[6].lt ) { return 0x820732A0;  }
		/* 82073404h case    2:*/		return 0x82073408;
	}
	return 0x82073408;
} // Block from 820733FCh-82073408h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82073408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073408);
		  /* 82073408h */ case    0:  		/* stw R11, <#[R27 + 11088]> */
		/* 82073408h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00002B50) );
		/* 82073408h case    0:*/		return 0x8207340C;
		  /* 8207340Ch */ case    1:  		/* sync */
		/* 8207340Ch case    1:*/		cpu::op::sync<0>(regs);
		/* 8207340Ch case    1:*/		return 0x82073410;
		  /* 82073410h */ case    2:  		/* lis R10, 32712 */
		/* 82073410h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x7FC8);
		/* 82073410h case    2:*/		return 0x82073414;
		  /* 82073414h */ case    3:  		/* stw R11, <#[R10 + 1812]> */
		/* 82073414h case    3:*/		regs.IO->MEM_WRITE( 0x82073414, (uint32)(regs.R10 + 0x00000714), 4, &regs.R11 );
		/* 82073414h case    3:*/		return 0x82073418;
		  /* 82073418h */ case    4:  		/* eieio */
		/* 82073418h case    4:*/		cpu::op::eieio<0>(regs);
		/* 82073418h case    4:*/		return 0x8207341C;
		  /* 8207341Ch */ case    5:  		/* sync */
		/* 8207341Ch case    5:*/		cpu::op::sync<0>(regs);
		/* 8207341Ch case    5:*/		return 0x82073420;
		  /* 82073420h */ case    6:  		/* lwz R3, <#[R27 + 21940]> */
		/* 82073420h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x000055B4) );
		/* 82073420h case    6:*/		return 0x82073424;
		  /* 82073424h */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 82073424h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82073424h case    7:*/		return 0x82073428;
		  /* 82073428h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82073428h case    8:*/		if ( regs.CR[6].eq ) { return 0x8207343C;  }
		/* 82073428h case    8:*/		return 0x8207342C;
		  /* 8207342Ch */ case    9:  		/* lwz R11, <#[R3]> */
		/* 8207342Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8207342Ch case    9:*/		return 0x82073430;
		  /* 82073430h */ case   10:  		/* lwz R11, <#[R11 + 28]> */
		/* 82073430h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82073430h case   10:*/		return 0x82073434;
		  /* 82073434h */ case   11:  		/* mtspr CTR, R11 */
		/* 82073434h case   11:*/		regs.CTR = regs.R11;
		/* 82073434h case   11:*/		return 0x82073438;
		  /* 82073438h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 82073438h case   12:*/		if ( 1 ) { regs.LR = 0x8207343C; return (uint32)regs.CTR; }
		/* 82073438h case   12:*/		return 0x8207343C;
	}
	return 0x8207343C;
} // Block from 82073408h-8207343Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8207343Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207343C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207343C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207343C);
		  /* 8207343Ch */ case    0:  		/* lwz R11, <#[R27 + 23768]> */
		/* 8207343Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00005CD8) );
		/* 8207343Ch case    0:*/		return 0x82073440;
		  /* 82073440h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82073440h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82073440h case    1:*/		return 0x82073444;
		  /* 82073444h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 82073444h case    2:*/		if ( regs.CR[6].eq ) { return 0x82073460;  }
		/* 82073444h case    2:*/		return 0x82073448;
		  /* 82073448h */ case    3:  		/* li R6, 0 */
		/* 82073448h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82073448h case    3:*/		return 0x8207344C;
		  /* 8207344Ch */ case    4:  		/* mtspr CTR, R11 */
		/* 8207344Ch case    4:*/		regs.CTR = regs.R11;
		/* 8207344Ch case    4:*/		return 0x82073450;
		  /* 82073450h */ case    5:  		/* addi R5, R1, 80 */
		/* 82073450h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82073450h case    5:*/		return 0x82073454;
		  /* 82073454h */ case    6:  		/* li R4, 0 */
		/* 82073454h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82073454h case    6:*/		return 0x82073458;
		  /* 82073458h */ case    7:  		/* li R3, 2 */
		/* 82073458h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82073458h case    7:*/		return 0x8207345C;
		  /* 8207345Ch */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 8207345Ch case    8:*/		if ( 1 ) { regs.LR = 0x82073460; return (uint32)regs.CTR; }
		/* 8207345Ch case    8:*/		return 0x82073460;
	}
	return 0x82073460;
} // Block from 8207343Ch-82073460h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82073460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073460);
		  /* 82073460h */ case    0:  		/* addi R1, R1, 208 */
		/* 82073460h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 82073460h case    0:*/		return 0x82073464;
		  /* 82073464h */ case    1:  		/* b 122400 */
		/* 82073464h case    1:*/		return 0x82091284;
		/* 82073464h case    1:*/		return 0x82073468;
	}
	return 0x82073468;
} // Block from 82073460h-82073468h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82073468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073468);
		  /* 82073468h */ case    0:  		/* mfspr R12, LR */
		/* 82073468h case    0:*/		regs.R12 = regs.LR;
		/* 82073468h case    0:*/		return 0x8207346C;
		  /* 8207346Ch */ case    1:  		/* bl 122328 */
		/* 8207346Ch case    1:*/		regs.LR = 0x82073470; return 0x82091244;
		/* 8207346Ch case    1:*/		return 0x82073470;
		  /* 82073470h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82073470h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82073470h case    2:*/		return 0x82073474;
		  /* 82073474h */ case    3:  		/* li R11, -1 */
		/* 82073474h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82073474h case    3:*/		return 0x82073478;
		  /* 82073478h */ case    4:  		/* ld R10, <#[R3 + 12248]> */
		/* 82073478h case    4:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00002FD8) );
		/* 82073478h case    4:*/		return 0x8207347C;
		  /* 8207347Ch */ case    5:  		/* mr R31, R3 */
		/* 8207347Ch case    5:*/		regs.R31 = regs.R3;
		/* 8207347Ch case    5:*/		return 0x82073480;
		  /* 82073480h */ case    6:  		/* rldicl R11, R11, 0, 32 */
		/* 82073480h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 82073480h case    6:*/		return 0x82073484;
		  /* 82073484h */ case    7:  		/* mr R23, R4 */
		/* 82073484h case    7:*/		regs.R23 = regs.R4;
		/* 82073484h case    7:*/		return 0x82073488;
		  /* 82073488h */ case    8:  		/* mr R24, R5 */
		/* 82073488h case    8:*/		regs.R24 = regs.R5;
		/* 82073488h case    8:*/		return 0x8207348C;
		  /* 8207348Ch */ case    9:  		/* addi R28, R3, 12248 */
		/* 8207348Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R3,0x2FD8);
		/* 8207348Ch case    9:*/		return 0x82073490;
		  /* 82073490h */ case   10:  		/* li R27, 0 */
		/* 82073490h case   10:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82073490h case   10:*/		return 0x82073494;
		  /* 82073494h */ case   11:  		/* cmpld CR6, R10, R11 */
		/* 82073494h case   11:*/		cpu::op::cmpld<6>(regs,regs.R10,regs.R11);
		/* 82073494h case   11:*/		return 0x82073498;
		  /* 82073498h */ case   12:  		/* li R30, 1 */
		/* 82073498h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82073498h case   12:*/		return 0x8207349C;
		  /* 8207349Ch */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 8207349Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x820734A4;  }
		/* 8207349Ch case   13:*/		return 0x820734A0;
		  /* 820734A0h */ case   14:  		/* mr R30, R27 */
		/* 820734A0h case   14:*/		regs.R30 = regs.R27;
		/* 820734A0h case   14:*/		return 0x820734A4;
	}
	return 0x820734A4;
} // Block from 82073468h-820734A4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820734A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820734A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820734A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820734A4);
		  /* 820734A4h */ case    0:  		/* lbz R11, <#[R31 + 11070]> */
		/* 820734A4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3E) );
		/* 820734A4h case    0:*/		return 0x820734A8;
		  /* 820734A8h */ case    1:  		/* lwz R29, <#[R31 + 12256]> */
		/* 820734A8h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00002FE0) );
		/* 820734A8h case    1:*/		return 0x820734AC;
		  /* 820734ACh */ case    2:  		/* rlwinm R26, R11, 30, 31, 31 */
		/* 820734ACh case    2:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R26,regs.R11);
		/* 820734ACh case    2:*/		return 0x820734B0;
		  /* 820734B0h */ case    3:  		/* cmpwi CR6, R29, 0 */
		/* 820734B0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820734B0h case    3:*/		return 0x820734B4;
		  /* 820734B4h */ case    4:  		/* bc 12, CR6_EQ, 100 */
		/* 820734B4h case    4:*/		if ( regs.CR[6].eq ) { return 0x82073518;  }
		/* 820734B4h case    4:*/		return 0x820734B8;
		  /* 820734B8h */ case    5:  		/* li R25, 6 */
		/* 820734B8h case    5:*/		cpu::op::li<0>(regs,&regs.R25,0x6);
		/* 820734B8h case    5:*/		return 0x820734BC;
		  /* 820734BCh */ case    6:  		/* li R5, 32 */
		/* 820734BCh case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 820734BCh case    6:*/		return 0x820734C0;
		  /* 820734C0h */ case    7:  		/* mr R4, R25 */
		/* 820734C0h case    7:*/		regs.R4 = regs.R25;
		/* 820734C0h case    7:*/		return 0x820734C4;
		  /* 820734C4h */ case    8:  		/* mr R3, R31 */
		/* 820734C4h case    8:*/		regs.R3 = regs.R31;
		/* 820734C4h case    8:*/		return 0x820734C8;
		  /* 820734C8h */ case    9:  		/* bl -1416 */
		/* 820734C8h case    9:*/		regs.LR = 0x820734CC; return 0x82072F40;
		/* 820734C8h case    9:*/		return 0x820734CC;
		  /* 820734CCh */ case   10:  		/* or. R6, R3, R3 */
		/* 820734CCh case   10:*/		cpu::op::or<1>(regs,&regs.R6,regs.R3,regs.R3);
		/* 820734CCh case   10:*/		return 0x820734D0;
		  /* 820734D0h */ case   11:  		/* bc 12, CR0_EQ, 88 */
		/* 820734D0h case   11:*/		if ( regs.CR[0].eq ) { return 0x82073528;  }
		/* 820734D0h case   11:*/		return 0x820734D4;
		  /* 820734D4h */ case   12:  		/* addi R7, R6, -4 */
		/* 820734D4h case   12:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820734D4h case   12:*/		return 0x820734D8;
		  /* 820734D8h */ case   13:  		/* cmpwi CR6, R29, 0 */
		/* 820734D8h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820734D8h case   13:*/		return 0x820734DC;
		  /* 820734DCh */ case   14:  		/* bc 12, CR6_EQ, 84 */
		/* 820734DCh case   14:*/		if ( regs.CR[6].eq ) { return 0x82073530;  }
		/* 820734DCh case   14:*/		return 0x820734E0;
		  /* 820734E0h */ case   15:  		/* li R11, 1480 */
		/* 820734E0h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x5C8);
		/* 820734E0h case   15:*/		return 0x820734E4;
		  /* 820734E4h */ case   16:  		/* stw R27, <#[R31 + 12256]> */
		/* 820734E4h case   16:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00002FE0) );
		/* 820734E4h case   16:*/		return 0x820734E8;
		  /* 820734E8h */ case   17:  		/* lis R10, 2 */
		/* 820734E8h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0x2);
		/* 820734E8h case   17:*/		return 0x820734EC;
		  /* 820734ECh */ case   18:  		/* stwu R11, <#[R7 + 4]> */
		/* 820734ECh case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820734ECh case   18:*/		return 0x820734F0;
		  /* 820734F0h */ case   19:  		/* li R11, 3584 */
		/* 820734F0h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0xE00);
		/* 820734F0h case   19:*/		return 0x820734F4;
		  /* 820734F4h */ case   20:  		/* li R9, 1 */
		/* 820734F4h case   20:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820734F4h case   20:*/		return 0x820734F8;
		  /* 820734F8h */ case   21:  		/* li R8, 3648 */
		/* 820734F8h case   21:*/		cpu::op::li<0>(regs,&regs.R8,0xE40);
		/* 820734F8h case   21:*/		return 0x820734FC;
		  /* 820734FCh */ case   22:  		/* li R5, 1 */
		/* 820734FCh case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820734FCh case   22:*/		return 0x82073500;
		  /* 82073500h */ case   23:  		/* stwu R10, <#[R7 + 4]> */
		/* 82073500h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073500h case   23:*/		return 0x82073504;
		  /* 82073504h */ case   24:  		/* stwu R11, <#[R7 + 4]> */
		/* 82073504h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073504h case   24:*/		return 0x82073508;
		  /* 82073508h */ case   25:  		/* stwu R9, <#[R7 + 4]> */
		/* 82073508h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073508h case   25:*/		return 0x8207350C;
		  /* 8207350Ch */ case   26:  		/* stwu R8, <#[R7 + 4]> */
		/* 8207350Ch case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 8207350Ch case   26:*/		return 0x82073510;
		  /* 82073510h */ case   27:  		/* stwu R5, <#[R7 + 4]> */
		/* 82073510h case   27:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073510h case   27:*/		return 0x82073514;
		  /* 82073514h */ case   28:  		/* b 320 */
		/* 82073514h case   28:*/		return 0x82073654;
		/* 82073514h case   28:*/		return 0x82073518;
	}
	return 0x82073518;
} // Block from 820734A4h-82073518h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82073518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073518);
		  /* 82073518h */ case    0:  		/* add R11, R26, R30 */
		/* 82073518h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R26,regs.R30);
		/* 82073518h case    0:*/		return 0x8207351C;
		  /* 8207351Ch */ case    1:  		/* mulli R25, R11, 11 */
		/* 8207351Ch case    1:*/		cpu::op::mulli<0>(regs,&regs.R25,regs.R11,0xB);
		/* 8207351Ch case    1:*/		return 0x82073520;
		  /* 82073520h */ case    2:  		/* cmplwi CR6, R25, 0 */
		/* 82073520h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82073520h case    2:*/		return 0x82073524;
		  /* 82073524h */ case    3:  		/* bc 4, CR6_EQ, -104 */
		/* 82073524h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820734BC;  }
		/* 82073524h case    3:*/		return 0x82073528;
	}
	return 0x82073528;
} // Block from 82073518h-82073528h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82073528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073528);
		  /* 82073528h */ case    0:  		/* stw R27, <#[R24]> */
		/* 82073528h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R24 + 0x00000000) );
		/* 82073528h case    0:*/		return 0x8207352C;
		  /* 8207352Ch */ case    1:  		/* b 324 */
		/* 8207352Ch case    1:*/		return 0x82073670;
		/* 8207352Ch case    1:*/		return 0x82073530;
	}
	return 0x82073530;
} // Block from 82073528h-82073530h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82073530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073530);
		  /* 82073530h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 82073530h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82073530h case    0:*/		return 0x82073534;
		  /* 82073534h */ case    1:  		/* bc 12, CR6_EQ, 132 */
		/* 82073534h case    1:*/		if ( regs.CR[6].eq ) { return 0x820735B8;  }
		/* 82073534h case    1:*/		return 0x82073538;
		  /* 82073538h */ case    2:  		/* addi R5, R1, 80 */
		/* 82073538h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82073538h case    2:*/		return 0x8207353C;
		  /* 8207353Ch */ case    3:  		/* addi R4, R1, 84 */
		/* 8207353Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 8207353Ch case    3:*/		return 0x82073540;
		  /* 82073540h */ case    4:  		/* mr R3, R28 */
		/* 82073540h case    4:*/		regs.R3 = regs.R28;
		/* 82073540h case    4:*/		return 0x82073544;
		  /* 82073544h */ case    5:  		/* bl -2876 */
		/* 82073544h case    5:*/		regs.LR = 0x82073548; return 0x82072A08;
		/* 82073544h case    5:*/		return 0x82073548;
		  /* 82073548h */ case    6:  		/* li R11, 2609 */
		/* 82073548h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0xA31);
		/* 82073548h case    6:*/		return 0x8207354C;
		  /* 8207354Ch */ case    7:  		/* lis R10, 768 */
		/* 8207354Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x300);
		/* 8207354Ch case    7:*/		return 0x82073550;
		  /* 82073550h */ case    8:  		/* stwu R11, <#[R7 + 4]> */
		/* 82073550h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073550h case    8:*/		return 0x82073554;
		  /* 82073554h */ case    9:  		/* lis R9, 1 */
		/* 82073554h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x1);
		/* 82073554h case    9:*/		return 0x82073558;
		  /* 82073558h */ case   10:  		/* lis R8, -16380 */
		/* 82073558h case   10:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFC004);
		/* 82073558h case   10:*/		return 0x8207355C;
		  /* 8207355Ch */ case   11:  		/* ori R11, R9, 2607 */
		/* 8207355Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R9,0xA2F);
		/* 8207355Ch case   11:*/		return 0x82073560;
		  /* 82073560h */ case   12:  		/* ori R9, R8, 15360 */
		/* 82073560h case   12:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R8,0x3C00);
		/* 82073560h case   12:*/		return 0x82073564;
		  /* 82073564h */ case   13:  		/* li R8, 3 */
		/* 82073564h case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 82073564h case   13:*/		return 0x82073568;
		  /* 82073568h */ case   14:  		/* stwu R10, <#[R7 + 4]> */
		/* 82073568h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073568h case   14:*/		return 0x8207356C;
		  /* 8207356Ch */ case   15:  		/* li R5, 2609 */
		/* 8207356Ch case   15:*/		cpu::op::li<0>(regs,&regs.R5,0xA31);
		/* 8207356Ch case   15:*/		return 0x82073570;
		  /* 82073570h */ case   16:  		/* lis R3, -32768 */
		/* 82073570h case   16:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82073570h case   16:*/		return 0x82073574;
		  /* 82073574h */ case   17:  		/* li R10, 8 */
		/* 82073574h case   17:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 82073574h case   17:*/		return 0x82073578;
		  /* 82073578h */ case   18:  		/* mr R4, R27 */
		/* 82073578h case   18:*/		regs.R4 = regs.R27;
		/* 82073578h case   18:*/		return 0x8207357C;
		  /* 8207357Ch */ case   19:  		/* stwu R11, <#[R7 + 4]> */
		/* 8207357Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 8207357Ch case   19:*/		return 0x82073580;
		  /* 82073580h */ case   20:  		/* lwz R11, <#[R1 + 80]> */
		/* 82073580h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82073580h case   20:*/		return 0x82073584;
		  /* 82073584h */ case   21:  		/* lwz R30, <#[R1 + 84]> */
		/* 82073584h case   21:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 82073584h case   21:*/		return 0x82073588;
		  /* 82073588h */ case   22:  		/* addi R11, R11, 4095 */
		/* 82073588h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFF);
		/* 82073588h case   22:*/		return 0x8207358C;
		  /* 8207358Ch */ case   23:  		/* rlwinm R30, R30, 0, 0, 19 */
		/* 8207358Ch case   23:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R30,regs.R30);
		/* 8207358Ch case   23:*/		return 0x82073590;
		  /* 82073590h */ case   24:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 82073590h case   24:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 82073590h case   24:*/		return 0x82073594;
		  /* 82073594h */ case   25:  		/* subf R11, R30, R11 */
		/* 82073594h case   25:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 82073594h case   25:*/		return 0x82073598;
		  /* 82073598h */ case   26:  		/* stwu R11, <#[R7 + 4]> */
		/* 82073598h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073598h case   26:*/		return 0x8207359C;
		  /* 8207359Ch */ case   27:  		/* stwu R30, <#[R7 + 4]> */
		/* 8207359Ch case   27:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 8207359Ch case   27:*/		return 0x820735A0;
		  /* 820735A0h */ case   28:  		/* stwu R9, <#[R7 + 4]> */
		/* 820735A0h case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820735A0h case   28:*/		return 0x820735A4;
		  /* 820735A4h */ case   29:  		/* stwu R8, <#[R7 + 4]> */
		/* 820735A4h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820735A4h case   29:*/		return 0x820735A8;
		  /* 820735A8h */ case   30:  		/* stwu R5, <#[R7 + 4]> */
		/* 820735A8h case   30:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820735A8h case   30:*/		return 0x820735AC;
		  /* 820735ACh */ case   31:  		/* stwu R27, <#[R7 + 4]> */
		/* 820735ACh case   31:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820735ACh case   31:*/		return 0x820735B0;
		  /* 820735B0h */ case   32:  		/* stwu R3, <#[R7 + 4]> */
		/* 820735B0h case   32:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820735B0h case   32:*/		return 0x820735B4;
		  /* 820735B4h */ case   33:  		/* stwu R10, <#[R7 + 4]> */
		/* 820735B4h case   33:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820735B4h case   33:*/		return 0x820735B8;
	}
	return 0x820735B8;
} // Block from 82073530h-820735B8h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820735B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820735B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820735B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820735B8);
		  /* 820735B8h */ case    0:  		/* cmpwi CR6, R26, 0 */
		/* 820735B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 820735B8h case    0:*/		return 0x820735BC;
		  /* 820735BCh */ case    1:  		/* bc 12, CR6_EQ, 152 */
		/* 820735BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82073654;  }
		/* 820735BCh case    1:*/		return 0x820735C0;
		  /* 820735C0h */ case    2:  		/* li R11, 2609 */
		/* 820735C0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xA31);
		/* 820735C0h case    2:*/		return 0x820735C4;
		  /* 820735C4h */ case    3:  		/* lwz R9, <#[R31 + 15312]> */
		/* 820735C4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003BD0) );
		/* 820735C4h case    3:*/		return 0x820735C8;
		  /* 820735C8h */ case    4:  		/* lwz R5, <#[R31 + 15308]> */
		/* 820735C8h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00003BCC) );
		/* 820735C8h case    4:*/		return 0x820735CC;
		  /* 820735CCh */ case    5:  		/* lis R8, 256 */
		/* 820735CCh case    5:*/		cpu::op::lis<0>(regs,&regs.R8,0x100);
		/* 820735CCh case    5:*/		return 0x820735D0;
		  /* 820735D0h */ case    6:  		/* stwu R11, <#[R7 + 4]> */
		/* 820735D0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820735D0h case    6:*/		return 0x820735D4;
		  /* 820735D4h */ case    7:  		/* rlwinm R11, R9, 12, 20, 31 */
		/* 820735D4h case    7:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R9);
		/* 820735D4h case    7:*/		return 0x820735D8;
		  /* 820735D8h */ case    8:  		/* rlwinm R10, R5, 12, 20, 31 */
		/* 820735D8h case    8:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R5);
		/* 820735D8h case    8:*/		return 0x820735DC;
		  /* 820735DCh */ case    9:  		/* addi R11, R11, 512 */
		/* 820735DCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 820735DCh case    9:*/		return 0x820735E0;
		  /* 820735E0h */ case   10:  		/* addi R4, R10, 512 */
		/* 820735E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x200);
		/* 820735E0h case   10:*/		return 0x820735E4;
		  /* 820735E4h */ case   11:  		/* rlwinm R10, R11, 0, 19, 19 */
		/* 820735E4h case   11:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R11);
		/* 820735E4h case   11:*/		return 0x820735E8;
		  /* 820735E8h */ case   12:  		/* rlwinm R11, R9, 0, 3, 31 */
		/* 820735E8h case   12:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R11,regs.R9);
		/* 820735E8h case   12:*/		return 0x820735EC;
		  /* 820735ECh */ case   13:  		/* stwu R8, <#[R7 + 4]> */
		/* 820735ECh case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820735ECh case   13:*/		return 0x820735F0;
		  /* 820735F0h */ case   14:  		/* rlwinm R9, R5, 0, 3, 31 */
		/* 820735F0h case   14:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R9,regs.R5);
		/* 820735F0h case   14:*/		return 0x820735F4;
		  /* 820735F4h */ case   15:  		/* add R11, R10, R11 */
		/* 820735F4h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820735F4h case   15:*/		return 0x820735F8;
		  /* 820735F8h */ case   16:  		/* rlwinm R8, R4, 0, 19, 19 */
		/* 820735F8h case   16:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R8,regs.R4);
		/* 820735F8h case   16:*/		return 0x820735FC;
		  /* 820735FCh */ case   17:  		/* lis R3, 1 */
		/* 820735FCh case   17:*/		cpu::op::lis<0>(regs,&regs.R3,0x1);
		/* 820735FCh case   17:*/		return 0x82073600;
		  /* 82073600h */ case   18:  		/* add R10, R8, R9 */
		/* 82073600h case   18:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R9);
		/* 82073600h case   18:*/		return 0x82073604;
		  /* 82073604h */ case   19:  		/* addi R11, R11, 4095 */
		/* 82073604h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFF);
		/* 82073604h case   19:*/		return 0x82073608;
		  /* 82073608h */ case   20:  		/* ori R5, R3, 2607 */
		/* 82073608h case   20:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R3,0xA2F);
		/* 82073608h case   20:*/		return 0x8207360C;
		  /* 8207360Ch */ case   21:  		/* rlwinm R10, R10, 0, 0, 19 */
		/* 8207360Ch case   21:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R10,regs.R10);
		/* 8207360Ch case   21:*/		return 0x82073610;
		  /* 82073610h */ case   22:  		/* stwu R5, <#[R7 + 4]> */
		/* 82073610h case   22:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073610h case   22:*/		return 0x82073614;
		  /* 82073614h */ case   23:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 82073614h case   23:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 82073614h case   23:*/		return 0x82073618;
		  /* 82073618h */ case   24:  		/* lis R9, -16380 */
		/* 82073618h case   24:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC004);
		/* 82073618h case   24:*/		return 0x8207361C;
		  /* 8207361Ch */ case   25:  		/* subf R11, R10, R11 */
		/* 8207361Ch case   25:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8207361Ch case   25:*/		return 0x82073620;
		  /* 82073620h */ case   26:  		/* ori R9, R9, 15360 */
		/* 82073620h case   26:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x3C00);
		/* 82073620h case   26:*/		return 0x82073624;
		  /* 82073624h */ case   27:  		/* li R8, 2609 */
		/* 82073624h case   27:*/		cpu::op::li<0>(regs,&regs.R8,0xA31);
		/* 82073624h case   27:*/		return 0x82073628;
		  /* 82073628h */ case   28:  		/* stwu R11, <#[R7 + 4]> */
		/* 82073628h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073628h case   28:*/		return 0x8207362C;
		  /* 8207362Ch */ case   29:  		/* li R11, 3 */
		/* 8207362Ch case   29:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8207362Ch case   29:*/		return 0x82073630;
		  /* 82073630h */ case   30:  		/* lis R5, -32768 */
		/* 82073630h case   30:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8000);
		/* 82073630h case   30:*/		return 0x82073634;
		  /* 82073634h */ case   31:  		/* li R4, 8 */
		/* 82073634h case   31:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 82073634h case   31:*/		return 0x82073638;
		  /* 82073638h */ case   32:  		/* stwu R10, <#[R7 + 4]> */
		/* 82073638h case   32:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073638h case   32:*/		return 0x8207363C;
		  /* 8207363Ch */ case   33:  		/* stwu R9, <#[R7 + 4]> */
		/* 8207363Ch case   33:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 8207363Ch case   33:*/		return 0x82073640;
		  /* 82073640h */ case   34:  		/* stwu R11, <#[R7 + 4]> */
		/* 82073640h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073640h case   34:*/		return 0x82073644;
		  /* 82073644h */ case   35:  		/* stwu R8, <#[R7 + 4]> */
		/* 82073644h case   35:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073644h case   35:*/		return 0x82073648;
		  /* 82073648h */ case   36:  		/* stwu R27, <#[R7 + 4]> */
		/* 82073648h case   36:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073648h case   36:*/		return 0x8207364C;
		  /* 8207364Ch */ case   37:  		/* stwu R5, <#[R7 + 4]> */
		/* 8207364Ch case   37:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 8207364Ch case   37:*/		return 0x82073650;
		  /* 82073650h */ case   38:  		/* stwu R4, <#[R7 + 4]> */
		/* 82073650h case   38:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 82073650h case   38:*/		return 0x82073654;
	}
	return 0x82073654;
} // Block from 820735B8h-82073654h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82073654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073654);
		  /* 82073654h */ case    0:  		/* rlwinm R11, R6, 12, 20, 31 */
		/* 82073654h case    0:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R6);
		/* 82073654h case    0:*/		return 0x82073658;
		  /* 82073658h */ case    1:  		/* rlwinm R10, R6, 0, 3, 31 */
		/* 82073658h case    1:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R6);
		/* 82073658h case    1:*/		return 0x8207365C;
		  /* 8207365Ch */ case    2:  		/* addi R11, R11, 512 */
		/* 8207365Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8207365Ch case    2:*/		return 0x82073660;
		  /* 82073660h */ case    3:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82073660h case    3:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82073660h case    3:*/		return 0x82073664;
		  /* 82073664h */ case    4:  		/* add R11, R11, R10 */
		/* 82073664h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82073664h case    4:*/		return 0x82073668;
		  /* 82073668h */ case    5:  		/* stw R11, <#[R23]> */
		/* 82073668h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82073668h case    5:*/		return 0x8207366C;
		  /* 8207366Ch */ case    6:  		/* stw R25, <#[R24]> */
		/* 8207366Ch case    6:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R24 + 0x00000000) );
		/* 8207366Ch case    6:*/		return 0x82073670;
	}
	return 0x82073670;
} // Block from 82073654h-82073670h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82073670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073670);
		  /* 82073670h */ case    0:  		/* addi R1, R1, 176 */
		/* 82073670h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82073670h case    0:*/		return 0x82073674;
		  /* 82073674h */ case    1:  		/* b 121888 */
		/* 82073674h case    1:*/		return 0x82091294;
		/* 82073674h case    1:*/		return 0x82073678;
	}
	return 0x82073678;
} // Block from 82073670h-82073678h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82073678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073678);
		  /* 82073678h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 82073678h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82073678h case    0:*/		return 0x8207367C;
		  /* 8207367Ch */ case    1:  		/* lwz R10, <#[R3 + 15324]> */
		/* 8207367Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00003BDC) );
		/* 8207367Ch case    1:*/		return 0x82073680;
		  /* 82073680h */ case    2:  		/* mr R11, R3 */
		/* 82073680h case    2:*/		regs.R11 = regs.R3;
		/* 82073680h case    2:*/		return 0x82073684;
		  /* 82073684h */ case    3:  		/* lwz R9, <#[R3 + 48]> */
		/* 82073684h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000030) );
		/* 82073684h case    3:*/		return 0x82073688;
		  /* 82073688h */ case    4:  		/* lis R8, -16384 */
		/* 82073688h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFC000);
		/* 82073688h case    4:*/		return 0x8207368C;
		  /* 8207368Ch */ case    5:  		/* lwz R6, <#[R3 + 11036]> */
		/* 8207368Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00002B1C) );
		/* 8207368Ch case    5:*/		return 0x82073690;
		  /* 82073690h */ case    6:  		/* rlwinm R5, R10, 0, 30, 31 */
		/* 82073690h case    6:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R10);
		/* 82073690h case    6:*/		return 0x82073694;
		  /* 82073694h */ case    7:  		/* ori R3, R8, 15104 */
		/* 82073694h case    7:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R8,0x3B00);
		/* 82073694h case    7:*/		return 0x82073698;
		  /* 82073698h */ case    8:  		/* li R7, 32767 */
		/* 82073698h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x7FFF);
		/* 82073698h case    8:*/		return 0x8207369C;
		  /* 8207369Ch */ case    9:  		/* lwz R8, <#[R11 + 11024]> */
		/* 8207369Ch case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00002B10) );
		/* 8207369Ch case    9:*/		return 0x820736A0;
		  /* 820736A0h */ case   10:  		/* or R5, R5, R9 */
		/* 820736A0h case   10:*/		cpu::op::or<0>(regs,&regs.R5,regs.R5,regs.R9);
		/* 820736A0h case   10:*/		return 0x820736A4;
		  /* 820736A4h */ case   11:  		/* stw R9, <#[R11 + 13608]> */
		/* 820736A4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00003528) );
		/* 820736A4h case   11:*/		return 0x820736A8;
		  /* 820736A8h */ case   12:  		/* stw R10, <#[R11 + 13612]> */
		/* 820736A8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000352C) );
		/* 820736A8h case   12:*/		return 0x820736AC;
		  /* 820736ACh */ case   13:  		/* stwu R3, <#[R4 + 4]> */
		/* 820736ACh case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 820736ACh case   13:*/		return 0x820736B0;
		  /* 820736B0h */ case   14:  		/* mr R10, R4 */
		/* 820736B0h case   14:*/		regs.R10 = regs.R4;
		/* 820736B0h case   14:*/		return 0x820736B4;
		  /* 820736B4h */ case   15:  		/* stwu R7, <#[R10 + 4]> */
		/* 820736B4h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820736B4h case   15:*/		return 0x820736B8;
		  /* 820736B8h */ case   16:  		/* lbz R9, <#[R11 + 11072]> */
		/* 820736B8h case   16:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00002B40) );
		/* 820736B8h case   16:*/		return 0x820736BC;
		  /* 820736BCh */ case   17:  		/* rlwinm. R9, R9, 0, 0, 24 */
		/* 820736BCh case   17:*/		cpu::op::rlwinm<1,0,0,24>(regs,&regs.R9,regs.R9);
		/* 820736BCh case   17:*/		return 0x820736C0;
		  /* 820736C0h */ case   18:  		/* bc 12, CR0_EQ, 60 */
		/* 820736C0h case   18:*/		if ( regs.CR[0].eq ) { return 0x820736FC;  }
		/* 820736C0h case   18:*/		return 0x820736C4;
		  /* 820736C4h */ case   19:  		/* li R9, 1480 */
		/* 820736C4h case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x5C8);
		/* 820736C4h case   19:*/		return 0x820736C8;
		  /* 820736C8h */ case   20:  		/* lis R7, 2 */
		/* 820736C8h case   20:*/		cpu::op::lis<0>(regs,&regs.R7,0x2);
		/* 820736C8h case   20:*/		return 0x820736CC;
		  /* 820736CCh */ case   21:  		/* stwu R9, <#[R10 + 4]> */
		/* 820736CCh case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820736CCh case   21:*/		return 0x820736D0;
		  /* 820736D0h */ case   22:  		/* stwu R7, <#[R10 + 4]> */
		/* 820736D0h case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820736D0h case   22:*/		return 0x820736D4;
		  /* 820736D4h */ case   23:  		/* ld R9, <#[R11 + 32]> */
		/* 820736D4h case   23:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + 0x00000020) );
		/* 820736D4h case   23:*/		return 0x820736D8;
		  /* 820736D8h */ case   24:  		/* rldicl R9, R9, 0, 1 */
		/* 820736D8h case   24:*/		cpu::op::rldicl<0,0,1>(regs,&regs.R9,regs.R9);
		/* 820736D8h case   24:*/		return 0x820736DC;
		  /* 820736DCh */ case   25:  		/* std R9, <#[R11 + 32]> */
		/* 820736DCh case   25:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R11 + 0x00000020) );
		/* 820736DCh case   25:*/		return 0x820736E0;
		  /* 820736E0h */ case   26:  		/* lbz R7, <#[R11 + 11072]> */
		/* 820736E0h case   26:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0x00002B40) );
		/* 820736E0h case   26:*/		return 0x820736E4;
		  /* 820736E4h */ case   27:  		/* lbz R9, <#[R11 + 11071]> */
		/* 820736E4h case   27:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00002B3F) );
		/* 820736E4h case   27:*/		return 0x820736E8;
		  /* 820736E8h */ case   28:  		/* rlwinm R9, R9, 0, 0, 29 */
		/* 820736E8h case   28:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R9,regs.R9);
		/* 820736E8h case   28:*/		return 0x820736EC;
		  /* 820736ECh */ case   29:  		/* rlwinm R7, R7, 0, 25, 31 */
		/* 820736ECh case   29:*/		cpu::op::rlwinm<0,0,25,31>(regs,&regs.R7,regs.R7);
		/* 820736ECh case   29:*/		return 0x820736F0;
		  /* 820736F0h */ case   30:  		/* stb R9, <#[R11 + 11071]> */
		/* 820736F0h case   30:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00002B3F) );
		/* 820736F0h case   30:*/		return 0x820736F4;
		  /* 820736F4h */ case   31:  		/* stb R7, <#[R11 + 11072]> */
		/* 820736F4h case   31:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R11 + 0x00002B40) );
		/* 820736F4h case   31:*/		return 0x820736F8;
		  /* 820736F8h */ case   32:  		/* b 28 */
		/* 820736F8h case   32:*/		return 0x82073714;
		/* 820736F8h case   32:*/		return 0x820736FC;
	}
	return 0x820736FC;
} // Block from 82073678h-820736FCh (33 instructions)

//////////////////////////////////////////////////////
// Block at 820736FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820736FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820736FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820736FC);
		  /* 820736FCh */ case    0:  		/* lis R9, -16384 */
		/* 820736FCh case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC000);
		/* 820736FCh case    0:*/		return 0x82073700;
		  /* 82073700h */ case    1:  		/* lis R7, 30583 */
		/* 82073700h case    1:*/		cpu::op::lis<0>(regs,&regs.R7,0x7777);
		/* 82073700h case    1:*/		return 0x82073704;
		  /* 82073704h */ case    2:  		/* ori R9, R9, 4096 */
		/* 82073704h case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x1000);
		/* 82073704h case    2:*/		return 0x82073708;
		  /* 82073708h */ case    3:  		/* ori R7, R7, 30583 */
		/* 82073708h case    3:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x7777);
		/* 82073708h case    3:*/		return 0x8207370C;
		  /* 8207370Ch */ case    4:  		/* stwu R9, <#[R10 + 4]> */
		/* 8207370Ch case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8207370Ch case    4:*/		return 0x82073710;
		  /* 82073710h */ case    5:  		/* stwu R7, <#[R10 + 4]> */
		/* 82073710h case    5:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82073710h case    5:*/		return 0x82073714;
	}
	return 0x82073714;
} // Block from 820736FCh-82073714h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82073714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073714);
		  /* 82073714h */ case    0:  		/* lis R7, -16382 */
		/* 82073714h case    0:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFFC002);
		/* 82073714h case    0:*/		return 0x82073718;
		  /* 82073718h */ case    1:  		/* addi R9, R8, 4 */
		/* 82073718h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x4);
		/* 82073718h case    1:*/		return 0x8207371C;
		  /* 8207371Ch */ case    2:  		/* ori R4, R7, 22528 */
		/* 8207371Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R7,0x5800);
		/* 8207371Ch case    2:*/		return 0x82073720;
		  /* 82073720h */ case    3:  		/* rlwinm R7, R9, 12, 20, 31 */
		/* 82073720h case    3:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R7,regs.R9);
		/* 82073720h case    3:*/		return 0x82073724;
		  /* 82073724h */ case    4:  		/* stwu R4, <#[R10 + 4]> */
		/* 82073724h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82073724h case    4:*/		return 0x82073728;
		  /* 82073728h */ case    5:  		/* rlwinm R9, R9, 0, 3, 31 */
		/* 82073728h case    5:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R9,regs.R9);
		/* 82073728h case    5:*/		return 0x8207372C;
		  /* 8207372Ch */ case    6:  		/* addi R7, R7, 512 */
		/* 8207372Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x200);
		/* 8207372Ch case    6:*/		return 0x82073730;
		  /* 82073730h */ case    7:  		/* mr R3, R10 */
		/* 82073730h case    7:*/		regs.R3 = regs.R10;
		/* 82073730h case    7:*/		return 0x82073734;
		  /* 82073734h */ case    8:  		/* rlwinm R10, R7, 0, 19, 19 */
		/* 82073734h case    8:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R7);
		/* 82073734h case    8:*/		return 0x82073738;
		  /* 82073738h */ case    9:  		/* li R4, 3 */
		/* 82073738h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 82073738h case    9:*/		return 0x8207373C;
		  /* 8207373Ch */ case   10:  		/* add R10, R10, R9 */
		/* 8207373Ch case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8207373Ch case   10:*/		return 0x82073740;
		  /* 82073740h */ case   11:  		/* lis R7, -16382 */
		/* 82073740h case   11:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFFC002);
		/* 82073740h case   11:*/		return 0x82073744;
		  /* 82073744h */ case   12:  		/* stwu R4, <#[R3 + 4]> */
		/* 82073744h case   12:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82073744h case   12:*/		return 0x82073748;
		  /* 82073748h */ case   13:  		/* ori R9, R10, 2 */
		/* 82073748h case   13:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R10,0x2);
		/* 82073748h case   13:*/		return 0x8207374C;
		  /* 8207374Ch */ case   14:  		/* rlwinm R10, R8, 12, 20, 31 */
		/* 8207374Ch case   14:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R8);
		/* 8207374Ch case   14:*/		return 0x82073750;
		  /* 82073750h */ case   15:  		/* ori R7, R7, 22528 */
		/* 82073750h case   15:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x5800);
		/* 82073750h case   15:*/		return 0x82073754;
		  /* 82073754h */ case   16:  		/* addi R31, R10, 512 */
		/* 82073754h case   16:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0x200);
		/* 82073754h case   16:*/		return 0x82073758;
		  /* 82073758h */ case   17:  		/* rlwinm R10, R8, 0, 3, 31 */
		/* 82073758h case   17:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R8);
		/* 82073758h case   17:*/		return 0x8207375C;
		  /* 8207375Ch */ case   18:  		/* stwu R9, <#[R3 + 4]> */
		/* 8207375Ch case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207375Ch case   18:*/		return 0x82073760;
		  /* 82073760h */ case   19:  		/* rlwinm R9, R31, 0, 19, 19 */
		/* 82073760h case   19:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R9,regs.R31);
		/* 82073760h case   19:*/		return 0x82073764;
		  /* 82073764h */ case   20:  		/* add R10, R9, R10 */
		/* 82073764h case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82073764h case   20:*/		return 0x82073768;
		  /* 82073768h */ case   21:  		/* ori R10, R10, 2 */
		/* 82073768h case   21:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82073768h case   21:*/		return 0x8207376C;
		  /* 8207376Ch */ case   22:  		/* stwu R5, <#[R3 + 4]> */
		/* 8207376Ch case   22:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207376Ch case   22:*/		return 0x82073770;
		  /* 82073770h */ case   23:  		/* stwu R7, <#[R3 + 4]> */
		/* 82073770h case   23:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82073770h case   23:*/		return 0x82073774;
		  /* 82073774h */ case   24:  		/* stwu R4, <#[R3 + 4]> */
		/* 82073774h case   24:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82073774h case   24:*/		return 0x82073778;
		  /* 82073778h */ case   25:  		/* stwu R10, <#[R3 + 4]> */
		/* 82073778h case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82073778h case   25:*/		return 0x8207377C;
		  /* 8207377Ch */ case   26:  		/* stwu R6, <#[R3 + 4]> */
		/* 8207377Ch case   26:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207377Ch case   26:*/		return 0x82073780;
		  /* 82073780h */ case   27:  		/* lwz R10, <#[R11 + 21940]> */
		/* 82073780h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000055B4) );
		/* 82073780h case   27:*/		return 0x82073784;
		  /* 82073784h */ case   28:  		/* cmplwi CR6, R10, 0 */
		/* 82073784h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82073784h case   28:*/		return 0x82073788;
		  /* 82073788h */ case   29:  		/* bc 4, CR6_EQ, 32 */
		/* 82073788h case   29:*/		if ( !regs.CR[6].eq ) { return 0x820737A8;  }
		/* 82073788h case   29:*/		return 0x8207378C;
		  /* 8207378Ch */ case   30:  		/* lbz R10, <#[R11 + 11069]> */
		/* 8207378Ch case   30:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00002B3D) );
		/* 8207378Ch case   30:*/		return 0x82073790;
		  /* 82073790h */ case   31:  		/* rlwinm. R10, R10, 0, 30, 30 */
		/* 82073790h case   31:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R10);
		/* 82073790h case   31:*/		return 0x82073794;
		  /* 82073794h */ case   32:  		/* bc 12, CR0_EQ, 20 */
		/* 82073794h case   32:*/		if ( regs.CR[0].eq ) { return 0x820737A8;  }
		/* 82073794h case   32:*/		return 0x82073798;
		  /* 82073798h */ case   33:  		/* lwz R10, <#[R11 + 11024]> */
		/* 82073798h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00002B10) );
		/* 82073798h case   33:*/		return 0x8207379C;
		  /* 8207379Ch */ case   34:  		/* stw R6, <#[R10]> */
		/* 8207379Ch case   34:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 8207379Ch case   34:*/		return 0x820737A0;
		  /* 820737A0h */ case   35:  		/* lwz R10, <#[R11 + 11024]> */
		/* 820737A0h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00002B10) );
		/* 820737A0h case   35:*/		return 0x820737A4;
		  /* 820737A4h */ case   36:  		/* stw R5, <#[R10 + 4]> */
		/* 820737A4h case   36:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x00000004) );
		/* 820737A4h case   36:*/		return 0x820737A8;
	}
	return 0x820737A8;
} // Block from 82073714h-820737A8h (37 instructions)

//////////////////////////////////////////////////////
// Block at 820737A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820737A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820737A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820737A8);
		  /* 820737A8h */ case    0:  		/* addi R10, R6, 2 */
		/* 820737A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0x2);
		/* 820737A8h case    0:*/		return 0x820737AC;
		  /* 820737ACh */ case    1:  		/* stw R10, <#[R11 + 11036]> */
		/* 820737ACh case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00002B1C) );
		/* 820737ACh case    1:*/		return 0x820737B0;
		  /* 820737B0h */ case    2:  		/* ld R31, <#[R1 - 8]> */
		/* 820737B0h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820737B0h case    2:*/		return 0x820737B4;
		  /* 820737B4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820737B4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820737B4h case    3:*/		return 0x820737B8;
	}
	return 0x820737B8;
} // Block from 820737A8h-820737B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820737B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820737B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820737B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820737B8);
		  /* 820737B8h */ case    0:  		/* mfspr R12, LR */
		/* 820737B8h case    0:*/		regs.R12 = regs.LR;
		/* 820737B8h case    0:*/		return 0x820737BC;
		  /* 820737BCh */ case    1:  		/* bl 121492 */
		/* 820737BCh case    1:*/		regs.LR = 0x820737C0; return 0x82091250;
		/* 820737BCh case    1:*/		return 0x820737C0;
		  /* 820737C0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820737C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820737C0h case    2:*/		return 0x820737C4;
		  /* 820737C4h */ case    3:  		/* mr R31, R3 */
		/* 820737C4h case    3:*/		regs.R31 = regs.R3;
		/* 820737C4h case    3:*/		return 0x820737C8;
		  /* 820737C8h */ case    4:  		/* mr R30, R4 */
		/* 820737C8h case    4:*/		regs.R30 = regs.R4;
		/* 820737C8h case    4:*/		return 0x820737CC;
		  /* 820737CCh */ case    5:  		/* mr R26, R5 */
		/* 820737CCh case    5:*/		regs.R26 = regs.R5;
		/* 820737CCh case    5:*/		return 0x820737D0;
		  /* 820737D0h */ case    6:  		/* mr R27, R6 */
		/* 820737D0h case    6:*/		regs.R27 = regs.R6;
		/* 820737D0h case    6:*/		return 0x820737D4;
		  /* 820737D4h */ case    7:  		/* mr R28, R7 */
		/* 820737D4h case    7:*/		regs.R28 = regs.R7;
		/* 820737D4h case    7:*/		return 0x820737D8;
		  /* 820737D8h */ case    8:  		/* rlwinm R29, R5, 8, 26, 31 */
		/* 820737D8h case    8:*/		cpu::op::rlwinm<0,8,26,31>(regs,&regs.R29,regs.R5);
		/* 820737D8h case    8:*/		return 0x820737DC;
		  /* 820737DCh */ case    9:  		/* bl 2070300 */
		/* 820737DCh case    9:*/		regs.LR = 0x820737E0; return 0x8226CEF8;
		/* 820737DCh case    9:*/		return 0x820737E0;
		  /* 820737E0h */ case   10:  		/* cmpwi CR6, R3, 2 */
		/* 820737E0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 820737E0h case   10:*/		return 0x820737E4;
		  /* 820737E4h */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 820737E4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820737F4;  }
		/* 820737E4h case   11:*/		return 0x820737E8;
		  /* 820737E8h */ case   12:  		/* lis R11, -32256 */
		/* 820737E8h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820737E8h case   12:*/		return 0x820737EC;
		  /* 820737ECh */ case   13:  		/* lwz R11, <#[R11 + 1452]> */
		/* 820737ECh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005AC) );
		/* 820737ECh case   13:*/		return 0x820737F0;
		  /* 820737F0h */ case   14:  		/* b 12 */
		/* 820737F0h case   14:*/		return 0x820737FC;
		/* 820737F0h case   14:*/		return 0x820737F4;
	}
	return 0x820737F4;
} // Block from 820737B8h-820737F4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820737F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820737F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820737F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820737F4);
		  /* 820737F4h */ case    0:  		/* lis R11, -32256 */
		/* 820737F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820737F4h case    0:*/		return 0x820737F8;
		  /* 820737F8h */ case    1:  		/* lwz R11, <#[R11 + 1456]> */
		/* 820737F8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005B0) );
		/* 820737F8h case    1:*/		return 0x820737FC;
	}
	return 0x820737FC;
} // Block from 820737F4h-820737FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820737FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820737FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820737FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820737FC);
		  /* 820737FCh */ case    0:  		/* lwz R11, <#[R11]> */
		/* 820737FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820737FCh case    0:*/		return 0x82073800;
		  /* 82073800h */ case    1:  		/* rlwinm. R10, R26, 0, 29, 30 */
		/* 82073800h case    1:*/		cpu::op::rlwinm<1,0,29,30>(regs,&regs.R10,regs.R26);
		/* 82073800h case    1:*/		return 0x82073804;
		  /* 82073804h */ case    2:  		/* lwz R9, <#[R11 + 11028]> */
		/* 82073804h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00002B14) );
		/* 82073804h case    2:*/		return 0x82073808;
		  /* 82073808h */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 82073808h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82073810;  }
		/* 82073808h case    3:*/		return 0x8207380C;
		  /* 8207380Ch */ case    4:  		/* ori R26, R26, 6 */
		/* 8207380Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R26,regs.R26,0x6);
		/* 8207380Ch case    4:*/		return 0x82073810;
	}
	return 0x82073810;
} // Block from 820737FCh-82073810h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82073810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073810);
		  /* 82073810h */ case    0:  		/* lis R11, -16380 */
		/* 82073810h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC004);
		/* 82073810h case    0:*/		return 0x82073814;
		  /* 82073814h */ case    1:  		/* rlwinm. R10, R26, 0, 30, 30 */
		/* 82073814h case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R26);
		/* 82073814h case    1:*/		return 0x82073818;
		  /* 82073818h */ case    2:  		/* li R7, -1 */
		/* 82073818h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 82073818h case    2:*/		return 0x8207381C;
		  /* 8207381Ch */ case    3:  		/* ori R11, R11, 15360 */
		/* 8207381Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x3C00);
		/* 8207381Ch case    3:*/		return 0x82073820;
		  /* 82073820h */ case    4:  		/* bc 12, CR0_EQ, 428 */
		/* 82073820h case    4:*/		if ( regs.CR[0].eq ) { return 0x820739CC;  }
		/* 82073820h case    4:*/		return 0x82073824;
		  /* 82073824h */ case    5:  		/* rlwinm. R10, R26, 0, 31, 31 */
		/* 82073824h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R26);
		/* 82073824h case    5:*/		return 0x82073828;
		  /* 82073828h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82073828h case    6:*/		if ( regs.CR[0].eq ) { return 0x82073838;  }
		/* 82073828h case    6:*/		return 0x8207382C;
		  /* 8207382Ch */ case    7:  		/* lbz R10, <#[R31 + 11072]> */
		/* 8207382Ch case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B40) );
		/* 8207382Ch case    7:*/		return 0x82073830;
		  /* 82073830h */ case    8:  		/* rlwinm. R10, R10, 0, 0, 24 */
		/* 82073830h case    8:*/		cpu::op::rlwinm<1,0,0,24>(regs,&regs.R10,regs.R10);
		/* 82073830h case    8:*/		return 0x82073834;
		  /* 82073834h */ case    9:  		/* bc 12, CR0_EQ, 56 */
		/* 82073834h case    9:*/		if ( regs.CR[0].eq ) { return 0x8207386C;  }
		/* 82073834h case    9:*/		return 0x82073838;
	}
	return 0x82073838;
} // Block from 82073810h-82073838h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82073838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073838);
		  /* 82073838h */ case    0:  		/* li R10, 1480 */
		/* 82073838h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x5C8);
		/* 82073838h case    0:*/		return 0x8207383C;
		  /* 8207383Ch */ case    1:  		/* lis R8, 2 */
		/* 8207383Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0x2);
		/* 8207383Ch case    1:*/		return 0x82073840;
		  /* 82073840h */ case    2:  		/* stwu R10, <#[R30 + 4]> */
		/* 82073840h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82073840h case    2:*/		return 0x82073844;
		  /* 82073844h */ case    3:  		/* stwu R8, <#[R30 + 4]> */
		/* 82073844h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82073844h case    3:*/		return 0x82073848;
		  /* 82073848h */ case    4:  		/* ld R10, <#[R31 + 32]> */
		/* 82073848h case    4:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 82073848h case    4:*/		return 0x8207384C;
		  /* 8207384Ch */ case    5:  		/* rldicl R10, R10, 0, 1 */
		/* 8207384Ch case    5:*/		cpu::op::rldicl<0,0,1>(regs,&regs.R10,regs.R10);
		/* 8207384Ch case    5:*/		return 0x82073850;
		  /* 82073850h */ case    6:  		/* std R10, <#[R31 + 32]> */
		/* 82073850h case    6:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 82073850h case    6:*/		return 0x82073854;
		  /* 82073854h */ case    7:  		/* lbz R8, <#[R31 + 11072]> */
		/* 82073854h case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R31 + 0x00002B40) );
		/* 82073854h case    7:*/		return 0x82073858;
		  /* 82073858h */ case    8:  		/* lbz R10, <#[R31 + 11071]> */
		/* 82073858h case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B3F) );
		/* 82073858h case    8:*/		return 0x8207385C;
		  /* 8207385Ch */ case    9:  		/* rlwinm R10, R10, 0, 0, 29 */
		/* 8207385Ch case    9:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R10);
		/* 8207385Ch case    9:*/		return 0x82073860;
		  /* 82073860h */ case   10:  		/* rlwinm R8, R8, 0, 25, 31 */
		/* 82073860h case   10:*/		cpu::op::rlwinm<0,0,25,31>(regs,&regs.R8,regs.R8);
		/* 82073860h case   10:*/		return 0x82073864;
		  /* 82073864h */ case   11:  		/* stb R10, <#[R31 + 11071]> */
		/* 82073864h case   11:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00002B3F) );
		/* 82073864h case   11:*/		return 0x82073868;
		  /* 82073868h */ case   12:  		/* stb R8, <#[R31 + 11072]> */
		/* 82073868h case   12:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R31 + 0x00002B40) );
		/* 82073868h case   12:*/		return 0x8207386C;
	}
	return 0x8207386C;
} // Block from 82073838h-8207386Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8207386Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207386C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207386C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207386C);
		  /* 8207386Ch */ case    0:  		/* rlwinm. R6, R26, 0, 24, 24 */
		/* 8207386Ch case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R6,regs.R26);
		/* 8207386Ch case    0:*/		return 0x82073870;
		  /* 82073870h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82073870h case    1:*/		if ( regs.CR[0].eq ) { return 0x82073888;  }
		/* 82073870h case    1:*/		return 0x82073874;
		  /* 82073874h */ case    2:  		/* li R10, 1404 */
		/* 82073874h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x57C);
		/* 82073874h case    2:*/		return 0x82073878;
		  /* 82073878h */ case    3:  		/* stwu R10, <#[R30 + 4]> */
		/* 82073878h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82073878h case    3:*/		return 0x8207387C;
		  /* 8207387Ch */ case    4:  		/* stwu R27, <#[R30 + 4]> */
		/* 8207387Ch case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8207387Ch case    4:*/		return 0x82073880;
	}
	return 0x82073880;
} // Block from 8207386Ch-82073880h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82073880h
// Function '?MakeBufferResourceSpace@D3D@@YAPAVBufferResource@1@PAVCDevice@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073880);
		  /* 82073880h */ case    0:  		/* mr R10, R30 */
		/* 82073880h case    0:*/		regs.R10 = regs.R30;
		/* 82073880h case    0:*/		return 0x82073884;
		  /* 82073884h */ case    1:  		/* b 28 */
		/* 82073884h case    1:*/		return 0x820738A0;
		/* 82073884h case    1:*/		return 0x82073888;
	}
	return 0x82073888;
} // Block from 82073880h-82073888h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82073888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073888);
		  /* 82073888h */ case    0:  		/* lis R10, 1 */
		/* 82073888h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 82073888h case    0:*/		return 0x8207388C;
		  /* 8207388Ch */ case    1:  		/* ori R10, R10, 1404 */
		/* 8207388Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x57C);
		/* 8207388Ch case    1:*/		return 0x82073890;
		  /* 82073890h */ case    2:  		/* stwu R10, <#[R30 + 4]> */
		/* 82073890h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82073890h case    2:*/		return 0x82073894;
		  /* 82073894h */ case    3:  		/* stwu R27, <#[R30 + 4]> */
		/* 82073894h case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82073894h case    3:*/		return 0x82073898;
		  /* 82073898h */ case    4:  		/* mr R10, R30 */
		/* 82073898h case    4:*/		regs.R10 = regs.R30;
		/* 82073898h case    4:*/		return 0x8207389C;
		  /* 8207389Ch */ case    5:  		/* stwu R28, <#[R10 + 4]> */
		/* 8207389Ch case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8207389Ch case    5:*/		return 0x820738A0;
	}
	return 0x820738A0;
} // Block from 82073888h-820738A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820738A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820738A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820738A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820738A0);
		  /* 820738A0h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820738A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820738A0h case    0:*/		return 0x820738A4;
		  /* 820738A4h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 820738A4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820738AC;  }
		/* 820738A4h case    1:*/		return 0x820738A8;
		  /* 820738A8h */ case    2:  		/* li R29, 4 */
		/* 820738A8h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x4);
		/* 820738A8h case    2:*/		return 0x820738AC;
	}
	return 0x820738AC;
} // Block from 820738A0h-820738ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820738ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820738AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820738AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820738AC);
		  /* 820738ACh */ case    0:  		/* li R5, 1400 */
		/* 820738ACh case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x578);
		/* 820738ACh case    0:*/		return 0x820738B0;
		  /* 820738B0h */ case    1:  		/* rlwinm R8, R9, 12, 20, 31 */
		/* 820738B0h case    1:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R8,regs.R9);
		/* 820738B0h case    1:*/		return 0x820738B4;
		  /* 820738B4h */ case    2:  		/* stwu R5, <#[R10 + 4]> */
		/* 820738B4h case    2:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820738B4h case    2:*/		return 0x820738B8;
		  /* 820738B8h */ case    3:  		/* li R5, 19 */
		/* 820738B8h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x13);
		/* 820738B8h case    3:*/		return 0x820738BC;
		  /* 820738BCh */ case    4:  		/* addi R8, R8, 512 */
		/* 820738BCh case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x200);
		/* 820738BCh case    4:*/		return 0x820738C0;
		  /* 820738C0h */ case    5:  		/* mr R4, R10 */
		/* 820738C0h case    5:*/		regs.R4 = regs.R10;
		/* 820738C0h case    5:*/		return 0x820738C4;
		  /* 820738C4h */ case    6:  		/* rlwinm R8, R8, 0, 19, 19 */
		/* 820738C4h case    6:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R8,regs.R8);
		/* 820738C4h case    6:*/		return 0x820738C8;
		  /* 820738C8h */ case    7:  		/* rlwinm R10, R9, 0, 3, 31 */
		/* 820738C8h case    7:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R9);
		/* 820738C8h case    7:*/		return 0x820738CC;
		  /* 820738CCh */ case    8:  		/* mr R3, R7 */
		/* 820738CCh case    8:*/		regs.R3 = regs.R7;
		/* 820738CCh case    8:*/		return 0x820738D0;
		  /* 820738D0h */ case    9:  		/* add R10, R8, R10 */
		/* 820738D0h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 820738D0h case    9:*/		return 0x820738D4;
		  /* 820738D4h */ case   10:  		/* stwu R29, <#[R4 + 4]> */
		/* 820738D4h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 820738D4h case   10:*/		return 0x820738D8;
		  /* 820738D8h */ case   11:  		/* li R8, 256 */
		/* 820738D8h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x100);
		/* 820738D8h case   11:*/		return 0x820738DC;
		  /* 820738DCh */ case   12:  		/* lwz R30, <#[R31 + 13092]> */
		/* 820738DCh case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00003324) );
		/* 820738DCh case   12:*/		return 0x820738E0;
		  /* 820738E0h */ case   13:  		/* ori R10, R10, 2 */
		/* 820738E0h case   13:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 820738E0h case   13:*/		return 0x820738E4;
		  /* 820738E4h */ case   14:  		/* cmplwi CR6, R6, 0 */
		/* 820738E4h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820738E4h case   14:*/		return 0x820738E8;
		  /* 820738E8h */ case   15:  		/* or R30, R30, R11 */
		/* 820738E8h case   15:*/		cpu::op::or<0>(regs,&regs.R30,regs.R30,regs.R11);
		/* 820738E8h case   15:*/		return 0x820738EC;
		  /* 820738ECh */ case   16:  		/* stwu R30, <#[R4 + 4]> */
		/* 820738ECh case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 820738ECh case   16:*/		return 0x820738F0;
		  /* 820738F0h */ case   17:  		/* stwu R5, <#[R4 + 4]> */
		/* 820738F0h case   17:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 820738F0h case   17:*/		return 0x820738F4;
		  /* 820738F4h */ case   18:  		/* stwu R10, <#[R4 + 4]> */
		/* 820738F4h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 820738F4h case   18:*/		return 0x820738F8;
		  /* 820738F8h */ case   19:  		/* stwu R29, <#[R4 + 4]> */
		/* 820738F8h case   19:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 820738F8h case   19:*/		return 0x820738FC;
		  /* 820738FCh */ case   20:  		/* stwu R7, <#[R4 + 4]> */
		/* 820738FCh case   20:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 820738FCh case   20:*/		return 0x82073900;
		  /* 82073900h */ case   21:  		/* mr R10, R4 */
		/* 82073900h case   21:*/		regs.R10 = regs.R4;
		/* 82073900h case   21:*/		return 0x82073904;
		  /* 82073904h */ case   22:  		/* stwu R8, <#[R10 + 4]> */
		/* 82073904h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82073904h case   22:*/		return 0x82073908;
		  /* 82073908h */ case   23:  		/* bc 4, CR6_EQ, 84 */
		/* 82073908h case   23:*/		if ( !regs.CR[6].eq ) { return 0x8207395C;  }
		/* 82073908h case   23:*/		return 0x8207390C;
		  /* 8207390Ch */ case   24:  		/* lwz R8, <#[R31 + 13092]> */
		/* 8207390Ch case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00003324) );
		/* 8207390Ch case   24:*/		return 0x82073910;
		  /* 82073910h */ case   25:  		/* mr R6, R10 */
		/* 82073910h case   25:*/		regs.R6 = regs.R10;
		/* 82073910h case   25:*/		return 0x82073914;
		  /* 82073914h */ case   26:  		/* addi R10, R9, 20 */
		/* 82073914h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x14);
		/* 82073914h case   26:*/		return 0x82073918;
		  /* 82073918h */ case   27:  		/* or R5, R8, R11 */
		/* 82073918h case   27:*/		cpu::op::or<0>(regs,&regs.R5,regs.R8,regs.R11);
		/* 82073918h case   27:*/		return 0x8207391C;
		  /* 8207391Ch */ case   28:  		/* rlwinm R8, R10, 12, 20, 31 */
		/* 8207391Ch case   28:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R8,regs.R10);
		/* 8207391Ch case   28:*/		return 0x82073920;
		  /* 82073920h */ case   29:  		/* rlwinm R10, R10, 0, 3, 31 */
		/* 82073920h case   29:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R10);
		/* 82073920h case   29:*/		return 0x82073924;
		  /* 82073924h */ case   30:  		/* stwu R5, <#[R6 + 4]> */
		/* 82073924h case   30:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82073924h case   30:*/		return 0x82073928;
		  /* 82073928h */ case   31:  		/* addi R8, R8, 512 */
		/* 82073928h case   31:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x200);
		/* 82073928h case   31:*/		return 0x8207392C;
		  /* 8207392Ch */ case   32:  		/* li R4, 19 */
		/* 8207392Ch case   32:*/		cpu::op::li<0>(regs,&regs.R4,0x13);
		/* 8207392Ch case   32:*/		return 0x82073930;
		  /* 82073930h */ case   33:  		/* rlwinm R8, R8, 0, 19, 19 */
		/* 82073930h case   33:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R8,regs.R8);
		/* 82073930h case   33:*/		return 0x82073934;
		  /* 82073934h */ case   34:  		/* mr R5, R7 */
		/* 82073934h case   34:*/		regs.R5 = regs.R7;
		/* 82073934h case   34:*/		return 0x82073938;
		  /* 82073938h */ case   35:  		/* add R10, R8, R10 */
		/* 82073938h case   35:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82073938h case   35:*/		return 0x8207393C;
		  /* 8207393Ch */ case   36:  		/* stwu R4, <#[R6 + 4]> */
		/* 8207393Ch case   36:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 8207393Ch case   36:*/		return 0x82073940;
	}
	return 0x82073940;
} // Block from 820738ACh-82073940h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82073940h
// Function '?MakeSegmentCallSpace@D3D@@YAPAUSegmentCall@1@PAVCDevice@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073940);
		  /* 82073940h */ case    0:  		/* li R8, 256 */
		/* 82073940h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x100);
		/* 82073940h case    0:*/		return 0x82073944;
		  /* 82073944h */ case    1:  		/* ori R10, R10, 2 */
		/* 82073944h case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82073944h case    1:*/		return 0x82073948;
		  /* 82073948h */ case    2:  		/* stwu R10, <#[R6 + 4]> */
		/* 82073948h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82073948h case    2:*/		return 0x8207394C;
		  /* 8207394Ch */ case    3:  		/* stwu R28, <#[R6 + 4]> */
		/* 8207394Ch case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 8207394Ch case    3:*/		return 0x82073950;
		  /* 82073950h */ case    4:  		/* stwu R7, <#[R6 + 4]> */
		/* 82073950h case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000004) );
		regs.R6 = (uint32)(regs.R6 + 0x00000004);
		/* 82073950h case    4:*/		return 0x82073954;
		  /* 82073954h */ case    5:  		/* mr R10, R6 */
		/* 82073954h case    5:*/		regs.R10 = regs.R6;
		/* 82073954h case    5:*/		return 0x82073958;
		  /* 82073958h */ case    6:  		/* stwu R8, <#[R10 + 4]> */
		/* 82073958h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82073958h case    6:*/		return 0x8207395C;
	}
	return 0x8207395C;
} // Block from 82073940h-8207395Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8207395Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207395C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207395C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207395C);
		  /* 8207395Ch */ case    0:  		/* lwz R6, <#[R31 + 13092]> */
		/* 8207395Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00003324) );
		/* 8207395Ch case    0:*/		return 0x82073960;
		  /* 82073960h */ case    1:  		/* addi R8, R9, 16 */
		/* 82073960h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x10);
		/* 82073960h case    1:*/		return 0x82073964;
		  /* 82073964h */ case    2:  		/* li R5, 19 */
		/* 82073964h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x13);
		/* 82073964h case    2:*/		return 0x82073968;
		  /* 82073968h */ case    3:  		/* or R4, R6, R11 */
		/* 82073968h case    3:*/		cpu::op::or<0>(regs,&regs.R4,regs.R6,regs.R11);
		/* 82073968h case    3:*/		return 0x8207396C;
		  /* 8207396Ch */ case    4:  		/* rlwinm R6, R8, 12, 20, 31 */
		/* 8207396Ch case    4:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R6,regs.R8);
		/* 8207396Ch case    4:*/		return 0x82073970;
		  /* 82073970h */ case    5:  		/* stwu R4, <#[R10 + 4]> */
		/* 82073970h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82073970h case    5:*/		return 0x82073974;
		  /* 82073974h */ case    6:  		/* mr R4, R7 */
		/* 82073974h case    6:*/		regs.R4 = regs.R7;
		/* 82073974h case    6:*/		return 0x82073978;
		  /* 82073978h */ case    7:  		/* addi R6, R6, 512 */
		/* 82073978h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x200);
		/* 82073978h case    7:*/		return 0x8207397C;
		  /* 8207397Ch */ case    8:  		/* mr R3, R10 */
		/* 8207397Ch case    8:*/		regs.R3 = regs.R10;
		/* 8207397Ch case    8:*/		return 0x82073980;
		  /* 82073980h */ case    9:  		/* rlwinm R10, R8, 0, 3, 31 */
		/* 82073980h case    9:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R8);
		/* 82073980h case    9:*/		return 0x82073984;
		  /* 82073984h */ case   10:  		/* rlwinm R8, R6, 0, 19, 19 */
		/* 82073984h case   10:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R8,regs.R6);
		/* 82073984h case   10:*/		return 0x82073988;
		  /* 82073988h */ case   11:  		/* li R6, 256 */
		/* 82073988h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x100);
		/* 82073988h case   11:*/		return 0x8207398C;
		  /* 8207398Ch */ case   12:  		/* add R10, R8, R10 */
		/* 8207398Ch case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8207398Ch case   12:*/		return 0x82073990;
		  /* 82073990h */ case   13:  		/* stwu R5, <#[R3 + 4]> */
		/* 82073990h case   13:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82073990h case   13:*/		return 0x82073994;
		  /* 82073994h */ case   14:  		/* li R8, 1118 */
		/* 82073994h case   14:*/		cpu::op::li<0>(regs,&regs.R8,0x45E);
		/* 82073994h case   14:*/		return 0x82073998;
		  /* 82073998h */ case   15:  		/* ori R10, R10, 2 */
		/* 82073998h case   15:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82073998h case   15:*/		return 0x8207399C;
		  /* 8207399Ch */ case   16:  		/* stwu R10, <#[R3 + 4]> */
		/* 8207399Ch case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207399Ch case   16:*/		return 0x820739A0;
		  /* 820739A0h */ case   17:  		/* stwu R27, <#[R3 + 4]> */
		/* 820739A0h case   17:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820739A0h case   17:*/		return 0x820739A4;
		  /* 820739A4h */ case   18:  		/* stwu R7, <#[R3 + 4]> */
		/* 820739A4h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820739A4h case   18:*/		return 0x820739A8;
		  /* 820739A8h */ case   19:  		/* stwu R6, <#[R3 + 4]> */
		/* 820739A8h case   19:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820739A8h case   19:*/		return 0x820739AC;
		  /* 820739ACh */ case   20:  		/* lwz R10, <#[R31 + 13092]> */
		/* 820739ACh case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003324) );
		/* 820739ACh case   20:*/		return 0x820739B0;
		  /* 820739B0h */ case   21:  		/* oris R10, R10, 49152 */
		/* 820739B0h case   21:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0xC000);
		/* 820739B0h case   21:*/		return 0x820739B4;
		  /* 820739B4h */ case   22:  		/* ori R10, R10, 21504 */
		/* 820739B4h case   22:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x5400);
		/* 820739B4h case   22:*/		return 0x820739B8;
		  /* 820739B8h */ case   23:  		/* stwu R10, <#[R3 + 4]> */
		/* 820739B8h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820739B8h case   23:*/		return 0x820739BC;
		  /* 820739BCh */ case   24:  		/* stwu R29, <#[R3 + 4]> */
		/* 820739BCh case   24:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820739BCh case   24:*/		return 0x820739C0;
		  /* 820739C0h */ case   25:  		/* stwu R8, <#[R3 + 4]> */
		/* 820739C0h case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820739C0h case   25:*/		return 0x820739C4;
		  /* 820739C4h */ case   26:  		/* mr R30, R3 */
		/* 820739C4h case   26:*/		regs.R30 = regs.R3;
		/* 820739C4h case   26:*/		return 0x820739C8;
		  /* 820739C8h */ case   27:  		/* stwu R29, <#[R30 + 4]> */
		/* 820739C8h case   27:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 820739C8h case   27:*/		return 0x820739CC;
	}
	return 0x820739CC;
} // Block from 8207395Ch-820739CCh (28 instructions)

//////////////////////////////////////////////////////
// Block at 820739CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820739CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820739CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820739CC);
		  /* 820739CCh */ case    0:  		/* rlwinm. R10, R26, 0, 29, 29 */
		/* 820739CCh case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R26);
		/* 820739CCh case    0:*/		return 0x820739D0;
		  /* 820739D0h */ case    1:  		/* bc 12, CR0_EQ, 92 */
		/* 820739D0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82073A2C;  }
		/* 820739D0h case    1:*/		return 0x820739D4;
		  /* 820739D4h */ case    2:  		/* lwz R10, <#[R31 + 13092]> */
		/* 820739D4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003324) );
		/* 820739D4h case    2:*/		return 0x820739D8;
		  /* 820739D8h */ case    3:  		/* li R8, 19 */
		/* 820739D8h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x13);
		/* 820739D8h case    3:*/		return 0x820739DC;
		  /* 820739DCh */ case    4:  		/* or R10, R10, R11 */
		/* 820739DCh case    4:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820739DCh case    4:*/		return 0x820739E0;
		  /* 820739E0h */ case    5:  		/* rlwinm R11, R9, 12, 20, 31 */
		/* 820739E0h case    5:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R9);
		/* 820739E0h case    5:*/		return 0x820739E4;
		  /* 820739E4h */ case    6:  		/* stwu R10, <#[R30 + 4]> */
		/* 820739E4h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 820739E4h case    6:*/		return 0x820739E8;
		  /* 820739E8h */ case    7:  		/* addi R6, R11, 512 */
		/* 820739E8h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x200);
		/* 820739E8h case    7:*/		return 0x820739EC;
		  /* 820739ECh */ case    8:  		/* rlwinm R11, R9, 0, 3, 31 */
		/* 820739ECh case    8:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R11,regs.R9);
		/* 820739ECh case    8:*/		return 0x820739F0;
		  /* 820739F0h */ case    9:  		/* rlwinm R10, R6, 0, 19, 19 */
		/* 820739F0h case    9:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R6);
		/* 820739F0h case    9:*/		return 0x820739F4;
		  /* 820739F4h */ case   10:  		/* li R9, 256 */
		/* 820739F4h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x100);
		/* 820739F4h case   10:*/		return 0x820739F8;
		  /* 820739F8h */ case   11:  		/* stwu R8, <#[R30 + 4]> */
		/* 820739F8h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 820739F8h case   11:*/		return 0x820739FC;
		  /* 820739FCh */ case   12:  		/* add R11, R10, R11 */
		/* 820739FCh case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820739FCh case   12:*/		return 0x82073A00;
	}
	return 0x82073A00;
} // Block from 820739CCh-82073A00h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82073A00h
// Function '?Destroy@CCommandBuffer@D3D@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073A00);
		  /* 82073A00h */ case    0:  		/* li R10, 0 */
		/* 82073A00h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82073A00h case    0:*/		return 0x82073A04;
		  /* 82073A04h */ case    1:  		/* ori R11, R11, 2 */
		/* 82073A04h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82073A04h case    1:*/		return 0x82073A08;
		  /* 82073A08h */ case    2:  		/* li R8, 1404 */
		/* 82073A08h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x57C);
		/* 82073A08h case    2:*/		return 0x82073A0C;
		  /* 82073A0Ch */ case    3:  		/* lis R6, 2989 */
		/* 82073A0Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R6,0xBAD);
		/* 82073A0Ch case    3:*/		return 0x82073A10;
		  /* 82073A10h */ case    4:  		/* stwu R11, <#[R30 + 4]> */
		/* 82073A10h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82073A10h case    4:*/		return 0x82073A14;
		  /* 82073A14h */ case    5:  		/* ori R6, R6, 61453 */
		/* 82073A14h case    5:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0xF00D);
		/* 82073A14h case    5:*/		return 0x82073A18;
		  /* 82073A18h */ case    6:  		/* stwu R10, <#[R30 + 4]> */
		/* 82073A18h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82073A18h case    6:*/		return 0x82073A1C;
		  /* 82073A1Ch */ case    7:  		/* stwu R7, <#[R30 + 4]> */
		/* 82073A1Ch case    7:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82073A1Ch case    7:*/		return 0x82073A20;
		  /* 82073A20h */ case    8:  		/* stwu R9, <#[R30 + 4]> */
		/* 82073A20h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82073A20h case    8:*/		return 0x82073A24;
		  /* 82073A24h */ case    9:  		/* stwu R8, <#[R30 + 4]> */
		/* 82073A24h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82073A24h case    9:*/		return 0x82073A28;
		  /* 82073A28h */ case   10:  		/* stwu R6, <#[R30 + 4]> */
		/* 82073A28h case   10:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82073A28h case   10:*/		return 0x82073A2C;
	}
	return 0x82073A2C;
} // Block from 82073A00h-82073A2Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82073A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073A2C);
		  /* 82073A2Ch */ case    0:  		/* mr R3, R30 */
		/* 82073A2Ch case    0:*/		regs.R3 = regs.R30;
		/* 82073A2Ch case    0:*/		return 0x82073A30;
		  /* 82073A30h */ case    1:  		/* addi R1, R1, 144 */
		/* 82073A30h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82073A30h case    1:*/		return 0x82073A34;
		  /* 82073A34h */ case    2:  		/* b 120940 */
		/* 82073A34h case    2:*/		return 0x820912A0;
		/* 82073A34h case    2:*/		return 0x82073A38;
	}
	return 0x82073A38;
} // Block from 82073A2Ch-82073A38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82073A38h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073A38);
		  /* 82073A38h */ case    0:  		/* mfspr R12, LR */
		/* 82073A38h case    0:*/		regs.R12 = regs.LR;
		/* 82073A38h case    0:*/		return 0x82073A3C;
		  /* 82073A3Ch */ case    1:  		/* bl 120864 */
		/* 82073A3Ch case    1:*/		regs.LR = 0x82073A40; return 0x8209125C;
		/* 82073A3Ch case    1:*/		return 0x82073A40;
		  /* 82073A40h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82073A40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82073A40h case    2:*/		return 0x82073A44;
		  /* 82073A44h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 82073A44h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82073A44h case    3:*/		return 0x82073A48;
		  /* 82073A48h */ case    4:  		/* mr R30, R3 */
		/* 82073A48h case    4:*/		regs.R30 = regs.R3;
		/* 82073A48h case    4:*/		return 0x82073A4C;
		  /* 82073A4Ch */ case    5:  		/* lis R29, 16384 */
		/* 82073A4Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R29,0x4000);
		/* 82073A4Ch case    5:*/		return 0x82073A50;
		  /* 82073A50h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82073A50h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82073A50h case    6:*/		return 0x82073A54;
		  /* 82073A54h */ case    7:  		/* bc 12, CR6_EQ, 36 */
		/* 82073A54h case    7:*/		if ( regs.CR[6].eq ) { return 0x82073A78;  }
		/* 82073A54h case    7:*/		return 0x82073A58;
		  /* 82073A58h */ case    8:  		/* lwz R9, <#[R3 + 12]> */
		/* 82073A58h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 82073A58h case    8:*/		return 0x82073A5C;
		  /* 82073A5Ch */ case    9:  		/* rlwinm R10, R9, 12, 20, 31 */
		/* 82073A5Ch case    9:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R9);
		/* 82073A5Ch case    9:*/		return 0x82073A60;
		  /* 82073A60h */ case   10:  		/* rlwinm R9, R9, 0, 3, 31 */
		/* 82073A60h case   10:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R9,regs.R9);
		/* 82073A60h case   10:*/		return 0x82073A64;
		  /* 82073A64h */ case   11:  		/* addi R10, R10, 512 */
		/* 82073A64h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 82073A64h case   11:*/		return 0x82073A68;
		  /* 82073A68h */ case   12:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 82073A68h case   12:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 82073A68h case   12:*/		return 0x82073A6C;
		  /* 82073A6Ch */ case   13:  		/* add R10, R10, R9 */
		/* 82073A6Ch case   13:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82073A6Ch case   13:*/		return 0x82073A70;
		  /* 82073A70h */ case   14:  		/* subf R10, R29, R10 */
		/* 82073A70h case   14:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R29,regs.R10);
		/* 82073A70h case   14:*/		return 0x82073A74;
		  /* 82073A74h */ case   15:  		/* stw R10, <#[R11]> */
		/* 82073A74h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82073A74h case   15:*/		return 0x82073A78;
	}
	return 0x82073A78;
} // Block from 82073A38h-82073A78h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82073A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073A78);
		  /* 82073A78h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82073A78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82073A78h case    0:*/		return 0x82073A7C;
		  /* 82073A7Ch */ case    1:  		/* li R5, 128 */
		/* 82073A7Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x80);
		/* 82073A7Ch case    1:*/		return 0x82073A80;
		  /* 82073A80h */ case    2:  		/* lwz R3, <#[R30 + 20]> */
		/* 82073A80h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000014) );
		/* 82073A80h case    2:*/		return 0x82073A84;
		  /* 82073A84h */ case    3:  		/* rlwinm R4, R11, 30, 2, 31 */
		/* 82073A84h case    3:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R4,regs.R11);
		/* 82073A84h case    3:*/		return 0x82073A88;
		  /* 82073A88h */ case    4:  		/* bl -2888 */
		/* 82073A88h case    4:*/		regs.LR = 0x82073A8C; return 0x82072F40;
		/* 82073A88h case    4:*/		return 0x82073A8C;
		  /* 82073A8Ch */ case    5:  		/* or. R31, R3, R3 */
		/* 82073A8Ch case    5:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82073A8Ch case    5:*/		return 0x82073A90;
		  /* 82073A90h */ case    6:  		/* bc 4, CR0_EQ, 24 */
		/* 82073A90h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82073AA8;  }
		/* 82073A90h case    6:*/		return 0x82073A94;
		  /* 82073A94h */ case    7:  		/* lwz R11, <#[R30 + 20]> */
		/* 82073A94h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82073A94h case    7:*/		return 0x82073A98;
		  /* 82073A98h */ case    8:  		/* li R10, 0 */
		/* 82073A98h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82073A98h case    8:*/		return 0x82073A9C;
		  /* 82073A9Ch */ case    9:  		/* lwz R31, <#[R11 + 17136]> */
		/* 82073A9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x000042F0) );
		/* 82073A9Ch case    9:*/		return 0x82073AA0;
		  /* 82073AA0h */ case   10:  		/* stw R10, <#[R30]> */
		/* 82073AA0h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82073AA0h case   10:*/		return 0x82073AA4;
		  /* 82073AA4h */ case   11:  		/* b 124 */
		/* 82073AA4h case   11:*/		return 0x82073B20;
		/* 82073AA4h case   11:*/		return 0x82073AA8;
	}
	return 0x82073AA8;
} // Block from 82073A78h-82073AA8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82073AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073AA8);
		  /* 82073AA8h */ case    0:  		/* addi R11, R31, 4 */
		/* 82073AA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x4);
		/* 82073AA8h case    0:*/		return 0x82073AAC;
		  /* 82073AACh */ case    1:  		/* rlwinm R9, R11, 12, 20, 31 */
		/* 82073AACh case    1:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R9,regs.R11);
		/* 82073AACh case    1:*/		return 0x82073AB0;
		  /* 82073AB0h */ case    2:  		/* rlwinm R10, R11, 0, 3, 31 */
		/* 82073AB0h case    2:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R11);
		/* 82073AB0h case    2:*/		return 0x82073AB4;
		  /* 82073AB4h */ case    3:  		/* addi R11, R9, 512 */
		/* 82073AB4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x200);
		/* 82073AB4h case    3:*/		return 0x82073AB8;
		  /* 82073AB8h */ case    4:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82073AB8h case    4:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82073AB8h case    4:*/		return 0x82073ABC;
		  /* 82073ABCh */ case    5:  		/* add R11, R11, R10 */
		/* 82073ABCh case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82073ABCh case    5:*/		return 0x82073AC0;
		  /* 82073AC0h */ case    6:  		/* subf R11, R29, R11 */
		/* 82073AC0h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82073AC0h case    6:*/		return 0x82073AC4;
		  /* 82073AC4h */ case    7:  		/* stw R11, <#[R31]> */
		/* 82073AC4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82073AC4h case    7:*/		return 0x82073AC8;
		  /* 82073AC8h */ case    8:  		/* lwz R11, <#[R30 + 12]> */
		/* 82073AC8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82073AC8h case    8:*/		return 0x82073ACC;
		  /* 82073ACCh */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82073ACCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82073ACCh case    9:*/		return 0x82073AD0;
		  /* 82073AD0h */ case   10:  		/* bc 12, CR6_EQ, 36 */
		/* 82073AD0h case   10:*/		if ( regs.CR[6].eq ) { return 0x82073AF4;  }
		/* 82073AD0h case   10:*/		return 0x82073AD4;
		  /* 82073AD4h */ case   11:  		/* rlwinm R10, R31, 12, 20, 31 */
		/* 82073AD4h case   11:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R31);
		/* 82073AD4h case   11:*/		return 0x82073AD8;
		  /* 82073AD8h */ case   12:  		/* rlwinm R9, R31, 0, 3, 31 */
		/* 82073AD8h case   12:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R9,regs.R31);
		/* 82073AD8h case   12:*/		return 0x82073ADC;
		  /* 82073ADCh */ case   13:  		/* addi R10, R10, 512 */
		/* 82073ADCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 82073ADCh case   13:*/		return 0x82073AE0;
		  /* 82073AE0h */ case   14:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 82073AE0h case   14:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 82073AE0h case   14:*/		return 0x82073AE4;
		  /* 82073AE4h */ case   15:  		/* add R10, R10, R9 */
		/* 82073AE4h case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82073AE4h case   15:*/		return 0x82073AE8;
		  /* 82073AE8h */ case   16:  		/* subf R10, R29, R10 */
		/* 82073AE8h case   16:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R29,regs.R10);
		/* 82073AE8h case   16:*/		return 0x82073AEC;
		  /* 82073AECh */ case   17:  		/* stw R10, <#[R11]> */
		/* 82073AECh case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82073AECh case   17:*/		return 0x82073AF0;
		  /* 82073AF0h */ case   18:  		/* b 8 */
		/* 82073AF0h case   18:*/		return 0x82073AF8;
		/* 82073AF0h case   18:*/		return 0x82073AF4;
	}
	return 0x82073AF4;
} // Block from 82073AA8h-82073AF4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82073AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073AF4);
		  /* 82073AF4h */ case    0:  		/* stw R31, <#[R30]> */
		/* 82073AF4h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82073AF4h case    0:*/		return 0x82073AF8;
	}
	return 0x82073AF8;
} // Block from 82073AF4h-82073AF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82073AF8h
// Function '?BeginRingBig@CDevice@D3D@@QAAPAKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073AF8);
		  /* 82073AF8h */ case    0:  		/* rlwinm R10, R31, 12, 20, 31 */
		/* 82073AF8h case    0:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R31);
		/* 82073AF8h case    0:*/		return 0x82073AFC;
		  /* 82073AFCh */ case    1:  		/* lwz R11, <#[R30 + 8]> */
		/* 82073AFCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82073AFCh case    1:*/		return 0x82073B00;
		  /* 82073B00h */ case    2:  		/* rlwinm R9, R31, 0, 3, 31 */
		/* 82073B00h case    2:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R9,regs.R31);
		/* 82073B00h case    2:*/		return 0x82073B04;
		  /* 82073B04h */ case    3:  		/* addi R10, R10, 512 */
		/* 82073B04h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 82073B04h case    3:*/		return 0x82073B08;
		  /* 82073B08h */ case    4:  		/* li R5, 0 */
		/* 82073B08h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82073B08h case    4:*/		return 0x82073B0C;
		  /* 82073B0Ch */ case    5:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 82073B0Ch case    5:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 82073B0Ch case    5:*/		return 0x82073B10;
		  /* 82073B10h */ case    6:  		/* add R10, R10, R9 */
		/* 82073B10h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82073B10h case    6:*/		return 0x82073B14;
		  /* 82073B14h */ case    7:  		/* subf R3, R29, R10 */
		/* 82073B14h case    7:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R29,regs.R10);
		/* 82073B14h case    7:*/		return 0x82073B18;
		  /* 82073B18h */ case    8:  		/* add R4, R11, R3 */
		/* 82073B18h case    8:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R3);
		/* 82073B18h case    8:*/		return 0x82073B1C;
		  /* 82073B1Ch */ case    9:  		/* bl 71340 */
		/* 82073B1Ch case    9:*/		regs.LR = 0x82073B20; return 0x820851C8;
		/* 82073B1Ch case    9:*/		return 0x82073B20;
	}
	return 0x82073B20;
} // Block from 82073AF8h-82073B20h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82073B20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073B20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073B20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073B20);
		  /* 82073B20h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82073B20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82073B20h case    0:*/		return 0x82073B24;
		  /* 82073B24h */ case    1:  		/* addi R3, R31, 4 */
		/* 82073B24h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x4);
		/* 82073B24h case    1:*/		return 0x82073B28;
		  /* 82073B28h */ case    2:  		/* stw R31, <#[R30 + 4]> */
		/* 82073B28h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 82073B28h case    2:*/		return 0x82073B2C;
		  /* 82073B2Ch */ case    3:  		/* addi R11, R11, -4 */
		/* 82073B2Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82073B2Ch case    3:*/		return 0x82073B30;
		  /* 82073B30h */ case    4:  		/* stw R3, <#[R30 + 12]> */
		/* 82073B30h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 82073B30h case    4:*/		return 0x82073B34;
		  /* 82073B34h */ case    5:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 82073B34h case    5:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 82073B34h case    5:*/		return 0x82073B38;
		  /* 82073B38h */ case    6:  		/* add R11, R11, R31 */
		/* 82073B38h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82073B38h case    6:*/		return 0x82073B3C;
		  /* 82073B3Ch */ case    7:  		/* stw R11, <#[R30 + 16]> */
		/* 82073B3Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82073B3Ch case    7:*/		return 0x82073B40;
		  /* 82073B40h */ case    8:  		/* addi R1, R1, 112 */
		/* 82073B40h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82073B40h case    8:*/		return 0x82073B44;
		  /* 82073B44h */ case    9:  		/* b 120680 */
		/* 82073B44h case    9:*/		return 0x820912AC;
		/* 82073B44h case    9:*/		return 0x82073B48;
	}
	return 0x82073B48;
} // Block from 82073B20h-82073B48h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82073B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073B48);
		  /* 82073B48h */ case    0:  		/* mfspr R12, LR */
		/* 82073B48h case    0:*/		regs.R12 = regs.LR;
		/* 82073B48h case    0:*/		return 0x82073B4C;
		  /* 82073B4Ch */ case    1:  		/* bl 120580 */
		/* 82073B4Ch case    1:*/		regs.LR = 0x82073B50; return 0x82091250;
		/* 82073B4Ch case    1:*/		return 0x82073B50;
		  /* 82073B50h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82073B50h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82073B50h case    2:*/		return 0x82073B54;
		  /* 82073B54h */ case    3:  		/* addi R11, R6, -1 */
		/* 82073B54h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0xFFFFFFFF);
		/* 82073B54h case    3:*/		return 0x82073B58;
		  /* 82073B58h */ case    4:  		/* mr R30, R3 */
		/* 82073B58h case    4:*/		regs.R30 = regs.R3;
		/* 82073B58h case    4:*/		return 0x82073B5C;
		  /* 82073B5Ch */ case    5:  		/* mr R27, R4 */
		/* 82073B5Ch case    5:*/		regs.R27 = regs.R4;
		/* 82073B5Ch case    5:*/		return 0x82073B60;
		  /* 82073B60h */ case    6:  		/* mullw R31, R5, R6 */
		/* 82073B60h case    6:*/		cpu::op::mullw<0>(regs,&regs.R31,regs.R5,regs.R6);
		/* 82073B60h case    6:*/		return 0x82073B64;
		  /* 82073B64h */ case    7:  		/* nor R26, R11, R11 */
		/* 82073B64h case    7:*/		cpu::op::nor<0>(regs,&regs.R26,regs.R11,regs.R11);
		/* 82073B64h case    7:*/		return 0x82073B68;
		  /* 82073B68h */ case    8:  		/* lwz R3, <#[R30 + 12]> */
		/* 82073B68h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 82073B68h case    8:*/		return 0x82073B6C;
		  /* 82073B6Ch */ case    9:  		/* lwz R11, <#[R30 + 16]> */
		/* 82073B6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82073B6Ch case    9:*/		return 0x82073B70;
	}
	return 0x82073B70;
} // Block from 82073B48h-82073B70h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82073B70h
// Function '?Finalize@CRingAllocList@D3D@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073B70);
		  /* 82073B70h */ case    0:  		/* subf R11, R3, R11 */
		/* 82073B70h case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82073B70h case    0:*/		return 0x82073B74;
		  /* 82073B74h */ case    1:  		/* srawi R11, R11, 2 */
		/* 82073B74h case    1:*/		cpu::op::srawi<0,2>(regs,&regs.R11,regs.R11);
		/* 82073B74h case    1:*/		return 0x82073B78;
		  /* 82073B78h */ case    2:  		/* and R28, R11, R26 */
		/* 82073B78h case    2:*/		cpu::op::and<0>(regs,&regs.R28,regs.R11,regs.R26);
		/* 82073B78h case    2:*/		return 0x82073B7C;
		  /* 82073B7Ch */ case    3:  		/* cmplw CR6, R28, R31 */
		/* 82073B7Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R31);
		/* 82073B7Ch case    3:*/		return 0x82073B80;
		  /* 82073B80h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 82073B80h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82073B88;  }
		/* 82073B80h case    4:*/		return 0x82073B84;
		  /* 82073B84h */ case    5:  		/* mr R28, R31 */
		/* 82073B84h case    5:*/		regs.R28 = regs.R31;
		/* 82073B84h case    5:*/		return 0x82073B88;
	}
	return 0x82073B88;
} // Block from 82073B70h-82073B88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82073B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073B88);
		  /* 82073B88h */ case    0:  		/* rlwinm R29, R28, 2, 0, 29 */
		/* 82073B88h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R28);
		/* 82073B88h case    0:*/		return 0x82073B8C;
		  /* 82073B8Ch */ case    1:  		/* mr R4, R27 */
		/* 82073B8Ch case    1:*/		regs.R4 = regs.R27;
		/* 82073B8Ch case    1:*/		return 0x82073B90;
		  /* 82073B90h */ case    2:  		/* mr R5, R29 */
		/* 82073B90h case    2:*/		regs.R5 = regs.R29;
		/* 82073B90h case    2:*/		return 0x82073B94;
		  /* 82073B94h */ case    3:  		/* bl 122396 */
		/* 82073B94h case    3:*/		regs.LR = 0x82073B98; return 0x820919B0;
		/* 82073B94h case    3:*/		return 0x82073B98;
		  /* 82073B98h */ case    4:  		/* lwz R11, <#[R30 + 12]> */
		/* 82073B98h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82073B98h case    4:*/		return 0x82073B9C;
		  /* 82073B9Ch */ case    5:  		/* subf. R31, R28, R31 */
		/* 82073B9Ch case    5:*/		cpu::op::subf<1>(regs,&regs.R31,regs.R28,regs.R31);
		/* 82073B9Ch case    5:*/		return 0x82073BA0;
		  /* 82073BA0h */ case    6:  		/* add R11, R11, R29 */
		/* 82073BA0h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 82073BA0h case    6:*/		return 0x82073BA4;
		  /* 82073BA4h */ case    7:  		/* add R27, R29, R27 */
		/* 82073BA4h case    7:*/		cpu::op::add<0>(regs,&regs.R27,regs.R29,regs.R27);
		/* 82073BA4h case    7:*/		return 0x82073BA8;
		  /* 82073BA8h */ case    8:  		/* stw R11, <#[R30 + 12]> */
		/* 82073BA8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82073BA8h case    8:*/		return 0x82073BAC;
		  /* 82073BACh */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 82073BACh case    9:*/		if ( regs.CR[0].eq ) { return 0x82073BBC;  }
		/* 82073BACh case    9:*/		return 0x82073BB0;
		  /* 82073BB0h */ case   10:  		/* mr R3, R30 */
		/* 82073BB0h case   10:*/		regs.R3 = regs.R30;
		/* 82073BB0h case   10:*/		return 0x82073BB4;
		  /* 82073BB4h */ case   11:  		/* bl -380 */
		/* 82073BB4h case   11:*/		regs.LR = 0x82073BB8; return 0x82073A38;
		/* 82073BB4h case   11:*/		return 0x82073BB8;
	}
	return 0x82073BB8;
} // Block from 82073B88h-82073BB8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82073BB8h
// Function '?MakeSpace@CRingAllocList@D3D@@AAAPAKXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073BB8);
		  /* 82073BB8h */ case    0:  		/* b -80 */
		/* 82073BB8h case    0:*/		return 0x82073B68;
		/* 82073BB8h case    0:*/		return 0x82073BBC;
	}
	return 0x82073BBC;
} // Block from 82073BB8h-82073BBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82073BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073BBC);
		  /* 82073BBCh */ case    0:  		/* addi R1, R1, 144 */
		/* 82073BBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82073BBCh case    0:*/		return 0x82073BC0;
		  /* 82073BC0h */ case    1:  		/* b 120544 */
		/* 82073BC0h case    1:*/		return 0x820912A0;
		/* 82073BC0h case    1:*/		return 0x82073BC4;
		  /* 82073BC4h */ case    2:  		/* nop */
		/* 82073BC4h case    2:*/		cpu::op::nop();
		/* 82073BC4h case    2:*/		return 0x82073BC8;
	}
	return 0x82073BC8;
} // Block from 82073BBCh-82073BC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82073BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073BC8);
		  /* 82073BC8h */ case    0:  		/* mfspr R12, LR */
		/* 82073BC8h case    0:*/		regs.R12 = regs.LR;
		/* 82073BC8h case    0:*/		return 0x82073BCC;
		  /* 82073BCCh */ case    1:  		/* bl 120436 */
		/* 82073BCCh case    1:*/		regs.LR = 0x82073BD0; return 0x82091240;
		/* 82073BCCh case    1:*/		return 0x82073BD0;
		  /* 82073BD0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82073BD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82073BD0h case    2:*/		return 0x82073BD4;
		  /* 82073BD4h */ case    3:  		/* lwz R11, <#[R3 + 13600]> */
		/* 82073BD4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003520) );
		/* 82073BD4h case    3:*/		return 0x82073BD8;
		  /* 82073BD8h */ case    4:  		/* mr R31, R3 */
		/* 82073BD8h case    4:*/		regs.R31 = regs.R3;
		/* 82073BD8h case    4:*/		return 0x82073BDC;
		  /* 82073BDCh */ case    5:  		/* mr R29, R4 */
		/* 82073BDCh case    5:*/		regs.R29 = regs.R4;
		/* 82073BDCh case    5:*/		return 0x82073BE0;
		  /* 82073BE0h */ case    6:  		/* mr R27, R5 */
		/* 82073BE0h case    6:*/		regs.R27 = regs.R5;
		/* 82073BE0h case    6:*/		return 0x82073BE4;
		  /* 82073BE4h */ case    7:  		/* mr R30, R6 */
		/* 82073BE4h case    7:*/		regs.R30 = regs.R6;
		/* 82073BE4h case    7:*/		return 0x82073BE8;
		  /* 82073BE8h */ case    8:  		/* mr R26, R7 */
		/* 82073BE8h case    8:*/		regs.R26 = regs.R7;
		/* 82073BE8h case    8:*/		return 0x82073BEC;
		  /* 82073BECh */ case    9:  		/* mr R25, R8 */
		/* 82073BECh case    9:*/		regs.R25 = regs.R8;
		/* 82073BECh case    9:*/		return 0x82073BF0;
		  /* 82073BF0h */ case   10:  		/* mr R23, R9 */
		/* 82073BF0h case   10:*/		regs.R23 = regs.R9;
		/* 82073BF0h case   10:*/		return 0x82073BF4;
		  /* 82073BF4h */ case   11:  		/* li R28, 0 */
		/* 82073BF4h case   11:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82073BF4h case   11:*/		return 0x82073BF8;
		  /* 82073BF8h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 82073BF8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82073BF8h case   12:*/		return 0x82073BFC;
		  /* 82073BFCh */ case   13:  		/* bc 12, CR6_EQ, 56 */
		/* 82073BFCh case   13:*/		if ( regs.CR[6].eq ) { return 0x82073C34;  }
		/* 82073BFCh case   13:*/		return 0x82073C00;
		  /* 82073C00h */ case   14:  		/* subfic R11, R9, 0 */
		/* 82073C00h case   14:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R9,0x0);
		/* 82073C00h case   14:*/		return 0x82073C04;
		  /* 82073C04h */ case   15:  		/* stw R5, <#[R1 + 84]> */
		/* 82073C04h case   15:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 82073C04h case   15:*/		return 0x82073C08;
		  /* 82073C08h */ case   16:  		/* li R6, 2 */
		/* 82073C08h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 82073C08h case   16:*/		return 0x82073C0C;
		  /* 82073C0Ch */ case   17:  		/* subfe R11, R11, R11 */
		/* 82073C0Ch case   17:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82073C0Ch case   17:*/		return 0x82073C10;
		  /* 82073C10h */ case   18:  		/* li R5, 1 */
		/* 82073C10h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82073C10h case   18:*/		return 0x82073C14;
		  /* 82073C14h */ case   19:  		/* rlwinm R11, R11, 0, 28, 30 */
		/* 82073C14h case   19:*/		cpu::op::rlwinm<0,0,28,30>(regs,&regs.R11,regs.R11);
		/* 82073C14h case   19:*/		return 0x82073C18;
		  /* 82073C18h */ case   20:  		/* addi R4, R1, 80 */
		/* 82073C18h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82073C18h case   20:*/		return 0x82073C1C;
		  /* 82073C1Ch */ case   21:  		/* addi R11, R11, -127 */
		/* 82073C1Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFF81);
		/* 82073C1Ch case   21:*/		return 0x82073C20;
		  /* 82073C20h */ case   22:  		/* addi R3, R3, 13760 */
		/* 82073C20h case   22:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x35C0);
		/* 82073C20h case   22:*/		return 0x82073C24;
		  /* 82073C24h */ case   23:  		/* rlwimi R30, R11, 24, 0, 7 */
		/* 82073C24h case   23:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R30,regs.R11);
		/* 82073C24h case   23:*/		return 0x82073C28;
		  /* 82073C28h */ case   24:  		/* stw R30, <#[R1 + 80]> */
		/* 82073C28h case   24:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 82073C28h case   24:*/		return 0x82073C2C;
		  /* 82073C2Ch */ case   25:  		/* bl -228 */
		/* 82073C2Ch case   25:*/		regs.LR = 0x82073C30; return 0x82073B48;
		/* 82073C2Ch case   25:*/		return 0x82073C30;
		  /* 82073C30h */ case   26:  		/* b 360 */
		/* 82073C30h case   26:*/		return 0x82073D98;
		/* 82073C30h case   26:*/		return 0x82073C34;
	}
	return 0x82073C34;
} // Block from 82073BC8h-82073C34h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82073C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073C34);
		  /* 82073C34h */ case    0:  		/* lwz R11, <#[R31 + 11152]> */
		/* 82073C34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073C34h case    0:*/		return 0x82073C38;
		  /* 82073C38h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82073C38h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82073C38h case    1:*/		return 0x82073C3C;
		  /* 82073C3Ch */ case    2:  		/* bc 12, CR6_EQ, 172 */
		/* 82073C3Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82073CE8;  }
		/* 82073C3Ch case    2:*/		return 0x82073C40;
		  /* 82073C40h */ case    3:  		/* addi R24, R31, 11156 */
		/* 82073C40h case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R31,0x2B94);
		/* 82073C40h case    3:*/		return 0x82073C44;
		  /* 82073C44h */ case    4:  		/* mr R3, R24 */
		/* 82073C44h case    4:*/		regs.R3 = regs.R24;
		/* 82073C44h case    4:*/		return 0x82073C48;
		  /* 82073C48h */ case    5:  		/* bl 2069216 */
		/* 82073C48h case    5:*/		regs.LR = 0x82073C4C; return 0x8226CF28;
		/* 82073C48h case    5:*/		return 0x82073C4C;
		  /* 82073C4Ch */ case    6:  		/* lwz R11, <#[R31 + 11152]> */
		/* 82073C4Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073C4Ch case    6:*/		return 0x82073C50;
		  /* 82073C50h */ case    7:  		/* mr R22, R3 */
		/* 82073C50h case    7:*/		regs.R22 = regs.R3;
		/* 82073C50h case    7:*/		return 0x82073C54;
		  /* 82073C54h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 82073C54h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82073C54h case    8:*/		return 0x82073C58;
		  /* 82073C58h */ case    9:  		/* bc 12, CR6_EQ, 80 */
		/* 82073C58h case    9:*/		if ( regs.CR[6].eq ) { return 0x82073CA8;  }
		/* 82073C58h case    9:*/		return 0x82073C5C;
		  /* 82073C5Ch */ case   10:  		/* lwz R11, <#[R31 + 11152]> */
		/* 82073C5Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073C5Ch case   10:*/		return 0x82073C60;
		  /* 82073C60h */ case   11:  		/* cmpwi CR6, R23, 0 */
		/* 82073C60h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82073C60h case   11:*/		return 0x82073C64;
		  /* 82073C64h */ case   12:  		/* lis R11, -28928 */
		/* 82073C64h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8F00);
		/* 82073C64h case   12:*/		return 0x82073C68;
		  /* 82073C68h */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 82073C68h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82073C70;  }
		/* 82073C68h case   13:*/		return 0x82073C6C;
		  /* 82073C6Ch */ case   14:  		/* lis R11, -32512 */
		/* 82073C6Ch case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8100);
		/* 82073C6Ch case   14:*/		return 0x82073C70;
	}
	return 0x82073C70;
} // Block from 82073C34h-82073C70h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82073C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073C70);
		  /* 82073C70h */ case    0:  		/* or R11, R11, R30 */
		/* 82073C70h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82073C70h case    0:*/		return 0x82073C74;
		  /* 82073C74h */ case    1:  		/* lis R10, -16384 */
		/* 82073C74h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC000);
		/* 82073C74h case    1:*/		return 0x82073C78;
		  /* 82073C78h */ case    2:  		/* stw R11, <#[R29 + 4]> */
		/* 82073C78h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82073C78h case    2:*/		return 0x82073C7C;
		  /* 82073C7Ch */ case    3:  		/* mr R4, R29 */
		/* 82073C7Ch case    3:*/		regs.R4 = regs.R29;
		/* 82073C7Ch case    3:*/		return 0x82073C80;
		  /* 82073C80h */ case    4:  		/* stw R27, <#[R29 + 8]> */
		/* 82073C80h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R29 + 0x00000008) );
		/* 82073C80h case    4:*/		return 0x82073C84;
		  /* 82073C84h */ case    5:  		/* mr R3, R25 */
		/* 82073C84h case    5:*/		regs.R3 = regs.R25;
		/* 82073C84h case    5:*/		return 0x82073C88;
		  /* 82073C88h */ case    6:  		/* stw R10, <#[R29 + 12]> */
		/* 82073C88h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 82073C88h case    6:*/		return 0x82073C8C;
		  /* 82073C8Ch */ case    7:  		/* addi R29, R29, 16 */
		/* 82073C8Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x10);
		/* 82073C8Ch case    7:*/		return 0x82073C90;
		  /* 82073C90h */ case    8:  		/* mr R5, R29 */
		/* 82073C90h case    8:*/		regs.R5 = regs.R29;
		/* 82073C90h case    8:*/		return 0x82073C94;
		  /* 82073C94h */ case    9:  		/* bl -3572 */
		/* 82073C94h case    9:*/		regs.LR = 0x82073C98; return 0x82072EA0;
		/* 82073C94h case    9:*/		return 0x82073C98;
		  /* 82073C98h */ case   10:  		/* lwz R11, <#[R31 + 11152]> */
		/* 82073C98h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073C98h case   10:*/		return 0x82073C9C;
		  /* 82073C9Ch */ case   11:  		/* li R28, 1 */
		/* 82073C9Ch case   11:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 82073C9Ch case   11:*/		return 0x82073CA0;
		  /* 82073CA0h */ case   12:  		/* add R11, R11, R26 */
		/* 82073CA0h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R26);
		/* 82073CA0h case   12:*/		return 0x82073CA4;
		  /* 82073CA4h */ case   13:  		/* stw R11, <#[R31 + 11152]> */
		/* 82073CA4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073CA4h case   13:*/		return 0x82073CA8;
	}
	return 0x82073CA8;
} // Block from 82073C70h-82073CA8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82073CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073CA8);
		  /* 82073CA8h */ case    0:  		/* mr R4, R22 */
		/* 82073CA8h case    0:*/		regs.R4 = regs.R22;
		/* 82073CA8h case    0:*/		return 0x82073CAC;
		  /* 82073CACh */ case    1:  		/* mr R3, R24 */
		/* 82073CACh case    1:*/		regs.R3 = regs.R24;
		/* 82073CACh case    1:*/		return 0x82073CB0;
		  /* 82073CB0h */ case    2:  		/* bl 2069080 */
		/* 82073CB0h case    2:*/		regs.LR = 0x82073CB4; return 0x8226CF08;
		/* 82073CB0h case    2:*/		return 0x82073CB4;
		  /* 82073CB4h */ case    3:  		/* cmpwi CR6, R28, 0 */
		/* 82073CB4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82073CB4h case    3:*/		return 0x82073CB8;
		  /* 82073CB8h */ case    4:  		/* bc 12, CR6_EQ, 48 */
		/* 82073CB8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82073CE8;  }
		/* 82073CB8h case    4:*/		return 0x82073CBC;
		  /* 82073CBCh */ case    5:  		/* lbz R11, <#[R31 + 11072]> */
		/* 82073CBCh case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B40) );
		/* 82073CBCh case    5:*/		return 0x82073CC0;
		  /* 82073CC0h */ case    6:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 82073CC0h case    6:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 82073CC0h case    6:*/		return 0x82073CC4;
		  /* 82073CC4h */ case    7:  		/* bc 12, CR0_EQ, 212 */
		/* 82073CC4h case    7:*/		if ( regs.CR[0].eq ) { return 0x82073D98;  }
		/* 82073CC4h case    7:*/		return 0x82073CC8;
		  /* 82073CC8h */ case    8:  		/* li R5, 0 */
		/* 82073CC8h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82073CC8h case    8:*/		return 0x82073CCC;
		  /* 82073CCCh */ case    9:  		/* li R4, 1 */
		/* 82073CCCh case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82073CCCh case    9:*/		return 0x82073CD0;
		  /* 82073CD0h */ case   10:  		/* addi R3, R31, 24460 */
		/* 82073CD0h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x5F8C);
		/* 82073CD0h case   10:*/		return 0x82073CD4;
		  /* 82073CD4h */ case   11:  		/* bl 2069060 */
		/* 82073CD4h case   11:*/		regs.LR = 0x82073CD8; return 0x8226CF18;
		/* 82073CD4h case   11:*/		return 0x82073CD8;
		  /* 82073CD8h */ case   12:  		/* lbz R11, <#[R31 + 11072]> */
		/* 82073CD8h case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B40) );
		/* 82073CD8h case   12:*/		return 0x82073CDC;
		  /* 82073CDCh */ case   13:  		/* andi. R11, R11, 247 */
		/* 82073CDCh case   13:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0xF7);
		/* 82073CDCh case   13:*/		return 0x82073CE0;
	}
	return 0x82073CE0;
} // Block from 82073CA8h-82073CE0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82073CE0h
// Function '?AddChunkNode@CRingAllocList@D3D@@QAAXPAURingAllocChunk@2@PAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073CE0);
		  /* 82073CE0h */ case    0:  		/* stb R11, <#[R31 + 11072]> */
		/* 82073CE0h case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002B40) );
		/* 82073CE0h case    0:*/		return 0x82073CE4;
		  /* 82073CE4h */ case    1:  		/* b 180 */
		/* 82073CE4h case    1:*/		return 0x82073D98;
		/* 82073CE4h case    1:*/		return 0x82073CE8;
	}
	return 0x82073CE8;
} // Block from 82073CE0h-82073CE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82073CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073CE8);
		  /* 82073CE8h */ case    0:  		/* lwz R11, <#[R31 + 24392]> */
		/* 82073CE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005F48) );
		/* 82073CE8h case    0:*/		return 0x82073CEC;
		  /* 82073CECh */ case    1:  		/* lwz R10, <#[R31 + 21940]> */
		/* 82073CECh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000055B4) );
		/* 82073CECh case    1:*/		return 0x82073CF0;
		  /* 82073CF0h */ case    2:  		/* nor R11, R11, R11 */
		/* 82073CF0h case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82073CF0h case    2:*/		return 0x82073CF4;
		  /* 82073CF4h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82073CF4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82073CF4h case    3:*/		return 0x82073CF8;
		  /* 82073CF8h */ case    4:  		/* rlwinm R10, R11, 24, 31, 31 */
		/* 82073CF8h case    4:*/		cpu::op::rlwinm<0,24,31,31>(regs,&regs.R10,regs.R11);
		/* 82073CF8h case    4:*/		return 0x82073CFC;
		  /* 82073CFCh */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 82073CFCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x82073D10;  }
		/* 82073CFCh case    5:*/		return 0x82073D00;
		  /* 82073D00h */ case    6:  		/* lwz R11, <#[R31 + 23768]> */
		/* 82073D00h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005CD8) );
		/* 82073D00h case    6:*/		return 0x82073D04;
		  /* 82073D04h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82073D04h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82073D04h case    7:*/		return 0x82073D08;
		  /* 82073D08h */ case    8:  		/* li R11, 0 */
		/* 82073D08h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82073D08h case    8:*/		return 0x82073D0C;
		  /* 82073D0Ch */ case    9:  		/* bc 12, CR6_EQ, 8 */
		/* 82073D0Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82073D14;  }
		/* 82073D0Ch case    9:*/		return 0x82073D10;
	}
	return 0x82073D10;
} // Block from 82073CE8h-82073D10h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82073D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073D10);
		  /* 82073D10h */ case    0:  		/* li R11, 1 */
		/* 82073D10h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82073D10h case    0:*/		return 0x82073D14;
	}
	return 0x82073D14;
} // Block from 82073D10h-82073D14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82073D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073D14);
		  /* 82073D14h */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 82073D14h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82073D14h case    0:*/		return 0x82073D18;
		  /* 82073D18h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 82073D18h case    1:*/		if ( regs.CR[6].eq ) { return 0x82073D5C;  }
		/* 82073D18h case    1:*/		return 0x82073D1C;
		  /* 82073D1Ch */ case    2:  		/* cmpwi CR6, R23, 0 */
		/* 82073D1Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82073D1Ch case    2:*/		return 0x82073D20;
		  /* 82073D20h */ case    3:  		/* bc 12, CR6_EQ, 60 */
		/* 82073D20h case    3:*/		if ( regs.CR[6].eq ) { return 0x82073D5C;  }
		/* 82073D20h case    3:*/		return 0x82073D24;
		  /* 82073D24h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 82073D24h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82073D24h case    4:*/		return 0x82073D28;
		  /* 82073D28h */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 82073D28h case    5:*/		if ( regs.CR[6].eq ) { return 0x82073D5C;  }
		/* 82073D28h case    5:*/		return 0x82073D2C;
		  /* 82073D2Ch */ case    6:  		/* lwz R11, <#[R31 + 11152]> */
		/* 82073D2Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073D2Ch case    6:*/		return 0x82073D30;
		  /* 82073D30h */ case    7:  		/* lis R7, -28928 */
		/* 82073D30h case    7:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8F00);
		/* 82073D30h case    7:*/		return 0x82073D34;
		  /* 82073D34h */ case    8:  		/* lwz R11, <#[R31 + 11152]> */
		/* 82073D34h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073D34h case    8:*/		return 0x82073D38;
		  /* 82073D38h */ case    9:  		/* mr R6, R25 */
		/* 82073D38h case    9:*/		regs.R6 = regs.R25;
		/* 82073D38h case    9:*/		return 0x82073D3C;
		  /* 82073D3Ch */ case   10:  		/* mr R5, R30 */
		/* 82073D3Ch case   10:*/		regs.R5 = regs.R30;
		/* 82073D3Ch case   10:*/		return 0x82073D40;
		  /* 82073D40h */ case   11:  		/* add R11, R11, R26 */
		/* 82073D40h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R26);
		/* 82073D40h case   11:*/		return 0x82073D44;
		  /* 82073D44h */ case   12:  		/* mr R4, R27 */
		/* 82073D44h case   12:*/		regs.R4 = regs.R27;
		/* 82073D44h case   12:*/		return 0x82073D48;
		  /* 82073D48h */ case   13:  		/* addi R11, R11, 1 */
		/* 82073D48h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82073D48h case   13:*/		return 0x82073D4C;
		  /* 82073D4Ch */ case   14:  		/* mr R3, R31 */
		/* 82073D4Ch case   14:*/		regs.R3 = regs.R31;
		/* 82073D4Ch case   14:*/		return 0x82073D50;
		  /* 82073D50h */ case   15:  		/* stw R11, <#[R31 + 11152]> */
		/* 82073D50h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073D50h case   15:*/		return 0x82073D54;
		  /* 82073D54h */ case   16:  		/* bl 75716 */
		/* 82073D54h case   16:*/		regs.LR = 0x82073D58; return 0x82086518;
		/* 82073D54h case   16:*/		return 0x82073D58;
		  /* 82073D58h */ case   17:  		/* b 64 */
		/* 82073D58h case   17:*/		return 0x82073D98;
		/* 82073D58h case   17:*/		return 0x82073D5C;
	}
	return 0x82073D5C;
} // Block from 82073D14h-82073D5Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 82073D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073D5C);
		  /* 82073D5Ch */ case    0:  		/* subfic R10, R23, 0 */
		/* 82073D5Ch case    0:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R23,0x0);
		/* 82073D5Ch case    0:*/		return 0x82073D60;
		  /* 82073D60h */ case    1:  		/* lwz R11, <#[R31 + 11152]> */
		/* 82073D60h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073D60h case    1:*/		return 0x82073D64;
		  /* 82073D64h */ case    2:  		/* lwz R11, <#[R31 + 11152]> */
		/* 82073D64h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073D64h case    2:*/		return 0x82073D68;
		  /* 82073D68h */ case    3:  		/* li R5, 1 */
		/* 82073D68h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82073D68h case    3:*/		return 0x82073D6C;
		  /* 82073D6Ch */ case    4:  		/* subfe R10, R10, R10 */
		/* 82073D6Ch case    4:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82073D6Ch case    4:*/		return 0x82073D70;
		  /* 82073D70h */ case    5:  		/* stw R27, <#[R1 + 84]> */
		/* 82073D70h case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000054) );
		/* 82073D70h case    5:*/		return 0x82073D74;
		  /* 82073D74h */ case    6:  		/* add R9, R11, R26 */
		/* 82073D74h case    6:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R26);
		/* 82073D74h case    6:*/		return 0x82073D78;
		  /* 82073D78h */ case    7:  		/* rlwinm R11, R10, 0, 28, 30 */
		/* 82073D78h case    7:*/		cpu::op::rlwinm<0,0,28,30>(regs,&regs.R11,regs.R10);
		/* 82073D78h case    7:*/		return 0x82073D7C;
		  /* 82073D7Ch */ case    8:  		/* stw R9, <#[R31 + 11152]> */
		/* 82073D7Ch case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073D7Ch case    8:*/		return 0x82073D80;
		  /* 82073D80h */ case    9:  		/* addi R4, R1, 80 */
		/* 82073D80h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82073D80h case    9:*/		return 0x82073D84;
		  /* 82073D84h */ case   10:  		/* addi R11, R11, -127 */
		/* 82073D84h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFF81);
		/* 82073D84h case   10:*/		return 0x82073D88;
	}
	return 0x82073D88;
} // Block from 82073D5Ch-82073D88h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82073D88h
// Function '?AppendArrayData@CRingAllocList@D3D@@QAAXPBXKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073D88);
		  /* 82073D88h */ case    0:  		/* mr R3, R31 */
		/* 82073D88h case    0:*/		regs.R3 = regs.R31;
		/* 82073D88h case    0:*/		return 0x82073D8C;
		  /* 82073D8Ch */ case    1:  		/* rlwimi R30, R11, 24, 0, 7 */
		/* 82073D8Ch case    1:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R30,regs.R11);
		/* 82073D8Ch case    1:*/		return 0x82073D90;
		  /* 82073D90h */ case    2:  		/* stw R30, <#[R1 + 80]> */
		/* 82073D90h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 82073D90h case    2:*/		return 0x82073D94;
		  /* 82073D94h */ case    3:  		/* bl -3068 */
		/* 82073D94h case    3:*/		regs.LR = 0x82073D98; return 0x82073198;
		/* 82073D94h case    3:*/		return 0x82073D98;
	}
	return 0x82073D98;
} // Block from 82073D88h-82073D98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82073D98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073D98);
		  /* 82073D98h */ case    0:  		/* mr R3, R29 */
		/* 82073D98h case    0:*/		regs.R3 = regs.R29;
		/* 82073D98h case    0:*/		return 0x82073D9C;
		  /* 82073D9Ch */ case    1:  		/* addi R1, R1, 176 */
		/* 82073D9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82073D9Ch case    1:*/		return 0x82073DA0;
		  /* 82073DA0h */ case    2:  		/* b 120048 */
		/* 82073DA0h case    2:*/		return 0x82091290;
		/* 82073DA0h case    2:*/		return 0x82073DA4;
		  /* 82073DA4h */ case    3:  		/* nop */
		/* 82073DA4h case    3:*/		cpu::op::nop();
		/* 82073DA4h case    3:*/		return 0x82073DA8;
		  /* 82073DA8h */ case    4:  		/* li R11, 0 */
		/* 82073DA8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82073DA8h case    4:*/		return 0x82073DAC;
		  /* 82073DACh */ case    5:  		/* stw R4, <#[R3 + 20]> */
		/* 82073DACh case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000014) );
		/* 82073DACh case    5:*/		return 0x82073DB0;
		  /* 82073DB0h */ case    6:  		/* stw R5, <#[R3 + 8]> */
		/* 82073DB0h case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000008) );
		/* 82073DB0h case    6:*/		return 0x82073DB4;
		  /* 82073DB4h */ case    7:  		/* stw R11, <#[R3 + 4]> */
		/* 82073DB4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82073DB4h case    7:*/		return 0x82073DB8;
		  /* 82073DB8h */ case    8:  		/* stw R11, <#[R3 + 12]> */
		/* 82073DB8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82073DB8h case    8:*/		return 0x82073DBC;
		  /* 82073DBCh */ case    9:  		/* stw R11, <#[R3 + 16]> */
		/* 82073DBCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82073DBCh case    9:*/		return 0x82073DC0;
		  /* 82073DC0h */ case   10:  		/* stw R11, <#[R3]> */
		/* 82073DC0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82073DC0h case   10:*/		return 0x82073DC4;
		  /* 82073DC4h */ case   11:  		/* b -908 */
		/* 82073DC4h case   11:*/		return 0x82073A38;
		/* 82073DC4h case   11:*/		return 0x82073DC8;
	}
	return 0x82073DC8;
} // Block from 82073D98h-82073DC8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82073DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073DC8);
		  /* 82073DC8h */ case    0:  		/* mfspr R12, LR */
		/* 82073DC8h case    0:*/		regs.R12 = regs.LR;
		/* 82073DC8h case    0:*/		return 0x82073DCC;
		  /* 82073DCCh */ case    1:  		/* bl 119948 */
		/* 82073DCCh case    1:*/		regs.LR = 0x82073DD0; return 0x82091258;
		/* 82073DCCh case    1:*/		return 0x82073DD0;
		  /* 82073DD0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82073DD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82073DD0h case    2:*/		return 0x82073DD4;
		  /* 82073DD4h */ case    3:  		/* lbz R10, <#[R3 + 11069]> */
		/* 82073DD4h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002B3D) );
		/* 82073DD4h case    3:*/		return 0x82073DD8;
		  /* 82073DD8h */ case    4:  		/* mr R31, R3 */
		/* 82073DD8h case    4:*/		regs.R31 = regs.R3;
		/* 82073DD8h case    4:*/		return 0x82073DDC;
		  /* 82073DDCh */ case    5:  		/* lwz R11, <#[R3 + 48]> */
		/* 82073DDCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 82073DDCh case    5:*/		return 0x82073DE0;
		  /* 82073DE0h */ case    6:  		/* lwz R30, <#[R3 + 15332]> */
		/* 82073DE0h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00003BE4) );
		/* 82073DE0h case    6:*/		return 0x82073DE4;
		  /* 82073DE4h */ case    7:  		/* rlwinm. R10, R10, 0, 26, 26 */
		/* 82073DE4h case    7:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R10);
		/* 82073DE4h case    7:*/		return 0x82073DE8;
		  /* 82073DE8h */ case    8:  		/* addi R28, R11, 4 */
		/* 82073DE8h case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x4);
		/* 82073DE8h case    8:*/		return 0x82073DEC;
		  /* 82073DECh */ case    9:  		/* bc 4, CR0_EQ, 288 */
		/* 82073DECh case    9:*/		if ( !regs.CR[0].eq ) { return 0x82073F0C;  }
		/* 82073DECh case    9:*/		return 0x82073DF0;
		  /* 82073DF0h */ case   10:  		/* lbz R11, <#[R3 + 11068]> */
		/* 82073DF0h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B3C) );
		/* 82073DF0h case   10:*/		return 0x82073DF4;
		  /* 82073DF4h */ case   11:  		/* rlwinm. R11, R11, 0, 0, 24 */
		/* 82073DF4h case   11:*/		cpu::op::rlwinm<1,0,0,24>(regs,&regs.R11,regs.R11);
		/* 82073DF4h case   11:*/		return 0x82073DF8;
		  /* 82073DF8h */ case   12:  		/* bc 12, CR0_EQ, 108 */
		/* 82073DF8h case   12:*/		if ( regs.CR[0].eq ) { return 0x82073E64;  }
		/* 82073DF8h case   12:*/		return 0x82073DFC;
		  /* 82073DFCh */ case   13:  		/* lwz R11, <#[R3 + 13920]> */
		/* 82073DFCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003660) );
		/* 82073DFCh case   13:*/		return 0x82073E00;
		  /* 82073E00h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82073E00h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82073E00h case   14:*/		return 0x82073E04;
		  /* 82073E04h */ case   15:  		/* bc 12, CR6_EQ, 264 */
		/* 82073E04h case   15:*/		if ( regs.CR[6].eq ) { return 0x82073F0C;  }
		/* 82073E04h case   15:*/		return 0x82073E08;
	}
	return 0x82073E08;
} // Block from 82073DC8h-82073E08h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82073E08h
// Function '?BlockOnSecondaryPosition@CDevice@D3D@@QAAXPAKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073E08);
		  /* 82073E08h */ case    0:  		/* lwz R11, <#[R11 + 152]> */
		/* 82073E08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000098) );
		/* 82073E08h case    0:*/		return 0x82073E0C;
		  /* 82073E0Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82073E0Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82073E0Ch case    1:*/		return 0x82073E10;
		  /* 82073E10h */ case    2:  		/* bc 4, CR6_EQ, 252 */
		/* 82073E10h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82073F0C;  }
		/* 82073E10h case    2:*/		return 0x82073E14;
		  /* 82073E14h */ case    3:  		/* subf R11, R30, R28 */
		/* 82073E14h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R30,regs.R28);
		/* 82073E14h case    3:*/		return 0x82073E18;
		  /* 82073E18h */ case    4:  		/* srawi. R29, R11, 2 */
		/* 82073E18h case    4:*/		cpu::op::srawi<1,2>(regs,&regs.R29,regs.R11);
		/* 82073E18h case    4:*/		return 0x82073E1C;
		  /* 82073E1Ch */ case    5:  		/* bc 12, CR0_EQ, 240 */
		/* 82073E1Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82073F0C;  }
		/* 82073E1Ch case    5:*/		return 0x82073E20;
		  /* 82073E20h */ case    6:  		/* lwz R11, <#[R3 + 13944]> */
		/* 82073E20h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003678) );
		/* 82073E20h case    6:*/		return 0x82073E24;
		  /* 82073E24h */ case    7:  		/* lwz R3, <#[R3 + 13940]> */
		/* 82073E24h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00003674) );
		/* 82073E24h case    7:*/		return 0x82073E28;
		  /* 82073E28h */ case    8:  		/* cmplw CR6, R3, R11 */
		/* 82073E28h case    8:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82073E28h case    8:*/		return 0x82073E2C;
		  /* 82073E2Ch */ case    9:  		/* bc 12, CR6_LT, 12 */
		/* 82073E2Ch case    9:*/		if ( regs.CR[6].lt ) { return 0x82073E38;  }
		/* 82073E2Ch case    9:*/		return 0x82073E30;
		  /* 82073E30h */ case   10:  		/* mr R3, R31 */
		/* 82073E30h case   10:*/		regs.R3 = regs.R31;
		/* 82073E30h case   10:*/		return 0x82073E34;
		  /* 82073E34h */ case   11:  		/* bl 3052 */
		/* 82073E34h case   11:*/		regs.LR = 0x82073E38; return 0x82074A20;
		/* 82073E34h case   11:*/		return 0x82073E38;
	}
	return 0x82073E38;
} // Block from 82073E08h-82073E38h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82073E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073E38);
		  /* 82073E38h */ case    0:  		/* rlwinm R11, R30, 12, 20, 31 */
		/* 82073E38h case    0:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R30);
		/* 82073E38h case    0:*/		return 0x82073E3C;
		  /* 82073E3Ch */ case    1:  		/* rlwinm R10, R30, 0, 3, 31 */
		/* 82073E3Ch case    1:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R30);
		/* 82073E3Ch case    1:*/		return 0x82073E40;
		  /* 82073E40h */ case    2:  		/* addi R11, R11, 512 */
		/* 82073E40h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82073E40h case    2:*/		return 0x82073E44;
		  /* 82073E44h */ case    3:  		/* oris R9, R29, 33024 */
		/* 82073E44h case    3:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R29,0x8100);
		/* 82073E44h case    3:*/		return 0x82073E48;
		  /* 82073E48h */ case    4:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82073E48h case    4:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82073E48h case    4:*/		return 0x82073E4C;
		  /* 82073E4Ch */ case    5:  		/* addi R8, R3, 8 */
		/* 82073E4Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R3,0x8);
		/* 82073E4Ch case    5:*/		return 0x82073E50;
		  /* 82073E50h */ case    6:  		/* stw R9, <#[R3]> */
		/* 82073E50h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82073E50h case    6:*/		return 0x82073E54;
		  /* 82073E54h */ case    7:  		/* add R11, R11, R10 */
		/* 82073E54h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82073E54h case    7:*/		return 0x82073E58;
		  /* 82073E58h */ case    8:  		/* stw R11, <#[R3 + 4]> */
		/* 82073E58h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82073E58h case    8:*/		return 0x82073E5C;
		  /* 82073E5Ch */ case    9:  		/* stw R8, <#[R31 + 13940]> */
		/* 82073E5Ch case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00003674) );
		/* 82073E5Ch case    9:*/		return 0x82073E60;
		  /* 82073E60h */ case   10:  		/* b 172 */
		/* 82073E60h case   10:*/		return 0x82073F0C;
		/* 82073E60h case   10:*/		return 0x82073E64;
	}
	return 0x82073E64;
} // Block from 82073E38h-82073E64h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82073E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073E64);
		  /* 82073E64h */ case    0:  		/* lwz R11, <#[R31 + 13600]> */
		/* 82073E64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003520) );
		/* 82073E64h case    0:*/		return 0x82073E68;
		  /* 82073E68h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82073E68h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82073E68h case    1:*/		return 0x82073E6C;
		  /* 82073E6Ch */ case    2:  		/* bc 12, CR6_EQ, 92 */
		/* 82073E6Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82073EC8;  }
		/* 82073E6Ch case    2:*/		return 0x82073E70;
		  /* 82073E70h */ case    3:  		/* rlwinm R11, R30, 12, 20, 31 */
		/* 82073E70h case    3:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R30);
		/* 82073E70h case    3:*/		return 0x82073E74;
		  /* 82073E74h */ case    4:  		/* rlwinm R10, R30, 0, 3, 31 */
		/* 82073E74h case    4:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R30);
		/* 82073E74h case    4:*/		return 0x82073E78;
		  /* 82073E78h */ case    5:  		/* addi R11, R11, 512 */
		/* 82073E78h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82073E78h case    5:*/		return 0x82073E7C;
		  /* 82073E7Ch */ case    6:  		/* subf R9, R30, R28 */
		/* 82073E7Ch case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R30,regs.R28);
		/* 82073E7Ch case    6:*/		return 0x82073E80;
		  /* 82073E80h */ case    7:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82073E80h case    7:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82073E80h case    7:*/		return 0x82073E84;
		  /* 82073E84h */ case    8:  		/* srawi. R30, R9, 2 */
		/* 82073E84h case    8:*/		cpu::op::srawi<1,2>(regs,&regs.R30,regs.R9);
		/* 82073E84h case    8:*/		return 0x82073E88;
		  /* 82073E88h */ case    9:  		/* add R29, R11, R10 */
		/* 82073E88h case    9:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R10);
		/* 82073E88h case    9:*/		return 0x82073E8C;
		  /* 82073E8Ch */ case   10:  		/* bc 12, CR0_EQ, 128 */
		/* 82073E8Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x82073F0C;  }
		/* 82073E8Ch case   10:*/		return 0x82073E90;
		  /* 82073E90h */ case   11:  		/* lwz R11, <#[R31 + 13772]> */
		/* 82073E90h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000035CC) );
		/* 82073E90h case   11:*/		return 0x82073E94;
		  /* 82073E94h */ case   12:  		/* addi R3, R31, 13760 */
		/* 82073E94h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x35C0);
		/* 82073E94h case   12:*/		return 0x82073E98;
		  /* 82073E98h */ case   13:  		/* lwz R10, <#[R31 + 13776]> */
		/* 82073E98h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000035D0) );
		/* 82073E98h case   13:*/		return 0x82073E9C;
		  /* 82073E9Ch */ case   14:  		/* addi R9, R11, 8 */
		/* 82073E9Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x8);
		/* 82073E9Ch case   14:*/		return 0x82073EA0;
		  /* 82073EA0h */ case   15:  		/* cmplw CR6, R9, R10 */
		/* 82073EA0h case   15:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82073EA0h case   15:*/		return 0x82073EA4;
		  /* 82073EA4h */ case   16:  		/* bc 4, CR6_GT, 12 */
		/* 82073EA4h case   16:*/		if ( !regs.CR[6].gt ) { return 0x82073EB0;  }
		/* 82073EA4h case   16:*/		return 0x82073EA8;
		  /* 82073EA8h */ case   17:  		/* bl -1136 */
		/* 82073EA8h case   17:*/		regs.LR = 0x82073EAC; return 0x82073A38;
		/* 82073EA8h case   17:*/		return 0x82073EAC;
		  /* 82073EACh */ case   18:  		/* mr R11, R3 */
		/* 82073EACh case   18:*/		regs.R11 = regs.R3;
		/* 82073EACh case   18:*/		return 0x82073EB0;
	}
	return 0x82073EB0;
} // Block from 82073E64h-82073EB0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82073EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073EB0);
		  /* 82073EB0h */ case    0:  		/* oris R10, R30, 33024 */
		/* 82073EB0h case    0:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R30,0x8100);
		/* 82073EB0h case    0:*/		return 0x82073EB4;
		  /* 82073EB4h */ case    1:  		/* stw R29, <#[R11 + 4]> */
		/* 82073EB4h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 82073EB4h case    1:*/		return 0x82073EB8;
		  /* 82073EB8h */ case    2:  		/* addi R9, R11, 8 */
		/* 82073EB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x8);
		/* 82073EB8h case    2:*/		return 0x82073EBC;
		  /* 82073EBCh */ case    3:  		/* stw R10, <#[R11]> */
		/* 82073EBCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82073EBCh case    3:*/		return 0x82073EC0;
	}
	return 0x82073EC0;
} // Block from 82073EB0h-82073EC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82073EC0h
// Function '?RingBufferDeviceAllocate@D3D@@YAPAXPAVCDevice@1@KPAKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073EC0);
		  /* 82073EC0h */ case    0:  		/* stw R9, <#[R31 + 13772]> */
		/* 82073EC0h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x000035CC) );
		/* 82073EC0h case    0:*/		return 0x82073EC4;
		  /* 82073EC4h */ case    1:  		/* b 72 */
		/* 82073EC4h case    1:*/		return 0x82073F0C;
		/* 82073EC4h case    1:*/		return 0x82073EC8;
	}
	return 0x82073EC8;
} // Block from 82073EC0h-82073EC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82073EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073EC8);
		  /* 82073EC8h */ case    0:  		/* addi R4, R28, -4 */
		/* 82073EC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R28,0xFFFFFFFC);
		/* 82073EC8h case    0:*/		return 0x82073ECC;
		  /* 82073ECCh */ case    1:  		/* mr R3, R31 */
		/* 82073ECCh case    1:*/		regs.R3 = regs.R31;
		/* 82073ECCh case    1:*/		return 0x82073ED0;
		  /* 82073ED0h */ case    2:  		/* bl -2136 */
		/* 82073ED0h case    2:*/		regs.LR = 0x82073ED4; return 0x82073678;
		/* 82073ED0h case    2:*/		return 0x82073ED4;
		  /* 82073ED4h */ case    3:  		/* rlwinm R11, R30, 12, 20, 31 */
		/* 82073ED4h case    3:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R30);
		/* 82073ED4h case    3:*/		return 0x82073ED8;
		  /* 82073ED8h */ case    4:  		/* addi R4, R3, 4 */
		/* 82073ED8h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x4);
		/* 82073ED8h case    4:*/		return 0x82073EDC;
		  /* 82073EDCh */ case    5:  		/* addi R11, R11, 512 */
		/* 82073EDCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82073EDCh case    5:*/		return 0x82073EE0;
		  /* 82073EE0h */ case    6:  		/* subf R6, R30, R4 */
		/* 82073EE0h case    6:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R30,regs.R4);
		/* 82073EE0h case    6:*/		return 0x82073EE4;
		  /* 82073EE4h */ case    7:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82073EE4h case    7:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82073EE4h case    7:*/		return 0x82073EE8;
		  /* 82073EE8h */ case    8:  		/* rlwinm R10, R30, 0, 3, 31 */
		/* 82073EE8h case    8:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R30);
		/* 82073EE8h case    8:*/		return 0x82073EEC;
		  /* 82073EECh */ case    9:  		/* addi R8, R31, 13760 */
		/* 82073EECh case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x35C0);
		/* 82073EECh case    9:*/		return 0x82073EF0;
		  /* 82073EF0h */ case   10:  		/* li R9, 0 */
		/* 82073EF0h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82073EF0h case   10:*/		return 0x82073EF4;
		  /* 82073EF4h */ case   11:  		/* li R7, 0 */
		/* 82073EF4h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82073EF4h case   11:*/		return 0x82073EF8;
		  /* 82073EF8h */ case   12:  		/* srawi R6, R6, 2 */
		/* 82073EF8h case   12:*/		cpu::op::srawi<0,2>(regs,&regs.R6,regs.R6);
		/* 82073EF8h case   12:*/		return 0x82073EFC;
		  /* 82073EFCh */ case   13:  		/* add R5, R11, R10 */
		/* 82073EFCh case   13:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R10);
		/* 82073EFCh case   13:*/		return 0x82073F00;
		  /* 82073F00h */ case   14:  		/* mr R3, R31 */
		/* 82073F00h case   14:*/		regs.R3 = regs.R31;
		/* 82073F00h case   14:*/		return 0x82073F04;
		  /* 82073F04h */ case   15:  		/* bl -828 */
		/* 82073F04h case   15:*/		regs.LR = 0x82073F08; return 0x82073BC8;
		/* 82073F04h case   15:*/		return 0x82073F08;
		  /* 82073F08h */ case   16:  		/* mr R28, R3 */
		/* 82073F08h case   16:*/		regs.R28 = regs.R3;
		/* 82073F08h case   16:*/		return 0x82073F0C;
	}
	return 0x82073F0C;
} // Block from 82073EC8h-82073F0Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 82073F0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073F0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073F0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073F0C);
		  /* 82073F0Ch */ case    0:  		/* addi R11, R28, 31 */
		/* 82073F0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x1F);
		/* 82073F0Ch case    0:*/		return 0x82073F10;
		  /* 82073F10h */ case    1:  		/* lwz R10, <#[R31 + 56]> */
		/* 82073F10h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 82073F10h case    1:*/		return 0x82073F14;
		  /* 82073F14h */ case    2:  		/* rlwinm R9, R11, 0, 0, 26 */
		/* 82073F14h case    2:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R9,regs.R11);
		/* 82073F14h case    2:*/		return 0x82073F18;
		  /* 82073F18h */ case    3:  		/* cmplw CR6, R9, R10 */
		/* 82073F18h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 82073F18h case    3:*/		return 0x82073F1C;
		  /* 82073F1Ch */ case    4:  		/* bc 4, CR6_GT, 28 */
		/* 82073F1Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x82073F38;  }
		/* 82073F1Ch case    4:*/		return 0x82073F20;
		  /* 82073F20h */ case    5:  		/* addi R11, R28, -4 */
		/* 82073F20h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFC);
		/* 82073F20h case    5:*/		return 0x82073F24;
		  /* 82073F24h */ case    6:  		/* li R4, 0 */
		/* 82073F24h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82073F24h case    6:*/		return 0x82073F28;
		  /* 82073F28h */ case    7:  		/* stw R11, <#[R31 + 48]> */
		/* 82073F28h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82073F28h case    7:*/		return 0x82073F2C;
		  /* 82073F2Ch */ case    8:  		/* mr R3, R31 */
		/* 82073F2Ch case    8:*/		regs.R3 = regs.R31;
		/* 82073F2Ch case    8:*/		return 0x82073F30;
		  /* 82073F30h */ case    9:  		/* bl -3848 */
		/* 82073F30h case    9:*/		regs.LR = 0x82073F34; return 0x82073028;
		/* 82073F30h case    9:*/		return 0x82073F34;
		  /* 82073F34h */ case   10:  		/* b 20 */
		/* 82073F34h case   10:*/		return 0x82073F48;
		/* 82073F34h case   10:*/		return 0x82073F38;
	}
	return 0x82073F38;
} // Block from 82073F0Ch-82073F38h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82073F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073F38);
		  /* 82073F38h */ case    0:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 82073F38h case    0:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 82073F38h case    0:*/		return 0x82073F3C;
		  /* 82073F3Ch */ case    1:  		/* addi R10, R11, -4 */
		/* 82073F3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFFC);
		/* 82073F3Ch case    1:*/		return 0x82073F40;
		  /* 82073F40h */ case    2:  		/* stw R11, <#[R31 + 15332]> */
		/* 82073F40h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00003BE4) );
		/* 82073F40h case    2:*/		return 0x82073F44;
		  /* 82073F44h */ case    3:  		/* stw R10, <#[R31 + 48]> */
		/* 82073F44h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 82073F44h case    3:*/		return 0x82073F48;
	}
	return 0x82073F48;
} // Block from 82073F38h-82073F48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82073F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073F48);
		  /* 82073F48h */ case    0:  		/* addi R1, R1, 128 */
		/* 82073F48h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82073F48h case    0:*/		return 0x82073F4C;
		  /* 82073F4Ch */ case    1:  		/* b 119644 */
		/* 82073F4Ch case    1:*/		return 0x820912A8;
		/* 82073F4Ch case    1:*/		return 0x82073F50;
	}
	return 0x82073F50;
} // Block from 82073F48h-82073F50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82073F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073F50);
		  /* 82073F50h */ case    0:  		/* mfspr R12, LR */
		/* 82073F50h case    0:*/		regs.R12 = regs.LR;
		/* 82073F50h case    0:*/		return 0x82073F54;
		  /* 82073F54h */ case    1:  		/* bl 119524 */
		/* 82073F54h case    1:*/		regs.LR = 0x82073F58; return 0x82091238;
		/* 82073F54h case    1:*/		return 0x82073F58;
		  /* 82073F58h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82073F58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82073F58h case    2:*/		return 0x82073F5C;
		  /* 82073F5Ch */ case    3:  		/* lwz R11, <#[R3 + 13600]> */
		/* 82073F5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003520) );
		/* 82073F5Ch case    3:*/		return 0x82073F60;
		  /* 82073F60h */ case    4:  		/* mr R31, R3 */
		/* 82073F60h case    4:*/		regs.R31 = regs.R3;
		/* 82073F60h case    4:*/		return 0x82073F64;
		  /* 82073F64h */ case    5:  		/* mr R27, R4 */
		/* 82073F64h case    5:*/		regs.R27 = regs.R4;
		/* 82073F64h case    5:*/		return 0x82073F68;
		  /* 82073F68h */ case    6:  		/* mr R26, R5 */
		/* 82073F68h case    6:*/		regs.R26 = regs.R5;
		/* 82073F68h case    6:*/		return 0x82073F6C;
		  /* 82073F6Ch */ case    7:  		/* mr R25, R6 */
		/* 82073F6Ch case    7:*/		regs.R25 = regs.R6;
		/* 82073F6Ch case    7:*/		return 0x82073F70;
		  /* 82073F70h */ case    8:  		/* mr R21, R7 */
		/* 82073F70h case    8:*/		regs.R21 = regs.R7;
		/* 82073F70h case    8:*/		return 0x82073F74;
		  /* 82073F74h */ case    9:  		/* mr R20, R8 */
		/* 82073F74h case    9:*/		regs.R20 = regs.R8;
		/* 82073F74h case    9:*/		return 0x82073F78;
		  /* 82073F78h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82073F78h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82073F78h case   10:*/		return 0x82073F7C;
		  /* 82073F7Ch */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 82073F7Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82073F94;  }
		/* 82073F7Ch case   11:*/		return 0x82073F80;
		  /* 82073F80h */ case   12:  		/* addi R3, R3, 13760 */
		/* 82073F80h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x35C0);
		/* 82073F80h case   12:*/		return 0x82073F84;
		  /* 82073F84h */ case   13:  		/* bl -1084 */
		/* 82073F84h case   13:*/		regs.LR = 0x82073F88; return 0x82073B48;
		/* 82073F84h case   13:*/		return 0x82073F88;
		  /* 82073F88h */ case   14:  		/* li R3, 1 */
		/* 82073F88h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82073F88h case   14:*/		return 0x82073F8C;
		  /* 82073F8Ch */ case   15:  		/* addi R1, R1, 192 */
		/* 82073F8Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82073F8Ch case   15:*/		return 0x82073F90;
		  /* 82073F90h */ case   16:  		/* b 119544 */
		/* 82073F90h case   16:*/		return 0x82091288;
		/* 82073F90h case   16:*/		return 0x82073F94;
	}
	return 0x82073F94;
} // Block from 82073F50h-82073F94h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82073F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82073F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82073F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82073F94);
		  /* 82073F94h */ case    0:  		/* lwz R11, <#[R31 + 11152]> */
		/* 82073F94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073F94h case    0:*/		return 0x82073F98;
		  /* 82073F98h */ case    1:  		/* li R24, 0 */
		/* 82073F98h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82073F98h case    1:*/		return 0x82073F9C;
		  /* 82073F9Ch */ case    2:  		/* mr R22, R24 */
		/* 82073F9Ch case    2:*/		regs.R22 = regs.R24;
		/* 82073F9Ch case    2:*/		return 0x82073FA0;
		  /* 82073FA0h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 82073FA0h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82073FA0h case    3:*/		return 0x82073FA4;
		  /* 82073FA4h */ case    4:  		/* bc 12, CR6_EQ, 184 */
		/* 82073FA4h case    4:*/		if ( regs.CR[6].eq ) { return 0x8207405C;  }
		/* 82073FA4h case    4:*/		return 0x82073FA8;
		  /* 82073FA8h */ case    5:  		/* mullw R29, R26, R25 */
		/* 82073FA8h case    5:*/		cpu::op::mullw<0>(regs,&regs.R29,regs.R26,regs.R25);
		/* 82073FA8h case    5:*/		return 0x82073FAC;
		  /* 82073FACh */ case    6:  		/* li R5, 4 */
		/* 82073FACh case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 82073FACh case    6:*/		return 0x82073FB0;
		  /* 82073FB0h */ case    7:  		/* addi R4, R29, 2 */
		/* 82073FB0h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0x2);
		/* 82073FB0h case    7:*/		return 0x82073FB4;
		  /* 82073FB4h */ case    8:  		/* mr R3, R31 */
		/* 82073FB4h case    8:*/		regs.R3 = regs.R31;
		/* 82073FB4h case    8:*/		return 0x82073FB8;
		  /* 82073FB8h */ case    9:  		/* bl -4216 */
		/* 82073FB8h case    9:*/		regs.LR = 0x82073FBC; return 0x82072F40;
		/* 82073FB8h case    9:*/		return 0x82073FBC;
		  /* 82073FBCh */ case   10:  		/* rlwinm R29, R29, 2, 0, 29 */
		/* 82073FBCh case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R29);
		/* 82073FBCh case   10:*/		return 0x82073FC0;
		  /* 82073FC0h */ case   11:  		/* mr R30, R3 */
		/* 82073FC0h case   11:*/		regs.R30 = regs.R3;
		/* 82073FC0h case   11:*/		return 0x82073FC4;
		  /* 82073FC4h */ case   12:  		/* mr R4, R27 */
		/* 82073FC4h case   12:*/		regs.R4 = regs.R27;
		/* 82073FC4h case   12:*/		return 0x82073FC8;
		  /* 82073FC8h */ case   13:  		/* mr R5, R29 */
		/* 82073FC8h case   13:*/		regs.R5 = regs.R29;
		/* 82073FC8h case   13:*/		return 0x82073FCC;
		  /* 82073FCCh */ case   14:  		/* addi R3, R3, 4 */
		/* 82073FCCh case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82073FCCh case   14:*/		return 0x82073FD0;
		  /* 82073FD0h */ case   15:  		/* bl 121312 */
		/* 82073FD0h case   15:*/		regs.LR = 0x82073FD4; return 0x820919B0;
		/* 82073FD0h case   15:*/		return 0x82073FD4;
		  /* 82073FD4h */ case   16:  		/* add R11, R29, R30 */
		/* 82073FD4h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R29,regs.R30);
		/* 82073FD4h case   16:*/		return 0x82073FD8;
		  /* 82073FD8h */ case   17:  		/* lis R10, -16384 */
		/* 82073FD8h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC000);
		/* 82073FD8h case   17:*/		return 0x82073FDC;
		  /* 82073FDCh */ case   18:  		/* addi R28, R31, 11156 */
		/* 82073FDCh case   18:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x2B94);
		/* 82073FDCh case   18:*/		return 0x82073FE0;
		  /* 82073FE0h */ case   19:  		/* addi R29, R11, 4 */
		/* 82073FE0h case   19:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x4);
		/* 82073FE0h case   19:*/		return 0x82073FE4;
		  /* 82073FE4h */ case   20:  		/* mr R3, R28 */
		/* 82073FE4h case   20:*/		regs.R3 = regs.R28;
		/* 82073FE4h case   20:*/		return 0x82073FE8;
		  /* 82073FE8h */ case   21:  		/* stw R10, <#[R11 + 4]> */
		/* 82073FE8h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82073FE8h case   21:*/		return 0x82073FEC;
		  /* 82073FECh */ case   22:  		/* bl 2068284 */
		/* 82073FECh case   22:*/		regs.LR = 0x82073FF0; return 0x8226CF28;
		/* 82073FECh case   22:*/		return 0x82073FF0;
		  /* 82073FF0h */ case   23:  		/* lwz R11, <#[R31 + 11152]> */
		/* 82073FF0h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82073FF0h case   23:*/		return 0x82073FF4;
		  /* 82073FF4h */ case   24:  		/* mr R23, R3 */
		/* 82073FF4h case   24:*/		regs.R23 = regs.R3;
		/* 82073FF4h case   24:*/		return 0x82073FF8;
		  /* 82073FF8h */ case   25:  		/* cmpwi CR6, R11, 0 */
		/* 82073FF8h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82073FF8h case   25:*/		return 0x82073FFC;
		  /* 82073FFCh */ case   26:  		/* bc 12, CR6_EQ, 24 */
		/* 82073FFCh case   26:*/		if ( regs.CR[6].eq ) { return 0x82074014;  }
		/* 82073FFCh case   26:*/		return 0x82074000;
		  /* 82074000h */ case   27:  		/* addi R3, R31, 13760 */
		/* 82074000h case   27:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x35C0);
		/* 82074000h case   27:*/		return 0x82074004;
		  /* 82074004h */ case   28:  		/* addi R5, R29, 4 */
		/* 82074004h case   28:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R29,0x4);
		/* 82074004h case   28:*/		return 0x82074008;
		  /* 82074008h */ case   29:  		/* mr R4, R30 */
		/* 82074008h case   29:*/		regs.R4 = regs.R30;
		/* 82074008h case   29:*/		return 0x8207400C;
		  /* 8207400Ch */ case   30:  		/* bl -4460 */
		/* 8207400Ch case   30:*/		regs.LR = 0x82074010; return 0x82072EA0;
		/* 8207400Ch case   30:*/		return 0x82074010;
		  /* 82074010h */ case   31:  		/* li R22, 1 */
		/* 82074010h case   31:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 82074010h case   31:*/		return 0x82074014;
	}
	return 0x82074014;
} // Block from 82073F94h-82074014h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82074014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074014);
		  /* 82074014h */ case    0:  		/* mr R4, R23 */
		/* 82074014h case    0:*/		regs.R4 = regs.R23;
		/* 82074014h case    0:*/		return 0x82074018;
		  /* 82074018h */ case    1:  		/* mr R3, R28 */
		/* 82074018h case    1:*/		regs.R3 = regs.R28;
		/* 82074018h case    1:*/		return 0x8207401C;
		  /* 8207401Ch */ case    2:  		/* bl 2068204 */
		/* 8207401Ch case    2:*/		regs.LR = 0x82074020; return 0x8226CF08;
		/* 8207401Ch case    2:*/		return 0x82074020;
		  /* 82074020h */ case    3:  		/* cmpwi CR6, R22, 0 */
		/* 82074020h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 82074020h case    3:*/		return 0x82074024;
		  /* 82074024h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 82074024h case    4:*/		if ( regs.CR[6].eq ) { return 0x8207405C;  }
		/* 82074024h case    4:*/		return 0x82074028;
		  /* 82074028h */ case    5:  		/* cmpwi CR6, R20, 0 */
		/* 82074028h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 82074028h case    5:*/		return 0x8207402C;
		  /* 8207402Ch */ case    6:  		/* bc 12, CR6_EQ, -164 */
		/* 8207402Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82073F88;  }
		/* 8207402Ch case    6:*/		return 0x82074030;
		  /* 82074030h */ case    7:  		/* lbz R11, <#[R31 + 11072]> */
		/* 82074030h case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B40) );
		/* 82074030h case    7:*/		return 0x82074034;
		  /* 82074034h */ case    8:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 82074034h case    8:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 82074034h case    8:*/		return 0x82074038;
		  /* 82074038h */ case    9:  		/* bc 12, CR0_EQ, -176 */
		/* 82074038h case    9:*/		if ( regs.CR[0].eq ) { return 0x82073F88;  }
		/* 82074038h case    9:*/		return 0x8207403C;
		  /* 8207403Ch */ case   10:  		/* li R5, 0 */
		/* 8207403Ch case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8207403Ch case   10:*/		return 0x82074040;
		  /* 82074040h */ case   11:  		/* li R4, 1 */
		/* 82074040h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82074040h case   11:*/		return 0x82074044;
		  /* 82074044h */ case   12:  		/* addi R3, R31, 24460 */
		/* 82074044h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x5F8C);
		/* 82074044h case   12:*/		return 0x82074048;
		  /* 82074048h */ case   13:  		/* bl 2068176 */
		/* 82074048h case   13:*/		regs.LR = 0x8207404C; return 0x8226CF18;
		/* 82074048h case   13:*/		return 0x8207404C;
		  /* 8207404Ch */ case   14:  		/* lbz R11, <#[R31 + 11072]> */
		/* 8207404Ch case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B40) );
		/* 8207404Ch case   14:*/		return 0x82074050;
		  /* 82074050h */ case   15:  		/* andi. R11, R11, 247 */
		/* 82074050h case   15:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0xF7);
		/* 82074050h case   15:*/		return 0x82074054;
		  /* 82074054h */ case   16:  		/* stb R11, <#[R31 + 11072]> */
		/* 82074054h case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002B40) );
		/* 82074054h case   16:*/		return 0x82074058;
		  /* 82074058h */ case   17:  		/* b -208 */
		/* 82074058h case   17:*/		return 0x82073F88;
		/* 82074058h case   17:*/		return 0x8207405C;
	}
	return 0x8207405C;
} // Block from 82074014h-8207405Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8207405Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207405C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207405C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207405C);
		  /* 8207405Ch */ case    0:  		/* cmpwi CR6, R21, 0 */
		/* 8207405Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8207405Ch case    0:*/		return 0x82074060;
		  /* 82074060h */ case    1:  		/* bc 12, CR6_EQ, 156 */
		/* 82074060h case    1:*/		if ( regs.CR[6].eq ) { return 0x820740FC;  }
		/* 82074060h case    1:*/		return 0x82074064;
		  /* 82074064h */ case    2:  		/* li R11, 128 */
		/* 82074064h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x80);
		/* 82074064h case    2:*/		return 0x82074068;
		  /* 82074068h */ case    3:  		/* stw R31, <#[R31 + 13780]> */
		/* 82074068h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R31 + 0x000035D4) );
		/* 82074068h case    3:*/		return 0x8207406C;
		  /* 8207406Ch */ case    4:  		/* stw R24, <#[R31 + 13764]> */
		/* 8207406Ch case    4:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x000035C4) );
		/* 8207406Ch case    4:*/		return 0x82074070;
		  /* 82074070h */ case    5:  		/* addi R30, R31, 13760 */
		/* 82074070h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x35C0);
		/* 82074070h case    5:*/		return 0x82074074;
		  /* 82074074h */ case    6:  		/* stw R11, <#[R31 + 13768]> */
		/* 82074074h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000035C8) );
		/* 82074074h case    6:*/		return 0x82074078;
		  /* 82074078h */ case    7:  		/* stw R24, <#[R31 + 13772]> */
		/* 82074078h case    7:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x000035CC) );
		/* 82074078h case    7:*/		return 0x8207407C;
		  /* 8207407Ch */ case    8:  		/* mr R3, R30 */
		/* 8207407Ch case    8:*/		regs.R3 = regs.R30;
		/* 8207407Ch case    8:*/		return 0x82074080;
		  /* 82074080h */ case    9:  		/* stw R24, <#[R31 + 13776]> */
		/* 82074080h case    9:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x000035D0) );
		/* 82074080h case    9:*/		return 0x82074084;
		  /* 82074084h */ case   10:  		/* stw R24, <#[R31 + 13760]> */
		/* 82074084h case   10:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x000035C0) );
		/* 82074084h case   10:*/		return 0x82074088;
		  /* 82074088h */ case   11:  		/* bl -1616 */
		/* 82074088h case   11:*/		regs.LR = 0x8207408C; return 0x82073A38;
		/* 82074088h case   11:*/		return 0x8207408C;
		  /* 8207408Ch */ case   12:  		/* mr R3, R30 */
		/* 8207408Ch case   12:*/		regs.R3 = regs.R30;
		/* 8207408Ch case   12:*/		return 0x82074090;
		  /* 82074090h */ case   13:  		/* mr R6, R25 */
		/* 82074090h case   13:*/		regs.R6 = regs.R25;
		/* 82074090h case   13:*/		return 0x82074094;
		  /* 82074094h */ case   14:  		/* mr R5, R26 */
		/* 82074094h case   14:*/		regs.R5 = regs.R26;
		/* 82074094h case   14:*/		return 0x82074098;
		  /* 82074098h */ case   15:  		/* mr R4, R27 */
		/* 82074098h case   15:*/		regs.R4 = regs.R27;
		/* 82074098h case   15:*/		return 0x8207409C;
		  /* 8207409Ch */ case   16:  		/* bl -1364 */
		/* 8207409Ch case   16:*/		regs.LR = 0x820740A0; return 0x82073B48;
		/* 8207409Ch case   16:*/		return 0x820740A0;
		  /* 820740A0h */ case   17:  		/* mr R3, R30 */
		/* 820740A0h case   17:*/		regs.R3 = regs.R30;
		/* 820740A0h case   17:*/		return 0x820740A4;
		  /* 820740A4h */ case   18:  		/* bl -4684 */
		/* 820740A4h case   18:*/		regs.LR = 0x820740A8; return 0x82072E58;
		/* 820740A4h case   18:*/		return 0x820740A8;
		  /* 820740A8h */ case   19:  		/* lwz R11, <#[R31 + 11152]> */
		/* 820740A8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 820740A8h case   19:*/		return 0x820740AC;
		  /* 820740ACh */ case   20:  		/* addi R11, R11, 1 */
		/* 820740ACh case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820740ACh case   20:*/		return 0x820740B0;
		  /* 820740B0h */ case   21:  		/* stw R11, <#[R31 + 11152]> */
		/* 820740B0h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 820740B0h case   21:*/		return 0x820740B4;
		  /* 820740B4h */ case   22:  		/* lwz R11, <#[R31 + 13760]> */
		/* 820740B4h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000035C0) );
		/* 820740B4h case   22:*/		return 0x820740B8;
		  /* 820740B8h */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 820740B8h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820740B8h case   23:*/		return 0x820740BC;
		  /* 820740BCh */ case   24:  		/* bc 4, CR6_EQ, 12 */
		/* 820740BCh case   24:*/		if ( !regs.CR[6].eq ) { return 0x820740C8;  }
		/* 820740BCh case   24:*/		return 0x820740C0;
		  /* 820740C0h */ case   25:  		/* mr R4, R24 */
		/* 820740C0h case   25:*/		regs.R4 = regs.R24;
		/* 820740C0h case   25:*/		return 0x820740C4;
		  /* 820740C4h */ case   26:  		/* b 28 */
		/* 820740C4h case   26:*/		return 0x820740E0;
		/* 820740C4h case   26:*/		return 0x820740C8;
	}
	return 0x820740C8;
} // Block from 8207405Ch-820740C8h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820740C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820740C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820740C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820740C8);
		  /* 820740C8h */ case    0:  		/* rlwinm R9, R11, 12, 20, 31 */
		/* 820740C8h case    0:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R9,regs.R11);
		/* 820740C8h case    0:*/		return 0x820740CC;
		  /* 820740CCh */ case    1:  		/* rlwinm R10, R11, 0, 3, 31 */
		/* 820740CCh case    1:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R11);
		/* 820740CCh case    1:*/		return 0x820740D0;
		  /* 820740D0h */ case    2:  		/* addi R11, R9, 512 */
		/* 820740D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x200);
		/* 820740D0h case    2:*/		return 0x820740D4;
		  /* 820740D4h */ case    3:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 820740D4h case    3:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 820740D4h case    3:*/		return 0x820740D8;
		  /* 820740D8h */ case    4:  		/* add R11, R11, R10 */
		/* 820740D8h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820740D8h case    4:*/		return 0x820740DC;
		  /* 820740DCh */ case    5:  		/* addis R4, R11, -16384 */
		/* 820740DCh case    5:*/		cpu::op::addis<0>(regs,&regs.R4,regs.R11,0xFFFFC000);
		/* 820740DCh case    5:*/		return 0x820740E0;
	}
	return 0x820740E0;
} // Block from 820740C8h-820740E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820740E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820740E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820740E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820740E0);
		  /* 820740E0h */ case    0:  		/* lwz R11, <#[R31 + 11464]> */
		/* 820740E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002CC8) );
		/* 820740E0h case    0:*/		return 0x820740E4;
		  /* 820740E4h */ case    1:  		/* li R5, 0 */
		/* 820740E4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820740E4h case    1:*/		return 0x820740E8;
		  /* 820740E8h */ case    2:  		/* mulli R11, R11, 108 */
		/* 820740E8h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x6C);
		/* 820740E8h case    2:*/		return 0x820740EC;
		  /* 820740ECh */ case    3:  		/* add R11, R11, R31 */
		/* 820740ECh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820740ECh case    3:*/		return 0x820740F0;
	}
	return 0x820740F0;
} // Block from 820740E0h-820740F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820740F0h
// Function '?BeginRingAlloc@CDevice@D3D@@QAAPAKKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820740F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820740F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820740F0);
		  /* 820740F0h */ case    0:  		/* addi R3, R11, 11608 */
		/* 820740F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x2D58);
		/* 820740F0h case    0:*/		return 0x820740F4;
		  /* 820740F4h */ case    1:  		/* bl 2068164 */
		/* 820740F4h case    1:*/		regs.LR = 0x820740F8; return 0x8226CFB8;
		/* 820740F4h case    1:*/		return 0x820740F8;
		  /* 820740F8h */ case    2:  		/* b -368 */
		/* 820740F8h case    2:*/		return 0x82073F88;
		/* 820740F8h case    2:*/		return 0x820740FC;
	}
	return 0x820740FC;
} // Block from 820740F0h-820740FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820740FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820740FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820740FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820740FC);
		  /* 820740FCh */ case    0:  		/* li R3, 0 */
		/* 820740FCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820740FCh case    0:*/		return 0x82074100;
		  /* 82074100h */ case    1:  		/* b -372 */
		/* 82074100h case    1:*/		return 0x82073F8C;
		/* 82074100h case    1:*/		return 0x82074104;
		  /* 82074104h */ case    2:  		/* nop */
		/* 82074104h case    2:*/		cpu::op::nop();
		/* 82074104h case    2:*/		return 0x82074108;
	}
	return 0x82074108;
} // Block from 820740FCh-82074108h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82074108h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074108);
		  /* 82074108h */ case    0:  		/* mfspr R12, LR */
		/* 82074108h case    0:*/		regs.R12 = regs.LR;
		/* 82074108h case    0:*/		return 0x8207410C;
		  /* 8207410Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8207410Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8207410Ch case    1:*/		return 0x82074110;
		  /* 82074110h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82074110h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82074110h case    2:*/		return 0x82074114;
		  /* 82074114h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82074114h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074114h case    3:*/		return 0x82074118;
		  /* 82074118h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82074118h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82074118h case    4:*/		return 0x8207411C;
		  /* 8207411Ch */ case    5:  		/* lwz R11, <#[R3 + 11024]> */
		/* 8207411Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B10) );
		/* 8207411Ch case    5:*/		return 0x82074120;
		  /* 82074120h */ case    6:  		/* mr R31, R3 */
		/* 82074120h case    6:*/		regs.R31 = regs.R3;
		/* 82074120h case    6:*/		return 0x82074124;
		  /* 82074124h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82074124h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82074124h case    7:*/		return 0x82074128;
		  /* 82074128h */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 82074128h case    8:*/		if ( regs.CR[6].eq ) { return 0x82074130;  }
		/* 82074128h case    8:*/		return 0x8207412C;
		  /* 8207412Ch */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8207412Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8207412Ch case    9:*/		return 0x82074130;
	}
	return 0x82074130;
} // Block from 82074108h-82074130h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82074130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074130);
		  /* 82074130h */ case    0:  		/* lwz R11, <#[R31 + 13600]> */
		/* 82074130h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003520) );
		/* 82074130h case    0:*/		return 0x82074134;
		  /* 82074134h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82074134h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82074134h case    1:*/		return 0x82074138;
		  /* 82074138h */ case    2:  		/* bc 4, CR6_EQ, 96 */
		/* 82074138h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82074198;  }
		/* 82074138h case    2:*/		return 0x8207413C;
		  /* 8207413Ch */ case    3:  		/* lbz R11, <#[R31 + 11068]> */
		/* 8207413Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3C) );
		/* 8207413Ch case    3:*/		return 0x82074140;
		  /* 82074140h */ case    4:  		/* rlwinm. R11, R11, 0, 0, 24 */
		/* 82074140h case    4:*/		cpu::op::rlwinm<1,0,0,24>(regs,&regs.R11,regs.R11);
		/* 82074140h case    4:*/		return 0x82074144;
		  /* 82074144h */ case    5:  		/* bc 4, CR0_EQ, 84 */
		/* 82074144h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82074198;  }
		/* 82074144h case    5:*/		return 0x82074148;
		  /* 82074148h */ case    6:  		/* addi R5, R1, 80 */
		/* 82074148h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82074148h case    6:*/		return 0x8207414C;
		  /* 8207414Ch */ case    7:  		/* addi R4, R1, 84 */
		/* 8207414Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 8207414Ch case    7:*/		return 0x82074150;
		  /* 82074150h */ case    8:  		/* mr R3, R31 */
		/* 82074150h case    8:*/		regs.R3 = regs.R31;
		/* 82074150h case    8:*/		return 0x82074154;
		  /* 82074154h */ case    9:  		/* bl -3308 */
		/* 82074154h case    9:*/		regs.LR = 0x82074158; return 0x82073468;
		/* 82074154h case    9:*/		return 0x82074158;
		  /* 82074158h */ case   10:  		/* lwz R30, <#[R1 + 80]> */
		/* 82074158h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 82074158h case   10:*/		return 0x8207415C;
		  /* 8207415Ch */ case   11:  		/* cmplwi CR6, R30, 0 */
		/* 8207415Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8207415Ch case   11:*/		return 0x82074160;
		  /* 82074160h */ case   12:  		/* bc 12, CR6_EQ, 56 */
		/* 82074160h case   12:*/		if ( regs.CR[6].eq ) { return 0x82074198;  }
		/* 82074160h case   12:*/		return 0x82074164;
		  /* 82074164h */ case   13:  		/* li R5, 4 */
		/* 82074164h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 82074164h case   13:*/		return 0x82074168;
		  /* 82074168h */ case   14:  		/* li R4, 4 */
		/* 82074168h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 82074168h case   14:*/		return 0x8207416C;
		  /* 8207416Ch */ case   15:  		/* mr R3, R31 */
		/* 8207416Ch case   15:*/		regs.R3 = regs.R31;
		/* 8207416Ch case   15:*/		return 0x82074170;
		  /* 82074170h */ case   16:  		/* bl -4656 */
		/* 82074170h case   16:*/		regs.LR = 0x82074174; return 0x82072F40;
		/* 82074170h case   16:*/		return 0x82074174;
		  /* 82074174h */ case   17:  		/* or. R4, R3, R3 */
		/* 82074174h case   17:*/		cpu::op::or<1>(regs,&regs.R4,regs.R3,regs.R3);
		/* 82074174h case   17:*/		return 0x82074178;
		  /* 82074178h */ case   18:  		/* bc 12, CR0_EQ, 32 */
		/* 82074178h case   18:*/		if ( regs.CR[0].eq ) { return 0x82074198;  }
		/* 82074178h case   18:*/		return 0x8207417C;
		  /* 8207417Ch */ case   19:  		/* li R9, 0 */
		/* 8207417Ch case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8207417Ch case   19:*/		return 0x82074180;
		  /* 82074180h */ case   20:  		/* lwz R5, <#[R1 + 84]> */
		/* 82074180h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 82074180h case   20:*/		return 0x82074184;
		  /* 82074184h */ case   21:  		/* addi R8, R31, 13760 */
		/* 82074184h case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x35C0);
		/* 82074184h case   21:*/		return 0x82074188;
		  /* 82074188h */ case   22:  		/* li R7, 0 */
		/* 82074188h case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82074188h case   22:*/		return 0x8207418C;
		  /* 8207418Ch */ case   23:  		/* mr R6, R30 */
		/* 8207418Ch case   23:*/		regs.R6 = regs.R30;
		/* 8207418Ch case   23:*/		return 0x82074190;
		  /* 82074190h */ case   24:  		/* mr R3, R31 */
		/* 82074190h case   24:*/		regs.R3 = regs.R31;
		/* 82074190h case   24:*/		return 0x82074194;
		  /* 82074194h */ case   25:  		/* bl -1484 */
		/* 82074194h case   25:*/		regs.LR = 0x82074198; return 0x82073BC8;
		/* 82074194h case   25:*/		return 0x82074198;
	}
	return 0x82074198;
} // Block from 82074130h-82074198h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82074198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074198);
		  /* 82074198h */ case    0:  		/* mr R3, R31 */
		/* 82074198h case    0:*/		regs.R3 = regs.R31;
		/* 82074198h case    0:*/		return 0x8207419C;
		  /* 8207419Ch */ case    1:  		/* bl -980 */
		/* 8207419Ch case    1:*/		regs.LR = 0x820741A0; return 0x82073DC8;
		/* 8207419Ch case    1:*/		return 0x820741A0;
		  /* 820741A0h */ case    2:  		/* lbz R11, <#[R31 + 11068]> */
		/* 820741A0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3C) );
		/* 820741A0h case    2:*/		return 0x820741A4;
		  /* 820741A4h */ case    3:  		/* rlwinm. R11, R11, 0, 0, 24 */
		/* 820741A4h case    3:*/		cpu::op::rlwinm<1,0,0,24>(regs,&regs.R11,regs.R11);
		/* 820741A4h case    3:*/		return 0x820741A8;
		  /* 820741A8h */ case    4:  		/* bc 4, CR0_EQ, 72 */
		/* 820741A8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820741F0;  }
		/* 820741A8h case    4:*/		return 0x820741AC;
		  /* 820741ACh */ case    5:  		/* lis R11, -32216 */
		/* 820741ACh case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 820741ACh case    5:*/		return 0x820741B0;
		  /* 820741B0h */ case    6:  		/* lwz R11, <#[R11 + 28736]> */
		/* 820741B0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00007040) );
		/* 820741B0h case    6:*/		return 0x820741B4;
		  /* 820741B4h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820741B4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820741B4h case    7:*/		return 0x820741B8;
		  /* 820741B8h */ case    8:  		/* bc 12, CR6_EQ, 56 */
		/* 820741B8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820741F0;  }
		/* 820741B8h case    8:*/		return 0x820741BC;
		  /* 820741BCh */ case    9:  		/* lbz R11, <#[R31 + 11069]> */
		/* 820741BCh case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 820741BCh case    9:*/		return 0x820741C0;
		  /* 820741C0h */ case   10:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820741C0h case   10:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820741C0h case   10:*/		return 0x820741C4;
		  /* 820741C4h */ case   11:  		/* bc 4, CR0_EQ, 44 */
		/* 820741C4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820741F0;  }
		/* 820741C4h case   11:*/		return 0x820741C8;
		  /* 820741C8h */ case   12:  		/* lwz R11, <#[R31 + 11036]> */
		/* 820741C8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B1C) );
		/* 820741C8h case   12:*/		return 0x820741CC;
		  /* 820741CCh */ case   13:  		/* li R7, 0 */
		/* 820741CCh case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820741CCh case   13:*/		return 0x820741D0;
		  /* 820741D0h */ case   14:  		/* li R6, 0 */
		/* 820741D0h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820741D0h case   14:*/		return 0x820741D4;
		  /* 820741D4h */ case   15:  		/* li R5, 0 */
		/* 820741D4h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820741D4h case   15:*/		return 0x820741D8;
		  /* 820741D8h */ case   16:  		/* addi R4, R11, -2 */
		/* 820741D8h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFE);
		/* 820741D8h case   16:*/		return 0x820741DC;
		  /* 820741DCh */ case   17:  		/* mr R3, R31 */
		/* 820741DCh case   17:*/		regs.R3 = regs.R31;
		/* 820741DCh case   17:*/		return 0x820741E0;
		  /* 820741E0h */ case   18:  		/* bl -5304 */
		/* 820741E0h case   18:*/		regs.LR = 0x820741E4; return 0x82072D28;
		/* 820741E0h case   18:*/		return 0x820741E4;
		  /* 820741E4h */ case   19:  		/* lbz R11, <#[R31 + 11069]> */
		/* 820741E4h case   19:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 820741E4h case   19:*/		return 0x820741E8;
		  /* 820741E8h */ case   20:  		/* ori R11, R11, 2 */
		/* 820741E8h case   20:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820741E8h case   20:*/		return 0x820741EC;
		  /* 820741ECh */ case   21:  		/* stb R11, <#[R31 + 11069]> */
		/* 820741ECh case   21:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002B3D) );
		/* 820741ECh case   21:*/		return 0x820741F0;
	}
	return 0x820741F0;
} // Block from 82074198h-820741F0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820741F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820741F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820741F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820741F0);
		  /* 820741F0h */ case    0:  		/* lwz R3, <#[R31 + 48]> */
		/* 820741F0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 820741F0h case    0:*/		return 0x820741F4;
		  /* 820741F4h */ case    1:  		/* addi R1, R1, 112 */
		/* 820741F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820741F4h case    1:*/		return 0x820741F8;
		  /* 820741F8h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820741F8h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820741F8h case    2:*/		return 0x820741FC;
		  /* 820741FCh */ case    3:  		/* mtspr LR, R12 */
		/* 820741FCh case    3:*/		regs.LR = regs.R12;
		/* 820741FCh case    3:*/		return 0x82074200;
		  /* 82074200h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82074200h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82074200h case    4:*/		return 0x82074204;
		  /* 82074204h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82074204h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074204h case    5:*/		return 0x82074208;
		  /* 82074208h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82074208h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82074208h case    6:*/		return 0x8207420C;
	}
	return 0x8207420C;
} // Block from 820741F0h-8207420Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8207420Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207420C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207420C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207420C);
		  /* 8207420Ch */ case    0:  		/* nop */
		/* 8207420Ch case    0:*/		cpu::op::nop();
		/* 8207420Ch case    0:*/		return 0x82074210;
	}
	return 0x82074210;
} // Block from 8207420Ch-82074210h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82074210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074210);
		  /* 82074210h */ case    0:  		/* mfspr R12, LR */
		/* 82074210h case    0:*/		regs.R12 = regs.LR;
		/* 82074210h case    0:*/		return 0x82074214;
		  /* 82074214h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82074214h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074214h case    1:*/		return 0x82074218;
		  /* 82074218h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82074218h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074218h case    2:*/		return 0x8207421C;
		  /* 8207421Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8207421Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8207421Ch case    3:*/		return 0x82074220;
		  /* 82074220h */ case    4:  		/* lwz R31, <#[R3 + 11036]> */
		/* 82074220h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00002B1C) );
		/* 82074220h case    4:*/		return 0x82074224;
		  /* 82074224h */ case    5:  		/* stw R31, <#[R3 + 11056]> */
		/* 82074224h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00002B30) );
		/* 82074224h case    5:*/		return 0x82074228;
		  /* 82074228h */ case    6:  		/* bl -288 */
		/* 82074228h case    6:*/		regs.LR = 0x8207422C; return 0x82074108;
		/* 82074228h case    6:*/		return 0x8207422C;
		  /* 8207422Ch */ case    7:  		/* mr R3, R31 */
		/* 8207422Ch case    7:*/		regs.R3 = regs.R31;
		/* 8207422Ch case    7:*/		return 0x82074230;
		  /* 82074230h */ case    8:  		/* addi R1, R1, 96 */
		/* 82074230h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82074230h case    8:*/		return 0x82074234;
		  /* 82074234h */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 82074234h case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074234h case    9:*/		return 0x82074238;
		  /* 82074238h */ case   10:  		/* mtspr LR, R12 */
		/* 82074238h case   10:*/		regs.LR = regs.R12;
		/* 82074238h case   10:*/		return 0x8207423C;
		  /* 8207423Ch */ case   11:  		/* ld R31, <#[R1 - 16]> */
		/* 8207423Ch case   11:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8207423Ch case   11:*/		return 0x82074240;
		  /* 82074240h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82074240h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82074240h case   12:*/		return 0x82074244;
	}
	return 0x82074244;
} // Block from 82074210h-82074244h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82074244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074244);
		  /* 82074244h */ case    0:  		/* nop */
		/* 82074244h case    0:*/		cpu::op::nop();
		/* 82074244h case    0:*/		return 0x82074248;
	}
	return 0x82074248;
} // Block from 82074244h-82074248h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82074248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074248);
		  /* 82074248h */ case    0:  		/* mfspr R12, LR */
		/* 82074248h case    0:*/		regs.R12 = regs.LR;
		/* 82074248h case    0:*/		return 0x8207424C;
		  /* 8207424Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8207424Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8207424Ch case    1:*/		return 0x82074250;
		  /* 82074250h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82074250h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82074250h case    2:*/		return 0x82074254;
		  /* 82074254h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82074254h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074254h case    3:*/		return 0x82074258;
		  /* 82074258h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82074258h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82074258h case    4:*/		return 0x8207425C;
		  /* 8207425Ch */ case    5:  		/* mr R30, R3 */
		/* 8207425Ch case    5:*/		regs.R30 = regs.R3;
		/* 8207425Ch case    5:*/		return 0x82074260;
		  /* 82074260h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 82074260h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82074260h case    6:*/		return 0x82074264;
		  /* 82074264h */ case    7:  		/* bc 12, CR6_EQ, 92 */
		/* 82074264h case    7:*/		if ( regs.CR[6].eq ) { return 0x820742C0;  }
		/* 82074264h case    7:*/		return 0x82074268;
		  /* 82074268h */ case    8:  		/* bl 2067600 */
		/* 82074268h case    8:*/		regs.LR = 0x8207426C; return 0x8226CEF8;
		/* 82074268h case    8:*/		return 0x8207426C;
		  /* 8207426Ch */ case    9:  		/* cmpwi CR6, R3, 2 */
		/* 8207426Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 8207426Ch case    9:*/		return 0x82074270;
		  /* 82074270h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 82074270h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82074280;  }
		/* 82074270h case   10:*/		return 0x82074274;
		  /* 82074274h */ case   11:  		/* lis R11, -32256 */
		/* 82074274h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074274h case   11:*/		return 0x82074278;
		  /* 82074278h */ case   12:  		/* lwz R11, <#[R11 + 1452]> */
		/* 82074278h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005AC) );
		/* 82074278h case   12:*/		return 0x8207427C;
		  /* 8207427Ch */ case   13:  		/* b 12 */
		/* 8207427Ch case   13:*/		return 0x82074288;
		/* 8207427Ch case   13:*/		return 0x82074280;
	}
	return 0x82074280;
} // Block from 82074248h-82074280h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82074280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074280);
		  /* 82074280h */ case    0:  		/* lis R11, -32256 */
		/* 82074280h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074280h case    0:*/		return 0x82074284;
		  /* 82074284h */ case    1:  		/* lwz R11, <#[R11 + 1456]> */
		/* 82074284h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005B0) );
		/* 82074284h case    1:*/		return 0x82074288;
	}
	return 0x82074288;
} // Block from 82074280h-82074288h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82074288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074288);
		  /* 82074288h */ case    0:  		/* lwz R31, <#[R11]> */
		/* 82074288h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82074288h case    0:*/		return 0x8207428C;
		  /* 8207428Ch */ case    1:  		/* lwz R11, <#[R31 + 11036]> */
		/* 8207428Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B1C) );
		/* 8207428Ch case    1:*/		return 0x82074290;
	}
	return 0x82074290;
} // Block from 82074288h-82074290h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82074290h
// Function '?StartNewSegment@CDevice@D3D@@QAAPAKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074290);
		  /* 82074290h */ case    0:  		/* cmplw CR6, R30, R11 */
		/* 82074290h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82074290h case    0:*/		return 0x82074294;
		  /* 82074294h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82074294h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820742A0;  }
		/* 82074294h case    1:*/		return 0x82074298;
		  /* 82074298h */ case    2:  		/* mr R3, R31 */
		/* 82074298h case    2:*/		regs.R3 = regs.R31;
		/* 82074298h case    2:*/		return 0x8207429C;
		  /* 8207429Ch */ case    3:  		/* bl -404 */
		/* 8207429Ch case    3:*/		regs.LR = 0x820742A0; return 0x82074108;
		/* 8207429Ch case    3:*/		return 0x820742A0;
	}
	return 0x820742A0;
} // Block from 82074290h-820742A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820742A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820742A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820742A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820742A0);
		  /* 820742A0h */ case    0:  		/* lwz R11, <#[R31 + 11024]> */
		/* 820742A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 820742A0h case    0:*/		return 0x820742A4;
		  /* 820742A4h */ case    1:  		/* lwz R10, <#[R31 + 11036]> */
		/* 820742A4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B1C) );
		/* 820742A4h case    1:*/		return 0x820742A8;
		  /* 820742A8h */ case    2:  		/* subf R9, R30, R10 */
		/* 820742A8h case    2:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R30,regs.R10);
		/* 820742A8h case    2:*/		return 0x820742AC;
		  /* 820742ACh */ case    3:  		/* lwz R11, <#[R11]> */
		/* 820742ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820742ACh case    3:*/		return 0x820742B0;
		  /* 820742B0h */ case    4:  		/* subf R11, R11, R10 */
		/* 820742B0h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820742B0h case    4:*/		return 0x820742B4;
		  /* 820742B4h */ case    5:  		/* subfc R11, R11, R9 */
		/* 820742B4h case    5:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820742B4h case    5:*/		return 0x820742B8;
		  /* 820742B8h */ case    6:  		/* subfe R11, R11, R11 */
		/* 820742B8h case    6:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820742B8h case    6:*/		return 0x820742BC;
		  /* 820742BCh */ case    7:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 820742BCh case    7:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 820742BCh case    7:*/		return 0x820742C0;
	}
	return 0x820742C0;
} // Block from 820742A0h-820742C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820742C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820742C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820742C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820742C0);
		  /* 820742C0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820742C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820742C0h case    0:*/		return 0x820742C4;
		  /* 820742C4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820742C4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820742C4h case    1:*/		return 0x820742C8;
		  /* 820742C8h */ case    2:  		/* mtspr LR, R12 */
		/* 820742C8h case    2:*/		regs.LR = regs.R12;
		/* 820742C8h case    2:*/		return 0x820742CC;
		  /* 820742CCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820742CCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820742CCh case    3:*/		return 0x820742D0;
		  /* 820742D0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820742D0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820742D0h case    4:*/		return 0x820742D4;
		  /* 820742D4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820742D4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820742D4h case    5:*/		return 0x820742D8;
	}
	return 0x820742D8;
} // Block from 820742C0h-820742D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820742D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820742D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820742D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820742D8);
		  /* 820742D8h */ case    0:  		/* mfspr R12, LR */
		/* 820742D8h case    0:*/		regs.R12 = regs.LR;
		/* 820742D8h case    0:*/		return 0x820742DC;
		  /* 820742DCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820742DCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820742DCh case    1:*/		return 0x820742E0;
		  /* 820742E0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820742E0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820742E0h case    2:*/		return 0x820742E4;
		  /* 820742E4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820742E4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820742E4h case    3:*/		return 0x820742E8;
		  /* 820742E8h */ case    4:  		/* lwz R11, <#[R3 + 56]> */
		/* 820742E8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820742E8h case    4:*/		return 0x820742EC;
		  /* 820742ECh */ case    5:  		/* mr R31, R3 */
		/* 820742ECh case    5:*/		regs.R31 = regs.R3;
		/* 820742ECh case    5:*/		return 0x820742F0;
		  /* 820742F0h */ case    6:  		/* lwz R3, <#[R3 + 48]> */
		/* 820742F0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 820742F0h case    6:*/		return 0x820742F4;
		  /* 820742F4h */ case    7:  		/* cmplw CR6, R3, R11 */
		/* 820742F4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820742F4h case    7:*/		return 0x820742F8;
		  /* 820742F8h */ case    8:  		/* bc 4, CR6_GT, 12 */
		/* 820742F8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82074304;  }
		/* 820742F8h case    8:*/		return 0x820742FC;
		  /* 820742FCh */ case    9:  		/* mr R3, R31 */
		/* 820742FCh case    9:*/		regs.R3 = regs.R31;
		/* 820742FCh case    9:*/		return 0x82074300;
		  /* 82074300h */ case   10:  		/* bl -504 */
		/* 82074300h case   10:*/		regs.LR = 0x82074304; return 0x82074108;
		/* 82074300h case   10:*/		return 0x82074304;
	}
	return 0x82074304;
} // Block from 820742D8h-82074304h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82074304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074304);
		  /* 82074304h */ case    0:  		/* li R11, 1480 */
		/* 82074304h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x5C8);
		/* 82074304h case    0:*/		return 0x82074308;
		  /* 82074308h */ case    1:  		/* lis R10, 2 */
		/* 82074308h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x2);
		/* 82074308h case    1:*/		return 0x8207430C;
		  /* 8207430Ch */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 8207430Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207430Ch case    2:*/		return 0x82074310;
		  /* 82074310h */ case    3:  		/* li R11, 3332 */
		/* 82074310h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xD04);
		/* 82074310h case    3:*/		return 0x82074314;
		  /* 82074314h */ case    4:  		/* li R9, 0 */
		/* 82074314h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82074314h case    4:*/		return 0x82074318;
		  /* 82074318h */ case    5:  		/* stwu R10, <#[R3 + 4]> */
		/* 82074318h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82074318h case    5:*/		return 0x8207431C;
		  /* 8207431Ch */ case    6:  		/* stwu R11, <#[R3 + 4]> */
		/* 8207431Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207431Ch case    6:*/		return 0x82074320;
		  /* 82074320h */ case    7:  		/* stwu R9, <#[R3 + 4]> */
		/* 82074320h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82074320h case    7:*/		return 0x82074324;
		  /* 82074324h */ case    8:  		/* stw R3, <#[R31 + 48]> */
		/* 82074324h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82074324h case    8:*/		return 0x82074328;
		  /* 82074328h */ case    9:  		/* addi R1, R1, 96 */
		/* 82074328h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82074328h case    9:*/		return 0x8207432C;
		  /* 8207432Ch */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 8207432Ch case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8207432Ch case   10:*/		return 0x82074330;
		  /* 82074330h */ case   11:  		/* mtspr LR, R12 */
		/* 82074330h case   11:*/		regs.LR = regs.R12;
		/* 82074330h case   11:*/		return 0x82074334;
		  /* 82074334h */ case   12:  		/* ld R31, <#[R1 - 16]> */
		/* 82074334h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074334h case   12:*/		return 0x82074338;
		  /* 82074338h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82074338h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82074338h case   13:*/		return 0x8207433C;
	}
	return 0x8207433C;
} // Block from 82074304h-8207433Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8207433Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207433C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207433C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207433C);
		  /* 8207433Ch */ case    0:  		/* nop */
		/* 8207433Ch case    0:*/		cpu::op::nop();
		/* 8207433Ch case    0:*/		return 0x82074340;
	}
	return 0x82074340;
} // Block from 8207433Ch-82074340h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82074340h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074340);
		  /* 82074340h */ case    0:  		/* mfspr R12, LR */
		/* 82074340h case    0:*/		regs.R12 = regs.LR;
		/* 82074340h case    0:*/		return 0x82074344;
		  /* 82074344h */ case    1:  		/* bl 118552 */
		/* 82074344h case    1:*/		regs.LR = 0x82074348; return 0x8209125C;
		/* 82074344h case    1:*/		return 0x82074348;
		  /* 82074348h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82074348h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82074348h case    2:*/		return 0x8207434C;
		  /* 8207434Ch */ case    3:  		/* lwz R11, <#[R3 + 48]> */
		/* 8207434Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 8207434Ch case    3:*/		return 0x82074350;
		  /* 82074350h */ case    4:  		/* rlwinm R30, R4, 2, 0, 29 */
		/* 82074350h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R4);
		/* 82074350h case    4:*/		return 0x82074354;
		  /* 82074354h */ case    5:  		/* lwz R10, <#[R3 + 52]> */
		/* 82074354h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000034) );
		/* 82074354h case    5:*/		return 0x82074358;
		  /* 82074358h */ case    6:  		/* mr R31, R3 */
		/* 82074358h case    6:*/		regs.R31 = regs.R3;
		/* 82074358h case    6:*/		return 0x8207435C;
		  /* 8207435Ch */ case    7:  		/* add R11, R30, R11 */
		/* 8207435Ch case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8207435Ch case    7:*/		return 0x82074360;
		  /* 82074360h */ case    8:  		/* mr R29, R4 */
		/* 82074360h case    8:*/		regs.R29 = regs.R4;
		/* 82074360h case    8:*/		return 0x82074364;
		  /* 82074364h */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 82074364h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82074364h case    9:*/		return 0x82074368;
		  /* 82074368h */ case   10:  		/* bc 4, CR6_GT, 68 */
		/* 82074368h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820743AC;  }
		/* 82074368h case   10:*/		return 0x8207436C;
		  /* 8207436Ch */ case   11:  		/* bl -612 */
		/* 8207436Ch case   11:*/		regs.LR = 0x82074370; return 0x82074108;
		/* 8207436Ch case   11:*/		return 0x82074370;
		  /* 82074370h */ case   12:  		/* lwz R11, <#[R31 + 48]> */
		/* 82074370h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82074370h case   12:*/		return 0x82074374;
		  /* 82074374h */ case   13:  		/* lwz R10, <#[R31 + 52]> */
		/* 82074374h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000034) );
		/* 82074374h case   13:*/		return 0x82074378;
		  /* 82074378h */ case   14:  		/* add R11, R30, R11 */
		/* 82074378h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 82074378h case   14:*/		return 0x8207437C;
		  /* 8207437Ch */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 8207437Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8207437Ch case   15:*/		return 0x82074380;
		  /* 82074380h */ case   16:  		/* bc 4, CR6_GT, 44 */
		/* 82074380h case   16:*/		if ( !regs.CR[6].gt ) { return 0x820743AC;  }
		/* 82074380h case   16:*/		return 0x82074384;
		  /* 82074384h */ case   17:  		/* mr R4, R29 */
		/* 82074384h case   17:*/		regs.R4 = regs.R29;
		/* 82074384h case   17:*/		return 0x82074388;
		  /* 82074388h */ case   18:  		/* mr R3, R31 */
		/* 82074388h case   18:*/		regs.R3 = regs.R31;
		/* 82074388h case   18:*/		return 0x8207438C;
		  /* 8207438Ch */ case   19:  		/* bl -4964 */
		/* 8207438Ch case   19:*/		regs.LR = 0x82074390; return 0x82073028;
		/* 8207438Ch case   19:*/		return 0x82074390;
		  /* 82074390h */ case   20:  		/* cmplwi CR0, R3, 0 */
		/* 82074390h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82074390h case   20:*/		return 0x82074394;
		  /* 82074394h */ case   21:  		/* bc 4, CR0_EQ, 24 */
		/* 82074394h case   21:*/		if ( !regs.CR[0].eq ) { return 0x820743AC;  }
		/* 82074394h case   21:*/		return 0x82074398;
		  /* 82074398h */ case   22:  		/* lwz R11, <#[R31 + 48]> */
		/* 82074398h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82074398h case   22:*/		return 0x8207439C;
		  /* 8207439Ch */ case   23:  		/* lwz R10, <#[R31 + 52]> */
		/* 8207439Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000034) );
		/* 8207439Ch case   23:*/		return 0x820743A0;
		  /* 820743A0h */ case   24:  		/* add R11, R30, R11 */
		/* 820743A0h case   24:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 820743A0h case   24:*/		return 0x820743A4;
		  /* 820743A4h */ case   25:  		/* cmplw CR6, R11, R10 */
		/* 820743A4h case   25:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820743A4h case   25:*/		return 0x820743A8;
		  /* 820743A8h */ case   26:  		/* bc 12, CR6_GT, 8 */
		/* 820743A8h case   26:*/		if ( regs.CR[6].gt ) { return 0x820743B0;  }
		/* 820743A8h case   26:*/		return 0x820743AC;
	}
	return 0x820743AC;
} // Block from 82074340h-820743ACh (27 instructions)

//////////////////////////////////////////////////////
// Block at 820743ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820743AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820743AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820743AC);
		  /* 820743ACh */ case    0:  		/* lwz R3, <#[R31 + 48]> */
		/* 820743ACh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 820743ACh case    0:*/		return 0x820743B0;
	}
	return 0x820743B0;
} // Block from 820743ACh-820743B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820743B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820743B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820743B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820743B0);
		  /* 820743B0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820743B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820743B0h case    0:*/		return 0x820743B4;
		  /* 820743B4h */ case    1:  		/* b 118520 */
		/* 820743B4h case    1:*/		return 0x820912AC;
		/* 820743B4h case    1:*/		return 0x820743B8;
	}
	return 0x820743B8;
} // Block from 820743B0h-820743B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820743B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820743B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820743B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820743B8);
		  /* 820743B8h */ case    0:  		/* mfspr R12, LR */
		/* 820743B8h case    0:*/		regs.R12 = regs.LR;
		/* 820743B8h case    0:*/		return 0x820743BC;
		  /* 820743BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820743BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820743BCh case    1:*/		return 0x820743C0;
		  /* 820743C0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820743C0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820743C0h case    2:*/		return 0x820743C4;
		  /* 820743C4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820743C4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820743C4h case    3:*/		return 0x820743C8;
		  /* 820743C8h */ case    4:  		/* lwz R10, <#[R3 + 56]> */
		/* 820743C8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000038) );
		/* 820743C8h case    4:*/		return 0x820743CC;
		  /* 820743CCh */ case    5:  		/* mr R31, R3 */
		/* 820743CCh case    5:*/		regs.R31 = regs.R3;
		/* 820743CCh case    5:*/		return 0x820743D0;
		  /* 820743D0h */ case    6:  		/* lwz R11, <#[R3 + 48]> */
		/* 820743D0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820743D0h case    6:*/		return 0x820743D4;
		  /* 820743D4h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820743D4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820743D4h case    7:*/		return 0x820743D8;
		  /* 820743D8h */ case    8:  		/* bc 4, CR6_GT, 12 */
		/* 820743D8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820743E4;  }
		/* 820743D8h case    8:*/		return 0x820743DC;
		  /* 820743DCh */ case    9:  		/* bl -724 */
		/* 820743DCh case    9:*/		regs.LR = 0x820743E0; return 0x82074108;
		/* 820743DCh case    9:*/		return 0x820743E0;
		  /* 820743E0h */ case   10:  		/* mr R11, R3 */
		/* 820743E0h case   10:*/		regs.R11 = regs.R3;
		/* 820743E0h case   10:*/		return 0x820743E4;
	}
	return 0x820743E4;
} // Block from 820743B8h-820743E4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820743E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820743E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820743E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820743E4);
		  /* 820743E4h */ case    0:  		/* li R10, 1480 */
		/* 820743E4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x5C8);
		/* 820743E4h case    0:*/		return 0x820743E8;
		  /* 820743E8h */ case    1:  		/* lis R9, 2 */
		/* 820743E8h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0x2);
		/* 820743E8h case    1:*/		return 0x820743EC;
		  /* 820743ECh */ case    2:  		/* stwu R10, <#[R11 + 4]> */
		/* 820743ECh case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820743ECh case    2:*/		return 0x820743F0;
		  /* 820743F0h */ case    3:  		/* li R7, 0 */
		/* 820743F0h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820743F0h case    3:*/		return 0x820743F4;
		  /* 820743F4h */ case    4:  		/* li R6, 0 */
		/* 820743F4h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820743F4h case    4:*/		return 0x820743F8;
		  /* 820743F8h */ case    5:  		/* li R5, 4 */
		/* 820743F8h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820743F8h case    5:*/		return 0x820743FC;
		  /* 820743FCh */ case    6:  		/* mr R3, R31 */
		/* 820743FCh case    6:*/		regs.R3 = regs.R31;
		/* 820743FCh case    6:*/		return 0x82074400;
		  /* 82074400h */ case    7:  		/* stwu R9, <#[R11 + 4]> */
		/* 82074400h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82074400h case    7:*/		return 0x82074404;
		  /* 82074404h */ case    8:  		/* lwz R4, <#[R31 + 11036]> */
		/* 82074404h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00002B1C) );
		/* 82074404h case    8:*/		return 0x82074408;
		  /* 82074408h */ case    9:  		/* stw R11, <#[R31 + 48]> */
		/* 82074408h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82074408h case    9:*/		return 0x8207440C;
		  /* 8207440Ch */ case   10:  		/* bl -5860 */
		/* 8207440Ch case   10:*/		regs.LR = 0x82074410; return 0x82072D28;
		/* 8207440Ch case   10:*/		return 0x82074410;
		  /* 82074410h */ case   11:  		/* lwz R11, <#[R31 + 11152]> */
		/* 82074410h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B90) );
		/* 82074410h case   11:*/		return 0x82074414;
		  /* 82074414h */ case   12:  		/* cmpwi CR6, R11, 0 */
		/* 82074414h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82074414h case   12:*/		return 0x82074418;
		  /* 82074418h */ case   13:  		/* bc 4, CR6_EQ, -8 */
		/* 82074418h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82074410;  }
		/* 82074418h case   13:*/		return 0x8207441C;
		  /* 8207441Ch */ case   14:  		/* addi R1, R1, 96 */
		/* 8207441Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8207441Ch case   14:*/		return 0x82074420;
		  /* 82074420h */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 82074420h case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074420h case   15:*/		return 0x82074424;
		  /* 82074424h */ case   16:  		/* mtspr LR, R12 */
		/* 82074424h case   16:*/		regs.LR = regs.R12;
		/* 82074424h case   16:*/		return 0x82074428;
		  /* 82074428h */ case   17:  		/* ld R31, <#[R1 - 16]> */
		/* 82074428h case   17:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074428h case   17:*/		return 0x8207442C;
		  /* 8207442Ch */ case   18:  		/* bclr 20, CR0_LT */
		/* 8207442Ch case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8207442Ch case   18:*/		return 0x82074430;
	}
	return 0x82074430;
} // Block from 820743E4h-82074430h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82074430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074430);
		  /* 82074430h */ case    0:  		/* mfspr R12, LR */
		/* 82074430h case    0:*/		regs.R12 = regs.LR;
		/* 82074430h case    0:*/		return 0x82074434;
		  /* 82074434h */ case    1:  		/* bl 118288 */
		/* 82074434h case    1:*/		regs.LR = 0x82074438; return 0x82091244;
		/* 82074434h case    1:*/		return 0x82074438;
		  /* 82074438h */ case    2:  		/* stwu R1, <#[R1 - 320]> */
		/* 82074438h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEC0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEC0);
		/* 82074438h case    2:*/		return 0x8207443C;
		  /* 8207443Ch */ case    3:  		/* lwz R11, <#[R3 + 11036]> */
		/* 8207443Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B1C) );
		/* 8207443Ch case    3:*/		return 0x82074440;
		  /* 82074440h */ case    4:  		/* mr R31, R3 */
		/* 82074440h case    4:*/		regs.R31 = regs.R3;
		/* 82074440h case    4:*/		return 0x82074444;
		  /* 82074444h */ case    5:  		/* mr R27, R4 */
		/* 82074444h case    5:*/		regs.R27 = regs.R4;
		/* 82074444h case    5:*/		return 0x82074448;
		  /* 82074448h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82074448h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82074448h case    6:*/		return 0x8207444C;
		  /* 8207444Ch */ case    7:  		/* bc 12, CR6_EQ, 48 */
		/* 8207444Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8207447C;  }
		/* 8207444Ch case    7:*/		return 0x82074450;
		  /* 82074450h */ case    8:  		/* lwz R11, <#[R3 + 48]> */
		/* 82074450h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 82074450h case    8:*/		return 0x82074454;
		  /* 82074454h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82074454h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82074454h case    9:*/		return 0x82074458;
		  /* 82074458h */ case   10:  		/* bc 12, CR6_EQ, 36 */
		/* 82074458h case   10:*/		if ( regs.CR[6].eq ) { return 0x8207447C;  }
		/* 82074458h case   10:*/		return 0x8207445C;
		  /* 8207445Ch */ case   11:  		/* bl -164 */
		/* 8207445Ch case   11:*/		regs.LR = 0x82074460; return 0x820743B8;
		/* 8207445Ch case   11:*/		return 0x82074460;
		  /* 82074460h */ case   12:  		/* b 12 */
		/* 82074460h case   12:*/		return 0x8207446C;
		/* 82074460h case   12:*/		return 0x82074464;
		  /* 82074464h */ case   13:  		/* li R3, 1 */
		/* 82074464h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82074464h case   13:*/		return 0x82074468;
		  /* 82074468h */ case   14:  		/* bl 81872 */
		/* 82074468h case   14:*/		regs.LR = 0x8207446C; return 0x82088438;
		/* 82074468h case   14:*/		return 0x8207446C;
	}
	return 0x8207446C;
} // Block from 82074430h-8207446Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8207446Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207446C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207446C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207446C);
		  /* 8207446Ch */ case    0:  		/* lwz R10, <#[R31 + 11120]> */
		/* 8207446Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B70) );
		/* 8207446Ch case    0:*/		return 0x82074470;
	}
	return 0x82074470;
} // Block from 8207446Ch-82074470h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82074470h
// Function '?BlockOnPrimaryRange@CDevice@D3D@@QAAKKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074470);
		  /* 82074470h */ case    0:  		/* lwz R11, <#[R31 + 11124]> */
		/* 82074470h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B74) );
		/* 82074470h case    0:*/		return 0x82074474;
		  /* 82074474h */ case    1:  		/* cmpw CR6, R11, R10 */
		/* 82074474h case    1:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82074474h case    1:*/		return 0x82074478;
		  /* 82074478h */ case    2:  		/* bc 4, CR6_EQ, -20 */
		/* 82074478h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82074464;  }
		/* 82074478h case    2:*/		return 0x8207447C;
	}
	return 0x8207447C;
} // Block from 82074470h-8207447Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8207447Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207447C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207447C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207447C);
		  /* 8207447Ch */ case    0:  		/* lwz R11, <#[R31 + 15308]> */
		/* 8207447Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003BCC) );
		/* 8207447Ch case    0:*/		return 0x82074480;
		  /* 82074480h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82074480h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82074480h case    1:*/		return 0x82074484;
		  /* 82074484h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 82074484h case    2:*/		if ( regs.CR[6].eq ) { return 0x820744C8;  }
		/* 82074484h case    2:*/		return 0x82074488;
		  /* 82074488h */ case    3:  		/* lwz R8, <#[R31 + 15312]> */
		/* 82074488h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00003BD0) );
		/* 82074488h case    3:*/		return 0x8207448C;
		  /* 8207448Ch */ case    4:  		/* rlwinm R10, R11, 12, 20, 31 */
		/* 8207448Ch case    4:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R11);
		/* 8207448Ch case    4:*/		return 0x82074490;
		  /* 82074490h */ case    5:  		/* rlwinm R9, R11, 0, 3, 31 */
		/* 82074490h case    5:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R9,regs.R11);
		/* 82074490h case    5:*/		return 0x82074494;
		  /* 82074494h */ case    6:  		/* rlwinm R11, R8, 12, 20, 31 */
		/* 82074494h case    6:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R8);
		/* 82074494h case    6:*/		return 0x82074498;
		  /* 82074498h */ case    7:  		/* addi R7, R10, 512 */
		/* 82074498h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x200);
		/* 82074498h case    7:*/		return 0x8207449C;
		  /* 8207449Ch */ case    8:  		/* addi R10, R11, 512 */
		/* 8207449Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x200);
		/* 8207449Ch case    8:*/		return 0x820744A0;
		  /* 820744A0h */ case    9:  		/* rlwinm R11, R8, 0, 3, 31 */
		/* 820744A0h case    9:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R11,regs.R8);
		/* 820744A0h case    9:*/		return 0x820744A4;
		  /* 820744A4h */ case   10:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 820744A4h case   10:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 820744A4h case   10:*/		return 0x820744A8;
		  /* 820744A8h */ case   11:  		/* rlwinm R8, R7, 0, 19, 19 */
		/* 820744A8h case   11:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R8,regs.R7);
		/* 820744A8h case   11:*/		return 0x820744AC;
		  /* 820744ACh */ case   12:  		/* add R11, R10, R11 */
		/* 820744ACh case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820744ACh case   12:*/		return 0x820744B0;
		  /* 820744B0h */ case   13:  		/* lis R7, 16384 */
		/* 820744B0h case   13:*/		cpu::op::lis<0>(regs,&regs.R7,0x4000);
		/* 820744B0h case   13:*/		return 0x820744B4;
		  /* 820744B4h */ case   14:  		/* add R10, R8, R9 */
		/* 820744B4h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R9);
		/* 820744B4h case   14:*/		return 0x820744B8;
		  /* 820744B8h */ case   15:  		/* li R5, 0 */
		/* 820744B8h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820744B8h case   15:*/		return 0x820744BC;
		  /* 820744BCh */ case   16:  		/* subf R4, R7, R11 */
		/* 820744BCh case   16:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R7,regs.R11);
		/* 820744BCh case   16:*/		return 0x820744C0;
		  /* 820744C0h */ case   17:  		/* subf R3, R7, R10 */
		/* 820744C0h case   17:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R7,regs.R10);
		/* 820744C0h case   17:*/		return 0x820744C4;
		  /* 820744C4h */ case   18:  		/* bl 68868 */
		/* 820744C4h case   18:*/		regs.LR = 0x820744C8; return 0x820851C8;
		/* 820744C4h case   18:*/		return 0x820744C8;
	}
	return 0x820744C8;
} // Block from 8207447Ch-820744C8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820744C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820744C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820744C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820744C8);
		  /* 820744C8h */ case    0:  		/* lis R4, -20096 */
		/* 820744C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB180);
		/* 820744C8h case    0:*/		return 0x820744CC;
		  /* 820744CCh */ case    1:  		/* lwz R3, <#[R31 + 15240]> */
		/* 820744CCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00003B88) );
		/* 820744CCh case    1:*/		return 0x820744D0;
		  /* 820744D0h */ case    2:  		/* bl 81512 */
		/* 820744D0h case    2:*/		regs.LR = 0x820744D4; return 0x82088338;
		/* 820744D0h case    2:*/		return 0x820744D4;
		  /* 820744D4h */ case    3:  		/* lis R4, -20096 */
		/* 820744D4h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB180);
		/* 820744D4h case    3:*/		return 0x820744D8;
		  /* 820744D8h */ case    4:  		/* lwz R3, <#[R31 + 15244]> */
		/* 820744D8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00003B8C) );
		/* 820744D8h case    4:*/		return 0x820744DC;
		  /* 820744DCh */ case    5:  		/* bl 81500 */
		/* 820744DCh case    5:*/		regs.LR = 0x820744E0; return 0x82088338;
		/* 820744DCh case    5:*/		return 0x820744E0;
		  /* 820744E0h */ case    6:  		/* li R29, 0 */
		/* 820744E0h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820744E0h case    6:*/		return 0x820744E4;
		  /* 820744E4h */ case    7:  		/* li R3, 0 */
		/* 820744E4h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820744E4h case    7:*/		return 0x820744E8;
		  /* 820744E8h */ case    8:  		/* stw R29, <#[R31 + 15240]> */
		/* 820744E8h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00003B88) );
		/* 820744E8h case    8:*/		return 0x820744EC;
		  /* 820744ECh */ case    9:  		/* stw R29, <#[R31 + 15244]> */
		/* 820744ECh case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00003B8C) );
		/* 820744ECh case    9:*/		return 0x820744F0;
		  /* 820744F0h */ case   10:  		/* stw R29, <#[R31 + 48]> */
		/* 820744F0h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000030) );
		/* 820744F0h case   10:*/		return 0x820744F4;
		  /* 820744F4h */ case   11:  		/* stw R29, <#[R31 + 52]> */
		/* 820744F4h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000034) );
		/* 820744F4h case   11:*/		return 0x820744F8;
		  /* 820744F8h */ case   12:  		/* bl 2067216 */
		/* 820744F8h case   12:*/		regs.LR = 0x820744FC; return 0x8226D008;
		/* 820744F8h case   12:*/		return 0x820744FC;
		  /* 820744FCh */ case   13:  		/* cmplwi CR6, R27, 0 */
		/* 820744FCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820744FCh case   13:*/		return 0x82074500;
		  /* 82074500h */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 82074500h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8207450C;  }
		/* 82074500h case   14:*/		return 0x82074504;
		  /* 82074504h */ case   15:  		/* li R3, 0 */
		/* 82074504h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82074504h case   15:*/		return 0x82074508;
		  /* 82074508h */ case   16:  		/* b 744 */
		/* 82074508h case   16:*/		return 0x820747F0;
		/* 82074508h case   16:*/		return 0x8207450C;
	}
	return 0x8207450C;
} // Block from 820744C8h-8207450Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8207450Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207450C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207450C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207450C);
		  /* 8207450Ch */ case    0:  		/* lwz R25, <#[R27 + 4]> */
		/* 8207450Ch case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R27 + 0x00000004) );
		/* 8207450Ch case    0:*/		return 0x82074510;
		  /* 82074510h */ case    1:  		/* lwz R26, <#[R27 + 8]> */
		/* 82074510h case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R27 + 0x00000008) );
		/* 82074510h case    1:*/		return 0x82074514;
		  /* 82074514h */ case    2:  		/* lwz R28, <#[R27 + 12]> */
		/* 82074514h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R27 + 0x0000000C) );
		/* 82074514h case    2:*/		return 0x82074518;
		  /* 82074518h */ case    3:  		/* cmplwi CR6, R25, 0 */
		/* 82074518h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82074518h case    3:*/		return 0x8207451C;
		  /* 8207451Ch */ case    4:  		/* lwz R30, <#[R27 + 16]> */
		/* 8207451Ch case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000010) );
		/* 8207451Ch case    4:*/		return 0x82074520;
		  /* 82074520h */ case    5:  		/* lwz R11, <#[R27 + 20]> */
		/* 82074520h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 82074520h case    5:*/		return 0x82074524;
		  /* 82074524h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 82074524h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82074530;  }
		/* 82074524h case    6:*/		return 0x82074528;
		  /* 82074528h */ case    7:  		/* lis R25, 0 */
		/* 82074528h case    7:*/		cpu::op::lis<0>(regs,&regs.R25,0x0);
		/* 82074528h case    7:*/		return 0x8207452C;
		  /* 8207452Ch */ case    8:  		/* ori R25, R25, 32768 */
		/* 8207452Ch case    8:*/		cpu::op::ori<0>(regs,&regs.R25,regs.R25,0x8000);
		/* 8207452Ch case    8:*/		return 0x82074530;
	}
	return 0x82074530;
} // Block from 8207450Ch-82074530h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82074530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074530);
		  /* 82074530h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 82074530h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82074530h case    0:*/		return 0x82074534;
		  /* 82074534h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82074534h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8207453C;  }
		/* 82074534h case    1:*/		return 0x82074538;
	}
	return 0x82074538;
} // Block from 82074530h-82074538h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82074538h
// Function '?AddCommandsToPrimaryBuffer@CDevice@D3D@@QAAXPBKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074538);
		  /* 82074538h */ case    0:  		/* lis R28, 32 */
		/* 82074538h case    0:*/		cpu::op::lis<0>(regs,&regs.R28,0x20);
		/* 82074538h case    0:*/		return 0x8207453C;
	}
	return 0x8207453C;
} // Block from 82074538h-8207453Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8207453Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207453C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207453C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207453C);
		  /* 8207453Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8207453Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8207453Ch case    0:*/		return 0x82074540;
		  /* 82074540h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82074540h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82074548;  }
		/* 82074540h case    1:*/		return 0x82074544;
		  /* 82074544h */ case    2:  		/* li R11, 32 */
		/* 82074544h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x20);
		/* 82074544h case    2:*/		return 0x82074548;
	}
	return 0x82074548;
} // Block from 8207453Ch-82074548h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82074548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074548);
		  /* 82074548h */ case    0:  		/* divwu R27, R28, R11 */
		/* 82074548h case    0:*/		cpu::op::divwu<0>(regs,&regs.R27,regs.R28,regs.R11);
		/* 82074548h case    0:*/		return 0x8207454C;
		  /* 8207454Ch */ case    1:  		/* twi 6, R11, 0 */
		/* 8207454Ch case    1:*/		cpu::op::tw<6>(regs, 0x8207454C, regs.R11, 0x00000000);
		/* 8207454Ch case    1:*/		return 0x82074550;
		  /* 82074550h */ case    2:  		/* cmplwi CR6, R26, 0 */
		/* 82074550h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82074550h case    2:*/		return 0x82074554;
		  /* 82074554h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82074554h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8207456C;  }
		/* 82074554h case    3:*/		return 0x82074558;
		  /* 82074558h */ case    4:  		/* lis R4, -19072 */
		/* 82074558h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB580);
		/* 82074558h case    4:*/		return 0x8207455C;
		  /* 8207455Ch */ case    5:  		/* mr R3, R25 */
		/* 8207455Ch case    5:*/		regs.R3 = regs.R25;
		/* 8207455Ch case    5:*/		return 0x82074560;
		  /* 82074560h */ case    6:  		/* bl 81056 */
		/* 82074560h case    6:*/		regs.LR = 0x82074564; return 0x82088200;
		/* 82074560h case    6:*/		return 0x82074564;
		  /* 82074564h */ case    7:  		/* mr R26, R3 */
		/* 82074564h case    7:*/		regs.R26 = regs.R3;
		/* 82074564h case    7:*/		return 0x82074568;
		  /* 82074568h */ case    8:  		/* stw R3, <#[R31 + 15240]> */
		/* 82074568h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00003B88) );
		/* 82074568h case    8:*/		return 0x8207456C;
	}
	return 0x8207456C;
} // Block from 82074548h-8207456Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8207456Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207456C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207456C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207456C);
		  /* 8207456Ch */ case    0:  		/* li R24, 3 */
		/* 8207456Ch case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x3);
		/* 8207456Ch case    0:*/		return 0x82074570;
		  /* 82074570h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82074570h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82074570h case    1:*/		return 0x82074574;
		  /* 82074574h */ case    2:  		/* bc 4, CR6_EQ, 44 */
		/* 82074574h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820745A0;  }
		/* 82074574h case    2:*/		return 0x82074578;
		  /* 82074578h */ case    3:  		/* lis R11, 8 */
		/* 82074578h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x8);
		/* 82074578h case    3:*/		return 0x8207457C;
		  /* 8207457Ch */ case    4:  		/* lis R4, -30848 */
		/* 8207457Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8780);
		/* 8207457Ch case    4:*/		return 0x82074580;
		  /* 82074580h */ case    5:  		/* subfc R11, R11, R28 */
		/* 82074580h case    5:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 82074580h case    5:*/		return 0x82074584;
		  /* 82074584h */ case    6:  		/* mr R3, R28 */
		/* 82074584h case    6:*/		regs.R3 = regs.R28;
		/* 82074584h case    6:*/		return 0x82074588;
		  /* 82074588h */ case    7:  		/* subfe R11, R11, R11 */
		/* 82074588h case    7:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82074588h case    7:*/		return 0x8207458C;
		  /* 8207458Ch */ case    8:  		/* and R11, R11, R24 */
		/* 8207458Ch case    8:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R24);
		/* 8207458Ch case    8:*/		return 0x82074590;
		  /* 82074590h */ case    9:  		/* rlwimi R4, R11, 28, 1, 3 */
		/* 82074590h case    9:*/		cpu::op::rlwimi<0,28,1,3>(regs,&regs.R4,regs.R11);
		/* 82074590h case    9:*/		return 0x82074594;
		  /* 82074594h */ case   10:  		/* bl 81004 */
		/* 82074594h case   10:*/		regs.LR = 0x82074598; return 0x82088200;
		/* 82074594h case   10:*/		return 0x82074598;
		  /* 82074598h */ case   11:  		/* mr R30, R3 */
		/* 82074598h case   11:*/		regs.R30 = regs.R3;
		/* 82074598h case   11:*/		return 0x8207459C;
		  /* 8207459Ch */ case   12:  		/* stw R3, <#[R31 + 15244]> */
		/* 8207459Ch case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00003B8C) );
		/* 8207459Ch case   12:*/		return 0x820745A0;
	}
	return 0x820745A0;
} // Block from 8207456Ch-820745A0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820745A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820745A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820745A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820745A0);
		  /* 820745A0h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 820745A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 820745A0h case    0:*/		return 0x820745A4;
		  /* 820745A4h */ case    1:  		/* bc 12, CR6_EQ, 580 */
		/* 820745A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820747E8;  }
		/* 820745A4h case    1:*/		return 0x820745A8;
		  /* 820745A8h */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 820745A8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820745A8h case    2:*/		return 0x820745AC;
		  /* 820745ACh */ case    3:  		/* bc 12, CR6_EQ, 572 */
		/* 820745ACh case    3:*/		if ( regs.CR[6].eq ) { return 0x820747E8;  }
		/* 820745ACh case    3:*/		return 0x820745B0;
		  /* 820745B0h */ case    4:  		/* cntlzw R11, R25 */
		/* 820745B0h case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R25);
		/* 820745B0h case    4:*/		return 0x820745B4;
		  /* 820745B4h */ case    5:  		/* mr R3, R26 */
		/* 820745B4h case    5:*/		regs.R3 = regs.R26;
		/* 820745B4h case    5:*/		return 0x820745B8;
		  /* 820745B8h */ case    6:  		/* subfic R23, R11, 28 */
		/* 820745B8h case    6:*/		cpu::op::subfic<0>(regs,&regs.R23,regs.R11,0x1C);
		/* 820745B8h case    6:*/		return 0x820745BC;
		  /* 820745BCh */ case    7:  		/* bl 2067004 */
		/* 820745BCh case    7:*/		regs.LR = 0x820745C0; return 0x8226CFF8;
		/* 820745BCh case    7:*/		return 0x820745C0;
		  /* 820745C0h */ case    8:  		/* mr R4, R23 */
		/* 820745C0h case    8:*/		regs.R4 = regs.R23;
		/* 820745C0h case    8:*/		return 0x820745C4;
		  /* 820745C4h */ case    9:  		/* bl 2066980 */
		/* 820745C4h case    9:*/		regs.LR = 0x820745C8; return 0x8226CFE8;
		/* 820745C4h case    9:*/		return 0x820745C8;
		  /* 820745C8h */ case   10:  		/* rlwinm R11, R25, 23, 9, 31 */
		/* 820745C8h case   10:*/		cpu::op::rlwinm<0,23,9,31>(regs,&regs.R11,regs.R25);
		/* 820745C8h case   10:*/		return 0x820745CC;
		  /* 820745CCh */ case   11:  		/* cntlzw R11, R11 */
		/* 820745CCh case   11:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820745CCh case   11:*/		return 0x820745D0;
		  /* 820745D0h */ case   12:  		/* subfic R4, R11, 31 */
		/* 820745D0h case   12:*/		cpu::op::subfic<0>(regs,&regs.R4,regs.R11,0x1F);
		/* 820745D0h case   12:*/		return 0x820745D4;
		  /* 820745D4h */ case   13:  		/* cmplwi CR6, R4, 19 */
		/* 820745D4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000013);
		/* 820745D4h case   13:*/		return 0x820745D8;
		  /* 820745D8h */ case   14:  		/* bc 4, CR6_GT, 8 */
		/* 820745D8h case   14:*/		if ( !regs.CR[6].gt ) { return 0x820745E0;  }
		/* 820745D8h case   14:*/		return 0x820745DC;
		  /* 820745DCh */ case   15:  		/* li R4, 19 */
		/* 820745DCh case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x13);
		/* 820745DCh case   15:*/		return 0x820745E0;
	}
	return 0x820745E0;
} // Block from 820745A0h-820745E0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820745E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820745E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820745E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820745E0);
		  /* 820745E0h */ case    0:  		/* lwz R11, <#[R31 + 11024]> */
		/* 820745E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 820745E0h case    0:*/		return 0x820745E4;
		  /* 820745E4h */ case    1:  		/* addi R11, R11, 60 */
		/* 820745E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3C);
		/* 820745E4h case    1:*/		return 0x820745E8;
		  /* 820745E8h */ case    2:  		/* rlwinm R10, R11, 12, 20, 31 */
		/* 820745E8h case    2:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R11);
		/* 820745E8h case    2:*/		return 0x820745EC;
		  /* 820745ECh */ case    3:  		/* rlwinm R11, R11, 0, 3, 31 */
		/* 820745ECh case    3:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R11,regs.R11);
		/* 820745ECh case    3:*/		return 0x820745F0;
		  /* 820745F0h */ case    4:  		/* addi R10, R10, 512 */
		/* 820745F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 820745F0h case    4:*/		return 0x820745F4;
		  /* 820745F4h */ case    5:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 820745F4h case    5:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 820745F4h case    5:*/		return 0x820745F8;
		  /* 820745F8h */ case    6:  		/* add R3, R10, R11 */
		/* 820745F8h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 820745F8h case    6:*/		return 0x820745FC;
		  /* 820745FCh */ case    7:  		/* bl 2066908 */
		/* 820745FCh case    7:*/		regs.LR = 0x82074600; return 0x8226CFD8;
		/* 820745FCh case    7:*/		return 0x82074600;
		  /* 82074600h */ case    8:  		/* rlwinm R11, R28, 0, 0, 29 */
		/* 82074600h case    8:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R28);
		/* 82074600h case    8:*/		return 0x82074604;
		  /* 82074604h */ case    9:  		/* lis R9, 2989 */
		/* 82074604h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xBAD);
		/* 82074604h case    9:*/		return 0x82074608;
		  /* 82074608h */ case   10:  		/* add R11, R11, R30 */
		/* 82074608h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82074608h case   10:*/		return 0x8207460C;
		  /* 8207460Ch */ case   11:  		/* ori R7, R9, 61453 */
		/* 8207460Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R9,0xF00D);
		/* 8207460Ch case   11:*/		return 0x82074610;
		  /* 82074610h */ case   12:  		/* rlwinm R8, R25, 30, 2, 31 */
		/* 82074610h case   12:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R8,regs.R25);
		/* 82074610h case   12:*/		return 0x82074614;
		  /* 82074614h */ case   13:  		/* rlwinm R10, R27, 0, 0, 29 */
		/* 82074614h case   13:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R27);
		/* 82074614h case   13:*/		return 0x82074618;
		  /* 82074618h */ case   14:  		/* addi R9, R11, -4 */
		/* 82074618h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFC);
		/* 82074618h case   14:*/		return 0x8207461C;
		  /* 8207461Ch */ case   15:  		/* stw R7, <#[R11 - 4]> */
		/* 8207461Ch case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 8207461Ch case   15:*/		return 0x82074620;
		  /* 82074620h */ case   16:  		/* rlwinm R11, R28, 30, 2, 31 */
		/* 82074620h case   16:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R28);
		/* 82074620h case   16:*/		return 0x82074624;
		  /* 82074624h */ case   17:  		/* add R10, R10, R30 */
		/* 82074624h case   17:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 82074624h case   17:*/		return 0x82074628;
		  /* 82074628h */ case   18:  		/* stw R9, <#[R31 + 15312]> */
		/* 82074628h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00003BD0) );
		/* 82074628h case   18:*/		return 0x8207462C;
		  /* 8207462Ch */ case   19:  		/* addi R8, R8, -1 */
		/* 8207462Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 8207462Ch case   19:*/		return 0x82074630;
		  /* 82074630h */ case   20:  		/* stw R11, <#[R31 + 15340]> */
		/* 82074630h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00003BEC) );
		/* 82074630h case   20:*/		return 0x82074634;
		  /* 82074634h */ case   21:  		/* stw R26, <#[R31 + 15300]> */
		/* 82074634h case   21:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00003BC4) );
		/* 82074634h case   21:*/		return 0x82074638;
		  /* 82074638h */ case   22:  		/* addi R9, R30, -4 */
		/* 82074638h case   22:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0xFFFFFFFC);
		/* 82074638h case   22:*/		return 0x8207463C;
		  /* 8207463Ch */ case   23:  		/* stw R30, <#[R31 + 15308]> */
		/* 8207463Ch case   23:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00003BCC) );
		/* 8207463Ch case   23:*/		return 0x82074640;
		  /* 82074640h */ case   24:  		/* addi R7, R10, -160 */
		/* 82074640h case   24:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFF60);
		/* 82074640h case   24:*/		return 0x82074644;
		  /* 82074644h */ case   25:  		/* stw R30, <#[R31 + 15328]> */
		/* 82074644h case   25:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00003BE0) );
		/* 82074644h case   25:*/		return 0x82074648;
		  /* 82074648h */ case   26:  		/* stw R30, <#[R31 + 15332]> */
		/* 82074648h case   26:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00003BE4) );
		/* 82074648h case   26:*/		return 0x8207464C;
		  /* 8207464Ch */ case   27:  		/* stw R27, <#[R31 + 15316]> */
		/* 8207464Ch case   27:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00003BD4) );
		/* 8207464Ch case   27:*/		return 0x82074650;
	}
	return 0x82074650;
} // Block from 820745E0h-82074650h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82074650h
// Function '?AddCallsToPrimaryBuffer@CDevice@D3D@@QAAXPBUSegmentCall@2@K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074650);
		  /* 82074650h */ case    0:  		/* stw R8, <#[R31 + 15304]> */
		/* 82074650h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00003BC8) );
		/* 82074650h case    0:*/		return 0x82074654;
		  /* 82074654h */ case    1:  		/* lwz R11, <#[R31 + 11024]> */
		/* 82074654h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 82074654h case    1:*/		return 0x82074658;
		  /* 82074658h */ case    2:  		/* stw R29, <#[R11 + 60]> */
		/* 82074658h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x0000003C) );
		/* 82074658h case    2:*/		return 0x8207465C;
		  /* 8207465Ch */ case    3:  		/* lwz R11, <#[R31 + 11036]> */
		/* 8207465Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B1C) );
		/* 8207465Ch case    3:*/		return 0x82074660;
		  /* 82074660h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82074660h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82074660h case    4:*/		return 0x82074664;
		  /* 82074664h */ case    5:  		/* stw R29, <#[R31 + 11088]> */
		/* 82074664h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00002B50) );
		/* 82074664h case    5:*/		return 0x82074668;
		  /* 82074668h */ case    6:  		/* stw R9, <#[R31 + 48]> */
		/* 82074668h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000030) );
		/* 82074668h case    6:*/		return 0x8207466C;
		  /* 8207466Ch */ case    7:  		/* stw R10, <#[R31 + 52]> */
		/* 8207466Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000034) );
		/* 8207466Ch case    7:*/		return 0x82074670;
		  /* 82074670h */ case    8:  		/* stw R7, <#[R31 + 56]> */
		/* 82074670h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000038) );
		/* 82074670h case    8:*/		return 0x82074674;
		  /* 82074674h */ case    9:  		/* stw R29, <#[R31 + 15320]> */
		/* 82074674h case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00003BD8) );
		/* 82074674h case    9:*/		return 0x82074678;
		  /* 82074678h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 82074678h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82074680;  }
		/* 82074678h case   10:*/		return 0x8207467C;
		  /* 8207467Ch */ case   11:  		/* stw R24, <#[R31 + 11036]> */
		/* 8207467Ch case   11:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00002B1C) );
		/* 8207467Ch case   11:*/		return 0x82074680;
	}
	return 0x82074680;
} // Block from 82074650h-82074680h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82074680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074680);
		  /* 82074680h */ case    0:  		/* lwz R11, <#[R31 + 11036]> */
		/* 82074680h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B1C) );
		/* 82074680h case    0:*/		return 0x82074684;
		  /* 82074684h */ case    1:  		/* lwz R10, <#[R31 + 11024]> */
		/* 82074684h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B10) );
		/* 82074684h case    1:*/		return 0x82074688;
		  /* 82074688h */ case    2:  		/* addi R11, R11, -2 */
		/* 82074688h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 82074688h case    2:*/		return 0x8207468C;
		  /* 8207468Ch */ case    3:  		/* stw R11, <#[R10]> */
		/* 8207468Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8207468Ch case    3:*/		return 0x82074690;
		  /* 82074690h */ case    4:  		/* lwz R11, <#[R31 + 48]> */
		/* 82074690h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82074690h case    4:*/		return 0x82074694;
		  /* 82074694h */ case    5:  		/* lwz R10, <#[R31 + 11024]> */
		/* 82074694h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B10) );
		/* 82074694h case    5:*/		return 0x82074698;
		  /* 82074698h */ case    6:  		/* lwz R9, <#[R31 + 15324]> */
		/* 82074698h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003BDC) );
		/* 82074698h case    6:*/		return 0x8207469C;
		  /* 8207469Ch */ case    7:  		/* rlwinm R9, R9, 0, 30, 31 */
		/* 8207469Ch case    7:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R9);
		/* 8207469Ch case    7:*/		return 0x820746A0;
		  /* 820746A0h */ case    8:  		/* or R11, R9, R11 */
		/* 820746A0h case    8:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820746A0h case    8:*/		return 0x820746A4;
		  /* 820746A4h */ case    9:  		/* stw R11, <#[R10 + 4]> */
		/* 820746A4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820746A4h case    9:*/		return 0x820746A8;
		  /* 820746A8h */ case   10:  		/* lwz R11, <#[R31 + 11024]> */
		/* 820746A8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B10) );
		/* 820746A8h case   10:*/		return 0x820746AC;
		  /* 820746ACh */ case   11:  		/* addi R3, R11, 8 */
		/* 820746ACh case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x8);
		/* 820746ACh case   11:*/		return 0x820746B0;
		  /* 820746B0h */ case   12:  		/* bl 2066776 */
		/* 820746B0h case   12:*/		regs.LR = 0x820746B4; return 0x8226D008;
		/* 820746B0h case   12:*/		return 0x820746B4;
		  /* 820746B4h */ case   13:  		/* li R11, 8 */
		/* 820746B4h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x8);
		/* 820746B4h case   13:*/		return 0x820746B8;
		  /* 820746B8h */ case   14:  		/* lis R9, -16367 */
		/* 820746B8h case   14:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC011);
		/* 820746B8h case   14:*/		return 0x820746BC;
		  /* 820746BCh */ case   15:  		/* stw R29, <#[R1 + 88]> */
		/* 820746BCh case   15:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000058) );
		/* 820746BCh case   15:*/		return 0x820746C0;
		  /* 820746C0h */ case   16:  		/* lis R10, -32256 */
		/* 820746C0h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820746C0h case   16:*/		return 0x820746C4;
		  /* 820746C4h */ case   17:  		/* ori R8, R9, 18432 */
		/* 820746C4h case   17:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R9,0x4800);
		/* 820746C4h case   17:*/		return 0x820746C8;
		  /* 820746C8h */ case   18:  		/* addi R10, R10, 4552 */
		/* 820746C8h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x11C8);
		/* 820746C8h case   18:*/		return 0x820746CC;
		  /* 820746CCh */ case   19:  		/* li R7, 1023 */
		/* 820746CCh case   19:*/		cpu::op::li<0>(regs,&regs.R7,0x3FF);
		/* 820746CCh case   19:*/		return 0x820746D0;
		  /* 820746D0h */ case   20:  		/* mtspr CTR, R11 */
		/* 820746D0h case   20:*/		regs.CTR = regs.R11;
		/* 820746D0h case   20:*/		return 0x820746D4;
		  /* 820746D4h */ case   21:  		/* addi R9, R1, 92 */
		/* 820746D4h case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x5C);
		/* 820746D4h case   21:*/		return 0x820746D8;
		  /* 820746D8h */ case   22:  		/* stw R8, <#[R1 + 80]> */
		/* 820746D8h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 820746D8h case   22:*/		return 0x820746DC;
		  /* 820746DCh */ case   23:  		/* stw R7, <#[R1 + 84]> */
		/* 820746DCh case   23:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 820746DCh case   23:*/		return 0x820746E0;
		  /* 820746E0h */ case   24:  		/* addi R11, R10, -4 */
		/* 820746E0h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFC);
		/* 820746E0h case   24:*/		return 0x820746E4;
		  /* 820746E4h */ case   25:  		/* stw R29, <#[R1 + 92]> */
		/* 820746E4h case   25:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000005C) );
		/* 820746E4h case   25:*/		return 0x820746E8;
		  /* 820746E8h */ case   26:  		/* lwzu R10, <#[R11 + 4]> */
		/* 820746E8h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820746E8h case   26:*/		return 0x820746EC;
		  /* 820746ECh */ case   27:  		/* stwu R10, <#[R9 + 4]> */
		/* 820746ECh case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820746ECh case   27:*/		return 0x820746F0;
		  /* 820746F0h */ case   28:  		/* bc 16, CR0_LT, -8 */
		/* 820746F0h case   28:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820746E8;  }
		/* 820746F0h case   28:*/		return 0x820746F4;
		  /* 820746F4h */ case   29:  		/* li R10, 1 */
		/* 820746F4h case   29:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820746F4h case   29:*/		return 0x820746F8;
		  /* 820746F8h */ case   30:  		/* stw R29, <#[R1 + 136]> */
		/* 820746F8h case   30:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000088) );
		/* 820746F8h case   30:*/		return 0x820746FC;
		  /* 820746FCh */ case   31:  		/* li R11, 2048 */
		/* 820746FCh case   31:*/		cpu::op::li<0>(regs,&regs.R11,0x800);
		/* 820746FCh case   31:*/		return 0x82074700;
		  /* 82074700h */ case   32:  		/* stw R29, <#[R1 + 140]> */
		/* 82074700h case   32:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x0000008C) );
		/* 82074700h case   32:*/		return 0x82074704;
		  /* 82074704h */ case   33:  		/* li R9, 7 */
		/* 82074704h case   33:*/		cpu::op::li<0>(regs,&regs.R9,0x7);
		/* 82074704h case   33:*/		return 0x82074708;
		  /* 82074708h */ case   34:  		/* sth R10, <#[R31 + 11052]> */
		/* 82074708h case   34:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R31 + 0x00002B2C) );
		/* 82074708h case   34:*/		return 0x8207470C;
		  /* 8207470Ch */ case   35:  		/* sth R11, <#[R31 + 11054]> */
		/* 8207470Ch case   35:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00002B2E) );
		/* 8207470Ch case   35:*/		return 0x82074710;
		  /* 82074710h */ case   36:  		/* li R4, 19 */
		/* 82074710h case   36:*/		cpu::op::li<0>(regs,&regs.R4,0x13);
		/* 82074710h case   36:*/		return 0x82074714;
		  /* 82074714h */ case   37:  		/* sth R11, <#[R1 + 130]> */
		/* 82074714h case   37:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000082) );
		/* 82074714h case   37:*/		return 0x82074718;
		  /* 82074718h */ case   38:  		/* addi R3, R1, 80 */
		/* 82074718h case   38:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82074718h case   38:*/		return 0x8207471C;
		  /* 8207471Ch */ case   39:  		/* sth R10, <#[R1 + 128]> */
		/* 8207471Ch case   39:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 8207471Ch case   39:*/		return 0x82074720;
		  /* 82074720h */ case   40:  		/* stw R9, <#[R1 + 132]> */
		/* 82074720h case   40:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000084) );
		/* 82074720h case   40:*/		return 0x82074724;
		  /* 82074724h */ case   41:  		/* stw R29, <#[R1 + 144]> */
		/* 82074724h case   41:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000090) );
		/* 82074724h case   41:*/		return 0x82074728;
		  /* 82074728h */ case   42:  		/* stw R29, <#[R1 + 148]> */
		/* 82074728h case   42:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000094) );
		/* 82074728h case   42:*/		return 0x8207472C;
		  /* 8207472Ch */ case   43:  		/* stw R29, <#[R1 + 152]> */
		/* 8207472Ch case   43:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000098) );
		/* 8207472Ch case   43:*/		return 0x82074730;
		  /* 82074730h */ case   44:  		/* bl 2066584 */
		/* 82074730h case   44:*/		regs.LR = 0x82074734; return 0x8226CFC8;
		/* 82074730h case   44:*/		return 0x82074734;
		  /* 82074734h */ case   45:  		/* li R5, 19 */
		/* 82074734h case   45:*/		cpu::op::li<0>(regs,&regs.R5,0x13);
		/* 82074734h case   45:*/		return 0x82074738;
		  /* 82074738h */ case   46:  		/* addi R4, R1, 80 */
		/* 82074738h case   46:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82074738h case   46:*/		return 0x8207473C;
		  /* 8207473Ch */ case   47:  		/* mr R3, R31 */
		/* 8207473Ch case   47:*/		regs.R3 = regs.R31;
		/* 8207473Ch case   47:*/		return 0x82074740;
		  /* 82074740h */ case   48:  		/* bl -7896 */
		/* 82074740h case   48:*/		regs.LR = 0x82074744; return 0x82072868;
		/* 82074740h case   48:*/		return 0x82074744;
		  /* 82074744h */ case   49:  		/* lwz R3, <#[R31 + 48]> */
		/* 82074744h case   49:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82074744h case   49:*/		return 0x82074748;
		  /* 82074748h */ case   50:  		/* lwz R11, <#[R31 + 56]> */
		/* 82074748h case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82074748h case   50:*/		return 0x8207474C;
		  /* 8207474Ch */ case   51:  		/* cmplw CR6, R3, R11 */
		/* 8207474Ch case   51:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8207474Ch case   51:*/		return 0x82074750;
		  /* 82074750h */ case   52:  		/* bc 4, CR6_GT, 12 */
		/* 82074750h case   52:*/		if ( !regs.CR[6].gt ) { return 0x8207475C;  }
		/* 82074750h case   52:*/		return 0x82074754;
		  /* 82074754h */ case   53:  		/* mr R3, R31 */
		/* 82074754h case   53:*/		regs.R3 = regs.R31;
		/* 82074754h case   53:*/		return 0x82074758;
		  /* 82074758h */ case   54:  		/* bl -1616 */
		/* 82074758h case   54:*/		regs.LR = 0x8207475C; return 0x82074108;
		/* 82074758h case   54:*/		return 0x8207475C;
	}
	return 0x8207475C;
} // Block from 82074680h-8207475Ch (55 instructions)

//////////////////////////////////////////////////////
// Block at 8207475Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207475C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207475C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207475C);
		  /* 8207475Ch */ case    0:  		/* li R11, 3330 */
		/* 8207475Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xD02);
		/* 8207475Ch case    0:*/		return 0x82074760;
		  /* 82074760h */ case    1:  		/* lis R10, 1 */
		/* 82074760h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 82074760h case    1:*/		return 0x82074764;
		  /* 82074764h */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 82074764h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82074764h case    2:*/		return 0x82074768;
		  /* 82074768h */ case    3:  		/* lis R11, 3 */
		/* 82074768h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x3);
		/* 82074768h case    3:*/		return 0x8207476C;
		  /* 8207476Ch */ case    4:  		/* ori R10, R10, 2048 */
		/* 8207476Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x800);
		/* 8207476Ch case    4:*/		return 0x82074770;
		  /* 82074770h */ case    5:  		/* ori R11, R11, 2562 */
		/* 82074770h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xA02);
		/* 82074770h case    5:*/		return 0x82074774;
		  /* 82074774h */ case    6:  		/* lis R9, -16368 */
		/* 82074774h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC010);
		/* 82074774h case    6:*/		return 0x82074778;
		  /* 82074778h */ case    7:  		/* lis R8, 2032 */
		/* 82074778h case    7:*/		cpu::op::lis<0>(regs,&regs.R8,0x7F0);
		/* 82074778h case    7:*/		return 0x8207477C;
		  /* 8207477Ch */ case    8:  		/* stwu R10, <#[R3 + 4]> */
		/* 8207477Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207477Ch case    8:*/		return 0x82074780;
		  /* 82074780h */ case    9:  		/* lis R7, -16384 */
		/* 82074780h case    9:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFFC000);
		/* 82074780h case    9:*/		return 0x82074784;
		  /* 82074784h */ case   10:  		/* lis R10, 16 */
		/* 82074784h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x10);
		/* 82074784h case   10:*/		return 0x82074788;
		  /* 82074788h */ case   11:  		/* mr R5, R3 */
		/* 82074788h case   11:*/		regs.R5 = regs.R3;
		/* 82074788h case   11:*/		return 0x8207478C;
		  /* 8207478Ch */ case   12:  		/* li R6, 477 */
		/* 8207478Ch case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x1DD);
		/* 8207478Ch case   12:*/		return 0x82074790;
		  /* 82074790h */ case   13:  		/* li R4, 476 */
		/* 82074790h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1DC);
		/* 82074790h case   13:*/		return 0x82074794;
		  /* 82074794h */ case   14:  		/* lis R30, 2 */
		/* 82074794h case   14:*/		cpu::op::lis<0>(regs,&regs.R30,0x2);
		/* 82074794h case   14:*/		return 0x82074798;
		  /* 82074798h */ case   15:  		/* mr R3, R31 */
		/* 82074798h case   15:*/		regs.R3 = regs.R31;
		/* 82074798h case   15:*/		return 0x8207479C;
		  /* 8207479Ch */ case   16:  		/* stwu R11, <#[R5 + 4]> */
		/* 8207479Ch case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 8207479Ch case   16:*/		return 0x820747A0;
		  /* 820747A0h */ case   17:  		/* ori R30, R30, 55 */
		/* 820747A0h case   17:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x37);
		/* 820747A0h case   17:*/		return 0x820747A4;
		  /* 820747A4h */ case   18:  		/* stwu R9, <#[R5 + 4]> */
		/* 820747A4h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 820747A4h case   18:*/		return 0x820747A8;
		  /* 820747A8h */ case   19:  		/* stwu R8, <#[R5 + 4]> */
		/* 820747A8h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 820747A8h case   19:*/		return 0x820747AC;
		  /* 820747ACh */ case   20:  		/* stwu R7, <#[R5 + 4]> */
		/* 820747ACh case   20:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 820747ACh case   20:*/		return 0x820747B0;
		  /* 820747B0h */ case   21:  		/* stwu R10, <#[R5 + 4]> */
		/* 820747B0h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 820747B0h case   21:*/		return 0x820747B4;
		  /* 820747B4h */ case   22:  		/* stwu R6, <#[R5 + 4]> */
		/* 820747B4h case   22:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 820747B4h case   22:*/		return 0x820747B8;
		  /* 820747B8h */ case   23:  		/* lwz R10, <#[R31 + 11028]> */
		/* 820747B8h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B14) );
		/* 820747B8h case   23:*/		return 0x820747BC;
		  /* 820747BCh */ case   24:  		/* rlwinm R11, R10, 12, 20, 31 */
		/* 820747BCh case   24:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R10);
		/* 820747BCh case   24:*/		return 0x820747C0;
		  /* 820747C0h */ case   25:  		/* rlwinm R10, R10, 0, 3, 31 */
		/* 820747C0h case   25:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R10);
		/* 820747C0h case   25:*/		return 0x820747C4;
		  /* 820747C4h */ case   26:  		/* addi R11, R11, 512 */
		/* 820747C4h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 820747C4h case   26:*/		return 0x820747C8;
		  /* 820747C8h */ case   27:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 820747C8h case   27:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 820747C8h case   27:*/		return 0x820747CC;
		  /* 820747CCh */ case   28:  		/* add R11, R11, R10 */
		/* 820747CCh case   28:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820747CCh case   28:*/		return 0x820747D0;
		  /* 820747D0h */ case   29:  		/* stwu R11, <#[R5 + 4]> */
		/* 820747D0h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 820747D0h case   29:*/		return 0x820747D4;
		  /* 820747D4h */ case   30:  		/* stwu R4, <#[R5 + 4]> */
		/* 820747D4h case   30:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 820747D4h case   30:*/		return 0x820747D8;
		  /* 820747D8h */ case   31:  		/* stwu R30, <#[R5 + 4]> */
		/* 820747D8h case   31:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R5 + 0x00000004) );
		regs.R5 = (uint32)(regs.R5 + 0x00000004);
		/* 820747D8h case   31:*/		return 0x820747DC;
		  /* 820747DCh */ case   32:  		/* stw R5, <#[R31 + 48]> */
		/* 820747DCh case   32:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x00000030) );
		/* 820747DCh case   32:*/		return 0x820747E0;
		  /* 820747E0h */ case   33:  		/* bl -1288 */
		/* 820747E0h case   33:*/		regs.LR = 0x820747E4; return 0x820742D8;
		/* 820747E0h case   33:*/		return 0x820747E4;
		  /* 820747E4h */ case   34:  		/* b -736 */
		/* 820747E4h case   34:*/		return 0x82074504;
		/* 820747E4h case   34:*/		return 0x820747E8;
	}
	return 0x820747E8;
} // Block from 8207475Ch-820747E8h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820747E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820747E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820747E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820747E8);
		  /* 820747E8h */ case    0:  		/* lis R3, -32761 */
		/* 820747E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820747E8h case    0:*/		return 0x820747EC;
		  /* 820747ECh */ case    1:  		/* ori R3, R3, 14 */
		/* 820747ECh case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820747ECh case    1:*/		return 0x820747F0;
	}
	return 0x820747F0;
} // Block from 820747E8h-820747F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820747F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820747F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820747F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820747F0);
		  /* 820747F0h */ case    0:  		/* addi R1, R1, 320 */
		/* 820747F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x140);
		/* 820747F0h case    0:*/		return 0x820747F4;
		  /* 820747F4h */ case    1:  		/* b 117408 */
		/* 820747F4h case    1:*/		return 0x82091294;
		/* 820747F4h case    1:*/		return 0x820747F8;
	}
	return 0x820747F8;
} // Block from 820747F0h-820747F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820747F8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820747F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820747F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820747F8);
		  /* 820747F8h */ case    0:  		/* mfspr R12, LR */
		/* 820747F8h case    0:*/		regs.R12 = regs.LR;
		/* 820747F8h case    0:*/		return 0x820747FC;
		  /* 820747FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820747FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820747FCh case    1:*/		return 0x82074800;
		  /* 82074800h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82074800h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82074800h case    2:*/		return 0x82074804;
		  /* 82074804h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82074804h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074804h case    3:*/		return 0x82074808;
		  /* 82074808h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82074808h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82074808h case    4:*/		return 0x8207480C;
		  /* 8207480Ch */ case    5:  		/* mr R31, R3 */
		/* 8207480Ch case    5:*/		regs.R31 = regs.R3;
		/* 8207480Ch case    5:*/		return 0x82074810;
		  /* 82074810h */ case    6:  		/* lwz R3, <#[R3 + 108]> */
		/* 82074810h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000006C) );
		/* 82074810h case    6:*/		return 0x82074814;
		  /* 82074814h */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 82074814h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82074814h case    7:*/		return 0x82074818;
		  /* 82074818h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82074818h case    8:*/		if ( regs.CR[6].eq ) { return 0x82074824;  }
		/* 82074818h case    8:*/		return 0x8207481C;
		  /* 8207481Ch */ case    9:  		/* lis R4, -20096 */
		/* 8207481Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB180);
		/* 8207481Ch case    9:*/		return 0x82074820;
		  /* 82074820h */ case   10:  		/* bl 80664 */
		/* 82074820h case   10:*/		regs.LR = 0x82074824; return 0x82088338;
		/* 82074820h case   10:*/		return 0x82074824;
	}
	return 0x82074824;
} // Block from 820747F8h-82074824h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82074824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074824);
		  /* 82074824h */ case    0:  		/* lwz R3, <#[R31 + 132]> */
		/* 82074824h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000084) );
		/* 82074824h case    0:*/		return 0x82074828;
		  /* 82074828h */ case    1:  		/* li R30, 0 */
		/* 82074828h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82074828h case    1:*/		return 0x8207482C;
		  /* 8207482Ch */ case    2:  		/* stw R30, <#[R31 + 108]> */
		/* 8207482Ch case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000006C) );
		/* 8207482Ch case    2:*/		return 0x82074830;
		  /* 82074830h */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 82074830h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82074830h case    3:*/		return 0x82074834;
		  /* 82074834h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82074834h case    4:*/		if ( regs.CR[6].eq ) { return 0x82074840;  }
		/* 82074834h case    4:*/		return 0x82074838;
		  /* 82074838h */ case    5:  		/* lis R4, 9344 */
		/* 82074838h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 82074838h case    5:*/		return 0x8207483C;
		  /* 8207483Ch */ case    6:  		/* bl 80636 */
		/* 8207483Ch case    6:*/		regs.LR = 0x82074840; return 0x82088338;
		/* 8207483Ch case    6:*/		return 0x82074840;
	}
	return 0x82074840;
} // Block from 82074824h-82074840h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82074840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074840);
		  /* 82074840h */ case    0:  		/* stw R30, <#[R31 + 132]> */
		/* 82074840h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000084) );
		/* 82074840h case    0:*/		return 0x82074844;
		  /* 82074844h */ case    1:  		/* addi R1, R1, 112 */
		/* 82074844h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82074844h case    1:*/		return 0x82074848;
		  /* 82074848h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82074848h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074848h case    2:*/		return 0x8207484C;
		  /* 8207484Ch */ case    3:  		/* mtspr LR, R12 */
		/* 8207484Ch case    3:*/		regs.LR = regs.R12;
		/* 8207484Ch case    3:*/		return 0x82074850;
		  /* 82074850h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82074850h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82074850h case    4:*/		return 0x82074854;
		  /* 82074854h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82074854h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074854h case    5:*/		return 0x82074858;
		  /* 82074858h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82074858h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82074858h case    6:*/		return 0x8207485C;
	}
	return 0x8207485C;
} // Block from 82074840h-8207485Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8207485Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207485C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207485C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207485C);
		  /* 8207485Ch */ case    0:  		/* nop */
		/* 8207485Ch case    0:*/		cpu::op::nop();
		/* 8207485Ch case    0:*/		return 0x82074860;
	}
	return 0x82074860;
} // Block from 8207485Ch-82074860h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82074860h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074860);
		  /* 82074860h */ case    0:  		/* lwz R9, <#[R3 + 13920]> */
		/* 82074860h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00003660) );
		/* 82074860h case    0:*/		return 0x82074864;
		  /* 82074864h */ case    1:  		/* mr R11, R3 */
		/* 82074864h case    1:*/		regs.R11 = regs.R3;
		/* 82074864h case    1:*/		return 0x82074868;
		  /* 82074868h */ case    2:  		/* rlwinm. R10, R4, 0, 31, 31 */
		/* 82074868h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R4);
		/* 82074868h case    2:*/		return 0x8207486C;
		  /* 8207486Ch */ case    3:  		/* bc 12, CR0_EQ, 124 */
		/* 8207486Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820748E8;  }
		/* 8207486Ch case    3:*/		return 0x82074870;
		  /* 82074870h */ case    4:  		/* lwz R8, <#[R5]> */
		/* 82074870h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000000) );
		/* 82074870h case    4:*/		return 0x82074874;
		  /* 82074874h */ case    5:  		/* lwz R10, <#[R3 + 15320]> */
		/* 82074874h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00003BD8) );
		/* 82074874h case    5:*/		return 0x82074878;
		  /* 82074878h */ case    6:  		/* rlwinm R8, R8, 30, 2, 31 */
		/* 82074878h case    6:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R8,regs.R8);
		/* 82074878h case    6:*/		return 0x8207487C;
		  /* 8207487Ch */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 8207487Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8207487Ch case    7:*/		return 0x82074880;
		  /* 82074880h */ case    8:  		/* bc 4, CR6_EQ, 20 */
		/* 82074880h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82074894;  }
		/* 82074880h case    8:*/		return 0x82074884;
		  /* 82074884h */ case    9:  		/* lwz R7, <#[R9 + 156]> */
		/* 82074884h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x0000009C) );
		/* 82074884h case    9:*/		return 0x82074888;
		  /* 82074888h */ case   10:  		/* lwz R10, <#[R9 + 152]> */
		/* 82074888h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000098) );
		/* 82074888h case   10:*/		return 0x8207488C;
		  /* 8207488Ch */ case   11:  		/* rlwinm R9, R7, 0, 0, 29 */
		/* 8207488Ch case   11:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R9,regs.R7);
		/* 8207488Ch case   11:*/		return 0x82074890;
		  /* 82074890h */ case   12:  		/* add R10, R9, R10 */
		/* 82074890h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82074890h case   12:*/		return 0x82074894;
	}
	return 0x82074894;
} // Block from 82074860h-82074894h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82074894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074894);
		  /* 82074894h */ case    0:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82074894h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82074894h case    0:*/		return 0x82074898;
		  /* 82074898h */ case    1:  		/* lwz R9, <#[R11 + 48]> */
		/* 82074898h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 82074898h case    1:*/		return 0x8207489C;
		  /* 8207489Ch */ case    2:  		/* addi R7, R6, -1 */
		/* 8207489Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFF);
		/* 8207489Ch case    2:*/		return 0x820748A0;
		  /* 820748A0h */ case    3:  		/* subf R8, R8, R10 */
		/* 820748A0h case    3:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 820748A0h case    3:*/		return 0x820748A4;
		  /* 820748A4h */ case    4:  		/* addi R9, R9, 164 */
		/* 820748A4h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xA4);
		/* 820748A4h case    4:*/		return 0x820748A8;
		  /* 820748A8h */ case    5:  		/* andc R3, R8, R7 */
		/* 820748A8h case    5:*/		cpu::op::andc<0>(regs,&regs.R3,regs.R8,regs.R7);
		/* 820748A8h case    5:*/		return 0x820748AC;
		  /* 820748ACh */ case    6:  		/* cmplw CR6, R3, R9 */
		/* 820748ACh case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 820748ACh case    6:*/		return 0x820748B0;
		  /* 820748B0h */ case    7:  		/* bc 4, CR6_LT, 12 */
		/* 820748B0h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820748BC;  }
		/* 820748B0h case    7:*/		return 0x820748B4;
		  /* 820748B4h */ case    8:  		/* li R3, 0 */
		/* 820748B4h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820748B4h case    8:*/		return 0x820748B8;
		  /* 820748B8h */ case    9:  		/* bclr 20, CR0_LT */
		/* 820748B8h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820748B8h case    9:*/		return 0x820748BC;
	}
	return 0x820748BC;
} // Block from 82074894h-820748BCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820748BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820748BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820748BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820748BC);
		  /* 820748BCh */ case    0:  		/* subf R10, R3, R10 */
		/* 820748BCh case    0:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R3,regs.R10);
		/* 820748BCh case    0:*/		return 0x820748C0;
		  /* 820748C0h */ case    1:  		/* lwz R9, <#[R11 + 52]> */
		/* 820748C0h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000034) );
		/* 820748C0h case    1:*/		return 0x820748C4;
		  /* 820748C4h */ case    2:  		/* lwz R8, <#[R11 + 56]> */
		/* 820748C4h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000038) );
		/* 820748C4h case    2:*/		return 0x820748C8;
		  /* 820748C8h */ case    3:  		/* srawi R10, R10, 2 */
		/* 820748C8h case    3:*/		cpu::op::srawi<0,2>(regs,&regs.R10,regs.R10);
		/* 820748C8h case    3:*/		return 0x820748CC;
		  /* 820748CCh */ case    4:  		/* stw R3, <#[R11 + 15320]> */
		/* 820748CCh case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00003BD8) );
		/* 820748CCh case    4:*/		return 0x820748D0;
		  /* 820748D0h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820748D0h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820748D0h case    5:*/		return 0x820748D4;
		  /* 820748D4h */ case    6:  		/* subf R9, R10, R9 */
		/* 820748D4h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820748D4h case    6:*/		return 0x820748D8;
		  /* 820748D8h */ case    7:  		/* subf R10, R10, R8 */
		/* 820748D8h case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820748D8h case    7:*/		return 0x820748DC;
		  /* 820748DCh */ case    8:  		/* stw R9, <#[R11 + 52]> */
		/* 820748DCh case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000034) );
		/* 820748DCh case    8:*/		return 0x820748E0;
		  /* 820748E0h */ case    9:  		/* stw R10, <#[R11 + 56]> */
		/* 820748E0h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 820748E0h case    9:*/		return 0x820748E4;
		  /* 820748E4h */ case   10:  		/* bclr 20, CR0_LT */
		/* 820748E4h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820748E4h case   10:*/		return 0x820748E8;
	}
	return 0x820748E8;
} // Block from 820748BCh-820748E8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820748E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820748E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820748E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820748E8);
		  /* 820748E8h */ case    0:  		/* lwz R10, <#[R11 + 56]> */
		/* 820748E8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000038) );
		/* 820748E8h case    0:*/		return 0x820748EC;
		  /* 820748ECh */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820748ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820748ECh case    1:*/		return 0x820748F0;
		  /* 820748F0h */ case    2:  		/* bc 4, CR6_EQ, -60 */
		/* 820748F0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820748B4;  }
		/* 820748F0h case    2:*/		return 0x820748F4;
		  /* 820748F4h */ case    3:  		/* lwz R10, <#[R9 + 152]> */
		/* 820748F4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000098) );
		/* 820748F4h case    3:*/		return 0x820748F8;
		  /* 820748F8h */ case    4:  		/* stw R10, <#[R11 + 15332]> */
		/* 820748F8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00003BE4) );
		/* 820748F8h case    4:*/		return 0x820748FC;
		  /* 820748FCh */ case    5:  		/* lwz R11, <#[R9 + 156]> */
		/* 820748FCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000009C) );
		/* 820748FCh case    5:*/		return 0x82074900;
		  /* 82074900h */ case    6:  		/* stw R11, <#[R5]> */
		/* 82074900h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82074900h case    6:*/		return 0x82074904;
		  /* 82074904h */ case    7:  		/* lwz R3, <#[R9 + 152]> */
		/* 82074904h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x00000098) );
		/* 82074904h case    7:*/		return 0x82074908;
		  /* 82074908h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82074908h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82074908h case    8:*/		return 0x8207490C;
	}
	return 0x8207490C;
} // Block from 820748E8h-8207490Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8207490Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207490C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207490C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207490C);
		  /* 8207490Ch */ case    0:  		/* nop */
		/* 8207490Ch case    0:*/		cpu::op::nop();
		/* 8207490Ch case    0:*/		return 0x82074910;
		  /* 82074910h */ case    1:  		/* lwz R9, <#[R3 + 156]> */
		/* 82074910h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000009C) );
		/* 82074910h case    1:*/		return 0x82074914;
		  /* 82074914h */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 82074914h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82074914h case    2:*/		return 0x82074918;
		  /* 82074918h */ case    3:  		/* bclr 12, CR6_EQ */
		/* 82074918h case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82074918h case    3:*/		return 0x8207491C;
	}
	return 0x8207491C;
} // Block from 8207490Ch-8207491Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8207491Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207491C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207491C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207491C);
		  /* 8207491Ch */ case    0:  		/* lis R10, 16384 */
		/* 8207491Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0x4000);
		/* 8207491Ch case    0:*/		return 0x82074920;
	}
	return 0x82074920;
} // Block from 8207491Ch-82074920h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82074920h
// Function '?CreateInvalidateBuffer@CDevice@D3D@@QAAXPAK0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074920);
		  /* 82074920h */ case    0:  		/* lwz R11, <#[R3 + 152]> */
		/* 82074920h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000098) );
		/* 82074920h case    0:*/		return 0x82074924;
		  /* 82074924h */ case    1:  		/* li R5, 0 */
		/* 82074924h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82074924h case    1:*/		return 0x82074928;
		  /* 82074928h */ case    2:  		/* mr R6, R10 */
		/* 82074928h case    2:*/		regs.R6 = regs.R10;
		/* 82074928h case    2:*/		return 0x8207492C;
		  /* 8207492Ch */ case    3:  		/* mr R7, R10 */
		/* 8207492Ch case    3:*/		regs.R7 = regs.R10;
		/* 8207492Ch case    3:*/		return 0x82074930;
		  /* 82074930h */ case    4:  		/* add R10, R11, R9 */
		/* 82074930h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 82074930h case    4:*/		return 0x82074934;
		  /* 82074934h */ case    5:  		/* rlwinm R9, R11, 12, 20, 31 */
		/* 82074934h case    5:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R9,regs.R11);
		/* 82074934h case    5:*/		return 0x82074938;
		  /* 82074938h */ case    6:  		/* addi R10, R10, -1 */
		/* 82074938h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82074938h case    6:*/		return 0x8207493C;
		  /* 8207493Ch */ case    7:  		/* addi R4, R9, 512 */
		/* 8207493Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x200);
		/* 8207493Ch case    7:*/		return 0x82074940;
		  /* 82074940h */ case    8:  		/* rlwinm R9, R10, 12, 20, 31 */
		/* 82074940h case    8:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R9,regs.R10);
		/* 82074940h case    8:*/		return 0x82074944;
		  /* 82074944h */ case    9:  		/* rlwinm R8, R10, 0, 3, 31 */
		/* 82074944h case    9:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R8,regs.R10);
		/* 82074944h case    9:*/		return 0x82074948;
		  /* 82074948h */ case   10:  		/* addi R9, R9, 512 */
		/* 82074948h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x200);
		/* 82074948h case   10:*/		return 0x8207494C;
		  /* 8207494Ch */ case   11:  		/* rlwinm R10, R4, 0, 19, 19 */
		/* 8207494Ch case   11:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R4);
		/* 8207494Ch case   11:*/		return 0x82074950;
		  /* 82074950h */ case   12:  		/* rlwinm R9, R9, 0, 19, 19 */
		/* 82074950h case   12:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R9,regs.R9);
		/* 82074950h case   12:*/		return 0x82074954;
		  /* 82074954h */ case   13:  		/* rlwinm R11, R11, 0, 3, 31 */
		/* 82074954h case   13:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R11,regs.R11);
		/* 82074954h case   13:*/		return 0x82074958;
		  /* 82074958h */ case   14:  		/* add R9, R9, R8 */
		/* 82074958h case   14:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82074958h case   14:*/		return 0x8207495C;
		  /* 8207495Ch */ case   15:  		/* add R11, R10, R11 */
		/* 8207495Ch case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8207495Ch case   15:*/		return 0x82074960;
		  /* 82074960h */ case   16:  		/* subf R4, R6, R9 */
		/* 82074960h case   16:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R6,regs.R9);
		/* 82074960h case   16:*/		return 0x82074964;
		  /* 82074964h */ case   17:  		/* subf R3, R6, R11 */
		/* 82074964h case   17:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R6,regs.R11);
		/* 82074964h case   17:*/		return 0x82074968;
		  /* 82074968h */ case   18:  		/* b 67680 */
		/* 82074968h case   18:*/		return 0x820851C8;
		/* 82074968h case   18:*/		return 0x8207496C;
		  /* 8207496Ch */ case   19:  		/* bclr 20, CR0_LT */
		/* 8207496Ch case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8207496Ch case   19:*/		return 0x82074970;
	}
	return 0x82074970;
} // Block from 82074920h-82074970h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82074970h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074970);
		  /* 82074970h */ case    0:  		/* mfspr R12, LR */
		/* 82074970h case    0:*/		regs.R12 = regs.LR;
		/* 82074970h case    0:*/		return 0x82074974;
		  /* 82074974h */ case    1:  		/* bl 116968 */
		/* 82074974h case    1:*/		regs.LR = 0x82074978; return 0x8209125C;
		/* 82074974h case    1:*/		return 0x82074978;
		  /* 82074978h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82074978h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82074978h case    2:*/		return 0x8207497C;
		  /* 8207497Ch */ case    3:  		/* li R5, 128 */
		/* 8207497Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x80);
		/* 8207497Ch case    3:*/		return 0x82074980;
		  /* 82074980h */ case    4:  		/* lwz R29, <#[R3 + 13924]> */
		/* 82074980h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00003664) );
		/* 82074980h case    4:*/		return 0x82074984;
		  /* 82074984h */ case    5:  		/* li R4, 502 */
		/* 82074984h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1F6);
		/* 82074984h case    5:*/		return 0x82074988;
		  /* 82074988h */ case    6:  		/* mr R30, R3 */
		/* 82074988h case    6:*/		regs.R30 = regs.R3;
		/* 82074988h case    6:*/		return 0x8207498C;
		  /* 8207498Ch */ case    7:  		/* bl -6732 */
		/* 8207498Ch case    7:*/		regs.LR = 0x82074990; return 0x82072F40;
		/* 8207498Ch case    7:*/		return 0x82074990;
		  /* 82074990h */ case    8:  		/* lbz R11, <#[R30 + 11069]> */
		/* 82074990h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00002B3D) );
		/* 82074990h case    8:*/		return 0x82074994;
		  /* 82074994h */ case    9:  		/* mr R31, R3 */
		/* 82074994h case    9:*/		regs.R31 = regs.R3;
		/* 82074994h case    9:*/		return 0x82074998;
		  /* 82074998h */ case   10:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82074998h case   10:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82074998h case   10:*/		return 0x8207499C;
		  /* 8207499Ch */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 8207499Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x820749A8;  }
		/* 8207499Ch case   11:*/		return 0x820749A0;
		  /* 820749A0h */ case   12:  		/* lwz R31, <#[R30 + 17136]> */
		/* 820749A0h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x000042F0) );
		/* 820749A0h case   12:*/		return 0x820749A4;
		  /* 820749A4h */ case   13:  		/* b 96 */
		/* 820749A4h case   13:*/		return 0x82074A04;
		/* 820749A4h case   13:*/		return 0x820749A8;
	}
	return 0x820749A8;
} // Block from 82074970h-820749A8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820749A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820749A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820749A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820749A8);
		  /* 820749A8h */ case    0:  		/* rlwinm R11, R31, 12, 20, 31 */
		/* 820749A8h case    0:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R31);
		/* 820749A8h case    0:*/		return 0x820749AC;
		  /* 820749ACh */ case    1:  		/* stw R31, <#[R30 + 13924]> */
		/* 820749ACh case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00003664) );
		/* 820749ACh case    1:*/		return 0x820749B0;
		  /* 820749B0h */ case    2:  		/* rlwinm R10, R31, 0, 3, 31 */
		/* 820749B0h case    2:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R31);
		/* 820749B0h case    2:*/		return 0x820749B4;
		  /* 820749B4h */ case    3:  		/* addi R11, R11, 512 */
		/* 820749B4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 820749B4h case    3:*/		return 0x820749B8;
		  /* 820749B8h */ case    4:  		/* li R9, 0 */
		/* 820749B8h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820749B8h case    4:*/		return 0x820749BC;
		  /* 820749BCh */ case    5:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 820749BCh case    5:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 820749BCh case    5:*/		return 0x820749C0;
		  /* 820749C0h */ case    6:  		/* stw R9, <#[R31]> */
		/* 820749C0h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820749C0h case    6:*/		return 0x820749C4;
		  /* 820749C4h */ case    7:  		/* cmplwi CR6, R29, 0 */
		/* 820749C4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820749C4h case    7:*/		return 0x820749C8;
		  /* 820749C8h */ case    8:  		/* add R11, R11, R10 */
		/* 820749C8h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820749C8h case    8:*/		return 0x820749CC;
		  /* 820749CCh */ case    9:  		/* addis R3, R11, -16384 */
		/* 820749CCh case    9:*/		cpu::op::addis<0>(regs,&regs.R3,regs.R11,0xFFFFC000);
		/* 820749CCh case    9:*/		return 0x820749D0;
		  /* 820749D0h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 820749D0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820749E0;  }
		/* 820749D0h case   10:*/		return 0x820749D4;
		  /* 820749D4h */ case   11:  		/* lwz R11, <#[R30 + 13920]> */
		/* 820749D4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00003660) );
		/* 820749D4h case   11:*/		return 0x820749D8;
		  /* 820749D8h */ case   12:  		/* stw R3, <#[R11 + 112]> */
		/* 820749D8h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000070) );
		/* 820749D8h case   12:*/		return 0x820749DC;
		  /* 820749DCh */ case   13:  		/* b 28 */
		/* 820749DCh case   13:*/		return 0x820749F8;
		/* 820749DCh case   13:*/		return 0x820749E0;
	}
	return 0x820749E0;
} // Block from 820749A8h-820749E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820749E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820749E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820749E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820749E0);
		  /* 820749E0h */ case    0:  		/* stw R3, <#[R29]> */
		/* 820749E0h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 820749E0h case    0:*/		return 0x820749E4;
		  /* 820749E4h */ case    1:  		/* lwz R11, <#[R30 + 13928]> */
		/* 820749E4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00003668) );
		/* 820749E4h case    1:*/		return 0x820749E8;
		  /* 820749E8h */ case    2:  		/* subf R11, R29, R11 */
		/* 820749E8h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 820749E8h case    2:*/		return 0x820749EC;
		  /* 820749ECh */ case    3:  		/* addi R11, R11, -8 */
		/* 820749ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF8);
		/* 820749ECh case    3:*/		return 0x820749F0;
		  /* 820749F0h */ case    4:  		/* srawi R11, R11, 3 */
		/* 820749F0h case    4:*/		cpu::op::srawi<0,3>(regs,&regs.R11,regs.R11);
		/* 820749F0h case    4:*/		return 0x820749F4;
		  /* 820749F4h */ case    5:  		/* stw R11, <#[R29 + 4]> */
		/* 820749F4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820749F4h case    5:*/		return 0x820749F8;
	}
	return 0x820749F8;
} // Block from 820749E0h-820749F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820749F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820749F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820749F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820749F8);
		  /* 820749F8h */ case    0:  		/* addi R4, R3, 2008 */
		/* 820749F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x7D8);
		/* 820749F8h case    0:*/		return 0x820749FC;
		  /* 820749FCh */ case    1:  		/* li R5, 0 */
		/* 820749FCh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820749FCh case    1:*/		return 0x82074A00;
		  /* 82074A00h */ case    2:  		/* bl 67528 */
		/* 82074A00h case    2:*/		regs.LR = 0x82074A04; return 0x820851C8;
		/* 82074A00h case    2:*/		return 0x82074A04;
	}
	return 0x82074A04;
} // Block from 820749F8h-82074A04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82074A04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074A04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074A04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074A04);
		  /* 82074A04h */ case    0:  		/* addi R3, R31, 8 */
		/* 82074A04h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x8);
		/* 82074A04h case    0:*/		return 0x82074A08;
		  /* 82074A08h */ case    1:  		/* addi R11, R31, 2008 */
		/* 82074A08h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x7D8);
		/* 82074A08h case    1:*/		return 0x82074A0C;
		  /* 82074A0Ch */ case    2:  		/* stw R3, <#[R30 + 13928]> */
		/* 82074A0Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00003668) );
		/* 82074A0Ch case    2:*/		return 0x82074A10;
		  /* 82074A10h */ case    3:  		/* stw R11, <#[R30 + 13932]> */
		/* 82074A10h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000366C) );
		/* 82074A10h case    3:*/		return 0x82074A14;
		  /* 82074A14h */ case    4:  		/* addi R1, R1, 112 */
		/* 82074A14h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82074A14h case    4:*/		return 0x82074A18;
		  /* 82074A18h */ case    5:  		/* b 116884 */
		/* 82074A18h case    5:*/		return 0x820912AC;
		/* 82074A18h case    5:*/		return 0x82074A1C;
		  /* 82074A1Ch */ case    6:  		/* nop */
		/* 82074A1Ch case    6:*/		cpu::op::nop();
		/* 82074A1Ch case    6:*/		return 0x82074A20;
	}
	return 0x82074A20;
} // Block from 82074A04h-82074A20h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82074A20h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074A20);
		  /* 82074A20h */ case    0:  		/* mfspr R12, LR */
		/* 82074A20h case    0:*/		regs.R12 = regs.LR;
		/* 82074A20h case    0:*/		return 0x82074A24;
		  /* 82074A24h */ case    1:  		/* bl 116792 */
		/* 82074A24h case    1:*/		regs.LR = 0x82074A28; return 0x8209125C;
		/* 82074A24h case    1:*/		return 0x82074A28;
		  /* 82074A28h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82074A28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82074A28h case    2:*/		return 0x82074A2C;
		  /* 82074A2Ch */ case    3:  		/* li R5, 128 */
		/* 82074A2Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x80);
		/* 82074A2Ch case    3:*/		return 0x82074A30;
		  /* 82074A30h */ case    4:  		/* lwz R29, <#[R3 + 13936]> */
		/* 82074A30h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00003670) );
		/* 82074A30h case    4:*/		return 0x82074A34;
		  /* 82074A34h */ case    5:  		/* li R4, 34 */
		/* 82074A34h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x22);
		/* 82074A34h case    5:*/		return 0x82074A38;
		  /* 82074A38h */ case    6:  		/* mr R30, R3 */
		/* 82074A38h case    6:*/		regs.R30 = regs.R3;
		/* 82074A38h case    6:*/		return 0x82074A3C;
		  /* 82074A3Ch */ case    7:  		/* bl -6908 */
		/* 82074A3Ch case    7:*/		regs.LR = 0x82074A40; return 0x82072F40;
		/* 82074A3Ch case    7:*/		return 0x82074A40;
		  /* 82074A40h */ case    8:  		/* lbz R11, <#[R30 + 11069]> */
		/* 82074A40h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00002B3D) );
		/* 82074A40h case    8:*/		return 0x82074A44;
		  /* 82074A44h */ case    9:  		/* mr R31, R3 */
		/* 82074A44h case    9:*/		regs.R31 = regs.R3;
		/* 82074A44h case    9:*/		return 0x82074A48;
		  /* 82074A48h */ case   10:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82074A48h case   10:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82074A48h case   10:*/		return 0x82074A4C;
		  /* 82074A4Ch */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 82074A4Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82074A58;  }
		/* 82074A4Ch case   11:*/		return 0x82074A50;
		  /* 82074A50h */ case   12:  		/* lwz R31, <#[R30 + 17136]> */
		/* 82074A50h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x000042F0) );
		/* 82074A50h case   12:*/		return 0x82074A54;
		  /* 82074A54h */ case   13:  		/* b 96 */
		/* 82074A54h case   13:*/		return 0x82074AB4;
		/* 82074A54h case   13:*/		return 0x82074A58;
	}
	return 0x82074A58;
} // Block from 82074A20h-82074A58h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82074A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074A58);
		  /* 82074A58h */ case    0:  		/* rlwinm R11, R31, 12, 20, 31 */
		/* 82074A58h case    0:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R31);
		/* 82074A58h case    0:*/		return 0x82074A5C;
		  /* 82074A5Ch */ case    1:  		/* stw R31, <#[R30 + 13936]> */
		/* 82074A5Ch case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00003670) );
		/* 82074A5Ch case    1:*/		return 0x82074A60;
		  /* 82074A60h */ case    2:  		/* rlwinm R10, R31, 0, 3, 31 */
		/* 82074A60h case    2:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R31);
		/* 82074A60h case    2:*/		return 0x82074A64;
		  /* 82074A64h */ case    3:  		/* addi R11, R11, 512 */
		/* 82074A64h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82074A64h case    3:*/		return 0x82074A68;
		  /* 82074A68h */ case    4:  		/* li R9, 0 */
		/* 82074A68h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82074A68h case    4:*/		return 0x82074A6C;
		  /* 82074A6Ch */ case    5:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82074A6Ch case    5:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82074A6Ch case    5:*/		return 0x82074A70;
		  /* 82074A70h */ case    6:  		/* stw R9, <#[R31]> */
		/* 82074A70h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82074A70h case    6:*/		return 0x82074A74;
		  /* 82074A74h */ case    7:  		/* cmplwi CR6, R29, 0 */
		/* 82074A74h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82074A74h case    7:*/		return 0x82074A78;
		  /* 82074A78h */ case    8:  		/* add R11, R11, R10 */
		/* 82074A78h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82074A78h case    8:*/		return 0x82074A7C;
		  /* 82074A7Ch */ case    9:  		/* addis R3, R11, -16384 */
		/* 82074A7Ch case    9:*/		cpu::op::addis<0>(regs,&regs.R3,regs.R11,0xFFFFC000);
		/* 82074A7Ch case    9:*/		return 0x82074A80;
		  /* 82074A80h */ case   10:  		/* bc 4, CR6_EQ, 16 */
		/* 82074A80h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82074A90;  }
		/* 82074A80h case   10:*/		return 0x82074A84;
		  /* 82074A84h */ case   11:  		/* lwz R11, <#[R30 + 13920]> */
		/* 82074A84h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00003660) );
		/* 82074A84h case   11:*/		return 0x82074A88;
		  /* 82074A88h */ case   12:  		/* stw R3, <#[R11 + 116]> */
		/* 82074A88h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000074) );
		/* 82074A88h case   12:*/		return 0x82074A8C;
		  /* 82074A8Ch */ case   13:  		/* b 28 */
		/* 82074A8Ch case   13:*/		return 0x82074AA8;
		/* 82074A8Ch case   13:*/		return 0x82074A90;
	}
	return 0x82074A90;
} // Block from 82074A58h-82074A90h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82074A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074A90);
		  /* 82074A90h */ case    0:  		/* stw R3, <#[R29]> */
		/* 82074A90h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 82074A90h case    0:*/		return 0x82074A94;
		  /* 82074A94h */ case    1:  		/* lwz R11, <#[R30 + 13940]> */
		/* 82074A94h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00003674) );
		/* 82074A94h case    1:*/		return 0x82074A98;
		  /* 82074A98h */ case    2:  		/* subf R11, R29, R11 */
		/* 82074A98h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82074A98h case    2:*/		return 0x82074A9C;
		  /* 82074A9Ch */ case    3:  		/* addi R11, R11, -8 */
		/* 82074A9Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF8);
		/* 82074A9Ch case    3:*/		return 0x82074AA0;
		  /* 82074AA0h */ case    4:  		/* srawi R11, R11, 3 */
		/* 82074AA0h case    4:*/		cpu::op::srawi<0,3>(regs,&regs.R11,regs.R11);
		/* 82074AA0h case    4:*/		return 0x82074AA4;
		  /* 82074AA4h */ case    5:  		/* stw R11, <#[R29 + 4]> */
		/* 82074AA4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82074AA4h case    5:*/		return 0x82074AA8;
	}
	return 0x82074AA8;
} // Block from 82074A90h-82074AA8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82074AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074AA8);
		  /* 82074AA8h */ case    0:  		/* addi R4, R3, 136 */
		/* 82074AA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x88);
		/* 82074AA8h case    0:*/		return 0x82074AAC;
		  /* 82074AACh */ case    1:  		/* li R5, 0 */
		/* 82074AACh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82074AACh case    1:*/		return 0x82074AB0;
		  /* 82074AB0h */ case    2:  		/* bl 67352 */
		/* 82074AB0h case    2:*/		regs.LR = 0x82074AB4; return 0x820851C8;
		/* 82074AB0h case    2:*/		return 0x82074AB4;
	}
	return 0x82074AB4;
} // Block from 82074AA8h-82074AB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82074AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074AB4);
		  /* 82074AB4h */ case    0:  		/* addi R3, R31, 8 */
		/* 82074AB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x8);
		/* 82074AB4h case    0:*/		return 0x82074AB8;
		  /* 82074AB8h */ case    1:  		/* addi R11, R31, 136 */
		/* 82074AB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x88);
		/* 82074AB8h case    1:*/		return 0x82074ABC;
		  /* 82074ABCh */ case    2:  		/* stw R3, <#[R30 + 13940]> */
		/* 82074ABCh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00003674) );
		/* 82074ABCh case    2:*/		return 0x82074AC0;
		  /* 82074AC0h */ case    3:  		/* stw R11, <#[R30 + 13944]> */
		/* 82074AC0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00003678) );
		/* 82074AC0h case    3:*/		return 0x82074AC4;
		  /* 82074AC4h */ case    4:  		/* addi R1, R1, 112 */
		/* 82074AC4h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82074AC4h case    4:*/		return 0x82074AC8;
		  /* 82074AC8h */ case    5:  		/* b 116708 */
		/* 82074AC8h case    5:*/		return 0x820912AC;
		/* 82074AC8h case    5:*/		return 0x82074ACC;
		  /* 82074ACCh */ case    6:  		/* nop */
		/* 82074ACCh case    6:*/		cpu::op::nop();
		/* 82074ACCh case    6:*/		return 0x82074AD0;
	}
	return 0x82074AD0;
} // Block from 82074AB4h-82074AD0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82074AD0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074AD0);
		  /* 82074AD0h */ case    0:  		/* mfspr R12, LR */
		/* 82074AD0h case    0:*/		regs.R12 = regs.LR;
		/* 82074AD0h case    0:*/		return 0x82074AD4;
		  /* 82074AD4h */ case    1:  		/* bl 116608 */
		/* 82074AD4h case    1:*/		regs.LR = 0x82074AD8; return 0x82091254;
		/* 82074AD4h case    1:*/		return 0x82074AD8;
		  /* 82074AD8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82074AD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82074AD8h case    2:*/		return 0x82074ADC;
		  /* 82074ADCh */ case    3:  		/* mr R30, R3 */
		/* 82074ADCh case    3:*/		regs.R30 = regs.R3;
		/* 82074ADCh case    3:*/		return 0x82074AE0;
		  /* 82074AE0h */ case    4:  		/* mr R29, R4 */
		/* 82074AE0h case    4:*/		regs.R29 = regs.R4;
		/* 82074AE0h case    4:*/		return 0x82074AE4;
		  /* 82074AE4h */ case    5:  		/* mr R28, R5 */
		/* 82074AE4h case    5:*/		regs.R28 = regs.R5;
		/* 82074AE4h case    5:*/		return 0x82074AE8;
		  /* 82074AE8h */ case    6:  		/* mr R27, R6 */
		/* 82074AE8h case    6:*/		regs.R27 = regs.R6;
		/* 82074AE8h case    6:*/		return 0x82074AEC;
		  /* 82074AECh */ case    7:  		/* bl 2065420 */
		/* 82074AECh case    7:*/		regs.LR = 0x82074AF0; return 0x8226CEF8;
		/* 82074AECh case    7:*/		return 0x82074AF0;
		  /* 82074AF0h */ case    8:  		/* cmpwi CR6, R3, 2 */
		/* 82074AF0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82074AF0h case    8:*/		return 0x82074AF4;
		  /* 82074AF4h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 82074AF4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82074B04;  }
		/* 82074AF4h case    9:*/		return 0x82074AF8;
		  /* 82074AF8h */ case   10:  		/* lis R11, -32256 */
		/* 82074AF8h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074AF8h case   10:*/		return 0x82074AFC;
		  /* 82074AFCh */ case   11:  		/* lwz R11, <#[R11 + 1452]> */
		/* 82074AFCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005AC) );
		/* 82074AFCh case   11:*/		return 0x82074B00;
		  /* 82074B00h */ case   12:  		/* b 12 */
		/* 82074B00h case   12:*/		return 0x82074B0C;
		/* 82074B00h case   12:*/		return 0x82074B04;
	}
	return 0x82074B04;
} // Block from 82074AD0h-82074B04h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82074B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074B04);
		  /* 82074B04h */ case    0:  		/* lis R11, -32256 */
		/* 82074B04h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074B04h case    0:*/		return 0x82074B08;
		  /* 82074B08h */ case    1:  		/* lwz R11, <#[R11 + 1456]> */
		/* 82074B08h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005B0) );
		/* 82074B08h case    1:*/		return 0x82074B0C;
	}
	return 0x82074B0C;
} // Block from 82074B04h-82074B0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82074B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074B0C);
		  /* 82074B0Ch */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82074B0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82074B0Ch case    0:*/		return 0x82074B10;
		  /* 82074B10h */ case    1:  		/* addi R31, R11, 15376 */
		/* 82074B10h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x3C10);
		/* 82074B10h case    1:*/		return 0x82074B14;
		  /* 82074B14h */ case    2:  		/* mr R3, R31 */
		/* 82074B14h case    2:*/		regs.R3 = regs.R31;
		/* 82074B14h case    2:*/		return 0x82074B18;
		  /* 82074B18h */ case    3:  		/* bl 2065696 */
		/* 82074B18h case    3:*/		regs.LR = 0x82074B1C; return 0x8226D038;
		/* 82074B18h case    3:*/		return 0x82074B1C;
		  /* 82074B1Ch */ case    4:  		/* lwz R11, <#[R30 + 172]> */
		/* 82074B1Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000AC) );
		/* 82074B1Ch case    4:*/		return 0x82074B20;
		  /* 82074B20h */ case    5:  		/* mr R6, R27 */
		/* 82074B20h case    5:*/		regs.R6 = regs.R27;
		/* 82074B20h case    5:*/		return 0x82074B24;
		  /* 82074B24h */ case    6:  		/* lwz R3, <#[R30 + 164]> */
		/* 82074B24h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000000A4) );
		/* 82074B24h case    6:*/		return 0x82074B28;
		  /* 82074B28h */ case    7:  		/* mr R5, R28 */
		/* 82074B28h case    7:*/		regs.R5 = regs.R28;
		/* 82074B28h case    7:*/		return 0x82074B2C;
		  /* 82074B2Ch */ case    8:  		/* mr R4, R29 */
		/* 82074B2Ch case    8:*/		regs.R4 = regs.R29;
		/* 82074B2Ch case    8:*/		return 0x82074B30;
		  /* 82074B30h */ case    9:  		/* mtspr CTR, R11 */
		/* 82074B30h case    9:*/		regs.CTR = regs.R11;
		/* 82074B30h case    9:*/		return 0x82074B34;
		  /* 82074B34h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 82074B34h case   10:*/		if ( 1 ) { regs.LR = 0x82074B38; return (uint32)regs.CTR; }
		/* 82074B34h case   10:*/		return 0x82074B38;
		  /* 82074B38h */ case   11:  		/* mr R30, R3 */
		/* 82074B38h case   11:*/		regs.R30 = regs.R3;
		/* 82074B38h case   11:*/		return 0x82074B3C;
		  /* 82074B3Ch */ case   12:  		/* mr R3, R31 */
		/* 82074B3Ch case   12:*/		regs.R3 = regs.R31;
		/* 82074B3Ch case   12:*/		return 0x82074B40;
		  /* 82074B40h */ case   13:  		/* bl 2065640 */
		/* 82074B40h case   13:*/		regs.LR = 0x82074B44; return 0x8226D028;
		/* 82074B40h case   13:*/		return 0x82074B44;
		  /* 82074B44h */ case   14:  		/* mr R3, R30 */
		/* 82074B44h case   14:*/		regs.R3 = regs.R30;
		/* 82074B44h case   14:*/		return 0x82074B48;
		  /* 82074B48h */ case   15:  		/* addi R1, R1, 128 */
		/* 82074B48h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82074B48h case   15:*/		return 0x82074B4C;
		  /* 82074B4Ch */ case   16:  		/* b 116568 */
		/* 82074B4Ch case   16:*/		return 0x820912A4;
		/* 82074B4Ch case   16:*/		return 0x82074B50;
	}
	return 0x82074B50;
} // Block from 82074B0Ch-82074B50h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82074B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074B50);
		  /* 82074B50h */ case    0:  		/* mfspr R12, LR */
		/* 82074B50h case    0:*/		regs.R12 = regs.LR;
		/* 82074B50h case    0:*/		return 0x82074B54;
		  /* 82074B54h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82074B54h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074B54h case    1:*/		return 0x82074B58;
		  /* 82074B58h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82074B58h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82074B58h case    2:*/		return 0x82074B5C;
		  /* 82074B5Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82074B5Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074B5Ch case    3:*/		return 0x82074B60;
		  /* 82074B60h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82074B60h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82074B60h case    4:*/		return 0x82074B64;
		  /* 82074B64h */ case    5:  		/* mr R30, R3 */
		/* 82074B64h case    5:*/		regs.R30 = regs.R3;
		/* 82074B64h case    5:*/		return 0x82074B68;
	}
	return 0x82074B68;
} // Block from 82074B50h-82074B68h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82074B68h
// Function '?SetFence@CDevice@D3D@@QAAPAKPAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074B68);
		  /* 82074B68h */ case    0:  		/* bl 2065296 */
		/* 82074B68h case    0:*/		regs.LR = 0x82074B6C; return 0x8226CEF8;
		/* 82074B68h case    0:*/		return 0x82074B6C;
		  /* 82074B6Ch */ case    1:  		/* cmpwi CR6, R3, 2 */
		/* 82074B6Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82074B6Ch case    1:*/		return 0x82074B70;
		  /* 82074B70h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82074B70h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82074B80;  }
		/* 82074B70h case    2:*/		return 0x82074B74;
		  /* 82074B74h */ case    3:  		/* lis R11, -32256 */
		/* 82074B74h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074B74h case    3:*/		return 0x82074B78;
		  /* 82074B78h */ case    4:  		/* lwz R11, <#[R11 + 1452]> */
		/* 82074B78h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005AC) );
		/* 82074B78h case    4:*/		return 0x82074B7C;
		  /* 82074B7Ch */ case    5:  		/* b 12 */
		/* 82074B7Ch case    5:*/		return 0x82074B88;
		/* 82074B7Ch case    5:*/		return 0x82074B80;
	}
	return 0x82074B80;
} // Block from 82074B68h-82074B80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82074B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074B80);
		  /* 82074B80h */ case    0:  		/* lis R11, -32256 */
		/* 82074B80h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074B80h case    0:*/		return 0x82074B84;
		  /* 82074B84h */ case    1:  		/* lwz R11, <#[R11 + 1456]> */
		/* 82074B84h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x000005B0) );
		/* 82074B84h case    1:*/		return 0x82074B88;
	}
	return 0x82074B88;
} // Block from 82074B80h-82074B88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82074B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074B88);
		  /* 82074B88h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82074B88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82074B88h case    0:*/		return 0x82074B8C;
		  /* 82074B8Ch */ case    1:  		/* addi R31, R11, 15376 */
		/* 82074B8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x3C10);
		/* 82074B8Ch case    1:*/		return 0x82074B90;
		  /* 82074B90h */ case    2:  		/* mr R3, R31 */
		/* 82074B90h case    2:*/		regs.R3 = regs.R31;
		/* 82074B90h case    2:*/		return 0x82074B94;
		  /* 82074B94h */ case    3:  		/* bl 2065572 */
		/* 82074B94h case    3:*/		regs.LR = 0x82074B98; return 0x8226D038;
		/* 82074B94h case    3:*/		return 0x82074B98;
		  /* 82074B98h */ case    4:  		/* lwz R11, <#[R30 + 176]> */
		/* 82074B98h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000B0) );
		/* 82074B98h case    4:*/		return 0x82074B9C;
		  /* 82074B9Ch */ case    5:  		/* lwz R3, <#[R30 + 164]> */
		/* 82074B9Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x000000A4) );
		/* 82074B9Ch case    5:*/		return 0x82074BA0;
		  /* 82074BA0h */ case    6:  		/* mtspr CTR, R11 */
		/* 82074BA0h case    6:*/		regs.CTR = regs.R11;
		/* 82074BA0h case    6:*/		return 0x82074BA4;
		  /* 82074BA4h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82074BA4h case    7:*/		if ( 1 ) { regs.LR = 0x82074BA8; return (uint32)regs.CTR; }
		/* 82074BA4h case    7:*/		return 0x82074BA8;
		  /* 82074BA8h */ case    8:  		/* mr R3, R31 */
		/* 82074BA8h case    8:*/		regs.R3 = regs.R31;
		/* 82074BA8h case    8:*/		return 0x82074BAC;
		  /* 82074BACh */ case    9:  		/* bl 2065532 */
		/* 82074BACh case    9:*/		regs.LR = 0x82074BB0; return 0x8226D028;
		/* 82074BACh case    9:*/		return 0x82074BB0;
		  /* 82074BB0h */ case   10:  		/* addi R1, R1, 112 */
		/* 82074BB0h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82074BB0h case   10:*/		return 0x82074BB4;
		  /* 82074BB4h */ case   11:  		/* lwz R12, <#[R1 - 8]> */
		/* 82074BB4h case   11:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074BB4h case   11:*/		return 0x82074BB8;
		  /* 82074BB8h */ case   12:  		/* mtspr LR, R12 */
		/* 82074BB8h case   12:*/		regs.LR = regs.R12;
		/* 82074BB8h case   12:*/		return 0x82074BBC;
		  /* 82074BBCh */ case   13:  		/* ld R30, <#[R1 - 24]> */
		/* 82074BBCh case   13:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82074BBCh case   13:*/		return 0x82074BC0;
		  /* 82074BC0h */ case   14:  		/* ld R31, <#[R1 - 16]> */
		/* 82074BC0h case   14:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074BC0h case   14:*/		return 0x82074BC4;
		  /* 82074BC4h */ case   15:  		/* bclr 20, CR0_LT */
		/* 82074BC4h case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82074BC4h case   15:*/		return 0x82074BC8;
	}
	return 0x82074BC8;
} // Block from 82074B88h-82074BC8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82074BC8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074BC8);
		  /* 82074BC8h */ case    0:  		/* mfspr R12, LR */
		/* 82074BC8h case    0:*/		regs.R12 = regs.LR;
		/* 82074BC8h case    0:*/		return 0x82074BCC;
		  /* 82074BCCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82074BCCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074BCCh case    1:*/		return 0x82074BD0;
		  /* 82074BD0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82074BD0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074BD0h case    2:*/		return 0x82074BD4;
		  /* 82074BD4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82074BD4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82074BD4h case    3:*/		return 0x82074BD8;
		  /* 82074BD8h */ case    4:  		/* lwz R11, <#[R3 + 152]> */
		/* 82074BD8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000098) );
		/* 82074BD8h case    4:*/		return 0x82074BDC;
		  /* 82074BDCh */ case    5:  		/* mr R31, R3 */
		/* 82074BDCh case    5:*/		regs.R31 = regs.R3;
		/* 82074BDCh case    5:*/		return 0x82074BE0;
		  /* 82074BE0h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82074BE0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82074BE0h case    6:*/		return 0x82074BE4;
		  /* 82074BE4h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 82074BE4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82074BF0;  }
		/* 82074BE4h case    7:*/		return 0x82074BE8;
		  /* 82074BE8h */ case    8:  		/* bl -152 */
		/* 82074BE8h case    8:*/		regs.LR = 0x82074BEC; return 0x82074B50;
		/* 82074BE8h case    8:*/		return 0x82074BEC;
		  /* 82074BECh */ case    9:  		/* b 32 */
		/* 82074BECh case    9:*/		return 0x82074C0C;
		/* 82074BECh case    9:*/		return 0x82074BF0;
	}
	return 0x82074BF0;
} // Block from 82074BC8h-82074BF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82074BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074BF0);
		  /* 82074BF0h */ case    0:  		/* bl -736 */
		/* 82074BF0h case    0:*/		regs.LR = 0x82074BF4; return 0x82074910;
		/* 82074BF0h case    0:*/		return 0x82074BF4;
		  /* 82074BF4h */ case    1:  		/* lwz R11, <#[R31 + 108]> */
		/* 82074BF4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 82074BF4h case    1:*/		return 0x82074BF8;
		  /* 82074BF8h */ case    2:  		/* rlwinm. R11, R11, 0, 15, 15 */
		/* 82074BF8h case    2:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R11,regs.R11);
		/* 82074BF8h case    2:*/		return 0x82074BFC;
		  /* 82074BFCh */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82074BFCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x82074C0C;  }
		/* 82074BFCh case    3:*/		return 0x82074C00;
		  /* 82074C00h */ case    4:  		/* lis R4, -20096 */
		/* 82074C00h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB180);
		/* 82074C00h case    4:*/		return 0x82074C04;
		  /* 82074C04h */ case    5:  		/* lwz R3, <#[R31 + 152]> */
		/* 82074C04h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000098) );
		/* 82074C04h case    5:*/		return 0x82074C08;
		  /* 82074C08h */ case    6:  		/* bl 79664 */
		/* 82074C08h case    6:*/		regs.LR = 0x82074C0C; return 0x82088338;
		/* 82074C08h case    6:*/		return 0x82074C0C;
	}
	return 0x82074C0C;
} // Block from 82074BF0h-82074C0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82074C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074C0C);
		  /* 82074C0Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 82074C0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82074C0Ch case    0:*/		return 0x82074C10;
		  /* 82074C10h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82074C10h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074C10h case    1:*/		return 0x82074C14;
		  /* 82074C14h */ case    2:  		/* mtspr LR, R12 */
		/* 82074C14h case    2:*/		regs.LR = regs.R12;
		/* 82074C14h case    2:*/		return 0x82074C18;
		  /* 82074C18h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82074C18h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074C18h case    3:*/		return 0x82074C1C;
		  /* 82074C1Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 82074C1Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82074C1Ch case    4:*/		return 0x82074C20;
	}
	return 0x82074C20;
} // Block from 82074C0Ch-82074C20h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82074C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074C20);
		  /* 82074C20h */ case    0:  		/* lhz R11, <#[R4]> */
		/* 82074C20h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82074C20h case    0:*/		return 0x82074C24;
		  /* 82074C24h */ case    1:  		/* lhz R9, <#[R4 + 2]> */
		/* 82074C24h case    1:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000002) );
		/* 82074C24h case    1:*/		return 0x82074C28;
		  /* 82074C28h */ case    2:  		/* rlwinm R10, R11, 26, 6, 31 */
		/* 82074C28h case    2:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R10,regs.R11);
		/* 82074C28h case    2:*/		return 0x82074C2C;
		  /* 82074C2Ch */ case    3:  		/* rlwinm R11, R9, 26, 6, 31 */
		/* 82074C2Ch case    3:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R11,regs.R9);
		/* 82074C2Ch case    3:*/		return 0x82074C30;
		  /* 82074C30h */ case    4:  		/* add R11, R11, R10 */
		/* 82074C30h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82074C30h case    4:*/		return 0x82074C34;
		  /* 82074C34h */ case    5:  		/* rlwinm R9, R11, 0, 16, 31 */
		/* 82074C34h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R11);
		/* 82074C34h case    5:*/		return 0x82074C38;
		  /* 82074C38h */ case    6:  		/* cmplwi CR6, R9, 1023 */
		/* 82074C38h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x000003FF);
		/* 82074C38h case    6:*/		return 0x82074C3C;
		  /* 82074C3Ch */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 82074C3Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x82074C44;  }
		/* 82074C3Ch case    7:*/		return 0x82074C40;
		  /* 82074C40h */ case    8:  		/* li R11, 1023 */
		/* 82074C40h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x3FF);
		/* 82074C40h case    8:*/		return 0x82074C44;
	}
	return 0x82074C44;
} // Block from 82074C20h-82074C44h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82074C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074C44);
		  /* 82074C44h */ case    0:  		/* rlwinm R10, R10, 1, 15, 30 */
		/* 82074C44h case    0:*/		cpu::op::rlwinm<0,1,15,30>(regs,&regs.R10,regs.R10);
		/* 82074C44h case    0:*/		return 0x82074C48;
		  /* 82074C48h */ case    1:  		/* rlwinm R11, R11, 1, 15, 30 */
		/* 82074C48h case    1:*/		cpu::op::rlwinm<0,1,15,30>(regs,&regs.R11,regs.R11);
		/* 82074C48h case    1:*/		return 0x82074C4C;
		  /* 82074C4Ch */ case    2:  		/* lhzx R9, <#[R10 + R5]> */
		/* 82074C4Ch case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 82074C4Ch case    2:*/		return 0x82074C50;
		  /* 82074C50h */ case    3:  		/* rlwinm R9, R9, 6, 16, 25 */
		/* 82074C50h case    3:*/		cpu::op::rlwinm<0,6,16,25>(regs,&regs.R9,regs.R9);
		/* 82074C50h case    3:*/		return 0x82074C54;
		  /* 82074C54h */ case    4:  		/* sth R9, <#[R3]> */
		/* 82074C54h case    4:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82074C54h case    4:*/		return 0x82074C58;
		  /* 82074C58h */ case    5:  		/* lhzx R11, <#[R11 + R5]> */
		/* 82074C58h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 82074C58h case    5:*/		return 0x82074C5C;
		  /* 82074C5Ch */ case    6:  		/* lhzx R10, <#[R10 + R5]> */
		/* 82074C5Ch case    6:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 82074C5Ch case    6:*/		return 0x82074C60;
		  /* 82074C60h */ case    7:  		/* subf R11, R10, R11 */
		/* 82074C60h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82074C60h case    7:*/		return 0x82074C64;
		  /* 82074C64h */ case    8:  		/* rlwinm R11, R11, 6, 16, 25 */
		/* 82074C64h case    8:*/		cpu::op::rlwinm<0,6,16,25>(regs,&regs.R11,regs.R11);
		/* 82074C64h case    8:*/		return 0x82074C68;
		  /* 82074C68h */ case    9:  		/* sth R11, <#[R3 + 2]> */
		/* 82074C68h case    9:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00000002) );
		/* 82074C68h case    9:*/		return 0x82074C6C;
		  /* 82074C6Ch */ case   10:  		/* bclr 20, CR0_LT */
		/* 82074C6Ch case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82074C6Ch case   10:*/		return 0x82074C70;
	}
	return 0x82074C70;
} // Block from 82074C44h-82074C70h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82074C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074C70);
		  /* 82074C70h */ case    0:  		/* mfspr R12, LR */
		/* 82074C70h case    0:*/		regs.R12 = regs.LR;
		/* 82074C70h case    0:*/		return 0x82074C74;
		  /* 82074C74h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82074C74h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074C74h case    1:*/		return 0x82074C78;
		  /* 82074C78h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82074C78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82074C78h case    2:*/		return 0x82074C7C;
		  /* 82074C7Ch */ case    3:  		/* cmpwi CR6, R4, 0 */
		/* 82074C7Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82074C7Ch case    3:*/		return 0x82074C80;
		  /* 82074C80h */ case    4:  		/* bc 12, CR6_EQ, 76 */
		/* 82074C80h case    4:*/		if ( regs.CR[6].eq ) { return 0x82074CCC;  }
		/* 82074C80h case    4:*/		return 0x82074C84;
		  /* 82074C84h */ case    5:  		/* lis R11, -32256 */
		/* 82074C84h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074C84h case    5:*/		return 0x82074C88;
		  /* 82074C88h */ case    6:  		/* lfd FR0, <#[R11 + 4648]> */
		/* 82074C88h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001228) );
		/* 82074C88h case    6:*/		return 0x82074C8C;
		  /* 82074C8Ch */ case    7:  		/* fcmpu CR6, FR1, FR0 */
		/* 82074C8Ch case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82074C8Ch case    7:*/		return 0x82074C90;
		  /* 82074C90h */ case    8:  		/* bc 12, CR6_GT, 16 */
		/* 82074C90h case    8:*/		if ( regs.CR[6].gt ) { return 0x82074CA0;  }
		/* 82074C90h case    8:*/		return 0x82074C94;
		  /* 82074C94h */ case    9:  		/* lis R11, -32256 */
		/* 82074C94h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074C94h case    9:*/		return 0x82074C98;
		  /* 82074C98h */ case   10:  		/* lfs FR0, <#[R11 + 4640]> */
		/* 82074C98h case   10:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001220) );
		/* 82074C98h case   10:*/		return 0x82074C9C;
		  /* 82074C9Ch */ case   11:  		/* b 72 */
		/* 82074C9Ch case   11:*/		return 0x82074CE4;
		/* 82074C9Ch case   11:*/		return 0x82074CA0;
	}
	return 0x82074CA0;
} // Block from 82074C70h-82074CA0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82074CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074CA0);
		  /* 82074CA0h */ case    0:  		/* lis R11, -32256 */
		/* 82074CA0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074CA0h case    0:*/		return 0x82074CA4;
		  /* 82074CA4h */ case    1:  		/* lis R9, -32256 */
		/* 82074CA4h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82074CA4h case    1:*/		return 0x82074CA8;
	}
	return 0x82074CA8;
} // Block from 82074CA0h-82074CA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82074CA8h
// Function '?KickOffSegment@CDevice@D3D@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074CA8);
		  /* 82074CA8h */ case    0:  		/* lis R10, -32256 */
		/* 82074CA8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82074CA8h case    0:*/		return 0x82074CAC;
		  /* 82074CACh */ case    1:  		/* lfs FR0, <#[R11 + 4636]> */
		/* 82074CACh case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x0000121C) );
		/* 82074CACh case    1:*/		return 0x82074CB0;
		  /* 82074CB0h */ case    2:  		/* fadds FR13, FR1, FR0 */
		/* 82074CB0h case    2:*/		cpu::op::fadds<0>(regs,&regs.FR13,regs.FR1,regs.FR0);
		/* 82074CB0h case    2:*/		return 0x82074CB4;
		  /* 82074CB4h */ case    3:  		/* lfs FR0, <#[R9 + 4632]> */
		/* 82074CB4h case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00001218) );
		/* 82074CB4h case    3:*/		return 0x82074CB8;
		  /* 82074CB8h */ case    4:  		/* lfd FR2, <#[R10 + 4624]> */
		/* 82074CB8h case    4:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R10 + 0x00001210) );
		/* 82074CB8h case    4:*/		return 0x82074CBC;
		  /* 82074CBCh */ case    5:  		/* fmuls FR1, FR13, FR0 */
		/* 82074CBCh case    5:*/		cpu::op::fmuls<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 82074CBCh case    5:*/		return 0x82074CC0;
		  /* 82074CC0h */ case    6:  		/* bl 121080 */
		/* 82074CC0h case    6:*/		regs.LR = 0x82074CC4; return 0x820925B8;
		/* 82074CC0h case    6:*/		return 0x82074CC4;
		  /* 82074CC4h */ case    7:  		/* frsp FR1, FR1 */
		/* 82074CC4h case    7:*/		cpu::op::frsp<0>(regs,&regs.FR1,regs.FR1);
		/* 82074CC4h case    7:*/		return 0x82074CC8;
		  /* 82074CC8h */ case    8:  		/* b 72 */
		/* 82074CC8h case    8:*/		return 0x82074D10;
		/* 82074CC8h case    8:*/		return 0x82074CCC;
	}
	return 0x82074CCC;
} // Block from 82074CA8h-82074CCCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82074CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074CCC);
		  /* 82074CCCh */ case    0:  		/* lis R11, -32256 */
		/* 82074CCCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074CCCh case    0:*/		return 0x82074CD0;
		  /* 82074CD0h */ case    1:  		/* lfd FR0, <#[R11 + 4616]> */
		/* 82074CD0h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001208) );
		/* 82074CD0h case    1:*/		return 0x82074CD4;
		  /* 82074CD4h */ case    2:  		/* fcmpu CR6, FR1, FR0 */
		/* 82074CD4h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82074CD4h case    2:*/		return 0x82074CD8;
		  /* 82074CD8h */ case    3:  		/* bc 12, CR6_GT, 20 */
		/* 82074CD8h case    3:*/		if ( regs.CR[6].gt ) { return 0x82074CEC;  }
		/* 82074CD8h case    3:*/		return 0x82074CDC;
		  /* 82074CDCh */ case    4:  		/* lis R11, -32256 */
		/* 82074CDCh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074CDCh case    4:*/		return 0x82074CE0;
		  /* 82074CE0h */ case    5:  		/* lfs FR0, <#[R11 + 4608]> */
		/* 82074CE0h case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001200) );
		/* 82074CE0h case    5:*/		return 0x82074CE4;
	}
	return 0x82074CE4;
} // Block from 82074CCCh-82074CE4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82074CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074CE4);
		  /* 82074CE4h */ case    0:  		/* fmuls FR1, FR1, FR0 */
		/* 82074CE4h case    0:*/		cpu::op::fmuls<0>(regs,&regs.FR1,regs.FR1,regs.FR0);
		/* 82074CE4h case    0:*/		return 0x82074CE8;
		  /* 82074CE8h */ case    1:  		/* b 40 */
		/* 82074CE8h case    1:*/		return 0x82074D10;
		/* 82074CE8h case    1:*/		return 0x82074CEC;
	}
	return 0x82074CEC;
} // Block from 82074CE4h-82074CECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82074CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074CEC);
		  /* 82074CECh */ case    0:  		/* lis R11, -32256 */
		/* 82074CECh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074CECh case    0:*/		return 0x82074CF0;
		  /* 82074CF0h */ case    1:  		/* lfd FR2, <#[R11 + 4600]> */
		/* 82074CF0h case    1:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0x000011F8) );
		/* 82074CF0h case    1:*/		return 0x82074CF4;
		  /* 82074CF4h */ case    2:  		/* bl 121028 */
		/* 82074CF4h case    2:*/		regs.LR = 0x82074CF8; return 0x820925B8;
		/* 82074CF4h case    2:*/		return 0x82074CF8;
		  /* 82074CF8h */ case    3:  		/* frsp FR12, FR1 */
		/* 82074CF8h case    3:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR1);
		/* 82074CF8h case    3:*/		return 0x82074CFC;
		  /* 82074CFCh */ case    4:  		/* lis R11, -32256 */
		/* 82074CFCh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074CFCh case    4:*/		return 0x82074D00;
		  /* 82074D00h */ case    5:  		/* lis R10, -32256 */
		/* 82074D00h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82074D00h case    5:*/		return 0x82074D04;
		  /* 82074D04h */ case    6:  		/* lfs FR0, <#[R11 + 4596]> */
		/* 82074D04h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x000011F4) );
		/* 82074D04h case    6:*/		return 0x82074D08;
		  /* 82074D08h */ case    7:  		/* lfs FR13, <#[R10 + 4636]> */
		/* 82074D08h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x0000121C) );
		/* 82074D08h case    7:*/		return 0x82074D0C;
		  /* 82074D0Ch */ case    8:  		/* fmsubs FR1, FR12, FR0, FR13 */
		/* 82074D0Ch case    8:*/		cpu::op::fmsubs<0>(regs,&regs.FR1,regs.FR12,regs.FR0,regs.FR13);
		/* 82074D0Ch case    8:*/		return 0x82074D10;
	}
	return 0x82074D10;
} // Block from 82074CECh-82074D10h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82074D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074D10);
		  /* 82074D10h */ case    0:  		/* addi R1, R1, 96 */
		/* 82074D10h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82074D10h case    0:*/		return 0x82074D14;
		  /* 82074D14h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82074D14h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074D14h case    1:*/		return 0x82074D18;
		  /* 82074D18h */ case    2:  		/* mtspr LR, R12 */
		/* 82074D18h case    2:*/		regs.LR = regs.R12;
		/* 82074D18h case    2:*/		return 0x82074D1C;
		  /* 82074D1Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 82074D1Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82074D1Ch case    3:*/		return 0x82074D20;
	}
	return 0x82074D20;
} // Block from 82074D10h-82074D20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82074D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074D20);
		  /* 82074D20h */ case    0:  		/* mfspr R12, LR */
		/* 82074D20h case    0:*/		regs.R12 = regs.LR;
		/* 82074D20h case    0:*/		return 0x82074D24;
		  /* 82074D24h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82074D24h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074D24h case    1:*/		return 0x82074D28;
		  /* 82074D28h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82074D28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82074D28h case    2:*/		return 0x82074D2C;
		  /* 82074D2Ch */ case    3:  		/* cmpwi CR6, R4, 0 */
		/* 82074D2Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82074D2Ch case    3:*/		return 0x82074D30;
		  /* 82074D30h */ case    4:  		/* bc 12, CR6_EQ, 76 */
		/* 82074D30h case    4:*/		if ( regs.CR[6].eq ) { return 0x82074D7C;  }
		/* 82074D30h case    4:*/		return 0x82074D34;
		  /* 82074D34h */ case    5:  		/* lis R11, -32256 */
		/* 82074D34h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074D34h case    5:*/		return 0x82074D38;
		  /* 82074D38h */ case    6:  		/* lfd FR0, <#[R11 + 4712]> */
		/* 82074D38h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001268) );
		/* 82074D38h case    6:*/		return 0x82074D3C;
		  /* 82074D3Ch */ case    7:  		/* fcmpu CR6, FR1, FR0 */
		/* 82074D3Ch case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82074D3Ch case    7:*/		return 0x82074D40;
		  /* 82074D40h */ case    8:  		/* bc 4, CR6_LT, 16 */
		/* 82074D40h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82074D50;  }
		/* 82074D40h case    8:*/		return 0x82074D44;
		  /* 82074D44h */ case    9:  		/* lis R11, -32256 */
		/* 82074D44h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074D44h case    9:*/		return 0x82074D48;
		  /* 82074D48h */ case   10:  		/* lfs FR0, <#[R11 + 4704]> */
		/* 82074D48h case   10:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001260) );
		/* 82074D48h case   10:*/		return 0x82074D4C;
		  /* 82074D4Ch */ case   11:  		/* b 72 */
		/* 82074D4Ch case   11:*/		return 0x82074D94;
		/* 82074D4Ch case   11:*/		return 0x82074D50;
	}
	return 0x82074D50;
} // Block from 82074D20h-82074D50h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82074D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074D50);
		  /* 82074D50h */ case    0:  		/* lis R11, -32256 */
		/* 82074D50h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074D50h case    0:*/		return 0x82074D54;
		  /* 82074D54h */ case    1:  		/* lis R9, -32256 */
		/* 82074D54h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82074D54h case    1:*/		return 0x82074D58;
		  /* 82074D58h */ case    2:  		/* lis R10, -32256 */
		/* 82074D58h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82074D58h case    2:*/		return 0x82074D5C;
		  /* 82074D5Ch */ case    3:  		/* lfs FR0, <#[R11 + 4700]> */
		/* 82074D5Ch case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x0000125C) );
		/* 82074D5Ch case    3:*/		return 0x82074D60;
		  /* 82074D60h */ case    4:  		/* fadds FR13, FR1, FR0 */
		/* 82074D60h case    4:*/		cpu::op::fadds<0>(regs,&regs.FR13,regs.FR1,regs.FR0);
		/* 82074D60h case    4:*/		return 0x82074D64;
		  /* 82074D64h */ case    5:  		/* lfs FR0, <#[R9 + 4696]> */
		/* 82074D64h case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00001258) );
		/* 82074D64h case    5:*/		return 0x82074D68;
		  /* 82074D68h */ case    6:  		/* lfd FR2, <#[R10 + 4688]> */
		/* 82074D68h case    6:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R10 + 0x00001250) );
		/* 82074D68h case    6:*/		return 0x82074D6C;
		  /* 82074D6Ch */ case    7:  		/* fmuls FR1, FR13, FR0 */
		/* 82074D6Ch case    7:*/		cpu::op::fmuls<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 82074D6Ch case    7:*/		return 0x82074D70;
		  /* 82074D70h */ case    8:  		/* bl 120904 */
		/* 82074D70h case    8:*/		regs.LR = 0x82074D74; return 0x820925B8;
		/* 82074D70h case    8:*/		return 0x82074D74;
		  /* 82074D74h */ case    9:  		/* frsp FR1, FR1 */
		/* 82074D74h case    9:*/		cpu::op::frsp<0>(regs,&regs.FR1,regs.FR1);
		/* 82074D74h case    9:*/		return 0x82074D78;
		  /* 82074D78h */ case   10:  		/* b 72 */
		/* 82074D78h case   10:*/		return 0x82074DC0;
		/* 82074D78h case   10:*/		return 0x82074D7C;
	}
	return 0x82074D7C;
} // Block from 82074D50h-82074D7Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82074D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074D7C);
		  /* 82074D7Ch */ case    0:  		/* lis R11, -32256 */
		/* 82074D7Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074D7Ch case    0:*/		return 0x82074D80;
		  /* 82074D80h */ case    1:  		/* lfd FR0, <#[R11 + 4680]> */
		/* 82074D80h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001248) );
		/* 82074D80h case    1:*/		return 0x82074D84;
		  /* 82074D84h */ case    2:  		/* fcmpu CR6, FR1, FR0 */
		/* 82074D84h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82074D84h case    2:*/		return 0x82074D88;
		  /* 82074D88h */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 82074D88h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82074D9C;  }
		/* 82074D88h case    3:*/		return 0x82074D8C;
		  /* 82074D8Ch */ case    4:  		/* lis R11, -32256 */
		/* 82074D8Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074D8Ch case    4:*/		return 0x82074D90;
		  /* 82074D90h */ case    5:  		/* lfs FR0, <#[R11 + 4672]> */
		/* 82074D90h case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001240) );
		/* 82074D90h case    5:*/		return 0x82074D94;
	}
	return 0x82074D94;
} // Block from 82074D7Ch-82074D94h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82074D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074D94);
		  /* 82074D94h */ case    0:  		/* fmuls FR1, FR1, FR0 */
		/* 82074D94h case    0:*/		cpu::op::fmuls<0>(regs,&regs.FR1,regs.FR1,regs.FR0);
		/* 82074D94h case    0:*/		return 0x82074D98;
		  /* 82074D98h */ case    1:  		/* b 40 */
		/* 82074D98h case    1:*/		return 0x82074DC0;
		/* 82074D98h case    1:*/		return 0x82074D9C;
	}
	return 0x82074D9C;
} // Block from 82074D94h-82074D9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82074D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074D9C);
		  /* 82074D9Ch */ case    0:  		/* lis R11, -32256 */
		/* 82074D9Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074D9Ch case    0:*/		return 0x82074DA0;
		  /* 82074DA0h */ case    1:  		/* lfd FR2, <#[R11 + 4664]> */
		/* 82074DA0h case    1:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0x00001238) );
		/* 82074DA0h case    1:*/		return 0x82074DA4;
		  /* 82074DA4h */ case    2:  		/* bl 120852 */
		/* 82074DA4h case    2:*/		regs.LR = 0x82074DA8; return 0x820925B8;
		/* 82074DA4h case    2:*/		return 0x82074DA8;
		  /* 82074DA8h */ case    3:  		/* frsp FR12, FR1 */
		/* 82074DA8h case    3:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR1);
		/* 82074DA8h case    3:*/		return 0x82074DAC;
		  /* 82074DACh */ case    4:  		/* lis R11, -32256 */
		/* 82074DACh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074DACh case    4:*/		return 0x82074DB0;
		  /* 82074DB0h */ case    5:  		/* lis R10, -32256 */
		/* 82074DB0h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82074DB0h case    5:*/		return 0x82074DB4;
		  /* 82074DB4h */ case    6:  		/* lfs FR0, <#[R11 + 4656]> */
		/* 82074DB4h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001230) );
		/* 82074DB4h case    6:*/		return 0x82074DB8;
		  /* 82074DB8h */ case    7:  		/* lfs FR13, <#[R10 + 4700]> */
		/* 82074DB8h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x0000125C) );
		/* 82074DB8h case    7:*/		return 0x82074DBC;
		  /* 82074DBCh */ case    8:  		/* fmsubs FR1, FR12, FR0, FR13 */
		/* 82074DBCh case    8:*/		cpu::op::fmsubs<0>(regs,&regs.FR1,regs.FR12,regs.FR0,regs.FR13);
		/* 82074DBCh case    8:*/		return 0x82074DC0;
	}
	return 0x82074DC0;
} // Block from 82074D9Ch-82074DC0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82074DC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074DC0);
		  /* 82074DC0h */ case    0:  		/* addi R1, R1, 96 */
		/* 82074DC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82074DC0h case    0:*/		return 0x82074DC4;
		  /* 82074DC4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82074DC4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074DC4h case    1:*/		return 0x82074DC8;
		  /* 82074DC8h */ case    2:  		/* mtspr LR, R12 */
		/* 82074DC8h case    2:*/		regs.LR = regs.R12;
		/* 82074DC8h case    2:*/		return 0x82074DCC;
		  /* 82074DCCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 82074DCCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82074DCCh case    3:*/		return 0x82074DD0;
	}
	return 0x82074DD0;
} // Block from 82074DC0h-82074DD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82074DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074DD0);
		  /* 82074DD0h */ case    0:  		/* mfspr R12, LR */
		/* 82074DD0h case    0:*/		regs.R12 = regs.LR;
		/* 82074DD0h case    0:*/		return 0x82074DD4;
		  /* 82074DD4h */ case    1:  		/* bl 115844 */
		/* 82074DD4h case    1:*/		regs.LR = 0x82074DD8; return 0x82091258;
		/* 82074DD4h case    1:*/		return 0x82074DD8;
		  /* 82074DD8h */ case    2:  		/* addi R12, R1, -40 */
		/* 82074DD8h case    2:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFD8);
		/* 82074DD8h case    2:*/		return 0x82074DDC;
		  /* 82074DDCh */ case    3:  		/* bl 116284 */
		/* 82074DDCh case    3:*/		regs.LR = 0x82074DE0; return 0x82091418;
		/* 82074DDCh case    3:*/		return 0x82074DE0;
		  /* 82074DE0h */ case    4:  		/* stwu R1, <#[R1 - 176]> */
		/* 82074DE0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82074DE0h case    4:*/		return 0x82074DE4;
		  /* 82074DE4h */ case    5:  		/* mr R30, R3 */
		/* 82074DE4h case    5:*/		regs.R30 = regs.R3;
		/* 82074DE4h case    5:*/		return 0x82074DE8;
		  /* 82074DE8h */ case    6:  		/* addic R11, R3, -1 */
		/* 82074DE8h case    6:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 82074DE8h case    6:*/		return 0x82074DEC;
		  /* 82074DECh */ case    7:  		/* addi R4, R1, 80 */
		/* 82074DECh case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82074DECh case    7:*/		return 0x82074DF0;
		  /* 82074DF0h */ case    8:  		/* addi R3, R1, 84 */
		/* 82074DF0h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x54);
		/* 82074DF0h case    8:*/		return 0x82074DF4;
		  /* 82074DF4h */ case    9:  		/* subfe R31, R11, R30 */
		/* 82074DF4h case    9:*/		cpu::op::subfe<0>(regs,&regs.R31,regs.R11,regs.R30);
		/* 82074DF4h case    9:*/		return 0x82074DF8;
		  /* 82074DF8h */ case   10:  		/* bl 2064976 */
		/* 82074DF8h case   10:*/		regs.LR = 0x82074DFC; return 0x8226D048;
		/* 82074DF8h case   10:*/		return 0x82074DFC;
		  /* 82074DFCh */ case   11:  		/* lis R10, -32217 */
		/* 82074DFCh case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82074DFCh case   11:*/		return 0x82074E00;
		  /* 82074E00h */ case   12:  		/* lis R9, -32216 */
		/* 82074E00h case   12:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8228);
		/* 82074E00h case   12:*/		return 0x82074E04;
		  /* 82074E04h */ case   13:  		/* lfs FR2, <#[R1 + 80]> */
		/* 82074E04h case   13:*/		cpu::mem::load32f( regs, &regs.FR2, (uint32)(regs.R1 + 0x00000050) );
		/* 82074E04h case   13:*/		return 0x82074E08;
		  /* 82074E08h */ case   14:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 82074E08h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 82074E08h case   14:*/		return 0x82074E0C;
		  /* 82074E0Ch */ case   15:  		/* addi R10, R10, 1680 */
		/* 82074E0Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x690);
		/* 82074E0Ch case   15:*/		return 0x82074E10;
		  /* 82074E10h */ case   16:  		/* addi R9, R9, 28752 */
		/* 82074E10h case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x7050);
		/* 82074E10h case   16:*/		return 0x82074E14;
		  /* 82074E14h */ case   17:  		/* rlwinm R8, R31, 11, 0, 20 */
		/* 82074E14h case   17:*/		cpu::op::rlwinm<0,11,0,20>(regs,&regs.R8,regs.R31);
		/* 82074E14h case   17:*/		return 0x82074E18;
		  /* 82074E18h */ case   18:  		/* lis R7, -32216 */
		/* 82074E18h case   18:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8228);
		/* 82074E18h case   18:*/		return 0x82074E1C;
		  /* 82074E1Ch */ case   19:  		/* add R28, R8, R9 */
		/* 82074E1Ch case   19:*/		cpu::op::add<0>(regs,&regs.R28,regs.R8,regs.R9);
		/* 82074E1Ch case   19:*/		return 0x82074E20;
		  /* 82074E20h */ case   20:  		/* addi R9, R7, 28744 */
		/* 82074E20h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R7,0x7048);
		/* 82074E20h case   20:*/		return 0x82074E24;
		  /* 82074E24h */ case   21:  		/* lwzx R7, <#[R11 + R10]> */
		/* 82074E24h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82074E24h case   21:*/		return 0x82074E28;
	}
	return 0x82074E28;
} // Block from 82074DD0h-82074E28h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82074E28h
// Function '?QueueIndirectBuffer@CDevice@D3D@@QAAPAKPAKKKKPAVCWorkerThreadCommandList@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074E28);
		  /* 82074E28h */ case    0:  		/* lwz R8, <#[R1 + 84]> */
		/* 82074E28h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 82074E28h case    0:*/		return 0x82074E2C;
		  /* 82074E2Ch */ case    1:  		/* cmplw CR6, R7, R8 */
		/* 82074E2Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 82074E2Ch case    1:*/		return 0x82074E30;
		  /* 82074E30h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82074E30h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82074E40;  }
		/* 82074E30h case    2:*/		return 0x82074E34;
		  /* 82074E34h */ case    3:  		/* lfsx FR0, <#[R11 + R9]> */
		/* 82074E34h case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82074E34h case    3:*/		return 0x82074E38;
		  /* 82074E38h */ case    4:  		/* fcmpu CR6, FR0, FR2 */
		/* 82074E38h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR2);
		/* 82074E38h case    4:*/		return 0x82074E3C;
		  /* 82074E3Ch */ case    5:  		/* bc 12, CR6_EQ, 260 */
		/* 82074E3Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82074F40;  }
		/* 82074E3Ch case    5:*/		return 0x82074E40;
	}
	return 0x82074E40;
} // Block from 82074E28h-82074E40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82074E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074E40);
		  /* 82074E40h */ case    0:  		/* stfsx FR2, <#[R11 + R9]> */
		/* 82074E40h case    0:*/		cpu::mem::store32f( regs, regs.FR2, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82074E40h case    0:*/		return 0x82074E44;
		  /* 82074E44h */ case    1:  		/* stwx R8, <#[R11 + R10]> */
		/* 82074E44h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82074E44h case    1:*/		return 0x82074E48;
		  /* 82074E48h */ case    2:  		/* lis R11, -32256 */
		/* 82074E48h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82074E48h case    2:*/		return 0x82074E4C;
		  /* 82074E4Ch */ case    3:  		/* lis R10, -32256 */
		/* 82074E4Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82074E4Ch case    3:*/		return 0x82074E50;
		  /* 82074E50h */ case    4:  		/* lis R9, -32256 */
		/* 82074E50h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82074E50h case    4:*/		return 0x82074E54;
		  /* 82074E54h */ case    5:  		/* lis R7, -32256 */
		/* 82074E54h case    5:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8200);
		/* 82074E54h case    5:*/		return 0x82074E58;
		  /* 82074E58h */ case    6:  		/* li R31, 0 */
		/* 82074E58h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82074E58h case    6:*/		return 0x82074E5C;
		  /* 82074E5Ch */ case    7:  		/* lfd FR29, <#[R11 + 4736]> */
		/* 82074E5Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R11 + 0x00001280) );
		/* 82074E5Ch case    7:*/		return 0x82074E60;
		  /* 82074E60h */ case    8:  		/* addi R29, R28, -2 */
		/* 82074E60h case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R28,0xFFFFFFFE);
		/* 82074E60h case    8:*/		return 0x82074E64;
		  /* 82074E64h */ case    9:  		/* lfd FR30, <#[R10 + 4728]> */
		/* 82074E64h case    9:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R10 + 0x00001278) );
		/* 82074E64h case    9:*/		return 0x82074E68;
		  /* 82074E68h */ case   10:  		/* lfs FR31, <#[R9 + 1792]> */
		/* 82074E68h case   10:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R9 + 0x00000700) );
		/* 82074E68h case   10:*/		return 0x82074E6C;
		  /* 82074E6Ch */ case   11:  		/* lfs FR28, <#[R7 + 4720]> */
		/* 82074E6Ch case   11:*/		cpu::mem::load32f( regs, &regs.FR28, (uint32)(regs.R7 + 0x00001270) );
		/* 82074E6Ch case   11:*/		return 0x82074E70;
		  /* 82074E70h */ case   12:  		/* b 12 */
		/* 82074E70h case   12:*/		return 0x82074E7C;
		/* 82074E70h case   12:*/		return 0x82074E74;
		  /* 82074E74h */ case   13:  		/* lfs FR2, <#[R1 + 80]> */
		/* 82074E74h case   13:*/		cpu::mem::load32f( regs, &regs.FR2, (uint32)(regs.R1 + 0x00000050) );
		/* 82074E74h case   13:*/		return 0x82074E78;
		  /* 82074E78h */ case   14:  		/* lwz R8, <#[R1 + 84]> */
		/* 82074E78h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 82074E78h case   14:*/		return 0x82074E7C;
	}
	return 0x82074E7C;
} // Block from 82074E40h-82074E7Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 82074E7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074E7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074E7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074E7C);
		  /* 82074E7Ch */ case    0:  		/* extsw R11, R31 */
		/* 82074E7Ch case    0:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R31);
		/* 82074E7Ch case    0:*/		return 0x82074E80;
		  /* 82074E80h */ case    1:  		/* cmpwi CR6, R30, 0 */
		/* 82074E80h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82074E80h case    1:*/		return 0x82074E84;
		  /* 82074E84h */ case    2:  		/* std R11, <#[R1 + 88]> */
		/* 82074E84h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82074E84h case    2:*/		return 0x82074E88;
		  /* 82074E88h */ case    3:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82074E88h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82074E88h case    3:*/		return 0x82074E8C;
		  /* 82074E8Ch */ case    4:  		/* fcfid FR0, FR0 */
		/* 82074E8Ch case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82074E8Ch case    4:*/		return 0x82074E90;
		  /* 82074E90h */ case    5:  		/* frsp FR0, FR0 */
		/* 82074E90h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82074E90h case    5:*/		return 0x82074E94;
		  /* 82074E94h */ case    6:  		/* fmuls FR1, FR0, FR28 */
		/* 82074E94h case    6:*/		cpu::op::fmuls<0>(regs,&regs.FR1,regs.FR0,regs.FR28);
		/* 82074E94h case    6:*/		return 0x82074E98;
		  /* 82074E98h */ case    7:  		/* bc 4, CR6_EQ, 20 */
		/* 82074E98h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82074EAC;  }
		/* 82074E98h case    7:*/		return 0x82074E9C;
		  /* 82074E9Ch */ case    8:  		/* li R4, 1 */
		/* 82074E9Ch case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82074E9Ch case    8:*/		return 0x82074EA0;
		  /* 82074EA0h */ case    9:  		/* bl -560 */
		/* 82074EA0h case    9:*/		regs.LR = 0x82074EA4; return 0x82074C70;
		/* 82074EA0h case    9:*/		return 0x82074EA4;
		  /* 82074EA4h */ case   10:  		/* lfs FR2, <#[R1 + 80]> */
		/* 82074EA4h case   10:*/		cpu::mem::load32f( regs, &regs.FR2, (uint32)(regs.R1 + 0x00000050) );
		/* 82074EA4h case   10:*/		return 0x82074EA8;
		  /* 82074EA8h */ case   11:  		/* lwz R8, <#[R1 + 84]> */
		/* 82074EA8h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 82074EA8h case   11:*/		return 0x82074EAC;
	}
	return 0x82074EAC;
} // Block from 82074E7Ch-82074EACh (12 instructions)

//////////////////////////////////////////////////////
// Block at 82074EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074EAC);
		  /* 82074EACh */ case    0:  		/* cmplwi CR6, R8, 1 */
		/* 82074EACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000001);
		/* 82074EACh case    0:*/		return 0x82074EB0;
		  /* 82074EB0h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 82074EB0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82074EE8;  }
		/* 82074EB0h case    1:*/		return 0x82074EB4;
		  /* 82074EB4h */ case    2:  		/* cmplwi CR6, R8, 2 */
		/* 82074EB4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000002);
		/* 82074EB4h case    2:*/		return 0x82074EB8;
		  /* 82074EB8h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 82074EB8h case    3:*/		if ( regs.CR[6].eq ) { return 0x82074EDC;  }
		/* 82074EB8h case    3:*/		return 0x82074EBC;
		  /* 82074EBCh */ case    4:  		/* cmplwi CR6, R8, 3 */
		/* 82074EBCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000003);
		/* 82074EBCh case    4:*/		return 0x82074EC0;
		  /* 82074EC0h */ case    5:  		/* bc 4, CR6_EQ, 28 */
		/* 82074EC0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82074EDC;  }
		/* 82074EC0h case    5:*/		return 0x82074EC4;
		  /* 82074EC4h */ case    6:  		/* cmpwi CR6, R30, 0 */
		/* 82074EC4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82074EC4h case    6:*/		return 0x82074EC8;
		  /* 82074EC8h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 82074EC8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82074ED0;  }
		/* 82074EC8h case    7:*/		return 0x82074ECC;
		  /* 82074ECCh */ case    8:  		/* fdivs FR2, FR31, FR2 */
		/* 82074ECCh case    8:*/		cpu::op::fdivs<0>(regs,&regs.FR2,regs.FR31,regs.FR2);
		/* 82074ECCh case    8:*/		return 0x82074ED0;
	}
	return 0x82074ED0;
} // Block from 82074EACh-82074ED0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82074ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074ED0);
		  /* 82074ED0h */ case    0:  		/* bl 120552 */
		/* 82074ED0h case    0:*/		regs.LR = 0x82074ED4; return 0x820925B8;
		/* 82074ED0h case    0:*/		return 0x82074ED4;
		  /* 82074ED4h */ case    1:  		/* frsp FR1, FR1 */
		/* 82074ED4h case    1:*/		cpu::op::frsp<0>(regs,&regs.FR1,regs.FR1);
		/* 82074ED4h case    1:*/		return 0x82074ED8;
		  /* 82074ED8h */ case    2:  		/* b 24 */
		/* 82074ED8h case    2:*/		return 0x82074EF0;
		/* 82074ED8h case    2:*/		return 0x82074EDC;
	}
	return 0x82074EDC;
} // Block from 82074ED0h-82074EDCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82074EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074EDC);
		  /* 82074EDCh */ case    0:  		/* mr R4, R30 */
		/* 82074EDCh case    0:*/		regs.R4 = regs.R30;
		/* 82074EDCh case    0:*/		return 0x82074EE0;
		  /* 82074EE0h */ case    1:  		/* bl -448 */
		/* 82074EE0h case    1:*/		regs.LR = 0x82074EE4; return 0x82074D20;
		/* 82074EE0h case    1:*/		return 0x82074EE4;
		  /* 82074EE4h */ case    2:  		/* b 12 */
		/* 82074EE4h case    2:*/		return 0x82074EF0;
		/* 82074EE4h case    2:*/		return 0x82074EE8;
	}
	return 0x82074EE8;
} // Block from 82074EDCh-82074EE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82074EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074EE8);
		  /* 82074EE8h */ case    0:  		/* mr R4, R30 */
		/* 82074EE8h case    0:*/		regs.R4 = regs.R30;
		/* 82074EE8h case    0:*/		return 0x82074EEC;
		  /* 82074EECh */ case    1:  		/* bl -636 */
		/* 82074EECh case    1:*/		regs.LR = 0x82074EF0; return 0x82074C70;
		/* 82074EECh case    1:*/		return 0x82074EF0;
	}
	return 0x82074EF0;
} // Block from 82074EE8h-82074EF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82074EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074EF0);
		  /* 82074EF0h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 82074EF0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82074EF0h case    0:*/		return 0x82074EF4;
		  /* 82074EF4h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82074EF4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82074F00;  }
		/* 82074EF4h case    1:*/		return 0x82074EF8;
		  /* 82074EF8h */ case    2:  		/* li R4, 0 */
		/* 82074EF8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82074EF8h case    2:*/		return 0x82074EFC;
		  /* 82074EFCh */ case    3:  		/* bl -652 */
		/* 82074EFCh case    3:*/		regs.LR = 0x82074F00; return 0x82074C70;
		/* 82074EFCh case    3:*/		return 0x82074F00;
	}
	return 0x82074F00;
} // Block from 82074EF0h-82074F00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82074F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074F00);
		  /* 82074F00h */ case    0:  		/* fmadd FR0, FR1, FR30, FR29 */
		/* 82074F00h case    0:*/		cpu::op::fmadd<0>(regs,&regs.FR0,regs.FR1,regs.FR30,regs.FR29);
		/* 82074F00h case    0:*/		return 0x82074F04;
		  /* 82074F04h */ case    1:  		/* fctiwz FR0, FR0 */
		/* 82074F04h case    1:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82074F04h case    1:*/		return 0x82074F08;
		  /* 82074F08h */ case    2:  		/* stfd FR0, <#[R1 + 96]> */
		/* 82074F08h case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 82074F08h case    2:*/		return 0x82074F0C;
		  /* 82074F0Ch */ case    3:  		/* lwz R11, <#[R1 + 100]> */
		/* 82074F0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82074F0Ch case    3:*/		return 0x82074F10;
		  /* 82074F10h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 82074F10h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82074F10h case    4:*/		return 0x82074F14;
		  /* 82074F14h */ case    5:  		/* bc 4, CR6_LT, 12 */
		/* 82074F14h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82074F20;  }
		/* 82074F14h case    5:*/		return 0x82074F18;
		  /* 82074F18h */ case    6:  		/* li R11, 0 */
		/* 82074F18h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82074F18h case    6:*/		return 0x82074F1C;
		  /* 82074F1Ch */ case    7:  		/* b 16 */
		/* 82074F1Ch case    7:*/		return 0x82074F2C;
		/* 82074F1Ch case    7:*/		return 0x82074F20;
	}
	return 0x82074F20;
} // Block from 82074F00h-82074F20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82074F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074F20);
		  /* 82074F20h */ case    0:  		/* cmpwi CR6, R11, 1023 */
		/* 82074F20h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x000003FF);
		/* 82074F20h case    0:*/		return 0x82074F24;
		  /* 82074F24h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 82074F24h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82074F2C;  }
		/* 82074F24h case    1:*/		return 0x82074F28;
		  /* 82074F28h */ case    2:  		/* li R11, 1023 */
		/* 82074F28h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x3FF);
		/* 82074F28h case    2:*/		return 0x82074F2C;
	}
	return 0x82074F2C;
} // Block from 82074F20h-82074F2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82074F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074F2C);
		  /* 82074F2Ch */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82074F2Ch case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82074F2Ch case    0:*/		return 0x82074F30;
		  /* 82074F30h */ case    1:  		/* addi R31, R31, 1 */
		/* 82074F30h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82074F30h case    1:*/		return 0x82074F34;
		  /* 82074F34h */ case    2:  		/* sthu R11, <#[R29 + 2]> */
		/* 82074F34h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R29 + 0x00000002) );
		regs.R29 = (uint32)(regs.R29 + 0x00000002);
		/* 82074F34h case    2:*/		return 0x82074F38;
		  /* 82074F38h */ case    3:  		/* cmpwi CR6, R31, 1024 */
		/* 82074F38h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000400);
		/* 82074F38h case    3:*/		return 0x82074F3C;
		  /* 82074F3Ch */ case    4:  		/* bc 12, CR6_LT, -200 */
		/* 82074F3Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x82074E74;  }
		/* 82074F3Ch case    4:*/		return 0x82074F40;
	}
	return 0x82074F40;
} // Block from 82074F2Ch-82074F40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82074F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074F40);
		  /* 82074F40h */ case    0:  		/* mr R3, R28 */
		/* 82074F40h case    0:*/		regs.R3 = regs.R28;
		/* 82074F40h case    0:*/		return 0x82074F44;
		  /* 82074F44h */ case    1:  		/* addi R1, R1, 176 */
		/* 82074F44h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82074F44h case    1:*/		return 0x82074F48;
		  /* 82074F48h */ case    2:  		/* addi R12, R1, -40 */
		/* 82074F48h case    2:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFD8);
		/* 82074F48h case    2:*/		return 0x82074F4C;
		  /* 82074F4Ch */ case    3:  		/* bl 115992 */
		/* 82074F4Ch case    3:*/		regs.LR = 0x82074F50; return 0x82091464;
		/* 82074F4Ch case    3:*/		return 0x82074F50;
		  /* 82074F50h */ case    4:  		/* b 115544 */
		/* 82074F50h case    4:*/		return 0x820912A8;
		/* 82074F50h case    4:*/		return 0x82074F54;
		  /* 82074F54h */ case    5:  		/* nop */
		/* 82074F54h case    5:*/		cpu::op::nop();
		/* 82074F54h case    5:*/		return 0x82074F58;
	}
	return 0x82074F58;
} // Block from 82074F40h-82074F58h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82074F58h
// Function '?QueueCommands@CDevice@D3D@@QAAHPBXKKHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074F58);
		  /* 82074F58h */ case    0:  		/* mfspr R12, LR */
		/* 82074F58h case    0:*/		regs.R12 = regs.LR;
		/* 82074F58h case    0:*/		return 0x82074F5C;
		  /* 82074F5Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82074F5Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074F5Ch case    1:*/		return 0x82074F60;
		  /* 82074F60h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82074F60h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82074F60h case    2:*/		return 0x82074F64;
		  /* 82074F64h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82074F64h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074F64h case    3:*/		return 0x82074F68;
		  /* 82074F68h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82074F68h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82074F68h case    4:*/		return 0x82074F6C;
		  /* 82074F6Ch */ case    5:  		/* mr R30, R3 */
		/* 82074F6Ch case    5:*/		regs.R30 = regs.R3;
		/* 82074F6Ch case    5:*/		return 0x82074F70;
		  /* 82074F70h */ case    6:  		/* mr R3, R5 */
		/* 82074F70h case    6:*/		regs.R3 = regs.R5;
		/* 82074F70h case    6:*/		return 0x82074F74;
		  /* 82074F74h */ case    7:  		/* mr R31, R4 */
		/* 82074F74h case    7:*/		regs.R31 = regs.R4;
		/* 82074F74h case    7:*/		return 0x82074F78;
		  /* 82074F78h */ case    8:  		/* bl -424 */
		/* 82074F78h case    8:*/		regs.LR = 0x82074F7C; return 0x82074DD0;
		/* 82074F78h case    8:*/		return 0x82074F7C;
		  /* 82074F7Ch */ case    9:  		/* li R9, 256 */
		/* 82074F7Ch case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x100);
		/* 82074F7Ch case    9:*/		return 0x82074F80;
		  /* 82074F80h */ case   10:  		/* addi R10, R31, 1022 */
		/* 82074F80h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x3FE);
		/* 82074F80h case   10:*/		return 0x82074F84;
		  /* 82074F84h */ case   11:  		/* addi R11, R30, 512 */
		/* 82074F84h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x200);
		/* 82074F84h case   11:*/		return 0x82074F88;
		  /* 82074F88h */ case   12:  		/* subf R8, R30, R31 */
		/* 82074F88h case   12:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R30,regs.R31);
		/* 82074F88h case   12:*/		return 0x82074F8C;
		  /* 82074F8Ch */ case   13:  		/* mtspr CTR, R9 */
		/* 82074F8Ch case   13:*/		regs.CTR = regs.R9;
		/* 82074F8Ch case   13:*/		return 0x82074F90;
		  /* 82074F90h */ case   14:  		/* lhz R9, <#[R10 - 1022]> */
		/* 82074F90h case   14:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R10 + 0xFFFFFC02) );
		/* 82074F90h case   14:*/		return 0x82074F94;
		  /* 82074F94h */ case   15:  		/* rlwinm R9, R9, 27, 5, 30 */
		/* 82074F94h case   15:*/		cpu::op::rlwinm<0,27,5,30>(regs,&regs.R9,regs.R9);
		/* 82074F94h case   15:*/		return 0x82074F98;
		  /* 82074F98h */ case   16:  		/* lhzx R9, <#[R9 + R3]> */
		/* 82074F98h case   16:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82074F98h case   16:*/		return 0x82074F9C;
		  /* 82074F9Ch */ case   17:  		/* rlwinm R9, R9, 6, 16, 25 */
		/* 82074F9Ch case   17:*/		cpu::op::rlwinm<0,6,16,25>(regs,&regs.R9,regs.R9);
		/* 82074F9Ch case   17:*/		return 0x82074FA0;
		  /* 82074FA0h */ case   18:  		/* sth R9, <#[R11 - 512]> */
		/* 82074FA0h case   18:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R11 + 0xFFFFFE00) );
		/* 82074FA0h case   18:*/		return 0x82074FA4;
		  /* 82074FA4h */ case   19:  		/* lhzx R9, <#[R8 + R11]> */
		/* 82074FA4h case   19:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82074FA4h case   19:*/		return 0x82074FA8;
		  /* 82074FA8h */ case   20:  		/* rlwinm R9, R9, 27, 5, 30 */
		/* 82074FA8h case   20:*/		cpu::op::rlwinm<0,27,5,30>(regs,&regs.R9,regs.R9);
		/* 82074FA8h case   20:*/		return 0x82074FAC;
		  /* 82074FACh */ case   21:  		/* lhzx R9, <#[R9 + R3]> */
		/* 82074FACh case   21:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82074FACh case   21:*/		return 0x82074FB0;
		  /* 82074FB0h */ case   22:  		/* rlwinm R9, R9, 6, 16, 25 */
		/* 82074FB0h case   22:*/		cpu::op::rlwinm<0,6,16,25>(regs,&regs.R9,regs.R9);
		/* 82074FB0h case   22:*/		return 0x82074FB4;
		  /* 82074FB4h */ case   23:  		/* sth R9, <#[R11]> */
		/* 82074FB4h case   23:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82074FB4h case   23:*/		return 0x82074FB8;
		  /* 82074FB8h */ case   24:  		/* lhzu R9, <#[R10 + 2]> */
		/* 82074FB8h case   24:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000002) );
		regs.R10 = (uint32)(regs.R10 + 0x00000002);
		/* 82074FB8h case   24:*/		return 0x82074FBC;
		  /* 82074FBCh */ case   25:  		/* rlwinm R9, R9, 27, 5, 30 */
		/* 82074FBCh case   25:*/		cpu::op::rlwinm<0,27,5,30>(regs,&regs.R9,regs.R9);
		/* 82074FBCh case   25:*/		return 0x82074FC0;
		  /* 82074FC0h */ case   26:  		/* lhzx R9, <#[R9 + R3]> */
		/* 82074FC0h case   26:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82074FC0h case   26:*/		return 0x82074FC4;
		  /* 82074FC4h */ case   27:  		/* rlwinm R9, R9, 6, 16, 25 */
		/* 82074FC4h case   27:*/		cpu::op::rlwinm<0,6,16,25>(regs,&regs.R9,regs.R9);
		/* 82074FC4h case   27:*/		return 0x82074FC8;
		  /* 82074FC8h */ case   28:  		/* sth R9, <#[R11 + 512]> */
		/* 82074FC8h case   28:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R11 + 0x00000200) );
		/* 82074FC8h case   28:*/		return 0x82074FCC;
		  /* 82074FCCh */ case   29:  		/* addi R11, R11, 2 */
		/* 82074FCCh case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82074FCCh case   29:*/		return 0x82074FD0;
		  /* 82074FD0h */ case   30:  		/* bc 16, CR0_LT, -64 */
		/* 82074FD0h case   30:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82074F90;  }
		/* 82074FD0h case   30:*/		return 0x82074FD4;
		  /* 82074FD4h */ case   31:  		/* addi R1, R1, 112 */
		/* 82074FD4h case   31:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82074FD4h case   31:*/		return 0x82074FD8;
		  /* 82074FD8h */ case   32:  		/* lwz R12, <#[R1 - 8]> */
		/* 82074FD8h case   32:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074FD8h case   32:*/		return 0x82074FDC;
		  /* 82074FDCh */ case   33:  		/* mtspr LR, R12 */
		/* 82074FDCh case   33:*/		regs.LR = regs.R12;
		/* 82074FDCh case   33:*/		return 0x82074FE0;
		  /* 82074FE0h */ case   34:  		/* ld R30, <#[R1 - 24]> */
		/* 82074FE0h case   34:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82074FE0h case   34:*/		return 0x82074FE4;
		  /* 82074FE4h */ case   35:  		/* ld R31, <#[R1 - 16]> */
		/* 82074FE4h case   35:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074FE4h case   35:*/		return 0x82074FE8;
		  /* 82074FE8h */ case   36:  		/* bclr 20, CR0_LT */
		/* 82074FE8h case   36:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82074FE8h case   36:*/		return 0x82074FEC;
	}
	return 0x82074FEC;
} // Block from 82074F58h-82074FECh (37 instructions)

//////////////////////////////////////////////////////
// Block at 82074FECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074FEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074FEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074FEC);
		  /* 82074FECh */ case    0:  		/* nop */
		/* 82074FECh case    0:*/		cpu::op::nop();
		/* 82074FECh case    0:*/		return 0x82074FF0;
	}
	return 0x82074FF0;
} // Block from 82074FECh-82074FF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82074FF0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82074FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82074FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82074FF0);
		  /* 82074FF0h */ case    0:  		/* mfspr R12, LR */
		/* 82074FF0h case    0:*/		regs.R12 = regs.LR;
		/* 82074FF0h case    0:*/		return 0x82074FF4;
		  /* 82074FF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82074FF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82074FF4h case    1:*/		return 0x82074FF8;
		  /* 82074FF8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82074FF8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82074FF8h case    2:*/		return 0x82074FFC;
		  /* 82074FFCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82074FFCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82074FFCh case    3:*/		return 0x82075000;
		  /* 82075000h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82075000h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82075000h case    4:*/		return 0x82075004;
		  /* 82075004h */ case    5:  		/* mr R30, R3 */
		/* 82075004h case    5:*/		regs.R30 = regs.R3;
		/* 82075004h case    5:*/		return 0x82075008;
		  /* 82075008h */ case    6:  		/* mr R3, R5 */
		/* 82075008h case    6:*/		regs.R3 = regs.R5;
		/* 82075008h case    6:*/		return 0x8207500C;
		  /* 8207500Ch */ case    7:  		/* mr R31, R4 */
		/* 8207500Ch case    7:*/		regs.R31 = regs.R4;
		/* 8207500Ch case    7:*/		return 0x82075010;
		  /* 82075010h */ case    8:  		/* bl -576 */
		/* 82075010h case    8:*/		regs.LR = 0x82075014; return 0x82074DD0;
		/* 82075010h case    8:*/		return 0x82075014;
		  /* 82075014h */ case    9:  		/* mr R7, R31 */
		/* 82075014h case    9:*/		regs.R7 = regs.R31;
		/* 82075014h case    9:*/		return 0x82075018;
		  /* 82075018h */ case   10:  		/* mr R5, R3 */
		/* 82075018h case   10:*/		regs.R5 = regs.R3;
		/* 82075018h case   10:*/		return 0x8207501C;
		  /* 8207501Ch */ case   11:  		/* addi R8, R30, 512 */
		/* 8207501Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x200);
		/* 8207501Ch case   11:*/		return 0x82075020;
		  /* 82075020h */ case   12:  		/* subf R31, R30, R31 */
		/* 82075020h case   12:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R30,regs.R31);
		/* 82075020h case   12:*/		return 0x82075024;
		  /* 82075024h */ case   13:  		/* li R6, 128 */
		/* 82075024h case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x80);
		/* 82075024h case   13:*/		return 0x82075028;
		  /* 82075028h */ case   14:  		/* mr R4, R7 */
		/* 82075028h case   14:*/		regs.R4 = regs.R7;
		/* 82075028h case   14:*/		return 0x8207502C;
		  /* 8207502Ch */ case   15:  		/* addi R3, R8, -512 */
		/* 8207502Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R8,0xFFFFFE00);
		/* 8207502Ch case   15:*/		return 0x82075030;
		  /* 82075030h */ case   16:  		/* bl -1040 */
		/* 82075030h case   16:*/		regs.LR = 0x82075034; return 0x82074C20;
		/* 82075030h case   16:*/		return 0x82075034;
		  /* 82075034h */ case   17:  		/* add R4, R31, R8 */
		/* 82075034h case   17:*/		cpu::op::add<0>(regs,&regs.R4,regs.R31,regs.R8);
		/* 82075034h case   17:*/		return 0x82075038;
		  /* 82075038h */ case   18:  		/* mr R3, R8 */
		/* 82075038h case   18:*/		regs.R3 = regs.R8;
		/* 82075038h case   18:*/		return 0x8207503C;
		  /* 8207503Ch */ case   19:  		/* bl -1052 */
		/* 8207503Ch case   19:*/		regs.LR = 0x82075040; return 0x82074C20;
		/* 8207503Ch case   19:*/		return 0x82075040;
		  /* 82075040h */ case   20:  		/* addi R4, R7, 1024 */
		/* 82075040h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R7,0x400);
		/* 82075040h case   20:*/		return 0x82075044;
		  /* 82075044h */ case   21:  		/* addi R3, R8, 512 */
		/* 82075044h case   21:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R8,0x200);
		/* 82075044h case   21:*/		return 0x82075048;
		  /* 82075048h */ case   22:  		/* bl -1064 */
		/* 82075048h case   22:*/		regs.LR = 0x8207504C; return 0x82074C20;
		/* 82075048h case   22:*/		return 0x8207504C;
		  /* 8207504Ch */ case   23:  		/* addic. R6, R6, -1 */
		/* 8207504Ch case   23:*/		cpu::op::addic<1>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 8207504Ch case   23:*/		return 0x82075050;
		  /* 82075050h */ case   24:  		/* addi R7, R7, 4 */
		/* 82075050h case   24:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 82075050h case   24:*/		return 0x82075054;
		  /* 82075054h */ case   25:  		/* addi R8, R8, 4 */
		/* 82075054h case   25:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 82075054h case   25:*/		return 0x82075058;
		  /* 82075058h */ case   26:  		/* bc 4, CR0_EQ, -48 */
		/* 82075058h case   26:*/		if ( !regs.CR[0].eq ) { return 0x82075028;  }
		/* 82075058h case   26:*/		return 0x8207505C;
		  /* 8207505Ch */ case   27:  		/* addi R1, R1, 112 */
		/* 8207505Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8207505Ch case   27:*/		return 0x82075060;
		  /* 82075060h */ case   28:  		/* lwz R12, <#[R1 - 8]> */
		/* 82075060h case   28:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82075060h case   28:*/		return 0x82075064;
		  /* 82075064h */ case   29:  		/* mtspr LR, R12 */
		/* 82075064h case   29:*/		regs.LR = regs.R12;
		/* 82075064h case   29:*/		return 0x82075068;
		  /* 82075068h */ case   30:  		/* ld R30, <#[R1 - 24]> */
		/* 82075068h case   30:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82075068h case   30:*/		return 0x8207506C;
		  /* 8207506Ch */ case   31:  		/* ld R31, <#[R1 - 16]> */
		/* 8207506Ch case   31:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8207506Ch case   31:*/		return 0x82075070;
		  /* 82075070h */ case   32:  		/* bclr 20, CR0_LT */
		/* 82075070h case   32:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82075070h case   32:*/		return 0x82075074;
	}
	return 0x82075074;
} // Block from 82074FF0h-82075074h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82075074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075074);
		  /* 82075074h */ case    0:  		/* nop */
		/* 82075074h case    0:*/		cpu::op::nop();
		/* 82075074h case    0:*/		return 0x82075078;
	}
	return 0x82075078;
} // Block from 82075074h-82075078h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82075078h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075078);
		  /* 82075078h */ case    0:  		/* mfspr R12, LR */
		/* 82075078h case    0:*/		regs.R12 = regs.LR;
		/* 82075078h case    0:*/		return 0x8207507C;
		  /* 8207507Ch */ case    1:  		/* bl 115168 */
		/* 8207507Ch case    1:*/		regs.LR = 0x82075080; return 0x8209125C;
		/* 8207507Ch case    1:*/		return 0x82075080;
		  /* 82075080h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82075080h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82075080h case    2:*/		return 0x82075084;
		  /* 82075084h */ case    3:  		/* mr R30, R4 */
		/* 82075084h case    3:*/		regs.R30 = regs.R4;
		/* 82075084h case    3:*/		return 0x82075088;
		  /* 82075088h */ case    4:  		/* li R4, 2309 */
		/* 82075088h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x905);
		/* 82075088h case    4:*/		return 0x8207508C;
		  /* 8207508Ch */ case    5:  		/* mr R31, R3 */
		/* 8207508Ch case    5:*/		regs.R31 = regs.R3;
		/* 8207508Ch case    5:*/		return 0x82075090;
		  /* 82075090h */ case    6:  		/* bl -3408 */
		/* 82075090h case    6:*/		regs.LR = 0x82075094; return 0x82074340;
		/* 82075090h case    6:*/		return 0x82075094;
		  /* 82075094h */ case    7:  		/* lis R11, 1 */
		/* 82075094h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 82075094h case    7:*/		return 0x82075098;
		  /* 82075098h */ case    8:  		/* li R9, 0 */
		/* 82075098h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82075098h case    8:*/		return 0x8207509C;
		  /* 8207509Ch */ case    9:  		/* ori R11, R11, 6433 */
		/* 8207509Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1921);
		/* 8207509Ch case    9:*/		return 0x820750A0;
		  /* 820750A0h */ case   10:  		/* li R7, 0 */
		/* 820750A0h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820750A0h case   10:*/		return 0x820750A4;
		  /* 820750A4h */ case   11:  		/* stwu R11, <#[R3 + 4]> */
		/* 820750A4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820750A4h case   11:*/		return 0x820750A8;
		  /* 820750A8h */ case   12:  		/* li R10, 256 */
		/* 820750A8h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x100);
		/* 820750A8h case   12:*/		return 0x820750AC;
		  /* 820750ACh */ case   13:  		/* li R6, 6439 */
		/* 820750ACh case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x1927);
		/* 820750ACh case   13:*/		return 0x820750B0;
		  /* 820750B0h */ case   14:  		/* li R5, 7 */
		/* 820750B0h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x7);
		/* 820750B0h case   14:*/		return 0x820750B4;
		  /* 820750B4h */ case   15:  		/* li R8, 0 */
		/* 820750B4h case   15:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820750B4h case   15:*/		return 0x820750B8;
		  /* 820750B8h */ case   16:  		/* addi R11, R30, 1024 */
		/* 820750B8h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x400);
		/* 820750B8h case   16:*/		return 0x820750BC;
		  /* 820750BCh */ case   17:  		/* stwu R9, <#[R3 + 4]> */
		/* 820750BCh case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820750BCh case   17:*/		return 0x820750C0;
		  /* 820750C0h */ case   18:  		/* mtspr CTR, R10 */
		/* 820750C0h case   18:*/		regs.CTR = regs.R10;
		/* 820750C0h case   18:*/		return 0x820750C4;
		  /* 820750C4h */ case   19:  		/* stwu R7, <#[R3 + 4]> */
		/* 820750C4h case   19:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820750C4h case   19:*/		return 0x820750C8;
		  /* 820750C8h */ case   20:  		/* stwu R6, <#[R3 + 4]> */
		/* 820750C8h case   20:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820750C8h case   20:*/		return 0x820750CC;
		  /* 820750CCh */ case   21:  		/* mr R10, R3 */
		/* 820750CCh case   21:*/		regs.R10 = regs.R3;
		/* 820750CCh case   21:*/		return 0x820750D0;
		  /* 820750D0h */ case   22:  		/* stwu R5, <#[R10 + 4]> */
		/* 820750D0h case   22:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820750D0h case   22:*/		return 0x820750D4;
		  /* 820750D4h */ case   23:  		/* cmplwi CR6, R30, 0 */
		/* 820750D4h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820750D4h case   23:*/		return 0x820750D8;
	}
	return 0x820750D8;
} // Block from 82075078h-820750D8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820750D8h
// Function '?KickOff@CDevice@D3D@@QAAPAKXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820750D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820750D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820750D8);
		  /* 820750D8h */ case    0:  		/* bc 12, CR6_EQ, 36 */
		/* 820750D8h case    0:*/		if ( regs.CR[6].eq ) { return 0x820750FC;  }
		/* 820750D8h case    0:*/		return 0x820750DC;
		  /* 820750DCh */ case    1:  		/* lhz R9, <#[R11 - 1024]> */
		/* 820750DCh case    1:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R11 + 0xFFFFFC00) );
		/* 820750DCh case    1:*/		return 0x820750E0;
		  /* 820750E0h */ case    2:  		/* lhz R7, <#[R11 - 512]> */
		/* 820750E0h case    2:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R11 + 0xFFFFFE00) );
		/* 820750E0h case    2:*/		return 0x820750E4;
		  /* 820750E4h */ case    3:  		/* lhz R6, <#[R11]> */
		/* 820750E4h case    3:*/		cpu::mem::load16z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 820750E4h case    3:*/		return 0x820750E8;
		  /* 820750E8h */ case    4:  		/* rlwimi R7, R9, 10, 6, 15 */
		/* 820750E8h case    4:*/		cpu::op::rlwimi<0,10,6,15>(regs,&regs.R7,regs.R9);
		/* 820750E8h case    4:*/		return 0x820750EC;
		  /* 820750ECh */ case    5:  		/* rlwinm R9, R6, 26, 6, 31 */
		/* 820750ECh case    5:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R9,regs.R6);
		/* 820750ECh case    5:*/		return 0x820750F0;
		  /* 820750F0h */ case    6:  		/* rlwinm R7, R7, 4, 2, 21 */
		/* 820750F0h case    6:*/		cpu::op::rlwinm<0,4,2,21>(regs,&regs.R7,regs.R7);
		/* 820750F0h case    6:*/		return 0x820750F4;
		  /* 820750F4h */ case    7:  		/* or R9, R7, R9 */
		/* 820750F4h case    7:*/		cpu::op::or<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820750F4h case    7:*/		return 0x820750F8;
		  /* 820750F8h */ case    8:  		/* b 8 */
		/* 820750F8h case    8:*/		return 0x82075100;
		/* 820750F8h case    8:*/		return 0x820750FC;
	}
	return 0x820750FC;
} // Block from 820750D8h-820750FCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820750FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820750FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820750FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820750FC);
		  /* 820750FCh */ case    0:  		/* li R9, 0 */
		/* 820750FCh case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820750FCh case    0:*/		return 0x82075100;
	}
	return 0x82075100;
} // Block from 820750FCh-82075100h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82075100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075100);
		  /* 82075100h */ case    0:  		/* li R7, 6437 */
		/* 82075100h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1925);
		/* 82075100h case    0:*/		return 0x82075104;
		  /* 82075104h */ case    1:  		/* lis R6, -16379 */
		/* 82075104h case    1:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFFC005);
		/* 82075104h case    1:*/		return 0x82075108;
		  /* 82075108h */ case    2:  		/* stwu R7, <#[R10 + 4]> */
		/* 82075108h case    2:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82075108h case    2:*/		return 0x8207510C;
		  /* 8207510Ch */ case    3:  		/* li R5, 7 */
		/* 8207510Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x7);
		/* 8207510Ch case    3:*/		return 0x82075110;
		  /* 82075110h */ case    4:  		/* ori R6, R6, 17664 */
		/* 82075110h case    4:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R6,0x4500);
		/* 82075110h case    4:*/		return 0x82075114;
		  /* 82075114h */ case    5:  		/* mr R3, R10 */
		/* 82075114h case    5:*/		regs.R3 = regs.R10;
		/* 82075114h case    5:*/		return 0x82075118;
		  /* 82075118h */ case    6:  		/* li R4, -1 */
		/* 82075118h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0xFFFFFFFF);
		/* 82075118h case    6:*/		return 0x8207511C;
		  /* 8207511Ch */ case    7:  		/* li R29, 6434 */
		/* 8207511Ch case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x1922);
		/* 8207511Ch case    7:*/		return 0x82075120;
		  /* 82075120h */ case    8:  		/* addi R10, R8, 1 */
		/* 82075120h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0x1);
		/* 82075120h case    8:*/		return 0x82075124;
		  /* 82075124h */ case    9:  		/* addi R11, R11, 2 */
		/* 82075124h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82075124h case    9:*/		return 0x82075128;
		  /* 82075128h */ case   10:  		/* stwu R9, <#[R3 + 4]> */
		/* 82075128h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82075128h case   10:*/		return 0x8207512C;
		  /* 8207512Ch */ case   11:  		/* mr R8, R10 */
		/* 8207512Ch case   11:*/		regs.R8 = regs.R10;
		/* 8207512Ch case   11:*/		return 0x82075130;
		  /* 82075130h */ case   12:  		/* stwu R6, <#[R3 + 4]> */
		/* 82075130h case   12:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82075130h case   12:*/		return 0x82075134;
		  /* 82075134h */ case   13:  		/* stwu R5, <#[R3 + 4]> */
		/* 82075134h case   13:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82075134h case   13:*/		return 0x82075138;
		  /* 82075138h */ case   14:  		/* stwu R7, <#[R3 + 4]> */
		/* 82075138h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82075138h case   14:*/		return 0x8207513C;
		  /* 8207513Ch */ case   15:  		/* stwu R9, <#[R3 + 4]> */
		/* 8207513Ch case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207513Ch case   15:*/		return 0x82075140;
		  /* 82075140h */ case   16:  		/* stwu R4, <#[R3 + 4]> */
		/* 82075140h case   16:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82075140h case   16:*/		return 0x82075144;
		  /* 82075144h */ case   17:  		/* stwu R29, <#[R3 + 4]> */
		/* 82075144h case   17:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82075144h case   17:*/		return 0x82075148;
		  /* 82075148h */ case   18:  		/* mr R9, R3 */
		/* 82075148h case   18:*/		regs.R9 = regs.R3;
		/* 82075148h case   18:*/		return 0x8207514C;
		  /* 8207514Ch */ case   19:  		/* stwu R10, <#[R9 + 4]> */
		/* 8207514Ch case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 8207514Ch case   19:*/		return 0x82075150;
		  /* 82075150h */ case   20:  		/* mr R10, R9 */
		/* 82075150h case   20:*/		regs.R10 = regs.R9;
		/* 82075150h case   20:*/		return 0x82075154;
		  /* 82075154h */ case   21:  		/* bc 16, CR0_LT, -128 */
		/* 82075154h case   21:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820750D4;  }
		/* 82075154h case   21:*/		return 0x82075158;
		  /* 82075158h */ case   22:  		/* stw R9, <#[R31 + 48]> */
		/* 82075158h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000030) );
		/* 82075158h case   22:*/		return 0x8207515C;
		  /* 8207515Ch */ case   23:  		/* addi R1, R1, 112 */
		/* 8207515Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8207515Ch case   23:*/		return 0x82075160;
		  /* 82075160h */ case   24:  		/* b 115020 */
		/* 82075160h case   24:*/		return 0x820912AC;
		/* 82075160h case   24:*/		return 0x82075164;
		  /* 82075164h */ case   25:  		/* nop */
		/* 82075164h case   25:*/		cpu::op::nop();
		/* 82075164h case   25:*/		return 0x82075168;
	}
	return 0x82075168;
} // Block from 82075100h-82075168h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82075168h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075168);
		  /* 82075168h */ case    0:  		/* mfspr R12, LR */
		/* 82075168h case    0:*/		regs.R12 = regs.LR;
		/* 82075168h case    0:*/		return 0x8207516C;
		  /* 8207516Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8207516Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8207516Ch case    1:*/		return 0x82075170;
		  /* 82075170h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82075170h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82075170h case    2:*/		return 0x82075174;
		  /* 82075174h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82075174h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82075174h case    3:*/		return 0x82075178;
		  /* 82075178h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82075178h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82075178h case    4:*/		return 0x8207517C;
		  /* 8207517Ch */ case    5:  		/* mr R31, R4 */
		/* 8207517Ch case    5:*/		regs.R31 = regs.R4;
		/* 8207517Ch case    5:*/		return 0x82075180;
		  /* 82075180h */ case    6:  		/* li R4, 1413 */
		/* 82075180h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x585);
		/* 82075180h case    6:*/		return 0x82075184;
		  /* 82075184h */ case    7:  		/* mr R30, R3 */
		/* 82075184h case    7:*/		regs.R30 = regs.R3;
		/* 82075184h case    7:*/		return 0x82075188;
		  /* 82075188h */ case    8:  		/* bl -3656 */
		/* 82075188h case    8:*/		regs.LR = 0x8207518C; return 0x82074340;
		/* 82075188h case    8:*/		return 0x8207518C;
		  /* 8207518Ch */ case    9:  		/* lis R11, 1 */
		/* 8207518Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 8207518Ch case    9:*/		return 0x82075190;
		  /* 82075190h */ case   10:  		/* li R8, 1 */
		/* 82075190h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82075190h case   10:*/		return 0x82075194;
		  /* 82075194h */ case   11:  		/* ori R11, R11, 6433 */
		/* 82075194h case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1921);
		/* 82075194h case   11:*/		return 0x82075198;
		  /* 82075198h */ case   12:  		/* li R7, 0 */
		/* 82075198h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82075198h case   12:*/		return 0x8207519C;
		  /* 8207519Ch */ case   13:  		/* stwu R11, <#[R3 + 4]> */
		/* 8207519Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207519Ch case   13:*/		return 0x820751A0;
		  /* 820751A0h */ case   14:  		/* li R10, 128 */
		/* 820751A0h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x80);
		/* 820751A0h case   14:*/		return 0x820751A4;
		  /* 820751A4h */ case   15:  		/* li R6, 6439 */
		/* 820751A4h case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x1927);
		/* 820751A4h case   15:*/		return 0x820751A8;
		  /* 820751A8h */ case   16:  		/* li R5, 7 */
		/* 820751A8h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x7);
		/* 820751A8h case   16:*/		return 0x820751AC;
		  /* 820751ACh */ case   17:  		/* li R9, 0 */
		/* 820751ACh case   17:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820751ACh case   17:*/		return 0x820751B0;
		  /* 820751B0h */ case   18:  		/* addi R11, R31, 514 */
		/* 820751B0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x202);
		/* 820751B0h case   18:*/		return 0x820751B4;
		  /* 820751B4h */ case   19:  		/* stwu R8, <#[R3 + 4]> */
		/* 820751B4h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820751B4h case   19:*/		return 0x820751B8;
		  /* 820751B8h */ case   20:  		/* mtspr CTR, R10 */
		/* 820751B8h case   20:*/		regs.CTR = regs.R10;
		/* 820751B8h case   20:*/		return 0x820751BC;
		  /* 820751BCh */ case   21:  		/* stwu R7, <#[R3 + 4]> */
		/* 820751BCh case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820751BCh case   21:*/		return 0x820751C0;
		  /* 820751C0h */ case   22:  		/* stwu R6, <#[R3 + 4]> */
		/* 820751C0h case   22:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820751C0h case   22:*/		return 0x820751C4;
		  /* 820751C4h */ case   23:  		/* mr R10, R3 */
		/* 820751C4h case   23:*/		regs.R10 = regs.R3;
		/* 820751C4h case   23:*/		return 0x820751C8;
		  /* 820751C8h */ case   24:  		/* stwu R5, <#[R10 + 4]> */
		/* 820751C8h case   24:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820751C8h case   24:*/		return 0x820751CC;
		  /* 820751CCh */ case   25:  		/* lis R8, 2 */
		/* 820751CCh case   25:*/		cpu::op::lis<0>(regs,&regs.R8,0x2);
		/* 820751CCh case   25:*/		return 0x820751D0;
		  /* 820751D0h */ case   26:  		/* cmplwi CR6, R31, 0 */
		/* 820751D0h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820751D0h case   26:*/		return 0x820751D4;
		  /* 820751D4h */ case   27:  		/* ori R8, R8, 39204 */
		/* 820751D4h case   27:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x9924);
		/* 820751D4h case   27:*/		return 0x820751D8;
	}
	return 0x820751D8;
} // Block from 82075168h-820751D8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820751D8h
// Function '?BlockOnFence@CDevice@D3D@@QAAXKW4_D3DBLOCKTYPE@@PAUD3DResource@@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820751D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820751D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820751D8);
		  /* 820751D8h */ case    0:  		/* stwu R8, <#[R10 + 4]> */
		/* 820751D8h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820751D8h case    0:*/		return 0x820751DC;
		  /* 820751DCh */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 820751DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82075210;  }
		/* 820751DCh case    1:*/		return 0x820751E0;
		  /* 820751E0h */ case    2:  		/* lhz R7, <#[R11 - 512]> */
		/* 820751E0h case    2:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R11 + 0xFFFFFE00) );
		/* 820751E0h case    2:*/		return 0x820751E4;
		  /* 820751E4h */ case    3:  		/* lhz R8, <#[R11 - 514]> */
		/* 820751E4h case    3:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFDFE) );
		/* 820751E4h case    3:*/		return 0x820751E8;
		  /* 820751E8h */ case    4:  		/* rlwimi R8, R7, 16, 0, 15 */
		/* 820751E8h case    4:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R8,regs.R7);
		/* 820751E8h case    4:*/		return 0x820751EC;
		  /* 820751ECh */ case    5:  		/* stwu R8, <#[R10 + 4]> */
		/* 820751ECh case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820751ECh case    5:*/		return 0x820751F0;
		  /* 820751F0h */ case    6:  		/* lhz R7, <#[R11]> */
		/* 820751F0h case    6:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820751F0h case    6:*/		return 0x820751F4;
		  /* 820751F4h */ case    7:  		/* lhz R8, <#[R11 - 2]> */
		/* 820751F4h case    7:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFFE) );
		/* 820751F4h case    7:*/		return 0x820751F8;
		  /* 820751F8h */ case    8:  		/* rlwimi R8, R7, 16, 0, 15 */
		/* 820751F8h case    8:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R8,regs.R7);
		/* 820751F8h case    8:*/		return 0x820751FC;
		  /* 820751FCh */ case    9:  		/* stwu R8, <#[R10 + 4]> */
		/* 820751FCh case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820751FCh case    9:*/		return 0x82075200;
		  /* 82075200h */ case   10:  		/* lhz R8, <#[R11 + 510]> */
		/* 82075200h case   10:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + 0x000001FE) );
		/* 82075200h case   10:*/		return 0x82075204;
		  /* 82075204h */ case   11:  		/* lhz R7, <#[R11 + 512]> */
		/* 82075204h case   11:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000200) );
		/* 82075204h case   11:*/		return 0x82075208;
		  /* 82075208h */ case   12:  		/* rlwimi R8, R7, 16, 0, 15 */
		/* 82075208h case   12:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R8,regs.R7);
		/* 82075208h case   12:*/		return 0x8207520C;
		  /* 8207520Ch */ case   13:  		/* b 20 */
		/* 8207520Ch case   13:*/		return 0x82075220;
		/* 8207520Ch case   13:*/		return 0x82075210;
	}
	return 0x82075210;
} // Block from 820751D8h-82075210h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82075210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075210);
		  /* 82075210h */ case    0:  		/* li R8, 512 */
		/* 82075210h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x200);
		/* 82075210h case    0:*/		return 0x82075214;
		  /* 82075214h */ case    1:  		/* li R7, 64 */
		/* 82075214h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x40);
		/* 82075214h case    1:*/		return 0x82075218;
		  /* 82075218h */ case    2:  		/* stwu R8, <#[R10 + 4]> */
		/* 82075218h case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82075218h case    2:*/		return 0x8207521C;
		  /* 8207521Ch */ case    3:  		/* stwu R7, <#[R10 + 4]> */
		/* 8207521Ch case    3:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 8207521Ch case    3:*/		return 0x82075220;
	}
	return 0x82075220;
} // Block from 82075210h-82075220h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82075220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075220);
		  /* 82075220h */ case    0:  		/* stwu R8, <#[R10 + 4]> */
		/* 82075220h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82075220h case    0:*/		return 0x82075224;
		  /* 82075224h */ case    1:  		/* lis R8, -16379 */
		/* 82075224h case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFC005);
		/* 82075224h case    1:*/		return 0x82075228;
		  /* 82075228h */ case    2:  		/* li R7, 7 */
		/* 82075228h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x7);
		/* 82075228h case    2:*/		return 0x8207522C;
		  /* 8207522Ch */ case    3:  		/* ori R8, R8, 17664 */
		/* 8207522Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x4500);
		/* 8207522Ch case    3:*/		return 0x82075230;
		  /* 82075230h */ case    4:  		/* li R6, 6436 */
		/* 82075230h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x1924);
		/* 82075230h case    4:*/		return 0x82075234;
		  /* 82075234h */ case    5:  		/* li R5, -1 */
		/* 82075234h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 82075234h case    5:*/		return 0x82075238;
		  /* 82075238h */ case    6:  		/* stwu R8, <#[R10 + 4]> */
		/* 82075238h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82075238h case    6:*/		return 0x8207523C;
		  /* 8207523Ch */ case    7:  		/* li R8, 0 */
		/* 8207523Ch case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8207523Ch case    7:*/		return 0x82075240;
		  /* 82075240h */ case    8:  		/* li R3, 6434 */
		/* 82075240h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x1922);
		/* 82075240h case    8:*/		return 0x82075244;
		  /* 82075244h */ case    9:  		/* mr R4, R10 */
		/* 82075244h case    9:*/		regs.R4 = regs.R10;
		/* 82075244h case    9:*/		return 0x82075248;
		  /* 82075248h */ case   10:  		/* addi R10, R9, 1 */
		/* 82075248h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x1);
		/* 82075248h case   10:*/		return 0x8207524C;
		  /* 8207524Ch */ case   11:  		/* addi R11, R11, 4 */
		/* 8207524Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8207524Ch case   11:*/		return 0x82075250;
		  /* 82075250h */ case   12:  		/* mr R9, R10 */
		/* 82075250h case   12:*/		regs.R9 = regs.R10;
		/* 82075250h case   12:*/		return 0x82075254;
		  /* 82075254h */ case   13:  		/* stwu R7, <#[R4 + 4]> */
		/* 82075254h case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 82075254h case   13:*/		return 0x82075258;
		  /* 82075258h */ case   14:  		/* stwu R6, <#[R4 + 4]> */
		/* 82075258h case   14:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 82075258h case   14:*/		return 0x8207525C;
		  /* 8207525Ch */ case   15:  		/* stwu R8, <#[R4 + 4]> */
		/* 8207525Ch case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 8207525Ch case   15:*/		return 0x82075260;
		  /* 82075260h */ case   16:  		/* stwu R5, <#[R4 + 4]> */
		/* 82075260h case   16:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 82075260h case   16:*/		return 0x82075264;
		  /* 82075264h */ case   17:  		/* stwu R3, <#[R4 + 4]> */
		/* 82075264h case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 82075264h case   17:*/		return 0x82075268;
		  /* 82075268h */ case   18:  		/* mr R8, R4 */
		/* 82075268h case   18:*/		regs.R8 = regs.R4;
		/* 82075268h case   18:*/		return 0x8207526C;
		  /* 8207526Ch */ case   19:  		/* stwu R10, <#[R8 + 4]> */
		/* 8207526Ch case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 8207526Ch case   19:*/		return 0x82075270;
		  /* 82075270h */ case   20:  		/* mr R10, R8 */
		/* 82075270h case   20:*/		regs.R10 = regs.R8;
		/* 82075270h case   20:*/		return 0x82075274;
		  /* 82075274h */ case   21:  		/* bc 16, CR0_LT, -168 */
		/* 82075274h case   21:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820751CC;  }
		/* 82075274h case   21:*/		return 0x82075278;
		  /* 82075278h */ case   22:  		/* stw R8, <#[R30 + 48]> */
		/* 82075278h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000030) );
		/* 82075278h case   22:*/		return 0x8207527C;
		  /* 8207527Ch */ case   23:  		/* addi R1, R1, 112 */
		/* 8207527Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8207527Ch case   23:*/		return 0x82075280;
		  /* 82075280h */ case   24:  		/* lwz R12, <#[R1 - 8]> */
		/* 82075280h case   24:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82075280h case   24:*/		return 0x82075284;
		  /* 82075284h */ case   25:  		/* mtspr LR, R12 */
		/* 82075284h case   25:*/		regs.LR = regs.R12;
		/* 82075284h case   25:*/		return 0x82075288;
		  /* 82075288h */ case   26:  		/* ld R30, <#[R1 - 24]> */
		/* 82075288h case   26:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82075288h case   26:*/		return 0x8207528C;
		  /* 8207528Ch */ case   27:  		/* ld R31, <#[R1 - 16]> */
		/* 8207528Ch case   27:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8207528Ch case   27:*/		return 0x82075290;
		  /* 82075290h */ case   28:  		/* bclr 20, CR0_LT */
		/* 82075290h case   28:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82075290h case   28:*/		return 0x82075294;
	}
	return 0x82075294;
} // Block from 82075220h-82075294h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82075294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075294);
		  /* 82075294h */ case    0:  		/* nop */
		/* 82075294h case    0:*/		cpu::op::nop();
		/* 82075294h case    0:*/		return 0x82075298;
	}
	return 0x82075298;
} // Block from 82075294h-82075298h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82075298h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075298);
		  /* 82075298h */ case    0:  		/* li R9, 256 */
		/* 82075298h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x100);
		/* 82075298h case    0:*/		return 0x8207529C;
		  /* 8207529Ch */ case    1:  		/* li R10, 0 */
		/* 8207529Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8207529Ch case    1:*/		return 0x820752A0;
		  /* 820752A0h */ case    2:  		/* addi R11, R3, 1022 */
		/* 820752A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x3FE);
		/* 820752A0h case    2:*/		return 0x820752A4;
		  /* 820752A4h */ case    3:  		/* mtspr CTR, R9 */
		/* 820752A4h case    3:*/		regs.CTR = regs.R9;
		/* 820752A4h case    3:*/		return 0x820752A8;
		  /* 820752A8h */ case    4:  		/* li R9, 255 */
		/* 820752A8h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0xFF);
		/* 820752A8h case    4:*/		return 0x820752AC;
		  /* 820752ACh */ case    5:  		/* divwu R9, R10, R9 */
		/* 820752ACh case    5:*/		cpu::op::divwu<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 820752ACh case    5:*/		return 0x820752B0;
		  /* 820752B0h */ case    6:  		/* addi R10, R10, 1023 */
		/* 820752B0h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3FF);
		/* 820752B0h case    6:*/		return 0x820752B4;
		  /* 820752B4h */ case    7:  		/* rlwinm R9, R9, 6, 16, 25 */
		/* 820752B4h case    7:*/		cpu::op::rlwinm<0,6,16,25>(regs,&regs.R9,regs.R9);
		/* 820752B4h case    7:*/		return 0x820752B8;
		  /* 820752B8h */ case    8:  		/* sth R9, <#[R11 - 1022]> */
		/* 820752B8h case    8:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R11 + 0xFFFFFC02) );
		/* 820752B8h case    8:*/		return 0x820752BC;
		  /* 820752BCh */ case    9:  		/* sth R9, <#[R11 - 510]> */
		/* 820752BCh case    9:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R11 + 0xFFFFFE02) );
		/* 820752BCh case    9:*/		return 0x820752C0;
		  /* 820752C0h */ case   10:  		/* sthu R9, <#[R11 + 2]> */
		/* 820752C0h case   10:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R11 + 0x00000002) );
		regs.R11 = (uint32)(regs.R11 + 0x00000002);
		/* 820752C0h case   10:*/		return 0x820752C4;
		  /* 820752C4h */ case   11:  		/* bc 16, CR0_LT, -28 */
		/* 820752C4h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820752A8;  }
		/* 820752C4h case   11:*/		return 0x820752C8;
		  /* 820752C8h */ case   12:  		/* cmpwi CR6, R4, 0 */
		/* 820752C8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 820752C8h case   12:*/		return 0x820752CC;
		  /* 820752CCh */ case   13:  		/* bclr 12, CR6_EQ */
		/* 820752CCh case   13:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820752CCh case   13:*/		return 0x820752D0;
	}
	return 0x820752D0;
} // Block from 82075298h-820752D0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820752D0h
// Function '?InsertCallback@D3D@@YAPAKPAVCDevice@1@PAKKP6AXK@ZK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820752D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820752D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820752D0);
		  /* 820752D0h */ case    0:  		/* mr R4, R3 */
		/* 820752D0h case    0:*/		regs.R4 = regs.R3;
		/* 820752D0h case    0:*/		return 0x820752D4;
		  /* 820752D4h */ case    1:  		/* li R5, 0 */
		/* 820752D4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820752D4h case    1:*/		return 0x820752D8;
		  /* 820752D8h */ case    2:  		/* b -896 */
		/* 820752D8h case    2:*/		return 0x82074F58;
		/* 820752D8h case    2:*/		return 0x820752DC;
		  /* 820752DCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 820752DCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820752DCh case    3:*/		return 0x820752E0;
	}
	return 0x820752E0;
} // Block from 820752D0h-820752E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820752E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820752E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820752E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820752E0);
		  /* 820752E0h */ case    0:  		/* li R9, 128 */
		/* 820752E0h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x80);
		/* 820752E0h case    0:*/		return 0x820752E4;
		  /* 820752E4h */ case    1:  		/* li R10, 0 */
		/* 820752E4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820752E4h case    1:*/		return 0x820752E8;
		  /* 820752E8h */ case    2:  		/* addi R11, R3, 1022 */
		/* 820752E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x3FE);
		/* 820752E8h case    2:*/		return 0x820752EC;
		  /* 820752ECh */ case    3:  		/* mtspr CTR, R9 */
		/* 820752ECh case    3:*/		regs.CTR = regs.R9;
		/* 820752ECh case    3:*/		return 0x820752F0;
		  /* 820752F0h */ case    4:  		/* li R9, 127 */
		/* 820752F0h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x7F);
		/* 820752F0h case    4:*/		return 0x820752F4;
		  /* 820752F4h */ case    5:  		/* divwu R8, R10, R9 */
		/* 820752F4h case    5:*/		cpu::op::divwu<0>(regs,&regs.R8,regs.R10,regs.R9);
		/* 820752F4h case    5:*/		return 0x820752F8;
		  /* 820752F8h */ case    6:  		/* addis R10, R10, 1 */
		/* 820752F8h case    6:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820752F8h case    6:*/		return 0x820752FC;
		  /* 820752FCh */ case    7:  		/* rlwinm R8, R8, 0, 16, 31 */
		/* 820752FCh case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R8,regs.R8);
		/* 820752FCh case    7:*/		return 0x82075300;
		  /* 82075300h */ case    8:  		/* addi R10, R10, -1 */
		/* 82075300h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82075300h case    8:*/		return 0x82075304;
		  /* 82075304h */ case    9:  		/* sth R8, <#[R11 - 1022]> */
		/* 82075304h case    9:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R11 + 0xFFFFFC02) );
		/* 82075304h case    9:*/		return 0x82075308;
		  /* 82075308h */ case   10:  		/* divwu R7, R10, R9 */
		/* 82075308h case   10:*/		cpu::op::divwu<0>(regs,&regs.R7,regs.R10,regs.R9);
		/* 82075308h case   10:*/		return 0x8207530C;
		  /* 8207530Ch */ case   11:  		/* sth R8, <#[R11 - 510]> */
		/* 8207530Ch case   11:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R11 + 0xFFFFFE02) );
		/* 8207530Ch case   11:*/		return 0x82075310;
		  /* 82075310h */ case   12:  		/* sth R8, <#[R11 + 2]> */
		/* 82075310h case   12:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R11 + 0x00000002) );
		/* 82075310h case   12:*/		return 0x82075314;
		  /* 82075314h */ case   13:  		/* subf R7, R8, R7 */
		/* 82075314h case   13:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R8,regs.R7);
		/* 82075314h case   13:*/		return 0x82075318;
		  /* 82075318h */ case   14:  		/* rlwinm R8, R7, 0, 16, 31 */
		/* 82075318h case   14:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R8,regs.R7);
		/* 82075318h case   14:*/		return 0x8207531C;
		  /* 8207531Ch */ case   15:  		/* sth R8, <#[R11 - 1020]> */
		/* 8207531Ch case   15:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R11 + 0xFFFFFC04) );
		/* 8207531Ch case   15:*/		return 0x82075320;
		  /* 82075320h */ case   16:  		/* sth R8, <#[R11 - 508]> */
		/* 82075320h case   16:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R11 + 0xFFFFFE04) );
		/* 82075320h case   16:*/		return 0x82075324;
		  /* 82075324h */ case   17:  		/* sthu R8, <#[R11 + 4]> */
		/* 82075324h case   17:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82075324h case   17:*/		return 0x82075328;
		  /* 82075328h */ case   18:  		/* bc 16, CR0_LT, -52 */
		/* 82075328h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820752F4;  }
		/* 82075328h case   18:*/		return 0x8207532C;
		  /* 8207532Ch */ case   19:  		/* cmpwi CR6, R4, 0 */
		/* 8207532Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 8207532Ch case   19:*/		return 0x82075330;
		  /* 82075330h */ case   20:  		/* bclr 12, CR6_EQ */
		/* 82075330h case   20:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82075330h case   20:*/		return 0x82075334;
	}
	return 0x82075334;
} // Block from 820752E0h-82075334h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82075334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075334);
		  /* 82075334h */ case    0:  		/* mr R4, R3 */
		/* 82075334h case    0:*/		regs.R4 = regs.R3;
		/* 82075334h case    0:*/		return 0x82075338;
		  /* 82075338h */ case    1:  		/* li R5, 0 */
		/* 82075338h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82075338h case    1:*/		return 0x8207533C;
		  /* 8207533Ch */ case    2:  		/* b -844 */
		/* 8207533Ch case    2:*/		return 0x82074FF0;
		/* 8207533Ch case    2:*/		return 0x82075340;
		  /* 82075340h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82075340h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82075340h case    3:*/		return 0x82075344;
	}
	return 0x82075344;
} // Block from 82075334h-82075344h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82075344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075344);
		  /* 82075344h */ case    0:  		/* nop */
		/* 82075344h case    0:*/		cpu::op::nop();
		/* 82075344h case    0:*/		return 0x82075348;
		  /* 82075348h */ case    1:  		/* lwz R11, <#[R3 + 13948]> */
		/* 82075348h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000367C) );
		/* 82075348h case    1:*/		return 0x8207534C;
		  /* 8207534Ch */ case    2:  		/* stw R11, <#[R5]> */
		/* 8207534Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8207534Ch case    2:*/		return 0x82075350;
		  /* 82075350h */ case    3:  		/* lwz R11, <#[R3 + 13952]> */
		/* 82075350h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003680) );
		/* 82075350h case    3:*/		return 0x82075354;
		  /* 82075354h */ case    4:  		/* stw R11, <#[R5 + 4]> */
		/* 82075354h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 82075354h case    4:*/		return 0x82075358;
		  /* 82075358h */ case    5:  		/* lwz R11, <#[R3 + 21964]> */
		/* 82075358h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000055CC) );
		/* 82075358h case    5:*/		return 0x8207535C;
		  /* 8207535Ch */ case    6:  		/* stw R11, <#[R5 + 8]> */
		/* 8207535Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 8207535Ch case    6:*/		return 0x82075360;
		  /* 82075360h */ case    7:  		/* lwz R11, <#[R3 + 13956]> */
		/* 82075360h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003684) );
		/* 82075360h case    7:*/		return 0x82075364;
		  /* 82075364h */ case    8:  		/* stw R11, <#[R5 + 12]> */
		/* 82075364h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x0000000C) );
		/* 82075364h case    8:*/		return 0x82075368;
		  /* 82075368h */ case    9:  		/* bclr 20, CR0_LT */
		/* 82075368h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82075368h case    9:*/		return 0x8207536C;
	}
	return 0x8207536C;
} // Block from 82075344h-8207536Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8207536Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207536C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207536C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207536C);
		  /* 8207536Ch */ case    0:  		/* nop */
		/* 8207536Ch case    0:*/		cpu::op::nop();
		/* 8207536Ch case    0:*/		return 0x82075370;
		  /* 82075370h */ case    1:  		/* lbz R11, <#[R3 + 11068]> */
		/* 82075370h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B3C) );
		/* 82075370h case    1:*/		return 0x82075374;
		  /* 82075374h */ case    2:  		/* rlwinm. R10, R11, 0, 26, 26 */
		/* 82075374h case    2:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R11);
		/* 82075374h case    2:*/		return 0x82075378;
		  /* 82075378h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82075378h case    3:*/		if ( regs.CR[0].eq ) { return 0x82075384;  }
		/* 82075378h case    3:*/		return 0x8207537C;
		  /* 8207537Ch */ case    4:  		/* lwz R10, <#[R3 + 13124]> */
		/* 8207537Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00003344) );
		/* 8207537Ch case    4:*/		return 0x82075380;
		  /* 82075380h */ case    5:  		/* b 8 */
		/* 82075380h case    5:*/		return 0x82075388;
		/* 82075380h case    5:*/		return 0x82075384;
	}
	return 0x82075384;
} // Block from 8207536Ch-82075384h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82075384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075384);
		  /* 82075384h */ case    0:  		/* li R10, 1 */
		/* 82075384h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82075384h case    0:*/		return 0x82075388;
	}
	return 0x82075388;
} // Block from 82075384h-82075388h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82075388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075388);
		  /* 82075388h */ case    0:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 82075388h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 82075388h case    0:*/		return 0x8207538C;
		  /* 8207538Ch */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 8207538Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820753AC;  }
		/* 8207538Ch case    1:*/		return 0x82075390;
		  /* 82075390h */ case    2:  		/* lbz R11, <#[R3 + 11071]> */
		/* 82075390h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B3F) );
		/* 82075390h case    2:*/		return 0x82075394;
		  /* 82075394h */ case    3:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82075394h case    3:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82075394h case    3:*/		return 0x82075398;
		  /* 82075398h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 82075398h case    4:*/		if ( regs.CR[0].eq ) { return 0x820753A4;  }
		/* 82075398h case    4:*/		return 0x8207539C;
		  /* 8207539Ch */ case    5:  		/* li R11, 1 */
		/* 8207539Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8207539Ch case    5:*/		return 0x820753A0;
		  /* 820753A0h */ case    6:  		/* b 16 */
		/* 820753A0h case    6:*/		return 0x820753B0;
		/* 820753A0h case    6:*/		return 0x820753A4;
	}
	return 0x820753A4;
} // Block from 82075388h-820753A4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820753A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820753A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820753A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820753A4);
		  /* 820753A4h */ case    0:  		/* mr R11, R10 */
		/* 820753A4h case    0:*/		regs.R11 = regs.R10;
		/* 820753A4h case    0:*/		return 0x820753A8;
		  /* 820753A8h */ case    1:  		/* b 8 */
		/* 820753A8h case    1:*/		return 0x820753B0;
		/* 820753A8h case    1:*/		return 0x820753AC;
	}
	return 0x820753AC;
} // Block from 820753A4h-820753ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820753ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820753AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820753AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820753AC);
		  /* 820753ACh */ case    0:  		/* li R11, 0 */
		/* 820753ACh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820753ACh case    0:*/		return 0x820753B0;
	}
	return 0x820753B0;
} // Block from 820753ACh-820753B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820753B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820753B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820753B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820753B0);
		  /* 820753B0h */ case    0:  		/* add R3, R11, R10 */
		/* 820753B0h case    0:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820753B0h case    0:*/		return 0x820753B4;
		  /* 820753B4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820753B4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820753B4h case    1:*/		return 0x820753B8;
	}
	return 0x820753B8;
} // Block from 820753B0h-820753B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820753B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820753B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820753B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820753B8);
		  /* 820753B8h */ case    0:  		/* mfspr R12, LR */
		/* 820753B8h case    0:*/		regs.R12 = regs.LR;
		/* 820753B8h case    0:*/		return 0x820753BC;
		  /* 820753BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820753BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820753BCh case    1:*/		return 0x820753C0;
		  /* 820753C0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820753C0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820753C0h case    2:*/		return 0x820753C4;
		  /* 820753C4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820753C4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820753C4h case    3:*/		return 0x820753C8;
		  /* 820753C8h */ case    4:  		/* lwz R11, <#[R3 + 11044]> */
		/* 820753C8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B24) );
		/* 820753C8h case    4:*/		return 0x820753CC;
		  /* 820753CCh */ case    5:  		/* mr R31, R3 */
		/* 820753CCh case    5:*/		regs.R31 = regs.R3;
		/* 820753CCh case    5:*/		return 0x820753D0;
		  /* 820753D0h */ case    6:  		/* lwz R10, <#[R3 + 56]> */
		/* 820753D0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000038) );
		/* 820753D0h case    6:*/		return 0x820753D4;
		  /* 820753D4h */ case    7:  		/* lwz R3, <#[R3 + 48]> */
		/* 820753D4h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 820753D4h case    7:*/		return 0x820753D8;
		  /* 820753D8h */ case    8:  		/* rlwimi R11, R4, 12, 18, 19 */
		/* 820753D8h case    8:*/		cpu::op::rlwimi<0,12,18,19>(regs,&regs.R11,regs.R4);
		/* 820753D8h case    8:*/		return 0x820753DC;
		  /* 820753DCh */ case    9:  		/* cmplw CR6, R3, R10 */
		/* 820753DCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820753DCh case    9:*/		return 0x820753E0;
		  /* 820753E0h */ case   10:  		/* stw R11, <#[R31 + 11044]> */
		/* 820753E0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002B24) );
		/* 820753E0h case   10:*/		return 0x820753E4;
		  /* 820753E4h */ case   11:  		/* bc 4, CR6_GT, 12 */
		/* 820753E4h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820753F0;  }
		/* 820753E4h case   11:*/		return 0x820753E8;
		  /* 820753E8h */ case   12:  		/* mr R3, R31 */
		/* 820753E8h case   12:*/		regs.R3 = regs.R31;
		/* 820753E8h case   12:*/		return 0x820753EC;
		  /* 820753ECh */ case   13:  		/* bl -4836 */
		/* 820753ECh case   13:*/		regs.LR = 0x820753F0; return 0x82074108;
		/* 820753ECh case   13:*/		return 0x820753F0;
	}
	return 0x820753F0;
} // Block from 820753B8h-820753F0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820753F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820753F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820753F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820753F0);
		  /* 820753F0h */ case    0:  		/* li R11, 1480 */
		/* 820753F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x5C8);
		/* 820753F0h case    0:*/		return 0x820753F4;
		  /* 820753F4h */ case    1:  		/* lis R10, 2 */
		/* 820753F4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x2);
		/* 820753F4h case    1:*/		return 0x820753F8;
		  /* 820753F8h */ case    2:  		/* stwu R11, <#[R3 + 4]> */
		/* 820753F8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820753F8h case    2:*/		return 0x820753FC;
		  /* 820753FCh */ case    3:  		/* li R11, 3841 */
		/* 820753FCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xF01);
		/* 820753FCh case    3:*/		return 0x82075400;
		  /* 82075400h */ case    4:  		/* stwu R10, <#[R3 + 4]> */
		/* 82075400h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82075400h case    4:*/		return 0x82075404;
		  /* 82075404h */ case    5:  		/* stwu R11, <#[R3 + 4]> */
		/* 82075404h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82075404h case    5:*/		return 0x82075408;
		  /* 82075408h */ case    6:  		/* lwz R11, <#[R31 + 11044]> */
		/* 82075408h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B24) );
		/* 82075408h case    6:*/		return 0x8207540C;
		  /* 8207540Ch */ case    7:  		/* stwu R11, <#[R3 + 4]> */
		/* 8207540Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 8207540Ch case    7:*/		return 0x82075410;
		  /* 82075410h */ case    8:  		/* stw R3, <#[R31 + 48]> */
		/* 82075410h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82075410h case    8:*/		return 0x82075414;
		  /* 82075414h */ case    9:  		/* addi R1, R1, 96 */
		/* 82075414h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82075414h case    9:*/		return 0x82075418;
		  /* 82075418h */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 82075418h case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82075418h case   10:*/		return 0x8207541C;
		  /* 8207541Ch */ case   11:  		/* mtspr LR, R12 */
		/* 8207541Ch case   11:*/		regs.LR = regs.R12;
		/* 8207541Ch case   11:*/		return 0x82075420;
		  /* 82075420h */ case   12:  		/* ld R31, <#[R1 - 16]> */
		/* 82075420h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82075420h case   12:*/		return 0x82075424;
		  /* 82075424h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82075424h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82075424h case   13:*/		return 0x82075428;
	}
	return 0x82075428;
} // Block from 820753F0h-82075428h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82075428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075428);
		  /* 82075428h */ case    0:  		/* mfspr R12, LR */
		/* 82075428h case    0:*/		regs.R12 = regs.LR;
		/* 82075428h case    0:*/		return 0x8207542C;
		  /* 8207542Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8207542Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8207542Ch case    1:*/		return 0x82075430;
		  /* 82075430h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82075430h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82075430h case    2:*/		return 0x82075434;
		  /* 82075434h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82075434h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82075434h case    3:*/		return 0x82075438;
		  /* 82075438h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82075438h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82075438h case    4:*/		return 0x8207543C;
		  /* 8207543Ch */ case    5:  		/* lbz R11, <#[R3 + 11070]> */
		/* 8207543Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B3E) );
		/* 8207543Ch case    5:*/		return 0x82075440;
		  /* 82075440h */ case    6:  		/* mr R31, R3 */
		/* 82075440h case    6:*/		regs.R31 = regs.R3;
		/* 82075440h case    6:*/		return 0x82075444;
		  /* 82075444h */ case    7:  		/* mr R30, R4 */
		/* 82075444h case    7:*/		regs.R30 = regs.R4;
		/* 82075444h case    7:*/		return 0x82075448;
		  /* 82075448h */ case    8:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 82075448h case    8:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82075448h case    8:*/		return 0x8207544C;
		  /* 8207544Ch */ case    9:  		/* cmpw CR6, R11, R4 */
		/* 8207544Ch case    9:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R4);
		/* 8207544Ch case    9:*/		return 0x82075450;
		  /* 82075450h */ case   10:  		/* bc 12, CR6_EQ, 144 */
		/* 82075450h case   10:*/		if ( regs.CR[6].eq ) { return 0x820754E0;  }
		/* 82075450h case   10:*/		return 0x82075454;
		  /* 82075454h */ case   11:  		/* bl -4252 */
		/* 82075454h case   11:*/		regs.LR = 0x82075458; return 0x820743B8;
		/* 82075454h case   11:*/		return 0x82075458;
		  /* 82075458h */ case   12:  		/* cntlzw R11, R30 */
		/* 82075458h case   12:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R30);
		/* 82075458h case   12:*/		return 0x8207545C;
		  /* 8207545Ch */ case   13:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 8207545Ch case   13:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 8207545Ch case   13:*/		return 0x82075460;
		  /* 82075460h */ case   14:  		/* bl 2063352 */
		/* 82075460h case   14:*/		regs.LR = 0x82075464; return 0x8226D058;
		/* 82075460h case   14:*/		return 0x82075464;
		  /* 82075464h */ case   15:  		/* cmpwi CR6, R30, 0 */
		/* 82075464h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82075464h case   15:*/		return 0x82075468;
		  /* 82075468h */ case   16:  		/* bc 4, CR6_EQ, 120 */
		/* 82075468h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820754E0;  }
		/* 82075468h case   16:*/		return 0x8207546C;
		  /* 8207546Ch */ case   17:  		/* lwz R11, <#[R31 + 56]> */
		/* 8207546Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 8207546Ch case   17:*/		return 0x82075470;
		  /* 82075470h */ case   18:  		/* lwz R3, <#[R31 + 48]> */
		/* 82075470h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82075470h case   18:*/		return 0x82075474;
		  /* 82075474h */ case   19:  		/* cmplw CR6, R3, R11 */
		/* 82075474h case   19:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82075474h case   19:*/		return 0x82075478;
		  /* 82075478h */ case   20:  		/* bc 4, CR6_GT, 12 */
		/* 82075478h case   20:*/		if ( !regs.CR[6].gt ) { return 0x82075484;  }
		/* 82075478h case   20:*/		return 0x8207547C;
		  /* 8207547Ch */ case   21:  		/* mr R3, R31 */
		/* 8207547Ch case   21:*/		regs.R3 = regs.R31;
		/* 8207547Ch case   21:*/		return 0x82075480;
		  /* 82075480h */ case   22:  		/* bl -4984 */
		/* 82075480h case   22:*/		regs.LR = 0x82075484; return 0x82074108;
		/* 82075480h case   22:*/		return 0x82075484;
	}
	return 0x82075484;
} // Block from 82075428h-82075484h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82075484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075484);
		  /* 82075484h */ case    0:  		/* lis R11, -16382 */
		/* 82075484h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC002);
		/* 82075484h case    0:*/		return 0x82075488;
		  /* 82075488h */ case    1:  		/* li R10, 129 */
		/* 82075488h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x81);
		/* 82075488h case    1:*/		return 0x8207548C;
		  /* 8207548Ch */ case    2:  		/* ori R9, R11, 8448 */
		/* 8207548Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R11,0x2100);
		/* 8207548Ch case    2:*/		return 0x82075490;
		  /* 82075490h */ case    3:  		/* li R11, -1 */
		/* 82075490h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82075490h case    3:*/		return 0x82075494;
		  /* 82075494h */ case    4:  		/* stwu R9, <#[R3 + 4]> */
		/* 82075494h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82075494h case    4:*/		return 0x82075498;
		  /* 82075498h */ case    5:  		/* lis R9, -32215 */
		/* 82075498h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8229);
		/* 82075498h case    5:*/		return 0x8207549C;
		  /* 8207549Ch */ case    6:  		/* mr R7, R11 */
		/* 8207549Ch case    6:*/		regs.R7 = regs.R11;
		/* 8207549Ch case    6:*/		return 0x820754A0;
		  /* 820754A0h */ case    7:  		/* mr R8, R11 */
		/* 820754A0h case    7:*/		regs.R8 = regs.R11;
		/* 820754A0h case    7:*/		return 0x820754A4;
		  /* 820754A4h */ case    8:  		/* lis R11, -16382 */
		/* 820754A4h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC002);
		/* 820754A4h case    8:*/		return 0x820754A8;
		  /* 820754A8h */ case    9:  		/* li R6, 130 */
		/* 820754A8h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x82);
		/* 820754A8h case    9:*/		return 0x820754AC;
		  /* 820754ACh */ case   10:  		/* stwu R10, <#[R3 + 4]> */
		/* 820754ACh case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820754ACh case   10:*/		return 0x820754B0;
		  /* 820754B0h */ case   11:  		/* ori R5, R11, 8448 */
		/* 820754B0h case   11:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R11,0x2100);
		/* 820754B0h case   11:*/		return 0x820754B4;
		  /* 820754B4h */ case   12:  		/* lis R10, -32215 */
		/* 820754B4h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8229);
		/* 820754B4h case   12:*/		return 0x820754B8;
		  /* 820754B8h */ case   13:  		/* stwu R7, <#[R3 + 4]> */
		/* 820754B8h case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820754B8h case   13:*/		return 0x820754BC;
		  /* 820754BCh */ case   14:  		/* lwz R11, <#[R9 - 31288]> */
		/* 820754BCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0xFFFF85C8) );
		/* 820754BCh case   14:*/		return 0x820754C0;
		  /* 820754C0h */ case   15:  		/* oris R11, R11, 32769 */
		/* 820754C0h case   15:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8001);
		/* 820754C0h case   15:*/		return 0x820754C4;
		  /* 820754C4h */ case   16:  		/* stwu R11, <#[R3 + 4]> */
		/* 820754C4h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820754C4h case   16:*/		return 0x820754C8;
		  /* 820754C8h */ case   17:  		/* stwu R5, <#[R3 + 4]> */
		/* 820754C8h case   17:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820754C8h case   17:*/		return 0x820754CC;
		  /* 820754CCh */ case   18:  		/* stwu R6, <#[R3 + 4]> */
		/* 820754CCh case   18:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820754CCh case   18:*/		return 0x820754D0;
		  /* 820754D0h */ case   19:  		/* stwu R7, <#[R3 + 4]> */
		/* 820754D0h case   19:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820754D0h case   19:*/		return 0x820754D4;
		  /* 820754D4h */ case   20:  		/* lwz R11, <#[R10 - 31284]> */
		/* 820754D4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFF85CC) );
		/* 820754D4h case   20:*/		return 0x820754D8;
		  /* 820754D8h */ case   21:  		/* stwu R11, <#[R3 + 4]> */
		/* 820754D8h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820754D8h case   21:*/		return 0x820754DC;
		  /* 820754DCh */ case   22:  		/* stw R3, <#[R31 + 48]> */
		/* 820754DCh case   22:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 820754DCh case   22:*/		return 0x820754E0;
	}
	return 0x820754E0;
} // Block from 82075484h-820754E0h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820754E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820754E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820754E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820754E0);
		  /* 820754E0h */ case    0:  		/* addi R11, R30, -1 */
		/* 820754E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFF);
		/* 820754E0h case    0:*/		return 0x820754E4;
		  /* 820754E4h */ case    1:  		/* lbz R10, <#[R31 + 11070]> */
		/* 820754E4h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B3E) );
		/* 820754E4h case    1:*/		return 0x820754E8;
		  /* 820754E8h */ case    2:  		/* cntlzw R11, R11 */
		/* 820754E8h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820754E8h case    2:*/		return 0x820754EC;
		  /* 820754ECh */ case    3:  		/* rlwimi R10, R11, 27, 31, 31 */
		/* 820754ECh case    3:*/		cpu::op::rlwimi<0,27,31,31>(regs,&regs.R10,regs.R11);
		/* 820754ECh case    3:*/		return 0x820754F0;
		  /* 820754F0h */ case    4:  		/* stb R10, <#[R31 + 11070]> */
		/* 820754F0h case    4:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00002B3E) );
		/* 820754F0h case    4:*/		return 0x820754F4;
		  /* 820754F4h */ case    5:  		/* addi R1, R1, 112 */
		/* 820754F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820754F4h case    5:*/		return 0x820754F8;
		  /* 820754F8h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 820754F8h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820754F8h case    6:*/		return 0x820754FC;
		  /* 820754FCh */ case    7:  		/* mtspr LR, R12 */
		/* 820754FCh case    7:*/		regs.LR = regs.R12;
		/* 820754FCh case    7:*/		return 0x82075500;
		  /* 82075500h */ case    8:  		/* ld R30, <#[R1 - 24]> */
		/* 82075500h case    8:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82075500h case    8:*/		return 0x82075504;
		  /* 82075504h */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 82075504h case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82075504h case    9:*/		return 0x82075508;
		  /* 82075508h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82075508h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82075508h case   10:*/		return 0x8207550C;
	}
	return 0x8207550C;
} // Block from 820754E0h-8207550Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8207550Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207550C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207550C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207550C);
		  /* 8207550Ch */ case    0:  		/* nop */
		/* 8207550Ch case    0:*/		cpu::op::nop();
		/* 8207550Ch case    0:*/		return 0x82075510;
	}
	return 0x82075510;
} // Block from 8207550Ch-82075510h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82075510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075510);
		  /* 82075510h */ case    0:  		/* mfspr R12, LR */
		/* 82075510h case    0:*/		regs.R12 = regs.LR;
		/* 82075510h case    0:*/		return 0x82075514;
		  /* 82075514h */ case    1:  		/* bl 113992 */
		/* 82075514h case    1:*/		regs.LR = 0x82075518; return 0x8209125C;
		/* 82075514h case    1:*/		return 0x82075518;
		  /* 82075518h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82075518h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82075518h case    2:*/		return 0x8207551C;
		  /* 8207551Ch */ case    3:  		/* mr R29, R3 */
		/* 8207551Ch case    3:*/		regs.R29 = regs.R3;
		/* 8207551Ch case    3:*/		return 0x82075520;
		  /* 82075520h */ case    4:  		/* mr R30, R5 */
		/* 82075520h case    4:*/		regs.R30 = regs.R5;
		/* 82075520h case    4:*/		return 0x82075524;
		  /* 82075524h */ case    5:  		/* mr R31, R6 */
		/* 82075524h case    5:*/		regs.R31 = regs.R6;
		/* 82075524h case    5:*/		return 0x82075528;
		  /* 82075528h */ case    6:  		/* cmplwi CR6, R6, 0 */
		/* 82075528h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82075528h case    6:*/		return 0x8207552C;
		  /* 8207552Ch */ case    7:  		/* bc 4, CR6_EQ, 32 */
		/* 8207552Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x8207554C;  }
		/* 8207552Ch case    7:*/		return 0x82075530;
		  /* 82075530h */ case    8:  		/* lis R4, 9344 */
		/* 82075530h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 82075530h case    8:*/		return 0x82075534;
		  /* 82075534h */ case    9:  		/* li R3, 16 */
		/* 82075534h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x10);
		/* 82075534h case    9:*/		return 0x82075538;
		  /* 82075538h */ case   10:  		/* bl 77000 */
		/* 82075538h case   10:*/		regs.LR = 0x8207553C; return 0x82088200;
		/* 82075538h case   10:*/		return 0x8207553C;
		  /* 8207553Ch */ case   11:  		/* or. R31, R3, R3 */
		/* 8207553Ch case   11:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8207553Ch case   11:*/		return 0x82075540;
		  /* 82075540h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 82075540h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8207554C;  }
		/* 82075540h case   12:*/		return 0x82075544;
		  /* 82075544h */ case   13:  		/* li R3, 0 */
		/* 82075544h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82075544h case   13:*/		return 0x82075548;
		  /* 82075548h */ case   14:  		/* b 56 */
		/* 82075548h case   14:*/		return 0x82075580;
		/* 82075548h case   14:*/		return 0x8207554C;
	}
	return 0x8207554C;
} // Block from 82075510h-8207554Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8207554Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8207554C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8207554C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8207554C);
		  /* 8207554Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8207554Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8207554Ch case    0:*/		return 0x82075550;
	}
	return 0x82075550;
} // Block from 8207554Ch-82075550h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82075550h
// Function '?InterruptCallback@D3D@@YAXKPAVCDevice@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82075550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82075550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82075550);
		  /* 82075550h */ case    0:  		/* bc 12, CR6_EQ, 56 */
		/* 82075550h case    0:*/		if ( regs.CR[6].eq ) { return 0x82075588;  }
		/* 82075550h case    0:*/		return 0x82075554;
		  /* 82075554h */ case    1:  		/* stw R30, <#[R31 + 4]> */
		/* 82075554h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 82075554h case    1:*/		return 0x82075558;
		  /* 82075558h */ case    2:  		/* lwz R3, <#[R31 + 4]> */
		/* 82075558h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 82075558h case    2:*/		return 0x8207555C;
		  /* 8207555Ch */ case    3:  		/* li R5, 0 */
		/* 8207555Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8207555Ch case    3:*/		return 0x82075560;
		  /* 82075560h */ case    4:  		/* addi R4, R3, 480 */
		/* 82075560h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x1E0);
		/* 82075560h case    4:*/		return 0x82075564;
		  /* 82075564h */ case    5:  		/* bl 64612 */
		/* 82075564h case    5:*/		regs.LR = 0x82075568; return 0x820851C8;
		/* 82075564h case    5:*/		return 0x82075568;
		  /* 82075568h */ case    6:  		/* li R11, 1 */
		/* 82075568h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82075568h case    6:*/		return 0x8207556C;
		  /* 8207556Ch */ case    7:  		/* li R10, 0 */
		/* 8207556Ch case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8207556Ch case    7:*/		return 0x82075570;
		  /* 82075570h */ case    8:  		/* stw R29, <#[R31 + 8]> */
		/* 82075570h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 82075570h case    8:*/		return 0x82075574;
		  /* 82075574h */ case    9:  		/* stw R11, <#[R31]> */
		/* 82075574h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82075574h case    9:*/		return 0x82075578;
		  /* 82075578h */ case   10:  		/* mr R3, R31 */
		/* 82075578h case   10:*/		regs.R3 = regs.R31;
		/* 82075578h case   10:*/		return 0x8207557C;
		  /* 8207557Ch */ case   11:  		/* stw R10, <#[R31 + 12]> */
		/* 8207557Ch case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 8207557Ch case   11:*/		return 0x82075580;
	}
	return 0x82075580;
} // Block from 82075550h-82075580h (12 instructions)

