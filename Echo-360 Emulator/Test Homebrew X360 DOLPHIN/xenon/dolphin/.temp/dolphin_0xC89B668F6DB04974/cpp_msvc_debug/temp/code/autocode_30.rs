#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 821960B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821960B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821960B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821960B4);
		  /* 821960B4h */ case    0:  		/* rlwinm R11, R19, 0, 0, 30 */
		/* 821960B4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R19);
		/* 821960B4h case    0:*/		return 0x821960B8;
		  /* 821960B8h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 821960B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821960B8h case    1:*/		return 0x821960BC;
		  /* 821960BCh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821960BCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821960BCh case    2:*/		return 0x821960C0;
		  /* 821960C0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821960C0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821960D0;  }
		/* 821960C0h case    3:*/		return 0x821960C4;
	}
	return 0x821960C4;
} // Block from 821960B4h-821960C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821960C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821960C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821960C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821960C4);
		  /* 821960C4h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821960C4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821960C4h case    0:*/		return 0x821960C8;
		  /* 821960C8h */ case    1:  		/* addic. R19, R11, -4 */
		/* 821960C8h case    1:*/		cpu::op::addic<1>(regs,&regs.R19,regs.R11,0xFFFFFFFC);
		/* 821960C8h case    1:*/		return 0x821960CC;
		  /* 821960CCh */ case    2:  		/* bc 4, CR0_EQ, -1484 */
		/* 821960CCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82195B00;  }
		/* 821960CCh case    2:*/		return 0x821960D0;
	}
	return 0x821960D0;
} // Block from 821960C4h-821960D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821960D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821960D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821960D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821960D0);
		  /* 821960D0h */ case    0:  		/* lwz R11, <#[R18 + 4]> */
		/* 821960D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 821960D0h case    0:*/		return 0x821960D4;
		  /* 821960D4h */ case    1:  		/* mr R3, R18 */
		/* 821960D4h case    1:*/		regs.R3 = regs.R18;
		/* 821960D4h case    1:*/		return 0x821960D8;
		  /* 821960D8h */ case    2:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821960D8h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821960D8h case    2:*/		return 0x821960DC;
		  /* 821960DCh */ case    3:  		/* addic R10, R10, -1 */
		/* 821960DCh case    3:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821960DCh case    3:*/		return 0x821960E0;
		  /* 821960E0h */ case    4:  		/* subfe R10, R10, R10 */
		/* 821960E0h case    4:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821960E0h case    4:*/		return 0x821960E4;
		  /* 821960E4h */ case    5:  		/* and R30, R10, R11 */
		/* 821960E4h case    5:*/		cpu::op::and<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 821960E4h case    5:*/		return 0x821960E8;
		  /* 821960E8h */ case    6:  		/* mr R4, R30 */
		/* 821960E8h case    6:*/		regs.R4 = regs.R30;
		/* 821960E8h case    6:*/		return 0x821960EC;
		  /* 821960ECh */ case    7:  		/* bl -7724 */
		/* 821960ECh case    7:*/		regs.LR = 0x821960F0; return 0x821942C0;
		/* 821960ECh case    7:*/		return 0x821960F0;
		  /* 821960F0h */ case    8:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821960F0h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821960F0h case    8:*/		return 0x821960F4;
		  /* 821960F4h */ case    9:  		/* b 44 */
		/* 821960F4h case    9:*/		return 0x82196120;
		/* 821960F4h case    9:*/		return 0x821960F8;
	}
	return 0x821960F8;
} // Block from 821960D0h-821960F8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821960F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821960F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821960F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821960F8);
		  /* 821960F8h */ case    0:  		/* li R4, 4800 */
		/* 821960F8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821960F8h case    0:*/		return 0x821960FC;
		  /* 821960FCh */ case    1:  		/* mr R3, R18 */
		/* 821960FCh case    1:*/		regs.R3 = regs.R18;
		/* 821960FCh case    1:*/		return 0x82196100;
		  /* 82196100h */ case    2:  		/* bl -279192 */
		/* 82196100h case    2:*/		regs.LR = 0x82196104; return 0x82151E68;
		/* 82196100h case    2:*/		return 0x82196104;
		  /* 82196104h */ case    3:  		/* mr R4, R31 */
		/* 82196104h case    3:*/		regs.R4 = regs.R31;
		/* 82196104h case    3:*/		return 0x82196108;
		  /* 82196108h */ case    4:  		/* mr R3, R18 */
		/* 82196108h case    4:*/		regs.R3 = regs.R18;
		/* 82196108h case    4:*/		return 0x8219610C;
		  /* 8219610Ch */ case    5:  		/* bl -7756 */
		/* 8219610Ch case    5:*/		regs.LR = 0x82196110; return 0x821942C0;
		/* 8219610Ch case    5:*/		return 0x82196110;
		  /* 82196110h */ case    6:  		/* mr R4, R31 */
		/* 82196110h case    6:*/		regs.R4 = regs.R31;
		/* 82196110h case    6:*/		return 0x82196114;
		  /* 82196114h */ case    7:  		/* mr R3, R18 */
		/* 82196114h case    7:*/		regs.R3 = regs.R18;
		/* 82196114h case    7:*/		return 0x82196118;
		  /* 82196118h */ case    8:  		/* bl -23336 */
		/* 82196118h case    8:*/		regs.LR = 0x8219611C; return 0x821905F0;
		/* 82196118h case    8:*/		return 0x8219611C;
		  /* 8219611Ch */ case    9:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8219611Ch case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8219611Ch case    9:*/		return 0x82196120;
	}
	return 0x82196120;
} // Block from 821960F8h-82196120h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82196120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196120);
		  /* 82196120h */ case    0:  		/* lwz R31, <#[R11 + 4]> */
		/* 82196120h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 82196120h case    0:*/		return 0x82196124;
		  /* 82196124h */ case    1:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82196124h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82196124h case    1:*/		return 0x82196128;
		  /* 82196128h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 82196128h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82196134;  }
		/* 82196128h case    2:*/		return 0x8219612C;
		  /* 8219612Ch */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 8219612Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219612Ch case    3:*/		return 0x82196130;
		  /* 82196130h */ case    4:  		/* bc 4, CR6_EQ, -44 */
		/* 82196130h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82196104;  }
		/* 82196130h case    4:*/		return 0x82196134;
	}
	return 0x82196134;
} // Block from 82196120h-82196134h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82196134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196134);
		  /* 82196134h */ case    0:  		/* mr R4, R30 */
		/* 82196134h case    0:*/		regs.R4 = regs.R30;
		/* 82196134h case    0:*/		return 0x82196138;
		  /* 82196138h */ case    1:  		/* mr R3, R18 */
		/* 82196138h case    1:*/		regs.R3 = regs.R18;
		/* 82196138h case    1:*/		return 0x8219613C;
		  /* 8219613Ch */ case    2:  		/* bl -23372 */
		/* 8219613Ch case    2:*/		regs.LR = 0x82196140; return 0x821905F0;
		/* 8219613Ch case    2:*/		return 0x82196140;
		  /* 82196140h */ case    3:  		/* lwz R11, <#[R18 + 40]> */
		/* 82196140h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000028) );
		/* 82196140h case    3:*/		return 0x82196144;
		  /* 82196144h */ case    4:  		/* oris R11, R11, 8 */
		/* 82196144h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82196144h case    4:*/		return 0x82196148;
		  /* 82196148h */ case    5:  		/* stw R11, <#[R18 + 40]> */
		/* 82196148h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R18 + 0x00000028) );
		/* 82196148h case    5:*/		return 0x8219614C;
		  /* 8219614Ch */ case    6:  		/* addi R1, R1, 256 */
		/* 8219614Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 8219614Ch case    6:*/		return 0x82196150;
		  /* 82196150h */ case    7:  		/* b -1068756 */
		/* 82196150h case    7:*/		return 0x8209127C;
		/* 82196150h case    7:*/		return 0x82196154;
		  /* 82196154h */ case    8:  		/* nop */
		/* 82196154h case    8:*/		cpu::op::nop();
		/* 82196154h case    8:*/		return 0x82196158;
		  /* 82196158h */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 82196158h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82196158h case    9:*/		return 0x8219615C;
		  /* 8219615Ch */ case   10:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 8219615Ch case   10:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 8219615Ch case   10:*/		return 0x82196160;
		  /* 82196160h */ case   11:  		/* cmplwi CR6, R10, 1 */
		/* 82196160h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82196160h case   11:*/		return 0x82196164;
		  /* 82196164h */ case   12:  		/* bc 12, CR6_LT, 16 */
		/* 82196164h case   12:*/		if ( regs.CR[6].lt ) { return 0x82196174;  }
		/* 82196164h case   12:*/		return 0x82196168;
		  /* 82196168h */ case   13:  		/* cmplwi CR6, R10, 102 */
		/* 82196168h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 82196168h case   13:*/		return 0x8219616C;
		  /* 8219616Ch */ case   14:  		/* li R11, 1 */
		/* 8219616Ch case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219616Ch case   14:*/		return 0x82196170;
		  /* 82196170h */ case   15:  		/* bc 4, CR6_GT, 8 */
		/* 82196170h case   15:*/		if ( !regs.CR[6].gt ) { return 0x82196178;  }
		/* 82196170h case   15:*/		return 0x82196174;
	}
	return 0x82196174;
} // Block from 82196134h-82196174h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82196174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196174);
		  /* 82196174h */ case    0:  		/* li R11, 0 */
		/* 82196174h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82196174h case    0:*/		return 0x82196178;
	}
	return 0x82196178;
} // Block from 82196174h-82196178h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196178);
		  /* 82196178h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82196178h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82196178h case    0:*/		return 0x8219617C;
		  /* 8219617Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8219617Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82196188;  }
		/* 8219617Ch case    1:*/		return 0x82196180;
		  /* 82196180h */ case    2:  		/* li R3, 0 */
		/* 82196180h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82196180h case    2:*/		return 0x82196184;
		  /* 82196184h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82196184h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82196184h case    3:*/		return 0x82196188;
	}
	return 0x82196188;
} // Block from 82196178h-82196188h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82196188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196188);
		  /* 82196188h */ case    0:  		/* cmplwi CR6, R10, 96 */
		/* 82196188h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000060);
		/* 82196188h case    0:*/		return 0x8219618C;
		  /* 8219618Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8219618Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8219619C;  }
		/* 8219618Ch case    1:*/		return 0x82196190;
		  /* 82196190h */ case    2:  		/* cmplwi CR6, R10, 97 */
		/* 82196190h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000061);
		/* 82196190h case    2:*/		return 0x82196194;
		  /* 82196194h */ case    3:  		/* li R11, 1 */
		/* 82196194h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82196194h case    3:*/		return 0x82196198;
		  /* 82196198h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82196198h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821961A0;  }
		/* 82196198h case    4:*/		return 0x8219619C;
	}
	return 0x8219619C;
} // Block from 82196188h-8219619Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219619Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219619C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219619C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219619C);
		  /* 8219619Ch */ case    0:  		/* li R11, 0 */
		/* 8219619Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219619Ch case    0:*/		return 0x821961A0;
	}
	return 0x821961A0;
} // Block from 8219619Ch-821961A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821961A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821961A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821961A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821961A0);
		  /* 821961A0h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 821961A0h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 821961A0h case    0:*/		return 0x821961A4;
		  /* 821961A4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821961A4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821961A4h case    1:*/		return 0x821961A8;
	}
	return 0x821961A8;
} // Block from 821961A0h-821961A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821961A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821961A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821961A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821961A8);
		  /* 821961A8h */ case    0:  		/* rlwinm. R11, R3, 0, 27, 28 */
		/* 821961A8h case    0:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R3);
		/* 821961A8h case    0:*/		return 0x821961AC;
		  /* 821961ACh */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821961ACh case    1:*/		if ( regs.CR[0].eq ) { return 0x821961C0;  }
		/* 821961ACh case    1:*/		return 0x821961B0;
		  /* 821961B0h */ case    2:  		/* rlwinm. R11, R4, 0, 27, 28 */
		/* 821961B0h case    2:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R4);
		/* 821961B0h case    2:*/		return 0x821961B4;
		  /* 821961B4h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 821961B4h case    3:*/		if ( regs.CR[0].eq ) { return 0x821961C0;  }
		/* 821961B4h case    3:*/		return 0x821961B8;
		  /* 821961B8h */ case    4:  		/* li R3, 0 */
		/* 821961B8h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821961B8h case    4:*/		return 0x821961BC;
		  /* 821961BCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 821961BCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821961BCh case    5:*/		return 0x821961C0;
	}
	return 0x821961C0;
} // Block from 821961A8h-821961C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821961C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821961C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821961C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821961C0);
		  /* 821961C0h */ case    0:  		/* rlwinm. R11, R3, 0, 30, 30 */
		/* 821961C0h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R3);
		/* 821961C0h case    0:*/		return 0x821961C4;
		  /* 821961C4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821961C4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821961D0;  }
		/* 821961C4h case    1:*/		return 0x821961C8;
		  /* 821961C8h */ case    2:  		/* rlwinm. R11, R4, 0, 31, 31 */
		/* 821961C8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R4);
		/* 821961C8h case    2:*/		return 0x821961CC;
		  /* 821961CCh */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 821961CCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821961B8;  }
		/* 821961CCh case    3:*/		return 0x821961D0;
	}
	return 0x821961D0;
} // Block from 821961C0h-821961D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821961D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821961D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821961D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821961D0);
		  /* 821961D0h */ case    0:  		/* rlwinm. R11, R3, 0, 29, 29 */
		/* 821961D0h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R3);
		/* 821961D0h case    0:*/		return 0x821961D4;
		  /* 821961D4h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821961D4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821961E4;  }
		/* 821961D4h case    1:*/		return 0x821961D8;
		  /* 821961D8h */ case    2:  		/* rlwinm. R11, R4, 0, 31, 31 */
		/* 821961D8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R4);
		/* 821961D8h case    2:*/		return 0x821961DC;
		  /* 821961DCh */ case    3:  		/* li R3, 0 */
		/* 821961DCh case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821961DCh case    3:*/		return 0x821961E0;
		  /* 821961E0h */ case    4:  		/* bclr 4, CR0_EQ */
		/* 821961E0h case    4:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821961E0h case    4:*/		return 0x821961E4;
	}
	return 0x821961E4;
} // Block from 821961D0h-821961E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821961E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821961E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821961E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821961E4);
		  /* 821961E4h */ case    0:  		/* li R3, 1 */
		/* 821961E4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821961E4h case    0:*/		return 0x821961E8;
		  /* 821961E8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821961E8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821961E8h case    1:*/		return 0x821961EC;
	}
	return 0x821961EC;
} // Block from 821961E4h-821961ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821961ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821961EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821961EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821961EC);
		  /* 821961ECh */ case    0:  		/* nop */
		/* 821961ECh case    0:*/		cpu::op::nop();
		/* 821961ECh case    0:*/		return 0x821961F0;
		  /* 821961F0h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 821961F0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821961F0h case    1:*/		return 0x821961F4;
		  /* 821961F4h */ case    2:  		/* rlwinm R10, R4, 27, 29, 30 */
		/* 821961F4h case    2:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R10,regs.R4);
		/* 821961F4h case    2:*/		return 0x821961F8;
		  /* 821961F8h */ case    3:  		/* rlwinm R9, R4, 29, 29, 30 */
		/* 821961F8h case    3:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R9,regs.R4);
		/* 821961F8h case    3:*/		return 0x821961FC;
		  /* 821961FCh */ case    4:  		/* rlwinm R8, R11, 27, 24, 31 */
		/* 821961FCh case    4:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R11);
		/* 821961FCh case    4:*/		return 0x82196200;
		  /* 82196200h */ case    5:  		/* rlwinm R7, R4, 31, 29, 30 */
		/* 82196200h case    5:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R7,regs.R4);
		/* 82196200h case    5:*/		return 0x82196204;
		  /* 82196204h */ case    6:  		/* srw R10, R8, R10 */
		/* 82196204h case    6:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82196204h case    6:*/		return 0x82196208;
		  /* 82196208h */ case    7:  		/* srw R9, R8, R9 */
		/* 82196208h case    7:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82196208h case    7:*/		return 0x8219620C;
		  /* 8219620Ch */ case    8:  		/* rlwimi R9, R10, 2, 28, 29 */
		/* 8219620Ch case    8:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R9,regs.R10);
		/* 8219620Ch case    8:*/		return 0x82196210;
		  /* 82196210h */ case    9:  		/* srw R10, R8, R7 */
		/* 82196210h case    9:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R7);
		/* 82196210h case    9:*/		return 0x82196214;
		  /* 82196214h */ case   10:  		/* rlwinm R9, R9, 0, 28, 31 */
		/* 82196214h case   10:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R9);
		/* 82196214h case   10:*/		return 0x82196218;
		  /* 82196218h */ case   11:  		/* rlwinm R7, R4, 1, 29, 30 */
		/* 82196218h case   11:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R7,regs.R4);
		/* 82196218h case   11:*/		return 0x8219621C;
		  /* 8219621Ch */ case   12:  		/* rlwimi R10, R9, 2, 0, 29 */
		/* 8219621Ch case   12:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 8219621Ch case   12:*/		return 0x82196220;
		  /* 82196220h */ case   13:  		/* srw R9, R8, R7 */
		/* 82196220h case   13:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R8,regs.R7);
		/* 82196220h case   13:*/		return 0x82196224;
		  /* 82196224h */ case   14:  		/* rlwimi R9, R10, 2, 0, 29 */
		/* 82196224h case   14:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 82196224h case   14:*/		return 0x82196228;
		  /* 82196228h */ case   15:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 82196228h case   15:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 82196228h case   15:*/		return 0x8219622C;
		  /* 8219622Ch */ case   16:  		/* rlwinm R10, R9, 5, 0, 26 */
		/* 8219622Ch case   16:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R9);
		/* 8219622Ch case   16:*/		return 0x82196230;
		  /* 82196230h */ case   17:  		/* or R11, R10, R11 */
		/* 82196230h case   17:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82196230h case   17:*/		return 0x82196234;
		  /* 82196234h */ case   18:  		/* stw R11, <#[R3]> */
		/* 82196234h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82196234h case   18:*/		return 0x82196238;
		  /* 82196238h */ case   19:  		/* bclr 20, CR0_LT */
		/* 82196238h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82196238h case   19:*/		return 0x8219623C;
	}
	return 0x8219623C;
} // Block from 821961ECh-8219623Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219623Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219623C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219623C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219623C);
		  /* 8219623Ch */ case    0:  		/* nop */
		/* 8219623Ch case    0:*/		cpu::op::nop();
		/* 8219623Ch case    0:*/		return 0x82196240;
		  /* 82196240h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 82196240h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82196240h case    1:*/		return 0x82196244;
		  /* 82196244h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82196244h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82196244h case    2:*/		return 0x82196248;
		  /* 82196248h */ case    3:  		/* rlwinm. R10, R11, 0, 27, 28 */
		/* 82196248h case    3:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R11);
		/* 82196248h case    3:*/		return 0x8219624C;
		  /* 8219624Ch */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 8219624Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82196260;  }
		/* 8219624Ch case    4:*/		return 0x82196250;
		  /* 82196250h */ case    5:  		/* rlwinm. R10, R4, 0, 27, 28 */
		/* 82196250h case    5:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R4);
		/* 82196250h case    5:*/		return 0x82196254;
		  /* 82196254h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 82196254h case    6:*/		if ( regs.CR[0].eq ) { return 0x82196260;  }
		/* 82196254h case    6:*/		return 0x82196258;
		  /* 82196258h */ case    7:  		/* li R3, 0 */
		/* 82196258h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82196258h case    7:*/		return 0x8219625C;
		  /* 8219625Ch */ case    8:  		/* bclr 20, CR0_LT */
		/* 8219625Ch case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219625Ch case    8:*/		return 0x82196260;
	}
	return 0x82196260;
} // Block from 8219623Ch-82196260h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82196260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196260);
		  /* 82196260h */ case    0:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 82196260h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 82196260h case    0:*/		return 0x82196264;
		  /* 82196264h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82196264h case    1:*/		if ( regs.CR[0].eq ) { return 0x82196270;  }
		/* 82196264h case    1:*/		return 0x82196268;
		  /* 82196268h */ case    2:  		/* rlwinm. R10, R4, 0, 31, 31 */
		/* 82196268h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R4);
		/* 82196268h case    2:*/		return 0x8219626C;
		  /* 8219626Ch */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 8219626Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x82196258;  }
		/* 8219626Ch case    3:*/		return 0x82196270;
	}
	return 0x82196270;
} // Block from 82196260h-82196270h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82196270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196270);
		  /* 82196270h */ case    0:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 82196270h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 82196270h case    0:*/		return 0x82196274;
		  /* 82196274h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82196274h case    1:*/		if ( regs.CR[0].eq ) { return 0x82196284;  }
		/* 82196274h case    1:*/		return 0x82196278;
		  /* 82196278h */ case    2:  		/* rlwinm. R11, R4, 0, 31, 31 */
		/* 82196278h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R4);
		/* 82196278h case    2:*/		return 0x8219627C;
		  /* 8219627Ch */ case    3:  		/* li R3, 0 */
		/* 8219627Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219627Ch case    3:*/		return 0x82196280;
		  /* 82196280h */ case    4:  		/* bclr 4, CR0_EQ */
		/* 82196280h case    4:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82196280h case    4:*/		return 0x82196284;
	}
	return 0x82196284;
} // Block from 82196270h-82196284h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82196284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196284);
		  /* 82196284h */ case    0:  		/* li R3, 1 */
		/* 82196284h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82196284h case    0:*/		return 0x82196288;
		  /* 82196288h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82196288h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82196288h case    1:*/		return 0x8219628C;
	}
	return 0x8219628C;
} // Block from 82196284h-8219628Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219628Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219628C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219628C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219628C);
		  /* 8219628Ch */ case    0:  		/* nop */
		/* 8219628Ch case    0:*/		cpu::op::nop();
		/* 8219628Ch case    0:*/		return 0x82196290;
		  /* 82196290h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 82196290h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82196290h case    1:*/		return 0x82196294;
		  /* 82196294h */ case    2:  		/* rlwinm R9, R4, 0, 27, 30 */
		/* 82196294h case    2:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R9,regs.R4);
		/* 82196294h case    2:*/		return 0x82196298;
		  /* 82196298h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82196298h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82196298h case    3:*/		return 0x8219629C;
		  /* 8219629Ch */ case    4:  		/* cmplwi CR6, R11, 96 */
		/* 8219629Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 8219629Ch case    4:*/		return 0x821962A0;
		  /* 821962A0h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 821962A0h case    5:*/		if ( regs.CR[6].lt ) { return 0x821962B0;  }
		/* 821962A0h case    5:*/		return 0x821962A4;
		  /* 821962A4h */ case    6:  		/* cmplwi CR6, R11, 102 */
		/* 821962A4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 821962A4h case    6:*/		return 0x821962A8;
		  /* 821962A8h */ case    7:  		/* li R10, 1 */
		/* 821962A8h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821962A8h case    7:*/		return 0x821962AC;
		  /* 821962ACh */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 821962ACh case    8:*/		if ( !regs.CR[6].gt ) { return 0x821962B4;  }
		/* 821962ACh case    8:*/		return 0x821962B0;
	}
	return 0x821962B0;
} // Block from 8219628Ch-821962B0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821962B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821962B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821962B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821962B0);
		  /* 821962B0h */ case    0:  		/* li R10, 0 */
		/* 821962B0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821962B0h case    0:*/		return 0x821962B4;
	}
	return 0x821962B4;
} // Block from 821962B0h-821962B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821962B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821962B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821962B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821962B4);
		  /* 821962B4h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821962B4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821962B4h case    0:*/		return 0x821962B8;
		  /* 821962B8h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821962B8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821962CC;  }
		/* 821962B8h case    1:*/		return 0x821962BC;
		  /* 821962BCh */ case    2:  		/* rlwinm R11, R9, 0, 28, 26 */
		/* 821962BCh case    2:*/		cpu::op::rlwinm<0,0,28,26>(regs,&regs.R11,regs.R9);
		/* 821962BCh case    2:*/		return 0x821962C0;
		  /* 821962C0h */ case    3:  		/* cntlzw R11, R11 */
		/* 821962C0h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821962C0h case    3:*/		return 0x821962C4;
		  /* 821962C4h */ case    4:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 821962C4h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 821962C4h case    4:*/		return 0x821962C8;
		  /* 821962C8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821962C8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821962C8h case    5:*/		return 0x821962CC;
	}
	return 0x821962CC;
} // Block from 821962B4h-821962CCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821962CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821962CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821962CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821962CC);
		  /* 821962CCh */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 821962CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821962CCh case    0:*/		return 0x821962D0;
		  /* 821962D0h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 821962D0h case    1:*/		if ( regs.CR[6].lt ) { return 0x821962E0;  }
		/* 821962D0h case    1:*/		return 0x821962D4;
		  /* 821962D4h */ case    2:  		/* cmplwi CR6, R11, 82 */
		/* 821962D4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 821962D4h case    2:*/		return 0x821962D8;
		  /* 821962D8h */ case    3:  		/* li R11, 1 */
		/* 821962D8h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821962D8h case    3:*/		return 0x821962DC;
		  /* 821962DCh */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 821962DCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x821962E4;  }
		/* 821962DCh case    4:*/		return 0x821962E0;
	}
	return 0x821962E0;
} // Block from 821962CCh-821962E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821962E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821962E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821962E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821962E0);
		  /* 821962E0h */ case    0:  		/* li R11, 0 */
		/* 821962E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821962E0h case    0:*/		return 0x821962E4;
	}
	return 0x821962E4;
} // Block from 821962E0h-821962E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821962E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821962E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821962E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821962E4);
		  /* 821962E4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821962E4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821962E4h case    0:*/		return 0x821962E8;
		  /* 821962E8h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 821962E8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821962F4;  }
		/* 821962E8h case    1:*/		return 0x821962EC;
		  /* 821962ECh */ case    2:  		/* cntlzw R11, R9 */
		/* 821962ECh case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R9);
		/* 821962ECh case    2:*/		return 0x821962F0;
		  /* 821962F0h */ case    3:  		/* b -44 */
		/* 821962F0h case    3:*/		return 0x821962C4;
		/* 821962F0h case    3:*/		return 0x821962F4;
	}
	return 0x821962F4;
} // Block from 821962E4h-821962F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821962F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821962F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821962F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821962F4);
		  /* 821962F4h */ case    0:  		/* li R3, 1 */
		/* 821962F4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821962F4h case    0:*/		return 0x821962F8;
		  /* 821962F8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821962F8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821962F8h case    1:*/		return 0x821962FC;
	}
	return 0x821962FC;
} // Block from 821962F4h-821962FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821962FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821962FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821962FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821962FC);
		  /* 821962FCh */ case    0:  		/* nop */
		/* 821962FCh case    0:*/		cpu::op::nop();
		/* 821962FCh case    0:*/		return 0x82196300;
	}
	return 0x82196300;
} // Block from 821962FCh-82196300h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196300);
		  /* 82196300h */ case    0:  		/* mfspr R12, LR */
		/* 82196300h case    0:*/		regs.R12 = regs.LR;
		/* 82196300h case    0:*/		return 0x82196304;
		  /* 82196304h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82196304h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82196304h case    1:*/		return 0x82196308;
		  /* 82196308h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82196308h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82196308h case    2:*/		return 0x8219630C;
		  /* 8219630Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8219630Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219630Ch case    3:*/		return 0x82196310;
		  /* 82196310h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82196310h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82196310h case    4:*/		return 0x82196314;
		  /* 82196314h */ case    5:  		/* mr R30, R3 */
		/* 82196314h case    5:*/		regs.R30 = regs.R3;
		/* 82196314h case    5:*/		return 0x82196318;
		  /* 82196318h */ case    6:  		/* cmplwi CR6, R4, 31 */
		/* 82196318h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000001F);
		/* 82196318h case    6:*/		return 0x8219631C;
		  /* 8219631Ch */ case    7:  		/* bc 4, CR6_GT, 44 */
		/* 8219631Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x82196348;  }
		/* 8219631Ch case    7:*/		return 0x82196320;
		  /* 82196320h */ case    8:  		/* addi R11, R4, 32 */
		/* 82196320h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x20);
		/* 82196320h case    8:*/		return 0x82196324;
		  /* 82196324h */ case    9:  		/* mtspr CTR, R5 */
		/* 82196324h case    9:*/		regs.CTR = regs.R5;
		/* 82196324h case    9:*/		return 0x82196328;
		  /* 82196328h */ case   10:  		/* mr R3, R6 */
		/* 82196328h case   10:*/		regs.R3 = regs.R6;
		/* 82196328h case   10:*/		return 0x8219632C;
		  /* 8219632Ch */ case   11:  		/* rlwinm R31, R11, 27, 5, 31 */
		/* 8219632Ch case   11:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R31,regs.R11);
		/* 8219632Ch case   11:*/		return 0x82196330;
		  /* 82196330h */ case   12:  		/* addi R11, R31, 1 */
		/* 82196330h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 82196330h case   12:*/		return 0x82196334;
		  /* 82196334h */ case   13:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 82196334h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 82196334h case   13:*/		return 0x82196338;
		  /* 82196338h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 82196338h case   14:*/		if ( 1 ) { regs.LR = 0x8219633C; return (uint32)regs.CTR; }
		/* 82196338h case   14:*/		return 0x8219633C;
		  /* 8219633Ch */ case   15:  		/* stw R3, <#[R30]> */
		/* 8219633Ch case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 8219633Ch case   15:*/		return 0x82196340;
		  /* 82196340h */ case   16:  		/* stw R31, <#[R3]> */
		/* 82196340h case   16:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82196340h case   16:*/		return 0x82196344;
		  /* 82196344h */ case   17:  		/* b 12 */
		/* 82196344h case   17:*/		return 0x82196350;
		/* 82196344h case   17:*/		return 0x82196348;
	}
	return 0x82196348;
} // Block from 82196300h-82196348h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82196348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196348);
		  /* 82196348h */ case    0:  		/* li R11, 1 */
		/* 82196348h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82196348h case    0:*/		return 0x8219634C;
		  /* 8219634Ch */ case    1:  		/* stw R11, <#[R30]> */
		/* 8219634Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8219634Ch case    1:*/		return 0x82196350;
	}
	return 0x82196350;
} // Block from 82196348h-82196350h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82196350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196350);
		  /* 82196350h */ case    0:  		/* addi R1, R1, 112 */
		/* 82196350h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82196350h case    0:*/		return 0x82196354;
		  /* 82196354h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82196354h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82196354h case    1:*/		return 0x82196358;
		  /* 82196358h */ case    2:  		/* mtspr LR, R12 */
		/* 82196358h case    2:*/		regs.LR = regs.R12;
		/* 82196358h case    2:*/		return 0x8219635C;
		  /* 8219635Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8219635Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8219635Ch case    3:*/		return 0x82196360;
		  /* 82196360h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82196360h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82196360h case    4:*/		return 0x82196364;
		  /* 82196364h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82196364h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82196364h case    5:*/		return 0x82196368;
	}
	return 0x82196368;
} // Block from 82196350h-82196368h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82196368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196368);
		  /* 82196368h */ case    0:  		/* mfspr R12, LR */
		/* 82196368h case    0:*/		regs.R12 = regs.LR;
		/* 82196368h case    0:*/		return 0x8219636C;
		  /* 8219636Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219636Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219636Ch case    1:*/		return 0x82196370;
		  /* 82196370h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82196370h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82196370h case    2:*/		return 0x82196374;
		  /* 82196374h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82196374h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82196374h case    3:*/		return 0x82196378;
		  /* 82196378h */ case    4:  		/* mr R31, R3 */
		/* 82196378h case    4:*/		regs.R31 = regs.R3;
		/* 82196378h case    4:*/		return 0x8219637C;
		  /* 8219637Ch */ case    5:  		/* mr R3, R4 */
		/* 8219637Ch case    5:*/		regs.R3 = regs.R4;
		/* 8219637Ch case    5:*/		return 0x82196380;
		  /* 82196380h */ case    6:  		/* li R6, 0 */
		/* 82196380h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82196380h case    6:*/		return 0x82196384;
		  /* 82196384h */ case    7:  		/* li R4, 120 */
		/* 82196384h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x78);
		/* 82196384h case    7:*/		return 0x82196388;
		  /* 82196388h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 82196388h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82196388h case    8:*/		return 0x8219638C;
		  /* 8219638Ch */ case    9:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8219638Ch case    9:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8219638Ch case    9:*/		return 0x82196390;
		  /* 82196390h */ case   10:  		/* bl -204640 */
		/* 82196390h case   10:*/		regs.LR = 0x82196394; return 0x82164430;
		/* 82196390h case   10:*/		return 0x82196394;
		  /* 82196394h */ case   11:  		/* addi R11, R31, -4 */
		/* 82196394h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFC);
		/* 82196394h case   11:*/		return 0x82196398;
		  /* 82196398h */ case   12:  		/* add R3, R3, R11 */
		/* 82196398h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 82196398h case   12:*/		return 0x8219639C;
		  /* 8219639Ch */ case   13:  		/* addi R1, R1, 96 */
		/* 8219639Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8219639Ch case   13:*/		return 0x821963A0;
		  /* 821963A0h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 821963A0h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821963A0h case   14:*/		return 0x821963A4;
		  /* 821963A4h */ case   15:  		/* mtspr LR, R12 */
		/* 821963A4h case   15:*/		regs.LR = regs.R12;
		/* 821963A4h case   15:*/		return 0x821963A8;
		  /* 821963A8h */ case   16:  		/* ld R31, <#[R1 - 16]> */
		/* 821963A8h case   16:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821963A8h case   16:*/		return 0x821963AC;
		  /* 821963ACh */ case   17:  		/* bclr 20, CR0_LT */
		/* 821963ACh case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821963ACh case   17:*/		return 0x821963B0;
	}
	return 0x821963B0;
} // Block from 82196368h-821963B0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821963B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821963B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821963B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821963B0);
		  /* 821963B0h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 821963B0h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821963B0h case    0:*/		return 0x821963B4;
		  /* 821963B4h */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 821963B4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 821963B4h case    1:*/		return 0x821963B8;
		  /* 821963B8h */ case    2:  		/* li R6, 0 */
		/* 821963B8h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821963B8h case    2:*/		return 0x821963BC;
		  /* 821963BCh */ case    3:  		/* li R5, 1 */
		/* 821963BCh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821963BCh case    3:*/		return 0x821963C0;
		  /* 821963C0h */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 821963C0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821963C0h case    4:*/		return 0x821963C4;
		  /* 821963C4h */ case    5:  		/* bc 12, CR6_EQ, 108 */
		/* 821963C4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82196430;  }
		/* 821963C4h case    5:*/		return 0x821963C8;
		  /* 821963C8h */ case    6:  		/* lwz R7, <#[R4]> */
		/* 821963C8h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000000) );
		/* 821963C8h case    6:*/		return 0x821963CC;
		  /* 821963CCh */ case    7:  		/* rlwinm. R11, R7, 0, 1, 1 */
		/* 821963CCh case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R7);
		/* 821963CCh case    7:*/		return 0x821963D0;
		  /* 821963D0h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821963D0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821963E0;  }
		/* 821963D0h case    8:*/		return 0x821963D4;
		  /* 821963D4h */ case    9:  		/* rlwinm. R11, R7, 0, 4, 6 */
		/* 821963D4h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R7);
		/* 821963D4h case    9:*/		return 0x821963D8;
		  /* 821963D8h */ case   10:  		/* li R11, 0 */
		/* 821963D8h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821963D8h case   10:*/		return 0x821963DC;
		  /* 821963DCh */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 821963DCh case   11:*/		if ( regs.CR[0].eq ) { return 0x821963E4;  }
		/* 821963DCh case   11:*/		return 0x821963E0;
	}
	return 0x821963E0;
} // Block from 821963B0h-821963E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821963E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821963E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821963E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821963E0);
		  /* 821963E0h */ case    0:  		/* mr R11, R5 */
		/* 821963E0h case    0:*/		regs.R11 = regs.R5;
		/* 821963E0h case    0:*/		return 0x821963E4;
	}
	return 0x821963E4;
} // Block from 821963E0h-821963E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821963E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821963E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821963E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821963E4);
		  /* 821963E4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821963E4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821963E4h case    0:*/		return 0x821963E8;
		  /* 821963E8h */ case    1:  		/* bc 12, CR0_EQ, 64 */
		/* 821963E8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82196428;  }
		/* 821963E8h case    1:*/		return 0x821963EC;
		  /* 821963ECh */ case    2:  		/* rlwinm. R8, R7, 7, 29, 31 */
		/* 821963ECh case    2:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R8,regs.R7);
		/* 821963ECh case    2:*/		return 0x821963F0;
		  /* 821963F0h */ case    3:  		/* li R9, 0 */
		/* 821963F0h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821963F0h case    3:*/		return 0x821963F4;
		  /* 821963F4h */ case    4:  		/* li R11, 0 */
		/* 821963F4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821963F4h case    4:*/		return 0x821963F8;
		  /* 821963F8h */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 821963F8h case    5:*/		if ( regs.CR[0].eq ) { return 0x82196424;  }
		/* 821963F8h case    5:*/		return 0x821963FC;
		  /* 821963FCh */ case    6:  		/* li R10, 0 */
		/* 821963FCh case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821963FCh case    6:*/		return 0x82196400;
		  /* 82196400h */ case    7:  		/* rlwinm R31, R7, 27, 24, 31 */
		/* 82196400h case    7:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R31,regs.R7);
		/* 82196400h case    7:*/		return 0x82196404;
		  /* 82196404h */ case    8:  		/* addi R11, R11, 1 */
		/* 82196404h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82196404h case    8:*/		return 0x82196408;
		  /* 82196408h */ case    9:  		/* srw R31, R31, R10 */
		/* 82196408h case    9:*/		cpu::op::srw<0>(regs,&regs.R31,regs.R31,regs.R10);
		/* 82196408h case    9:*/		return 0x8219640C;
		  /* 8219640Ch */ case   10:  		/* rlwinm R31, R31, 0, 30, 31 */
		/* 8219640Ch case   10:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R31,regs.R31);
		/* 8219640Ch case   10:*/		return 0x82196410;
		  /* 82196410h */ case   11:  		/* addi R10, R10, 2 */
		/* 82196410h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82196410h case   11:*/		return 0x82196414;
		  /* 82196414h */ case   12:  		/* slw R31, R5, R31 */
		/* 82196414h case   12:*/		cpu::op::slw<0>(regs,&regs.R31,regs.R5,regs.R31);
		/* 82196414h case   12:*/		return 0x82196418;
		  /* 82196418h */ case   13:  		/* or R9, R31, R9 */
		/* 82196418h case   13:*/		cpu::op::or<0>(regs,&regs.R9,regs.R31,regs.R9);
		/* 82196418h case   13:*/		return 0x8219641C;
		  /* 8219641Ch */ case   14:  		/* cmplw CR6, R11, R8 */
		/* 8219641Ch case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8219641Ch case   14:*/		return 0x82196420;
		  /* 82196420h */ case   15:  		/* bc 12, CR6_LT, -32 */
		/* 82196420h case   15:*/		if ( regs.CR[6].lt ) { return 0x82196400;  }
		/* 82196420h case   15:*/		return 0x82196424;
	}
	return 0x82196424;
} // Block from 821963E4h-82196424h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82196424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196424);
		  /* 82196424h */ case    0:  		/* or R6, R9, R6 */
		/* 82196424h case    0:*/		cpu::op::or<0>(regs,&regs.R6,regs.R9,regs.R6);
		/* 82196424h case    0:*/		return 0x82196428;
	}
	return 0x82196428;
} // Block from 82196424h-82196428h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196428);
		  /* 82196428h */ case    0:  		/* lwz R4, <#[R4 + 8]> */
		/* 82196428h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000008) );
		/* 82196428h case    0:*/		return 0x8219642C;
		  /* 8219642Ch */ case    1:  		/* b -108 */
		/* 8219642Ch case    1:*/		return 0x821963C0;
		/* 8219642Ch case    1:*/		return 0x82196430;
	}
	return 0x82196430;
} // Block from 82196428h-82196430h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82196430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196430);
		  /* 82196430h */ case    0:  		/* li R11, 0 */
		/* 82196430h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82196430h case    0:*/		return 0x82196434;
		  /* 82196434h */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 82196434h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82196434h case    1:*/		return 0x82196438;
		  /* 82196438h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82196438h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219644C;  }
		/* 82196438h case    2:*/		return 0x8219643C;
		  /* 8219643Ch */ case    3:  		/* cntlzw R11, R6 */
		/* 8219643Ch case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R6);
		/* 8219643Ch case    3:*/		return 0x82196440;
		  /* 82196440h */ case    4:  		/* subfic R11, R11, 32 */
		/* 82196440h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82196440h case    4:*/		return 0x82196444;
		  /* 82196444h */ case    5:  		/* slw R11, R5, R11 */
		/* 82196444h case    5:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 82196444h case    5:*/		return 0x82196448;
		  /* 82196448h */ case    6:  		/* addi R11, R11, -1 */
		/* 82196448h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82196448h case    6:*/		return 0x8219644C;
	}
	return 0x8219644C;
} // Block from 82196430h-8219644Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219644Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219644C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219644C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219644C);
		  /* 8219644Ch */ case    0:  		/* lis R10, -28311 */
		/* 8219644Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF9169);
		/* 8219644Ch case    0:*/		return 0x82196450;
		  /* 82196450h */ case    1:  		/* lwz R9, <#[R3 + 8]> */
		/* 82196450h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 82196450h case    1:*/		return 0x82196454;
		  /* 82196454h */ case    2:  		/* lis R8, 0 */
		/* 82196454h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0x0);
		/* 82196454h case    2:*/		return 0x82196458;
		  /* 82196458h */ case    3:  		/* ori R10, R10, 5192 */
		/* 82196458h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1448);
		/* 82196458h case    3:*/		return 0x8219645C;
		  /* 8219645Ch */ case    4:  		/* ori R8, R8, 36262 */
		/* 8219645Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x8DA6);
		/* 8219645Ch case    4:*/		return 0x82196460;
		  /* 82196460h */ case    5:  		/* rldicl R7, R11, 0, 32 */
		/* 82196460h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R11);
		/* 82196460h case    5:*/		return 0x82196464;
		  /* 82196464h */ case    6:  		/* rldimi R10, R8, 32, 0 */
		/* 82196464h case    6:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R10,regs.R8);
		/* 82196464h case    6:*/		return 0x82196468;
		  /* 82196468h */ case    7:  		/* srd R10, R10, R7 */
		/* 82196468h case    7:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82196468h case    7:*/		return 0x8219646C;
		  /* 8219646Ch */ case    8:  		/* srd R10, R10, R7 */
		/* 8219646Ch case    8:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 8219646Ch case    8:*/		return 0x82196470;
		  /* 82196470h */ case    9:  		/* srd R10, R10, R7 */
		/* 82196470h case    9:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82196470h case    9:*/		return 0x82196474;
		  /* 82196474h */ case   10:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 82196474h case   10:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 82196474h case   10:*/		return 0x82196478;
		  /* 82196478h */ case   11:  		/* rlwimi R11, R10, 13, 16, 18 */
		/* 82196478h case   11:*/		cpu::op::rlwimi<0,13,16,18>(regs,&regs.R11,regs.R10);
		/* 82196478h case   11:*/		return 0x8219647C;
		  /* 8219647Ch */ case   12:  		/* rlwimi R9, R11, 1, 27, 30 */
		/* 8219647Ch case   12:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R9,regs.R11);
		/* 8219647Ch case   12:*/		return 0x82196480;
		  /* 82196480h */ case   13:  		/* rlwimi R9, R11, 1, 15, 17 */
		/* 82196480h case   13:*/		cpu::op::rlwimi<0,1,15,17>(regs,&regs.R9,regs.R11);
		/* 82196480h case   13:*/		return 0x82196484;
		  /* 82196484h */ case   14:  		/* stw R9, <#[R3 + 8]> */
		/* 82196484h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 82196484h case   14:*/		return 0x82196488;
		  /* 82196488h */ case   15:  		/* ld R31, <#[R1 - 8]> */
		/* 82196488h case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82196488h case   15:*/		return 0x8219648C;
		  /* 8219648Ch */ case   16:  		/* bclr 20, CR0_LT */
		/* 8219648Ch case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219648Ch case   16:*/		return 0x82196490;
	}
	return 0x82196490;
} // Block from 8219644Ch-82196490h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82196490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196490);
		  /* 82196490h */ case    0:  		/* mfspr R12, LR */
		/* 82196490h case    0:*/		regs.R12 = regs.LR;
		/* 82196490h case    0:*/		return 0x82196494;
		  /* 82196494h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82196494h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82196494h case    1:*/		return 0x82196498;
		  /* 82196498h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82196498h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82196498h case    2:*/		return 0x8219649C;
		  /* 8219649Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8219649Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219649Ch case    3:*/		return 0x821964A0;
		  /* 821964A0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821964A0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821964A0h case    4:*/		return 0x821964A4;
		  /* 821964A4h */ case    5:  		/* lwz R11, <#[R4 + 8]> */
		/* 821964A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821964A4h case    5:*/		return 0x821964A8;
		  /* 821964A8h */ case    6:  		/* mr R31, R3 */
		/* 821964A8h case    6:*/		regs.R31 = regs.R3;
		/* 821964A8h case    6:*/		return 0x821964AC;
		  /* 821964ACh */ case    7:  		/* mr R30, R5 */
		/* 821964ACh case    7:*/		regs.R30 = regs.R5;
		/* 821964ACh case    7:*/		return 0x821964B0;
		  /* 821964B0h */ case    8:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821964B0h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821964B0h case    8:*/		return 0x821964B4;
		  /* 821964B4h */ case    9:  		/* cmplwi CR6, R11, 125 */
		/* 821964B4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821964B4h case    9:*/		return 0x821964B8;
		  /* 821964B8h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 821964B8h case   10:*/		if ( regs.CR[6].eq ) { return 0x821964C8;  }
		/* 821964B8h case   10:*/		return 0x821964BC;
		  /* 821964BCh */ case   11:  		/* cmplwi CR6, R11, 124 */
		/* 821964BCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821964BCh case   11:*/		return 0x821964C0;
		  /* 821964C0h */ case   12:  		/* li R11, 0 */
		/* 821964C0h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821964C0h case   12:*/		return 0x821964C4;
		  /* 821964C4h */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 821964C4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821964CC;  }
		/* 821964C4h case   13:*/		return 0x821964C8;
	}
	return 0x821964C8;
} // Block from 82196490h-821964C8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821964C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821964C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821964C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821964C8);
		  /* 821964C8h */ case    0:  		/* li R11, 1 */
		/* 821964C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821964C8h case    0:*/		return 0x821964CC;
	}
	return 0x821964CC;
} // Block from 821964C8h-821964CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821964CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821964CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821964CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821964CC);
		  /* 821964CCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821964CCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821964CCh case    0:*/		return 0x821964D0;
		  /* 821964D0h */ case    1:  		/* bc 12, CR0_EQ, 144 */
		/* 821964D0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82196560;  }
		/* 821964D0h case    1:*/		return 0x821964D4;
		  /* 821964D4h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821964D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821964D4h case    2:*/		return 0x821964D8;
		  /* 821964D8h */ case    3:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 821964D8h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 821964D8h case    3:*/		return 0x821964DC;
		  /* 821964DCh */ case    4:  		/* cmplwi CR6, R10, 96 */
		/* 821964DCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000060);
		/* 821964DCh case    4:*/		return 0x821964E0;
		  /* 821964E0h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 821964E0h case    5:*/		if ( regs.CR[6].lt ) { return 0x821964F0;  }
		/* 821964E0h case    5:*/		return 0x821964E4;
		  /* 821964E4h */ case    6:  		/* cmplwi CR6, R10, 102 */
		/* 821964E4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 821964E4h case    6:*/		return 0x821964E8;
		  /* 821964E8h */ case    7:  		/* li R11, 1 */
		/* 821964E8h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821964E8h case    7:*/		return 0x821964EC;
		  /* 821964ECh */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 821964ECh case    8:*/		if ( !regs.CR[6].gt ) { return 0x821964F4;  }
		/* 821964ECh case    8:*/		return 0x821964F0;
	}
	return 0x821964F0;
} // Block from 821964CCh-821964F0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821964F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821964F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821964F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821964F0);
		  /* 821964F0h */ case    0:  		/* li R11, 0 */
		/* 821964F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821964F0h case    0:*/		return 0x821964F4;
	}
	return 0x821964F4;
} // Block from 821964F0h-821964F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821964F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821964F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821964F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821964F4);
		  /* 821964F4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821964F4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821964F4h case    0:*/		return 0x821964F8;
		  /* 821964F8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821964F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82196504;  }
		/* 821964F8h case    1:*/		return 0x821964FC;
		  /* 821964FCh */ case    2:  		/* li R3, 0 */
		/* 821964FCh case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821964FCh case    2:*/		return 0x82196500;
		  /* 82196500h */ case    3:  		/* b 100 */
		/* 82196500h case    3:*/		return 0x82196564;
		/* 82196500h case    3:*/		return 0x82196504;
	}
	return 0x82196504;
} // Block from 821964F4h-82196504h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82196504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196504);
		  /* 82196504h */ case    0:  		/* cmplwi CR6, R10, 117 */
		/* 82196504h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000075);
		/* 82196504h case    0:*/		return 0x82196508;
		  /* 82196508h */ case    1:  		/* bc 4, CR6_EQ, 88 */
		/* 82196508h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82196560;  }
		/* 82196508h case    1:*/		return 0x8219650C;
		  /* 8219650Ch */ case    2:  		/* li R6, 0 */
		/* 8219650Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8219650Ch case    2:*/		return 0x82196510;
		  /* 82196510h */ case    3:  		/* li R5, 0 */
		/* 82196510h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82196510h case    3:*/		return 0x82196514;
		  /* 82196514h */ case    4:  		/* li R4, 117 */
		/* 82196514h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 82196514h case    4:*/		return 0x82196518;
		  /* 82196518h */ case    5:  		/* mr R3, R30 */
		/* 82196518h case    5:*/		regs.R3 = regs.R30;
		/* 82196518h case    5:*/		return 0x8219651C;
		  /* 8219651Ch */ case    6:  		/* bl -205036 */
		/* 8219651Ch case    6:*/		regs.LR = 0x82196520; return 0x82164430;
		/* 8219651Ch case    6:*/		return 0x82196520;
		  /* 82196520h */ case    7:  		/* addi R11, R31, -16 */
		/* 82196520h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 82196520h case    7:*/		return 0x82196524;
		  /* 82196524h */ case    8:  		/* lwzx R11, <#[R3 + R11]> */
		/* 82196524h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 82196524h case    8:*/		return 0x82196528;
		  /* 82196528h */ case    9:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 82196528h case    9:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 82196528h case    9:*/		return 0x8219652C;
		  /* 8219652Ch */ case   10:  		/* cmplwi CR6, R11, 4 */
		/* 8219652Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8219652Ch case   10:*/		return 0x82196530;
		  /* 82196530h */ case   11:  		/* bc 12, CR6_LT, 16 */
		/* 82196530h case   11:*/		if ( regs.CR[6].lt ) { return 0x82196540;  }
		/* 82196530h case   11:*/		return 0x82196534;
		  /* 82196534h */ case   12:  		/* cmplwi CR6, R11, 6 */
		/* 82196534h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 82196534h case   12:*/		return 0x82196538;
		  /* 82196538h */ case   13:  		/* li R11, 1 */
		/* 82196538h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82196538h case   13:*/		return 0x8219653C;
		  /* 8219653Ch */ case   14:  		/* bc 4, CR6_GT, 8 */
		/* 8219653Ch case   14:*/		if ( !regs.CR[6].gt ) { return 0x82196544;  }
		/* 8219653Ch case   14:*/		return 0x82196540;
	}
	return 0x82196540;
} // Block from 82196504h-82196540h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82196540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196540);
		  /* 82196540h */ case    0:  		/* li R11, 0 */
		/* 82196540h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82196540h case    0:*/		return 0x82196544;
	}
	return 0x82196544;
} // Block from 82196540h-82196544h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196544);
		  /* 82196544h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82196544h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82196544h case    0:*/		return 0x82196548;
		  /* 82196548h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82196548h case    1:*/		if ( regs.CR[0].eq ) { return 0x82196560;  }
		/* 82196548h case    1:*/		return 0x8219654C;
		  /* 8219654Ch */ case    2:  		/* lwz R11, <#[R30 + 52]> */
		/* 8219654Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000034) );
		/* 8219654Ch case    2:*/		return 0x82196550;
		  /* 82196550h */ case    3:  		/* li R3, 0 */
		/* 82196550h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82196550h case    3:*/		return 0x82196554;
		  /* 82196554h */ case    4:  		/* nor R11, R11, R11 */
		/* 82196554h case    4:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82196554h case    4:*/		return 0x82196558;
		  /* 82196558h */ case    5:  		/* rlwinm. R11, R11, 25, 31, 31 */
		/* 82196558h case    5:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R11,regs.R11);
		/* 82196558h case    5:*/		return 0x8219655C;
		  /* 8219655Ch */ case    6:  		/* bc 4, CR0_EQ, 8 */
		/* 8219655Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x82196564;  }
		/* 8219655Ch case    6:*/		return 0x82196560;
	}
	return 0x82196560;
} // Block from 82196544h-82196560h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82196560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196560);
		  /* 82196560h */ case    0:  		/* li R3, 1 */
		/* 82196560h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82196560h case    0:*/		return 0x82196564;
	}
	return 0x82196564;
} // Block from 82196560h-82196564h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196564);
		  /* 82196564h */ case    0:  		/* addi R1, R1, 112 */
		/* 82196564h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82196564h case    0:*/		return 0x82196568;
		  /* 82196568h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82196568h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82196568h case    1:*/		return 0x8219656C;
		  /* 8219656Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8219656Ch case    2:*/		regs.LR = regs.R12;
		/* 8219656Ch case    2:*/		return 0x82196570;
		  /* 82196570h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82196570h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82196570h case    3:*/		return 0x82196574;
		  /* 82196574h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82196574h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82196574h case    4:*/		return 0x82196578;
		  /* 82196578h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82196578h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82196578h case    5:*/		return 0x8219657C;
	}
	return 0x8219657C;
} // Block from 82196564h-8219657Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219657Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219657C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219657C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219657C);
		  /* 8219657Ch */ case    0:  		/* nop */
		/* 8219657Ch case    0:*/		cpu::op::nop();
		/* 8219657Ch case    0:*/		return 0x82196580;
	}
	return 0x82196580;
} // Block from 8219657Ch-82196580h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196580);
		  /* 82196580h */ case    0:  		/* mfspr R12, LR */
		/* 82196580h case    0:*/		regs.R12 = regs.LR;
		/* 82196580h case    0:*/		return 0x82196584;
		  /* 82196584h */ case    1:  		/* bl -1069900 */
		/* 82196584h case    1:*/		regs.LR = 0x82196588; return 0x82091238;
		/* 82196584h case    1:*/		return 0x82196588;
		  /* 82196588h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 82196588h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 82196588h case    2:*/		return 0x8219658C;
		  /* 8219658Ch */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219658Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219658Ch case    3:*/		return 0x82196590;
		  /* 82196590h */ case    4:  		/* mr R27, R3 */
		/* 82196590h case    4:*/		regs.R27 = regs.R3;
		/* 82196590h case    4:*/		return 0x82196594;
		  /* 82196594h */ case    5:  		/* mr R21, R4 */
		/* 82196594h case    5:*/		regs.R21 = regs.R4;
		/* 82196594h case    5:*/		return 0x82196598;
		  /* 82196598h */ case    6:  		/* stw R7, <#[R1 + 260]> */
		/* 82196598h case    6:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000104) );
		/* 82196598h case    6:*/		return 0x8219659C;
		  /* 8219659Ch */ case    7:  		/* mr R30, R5 */
		/* 8219659Ch case    7:*/		regs.R30 = regs.R5;
		/* 8219659Ch case    7:*/		return 0x821965A0;
		  /* 821965A0h */ case    8:  		/* mr R31, R6 */
		/* 821965A0h case    8:*/		regs.R31 = regs.R6;
		/* 821965A0h case    8:*/		return 0x821965A4;
		  /* 821965A4h */ case    9:  		/* mr R29, R7 */
		/* 821965A4h case    9:*/		regs.R29 = regs.R7;
		/* 821965A4h case    9:*/		return 0x821965A8;
		  /* 821965A8h */ case   10:  		/* mr R20, R8 */
		/* 821965A8h case   10:*/		regs.R20 = regs.R8;
		/* 821965A8h case   10:*/		return 0x821965AC;
		  /* 821965ACh */ case   11:  		/* rlwinm. R10, R11, 27, 31, 31 */
		/* 821965ACh case   11:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R10,regs.R11);
		/* 821965ACh case   11:*/		return 0x821965B0;
		  /* 821965B0h */ case   12:  		/* bc 4, CR0_EQ, 1512 */
		/* 821965B0h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82196B98;  }
		/* 821965B0h case   12:*/		return 0x821965B4;
		  /* 821965B4h */ case   13:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 821965B4h case   13:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 821965B4h case   13:*/		return 0x821965B8;
		  /* 821965B8h */ case   14:  		/* bc 4, CR0_EQ, 1504 */
		/* 821965B8h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82196B98;  }
		/* 821965B8h case   14:*/		return 0x821965BC;
		  /* 821965BCh */ case   15:  		/* lwz R26, <#[R6]> */
		/* 821965BCh case   15:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R6 + 0x00000000) );
		/* 821965BCh case   15:*/		return 0x821965C0;
		  /* 821965C0h */ case   16:  		/* andi. R11, R26, 27 */
		/* 821965C0h case   16:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R26,0x1B);
		/* 821965C0h case   16:*/		return 0x821965C4;
		  /* 821965C4h */ case   17:  		/* cmplwi CR0, R11, 0 */
		/* 821965C4h case   17:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821965C4h case   17:*/		return 0x821965C8;
		  /* 821965C8h */ case   18:  		/* bc 4, CR0_EQ, 1488 */
		/* 821965C8h case   18:*/		if ( !regs.CR[0].eq ) { return 0x82196B98;  }
		/* 821965C8h case   18:*/		return 0x821965CC;
		  /* 821965CCh */ case   19:  		/* lwz R11, <#[R7 + 12]> */
		/* 821965CCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000000C) );
		/* 821965CCh case   19:*/		return 0x821965D0;
		  /* 821965D0h */ case   20:  		/* cmplw CR6, R11, R5 */
		/* 821965D0h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 821965D0h case   20:*/		return 0x821965D4;
		  /* 821965D4h */ case   21:  		/* bc 12, CR6_EQ, 1476 */
		/* 821965D4h case   21:*/		if ( regs.CR[6].eq ) { return 0x82196B98;  }
		/* 821965D4h case   21:*/		return 0x821965D8;
		  /* 821965D8h */ case   22:  		/* lwz R11, <#[R5 + 8]> */
		/* 821965D8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 821965D8h case   22:*/		return 0x821965DC;
		  /* 821965DCh */ case   23:  		/* mr R23, R4 */
		/* 821965DCh case   23:*/		regs.R23 = regs.R4;
		/* 821965DCh case   23:*/		return 0x821965E0;
		  /* 821965E0h */ case   24:  		/* li R22, 1 */
		/* 821965E0h case   24:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 821965E0h case   24:*/		return 0x821965E4;
		  /* 821965E4h */ case   25:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821965E4h case   25:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821965E4h case   25:*/		return 0x821965E8;
		  /* 821965E8h */ case   26:  		/* cmplwi CR6, R11, 2 */
		/* 821965E8h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 821965E8h case   26:*/		return 0x821965EC;
		  /* 821965ECh */ case   27:  		/* bc 4, CR6_EQ, 272 */
		/* 821965ECh case   27:*/		if ( !regs.CR[6].eq ) { return 0x821966FC;  }
		/* 821965ECh case   27:*/		return 0x821965F0;
		  /* 821965F0h */ case   28:  		/* lwz R4, <#[R5 + 44]> */
		/* 821965F0h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000002C) );
		/* 821965F0h case   28:*/		return 0x821965F4;
		  /* 821965F4h */ case   29:  		/* lwz R5, <#[R4 + 12]> */
		/* 821965F4h case   29:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x0000000C) );
		/* 821965F4h case   29:*/		return 0x821965F8;
		  /* 821965F8h */ case   30:  		/* bl -152840 */
		/* 821965F8h case   30:*/		regs.LR = 0x821965FC; return 0x821710F0;
		/* 821965F8h case   30:*/		return 0x821965FC;
		  /* 821965FCh */ case   31:  		/* mr R11, R3 */
		/* 821965FCh case   31:*/		regs.R11 = regs.R3;
		/* 821965FCh case   31:*/		return 0x82196600;
		  /* 82196600h */ case   32:  		/* lwz R10, <#[R31]> */
		/* 82196600h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82196600h case   32:*/		return 0x82196604;
		  /* 82196604h */ case   33:  		/* mr R3, R27 */
		/* 82196604h case   33:*/		regs.R3 = regs.R27;
		/* 82196604h case   33:*/		return 0x82196608;
		  /* 82196608h */ case   34:  		/* stw R11, <#[R1 + 80]> */
		/* 82196608h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82196608h case   34:*/		return 0x8219660C;
		  /* 8219660Ch */ case   35:  		/* lwz R9, <#[R11]> */
		/* 8219660Ch case   35:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8219660Ch case   35:*/		return 0x82196610;
		  /* 82196610h */ case   36:  		/* rlwimi R10, R9, 0, 7, 3 */
		/* 82196610h case   36:*/		cpu::op::rlwimi<0,0,7,3>(regs,&regs.R10,regs.R9);
		/* 82196610h case   36:*/		return 0x82196614;
		  /* 82196614h */ case   37:  		/* stw R10, <#[R11]> */
		/* 82196614h case   37:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82196614h case   37:*/		return 0x82196618;
		  /* 82196618h */ case   38:  		/* lwz R11, <#[R1 + 80]> */
		/* 82196618h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82196618h case   38:*/		return 0x8219661C;
		  /* 8219661Ch */ case   39:  		/* lwz R10, <#[R31]> */
		/* 8219661Ch case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8219661Ch case   39:*/		return 0x82196620;
		  /* 82196620h */ case   40:  		/* rlwinm R10, R10, 27, 24, 31 */
		/* 82196620h case   40:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R10);
		/* 82196620h case   40:*/		return 0x82196624;
		  /* 82196624h */ case   41:  		/* lwz R9, <#[R11]> */
		/* 82196624h case   41:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82196624h case   41:*/		return 0x82196628;
		  /* 82196628h */ case   42:  		/* rlwinm R7, R10, 27, 29, 30 */
		/* 82196628h case   42:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R7,regs.R10);
		/* 82196628h case   42:*/		return 0x8219662C;
		  /* 8219662Ch */ case   43:  		/* rlwinm R6, R10, 29, 29, 30 */
		/* 8219662Ch case   43:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R6,regs.R10);
		/* 8219662Ch case   43:*/		return 0x82196630;
		  /* 82196630h */ case   44:  		/* rlwinm R8, R9, 27, 24, 31 */
		/* 82196630h case   44:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R9);
		/* 82196630h case   44:*/		return 0x82196634;
		  /* 82196634h */ case   45:  		/* srw R7, R8, R7 */
		/* 82196634h case   45:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R8,regs.R7);
		/* 82196634h case   45:*/		return 0x82196638;
		  /* 82196638h */ case   46:  		/* srw R6, R8, R6 */
		/* 82196638h case   46:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R8,regs.R6);
		/* 82196638h case   46:*/		return 0x8219663C;
		  /* 8219663Ch */ case   47:  		/* rlwinm R5, R10, 31, 29, 30 */
		/* 8219663Ch case   47:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R5,regs.R10);
		/* 8219663Ch case   47:*/		return 0x82196640;
		  /* 82196640h */ case   48:  		/* rlwimi R6, R7, 2, 28, 29 */
		/* 82196640h case   48:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R6,regs.R7);
		/* 82196640h case   48:*/		return 0x82196644;
		  /* 82196644h */ case   49:  		/* rlwinm R10, R10, 1, 29, 30 */
		/* 82196644h case   49:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R10,regs.R10);
		/* 82196644h case   49:*/		return 0x82196648;
		  /* 82196648h */ case   50:  		/* srw R7, R8, R5 */
		/* 82196648h case   50:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R8,regs.R5);
		/* 82196648h case   50:*/		return 0x8219664C;
		  /* 8219664Ch */ case   51:  		/* rlwinm R6, R6, 0, 28, 31 */
		/* 8219664Ch case   51:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R6,regs.R6);
		/* 8219664Ch case   51:*/		return 0x82196650;
		  /* 82196650h */ case   52:  		/* srw R10, R8, R10 */
		/* 82196650h case   52:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82196650h case   52:*/		return 0x82196654;
		  /* 82196654h */ case   53:  		/* rlwimi R7, R6, 2, 0, 29 */
		/* 82196654h case   53:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R7,regs.R6);
		/* 82196654h case   53:*/		return 0x82196658;
		  /* 82196658h */ case   54:  		/* rlwinm R9, R9, 0, 27, 18 */
		/* 82196658h case   54:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R9,regs.R9);
		/* 82196658h case   54:*/		return 0x8219665C;
		  /* 8219665Ch */ case   55:  		/* rlwimi R10, R7, 2, 0, 29 */
		/* 8219665Ch case   55:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 8219665Ch case   55:*/		return 0x82196660;
		  /* 82196660h */ case   56:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 82196660h case   56:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 82196660h case   56:*/		return 0x82196664;
		  /* 82196664h */ case   57:  		/* or R10, R10, R9 */
		/* 82196664h case   57:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82196664h case   57:*/		return 0x82196668;
		  /* 82196668h */ case   58:  		/* stw R10, <#[R11]> */
		/* 82196668h case   58:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82196668h case   58:*/		return 0x8219666C;
		  /* 8219666Ch */ case   59:  		/* lwz R4, <#[R30 + 48]> */
		/* 8219666Ch case   59:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000030) );
		/* 8219666Ch case   59:*/		return 0x82196670;
		  /* 82196670h */ case   60:  		/* lwz R5, <#[R4 + 12]> */
		/* 82196670h case   60:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x0000000C) );
		/* 82196670h case   60:*/		return 0x82196674;
		  /* 82196674h */ case   61:  		/* bl -152964 */
		/* 82196674h case   61:*/		regs.LR = 0x82196678; return 0x821710F0;
		/* 82196674h case   61:*/		return 0x82196678;
		  /* 82196678h */ case   62:  		/* lwz R11, <#[R31]> */
		/* 82196678h case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82196678h case   62:*/		return 0x8219667C;
		  /* 8219667Ch */ case   63:  		/* stw R3, <#[R1 + 84]> */
		/* 8219667Ch case   63:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8219667Ch case   63:*/		return 0x82196680;
		  /* 82196680h */ case   64:  		/* lwz R10, <#[R3]> */
		/* 82196680h case   64:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82196680h case   64:*/		return 0x82196684;
		  /* 82196684h */ case   65:  		/* rlwimi R11, R10, 0, 7, 3 */
		/* 82196684h case   65:*/		cpu::op::rlwimi<0,0,7,3>(regs,&regs.R11,regs.R10);
		/* 82196684h case   65:*/		return 0x82196688;
		  /* 82196688h */ case   66:  		/* stw R11, <#[R3]> */
		/* 82196688h case   66:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82196688h case   66:*/		return 0x8219668C;
		  /* 8219668Ch */ case   67:  		/* lwz R11, <#[R1 + 84]> */
		/* 8219668Ch case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8219668Ch case   67:*/		return 0x82196690;
		  /* 82196690h */ case   68:  		/* lwz R10, <#[R31]> */
		/* 82196690h case   68:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82196690h case   68:*/		return 0x82196694;
		  /* 82196694h */ case   69:  		/* rlwinm R10, R10, 27, 24, 31 */
		/* 82196694h case   69:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R10);
		/* 82196694h case   69:*/		return 0x82196698;
		  /* 82196698h */ case   70:  		/* lwz R9, <#[R11]> */
		/* 82196698h case   70:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82196698h case   70:*/		return 0x8219669C;
		  /* 8219669Ch */ case   71:  		/* rlwinm R7, R10, 27, 29, 30 */
		/* 8219669Ch case   71:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R7,regs.R10);
		/* 8219669Ch case   71:*/		return 0x821966A0;
		  /* 821966A0h */ case   72:  		/* rlwinm R6, R10, 29, 29, 30 */
		/* 821966A0h case   72:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R6,regs.R10);
		/* 821966A0h case   72:*/		return 0x821966A4;
		  /* 821966A4h */ case   73:  		/* rlwinm R8, R9, 27, 24, 31 */
		/* 821966A4h case   73:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R9);
		/* 821966A4h case   73:*/		return 0x821966A8;
		  /* 821966A8h */ case   74:  		/* srw R7, R8, R7 */
		/* 821966A8h case   74:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R8,regs.R7);
		/* 821966A8h case   74:*/		return 0x821966AC;
		  /* 821966ACh */ case   75:  		/* srw R6, R8, R6 */
		/* 821966ACh case   75:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R8,regs.R6);
		/* 821966ACh case   75:*/		return 0x821966B0;
		  /* 821966B0h */ case   76:  		/* rlwinm R5, R10, 31, 29, 30 */
		/* 821966B0h case   76:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R5,regs.R10);
		/* 821966B0h case   76:*/		return 0x821966B4;
		  /* 821966B4h */ case   77:  		/* rlwimi R6, R7, 2, 28, 29 */
		/* 821966B4h case   77:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R6,regs.R7);
		/* 821966B4h case   77:*/		return 0x821966B8;
		  /* 821966B8h */ case   78:  		/* rlwinm R10, R10, 1, 29, 30 */
		/* 821966B8h case   78:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R10,regs.R10);
		/* 821966B8h case   78:*/		return 0x821966BC;
		  /* 821966BCh */ case   79:  		/* srw R7, R8, R5 */
		/* 821966BCh case   79:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R8,regs.R5);
		/* 821966BCh case   79:*/		return 0x821966C0;
		  /* 821966C0h */ case   80:  		/* rlwinm R6, R6, 0, 28, 31 */
		/* 821966C0h case   80:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R6,regs.R6);
		/* 821966C0h case   80:*/		return 0x821966C4;
		  /* 821966C4h */ case   81:  		/* srw R10, R8, R10 */
		/* 821966C4h case   81:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 821966C4h case   81:*/		return 0x821966C8;
		  /* 821966C8h */ case   82:  		/* rlwimi R7, R6, 2, 0, 29 */
		/* 821966C8h case   82:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R7,regs.R6);
		/* 821966C8h case   82:*/		return 0x821966CC;
		  /* 821966CCh */ case   83:  		/* rlwinm R9, R9, 0, 27, 18 */
		/* 821966CCh case   83:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R9,regs.R9);
		/* 821966CCh case   83:*/		return 0x821966D0;
		  /* 821966D0h */ case   84:  		/* rlwimi R10, R7, 2, 0, 29 */
		/* 821966D0h case   84:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 821966D0h case   84:*/		return 0x821966D4;
		  /* 821966D4h */ case   85:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 821966D4h case   85:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 821966D4h case   85:*/		return 0x821966D8;
		  /* 821966D8h */ case   86:  		/* or R10, R10, R9 */
		/* 821966D8h case   86:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821966D8h case   86:*/		return 0x821966DC;
		  /* 821966DCh */ case   87:  		/* stw R10, <#[R11]> */
		/* 821966DCh case   87:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821966DCh case   87:*/		return 0x821966E0;
		  /* 821966E0h */ case   88:  		/* lwz R11, <#[R31]> */
		/* 821966E0h case   88:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821966E0h case   88:*/		return 0x821966E4;
		  /* 821966E4h */ case   89:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 821966E4h case   89:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821966E4h case   89:*/		return 0x821966E8;
		  /* 821966E8h */ case   90:  		/* bc 12, CR0_EQ, 896 */
		/* 821966E8h case   90:*/		if ( regs.CR[0].eq ) { return 0x82196A68;  }
		/* 821966E8h case   90:*/		return 0x821966EC;
		  /* 821966ECh */ case   91:  		/* li R4, 4 */
		/* 821966ECh case   91:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 821966ECh case   91:*/		return 0x821966F0;
		  /* 821966F0h */ case   92:  		/* lwz R3, <#[R1 + 80]> */
		/* 821966F0h case   92:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 821966F0h case   92:*/		return 0x821966F4;
		  /* 821966F4h */ case   93:  		/* bl -126004 */
		/* 821966F4h case   93:*/		regs.LR = 0x821966F8; return 0x82177AC0;
		/* 821966F4h case   93:*/		return 0x821966F8;
		  /* 821966F8h */ case   94:  		/* b 880 */
		/* 821966F8h case   94:*/		return 0x82196A68;
		/* 821966F8h case   94:*/		return 0x821966FC;
	}
	return 0x821966FC;
} // Block from 82196580h-821966FCh (95 instructions)

//////////////////////////////////////////////////////
// Block at 821966FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821966FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821966FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821966FC);
		  /* 821966FCh */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 821966FCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821966FCh case    0:*/		return 0x82196700;
		  /* 82196700h */ case    1:  		/* bc 4, CR6_EQ, 1176 */
		/* 82196700h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82196B98;  }
		/* 82196700h case    1:*/		return 0x82196704;
		  /* 82196704h */ case    2:  		/* lwz R28, <#[R30 + 44]> */
		/* 82196704h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x0000002C) );
		/* 82196704h case    2:*/		return 0x82196708;
		  /* 82196708h */ case    3:  		/* lwz R25, <#[R30 + 48]> */
		/* 82196708h case    3:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R30 + 0x00000030) );
		/* 82196708h case    3:*/		return 0x8219670C;
		  /* 8219670Ch */ case    4:  		/* mr R3, R28 */
		/* 8219670Ch case    4:*/		regs.R3 = regs.R28;
		/* 8219670Ch case    4:*/		return 0x82196710;
		  /* 82196710h */ case    5:  		/* mr R4, R25 */
		/* 82196710h case    5:*/		regs.R4 = regs.R25;
		/* 82196710h case    5:*/		return 0x82196714;
		  /* 82196714h */ case    6:  		/* stw R28, <#[R1 + 80]> */
		/* 82196714h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 82196714h case    6:*/		return 0x82196718;
		  /* 82196718h */ case    7:  		/* stw R25, <#[R1 + 84]> */
		/* 82196718h case    7:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000054) );
		/* 82196718h case    7:*/		return 0x8219671C;
		  /* 8219671Ch */ case    8:  		/* bl -205972 */
		/* 8219671Ch case    8:*/		regs.LR = 0x82196720; return 0x82164288;
		/* 8219671Ch case    8:*/		return 0x82196720;
		  /* 82196720h */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82196720h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82196720h case    9:*/		return 0x82196724;
		  /* 82196724h */ case   10:  		/* bc 4, CR0_EQ, 576 */
		/* 82196724h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82196964;  }
		/* 82196724h case   10:*/		return 0x82196728;
		  /* 82196728h */ case   11:  		/* mr R4, R29 */
		/* 82196728h case   11:*/		regs.R4 = regs.R29;
		/* 82196728h case   11:*/		return 0x8219672C;
		  /* 8219672Ch */ case   12:  		/* mr R3, R28 */
		/* 8219672Ch case   12:*/		regs.R3 = regs.R28;
		/* 8219672Ch case   12:*/		return 0x82196730;
		  /* 82196730h */ case   13:  		/* li R24, 0 */
		/* 82196730h case   13:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82196730h case   13:*/		return 0x82196734;
		  /* 82196734h */ case   14:  		/* bl -205996 */
		/* 82196734h case   14:*/		regs.LR = 0x82196738; return 0x82164288;
		/* 82196734h case   14:*/		return 0x82196738;
		  /* 82196738h */ case   15:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82196738h case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82196738h case   15:*/		return 0x8219673C;
		  /* 8219673Ch */ case   16:  		/* bc 12, CR0_EQ, 268 */
		/* 8219673Ch case   16:*/		if ( regs.CR[0].eq ) { return 0x82196848;  }
		/* 8219673Ch case   16:*/		return 0x82196740;
		  /* 82196740h */ case   17:  		/* rlwinm. R11, R26, 0, 27, 31 */
		/* 82196740h case   17:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R26);
		/* 82196740h case   17:*/		return 0x82196744;
		  /* 82196744h */ case   18:  		/* bc 4, CR0_EQ, 260 */
		/* 82196744h case   18:*/		if ( !regs.CR[0].eq ) { return 0x82196848;  }
		/* 82196744h case   18:*/		return 0x82196748;
		  /* 82196748h */ case   19:  		/* lwz R11, <#[R28]> */
		/* 82196748h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82196748h case   19:*/		return 0x8219674C;
		  /* 8219674Ch */ case   20:  		/* rlwinm R10, R26, 22, 29, 30 */
		/* 8219674Ch case   20:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R10,regs.R26);
		/* 8219674Ch case   20:*/		return 0x82196750;
		  /* 82196750h */ case   21:  		/* rlwinm R9, R26, 24, 29, 30 */
		/* 82196750h case   21:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R9,regs.R26);
		/* 82196750h case   21:*/		return 0x82196754;
		  /* 82196754h */ case   22:  		/* lwz R8, <#[R29]> */
		/* 82196754h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000000) );
		/* 82196754h case   22:*/		return 0x82196758;
		  /* 82196758h */ case   23:  		/* rlwinm R7, R11, 27, 24, 31 */
		/* 82196758h case   23:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R7,regs.R11);
		/* 82196758h case   23:*/		return 0x8219675C;
		  /* 8219675Ch */ case   24:  		/* rlwinm R6, R26, 26, 29, 30 */
		/* 8219675Ch case   24:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R6,regs.R26);
		/* 8219675Ch case   24:*/		return 0x82196760;
		  /* 82196760h */ case   25:  		/* srw R10, R7, R10 */
		/* 82196760h case   25:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 82196760h case   25:*/		return 0x82196764;
		  /* 82196764h */ case   26:  		/* srw R9, R7, R9 */
		/* 82196764h case   26:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 82196764h case   26:*/		return 0x82196768;
		  /* 82196768h */ case   27:  		/* rlwimi R9, R10, 2, 28, 29 */
		/* 82196768h case   27:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R9,regs.R10);
		/* 82196768h case   27:*/		return 0x8219676C;
		  /* 8219676Ch */ case   28:  		/* rlwinm R10, R8, 8, 28, 30 */
		/* 8219676Ch case   28:*/		cpu::op::rlwinm<0,8,28,30>(regs,&regs.R10,regs.R8);
		/* 8219676Ch case   28:*/		return 0x82196770;
		  /* 82196770h */ case   29:  		/* rlwinm R4, R11, 8, 28, 30 */
		/* 82196770h case   29:*/		cpu::op::rlwinm<0,8,28,30>(regs,&regs.R4,regs.R11);
		/* 82196770h case   29:*/		return 0x82196774;
		  /* 82196774h */ case   30:  		/* rlwinm R9, R9, 0, 28, 31 */
		/* 82196774h case   30:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R9);
		/* 82196774h case   30:*/		return 0x82196778;
		  /* 82196778h */ case   31:  		/* srw R6, R7, R6 */
		/* 82196778h case   31:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R7,regs.R6);
		/* 82196778h case   31:*/		return 0x8219677C;
		  /* 8219677Ch */ case   32:  		/* slw R11, R22, R10 */
		/* 8219677Ch case   32:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R22,regs.R10);
		/* 8219677Ch case   32:*/		return 0x82196780;
		  /* 82196780h */ case   33:  		/* rlwinm R5, R26, 28, 29, 30 */
		/* 82196780h case   33:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R5,regs.R26);
		/* 82196780h case   33:*/		return 0x82196784;
		  /* 82196784h */ case   34:  		/* rlwimi R6, R9, 2, 0, 29 */
		/* 82196784h case   34:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R6,regs.R9);
		/* 82196784h case   34:*/		return 0x82196788;
		  /* 82196788h */ case   35:  		/* addi R11, R11, -1 */
		/* 82196788h case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82196788h case   35:*/		return 0x8219678C;
		  /* 8219678Ch */ case   36:  		/* srw R9, R7, R5 */
		/* 8219678Ch case   36:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R7,regs.R5);
		/* 8219678Ch case   36:*/		return 0x82196790;
		  /* 82196790h */ case   37:  		/* slw R10, R22, R4 */
		/* 82196790h case   37:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R22,regs.R4);
		/* 82196790h case   37:*/		return 0x82196794;
		  /* 82196794h */ case   38:  		/* rlwinm R8, R8, 27, 5, 31 */
		/* 82196794h case   38:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R8,regs.R8);
		/* 82196794h case   38:*/		return 0x82196798;
		  /* 82196798h */ case   39:  		/* rlwimi R9, R6, 2, 0, 29 */
		/* 82196798h case   39:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R6);
		/* 82196798h case   39:*/		return 0x8219679C;
		  /* 8219679Ch */ case   40:  		/* addi R10, R10, -1 */
		/* 8219679Ch case   40:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219679Ch case   40:*/		return 0x821967A0;
		  /* 821967A0h */ case   41:  		/* and R11, R11, R8 */
		/* 821967A0h case   41:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 821967A0h case   41:*/		return 0x821967A4;
		  /* 821967A4h */ case   42:  		/* and R10, R9, R10 */
		/* 821967A4h case   42:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821967A4h case   42:*/		return 0x821967A8;
		  /* 821967A8h */ case   43:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821967A8h case   43:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821967A8h case   43:*/		return 0x821967AC;
		  /* 821967ACh */ case   44:  		/* cmplw CR6, R10, R11 */
		/* 821967ACh case   44:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821967ACh case   44:*/		return 0x821967B0;
		  /* 821967B0h */ case   45:  		/* bc 4, CR6_EQ, 152 */
		/* 821967B0h case   45:*/		if ( !regs.CR[6].eq ) { return 0x82196848;  }
		/* 821967B0h case   45:*/		return 0x821967B4;
		  /* 821967B4h */ case   46:  		/* stw R29, <#[R1 + 84]> */
		/* 821967B4h case   46:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 821967B4h case   46:*/		return 0x821967B8;
		  /* 821967B8h */ case   47:  		/* mr R3, R27 */
		/* 821967B8h case   47:*/		regs.R3 = regs.R27;
		/* 821967B8h case   47:*/		return 0x821967BC;
		  /* 821967BCh */ case   48:  		/* stw R25, <#[R1 + 260]> */
		/* 821967BCh case   48:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000104) );
		/* 821967BCh case   48:*/		return 0x821967C0;
		  /* 821967C0h */ case   49:  		/* mr R4, R25 */
		/* 821967C0h case   49:*/		regs.R4 = regs.R25;
		/* 821967C0h case   49:*/		return 0x821967C4;
		  /* 821967C4h */ case   50:  		/* lwz R5, <#[R25 + 12]> */
		/* 821967C4h case   50:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R25 + 0x0000000C) );
		/* 821967C4h case   50:*/		return 0x821967C8;
		  /* 821967C8h */ case   51:  		/* mr R23, R30 */
		/* 821967C8h case   51:*/		regs.R23 = regs.R30;
		/* 821967C8h case   51:*/		return 0x821967CC;
		  /* 821967CCh */ case   52:  		/* bl -153308 */
		/* 821967CCh case   52:*/		regs.LR = 0x821967D0; return 0x821710F0;
		/* 821967CCh case   52:*/		return 0x821967D0;
		  /* 821967D0h */ case   53:  		/* lwz R11, <#[R31]> */
		/* 821967D0h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821967D0h case   53:*/		return 0x821967D4;
		  /* 821967D4h */ case   54:  		/* stw R3, <#[R1 + 260]> */
		/* 821967D4h case   54:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000104) );
		/* 821967D4h case   54:*/		return 0x821967D8;
		  /* 821967D8h */ case   55:  		/* mr R24, R22 */
		/* 821967D8h case   55:*/		regs.R24 = regs.R22;
		/* 821967D8h case   55:*/		return 0x821967DC;
		  /* 821967DCh */ case   56:  		/* lwz R10, <#[R3]> */
		/* 821967DCh case   56:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821967DCh case   56:*/		return 0x821967E0;
		  /* 821967E0h */ case   57:  		/* rlwimi R11, R10, 0, 7, 3 */
		/* 821967E0h case   57:*/		cpu::op::rlwimi<0,0,7,3>(regs,&regs.R11,regs.R10);
		/* 821967E0h case   57:*/		return 0x821967E4;
		  /* 821967E4h */ case   58:  		/* stw R11, <#[R3]> */
		/* 821967E4h case   58:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821967E4h case   58:*/		return 0x821967E8;
		  /* 821967E8h */ case   59:  		/* lwz R11, <#[R1 + 260]> */
		/* 821967E8h case   59:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000104) );
		/* 821967E8h case   59:*/		return 0x821967EC;
		  /* 821967ECh */ case   60:  		/* lwz R10, <#[R31]> */
		/* 821967ECh case   60:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821967ECh case   60:*/		return 0x821967F0;
		  /* 821967F0h */ case   61:  		/* rlwinm R10, R10, 27, 24, 31 */
		/* 821967F0h case   61:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R10);
		/* 821967F0h case   61:*/		return 0x821967F4;
		  /* 821967F4h */ case   62:  		/* lwz R9, <#[R11]> */
		/* 821967F4h case   62:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821967F4h case   62:*/		return 0x821967F8;
		  /* 821967F8h */ case   63:  		/* rlwinm R7, R10, 27, 29, 30 */
		/* 821967F8h case   63:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R7,regs.R10);
		/* 821967F8h case   63:*/		return 0x821967FC;
		  /* 821967FCh */ case   64:  		/* rlwinm R6, R10, 29, 29, 30 */
		/* 821967FCh case   64:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R6,regs.R10);
		/* 821967FCh case   64:*/		return 0x82196800;
		  /* 82196800h */ case   65:  		/* rlwinm R8, R9, 27, 24, 31 */
		/* 82196800h case   65:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R9);
		/* 82196800h case   65:*/		return 0x82196804;
		  /* 82196804h */ case   66:  		/* rlwinm R5, R10, 31, 29, 30 */
		/* 82196804h case   66:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R5,regs.R10);
		/* 82196804h case   66:*/		return 0x82196808;
		  /* 82196808h */ case   67:  		/* srw R7, R8, R7 */
		/* 82196808h case   67:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R8,regs.R7);
		/* 82196808h case   67:*/		return 0x8219680C;
		  /* 8219680Ch */ case   68:  		/* srw R6, R8, R6 */
		/* 8219680Ch case   68:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R8,regs.R6);
		/* 8219680Ch case   68:*/		return 0x82196810;
		  /* 82196810h */ case   69:  		/* rlwimi R6, R7, 2, 28, 29 */
		/* 82196810h case   69:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R6,regs.R7);
		/* 82196810h case   69:*/		return 0x82196814;
		  /* 82196814h */ case   70:  		/* rlwinm R10, R10, 1, 29, 30 */
		/* 82196814h case   70:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R10,regs.R10);
		/* 82196814h case   70:*/		return 0x82196818;
		  /* 82196818h */ case   71:  		/* srw R7, R8, R5 */
		/* 82196818h case   71:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R8,regs.R5);
		/* 82196818h case   71:*/		return 0x8219681C;
		  /* 8219681Ch */ case   72:  		/* rlwinm R6, R6, 0, 28, 31 */
		/* 8219681Ch case   72:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R6,regs.R6);
		/* 8219681Ch case   72:*/		return 0x82196820;
		  /* 82196820h */ case   73:  		/* srw R10, R8, R10 */
		/* 82196820h case   73:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82196820h case   73:*/		return 0x82196824;
		  /* 82196824h */ case   74:  		/* rlwimi R7, R6, 2, 0, 29 */
		/* 82196824h case   74:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R7,regs.R6);
		/* 82196824h case   74:*/		return 0x82196828;
		  /* 82196828h */ case   75:  		/* rlwinm R9, R9, 0, 27, 18 */
		/* 82196828h case   75:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R9,regs.R9);
		/* 82196828h case   75:*/		return 0x8219682C;
		  /* 8219682Ch */ case   76:  		/* rlwimi R10, R7, 2, 0, 29 */
		/* 8219682Ch case   76:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R7);
		/* 8219682Ch case   76:*/		return 0x82196830;
		  /* 82196830h */ case   77:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 82196830h case   77:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 82196830h case   77:*/		return 0x82196834;
		  /* 82196834h */ case   78:  		/* or R10, R10, R9 */
		/* 82196834h case   78:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82196834h case   78:*/		return 0x82196838;
		  /* 82196838h */ case   79:  		/* stw R10, <#[R11]> */
		/* 82196838h case   79:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82196838h case   79:*/		return 0x8219683C;
		  /* 8219683Ch */ case   80:  		/* lwz R29, <#[R1 + 260]> */
		/* 8219683Ch case   80:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000104) );
		/* 8219683Ch case   80:*/		return 0x82196840;
		  /* 82196840h */ case   81:  		/* lwz R25, <#[R1 + 84]> */
		/* 82196840h case   81:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000054) );
		/* 82196840h case   81:*/		return 0x82196844;
		  /* 82196844h */ case   82:  		/* lwz R28, <#[R1 + 80]> */
		/* 82196844h case   82:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 82196844h case   82:*/		return 0x82196848;
	}
	return 0x82196848;
} // Block from 821966FCh-82196848h (83 instructions)

//////////////////////////////////////////////////////
// Block at 82196848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196848);
		  /* 82196848h */ case    0:  		/* rlwinm. R11, R24, 0, 24, 31 */
		/* 82196848h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R24);
		/* 82196848h case    0:*/		return 0x8219684C;
		  /* 8219684Ch */ case    1:  		/* bc 4, CR0_EQ, 280 */
		/* 8219684Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82196964;  }
		/* 8219684Ch case    1:*/		return 0x82196850;
		  /* 82196850h */ case    2:  		/* mr R4, R29 */
		/* 82196850h case    2:*/		regs.R4 = regs.R29;
		/* 82196850h case    2:*/		return 0x82196854;
		  /* 82196854h */ case    3:  		/* mr R3, R25 */
		/* 82196854h case    3:*/		regs.R3 = regs.R25;
		/* 82196854h case    3:*/		return 0x82196858;
		  /* 82196858h */ case    4:  		/* bl -206288 */
		/* 82196858h case    4:*/		regs.LR = 0x8219685C; return 0x82164288;
		/* 82196858h case    4:*/		return 0x8219685C;
		  /* 8219685Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219685Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219685Ch case    5:*/		return 0x82196860;
		  /* 82196860h */ case    6:  		/* bc 12, CR0_EQ, 824 */
		/* 82196860h case    6:*/		if ( regs.CR[0].eq ) { return 0x82196B98;  }
		/* 82196860h case    6:*/		return 0x82196864;
		  /* 82196864h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82196864h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82196864h case    7:*/		return 0x82196868;
		  /* 82196868h */ case    8:  		/* rlwinm. R10, R11, 0, 27, 31 */
		/* 82196868h case    8:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R10,regs.R11);
		/* 82196868h case    8:*/		return 0x8219686C;
		  /* 8219686Ch */ case    9:  		/* bc 4, CR0_EQ, 812 */
		/* 8219686Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x82196B98;  }
		/* 8219686Ch case    9:*/		return 0x82196870;
		  /* 82196870h */ case   10:  		/* lwz R10, <#[R25]> */
		/* 82196870h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 82196870h case   10:*/		return 0x82196874;
		  /* 82196874h */ case   11:  		/* rlwinm R9, R11, 22, 29, 30 */
		/* 82196874h case   11:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R11);
		/* 82196874h case   11:*/		return 0x82196878;
		  /* 82196878h */ case   12:  		/* rlwinm R8, R11, 24, 29, 30 */
		/* 82196878h case   12:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R8,regs.R11);
		/* 82196878h case   12:*/		return 0x8219687C;
		  /* 8219687Ch */ case   13:  		/* lwz R7, <#[R29]> */
		/* 8219687Ch case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R29 + 0x00000000) );
		/* 8219687Ch case   13:*/		return 0x82196880;
		  /* 82196880h */ case   14:  		/* rlwinm R6, R10, 27, 24, 31 */
		/* 82196880h case   14:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R10);
		/* 82196880h case   14:*/		return 0x82196884;
		  /* 82196884h */ case   15:  		/* rlwinm R5, R11, 26, 29, 30 */
		/* 82196884h case   15:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R5,regs.R11);
		/* 82196884h case   15:*/		return 0x82196888;
		  /* 82196888h */ case   16:  		/* srw R9, R6, R9 */
		/* 82196888h case   16:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 82196888h case   16:*/		return 0x8219688C;
		  /* 8219688Ch */ case   17:  		/* srw R8, R6, R8 */
		/* 8219688Ch case   17:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R6,regs.R8);
		/* 8219688Ch case   17:*/		return 0x82196890;
		  /* 82196890h */ case   18:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 82196890h case   18:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 82196890h case   18:*/		return 0x82196894;
		  /* 82196894h */ case   19:  		/* rlwinm R9, R7, 8, 28, 30 */
		/* 82196894h case   19:*/		cpu::op::rlwinm<0,8,28,30>(regs,&regs.R9,regs.R7);
		/* 82196894h case   19:*/		return 0x82196898;
		  /* 82196898h */ case   20:  		/* rlwinm R4, R11, 28, 29, 30 */
		/* 82196898h case   20:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R4,regs.R11);
		/* 82196898h case   20:*/		return 0x8219689C;
		  /* 8219689Ch */ case   21:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 8219689Ch case   21:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 8219689Ch case   21:*/		return 0x821968A0;
		  /* 821968A0h */ case   22:  		/* srw R5, R6, R5 */
		/* 821968A0h case   22:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R6,regs.R5);
		/* 821968A0h case   22:*/		return 0x821968A4;
		  /* 821968A4h */ case   23:  		/* rlwinm R10, R10, 8, 28, 30 */
		/* 821968A4h case   23:*/		cpu::op::rlwinm<0,8,28,30>(regs,&regs.R10,regs.R10);
		/* 821968A4h case   23:*/		return 0x821968A8;
		  /* 821968A8h */ case   24:  		/* slw R11, R22, R9 */
		/* 821968A8h case   24:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R22,regs.R9);
		/* 821968A8h case   24:*/		return 0x821968AC;
		  /* 821968ACh */ case   25:  		/* rlwimi R5, R8, 2, 0, 29 */
		/* 821968ACh case   25:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R5,regs.R8);
		/* 821968ACh case   25:*/		return 0x821968B0;
		  /* 821968B0h */ case   26:  		/* slw R10, R22, R10 */
		/* 821968B0h case   26:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R22,regs.R10);
		/* 821968B0h case   26:*/		return 0x821968B4;
		  /* 821968B4h */ case   27:  		/* addi R11, R11, -1 */
		/* 821968B4h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821968B4h case   27:*/		return 0x821968B8;
		  /* 821968B8h */ case   28:  		/* srw R9, R6, R4 */
		/* 821968B8h case   28:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R6,regs.R4);
		/* 821968B8h case   28:*/		return 0x821968BC;
		  /* 821968BCh */ case   29:  		/* rlwinm R8, R7, 27, 5, 31 */
		/* 821968BCh case   29:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R8,regs.R7);
		/* 821968BCh case   29:*/		return 0x821968C0;
		  /* 821968C0h */ case   30:  		/* rlwimi R9, R5, 2, 0, 29 */
		/* 821968C0h case   30:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R5);
		/* 821968C0h case   30:*/		return 0x821968C4;
		  /* 821968C4h */ case   31:  		/* addi R10, R10, -1 */
		/* 821968C4h case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821968C4h case   31:*/		return 0x821968C8;
		  /* 821968C8h */ case   32:  		/* and R11, R11, R8 */
		/* 821968C8h case   32:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 821968C8h case   32:*/		return 0x821968CC;
		  /* 821968CCh */ case   33:  		/* and R10, R9, R10 */
		/* 821968CCh case   33:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821968CCh case   33:*/		return 0x821968D0;
		  /* 821968D0h */ case   34:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821968D0h case   34:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821968D0h case   34:*/		return 0x821968D4;
		  /* 821968D4h */ case   35:  		/* cmplw CR6, R10, R11 */
		/* 821968D4h case   35:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821968D4h case   35:*/		return 0x821968D8;
		  /* 821968D8h */ case   36:  		/* bc 4, CR6_EQ, 704 */
		/* 821968D8h case   36:*/		if ( !regs.CR[6].eq ) { return 0x82196B98;  }
		/* 821968D8h case   36:*/		return 0x821968DC;
		  /* 821968DCh */ case   37:  		/* stw R29, <#[R1 + 80]> */
		/* 821968DCh case   37:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 821968DCh case   37:*/		return 0x821968E0;
		  /* 821968E0h */ case   38:  		/* mr R3, R27 */
		/* 821968E0h case   38:*/		regs.R3 = regs.R27;
		/* 821968E0h case   38:*/		return 0x821968E4;
		  /* 821968E4h */ case   39:  		/* stw R28, <#[R1 + 260]> */
		/* 821968E4h case   39:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000104) );
		/* 821968E4h case   39:*/		return 0x821968E8;
		  /* 821968E8h */ case   40:  		/* mr R4, R28 */
		/* 821968E8h case   40:*/		regs.R4 = regs.R28;
		/* 821968E8h case   40:*/		return 0x821968EC;
		  /* 821968ECh */ case   41:  		/* mr R23, R30 */
		/* 821968ECh case   41:*/		regs.R23 = regs.R30;
		/* 821968ECh case   41:*/		return 0x821968F0;
		  /* 821968F0h */ case   42:  		/* lwz R5, <#[R28 + 12]> */
		/* 821968F0h case   42:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 821968F0h case   42:*/		return 0x821968F4;
		  /* 821968F4h */ case   43:  		/* bl -153604 */
		/* 821968F4h case   43:*/		regs.LR = 0x821968F8; return 0x821710F0;
		/* 821968F4h case   43:*/		return 0x821968F8;
		  /* 821968F8h */ case   44:  		/* stw R3, <#[R1 + 260]> */
		/* 821968F8h case   44:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000104) );
		/* 821968F8h case   44:*/		return 0x821968FC;
		  /* 821968FCh */ case   45:  		/* lwz R11, <#[R31]> */
		/* 821968FCh case   45:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821968FCh case   45:*/		return 0x82196900;
		  /* 82196900h */ case   46:  		/* lwz R10, <#[R3]> */
		/* 82196900h case   46:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82196900h case   46:*/		return 0x82196904;
		  /* 82196904h */ case   47:  		/* rlwimi R11, R10, 0, 7, 3 */
		/* 82196904h case   47:*/		cpu::op::rlwimi<0,0,7,3>(regs,&regs.R11,regs.R10);
		/* 82196904h case   47:*/		return 0x82196908;
		  /* 82196908h */ case   48:  		/* stw R11, <#[R3]> */
		/* 82196908h case   48:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82196908h case   48:*/		return 0x8219690C;
		  /* 8219690Ch */ case   49:  		/* lwz R11, <#[R1 + 260]> */
		/* 8219690Ch case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000104) );
		/* 8219690Ch case   49:*/		return 0x82196910;
		  /* 82196910h */ case   50:  		/* lwz R10, <#[R31]> */
		/* 82196910h case   50:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82196910h case   50:*/		return 0x82196914;
		  /* 82196914h */ case   51:  		/* rlwinm R10, R10, 27, 24, 31 */
		/* 82196914h case   51:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R10);
		/* 82196914h case   51:*/		return 0x82196918;
		  /* 82196918h */ case   52:  		/* lwz R6, <#[R11]> */
		/* 82196918h case   52:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 82196918h case   52:*/		return 0x8219691C;
		  /* 8219691Ch */ case   53:  		/* rlwinm R9, R10, 27, 29, 30 */
		/* 8219691Ch case   53:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R9,regs.R10);
		/* 8219691Ch case   53:*/		return 0x82196920;
		  /* 82196920h */ case   54:  		/* rlwinm R8, R10, 29, 29, 30 */
		/* 82196920h case   54:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R8,regs.R10);
		/* 82196920h case   54:*/		return 0x82196924;
		  /* 82196924h */ case   55:  		/* rlwinm R5, R6, 27, 24, 31 */
		/* 82196924h case   55:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R5,regs.R6);
		/* 82196924h case   55:*/		return 0x82196928;
		  /* 82196928h */ case   56:  		/* srw R9, R5, R9 */
		/* 82196928h case   56:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 82196928h case   56:*/		return 0x8219692C;
		  /* 8219692Ch */ case   57:  		/* srw R8, R5, R8 */
		/* 8219692Ch case   57:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 8219692Ch case   57:*/		return 0x82196930;
		  /* 82196930h */ case   58:  		/* rlwinm R7, R10, 31, 29, 30 */
		/* 82196930h case   58:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R7,regs.R10);
		/* 82196930h case   58:*/		return 0x82196934;
		  /* 82196934h */ case   59:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 82196934h case   59:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 82196934h case   59:*/		return 0x82196938;
		  /* 82196938h */ case   60:  		/* rlwinm R10, R10, 1, 29, 30 */
		/* 82196938h case   60:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R10,regs.R10);
		/* 82196938h case   60:*/		return 0x8219693C;
		  /* 8219693Ch */ case   61:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 8219693Ch case   61:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 8219693Ch case   61:*/		return 0x82196940;
		  /* 82196940h */ case   62:  		/* srw R9, R5, R7 */
		/* 82196940h case   62:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R5,regs.R7);
		/* 82196940h case   62:*/		return 0x82196944;
		  /* 82196944h */ case   63:  		/* srw R10, R5, R10 */
		/* 82196944h case   63:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 82196944h case   63:*/		return 0x82196948;
		  /* 82196948h */ case   64:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 82196948h case   64:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 82196948h case   64:*/		return 0x8219694C;
		  /* 8219694Ch */ case   65:  		/* rlwinm R8, R6, 0, 27, 18 */
		/* 8219694Ch case   65:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R8,regs.R6);
		/* 8219694Ch case   65:*/		return 0x82196950;
		  /* 82196950h */ case   66:  		/* rlwimi R10, R9, 2, 0, 29 */
		/* 82196950h case   66:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 82196950h case   66:*/		return 0x82196954;
		  /* 82196954h */ case   67:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 82196954h case   67:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 82196954h case   67:*/		return 0x82196958;
		  /* 82196958h */ case   68:  		/* or R10, R10, R8 */
		/* 82196958h case   68:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82196958h case   68:*/		return 0x8219695C;
		  /* 8219695Ch */ case   69:  		/* stw R10, <#[R11]> */
		/* 8219695Ch case   69:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219695Ch case   69:*/		return 0x82196960;
		  /* 82196960h */ case   70:  		/* lwz R28, <#[R1 + 80]> */
		/* 82196960h case   70:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 82196960h case   70:*/		return 0x82196964;
	}
	return 0x82196964;
} // Block from 82196848h-82196964h (71 instructions)

//////////////////////////////////////////////////////
// Block at 82196964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196964);
		  /* 82196964h */ case    0:  		/* mr R4, R28 */
		/* 82196964h case    0:*/		regs.R4 = regs.R28;
		/* 82196964h case    0:*/		return 0x82196968;
		  /* 82196968h */ case    1:  		/* lwz R5, <#[R28 + 12]> */
		/* 82196968h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 82196968h case    1:*/		return 0x8219696C;
		  /* 8219696Ch */ case    2:  		/* mr R3, R27 */
		/* 8219696Ch case    2:*/		regs.R3 = regs.R27;
		/* 8219696Ch case    2:*/		return 0x82196970;
		  /* 82196970h */ case    3:  		/* bl -153728 */
		/* 82196970h case    3:*/		regs.LR = 0x82196974; return 0x821710F0;
		/* 82196970h case    3:*/		return 0x82196974;
		  /* 82196974h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 82196974h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82196974h case    4:*/		return 0x82196978;
		  /* 82196978h */ case    5:  		/* stw R3, <#[R1 + 80]> */
		/* 82196978h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 82196978h case    5:*/		return 0x8219697C;
		  /* 8219697Ch */ case    6:  		/* lis R10, -32256 */
		/* 8219697Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8219697Ch case    6:*/		return 0x82196980;
		  /* 82196980h */ case    7:  		/* lwz R9, <#[R3]> */
		/* 82196980h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82196980h case    7:*/		return 0x82196984;
		  /* 82196984h */ case    8:  		/* rlwimi R11, R9, 0, 7, 3 */
		/* 82196984h case    8:*/		cpu::op::rlwimi<0,0,7,3>(regs,&regs.R11,regs.R9);
		/* 82196984h case    8:*/		return 0x82196988;
		  /* 82196988h */ case    9:  		/* stw R11, <#[R3]> */
		/* 82196988h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82196988h case    9:*/		return 0x8219698C;
		  /* 8219698Ch */ case   10:  		/* lfs FR1, <#[R10 + 2752]> */
		/* 8219698Ch case   10:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00000AC0) );
		/* 8219698Ch case   10:*/		return 0x82196990;
		  /* 82196990h */ case   11:  		/* lwz R10, <#[R31]> */
		/* 82196990h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82196990h case   11:*/		return 0x82196994;
		  /* 82196994h */ case   12:  		/* rlwinm R10, R10, 27, 24, 31 */
		/* 82196994h case   12:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R10);
		/* 82196994h case   12:*/		return 0x82196998;
		  /* 82196998h */ case   13:  		/* lwz R11, <#[R1 + 80]> */
		/* 82196998h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82196998h case   13:*/		return 0x8219699C;
		  /* 8219699Ch */ case   14:  		/* rlwinm R9, R10, 27, 29, 30 */
		/* 8219699Ch case   14:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R9,regs.R10);
		/* 8219699Ch case   14:*/		return 0x821969A0;
		  /* 821969A0h */ case   15:  		/* rlwinm R8, R10, 29, 29, 30 */
		/* 821969A0h case   15:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R8,regs.R10);
		/* 821969A0h case   15:*/		return 0x821969A4;
		  /* 821969A4h */ case   16:  		/* rlwinm R7, R10, 31, 29, 30 */
		/* 821969A4h case   16:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R7,regs.R10);
		/* 821969A4h case   16:*/		return 0x821969A8;
		  /* 821969A8h */ case   17:  		/* rlwinm R10, R10, 1, 29, 30 */
		/* 821969A8h case   17:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R10,regs.R10);
		/* 821969A8h case   17:*/		return 0x821969AC;
		  /* 821969ACh */ case   18:  		/* lwz R6, <#[R11]> */
		/* 821969ACh case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821969ACh case   18:*/		return 0x821969B0;
		  /* 821969B0h */ case   19:  		/* rlwinm R5, R6, 27, 24, 31 */
		/* 821969B0h case   19:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R5,regs.R6);
		/* 821969B0h case   19:*/		return 0x821969B4;
		  /* 821969B4h */ case   20:  		/* srw R9, R5, R9 */
		/* 821969B4h case   20:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 821969B4h case   20:*/		return 0x821969B8;
		  /* 821969B8h */ case   21:  		/* srw R8, R5, R8 */
		/* 821969B8h case   21:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 821969B8h case   21:*/		return 0x821969BC;
		  /* 821969BCh */ case   22:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 821969BCh case   22:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 821969BCh case   22:*/		return 0x821969C0;
		  /* 821969C0h */ case   23:  		/* srw R9, R5, R7 */
		/* 821969C0h case   23:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R5,regs.R7);
		/* 821969C0h case   23:*/		return 0x821969C4;
		  /* 821969C4h */ case   24:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 821969C4h case   24:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 821969C4h case   24:*/		return 0x821969C8;
		  /* 821969C8h */ case   25:  		/* srw R10, R5, R10 */
		/* 821969C8h case   25:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 821969C8h case   25:*/		return 0x821969CC;
		  /* 821969CCh */ case   26:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 821969CCh case   26:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 821969CCh case   26:*/		return 0x821969D0;
		  /* 821969D0h */ case   27:  		/* rlwinm R8, R6, 0, 27, 18 */
		/* 821969D0h case   27:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R8,regs.R6);
		/* 821969D0h case   27:*/		return 0x821969D4;
		  /* 821969D4h */ case   28:  		/* rlwimi R10, R9, 2, 0, 29 */
		/* 821969D4h case   28:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 821969D4h case   28:*/		return 0x821969D8;
		  /* 821969D8h */ case   29:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 821969D8h case   29:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 821969D8h case   29:*/		return 0x821969DC;
		  /* 821969DCh */ case   30:  		/* or R10, R10, R8 */
		/* 821969DCh case   30:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821969DCh case   30:*/		return 0x821969E0;
		  /* 821969E0h */ case   31:  		/* stw R10, <#[R11]> */
		/* 821969E0h case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821969E0h case   31:*/		return 0x821969E4;
		  /* 821969E4h */ case   32:  		/* lwz R11, <#[R31]> */
		/* 821969E4h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821969E4h case   32:*/		return 0x821969E8;
		  /* 821969E8h */ case   33:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 821969E8h case   33:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821969E8h case   33:*/		return 0x821969EC;
		  /* 821969ECh */ case   34:  		/* bc 12, CR0_EQ, 12 */
		/* 821969ECh case   34:*/		if ( regs.CR[0].eq ) { return 0x821969F8;  }
		/* 821969ECh case   34:*/		return 0x821969F0;
		  /* 821969F0h */ case   35:  		/* lis R11, -32252 */
		/* 821969F0h case   35:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821969F0h case   35:*/		return 0x821969F4;
		  /* 821969F4h */ case   36:  		/* lfs FR1, <#[R11 - 16652]> */
		/* 821969F4h case   36:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R11 + 0xFFFFBEF4) );
		/* 821969F4h case   36:*/		return 0x821969F8;
	}
	return 0x821969F8;
} // Block from 82196964h-821969F8h (37 instructions)

//////////////////////////////////////////////////////
// Block at 821969F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821969F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821969F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821969F8);
		  /* 821969F8h */ case    0:  		/* lis R11, -32256 */
		/* 821969F8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821969F8h case    0:*/		return 0x821969FC;
		  /* 821969FCh */ case    1:  		/* li R4, 1 */
		/* 821969FCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821969FCh case    1:*/		return 0x82196A00;
		  /* 82196A00h */ case    2:  		/* mr R3, R27 */
		/* 82196A00h case    2:*/		regs.R3 = regs.R27;
		/* 82196A00h case    2:*/		return 0x82196A04;
		  /* 82196A04h */ case    3:  		/* lfs FR4, <#[R11 + 1816]> */
		/* 82196A04h case    3:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R11 + 0x00000718) );
		/* 82196A04h case    3:*/		return 0x82196A08;
		  /* 82196A08h */ case    4:  		/* fmr FR3, FR4 */
		/* 82196A08h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 82196A08h case    4:*/		return 0x82196A0C;
		  /* 82196A0Ch */ case    5:  		/* fmr FR2, FR4 */
		/* 82196A0Ch case    5:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 82196A0Ch case    5:*/		return 0x82196A10;
		  /* 82196A10h */ case    6:  		/* bl 606536 */
		/* 82196A10h case    6:*/		regs.LR = 0x82196A14; return 0x8222AB58;
		/* 82196A10h case    6:*/		return 0x82196A14;
		  /* 82196A14h */ case    7:  		/* mr R29, R3 */
		/* 82196A14h case    7:*/		regs.R29 = regs.R3;
		/* 82196A14h case    7:*/		return 0x82196A18;
		  /* 82196A18h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 82196A18h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82196A18h case    8:*/		return 0x82196A1C;
		  /* 82196A1Ch */ case    9:  		/* mr R3, R27 */
		/* 82196A1Ch case    9:*/		regs.R3 = regs.R27;
		/* 82196A1Ch case    9:*/		return 0x82196A20;
		  /* 82196A20h */ case   10:  		/* mr R4, R29 */
		/* 82196A20h case   10:*/		regs.R4 = regs.R29;
		/* 82196A20h case   10:*/		return 0x82196A24;
		  /* 82196A24h */ case   11:  		/* rlwinm R31, R11, 7, 29, 31 */
		/* 82196A24h case   11:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R31,regs.R11);
		/* 82196A24h case   11:*/		return 0x82196A28;
		  /* 82196A28h */ case   12:  		/* bl -125480 */
		/* 82196A28h case   12:*/		regs.LR = 0x82196A2C; return 0x82178000;
		/* 82196A28h case   12:*/		return 0x82196A2C;
		  /* 82196A2Ch */ case   13:  		/* lwz R11, <#[R3]> */
		/* 82196A2Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82196A2Ch case   13:*/		return 0x82196A30;
		  /* 82196A30h */ case   14:  		/* li R4, 0 */
		/* 82196A30h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82196A30h case   14:*/		return 0x82196A34;
		  /* 82196A34h */ case   15:  		/* rlwimi R11, R31, 25, 4, 6 */
		/* 82196A34h case   15:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R31);
		/* 82196A34h case   15:*/		return 0x82196A38;
		  /* 82196A38h */ case   16:  		/* mr R28, R3 */
		/* 82196A38h case   16:*/		regs.R28 = regs.R3;
		/* 82196A38h case   16:*/		return 0x82196A3C;
		  /* 82196A3Ch */ case   17:  		/* stw R11, <#[R3]> */
		/* 82196A3Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82196A3Ch case   17:*/		return 0x82196A40;
		  /* 82196A40h */ case   18:  		/* bl -126848 */
		/* 82196A40h case   18:*/		regs.LR = 0x82196A44; return 0x82177AC0;
		/* 82196A40h case   18:*/		return 0x82196A44;
		  /* 82196A44h */ case   19:  		/* lwz R11, <#[R28]> */
		/* 82196A44h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82196A44h case   19:*/		return 0x82196A48;
		  /* 82196A48h */ case   20:  		/* mr R3, R29 */
		/* 82196A48h case   20:*/		regs.R3 = regs.R29;
		/* 82196A48h case   20:*/		return 0x82196A4C;
		  /* 82196A4Ch */ case   21:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 82196A4Ch case   21:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 82196A4Ch case   21:*/		return 0x82196A50;
		  /* 82196A50h */ case   22:  		/* stw R11, <#[R28]> */
		/* 82196A50h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82196A50h case   22:*/		return 0x82196A54;
		  /* 82196A54h */ case   23:  		/* stw R28, <#[R1 + 84]> */
		/* 82196A54h case   23:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 82196A54h case   23:*/		return 0x82196A58;
		  /* 82196A58h */ case   24:  		/* bl -1704 */
		/* 82196A58h case   24:*/		regs.LR = 0x82196A5C; return 0x821963B0;
		/* 82196A58h case   24:*/		return 0x82196A5C;
		  /* 82196A5Ch */ case   25:  		/* lwz R11, <#[R29 + 8]> */
		/* 82196A5Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82196A5Ch case   25:*/		return 0x82196A60;
		  /* 82196A60h */ case   26:  		/* oris R11, R11, 256 */
		/* 82196A60h case   26:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82196A60h case   26:*/		return 0x82196A64;
		  /* 82196A64h */ case   27:  		/* stw R11, <#[R29 + 8]> */
		/* 82196A64h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82196A64h case   27:*/		return 0x82196A68;
	}
	return 0x82196A68;
} // Block from 821969F8h-82196A68h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82196A68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196A68);
		  /* 82196A68h */ case    0:  		/* addi R6, R1, 260 */
		/* 82196A68h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x104);
		/* 82196A68h case    0:*/		return 0x82196A6C;
		  /* 82196A6Ch */ case    1:  		/* addi R5, R1, 84 */
		/* 82196A6Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82196A6Ch case    1:*/		return 0x82196A70;
		  /* 82196A70h */ case    2:  		/* addi R4, R1, 80 */
		/* 82196A70h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82196A70h case    2:*/		return 0x82196A74;
		  /* 82196A74h */ case    3:  		/* mr R3, R27 */
		/* 82196A74h case    3:*/		regs.R3 = regs.R27;
		/* 82196A74h case    3:*/		return 0x82196A78;
		  /* 82196A78h */ case    4:  		/* bl 36592 */
		/* 82196A78h case    4:*/		regs.LR = 0x82196A7C; return 0x8219F968;
		/* 82196A78h case    4:*/		return 0x82196A7C;
		  /* 82196A7Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82196A7Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82196A7Ch case    5:*/		return 0x82196A80;
		  /* 82196A80h */ case    6:  		/* bc 12, CR0_EQ, 280 */
		/* 82196A80h case    6:*/		if ( regs.CR[0].eq ) { return 0x82196B98;  }
		/* 82196A80h case    6:*/		return 0x82196A84;
		  /* 82196A84h */ case    7:  		/* li R7, 0 */
		/* 82196A84h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82196A84h case    7:*/		return 0x82196A88;
		  /* 82196A88h */ case    8:  		/* li R6, 1 */
		/* 82196A88h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82196A88h case    8:*/		return 0x82196A8C;
		  /* 82196A8Ch */ case    9:  		/* mr R5, R21 */
		/* 82196A8Ch case    9:*/		regs.R5 = regs.R21;
		/* 82196A8Ch case    9:*/		return 0x82196A90;
		  /* 82196A90h */ case   10:  		/* mr R4, R30 */
		/* 82196A90h case   10:*/		regs.R4 = regs.R30;
		/* 82196A90h case   10:*/		return 0x82196A94;
		  /* 82196A94h */ case   11:  		/* mr R3, R27 */
		/* 82196A94h case   11:*/		regs.R3 = regs.R27;
		/* 82196A94h case   11:*/		return 0x82196A98;
		  /* 82196A98h */ case   12:  		/* bl 618456 */
		/* 82196A98h case   12:*/		regs.LR = 0x82196A9C; return 0x8222DA70;
		/* 82196A98h case   12:*/		return 0x82196A9C;
		  /* 82196A9Ch */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82196A9Ch case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82196A9Ch case   13:*/		return 0x82196AA0;
		  /* 82196AA0h */ case   14:  		/* bc 12, CR0_EQ, 248 */
		/* 82196AA0h case   14:*/		if ( regs.CR[0].eq ) { return 0x82196B98;  }
		/* 82196AA0h case   14:*/		return 0x82196AA4;
		  /* 82196AA4h */ case   15:  		/* addi R10, R1, 88 */
		/* 82196AA4h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x58);
		/* 82196AA4h case   15:*/		return 0x82196AA8;
		  /* 82196AA8h */ case   16:  		/* lwz R8, <#[R1 + 260]> */
		/* 82196AA8h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000104) );
		/* 82196AA8h case   16:*/		return 0x82196AAC;
		  /* 82196AACh */ case   17:  		/* mr R9, R23 */
		/* 82196AACh case   17:*/		regs.R9 = regs.R23;
		/* 82196AACh case   17:*/		return 0x82196AB0;
		  /* 82196AB0h */ case   18:  		/* lwz R6, <#[R1 + 84]> */
		/* 82196AB0h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 82196AB0h case   18:*/		return 0x82196AB4;
		  /* 82196AB4h */ case   19:  		/* mr R7, R30 */
		/* 82196AB4h case   19:*/		regs.R7 = regs.R30;
		/* 82196AB4h case   19:*/		return 0x82196AB8;
		  /* 82196AB8h */ case   20:  		/* lwz R4, <#[R1 + 80]> */
		/* 82196AB8h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 82196AB8h case   20:*/		return 0x82196ABC;
		  /* 82196ABCh */ case   21:  		/* mr R5, R30 */
		/* 82196ABCh case   21:*/		regs.R5 = regs.R30;
		/* 82196ABCh case   21:*/		return 0x82196AC0;
		  /* 82196AC0h */ case   22:  		/* mr R3, R27 */
		/* 82196AC0h case   22:*/		regs.R3 = regs.R27;
		/* 82196AC0h case   22:*/		return 0x82196AC4;
		  /* 82196AC4h */ case   23:  		/* bl 18724 */
		/* 82196AC4h case   23:*/		regs.LR = 0x82196AC8; return 0x8219B3E8;
		/* 82196AC4h case   23:*/		return 0x82196AC8;
		  /* 82196AC8h */ case   24:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82196AC8h case   24:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82196AC8h case   24:*/		return 0x82196ACC;
		  /* 82196ACCh */ case   25:  		/* bc 12, CR0_EQ, 204 */
		/* 82196ACCh case   25:*/		if ( regs.CR[0].eq ) { return 0x82196B98;  }
		/* 82196ACCh case   25:*/		return 0x82196AD0;
		  /* 82196AD0h */ case   26:  		/* lwz R11, <#[R30]> */
		/* 82196AD0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82196AD0h case   26:*/		return 0x82196AD4;
		  /* 82196AD4h */ case   27:  		/* li R7, 0 */
		/* 82196AD4h case   27:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82196AD4h case   27:*/		return 0x82196AD8;
		  /* 82196AD8h */ case   28:  		/* li R8, 0 */
		/* 82196AD8h case   28:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82196AD8h case   28:*/		return 0x82196ADC;
		  /* 82196ADCh */ case   29:  		/* cmplwi CR6, R11, 0 */
		/* 82196ADCh case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82196ADCh case   29:*/		return 0x82196AE0;
		  /* 82196AE0h */ case   30:  		/* bc 12, CR6_EQ, 60 */
		/* 82196AE0h case   30:*/		if ( regs.CR[6].eq ) { return 0x82196B1C;  }
		/* 82196AE0h case   30:*/		return 0x82196AE4;
		  /* 82196AE4h */ case   31:  		/* lwz R9, <#[R11]> */
		/* 82196AE4h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82196AE4h case   31:*/		return 0x82196AE8;
		  /* 82196AE8h */ case   32:  		/* rlwinm. R10, R9, 0, 1, 1 */
		/* 82196AE8h case   32:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R9);
		/* 82196AE8h case   32:*/		return 0x82196AEC;
		  /* 82196AECh */ case   33:  		/* bc 12, CR0_EQ, 16 */
		/* 82196AECh case   33:*/		if ( regs.CR[0].eq ) { return 0x82196AFC;  }
		/* 82196AECh case   33:*/		return 0x82196AF0;
	}
	return 0x82196AF0;
} // Block from 82196A68h-82196AF0h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82196AF0h
// Function '?SupportsClampedModifier@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196AF0);
		  /* 82196AF0h */ case    0:  		/* rlwinm. R10, R9, 0, 4, 6 */
		/* 82196AF0h case    0:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R9);
		/* 82196AF0h case    0:*/		return 0x82196AF4;
		  /* 82196AF4h */ case    1:  		/* mr R10, R22 */
		/* 82196AF4h case    1:*/		regs.R10 = regs.R22;
		/* 82196AF4h case    1:*/		return 0x82196AF8;
		  /* 82196AF8h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 82196AF8h case    2:*/		if ( regs.CR[0].eq ) { return 0x82196B00;  }
		/* 82196AF8h case    2:*/		return 0x82196AFC;
	}
	return 0x82196AFC;
} // Block from 82196AF0h-82196AFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82196AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196AFC);
		  /* 82196AFCh */ case    0:  		/* li R10, 0 */
		/* 82196AFCh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82196AFCh case    0:*/		return 0x82196B00;
	}
	return 0x82196B00;
} // Block from 82196AFCh-82196B00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B00);
		  /* 82196B00h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82196B00h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82196B00h case    0:*/		return 0x82196B04;
		  /* 82196B04h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82196B04h case    1:*/		if ( regs.CR[0].eq ) { return 0x82196B10;  }
		/* 82196B04h case    1:*/		return 0x82196B08;
		  /* 82196B08h */ case    2:  		/* rlwinm. R10, R9, 0, 7, 18 */
		/* 82196B08h case    2:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R10,regs.R9);
		/* 82196B08h case    2:*/		return 0x82196B0C;
		  /* 82196B0Ch */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82196B0Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82196B18;  }
		/* 82196B0Ch case    3:*/		return 0x82196B10;
	}
	return 0x82196B10;
} // Block from 82196B00h-82196B10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82196B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B10);
		  /* 82196B10h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 82196B10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82196B10h case    0:*/		return 0x82196B14;
		  /* 82196B14h */ case    1:  		/* b -56 */
		/* 82196B14h case    1:*/		return 0x82196ADC;
		/* 82196B14h case    1:*/		return 0x82196B18;
	}
	return 0x82196B18;
} // Block from 82196B10h-82196B18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82196B18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B18);
		  /* 82196B18h */ case    0:  		/* lwz R7, <#[R11 + 12]> */
		/* 82196B18h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 82196B18h case    0:*/		return 0x82196B1C;
	}
	return 0x82196B1C;
} // Block from 82196B18h-82196B1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196B1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B1C);
		  /* 82196B1Ch */ case    0:  		/* lwz R10, <#[R21]> */
		/* 82196B1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000000) );
		/* 82196B1Ch case    0:*/		return 0x82196B20;
		  /* 82196B20h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 82196B20h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82196B20h case    1:*/		return 0x82196B24;
		  /* 82196B24h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 82196B24h case    2:*/		if ( regs.CR[6].eq ) { return 0x82196B60;  }
		/* 82196B24h case    2:*/		return 0x82196B28;
		  /* 82196B28h */ case    3:  		/* lwz R9, <#[R10]> */
		/* 82196B28h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82196B28h case    3:*/		return 0x82196B2C;
		  /* 82196B2Ch */ case    4:  		/* rlwinm. R11, R9, 0, 1, 1 */
		/* 82196B2Ch case    4:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R9);
		/* 82196B2Ch case    4:*/		return 0x82196B30;
		  /* 82196B30h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82196B30h case    5:*/		if ( regs.CR[0].eq ) { return 0x82196B40;  }
		/* 82196B30h case    5:*/		return 0x82196B34;
		  /* 82196B34h */ case    6:  		/* rlwinm. R11, R9, 0, 4, 6 */
		/* 82196B34h case    6:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R9);
		/* 82196B34h case    6:*/		return 0x82196B38;
		  /* 82196B38h */ case    7:  		/* mr R11, R22 */
		/* 82196B38h case    7:*/		regs.R11 = regs.R22;
		/* 82196B38h case    7:*/		return 0x82196B3C;
		  /* 82196B3Ch */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 82196B3Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x82196B44;  }
		/* 82196B3Ch case    8:*/		return 0x82196B40;
	}
	return 0x82196B40;
} // Block from 82196B1Ch-82196B40h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82196B40h
// Function '?CanAddModifiers@D3DXShader@@YA_NII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B40);
		  /* 82196B40h */ case    0:  		/* li R11, 0 */
		/* 82196B40h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82196B40h case    0:*/		return 0x82196B44;
	}
	return 0x82196B44;
} // Block from 82196B40h-82196B44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B44);
		  /* 82196B44h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82196B44h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82196B44h case    0:*/		return 0x82196B48;
		  /* 82196B48h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82196B48h case    1:*/		if ( regs.CR[0].eq ) { return 0x82196B54;  }
		/* 82196B48h case    1:*/		return 0x82196B4C;
		  /* 82196B4Ch */ case    2:  		/* rlwinm. R11, R9, 0, 7, 18 */
		/* 82196B4Ch case    2:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R9);
		/* 82196B4Ch case    2:*/		return 0x82196B50;
		  /* 82196B50h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82196B50h case    3:*/		if ( regs.CR[0].eq ) { return 0x82196B5C;  }
		/* 82196B50h case    3:*/		return 0x82196B54;
	}
	return 0x82196B54;
} // Block from 82196B44h-82196B54h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82196B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B54);
		  /* 82196B54h */ case    0:  		/* lwz R10, <#[R10 + 4]> */
		/* 82196B54h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 82196B54h case    0:*/		return 0x82196B58;
		  /* 82196B58h */ case    1:  		/* b -56 */
		/* 82196B58h case    1:*/		return 0x82196B20;
		/* 82196B58h case    1:*/		return 0x82196B5C;
	}
	return 0x82196B5C;
} // Block from 82196B54h-82196B5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82196B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B5C);
		  /* 82196B5Ch */ case    0:  		/* lwz R8, <#[R10 + 12]> */
		/* 82196B5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 82196B5Ch case    0:*/		return 0x82196B60;
	}
	return 0x82196B60;
} // Block from 82196B5Ch-82196B60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B60);
		  /* 82196B60h */ case    0:  		/* cmplwi CR6, R7, 0 */
		/* 82196B60h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 82196B60h case    0:*/		return 0x82196B64;
		  /* 82196B64h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82196B64h case    1:*/		if ( regs.CR[6].eq ) { return 0x82196B78;  }
		/* 82196B64h case    1:*/		return 0x82196B68;
		  /* 82196B68h */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 82196B68h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82196B68h case    2:*/		return 0x82196B6C;
		  /* 82196B6Ch */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82196B6Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82196B78;  }
		/* 82196B6Ch case    3:*/		return 0x82196B70;
		  /* 82196B70h */ case    4:  		/* cmplw CR6, R7, R8 */
		/* 82196B70h case    4:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 82196B70h case    4:*/		return 0x82196B74;
		  /* 82196B74h */ case    5:  		/* bc 4, CR6_EQ, 36 */
		/* 82196B74h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82196B98;  }
		/* 82196B74h case    5:*/		return 0x82196B78;
	}
	return 0x82196B78;
} // Block from 82196B60h-82196B78h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82196B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B78);
		  /* 82196B78h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82196B78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82196B78h case    0:*/		return 0x82196B7C;
		  /* 82196B7Ch */ case    1:  		/* li R3, 1 */
		/* 82196B7Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82196B7Ch case    1:*/		return 0x82196B80;
		  /* 82196B80h */ case    2:  		/* lwz R10, <#[R1 + 84]> */
		/* 82196B80h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82196B80h case    2:*/		return 0x82196B84;
		  /* 82196B84h */ case    3:  		/* lwz R9, <#[R1 + 260]> */
		/* 82196B84h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000104) );
		/* 82196B84h case    3:*/		return 0x82196B88;
	}
	return 0x82196B88;
} // Block from 82196B78h-82196B88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82196B88h
// Function '?ApplySwizzle@Dependency@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B88);
		  /* 82196B88h */ case    0:  		/* stw R11, <#[R20]> */
		/* 82196B88h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 82196B88h case    0:*/		return 0x82196B8C;
		  /* 82196B8Ch */ case    1:  		/* stw R10, <#[R20 + 4]> */
		/* 82196B8Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R20 + 0x00000004) );
		/* 82196B8Ch case    1:*/		return 0x82196B90;
		  /* 82196B90h */ case    2:  		/* stw R9, <#[R20 + 8]> */
		/* 82196B90h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R20 + 0x00000008) );
		/* 82196B90h case    2:*/		return 0x82196B94;
		  /* 82196B94h */ case    3:  		/* b 8 */
		/* 82196B94h case    3:*/		return 0x82196B9C;
		/* 82196B94h case    3:*/		return 0x82196B98;
	}
	return 0x82196B98;
} // Block from 82196B88h-82196B98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82196B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B98);
		  /* 82196B98h */ case    0:  		/* li R3, 0 */
		/* 82196B98h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82196B98h case    0:*/		return 0x82196B9C;
	}
	return 0x82196B9C;
} // Block from 82196B98h-82196B9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196B9C);
		  /* 82196B9Ch */ case    0:  		/* addi R1, R1, 208 */
		/* 82196B9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 82196B9Ch case    0:*/		return 0x82196BA0;
		  /* 82196BA0h */ case    1:  		/* b -1071384 */
		/* 82196BA0h case    1:*/		return 0x82091288;
		/* 82196BA0h case    1:*/		return 0x82196BA4;
		  /* 82196BA4h */ case    2:  		/* nop */
		/* 82196BA4h case    2:*/		cpu::op::nop();
		/* 82196BA4h case    2:*/		return 0x82196BA8;
	}
	return 0x82196BA8;
} // Block from 82196B9Ch-82196BA8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82196BA8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196BA8);
		  /* 82196BA8h */ case    0:  		/* mfspr R12, LR */
		/* 82196BA8h case    0:*/		regs.R12 = regs.LR;
		/* 82196BA8h case    0:*/		return 0x82196BAC;
		  /* 82196BACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82196BACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82196BACh case    1:*/		return 0x82196BB0;
		  /* 82196BB0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82196BB0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82196BB0h case    2:*/		return 0x82196BB4;
		  /* 82196BB4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82196BB4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82196BB4h case    3:*/		return 0x82196BB8;
		  /* 82196BB8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82196BB8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82196BB8h case    4:*/		return 0x82196BBC;
		  /* 82196BBCh */ case    5:  		/* mr R30, R4 */
		/* 82196BBCh case    5:*/		regs.R30 = regs.R4;
		/* 82196BBCh case    5:*/		return 0x82196BC0;
		  /* 82196BC0h */ case    6:  		/* lwz R4, <#[R3 + 4]> */
		/* 82196BC0h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82196BC0h case    6:*/		return 0x82196BC4;
		  /* 82196BC4h */ case    7:  		/* addi R31, R3, 4 */
		/* 82196BC4h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x4);
		/* 82196BC4h case    7:*/		return 0x82196BC8;
		  /* 82196BC8h */ case    8:  		/* b 52 */
		/* 82196BC8h case    8:*/		return 0x82196BFC;
		/* 82196BC8h case    8:*/		return 0x82196BCC;
		  /* 82196BCCh */ case    9:  		/* lwz R11, <#[R4 + 16]> */
		/* 82196BCCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 82196BCCh case    9:*/		return 0x82196BD0;
		  /* 82196BD0h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82196BD0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82196BD0h case   10:*/		return 0x82196BD4;
		  /* 82196BD4h */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 82196BD4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82196BF4;  }
		/* 82196BD4h case   11:*/		return 0x82196BD8;
	}
	return 0x82196BD8;
} // Block from 82196BA8h-82196BD8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82196BD8h
// Function '?CanAddModifiers@Dependency@D3DXShader@@QAA_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196BD8);
		  /* 82196BD8h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 82196BD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82196BD8h case    0:*/		return 0x82196BDC;
		  /* 82196BDCh */ case    1:  		/* li R6, 26 */
		/* 82196BDCh case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1A);
		/* 82196BDCh case    1:*/		return 0x82196BE0;
		  /* 82196BE0h */ case    2:  		/* li R5, 20 */
		/* 82196BE0h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x14);
		/* 82196BE0h case    2:*/		return 0x82196BE4;
		  /* 82196BE4h */ case    3:  		/* mr R3, R30 */
		/* 82196BE4h case    3:*/		regs.R3 = regs.R30;
		/* 82196BE4h case    3:*/		return 0x82196BE8;
		  /* 82196BE8h */ case    4:  		/* stw R11, <#[R31]> */
		/* 82196BE8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82196BE8h case    4:*/		return 0x82196BEC;
		  /* 82196BECh */ case    5:  		/* bl -204628 */
		/* 82196BECh case    5:*/		regs.LR = 0x82196BF0; return 0x82164C98;
		/* 82196BECh case    5:*/		return 0x82196BF0;
		  /* 82196BF0h */ case    6:  		/* b 8 */
		/* 82196BF0h case    6:*/		return 0x82196BF8;
		/* 82196BF0h case    6:*/		return 0x82196BF4;
	}
	return 0x82196BF4;
} // Block from 82196BD8h-82196BF4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82196BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196BF4);
		  /* 82196BF4h */ case    0:  		/* addi R31, R4, 8 */
		/* 82196BF4h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R4,0x8);
		/* 82196BF4h case    0:*/		return 0x82196BF8;
	}
	return 0x82196BF8;
} // Block from 82196BF4h-82196BF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196BF8);
		  /* 82196BF8h */ case    0:  		/* lwz R4, <#[R31]> */
		/* 82196BF8h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82196BF8h case    0:*/		return 0x82196BFC;
	}
	return 0x82196BFC;
} // Block from 82196BF8h-82196BFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196BFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196BFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196BFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196BFC);
		  /* 82196BFCh */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 82196BFCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82196BFCh case    0:*/		return 0x82196C00;
		  /* 82196C00h */ case    1:  		/* bc 4, CR6_EQ, -52 */
		/* 82196C00h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82196BCC;  }
		/* 82196C00h case    1:*/		return 0x82196C04;
		  /* 82196C04h */ case    2:  		/* addi R1, R1, 112 */
		/* 82196C04h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82196C04h case    2:*/		return 0x82196C08;
		  /* 82196C08h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82196C08h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82196C08h case    3:*/		return 0x82196C0C;
		  /* 82196C0Ch */ case    4:  		/* mtspr LR, R12 */
		/* 82196C0Ch case    4:*/		regs.LR = regs.R12;
		/* 82196C0Ch case    4:*/		return 0x82196C10;
		  /* 82196C10h */ case    5:  		/* ld R30, <#[R1 - 24]> */
		/* 82196C10h case    5:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82196C10h case    5:*/		return 0x82196C14;
		  /* 82196C14h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 82196C14h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82196C14h case    6:*/		return 0x82196C18;
		  /* 82196C18h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82196C18h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82196C18h case    7:*/		return 0x82196C1C;
	}
	return 0x82196C1C;
} // Block from 82196BFCh-82196C1Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82196C1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196C1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196C1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196C1C);
		  /* 82196C1Ch */ case    0:  		/* nop */
		/* 82196C1Ch case    0:*/		cpu::op::nop();
		/* 82196C1Ch case    0:*/		return 0x82196C20;
	}
	return 0x82196C20;
} // Block from 82196C1Ch-82196C20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196C20);
		  /* 82196C20h */ case    0:  		/* mfspr R12, LR */
		/* 82196C20h case    0:*/		regs.R12 = regs.LR;
		/* 82196C20h case    0:*/		return 0x82196C24;
		  /* 82196C24h */ case    1:  		/* bl -1071572 */
		/* 82196C24h case    1:*/		regs.LR = 0x82196C28; return 0x82091250;
		/* 82196C24h case    1:*/		return 0x82196C28;
	}
	return 0x82196C28;
} // Block from 82196C20h-82196C28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82196C28h
// Function '?SupportsInputModifiers@Instruction@D3DXShader@@QAA_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196C28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196C28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196C28);
		  /* 82196C28h */ case    0:  		/* stwu R1, <#[R1 - 144]> */
		/* 82196C28h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82196C28h case    0:*/		return 0x82196C2C;
		  /* 82196C2Ch */ case    1:  		/* mr R26, R4 */
		/* 82196C2Ch case    1:*/		regs.R26 = regs.R4;
		/* 82196C2Ch case    1:*/		return 0x82196C30;
		  /* 82196C30h */ case    2:  		/* lwz R4, <#[R5 + 28]> */
		/* 82196C30h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 82196C30h case    2:*/		return 0x82196C34;
		  /* 82196C34h */ case    3:  		/* mr R27, R5 */
		/* 82196C34h case    3:*/		regs.R27 = regs.R5;
		/* 82196C34h case    3:*/		return 0x82196C38;
		  /* 82196C38h */ case    4:  		/* mr R30, R6 */
		/* 82196C38h case    4:*/		regs.R30 = regs.R6;
		/* 82196C38h case    4:*/		return 0x82196C3C;
		  /* 82196C3Ch */ case    5:  		/* mr R28, R7 */
		/* 82196C3Ch case    5:*/		regs.R28 = regs.R7;
		/* 82196C3Ch case    5:*/		return 0x82196C40;
		  /* 82196C40h */ case    6:  		/* li R8, 4 */
		/* 82196C40h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82196C40h case    6:*/		return 0x82196C44;
		  /* 82196C44h */ case    7:  		/* li R7, 2 */
		/* 82196C44h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 82196C44h case    7:*/		return 0x82196C48;
		  /* 82196C48h */ case    8:  		/* li R6, 6 */
		/* 82196C48h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x6);
		/* 82196C48h case    8:*/		return 0x82196C4C;
		  /* 82196C4Ch */ case    9:  		/* li R5, 0 */
		/* 82196C4Ch case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82196C4Ch case    9:*/		return 0x82196C50;
		  /* 82196C50h */ case   10:  		/* mr R29, R3 */
		/* 82196C50h case   10:*/		regs.R29 = regs.R3;
		/* 82196C50h case   10:*/		return 0x82196C54;
		  /* 82196C54h */ case   11:  		/* bl 580932 */
		/* 82196C54h case   11:*/		regs.LR = 0x82196C58; return 0x82224998;
		/* 82196C54h case   11:*/		return 0x82196C58;
		  /* 82196C58h */ case   12:  		/* lwz R11, <#[R30 + 16]> */
		/* 82196C58h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82196C58h case   12:*/		return 0x82196C5C;
		  /* 82196C5Ch */ case   13:  		/* mr R31, R3 */
		/* 82196C5Ch case   13:*/		regs.R31 = regs.R3;
		/* 82196C5Ch case   13:*/		return 0x82196C60;
		  /* 82196C60h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82196C60h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82196C60h case   14:*/		return 0x82196C64;
		  /* 82196C64h */ case   15:  		/* mr R4, R30 */
		/* 82196C64h case   15:*/		regs.R4 = regs.R30;
		/* 82196C64h case   15:*/		return 0x82196C68;
		  /* 82196C68h */ case   16:  		/* bc 12, CR6_EQ, 20 */
		/* 82196C68h case   16:*/		if ( regs.CR[6].eq ) { return 0x82196C7C;  }
		/* 82196C68h case   16:*/		return 0x82196C6C;
		  /* 82196C6Ch */ case   17:  		/* mr R3, R29 */
		/* 82196C6Ch case   17:*/		regs.R3 = regs.R29;
		/* 82196C6Ch case   17:*/		return 0x82196C70;
		  /* 82196C70h */ case   18:  		/* lwz R5, <#[R30 + 12]> */
		/* 82196C70h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 82196C70h case   18:*/		return 0x82196C74;
		  /* 82196C74h */ case   19:  		/* bl -154500 */
		/* 82196C74h case   19:*/		regs.LR = 0x82196C78; return 0x821710F0;
		/* 82196C74h case   19:*/		return 0x82196C78;
		  /* 82196C78h */ case   20:  		/* mr R4, R3 */
		/* 82196C78h case   20:*/		regs.R4 = regs.R3;
		/* 82196C78h case   20:*/		return 0x82196C7C;
	}
	return 0x82196C7C;
} // Block from 82196C28h-82196C7Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 82196C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196C7C);
		  /* 82196C7Ch */ case    0:  		/* mr R3, R31 */
		/* 82196C7Ch case    0:*/		regs.R3 = regs.R31;
		/* 82196C7Ch case    0:*/		return 0x82196C80;
		  /* 82196C80h */ case    1:  		/* bl -125624 */
		/* 82196C80h case    1:*/		regs.LR = 0x82196C84; return 0x821781C8;
		/* 82196C80h case    1:*/		return 0x82196C84;
		  /* 82196C84h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 82196C84h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 82196C84h case    2:*/		return 0x82196C88;
		  /* 82196C88h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 82196C88h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 82196C88h case    3:*/		return 0x82196C8C;
		  /* 82196C8Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82196C8Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82196C8Ch case    4:*/		return 0x82196C90;
		  /* 82196C90h */ case    5:  		/* mr R4, R28 */
		/* 82196C90h case    5:*/		regs.R4 = regs.R28;
		/* 82196C90h case    5:*/		return 0x82196C94;
		  /* 82196C94h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82196C94h case    6:*/		if ( regs.CR[6].eq ) { return 0x82196CA8;  }
		/* 82196C94h case    6:*/		return 0x82196C98;
	}
	return 0x82196C98;
} // Block from 82196C7Ch-82196C98h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82196C98h
// Function '?InitFixedSize@?$DynamicBitSet@I$1?AllocInContext@CompilerHeap@D3DXShader@@SAPAXPAXK@Z$1?FreeInContext@23@SAX00K@Z@D3DXShader@@QAAXIP6APAXPAXK@Z0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196C98);
		  /* 82196C98h */ case    0:  		/* mr R3, R29 */
		/* 82196C98h case    0:*/		regs.R3 = regs.R29;
		/* 82196C98h case    0:*/		return 0x82196C9C;
		  /* 82196C9Ch */ case    1:  		/* lwz R5, <#[R28 + 12]> */
		/* 82196C9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 82196C9Ch case    1:*/		return 0x82196CA0;
		  /* 82196CA0h */ case    2:  		/* bl -154544 */
		/* 82196CA0h case    2:*/		regs.LR = 0x82196CA4; return 0x821710F0;
		/* 82196CA0h case    2:*/		return 0x82196CA4;
		  /* 82196CA4h */ case    3:  		/* mr R4, R3 */
		/* 82196CA4h case    3:*/		regs.R4 = regs.R3;
		/* 82196CA4h case    3:*/		return 0x82196CA8;
	}
	return 0x82196CA8;
} // Block from 82196C98h-82196CA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82196CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196CA8);
		  /* 82196CA8h */ case    0:  		/* mr R3, R31 */
		/* 82196CA8h case    0:*/		regs.R3 = regs.R31;
		/* 82196CA8h case    0:*/		return 0x82196CAC;
		  /* 82196CACh */ case    1:  		/* bl -125668 */
		/* 82196CACh case    1:*/		regs.LR = 0x82196CB0; return 0x821781C8;
		/* 82196CACh case    1:*/		return 0x82196CB0;
		  /* 82196CB0h */ case    2:  		/* lwz R11, <#[R31 + 44]> */
		/* 82196CB0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82196CB0h case    2:*/		return 0x82196CB4;
		  /* 82196CB4h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 82196CB4h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82196CB4h case    3:*/		return 0x82196CB8;
		  /* 82196CB8h */ case    4:  		/* mr R6, R27 */
		/* 82196CB8h case    4:*/		regs.R6 = regs.R27;
		/* 82196CB8h case    4:*/		return 0x82196CBC;
		  /* 82196CBCh */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 82196CBCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82196CBCh case    5:*/		return 0x82196CC0;
		  /* 82196CC0h */ case    6:  		/* mr R5, R26 */
		/* 82196CC0h case    6:*/		regs.R5 = regs.R26;
		/* 82196CC0h case    6:*/		return 0x82196CC4;
		  /* 82196CC4h */ case    7:  		/* mr R4, R31 */
		/* 82196CC4h case    7:*/		regs.R4 = regs.R31;
		/* 82196CC4h case    7:*/		return 0x82196CC8;
		  /* 82196CC8h */ case    8:  		/* mr R3, R29 */
		/* 82196CC8h case    8:*/		regs.R3 = regs.R29;
		/* 82196CC8h case    8:*/		return 0x82196CCC;
		  /* 82196CCCh */ case    9:  		/* lwz R11, <#[R11]> */
		/* 82196CCCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82196CCCh case    9:*/		return 0x82196CD0;
		  /* 82196CD0h */ case   10:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 82196CD0h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 82196CD0h case   10:*/		return 0x82196CD4;
		  /* 82196CD4h */ case   11:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 82196CD4h case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 82196CD4h case   11:*/		return 0x82196CD8;
		  /* 82196CD8h */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 82196CD8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82196CD8h case   12:*/		return 0x82196CDC;
		  /* 82196CDCh */ case   13:  		/* bl -171572 */
		/* 82196CDCh case   13:*/		regs.LR = 0x82196CE0; return 0x8216CEA8;
		/* 82196CDCh case   13:*/		return 0x82196CE0;
		  /* 82196CE0h */ case   14:  		/* mr R3, R31 */
		/* 82196CE0h case   14:*/		regs.R3 = regs.R31;
		/* 82196CE0h case   14:*/		return 0x82196CE4;
		  /* 82196CE4h */ case   15:  		/* addi R1, R1, 144 */
		/* 82196CE4h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82196CE4h case   15:*/		return 0x82196CE8;
		  /* 82196CE8h */ case   16:  		/* b -1071688 */
		/* 82196CE8h case   16:*/		return 0x820912A0;
		/* 82196CE8h case   16:*/		return 0x82196CEC;
		  /* 82196CECh */ case   17:  		/* nop */
		/* 82196CECh case   17:*/		cpu::op::nop();
		/* 82196CECh case   17:*/		return 0x82196CF0;
	}
	return 0x82196CF0;
} // Block from 82196CA8h-82196CF0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82196CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196CF0);
		  /* 82196CF0h */ case    0:  		/* mfspr R12, LR */
		/* 82196CF0h case    0:*/		regs.R12 = regs.LR;
		/* 82196CF0h case    0:*/		return 0x82196CF4;
		  /* 82196CF4h */ case    1:  		/* bl -1071780 */
		/* 82196CF4h case    1:*/		regs.LR = 0x82196CF8; return 0x82091250;
		/* 82196CF4h case    1:*/		return 0x82196CF8;
		  /* 82196CF8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82196CF8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82196CF8h case    2:*/		return 0x82196CFC;
		  /* 82196CFCh */ case    3:  		/* mr R26, R4 */
		/* 82196CFCh case    3:*/		regs.R26 = regs.R4;
		/* 82196CFCh case    3:*/		return 0x82196D00;
	}
	return 0x82196D00;
} // Block from 82196CF0h-82196D00h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82196D00h
// Function '?GetUnusedOperandInfo@Instruction@D3DXShader@@QAAPAUInstruction_UNUSED_OPERAND@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196D00);
		  /* 82196D00h */ case    0:  		/* lwz R4, <#[R5 + 28]> */
		/* 82196D00h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 82196D00h case    0:*/		return 0x82196D04;
		  /* 82196D04h */ case    1:  		/* mr R27, R5 */
		/* 82196D04h case    1:*/		regs.R27 = regs.R5;
		/* 82196D04h case    1:*/		return 0x82196D08;
		  /* 82196D08h */ case    2:  		/* mr R30, R6 */
		/* 82196D08h case    2:*/		regs.R30 = regs.R6;
		/* 82196D08h case    2:*/		return 0x82196D0C;
		  /* 82196D0Ch */ case    3:  		/* mr R28, R7 */
		/* 82196D0Ch case    3:*/		regs.R28 = regs.R7;
		/* 82196D0Ch case    3:*/		return 0x82196D10;
		  /* 82196D10h */ case    4:  		/* li R8, 4 */
		/* 82196D10h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82196D10h case    4:*/		return 0x82196D14;
		  /* 82196D14h */ case    5:  		/* li R7, 2 */
		/* 82196D14h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 82196D14h case    5:*/		return 0x82196D18;
		  /* 82196D18h */ case    6:  		/* li R6, 7 */
		/* 82196D18h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 82196D18h case    6:*/		return 0x82196D1C;
		  /* 82196D1Ch */ case    7:  		/* li R5, 0 */
		/* 82196D1Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82196D1Ch case    7:*/		return 0x82196D20;
		  /* 82196D20h */ case    8:  		/* mr R29, R3 */
		/* 82196D20h case    8:*/		regs.R29 = regs.R3;
		/* 82196D20h case    8:*/		return 0x82196D24;
		  /* 82196D24h */ case    9:  		/* bl 580724 */
		/* 82196D24h case    9:*/		regs.LR = 0x82196D28; return 0x82224998;
		/* 82196D24h case    9:*/		return 0x82196D28;
		  /* 82196D28h */ case   10:  		/* lwz R11, <#[R30 + 16]> */
		/* 82196D28h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82196D28h case   10:*/		return 0x82196D2C;
		  /* 82196D2Ch */ case   11:  		/* mr R31, R3 */
		/* 82196D2Ch case   11:*/		regs.R31 = regs.R3;
		/* 82196D2Ch case   11:*/		return 0x82196D30;
		  /* 82196D30h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 82196D30h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82196D30h case   12:*/		return 0x82196D34;
		  /* 82196D34h */ case   13:  		/* mr R4, R30 */
		/* 82196D34h case   13:*/		regs.R4 = regs.R30;
		/* 82196D34h case   13:*/		return 0x82196D38;
		  /* 82196D38h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 82196D38h case   14:*/		if ( regs.CR[6].eq ) { return 0x82196D4C;  }
		/* 82196D38h case   14:*/		return 0x82196D3C;
		  /* 82196D3Ch */ case   15:  		/* mr R3, R29 */
		/* 82196D3Ch case   15:*/		regs.R3 = regs.R29;
		/* 82196D3Ch case   15:*/		return 0x82196D40;
		  /* 82196D40h */ case   16:  		/* lwz R5, <#[R30 + 12]> */
		/* 82196D40h case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 82196D40h case   16:*/		return 0x82196D44;
		  /* 82196D44h */ case   17:  		/* bl -154708 */
		/* 82196D44h case   17:*/		regs.LR = 0x82196D48; return 0x821710F0;
		/* 82196D44h case   17:*/		return 0x82196D48;
	}
	return 0x82196D48;
} // Block from 82196D00h-82196D48h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82196D48h
// Function '?RecomputeConstantWriteMask@Instruction@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196D48);
		  /* 82196D48h */ case    0:  		/* mr R4, R3 */
		/* 82196D48h case    0:*/		regs.R4 = regs.R3;
		/* 82196D48h case    0:*/		return 0x82196D4C;
	}
	return 0x82196D4C;
} // Block from 82196D48h-82196D4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196D4C);
		  /* 82196D4Ch */ case    0:  		/* mr R3, R31 */
		/* 82196D4Ch case    0:*/		regs.R3 = regs.R31;
		/* 82196D4Ch case    0:*/		return 0x82196D50;
		  /* 82196D50h */ case    1:  		/* bl -125832 */
		/* 82196D50h case    1:*/		regs.LR = 0x82196D54; return 0x821781C8;
		/* 82196D50h case    1:*/		return 0x82196D54;
		  /* 82196D54h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 82196D54h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 82196D54h case    2:*/		return 0x82196D58;
		  /* 82196D58h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 82196D58h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 82196D58h case    3:*/		return 0x82196D5C;
		  /* 82196D5Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82196D5Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82196D5Ch case    4:*/		return 0x82196D60;
		  /* 82196D60h */ case    5:  		/* mr R4, R28 */
		/* 82196D60h case    5:*/		regs.R4 = regs.R28;
		/* 82196D60h case    5:*/		return 0x82196D64;
		  /* 82196D64h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82196D64h case    6:*/		if ( regs.CR[6].eq ) { return 0x82196D78;  }
		/* 82196D64h case    6:*/		return 0x82196D68;
		  /* 82196D68h */ case    7:  		/* mr R3, R29 */
		/* 82196D68h case    7:*/		regs.R3 = regs.R29;
		/* 82196D68h case    7:*/		return 0x82196D6C;
		  /* 82196D6Ch */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 82196D6Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 82196D6Ch case    8:*/		return 0x82196D70;
		  /* 82196D70h */ case    9:  		/* bl -154752 */
		/* 82196D70h case    9:*/		regs.LR = 0x82196D74; return 0x821710F0;
		/* 82196D70h case    9:*/		return 0x82196D74;
		  /* 82196D74h */ case   10:  		/* mr R4, R3 */
		/* 82196D74h case   10:*/		regs.R4 = regs.R3;
		/* 82196D74h case   10:*/		return 0x82196D78;
	}
	return 0x82196D78;
} // Block from 82196D4Ch-82196D78h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82196D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196D78);
		  /* 82196D78h */ case    0:  		/* mr R3, R31 */
		/* 82196D78h case    0:*/		regs.R3 = regs.R31;
		/* 82196D78h case    0:*/		return 0x82196D7C;
		  /* 82196D7Ch */ case    1:  		/* bl -125876 */
		/* 82196D7Ch case    1:*/		regs.LR = 0x82196D80; return 0x821781C8;
		/* 82196D7Ch case    1:*/		return 0x82196D80;
		  /* 82196D80h */ case    2:  		/* lwz R11, <#[R31 + 44]> */
		/* 82196D80h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82196D80h case    2:*/		return 0x82196D84;
		  /* 82196D84h */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 82196D84h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82196D84h case    3:*/		return 0x82196D88;
		  /* 82196D88h */ case    4:  		/* mr R6, R27 */
		/* 82196D88h case    4:*/		regs.R6 = regs.R27;
		/* 82196D88h case    4:*/		return 0x82196D8C;
		  /* 82196D8Ch */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 82196D8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82196D8Ch case    5:*/		return 0x82196D90;
		  /* 82196D90h */ case    6:  		/* mr R5, R26 */
		/* 82196D90h case    6:*/		regs.R5 = regs.R26;
		/* 82196D90h case    6:*/		return 0x82196D94;
		  /* 82196D94h */ case    7:  		/* mr R4, R31 */
		/* 82196D94h case    7:*/		regs.R4 = regs.R31;
		/* 82196D94h case    7:*/		return 0x82196D98;
		  /* 82196D98h */ case    8:  		/* mr R3, R29 */
		/* 82196D98h case    8:*/		regs.R3 = regs.R29;
		/* 82196D98h case    8:*/		return 0x82196D9C;
		  /* 82196D9Ch */ case    9:  		/* lwz R11, <#[R11]> */
		/* 82196D9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82196D9Ch case    9:*/		return 0x82196DA0;
		  /* 82196DA0h */ case   10:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 82196DA0h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 82196DA0h case   10:*/		return 0x82196DA4;
		  /* 82196DA4h */ case   11:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 82196DA4h case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 82196DA4h case   11:*/		return 0x82196DA8;
		  /* 82196DA8h */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 82196DA8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82196DA8h case   12:*/		return 0x82196DAC;
		  /* 82196DACh */ case   13:  		/* bl -171780 */
		/* 82196DACh case   13:*/		regs.LR = 0x82196DB0; return 0x8216CEA8;
		/* 82196DACh case   13:*/		return 0x82196DB0;
		  /* 82196DB0h */ case   14:  		/* mr R3, R31 */
		/* 82196DB0h case   14:*/		regs.R3 = regs.R31;
		/* 82196DB0h case   14:*/		return 0x82196DB4;
		  /* 82196DB4h */ case   15:  		/* addi R1, R1, 144 */
		/* 82196DB4h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82196DB4h case   15:*/		return 0x82196DB8;
		  /* 82196DB8h */ case   16:  		/* b -1071896 */
		/* 82196DB8h case   16:*/		return 0x820912A0;
		/* 82196DB8h case   16:*/		return 0x82196DBC;
		  /* 82196DBCh */ case   17:  		/* nop */
		/* 82196DBCh case   17:*/		cpu::op::nop();
		/* 82196DBCh case   17:*/		return 0x82196DC0;
	}
	return 0x82196DC0;
} // Block from 82196D78h-82196DC0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82196DC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196DC0);
		  /* 82196DC0h */ case    0:  		/* mfspr R12, LR */
		/* 82196DC0h case    0:*/		regs.R12 = regs.LR;
		/* 82196DC0h case    0:*/		return 0x82196DC4;
		  /* 82196DC4h */ case    1:  		/* bl -1071992 */
		/* 82196DC4h case    1:*/		regs.LR = 0x82196DC8; return 0x8209124C;
		/* 82196DC4h case    1:*/		return 0x82196DC8;
		  /* 82196DC8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82196DC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82196DC8h case    2:*/		return 0x82196DCC;
		  /* 82196DCCh */ case    3:  		/* mr R25, R4 */
		/* 82196DCCh case    3:*/		regs.R25 = regs.R4;
		/* 82196DCCh case    3:*/		return 0x82196DD0;
		  /* 82196DD0h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 82196DD0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 82196DD0h case    4:*/		return 0x82196DD4;
		  /* 82196DD4h */ case    5:  		/* mr R26, R5 */
		/* 82196DD4h case    5:*/		regs.R26 = regs.R5;
		/* 82196DD4h case    5:*/		return 0x82196DD8;
		  /* 82196DD8h */ case    6:  		/* mr R30, R6 */
		/* 82196DD8h case    6:*/		regs.R30 = regs.R6;
		/* 82196DD8h case    6:*/		return 0x82196DDC;
		  /* 82196DDCh */ case    7:  		/* mr R28, R7 */
		/* 82196DDCh case    7:*/		regs.R28 = regs.R7;
		/* 82196DDCh case    7:*/		return 0x82196DE0;
		  /* 82196DE0h */ case    8:  		/* mr R27, R8 */
		/* 82196DE0h case    8:*/		regs.R27 = regs.R8;
		/* 82196DE0h case    8:*/		return 0x82196DE4;
		  /* 82196DE4h */ case    9:  		/* li R8, 4 */
		/* 82196DE4h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82196DE4h case    9:*/		return 0x82196DE8;
		  /* 82196DE8h */ case   10:  		/* li R7, 3 */
		/* 82196DE8h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 82196DE8h case   10:*/		return 0x82196DEC;
		  /* 82196DECh */ case   11:  		/* li R6, 12 */
		/* 82196DECh case   11:*/		cpu::op::li<0>(regs,&regs.R6,0xC);
		/* 82196DECh case   11:*/		return 0x82196DF0;
		  /* 82196DF0h */ case   12:  		/* li R5, 0 */
		/* 82196DF0h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82196DF0h case   12:*/		return 0x82196DF4;
		  /* 82196DF4h */ case   13:  		/* mr R29, R3 */
		/* 82196DF4h case   13:*/		regs.R29 = regs.R3;
		/* 82196DF4h case   13:*/		return 0x82196DF8;
		  /* 82196DF8h */ case   14:  		/* bl 580512 */
		/* 82196DF8h case   14:*/		regs.LR = 0x82196DFC; return 0x82224998;
		/* 82196DF8h case   14:*/		return 0x82196DFC;
		  /* 82196DFCh */ case   15:  		/* lwz R11, <#[R30 + 16]> */
		/* 82196DFCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82196DFCh case   15:*/		return 0x82196E00;
		  /* 82196E00h */ case   16:  		/* mr R31, R3 */
		/* 82196E00h case   16:*/		regs.R31 = regs.R3;
		/* 82196E00h case   16:*/		return 0x82196E04;
		  /* 82196E04h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 82196E04h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82196E04h case   17:*/		return 0x82196E08;
		  /* 82196E08h */ case   18:  		/* mr R4, R30 */
		/* 82196E08h case   18:*/		regs.R4 = regs.R30;
		/* 82196E08h case   18:*/		return 0x82196E0C;
		  /* 82196E0Ch */ case   19:  		/* bc 12, CR6_EQ, 20 */
		/* 82196E0Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x82196E20;  }
		/* 82196E0Ch case   19:*/		return 0x82196E10;
		  /* 82196E10h */ case   20:  		/* mr R3, R29 */
		/* 82196E10h case   20:*/		regs.R3 = regs.R29;
		/* 82196E10h case   20:*/		return 0x82196E14;
		  /* 82196E14h */ case   21:  		/* lwz R5, <#[R30 + 12]> */
		/* 82196E14h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 82196E14h case   21:*/		return 0x82196E18;
		  /* 82196E18h */ case   22:  		/* bl -154920 */
		/* 82196E18h case   22:*/		regs.LR = 0x82196E1C; return 0x821710F0;
		/* 82196E18h case   22:*/		return 0x82196E1C;
		  /* 82196E1Ch */ case   23:  		/* mr R4, R3 */
		/* 82196E1Ch case   23:*/		regs.R4 = regs.R3;
		/* 82196E1Ch case   23:*/		return 0x82196E20;
	}
	return 0x82196E20;
} // Block from 82196DC0h-82196E20h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82196E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196E20);
		  /* 82196E20h */ case    0:  		/* mr R3, R31 */
		/* 82196E20h case    0:*/		regs.R3 = regs.R31;
		/* 82196E20h case    0:*/		return 0x82196E24;
		  /* 82196E24h */ case    1:  		/* bl -126044 */
		/* 82196E24h case    1:*/		regs.LR = 0x82196E28; return 0x821781C8;
		/* 82196E24h case    1:*/		return 0x82196E28;
	}
	return 0x82196E28;
} // Block from 82196E20h-82196E28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82196E28h
// Function '?SupportsInputDef_AfterCleanPhase@Instruction@D3DXShader@@QAA_NPAV12@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196E28);
		  /* 82196E28h */ case    0:  		/* stw R3, <#[R31 + 44]> */
		/* 82196E28h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 82196E28h case    0:*/		return 0x82196E2C;
		  /* 82196E2Ch */ case    1:  		/* lwz R11, <#[R28 + 16]> */
		/* 82196E2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 82196E2Ch case    1:*/		return 0x82196E30;
		  /* 82196E30h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82196E30h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82196E30h case    2:*/		return 0x82196E34;
		  /* 82196E34h */ case    3:  		/* mr R4, R28 */
		/* 82196E34h case    3:*/		regs.R4 = regs.R28;
		/* 82196E34h case    3:*/		return 0x82196E38;
		  /* 82196E38h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82196E38h case    4:*/		if ( regs.CR[6].eq ) { return 0x82196E4C;  }
		/* 82196E38h case    4:*/		return 0x82196E3C;
		  /* 82196E3Ch */ case    5:  		/* mr R3, R29 */
		/* 82196E3Ch case    5:*/		regs.R3 = regs.R29;
		/* 82196E3Ch case    5:*/		return 0x82196E40;
		  /* 82196E40h */ case    6:  		/* lwz R5, <#[R28 + 12]> */
		/* 82196E40h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 82196E40h case    6:*/		return 0x82196E44;
		  /* 82196E44h */ case    7:  		/* bl -154964 */
		/* 82196E44h case    7:*/		regs.LR = 0x82196E48; return 0x821710F0;
		/* 82196E44h case    7:*/		return 0x82196E48;
		  /* 82196E48h */ case    8:  		/* mr R4, R3 */
		/* 82196E48h case    8:*/		regs.R4 = regs.R3;
		/* 82196E48h case    8:*/		return 0x82196E4C;
	}
	return 0x82196E4C;
} // Block from 82196E28h-82196E4Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82196E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196E4C);
		  /* 82196E4Ch */ case    0:  		/* mr R3, R31 */
		/* 82196E4Ch case    0:*/		regs.R3 = regs.R31;
		/* 82196E4Ch case    0:*/		return 0x82196E50;
		  /* 82196E50h */ case    1:  		/* bl -126088 */
		/* 82196E50h case    1:*/		regs.LR = 0x82196E54; return 0x821781C8;
		/* 82196E50h case    1:*/		return 0x82196E54;
		  /* 82196E54h */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 82196E54h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82196E54h case    2:*/		return 0x82196E58;
		  /* 82196E58h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 82196E58h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 82196E58h case    3:*/		return 0x82196E5C;
		  /* 82196E5Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82196E5Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82196E5Ch case    4:*/		return 0x82196E60;
		  /* 82196E60h */ case    5:  		/* mr R4, R27 */
		/* 82196E60h case    5:*/		regs.R4 = regs.R27;
		/* 82196E60h case    5:*/		return 0x82196E64;
		  /* 82196E64h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 82196E64h case    6:*/		if ( regs.CR[6].eq ) { return 0x82196E78;  }
		/* 82196E64h case    6:*/		return 0x82196E68;
		  /* 82196E68h */ case    7:  		/* mr R3, R29 */
		/* 82196E68h case    7:*/		regs.R3 = regs.R29;
		/* 82196E68h case    7:*/		return 0x82196E6C;
		  /* 82196E6Ch */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 82196E6Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 82196E6Ch case    8:*/		return 0x82196E70;
		  /* 82196E70h */ case    9:  		/* bl -155008 */
		/* 82196E70h case    9:*/		regs.LR = 0x82196E74; return 0x821710F0;
		/* 82196E70h case    9:*/		return 0x82196E74;
		  /* 82196E74h */ case   10:  		/* mr R4, R3 */
		/* 82196E74h case   10:*/		regs.R4 = regs.R3;
		/* 82196E74h case   10:*/		return 0x82196E78;
	}
	return 0x82196E78;
} // Block from 82196E4Ch-82196E78h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82196E78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196E78);
		  /* 82196E78h */ case    0:  		/* mr R3, R31 */
		/* 82196E78h case    0:*/		regs.R3 = regs.R31;
		/* 82196E78h case    0:*/		return 0x82196E7C;
		  /* 82196E7Ch */ case    1:  		/* bl -126132 */
		/* 82196E7Ch case    1:*/		regs.LR = 0x82196E80; return 0x821781C8;
		/* 82196E7Ch case    1:*/		return 0x82196E80;
		  /* 82196E80h */ case    2:  		/* lwz R11, <#[R31 + 44]> */
		/* 82196E80h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82196E80h case    2:*/		return 0x82196E84;
		  /* 82196E84h */ case    3:  		/* stw R3, <#[R31 + 52]> */
		/* 82196E84h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 82196E84h case    3:*/		return 0x82196E88;
		  /* 82196E88h */ case    4:  		/* mr R6, R26 */
		/* 82196E88h case    4:*/		regs.R6 = regs.R26;
		/* 82196E88h case    4:*/		return 0x82196E8C;
		  /* 82196E8Ch */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 82196E8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82196E8Ch case    5:*/		return 0x82196E90;
		  /* 82196E90h */ case    6:  		/* mr R5, R25 */
		/* 82196E90h case    6:*/		regs.R5 = regs.R25;
		/* 82196E90h case    6:*/		return 0x82196E94;
		  /* 82196E94h */ case    7:  		/* mr R4, R31 */
		/* 82196E94h case    7:*/		regs.R4 = regs.R31;
		/* 82196E94h case    7:*/		return 0x82196E98;
		  /* 82196E98h */ case    8:  		/* mr R3, R29 */
		/* 82196E98h case    8:*/		regs.R3 = regs.R29;
		/* 82196E98h case    8:*/		return 0x82196E9C;
		  /* 82196E9Ch */ case    9:  		/* lwz R11, <#[R11]> */
		/* 82196E9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82196E9Ch case    9:*/		return 0x82196EA0;
		  /* 82196EA0h */ case   10:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 82196EA0h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 82196EA0h case   10:*/		return 0x82196EA4;
		  /* 82196EA4h */ case   11:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 82196EA4h case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 82196EA4h case   11:*/		return 0x82196EA8;
		  /* 82196EA8h */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 82196EA8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82196EA8h case   12:*/		return 0x82196EAC;
		  /* 82196EACh */ case   13:  		/* bl -172036 */
		/* 82196EACh case   13:*/		regs.LR = 0x82196EB0; return 0x8216CEA8;
		/* 82196EACh case   13:*/		return 0x82196EB0;
		  /* 82196EB0h */ case   14:  		/* mr R3, R31 */
		/* 82196EB0h case   14:*/		regs.R3 = regs.R31;
		/* 82196EB0h case   14:*/		return 0x82196EB4;
		  /* 82196EB4h */ case   15:  		/* addi R1, R1, 144 */
		/* 82196EB4h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82196EB4h case   15:*/		return 0x82196EB8;
		  /* 82196EB8h */ case   16:  		/* b -1072156 */
		/* 82196EB8h case   16:*/		return 0x8209129C;
		/* 82196EB8h case   16:*/		return 0x82196EBC;
		  /* 82196EBCh */ case   17:  		/* nop */
		/* 82196EBCh case   17:*/		cpu::op::nop();
		/* 82196EBCh case   17:*/		return 0x82196EC0;
		  /* 82196EC0h */ case   18:  		/* li R5, 0 */
		/* 82196EC0h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82196EC0h case   18:*/		return 0x82196EC4;
		  /* 82196EC4h */ case   19:  		/* b -204428 */
		/* 82196EC4h case   19:*/		return 0x82165038;
		/* 82196EC4h case   19:*/		return 0x82196EC8;
	}
	return 0x82196EC8;
} // Block from 82196E78h-82196EC8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82196EC8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196EC8);
		  /* 82196EC8h */ case    0:  		/* mfspr R12, LR */
		/* 82196EC8h case    0:*/		regs.R12 = regs.LR;
		/* 82196EC8h case    0:*/		return 0x82196ECC;
		  /* 82196ECCh */ case    1:  		/* bl -1072300 */
		/* 82196ECCh case    1:*/		regs.LR = 0x82196ED0; return 0x82091220;
		/* 82196ECCh case    1:*/		return 0x82196ED0;
		  /* 82196ED0h */ case    2:  		/* addi R12, R1, -152 */
		/* 82196ED0h case    2:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFF68);
		/* 82196ED0h case    2:*/		return 0x82196ED4;
		  /* 82196ED4h */ case    3:  		/* bl -1071812 */
		/* 82196ED4h case    3:*/		regs.LR = 0x82196ED8; return 0x82091410;
		/* 82196ED4h case    3:*/		return 0x82196ED8;
		  /* 82196ED8h */ case    4:  		/* stwu R1, <#[R1 - 464]> */
		/* 82196ED8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE30);
		/* 82196ED8h case    4:*/		return 0x82196EDC;
		  /* 82196EDCh */ case    5:  		/* lwz R11, <#[R3 + 40]> */
		/* 82196EDCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82196EDCh case    5:*/		return 0x82196EE0;
		  /* 82196EE0h */ case    6:  		/* li R18, 0 */
		/* 82196EE0h case    6:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 82196EE0h case    6:*/		return 0x82196EE4;
		  /* 82196EE4h */ case    7:  		/* stw R3, <#[R1 + 484]> */
		/* 82196EE4h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000001E4) );
		/* 82196EE4h case    7:*/		return 0x82196EE8;
		  /* 82196EE8h */ case    8:  		/* mr R21, R3 */
		/* 82196EE8h case    8:*/		regs.R21 = regs.R3;
		/* 82196EE8h case    8:*/		return 0x82196EEC;
		  /* 82196EECh */ case    9:  		/* li R19, 1 */
		/* 82196EECh case    9:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 82196EECh case    9:*/		return 0x82196EF0;
		  /* 82196EF0h */ case   10:  		/* stb R18, <#[R1 + 84]> */
		/* 82196EF0h case   10:*/		cpu::mem::store8( regs, regs.R18, (uint32)(regs.R1 + 0x00000054) );
		/* 82196EF0h case   10:*/		return 0x82196EF4;
		  /* 82196EF4h */ case   11:  		/* rlwinm. R11, R11, 0, 10, 10 */
		/* 82196EF4h case   11:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R11,regs.R11);
		/* 82196EF4h case   11:*/		return 0x82196EF8;
		  /* 82196EF8h */ case   12:  		/* bc 12, CR0_EQ, 1360 */
		/* 82196EF8h case   12:*/		if ( regs.CR[0].eq ) { return 0x82197448;  }
		/* 82196EF8h case   12:*/		return 0x82196EFC;
		  /* 82196EFCh */ case   13:  		/* lwz R11, <#[R3 + 4]> */
		/* 82196EFCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82196EFCh case   13:*/		return 0x82196F00;
		  /* 82196F00h */ case   14:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82196F00h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82196F00h case   14:*/		return 0x82196F04;
		  /* 82196F04h */ case   15:  		/* bc 4, CR0_EQ, 1348 */
		/* 82196F04h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82197448;  }
		/* 82196F04h case   15:*/		return 0x82196F08;
		  /* 82196F08h */ case   16:  		/* mr R26, R11 */
		/* 82196F08h case   16:*/		regs.R26 = regs.R11;
		/* 82196F08h case   16:*/		return 0x82196F0C;
		  /* 82196F0Ch */ case   17:  		/* cmplwi CR0, R11, 0 */
		/* 82196F0Ch case   17:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82196F0Ch case   17:*/		return 0x82196F10;
		  /* 82196F10h */ case   18:  		/* bc 12, CR0_EQ, 1336 */
		/* 82196F10h case   18:*/		if ( regs.CR[0].eq ) { return 0x82197448;  }
		/* 82196F10h case   18:*/		return 0x82196F14;
		  /* 82196F14h */ case   19:  		/* lwz R11, <#[R26 + 28]> */
		/* 82196F14h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000001C) );
		/* 82196F14h case   19:*/		return 0x82196F18;
	}
	return 0x82196F18;
} // Block from 82196EC8h-82196F18h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82196F18h
// Function '?CanUseMulAdd@Compiler@D3DXShader@@AAA_NPAVInstruction@2@0PAVDependency@2@1PAUPeepMulAddState@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196F18);
		  /* 82196F18h */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82196F18h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82196F18h case    0:*/		return 0x82196F1C;
		  /* 82196F1Ch */ case    1:  		/* bc 4, CR0_EQ, 1296 */
		/* 82196F1Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219742C;  }
		/* 82196F1Ch case    1:*/		return 0x82196F20;
		  /* 82196F20h */ case    2:  		/* mr R30, R11 */
		/* 82196F20h case    2:*/		regs.R30 = regs.R11;
		/* 82196F20h case    2:*/		return 0x82196F24;
		  /* 82196F24h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 82196F24h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82196F24h case    3:*/		return 0x82196F28;
		  /* 82196F28h */ case    4:  		/* bc 12, CR0_EQ, 1284 */
		/* 82196F28h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219742C;  }
		/* 82196F28h case    4:*/		return 0x82196F2C;
		  /* 82196F2Ch */ case    5:  		/* lwz R11, <#[R30 + 8]> */
		/* 82196F2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82196F2Ch case    5:*/		return 0x82196F30;
		  /* 82196F30h */ case    6:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 82196F30h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 82196F30h case    6:*/		return 0x82196F34;
		  /* 82196F34h */ case    7:  		/* cmplwi CR6, R10, 13440 */
		/* 82196F34h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003480);
		/* 82196F34h case    7:*/		return 0x82196F38;
		  /* 82196F38h */ case    8:  		/* bc 4, CR6_EQ, 1240 */
		/* 82196F38h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82197410;  }
		/* 82196F38h case    8:*/		return 0x82196F3C;
		  /* 82196F3Ch */ case    9:  		/* li R10, 3 */
		/* 82196F3Ch case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 82196F3Ch case    9:*/		return 0x82196F40;
		  /* 82196F40h */ case   10:  		/* rlwimi R11, R10, 9, 18, 24 */
		/* 82196F40h case   10:*/		cpu::op::rlwimi<0,9,18,24>(regs,&regs.R11,regs.R10);
		/* 82196F40h case   10:*/		return 0x82196F44;
		  /* 82196F44h */ case   11:  		/* stw R11, <#[R30 + 8]> */
		/* 82196F44h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82196F44h case   11:*/		return 0x82196F48;
		  /* 82196F48h */ case   12:  		/* lwz R29, <#[R30 + 48]> */
		/* 82196F48h case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000030) );
		/* 82196F48h case   12:*/		return 0x82196F4C;
		  /* 82196F4Ch */ case   13:  		/* lwz R28, <#[R30 + 52]> */
		/* 82196F4Ch case   13:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000034) );
		/* 82196F4Ch case   13:*/		return 0x82196F50;
		  /* 82196F50h */ case   14:  		/* lwz R27, <#[R30 + 44]> */
		/* 82196F50h case   14:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R30 + 0x0000002C) );
		/* 82196F50h case   14:*/		return 0x82196F54;
		  /* 82196F54h */ case   15:  		/* lwz R11, <#[R29 + 12]> */
		/* 82196F54h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82196F54h case   15:*/		return 0x82196F58;
		  /* 82196F58h */ case   16:  		/* stw R11, <#[R1 + 96]> */
		/* 82196F58h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82196F58h case   16:*/		return 0x82196F5C;
		  /* 82196F5Ch */ case   17:  		/* lwz R10, <#[R28 + 12]> */
		/* 82196F5Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000000C) );
		/* 82196F5Ch case   17:*/		return 0x82196F60;
		  /* 82196F60h */ case   18:  		/* stw R10, <#[R1 + 104]> */
		/* 82196F60h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 82196F60h case   18:*/		return 0x82196F64;
		  /* 82196F64h */ case   19:  		/* lwz R11, <#[R11 + 8]> */
		/* 82196F64h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82196F64h case   19:*/		return 0x82196F68;
		  /* 82196F68h */ case   20:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82196F68h case   20:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82196F68h case   20:*/		return 0x82196F6C;
		  /* 82196F6Ch */ case   21:  		/* cmplwi CR6, R11, 125 */
		/* 82196F6Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82196F6Ch case   21:*/		return 0x82196F70;
		  /* 82196F70h */ case   22:  		/* bc 12, CR6_EQ, 16 */
		/* 82196F70h case   22:*/		if ( regs.CR[6].eq ) { return 0x82196F80;  }
		/* 82196F70h case   22:*/		return 0x82196F74;
		  /* 82196F74h */ case   23:  		/* cmplwi CR6, R11, 124 */
		/* 82196F74h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82196F74h case   23:*/		return 0x82196F78;
		  /* 82196F78h */ case   24:  		/* mr R11, R18 */
		/* 82196F78h case   24:*/		regs.R11 = regs.R18;
		/* 82196F78h case   24:*/		return 0x82196F7C;
		  /* 82196F7Ch */ case   25:  		/* bc 4, CR6_EQ, 8 */
		/* 82196F7Ch case   25:*/		if ( !regs.CR[6].eq ) { return 0x82196F84;  }
		/* 82196F7Ch case   25:*/		return 0x82196F80;
	}
	return 0x82196F80;
} // Block from 82196F18h-82196F80h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82196F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196F80);
		  /* 82196F80h */ case    0:  		/* mr R11, R19 */
		/* 82196F80h case    0:*/		regs.R11 = regs.R19;
		/* 82196F80h case    0:*/		return 0x82196F84;
	}
	return 0x82196F84;
} // Block from 82196F80h-82196F84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196F84);
		  /* 82196F84h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82196F84h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82196F84h case    0:*/		return 0x82196F88;
		  /* 82196F88h */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 82196F88h case    1:*/		if ( regs.CR[0].eq ) { return 0x82196FB4;  }
		/* 82196F88h case    1:*/		return 0x82196F8C;
		  /* 82196F8Ch */ case    2:  		/* lwz R11, <#[R10 + 8]> */
		/* 82196F8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82196F8Ch case    2:*/		return 0x82196F90;
		  /* 82196F90h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82196F90h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82196F90h case    3:*/		return 0x82196F94;
		  /* 82196F94h */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 82196F94h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82196F94h case    4:*/		return 0x82196F98;
		  /* 82196F98h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 82196F98h case    5:*/		if ( regs.CR[6].eq ) { return 0x82196FA8;  }
		/* 82196F98h case    5:*/		return 0x82196F9C;
		  /* 82196F9Ch */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 82196F9Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82196F9Ch case    6:*/		return 0x82196FA0;
		  /* 82196FA0h */ case    7:  		/* mr R11, R18 */
		/* 82196FA0h case    7:*/		regs.R11 = regs.R18;
		/* 82196FA0h case    7:*/		return 0x82196FA4;
		  /* 82196FA4h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 82196FA4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82196FAC;  }
		/* 82196FA4h case    8:*/		return 0x82196FA8;
	}
	return 0x82196FA8;
} // Block from 82196F84h-82196FA8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82196FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196FA8);
		  /* 82196FA8h */ case    0:  		/* mr R11, R19 */
		/* 82196FA8h case    0:*/		regs.R11 = regs.R19;
		/* 82196FA8h case    0:*/		return 0x82196FAC;
	}
	return 0x82196FAC;
} // Block from 82196FA8h-82196FACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82196FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196FAC);
		  /* 82196FACh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82196FACh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82196FACh case    0:*/		return 0x82196FB0;
		  /* 82196FB0h */ case    1:  		/* bc 4, CR0_EQ, 1120 */
		/* 82196FB0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82197410;  }
		/* 82196FB0h case    1:*/		return 0x82196FB4;
	}
	return 0x82196FB4;
} // Block from 82196FACh-82196FB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82196FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82196FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82196FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82196FB4);
		  /* 82196FB4h */ case    0:  		/* addi R7, R1, 132 */
		/* 82196FB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x84);
		/* 82196FB4h case    0:*/		return 0x82196FB8;
		  /* 82196FB8h */ case    1:  		/* addi R6, R1, 124 */
		/* 82196FB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x7C);
		/* 82196FB8h case    1:*/		return 0x82196FBC;
		  /* 82196FBCh */ case    2:  		/* addi R5, R1, 112 */
		/* 82196FBCh case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 82196FBCh case    2:*/		return 0x82196FC0;
		  /* 82196FC0h */ case    3:  		/* mr R4, R27 */
		/* 82196FC0h case    3:*/		regs.R4 = regs.R27;
		/* 82196FC0h case    3:*/		return 0x82196FC4;
		  /* 82196FC4h */ case    4:  		/* mr R3, R21 */
		/* 82196FC4h case    4:*/		regs.R3 = regs.R21;
		/* 82196FC4h case    4:*/		return 0x82196FC8;
		  /* 82196FC8h */ case    5:  		/* bl 623408 */
		/* 82196FC8h case    5:*/		regs.LR = 0x82196FCC; return 0x8222F2F8;
		/* 82196FC8h case    5:*/		return 0x82196FCC;
		  /* 82196FCCh */ case    6:  		/* addi R7, R1, 116 */
		/* 82196FCCh case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x74);
		/* 82196FCCh case    6:*/		return 0x82196FD0;
		  /* 82196FD0h */ case    7:  		/* addi R6, R1, 120 */
		/* 82196FD0h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x78);
		/* 82196FD0h case    7:*/		return 0x82196FD4;
		  /* 82196FD4h */ case    8:  		/* addi R5, R1, 96 */
		/* 82196FD4h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82196FD4h case    8:*/		return 0x82196FD8;
		  /* 82196FD8h */ case    9:  		/* mr R4, R29 */
		/* 82196FD8h case    9:*/		regs.R4 = regs.R29;
		/* 82196FD8h case    9:*/		return 0x82196FDC;
		  /* 82196FDCh */ case   10:  		/* mr R3, R21 */
		/* 82196FDCh case   10:*/		regs.R3 = regs.R21;
		/* 82196FDCh case   10:*/		return 0x82196FE0;
		  /* 82196FE0h */ case   11:  		/* bl 623384 */
		/* 82196FE0h case   11:*/		regs.LR = 0x82196FE4; return 0x8222F2F8;
		/* 82196FE0h case   11:*/		return 0x82196FE4;
		  /* 82196FE4h */ case   12:  		/* lwz R11, <#[R1 + 112]> */
		/* 82196FE4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82196FE4h case   12:*/		return 0x82196FE8;
		  /* 82196FE8h */ case   13:  		/* lwz R11, <#[R11 + 8]> */
		/* 82196FE8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82196FE8h case   13:*/		return 0x82196FEC;
		  /* 82196FECh */ case   14:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82196FECh case   14:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82196FECh case   14:*/		return 0x82196FF0;
		  /* 82196FF0h */ case   15:  		/* cmplwi CR6, R11, 125 */
		/* 82196FF0h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82196FF0h case   15:*/		return 0x82196FF4;
		  /* 82196FF4h */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 82196FF4h case   16:*/		if ( regs.CR[6].eq ) { return 0x82197004;  }
		/* 82196FF4h case   16:*/		return 0x82196FF8;
		  /* 82196FF8h */ case   17:  		/* cmplwi CR6, R11, 124 */
		/* 82196FF8h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82196FF8h case   17:*/		return 0x82196FFC;
		  /* 82196FFCh */ case   18:  		/* mr R11, R18 */
		/* 82196FFCh case   18:*/		regs.R11 = regs.R18;
		/* 82196FFCh case   18:*/		return 0x82197000;
		  /* 82197000h */ case   19:  		/* bc 4, CR6_EQ, 8 */
		/* 82197000h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82197008;  }
		/* 82197000h case   19:*/		return 0x82197004;
	}
	return 0x82197004;
} // Block from 82196FB4h-82197004h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82197004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197004);
		  /* 82197004h */ case    0:  		/* mr R11, R19 */
		/* 82197004h case    0:*/		regs.R11 = regs.R19;
		/* 82197004h case    0:*/		return 0x82197008;
	}
	return 0x82197008;
} // Block from 82197004h-82197008h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197008);
		  /* 82197008h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82197008h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82197008h case    0:*/		return 0x8219700C;
		  /* 8219700Ch */ case    1:  		/* bc 4, CR0_EQ, 48 */
		/* 8219700Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219703C;  }
		/* 8219700Ch case    1:*/		return 0x82197010;
		  /* 82197010h */ case    2:  		/* lwz R11, <#[R1 + 96]> */
		/* 82197010h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82197010h case    2:*/		return 0x82197014;
		  /* 82197014h */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 82197014h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82197014h case    3:*/		return 0x82197018;
		  /* 82197018h */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82197018h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82197018h case    4:*/		return 0x8219701C;
		  /* 8219701Ch */ case    5:  		/* cmplwi CR6, R11, 125 */
		/* 8219701Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219701Ch case    5:*/		return 0x82197020;
		  /* 82197020h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82197020h case    6:*/		if ( regs.CR[6].eq ) { return 0x82197030;  }
		/* 82197020h case    6:*/		return 0x82197024;
		  /* 82197024h */ case    7:  		/* cmplwi CR6, R11, 124 */
		/* 82197024h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82197024h case    7:*/		return 0x82197028;
		  /* 82197028h */ case    8:  		/* mr R11, R18 */
		/* 82197028h case    8:*/		regs.R11 = regs.R18;
		/* 82197028h case    8:*/		return 0x8219702C;
		  /* 8219702Ch */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 8219702Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82197034;  }
		/* 8219702Ch case    9:*/		return 0x82197030;
	}
	return 0x82197030;
} // Block from 82197008h-82197030h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82197030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197030);
		  /* 82197030h */ case    0:  		/* mr R11, R19 */
		/* 82197030h case    0:*/		regs.R11 = regs.R19;
		/* 82197030h case    0:*/		return 0x82197034;
	}
	return 0x82197034;
} // Block from 82197030h-82197034h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197034);
		  /* 82197034h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82197034h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82197034h case    0:*/		return 0x82197038;
		  /* 82197038h */ case    1:  		/* bc 12, CR0_EQ, 1532 */
		/* 82197038h case    1:*/		if ( regs.CR[0].eq ) { return 0x82197634;  }
		/* 82197038h case    1:*/		return 0x8219703C;
	}
	return 0x8219703C;
} // Block from 82197034h-8219703Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219703Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219703C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219703C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219703C);
		  /* 8219703Ch */ case    0:  		/* addi R7, R1, 128 */
		/* 8219703Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x80);
		/* 8219703Ch case    0:*/		return 0x82197040;
		  /* 82197040h */ case    1:  		/* addi R6, R1, 136 */
		/* 82197040h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x88);
		/* 82197040h case    1:*/		return 0x82197044;
		  /* 82197044h */ case    2:  		/* addi R5, R1, 104 */
		/* 82197044h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x68);
		/* 82197044h case    2:*/		return 0x82197048;
		  /* 82197048h */ case    3:  		/* mr R4, R28 */
		/* 82197048h case    3:*/		regs.R4 = regs.R28;
		/* 82197048h case    3:*/		return 0x8219704C;
		  /* 8219704Ch */ case    4:  		/* mr R3, R21 */
		/* 8219704Ch case    4:*/		regs.R3 = regs.R21;
		/* 8219704Ch case    4:*/		return 0x82197050;
		  /* 82197050h */ case    5:  		/* bl 623272 */
		/* 82197050h case    5:*/		regs.LR = 0x82197054; return 0x8222F2F8;
		/* 82197050h case    5:*/		return 0x82197054;
		  /* 82197054h */ case    6:  		/* lwz R4, <#[R1 + 104]> */
		/* 82197054h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 82197054h case    6:*/		return 0x82197058;
		  /* 82197058h */ case    7:  		/* lwz R11, <#[R4 + 8]> */
		/* 82197058h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82197058h case    7:*/		return 0x8219705C;
		  /* 8219705Ch */ case    8:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219705Ch case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219705Ch case    8:*/		return 0x82197060;
		  /* 82197060h */ case    9:  		/* cmplwi CR6, R11, 125 */
		/* 82197060h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82197060h case    9:*/		return 0x82197064;
		  /* 82197064h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 82197064h case   10:*/		if ( regs.CR[6].eq ) { return 0x82197074;  }
		/* 82197064h case   10:*/		return 0x82197068;
		  /* 82197068h */ case   11:  		/* cmplwi CR6, R11, 124 */
		/* 82197068h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82197068h case   11:*/		return 0x8219706C;
		  /* 8219706Ch */ case   12:  		/* mr R11, R18 */
		/* 8219706Ch case   12:*/		regs.R11 = regs.R18;
		/* 8219706Ch case   12:*/		return 0x82197070;
		  /* 82197070h */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 82197070h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82197078;  }
		/* 82197070h case   13:*/		return 0x82197074;
	}
	return 0x82197074;
} // Block from 8219703Ch-82197074h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82197074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197074);
		  /* 82197074h */ case    0:  		/* mr R11, R19 */
		/* 82197074h case    0:*/		regs.R11 = regs.R19;
		/* 82197074h case    0:*/		return 0x82197078;
	}
	return 0x82197078;
} // Block from 82197074h-82197078h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197078);
		  /* 82197078h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82197078h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82197078h case    0:*/		return 0x8219707C;
		  /* 8219707Ch */ case    1:  		/* bc 12, CR0_EQ, 1476 */
		/* 8219707Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82197640;  }
		/* 8219707Ch case    1:*/		return 0x82197080;
		  /* 82197080h */ case    2:  		/* stw R28, <#[R1 + 92]> */
		/* 82197080h case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 82197080h case    2:*/		return 0x82197084;
		  /* 82197084h */ case    3:  		/* stw R29, <#[R1 + 80]> */
		/* 82197084h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 82197084h case    3:*/		return 0x82197088;
		  /* 82197088h */ case    4:  		/* lwz R11, <#[R28 + 12]> */
		/* 82197088h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 82197088h case    4:*/		return 0x8219708C;
		  /* 8219708Ch */ case    5:  		/* stw R27, <#[R1 + 88]> */
		/* 8219708Ch case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000058) );
		/* 8219708Ch case    5:*/		return 0x82197090;
		  /* 82197090h */ case    6:  		/* lwz R11, <#[R11 + 8]> */
		/* 82197090h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82197090h case    6:*/		return 0x82197094;
		  /* 82197094h */ case    7:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82197094h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82197094h case    7:*/		return 0x82197098;
		  /* 82197098h */ case    8:  		/* cmplwi CR6, R11, 125 */
		/* 82197098h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82197098h case    8:*/		return 0x8219709C;
		  /* 8219709Ch */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 8219709Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x821970AC;  }
		/* 8219709Ch case    9:*/		return 0x821970A0;
		  /* 821970A0h */ case   10:  		/* cmplwi CR6, R11, 124 */
		/* 821970A0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821970A0h case   10:*/		return 0x821970A4;
		  /* 821970A4h */ case   11:  		/* mr R11, R18 */
		/* 821970A4h case   11:*/		regs.R11 = regs.R18;
		/* 821970A4h case   11:*/		return 0x821970A8;
		  /* 821970A8h */ case   12:  		/* bc 4, CR6_EQ, 8 */
		/* 821970A8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821970B0;  }
		/* 821970A8h case   12:*/		return 0x821970AC;
	}
	return 0x821970AC;
} // Block from 82197078h-821970ACh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821970ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821970AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821970AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821970AC);
		  /* 821970ACh */ case    0:  		/* mr R11, R19 */
		/* 821970ACh case    0:*/		regs.R11 = regs.R19;
		/* 821970ACh case    0:*/		return 0x821970B0;
	}
	return 0x821970B0;
} // Block from 821970ACh-821970B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821970B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821970B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821970B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821970B0);
		  /* 821970B0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821970B0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821970B0h case    0:*/		return 0x821970B4;
		  /* 821970B4h */ case    1:  		/* bc 4, CR0_EQ, 68 */
		/* 821970B4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821970F8;  }
		/* 821970B4h case    1:*/		return 0x821970B8;
		  /* 821970B8h */ case    2:  		/* lwz R11, <#[R28]> */
		/* 821970B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821970B8h case    2:*/		return 0x821970BC;
		  /* 821970BCh */ case    3:  		/* mr R3, R21 */
		/* 821970BCh case    3:*/		regs.R3 = regs.R21;
		/* 821970BCh case    3:*/		return 0x821970C0;
		  /* 821970C0h */ case    4:  		/* lwz R25, <#[R1 + 128]> */
		/* 821970C0h case    4:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000080) );
		/* 821970C0h case    4:*/		return 0x821970C4;
		  /* 821970C4h */ case    5:  		/* lwz R24, <#[R1 + 136]> */
		/* 821970C4h case    5:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000088) );
		/* 821970C4h case    5:*/		return 0x821970C8;
		  /* 821970C8h */ case    6:  		/* rlwinm R23, R11, 7, 29, 31 */
		/* 821970C8h case    6:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R23,regs.R11);
		/* 821970C8h case    6:*/		return 0x821970CC;
		  /* 821970CCh */ case    7:  		/* bl -127180 */
		/* 821970CCh case    7:*/		regs.LR = 0x821970D0; return 0x82178000;
		/* 821970CCh case    7:*/		return 0x821970D0;
		  /* 821970D0h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 821970D0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821970D0h case    8:*/		return 0x821970D4;
		  /* 821970D4h */ case    9:  		/* mr R4, R25 */
		/* 821970D4h case    9:*/		regs.R4 = regs.R25;
		/* 821970D4h case    9:*/		return 0x821970D8;
		  /* 821970D8h */ case   10:  		/* rlwimi R11, R23, 25, 4, 6 */
		/* 821970D8h case   10:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R23);
		/* 821970D8h case   10:*/		return 0x821970DC;
		  /* 821970DCh */ case   11:  		/* mr R31, R3 */
		/* 821970DCh case   11:*/		regs.R31 = regs.R3;
		/* 821970DCh case   11:*/		return 0x821970E0;
		  /* 821970E0h */ case   12:  		/* stw R11, <#[R3]> */
		/* 821970E0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821970E0h case   12:*/		return 0x821970E4;
		  /* 821970E4h */ case   13:  		/* bl -128548 */
		/* 821970E4h case   13:*/		regs.LR = 0x821970E8; return 0x82177AC0;
		/* 821970E4h case   13:*/		return 0x821970E8;
		  /* 821970E8h */ case   14:  		/* lwz R11, <#[R31]> */
		/* 821970E8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821970E8h case   14:*/		return 0x821970EC;
		  /* 821970ECh */ case   15:  		/* rlwimi R11, R24, 5, 19, 26 */
		/* 821970ECh case   15:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R24);
		/* 821970ECh case   15:*/		return 0x821970F0;
		  /* 821970F0h */ case   16:  		/* stw R11, <#[R31]> */
		/* 821970F0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821970F0h case   16:*/		return 0x821970F4;
		  /* 821970F4h */ case   17:  		/* stw R31, <#[R1 + 92]> */
		/* 821970F4h case   17:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000005C) );
		/* 821970F4h case   17:*/		return 0x821970F8;
	}
	return 0x821970F8;
} // Block from 821970B0h-821970F8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821970F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821970F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821970F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821970F8);
		  /* 821970F8h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 821970F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 821970F8h case    0:*/		return 0x821970FC;
		  /* 821970FCh */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 821970FCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821970FCh case    1:*/		return 0x82197100;
		  /* 82197100h */ case    2:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82197100h case    2:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82197100h case    2:*/		return 0x82197104;
		  /* 82197104h */ case    3:  		/* cmplwi CR6, R11, 125 */
		/* 82197104h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82197104h case    3:*/		return 0x82197108;
		  /* 82197108h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82197108h case    4:*/		if ( regs.CR[6].eq ) { return 0x82197118;  }
		/* 82197108h case    4:*/		return 0x8219710C;
		  /* 8219710Ch */ case    5:  		/* cmplwi CR6, R11, 124 */
		/* 8219710Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219710Ch case    5:*/		return 0x82197110;
		  /* 82197110h */ case    6:  		/* mr R11, R18 */
		/* 82197110h case    6:*/		regs.R11 = regs.R18;
		/* 82197110h case    6:*/		return 0x82197114;
		  /* 82197114h */ case    7:  		/* bc 4, CR6_EQ, 8 */
		/* 82197114h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8219711C;  }
		/* 82197114h case    7:*/		return 0x82197118;
	}
	return 0x82197118;
} // Block from 821970F8h-82197118h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82197118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197118);
		  /* 82197118h */ case    0:  		/* mr R11, R19 */
		/* 82197118h case    0:*/		regs.R11 = regs.R19;
		/* 82197118h case    0:*/		return 0x8219711C;
	}
	return 0x8219711C;
} // Block from 82197118h-8219711Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219711Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219711C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219711C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219711C);
		  /* 8219711Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219711Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219711Ch case    0:*/		return 0x82197120;
		  /* 82197120h */ case    1:  		/* bc 4, CR0_EQ, 484 */
		/* 82197120h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82197304;  }
		/* 82197120h case    1:*/		return 0x82197124;
		  /* 82197124h */ case    2:  		/* lwz R11, <#[R29 + 12]> */
		/* 82197124h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82197124h case    2:*/		return 0x82197128;
		  /* 82197128h */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 82197128h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82197128h case    3:*/		return 0x8219712C;
		  /* 8219712Ch */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219712Ch case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219712Ch case    4:*/		return 0x82197130;
		  /* 82197130h */ case    5:  		/* cmplwi CR6, R11, 125 */
		/* 82197130h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82197130h case    5:*/		return 0x82197134;
		  /* 82197134h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82197134h case    6:*/		if ( regs.CR[6].eq ) { return 0x82197144;  }
		/* 82197134h case    6:*/		return 0x82197138;
		  /* 82197138h */ case    7:  		/* cmplwi CR6, R11, 124 */
		/* 82197138h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82197138h case    7:*/		return 0x8219713C;
		  /* 8219713Ch */ case    8:  		/* mr R11, R18 */
		/* 8219713Ch case    8:*/		regs.R11 = regs.R18;
		/* 8219713Ch case    8:*/		return 0x82197140;
		  /* 82197140h */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 82197140h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82197148;  }
		/* 82197140h case    9:*/		return 0x82197144;
	}
	return 0x82197144;
} // Block from 8219711Ch-82197144h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82197144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197144);
		  /* 82197144h */ case    0:  		/* mr R11, R19 */
		/* 82197144h case    0:*/		regs.R11 = regs.R19;
		/* 82197144h case    0:*/		return 0x82197148;
	}
	return 0x82197148;
} // Block from 82197144h-82197148h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197148);
		  /* 82197148h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82197148h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82197148h case    0:*/		return 0x8219714C;
		  /* 8219714Ch */ case    1:  		/* bc 4, CR0_EQ, 440 */
		/* 8219714Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82197304;  }
		/* 8219714Ch case    1:*/		return 0x82197150;
		  /* 82197150h */ case    2:  		/* lwz R4, <#[R1 + 112]> */
		/* 82197150h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000070) );
		/* 82197150h case    2:*/		return 0x82197154;
		  /* 82197154h */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 82197154h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82197154h case    3:*/		return 0x82197158;
		  /* 82197158h */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82197158h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82197158h case    4:*/		return 0x8219715C;
		  /* 8219715Ch */ case    5:  		/* cmplwi CR6, R11, 125 */
		/* 8219715Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219715Ch case    5:*/		return 0x82197160;
		  /* 82197160h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82197160h case    6:*/		if ( regs.CR[6].eq ) { return 0x82197170;  }
		/* 82197160h case    6:*/		return 0x82197164;
		  /* 82197164h */ case    7:  		/* cmplwi CR6, R11, 124 */
		/* 82197164h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82197164h case    7:*/		return 0x82197168;
		  /* 82197168h */ case    8:  		/* mr R11, R18 */
		/* 82197168h case    8:*/		regs.R11 = regs.R18;
		/* 82197168h case    8:*/		return 0x8219716C;
		  /* 8219716Ch */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 8219716Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82197174;  }
		/* 8219716Ch case    9:*/		return 0x82197170;
	}
	return 0x82197170;
} // Block from 82197148h-82197170h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82197170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197170);
		  /* 82197170h */ case    0:  		/* mr R11, R19 */
		/* 82197170h case    0:*/		regs.R11 = regs.R19;
		/* 82197170h case    0:*/		return 0x82197174;
	}
	return 0x82197174;
} // Block from 82197170h-82197174h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197174);
		  /* 82197174h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82197174h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82197174h case    0:*/		return 0x82197178;
		  /* 82197178h */ case    1:  		/* mr R3, R21 */
		/* 82197178h case    1:*/		regs.R3 = regs.R21;
		/* 82197178h case    1:*/		return 0x8219717C;
		  /* 8219717Ch */ case    2:  		/* bc 12, CR0_EQ, 300 */
		/* 8219717Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x821972A8;  }
		/* 8219717Ch case    2:*/		return 0x82197180;
		  /* 82197180h */ case    3:  		/* lwz R11, <#[R27]> */
		/* 82197180h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82197180h case    3:*/		return 0x82197184;
		  /* 82197184h */ case    4:  		/* lwz R31, <#[R1 + 132]> */
		/* 82197184h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000084) );
		/* 82197184h case    4:*/		return 0x82197188;
		  /* 82197188h */ case    5:  		/* lwz R25, <#[R1 + 124]> */
		/* 82197188h case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x0000007C) );
		/* 82197188h case    5:*/		return 0x8219718C;
		  /* 8219718Ch */ case    6:  		/* rlwinm R24, R11, 7, 29, 31 */
		/* 8219718Ch case    6:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R24,regs.R11);
		/* 8219718Ch case    6:*/		return 0x82197190;
		  /* 82197190h */ case    7:  		/* bl -127376 */
		/* 82197190h case    7:*/		regs.LR = 0x82197194; return 0x82178000;
		/* 82197190h case    7:*/		return 0x82197194;
		  /* 82197194h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 82197194h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82197194h case    8:*/		return 0x82197198;
		  /* 82197198h */ case    9:  		/* mr R4, R31 */
		/* 82197198h case    9:*/		regs.R4 = regs.R31;
		/* 82197198h case    9:*/		return 0x8219719C;
		  /* 8219719Ch */ case   10:  		/* rlwimi R11, R24, 25, 4, 6 */
		/* 8219719Ch case   10:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R24);
		/* 8219719Ch case   10:*/		return 0x821971A0;
		  /* 821971A0h */ case   11:  		/* mr R23, R3 */
		/* 821971A0h case   11:*/		regs.R23 = regs.R3;
		/* 821971A0h case   11:*/		return 0x821971A4;
		  /* 821971A4h */ case   12:  		/* stw R11, <#[R3]> */
		/* 821971A4h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821971A4h case   12:*/		return 0x821971A8;
		  /* 821971A8h */ case   13:  		/* bl -128744 */
		/* 821971A8h case   13:*/		regs.LR = 0x821971AC; return 0x82177AC0;
		/* 821971A8h case   13:*/		return 0x821971AC;
		  /* 821971ACh */ case   14:  		/* lwz R11, <#[R23]> */
		/* 821971ACh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 821971ACh case   14:*/		return 0x821971B0;
		  /* 821971B0h */ case   15:  		/* rlwimi R11, R25, 5, 19, 26 */
		/* 821971B0h case   15:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R25);
		/* 821971B0h case   15:*/		return 0x821971B4;
		  /* 821971B4h */ case   16:  		/* stw R11, <#[R23]> */
		/* 821971B4h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 821971B4h case   16:*/		return 0x821971B8;
		  /* 821971B8h */ case   17:  		/* lwz R4, <#[R1 + 96]> */
		/* 821971B8h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 821971B8h case   17:*/		return 0x821971BC;
		  /* 821971BCh */ case   18:  		/* stw R23, <#[R1 + 108]> */
		/* 821971BCh case   18:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x0000006C) );
		/* 821971BCh case   18:*/		return 0x821971C0;
		  /* 821971C0h */ case   19:  		/* lwz R11, <#[R4 + 8]> */
		/* 821971C0h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821971C0h case   19:*/		return 0x821971C4;
		  /* 821971C4h */ case   20:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821971C4h case   20:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821971C4h case   20:*/		return 0x821971C8;
		  /* 821971C8h */ case   21:  		/* cmplwi CR6, R11, 125 */
		/* 821971C8h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821971C8h case   21:*/		return 0x821971CC;
		  /* 821971CCh */ case   22:  		/* bc 12, CR6_EQ, 16 */
		/* 821971CCh case   22:*/		if ( regs.CR[6].eq ) { return 0x821971DC;  }
		/* 821971CCh case   22:*/		return 0x821971D0;
		  /* 821971D0h */ case   23:  		/* cmplwi CR6, R11, 124 */
		/* 821971D0h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821971D0h case   23:*/		return 0x821971D4;
		  /* 821971D4h */ case   24:  		/* mr R11, R18 */
		/* 821971D4h case   24:*/		regs.R11 = regs.R18;
		/* 821971D4h case   24:*/		return 0x821971D8;
		  /* 821971D8h */ case   25:  		/* bc 4, CR6_EQ, 8 */
		/* 821971D8h case   25:*/		if ( !regs.CR[6].eq ) { return 0x821971E0;  }
		/* 821971D8h case   25:*/		return 0x821971DC;
	}
	return 0x821971DC;
} // Block from 82197174h-821971DCh (26 instructions)

//////////////////////////////////////////////////////
// Block at 821971DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821971DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821971DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821971DC);
		  /* 821971DCh */ case    0:  		/* mr R11, R19 */
		/* 821971DCh case    0:*/		regs.R11 = regs.R19;
		/* 821971DCh case    0:*/		return 0x821971E0;
	}
	return 0x821971E0;
} // Block from 821971DCh-821971E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821971E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821971E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821971E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821971E0);
		  /* 821971E0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821971E0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821971E0h case    0:*/		return 0x821971E4;
		  /* 821971E4h */ case    1:  		/* bc 12, CR0_EQ, 156 */
		/* 821971E4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82197280;  }
		/* 821971E4h case    1:*/		return 0x821971E8;
		  /* 821971E8h */ case    2:  		/* lwz R11, <#[R29]> */
		/* 821971E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821971E8h case    2:*/		return 0x821971EC;
		  /* 821971ECh */ case    3:  		/* mr R3, R21 */
		/* 821971ECh case    3:*/		regs.R3 = regs.R21;
		/* 821971ECh case    3:*/		return 0x821971F0;
		  /* 821971F0h */ case    4:  		/* lwz R31, <#[R1 + 116]> */
		/* 821971F0h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000074) );
		/* 821971F0h case    4:*/		return 0x821971F4;
		  /* 821971F4h */ case    5:  		/* lwz R25, <#[R1 + 120]> */
		/* 821971F4h case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000078) );
		/* 821971F4h case    5:*/		return 0x821971F8;
		  /* 821971F8h */ case    6:  		/* rlwinm R24, R11, 7, 29, 31 */
		/* 821971F8h case    6:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R24,regs.R11);
		/* 821971F8h case    6:*/		return 0x821971FC;
		  /* 821971FCh */ case    7:  		/* bl -127484 */
		/* 821971FCh case    7:*/		regs.LR = 0x82197200; return 0x82178000;
		/* 821971FCh case    7:*/		return 0x82197200;
		  /* 82197200h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 82197200h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82197200h case    8:*/		return 0x82197204;
		  /* 82197204h */ case    9:  		/* mr R4, R31 */
		/* 82197204h case    9:*/		regs.R4 = regs.R31;
		/* 82197204h case    9:*/		return 0x82197208;
		  /* 82197208h */ case   10:  		/* rlwimi R11, R24, 25, 4, 6 */
		/* 82197208h case   10:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R24);
		/* 82197208h case   10:*/		return 0x8219720C;
		  /* 8219720Ch */ case   11:  		/* mr R23, R3 */
		/* 8219720Ch case   11:*/		regs.R23 = regs.R3;
		/* 8219720Ch case   11:*/		return 0x82197210;
		  /* 82197210h */ case   12:  		/* stw R11, <#[R3]> */
		/* 82197210h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82197210h case   12:*/		return 0x82197214;
		  /* 82197214h */ case   13:  		/* bl -128852 */
		/* 82197214h case   13:*/		regs.LR = 0x82197218; return 0x82177AC0;
		/* 82197214h case   13:*/		return 0x82197218;
		  /* 82197218h */ case   14:  		/* lwz R11, <#[R23]> */
		/* 82197218h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82197218h case   14:*/		return 0x8219721C;
		  /* 8219721Ch */ case   15:  		/* addi R6, R1, 92 */
		/* 8219721Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x5C);
		/* 8219721Ch case   15:*/		return 0x82197220;
		  /* 82197220h */ case   16:  		/* rlwimi R11, R25, 5, 19, 26 */
		/* 82197220h case   16:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R25);
		/* 82197220h case   16:*/		return 0x82197224;
		  /* 82197224h */ case   17:  		/* addi R5, R1, 100 */
		/* 82197224h case   17:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x64);
		/* 82197224h case   17:*/		return 0x82197228;
		  /* 82197228h */ case   18:  		/* stw R11, <#[R23]> */
		/* 82197228h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82197228h case   18:*/		return 0x8219722C;
		  /* 8219722Ch */ case   19:  		/* addi R4, R1, 108 */
		/* 8219722Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x6C);
		/* 8219722Ch case   19:*/		return 0x82197230;
		  /* 82197230h */ case   20:  		/* stw R23, <#[R1 + 100]> */
		/* 82197230h case   20:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000064) );
		/* 82197230h case   20:*/		return 0x82197234;
		  /* 82197234h */ case   21:  		/* mr R3, R21 */
		/* 82197234h case   21:*/		regs.R3 = regs.R21;
		/* 82197234h case   21:*/		return 0x82197238;
		  /* 82197238h */ case   22:  		/* bl 34608 */
		/* 82197238h case   22:*/		regs.LR = 0x8219723C; return 0x8219F968;
		/* 82197238h case   22:*/		return 0x8219723C;
		  /* 8219723Ch */ case   23:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219723Ch case   23:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219723Ch case   23:*/		return 0x82197240;
		  /* 82197240h */ case   24:  		/* bc 12, CR0_EQ, 24 */
		/* 82197240h case   24:*/		if ( regs.CR[0].eq ) { return 0x82197258;  }
		/* 82197240h case   24:*/		return 0x82197244;
		  /* 82197244h */ case   25:  		/* lwz R11, <#[R1 + 108]> */
		/* 82197244h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82197244h case   25:*/		return 0x82197248;
		  /* 82197248h */ case   26:  		/* lwz R10, <#[R1 + 100]> */
		/* 82197248h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 82197248h case   26:*/		return 0x8219724C;
		  /* 8219724Ch */ case   27:  		/* stw R11, <#[R1 + 88]> */
		/* 8219724Ch case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 8219724Ch case   27:*/		return 0x82197250;
		  /* 82197250h */ case   28:  		/* stw R10, <#[R1 + 80]> */
		/* 82197250h case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82197250h case   28:*/		return 0x82197254;
		  /* 82197254h */ case   29:  		/* b 176 */
		/* 82197254h case   29:*/		return 0x82197304;
		/* 82197254h case   29:*/		return 0x82197258;
	}
	return 0x82197258;
} // Block from 821971E0h-82197258h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82197258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197258);
		  /* 82197258h */ case    0:  		/* addi R6, R1, 92 */
		/* 82197258h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x5C);
		/* 82197258h case    0:*/		return 0x8219725C;
		  /* 8219725Ch */ case    1:  		/* addi R5, R1, 100 */
		/* 8219725Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x64);
		/* 8219725Ch case    1:*/		return 0x82197260;
		  /* 82197260h */ case    2:  		/* addi R4, R1, 88 */
		/* 82197260h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 82197260h case    2:*/		return 0x82197264;
		  /* 82197264h */ case    3:  		/* mr R3, R21 */
		/* 82197264h case    3:*/		regs.R3 = regs.R21;
		/* 82197264h case    3:*/		return 0x82197268;
		  /* 82197268h */ case    4:  		/* bl 34560 */
		/* 82197268h case    4:*/		regs.LR = 0x8219726C; return 0x8219F968;
		/* 82197268h case    4:*/		return 0x8219726C;
		  /* 8219726Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219726Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219726Ch case    5:*/		return 0x82197270;
		  /* 82197270h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82197270h case    6:*/		if ( regs.CR[0].eq ) { return 0x82197280;  }
		/* 82197270h case    6:*/		return 0x82197274;
		  /* 82197274h */ case    7:  		/* lwz R11, <#[R1 + 100]> */
		/* 82197274h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82197274h case    7:*/		return 0x82197278;
		  /* 82197278h */ case    8:  		/* stw R11, <#[R1 + 80]> */
		/* 82197278h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82197278h case    8:*/		return 0x8219727C;
		  /* 8219727Ch */ case    9:  		/* b 136 */
		/* 8219727Ch case    9:*/		return 0x82197304;
		/* 8219727Ch case    9:*/		return 0x82197280;
	}
	return 0x82197280;
} // Block from 82197258h-82197280h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82197280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197280);
		  /* 82197280h */ case    0:  		/* addi R6, R1, 92 */
		/* 82197280h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x5C);
		/* 82197280h case    0:*/		return 0x82197284;
		  /* 82197284h */ case    1:  		/* addi R5, R1, 80 */
		/* 82197284h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82197284h case    1:*/		return 0x82197288;
		  /* 82197288h */ case    2:  		/* addi R4, R1, 108 */
		/* 82197288h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x6C);
		/* 82197288h case    2:*/		return 0x8219728C;
		  /* 8219728Ch */ case    3:  		/* mr R3, R21 */
		/* 8219728Ch case    3:*/		regs.R3 = regs.R21;
		/* 8219728Ch case    3:*/		return 0x82197290;
		  /* 82197290h */ case    4:  		/* bl 34520 */
		/* 82197290h case    4:*/		regs.LR = 0x82197294; return 0x8219F968;
		/* 82197290h case    4:*/		return 0x82197294;
		  /* 82197294h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82197294h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82197294h case    5:*/		return 0x82197298;
		  /* 82197298h */ case    6:  		/* bc 12, CR0_EQ, 948 */
		/* 82197298h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219764C;  }
		/* 82197298h case    6:*/		return 0x8219729C;
		  /* 8219729Ch */ case    7:  		/* lwz R11, <#[R1 + 108]> */
		/* 8219729Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 8219729Ch case    7:*/		return 0x821972A0;
		  /* 821972A0h */ case    8:  		/* stw R11, <#[R1 + 88]> */
		/* 821972A0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 821972A0h case    8:*/		return 0x821972A4;
		  /* 821972A4h */ case    9:  		/* b 96 */
		/* 821972A4h case    9:*/		return 0x82197304;
		/* 821972A4h case    9:*/		return 0x821972A8;
	}
	return 0x821972A8;
} // Block from 82197280h-821972A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821972A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821972A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821972A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821972A8);
		  /* 821972A8h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821972A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821972A8h case    0:*/		return 0x821972AC;
		  /* 821972ACh */ case    1:  		/* lwz R4, <#[R1 + 96]> */
		/* 821972ACh case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 821972ACh case    1:*/		return 0x821972B0;
		  /* 821972B0h */ case    2:  		/* lwz R31, <#[R1 + 116]> */
		/* 821972B0h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000074) );
		/* 821972B0h case    2:*/		return 0x821972B4;
		  /* 821972B4h */ case    3:  		/* rlwinm R25, R11, 7, 29, 31 */
		/* 821972B4h case    3:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R25,regs.R11);
		/* 821972B4h case    3:*/		return 0x821972B8;
		  /* 821972B8h */ case    4:  		/* lwz R24, <#[R1 + 120]> */
		/* 821972B8h case    4:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000078) );
		/* 821972B8h case    4:*/		return 0x821972BC;
		  /* 821972BCh */ case    5:  		/* bl -127676 */
		/* 821972BCh case    5:*/		regs.LR = 0x821972C0; return 0x82178000;
		/* 821972BCh case    5:*/		return 0x821972C0;
		  /* 821972C0h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 821972C0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821972C0h case    6:*/		return 0x821972C4;
		  /* 821972C4h */ case    7:  		/* mr R4, R31 */
		/* 821972C4h case    7:*/		regs.R4 = regs.R31;
		/* 821972C4h case    7:*/		return 0x821972C8;
		  /* 821972C8h */ case    8:  		/* mr R23, R3 */
		/* 821972C8h case    8:*/		regs.R23 = regs.R3;
		/* 821972C8h case    8:*/		return 0x821972CC;
		  /* 821972CCh */ case    9:  		/* rlwimi R11, R25, 25, 4, 6 */
		/* 821972CCh case    9:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R25);
		/* 821972CCh case    9:*/		return 0x821972D0;
		  /* 821972D0h */ case   10:  		/* stw R11, <#[R3]> */
		/* 821972D0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821972D0h case   10:*/		return 0x821972D4;
		  /* 821972D4h */ case   11:  		/* bl -129044 */
		/* 821972D4h case   11:*/		regs.LR = 0x821972D8; return 0x82177AC0;
		/* 821972D4h case   11:*/		return 0x821972D8;
		  /* 821972D8h */ case   12:  		/* lwz R11, <#[R23]> */
		/* 821972D8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 821972D8h case   12:*/		return 0x821972DC;
		  /* 821972DCh */ case   13:  		/* addi R6, R1, 92 */
		/* 821972DCh case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x5C);
		/* 821972DCh case   13:*/		return 0x821972E0;
		  /* 821972E0h */ case   14:  		/* rlwimi R11, R24, 5, 19, 26 */
		/* 821972E0h case   14:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R24);
		/* 821972E0h case   14:*/		return 0x821972E4;
		  /* 821972E4h */ case   15:  		/* addi R5, R1, 80 */
		/* 821972E4h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821972E4h case   15:*/		return 0x821972E8;
		  /* 821972E8h */ case   16:  		/* stw R11, <#[R23]> */
		/* 821972E8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 821972E8h case   16:*/		return 0x821972EC;
		  /* 821972ECh */ case   17:  		/* addi R4, R1, 88 */
		/* 821972ECh case   17:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 821972ECh case   17:*/		return 0x821972F0;
		  /* 821972F0h */ case   18:  		/* stw R23, <#[R1 + 80]> */
		/* 821972F0h case   18:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000050) );
		/* 821972F0h case   18:*/		return 0x821972F4;
		  /* 821972F4h */ case   19:  		/* mr R3, R21 */
		/* 821972F4h case   19:*/		regs.R3 = regs.R21;
		/* 821972F4h case   19:*/		return 0x821972F8;
		  /* 821972F8h */ case   20:  		/* bl 34416 */
		/* 821972F8h case   20:*/		regs.LR = 0x821972FC; return 0x8219F968;
		/* 821972F8h case   20:*/		return 0x821972FC;
		  /* 821972FCh */ case   21:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821972FCh case   21:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821972FCh case   21:*/		return 0x82197300;
		  /* 82197300h */ case   22:  		/* bc 12, CR0_EQ, 856 */
		/* 82197300h case   22:*/		if ( regs.CR[0].eq ) { return 0x82197658;  }
		/* 82197300h case   22:*/		return 0x82197304;
	}
	return 0x82197304;
} // Block from 821972A8h-82197304h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82197304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197304);
		  /* 82197304h */ case    0:  		/* lwz R11, <#[R1 + 88]> */
		/* 82197304h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82197304h case    0:*/		return 0x82197308;
		  /* 82197308h */ case    1:  		/* cmplw CR6, R11, R27 */
		/* 82197308h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 82197308h case    1:*/		return 0x8219730C;
		  /* 8219730Ch */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 8219730Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82197334;  }
		/* 8219730Ch case    2:*/		return 0x82197310;
		  /* 82197310h */ case    3:  		/* mr R5, R21 */
		/* 82197310h case    3:*/		regs.R5 = regs.R21;
		/* 82197310h case    3:*/		return 0x82197314;
		  /* 82197314h */ case    4:  		/* lwz R4, <#[R30 + 44]> */
		/* 82197314h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000002C) );
		/* 82197314h case    4:*/		return 0x82197318;
		  /* 82197318h */ case    5:  		/* mr R3, R30 */
		/* 82197318h case    5:*/		regs.R3 = regs.R30;
		/* 82197318h case    5:*/		return 0x8219731C;
		  /* 8219731Ch */ case    6:  		/* mr R31, R11 */
		/* 8219731Ch case    6:*/		regs.R31 = regs.R11;
		/* 8219731Ch case    6:*/		return 0x82197320;
		  /* 82197320h */ case    7:  		/* bl -125456 */
		/* 82197320h case    7:*/		regs.LR = 0x82197324; return 0x82178910;
		/* 82197320h case    7:*/		return 0x82197324;
		  /* 82197324h */ case    8:  		/* mr R4, R31 */
		/* 82197324h case    8:*/		regs.R4 = regs.R31;
		/* 82197324h case    8:*/		return 0x82197328;
		  /* 82197328h */ case    9:  		/* mr R3, R30 */
		/* 82197328h case    9:*/		regs.R3 = regs.R30;
		/* 82197328h case    9:*/		return 0x8219732C;
		  /* 8219732Ch */ case   10:  		/* bl -127332 */
		/* 8219732Ch case   10:*/		regs.LR = 0x82197330; return 0x821781C8;
		/* 8219732Ch case   10:*/		return 0x82197330;
		  /* 82197330h */ case   11:  		/* stw R3, <#[R30 + 44]> */
		/* 82197330h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 82197330h case   11:*/		return 0x82197334;
	}
	return 0x82197334;
} // Block from 82197304h-82197334h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82197334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197334);
		  /* 82197334h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82197334h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82197334h case    0:*/		return 0x82197338;
		  /* 82197338h */ case    1:  		/* cmplw CR6, R11, R29 */
		/* 82197338h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 82197338h case    1:*/		return 0x8219733C;
		  /* 8219733Ch */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 8219733Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82197364;  }
		/* 8219733Ch case    2:*/		return 0x82197340;
		  /* 82197340h */ case    3:  		/* mr R5, R21 */
		/* 82197340h case    3:*/		regs.R5 = regs.R21;
		/* 82197340h case    3:*/		return 0x82197344;
		  /* 82197344h */ case    4:  		/* lwz R4, <#[R30 + 48]> */
		/* 82197344h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000030) );
		/* 82197344h case    4:*/		return 0x82197348;
		  /* 82197348h */ case    5:  		/* mr R3, R30 */
		/* 82197348h case    5:*/		regs.R3 = regs.R30;
		/* 82197348h case    5:*/		return 0x8219734C;
		  /* 8219734Ch */ case    6:  		/* mr R31, R11 */
		/* 8219734Ch case    6:*/		regs.R31 = regs.R11;
		/* 8219734Ch case    6:*/		return 0x82197350;
		  /* 82197350h */ case    7:  		/* bl -125504 */
		/* 82197350h case    7:*/		regs.LR = 0x82197354; return 0x82178910;
		/* 82197350h case    7:*/		return 0x82197354;
		  /* 82197354h */ case    8:  		/* mr R4, R31 */
		/* 82197354h case    8:*/		regs.R4 = regs.R31;
		/* 82197354h case    8:*/		return 0x82197358;
		  /* 82197358h */ case    9:  		/* mr R3, R30 */
		/* 82197358h case    9:*/		regs.R3 = regs.R30;
		/* 82197358h case    9:*/		return 0x8219735C;
		  /* 8219735Ch */ case   10:  		/* bl -127380 */
		/* 8219735Ch case   10:*/		regs.LR = 0x82197360; return 0x821781C8;
		/* 8219735Ch case   10:*/		return 0x82197360;
		  /* 82197360h */ case   11:  		/* stw R3, <#[R30 + 48]> */
		/* 82197360h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 82197360h case   11:*/		return 0x82197364;
	}
	return 0x82197364;
} // Block from 82197334h-82197364h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82197364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197364);
		  /* 82197364h */ case    0:  		/* lwz R11, <#[R1 + 92]> */
		/* 82197364h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82197364h case    0:*/		return 0x82197368;
		  /* 82197368h */ case    1:  		/* cmplw CR6, R11, R28 */
		/* 82197368h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 82197368h case    1:*/		return 0x8219736C;
		  /* 8219736Ch */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 8219736Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82197394;  }
		/* 8219736Ch case    2:*/		return 0x82197370;
		  /* 82197370h */ case    3:  		/* mr R5, R21 */
		/* 82197370h case    3:*/		regs.R5 = regs.R21;
		/* 82197370h case    3:*/		return 0x82197374;
		  /* 82197374h */ case    4:  		/* lwz R4, <#[R30 + 52]> */
		/* 82197374h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000034) );
		/* 82197374h case    4:*/		return 0x82197378;
		  /* 82197378h */ case    5:  		/* mr R3, R30 */
		/* 82197378h case    5:*/		regs.R3 = regs.R30;
		/* 82197378h case    5:*/		return 0x8219737C;
		  /* 8219737Ch */ case    6:  		/* mr R31, R11 */
		/* 8219737Ch case    6:*/		regs.R31 = regs.R11;
		/* 8219737Ch case    6:*/		return 0x82197380;
		  /* 82197380h */ case    7:  		/* bl -125552 */
		/* 82197380h case    7:*/		regs.LR = 0x82197384; return 0x82178910;
		/* 82197380h case    7:*/		return 0x82197384;
		  /* 82197384h */ case    8:  		/* mr R4, R31 */
		/* 82197384h case    8:*/		regs.R4 = regs.R31;
		/* 82197384h case    8:*/		return 0x82197388;
		  /* 82197388h */ case    9:  		/* mr R3, R30 */
		/* 82197388h case    9:*/		regs.R3 = regs.R30;
		/* 82197388h case    9:*/		return 0x8219738C;
		  /* 8219738Ch */ case   10:  		/* bl -127428 */
		/* 8219738Ch case   10:*/		regs.LR = 0x82197390; return 0x821781C8;
		/* 8219738Ch case   10:*/		return 0x82197390;
		  /* 82197390h */ case   11:  		/* stw R3, <#[R30 + 52]> */
		/* 82197390h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000034) );
		/* 82197390h case   11:*/		return 0x82197394;
	}
	return 0x82197394;
} // Block from 82197364h-82197394h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82197394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197394);
		  /* 82197394h */ case    0:  		/* lwz R3, <#[R1 + 112]> */
		/* 82197394h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000070) );
		/* 82197394h case    0:*/		return 0x82197398;
		  /* 82197398h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 82197398h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82197398h case    1:*/		return 0x8219739C;
		  /* 8219739Ch */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219739Ch case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219739Ch case    2:*/		return 0x821973A0;
		  /* 821973A0h */ case    3:  		/* cmplwi CR6, R11, 16000 */
		/* 821973A0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821973A0h case    3:*/		return 0x821973A4;
		  /* 821973A4h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 821973A4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821973BC;  }
		/* 821973A4h case    4:*/		return 0x821973A8;
		  /* 821973A8h */ case    5:  		/* bl -4088 */
		/* 821973A8h case    5:*/		regs.LR = 0x821973AC; return 0x821963B0;
		/* 821973A8h case    5:*/		return 0x821973AC;
		  /* 821973ACh */ case    6:  		/* lwz R11, <#[R1 + 112]> */
		/* 821973ACh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 821973ACh case    6:*/		return 0x821973B0;
		  /* 821973B0h */ case    7:  		/* lwz R10, <#[R11 + 8]> */
		/* 821973B0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821973B0h case    7:*/		return 0x821973B4;
		  /* 821973B4h */ case    8:  		/* oris R10, R10, 256 */
		/* 821973B4h case    8:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x100);
		/* 821973B4h case    8:*/		return 0x821973B8;
		  /* 821973B8h */ case    9:  		/* stw R10, <#[R11 + 8]> */
		/* 821973B8h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821973B8h case    9:*/		return 0x821973BC;
	}
	return 0x821973BC;
} // Block from 82197394h-821973BCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 821973BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821973BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821973BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821973BC);
		  /* 821973BCh */ case    0:  		/* lwz R3, <#[R1 + 96]> */
		/* 821973BCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 821973BCh case    0:*/		return 0x821973C0;
		  /* 821973C0h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 821973C0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821973C0h case    1:*/		return 0x821973C4;
		  /* 821973C4h */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821973C4h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821973C4h case    2:*/		return 0x821973C8;
		  /* 821973C8h */ case    3:  		/* cmplwi CR6, R11, 16000 */
		/* 821973C8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821973C8h case    3:*/		return 0x821973CC;
		  /* 821973CCh */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 821973CCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x821973E4;  }
		/* 821973CCh case    4:*/		return 0x821973D0;
		  /* 821973D0h */ case    5:  		/* bl -4128 */
		/* 821973D0h case    5:*/		regs.LR = 0x821973D4; return 0x821963B0;
		/* 821973D0h case    5:*/		return 0x821973D4;
		  /* 821973D4h */ case    6:  		/* lwz R11, <#[R1 + 96]> */
		/* 821973D4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 821973D4h case    6:*/		return 0x821973D8;
		  /* 821973D8h */ case    7:  		/* lwz R10, <#[R11 + 8]> */
		/* 821973D8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821973D8h case    7:*/		return 0x821973DC;
		  /* 821973DCh */ case    8:  		/* oris R10, R10, 256 */
		/* 821973DCh case    8:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x100);
		/* 821973DCh case    8:*/		return 0x821973E0;
		  /* 821973E0h */ case    9:  		/* stw R10, <#[R11 + 8]> */
		/* 821973E0h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821973E0h case    9:*/		return 0x821973E4;
	}
	return 0x821973E4;
} // Block from 821973BCh-821973E4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821973E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821973E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821973E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821973E4);
		  /* 821973E4h */ case    0:  		/* lwz R3, <#[R1 + 104]> */
		/* 821973E4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000068) );
		/* 821973E4h case    0:*/		return 0x821973E8;
		  /* 821973E8h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 821973E8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821973E8h case    1:*/		return 0x821973EC;
		  /* 821973ECh */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821973ECh case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821973ECh case    2:*/		return 0x821973F0;
		  /* 821973F0h */ case    3:  		/* cmplwi CR6, R11, 16000 */
		/* 821973F0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821973F0h case    3:*/		return 0x821973F4;
		  /* 821973F4h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 821973F4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8219740C;  }
		/* 821973F4h case    4:*/		return 0x821973F8;
		  /* 821973F8h */ case    5:  		/* bl -4168 */
		/* 821973F8h case    5:*/		regs.LR = 0x821973FC; return 0x821963B0;
		/* 821973F8h case    5:*/		return 0x821973FC;
		  /* 821973FCh */ case    6:  		/* lwz R11, <#[R1 + 104]> */
		/* 821973FCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 821973FCh case    6:*/		return 0x82197400;
		  /* 82197400h */ case    7:  		/* lwz R10, <#[R11 + 8]> */
		/* 82197400h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82197400h case    7:*/		return 0x82197404;
		  /* 82197404h */ case    8:  		/* oris R10, R10, 256 */
		/* 82197404h case    8:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x100);
		/* 82197404h case    8:*/		return 0x82197408;
		  /* 82197408h */ case    9:  		/* stw R10, <#[R11 + 8]> */
		/* 82197408h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82197408h case    9:*/		return 0x8219740C;
	}
	return 0x8219740C;
} // Block from 821973E4h-8219740Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219740Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219740C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219740C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219740C);
		  /* 8219740Ch */ case    0:  		/* stb R19, <#[R1 + 84]> */
		/* 8219740Ch case    0:*/		cpu::mem::store8( regs, regs.R19, (uint32)(regs.R1 + 0x00000054) );
		/* 8219740Ch case    0:*/		return 0x82197410;
	}
	return 0x82197410;
} // Block from 8219740Ch-82197410h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197410);
		  /* 82197410h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 82197410h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 82197410h case    0:*/		return 0x82197414;
		  /* 82197414h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 82197414h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82197414h case    1:*/		return 0x82197418;
		  /* 82197418h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82197418h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82197418h case    2:*/		return 0x8219741C;
		  /* 8219741Ch */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8219741Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219742C;  }
		/* 8219741Ch case    3:*/		return 0x82197420;
		  /* 82197420h */ case    4:  		/* mr R30, R11 */
		/* 82197420h case    4:*/		regs.R30 = regs.R11;
		/* 82197420h case    4:*/		return 0x82197424;
		  /* 82197424h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82197424h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82197424h case    5:*/		return 0x82197428;
		  /* 82197428h */ case    6:  		/* bc 4, CR6_EQ, -1276 */
		/* 82197428h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82196F2C;  }
		/* 82197428h case    6:*/		return 0x8219742C;
	}
	return 0x8219742C;
} // Block from 82197410h-8219742Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219742Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219742C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219742C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219742C);
		  /* 8219742Ch */ case    0:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 8219742Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 8219742Ch case    0:*/		return 0x82197430;
		  /* 82197430h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 82197430h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82197430h case    1:*/		return 0x82197434;
		  /* 82197434h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82197434h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82197434h case    2:*/		return 0x82197438;
		  /* 82197438h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 82197438h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82197448;  }
		/* 82197438h case    3:*/		return 0x8219743C;
		  /* 8219743Ch */ case    4:  		/* mr R26, R11 */
		/* 8219743Ch case    4:*/		regs.R26 = regs.R11;
		/* 8219743Ch case    4:*/		return 0x82197440;
		  /* 82197440h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82197440h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82197440h case    5:*/		return 0x82197444;
		  /* 82197444h */ case    6:  		/* bc 4, CR6_EQ, -1328 */
		/* 82197444h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82196F14;  }
		/* 82197444h case    6:*/		return 0x82197448;
	}
	return 0x82197448;
} // Block from 8219742Ch-82197448h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82197448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197448);
		  /* 82197448h */ case    0:  		/* lwz R11, <#[R21 + 4]> */
		/* 82197448h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 82197448h case    0:*/		return 0x8219744C;
		  /* 8219744Ch */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219744Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219744Ch case    1:*/		return 0x82197450;
		  /* 82197450h */ case    2:  		/* bc 4, CR0_EQ, 11768 */
		/* 82197450h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8219A248;  }
		/* 82197450h case    2:*/		return 0x82197454;
		  /* 82197454h */ case    3:  		/* mr R20, R11 */
		/* 82197454h case    3:*/		regs.R20 = regs.R11;
		/* 82197454h case    3:*/		return 0x82197458;
		  /* 82197458h */ case    4:  		/* stw R11, <#[R1 + 100]> */
		/* 82197458h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82197458h case    4:*/		return 0x8219745C;
		  /* 8219745Ch */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 8219745Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8219745Ch case    5:*/		return 0x82197460;
		  /* 82197460h */ case    6:  		/* bc 12, CR0_EQ, 11752 */
		/* 82197460h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219A248;  }
		/* 82197460h case    6:*/		return 0x82197464;
		  /* 82197464h */ case    7:  		/* lis R11, -32256 */
		/* 82197464h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82197464h case    7:*/		return 0x82197468;
		  /* 82197468h */ case    8:  		/* lis R10, -32256 */
		/* 82197468h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82197468h case    8:*/		return 0x8219746C;
		  /* 8219746Ch */ case    9:  		/* lis R9, -32256 */
		/* 8219746Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8219746Ch case    9:*/		return 0x82197470;
		  /* 82197470h */ case   10:  		/* lis R8, -32252 */
		/* 82197470h case   10:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8204);
		/* 82197470h case   10:*/		return 0x82197474;
		  /* 82197474h */ case   11:  		/* lis R7, -32256 */
		/* 82197474h case   11:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8200);
		/* 82197474h case   11:*/		return 0x82197478;
		  /* 82197478h */ case   12:  		/* lfd FR28, <#[R11 + 1808]> */
		/* 82197478h case   12:*/		cpu::mem::load64f( regs, &regs.FR28, (uint32)(regs.R11 + 0x00000710) );
		/* 82197478h case   12:*/		return 0x8219747C;
		  /* 8219747Ch */ case   13:  		/* lfs FR26, <#[R10 + 1792]> */
		/* 8219747Ch case   13:*/		cpu::mem::load32f( regs, &regs.FR26, (uint32)(regs.R10 + 0x00000700) );
		/* 8219747Ch case   13:*/		return 0x82197480;
		  /* 82197480h */ case   14:  		/* lfs FR29, <#[R9 + 1816]> */
		/* 82197480h case   14:*/		cpu::mem::load32f( regs, &regs.FR29, (uint32)(regs.R9 + 0x00000718) );
		/* 82197480h case   14:*/		return 0x82197484;
		  /* 82197484h */ case   15:  		/* lfs FR27, <#[R8 - 16652]> */
		/* 82197484h case   15:*/		cpu::mem::load32f( regs, &regs.FR27, (uint32)(regs.R8 + 0xFFFFBEF4) );
		/* 82197484h case   15:*/		return 0x82197488;
		  /* 82197488h */ case   16:  		/* lfs FR30, <#[R7 + 8792]> */
		/* 82197488h case   16:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R7 + 0x00002258) );
		/* 82197488h case   16:*/		return 0x8219748C;
		  /* 8219748Ch */ case   17:  		/* lwz R9, <#[R21 + 788]> */
		/* 8219748Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R21 + 0x00000314) );
		/* 8219748Ch case   17:*/		return 0x82197490;
		  /* 82197490h */ case   18:  		/* mr R8, R18 */
		/* 82197490h case   18:*/		regs.R8 = regs.R18;
		/* 82197490h case   18:*/		return 0x82197494;
		  /* 82197494h */ case   19:  		/* stw R18, <#[R1 + 120]> */
		/* 82197494h case   19:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000078) );
		/* 82197494h case   19:*/		return 0x82197498;
		  /* 82197498h */ case   20:  		/* cmpwi CR6, R9, -1 */
		/* 82197498h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R9,0xFFFFFFFF);
		/* 82197498h case   20:*/		return 0x8219749C;
		  /* 8219749Ch */ case   21:  		/* bc 12, CR6_EQ, 132 */
		/* 8219749Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82197520;  }
		/* 8219749Ch case   21:*/		return 0x821974A0;
		  /* 821974A0h */ case   22:  		/* lwz R11, <#[R20 + 28]> */
		/* 821974A0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x0000001C) );
		/* 821974A0h case   22:*/		return 0x821974A4;
		  /* 821974A4h */ case   23:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821974A4h case   23:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821974A4h case   23:*/		return 0x821974A8;
		  /* 821974A8h */ case   24:  		/* bc 4, CR0_EQ, 100 */
		/* 821974A8h case   24:*/		if ( !regs.CR[0].eq ) { return 0x8219750C;  }
		/* 821974A8h case   24:*/		return 0x821974AC;
		  /* 821974ACh */ case   25:  		/* mr R10, R11 */
		/* 821974ACh case   25:*/		regs.R10 = regs.R11;
		/* 821974ACh case   25:*/		return 0x821974B0;
		  /* 821974B0h */ case   26:  		/* cmplwi CR0, R11, 0 */
		/* 821974B0h case   26:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821974B0h case   26:*/		return 0x821974B4;
		  /* 821974B4h */ case   27:  		/* bc 12, CR0_EQ, 88 */
		/* 821974B4h case   27:*/		if ( regs.CR[0].eq ) { return 0x8219750C;  }
		/* 821974B4h case   27:*/		return 0x821974B8;
		  /* 821974B8h */ case   28:  		/* lwz R11, <#[R10 + 8]> */
		/* 821974B8h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821974B8h case   28:*/		return 0x821974BC;
		  /* 821974BCh */ case   29:  		/* rlwinm. R7, R11, 27, 31, 31 */
		/* 821974BCh case   29:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R7,regs.R11);
		/* 821974BCh case   29:*/		return 0x821974C0;
		  /* 821974C0h */ case   30:  		/* bc 12, CR0_EQ, 48 */
		/* 821974C0h case   30:*/		if ( regs.CR[0].eq ) { return 0x821974F0;  }
		/* 821974C0h case   30:*/		return 0x821974C4;
		  /* 821974C4h */ case   31:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821974C4h case   31:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821974C4h case   31:*/		return 0x821974C8;
		  /* 821974C8h */ case   32:  		/* cmplwi CR6, R11, 1 */
		/* 821974C8h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821974C8h case   32:*/		return 0x821974CC;
		  /* 821974CCh */ case   33:  		/* bc 12, CR6_LT, 16 */
		/* 821974CCh case   33:*/		if ( regs.CR[6].lt ) { return 0x821974DC;  }
		/* 821974CCh case   33:*/		return 0x821974D0;
		  /* 821974D0h */ case   34:  		/* cmplwi CR6, R11, 102 */
		/* 821974D0h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 821974D0h case   34:*/		return 0x821974D4;
		  /* 821974D4h */ case   35:  		/* mr R11, R19 */
		/* 821974D4h case   35:*/		regs.R11 = regs.R19;
		/* 821974D4h case   35:*/		return 0x821974D8;
		  /* 821974D8h */ case   36:  		/* bc 4, CR6_GT, 8 */
		/* 821974D8h case   36:*/		if ( !regs.CR[6].gt ) { return 0x821974E0;  }
		/* 821974D8h case   36:*/		return 0x821974DC;
	}
	return 0x821974DC;
} // Block from 82197448h-821974DCh (37 instructions)

//////////////////////////////////////////////////////
// Block at 821974DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821974DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821974DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821974DC);
		  /* 821974DCh */ case    0:  		/* mr R11, R18 */
		/* 821974DCh case    0:*/		regs.R11 = regs.R18;
		/* 821974DCh case    0:*/		return 0x821974E0;
	}
	return 0x821974E0;
} // Block from 821974DCh-821974E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821974E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821974E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821974E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821974E0);
		  /* 821974E0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821974E0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821974E0h case    0:*/		return 0x821974E4;
		  /* 821974E4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821974E4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821974F0;  }
		/* 821974E4h case    1:*/		return 0x821974E8;
		  /* 821974E8h */ case    2:  		/* addi R8, R8, 1 */
		/* 821974E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821974E8h case    2:*/		return 0x821974EC;
		  /* 821974ECh */ case    3:  		/* stw R8, <#[R1 + 120]> */
		/* 821974ECh case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000078) );
		/* 821974ECh case    3:*/		return 0x821974F0;
	}
	return 0x821974F0;
} // Block from 821974E0h-821974F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821974F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821974F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821974F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821974F0);
		  /* 821974F0h */ case    0:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 821974F0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 821974F0h case    0:*/		return 0x821974F4;
		  /* 821974F4h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821974F4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821974F4h case    1:*/		return 0x821974F8;
		  /* 821974F8h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821974F8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821974F8h case    2:*/		return 0x821974FC;
		  /* 821974FCh */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821974FCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219750C;  }
		/* 821974FCh case    3:*/		return 0x82197500;
		  /* 82197500h */ case    4:  		/* mr R10, R11 */
		/* 82197500h case    4:*/		regs.R10 = regs.R11;
		/* 82197500h case    4:*/		return 0x82197504;
		  /* 82197504h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82197504h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82197504h case    5:*/		return 0x82197508;
		  /* 82197508h */ case    6:  		/* bc 4, CR6_EQ, -80 */
		/* 82197508h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821974B8;  }
		/* 82197508h case    6:*/		return 0x8219750C;
	}
	return 0x8219750C;
} // Block from 821974F0h-8219750Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219750Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219750C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219750C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219750C);
		  /* 8219750Ch */ case    0:  		/* cmplw CR6, R8, R9 */
		/* 8219750Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8219750Ch case    0:*/		return 0x82197510;
		  /* 82197510h */ case    1:  		/* bc 4, CR6_GT, 16 */
		/* 82197510h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82197520;  }
		/* 82197510h case    1:*/		return 0x82197514;
		  /* 82197514h */ case    2:  		/* li R4, 3587 */
		/* 82197514h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0xE03);
		/* 82197514h case    2:*/		return 0x82197518;
		  /* 82197518h */ case    3:  		/* mr R3, R21 */
		/* 82197518h case    3:*/		regs.R3 = regs.R21;
		/* 82197518h case    3:*/		return 0x8219751C;
		  /* 8219751Ch */ case    4:  		/* bl -284580 */
		/* 8219751Ch case    4:*/		regs.LR = 0x82197520; return 0x82151D78;
		/* 8219751Ch case    4:*/		return 0x82197520;
	}
	return 0x82197520;
} // Block from 8219750Ch-82197520h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82197520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197520);
		  /* 82197520h */ case    0:  		/* lwz R10, <#[R20 + 28]> */
		/* 82197520h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x0000001C) );
		/* 82197520h case    0:*/		return 0x82197524;
		  /* 82197524h */ case    1:  		/* addi R11, R20, 24 */
		/* 82197524h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R20,0x18);
		/* 82197524h case    1:*/		return 0x82197528;
		  /* 82197528h */ case    2:  		/* stw R18, <#[R1 + 92]> */
		/* 82197528h case    2:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x0000005C) );
		/* 82197528h case    2:*/		return 0x8219752C;
		  /* 8219752Ch */ case    3:  		/* rlwinm R11, R10, 0, 31, 31 */
		/* 8219752Ch case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R10);
		/* 8219752Ch case    3:*/		return 0x82197530;
		  /* 82197530h */ case    4:  		/* addic R11, R11, -1 */
		/* 82197530h case    4:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82197530h case    4:*/		return 0x82197534;
		  /* 82197534h */ case    5:  		/* subfe R11, R11, R11 */
		/* 82197534h case    5:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82197534h case    5:*/		return 0x82197538;
		  /* 82197538h */ case    6:  		/* and R14, R11, R10 */
		/* 82197538h case    6:*/		cpu::op::and<0>(regs,&regs.R14,regs.R11,regs.R10);
		/* 82197538h case    6:*/		return 0x8219753C;
		  /* 8219753Ch */ case    7:  		/* lbz R11, <#[R1 + 84]> */
		/* 8219753Ch case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8219753Ch case    7:*/		return 0x82197540;
	}
	return 0x82197540;
} // Block from 82197520h-82197540h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82197540h
// Function '?RemoveAllUnusedDependents@Instruction@D3DXShader@@QAAXPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197540);
		  /* 82197540h */ case    0:  		/* cmplwi CR6, R14, 0 */
		/* 82197540h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 82197540h case    0:*/		return 0x82197544;
		  /* 82197544h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 82197544h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82197544h case    1:*/		return 0x82197548;
		  /* 82197548h */ case    2:  		/* bc 12, CR6_EQ, 11408 */
		/* 82197548h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219A1D8;  }
		/* 82197548h case    2:*/		return 0x8219754C;
		  /* 8219754Ch */ case    3:  		/* bc 12, CR0_EQ, 32 */
		/* 8219754Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8219756C;  }
		/* 8219754Ch case    3:*/		return 0x82197550;
		  /* 82197550h */ case    4:  		/* mr R4, R21 */
		/* 82197550h case    4:*/		regs.R4 = regs.R21;
		/* 82197550h case    4:*/		return 0x82197554;
		  /* 82197554h */ case    5:  		/* mr R3, R14 */
		/* 82197554h case    5:*/		regs.R3 = regs.R14;
		/* 82197554h case    5:*/		return 0x82197558;
		  /* 82197558h */ case    6:  		/* bl -2480 */
		/* 82197558h case    6:*/		regs.LR = 0x8219755C; return 0x82196BA8;
		/* 82197558h case    6:*/		return 0x8219755C;
		  /* 8219755Ch */ case    7:  		/* mr R3, R14 */
		/* 8219755Ch case    7:*/		regs.R3 = regs.R14;
		/* 8219755Ch case    7:*/		return 0x82197560;
		  /* 82197560h */ case    8:  		/* bl -207840 */
		/* 82197560h case    8:*/		regs.LR = 0x82197564; return 0x82164980;
		/* 82197560h case    8:*/		return 0x82197564;
		  /* 82197564h */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82197564h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82197564h case    9:*/		return 0x82197568;
		  /* 82197568h */ case   10:  		/* bc 4, CR0_EQ, 7536 */
		/* 82197568h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821992D8;  }
		/* 82197568h case   10:*/		return 0x8219756C;
	}
	return 0x8219756C;
} // Block from 82197540h-8219756Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219756Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219756C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219756C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219756C);
		  /* 8219756Ch */ case    0:  		/* lwz R31, <#[R14 + 8]> */
		/* 8219756Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R14 + 0x00000008) );
		/* 8219756Ch case    0:*/		return 0x82197570;
		  /* 82197570h */ case    1:  		/* rlwinm R11, R31, 25, 25, 31 */
		/* 82197570h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R31);
		/* 82197570h case    1:*/		return 0x82197574;
		  /* 82197574h */ case    2:  		/* cmpwi CR6, R11, 1 */
		/* 82197574h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82197574h case    2:*/		return 0x82197578;
		  /* 82197578h */ case    3:  		/* bc 12, CR6_EQ, 6004 */
		/* 82197578h case    3:*/		if ( regs.CR[6].eq ) { return 0x82198CEC;  }
		/* 82197578h case    3:*/		return 0x8219757C;
		  /* 8219757Ch */ case    4:  		/* cmpwi CR6, R11, 2 */
		/* 8219757Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8219757Ch case    4:*/		return 0x82197580;
		  /* 82197580h */ case    5:  		/* bc 12, CR6_EQ, 5836 */
		/* 82197580h case    5:*/		if ( regs.CR[6].eq ) { return 0x82198C4C;  }
		/* 82197580h case    5:*/		return 0x82197584;
		  /* 82197584h */ case    6:  		/* cmpwi CR6, R11, 3 */
		/* 82197584h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 82197584h case    6:*/		return 0x82197588;
		  /* 82197588h */ case    7:  		/* bc 12, CR6_EQ, 2592 */
		/* 82197588h case    7:*/		if ( regs.CR[6].eq ) { return 0x82197FA8;  }
		/* 82197588h case    7:*/		return 0x8219758C;
		  /* 8219758Ch */ case    8:  		/* cmpwi CR6, R11, 12 */
		/* 8219758Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000C);
		/* 8219758Ch case    8:*/		return 0x82197590;
		  /* 82197590h */ case    9:  		/* bc 12, CR6_EQ, 1940 */
		/* 82197590h case    9:*/		if ( regs.CR[6].eq ) { return 0x82197D24;  }
		/* 82197590h case    9:*/		return 0x82197594;
		  /* 82197594h */ case   10:  		/* cmpwi CR6, R11, 18 */
		/* 82197594h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000012);
		/* 82197594h case   10:*/		return 0x82197598;
		  /* 82197598h */ case   11:  		/* bc 12, CR6_EQ, 580 */
		/* 82197598h case   11:*/		if ( regs.CR[6].eq ) { return 0x821977DC;  }
		/* 82197598h case   11:*/		return 0x8219759C;
		  /* 8219759Ch */ case   12:  		/* cmpwi CR6, R11, 55 */
		/* 8219759Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000037);
		/* 8219759Ch case   12:*/		return 0x821975A0;
		  /* 821975A0h */ case   13:  		/* bc 12, CR6_EQ, 500 */
		/* 821975A0h case   13:*/		if ( regs.CR[6].eq ) { return 0x82197794;  }
		/* 821975A0h case   13:*/		return 0x821975A4;
		  /* 821975A4h */ case   14:  		/* cmpwi CR6, R11, 110 */
		/* 821975A4h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006E);
		/* 821975A4h case   14:*/		return 0x821975A8;
		  /* 821975A8h */ case   15:  		/* bc 4, CR6_EQ, 416 */
		/* 821975A8h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 821975A8h case   15:*/		return 0x821975AC;
		  /* 821975ACh */ case   16:  		/* lwz R31, <#[R14 + 4]> */
		/* 821975ACh case   16:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R14 + 0x00000004) );
		/* 821975ACh case   16:*/		return 0x821975B0;
		  /* 821975B0h */ case   17:  		/* addi R29, R14, 4 */
		/* 821975B0h case   17:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R14,0x4);
		/* 821975B0h case   17:*/		return 0x821975B4;
		  /* 821975B4h */ case   18:  		/* cmplwi CR6, R31, 0 */
		/* 821975B4h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821975B4h case   18:*/		return 0x821975B8;
	}
	return 0x821975B8;
} // Block from 8219756Ch-821975B8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821975B8h
// Function '?MakeInstr_V_SETGT@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821975B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821975B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821975B8);
		  /* 821975B8h */ case    0:  		/* bc 12, CR6_EQ, 172 */
		/* 821975B8h case    0:*/		if ( regs.CR[6].eq ) { return 0x82197664;  }
		/* 821975B8h case    0:*/		return 0x821975BC;
		  /* 821975BCh */ case    1:  		/* lwz R11, <#[R31 + 16]> */
		/* 821975BCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821975BCh case    1:*/		return 0x821975C0;
		  /* 821975C0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821975C0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821975C0h case    2:*/		return 0x821975C4;
		  /* 821975C4h */ case    3:  		/* bc 12, CR6_EQ, 104 */
		/* 821975C4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219762C;  }
		/* 821975C4h case    3:*/		return 0x821975C8;
		  /* 821975C8h */ case    4:  		/* lwz R30, <#[R31]> */
		/* 821975C8h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 821975C8h case    4:*/		return 0x821975CC;
		  /* 821975CCh */ case    5:  		/* rlwinm. R11, R30, 0, 4, 6 */
		/* 821975CCh case    5:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R30);
		/* 821975CCh case    5:*/		return 0x821975D0;
		  /* 821975D0h */ case    6:  		/* bc 12, CR0_EQ, 92 */
		/* 821975D0h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219762C;  }
		/* 821975D0h case    6:*/		return 0x821975D4;
		  /* 821975D4h */ case    7:  		/* mr R3, R31 */
		/* 821975D4h case    7:*/		regs.R3 = regs.R31;
		/* 821975D4h case    7:*/		return 0x821975D8;
		  /* 821975D8h */ case    8:  		/* bl -209816 */
		/* 821975D8h case    8:*/		regs.LR = 0x821975DC; return 0x82164240;
		/* 821975D8h case    8:*/		return 0x821975DC;
		  /* 821975DCh */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 821975DCh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821975DCh case    9:*/		return 0x821975E0;
		  /* 821975E0h */ case   10:  		/* bc 12, CR0_EQ, 24 */
		/* 821975E0h case   10:*/		if ( regs.CR[0].eq ) { return 0x821975F8;  }
		/* 821975E0h case   10:*/		return 0x821975E4;
		  /* 821975E4h */ case   11:  		/* addi R11, R3, -1 */
		/* 821975E4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 821975E4h case   11:*/		return 0x821975E8;
		  /* 821975E8h */ case   12:  		/* andc R11, R3, R11 */
		/* 821975E8h case   12:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821975E8h case   12:*/		return 0x821975EC;
		  /* 821975ECh */ case   13:  		/* subf. R11, R11, R3 */
		/* 821975ECh case   13:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R11,regs.R3);
		/* 821975ECh case   13:*/		return 0x821975F0;
		  /* 821975F0h */ case   14:  		/* mr R11, R19 */
		/* 821975F0h case   14:*/		regs.R11 = regs.R19;
		/* 821975F0h case   14:*/		return 0x821975F4;
		  /* 821975F4h */ case   15:  		/* bc 12, CR0_EQ, 8 */
		/* 821975F4h case   15:*/		if ( regs.CR[0].eq ) { return 0x821975FC;  }
		/* 821975F4h case   15:*/		return 0x821975F8;
	}
	return 0x821975F8;
} // Block from 821975B8h-821975F8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821975F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821975F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821975F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821975F8);
		  /* 821975F8h */ case    0:  		/* mr R11, R18 */
		/* 821975F8h case    0:*/		regs.R11 = regs.R18;
		/* 821975F8h case    0:*/		return 0x821975FC;
	}
	return 0x821975FC;
} // Block from 821975F8h-821975FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821975FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821975FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821975FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821975FC);
		  /* 821975FCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821975FCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821975FCh case    0:*/		return 0x82197600;
		  /* 82197600h */ case    1:  		/* bc 12, CR0_EQ, 328 */
		/* 82197600h case    1:*/		if ( regs.CR[0].eq ) { return 0x82197748;  }
		/* 82197600h case    1:*/		return 0x82197604;
		  /* 82197604h */ case    2:  		/* rlwinm R11, R30, 27, 30, 31 */
		/* 82197604h case    2:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R30);
		/* 82197604h case    2:*/		return 0x82197608;
		  /* 82197608h */ case    3:  		/* rlwinm R4, R30, 0, 27, 31 */
		/* 82197608h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R30);
		/* 82197608h case    3:*/		return 0x8219760C;
		  /* 8219760Ch */ case    4:  		/* addi R11, R11, 11 */
		/* 8219760Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB);
		/* 8219760Ch case    4:*/		return 0x82197610;
		  /* 82197610h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82197610h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82197610h case    5:*/		return 0x82197614;
		  /* 82197614h */ case    6:  		/* lwzx R11, <#[R11 + R14]> */
		/* 82197614h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R14 + 0x00000000) );
		/* 82197614h case    6:*/		return 0x82197618;
		  /* 82197618h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 82197618h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82197618h case    7:*/		return 0x8219761C;
		  /* 8219761Ch */ case    8:  		/* rlwinm R3, R11, 0, 27, 31 */
		/* 8219761Ch case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R3,regs.R11);
		/* 8219761Ch case    8:*/		return 0x82197620;
		  /* 82197620h */ case    9:  		/* bl -5240 */
		/* 82197620h case    9:*/		regs.LR = 0x82197624; return 0x821961A8;
		/* 82197620h case    9:*/		return 0x82197624;
		  /* 82197624h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82197624h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82197624h case   10:*/		return 0x82197628;
		  /* 82197628h */ case   11:  		/* bc 12, CR0_EQ, 288 */
		/* 82197628h case   11:*/		if ( regs.CR[0].eq ) { return 0x82197748;  }
		/* 82197628h case   11:*/		return 0x8219762C;
	}
	return 0x8219762C;
} // Block from 821975FCh-8219762Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219762Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219762C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219762C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219762C);
		  /* 8219762Ch */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8219762Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8219762Ch case    0:*/		return 0x82197630;
		  /* 82197630h */ case    1:  		/* b -124 */
		/* 82197630h case    1:*/		return 0x821975B4;
		/* 82197630h case    1:*/		return 0x82197634;
	}
	return 0x82197634;
} // Block from 8219762Ch-82197634h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82197634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197634);
		  /* 82197634h */ case    0:  		/* li R4, 3555 */
		/* 82197634h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDE3);
		/* 82197634h case    0:*/		return 0x82197638;
		  /* 82197638h */ case    1:  		/* mr R3, R21 */
		/* 82197638h case    1:*/		regs.R3 = regs.R21;
		/* 82197638h case    1:*/		return 0x8219763C;
		  /* 8219763Ch */ case    2:  		/* bl -284628 */
		/* 8219763Ch case    2:*/		regs.LR = 0x82197640; return 0x82151E68;
		/* 8219763Ch case    2:*/		return 0x82197640;
	}
	return 0x82197640;
} // Block from 82197634h-82197640h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82197640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197640);
		  /* 82197640h */ case    0:  		/* li R4, 3556 */
		/* 82197640h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xDE4);
		/* 82197640h case    0:*/		return 0x82197644;
		  /* 82197644h */ case    1:  		/* mr R3, R21 */
		/* 82197644h case    1:*/		regs.R3 = regs.R21;
		/* 82197644h case    1:*/		return 0x82197648;
		  /* 82197648h */ case    2:  		/* bl -284640 */
		/* 82197648h case    2:*/		regs.LR = 0x8219764C; return 0x82151E68;
		/* 82197648h case    2:*/		return 0x8219764C;
	}
	return 0x8219764C;
} // Block from 82197640h-8219764Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219764Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219764C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219764C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219764C);
		  /* 8219764Ch */ case    0:  		/* li R4, 3629 */
		/* 8219764Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE2D);
		/* 8219764Ch case    0:*/		return 0x82197650;
		  /* 82197650h */ case    1:  		/* mr R3, R21 */
		/* 82197650h case    1:*/		regs.R3 = regs.R21;
		/* 82197650h case    1:*/		return 0x82197654;
		  /* 82197654h */ case    2:  		/* bl -284652 */
		/* 82197654h case    2:*/		regs.LR = 0x82197658; return 0x82151E68;
		/* 82197654h case    2:*/		return 0x82197658;
	}
	return 0x82197658;
} // Block from 8219764Ch-82197658h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82197658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197658);
		  /* 82197658h */ case    0:  		/* li R4, 3629 */
		/* 82197658h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE2D);
		/* 82197658h case    0:*/		return 0x8219765C;
		  /* 8219765Ch */ case    1:  		/* mr R3, R21 */
		/* 8219765Ch case    1:*/		regs.R3 = regs.R21;
		/* 8219765Ch case    1:*/		return 0x82197660;
		  /* 82197660h */ case    2:  		/* bl -284664 */
		/* 82197660h case    2:*/		regs.LR = 0x82197664; return 0x82151E68;
		/* 82197660h case    2:*/		return 0x82197664;
	}
	return 0x82197664;
} // Block from 82197658h-82197664h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82197664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197664);
		  /* 82197664h */ case    0:  		/* lwz R31, <#[R29]> */
		/* 82197664h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 82197664h case    0:*/		return 0x82197668;
		  /* 82197668h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 82197668h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82197668h case    1:*/		return 0x8219766C;
		  /* 8219766Ch */ case    2:  		/* bc 12, CR6_EQ, 204 */
		/* 8219766Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82197738;  }
		/* 8219766Ch case    2:*/		return 0x82197670;
		  /* 82197670h */ case    3:  		/* lwz R11, <#[R31 + 16]> */
		/* 82197670h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82197670h case    3:*/		return 0x82197674;
		  /* 82197674h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82197674h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82197674h case    4:*/		return 0x82197678;
		  /* 82197678h */ case    5:  		/* bc 12, CR6_EQ, 172 */
		/* 82197678h case    5:*/		if ( regs.CR[6].eq ) { return 0x82197724;  }
		/* 82197678h case    5:*/		return 0x8219767C;
		  /* 8219767Ch */ case    6:  		/* lwz R11, <#[R31]> */
		/* 8219767Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219767Ch case    6:*/		return 0x82197680;
		  /* 82197680h */ case    7:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 82197680h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 82197680h case    7:*/		return 0x82197684;
		  /* 82197684h */ case    8:  		/* bc 12, CR0_EQ, 160 */
		/* 82197684h case    8:*/		if ( regs.CR[0].eq ) { return 0x82197724;  }
		/* 82197684h case    8:*/		return 0x82197688;
	}
	return 0x82197688;
} // Block from 82197664h-82197688h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82197688h
// Function '?MakeInstr_V_SETGE@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197688);
		  /* 82197688h */ case    0:  		/* rlwinm R11, R11, 27, 30, 31 */
		/* 82197688h case    0:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R11);
		/* 82197688h case    0:*/		return 0x8219768C;
		  /* 8219768Ch */ case    1:  		/* addi R10, R11, 11 */
		/* 8219768Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xB);
		/* 8219768Ch case    1:*/		return 0x82197690;
		  /* 82197690h */ case    2:  		/* lwz R11, <#[R31 + 12]> */
		/* 82197690h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82197690h case    2:*/		return 0x82197694;
		  /* 82197694h */ case    3:  		/* rlwinm R9, R10, 2, 0, 29 */
		/* 82197694h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R10);
		/* 82197694h case    3:*/		return 0x82197698;
		  /* 82197698h */ case    4:  		/* addi R10, R11, 4 */
		/* 82197698h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82197698h case    4:*/		return 0x8219769C;
		  /* 8219769Ch */ case    5:  		/* lwzx R11, <#[R9 + R14]> */
		/* 8219769Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R14 + 0x00000000) );
		/* 8219769Ch case    5:*/		return 0x821976A0;
		  /* 821976A0h */ case    6:  		/* lwz R9, <#[R10]> */
		/* 821976A0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821976A0h case    6:*/		return 0x821976A4;
		  /* 821976A4h */ case    7:  		/* lwz R7, <#[R11]> */
		/* 821976A4h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821976A4h case    7:*/		return 0x821976A8;
		  /* 821976A8h */ case    8:  		/* lwz R8, <#[R11 + 12]> */
		/* 821976A8h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 821976A8h case    8:*/		return 0x821976AC;
		  /* 821976ACh */ case    9:  		/* rlwinm R30, R7, 27, 30, 31 */
		/* 821976ACh case    9:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R30,regs.R7);
		/* 821976ACh case    9:*/		return 0x821976B0;
		  /* 821976B0h */ case   10:  		/* b 12 */
		/* 821976B0h case   10:*/		return 0x821976BC;
		/* 821976B0h case   10:*/		return 0x821976B4;
		  /* 821976B4h */ case   11:  		/* addi R10, R9, 8 */
		/* 821976B4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821976B4h case   11:*/		return 0x821976B8;
		  /* 821976B8h */ case   12:  		/* lwz R9, <#[R9 + 8]> */
		/* 821976B8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821976B8h case   12:*/		return 0x821976BC;
	}
	return 0x821976BC;
} // Block from 82197688h-821976BCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821976BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821976BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821976BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821976BC);
		  /* 821976BCh */ case    0:  		/* cmplw CR6, R9, R31 */
		/* 821976BCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 821976BCh case    0:*/		return 0x821976C0;
		  /* 821976C0h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821976C0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821976B4;  }
		/* 821976C0h case    1:*/		return 0x821976C4;
		  /* 821976C4h */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 821976C4h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821976C4h case    2:*/		return 0x821976C8;
		  /* 821976C8h */ case    3:  		/* stw R9, <#[R10]> */
		/* 821976C8h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821976C8h case    3:*/		return 0x821976CC;
		  /* 821976CCh */ case    4:  		/* lwz R10, <#[R8 + 4]> */
		/* 821976CCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 821976CCh case    4:*/		return 0x821976D0;
		  /* 821976D0h */ case    5:  		/* stw R10, <#[R31 + 8]> */
		/* 821976D0h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821976D0h case    5:*/		return 0x821976D4;
		  /* 821976D4h */ case    6:  		/* stw R31, <#[R8 + 4]> */
		/* 821976D4h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R8 + 0x00000004) );
		/* 821976D4h case    6:*/		return 0x821976D8;
		  /* 821976D8h */ case    7:  		/* stw R8, <#[R31 + 12]> */
		/* 821976D8h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x0000000C) );
		/* 821976D8h case    7:*/		return 0x821976DC;
		  /* 821976DCh */ case    8:  		/* lwz R11, <#[R11]> */
		/* 821976DCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821976DCh case    8:*/		return 0x821976E0;
		  /* 821976E0h */ case    9:  		/* rlwinm R3, R11, 0, 27, 31 */
		/* 821976E0h case    9:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R3,regs.R11);
		/* 821976E0h case    9:*/		return 0x821976E4;
		  /* 821976E4h */ case   10:  		/* lwz R10, <#[R31]> */
		/* 821976E4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821976E4h case   10:*/		return 0x821976E8;
		  /* 821976E8h */ case   11:  		/* rlwinm R4, R10, 0, 27, 31 */
		/* 821976E8h case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R10);
		/* 821976E8h case   11:*/		return 0x821976EC;
		  /* 821976ECh */ case   12:  		/* bl -130164 */
		/* 821976ECh case   12:*/		regs.LR = 0x821976F0; return 0x82177A78;
		/* 821976ECh case   12:*/		return 0x821976F0;
		  /* 821976F0h */ case   13:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 821976F0h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 821976F0h case   13:*/		return 0x821976F4;
		  /* 821976F4h */ case   14:  		/* rlwinm R10, R30, 0, 26, 31 */
		/* 821976F4h case   14:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R30);
		/* 821976F4h case   14:*/		return 0x821976F8;
		  /* 821976F8h */ case   15:  		/* lwz R9, <#[R31]> */
		/* 821976F8h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821976F8h case   15:*/		return 0x821976FC;
		  /* 821976FCh */ case   16:  		/* or R11, R11, R30 */
		/* 821976FCh case   16:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 821976FCh case   16:*/		return 0x82197700;
		  /* 82197700h */ case   17:  		/* rlwinm R8, R30, 0, 24, 31 */
		/* 82197700h case   17:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R8,regs.R30);
		/* 82197700h case   17:*/		return 0x82197704;
		  /* 82197704h */ case   18:  		/* rlwinm R11, R11, 2, 26, 29 */
		/* 82197704h case   18:*/		cpu::op::rlwinm<0,2,26,29>(regs,&regs.R11,regs.R11);
		/* 82197704h case   18:*/		return 0x82197708;
		  /* 82197708h */ case   19:  		/* or R11, R11, R10 */
		/* 82197708h case   19:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82197708h case   19:*/		return 0x8219770C;
		  /* 8219770Ch */ case   20:  		/* rlwinm R10, R9, 0, 0, 18 */
		/* 8219770Ch case   20:*/		cpu::op::rlwinm<0,0,0,18>(regs,&regs.R10,regs.R9);
		/* 8219770Ch case   20:*/		return 0x82197710;
		  /* 82197710h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82197710h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82197710h case   21:*/		return 0x82197714;
		  /* 82197714h */ case   22:  		/* or R11, R11, R8 */
		/* 82197714h case   22:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82197714h case   22:*/		return 0x82197718;
		  /* 82197718h */ case   23:  		/* rlwimi R3, R11, 5, 0, 26 */
		/* 82197718h case   23:*/		cpu::op::rlwimi<0,5,0,26>(regs,&regs.R3,regs.R11);
		/* 82197718h case   23:*/		return 0x8219771C;
		  /* 8219771Ch */ case   24:  		/* or R11, R3, R10 */
		/* 8219771Ch case   24:*/		cpu::op::or<0>(regs,&regs.R11,regs.R3,regs.R10);
		/* 8219771Ch case   24:*/		return 0x82197720;
		  /* 82197720h */ case   25:  		/* stw R11, <#[R31]> */
		/* 82197720h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82197720h case   25:*/		return 0x82197724;
	}
	return 0x82197724;
} // Block from 821976BCh-82197724h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82197724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197724);
		  /* 82197724h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 82197724h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82197724h case    0:*/		return 0x82197728;
		  /* 82197728h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 82197728h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82197728h case    1:*/		return 0x8219772C;
		  /* 8219772Ch */ case    2:  		/* bc 4, CR6_EQ, -200 */
		/* 8219772Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82197664;  }
		/* 8219772Ch case    2:*/		return 0x82197730;
		  /* 82197730h */ case    3:  		/* addi R29, R31, 8 */
		/* 82197730h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x8);
		/* 82197730h case    3:*/		return 0x82197734;
		  /* 82197734h */ case    4:  		/* b -208 */
		/* 82197734h case    4:*/		return 0x82197664;
		/* 82197734h case    4:*/		return 0x82197738;
	}
	return 0x82197738;
} // Block from 82197724h-82197738h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82197738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197738);
		  /* 82197738h */ case    0:  		/* mr R3, R14 */
		/* 82197738h case    0:*/		regs.R3 = regs.R14;
		/* 82197738h case    0:*/		return 0x8219773C;
		  /* 8219773Ch */ case    1:  		/* bl -208316 */
		/* 8219773Ch case    1:*/		regs.LR = 0x82197740; return 0x82164980;
		/* 8219773Ch case    1:*/		return 0x82197740;
		  /* 82197740h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82197740h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82197740h case    2:*/		return 0x82197744;
		  /* 82197744h */ case    3:  		/* bc 4, CR0_EQ, 7076 */
		/* 82197744h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821992E8;  }
		/* 82197744h case    3:*/		return 0x82197748;
	}
	return 0x82197748;
} // Block from 82197738h-82197748h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82197748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197748);
		  /* 82197748h */ case    0:  		/* lwz R11, <#[R1 + 92]> */
		/* 82197748h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82197748h case    0:*/		return 0x8219774C;
		  /* 8219774Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8219774Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219774Ch case    1:*/		return 0x82197750;
		  /* 82197750h */ case    2:  		/* bc 12, CR6_EQ, 7008 */
		/* 82197750h case    2:*/		if ( regs.CR[6].eq ) { return 0x821992B0;  }
		/* 82197750h case    2:*/		return 0x82197754;
		  /* 82197754h */ case    3:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82197754h case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82197754h case    3:*/		return 0x82197758;
	}
	return 0x82197758;
} // Block from 82197748h-82197758h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82197758h
// Function '?MakeInstr_V_MULADD@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@22@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197758);
		  /* 82197758h */ case    0:  		/* lwz R11, <#[R11 + 40]> */
		/* 82197758h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82197758h case    0:*/		return 0x8219775C;
		  /* 8219775Ch */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219775Ch case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219775Ch case    1:*/		return 0x82197760;
		  /* 82197760h */ case    2:  		/* addic R10, R10, -1 */
		/* 82197760h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82197760h case    2:*/		return 0x82197764;
		  /* 82197764h */ case    3:  		/* subfe R10, R10, R10 */
		/* 82197764h case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82197764h case    3:*/		return 0x82197768;
		  /* 82197768h */ case    4:  		/* and R10, R10, R11 */
		/* 82197768h case    4:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82197768h case    4:*/		return 0x8219776C;
		  /* 8219776Ch */ case    5:  		/* cmplw CR6, R14, R10 */
		/* 8219776Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R14,regs.R10);
		/* 8219776Ch case    5:*/		return 0x82197770;
		  /* 82197770h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 82197770h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82197780;  }
		/* 82197770h case    6:*/		return 0x82197774;
		  /* 82197774h */ case    7:  		/* rlwinm R11, R14, 0, 0, 30 */
		/* 82197774h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R14);
		/* 82197774h case    7:*/		return 0x82197778;
		  /* 82197778h */ case    8:  		/* stw R14, <#[R1 + 92]> */
		/* 82197778h case    8:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x0000005C) );
		/* 82197778h case    8:*/		return 0x8219777C;
		  /* 8219777Ch */ case    9:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219777Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219777Ch case    9:*/		return 0x82197780;
	}
	return 0x82197780;
} // Block from 82197758h-82197780h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82197780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197780);
		  /* 82197780h */ case    0:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 82197780h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82197780h case    0:*/		return 0x82197784;
		  /* 82197784h */ case    1:  		/* addic R10, R10, -1 */
		/* 82197784h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82197784h case    1:*/		return 0x82197788;
		  /* 82197788h */ case    2:  		/* subfe R10, R10, R10 */
		/* 82197788h case    2:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82197788h case    2:*/		return 0x8219778C;
		  /* 8219778Ch */ case    3:  		/* and R14, R10, R11 */
		/* 8219778Ch case    3:*/		cpu::op::and<0>(regs,&regs.R14,regs.R10,regs.R11);
		/* 8219778Ch case    3:*/		return 0x82197790;
		  /* 82197790h */ case    4:  		/* b -596 */
		/* 82197790h case    4:*/		return 0x8219753C;
		/* 82197790h case    4:*/		return 0x82197794;
	}
	return 0x82197794;
} // Block from 82197780h-82197794h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82197794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197794);
		  /* 82197794h */ case    0:  		/* lwz R11, <#[R14 + 44]> */
		/* 82197794h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000002C) );
		/* 82197794h case    0:*/		return 0x82197798;
		  /* 82197798h */ case    1:  		/* lwz R10, <#[R11]> */
		/* 82197798h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82197798h case    1:*/		return 0x8219779C;
		  /* 8219779Ch */ case    2:  		/* rlwinm R9, R10, 30, 2, 31 */
		/* 8219779Ch case    2:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R9,regs.R10);
		/* 8219779Ch case    2:*/		return 0x821977A0;
		  /* 821977A0h */ case    3:  		/* xor R9, R9, R10 */
		/* 821977A0h case    3:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 821977A0h case    3:*/		return 0x821977A4;
		  /* 821977A4h */ case    4:  		/* rlwinm. R9, R9, 0, 25, 26 */
		/* 821977A4h case    4:*/		cpu::op::rlwinm<1,0,25,26>(regs,&regs.R9,regs.R9);
		/* 821977A4h case    4:*/		return 0x821977A8;
		  /* 821977A8h */ case    5:  		/* bc 4, CR0_EQ, -96 */
		/* 821977A8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 821977A8h case    5:*/		return 0x821977AC;
		  /* 821977ACh */ case    6:  		/* lwz R31, <#[R11 + 12]> */
		/* 821977ACh case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 821977ACh case    6:*/		return 0x821977B0;
		  /* 821977B0h */ case    7:  		/* lwz R9, <#[R31 + 8]> */
		/* 821977B0h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821977B0h case    7:*/		return 0x821977B4;
		  /* 821977B4h */ case    8:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 821977B4h case    8:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 821977B4h case    8:*/		return 0x821977B8;
		  /* 821977B8h */ case    9:  		/* cmplwi CR6, R9, 1408 */
		/* 821977B8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000580);
		/* 821977B8h case    9:*/		return 0x821977BC;
		  /* 821977BCh */ case   10:  		/* bc 4, CR6_EQ, -116 */
		/* 821977BCh case   10:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 821977BCh case   10:*/		return 0x821977C0;
		  /* 821977C0h */ case   11:  		/* rlwinm. R10, R10, 0, 27, 31 */
		/* 821977C0h case   11:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R10,regs.R10);
		/* 821977C0h case   11:*/		return 0x821977C4;
		  /* 821977C4h */ case   12:  		/* bc 4, CR0_EQ, -124 */
		/* 821977C4h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 821977C4h case   12:*/		return 0x821977C8;
		  /* 821977C8h */ case   13:  		/* lwz R8, <#[R31 + 44]> */
		/* 821977C8h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000002C) );
		/* 821977C8h case   13:*/		return 0x821977CC;
		  /* 821977CCh */ case   14:  		/* addi R9, R31, 4 */
		/* 821977CCh case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x4);
		/* 821977CCh case   14:*/		return 0x821977D0;
		  /* 821977D0h */ case   15:  		/* lwz R7, <#[R31 + 4]> */
		/* 821977D0h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000004) );
		/* 821977D0h case   15:*/		return 0x821977D4;
		  /* 821977D4h */ case   16:  		/* lwz R10, <#[R8 + 12]> */
		/* 821977D4h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x0000000C) );
		/* 821977D4h case   16:*/		return 0x821977D8;
		  /* 821977D8h */ case   17:  		/* b 6964 */
		/* 821977D8h case   17:*/		return 0x8219930C;
		/* 821977D8h case   17:*/		return 0x821977DC;
	}
	return 0x821977DC;
} // Block from 82197794h-821977DCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 821977DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821977DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821977DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821977DC);
		  /* 821977DCh */ case    0:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821977DCh case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821977DCh case    0:*/		return 0x821977E0;
		  /* 821977E0h */ case    1:  		/* bc 4, CR0_EQ, -152 */
		/* 821977E0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 821977E0h case    1:*/		return 0x821977E4;
		  /* 821977E4h */ case    2:  		/* lis R24, 512 */
		/* 821977E4h case    2:*/		cpu::op::lis<0>(regs,&regs.R24,0x200);
		/* 821977E4h case    2:*/		return 0x821977E8;
		  /* 821977E8h */ case    3:  		/* lwz R11, <#[R14 + 8]> */
		/* 821977E8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 821977E8h case    3:*/		return 0x821977EC;
		  /* 821977ECh */ case    4:  		/* rlwinm R11, R11, 0, 15, 17 */
		/* 821977ECh case    4:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R11);
		/* 821977ECh case    4:*/		return 0x821977F0;
		  /* 821977F0h */ case    5:  		/* cmplwi CR6, R11, 16384 */
		/* 821977F0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00004000);
		/* 821977F0h case    5:*/		return 0x821977F4;
		  /* 821977F4h */ case    6:  		/* bc 4, CR6_EQ, -172 */
		/* 821977F4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 821977F4h case    6:*/		return 0x821977F8;
		  /* 821977F8h */ case    7:  		/* lwz R26, <#[R14 + 52]> */
		/* 821977F8h case    7:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R14 + 0x00000034) );
		/* 821977F8h case    7:*/		return 0x821977FC;
		  /* 821977FCh */ case    8:  		/* lwz R11, <#[R26]> */
		/* 821977FCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821977FCh case    8:*/		return 0x82197800;
		  /* 82197800h */ case    9:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 82197800h case    9:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82197800h case    9:*/		return 0x82197804;
		  /* 82197804h */ case   10:  		/* bc 4, CR0_EQ, -188 */
		/* 82197804h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82197804h case   10:*/		return 0x82197808;
		  /* 82197808h */ case   11:  		/* lwz R27, <#[R26 + 12]> */
		/* 82197808h case   11:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R26 + 0x0000000C) );
		/* 82197808h case   11:*/		return 0x8219780C;
		  /* 8219780Ch */ case   12:  		/* lwz R11, <#[R27 + 8]> */
		/* 8219780Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219780Ch case   12:*/		return 0x82197810;
		  /* 82197810h */ case   13:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 82197810h case   13:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 82197810h case   13:*/		return 0x82197814;
		  /* 82197814h */ case   14:  		/* cmplwi CR6, R10, 128 */
		/* 82197814h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000080);
		/* 82197814h case   14:*/		return 0x82197818;
		  /* 82197818h */ case   15:  		/* bc 4, CR6_EQ, -208 */
		/* 82197818h case   15:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 82197818h case   15:*/		return 0x8219781C;
		  /* 8219781Ch */ case   16:  		/* rlwinm R11, R11, 0, 15, 17 */
		/* 8219781Ch case   16:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R11);
		/* 8219781Ch case   16:*/		return 0x82197820;
		  /* 82197820h */ case   17:  		/* cmplwi CR6, R11, 16384 */
		/* 82197820h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00004000);
		/* 82197820h case   17:*/		return 0x82197824;
		  /* 82197824h */ case   18:  		/* bc 4, CR6_EQ, -220 */
		/* 82197824h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 82197824h case   18:*/		return 0x82197828;
		  /* 82197828h */ case   19:  		/* lwz R11, <#[R27 + 4]> */
		/* 82197828h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82197828h case   19:*/		return 0x8219782C;
		  /* 8219782Ch */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 8219782Ch case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219782Ch case   20:*/		return 0x82197830;
		  /* 82197830h */ case   21:  		/* bc 12, CR6_EQ, 32 */
		/* 82197830h case   21:*/		if ( regs.CR[6].eq ) { return 0x82197850;  }
		/* 82197830h case   21:*/		return 0x82197834;
		  /* 82197834h */ case   22:  		/* lwz R10, <#[R11 + 16]> */
		/* 82197834h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82197834h case   22:*/		return 0x82197838;
		  /* 82197838h */ case   23:  		/* cmplwi CR6, R10, 0 */
		/* 82197838h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82197838h case   23:*/		return 0x8219783C;
		  /* 8219783Ch */ case   24:  		/* bc 12, CR6_EQ, 12 */
		/* 8219783Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x82197848;  }
		/* 8219783Ch case   24:*/		return 0x82197840;
		  /* 82197840h */ case   25:  		/* cmplw CR6, R11, R26 */
		/* 82197840h case   25:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 82197840h case   25:*/		return 0x82197844;
		  /* 82197844h */ case   26:  		/* bc 4, CR6_EQ, -252 */
		/* 82197844h case   26:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 82197844h case   26:*/		return 0x82197848;
	}
	return 0x82197848;
} // Block from 821977DCh-82197848h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82197848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197848);
		  /* 82197848h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82197848h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82197848h case    0:*/		return 0x8219784C;
		  /* 8219784Ch */ case    1:  		/* b -32 */
		/* 8219784Ch case    1:*/		return 0x8219782C;
		/* 8219784Ch case    1:*/		return 0x82197850;
	}
	return 0x82197850;
} // Block from 82197848h-82197850h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82197850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197850);
		  /* 82197850h */ case    0:  		/* lwz R28, <#[R14 + 44]> */
		/* 82197850h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R14 + 0x0000002C) );
		/* 82197850h case    0:*/		return 0x82197854;
		  /* 82197854h */ case    1:  		/* mr R29, R18 */
		/* 82197854h case    1:*/		regs.R29 = regs.R18;
		/* 82197854h case    1:*/		return 0x82197858;
	}
	return 0x82197858;
} // Block from 82197850h-82197858h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82197858h
// Function '?AllocMemForBitSet@D3DXShader@@YAPAXPAXK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197858);
		  /* 82197858h */ case    0:  		/* lwz R25, <#[R14 + 48]> */
		/* 82197858h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R14 + 0x00000030) );
		/* 82197858h case    0:*/		return 0x8219785C;
		  /* 8219785Ch */ case    1:  		/* addi R30, R27, 44 */
		/* 8219785Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R27,0x2C);
		/* 8219785Ch case    1:*/		return 0x82197860;
	}
	return 0x82197860;
} // Block from 82197858h-82197860h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82197860h
// Function '?LatePeeps@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197860);
		  /* 82197860h */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 82197860h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82197860h case    0:*/		return 0x82197864;
		  /* 82197864h */ case    1:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 82197864h case    1:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 82197864h case    1:*/		return 0x82197868;
		  /* 82197868h */ case    2:  		/* cmplw CR6, R29, R11 */
		/* 82197868h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 82197868h case    2:*/		return 0x8219786C;
		  /* 8219786Ch */ case    3:  		/* bc 4, CR6_LT, -292 */
		/* 8219786Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x82197748;  }
		/* 8219786Ch case    3:*/		return 0x82197870;
		  /* 82197870h */ case    4:  		/* lwz R31, <#[R30]> */
		/* 82197870h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82197870h case    4:*/		return 0x82197874;
		  /* 82197874h */ case    5:  		/* stw R28, <#[R1 + 104]> */
		/* 82197874h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000068) );
		/* 82197874h case    5:*/		return 0x82197878;
		  /* 82197878h */ case    6:  		/* stw R25, <#[R1 + 112]> */
		/* 82197878h case    6:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000070) );
		/* 82197878h case    6:*/		return 0x8219787C;
		  /* 8219787Ch */ case    7:  		/* stw R31, <#[R1 + 80]> */
		/* 8219787Ch case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 8219787Ch case    7:*/		return 0x82197880;
		  /* 82197880h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 82197880h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82197880h case    8:*/		return 0x82197884;
		  /* 82197884h */ case    9:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 82197884h case    9:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82197884h case    9:*/		return 0x82197888;
		  /* 82197888h */ case   10:  		/* cmplw CR6, R11, R24 */
		/* 82197888h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 82197888h case   10:*/		return 0x8219788C;
		  /* 8219788Ch */ case   11:  		/* bc 12, CR6_EQ, 124 */
		/* 8219788Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82197908;  }
		/* 8219788Ch case   11:*/		return 0x82197890;
		  /* 82197890h */ case   12:  		/* mr R4, R31 */
		/* 82197890h case   12:*/		regs.R4 = regs.R31;
		/* 82197890h case   12:*/		return 0x82197894;
		  /* 82197894h */ case   13:  		/* lwz R5, <#[R31 + 12]> */
		/* 82197894h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82197894h case   13:*/		return 0x82197898;
		  /* 82197898h */ case   14:  		/* mr R3, R21 */
		/* 82197898h case   14:*/		regs.R3 = regs.R21;
		/* 82197898h case   14:*/		return 0x8219789C;
		  /* 8219789Ch */ case   15:  		/* bl -157612 */
		/* 8219789Ch case   15:*/		regs.LR = 0x821978A0; return 0x821710F0;
		/* 8219789Ch case   15:*/		return 0x821978A0;
		  /* 821978A0h */ case   16:  		/* stw R3, <#[R1 + 80]> */
		/* 821978A0h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 821978A0h case   16:*/		return 0x821978A4;
		  /* 821978A4h */ case   17:  		/* lwz R11, <#[R26]> */
		/* 821978A4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821978A4h case   17:*/		return 0x821978A8;
		  /* 821978A8h */ case   18:  		/* rlwinm R11, R11, 27, 30, 31 */
		/* 821978A8h case   18:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R11);
		/* 821978A8h case   18:*/		return 0x821978AC;
		  /* 821978ACh */ case   19:  		/* ori R11, R11, 228 */
		/* 821978ACh case   19:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xE4);
		/* 821978ACh case   19:*/		return 0x821978B0;
		  /* 821978B0h */ case   20:  		/* rlwinm R10, R11, 27, 29, 30 */
		/* 821978B0h case   20:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R10,regs.R11);
		/* 821978B0h case   20:*/		return 0x821978B4;
		  /* 821978B4h */ case   21:  		/* rlwinm R9, R11, 29, 29, 30 */
		/* 821978B4h case   21:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R9,regs.R11);
		/* 821978B4h case   21:*/		return 0x821978B8;
		  /* 821978B8h */ case   22:  		/* rlwinm R8, R11, 31, 29, 30 */
		/* 821978B8h case   22:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R8,regs.R11);
		/* 821978B8h case   22:*/		return 0x821978BC;
		  /* 821978BCh */ case   23:  		/* rlwinm R11, R11, 1, 29, 30 */
		/* 821978BCh case   23:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R11,regs.R11);
		/* 821978BCh case   23:*/		return 0x821978C0;
		  /* 821978C0h */ case   24:  		/* lwz R7, <#[R3]> */
		/* 821978C0h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x00000000) );
		/* 821978C0h case   24:*/		return 0x821978C4;
		  /* 821978C4h */ case   25:  		/* rlwinm R6, R7, 27, 24, 31 */
		/* 821978C4h case   25:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R7);
		/* 821978C4h case   25:*/		return 0x821978C8;
		  /* 821978C8h */ case   26:  		/* rlwinm R7, R7, 0, 27, 18 */
		/* 821978C8h case   26:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R7,regs.R7);
		/* 821978C8h case   26:*/		return 0x821978CC;
		  /* 821978CCh */ case   27:  		/* srw R10, R6, R10 */
		/* 821978CCh case   27:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R6,regs.R10);
		/* 821978CCh case   27:*/		return 0x821978D0;
		  /* 821978D0h */ case   28:  		/* srw R9, R6, R9 */
		/* 821978D0h case   28:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 821978D0h case   28:*/		return 0x821978D4;
		  /* 821978D4h */ case   29:  		/* rlwimi R9, R10, 2, 28, 29 */
		/* 821978D4h case   29:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R9,regs.R10);
		/* 821978D4h case   29:*/		return 0x821978D8;
		  /* 821978D8h */ case   30:  		/* srw R10, R6, R8 */
		/* 821978D8h case   30:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R6,regs.R8);
		/* 821978D8h case   30:*/		return 0x821978DC;
		  /* 821978DCh */ case   31:  		/* rlwinm R9, R9, 0, 28, 31 */
		/* 821978DCh case   31:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R9,regs.R9);
		/* 821978DCh case   31:*/		return 0x821978E0;
		  /* 821978E0h */ case   32:  		/* srw R11, R6, R11 */
		/* 821978E0h case   32:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 821978E0h case   32:*/		return 0x821978E4;
		  /* 821978E4h */ case   33:  		/* rlwimi R10, R9, 2, 0, 29 */
		/* 821978E4h case   33:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 821978E4h case   33:*/		return 0x821978E8;
		  /* 821978E8h */ case   34:  		/* rlwimi R11, R10, 2, 0, 29 */
		/* 821978E8h case   34:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 821978E8h case   34:*/		return 0x821978EC;
		  /* 821978ECh */ case   35:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821978ECh case   35:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821978ECh case   35:*/		return 0x821978F0;
		  /* 821978F0h */ case   36:  		/* or R11, R11, R7 */
		/* 821978F0h case   36:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 821978F0h case   36:*/		return 0x821978F4;
		  /* 821978F4h */ case   37:  		/* stw R11, <#[R3]> */
		/* 821978F4h case   37:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821978F4h case   37:*/		return 0x821978F8;
		  /* 821978F8h */ case   38:  		/* lwz R11, <#[R1 + 80]> */
		/* 821978F8h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821978F8h case   38:*/		return 0x821978FC;
		  /* 821978FCh */ case   39:  		/* lwz R10, <#[R11]> */
		/* 821978FCh case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821978FCh case   39:*/		return 0x82197900;
		  /* 82197900h */ case   40:  		/* rlwimi R10, R19, 25, 4, 6 */
		/* 82197900h case   40:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R10,regs.R19);
		/* 82197900h case   40:*/		return 0x82197904;
		  /* 82197904h */ case   41:  		/* stw R10, <#[R11]> */
		/* 82197904h case   41:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82197904h case   41:*/		return 0x82197908;
	}
	return 0x82197908;
} // Block from 82197860h-82197908h (42 instructions)

//////////////////////////////////////////////////////
// Block at 82197908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197908);
		  /* 82197908h */ case    0:  		/* addi R6, R1, 80 */
		/* 82197908h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82197908h case    0:*/		return 0x8219790C;
		  /* 8219790Ch */ case    1:  		/* addi R5, R1, 112 */
		/* 8219790Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 8219790Ch case    1:*/		return 0x82197910;
		  /* 82197910h */ case    2:  		/* addi R4, R1, 104 */
		/* 82197910h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x68);
		/* 82197910h case    2:*/		return 0x82197914;
		  /* 82197914h */ case    3:  		/* mr R3, R21 */
		/* 82197914h case    3:*/		regs.R3 = regs.R21;
		/* 82197914h case    3:*/		return 0x82197918;
		  /* 82197918h */ case    4:  		/* bl 32848 */
		/* 82197918h case    4:*/		regs.LR = 0x8219791C; return 0x8219F968;
		/* 82197918h case    4:*/		return 0x8219791C;
		  /* 8219791Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219791Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219791Ch case    5:*/		return 0x82197920;
		  /* 82197920h */ case    6:  		/* bc 12, CR0_EQ, 48 */
		/* 82197920h case    6:*/		if ( regs.CR[0].eq ) { return 0x82197950;  }
		/* 82197920h case    6:*/		return 0x82197924;
		  /* 82197924h */ case    7:  		/* addi R10, R1, 180 */
		/* 82197924h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xB4);
		/* 82197924h case    7:*/		return 0x82197928;
		  /* 82197928h */ case    8:  		/* lwz R8, <#[R1 + 80]> */
		/* 82197928h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 82197928h case    8:*/		return 0x8219792C;
		  /* 8219792Ch */ case    9:  		/* mr R9, R27 */
		/* 8219792Ch case    9:*/		regs.R9 = regs.R27;
		/* 8219792Ch case    9:*/		return 0x82197930;
		  /* 82197930h */ case   10:  		/* lwz R6, <#[R1 + 112]> */
		/* 82197930h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000070) );
		/* 82197930h case   10:*/		return 0x82197934;
		  /* 82197934h */ case   11:  		/* mr R7, R14 */
		/* 82197934h case   11:*/		regs.R7 = regs.R14;
		/* 82197934h case   11:*/		return 0x82197938;
		  /* 82197938h */ case   12:  		/* lwz R4, <#[R1 + 104]> */
		/* 82197938h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 82197938h case   12:*/		return 0x8219793C;
		  /* 8219793Ch */ case   13:  		/* mr R5, R14 */
		/* 8219793Ch case   13:*/		regs.R5 = regs.R14;
		/* 8219793Ch case   13:*/		return 0x82197940;
		  /* 82197940h */ case   14:  		/* mr R3, R21 */
		/* 82197940h case   14:*/		regs.R3 = regs.R21;
		/* 82197940h case   14:*/		return 0x82197944;
		  /* 82197944h */ case   15:  		/* bl 15012 */
		/* 82197944h case   15:*/		regs.LR = 0x82197948; return 0x8219B3E8;
		/* 82197944h case   15:*/		return 0x82197948;
		  /* 82197948h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82197948h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82197948h case   16:*/		return 0x8219794C;
		  /* 8219794Ch */ case   17:  		/* bc 4, CR0_EQ, 232 */
		/* 8219794Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x82197A34;  }
		/* 8219794Ch case   17:*/		return 0x82197950;
	}
	return 0x82197950;
} // Block from 82197908h-82197950h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82197950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197950);
		  /* 82197950h */ case    0:  		/* lwz R4, <#[R1 + 104]> */
		/* 82197950h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000068) );
		/* 82197950h case    0:*/		return 0x82197954;
		  /* 82197954h */ case    1:  		/* lwz R11, <#[R4 + 16]> */
		/* 82197954h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 82197954h case    1:*/		return 0x82197958;
		  /* 82197958h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82197958h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82197958h case    2:*/		return 0x8219795C;
		  /* 8219795Ch */ case    3:  		/* bc 4, CR6_EQ, 60 */
		/* 8219795Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82197998;  }
		/* 8219795Ch case    3:*/		return 0x82197960;
		  /* 82197960h */ case    4:  		/* lwz R11, <#[R4 + 12]> */
		/* 82197960h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82197960h case    4:*/		return 0x82197964;
		  /* 82197964h */ case    5:  		/* addi R10, R11, 4 */
		/* 82197964h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82197964h case    5:*/		return 0x82197968;
		  /* 82197968h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 82197968h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82197968h case    6:*/		return 0x8219796C;
		  /* 8219796Ch */ case    7:  		/* b 12 */
		/* 8219796Ch case    7:*/		return 0x82197978;
		/* 8219796Ch case    7:*/		return 0x82197970;
		  /* 82197970h */ case    8:  		/* addi R10, R11, 8 */
		/* 82197970h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 82197970h case    8:*/		return 0x82197974;
		  /* 82197974h */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 82197974h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82197974h case    9:*/		return 0x82197978;
	}
	return 0x82197978;
} // Block from 82197950h-82197978h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82197978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197978);
		  /* 82197978h */ case    0:  		/* cmplw CR6, R11, R4 */
		/* 82197978h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 82197978h case    0:*/		return 0x8219797C;
		  /* 8219797Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8219797Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82197970;  }
		/* 8219797Ch case    1:*/		return 0x82197980;
		  /* 82197980h */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 82197980h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82197980h case    2:*/		return 0x82197984;
		  /* 82197984h */ case    3:  		/* li R6, 26 */
		/* 82197984h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1A);
		/* 82197984h case    3:*/		return 0x82197988;
		  /* 82197988h */ case    4:  		/* li R5, 20 */
		/* 82197988h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x14);
		/* 82197988h case    4:*/		return 0x8219798C;
		  /* 8219798Ch */ case    5:  		/* mr R3, R21 */
		/* 8219798Ch case    5:*/		regs.R3 = regs.R21;
		/* 8219798Ch case    5:*/		return 0x82197990;
		  /* 82197990h */ case    6:  		/* stw R11, <#[R10]> */
		/* 82197990h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82197990h case    6:*/		return 0x82197994;
		  /* 82197994h */ case    7:  		/* bl -208124 */
		/* 82197994h case    7:*/		regs.LR = 0x82197998; return 0x82164C98;
		/* 82197994h case    7:*/		return 0x82197998;
	}
	return 0x82197998;
} // Block from 82197978h-82197998h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82197998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197998);
		  /* 82197998h */ case    0:  		/* lwz R4, <#[R1 + 112]> */
		/* 82197998h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000070) );
		/* 82197998h case    0:*/		return 0x8219799C;
		  /* 8219799Ch */ case    1:  		/* lwz R11, <#[R4 + 16]> */
		/* 8219799Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 8219799Ch case    1:*/		return 0x821979A0;
		  /* 821979A0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821979A0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821979A0h case    2:*/		return 0x821979A4;
		  /* 821979A4h */ case    3:  		/* bc 4, CR6_EQ, 60 */
		/* 821979A4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821979E0;  }
		/* 821979A4h case    3:*/		return 0x821979A8;
		  /* 821979A8h */ case    4:  		/* lwz R11, <#[R4 + 12]> */
		/* 821979A8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821979A8h case    4:*/		return 0x821979AC;
		  /* 821979ACh */ case    5:  		/* addi R10, R11, 4 */
		/* 821979ACh case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821979ACh case    5:*/		return 0x821979B0;
		  /* 821979B0h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 821979B0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821979B0h case    6:*/		return 0x821979B4;
		  /* 821979B4h */ case    7:  		/* b 12 */
		/* 821979B4h case    7:*/		return 0x821979C0;
		/* 821979B4h case    7:*/		return 0x821979B8;
		  /* 821979B8h */ case    8:  		/* addi R10, R11, 8 */
		/* 821979B8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 821979B8h case    8:*/		return 0x821979BC;
		  /* 821979BCh */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 821979BCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821979BCh case    9:*/		return 0x821979C0;
	}
	return 0x821979C0;
} // Block from 82197998h-821979C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821979C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821979C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821979C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821979C0);
		  /* 821979C0h */ case    0:  		/* cmplw CR6, R11, R4 */
		/* 821979C0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 821979C0h case    0:*/		return 0x821979C4;
		  /* 821979C4h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821979C4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821979B8;  }
		/* 821979C4h case    1:*/		return 0x821979C8;
		  /* 821979C8h */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 821979C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821979C8h case    2:*/		return 0x821979CC;
		  /* 821979CCh */ case    3:  		/* li R6, 26 */
		/* 821979CCh case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1A);
		/* 821979CCh case    3:*/		return 0x821979D0;
		  /* 821979D0h */ case    4:  		/* li R5, 20 */
		/* 821979D0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x14);
		/* 821979D0h case    4:*/		return 0x821979D4;
		  /* 821979D4h */ case    5:  		/* mr R3, R21 */
		/* 821979D4h case    5:*/		regs.R3 = regs.R21;
		/* 821979D4h case    5:*/		return 0x821979D8;
		  /* 821979D8h */ case    6:  		/* stw R11, <#[R10]> */
		/* 821979D8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821979D8h case    6:*/		return 0x821979DC;
		  /* 821979DCh */ case    7:  		/* bl -208196 */
		/* 821979DCh case    7:*/		regs.LR = 0x821979E0; return 0x82164C98;
		/* 821979DCh case    7:*/		return 0x821979E0;
	}
	return 0x821979E0;
} // Block from 821979C0h-821979E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821979E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821979E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821979E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821979E0);
		  /* 821979E0h */ case    0:  		/* lwz R4, <#[R1 + 80]> */
		/* 821979E0h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 821979E0h case    0:*/		return 0x821979E4;
		  /* 821979E4h */ case    1:  		/* lwz R11, <#[R4 + 16]> */
		/* 821979E4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 821979E4h case    1:*/		return 0x821979E8;
		  /* 821979E8h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821979E8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821979E8h case    2:*/		return 0x821979EC;
		  /* 821979ECh */ case    3:  		/* bc 4, CR6_EQ, 60 */
		/* 821979ECh case    3:*/		if ( !regs.CR[6].eq ) { return 0x82197A28;  }
		/* 821979ECh case    3:*/		return 0x821979F0;
		  /* 821979F0h */ case    4:  		/* lwz R11, <#[R4 + 12]> */
		/* 821979F0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821979F0h case    4:*/		return 0x821979F4;
		  /* 821979F4h */ case    5:  		/* addi R10, R11, 4 */
		/* 821979F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821979F4h case    5:*/		return 0x821979F8;
		  /* 821979F8h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 821979F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821979F8h case    6:*/		return 0x821979FC;
		  /* 821979FCh */ case    7:  		/* b 12 */
		/* 821979FCh case    7:*/		return 0x82197A08;
		/* 821979FCh case    7:*/		return 0x82197A00;
		  /* 82197A00h */ case    8:  		/* addi R10, R11, 8 */
		/* 82197A00h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 82197A00h case    8:*/		return 0x82197A04;
		  /* 82197A04h */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 82197A04h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82197A04h case    9:*/		return 0x82197A08;
	}
	return 0x82197A08;
} // Block from 821979E0h-82197A08h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82197A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197A08);
		  /* 82197A08h */ case    0:  		/* cmplw CR6, R11, R4 */
		/* 82197A08h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 82197A08h case    0:*/		return 0x82197A0C;
		  /* 82197A0Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82197A0Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82197A00;  }
		/* 82197A0Ch case    1:*/		return 0x82197A10;
		  /* 82197A10h */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 82197A10h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82197A10h case    2:*/		return 0x82197A14;
		  /* 82197A14h */ case    3:  		/* li R6, 26 */
		/* 82197A14h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1A);
		/* 82197A14h case    3:*/		return 0x82197A18;
		  /* 82197A18h */ case    4:  		/* li R5, 20 */
		/* 82197A18h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x14);
		/* 82197A18h case    4:*/		return 0x82197A1C;
		  /* 82197A1Ch */ case    5:  		/* mr R3, R21 */
		/* 82197A1Ch case    5:*/		regs.R3 = regs.R21;
		/* 82197A1Ch case    5:*/		return 0x82197A20;
		  /* 82197A20h */ case    6:  		/* stw R11, <#[R10]> */
		/* 82197A20h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82197A20h case    6:*/		return 0x82197A24;
		  /* 82197A24h */ case    7:  		/* bl -208268 */
		/* 82197A24h case    7:*/		regs.LR = 0x82197A28; return 0x82164C98;
		/* 82197A24h case    7:*/		return 0x82197A28;
	}
	return 0x82197A28;
} // Block from 82197A08h-82197A28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82197A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197A28);
		  /* 82197A28h */ case    0:  		/* addi R29, R29, 1 */
		/* 82197A28h case    0:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82197A28h case    0:*/		return 0x82197A2C;
		  /* 82197A2Ch */ case    1:  		/* addi R30, R30, 4 */
		/* 82197A2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82197A2Ch case    1:*/		return 0x82197A30;
		  /* 82197A30h */ case    2:  		/* b -464 */
		/* 82197A30h case    2:*/		return 0x82197860;
		/* 82197A30h case    2:*/		return 0x82197A34;
	}
	return 0x82197A34;
} // Block from 82197A28h-82197A34h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82197A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197A34);
		  /* 82197A34h */ case    0:  		/* subfic R11, R29, 12 */
		/* 82197A34h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R29,0xC);
		/* 82197A34h case    0:*/		return 0x82197A38;
		  /* 82197A38h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82197A38h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82197A38h case    1:*/		return 0x82197A3C;
		  /* 82197A3Ch */ case    2:  		/* lwzx R30, <#[R11 + R27]> */
		/* 82197A3Ch case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82197A3Ch case    2:*/		return 0x82197A40;
		  /* 82197A40h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 82197A40h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82197A40h case    3:*/		return 0x82197A44;
		  /* 82197A44h */ case    4:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 82197A44h case    4:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82197A44h case    4:*/		return 0x82197A48;
		  /* 82197A48h */ case    5:  		/* cmplw CR6, R11, R24 */
		/* 82197A48h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 82197A48h case    5:*/		return 0x82197A4C;
		  /* 82197A4Ch */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 82197A4Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82197A70;  }
		/* 82197A4Ch case    6:*/		return 0x82197A50;
		  /* 82197A50h */ case    7:  		/* lwz R11, <#[R26]> */
		/* 82197A50h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82197A50h case    7:*/		return 0x82197A54;
		  /* 82197A54h */ case    8:  		/* li R4, 228 */
		/* 82197A54h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0xE4);
		/* 82197A54h case    8:*/		return 0x82197A58;
		  /* 82197A58h */ case    9:  		/* mr R3, R30 */
		/* 82197A58h case    9:*/		regs.R3 = regs.R30;
		/* 82197A58h case    9:*/		return 0x82197A5C;
		  /* 82197A5Ch */ case   10:  		/* rlwimi R4, R11, 27, 30, 31 */
		/* 82197A5Ch case   10:*/		cpu::op::rlwimi<0,27,30,31>(regs,&regs.R4,regs.R11);
		/* 82197A5Ch case   10:*/		return 0x82197A60;
		  /* 82197A60h */ case   11:  		/* bl -6256 */
		/* 82197A60h case   11:*/		regs.LR = 0x82197A64; return 0x821961F0;
		/* 82197A60h case   11:*/		return 0x82197A64;
		  /* 82197A64h */ case   12:  		/* lwz R11, <#[R30]> */
		/* 82197A64h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82197A64h case   12:*/		return 0x82197A68;
		  /* 82197A68h */ case   13:  		/* rlwimi R11, R19, 25, 4, 6 */
		/* 82197A68h case   13:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R19);
		/* 82197A68h case   13:*/		return 0x82197A6C;
		  /* 82197A6Ch */ case   14:  		/* stw R11, <#[R30]> */
		/* 82197A6Ch case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82197A6Ch case   14:*/		return 0x82197A70;
	}
	return 0x82197A70;
} // Block from 82197A34h-82197A70h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82197A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197A70);
		  /* 82197A70h */ case    0:  		/* mr R6, R21 */
		/* 82197A70h case    0:*/		regs.R6 = regs.R21;
		/* 82197A70h case    0:*/		return 0x82197A74;
		  /* 82197A74h */ case    1:  		/* lwz R5, <#[R1 + 80]> */
		/* 82197A74h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 82197A74h case    1:*/		return 0x82197A78;
		  /* 82197A78h */ case    2:  		/* li R4, 2 */
		/* 82197A78h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82197A78h case    2:*/		return 0x82197A7C;
		  /* 82197A7Ch */ case    3:  		/* mr R3, R14 */
		/* 82197A7Ch case    3:*/		regs.R3 = regs.R14;
		/* 82197A7Ch case    3:*/		return 0x82197A80;
		  /* 82197A80h */ case    4:  		/* bl -121992 */
		/* 82197A80h case    4:*/		regs.LR = 0x82197A84; return 0x82179DF8;
		/* 82197A80h case    4:*/		return 0x82197A84;
		  /* 82197A84h */ case    5:  		/* lwz R5, <#[R1 + 104]> */
		/* 82197A84h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000068) );
		/* 82197A84h case    5:*/		return 0x82197A88;
		  /* 82197A88h */ case    6:  		/* stw R18, <#[R1 + 80]> */
		/* 82197A88h case    6:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x00000050) );
		/* 82197A88h case    6:*/		return 0x82197A8C;
		  /* 82197A8Ch */ case    7:  		/* cmplw CR6, R5, R28 */
		/* 82197A8Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R28);
		/* 82197A8Ch case    7:*/		return 0x82197A90;
		  /* 82197A90h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82197A90h case    8:*/		if ( regs.CR[6].eq ) { return 0x82197AA4;  }
		/* 82197A90h case    8:*/		return 0x82197A94;
		  /* 82197A94h */ case    9:  		/* mr R6, R21 */
		/* 82197A94h case    9:*/		regs.R6 = regs.R21;
		/* 82197A94h case    9:*/		return 0x82197A98;
		  /* 82197A98h */ case   10:  		/* li R4, 0 */
		/* 82197A98h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82197A98h case   10:*/		return 0x82197A9C;
		  /* 82197A9Ch */ case   11:  		/* mr R3, R14 */
		/* 82197A9Ch case   11:*/		regs.R3 = regs.R14;
		/* 82197A9Ch case   11:*/		return 0x82197AA0;
		  /* 82197AA0h */ case   12:  		/* bl -122024 */
		/* 82197AA0h case   12:*/		regs.LR = 0x82197AA4; return 0x82179DF8;
		/* 82197AA0h case   12:*/		return 0x82197AA4;
	}
	return 0x82197AA4;
} // Block from 82197A70h-82197AA4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82197AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197AA4);
		  /* 82197AA4h */ case    0:  		/* lwz R5, <#[R1 + 112]> */
		/* 82197AA4h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000070) );
		/* 82197AA4h case    0:*/		return 0x82197AA8;
		  /* 82197AA8h */ case    1:  		/* cmplw CR6, R5, R25 */
		/* 82197AA8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R25);
		/* 82197AA8h case    1:*/		return 0x82197AAC;
		  /* 82197AACh */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 82197AACh case    2:*/		if ( regs.CR[6].eq ) { return 0x82197AC0;  }
		/* 82197AACh case    2:*/		return 0x82197AB0;
		  /* 82197AB0h */ case    3:  		/* mr R6, R21 */
		/* 82197AB0h case    3:*/		regs.R6 = regs.R21;
		/* 82197AB0h case    3:*/		return 0x82197AB4;
		  /* 82197AB4h */ case    4:  		/* li R4, 1 */
		/* 82197AB4h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82197AB4h case    4:*/		return 0x82197AB8;
		  /* 82197AB8h */ case    5:  		/* mr R3, R14 */
		/* 82197AB8h case    5:*/		regs.R3 = regs.R14;
		/* 82197AB8h case    5:*/		return 0x82197ABC;
		  /* 82197ABCh */ case    6:  		/* bl -122052 */
		/* 82197ABCh case    6:*/		regs.LR = 0x82197AC0; return 0x82179DF8;
		/* 82197ABCh case    6:*/		return 0x82197AC0;
	}
	return 0x82197AC0;
} // Block from 82197AA4h-82197AC0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82197AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197AC0);
		  /* 82197AC0h */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 82197AC0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 82197AC0h case    0:*/		return 0x82197AC4;
		  /* 82197AC4h */ case    1:  		/* rlwinm R10, R14, 0, 0, 30 */
		/* 82197AC4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R14);
		/* 82197AC4h case    1:*/		return 0x82197AC8;
		  /* 82197AC8h */ case    2:  		/* addi R11, R11, 36 */
		/* 82197AC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82197AC8h case    2:*/		return 0x82197ACC;
		  /* 82197ACCh */ case    3:  		/* addi R10, R10, 36 */
		/* 82197ACCh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 82197ACCh case    3:*/		return 0x82197AD0;
		  /* 82197AD0h */ case    4:  		/* addi R9, R11, 4 */
		/* 82197AD0h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82197AD0h case    4:*/		return 0x82197AD4;
		  /* 82197AD4h */ case    5:  		/* addi R8, R10, 4 */
		/* 82197AD4h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 82197AD4h case    5:*/		return 0x82197AD8;
		  /* 82197AD8h */ case    6:  		/* addi R5, R11, -36 */
		/* 82197AD8h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFFFDC);
		/* 82197AD8h case    6:*/		return 0x82197ADC;
		  /* 82197ADCh */ case    7:  		/* lwz R6, <#[R11 + 4]> */
		/* 82197ADCh case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82197ADCh case    7:*/		return 0x82197AE0;
		  /* 82197AE0h */ case    8:  		/* addi R7, R14, 4 */
		/* 82197AE0h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R14,0x4);
		/* 82197AE0h case    8:*/		return 0x82197AE4;
		  /* 82197AE4h */ case    9:  		/* lwz R4, <#[R11]> */
		/* 82197AE4h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 82197AE4h case    9:*/		return 0x82197AE8;
		  /* 82197AE8h */ case   10:  		/* rlwinm R3, R6, 0, 0, 30 */
		/* 82197AE8h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R3,regs.R6);
		/* 82197AE8h case   10:*/		return 0x82197AEC;
		  /* 82197AECh */ case   11:  		/* mr R6, R7 */
		/* 82197AECh case   11:*/		regs.R6 = regs.R7;
		/* 82197AECh case   11:*/		return 0x82197AF0;
		  /* 82197AF0h */ case   12:  		/* stw R4, <#[R3 + 36]> */
		/* 82197AF0h case   12:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000024) );
		/* 82197AF0h case   12:*/		return 0x82197AF4;
		  /* 82197AF4h */ case   13:  		/* lwz R4, <#[R11]> */
		/* 82197AF4h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 82197AF4h case   13:*/		return 0x82197AF8;
		  /* 82197AF8h */ case   14:  		/* lwz R3, <#[R11 + 4]> */
		/* 82197AF8h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 82197AF8h case   14:*/		return 0x82197AFC;
		  /* 82197AFCh */ case   15:  		/* rlwinm R4, R4, 0, 0, 30 */
		/* 82197AFCh case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R4,regs.R4);
		/* 82197AFCh case   15:*/		return 0x82197B00;
		  /* 82197B00h */ case   16:  		/* stw R3, <#[R4]> */
		/* 82197B00h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R4 + 0x00000000) );
		/* 82197B00h case   16:*/		return 0x82197B04;
		  /* 82197B04h */ case   17:  		/* lwz R4, <#[R10 + 4]> */
		/* 82197B04h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 82197B04h case   17:*/		return 0x82197B08;
		  /* 82197B08h */ case   18:  		/* stw R4, <#[R11 + 4]> */
		/* 82197B08h case   18:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 82197B08h case   18:*/		return 0x82197B0C;
		  /* 82197B0Ch */ case   19:  		/* lwz R4, <#[R10 + 4]> */
		/* 82197B0Ch case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000004) );
		/* 82197B0Ch case   19:*/		return 0x82197B10;
		  /* 82197B10h */ case   20:  		/* rlwinm R4, R4, 0, 0, 30 */
		/* 82197B10h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R4,regs.R4);
		/* 82197B10h case   20:*/		return 0x82197B14;
		  /* 82197B14h */ case   21:  		/* stw R9, <#[R4 + 36]> */
		/* 82197B14h case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x00000024) );
		/* 82197B14h case   21:*/		return 0x82197B18;
		  /* 82197B18h */ case   22:  		/* stw R8, <#[R11]> */
		/* 82197B18h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82197B18h case   22:*/		return 0x82197B1C;
		  /* 82197B1Ch */ case   23:  		/* stw R5, <#[R10 + 4]> */
		/* 82197B1Ch case   23:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + 0x00000004) );
		/* 82197B1Ch case   23:*/		return 0x82197B20;
		  /* 82197B20h */ case   24:  		/* lwz R11, <#[R6]> */
		/* 82197B20h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 82197B20h case   24:*/		return 0x82197B24;
		  /* 82197B24h */ case   25:  		/* cmplwi CR6, R11, 0 */
		/* 82197B24h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82197B24h case   25:*/		return 0x82197B28;
		  /* 82197B28h */ case   26:  		/* bc 12, CR6_EQ, 172 */
		/* 82197B28h case   26:*/		if ( regs.CR[6].eq ) { return 0x82197BD4;  }
		/* 82197B28h case   26:*/		return 0x82197B2C;
		  /* 82197B2Ch */ case   27:  		/* lwz R10, <#[R11 + 16]> */
		/* 82197B2Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82197B2Ch case   27:*/		return 0x82197B30;
		  /* 82197B30h */ case   28:  		/* cmplwi CR6, R10, 0 */
		/* 82197B30h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82197B30h case   28:*/		return 0x82197B34;
		  /* 82197B34h */ case   29:  		/* bc 12, CR6_EQ, 140 */
		/* 82197B34h case   29:*/		if ( regs.CR[6].eq ) { return 0x82197BC0;  }
		/* 82197B34h case   29:*/		return 0x82197B38;
		  /* 82197B38h */ case   30:  		/* lwz R10, <#[R11]> */
		/* 82197B38h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82197B38h case   30:*/		return 0x82197B3C;
		  /* 82197B3Ch */ case   31:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 82197B3Ch case   31:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 82197B3Ch case   31:*/		return 0x82197B40;
		  /* 82197B40h */ case   32:  		/* bc 12, CR0_EQ, 128 */
		/* 82197B40h case   32:*/		if ( regs.CR[0].eq ) { return 0x82197BC0;  }
		/* 82197B40h case   32:*/		return 0x82197B44;
		  /* 82197B44h */ case   33:  		/* lwz R10, <#[R11 + 12]> */
		/* 82197B44h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82197B44h case   33:*/		return 0x82197B48;
		  /* 82197B48h */ case   34:  		/* addi R10, R10, 4 */
		/* 82197B48h case   34:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82197B48h case   34:*/		return 0x82197B4C;
		  /* 82197B4Ch */ case   35:  		/* lwz R9, <#[R10]> */
		/* 82197B4Ch case   35:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82197B4Ch case   35:*/		return 0x82197B50;
		  /* 82197B50h */ case   36:  		/* b 12 */
		/* 82197B50h case   36:*/		return 0x82197B5C;
		/* 82197B50h case   36:*/		return 0x82197B54;
		  /* 82197B54h */ case   37:  		/* addi R10, R9, 8 */
		/* 82197B54h case   37:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 82197B54h case   37:*/		return 0x82197B58;
		  /* 82197B58h */ case   38:  		/* lwz R9, <#[R9 + 8]> */
		/* 82197B58h case   38:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82197B58h case   38:*/		return 0x82197B5C;
	}
	return 0x82197B5C;
} // Block from 82197AC0h-82197B5Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 82197B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197B5C);
		  /* 82197B5Ch */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82197B5Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82197B5Ch case    0:*/		return 0x82197B60;
		  /* 82197B60h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82197B60h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82197B54;  }
		/* 82197B60h case    1:*/		return 0x82197B64;
		  /* 82197B64h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 82197B64h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82197B64h case    2:*/		return 0x82197B68;
		  /* 82197B68h */ case    3:  		/* stw R9, <#[R10]> */
		/* 82197B68h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82197B68h case    3:*/		return 0x82197B6C;
		  /* 82197B6Ch */ case    4:  		/* lwz R10, <#[R27 + 4]> */
		/* 82197B6Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000004) );
		/* 82197B6Ch case    4:*/		return 0x82197B70;
		  /* 82197B70h */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 82197B70h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82197B70h case    5:*/		return 0x82197B74;
		  /* 82197B74h */ case    6:  		/* stw R11, <#[R27 + 4]> */
		/* 82197B74h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82197B74h case    6:*/		return 0x82197B78;
		  /* 82197B78h */ case    7:  		/* stw R27, <#[R11 + 12]> */
		/* 82197B78h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x0000000C) );
		/* 82197B78h case    7:*/		return 0x82197B7C;
		  /* 82197B7Ch */ case    8:  		/* lwz R10, <#[R11]> */
		/* 82197B7Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82197B7Ch case    8:*/		return 0x82197B80;
		  /* 82197B80h */ case    9:  		/* rlwinm R9, R10, 22, 29, 30 */
		/* 82197B80h case    9:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R10);
		/* 82197B80h case    9:*/		return 0x82197B84;
		  /* 82197B84h */ case   10:  		/* rlwinm R8, R10, 24, 29, 30 */
		/* 82197B84h case   10:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R8,regs.R10);
		/* 82197B84h case   10:*/		return 0x82197B88;
		  /* 82197B88h */ case   11:  		/* srw R9, R18, R9 */
		/* 82197B88h case   11:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R18,regs.R9);
		/* 82197B88h case   11:*/		return 0x82197B8C;
		  /* 82197B8Ch */ case   12:  		/* srw R8, R18, R8 */
		/* 82197B8Ch case   12:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R18,regs.R8);
		/* 82197B8Ch case   12:*/		return 0x82197B90;
		  /* 82197B90h */ case   13:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 82197B90h case   13:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 82197B90h case   13:*/		return 0x82197B94;
		  /* 82197B94h */ case   14:  		/* rlwinm R9, R10, 26, 29, 30 */
		/* 82197B94h case   14:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R9,regs.R10);
		/* 82197B94h case   14:*/		return 0x82197B98;
		  /* 82197B98h */ case   15:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 82197B98h case   15:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 82197B98h case   15:*/		return 0x82197B9C;
		  /* 82197B9Ch */ case   16:  		/* srw R9, R18, R9 */
		/* 82197B9Ch case   16:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R18,regs.R9);
		/* 82197B9Ch case   16:*/		return 0x82197BA0;
		  /* 82197BA0h */ case   17:  		/* rlwinm R5, R10, 28, 29, 30 */
		/* 82197BA0h case   17:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R5,regs.R10);
		/* 82197BA0h case   17:*/		return 0x82197BA4;
		  /* 82197BA4h */ case   18:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 82197BA4h case   18:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 82197BA4h case   18:*/		return 0x82197BA8;
		  /* 82197BA8h */ case   19:  		/* srw R8, R18, R5 */
		/* 82197BA8h case   19:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R18,regs.R5);
		/* 82197BA8h case   19:*/		return 0x82197BAC;
		  /* 82197BACh */ case   20:  		/* rlwimi R8, R9, 2, 0, 29 */
		/* 82197BACh case   20:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R8,regs.R9);
		/* 82197BACh case   20:*/		return 0x82197BB0;
		  /* 82197BB0h */ case   21:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 82197BB0h case   21:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 82197BB0h case   21:*/		return 0x82197BB4;
		  /* 82197BB4h */ case   22:  		/* rlwinm R9, R8, 5, 0, 26 */
		/* 82197BB4h case   22:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R8);
		/* 82197BB4h case   22:*/		return 0x82197BB8;
		  /* 82197BB8h */ case   23:  		/* or R10, R9, R10 */
		/* 82197BB8h case   23:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82197BB8h case   23:*/		return 0x82197BBC;
		  /* 82197BBCh */ case   24:  		/* stw R10, <#[R11]> */
		/* 82197BBCh case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82197BBCh case   24:*/		return 0x82197BC0;
	}
	return 0x82197BC0;
} // Block from 82197B5Ch-82197BC0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82197BC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197BC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197BC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197BC0);
		  /* 82197BC0h */ case    0:  		/* lwz R10, <#[R6]> */
		/* 82197BC0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 82197BC0h case    0:*/		return 0x82197BC4;
		  /* 82197BC4h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 82197BC4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82197BC4h case    1:*/		return 0x82197BC8;
		  /* 82197BC8h */ case    2:  		/* bc 4, CR6_EQ, -168 */
		/* 82197BC8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82197B20;  }
		/* 82197BC8h case    2:*/		return 0x82197BCC;
		  /* 82197BCCh */ case    3:  		/* addi R6, R11, 8 */
		/* 82197BCCh case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x8);
		/* 82197BCCh case    3:*/		return 0x82197BD0;
		  /* 82197BD0h */ case    4:  		/* b -176 */
		/* 82197BD0h case    4:*/		return 0x82197B20;
		/* 82197BD0h case    4:*/		return 0x82197BD4;
	}
	return 0x82197BD4;
} // Block from 82197BC0h-82197BD4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82197BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197BD4);
		  /* 82197BD4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82197BD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82197BD4h case    0:*/		return 0x82197BD8;
		  /* 82197BD8h */ case    1:  		/* addi R11, R11, 4 */
		/* 82197BD8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82197BD8h case    1:*/		return 0x82197BDC;
		  /* 82197BDCh */ case    2:  		/* lwz R10, <#[R11]> */
		/* 82197BDCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82197BDCh case    2:*/		return 0x82197BE0;
		  /* 82197BE0h */ case    3:  		/* b 12 */
		/* 82197BE0h case    3:*/		return 0x82197BEC;
		/* 82197BE0h case    3:*/		return 0x82197BE4;
		  /* 82197BE4h */ case    4:  		/* addi R11, R10, 8 */
		/* 82197BE4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82197BE4h case    4:*/		return 0x82197BE8;
		  /* 82197BE8h */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 82197BE8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82197BE8h case    5:*/		return 0x82197BEC;
	}
	return 0x82197BEC;
} // Block from 82197BD4h-82197BECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82197BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197BEC);
		  /* 82197BECh */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 82197BECh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82197BECh case    0:*/		return 0x82197BF0;
		  /* 82197BF0h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82197BF0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82197BE4;  }
		/* 82197BF0h case    1:*/		return 0x82197BF4;
		  /* 82197BF4h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82197BF4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82197BF4h case    2:*/		return 0x82197BF8;
		  /* 82197BF8h */ case    3:  		/* lis R12, -3073 */
		/* 82197BF8h case    3:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFF3FF);
		/* 82197BF8h case    3:*/		return 0x82197BFC;
		  /* 82197BFCh */ case    4:  		/* mr R3, R27 */
		/* 82197BFCh case    4:*/		regs.R3 = regs.R27;
		/* 82197BFCh case    4:*/		return 0x82197C00;
		  /* 82197C00h */ case    5:  		/* ori R12, R12, 64640 */
		/* 82197C00h case    5:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFC80);
		/* 82197C00h case    5:*/		return 0x82197C04;
		  /* 82197C04h */ case    6:  		/* stw R10, <#[R11]> */
		/* 82197C04h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82197C04h case    6:*/		return 0x82197C08;
		  /* 82197C08h */ case    7:  		/* lwz R11, <#[R7]> */
		/* 82197C08h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82197C08h case    7:*/		return 0x82197C0C;
		  /* 82197C0Ch */ case    8:  		/* stw R11, <#[R31 + 8]> */
		/* 82197C0Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82197C0Ch case    8:*/		return 0x82197C10;
		  /* 82197C10h */ case    9:  		/* stw R31, <#[R7]> */
		/* 82197C10h case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R7 + 0x00000000) );
		/* 82197C10h case    9:*/		return 0x82197C14;
		  /* 82197C14h */ case   10:  		/* stw R14, <#[R31 + 12]> */
		/* 82197C14h case   10:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R31 + 0x0000000C) );
		/* 82197C14h case   10:*/		return 0x82197C18;
		  /* 82197C18h */ case   11:  		/* lwz R11, <#[R31]> */
		/* 82197C18h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82197C18h case   11:*/		return 0x82197C1C;
		  /* 82197C1Ch */ case   12:  		/* and R10, R11, R12 */
		/* 82197C1Ch case   12:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R12);
		/* 82197C1Ch case   12:*/		return 0x82197C20;
		  /* 82197C20h */ case   13:  		/* lwz R11, <#[R14 + 8]> */
		/* 82197C20h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82197C20h case   13:*/		return 0x82197C24;
		  /* 82197C24h */ case   14:  		/* rlwinm R11, R11, 31, 28, 31 */
		/* 82197C24h case   14:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R11,regs.R11);
		/* 82197C24h case   14:*/		return 0x82197C28;
		  /* 82197C28h */ case   15:  		/* addi R9, R11, -1 */
		/* 82197C28h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 82197C28h case   15:*/		return 0x82197C2C;
		  /* 82197C2Ch */ case   16:  		/* andc R11, R11, R9 */
		/* 82197C2Ch case   16:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82197C2Ch case   16:*/		return 0x82197C30;
		  /* 82197C30h */ case   17:  		/* cntlzw R11, R11 */
		/* 82197C30h case   17:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82197C30h case   17:*/		return 0x82197C34;
		  /* 82197C34h */ case   18:  		/* subfic R11, R11, -1 */
		/* 82197C34h case   18:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82197C34h case   18:*/		return 0x82197C38;
		  /* 82197C38h */ case   19:  		/* rlwinm R11, R11, 5, 22, 26 */
		/* 82197C38h case   19:*/		cpu::op::rlwinm<0,5,22,26>(regs,&regs.R11,regs.R11);
		/* 82197C38h case   19:*/		return 0x82197C3C;
		  /* 82197C3Ch */ case   20:  		/* rlwinm R11, R11, 0, 25, 23 */
		/* 82197C3Ch case   20:*/		cpu::op::rlwinm<0,0,25,23>(regs,&regs.R11,regs.R11);
		/* 82197C3Ch case   20:*/		return 0x82197C40;
		  /* 82197C40h */ case   21:  		/* oris R11, R11, 512 */
		/* 82197C40h case   21:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82197C40h case   21:*/		return 0x82197C44;
		  /* 82197C44h */ case   22:  		/* ori R11, R11, 7296 */
		/* 82197C44h case   22:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1C80);
		/* 82197C44h case   22:*/		return 0x82197C48;
		  /* 82197C48h */ case   23:  		/* or R11, R11, R10 */
		/* 82197C48h case   23:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82197C48h case   23:*/		return 0x82197C4C;
		  /* 82197C4Ch */ case   24:  		/* stw R11, <#[R31]> */
		/* 82197C4Ch case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82197C4Ch case   24:*/		return 0x82197C50;
		  /* 82197C50h */ case   25:  		/* bl -129240 */
		/* 82197C50h case   25:*/		regs.LR = 0x82197C54; return 0x82178378;
		/* 82197C50h case   25:*/		return 0x82197C54;
		  /* 82197C54h */ case   26:  		/* lwz R11, <#[R30]> */
		/* 82197C54h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82197C54h case   26:*/		return 0x82197C58;
		  /* 82197C58h */ case   27:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 82197C58h case   27:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 82197C58h case   27:*/		return 0x82197C5C;
		  /* 82197C5Ch */ case   28:  		/* bc 4, CR0_EQ, 112 */
		/* 82197C5Ch case   28:*/		if ( !regs.CR[0].eq ) { return 0x82197CCC;  }
		/* 82197C5Ch case   28:*/		return 0x82197C60;
		  /* 82197C60h */ case   29:  		/* mr R30, R27 */
		/* 82197C60h case   29:*/		regs.R30 = regs.R27;
		/* 82197C60h case   29:*/		return 0x82197C64;
		  /* 82197C64h */ case   30:  		/* lwz R31, <#[R30]> */
		/* 82197C64h case   30:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82197C64h case   30:*/		return 0x82197C68;
		  /* 82197C68h */ case   31:  		/* cmplwi CR6, R31, 0 */
		/* 82197C68h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82197C68h case   31:*/		return 0x82197C6C;
		  /* 82197C6Ch */ case   32:  		/* bc 12, CR6_EQ, 96 */
		/* 82197C6Ch case   32:*/		if ( regs.CR[6].eq ) { return 0x82197CCC;  }
		/* 82197C6Ch case   32:*/		return 0x82197C70;
		  /* 82197C70h */ case   33:  		/* lwz R10, <#[R31]> */
		/* 82197C70h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82197C70h case   33:*/		return 0x82197C74;
		  /* 82197C74h */ case   34:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 82197C74h case   34:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 82197C74h case   34:*/		return 0x82197C78;
		  /* 82197C78h */ case   35:  		/* bc 12, CR0_EQ, 16 */
		/* 82197C78h case   35:*/		if ( regs.CR[0].eq ) { return 0x82197C88;  }
		/* 82197C78h case   35:*/		return 0x82197C7C;
		  /* 82197C7Ch */ case   36:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 82197C7Ch case   36:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 82197C7Ch case   36:*/		return 0x82197C80;
		  /* 82197C80h */ case   37:  		/* mr R11, R19 */
		/* 82197C80h case   37:*/		regs.R11 = regs.R19;
		/* 82197C80h case   37:*/		return 0x82197C84;
		  /* 82197C84h */ case   38:  		/* bc 12, CR0_EQ, 8 */
		/* 82197C84h case   38:*/		if ( regs.CR[0].eq ) { return 0x82197C8C;  }
		/* 82197C84h case   38:*/		return 0x82197C88;
	}
	return 0x82197C88;
} // Block from 82197BECh-82197C88h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82197C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197C88);
		  /* 82197C88h */ case    0:  		/* mr R11, R18 */
		/* 82197C88h case    0:*/		regs.R11 = regs.R18;
		/* 82197C88h case    0:*/		return 0x82197C8C;
	}
	return 0x82197C8C;
} // Block from 82197C88h-82197C8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197C8C);
		  /* 82197C8Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82197C8Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82197C8Ch case    0:*/		return 0x82197C90;
		  /* 82197C90h */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 82197C90h case    1:*/		if ( regs.CR[0].eq ) { return 0x82197CB8;  }
		/* 82197C90h case    1:*/		return 0x82197C94;
		  /* 82197C94h */ case    2:  		/* rlwinm. R11, R10, 0, 7, 18 */
		/* 82197C94h case    2:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R10);
		/* 82197C94h case    2:*/		return 0x82197C98;
		  /* 82197C98h */ case    3:  		/* bc 4, CR0_EQ, 32 */
		/* 82197C98h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82197CB8;  }
		/* 82197C98h case    3:*/		return 0x82197C9C;
		  /* 82197C9Ch */ case    4:  		/* mr R4, R31 */
		/* 82197C9Ch case    4:*/		regs.R4 = regs.R31;
		/* 82197C9Ch case    4:*/		return 0x82197CA0;
		  /* 82197CA0h */ case    5:  		/* mr R3, R14 */
		/* 82197CA0h case    5:*/		regs.R3 = regs.R14;
		/* 82197CA0h case    5:*/		return 0x82197CA4;
		  /* 82197CA4h */ case    6:  		/* bl -129756 */
		/* 82197CA4h case    6:*/		regs.LR = 0x82197CA8; return 0x821781C8;
		/* 82197CA4h case    6:*/		return 0x82197CA8;
		  /* 82197CA8h */ case    7:  		/* mr R5, R21 */
		/* 82197CA8h case    7:*/		regs.R5 = regs.R21;
		/* 82197CA8h case    7:*/		return 0x82197CAC;
		  /* 82197CACh */ case    8:  		/* mr R4, R31 */
		/* 82197CACh case    8:*/		regs.R4 = regs.R31;
		/* 82197CACh case    8:*/		return 0x82197CB0;
		  /* 82197CB0h */ case    9:  		/* mr R3, R27 */
		/* 82197CB0h case    9:*/		regs.R3 = regs.R27;
		/* 82197CB0h case    9:*/		return 0x82197CB4;
		  /* 82197CB4h */ case   10:  		/* bl -127908 */
		/* 82197CB4h case   10:*/		regs.LR = 0x82197CB8; return 0x82178910;
		/* 82197CB4h case   10:*/		return 0x82197CB8;
	}
	return 0x82197CB8;
} // Block from 82197C8Ch-82197CB8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82197CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197CB8);
		  /* 82197CB8h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82197CB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82197CB8h case    0:*/		return 0x82197CBC;
		  /* 82197CBCh */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 82197CBCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 82197CBCh case    1:*/		return 0x82197CC0;
		  /* 82197CC0h */ case    2:  		/* bc 4, CR6_EQ, -92 */
		/* 82197CC0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82197C64;  }
		/* 82197CC0h case    2:*/		return 0x82197CC4;
		  /* 82197CC4h */ case    3:  		/* addi R30, R31, 4 */
		/* 82197CC4h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x4);
		/* 82197CC4h case    3:*/		return 0x82197CC8;
		  /* 82197CC8h */ case    4:  		/* b -100 */
		/* 82197CC8h case    4:*/		return 0x82197C64;
		/* 82197CC8h case    4:*/		return 0x82197CCC;
	}
	return 0x82197CCC;
} // Block from 82197CB8h-82197CCCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82197CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197CCC);
		  /* 82197CCCh */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82197CCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82197CCCh case    0:*/		return 0x82197CD0;
		  /* 82197CD0h */ case    1:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82197CD0h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82197CD0h case    1:*/		return 0x82197CD4;
		  /* 82197CD4h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 82197CD4h case    2:*/		if ( regs.CR[0].eq ) { return 0x82197CEC;  }
		/* 82197CD4h case    2:*/		return 0x82197CD8;
		  /* 82197CD8h */ case    3:  		/* lwz R10, <#[R27 + 8]> */
		/* 82197CD8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 82197CD8h case    3:*/		return 0x82197CDC;
		  /* 82197CDCh */ case    4:  		/* rlwinm. R10, R10, 9, 31, 31 */
		/* 82197CDCh case    4:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R10);
		/* 82197CDCh case    4:*/		return 0x82197CE0;
		  /* 82197CE0h */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 82197CE0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82197CEC;  }
		/* 82197CE0h case    5:*/		return 0x82197CE4;
		  /* 82197CE4h */ case    6:  		/* mr R4, R27 */
		/* 82197CE4h case    6:*/		regs.R4 = regs.R27;
		/* 82197CE4h case    6:*/		return 0x82197CE8;
		  /* 82197CE8h */ case    7:  		/* b 36 */
		/* 82197CE8h case    7:*/		return 0x82197D0C;
		/* 82197CE8h case    7:*/		return 0x82197CEC;
	}
	return 0x82197CEC;
} // Block from 82197CCCh-82197CECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 82197CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197CEC);
		  /* 82197CECh */ case    0:  		/* lwz R10, <#[R27 + 8]> */
		/* 82197CECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 82197CECh case    0:*/		return 0x82197CF0;
		  /* 82197CF0h */ case    1:  		/* rlwinm. R10, R10, 9, 31, 31 */
		/* 82197CF0h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R10);
		/* 82197CF0h case    1:*/		return 0x82197CF4;
		  /* 82197CF4h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 82197CF4h case    2:*/		if ( regs.CR[0].eq ) { return 0x82197D14;  }
		/* 82197CF4h case    2:*/		return 0x82197CF8;
		  /* 82197CF8h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82197CF8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82197CF8h case    3:*/		return 0x82197CFC;
		  /* 82197CFCh */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 82197CFCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x82197D14;  }
		/* 82197CFCh case    4:*/		return 0x82197D00;
		  /* 82197D00h */ case    5:  		/* mr R3, R27 */
		/* 82197D00h case    5:*/		regs.R3 = regs.R27;
		/* 82197D00h case    5:*/		return 0x82197D04;
		  /* 82197D04h */ case    6:  		/* bl -136324 */
		/* 82197D04h case    6:*/		regs.LR = 0x82197D08; return 0x82176880;
		/* 82197D04h case    6:*/		return 0x82197D08;
		  /* 82197D08h */ case    7:  		/* mr R4, R3 */
		/* 82197D08h case    7:*/		regs.R4 = regs.R3;
		/* 82197D08h case    7:*/		return 0x82197D0C;
	}
	return 0x82197D0C;
} // Block from 82197CECh-82197D0Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 82197D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197D0C);
		  /* 82197D0Ch */ case    0:  		/* mr R3, R21 */
		/* 82197D0Ch case    0:*/		regs.R3 = regs.R21;
		/* 82197D0Ch case    0:*/		return 0x82197D10;
		  /* 82197D10h */ case    1:  		/* bl 126264 */
		/* 82197D10h case    1:*/		regs.LR = 0x82197D14; return 0x821B6A48;
		/* 82197D10h case    1:*/		return 0x82197D14;
	}
	return 0x82197D14;
} // Block from 82197D0Ch-82197D14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82197D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197D14);
		  /* 82197D14h */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82197D14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82197D14h case    0:*/		return 0x82197D18;
		  /* 82197D18h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82197D18h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82197D18h case    1:*/		return 0x82197D1C;
		  /* 82197D1Ch */ case    2:  		/* bc 12, CR0_EQ, -1332 */
		/* 82197D1Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x821977E8;  }
		/* 82197D1Ch case    2:*/		return 0x82197D20;
		  /* 82197D20h */ case    3:  		/* b -1496 */
		/* 82197D20h case    3:*/		return 0x82197748;
		/* 82197D20h case    3:*/		return 0x82197D24;
	}
	return 0x82197D24;
} // Block from 82197D14h-82197D24h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82197D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197D24);
		  /* 82197D24h */ case    0:  		/* lwz R10, <#[R14 + 4]> */
		/* 82197D24h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000004) );
		/* 82197D24h case    0:*/		return 0x82197D28;
		  /* 82197D28h */ case    1:  		/* mr R24, R18 */
		/* 82197D28h case    1:*/		regs.R24 = regs.R18;
		/* 82197D28h case    1:*/		return 0x82197D2C;
		  /* 82197D2Ch */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 82197D2Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82197D2Ch case    2:*/		return 0x82197D30;
		  /* 82197D30h */ case    3:  		/* bc 12, CR6_EQ, 80 */
		/* 82197D30h case    3:*/		if ( regs.CR[6].eq ) { return 0x82197D80;  }
		/* 82197D30h case    3:*/		return 0x82197D34;
		  /* 82197D34h */ case    4:  		/* lwz R11, <#[R10 + 16]> */
		/* 82197D34h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 82197D34h case    4:*/		return 0x82197D38;
		  /* 82197D38h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82197D38h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82197D38h case    5:*/		return 0x82197D3C;
		  /* 82197D3Ch */ case    6:  		/* bc 12, CR6_EQ, 60 */
		/* 82197D3Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82197D78;  }
		/* 82197D3Ch case    6:*/		return 0x82197D40;
		  /* 82197D40h */ case    7:  		/* lwz R9, <#[R10]> */
		/* 82197D40h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82197D40h case    7:*/		return 0x82197D44;
		  /* 82197D44h */ case    8:  		/* rlwinm. R8, R9, 0, 4, 6 */
		/* 82197D44h case    8:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R9);
		/* 82197D44h case    8:*/		return 0x82197D48;
		  /* 82197D48h */ case    9:  		/* bc 12, CR0_EQ, 48 */
		/* 82197D48h case    9:*/		if ( regs.CR[0].eq ) { return 0x82197D78;  }
		/* 82197D48h case    9:*/		return 0x82197D4C;
		  /* 82197D4Ch */ case   10:  		/* lwz R8, <#[R11 + 8]> */
		/* 82197D4Ch case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 82197D4Ch case   10:*/		return 0x82197D50;
		  /* 82197D50h */ case   11:  		/* rlwinm R8, R8, 0, 18, 24 */
		/* 82197D50h case   11:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R8,regs.R8);
		/* 82197D50h case   11:*/		return 0x82197D54;
		  /* 82197D54h */ case   12:  		/* cmplwi CR6, R8, 128 */
		/* 82197D54h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000080);
		/* 82197D54h case   12:*/		return 0x82197D58;
		  /* 82197D58h */ case   13:  		/* bc 4, CR6_EQ, -1552 */
		/* 82197D58h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 82197D58h case   13:*/		return 0x82197D5C;
		  /* 82197D5Ch */ case   14:  		/* rlwinm. R9, R9, 0, 27, 31 */
		/* 82197D5Ch case   14:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82197D5Ch case   14:*/		return 0x82197D60;
		  /* 82197D60h */ case   15:  		/* bc 4, CR0_EQ, -1560 */
		/* 82197D60h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82197D60h case   15:*/		return 0x82197D64;
		  /* 82197D64h */ case   16:  		/* cmplwi CR6, R24, 0 */
		/* 82197D64h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82197D64h case   16:*/		return 0x82197D68;
		  /* 82197D68h */ case   17:  		/* bc 12, CR6_EQ, 12 */
		/* 82197D68h case   17:*/		if ( regs.CR[6].eq ) { return 0x82197D74;  }
		/* 82197D68h case   17:*/		return 0x82197D6C;
		  /* 82197D6Ch */ case   18:  		/* cmplw CR6, R11, R24 */
		/* 82197D6Ch case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 82197D6Ch case   18:*/		return 0x82197D70;
		  /* 82197D70h */ case   19:  		/* bc 4, CR6_EQ, -1576 */
		/* 82197D70h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 82197D70h case   19:*/		return 0x82197D74;
	}
	return 0x82197D74;
} // Block from 82197D24h-82197D74h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82197D74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197D74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197D74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197D74);
		  /* 82197D74h */ case    0:  		/* mr R24, R11 */
		/* 82197D74h case    0:*/		regs.R24 = regs.R11;
		/* 82197D74h case    0:*/		return 0x82197D78;
	}
	return 0x82197D78;
} // Block from 82197D74h-82197D78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197D78);
		  /* 82197D78h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82197D78h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82197D78h case    0:*/		return 0x82197D7C;
		  /* 82197D7Ch */ case    1:  		/* b -80 */
		/* 82197D7Ch case    1:*/		return 0x82197D2C;
		/* 82197D7Ch case    1:*/		return 0x82197D80;
	}
	return 0x82197D80;
} // Block from 82197D78h-82197D80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82197D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197D80);
		  /* 82197D80h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 82197D80h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 82197D80h case    0:*/		return 0x82197D84;
		  /* 82197D84h */ case    1:  		/* bc 12, CR6_EQ, -1596 */
		/* 82197D84h case    1:*/		if ( regs.CR[6].eq ) { return 0x82197748;  }
		/* 82197D84h case    1:*/		return 0x82197D88;
		  /* 82197D88h */ case    2:  		/* lwz R11, <#[R24 + 8]> */
		/* 82197D88h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82197D88h case    2:*/		return 0x82197D8C;
		  /* 82197D8Ch */ case    3:  		/* rlwinm. R10, R11, 7, 31, 31 */
		/* 82197D8Ch case    3:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R10,regs.R11);
		/* 82197D8Ch case    3:*/		return 0x82197D90;
		  /* 82197D90h */ case    4:  		/* bc 4, CR0_EQ, -1608 */
		/* 82197D90h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82197D90h case    4:*/		return 0x82197D94;
		  /* 82197D94h */ case    5:  		/* rlwinm. R10, R11, 27, 31, 31 */
		/* 82197D94h case    5:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R10,regs.R11);
		/* 82197D94h case    5:*/		return 0x82197D98;
		  /* 82197D98h */ case    6:  		/* bc 4, CR0_EQ, -1616 */
		/* 82197D98h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82197D98h case    6:*/		return 0x82197D9C;
		  /* 82197D9Ch */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 82197D9Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82197D9Ch case    7:*/		return 0x82197DA0;
		  /* 82197DA0h */ case    8:  		/* bc 4, CR0_EQ, -1624 */
		/* 82197DA0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82197DA0h case    8:*/		return 0x82197DA4;
		  /* 82197DA4h */ case    9:  		/* rlwinm R6, R31, 18, 29, 31 */
		/* 82197DA4h case    9:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R31);
		/* 82197DA4h case    9:*/		return 0x82197DA8;
		  /* 82197DA8h */ case   10:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 82197DA8h case   10:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 82197DA8h case   10:*/		return 0x82197DAC;
		  /* 82197DACh */ case   11:  		/* cmplw CR6, R11, R6 */
		/* 82197DACh case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 82197DACh case   11:*/		return 0x82197DB0;
		  /* 82197DB0h */ case   12:  		/* bc 4, CR6_EQ, -1640 */
		/* 82197DB0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 82197DB0h case   12:*/		return 0x82197DB4;
		  /* 82197DB4h */ case   13:  		/* lwz R31, <#[R24 + 44]> */
		/* 82197DB4h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + 0x0000002C) );
		/* 82197DB4h case   13:*/		return 0x82197DB8;
		  /* 82197DB8h */ case   14:  		/* lwz R30, <#[R24 + 48]> */
		/* 82197DB8h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R24 + 0x00000030) );
		/* 82197DB8h case   14:*/		return 0x82197DBC;
		  /* 82197DBCh */ case   15:  		/* lwz R11, <#[R31 + 12]> */
		/* 82197DBCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82197DBCh case   15:*/		return 0x82197DC0;
		  /* 82197DC0h */ case   16:  		/* cmplw CR6, R11, R14 */
		/* 82197DC0h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 82197DC0h case   16:*/		return 0x82197DC4;
		  /* 82197DC4h */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 82197DC4h case   17:*/		if ( regs.CR[6].eq ) { return 0x82197DD4;  }
		/* 82197DC4h case   17:*/		return 0x82197DC8;
		  /* 82197DC8h */ case   18:  		/* mr R11, R31 */
		/* 82197DC8h case   18:*/		regs.R11 = regs.R31;
		/* 82197DC8h case   18:*/		return 0x82197DCC;
		  /* 82197DCCh */ case   19:  		/* mr R31, R30 */
		/* 82197DCCh case   19:*/		regs.R31 = regs.R30;
		/* 82197DCCh case   19:*/		return 0x82197DD0;
		  /* 82197DD0h */ case   20:  		/* mr R30, R11 */
		/* 82197DD0h case   20:*/		regs.R30 = regs.R11;
		/* 82197DD0h case   20:*/		return 0x82197DD4;
	}
	return 0x82197DD4;
} // Block from 82197D80h-82197DD4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82197DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197DD4);
		  /* 82197DD4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82197DD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82197DD4h case    0:*/		return 0x82197DD8;
		  /* 82197DD8h */ case    1:  		/* lwz R29, <#[R14 + 52]> */
		/* 82197DD8h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R14 + 0x00000034) );
		/* 82197DD8h case    1:*/		return 0x82197DDC;
		  /* 82197DDCh */ case    2:  		/* rlwinm R26, R11, 27, 24, 31 */
		/* 82197DDCh case    2:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R26,regs.R11);
		/* 82197DDCh case    2:*/		return 0x82197DE0;
		  /* 82197DE0h */ case    3:  		/* b 168 */
		/* 82197DE0h case    3:*/		return 0x82197E88;
		/* 82197DE0h case    3:*/		return 0x82197DE4;
		  /* 82197DE4h */ case    4:  		/* lwz R7, <#[R29 + 16]> */
		/* 82197DE4h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R29 + 0x00000010) );
		/* 82197DE4h case    4:*/		return 0x82197DE8;
		  /* 82197DE8h */ case    5:  		/* lwz R9, <#[R11 + 4]> */
		/* 82197DE8h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82197DE8h case    5:*/		return 0x82197DEC;
		  /* 82197DECh */ case    6:  		/* cmplwi CR6, R9, 0 */
		/* 82197DECh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82197DECh case    6:*/		return 0x82197DF0;
		  /* 82197DF0h */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 82197DF0h case    7:*/		if ( regs.CR[6].eq ) { return 0x82197E18;  }
		/* 82197DF0h case    7:*/		return 0x82197DF4;
		  /* 82197DF4h */ case    8:  		/* lwz R8, <#[R9 + 16]> */
		/* 82197DF4h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000010) );
		/* 82197DF4h case    8:*/		return 0x82197DF8;
		  /* 82197DF8h */ case    9:  		/* cmplwi CR6, R8, 0 */
		/* 82197DF8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 82197DF8h case    9:*/		return 0x82197DFC;
		  /* 82197DFCh */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82197DFCh case   10:*/		if ( regs.CR[6].eq ) { return 0x82197E08;  }
		/* 82197DFCh case   10:*/		return 0x82197E00;
		  /* 82197E00h */ case   11:  		/* cmplw CR6, R8, R7 */
		/* 82197E00h case   11:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 82197E00h case   11:*/		return 0x82197E04;
		  /* 82197E04h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 82197E04h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82197E10;  }
		/* 82197E04h case   12:*/		return 0x82197E08;
	}
	return 0x82197E08;
} // Block from 82197DD4h-82197E08h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82197E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197E08);
		  /* 82197E08h */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 82197E08h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82197E08h case    0:*/		return 0x82197E0C;
		  /* 82197E0Ch */ case    1:  		/* b -32 */
		/* 82197E0Ch case    1:*/		return 0x82197DEC;
		/* 82197E0Ch case    1:*/		return 0x82197E10;
	}
	return 0x82197E10;
} // Block from 82197E08h-82197E10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82197E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197E10);
		  /* 82197E10h */ case    0:  		/* mr R9, R19 */
		/* 82197E10h case    0:*/		regs.R9 = regs.R19;
		/* 82197E10h case    0:*/		return 0x82197E14;
		  /* 82197E14h */ case    1:  		/* b 8 */
		/* 82197E14h case    1:*/		return 0x82197E1C;
		/* 82197E14h case    1:*/		return 0x82197E18;
	}
	return 0x82197E18;
} // Block from 82197E10h-82197E18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82197E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197E18);
		  /* 82197E18h */ case    0:  		/* mr R9, R18 */
		/* 82197E18h case    0:*/		regs.R9 = regs.R18;
		/* 82197E18h case    0:*/		return 0x82197E1C;
	}
	return 0x82197E1C;
} // Block from 82197E18h-82197E1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197E1C);
		  /* 82197E1Ch */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 82197E1Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 82197E1Ch case    0:*/		return 0x82197E20;
		  /* 82197E20h */ case    1:  		/* bc 4, CR0_EQ, 120 */
		/* 82197E20h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82197E98;  }
		/* 82197E20h case    1:*/		return 0x82197E24;
		  /* 82197E24h */ case    2:  		/* rlwinm R9, R10, 18, 29, 31 */
		/* 82197E24h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R9,regs.R10);
		/* 82197E24h case    2:*/		return 0x82197E28;
		  /* 82197E28h */ case    3:  		/* cmplw CR6, R9, R6 */
		/* 82197E28h case    3:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 82197E28h case    3:*/		return 0x82197E2C;
		  /* 82197E2Ch */ case    4:  		/* bc 4, CR6_EQ, 108 */
		/* 82197E2Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82197E98;  }
		/* 82197E2Ch case    4:*/		return 0x82197E30;
		  /* 82197E30h */ case    5:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 82197E30h case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 82197E30h case    5:*/		return 0x82197E34;
		  /* 82197E34h */ case    6:  		/* cmplwi CR6, R10, 2 */
		/* 82197E34h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 82197E34h case    6:*/		return 0x82197E38;
		  /* 82197E38h */ case    7:  		/* bc 12, CR6_EQ, 100 */
		/* 82197E38h case    7:*/		if ( regs.CR[6].eq ) { return 0x82197E9C;  }
		/* 82197E38h case    7:*/		return 0x82197E3C;
		  /* 82197E3Ch */ case    8:  		/* cmplwi CR6, R10, 12 */
		/* 82197E3Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000C);
		/* 82197E3Ch case    8:*/		return 0x82197E40;
		  /* 82197E40h */ case    9:  		/* bc 4, CR6_EQ, -1784 */
		/* 82197E40h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 82197E40h case    9:*/		return 0x82197E44;
		  /* 82197E44h */ case   10:  		/* lwz R10, <#[R29]> */
		/* 82197E44h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82197E44h case   10:*/		return 0x82197E48;
		  /* 82197E48h */ case   11:  		/* rlwinm. R9, R10, 0, 27, 31 */
		/* 82197E48h case   11:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R9,regs.R10);
		/* 82197E48h case   11:*/		return 0x82197E4C;
		  /* 82197E4Ch */ case   12:  		/* bc 4, CR0_EQ, -1796 */
		/* 82197E4Ch case   12:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82197E4Ch case   12:*/		return 0x82197E50;
		  /* 82197E50h */ case   13:  		/* lwz R29, <#[R11 + 52]> */
		/* 82197E50h case   13:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000034) );
		/* 82197E50h case   13:*/		return 0x82197E54;
		  /* 82197E54h */ case   14:  		/* rlwinm R9, R10, 27, 24, 31 */
		/* 82197E54h case   14:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R10);
		/* 82197E54h case   14:*/		return 0x82197E58;
		  /* 82197E58h */ case   15:  		/* rlwinm R11, R26, 27, 29, 30 */
		/* 82197E58h case   15:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R11,regs.R26);
		/* 82197E58h case   15:*/		return 0x82197E5C;
		  /* 82197E5Ch */ case   16:  		/* rlwinm R10, R26, 29, 29, 30 */
		/* 82197E5Ch case   16:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R10,regs.R26);
		/* 82197E5Ch case   16:*/		return 0x82197E60;
		  /* 82197E60h */ case   17:  		/* srw R8, R9, R11 */
		/* 82197E60h case   17:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R9,regs.R11);
		/* 82197E60h case   17:*/		return 0x82197E64;
		  /* 82197E64h */ case   18:  		/* srw R7, R9, R10 */
		/* 82197E64h case   18:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R9,regs.R10);
		/* 82197E64h case   18:*/		return 0x82197E68;
		  /* 82197E68h */ case   19:  		/* rlwinm R5, R26, 31, 29, 30 */
		/* 82197E68h case   19:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R5,regs.R26);
		/* 82197E68h case   19:*/		return 0x82197E6C;
		  /* 82197E6Ch */ case   20:  		/* rlwimi R7, R8, 2, 28, 29 */
		/* 82197E6Ch case   20:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R7,regs.R8);
		/* 82197E6Ch case   20:*/		return 0x82197E70;
		  /* 82197E70h */ case   21:  		/* rlwinm R8, R26, 1, 29, 30 */
		/* 82197E70h case   21:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R8,regs.R26);
		/* 82197E70h case   21:*/		return 0x82197E74;
		  /* 82197E74h */ case   22:  		/* rlwinm R7, R7, 0, 28, 31 */
		/* 82197E74h case   22:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R7,regs.R7);
		/* 82197E74h case   22:*/		return 0x82197E78;
		  /* 82197E78h */ case   23:  		/* srw R5, R9, R5 */
		/* 82197E78h case   23:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R9,regs.R5);
		/* 82197E78h case   23:*/		return 0x82197E7C;
		  /* 82197E7Ch */ case   24:  		/* rlwimi R5, R7, 2, 0, 29 */
		/* 82197E7Ch case   24:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R5,regs.R7);
		/* 82197E7Ch case   24:*/		return 0x82197E80;
		  /* 82197E80h */ case   25:  		/* srw R26, R9, R8 */
		/* 82197E80h case   25:*/		cpu::op::srw<0>(regs,&regs.R26,regs.R9,regs.R8);
		/* 82197E80h case   25:*/		return 0x82197E84;
		  /* 82197E84h */ case   26:  		/* rlwimi R26, R5, 2, 0, 29 */
		/* 82197E84h case   26:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R26,regs.R5);
		/* 82197E84h case   26:*/		return 0x82197E88;
	}
	return 0x82197E88;
} // Block from 82197E1Ch-82197E88h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82197E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197E88);
		  /* 82197E88h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 82197E88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 82197E88h case    0:*/		return 0x82197E8C;
		  /* 82197E8Ch */ case    1:  		/* lwz R10, <#[R11 + 8]> */
		/* 82197E8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82197E8Ch case    1:*/		return 0x82197E90;
		  /* 82197E90h */ case    2:  		/* rlwinm. R9, R10, 7, 31, 31 */
		/* 82197E90h case    2:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R9,regs.R10);
		/* 82197E90h case    2:*/		return 0x82197E94;
		  /* 82197E94h */ case    3:  		/* bc 12, CR0_EQ, -176 */
		/* 82197E94h case    3:*/		if ( regs.CR[0].eq ) { return 0x82197DE4;  }
		/* 82197E94h case    3:*/		return 0x82197E98;
	}
	return 0x82197E98;
} // Block from 82197E88h-82197E98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82197E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197E98);
		  /* 82197E98h */ case    0:  		/* mr R29, R18 */
		/* 82197E98h case    0:*/		regs.R29 = regs.R18;
		/* 82197E98h case    0:*/		return 0x82197E9C;
	}
	return 0x82197E9C;
} // Block from 82197E98h-82197E9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197E9C);
		  /* 82197E9Ch */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82197E9Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82197E9Ch case    0:*/		return 0x82197EA0;
		  /* 82197EA0h */ case    1:  		/* bc 12, CR6_EQ, -1880 */
		/* 82197EA0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82197748;  }
		/* 82197EA0h case    1:*/		return 0x82197EA4;
		  /* 82197EA4h */ case    2:  		/* lwz R4, <#[R30 + 12]> */
		/* 82197EA4h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 82197EA4h case    2:*/		return 0x82197EA8;
		  /* 82197EA8h */ case    3:  		/* lwz R28, <#[R29 + 12]> */
		/* 82197EA8h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x0000000C) );
		/* 82197EA8h case    3:*/		return 0x82197EAC;
		  /* 82197EACh */ case    4:  		/* lwz R11, <#[R4 + 8]> */
		/* 82197EACh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82197EACh case    4:*/		return 0x82197EB0;
		  /* 82197EB0h */ case    5:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82197EB0h case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82197EB0h case    5:*/		return 0x82197EB4;
		  /* 82197EB4h */ case    6:  		/* cmplwi CR6, R11, 125 */
		/* 82197EB4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82197EB4h case    6:*/		return 0x82197EB8;
		  /* 82197EB8h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 82197EB8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82197EC8;  }
		/* 82197EB8h case    7:*/		return 0x82197EBC;
		  /* 82197EBCh */ case    8:  		/* cmplwi CR6, R11, 124 */
		/* 82197EBCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82197EBCh case    8:*/		return 0x82197EC0;
		  /* 82197EC0h */ case    9:  		/* mr R11, R18 */
		/* 82197EC0h case    9:*/		regs.R11 = regs.R18;
		/* 82197EC0h case    9:*/		return 0x82197EC4;
		  /* 82197EC4h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 82197EC4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82197ECC;  }
		/* 82197EC4h case   10:*/		return 0x82197EC8;
	}
	return 0x82197EC8;
} // Block from 82197E9Ch-82197EC8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82197EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197EC8);
		  /* 82197EC8h */ case    0:  		/* mr R11, R19 */
		/* 82197EC8h case    0:*/		regs.R11 = regs.R19;
		/* 82197EC8h case    0:*/		return 0x82197ECC;
	}
	return 0x82197ECC;
} // Block from 82197EC8h-82197ECCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197ECC);
		  /* 82197ECCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82197ECCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82197ECCh case    0:*/		return 0x82197ED0;
		  /* 82197ED0h */ case    1:  		/* bc 4, CR0_EQ, 28 */
		/* 82197ED0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82197EEC;  }
		/* 82197ED0h case    1:*/		return 0x82197ED4;
		  /* 82197ED4h */ case    2:  		/* li R6, 0 */
		/* 82197ED4h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82197ED4h case    2:*/		return 0x82197ED8;
		  /* 82197ED8h */ case    3:  		/* mr R5, R28 */
		/* 82197ED8h case    3:*/		regs.R5 = regs.R28;
		/* 82197ED8h case    3:*/		return 0x82197EDC;
		  /* 82197EDCh */ case    4:  		/* mr R3, R21 */
		/* 82197EDCh case    4:*/		regs.R3 = regs.R21;
		/* 82197EDCh case    4:*/		return 0x82197EE0;
		  /* 82197EE0h */ case    5:  		/* bl 607624 */
		/* 82197EE0h case    5:*/		regs.LR = 0x82197EE4; return 0x8222C468;
		/* 82197EE0h case    5:*/		return 0x82197EE4;
		  /* 82197EE4h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82197EE4h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82197EE4h case    6:*/		return 0x82197EE8;
		  /* 82197EE8h */ case    7:  		/* bc 12, CR0_EQ, -1952 */
		/* 82197EE8h case    7:*/		if ( regs.CR[0].eq ) { return 0x82197748;  }
		/* 82197EE8h case    7:*/		return 0x82197EEC;
	}
	return 0x82197EEC;
} // Block from 82197ECCh-82197EECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 82197EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197EEC);
		  /* 82197EECh */ case    0:  		/* li R8, 4 */
		/* 82197EECh case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 82197EECh case    0:*/		return 0x82197EF0;
		  /* 82197EF0h */ case    1:  		/* li R7, 0 */
		/* 82197EF0h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82197EF0h case    1:*/		return 0x82197EF4;
		  /* 82197EF4h */ case    2:  		/* li R6, 120 */
		/* 82197EF4h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x78);
		/* 82197EF4h case    2:*/		return 0x82197EF8;
		  /* 82197EF8h */ case    3:  		/* mr R5, R24 */
		/* 82197EF8h case    3:*/		regs.R5 = regs.R24;
		/* 82197EF8h case    3:*/		return 0x82197EFC;
		  /* 82197EFCh */ case    4:  		/* li R4, 0 */
		/* 82197EFCh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82197EFCh case    4:*/		return 0x82197F00;
		  /* 82197F00h */ case    5:  		/* mr R3, R21 */
		/* 82197F00h case    5:*/		regs.R3 = regs.R21;
		/* 82197F00h case    5:*/		return 0x82197F04;
		  /* 82197F04h */ case    6:  		/* bl -175860 */
		/* 82197F04h case    6:*/		regs.LR = 0x82197F08; return 0x8216D010;
		/* 82197F04h case    6:*/		return 0x82197F08;
		  /* 82197F08h */ case    7:  		/* lwz R11, <#[R31 + 12]> */
		/* 82197F08h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82197F08h case    7:*/		return 0x82197F0C;
		  /* 82197F0Ch */ case    8:  		/* mr R25, R3 */
		/* 82197F0Ch case    8:*/		regs.R25 = regs.R3;
		/* 82197F0Ch case    8:*/		return 0x82197F10;
		  /* 82197F10h */ case    9:  		/* addi R11, R11, 4 */
		/* 82197F10h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82197F10h case    9:*/		return 0x82197F14;
		  /* 82197F14h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 82197F14h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82197F14h case   10:*/		return 0x82197F18;
		  /* 82197F18h */ case   11:  		/* b 12 */
		/* 82197F18h case   11:*/		return 0x82197F24;
		/* 82197F18h case   11:*/		return 0x82197F1C;
		  /* 82197F1Ch */ case   12:  		/* addi R11, R10, 8 */
		/* 82197F1Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82197F1Ch case   12:*/		return 0x82197F20;
		  /* 82197F20h */ case   13:  		/* lwz R10, <#[R10 + 8]> */
		/* 82197F20h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82197F20h case   13:*/		return 0x82197F24;
	}
	return 0x82197F24;
} // Block from 82197EECh-82197F24h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82197F24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197F24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197F24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197F24);
		  /* 82197F24h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 82197F24h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82197F24h case    0:*/		return 0x82197F28;
		  /* 82197F28h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82197F28h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82197F1C;  }
		/* 82197F28h case    1:*/		return 0x82197F2C;
		  /* 82197F2Ch */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82197F2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82197F2Ch case    2:*/		return 0x82197F30;
		  /* 82197F30h */ case    3:  		/* addi R8, R1, 160 */
		/* 82197F30h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xA0);
		/* 82197F30h case    3:*/		return 0x82197F34;
		  /* 82197F34h */ case    4:  		/* mr R7, R30 */
		/* 82197F34h case    4:*/		regs.R7 = regs.R30;
		/* 82197F34h case    4:*/		return 0x82197F38;
		  /* 82197F38h */ case    5:  		/* mr R6, R29 */
		/* 82197F38h case    5:*/		regs.R6 = regs.R29;
		/* 82197F38h case    5:*/		return 0x82197F3C;
		  /* 82197F3Ch */ case    6:  		/* mr R5, R28 */
		/* 82197F3Ch case    6:*/		regs.R5 = regs.R28;
		/* 82197F3Ch case    6:*/		return 0x82197F40;
		  /* 82197F40h */ case    7:  		/* mr R4, R24 */
		/* 82197F40h case    7:*/		regs.R4 = regs.R24;
		/* 82197F40h case    7:*/		return 0x82197F44;
		  /* 82197F44h */ case    8:  		/* stw R10, <#[R11]> */
		/* 82197F44h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82197F44h case    8:*/		return 0x82197F48;
		  /* 82197F48h */ case    9:  		/* mr R3, R21 */
		/* 82197F48h case    9:*/		regs.R3 = regs.R21;
		/* 82197F48h case    9:*/		return 0x82197F4C;
		  /* 82197F4Ch */ case   10:  		/* lwz R11, <#[R25 + 4]> */
		/* 82197F4Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 82197F4Ch case   10:*/		return 0x82197F50;
		  /* 82197F50h */ case   11:  		/* stw R11, <#[R31 + 8]> */
		/* 82197F50h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82197F50h case   11:*/		return 0x82197F54;
		  /* 82197F54h */ case   12:  		/* stw R31, <#[R25 + 4]> */
		/* 82197F54h case   12:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R25 + 0x00000004) );
		/* 82197F54h case   12:*/		return 0x82197F58;
		  /* 82197F58h */ case   13:  		/* stw R25, <#[R31 + 12]> */
		/* 82197F58h case   13:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x0000000C) );
		/* 82197F58h case   13:*/		return 0x82197F5C;
		  /* 82197F5Ch */ case   14:  		/* bl -6620 */
		/* 82197F5Ch case   14:*/		regs.LR = 0x82197F60; return 0x82196580;
		/* 82197F5Ch case   14:*/		return 0x82197F60;
		  /* 82197F60h */ case   15:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82197F60h case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82197F60h case   15:*/		return 0x82197F64;
		  /* 82197F64h */ case   16:  		/* bc 4, CR0_EQ, 5240 */
		/* 82197F64h case   16:*/		if ( !regs.CR[0].eq ) { return 0x821993DC;  }
		/* 82197F64h case   16:*/		return 0x82197F68;
		  /* 82197F68h */ case   17:  		/* lwz R11, <#[R31 + 12]> */
		/* 82197F68h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82197F68h case   17:*/		return 0x82197F6C;
		  /* 82197F6Ch */ case   18:  		/* addi R11, R11, 4 */
		/* 82197F6Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82197F6Ch case   18:*/		return 0x82197F70;
		  /* 82197F70h */ case   19:  		/* lwz R10, <#[R11]> */
		/* 82197F70h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82197F70h case   19:*/		return 0x82197F74;
		  /* 82197F74h */ case   20:  		/* b 12 */
		/* 82197F74h case   20:*/		return 0x82197F80;
		/* 82197F74h case   20:*/		return 0x82197F78;
		  /* 82197F78h */ case   21:  		/* addi R11, R10, 8 */
		/* 82197F78h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82197F78h case   21:*/		return 0x82197F7C;
		  /* 82197F7Ch */ case   22:  		/* lwz R10, <#[R10 + 8]> */
		/* 82197F7Ch case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82197F7Ch case   22:*/		return 0x82197F80;
	}
	return 0x82197F80;
} // Block from 82197F24h-82197F80h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82197F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197F80);
		  /* 82197F80h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 82197F80h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 82197F80h case    0:*/		return 0x82197F84;
		  /* 82197F84h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82197F84h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82197F78;  }
		/* 82197F84h case    1:*/		return 0x82197F88;
		  /* 82197F88h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 82197F88h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82197F88h case    2:*/		return 0x82197F8C;
		  /* 82197F8Ch */ case    3:  		/* mr R4, R25 */
		/* 82197F8Ch case    3:*/		regs.R4 = regs.R25;
		/* 82197F8Ch case    3:*/		return 0x82197F90;
		  /* 82197F90h */ case    4:  		/* stw R10, <#[R11]> */
		/* 82197F90h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82197F90h case    4:*/		return 0x82197F94;
		  /* 82197F94h */ case    5:  		/* lwz R11, <#[R14 + 4]> */
		/* 82197F94h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 82197F94h case    5:*/		return 0x82197F98;
		  /* 82197F98h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 82197F98h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82197F98h case    6:*/		return 0x82197F9C;
		  /* 82197F9Ch */ case    7:  		/* stw R31, <#[R14 + 4]> */
		/* 82197F9Ch case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R14 + 0x00000004) );
		/* 82197F9Ch case    7:*/		return 0x82197FA0;
		  /* 82197FA0h */ case    8:  		/* stw R14, <#[R31 + 12]> */
		/* 82197FA0h case    8:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R31 + 0x0000000C) );
		/* 82197FA0h case    8:*/		return 0x82197FA4;
		  /* 82197FA4h */ case    9:  		/* b 3220 */
		/* 82197FA4h case    9:*/		return 0x82198C38;
		/* 82197FA4h case    9:*/		return 0x82197FA8;
	}
	return 0x82197FA8;
} // Block from 82197F80h-82197FA8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82197FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197FA8);
		  /* 82197FA8h */ case    0:  		/* lwz R16, <#[R14 + 44]> */
		/* 82197FA8h case    0:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R14 + 0x0000002C) );
		/* 82197FA8h case    0:*/		return 0x82197FAC;
		  /* 82197FACh */ case    1:  		/* lwz R26, <#[R14 + 48]> */
		/* 82197FACh case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R14 + 0x00000030) );
		/* 82197FACh case    1:*/		return 0x82197FB0;
		  /* 82197FB0h */ case    2:  		/* mr R3, R16 */
		/* 82197FB0h case    2:*/		regs.R3 = regs.R16;
		/* 82197FB0h case    2:*/		return 0x82197FB4;
		  /* 82197FB4h */ case    3:  		/* mr R4, R26 */
		/* 82197FB4h case    3:*/		regs.R4 = regs.R26;
		/* 82197FB4h case    3:*/		return 0x82197FB8;
		  /* 82197FB8h */ case    4:  		/* bl -212272 */
		/* 82197FB8h case    4:*/		regs.LR = 0x82197FBC; return 0x82164288;
		/* 82197FB8h case    4:*/		return 0x82197FBC;
		  /* 82197FBCh */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82197FBCh case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82197FBCh case    5:*/		return 0x82197FC0;
		  /* 82197FC0h */ case    6:  		/* bc 12, CR0_EQ, -2168 */
		/* 82197FC0h case    6:*/		if ( regs.CR[0].eq ) { return 0x82197748;  }
		/* 82197FC0h case    6:*/		return 0x82197FC4;
		  /* 82197FC4h */ case    7:  		/* lwz R15, <#[R16 + 12]> */
		/* 82197FC4h case    7:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R16 + 0x0000000C) );
		/* 82197FC4h case    7:*/		return 0x82197FC8;
		  /* 82197FC8h */ case    8:  		/* lwz R10, <#[R15 + 8]> */
		/* 82197FC8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000008) );
		/* 82197FC8h case    8:*/		return 0x82197FCC;
		  /* 82197FCCh */ case    9:  		/* rlwinm. R11, R10, 27, 31, 31 */
		/* 82197FCCh case    9:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R10);
		/* 82197FCCh case    9:*/		return 0x82197FD0;
		  /* 82197FD0h */ case   10:  		/* bc 4, CR0_EQ, -2184 */
		/* 82197FD0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82197FD0h case   10:*/		return 0x82197FD4;
		  /* 82197FD4h */ case   11:  		/* rlwinm R9, R10, 25, 25, 31 */
		/* 82197FD4h case   11:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R10);
		/* 82197FD4h case   11:*/		return 0x82197FD8;
		  /* 82197FD8h */ case   12:  		/* cmplwi CR6, R9, 1 */
		/* 82197FD8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 82197FD8h case   12:*/		return 0x82197FDC;
		  /* 82197FDCh */ case   13:  		/* bc 12, CR6_LT, 16 */
		/* 82197FDCh case   13:*/		if ( regs.CR[6].lt ) { return 0x82197FEC;  }
		/* 82197FDCh case   13:*/		return 0x82197FE0;
		  /* 82197FE0h */ case   14:  		/* cmplwi CR6, R9, 82 */
		/* 82197FE0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000052);
		/* 82197FE0h case   14:*/		return 0x82197FE4;
		  /* 82197FE4h */ case   15:  		/* mr R11, R19 */
		/* 82197FE4h case   15:*/		regs.R11 = regs.R19;
		/* 82197FE4h case   15:*/		return 0x82197FE8;
		  /* 82197FE8h */ case   16:  		/* bc 4, CR6_GT, 8 */
		/* 82197FE8h case   16:*/		if ( !regs.CR[6].gt ) { return 0x82197FF0;  }
		/* 82197FE8h case   16:*/		return 0x82197FEC;
	}
	return 0x82197FEC;
} // Block from 82197FA8h-82197FECh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82197FECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197FEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197FEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197FEC);
		  /* 82197FECh */ case    0:  		/* mr R11, R18 */
		/* 82197FECh case    0:*/		regs.R11 = regs.R18;
		/* 82197FECh case    0:*/		return 0x82197FF0;
	}
	return 0x82197FF0;
} // Block from 82197FECh-82197FF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82197FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82197FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82197FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82197FF0);
		  /* 82197FF0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82197FF0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82197FF0h case    0:*/		return 0x82197FF4;
		  /* 82197FF4h */ case    1:  		/* bc 4, CR0_EQ, 1800 */
		/* 82197FF4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821986FC;  }
		/* 82197FF4h case    1:*/		return 0x82197FF8;
		  /* 82197FF8h */ case    2:  		/* cmplwi CR6, R9, 110 */
		/* 82197FF8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000006E);
		/* 82197FF8h case    2:*/		return 0x82197FFC;
		  /* 82197FFCh */ case    3:  		/* bc 4, CR6_EQ, 1304 */
		/* 82197FFCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x82198514;  }
		/* 82197FFCh case    3:*/		return 0x82198000;
		  /* 82198000h */ case    4:  		/* rlwinm. R11, R31, 27, 31, 31 */
		/* 82198000h case    4:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R31);
		/* 82198000h case    4:*/		return 0x82198004;
		  /* 82198004h */ case    5:  		/* bc 12, CR0_EQ, 1296 */
		/* 82198004h case    5:*/		if ( regs.CR[0].eq ) { return 0x82198514;  }
		/* 82198004h case    5:*/		return 0x82198008;
		  /* 82198008h */ case    6:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82198008h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82198008h case    6:*/		return 0x8219800C;
		  /* 8219800Ch */ case    7:  		/* bc 4, CR0_EQ, 1288 */
		/* 8219800Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82198514;  }
		/* 8219800Ch case    7:*/		return 0x82198010;
		  /* 82198010h */ case    8:  		/* rlwinm. R11, R31, 7, 31, 31 */
		/* 82198010h case    8:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R31);
		/* 82198010h case    8:*/		return 0x82198014;
		  /* 82198014h */ case    9:  		/* bc 4, CR0_EQ, 1280 */
		/* 82198014h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82198514;  }
		/* 82198014h case    9:*/		return 0x82198018;
		  /* 82198018h */ case   10:  		/* lwz R10, <#[R15 + 4]> */
		/* 82198018h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000004) );
		/* 82198018h case   10:*/		return 0x8219801C;
		  /* 8219801Ch */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 8219801Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219801Ch case   11:*/		return 0x82198020;
		  /* 82198020h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 82198020h case   12:*/		if ( regs.CR[6].eq ) { return 0x82198040;  }
		/* 82198020h case   12:*/		return 0x82198024;
		  /* 82198024h */ case   13:  		/* lwz R11, <#[R10 + 16]> */
		/* 82198024h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 82198024h case   13:*/		return 0x82198028;
		  /* 82198028h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82198028h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82198028h case   14:*/		return 0x8219802C;
		  /* 8219802Ch */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 8219802Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x82198038;  }
		/* 8219802Ch case   15:*/		return 0x82198030;
		  /* 82198030h */ case   16:  		/* cmplw CR6, R11, R14 */
		/* 82198030h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 82198030h case   16:*/		return 0x82198034;
		  /* 82198034h */ case   17:  		/* bc 4, CR6_EQ, -2284 */
		/* 82198034h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 82198034h case   17:*/		return 0x82198038;
	}
	return 0x82198038;
} // Block from 82197FF0h-82198038h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82198038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198038);
		  /* 82198038h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82198038h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82198038h case    0:*/		return 0x8219803C;
		  /* 8219803Ch */ case    1:  		/* b -32 */
		/* 8219803Ch case    1:*/		return 0x8219801C;
		/* 8219803Ch case    1:*/		return 0x82198040;
	}
	return 0x82198040;
} // Block from 82198038h-82198040h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198040);
		  /* 82198040h */ case    0:  		/* lwz R11, <#[R21 + 56]> */
		/* 82198040h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000038) );
		/* 82198040h case    0:*/		return 0x82198044;
		  /* 82198044h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82198044h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82198044h case    1:*/		return 0x82198048;
		  /* 82198048h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 82198048h case    2:*/		if ( regs.CR[6].eq ) { return 0x82198058;  }
		/* 82198048h case    2:*/		return 0x8219804C;
		  /* 8219804Ch */ case    3:  		/* lwz R11, <#[R11]> */
		/* 8219804Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219804Ch case    3:*/		return 0x82198050;
		  /* 82198050h */ case    4:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 82198050h case    4:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 82198050h case    4:*/		return 0x82198054;
		  /* 82198054h */ case    5:  		/* bc 4, CR0_EQ, 1524 */
		/* 82198054h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82198648;  }
		/* 82198054h case    5:*/		return 0x82198058;
	}
	return 0x82198058;
} // Block from 82198040h-82198058h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82198058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198058);
		  /* 82198058h */ case    0:  		/* lwz R11, <#[R14]> */
		/* 82198058h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 82198058h case    0:*/		return 0x8219805C;
		  /* 8219805Ch */ case    1:  		/* mr R17, R11 */
		/* 8219805Ch case    1:*/		regs.R17 = regs.R11;
		/* 8219805Ch case    1:*/		return 0x82198060;
		  /* 82198060h */ case    2:  		/* cmplwi CR6, R17, 0 */
		/* 82198060h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 82198060h case    2:*/		return 0x82198064;
		  /* 82198064h */ case    3:  		/* bc 12, CR6_EQ, 64 */
		/* 82198064h case    3:*/		if ( regs.CR[6].eq ) { return 0x821980A4;  }
		/* 82198064h case    3:*/		return 0x82198068;
		  /* 82198068h */ case    4:  		/* lwz R9, <#[R17]> */
		/* 82198068h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000000) );
		/* 82198068h case    4:*/		return 0x8219806C;
		  /* 8219806Ch */ case    5:  		/* rlwinm. R10, R9, 0, 1, 1 */
		/* 8219806Ch case    5:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R9);
		/* 8219806Ch case    5:*/		return 0x82198070;
		  /* 82198070h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 82198070h case    6:*/		if ( regs.CR[0].eq ) { return 0x82198080;  }
		/* 82198070h case    6:*/		return 0x82198074;
		  /* 82198074h */ case    7:  		/* rlwinm. R10, R9, 0, 4, 6 */
		/* 82198074h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R9);
		/* 82198074h case    7:*/		return 0x82198078;
		  /* 82198078h */ case    8:  		/* mr R10, R19 */
		/* 82198078h case    8:*/		regs.R10 = regs.R19;
		/* 82198078h case    8:*/		return 0x8219807C;
		  /* 8219807Ch */ case    9:  		/* bc 12, CR0_EQ, 8 */
		/* 8219807Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82198084;  }
		/* 8219807Ch case    9:*/		return 0x82198080;
	}
	return 0x82198080;
} // Block from 82198058h-82198080h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82198080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198080);
		  /* 82198080h */ case    0:  		/* mr R10, R18 */
		/* 82198080h case    0:*/		regs.R10 = regs.R18;
		/* 82198080h case    0:*/		return 0x82198084;
	}
	return 0x82198084;
} // Block from 82198080h-82198084h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82198084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198084);
		  /* 82198084h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82198084h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82198084h case    0:*/		return 0x82198088;
		  /* 82198088h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82198088h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219809C;  }
		/* 82198088h case    1:*/		return 0x8219808C;
		  /* 8219808Ch */ case    2:  		/* rlwinm R10, R9, 0, 7, 18 */
		/* 8219808Ch case    2:*/		cpu::op::rlwinm<0,0,7,18>(regs,&regs.R10,regs.R9);
		/* 8219808Ch case    2:*/		return 0x82198090;
		  /* 82198090h */ case    3:  		/* lis R9, 1 */
		/* 82198090h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x1);
		/* 82198090h case    3:*/		return 0x82198094;
		  /* 82198094h */ case    4:  		/* cmplw CR6, R10, R9 */
		/* 82198094h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82198094h case    4:*/		return 0x82198098;
		  /* 82198098h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 82198098h case    5:*/		if ( regs.CR[6].eq ) { return 0x821980A4;  }
		/* 82198098h case    5:*/		return 0x8219809C;
	}
	return 0x8219809C;
} // Block from 82198084h-8219809Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219809Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219809C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219809C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219809C);
		  /* 8219809Ch */ case    0:  		/* lwz R17, <#[R17 + 4]> */
		/* 8219809Ch case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R17 + 0x00000004) );
		/* 8219809Ch case    0:*/		return 0x821980A0;
		  /* 821980A0h */ case    1:  		/* b -64 */
		/* 821980A0h case    1:*/		return 0x82198060;
		/* 821980A0h case    1:*/		return 0x821980A4;
	}
	return 0x821980A4;
} // Block from 8219809Ch-821980A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821980A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821980A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821980A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821980A4);
		  /* 821980A4h */ case    0:  		/* lwz R18, <#[R20 + 92]> */
		/* 821980A4h case    0:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R20 + 0x0000005C) );
		/* 821980A4h case    0:*/		return 0x821980A8;
		  /* 821980A8h */ case    1:  		/* cmplwi CR6, R18, 0 */
		/* 821980A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 821980A8h case    1:*/		return 0x821980AC;
		  /* 821980ACh */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 821980ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x821980E8;  }
		/* 821980ACh case    2:*/		return 0x821980B0;
		  /* 821980B0h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821980B0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821980B0h case    3:*/		return 0x821980B4;
		  /* 821980B4h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 821980B4h case    4:*/		if ( regs.CR[6].eq ) { return 0x821980D4;  }
		/* 821980B4h case    4:*/		return 0x821980B8;
		  /* 821980B8h */ case    5:  		/* lwz R10, <#[R11 + 12]> */
		/* 821980B8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821980B8h case    5:*/		return 0x821980BC;
		  /* 821980BCh */ case    6:  		/* cmplw CR6, R10, R18 */
		/* 821980BCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R18);
		/* 821980BCh case    6:*/		return 0x821980C0;
		  /* 821980C0h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 821980C0h case    7:*/		if ( regs.CR[6].eq ) { return 0x821980CC;  }
		/* 821980C0h case    7:*/		return 0x821980C4;
		  /* 821980C4h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 821980C4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821980C4h case    8:*/		return 0x821980C8;
		  /* 821980C8h */ case    9:  		/* b -24 */
		/* 821980C8h case    9:*/		return 0x821980B0;
		/* 821980C8h case    9:*/		return 0x821980CC;
	}
	return 0x821980CC;
} // Block from 821980A4h-821980CCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 821980CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821980CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821980CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821980CC);
		  /* 821980CCh */ case    0:  		/* mr R11, R19 */
		/* 821980CCh case    0:*/		regs.R11 = regs.R19;
		/* 821980CCh case    0:*/		return 0x821980D0;
		  /* 821980D0h */ case    1:  		/* b 8 */
		/* 821980D0h case    1:*/		return 0x821980D8;
		/* 821980D0h case    1:*/		return 0x821980D4;
	}
	return 0x821980D4;
} // Block from 821980CCh-821980D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821980D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821980D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821980D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821980D4);
		  /* 821980D4h */ case    0:  		/* li R11, 0 */
		/* 821980D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821980D4h case    0:*/		return 0x821980D8;
	}
	return 0x821980D8;
} // Block from 821980D4h-821980D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821980D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821980D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821980D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821980D8);
		  /* 821980D8h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821980D8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821980D8h case    0:*/		return 0x821980DC;
		  /* 821980DCh */ case    1:  		/* subfic R11, R11, 0 */
		/* 821980DCh case    1:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 821980DCh case    1:*/		return 0x821980E0;
		  /* 821980E0h */ case    2:  		/* subfe R11, R11, R11 */
		/* 821980E0h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 821980E0h case    2:*/		return 0x821980E4;
		  /* 821980E4h */ case    3:  		/* and R18, R11, R18 */
		/* 821980E4h case    3:*/		cpu::op::and<0>(regs,&regs.R18,regs.R11,regs.R18);
		/* 821980E4h case    3:*/		return 0x821980E8;
	}
	return 0x821980E8;
} // Block from 821980D8h-821980E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821980E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821980E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821980E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821980E8);
		  /* 821980E8h */ case    0:  		/* lwz R19, <#[R14 + 4]> */
		/* 821980E8h case    0:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R14 + 0x00000004) );
		/* 821980E8h case    0:*/		return 0x821980EC;
		  /* 821980ECh */ case    1:  		/* cmplwi CR6, R19, 0 */
		/* 821980ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 821980ECh case    1:*/		return 0x821980F0;
		  /* 821980F0h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 821980F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82198114;  }
		/* 821980F0h case    2:*/		return 0x821980F4;
		  /* 821980F4h */ case    3:  		/* lwz R11, <#[R19 + 16]> */
		/* 821980F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000010) );
		/* 821980F4h case    3:*/		return 0x821980F8;
		  /* 821980F8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821980F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821980F8h case    4:*/		return 0x821980FC;
		  /* 821980FCh */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 821980FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x8219810C;  }
		/* 821980FCh case    5:*/		return 0x82198100;
		  /* 82198100h */ case    6:  		/* lwz R11, <#[R19]> */
		/* 82198100h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 82198100h case    6:*/		return 0x82198104;
		  /* 82198104h */ case    7:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82198104h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82198104h case    7:*/		return 0x82198108;
		  /* 82198108h */ case    8:  		/* bc 4, CR0_EQ, 12 */
		/* 82198108h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82198114;  }
		/* 82198108h case    8:*/		return 0x8219810C;
	}
	return 0x8219810C;
} // Block from 821980E8h-8219810Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219810Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219810C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219810C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219810C);
		  /* 8219810Ch */ case    0:  		/* lwz R19, <#[R19 + 8]> */
		/* 8219810Ch case    0:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R19 + 0x00000008) );
		/* 8219810Ch case    0:*/		return 0x82198110;
		  /* 82198110h */ case    1:  		/* b -36 */
		/* 82198110h case    1:*/		return 0x821980EC;
		/* 82198110h case    1:*/		return 0x82198114;
	}
	return 0x82198114;
} // Block from 8219810Ch-82198114h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198114);
		  /* 82198114h */ case    0:  		/* lwz R11, <#[R16]> */
		/* 82198114h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82198114h case    0:*/		return 0x82198118;
		  /* 82198118h */ case    1:  		/* li R22, 0 */
		/* 82198118h case    1:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 82198118h case    1:*/		return 0x8219811C;
		  /* 8219811Ch */ case    2:  		/* lwz R10, <#[R19]> */
		/* 8219811Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000000) );
		/* 8219811Ch case    2:*/		return 0x82198120;
		  /* 82198120h */ case    3:  		/* li R23, 0 */
		/* 82198120h case    3:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82198120h case    3:*/		return 0x82198124;
		  /* 82198124h */ case    4:  		/* rlwinm. R26, R11, 7, 29, 31 */
		/* 82198124h case    4:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R26,regs.R11);
		/* 82198124h case    4:*/		return 0x82198128;
		  /* 82198128h */ case    5:  		/* rlwinm R20, R10, 19, 20, 31 */
		/* 82198128h case    5:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R20,regs.R10);
		/* 82198128h case    5:*/		return 0x8219812C;
		  /* 8219812Ch */ case    6:  		/* rlwinm R21, R11, 27, 24, 31 */
		/* 8219812Ch case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R21,regs.R11);
		/* 8219812Ch case    6:*/		return 0x82198130;
		  /* 82198130h */ case    7:  		/* li R27, 0 */
		/* 82198130h case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82198130h case    7:*/		return 0x82198134;
		  /* 82198134h */ case    8:  		/* bc 12, CR0_EQ, 700 */
		/* 82198134h case    8:*/		if ( regs.CR[0].eq ) { return 0x821983F0;  }
		/* 82198134h case    8:*/		return 0x82198138;
		  /* 82198138h */ case    9:  		/* li R24, 0 */
		/* 82198138h case    9:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82198138h case    9:*/		return 0x8219813C;
		  /* 8219813Ch */ case   10:  		/* li R25, 0 */
		/* 8219813Ch case   10:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8219813Ch case   10:*/		return 0x82198140;
		  /* 82198140h */ case   11:  		/* srw R11, R21, R24 */
		/* 82198140h case   11:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R21,regs.R24);
		/* 82198140h case   11:*/		return 0x82198144;
		  /* 82198144h */ case   12:  		/* rlwinm R6, R11, 0, 30, 31 */
		/* 82198144h case   12:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R11);
		/* 82198144h case   12:*/		return 0x82198148;
		  /* 82198148h */ case   13:  		/* li R11, 1 */
		/* 82198148h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82198148h case   13:*/		return 0x8219814C;
		  /* 8219814Ch */ case   14:  		/* addi R10, R6, 11 */
		/* 8219814Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xB);
		/* 8219814Ch case   14:*/		return 0x82198150;
		  /* 82198150h */ case   15:  		/* slw R11, R11, R6 */
		/* 82198150h case   15:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82198150h case   15:*/		return 0x82198154;
		  /* 82198154h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82198154h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82198154h case   16:*/		return 0x82198158;
		  /* 82198158h */ case   17:  		/* or R22, R11, R22 */
		/* 82198158h case   17:*/		cpu::op::or<0>(regs,&regs.R22,regs.R11,regs.R22);
		/* 82198158h case   17:*/		return 0x8219815C;
		  /* 8219815Ch */ case   18:  		/* lwzx R11, <#[R10 + R15]> */
		/* 8219815Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R15 + 0x00000000) );
		/* 8219815Ch case   18:*/		return 0x82198160;
		  /* 82198160h */ case   19:  		/* lwz R28, <#[R11 + 12]> */
		/* 82198160h case   19:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x0000000C) );
		/* 82198160h case   19:*/		return 0x82198164;
		  /* 82198164h */ case   20:  		/* lwz R10, <#[R28 + 8]> */
		/* 82198164h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 82198164h case   20:*/		return 0x82198168;
		  /* 82198168h */ case   21:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 82198168h case   21:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 82198168h case   21:*/		return 0x8219816C;
		  /* 8219816Ch */ case   22:  		/* cmplwi CR6, R11, 112 */
		/* 8219816Ch case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000070);
		/* 8219816Ch case   22:*/		return 0x82198170;
		  /* 82198170h */ case   23:  		/* bc 12, CR6_EQ, 640 */
		/* 82198170h case   23:*/		if ( regs.CR[6].eq ) { return 0x821983F0;  }
		/* 82198170h case   23:*/		return 0x82198174;
		  /* 82198174h */ case   24:  		/* cmplwi CR6, R11, 1 */
		/* 82198174h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82198174h case   24:*/		return 0x82198178;
		  /* 82198178h */ case   25:  		/* bc 12, CR6_LT, 16 */
		/* 82198178h case   25:*/		if ( regs.CR[6].lt ) { return 0x82198188;  }
		/* 82198178h case   25:*/		return 0x8219817C;
		  /* 8219817Ch */ case   26:  		/* cmplwi CR6, R11, 102 */
		/* 8219817Ch case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 8219817Ch case   26:*/		return 0x82198180;
		  /* 82198180h */ case   27:  		/* li R11, 1 */
		/* 82198180h case   27:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82198180h case   27:*/		return 0x82198184;
		  /* 82198184h */ case   28:  		/* bc 4, CR6_GT, 8 */
		/* 82198184h case   28:*/		if ( !regs.CR[6].gt ) { return 0x8219818C;  }
		/* 82198184h case   28:*/		return 0x82198188;
	}
	return 0x82198188;
} // Block from 82198114h-82198188h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82198188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198188);
		  /* 82198188h */ case    0:  		/* li R11, 0 */
		/* 82198188h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82198188h case    0:*/		return 0x8219818C;
	}
	return 0x8219818C;
} // Block from 82198188h-8219818Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219818Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219818C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219818C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219818C);
		  /* 8219818Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219818Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219818Ch case    0:*/		return 0x82198190;
		  /* 82198190h */ case    1:  		/* bc 12, CR0_EQ, 608 */
		/* 82198190h case    1:*/		if ( regs.CR[0].eq ) { return 0x821983F0;  }
		/* 82198190h case    1:*/		return 0x82198194;
		  /* 82198194h */ case    2:  		/* rlwinm. R11, R10, 7, 31, 31 */
		/* 82198194h case    2:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R10);
		/* 82198194h case    2:*/		return 0x82198198;
		  /* 82198198h */ case    3:  		/* bc 4, CR0_EQ, 600 */
		/* 82198198h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821983F0;  }
		/* 82198198h case    3:*/		return 0x8219819C;
		  /* 8219819Ch */ case    4:  		/* lwz R10, <#[R28 + 4]> */
		/* 8219819Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 8219819Ch case    4:*/		return 0x821981A0;
		  /* 821981A0h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 821981A0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821981A0h case    5:*/		return 0x821981A4;
		  /* 821981A4h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 821981A4h case    6:*/		if ( regs.CR[6].eq ) { return 0x821981C4;  }
		/* 821981A4h case    6:*/		return 0x821981A8;
		  /* 821981A8h */ case    7:  		/* lwz R11, <#[R10 + 16]> */
		/* 821981A8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 821981A8h case    7:*/		return 0x821981AC;
		  /* 821981ACh */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 821981ACh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821981ACh case    8:*/		return 0x821981B0;
		  /* 821981B0h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 821981B0h case    9:*/		if ( regs.CR[6].eq ) { return 0x821981BC;  }
		/* 821981B0h case    9:*/		return 0x821981B4;
		  /* 821981B4h */ case   10:  		/* cmplw CR6, R11, R15 */
		/* 821981B4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R15);
		/* 821981B4h case   10:*/		return 0x821981B8;
		  /* 821981B8h */ case   11:  		/* bc 4, CR6_EQ, 568 */
		/* 821981B8h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821983F0;  }
		/* 821981B8h case   11:*/		return 0x821981BC;
	}
	return 0x821981BC;
} // Block from 8219818Ch-821981BCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 821981BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821981BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821981BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821981BC);
		  /* 821981BCh */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 821981BCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821981BCh case    0:*/		return 0x821981C0;
		  /* 821981C0h */ case    1:  		/* b -32 */
		/* 821981C0h case    1:*/		return 0x821981A0;
		/* 821981C0h case    1:*/		return 0x821981C4;
	}
	return 0x821981C4;
} // Block from 821981BCh-821981C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821981C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821981C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821981C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821981C4);
		  /* 821981C4h */ case    0:  		/* lwz R7, <#[R15 + 4]> */
		/* 821981C4h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R15 + 0x00000004) );
		/* 821981C4h case    0:*/		return 0x821981C8;
		  /* 821981C8h */ case    1:  		/* cmplwi CR6, R7, 0 */
		/* 821981C8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 821981C8h case    1:*/		return 0x821981CC;
		  /* 821981CCh */ case    2:  		/* bc 12, CR6_EQ, 116 */
		/* 821981CCh case    2:*/		if ( regs.CR[6].eq ) { return 0x82198240;  }
		/* 821981CCh case    2:*/		return 0x821981D0;
		  /* 821981D0h */ case    3:  		/* lwz R11, <#[R7 + 16]> */
		/* 821981D0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000010) );
		/* 821981D0h case    3:*/		return 0x821981D4;
		  /* 821981D4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821981D4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821981D4h case    4:*/		return 0x821981D8;
		  /* 821981D8h */ case    5:  		/* bc 12, CR6_EQ, 88 */
		/* 821981D8h case    5:*/		if ( regs.CR[6].eq ) { return 0x82198230;  }
		/* 821981D8h case    5:*/		return 0x821981DC;
		  /* 821981DCh */ case    6:  		/* lwz R8, <#[R7]> */
		/* 821981DCh case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821981DCh case    6:*/		return 0x821981E0;
		  /* 821981E0h */ case    7:  		/* rlwinm. R9, R8, 7, 29, 31 */
		/* 821981E0h case    7:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R9,regs.R8);
		/* 821981E0h case    7:*/		return 0x821981E4;
		  /* 821981E4h */ case    8:  		/* bc 12, CR0_EQ, 76 */
		/* 821981E4h case    8:*/		if ( regs.CR[0].eq ) { return 0x82198230;  }
		/* 821981E4h case    8:*/		return 0x821981E8;
		  /* 821981E8h */ case    9:  		/* cmplw CR6, R11, R14 */
		/* 821981E8h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 821981E8h case    9:*/		return 0x821981EC;
		  /* 821981ECh */ case   10:  		/* bc 12, CR6_EQ, 68 */
		/* 821981ECh case   10:*/		if ( regs.CR[6].eq ) { return 0x82198230;  }
		/* 821981ECh case   10:*/		return 0x821981F0;
		  /* 821981F0h */ case   11:  		/* li R10, 0 */
		/* 821981F0h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821981F0h case   11:*/		return 0x821981F4;
		  /* 821981F4h */ case   12:  		/* cmplwi CR6, R9, 0 */
		/* 821981F4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821981F4h case   12:*/		return 0x821981F8;
		  /* 821981F8h */ case   13:  		/* bc 12, CR6_EQ, 44 */
		/* 821981F8h case   13:*/		if ( regs.CR[6].eq ) { return 0x82198224;  }
		/* 821981F8h case   13:*/		return 0x821981FC;
		  /* 821981FCh */ case   14:  		/* li R11, 0 */
		/* 821981FCh case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821981FCh case   14:*/		return 0x82198200;
		  /* 82198200h */ case   15:  		/* rlwinm R5, R8, 27, 24, 31 */
		/* 82198200h case   15:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R5,regs.R8);
		/* 82198200h case   15:*/		return 0x82198204;
		  /* 82198204h */ case   16:  		/* srw R5, R5, R11 */
		/* 82198204h case   16:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R5,regs.R11);
		/* 82198204h case   16:*/		return 0x82198208;
		  /* 82198208h */ case   17:  		/* rlwinm R5, R5, 0, 30, 31 */
		/* 82198208h case   17:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R5);
		/* 82198208h case   17:*/		return 0x8219820C;
		  /* 8219820Ch */ case   18:  		/* cmpw CR6, R6, R5 */
		/* 8219820Ch case   18:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R5);
		/* 8219820Ch case   18:*/		return 0x82198210;
		  /* 82198210h */ case   19:  		/* bc 12, CR6_EQ, 40 */
		/* 82198210h case   19:*/		if ( regs.CR[6].eq ) { return 0x82198238;  }
		/* 82198210h case   19:*/		return 0x82198214;
		  /* 82198214h */ case   20:  		/* addi R10, R10, 1 */
		/* 82198214h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82198214h case   20:*/		return 0x82198218;
		  /* 82198218h */ case   21:  		/* addi R11, R11, 2 */
		/* 82198218h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82198218h case   21:*/		return 0x8219821C;
		  /* 8219821Ch */ case   22:  		/* cmplw CR6, R10, R9 */
		/* 8219821Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8219821Ch case   22:*/		return 0x82198220;
		  /* 82198220h */ case   23:  		/* bc 12, CR6_LT, -32 */
		/* 82198220h case   23:*/		if ( regs.CR[6].lt ) { return 0x82198200;  }
		/* 82198220h case   23:*/		return 0x82198224;
	}
	return 0x82198224;
} // Block from 821981C4h-82198224h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82198224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198224);
		  /* 82198224h */ case    0:  		/* li R11, 0 */
		/* 82198224h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82198224h case    0:*/		return 0x82198228;
		  /* 82198228h */ case    1:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82198228h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82198228h case    1:*/		return 0x8219822C;
		  /* 8219822Ch */ case    2:  		/* bc 4, CR0_EQ, 452 */
		/* 8219822Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x821983F0;  }
		/* 8219822Ch case    2:*/		return 0x82198230;
	}
	return 0x82198230;
} // Block from 82198224h-82198230h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82198230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198230);
		  /* 82198230h */ case    0:  		/* lwz R7, <#[R7 + 8]> */
		/* 82198230h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000008) );
		/* 82198230h case    0:*/		return 0x82198234;
		  /* 82198234h */ case    1:  		/* b -108 */
		/* 82198234h case    1:*/		return 0x821981C8;
		/* 82198234h case    1:*/		return 0x82198238;
	}
	return 0x82198238;
} // Block from 82198230h-82198238h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198238);
		  /* 82198238h */ case    0:  		/* li R11, 1 */
		/* 82198238h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82198238h case    0:*/		return 0x8219823C;
		  /* 8219823Ch */ case    1:  		/* b -20 */
		/* 8219823Ch case    1:*/		return 0x82198228;
		/* 8219823Ch case    1:*/		return 0x82198240;
	}
	return 0x82198240;
} // Block from 82198238h-82198240h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198240);
		  /* 82198240h */ case    0:  		/* cmplwi CR6, R17, 0 */
		/* 82198240h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 82198240h case    0:*/		return 0x82198244;
		  /* 82198244h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 82198244h case    1:*/		if ( regs.CR[6].eq ) { return 0x82198264;  }
		/* 82198244h case    1:*/		return 0x82198248;
		  /* 82198248h */ case    2:  		/* li R6, 0 */
		/* 82198248h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82198248h case    2:*/		return 0x8219824C;
		  /* 8219824Ch */ case    3:  		/* lwz R4, <#[R17 + 12]> */
		/* 8219824Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x0000000C) );
		/* 8219824Ch case    3:*/		return 0x82198250;
		  /* 82198250h */ case    4:  		/* mr R5, R28 */
		/* 82198250h case    4:*/		regs.R5 = regs.R28;
		/* 82198250h case    4:*/		return 0x82198254;
		  /* 82198254h */ case    5:  		/* lwz R3, <#[R1 + 484]> */
		/* 82198254h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000001E4) );
		/* 82198254h case    5:*/		return 0x82198258;
		  /* 82198258h */ case    6:  		/* bl 606736 */
		/* 82198258h case    6:*/		regs.LR = 0x8219825C; return 0x8222C468;
		/* 82198258h case    6:*/		return 0x8219825C;
		  /* 8219825Ch */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219825Ch case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219825Ch case    7:*/		return 0x82198260;
		  /* 82198260h */ case    8:  		/* bc 12, CR0_EQ, 400 */
		/* 82198260h case    8:*/		if ( regs.CR[0].eq ) { return 0x821983F0;  }
		/* 82198260h case    8:*/		return 0x82198264;
	}
	return 0x82198264;
} // Block from 82198240h-82198264h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82198264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198264);
		  /* 82198264h */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 82198264h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82198264h case    0:*/		return 0x82198268;
		  /* 82198268h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 82198268h case    1:*/		if ( regs.CR[6].eq ) { return 0x82198288;  }
		/* 82198268h case    1:*/		return 0x8219826C;
		  /* 8219826Ch */ case    2:  		/* li R6, 0 */
		/* 8219826Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8219826Ch case    2:*/		return 0x82198270;
		  /* 82198270h */ case    3:  		/* lwz R3, <#[R1 + 484]> */
		/* 82198270h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000001E4) );
		/* 82198270h case    3:*/		return 0x82198274;
		  /* 82198274h */ case    4:  		/* mr R5, R28 */
		/* 82198274h case    4:*/		regs.R5 = regs.R28;
		/* 82198274h case    4:*/		return 0x82198278;
		  /* 82198278h */ case    5:  		/* mr R4, R18 */
		/* 82198278h case    5:*/		regs.R4 = regs.R18;
		/* 82198278h case    5:*/		return 0x8219827C;
		  /* 8219827Ch */ case    6:  		/* bl 606700 */
		/* 8219827Ch case    6:*/		regs.LR = 0x82198280; return 0x8222C468;
		/* 8219827Ch case    6:*/		return 0x82198280;
		  /* 82198280h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198280h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198280h case    7:*/		return 0x82198284;
		  /* 82198284h */ case    8:  		/* bc 12, CR0_EQ, 364 */
		/* 82198284h case    8:*/		if ( regs.CR[0].eq ) { return 0x821983F0;  }
		/* 82198284h case    8:*/		return 0x82198288;
	}
	return 0x82198288;
} // Block from 82198264h-82198288h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82198288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198288);
		  /* 82198288h */ case    0:  		/* lwz R11, <#[R16]> */
		/* 82198288h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82198288h case    0:*/		return 0x8219828C;
		  /* 8219828Ch */ case    1:  		/* rlwinm. R30, R11, 0, 27, 31 */
		/* 8219828Ch case    1:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R30,regs.R11);
		/* 8219828Ch case    1:*/		return 0x82198290;
		  /* 82198290h */ case    2:  		/* bc 12, CR0_EQ, 124 */
		/* 82198290h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219830C;  }
		/* 82198290h case    2:*/		return 0x82198294;
		  /* 82198294h */ case    3:  		/* lwz R11, <#[R28 + 8]> */
		/* 82198294h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82198294h case    3:*/		return 0x82198298;
		  /* 82198298h */ case    4:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82198298h case    4:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82198298h case    4:*/		return 0x8219829C;
		  /* 8219829Ch */ case    5:  		/* cmplwi CR6, R11, 384 */
		/* 8219829Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000180);
		/* 8219829Ch case    5:*/		return 0x821982A0;
		  /* 821982A0h */ case    6:  		/* bc 4, CR6_EQ, 336 */
		/* 821982A0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821983F0;  }
		/* 821982A0h case    6:*/		return 0x821982A4;
		  /* 821982A4h */ case    7:  		/* lwz R31, <#[R28 + 44]> */
		/* 821982A4h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x0000002C) );
		/* 821982A4h case    7:*/		return 0x821982A8;
		  /* 821982A8h */ case    8:  		/* lwz R4, <#[R28 + 48]> */
		/* 821982A8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000030) );
		/* 821982A8h case    8:*/		return 0x821982AC;
		  /* 821982ACh */ case    9:  		/* mr R3, R31 */
		/* 821982ACh case    9:*/		regs.R3 = regs.R31;
		/* 821982ACh case    9:*/		return 0x821982B0;
		  /* 821982B0h */ case   10:  		/* bl -213032 */
		/* 821982B0h case   10:*/		regs.LR = 0x821982B4; return 0x82164288;
		/* 821982B0h case   10:*/		return 0x821982B4;
		  /* 821982B4h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821982B4h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821982B4h case   11:*/		return 0x821982B8;
		  /* 821982B8h */ case   12:  		/* bc 12, CR0_EQ, 312 */
		/* 821982B8h case   12:*/		if ( regs.CR[0].eq ) { return 0x821983F0;  }
		/* 821982B8h case   12:*/		return 0x821982BC;
		  /* 821982BCh */ case   13:  		/* lwz R11, <#[R31]> */
		/* 821982BCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821982BCh case   13:*/		return 0x821982C0;
		  /* 821982C0h */ case   14:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 821982C0h case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821982C0h case   14:*/		return 0x821982C4;
		  /* 821982C4h */ case   15:  		/* rlwinm. R10, R11, 0, 27, 28 */
		/* 821982C4h case   15:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R11);
		/* 821982C4h case   15:*/		return 0x821982C8;
		  /* 821982C8h */ case   16:  		/* bc 12, CR0_EQ, 20 */
		/* 821982C8h case   16:*/		if ( regs.CR[0].eq ) { return 0x821982DC;  }
		/* 821982C8h case   16:*/		return 0x821982CC;
		  /* 821982CCh */ case   17:  		/* rlwinm. R10, R30, 0, 27, 28 */
		/* 821982CCh case   17:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R30);
		/* 821982CCh case   17:*/		return 0x821982D0;
		  /* 821982D0h */ case   18:  		/* bc 12, CR0_EQ, 12 */
		/* 821982D0h case   18:*/		if ( regs.CR[0].eq ) { return 0x821982DC;  }
		/* 821982D0h case   18:*/		return 0x821982D4;
		  /* 821982D4h */ case   19:  		/* li R11, 0 */
		/* 821982D4h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821982D4h case   19:*/		return 0x821982D8;
		  /* 821982D8h */ case   20:  		/* b 44 */
		/* 821982D8h case   20:*/		return 0x82198304;
		/* 821982D8h case   20:*/		return 0x821982DC;
	}
	return 0x821982DC;
} // Block from 82198288h-821982DCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 821982DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821982DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821982DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821982DC);
		  /* 821982DCh */ case    0:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 821982DCh case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 821982DCh case    0:*/		return 0x821982E0;
		  /* 821982E0h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821982E0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821982EC;  }
		/* 821982E0h case    1:*/		return 0x821982E4;
		  /* 821982E4h */ case    2:  		/* rlwinm. R10, R30, 0, 31, 31 */
		/* 821982E4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R30);
		/* 821982E4h case    2:*/		return 0x821982E8;
		  /* 821982E8h */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 821982E8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821982D4;  }
		/* 821982E8h case    3:*/		return 0x821982EC;
	}
	return 0x821982EC;
} // Block from 821982DCh-821982ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821982ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821982EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821982EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821982EC);
		  /* 821982ECh */ case    0:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 821982ECh case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 821982ECh case    0:*/		return 0x821982F0;
		  /* 821982F0h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821982F0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82198300;  }
		/* 821982F0h case    1:*/		return 0x821982F4;
		  /* 821982F4h */ case    2:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 821982F4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 821982F4h case    2:*/		return 0x821982F8;
		  /* 821982F8h */ case    3:  		/* li R11, 0 */
		/* 821982F8h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821982F8h case    3:*/		return 0x821982FC;
		  /* 821982FCh */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 821982FCh case    4:*/		if ( !regs.CR[0].eq ) { return 0x82198304;  }
		/* 821982FCh case    4:*/		return 0x82198300;
	}
	return 0x82198300;
} // Block from 821982ECh-82198300h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82198300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198300);
		  /* 82198300h */ case    0:  		/* li R11, 1 */
		/* 82198300h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82198300h case    0:*/		return 0x82198304;
	}
	return 0x82198304;
} // Block from 82198300h-82198304h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82198304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198304);
		  /* 82198304h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82198304h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82198304h case    0:*/		return 0x82198308;
		  /* 82198308h */ case    1:  		/* bc 12, CR0_EQ, 232 */
		/* 82198308h case    1:*/		if ( regs.CR[0].eq ) { return 0x821983F0;  }
		/* 82198308h case    1:*/		return 0x8219830C;
	}
	return 0x8219830C;
} // Block from 82198304h-8219830Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219830Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219830C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219830C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219830C);
		  /* 8219830Ch */ case    0:  		/* li R30, 0 */
		/* 8219830Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8219830Ch case    0:*/		return 0x82198310;
		  /* 82198310h */ case    1:  		/* li R31, 0 */
		/* 82198310h case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82198310h case    1:*/		return 0x82198314;
		  /* 82198314h */ case    2:  		/* li R29, 0 */
		/* 82198314h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82198314h case    2:*/		return 0x82198318;
		  /* 82198318h */ case    3:  		/* rlwinm R10, R20, 0, 28, 31 */
		/* 82198318h case    3:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R20);
		/* 82198318h case    3:*/		return 0x8219831C;
		  /* 8219831Ch */ case    4:  		/* addi R23, R23, 1 */
		/* 8219831Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 8219831Ch case    4:*/		return 0x82198320;
		  /* 82198320h */ case    5:  		/* li R7, 0 */
		/* 82198320h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82198320h case    5:*/		return 0x82198324;
		  /* 82198324h */ case    6:  		/* li R11, 0 */
		/* 82198324h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82198324h case    6:*/		return 0x82198328;
		  /* 82198328h */ case    7:  		/* li R6, 0 */
		/* 82198328h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82198328h case    7:*/		return 0x8219832C;
		  /* 8219832Ch */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 8219832Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219832Ch case    8:*/		return 0x82198330;
		  /* 82198330h */ case    9:  		/* bc 12, CR6_EQ, 116 */
		/* 82198330h case    9:*/		if ( regs.CR[6].eq ) { return 0x821983A4;  }
		/* 82198330h case    9:*/		return 0x82198334;
		  /* 82198334h */ case   10:  		/* srw R9, R21, R6 */
		/* 82198334h case   10:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R21,regs.R6);
		/* 82198334h case   10:*/		return 0x82198338;
		  /* 82198338h */ case   11:  		/* rlwinm R9, R9, 0, 30, 31 */
		/* 82198338h case   11:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R9);
		/* 82198338h case   11:*/		return 0x8219833C;
		  /* 8219833Ch */ case   12:  		/* addi R8, R10, -1 */
		/* 8219833Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xFFFFFFFF);
		/* 8219833Ch case   12:*/		return 0x82198340;
		  /* 82198340h */ case   13:  		/* addi R5, R9, 11 */
		/* 82198340h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0xB);
		/* 82198340h case   13:*/		return 0x82198344;
		  /* 82198344h */ case   14:  		/* andc R9, R10, R8 */
		/* 82198344h case   14:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R10,regs.R8);
		/* 82198344h case   14:*/		return 0x82198348;
		  /* 82198348h */ case   15:  		/* rlwinm R8, R5, 2, 0, 29 */
		/* 82198348h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R5);
		/* 82198348h case   15:*/		return 0x8219834C;
		  /* 8219834Ch */ case   16:  		/* subf R10, R9, R10 */
		/* 8219834Ch case   16:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8219834Ch case   16:*/		return 0x82198350;
		  /* 82198350h */ case   17:  		/* lwzx R8, <#[R8 + R15]> */
		/* 82198350h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R15 + 0x00000000) );
		/* 82198350h case   17:*/		return 0x82198354;
		  /* 82198354h */ case   18:  		/* lwz R5, <#[R8 + 12]> */
		/* 82198354h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x0000000C) );
		/* 82198354h case   18:*/		return 0x82198358;
		  /* 82198358h */ case   19:  		/* cmplw CR6, R5, R28 */
		/* 82198358h case   19:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R28);
		/* 82198358h case   19:*/		return 0x8219835C;
		  /* 8219835Ch */ case   20:  		/* bc 4, CR6_EQ, 56 */
		/* 8219835Ch case   20:*/		if ( !regs.CR[6].eq ) { return 0x82198394;  }
		/* 8219835Ch case   20:*/		return 0x82198360;
		  /* 82198360h */ case   21:  		/* lwz R8, <#[R8]> */
		/* 82198360h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 82198360h case   21:*/		return 0x82198364;
		  /* 82198364h */ case   22:  		/* li R5, 3 */
		/* 82198364h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82198364h case   22:*/		return 0x82198368;
		  /* 82198368h */ case   23:  		/* addi R31, R31, 1 */
		/* 82198368h case   23:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82198368h case   23:*/		return 0x8219836C;
		  /* 8219836Ch */ case   24:  		/* slw R5, R5, R11 */
		/* 8219836Ch case   24:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R5,regs.R11);
		/* 8219836Ch case   24:*/		return 0x82198370;
		  /* 82198370h */ case   25:  		/* rlwinm R8, R8, 27, 30, 31 */
		/* 82198370h case   25:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R8,regs.R8);
		/* 82198370h case   25:*/		return 0x82198374;
		  /* 82198374h */ case   26:  		/* andc R5, R30, R5 */
		/* 82198374h case   26:*/		cpu::op::andc<0>(regs,&regs.R5,regs.R30,regs.R5);
		/* 82198374h case   26:*/		return 0x82198378;
		  /* 82198378h */ case   27:  		/* slw R8, R8, R11 */
		/* 82198378h case   27:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 82198378h case   27:*/		return 0x8219837C;
		  /* 8219837Ch */ case   28:  		/* or R30, R8, R5 */
		/* 8219837Ch case   28:*/		cpu::op::or<0>(regs,&regs.R30,regs.R8,regs.R5);
		/* 8219837Ch case   28:*/		return 0x82198380;
		  /* 82198380h */ case   29:  		/* addi R11, R11, 2 */
		/* 82198380h case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82198380h case   29:*/		return 0x82198384;
		  /* 82198384h */ case   30:  		/* or R29, R9, R29 */
		/* 82198384h case   30:*/		cpu::op::or<0>(regs,&regs.R29,regs.R9,regs.R29);
		/* 82198384h case   30:*/		return 0x82198388;
		  /* 82198388h */ case   31:  		/* cmplw CR6, R7, R27 */
		/* 82198388h case   31:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R27);
		/* 82198388h case   31:*/		return 0x8219838C;
		  /* 8219838Ch */ case   32:  		/* bc 4, CR6_LT, 8 */
		/* 8219838Ch case   32:*/		if ( !regs.CR[6].lt ) { return 0x82198394;  }
		/* 8219838Ch case   32:*/		return 0x82198390;
		  /* 82198390h */ case   33:  		/* addi R23, R23, -1 */
		/* 82198390h case   33:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0xFFFFFFFF);
		/* 82198390h case   33:*/		return 0x82198394;
	}
	return 0x82198394;
} // Block from 8219830Ch-82198394h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82198394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198394);
		  /* 82198394h */ case    0:  		/* addi R7, R7, 1 */
		/* 82198394h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 82198394h case    0:*/		return 0x82198398;
		  /* 82198398h */ case    1:  		/* addi R6, R6, 2 */
		/* 82198398h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x2);
		/* 82198398h case    1:*/		return 0x8219839C;
		  /* 8219839Ch */ case    2:  		/* cmplw CR6, R7, R26 */
		/* 8219839Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R26);
		/* 8219839Ch case    2:*/		return 0x821983A0;
		  /* 821983A0h */ case    3:  		/* bc 12, CR6_LT, -116 */
		/* 821983A0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8219832C;  }
		/* 821983A0h case    3:*/		return 0x821983A4;
	}
	return 0x821983A4;
} // Block from 82198394h-821983A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821983A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821983A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821983A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821983A4);
		  /* 821983A4h */ case    0:  		/* cmplw CR6, R7, R26 */
		/* 821983A4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R26);
		/* 821983A4h case    0:*/		return 0x821983A8;
		  /* 821983A8h */ case    1:  		/* bc 12, CR6_LT, 72 */
		/* 821983A8h case    1:*/		if ( regs.CR[6].lt ) { return 0x821983F0;  }
		/* 821983A8h case    1:*/		return 0x821983AC;
		  /* 821983ACh */ case    2:  		/* mr R5, R30 */
		/* 821983ACh case    2:*/		regs.R5 = regs.R30;
		/* 821983ACh case    2:*/		return 0x821983B0;
		  /* 821983B0h */ case    3:  		/* mr R4, R31 */
		/* 821983B0h case    3:*/		regs.R4 = regs.R31;
		/* 821983B0h case    3:*/		return 0x821983B4;
		  /* 821983B4h */ case    4:  		/* mr R3, R28 */
		/* 821983B4h case    4:*/		regs.R3 = regs.R28;
		/* 821983B4h case    4:*/		return 0x821983B8;
		  /* 821983B8h */ case    5:  		/* bl 562784 */
		/* 821983B8h case    5:*/		regs.LR = 0x821983BC; return 0x82221A18;
		/* 821983B8h case    5:*/		return 0x821983BC;
		  /* 821983BCh */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821983BCh case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821983BCh case    6:*/		return 0x821983C0;
		  /* 821983C0h */ case    7:  		/* bc 12, CR0_EQ, 48 */
		/* 821983C0h case    7:*/		if ( regs.CR[0].eq ) { return 0x821983F0;  }
		/* 821983C0h case    7:*/		return 0x821983C4;
		  /* 821983C4h */ case    8:  		/* addi R11, R1, 224 */
		/* 821983C4h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xE0);
		/* 821983C4h case    8:*/		return 0x821983C8;
		  /* 821983C8h */ case    9:  		/* addi R10, R1, 208 */
		/* 821983C8h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xD0);
		/* 821983C8h case    9:*/		return 0x821983CC;
		  /* 821983CCh */ case   10:  		/* addi R9, R1, 192 */
		/* 821983CCh case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xC0);
		/* 821983CCh case   10:*/		return 0x821983D0;
		  /* 821983D0h */ case   11:  		/* addi R27, R27, 1 */
		/* 821983D0h case   11:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821983D0h case   11:*/		return 0x821983D4;
		  /* 821983D4h */ case   12:  		/* addi R24, R24, 2 */
		/* 821983D4h case   12:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x2);
		/* 821983D4h case   12:*/		return 0x821983D8;
		  /* 821983D8h */ case   13:  		/* stwx R30, <#[R25 + R11]> */
		/* 821983D8h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R25 + regs.R11 + 0x00000000) );
		/* 821983D8h case   13:*/		return 0x821983DC;
		  /* 821983DCh */ case   14:  		/* cmplw CR6, R27, R26 */
		/* 821983DCh case   14:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R26);
		/* 821983DCh case   14:*/		return 0x821983E0;
		  /* 821983E0h */ case   15:  		/* stwx R31, <#[R25 + R10]> */
		/* 821983E0h case   15:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R25 + regs.R10 + 0x00000000) );
		/* 821983E0h case   15:*/		return 0x821983E4;
		  /* 821983E4h */ case   16:  		/* stwx R29, <#[R25 + R9]> */
		/* 821983E4h case   16:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R25 + regs.R9 + 0x00000000) );
		/* 821983E4h case   16:*/		return 0x821983E8;
		  /* 821983E8h */ case   17:  		/* addi R25, R25, 4 */
		/* 821983E8h case   17:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 821983E8h case   17:*/		return 0x821983EC;
		  /* 821983ECh */ case   18:  		/* bc 12, CR6_LT, -684 */
		/* 821983ECh case   18:*/		if ( regs.CR[6].lt ) { return 0x82198140;  }
		/* 821983ECh case   18:*/		return 0x821983F0;
	}
	return 0x821983F0;
} // Block from 821983A4h-821983F0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821983F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821983F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821983F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821983F0);
		  /* 821983F0h */ case    0:  		/* cmplw CR6, R27, R26 */
		/* 821983F0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R26);
		/* 821983F0h case    0:*/		return 0x821983F4;
		  /* 821983F4h */ case    1:  		/* bc 4, CR6_EQ, 596 */
		/* 821983F4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82198648;  }
		/* 821983F4h case    1:*/		return 0x821983F8;
		  /* 821983F8h */ case    2:  		/* lwz R11, <#[R15 + 8]> */
		/* 821983F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 821983F8h case    2:*/		return 0x821983FC;
		  /* 821983FCh */ case    3:  		/* rlwinm R11, R11, 31, 28, 31 */
		/* 821983FCh case    3:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R11,regs.R11);
		/* 821983FCh case    3:*/		return 0x82198400;
		  /* 82198400h */ case    4:  		/* cmplw CR6, R22, R11 */
		/* 82198400h case    4:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 82198400h case    4:*/		return 0x82198404;
		  /* 82198404h */ case    5:  		/* bc 4, CR6_EQ, 580 */
		/* 82198404h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82198648;  }
		/* 82198404h case    5:*/		return 0x82198408;
		  /* 82198408h */ case    6:  		/* lwz R11, <#[R1 + 120]> */
		/* 82198408h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 82198408h case    6:*/		return 0x8219840C;
		  /* 8219840Ch */ case    7:  		/* lwz R10, <#[R1 + 484]> */
		/* 8219840Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000001E4) );
		/* 8219840Ch case    7:*/		return 0x82198410;
		  /* 82198410h */ case    8:  		/* add R11, R23, R11 */
		/* 82198410h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R23,regs.R11);
		/* 82198410h case    8:*/		return 0x82198414;
		  /* 82198414h */ case    9:  		/* addi R11, R11, -1 */
		/* 82198414h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82198414h case    9:*/		return 0x82198418;
		  /* 82198418h */ case   10:  		/* lwz R10, <#[R10 + 788]> */
		/* 82198418h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000314) );
		/* 82198418h case   10:*/		return 0x8219841C;
		  /* 8219841Ch */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 8219841Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8219841Ch case   11:*/		return 0x82198420;
		  /* 82198420h */ case   12:  		/* bc 12, CR6_GT, 552 */
		/* 82198420h case   12:*/		if ( regs.CR[6].gt ) { return 0x82198648;  }
		/* 82198420h case   12:*/		return 0x82198424;
		  /* 82198424h */ case   13:  		/* lwz R25, <#[R1 + 484]> */
		/* 82198424h case   13:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000001E4) );
		/* 82198424h case   13:*/		return 0x82198428;
		  /* 82198428h */ case   14:  		/* cmplwi CR6, R26, 0 */
		/* 82198428h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82198428h case   14:*/		return 0x8219842C;
		  /* 8219842Ch */ case   15:  		/* bc 12, CR6_EQ, 5012 */
		/* 8219842Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x821997C0;  }
		/* 8219842Ch case   15:*/		return 0x82198430;
		  /* 82198430h */ case   16:  		/* li R27, 0 */
		/* 82198430h case   16:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82198430h case   16:*/		return 0x82198434;
		  /* 82198434h */ case   17:  		/* li R29, 0 */
		/* 82198434h case   17:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82198434h case   17:*/		return 0x82198438;
		  /* 82198438h */ case   18:  		/* srw R11, R21, R27 */
		/* 82198438h case   18:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R21,regs.R27);
		/* 82198438h case   18:*/		return 0x8219843C;
		  /* 8219843Ch */ case   19:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 8219843Ch case   19:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8219843Ch case   19:*/		return 0x82198440;
		  /* 82198440h */ case   20:  		/* addi R11, R11, 11 */
		/* 82198440h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB);
		/* 82198440h case   20:*/		return 0x82198444;
		  /* 82198444h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82198444h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82198444h case   21:*/		return 0x82198448;
		  /* 82198448h */ case   22:  		/* lwzx R11, <#[R11 + R15]> */
		/* 82198448h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R15 + 0x00000000) );
		/* 82198448h case   22:*/		return 0x8219844C;
		  /* 8219844Ch */ case   23:  		/* lwz R31, <#[R11 + 12]> */
		/* 8219844Ch case   23:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219844Ch case   23:*/		return 0x82198450;
		  /* 82198450h */ case   24:  		/* lwz R11, <#[R31 + 8]> */
		/* 82198450h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82198450h case   24:*/		return 0x82198454;
		  /* 82198454h */ case   25:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 82198454h case   25:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82198454h case   25:*/		return 0x82198458;
		  /* 82198458h */ case   26:  		/* bc 4, CR0_EQ, 4952 */
		/* 82198458h case   26:*/		if ( !regs.CR[0].eq ) { return 0x821997B0;  }
		/* 82198458h case   26:*/		return 0x8219845C;
		  /* 8219845Ch */ case   27:  		/* addi R11, R1, 208 */
		/* 8219845Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xD0);
		/* 8219845Ch case   27:*/		return 0x82198460;
		  /* 82198460h */ case   28:  		/* addi R10, R1, 224 */
		/* 82198460h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xE0);
		/* 82198460h case   28:*/		return 0x82198464;
		  /* 82198464h */ case   29:  		/* mr R3, R31 */
		/* 82198464h case   29:*/		regs.R3 = regs.R31;
		/* 82198464h case   29:*/		return 0x82198468;
		  /* 82198468h */ case   30:  		/* lwzx R28, <#[R29 + R11]> */
		/* 82198468h case   30:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82198468h case   30:*/		return 0x8219846C;
		  /* 8219846Ch */ case   31:  		/* lwzx R5, <#[R29 + R10]> */
		/* 8219846Ch case   31:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + regs.R10 + 0x00000000) );
		/* 8219846Ch case   31:*/		return 0x82198470;
		  /* 82198470h */ case   32:  		/* mr R4, R28 */
		/* 82198470h case   32:*/		regs.R4 = regs.R28;
		/* 82198470h case   32:*/		return 0x82198474;
		  /* 82198474h */ case   33:  		/* bl 562796 */
		/* 82198474h case   33:*/		regs.LR = 0x82198478; return 0x82221AE0;
		/* 82198474h case   33:*/		return 0x82198478;
		  /* 82198478h */ case   34:  		/* li R30, 0 */
		/* 82198478h case   34:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82198478h case   34:*/		return 0x8219847C;
		  /* 8219847Ch */ case   35:  		/* cmplwi CR6, R17, 0 */
		/* 8219847Ch case   35:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 8219847Ch case   35:*/		return 0x82198480;
		  /* 82198480h */ case   36:  		/* bc 12, CR6_EQ, 52 */
		/* 82198480h case   36:*/		if ( regs.CR[6].eq ) { return 0x821984B4;  }
		/* 82198480h case   36:*/		return 0x82198484;
		  /* 82198484h */ case   37:  		/* li R6, 0 */
		/* 82198484h case   37:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82198484h case   37:*/		return 0x82198488;
		  /* 82198488h */ case   38:  		/* lwz R4, <#[R17 + 12]> */
		/* 82198488h case   38:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x0000000C) );
		/* 82198488h case   38:*/		return 0x8219848C;
		  /* 8219848Ch */ case   39:  		/* mr R5, R31 */
		/* 8219848Ch case   39:*/		regs.R5 = regs.R31;
		/* 8219848Ch case   39:*/		return 0x82198490;
		  /* 82198490h */ case   40:  		/* mr R3, R25 */
		/* 82198490h case   40:*/		regs.R3 = regs.R25;
		/* 82198490h case   40:*/		return 0x82198494;
		  /* 82198494h */ case   41:  		/* bl 612268 */
		/* 82198494h case   41:*/		regs.LR = 0x82198498; return 0x8222DC40;
		/* 82198494h case   41:*/		return 0x82198498;
		  /* 82198498h */ case   42:  		/* cmplwi CR6, R18, 0 */
		/* 82198498h case   42:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 82198498h case   42:*/		return 0x8219849C;
		  /* 8219849Ch */ case   43:  		/* bc 12, CR6_EQ, 76 */
		/* 8219849Ch case   43:*/		if ( regs.CR[6].eq ) { return 0x821984E8;  }
		/* 8219849Ch case   43:*/		return 0x821984A0;
		  /* 821984A0h */ case   44:  		/* mr R5, R25 */
		/* 821984A0h case   44:*/		regs.R5 = regs.R25;
		/* 821984A0h case   44:*/		return 0x821984A4;
		  /* 821984A4h */ case   45:  		/* lwz R4, <#[R17 + 12]> */
		/* 821984A4h case   45:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R17 + 0x0000000C) );
		/* 821984A4h case   45:*/		return 0x821984A8;
		  /* 821984A8h */ case   46:  		/* mr R3, R31 */
		/* 821984A8h case   46:*/		regs.R3 = regs.R31;
		/* 821984A8h case   46:*/		return 0x821984AC;
		  /* 821984ACh */ case   47:  		/* bl -131716 */
		/* 821984ACh case   47:*/		regs.LR = 0x821984B0; return 0x82178228;
		/* 821984ACh case   47:*/		return 0x821984B0;
		  /* 821984B0h */ case   48:  		/* mr R30, R3 */
		/* 821984B0h case   48:*/		regs.R30 = regs.R3;
		/* 821984B0h case   48:*/		return 0x821984B4;
	}
	return 0x821984B4;
} // Block from 821983F0h-821984B4h (49 instructions)

//////////////////////////////////////////////////////
// Block at 821984B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821984B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821984B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821984B4);
		  /* 821984B4h */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 821984B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 821984B4h case    0:*/		return 0x821984B8;
		  /* 821984B8h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 821984B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821984E8;  }
		/* 821984B8h case    1:*/		return 0x821984BC;
		  /* 821984BCh */ case    2:  		/* li R6, 0 */
		/* 821984BCh case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821984BCh case    2:*/		return 0x821984C0;
		  /* 821984C0h */ case    3:  		/* mr R5, R31 */
		/* 821984C0h case    3:*/		regs.R5 = regs.R31;
		/* 821984C0h case    3:*/		return 0x821984C4;
		  /* 821984C4h */ case    4:  		/* mr R4, R18 */
		/* 821984C4h case    4:*/		regs.R4 = regs.R18;
		/* 821984C4h case    4:*/		return 0x821984C8;
		  /* 821984C8h */ case    5:  		/* mr R3, R25 */
		/* 821984C8h case    5:*/		regs.R3 = regs.R25;
		/* 821984C8h case    5:*/		return 0x821984CC;
		  /* 821984CCh */ case    6:  		/* bl 612212 */
		/* 821984CCh case    6:*/		regs.LR = 0x821984D0; return 0x8222DC40;
		/* 821984CCh case    6:*/		return 0x821984D0;
		  /* 821984D0h */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 821984D0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821984D0h case    7:*/		return 0x821984D4;
		  /* 821984D4h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 821984D4h case    8:*/		if ( regs.CR[6].eq ) { return 0x821984E8;  }
		/* 821984D4h case    8:*/		return 0x821984D8;
		  /* 821984D8h */ case    9:  		/* mr R5, R25 */
		/* 821984D8h case    9:*/		regs.R5 = regs.R25;
		/* 821984D8h case    9:*/		return 0x821984DC;
		  /* 821984DCh */ case   10:  		/* mr R4, R30 */
		/* 821984DCh case   10:*/		regs.R4 = regs.R30;
		/* 821984DCh case   10:*/		return 0x821984E0;
		  /* 821984E0h */ case   11:  		/* mr R3, R31 */
		/* 821984E0h case   11:*/		regs.R3 = regs.R31;
		/* 821984E0h case   11:*/		return 0x821984E4;
		  /* 821984E4h */ case   12:  		/* bl -130004 */
		/* 821984E4h case   12:*/		regs.LR = 0x821984E8; return 0x82178910;
		/* 821984E4h case   12:*/		return 0x821984E8;
	}
	return 0x821984E8;
} // Block from 821984B4h-821984E8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821984E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821984E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821984E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821984E8);
		  /* 821984E8h */ case    0:  		/* lwz R30, <#[R14]> */
		/* 821984E8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R14 + 0x00000000) );
		/* 821984E8h case    0:*/		return 0x821984EC;
		  /* 821984ECh */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 821984ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821984ECh case    1:*/		return 0x821984F0;
		  /* 821984F0h */ case    2:  		/* bc 12, CR6_EQ, 4564 */
		/* 821984F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x821996C4;  }
		/* 821984F0h case    2:*/		return 0x821984F4;
		  /* 821984F4h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 821984F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821984F4h case    3:*/		return 0x821984F8;
		  /* 821984F8h */ case    4:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821984F8h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821984F8h case    4:*/		return 0x821984FC;
		  /* 821984FCh */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 821984FCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x8219850C;  }
		/* 821984FCh case    5:*/		return 0x82198500;
		  /* 82198500h */ case    6:  		/* mr R4, R30 */
		/* 82198500h case    6:*/		regs.R4 = regs.R30;
		/* 82198500h case    6:*/		return 0x82198504;
		  /* 82198504h */ case    7:  		/* mr R3, R31 */
		/* 82198504h case    7:*/		regs.R3 = regs.R31;
		/* 82198504h case    7:*/		return 0x82198508;
		  /* 82198508h */ case    8:  		/* bl -131904 */
		/* 82198508h case    8:*/		regs.LR = 0x8219850C; return 0x821781C8;
		/* 82198508h case    8:*/		return 0x8219850C;
	}
	return 0x8219850C;
} // Block from 821984E8h-8219850Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219850Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219850C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219850C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219850C);
		  /* 8219850Ch */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 8219850Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 8219850Ch case    0:*/		return 0x82198510;
		  /* 82198510h */ case    1:  		/* b -36 */
		/* 82198510h case    1:*/		return 0x821984EC;
		/* 82198510h case    1:*/		return 0x82198514;
	}
	return 0x82198514;
} // Block from 8219850Ch-82198514h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198514);
		  /* 82198514h */ case    0:  		/* cmplwi CR6, R9, 125 */
		/* 82198514h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000007D);
		/* 82198514h case    0:*/		return 0x82198518;
		  /* 82198518h */ case    1:  		/* bc 4, CR6_EQ, 304 */
		/* 82198518h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82198648;  }
		/* 82198518h case    1:*/		return 0x8219851C;
		  /* 8219851Ch */ case    2:  		/* lwz R11, <#[R16]> */
		/* 8219851Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 8219851Ch case    2:*/		return 0x82198520;
		  /* 82198520h */ case    3:  		/* mr R3, R15 */
		/* 82198520h case    3:*/		regs.R3 = regs.R15;
		/* 82198520h case    3:*/		return 0x82198524;
		  /* 82198524h */ case    4:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 82198524h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 82198524h case    4:*/		return 0x82198528;
		  /* 82198528h */ case    5:  		/* rlwinm R4, R11, 27, 30, 31 */
		/* 82198528h case    5:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R4,regs.R11);
		/* 82198528h case    5:*/		return 0x8219852C;
		  /* 8219852Ch */ case    6:  		/* bl 561500 */
		/* 8219852Ch case    6:*/		regs.LR = 0x82198530; return 0x82221688;
		/* 8219852Ch case    6:*/		return 0x82198530;
		  /* 82198530h */ case    7:  		/* fmr FR31, FR1 */
		/* 82198530h case    7:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82198530h case    7:*/		return 0x82198534;
		  /* 82198534h */ case    8:  		/* fcmpu CR6, FR1, FR30 */
		/* 82198534h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR30);
		/* 82198534h case    8:*/		return 0x82198538;
		  /* 82198538h */ case    9:  		/* bc 4, CR6_EQ, 144 */
		/* 82198538h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821985C8;  }
		/* 82198538h case    9:*/		return 0x8219853C;
		  /* 8219853Ch */ case   10:  		/* lwz R31, <#[R14 + 4]> */
		/* 8219853Ch case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R14 + 0x00000004) );
		/* 8219853Ch case   10:*/		return 0x82198540;
		  /* 82198540h */ case   11:  		/* cmplwi CR6, R31, 0 */
		/* 82198540h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82198540h case   11:*/		return 0x82198544;
		  /* 82198544h */ case   12:  		/* bc 12, CR6_EQ, 132 */
		/* 82198544h case   12:*/		if ( regs.CR[6].eq ) { return 0x821985C8;  }
		/* 82198544h case   12:*/		return 0x82198548;
		  /* 82198548h */ case   13:  		/* lwz R3, <#[R31 + 16]> */
		/* 82198548h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82198548h case   13:*/		return 0x8219854C;
		  /* 8219854Ch */ case   14:  		/* cmplwi CR6, R3, 0 */
		/* 8219854Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8219854Ch case   14:*/		return 0x82198550;
		  /* 82198550h */ case   15:  		/* bc 12, CR6_EQ, 108 */
		/* 82198550h case   15:*/		if ( regs.CR[6].eq ) { return 0x821985BC;  }
		/* 82198550h case   15:*/		return 0x82198554;
		  /* 82198554h */ case   16:  		/* lwz R11, <#[R31]> */
		/* 82198554h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82198554h case   16:*/		return 0x82198558;
		  /* 82198558h */ case   17:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 82198558h case   17:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 82198558h case   17:*/		return 0x8219855C;
		  /* 8219855Ch */ case   18:  		/* bc 12, CR0_EQ, 96 */
		/* 8219855Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x821985BC;  }
		/* 8219855Ch case   18:*/		return 0x82198560;
		  /* 82198560h */ case   19:  		/* nor R10, R11, R11 */
		/* 82198560h case   19:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 82198560h case   19:*/		return 0x82198564;
		  /* 82198564h */ case   20:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 82198564h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82198564h case   20:*/		return 0x82198568;
		  /* 82198568h */ case   21:  		/* bc 12, CR0_EQ, 92 */
		/* 82198568h case   21:*/		if ( regs.CR[0].eq ) { return 0x821985C4;  }
		/* 82198568h case   21:*/		return 0x8219856C;
		  /* 8219856Ch */ case   22:  		/* rlwinm R9, R11, 0, 30, 30 */
		/* 8219856Ch case   22:*/		cpu::op::rlwinm<0,0,30,30>(regs,&regs.R9,regs.R11);
		/* 8219856Ch case   22:*/		return 0x82198570;
		  /* 82198570h */ case   23:  		/* li R10, 4 */
		/* 82198570h case   23:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82198570h case   23:*/		return 0x82198574;
		  /* 82198574h */ case   24:  		/* addic R9, R9, -1 */
		/* 82198574h case   24:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82198574h case   24:*/		return 0x82198578;
		  /* 82198578h */ case   25:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82198578h case   25:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82198578h case   25:*/		return 0x8219857C;
		  /* 8219857Ch */ case   26:  		/* subfe R9, R9, R9 */
		/* 8219857Ch case   26:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8219857Ch case   26:*/		return 0x82198580;
		  /* 82198580h */ case   27:  		/* and R10, R9, R10 */
		/* 82198580h case   27:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82198580h case   27:*/		return 0x82198584;
		  /* 82198584h */ case   28:  		/* and R9, R10, R11 */
		/* 82198584h case   28:*/		cpu::op::and<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 82198584h case   28:*/		return 0x82198588;
		  /* 82198588h */ case   29:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 82198588h case   29:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 82198588h case   29:*/		return 0x8219858C;
		  /* 8219858Ch */ case   30:  		/* bc 12, CR0_EQ, 12 */
		/* 8219858Ch case   30:*/		if ( regs.CR[0].eq ) { return 0x82198598;  }
		/* 8219858Ch case   30:*/		return 0x82198590;
		  /* 82198590h */ case   31:  		/* addi R10, R10, -4 */
		/* 82198590h case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 82198590h case   31:*/		return 0x82198594;
		  /* 82198594h */ case   32:  		/* addi R11, R11, -4 */
		/* 82198594h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82198594h case   32:*/		return 0x82198598;
	}
	return 0x82198598;
} // Block from 82198514h-82198598h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82198598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198598);
		  /* 82198598h */ case    0:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 82198598h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 82198598h case    0:*/		return 0x8219859C;
		  /* 8219859Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219859Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821985AC;  }
		/* 8219859Ch case    1:*/		return 0x821985A0;
		  /* 821985A0h */ case    2:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 821985A0h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 821985A0h case    2:*/		return 0x821985A4;
		  /* 821985A4h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 821985A4h case    3:*/		if ( regs.CR[0].eq ) { return 0x821985AC;  }
		/* 821985A4h case    3:*/		return 0x821985A8;
		  /* 821985A8h */ case    4:  		/* addi R11, R11, -2 */
		/* 821985A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 821985A8h case    4:*/		return 0x821985AC;
	}
	return 0x821985AC;
} // Block from 82198598h-821985ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821985ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821985AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821985AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821985AC);
		  /* 821985ACh */ case    0:  		/* or R4, R10, R11 */
		/* 821985ACh case    0:*/		cpu::op::or<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 821985ACh case    0:*/		return 0x821985B0;
		  /* 821985B0h */ case    1:  		/* bl -8992 */
		/* 821985B0h case    1:*/		regs.LR = 0x821985B4; return 0x82196290;
		/* 821985B0h case    1:*/		return 0x821985B4;
		  /* 821985B4h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821985B4h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821985B4h case    2:*/		return 0x821985B8;
		  /* 821985B8h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 821985B8h case    3:*/		if ( regs.CR[0].eq ) { return 0x821985C4;  }
		/* 821985B8h case    3:*/		return 0x821985BC;
	}
	return 0x821985BC;
} // Block from 821985ACh-821985BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821985BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821985BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821985BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821985BC);
		  /* 821985BCh */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 821985BCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 821985BCh case    0:*/		return 0x821985C0;
		  /* 821985C0h */ case    1:  		/* b -128 */
		/* 821985C0h case    1:*/		return 0x82198540;
		/* 821985C0h case    1:*/		return 0x821985C4;
	}
	return 0x821985C4;
} // Block from 821985BCh-821985C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821985C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821985C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821985C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821985C4);
		  /* 821985C4h */ case    0:  		/* fmr FR31, FR27 */
		/* 821985C4h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR27);
		/* 821985C4h case    0:*/		return 0x821985C8;
	}
	return 0x821985C8;
} // Block from 821985C4h-821985C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821985C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821985C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821985C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821985C8);
		  /* 821985C8h */ case    0:  		/* fcmpu CR6, FR31, FR29 */
		/* 821985C8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR29);
		/* 821985C8h case    0:*/		return 0x821985CC;
		  /* 821985CCh */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 821985CCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821985F4;  }
		/* 821985CCh case    1:*/		return 0x821985D0;
		  /* 821985D0h */ case    2:  		/* lwz R11, <#[R21 + 48]> */
		/* 821985D0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000030) );
		/* 821985D0h case    2:*/		return 0x821985D4;
		  /* 821985D4h */ case    3:  		/* lis R10, -1 */
		/* 821985D4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 821985D4h case    3:*/		return 0x821985D8;
		  /* 821985D8h */ case    4:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821985D8h case    4:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821985D8h case    4:*/		return 0x821985DC;
		  /* 821985DCh */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 821985DCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821985DCh case    5:*/		return 0x821985E0;
		  /* 821985E0h */ case    6:  		/* bc 12, CR6_EQ, 104 */
		/* 821985E0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82198648;  }
		/* 821985E0h case    6:*/		return 0x821985E4;
		  /* 821985E4h */ case    7:  		/* fcmpu CR6, FR31, FR26 */
		/* 821985E4h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR26);
		/* 821985E4h case    7:*/		return 0x821985E8;
		  /* 821985E8h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 821985E8h case    8:*/		if ( regs.CR[6].eq ) { return 0x821985F4;  }
		/* 821985E8h case    8:*/		return 0x821985EC;
		  /* 821985ECh */ case    9:  		/* fcmpu CR6, FR31, FR30 */
		/* 821985ECh case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR30);
		/* 821985ECh case    9:*/		return 0x821985F0;
		  /* 821985F0h */ case   10:  		/* bc 4, CR6_EQ, 88 */
		/* 821985F0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82198648;  }
		/* 821985F0h case   10:*/		return 0x821985F4;
	}
	return 0x821985F4;
} // Block from 821985C8h-821985F4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821985F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821985F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821985F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821985F4);
		  /* 821985F4h */ case    0:  		/* lwz R11, <#[R16]> */
		/* 821985F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 821985F4h case    0:*/		return 0x821985F8;
		  /* 821985F8h */ case    1:  		/* mr R30, R19 */
		/* 821985F8h case    1:*/		regs.R30 = regs.R19;
		/* 821985F8h case    1:*/		return 0x821985FC;
		  /* 821985FCh */ case    2:  		/* rlwinm R31, R11, 7, 29, 31 */
		/* 821985FCh case    2:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R31,regs.R11);
		/* 821985FCh case    2:*/		return 0x82198600;
		  /* 82198600h */ case    3:  		/* cmplwi CR6, R31, 1 */
		/* 82198600h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000001);
		/* 82198600h case    3:*/		return 0x82198604;
		  /* 82198604h */ case    4:  		/* bc 4, CR6_GT, 60 */
		/* 82198604h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82198640;  }
		/* 82198604h case    4:*/		return 0x82198608;
		  /* 82198608h */ case    5:  		/* li R29, 2 */
		/* 82198608h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x2);
		/* 82198608h case    5:*/		return 0x8219860C;
		  /* 8219860Ch */ case    6:  		/* lwz R11, <#[R16]> */
		/* 8219860Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 8219860Ch case    6:*/		return 0x82198610;
		  /* 82198610h */ case    7:  		/* mr R3, R15 */
		/* 82198610h case    7:*/		regs.R3 = regs.R15;
		/* 82198610h case    7:*/		return 0x82198614;
		  /* 82198614h */ case    8:  		/* rlwinm R10, R11, 27, 24, 31 */
		/* 82198614h case    8:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R11);
		/* 82198614h case    8:*/		return 0x82198618;
		  /* 82198618h */ case    9:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 82198618h case    9:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 82198618h case    9:*/		return 0x8219861C;
		  /* 8219861Ch */ case   10:  		/* srw R11, R10, R29 */
		/* 8219861Ch case   10:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R29);
		/* 8219861Ch case   10:*/		return 0x82198620;
		  /* 82198620h */ case   11:  		/* rlwinm R4, R11, 0, 30, 31 */
		/* 82198620h case   11:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R11);
		/* 82198620h case   11:*/		return 0x82198624;
		  /* 82198624h */ case   12:  		/* bl 561252 */
		/* 82198624h case   12:*/		regs.LR = 0x82198628; return 0x82221688;
		/* 82198624h case   12:*/		return 0x82198628;
		  /* 82198628h */ case   13:  		/* fcmpu CR6, FR1, FR31 */
		/* 82198628h case   13:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 82198628h case   13:*/		return 0x8219862C;
		  /* 8219862Ch */ case   14:  		/* bc 4, CR6_EQ, 20 */
		/* 8219862Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x82198640;  }
		/* 8219862Ch case   14:*/		return 0x82198630;
		  /* 82198630h */ case   15:  		/* addi R30, R30, 1 */
		/* 82198630h case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82198630h case   15:*/		return 0x82198634;
		  /* 82198634h */ case   16:  		/* addi R29, R29, 2 */
		/* 82198634h case   16:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x2);
		/* 82198634h case   16:*/		return 0x82198638;
		  /* 82198638h */ case   17:  		/* cmplw CR6, R30, R31 */
		/* 82198638h case   17:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R31);
		/* 82198638h case   17:*/		return 0x8219863C;
		  /* 8219863Ch */ case   18:  		/* bc 12, CR6_LT, -48 */
		/* 8219863Ch case   18:*/		if ( regs.CR[6].lt ) { return 0x8219860C;  }
		/* 8219863Ch case   18:*/		return 0x82198640;
	}
	return 0x82198640;
} // Block from 821985F4h-82198640h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82198640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198640);
		  /* 82198640h */ case    0:  		/* cmplw CR6, R30, R31 */
		/* 82198640h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R31);
		/* 82198640h case    0:*/		return 0x82198644;
		  /* 82198644h */ case    1:  		/* bc 12, CR6_EQ, 4564 */
		/* 82198644h case    1:*/		if ( regs.CR[6].eq ) { return 0x82199818;  }
		/* 82198644h case    1:*/		return 0x82198648;
	}
	return 0x82198648;
} // Block from 82198640h-82198648h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198648);
		  /* 82198648h */ case    0:  		/* lwz R31, <#[R14 + 8]> */
		/* 82198648h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R14 + 0x00000008) );
		/* 82198648h case    0:*/		return 0x8219864C;
		  /* 8219864Ch */ case    1:  		/* li R19, 1 */
		/* 8219864Ch case    1:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 8219864Ch case    1:*/		return 0x82198650;
		  /* 82198650h */ case    2:  		/* lwz R21, <#[R1 + 484]> */
		/* 82198650h case    2:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x000001E4) );
		/* 82198650h case    2:*/		return 0x82198654;
		  /* 82198654h */ case    3:  		/* li R18, 0 */
		/* 82198654h case    3:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 82198654h case    3:*/		return 0x82198658;
		  /* 82198658h */ case    4:  		/* lwz R20, <#[R1 + 100]> */
		/* 82198658h case    4:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x00000064) );
		/* 82198658h case    4:*/		return 0x8219865C;
		  /* 8219865Ch */ case    5:  		/* rlwinm. R11, R31, 27, 31, 31 */
		/* 8219865Ch case    5:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R31);
		/* 8219865Ch case    5:*/		return 0x82198660;
		  /* 82198660h */ case    6:  		/* bc 4, CR0_EQ, -3864 */
		/* 82198660h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198660h case    6:*/		return 0x82198664;
		  /* 82198664h */ case    7:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82198664h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82198664h case    7:*/		return 0x82198668;
		  /* 82198668h */ case    8:  		/* bc 4, CR0_EQ, -3872 */
		/* 82198668h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198668h case    8:*/		return 0x8219866C;
		  /* 8219866Ch */ case    9:  		/* rlwinm. R11, R31, 7, 31, 31 */
		/* 8219866Ch case    9:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R31);
		/* 8219866Ch case    9:*/		return 0x82198670;
		  /* 82198670h */ case   10:  		/* bc 4, CR0_EQ, -3880 */
		/* 82198670h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198670h case   10:*/		return 0x82198674;
		  /* 82198674h */ case   11:  		/* lwz R11, <#[R14 + 16]> */
		/* 82198674h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000010) );
		/* 82198674h case   11:*/		return 0x82198678;
		  /* 82198678h */ case   12:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 82198678h case   12:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 82198678h case   12:*/		return 0x8219867C;
		  /* 8219867Ch */ case   13:  		/* bc 4, CR0_EQ, -3892 */
		/* 8219867Ch case   13:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 8219867Ch case   13:*/		return 0x82198680;
		  /* 82198680h */ case   14:  		/* lwz R11, <#[R15 + 8]> */
		/* 82198680h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 82198680h case   14:*/		return 0x82198684;
		  /* 82198684h */ case   15:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82198684h case   15:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82198684h case   15:*/		return 0x82198688;
		  /* 82198688h */ case   16:  		/* cmplwi CR6, R11, 125 */
		/* 82198688h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82198688h case   16:*/		return 0x8219868C;
		  /* 8219868Ch */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 8219868Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x8219869C;  }
		/* 8219868Ch case   17:*/		return 0x82198690;
		  /* 82198690h */ case   18:  		/* cmplwi CR6, R11, 124 */
		/* 82198690h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82198690h case   18:*/		return 0x82198694;
		  /* 82198694h */ case   19:  		/* mr R11, R18 */
		/* 82198694h case   19:*/		regs.R11 = regs.R18;
		/* 82198694h case   19:*/		return 0x82198698;
		  /* 82198698h */ case   20:  		/* bc 4, CR6_EQ, 8 */
		/* 82198698h case   20:*/		if ( !regs.CR[6].eq ) { return 0x821986A0;  }
		/* 82198698h case   20:*/		return 0x8219869C;
	}
	return 0x8219869C;
} // Block from 82198648h-8219869Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8219869Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219869C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219869C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219869C);
		  /* 8219869Ch */ case    0:  		/* mr R11, R19 */
		/* 8219869Ch case    0:*/		regs.R11 = regs.R19;
		/* 8219869Ch case    0:*/		return 0x821986A0;
	}
	return 0x821986A0;
} // Block from 8219869Ch-821986A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821986A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821986A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821986A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821986A0);
		  /* 821986A0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821986A0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821986A0h case    0:*/		return 0x821986A4;
		  /* 821986A4h */ case    1:  		/* bc 4, CR0_EQ, -3932 */
		/* 821986A4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 821986A4h case    1:*/		return 0x821986A8;
		  /* 821986A8h */ case    2:  		/* lwz R11, <#[R16]> */
		/* 821986A8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 821986A8h case    2:*/		return 0x821986AC;
		  /* 821986ACh */ case    3:  		/* addi R25, R14, 4 */
		/* 821986ACh case    3:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R14,0x4);
		/* 821986ACh case    3:*/		return 0x821986B0;
		  /* 821986B0h */ case    4:  		/* rlwinm R27, R11, 27, 24, 31 */
		/* 821986B0h case    4:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R27,regs.R11);
		/* 821986B0h case    4:*/		return 0x821986B4;
		  /* 821986B4h */ case    5:  		/* rlwinm R26, R11, 0, 27, 31 */
		/* 821986B4h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R26,regs.R11);
		/* 821986B4h case    5:*/		return 0x821986B8;
		  /* 821986B8h */ case    6:  		/* lwz R28, <#[R25]> */
		/* 821986B8h case    6:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R25 + 0x00000000) );
		/* 821986B8h case    6:*/		return 0x821986BC;
		  /* 821986BCh */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 821986BCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821986BCh case    7:*/		return 0x821986C0;
		  /* 821986C0h */ case    8:  		/* bc 12, CR6_EQ, 1380 */
		/* 821986C0h case    8:*/		if ( regs.CR[6].eq ) { return 0x82198C24;  }
		/* 821986C0h case    8:*/		return 0x821986C4;
		  /* 821986C4h */ case    9:  		/* lwz R29, <#[R28 + 16]> */
		/* 821986C4h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x00000010) );
		/* 821986C4h case    9:*/		return 0x821986C8;
		  /* 821986C8h */ case   10:  		/* cmplwi CR6, R29, 0 */
		/* 821986C8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821986C8h case   10:*/		return 0x821986CC;
		  /* 821986CCh */ case   11:  		/* bc 12, CR6_EQ, 1348 */
		/* 821986CCh case   11:*/		if ( regs.CR[6].eq ) { return 0x82198C10;  }
		/* 821986CCh case   11:*/		return 0x821986D0;
		  /* 821986D0h */ case   12:  		/* lwz R30, <#[R28]> */
		/* 821986D0h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 821986D0h case   12:*/		return 0x821986D4;
		  /* 821986D4h */ case   13:  		/* rlwinm. R11, R30, 0, 4, 6 */
		/* 821986D4h case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R30);
		/* 821986D4h case   13:*/		return 0x821986D8;
		  /* 821986D8h */ case   14:  		/* bc 4, CR0_EQ, 840 */
		/* 821986D8h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82198A20;  }
		/* 821986D8h case   14:*/		return 0x821986DC;
		  /* 821986DCh */ case   15:  		/* mr R3, R15 */
		/* 821986DCh case   15:*/		regs.R3 = regs.R15;
		/* 821986DCh case   15:*/		return 0x821986E0;
		  /* 821986E0h */ case   16:  		/* bl -27856 */
		/* 821986E0h case   16:*/		regs.LR = 0x821986E4; return 0x82191A10;
		/* 821986E0h case   16:*/		return 0x821986E4;
		  /* 821986E4h */ case   17:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821986E4h case   17:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821986E4h case   17:*/		return 0x821986E8;
		  /* 821986E8h */ case   18:  		/* bc 12, CR0_EQ, 1320 */
		/* 821986E8h case   18:*/		if ( regs.CR[0].eq ) { return 0x82198C10;  }
		/* 821986E8h case   18:*/		return 0x821986EC;
		  /* 821986ECh */ case   19:  		/* lwz R11, <#[R28 + 12]> */
		/* 821986ECh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 821986ECh case   19:*/		return 0x821986F0;
		  /* 821986F0h */ case   20:  		/* addi R11, R11, 4 */
		/* 821986F0h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821986F0h case   20:*/		return 0x821986F4;
		  /* 821986F4h */ case   21:  		/* lwz R10, <#[R11]> */
		/* 821986F4h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821986F4h case   21:*/		return 0x821986F8;
		  /* 821986F8h */ case   22:  		/* b 772 */
		/* 821986F8h case   22:*/		return 0x821989FC;
		/* 821986F8h case   22:*/		return 0x821986FC;
	}
	return 0x821986FC;
} // Block from 821986A0h-821986FCh (23 instructions)

//////////////////////////////////////////////////////
// Block at 821986FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821986FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821986FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821986FC);
		  /* 821986FCh */ case    0:  		/* lwz R11, <#[R16]> */
		/* 821986FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 821986FCh case    0:*/		return 0x82198700;
		  /* 82198700h */ case    1:  		/* rlwinm R25, R11, 0, 27, 31 */
		/* 82198700h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R25,regs.R11);
		/* 82198700h case    1:*/		return 0x82198704;
		  /* 82198704h */ case    2:  		/* rlwinm. R11, R25, 0, 28, 28 */
		/* 82198704h case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R25);
		/* 82198704h case    2:*/		return 0x82198708;
		  /* 82198708h */ case    3:  		/* bc 4, CR0_EQ, -4032 */
		/* 82198708h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198708h case    3:*/		return 0x8219870C;
		  /* 8219870Ch */ case    4:  		/* rlwinm. R11, R31, 27, 31, 31 */
		/* 8219870Ch case    4:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R31);
		/* 8219870Ch case    4:*/		return 0x82198710;
		  /* 82198710h */ case    5:  		/* bc 12, CR0_EQ, -172 */
		/* 82198710h case    5:*/		if ( regs.CR[0].eq ) { return 0x82198664;  }
		/* 82198710h case    5:*/		return 0x82198714;
		  /* 82198714h */ case    6:  		/* rlwinm. R11, R10, 7, 31, 31 */
		/* 82198714h case    6:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R10);
		/* 82198714h case    6:*/		return 0x82198718;
		  /* 82198718h */ case    7:  		/* bc 4, CR0_EQ, -4048 */
		/* 82198718h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198718h case    7:*/		return 0x8219871C;
		  /* 8219871Ch */ case    8:  		/* rlwinm. R11, R25, 0, 27, 30 */
		/* 8219871Ch case    8:*/		cpu::op::rlwinm<1,0,27,30>(regs,&regs.R11,regs.R25);
		/* 8219871Ch case    8:*/		return 0x82198720;
		  /* 82198720h */ case    9:  		/* bc 4, CR0_EQ, -4056 */
		/* 82198720h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198720h case    9:*/		return 0x82198724;
		  /* 82198724h */ case   10:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82198724h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82198724h case   10:*/		return 0x82198728;
		  /* 82198728h */ case   11:  		/* bc 12, CR0_EQ, 52 */
		/* 82198728h case   11:*/		if ( regs.CR[0].eq ) { return 0x8219875C;  }
		/* 82198728h case   11:*/		return 0x8219872C;
		  /* 8219872Ch */ case   12:  		/* rlwinm. R11, R25, 0, 30, 30 */
		/* 8219872Ch case   12:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R25);
		/* 8219872Ch case   12:*/		return 0x82198730;
		  /* 82198730h */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 82198730h case   13:*/		if ( regs.CR[0].eq ) { return 0x8219873C;  }
		/* 82198730h case   13:*/		return 0x82198734;
		  /* 82198734h */ case   14:  		/* mr R11, R18 */
		/* 82198734h case   14:*/		regs.R11 = regs.R18;
		/* 82198734h case   14:*/		return 0x82198738;
		  /* 82198738h */ case   15:  		/* b 12 */
		/* 82198738h case   15:*/		return 0x82198744;
		/* 82198738h case   15:*/		return 0x8219873C;
	}
	return 0x8219873C;
} // Block from 821986FCh-8219873Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219873Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219873C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219873C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219873C);
		  /* 8219873Ch */ case    0:  		/* nor R11, R25, R25 */
		/* 8219873Ch case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R25,regs.R25);
		/* 8219873Ch case    0:*/		return 0x82198740;
		  /* 82198740h */ case    1:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 82198740h case    1:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82198740h case    1:*/		return 0x82198744;
	}
	return 0x82198744;
} // Block from 8219873Ch-82198744h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198744);
		  /* 82198744h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82198744h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82198744h case    0:*/		return 0x82198748;
		  /* 82198748h */ case    1:  		/* bc 12, CR0_EQ, -4096 */
		/* 82198748h case    1:*/		if ( regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198748h case    1:*/		return 0x8219874C;
		  /* 8219874Ch */ case    2:  		/* mr R3, R15 */
		/* 8219874Ch case    2:*/		regs.R3 = regs.R15;
		/* 8219874Ch case    2:*/		return 0x82198750;
		  /* 82198750h */ case    3:  		/* bl -9720 */
		/* 82198750h case    3:*/		regs.LR = 0x82198754; return 0x82196158;
		/* 82198750h case    3:*/		return 0x82198754;
		  /* 82198754h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198754h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198754h case    4:*/		return 0x82198758;
		  /* 82198758h */ case    5:  		/* bc 12, CR0_EQ, -4112 */
		/* 82198758h case    5:*/		if ( regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198758h case    5:*/		return 0x8219875C;
	}
	return 0x8219875C;
} // Block from 82198744h-8219875Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219875Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219875C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219875C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219875C);
		  /* 8219875Ch */ case    0:  		/* lwz R31, <#[R15 + 4]> */
		/* 8219875Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R15 + 0x00000004) );
		/* 8219875Ch case    0:*/		return 0x82198760;
		  /* 82198760h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 82198760h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82198760h case    1:*/		return 0x82198764;
		  /* 82198764h */ case    2:  		/* bc 12, CR6_EQ, 88 */
		/* 82198764h case    2:*/		if ( regs.CR[6].eq ) { return 0x821987BC;  }
		/* 82198764h case    2:*/		return 0x82198768;
		  /* 82198768h */ case    3:  		/* lwz R11, <#[R31 + 16]> */
		/* 82198768h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82198768h case    3:*/		return 0x8219876C;
		  /* 8219876Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219876Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219876Ch case    4:*/		return 0x82198770;
		  /* 82198770h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 82198770h case    5:*/		if ( regs.CR[6].eq ) { return 0x82198790;  }
		/* 82198770h case    5:*/		return 0x82198774;
		  /* 82198774h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 82198774h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82198774h case    6:*/		return 0x82198778;
		  /* 82198778h */ case    7:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82198778h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82198778h case    7:*/		return 0x8219877C;
		  /* 8219877Ch */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 8219877Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x82198790;  }
		/* 8219877Ch case    8:*/		return 0x82198780;
		  /* 82198780h */ case    9:  		/* cmplw CR6, R31, R16 */
		/* 82198780h case    9:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R16);
		/* 82198780h case    9:*/		return 0x82198784;
		  /* 82198784h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82198784h case   10:*/		if ( regs.CR[6].eq ) { return 0x82198790;  }
		/* 82198784h case   10:*/		return 0x82198788;
		  /* 82198788h */ case   11:  		/* cmplw CR6, R31, R26 */
		/* 82198788h case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 82198788h case   11:*/		return 0x8219878C;
		  /* 8219878Ch */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 8219878Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x82198798;  }
		/* 8219878Ch case   12:*/		return 0x82198790;
	}
	return 0x82198790;
} // Block from 8219875Ch-82198790h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82198790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198790);
		  /* 82198790h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 82198790h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 82198790h case    0:*/		return 0x82198794;
		  /* 82198794h */ case    1:  		/* b -52 */
		/* 82198794h case    1:*/		return 0x82198760;
		/* 82198794h case    1:*/		return 0x82198798;
	}
	return 0x82198798;
} // Block from 82198790h-82198798h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198798);
		  /* 82198798h */ case    0:  		/* mr R3, R15 */
		/* 82198798h case    0:*/		regs.R3 = regs.R15;
		/* 82198798h case    0:*/		return 0x8219879C;
		  /* 8219879Ch */ case    1:  		/* bl -36572 */
		/* 8219879Ch case    1:*/		regs.LR = 0x821987A0; return 0x8218F8C0;
		/* 8219879Ch case    1:*/		return 0x821987A0;
		  /* 821987A0h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821987A0h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821987A0h case    2:*/		return 0x821987A4;
		  /* 821987A4h */ case    3:  		/* bc 12, CR0_EQ, -4188 */
		/* 821987A4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82197748;  }
		/* 821987A4h case    3:*/		return 0x821987A8;
		  /* 821987A8h */ case    4:  		/* lwz R11, <#[R15 + 8]> */
		/* 821987A8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 821987A8h case    4:*/		return 0x821987AC;
		  /* 821987ACh */ case    5:  		/* lis R10, 16 */
		/* 821987ACh case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x10);
		/* 821987ACh case    5:*/		return 0x821987B0;
		  /* 821987B0h */ case    6:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 821987B0h case    6:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 821987B0h case    6:*/		return 0x821987B4;
		  /* 821987B4h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 821987B4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821987B4h case    7:*/		return 0x821987B8;
		  /* 821987B8h */ case    8:  		/* bc 12, CR6_GT, -4208 */
		/* 821987B8h case    8:*/		if ( regs.CR[6].gt ) { return 0x82197748;  }
		/* 821987B8h case    8:*/		return 0x821987BC;
	}
	return 0x821987BC;
} // Block from 82198798h-821987BCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821987BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821987BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821987BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821987BC);
		  /* 821987BCh */ case    0:  		/* li R7, 0 */
		/* 821987BCh case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821987BCh case    0:*/		return 0x821987C0;
		  /* 821987C0h */ case    1:  		/* li R6, 1 */
		/* 821987C0h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821987C0h case    1:*/		return 0x821987C4;
		  /* 821987C4h */ case    2:  		/* mr R5, R14 */
		/* 821987C4h case    2:*/		regs.R5 = regs.R14;
		/* 821987C4h case    2:*/		return 0x821987C8;
		  /* 821987C8h */ case    3:  		/* mr R4, R15 */
		/* 821987C8h case    3:*/		regs.R4 = regs.R15;
		/* 821987C8h case    3:*/		return 0x821987CC;
		  /* 821987CCh */ case    4:  		/* mr R3, R21 */
		/* 821987CCh case    4:*/		regs.R3 = regs.R21;
		/* 821987CCh case    4:*/		return 0x821987D0;
		  /* 821987D0h */ case    5:  		/* bl 610976 */
		/* 821987D0h case    5:*/		regs.LR = 0x821987D4; return 0x8222DA70;
		/* 821987D0h case    5:*/		return 0x821987D4;
		  /* 821987D4h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821987D4h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821987D4h case    6:*/		return 0x821987D8;
		  /* 821987D8h */ case    7:  		/* bc 12, CR0_EQ, -4240 */
		/* 821987D8h case    7:*/		if ( regs.CR[0].eq ) { return 0x82197748;  }
		/* 821987D8h case    7:*/		return 0x821987DC;
		  /* 821987DCh */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 821987DCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821987DCh case    8:*/		return 0x821987E0;
		  /* 821987E0h */ case    9:  		/* bc 12, CR6_EQ, 376 */
		/* 821987E0h case    9:*/		if ( regs.CR[6].eq ) { return 0x82198958;  }
		/* 821987E0h case    9:*/		return 0x821987E4;
		  /* 821987E4h */ case   10:  		/* mr R4, R15 */
		/* 821987E4h case   10:*/		regs.R4 = regs.R15;
		/* 821987E4h case   10:*/		return 0x821987E8;
		  /* 821987E8h */ case   11:  		/* mr R3, R21 */
		/* 821987E8h case   11:*/		regs.R3 = regs.R21;
		/* 821987E8h case   11:*/		return 0x821987EC;
		  /* 821987ECh */ case   12:  		/* bl 574388 */
		/* 821987ECh case   12:*/		regs.LR = 0x821987F0; return 0x82224BA0;
		/* 821987ECh case   12:*/		return 0x821987F0;
		  /* 821987F0h */ case   13:  		/* lwz R30, <#[R15]> */
		/* 821987F0h case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R15 + 0x00000000) );
		/* 821987F0h case   13:*/		return 0x821987F4;
		  /* 821987F4h */ case   14:  		/* mr R31, R3 */
		/* 821987F4h case   14:*/		regs.R31 = regs.R3;
		/* 821987F4h case   14:*/		return 0x821987F8;
		  /* 821987F8h */ case   15:  		/* cmplwi CR6, R30, 0 */
		/* 821987F8h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821987F8h case   15:*/		return 0x821987FC;
		  /* 821987FCh */ case   16:  		/* bc 12, CR6_EQ, 124 */
		/* 821987FCh case   16:*/		if ( regs.CR[6].eq ) { return 0x82198878;  }
		/* 821987FCh case   16:*/		return 0x82198800;
		  /* 82198800h */ case   17:  		/* mr R4, R30 */
		/* 82198800h case   17:*/		regs.R4 = regs.R30;
		/* 82198800h case   17:*/		return 0x82198804;
		  /* 82198804h */ case   18:  		/* lwz R5, <#[R30 + 12]> */
		/* 82198804h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 82198804h case   18:*/		return 0x82198808;
		  /* 82198808h */ case   19:  		/* mr R3, R21 */
		/* 82198808h case   19:*/		regs.R3 = regs.R21;
		/* 82198808h case   19:*/		return 0x8219880C;
		  /* 8219880Ch */ case   20:  		/* bl -161564 */
		/* 8219880Ch case   20:*/		regs.LR = 0x82198810; return 0x821710F0;
		/* 8219880Ch case   20:*/		return 0x82198810;
		  /* 82198810h */ case   21:  		/* lwz R11, <#[R15 + 8]> */
		/* 82198810h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 82198810h case   21:*/		return 0x82198814;
		  /* 82198814h */ case   22:  		/* mr R27, R3 */
		/* 82198814h case   22:*/		regs.R27 = regs.R3;
		/* 82198814h case   22:*/		return 0x82198818;
		  /* 82198818h */ case   23:  		/* rlwinm R10, R11, 13, 29, 31 */
		/* 82198818h case   23:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R10,regs.R11);
		/* 82198818h case   23:*/		return 0x8219881C;
		  /* 8219881Ch */ case   24:  		/* mr R29, R18 */
		/* 8219881Ch case   24:*/		regs.R29 = regs.R18;
		/* 8219881Ch case   24:*/		return 0x82198820;
		  /* 82198820h */ case   25:  		/* addi R11, R15, 44 */
		/* 82198820h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R15,0x2C);
		/* 82198820h case   25:*/		return 0x82198824;
		  /* 82198824h */ case   26:  		/* cmplw CR6, R29, R10 */
		/* 82198824h case   26:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 82198824h case   26:*/		return 0x82198828;
		  /* 82198828h */ case   27:  		/* bc 4, CR6_LT, 60 */
		/* 82198828h case   27:*/		if ( !regs.CR[6].lt ) { return 0x82198864;  }
		/* 82198828h case   27:*/		return 0x8219882C;
		  /* 8219882Ch */ case   28:  		/* lwz R28, <#[R11]> */
		/* 8219882Ch case   28:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 8219882Ch case   28:*/		return 0x82198830;
		  /* 82198830h */ case   29:  		/* cmplw CR6, R28, R30 */
		/* 82198830h case   29:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R30);
		/* 82198830h case   29:*/		return 0x82198834;
		  /* 82198834h */ case   30:  		/* bc 12, CR6_EQ, 16 */
		/* 82198834h case   30:*/		if ( regs.CR[6].eq ) { return 0x82198844;  }
		/* 82198834h case   30:*/		return 0x82198838;
		  /* 82198838h */ case   31:  		/* addi R29, R29, 1 */
		/* 82198838h case   31:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82198838h case   31:*/		return 0x8219883C;
		  /* 8219883Ch */ case   32:  		/* addi R11, R11, 4 */
		/* 8219883Ch case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219883Ch case   32:*/		return 0x82198840;
		  /* 82198840h */ case   33:  		/* b -28 */
		/* 82198840h case   33:*/		return 0x82198824;
		/* 82198840h case   33:*/		return 0x82198844;
	}
	return 0x82198844;
} // Block from 821987BCh-82198844h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82198844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198844);
		  /* 82198844h */ case    0:  		/* mr R4, R27 */
		/* 82198844h case    0:*/		regs.R4 = regs.R27;
		/* 82198844h case    0:*/		return 0x82198848;
		  /* 82198848h */ case    1:  		/* mr R3, R31 */
		/* 82198848h case    1:*/		regs.R3 = regs.R31;
		/* 82198848h case    1:*/		return 0x8219884C;
		  /* 8219884Ch */ case    2:  		/* bl -132740 */
		/* 8219884Ch case    2:*/		regs.LR = 0x82198850; return 0x821781C8;
		/* 8219884Ch case    2:*/		return 0x82198850;
		  /* 82198850h */ case    3:  		/* addi R11, R29, 11 */
		/* 82198850h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xB);
		/* 82198850h case    3:*/		return 0x82198854;
		  /* 82198854h */ case    4:  		/* cmplwi CR6, R28, 0 */
		/* 82198854h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82198854h case    4:*/		return 0x82198858;
		  /* 82198858h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82198858h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82198858h case    5:*/		return 0x8219885C;
		  /* 8219885Ch */ case    6:  		/* stwx R3, <#[R11 + R31]> */
		/* 8219885Ch case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 8219885Ch case    6:*/		return 0x82198860;
		  /* 82198860h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 82198860h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82198870;  }
		/* 82198860h case    7:*/		return 0x82198864;
	}
	return 0x82198864;
} // Block from 82198844h-82198864h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82198864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198864);
		  /* 82198864h */ case    0:  		/* mr R4, R27 */
		/* 82198864h case    0:*/		regs.R4 = regs.R27;
		/* 82198864h case    0:*/		return 0x82198868;
		  /* 82198868h */ case    1:  		/* mr R3, R31 */
		/* 82198868h case    1:*/		regs.R3 = regs.R31;
		/* 82198868h case    1:*/		return 0x8219886C;
		  /* 8219886Ch */ case    2:  		/* bl -132772 */
		/* 8219886Ch case    2:*/		regs.LR = 0x82198870; return 0x821781C8;
		/* 8219886Ch case    2:*/		return 0x82198870;
	}
	return 0x82198870;
} // Block from 82198864h-82198870h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82198870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198870);
		  /* 82198870h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 82198870h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 82198870h case    0:*/		return 0x82198874;
		  /* 82198874h */ case    1:  		/* b -124 */
		/* 82198874h case    1:*/		return 0x821987F8;
		/* 82198874h case    1:*/		return 0x82198878;
	}
	return 0x82198878;
} // Block from 82198870h-82198878h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198878);
		  /* 82198878h */ case    0:  		/* rlwinm R11, R15, 0, 0, 30 */
		/* 82198878h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R15);
		/* 82198878h case    0:*/		return 0x8219887C;
		  /* 8219887Ch */ case    1:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 8219887Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 8219887Ch case    1:*/		return 0x82198880;
		  /* 82198880h */ case    2:  		/* addi R11, R11, 36 */
		/* 82198880h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 82198880h case    2:*/		return 0x82198884;
		  /* 82198884h */ case    3:  		/* addi R10, R10, 36 */
		/* 82198884h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 82198884h case    3:*/		return 0x82198888;
		  /* 82198888h */ case    4:  		/* addi R8, R11, -36 */
		/* 82198888h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 82198888h case    4:*/		return 0x8219888C;
		  /* 8219888Ch */ case    5:  		/* addi R7, R10, -36 */
		/* 8219888Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 8219888Ch case    5:*/		return 0x82198890;
		  /* 82198890h */ case    6:  		/* addi R9, R10, 4 */
		/* 82198890h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 82198890h case    6:*/		return 0x82198894;
		  /* 82198894h */ case    7:  		/* lwz R6, <#[R11]> */
		/* 82198894h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 82198894h case    7:*/		return 0x82198898;
		  /* 82198898h */ case    8:  		/* stw R6, <#[R10]> */
		/* 82198898h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 82198898h case    8:*/		return 0x8219889C;
		  /* 8219889Ch */ case    9:  		/* lwz R6, <#[R11]> */
		/* 8219889Ch case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8219889Ch case    9:*/		return 0x821988A0;
		  /* 821988A0h */ case   10:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821988A0h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821988A0h case   10:*/		return 0x821988A4;
		  /* 821988A4h */ case   11:  		/* stw R7, <#[R6]> */
		/* 821988A4h case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 821988A4h case   11:*/		return 0x821988A8;
		  /* 821988A8h */ case   12:  		/* stw R8, <#[R10 + 4]> */
		/* 821988A8h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821988A8h case   12:*/		return 0x821988AC;
		  /* 821988ACh */ case   13:  		/* stw R9, <#[R11]> */
		/* 821988ACh case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821988ACh case   13:*/		return 0x821988B0;
		  /* 821988B0h */ case   14:  		/* lwz R11, <#[R16 + 12]> */
		/* 821988B0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x0000000C) );
		/* 821988B0h case   14:*/		return 0x821988B4;
		  /* 821988B4h */ case   15:  		/* addi R11, R11, 4 */
		/* 821988B4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821988B4h case   15:*/		return 0x821988B8;
		  /* 821988B8h */ case   16:  		/* lwz R10, <#[R11]> */
		/* 821988B8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821988B8h case   16:*/		return 0x821988BC;
		  /* 821988BCh */ case   17:  		/* b 12 */
		/* 821988BCh case   17:*/		return 0x821988C8;
		/* 821988BCh case   17:*/		return 0x821988C0;
		  /* 821988C0h */ case   18:  		/* addi R11, R10, 8 */
		/* 821988C0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821988C0h case   18:*/		return 0x821988C4;
		  /* 821988C4h */ case   19:  		/* lwz R10, <#[R10 + 8]> */
		/* 821988C4h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821988C4h case   19:*/		return 0x821988C8;
	}
	return 0x821988C8;
} // Block from 82198878h-821988C8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821988C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821988C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821988C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821988C8);
		  /* 821988C8h */ case    0:  		/* cmplw CR6, R10, R16 */
		/* 821988C8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R16);
		/* 821988C8h case    0:*/		return 0x821988CC;
		  /* 821988CCh */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821988CCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821988C0;  }
		/* 821988CCh case    1:*/		return 0x821988D0;
		  /* 821988D0h */ case    2:  		/* lwz R10, <#[R16 + 8]> */
		/* 821988D0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000008) );
		/* 821988D0h case    2:*/		return 0x821988D4;
		  /* 821988D4h */ case    3:  		/* stw R10, <#[R11]> */
		/* 821988D4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821988D4h case    3:*/		return 0x821988D8;
		  /* 821988D8h */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 821988D8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821988D8h case    4:*/		return 0x821988DC;
		  /* 821988DCh */ case    5:  		/* stw R11, <#[R16 + 8]> */
		/* 821988DCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821988DCh case    5:*/		return 0x821988E0;
		  /* 821988E0h */ case    6:  		/* stw R16, <#[R31 + 4]> */
		/* 821988E0h case    6:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R31 + 0x00000004) );
		/* 821988E0h case    6:*/		return 0x821988E4;
		  /* 821988E4h */ case    7:  		/* stw R31, <#[R16 + 12]> */
		/* 821988E4h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R16 + 0x0000000C) );
		/* 821988E4h case    7:*/		return 0x821988E8;
		  /* 821988E8h */ case    8:  		/* lwz R11, <#[R26 + 12]> */
		/* 821988E8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 821988E8h case    8:*/		return 0x821988EC;
		  /* 821988ECh */ case    9:  		/* addi R11, R11, 4 */
		/* 821988ECh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821988ECh case    9:*/		return 0x821988F0;
		  /* 821988F0h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 821988F0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821988F0h case   10:*/		return 0x821988F4;
		  /* 821988F4h */ case   11:  		/* b 12 */
		/* 821988F4h case   11:*/		return 0x82198900;
		/* 821988F4h case   11:*/		return 0x821988F8;
		  /* 821988F8h */ case   12:  		/* addi R11, R10, 8 */
		/* 821988F8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821988F8h case   12:*/		return 0x821988FC;
		  /* 821988FCh */ case   13:  		/* lwz R10, <#[R10 + 8]> */
		/* 821988FCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821988FCh case   13:*/		return 0x82198900;
	}
	return 0x82198900;
} // Block from 821988C8h-82198900h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82198900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198900);
		  /* 82198900h */ case    0:  		/* cmplw CR6, R10, R26 */
		/* 82198900h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R26);
		/* 82198900h case    0:*/		return 0x82198904;
		  /* 82198904h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82198904h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821988F8;  }
		/* 82198904h case    1:*/		return 0x82198908;
		  /* 82198908h */ case    2:  		/* lwz R10, <#[R26 + 8]> */
		/* 82198908h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 82198908h case    2:*/		return 0x8219890C;
		  /* 8219890Ch */ case    3:  		/* mr R3, R31 */
		/* 8219890Ch case    3:*/		regs.R3 = regs.R31;
		/* 8219890Ch case    3:*/		return 0x82198910;
		  /* 82198910h */ case    4:  		/* stw R10, <#[R11]> */
		/* 82198910h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82198910h case    4:*/		return 0x82198914;
		  /* 82198914h */ case    5:  		/* lwz R11, <#[R31 + 4]> */
		/* 82198914h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82198914h case    5:*/		return 0x82198918;
		  /* 82198918h */ case    6:  		/* stw R11, <#[R26 + 8]> */
		/* 82198918h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82198918h case    6:*/		return 0x8219891C;
		  /* 8219891Ch */ case    7:  		/* stw R26, <#[R31 + 4]> */
		/* 8219891Ch case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x00000004) );
		/* 8219891Ch case    7:*/		return 0x82198920;
		  /* 82198920h */ case    8:  		/* stw R31, <#[R26 + 12]> */
		/* 82198920h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R26 + 0x0000000C) );
		/* 82198920h case    8:*/		return 0x82198924;
		  /* 82198924h */ case    9:  		/* bl -132524 */
		/* 82198924h case    9:*/		regs.LR = 0x82198928; return 0x82178378;
		/* 82198924h case    9:*/		return 0x82198928;
		  /* 82198928h */ case   10:  		/* mr R3, R15 */
		/* 82198928h case   10:*/		regs.R3 = regs.R15;
		/* 82198928h case   10:*/		return 0x8219892C;
		  /* 8219892Ch */ case   11:  		/* bl -132532 */
		/* 8219892Ch case   11:*/		regs.LR = 0x82198930; return 0x82178378;
		/* 8219892Ch case   11:*/		return 0x82198930;
		  /* 82198930h */ case   12:  		/* lwz R11, <#[R15 + 8]> */
		/* 82198930h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 82198930h case   12:*/		return 0x82198934;
		  /* 82198934h */ case   13:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82198934h case   13:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82198934h case   13:*/		return 0x82198938;
		  /* 82198938h */ case   14:  		/* bc 12, CR0_EQ, 28 */
		/* 82198938h case   14:*/		if ( regs.CR[0].eq ) { return 0x82198954;  }
		/* 82198938h case   14:*/		return 0x8219893C;
		  /* 8219893Ch */ case   15:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219893Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219893Ch case   15:*/		return 0x82198940;
		  /* 82198940h */ case   16:  		/* lwz R10, <#[R31 + 16]> */
		/* 82198940h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82198940h case   16:*/		return 0x82198944;
		  /* 82198944h */ case   17:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 82198944h case   17:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 82198944h case   17:*/		return 0x82198948;
		  /* 82198948h */ case   18:  		/* rlwinm R10, R10, 0, 13, 10 */
		/* 82198948h case   18:*/		cpu::op::rlwinm<0,0,13,10>(regs,&regs.R10,regs.R10);
		/* 82198948h case   18:*/		return 0x8219894C;
		  /* 8219894Ch */ case   19:  		/* stw R11, <#[R31 + 8]> */
		/* 8219894Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219894Ch case   19:*/		return 0x82198950;
		  /* 82198950h */ case   20:  		/* stw R10, <#[R31 + 16]> */
		/* 82198950h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82198950h case   20:*/		return 0x82198954;
	}
	return 0x82198954;
} // Block from 82198900h-82198954h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82198954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198954);
		  /* 82198954h */ case    0:  		/* mr R15, R31 */
		/* 82198954h case    0:*/		regs.R15 = regs.R31;
		/* 82198954h case    0:*/		return 0x82198958;
	}
	return 0x82198958;
} // Block from 82198954h-82198958h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82198958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198958);
		  /* 82198958h */ case    0:  		/* lwz R11, <#[R16]> */
		/* 82198958h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82198958h case    0:*/		return 0x8219895C;
		  /* 8219895Ch */ case    1:  		/* lwz R10, <#[R15 + 8]> */
		/* 8219895Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000008) );
		/* 8219895Ch case    1:*/		return 0x82198960;
		  /* 82198960h */ case    2:  		/* rlwinm R4, R11, 7, 29, 31 */
		/* 82198960h case    2:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R4,regs.R11);
		/* 82198960h case    2:*/		return 0x82198964;
		  /* 82198964h */ case    3:  		/* rlwinm R10, R10, 18, 29, 31 */
		/* 82198964h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R10,regs.R10);
		/* 82198964h case    3:*/		return 0x82198968;
		  /* 82198968h */ case    4:  		/* cmplw CR6, R4, R10 */
		/* 82198968h case    4:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 82198968h case    4:*/		return 0x8219896C;
		  /* 8219896Ch */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 8219896Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219897C;  }
		/* 8219896Ch case    5:*/		return 0x82198970;
		  /* 82198970h */ case    6:  		/* rlwinm R10, R11, 0, 19, 26 */
		/* 82198970h case    6:*/		cpu::op::rlwinm<0,0,19,26>(regs,&regs.R10,regs.R11);
		/* 82198970h case    6:*/		return 0x82198974;
		  /* 82198974h */ case    7:  		/* cmplwi CR6, R10, 7296 */
		/* 82198974h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00001C80);
		/* 82198974h case    7:*/		return 0x82198978;
		  /* 82198978h */ case    8:  		/* bc 12, CR6_EQ, 44 */
		/* 82198978h case    8:*/		if ( regs.CR[6].eq ) { return 0x821989A4;  }
		/* 82198978h case    8:*/		return 0x8219897C;
	}
	return 0x8219897C;
} // Block from 82198958h-8219897Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219897Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219897C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219897C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219897C);
		  /* 8219897Ch */ case    0:  		/* rlwinm R5, R11, 27, 24, 31 */
		/* 8219897Ch case    0:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R5,regs.R11);
		/* 8219897Ch case    0:*/		return 0x82198980;
		  /* 82198980h */ case    1:  		/* mr R3, R15 */
		/* 82198980h case    1:*/		regs.R3 = regs.R15;
		/* 82198980h case    1:*/		return 0x82198984;
		  /* 82198984h */ case    2:  		/* bl 561300 */
		/* 82198984h case    2:*/		regs.LR = 0x82198988; return 0x82221A18;
		/* 82198984h case    2:*/		return 0x82198988;
		  /* 82198988h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198988h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198988h case    3:*/		return 0x8219898C;
		  /* 8219898Ch */ case    4:  		/* bc 12, CR0_EQ, -4676 */
		/* 8219898Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82197748;  }
		/* 8219898Ch case    4:*/		return 0x82198990;
		  /* 82198990h */ case    5:  		/* lwz R11, <#[R16]> */
		/* 82198990h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82198990h case    5:*/		return 0x82198994;
		  /* 82198994h */ case    6:  		/* mr R3, R15 */
		/* 82198994h case    6:*/		regs.R3 = regs.R15;
		/* 82198994h case    6:*/		return 0x82198998;
		  /* 82198998h */ case    7:  		/* rlwinm R5, R11, 27, 24, 31 */
		/* 82198998h case    7:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R5,regs.R11);
		/* 82198998h case    7:*/		return 0x8219899C;
		  /* 8219899Ch */ case    8:  		/* rlwinm R4, R11, 7, 29, 31 */
		/* 8219899Ch case    8:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R4,regs.R11);
		/* 8219899Ch case    8:*/		return 0x821989A0;
		  /* 821989A0h */ case    9:  		/* bl 561472 */
		/* 821989A0h case    9:*/		regs.LR = 0x821989A4; return 0x82221AE0;
		/* 821989A0h case    9:*/		return 0x821989A4;
	}
	return 0x821989A4;
} // Block from 8219897Ch-821989A4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821989A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821989A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821989A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821989A4);
		  /* 821989A4h */ case    0:  		/* li R7, 0 */
		/* 821989A4h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821989A4h case    0:*/		return 0x821989A8;
		  /* 821989A8h */ case    1:  		/* li R6, 1 */
		/* 821989A8h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821989A8h case    1:*/		return 0x821989AC;
		  /* 821989ACh */ case    2:  		/* mr R5, R14 */
		/* 821989ACh case    2:*/		regs.R5 = regs.R14;
		/* 821989ACh case    2:*/		return 0x821989B0;
		  /* 821989B0h */ case    3:  		/* mr R4, R15 */
		/* 821989B0h case    3:*/		regs.R4 = regs.R15;
		/* 821989B0h case    3:*/		return 0x821989B4;
		  /* 821989B4h */ case    4:  		/* mr R3, R21 */
		/* 821989B4h case    4:*/		regs.R3 = regs.R21;
		/* 821989B4h case    4:*/		return 0x821989B8;
		  /* 821989B8h */ case    5:  		/* bl 610768 */
		/* 821989B8h case    5:*/		regs.LR = 0x821989BC; return 0x8222DB88;
		/* 821989B8h case    5:*/		return 0x821989BC;
		  /* 821989BCh */ case    6:  		/* lwz R11, <#[R15 + 8]> */
		/* 821989BCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 821989BCh case    6:*/		return 0x821989C0;
		  /* 821989C0h */ case    7:  		/* addi R7, R14, 4 */
		/* 821989C0h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R14,0x4);
		/* 821989C0h case    7:*/		return 0x821989C4;
		  /* 821989C4h */ case    8:  		/* ori R11, R11, 32 */
		/* 821989C4h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 821989C4h case    8:*/		return 0x821989C8;
		  /* 821989C8h */ case    9:  		/* stw R11, <#[R15 + 8]> */
		/* 821989C8h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 821989C8h case    9:*/		return 0x821989CC;
		  /* 821989CCh */ case   10:  		/* lwz R11, <#[R7]> */
		/* 821989CCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 821989CCh case   10:*/		return 0x821989D0;
		  /* 821989D0h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 821989D0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821989D0h case   11:*/		return 0x821989D4;
		  /* 821989D4h */ case   12:  		/* bc 12, CR6_EQ, 4644 */
		/* 821989D4h case   12:*/		if ( regs.CR[6].eq ) { return 0x82199BF8;  }
		/* 821989D4h case   12:*/		return 0x821989D8;
		  /* 821989D8h */ case   13:  		/* lwz R10, <#[R11 + 16]> */
		/* 821989D8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821989D8h case   13:*/		return 0x821989DC;
		  /* 821989DCh */ case   14:  		/* cmplwi CR6, R10, 0 */
		/* 821989DCh case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821989DCh case   14:*/		return 0x821989E0;
		  /* 821989E0h */ case   15:  		/* bc 12, CR6_EQ, 4612 */
		/* 821989E0h case   15:*/		if ( regs.CR[6].eq ) { return 0x82199BE4;  }
		/* 821989E0h case   15:*/		return 0x821989E4;
		  /* 821989E4h */ case   16:  		/* lwz R10, <#[R11 + 12]> */
		/* 821989E4h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821989E4h case   16:*/		return 0x821989E8;
		  /* 821989E8h */ case   17:  		/* addi R10, R10, 4 */
		/* 821989E8h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821989E8h case   17:*/		return 0x821989EC;
		  /* 821989ECh */ case   18:  		/* lwz R9, <#[R10]> */
		/* 821989ECh case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821989ECh case   18:*/		return 0x821989F0;
		  /* 821989F0h */ case   19:  		/* b 4472 */
		/* 821989F0h case   19:*/		return 0x82199B68;
		/* 821989F0h case   19:*/		return 0x821989F4;
		  /* 821989F4h */ case   20:  		/* addi R11, R10, 8 */
		/* 821989F4h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821989F4h case   20:*/		return 0x821989F8;
		  /* 821989F8h */ case   21:  		/* lwz R10, <#[R10 + 8]> */
		/* 821989F8h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821989F8h case   21:*/		return 0x821989FC;
	}
	return 0x821989FC;
} // Block from 821989A4h-821989FCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 821989FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821989FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821989FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821989FC);
		  /* 821989FCh */ case    0:  		/* cmplw CR6, R10, R28 */
		/* 821989FCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 821989FCh case    0:*/		return 0x82198A00;
		  /* 82198A00h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82198A00h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821989F4;  }
		/* 82198A00h case    1:*/		return 0x82198A04;
		  /* 82198A04h */ case    2:  		/* lwz R10, <#[R28 + 8]> */
		/* 82198A04h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 82198A04h case    2:*/		return 0x82198A08;
		  /* 82198A08h */ case    3:  		/* stw R10, <#[R11]> */
		/* 82198A08h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82198A08h case    3:*/		return 0x82198A0C;
		  /* 82198A0Ch */ case    4:  		/* lwz R11, <#[R15 + 4]> */
		/* 82198A0Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000004) );
		/* 82198A0Ch case    4:*/		return 0x82198A10;
		  /* 82198A10h */ case    5:  		/* stw R11, <#[R28 + 8]> */
		/* 82198A10h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 82198A10h case    5:*/		return 0x82198A14;
		  /* 82198A14h */ case    6:  		/* stw R28, <#[R15 + 4]> */
		/* 82198A14h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R15 + 0x00000004) );
		/* 82198A14h case    6:*/		return 0x82198A18;
		  /* 82198A18h */ case    7:  		/* stw R15, <#[R28 + 12]> */
		/* 82198A18h case    7:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R28 + 0x0000000C) );
		/* 82198A18h case    7:*/		return 0x82198A1C;
		  /* 82198A1Ch */ case    8:  		/* b 500 */
		/* 82198A1Ch case    8:*/		return 0x82198C10;
		/* 82198A1Ch case    8:*/		return 0x82198A20;
	}
	return 0x82198A20;
} // Block from 821989FCh-82198A20h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82198A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198A20);
		  /* 82198A20h */ case    0:  		/* rlwinm. R11, R26, 0, 27, 28 */
		/* 82198A20h case    0:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R26);
		/* 82198A20h case    0:*/		return 0x82198A24;
		  /* 82198A24h */ case    1:  		/* rlwinm R31, R30, 0, 27, 31 */
		/* 82198A24h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R31,regs.R30);
		/* 82198A24h case    1:*/		return 0x82198A28;
		  /* 82198A28h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 82198A28h case    2:*/		if ( regs.CR[0].eq ) { return 0x82198A3C;  }
		/* 82198A28h case    2:*/		return 0x82198A2C;
		  /* 82198A2Ch */ case    3:  		/* rlwinm. R11, R31, 0, 27, 28 */
		/* 82198A2Ch case    3:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R31);
		/* 82198A2Ch case    3:*/		return 0x82198A30;
		  /* 82198A30h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 82198A30h case    4:*/		if ( regs.CR[0].eq ) { return 0x82198A3C;  }
		/* 82198A30h case    4:*/		return 0x82198A34;
		  /* 82198A34h */ case    5:  		/* mr R11, R18 */
		/* 82198A34h case    5:*/		regs.R11 = regs.R18;
		/* 82198A34h case    5:*/		return 0x82198A38;
		  /* 82198A38h */ case    6:  		/* b 44 */
		/* 82198A38h case    6:*/		return 0x82198A64;
		/* 82198A38h case    6:*/		return 0x82198A3C;
	}
	return 0x82198A3C;
} // Block from 82198A20h-82198A3Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82198A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198A3C);
		  /* 82198A3Ch */ case    0:  		/* rlwinm. R11, R26, 0, 30, 30 */
		/* 82198A3Ch case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R26);
		/* 82198A3Ch case    0:*/		return 0x82198A40;
		  /* 82198A40h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82198A40h case    1:*/		if ( regs.CR[0].eq ) { return 0x82198A4C;  }
		/* 82198A40h case    1:*/		return 0x82198A44;
		  /* 82198A44h */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82198A44h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82198A44h case    2:*/		return 0x82198A48;
		  /* 82198A48h */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 82198A48h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82198A34;  }
		/* 82198A48h case    3:*/		return 0x82198A4C;
	}
	return 0x82198A4C;
} // Block from 82198A3Ch-82198A4Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82198A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198A4C);
		  /* 82198A4Ch */ case    0:  		/* rlwinm. R11, R26, 0, 29, 29 */
		/* 82198A4Ch case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R26);
		/* 82198A4Ch case    0:*/		return 0x82198A50;
		  /* 82198A50h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82198A50h case    1:*/		if ( regs.CR[0].eq ) { return 0x82198A60;  }
		/* 82198A50h case    1:*/		return 0x82198A54;
		  /* 82198A54h */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82198A54h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82198A54h case    2:*/		return 0x82198A58;
		  /* 82198A58h */ case    3:  		/* mr R11, R18 */
		/* 82198A58h case    3:*/		regs.R11 = regs.R18;
		/* 82198A58h case    3:*/		return 0x82198A5C;
		  /* 82198A5Ch */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 82198A5Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x82198A64;  }
		/* 82198A5Ch case    4:*/		return 0x82198A60;
	}
	return 0x82198A60;
} // Block from 82198A4Ch-82198A60h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82198A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198A60);
		  /* 82198A60h */ case    0:  		/* mr R11, R19 */
		/* 82198A60h case    0:*/		regs.R11 = regs.R19;
		/* 82198A60h case    0:*/		return 0x82198A64;
	}
	return 0x82198A64;
} // Block from 82198A60h-82198A64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82198A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198A64);
		  /* 82198A64h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82198A64h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82198A64h case    0:*/		return 0x82198A68;
		  /* 82198A68h */ case    1:  		/* bc 12, CR0_EQ, 424 */
		/* 82198A68h case    1:*/		if ( regs.CR[0].eq ) { return 0x82198C10;  }
		/* 82198A68h case    1:*/		return 0x82198A6C;
		  /* 82198A6Ch */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 82198A6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82198A6Ch case    2:*/		return 0x82198A70;
		  /* 82198A70h */ case    3:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 82198A70h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 82198A70h case    3:*/		return 0x82198A74;
		  /* 82198A74h */ case    4:  		/* cmplwi CR6, R10, 112 */
		/* 82198A74h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000070);
		/* 82198A74h case    4:*/		return 0x82198A78;
		  /* 82198A78h */ case    5:  		/* bc 4, CR6_EQ, 44 */
		/* 82198A78h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82198AA4;  }
		/* 82198A78h case    5:*/		return 0x82198A7C;
		  /* 82198A7Ch */ case    6:  		/* lwz R11, <#[R29]> */
		/* 82198A7Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82198A7Ch case    6:*/		return 0x82198A80;
		  /* 82198A80h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82198A80h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82198A80h case    7:*/		return 0x82198A84;
		  /* 82198A84h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82198A84h case    8:*/		if ( regs.CR[6].eq ) { return 0x82198A98;  }
		/* 82198A84h case    8:*/		return 0x82198A88;
		  /* 82198A88h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 82198A88h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82198A88h case    9:*/		return 0x82198A8C;
		  /* 82198A8Ch */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82198A8Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82198A8Ch case   10:*/		return 0x82198A90;
		  /* 82198A90h */ case   11:  		/* mr R11, R19 */
		/* 82198A90h case   11:*/		regs.R11 = regs.R19;
		/* 82198A90h case   11:*/		return 0x82198A94;
		  /* 82198A94h */ case   12:  		/* bc 4, CR6_EQ, 8 */
		/* 82198A94h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82198A9C;  }
		/* 82198A94h case   12:*/		return 0x82198A98;
	}
	return 0x82198A98;
} // Block from 82198A64h-82198A98h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82198A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198A98);
		  /* 82198A98h */ case    0:  		/* mr R11, R18 */
		/* 82198A98h case    0:*/		regs.R11 = regs.R18;
		/* 82198A98h case    0:*/		return 0x82198A9C;
	}
	return 0x82198A9C;
} // Block from 82198A98h-82198A9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82198A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198A9C);
		  /* 82198A9Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82198A9Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82198A9Ch case    0:*/		return 0x82198AA0;
		  /* 82198AA0h */ case    1:  		/* bc 4, CR0_EQ, 368 */
		/* 82198AA0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82198C10;  }
		/* 82198AA0h case    1:*/		return 0x82198AA4;
	}
	return 0x82198AA4;
} // Block from 82198A9Ch-82198AA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198AA4);
		  /* 82198AA4h */ case    0:  		/* cmplwi CR6, R10, 110 */
		/* 82198AA4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000006E);
		/* 82198AA4h case    0:*/		return 0x82198AA8;
		  /* 82198AA8h */ case    1:  		/* bc 12, CR6_EQ, 360 */
		/* 82198AA8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82198C10;  }
		/* 82198AA8h case    1:*/		return 0x82198AAC;
		  /* 82198AACh */ case    2:  		/* cmplwi CR6, R10, 1 */
		/* 82198AACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82198AACh case    2:*/		return 0x82198AB0;
		  /* 82198AB0h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 82198AB0h case    3:*/		if ( regs.CR[6].lt ) { return 0x82198AC0;  }
		/* 82198AB0h case    3:*/		return 0x82198AB4;
		  /* 82198AB4h */ case    4:  		/* cmplwi CR6, R10, 102 */
		/* 82198AB4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 82198AB4h case    4:*/		return 0x82198AB8;
		  /* 82198AB8h */ case    5:  		/* mr R11, R19 */
		/* 82198AB8h case    5:*/		regs.R11 = regs.R19;
		/* 82198AB8h case    5:*/		return 0x82198ABC;
		  /* 82198ABCh */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 82198ABCh case    6:*/		if ( !regs.CR[6].gt ) { return 0x82198AC4;  }
		/* 82198ABCh case    6:*/		return 0x82198AC0;
	}
	return 0x82198AC0;
} // Block from 82198AA4h-82198AC0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82198AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198AC0);
		  /* 82198AC0h */ case    0:  		/* mr R11, R18 */
		/* 82198AC0h case    0:*/		regs.R11 = regs.R18;
		/* 82198AC0h case    0:*/		return 0x82198AC4;
	}
	return 0x82198AC4;
} // Block from 82198AC0h-82198AC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82198AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198AC4);
		  /* 82198AC4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82198AC4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82198AC4h case    0:*/		return 0x82198AC8;
		  /* 82198AC8h */ case    1:  		/* bc 4, CR0_EQ, 44 */
		/* 82198AC8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82198AF4;  }
		/* 82198AC8h case    1:*/		return 0x82198ACC;
		  /* 82198ACCh */ case    2:  		/* lwz R11, <#[R15 + 8]> */
		/* 82198ACCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 82198ACCh case    2:*/		return 0x82198AD0;
		  /* 82198AD0h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82198AD0h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82198AD0h case    3:*/		return 0x82198AD4;
		  /* 82198AD4h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 82198AD4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82198AD4h case    4:*/		return 0x82198AD8;
		  /* 82198AD8h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 82198AD8h case    5:*/		if ( regs.CR[6].lt ) { return 0x82198AE8;  }
		/* 82198AD8h case    5:*/		return 0x82198ADC;
		  /* 82198ADCh */ case    6:  		/* cmplwi CR6, R11, 102 */
		/* 82198ADCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 82198ADCh case    6:*/		return 0x82198AE0;
		  /* 82198AE0h */ case    7:  		/* mr R11, R19 */
		/* 82198AE0h case    7:*/		regs.R11 = regs.R19;
		/* 82198AE0h case    7:*/		return 0x82198AE4;
		  /* 82198AE4h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 82198AE4h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82198AEC;  }
		/* 82198AE4h case    8:*/		return 0x82198AE8;
	}
	return 0x82198AE8;
} // Block from 82198AC4h-82198AE8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82198AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198AE8);
		  /* 82198AE8h */ case    0:  		/* mr R11, R18 */
		/* 82198AE8h case    0:*/		regs.R11 = regs.R18;
		/* 82198AE8h case    0:*/		return 0x82198AEC;
	}
	return 0x82198AEC;
} // Block from 82198AE8h-82198AECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82198AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198AEC);
		  /* 82198AECh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82198AECh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82198AECh case    0:*/		return 0x82198AF0;
		  /* 82198AF0h */ case    1:  		/* bc 12, CR0_EQ, 288 */
		/* 82198AF0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82198C10;  }
		/* 82198AF0h case    1:*/		return 0x82198AF4;
	}
	return 0x82198AF4;
} // Block from 82198AECh-82198AF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198AF4);
		  /* 82198AF4h */ case    0:  		/* mr R5, R21 */
		/* 82198AF4h case    0:*/		regs.R5 = regs.R21;
		/* 82198AF4h case    0:*/		return 0x82198AF8;
		  /* 82198AF8h */ case    1:  		/* mr R4, R15 */
		/* 82198AF8h case    1:*/		regs.R4 = regs.R15;
		/* 82198AF8h case    1:*/		return 0x82198AFC;
		  /* 82198AFCh */ case    2:  		/* mr R3, R29 */
		/* 82198AFCh case    2:*/		regs.R3 = regs.R29;
		/* 82198AFCh case    2:*/		return 0x82198B00;
		  /* 82198B00h */ case    3:  		/* bl -9840 */
		/* 82198B00h case    3:*/		regs.LR = 0x82198B04; return 0x82196490;
		/* 82198B00h case    3:*/		return 0x82198B04;
		  /* 82198B04h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198B04h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198B04h case    4:*/		return 0x82198B08;
		  /* 82198B08h */ case    5:  		/* bc 12, CR0_EQ, 264 */
		/* 82198B08h case    5:*/		if ( regs.CR[0].eq ) { return 0x82198C10;  }
		/* 82198B08h case    5:*/		return 0x82198B0C;
		  /* 82198B0Ch */ case    6:  		/* rlwinm. R9, R26, 0, 29, 29 */
		/* 82198B0Ch case    6:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R26);
		/* 82198B0Ch case    6:*/		return 0x82198B10;
		  /* 82198B10h */ case    7:  		/* mr R10, R31 */
		/* 82198B10h case    7:*/		regs.R10 = regs.R31;
		/* 82198B10h case    7:*/		return 0x82198B14;
		  /* 82198B14h */ case    8:  		/* mr R11, R26 */
		/* 82198B14h case    8:*/		regs.R11 = regs.R26;
		/* 82198B14h case    8:*/		return 0x82198B18;
		  /* 82198B18h */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 82198B18h case    9:*/		if ( regs.CR[0].eq ) { return 0x82198B28;  }
		/* 82198B18h case    9:*/		return 0x82198B1C;
		  /* 82198B1Ch */ case   10:  		/* rlwinm. R9, R31, 0, 30, 30 */
		/* 82198B1Ch case   10:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R31);
		/* 82198B1Ch case   10:*/		return 0x82198B20;
		  /* 82198B20h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 82198B20h case   11:*/		if ( regs.CR[0].eq ) { return 0x82198B28;  }
		/* 82198B20h case   11:*/		return 0x82198B24;
		  /* 82198B24h */ case   12:  		/* addi R11, R26, -4 */
		/* 82198B24h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFFFC);
		/* 82198B24h case   12:*/		return 0x82198B28;
	}
	return 0x82198B28;
} // Block from 82198AF4h-82198B28h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82198B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198B28);
		  /* 82198B28h */ case    0:  		/* and R9, R31, R11 */
		/* 82198B28h case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R31,regs.R11);
		/* 82198B28h case    0:*/		return 0x82198B2C;
		  /* 82198B2Ch */ case    1:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 82198B2Ch case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 82198B2Ch case    1:*/		return 0x82198B30;
		  /* 82198B30h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82198B30h case    2:*/		if ( regs.CR[0].eq ) { return 0x82198B3C;  }
		/* 82198B30h case    2:*/		return 0x82198B34;
		  /* 82198B34h */ case    3:  		/* addi R11, R11, -4 */
		/* 82198B34h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82198B34h case    3:*/		return 0x82198B38;
		  /* 82198B38h */ case    4:  		/* addi R10, R31, -4 */
		/* 82198B38h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFFC);
		/* 82198B38h case    4:*/		return 0x82198B3C;
	}
	return 0x82198B3C;
} // Block from 82198B28h-82198B3Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82198B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198B3C);
		  /* 82198B3Ch */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 82198B3Ch case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 82198B3Ch case    0:*/		return 0x82198B40;
		  /* 82198B40h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82198B40h case    1:*/		if ( regs.CR[0].eq ) { return 0x82198B50;  }
		/* 82198B40h case    1:*/		return 0x82198B44;
		  /* 82198B44h */ case    2:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 82198B44h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 82198B44h case    2:*/		return 0x82198B48;
		  /* 82198B48h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 82198B48h case    3:*/		if ( regs.CR[0].eq ) { return 0x82198B50;  }
		/* 82198B48h case    3:*/		return 0x82198B4C;
		  /* 82198B4Ch */ case    4:  		/* addi R10, R10, -2 */
		/* 82198B4Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 82198B4Ch case    4:*/		return 0x82198B50;
	}
	return 0x82198B50;
} // Block from 82198B3Ch-82198B50h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82198B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198B50);
		  /* 82198B50h */ case    0:  		/* or R31, R11, R10 */
		/* 82198B50h case    0:*/		cpu::op::or<0>(regs,&regs.R31,regs.R11,regs.R10);
		/* 82198B50h case    0:*/		return 0x82198B54;
		  /* 82198B54h */ case    1:  		/* mr R3, R29 */
		/* 82198B54h case    1:*/		regs.R3 = regs.R29;
		/* 82198B54h case    1:*/		return 0x82198B58;
		  /* 82198B58h */ case    2:  		/* mr R4, R31 */
		/* 82198B58h case    2:*/		regs.R4 = regs.R31;
		/* 82198B58h case    2:*/		return 0x82198B5C;
		  /* 82198B5Ch */ case    3:  		/* bl -10444 */
		/* 82198B5Ch case    3:*/		regs.LR = 0x82198B60; return 0x82196290;
		/* 82198B5Ch case    3:*/		return 0x82198B60;
		  /* 82198B60h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198B60h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198B60h case    4:*/		return 0x82198B64;
		  /* 82198B64h */ case    5:  		/* bc 12, CR0_EQ, 172 */
		/* 82198B64h case    5:*/		if ( regs.CR[0].eq ) { return 0x82198C10;  }
		/* 82198B64h case    5:*/		return 0x82198B68;
		  /* 82198B68h */ case    6:  		/* rlwinm. R11, R31, 0, 27, 28 */
		/* 82198B68h case    6:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R31);
		/* 82198B68h case    6:*/		return 0x82198B6C;
		  /* 82198B6Ch */ case    7:  		/* bc 4, CR0_EQ, 164 */
		/* 82198B6Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x82198C10;  }
		/* 82198B6Ch case    7:*/		return 0x82198B70;
		  /* 82198B70h */ case    8:  		/* rlwinm R11, R30, 22, 29, 30 */
		/* 82198B70h case    8:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R11,regs.R30);
		/* 82198B70h case    8:*/		return 0x82198B74;
		  /* 82198B74h */ case    9:  		/* rlwinm R10, R30, 24, 29, 30 */
		/* 82198B74h case    9:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R10,regs.R30);
		/* 82198B74h case    9:*/		return 0x82198B78;
		  /* 82198B78h */ case   10:  		/* srw R11, R27, R11 */
		/* 82198B78h case   10:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 82198B78h case   10:*/		return 0x82198B7C;
		  /* 82198B7Ch */ case   11:  		/* srw R10, R27, R10 */
		/* 82198B7Ch case   11:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R27,regs.R10);
		/* 82198B7Ch case   11:*/		return 0x82198B80;
		  /* 82198B80h */ case   12:  		/* rlwimi R10, R11, 2, 28, 29 */
		/* 82198B80h case   12:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R10,regs.R11);
		/* 82198B80h case   12:*/		return 0x82198B84;
		  /* 82198B84h */ case   13:  		/* rlwinm R11, R30, 26, 29, 30 */
		/* 82198B84h case   13:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R11,regs.R30);
		/* 82198B84h case   13:*/		return 0x82198B88;
		  /* 82198B88h */ case   14:  		/* rlwinm R10, R10, 0, 28, 31 */
		/* 82198B88h case   14:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R10);
		/* 82198B88h case   14:*/		return 0x82198B8C;
		  /* 82198B8Ch */ case   15:  		/* srw R11, R27, R11 */
		/* 82198B8Ch case   15:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 82198B8Ch case   15:*/		return 0x82198B90;
		  /* 82198B90h */ case   16:  		/* rlwinm R9, R30, 28, 29, 30 */
		/* 82198B90h case   16:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R9,regs.R30);
		/* 82198B90h case   16:*/		return 0x82198B94;
		  /* 82198B94h */ case   17:  		/* rlwimi R11, R10, 2, 0, 29 */
		/* 82198B94h case   17:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82198B94h case   17:*/		return 0x82198B98;
		  /* 82198B98h */ case   18:  		/* srw R6, R27, R9 */
		/* 82198B98h case   18:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R27,regs.R9);
		/* 82198B98h case   18:*/		return 0x82198B9C;
		  /* 82198B9Ch */ case   19:  		/* rlwimi R6, R11, 2, 0, 29 */
		/* 82198B9Ch case   19:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R6,regs.R11);
		/* 82198B9Ch case   19:*/		return 0x82198BA0;
		  /* 82198BA0h */ case   20:  		/* mr R7, R31 */
		/* 82198BA0h case   20:*/		regs.R7 = regs.R31;
		/* 82198BA0h case   20:*/		return 0x82198BA4;
		  /* 82198BA4h */ case   21:  		/* mr R5, R15 */
		/* 82198BA4h case   21:*/		regs.R5 = regs.R15;
		/* 82198BA4h case   21:*/		return 0x82198BA8;
		  /* 82198BA8h */ case   22:  		/* mr R4, R28 */
		/* 82198BA8h case   22:*/		regs.R4 = regs.R28;
		/* 82198BA8h case   22:*/		return 0x82198BAC;
		  /* 82198BACh */ case   23:  		/* mr R3, R29 */
		/* 82198BACh case   23:*/		regs.R3 = regs.R29;
		/* 82198BACh case   23:*/		return 0x82198BB0;
		  /* 82198BB0h */ case   24:  		/* bl 559432 */
		/* 82198BB0h case   24:*/		regs.LR = 0x82198BB4; return 0x822214F8;
		/* 82198BB0h case   24:*/		return 0x82198BB4;
		  /* 82198BB4h */ case   25:  		/* lwz R10, <#[R29 + 8]> */
		/* 82198BB4h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 82198BB4h case   25:*/		return 0x82198BB8;
		  /* 82198BB8h */ case   26:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 82198BB8h case   26:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 82198BB8h case   26:*/		return 0x82198BBC;
		  /* 82198BBCh */ case   27:  		/* cmplwi CR6, R11, 112 */
		/* 82198BBCh case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000070);
		/* 82198BBCh case   27:*/		return 0x82198BC0;
		  /* 82198BC0h */ case   28:  		/* bc 12, CR6_EQ, 20 */
		/* 82198BC0h case   28:*/		if ( regs.CR[6].eq ) { return 0x82198BD4;  }
		/* 82198BC0h case   28:*/		return 0x82198BC4;
		  /* 82198BC4h */ case   29:  		/* cmplwi CR6, R11, 110 */
		/* 82198BC4h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006E);
		/* 82198BC4h case   29:*/		return 0x82198BC8;
		  /* 82198BC8h */ case   30:  		/* bc 4, CR6_EQ, 72 */
		/* 82198BC8h case   30:*/		if ( !regs.CR[6].eq ) { return 0x82198C10;  }
		/* 82198BC8h case   30:*/		return 0x82198BCC;
		  /* 82198BCCh */ case   31:  		/* rlwinm. R11, R10, 9, 31, 31 */
		/* 82198BCCh case   31:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R10);
		/* 82198BCCh case   31:*/		return 0x82198BD0;
		  /* 82198BD0h */ case   32:  		/* bc 12, CR0_EQ, 64 */
		/* 82198BD0h case   32:*/		if ( regs.CR[0].eq ) { return 0x82198C10;  }
		/* 82198BD0h case   32:*/		return 0x82198BD4;
	}
	return 0x82198BD4;
} // Block from 82198B50h-82198BD4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82198BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198BD4);
		  /* 82198BD4h */ case    0:  		/* lwz R11, <#[R15 + 8]> */
		/* 82198BD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 82198BD4h case    0:*/		return 0x82198BD8;
		  /* 82198BD8h */ case    1:  		/* rlwinm. R10, R11, 9, 31, 31 */
		/* 82198BD8h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R11);
		/* 82198BD8h case    1:*/		return 0x82198BDC;
		  /* 82198BDCh */ case    2:  		/* bc 4, CR0_EQ, 52 */
		/* 82198BDCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x82198C10;  }
		/* 82198BDCh case    2:*/		return 0x82198BE0;
		  /* 82198BE0h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 82198BE0h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 82198BE0h case    3:*/		return 0x82198BE4;
		  /* 82198BE4h */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 82198BE4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 82198BE4h case    4:*/		return 0x82198BE8;
		  /* 82198BE8h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 82198BE8h case    5:*/		if ( regs.CR[6].eq ) { return 0x82198BF8;  }
		/* 82198BE8h case    5:*/		return 0x82198BEC;
		  /* 82198BECh */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 82198BECh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 82198BECh case    6:*/		return 0x82198BF0;
		  /* 82198BF0h */ case    7:  		/* mr R11, R18 */
		/* 82198BF0h case    7:*/		regs.R11 = regs.R18;
		/* 82198BF0h case    7:*/		return 0x82198BF4;
		  /* 82198BF4h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 82198BF4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82198BFC;  }
		/* 82198BF4h case    8:*/		return 0x82198BF8;
	}
	return 0x82198BF8;
} // Block from 82198BD4h-82198BF8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82198BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198BF8);
		  /* 82198BF8h */ case    0:  		/* mr R11, R19 */
		/* 82198BF8h case    0:*/		regs.R11 = regs.R19;
		/* 82198BF8h case    0:*/		return 0x82198BFC;
	}
	return 0x82198BFC;
} // Block from 82198BF8h-82198BFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82198BFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198BFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198BFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198BFC);
		  /* 82198BFCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82198BFCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82198BFCh case    0:*/		return 0x82198C00;
		  /* 82198C00h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82198C00h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82198C10;  }
		/* 82198C00h case    1:*/		return 0x82198C04;
		  /* 82198C04h */ case    2:  		/* mr R4, R15 */
		/* 82198C04h case    2:*/		regs.R4 = regs.R15;
		/* 82198C04h case    2:*/		return 0x82198C08;
		  /* 82198C08h */ case    3:  		/* mr R3, R21 */
		/* 82198C08h case    3:*/		regs.R3 = regs.R21;
		/* 82198C08h case    3:*/		return 0x82198C0C;
		  /* 82198C0Ch */ case    4:  		/* bl 122428 */
		/* 82198C0Ch case    4:*/		regs.LR = 0x82198C10; return 0x821B6A48;
		/* 82198C0Ch case    4:*/		return 0x82198C10;
	}
	return 0x82198C10;
} // Block from 82198BFCh-82198C10h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82198C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198C10);
		  /* 82198C10h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 82198C10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82198C10h case    0:*/		return 0x82198C14;
		  /* 82198C14h */ case    1:  		/* cmplw CR6, R11, R28 */
		/* 82198C14h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R28);
		/* 82198C14h case    1:*/		return 0x82198C18;
		  /* 82198C18h */ case    2:  		/* bc 4, CR6_EQ, -1376 */
		/* 82198C18h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821986B8;  }
		/* 82198C18h case    2:*/		return 0x82198C1C;
		  /* 82198C1Ch */ case    3:  		/* addi R25, R28, 8 */
		/* 82198C1Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R28,0x8);
		/* 82198C1Ch case    3:*/		return 0x82198C20;
		  /* 82198C20h */ case    4:  		/* b -1384 */
		/* 82198C20h case    4:*/		return 0x821986B8;
		/* 82198C20h case    4:*/		return 0x82198C24;
	}
	return 0x82198C24;
} // Block from 82198C10h-82198C24h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82198C24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198C24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198C24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198C24);
		  /* 82198C24h */ case    0:  		/* mr R3, R14 */
		/* 82198C24h case    0:*/		regs.R3 = regs.R14;
		/* 82198C24h case    0:*/		return 0x82198C28;
		  /* 82198C28h */ case    1:  		/* bl -213672 */
		/* 82198C28h case    1:*/		regs.LR = 0x82198C2C; return 0x82164980;
		/* 82198C28h case    1:*/		return 0x82198C2C;
		  /* 82198C2Ch */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198C2Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198C2Ch case    2:*/		return 0x82198C30;
		  /* 82198C30h */ case    3:  		/* bc 12, CR0_EQ, -5352 */
		/* 82198C30h case    3:*/		if ( regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198C30h case    3:*/		return 0x82198C34;
		  /* 82198C34h */ case    4:  		/* mr R4, R14 */
		/* 82198C34h case    4:*/		regs.R4 = regs.R14;
		/* 82198C34h case    4:*/		return 0x82198C38;
	}
	return 0x82198C38;
} // Block from 82198C24h-82198C38h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82198C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198C38);
		  /* 82198C38h */ case    0:  		/* mr R3, R21 */
		/* 82198C38h case    0:*/		regs.R3 = regs.R21;
		/* 82198C38h case    0:*/		return 0x82198C3C;
		  /* 82198C3Ch */ case    1:  		/* li R5, 0 */
		/* 82198C3Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82198C3Ch case    1:*/		return 0x82198C40;
		  /* 82198C40h */ case    2:  		/* li R6, 1 */
		/* 82198C40h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82198C40h case    2:*/		return 0x82198C44;
		  /* 82198C44h */ case    3:  		/* bl 599940 */
		/* 82198C44h case    3:*/		regs.LR = 0x82198C48; return 0x8222B3C8;
		/* 82198C44h case    3:*/		return 0x82198C48;
		  /* 82198C48h */ case    4:  		/* b -5376 */
		/* 82198C48h case    4:*/		return 0x82197748;
		/* 82198C48h case    4:*/		return 0x82198C4C;
	}
	return 0x82198C4C;
} // Block from 82198C38h-82198C4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82198C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198C4C);
		  /* 82198C4Ch */ case    0:  		/* rlwinm. R11, R31, 27, 31, 31 */
		/* 82198C4Ch case    0:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R31);
		/* 82198C4Ch case    0:*/		return 0x82198C50;
		  /* 82198C50h */ case    1:  		/* bc 4, CR0_EQ, -5384 */
		/* 82198C50h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198C50h case    1:*/		return 0x82198C54;
		  /* 82198C54h */ case    2:  		/* rlwinm. R11, R31, 7, 31, 31 */
		/* 82198C54h case    2:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R31);
		/* 82198C54h case    2:*/		return 0x82198C58;
		  /* 82198C58h */ case    3:  		/* bc 4, CR0_EQ, -5392 */
		/* 82198C58h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198C58h case    3:*/		return 0x82198C5C;
		  /* 82198C5Ch */ case    4:  		/* lwz R30, <#[R14 + 4]> */
		/* 82198C5Ch case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R14 + 0x00000004) );
		/* 82198C5Ch case    4:*/		return 0x82198C60;
		  /* 82198C60h */ case    5:  		/* mr R29, R18 */
		/* 82198C60h case    5:*/		regs.R29 = regs.R18;
		/* 82198C60h case    5:*/		return 0x82198C64;
		  /* 82198C64h */ case    6:  		/* mr R28, R18 */
		/* 82198C64h case    6:*/		regs.R28 = regs.R18;
		/* 82198C64h case    6:*/		return 0x82198C68;
		  /* 82198C68h */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 82198C68h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82198C68h case    7:*/		return 0x82198C6C;
		  /* 82198C6Ch */ case    8:  		/* bc 12, CR6_EQ, 1528 */
		/* 82198C6Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x82199264;  }
		/* 82198C6Ch case    8:*/		return 0x82198C70;
		  /* 82198C70h */ case    9:  		/* lwz R31, <#[R30 + 16]> */
		/* 82198C70h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 82198C70h case    9:*/		return 0x82198C74;
		  /* 82198C74h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 82198C74h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82198C74h case   10:*/		return 0x82198C78;
		  /* 82198C78h */ case   11:  		/* bc 12, CR6_EQ, 108 */
		/* 82198C78h case   11:*/		if ( regs.CR[6].eq ) { return 0x82198CE4;  }
		/* 82198C78h case   11:*/		return 0x82198C7C;
		  /* 82198C7Ch */ case   12:  		/* lwz R11, <#[R30]> */
		/* 82198C7Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82198C7Ch case   12:*/		return 0x82198C80;
		  /* 82198C80h */ case   13:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82198C80h case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82198C80h case   13:*/		return 0x82198C84;
		  /* 82198C84h */ case   14:  		/* bc 12, CR0_EQ, 96 */
		/* 82198C84h case   14:*/		if ( regs.CR[0].eq ) { return 0x82198CE4;  }
		/* 82198C84h case   14:*/		return 0x82198C88;
		  /* 82198C88h */ case   15:  		/* lwz R11, <#[R31 + 8]> */
		/* 82198C88h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82198C88h case   15:*/		return 0x82198C8C;
		  /* 82198C8Ch */ case   16:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82198C8Ch case   16:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82198C8Ch case   16:*/		return 0x82198C90;
		  /* 82198C90h */ case   17:  		/* cmplwi CR6, R11, 128 */
		/* 82198C90h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 82198C90h case   17:*/		return 0x82198C94;
		  /* 82198C94h */ case   18:  		/* bc 4, CR6_EQ, -5452 */
		/* 82198C94h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82197748;  }
		/* 82198C94h case   18:*/		return 0x82198C98;
		  /* 82198C98h */ case   19:  		/* lwz R7, <#[R31 + 44]> */
		/* 82198C98h case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000002C) );
		/* 82198C98h case   19:*/		return 0x82198C9C;
		  /* 82198C9Ch */ case   20:  		/* stb R19, <#[R1 + 84]> */
		/* 82198C9Ch case   20:*/		cpu::mem::store8( regs, regs.R19, (uint32)(regs.R1 + 0x00000054) );
		/* 82198C9Ch case   20:*/		return 0x82198CA0;
		  /* 82198CA0h */ case   21:  		/* cmplw CR6, R7, R30 */
		/* 82198CA0h case   21:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R30);
		/* 82198CA0h case   21:*/		return 0x82198CA4;
		  /* 82198CA4h */ case   22:  		/* bc 4, CR6_EQ, 8 */
		/* 82198CA4h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82198CAC;  }
		/* 82198CA4h case   22:*/		return 0x82198CA8;
		  /* 82198CA8h */ case   23:  		/* lwz R7, <#[R31 + 48]> */
		/* 82198CA8h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000030) );
		/* 82198CA8h case   23:*/		return 0x82198CAC;
	}
	return 0x82198CAC;
} // Block from 82198C4Ch-82198CACh (24 instructions)

//////////////////////////////////////////////////////
// Block at 82198CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198CAC);
		  /* 82198CACh */ case    0:  		/* addi R8, R1, 240 */
		/* 82198CACh case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xF0);
		/* 82198CACh case    0:*/		return 0x82198CB0;
		  /* 82198CB0h */ case    1:  		/* mr R6, R30 */
		/* 82198CB0h case    1:*/		regs.R6 = regs.R30;
		/* 82198CB0h case    1:*/		return 0x82198CB4;
		  /* 82198CB4h */ case    2:  		/* mr R5, R14 */
		/* 82198CB4h case    2:*/		regs.R5 = regs.R14;
		/* 82198CB4h case    2:*/		return 0x82198CB8;
		  /* 82198CB8h */ case    3:  		/* mr R4, R31 */
		/* 82198CB8h case    3:*/		regs.R4 = regs.R31;
		/* 82198CB8h case    3:*/		return 0x82198CBC;
		  /* 82198CBCh */ case    4:  		/* mr R3, R21 */
		/* 82198CBCh case    4:*/		regs.R3 = regs.R21;
		/* 82198CBCh case    4:*/		return 0x82198CC0;
		  /* 82198CC0h */ case    5:  		/* bl -10048 */
		/* 82198CC0h case    5:*/		regs.LR = 0x82198CC4; return 0x82196580;
		/* 82198CC0h case    5:*/		return 0x82198CC4;
		  /* 82198CC4h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198CC4h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198CC4h case    6:*/		return 0x82198CC8;
		  /* 82198CC8h */ case    7:  		/* bc 12, CR0_EQ, -5504 */
		/* 82198CC8h case    7:*/		if ( regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198CC8h case    7:*/		return 0x82198CCC;
		  /* 82198CCCh */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 82198CCCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82198CCCh case    8:*/		return 0x82198CD0;
		  /* 82198CD0h */ case    9:  		/* addi R28, R28, 1 */
		/* 82198CD0h case    9:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82198CD0h case    9:*/		return 0x82198CD4;
		  /* 82198CD4h */ case   10:  		/* rlwinm R11, R11, 0, 15, 17 */
		/* 82198CD4h case   10:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R11);
		/* 82198CD4h case   10:*/		return 0x82198CD8;
		  /* 82198CD8h */ case   11:  		/* cmplwi CR6, R11, 16384 */
		/* 82198CD8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00004000);
		/* 82198CD8h case   11:*/		return 0x82198CDC;
		  /* 82198CDCh */ case   12:  		/* bc 4, CR6_EQ, 8 */
		/* 82198CDCh case   12:*/		if ( !regs.CR[6].eq ) { return 0x82198CE4;  }
		/* 82198CDCh case   12:*/		return 0x82198CE0;
		  /* 82198CE0h */ case   13:  		/* addi R29, R29, 1 */
		/* 82198CE0h case   13:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82198CE0h case   13:*/		return 0x82198CE4;
	}
	return 0x82198CE4;
} // Block from 82198CACh-82198CE4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82198CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198CE4);
		  /* 82198CE4h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 82198CE4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 82198CE4h case    0:*/		return 0x82198CE8;
		  /* 82198CE8h */ case    1:  		/* b -128 */
		/* 82198CE8h case    1:*/		return 0x82198C68;
		/* 82198CE8h case    1:*/		return 0x82198CEC;
	}
	return 0x82198CEC;
} // Block from 82198CE4h-82198CECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198CEC);
		  /* 82198CECh */ case    0:  		/* rlwinm. R11, R31, 27, 31, 31 */
		/* 82198CECh case    0:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R31);
		/* 82198CECh case    0:*/		return 0x82198CF0;
		  /* 82198CF0h */ case    1:  		/* bc 4, CR0_EQ, -5544 */
		/* 82198CF0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198CF0h case    1:*/		return 0x82198CF4;
		  /* 82198CF4h */ case    2:  		/* rlwinm. R11, R31, 7, 31, 31 */
		/* 82198CF4h case    2:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R31);
		/* 82198CF4h case    2:*/		return 0x82198CF8;
		  /* 82198CF8h */ case    3:  		/* bc 4, CR0_EQ, -5552 */
		/* 82198CF8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82197748;  }
		/* 82198CF8h case    3:*/		return 0x82198CFC;
		  /* 82198CFCh */ case    4:  		/* mr R23, R18 */
		/* 82198CFCh case    4:*/		regs.R23 = regs.R18;
		/* 82198CFCh case    4:*/		return 0x82198D00;
		  /* 82198D00h */ case    5:  		/* addi R25, R14, 44 */
		/* 82198D00h case    5:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R14,0x2C);
		/* 82198D00h case    5:*/		return 0x82198D04;
		  /* 82198D04h */ case    6:  		/* addi R27, R14, 48 */
		/* 82198D04h case    6:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R14,0x30);
		/* 82198D04h case    6:*/		return 0x82198D08;
		  /* 82198D08h */ case    7:  		/* lwz R11, <#[R14 + 8]> */
		/* 82198D08h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82198D08h case    7:*/		return 0x82198D0C;
		  /* 82198D0Ch */ case    8:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 82198D0Ch case    8:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 82198D0Ch case    8:*/		return 0x82198D10;
		  /* 82198D10h */ case    9:  		/* cmplw CR6, R23, R11 */
		/* 82198D10h case    9:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R11);
		/* 82198D10h case    9:*/		return 0x82198D14;
		  /* 82198D14h */ case   10:  		/* bc 4, CR6_LT, -184 */
		/* 82198D14h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82198C5C;  }
		/* 82198D14h case   10:*/		return 0x82198D18;
		  /* 82198D18h */ case   11:  		/* lwz R22, <#[R25]> */
		/* 82198D18h case   11:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R25 + 0x00000000) );
		/* 82198D18h case   11:*/		return 0x82198D1C;
		  /* 82198D1Ch */ case   12:  		/* lwz R6, <#[R22]> */
		/* 82198D1Ch case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R22 + 0x00000000) );
		/* 82198D1Ch case   12:*/		return 0x82198D20;
		  /* 82198D20h */ case   13:  		/* rlwinm. R11, R6, 0, 27, 31 */
		/* 82198D20h case   13:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R6);
		/* 82198D20h case   13:*/		return 0x82198D24;
		  /* 82198D24h */ case   14:  		/* bc 4, CR0_EQ, 1328 */
		/* 82198D24h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82199254;  }
		/* 82198D24h case   14:*/		return 0x82198D28;
		  /* 82198D28h */ case   15:  		/* lwz R9, <#[R27]> */
		/* 82198D28h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 82198D28h case   15:*/		return 0x82198D2C;
		  /* 82198D2Ch */ case   16:  		/* lwz R26, <#[R22 + 12]> */
		/* 82198D2Ch case   16:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R22 + 0x0000000C) );
		/* 82198D2Ch case   16:*/		return 0x82198D30;
		  /* 82198D30h */ case   17:  		/* stw R9, <#[R1 + 80]> */
		/* 82198D30h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82198D30h case   17:*/		return 0x82198D34;
		  /* 82198D34h */ case   18:  		/* lwz R11, <#[R26 + 4]> */
		/* 82198D34h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82198D34h case   18:*/		return 0x82198D38;
		  /* 82198D38h */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 82198D38h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82198D38h case   19:*/		return 0x82198D3C;
		  /* 82198D3Ch */ case   20:  		/* bc 12, CR6_EQ, 40 */
		/* 82198D3Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x82198D64;  }
		/* 82198D3Ch case   20:*/		return 0x82198D40;
		  /* 82198D40h */ case   21:  		/* lwz R10, <#[R11 + 16]> */
		/* 82198D40h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82198D40h case   21:*/		return 0x82198D44;
		  /* 82198D44h */ case   22:  		/* cmplwi CR6, R10, 0 */
		/* 82198D44h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82198D44h case   22:*/		return 0x82198D48;
		  /* 82198D48h */ case   23:  		/* bc 12, CR6_EQ, 12 */
		/* 82198D48h case   23:*/		if ( regs.CR[6].eq ) { return 0x82198D54;  }
		/* 82198D48h case   23:*/		return 0x82198D4C;
		  /* 82198D4Ch */ case   24:  		/* cmplw CR6, R10, R14 */
		/* 82198D4Ch case   24:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R14);
		/* 82198D4Ch case   24:*/		return 0x82198D50;
		  /* 82198D50h */ case   25:  		/* bc 4, CR6_EQ, 12 */
		/* 82198D50h case   25:*/		if ( !regs.CR[6].eq ) { return 0x82198D5C;  }
		/* 82198D50h case   25:*/		return 0x82198D54;
	}
	return 0x82198D54;
} // Block from 82198CECh-82198D54h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82198D54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198D54);
		  /* 82198D54h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82198D54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82198D54h case    0:*/		return 0x82198D58;
		  /* 82198D58h */ case    1:  		/* b -32 */
		/* 82198D58h case    1:*/		return 0x82198D38;
		/* 82198D58h case    1:*/		return 0x82198D5C;
	}
	return 0x82198D5C;
} // Block from 82198D54h-82198D5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198D5C);
		  /* 82198D5Ch */ case    0:  		/* mr R11, R19 */
		/* 82198D5Ch case    0:*/		regs.R11 = regs.R19;
		/* 82198D5Ch case    0:*/		return 0x82198D60;
		  /* 82198D60h */ case    1:  		/* b 8 */
		/* 82198D60h case    1:*/		return 0x82198D68;
		/* 82198D60h case    1:*/		return 0x82198D64;
	}
	return 0x82198D64;
} // Block from 82198D5Ch-82198D64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198D64);
		  /* 82198D64h */ case    0:  		/* mr R11, R18 */
		/* 82198D64h case    0:*/		regs.R11 = regs.R18;
		/* 82198D64h case    0:*/		return 0x82198D68;
	}
	return 0x82198D68;
} // Block from 82198D64h-82198D68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82198D68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198D68);
		  /* 82198D68h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82198D68h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82198D68h case    0:*/		return 0x82198D6C;
		  /* 82198D6Ch */ case    1:  		/* bc 4, CR0_EQ, 1256 */
		/* 82198D6Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82199254;  }
		/* 82198D6Ch case    1:*/		return 0x82198D70;
		  /* 82198D70h */ case    2:  		/* lwz R7, <#[R26 + 8]> */
		/* 82198D70h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R26 + 0x00000008) );
		/* 82198D70h case    2:*/		return 0x82198D74;
		  /* 82198D74h */ case    3:  		/* rlwinm. R11, R7, 9, 31, 31 */
		/* 82198D74h case    3:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R7);
		/* 82198D74h case    3:*/		return 0x82198D78;
		  /* 82198D78h */ case    4:  		/* bc 4, CR0_EQ, 1244 */
		/* 82198D78h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82199254;  }
		/* 82198D78h case    4:*/		return 0x82198D7C;
		  /* 82198D7Ch */ case    5:  		/* rlwinm R11, R7, 25, 25, 31 */
		/* 82198D7Ch case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R7);
		/* 82198D7Ch case    5:*/		return 0x82198D80;
		  /* 82198D80h */ case    6:  		/* cmplwi CR6, R11, 110 */
		/* 82198D80h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006E);
		/* 82198D80h case    6:*/		return 0x82198D84;
		  /* 82198D84h */ case    7:  		/* bc 4, CR6_EQ, 1024 */
		/* 82198D84h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82199184;  }
		/* 82198D84h case    7:*/		return 0x82198D88;
		  /* 82198D88h */ case    8:  		/* lwz R11, <#[R9 + 12]> */
		/* 82198D88h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 82198D88h case    8:*/		return 0x82198D8C;
		  /* 82198D8Ch */ case    9:  		/* cmplw CR6, R11, R26 */
		/* 82198D8Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 82198D8Ch case    9:*/		return 0x82198D90;
		  /* 82198D90h */ case   10:  		/* bc 12, CR6_EQ, 1220 */
		/* 82198D90h case   10:*/		if ( regs.CR[6].eq ) { return 0x82199254;  }
		/* 82198D90h case   10:*/		return 0x82198D94;
		  /* 82198D94h */ case   11:  		/* rlwinm. R8, R6, 7, 29, 31 */
		/* 82198D94h case   11:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R8,regs.R6);
		/* 82198D94h case   11:*/		return 0x82198D98;
		  /* 82198D98h */ case   12:  		/* mr R9, R18 */
		/* 82198D98h case   12:*/		regs.R9 = regs.R18;
		/* 82198D98h case   12:*/		return 0x82198D9C;
		  /* 82198D9Ch */ case   13:  		/* mr R11, R18 */
		/* 82198D9Ch case   13:*/		regs.R11 = regs.R18;
		/* 82198D9Ch case   13:*/		return 0x82198DA0;
		  /* 82198DA0h */ case   14:  		/* bc 12, CR0_EQ, 44 */
		/* 82198DA0h case   14:*/		if ( regs.CR[0].eq ) { return 0x82198DCC;  }
		/* 82198DA0h case   14:*/		return 0x82198DA4;
		  /* 82198DA4h */ case   15:  		/* mr R10, R18 */
		/* 82198DA4h case   15:*/		regs.R10 = regs.R18;
		/* 82198DA4h case   15:*/		return 0x82198DA8;
		  /* 82198DA8h */ case   16:  		/* rlwinm R5, R6, 27, 24, 31 */
		/* 82198DA8h case   16:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R5,regs.R6);
		/* 82198DA8h case   16:*/		return 0x82198DAC;
		  /* 82198DACh */ case   17:  		/* addi R11, R11, 1 */
		/* 82198DACh case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82198DACh case   17:*/		return 0x82198DB0;
		  /* 82198DB0h */ case   18:  		/* srw R5, R5, R10 */
		/* 82198DB0h case   18:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R5,regs.R10);
		/* 82198DB0h case   18:*/		return 0x82198DB4;
		  /* 82198DB4h */ case   19:  		/* rlwinm R5, R5, 0, 30, 31 */
		/* 82198DB4h case   19:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R5);
		/* 82198DB4h case   19:*/		return 0x82198DB8;
		  /* 82198DB8h */ case   20:  		/* addi R10, R10, 2 */
		/* 82198DB8h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82198DB8h case   20:*/		return 0x82198DBC;
		  /* 82198DBCh */ case   21:  		/* slw R5, R19, R5 */
		/* 82198DBCh case   21:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R19,regs.R5);
		/* 82198DBCh case   21:*/		return 0x82198DC0;
		  /* 82198DC0h */ case   22:  		/* or R9, R5, R9 */
		/* 82198DC0h case   22:*/		cpu::op::or<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 82198DC0h case   22:*/		return 0x82198DC4;
		  /* 82198DC4h */ case   23:  		/* cmplw CR6, R11, R8 */
		/* 82198DC4h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82198DC4h case   23:*/		return 0x82198DC8;
		  /* 82198DC8h */ case   24:  		/* bc 12, CR6_LT, -32 */
		/* 82198DC8h case   24:*/		if ( regs.CR[6].lt ) { return 0x82198DA8;  }
		/* 82198DC8h case   24:*/		return 0x82198DCC;
	}
	return 0x82198DCC;
} // Block from 82198D68h-82198DCCh (25 instructions)

//////////////////////////////////////////////////////
// Block at 82198DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198DCC);
		  /* 82198DCCh */ case    0:  		/* rlwinm R11, R7, 31, 28, 31 */
		/* 82198DCCh case    0:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R11,regs.R7);
		/* 82198DCCh case    0:*/		return 0x82198DD0;
		  /* 82198DD0h */ case    1:  		/* cmplw CR6, R9, R11 */
		/* 82198DD0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82198DD0h case    1:*/		return 0x82198DD4;
		  /* 82198DD4h */ case    2:  		/* bc 4, CR6_EQ, 1152 */
		/* 82198DD4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82199254;  }
		/* 82198DD4h case    2:*/		return 0x82198DD8;
		  /* 82198DD8h */ case    3:  		/* rlwinm R11, R7, 18, 29, 31 */
		/* 82198DD8h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R7);
		/* 82198DD8h case    3:*/		return 0x82198DDC;
		  /* 82198DDCh */ case    4:  		/* rlwinm R10, R7, 13, 29, 31 */
		/* 82198DDCh case    4:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R10,regs.R7);
		/* 82198DDCh case    4:*/		return 0x82198DE0;
		  /* 82198DE0h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 82198DE0h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82198DE0h case    5:*/		return 0x82198DE4;
		  /* 82198DE4h */ case    6:  		/* bc 4, CR6_EQ, 1136 */
		/* 82198DE4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82199254;  }
		/* 82198DE4h case    6:*/		return 0x82198DE8;
		  /* 82198DE8h */ case    7:  		/* cmplw CR6, R8, R11 */
		/* 82198DE8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 82198DE8h case    7:*/		return 0x82198DEC;
		  /* 82198DECh */ case    8:  		/* bc 4, CR6_EQ, 1128 */
		/* 82198DECh case    8:*/		if ( !regs.CR[6].eq ) { return 0x82199254;  }
		/* 82198DECh case    8:*/		return 0x82198DF0;
		  /* 82198DF0h */ case    9:  		/* lwz R11, <#[R14 + 4]> */
		/* 82198DF0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 82198DF0h case    9:*/		return 0x82198DF4;
		  /* 82198DF4h */ case   10:  		/* addi R24, R14, 4 */
		/* 82198DF4h case   10:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R14,0x4);
		/* 82198DF4h case   10:*/		return 0x82198DF8;
		  /* 82198DF8h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 82198DF8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82198DF8h case   11:*/		return 0x82198DFC;
		  /* 82198DFCh */ case   12:  		/* bc 12, CR6_EQ, 52 */
		/* 82198DFCh case   12:*/		if ( regs.CR[6].eq ) { return 0x82198E30;  }
		/* 82198DFCh case   12:*/		return 0x82198E00;
		  /* 82198E00h */ case   13:  		/* lwz R10, <#[R11 + 16]> */
		/* 82198E00h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82198E00h case   13:*/		return 0x82198E04;
		  /* 82198E04h */ case   14:  		/* cmplwi CR6, R10, 0 */
		/* 82198E04h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82198E04h case   14:*/		return 0x82198E08;
		  /* 82198E08h */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 82198E08h case   15:*/		if ( regs.CR[6].eq ) { return 0x82198E28;  }
		/* 82198E08h case   15:*/		return 0x82198E0C;
		  /* 82198E0Ch */ case   16:  		/* lwz R9, <#[R10 + 8]> */
		/* 82198E0Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 82198E0Ch case   16:*/		return 0x82198E10;
		  /* 82198E10h */ case   17:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 82198E10h case   17:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 82198E10h case   17:*/		return 0x82198E14;
		  /* 82198E14h */ case   18:  		/* cmplwi CR6, R9, 14080 */
		/* 82198E14h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003700);
		/* 82198E14h case   18:*/		return 0x82198E18;
		  /* 82198E18h */ case   19:  		/* bc 4, CR6_EQ, 16 */
		/* 82198E18h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82198E28;  }
		/* 82198E18h case   19:*/		return 0x82198E1C;
		  /* 82198E1Ch */ case   20:  		/* lwz R9, <#[R11]> */
		/* 82198E1Ch case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82198E1Ch case   20:*/		return 0x82198E20;
		  /* 82198E20h */ case   21:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 82198E20h case   21:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 82198E20h case   21:*/		return 0x82198E24;
		  /* 82198E24h */ case   22:  		/* bc 4, CR0_EQ, 16 */
		/* 82198E24h case   22:*/		if ( !regs.CR[0].eq ) { return 0x82198E34;  }
		/* 82198E24h case   22:*/		return 0x82198E28;
	}
	return 0x82198E28;
} // Block from 82198DCCh-82198E28h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82198E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198E28);
		  /* 82198E28h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 82198E28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82198E28h case    0:*/		return 0x82198E2C;
		  /* 82198E2Ch */ case    1:  		/* b -52 */
		/* 82198E2Ch case    1:*/		return 0x82198DF8;
		/* 82198E2Ch case    1:*/		return 0x82198E30;
	}
	return 0x82198E30;
} // Block from 82198E28h-82198E30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198E30);
		  /* 82198E30h */ case    0:  		/* mr R10, R18 */
		/* 82198E30h case    0:*/		regs.R10 = regs.R18;
		/* 82198E30h case    0:*/		return 0x82198E34;
	}
	return 0x82198E34;
} // Block from 82198E30h-82198E34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82198E34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198E34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198E34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198E34);
		  /* 82198E34h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 82198E34h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82198E34h case    0:*/		return 0x82198E38;
		  /* 82198E38h */ case    1:  		/* bc 4, CR6_EQ, 1052 */
		/* 82198E38h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82199254;  }
		/* 82198E38h case    1:*/		return 0x82198E3C;
		  /* 82198E3Ch */ case    2:  		/* li R7, 0 */
		/* 82198E3Ch case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82198E3Ch case    2:*/		return 0x82198E40;
		  /* 82198E40h */ case    3:  		/* li R6, 1 */
		/* 82198E40h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82198E40h case    3:*/		return 0x82198E44;
		  /* 82198E44h */ case    4:  		/* mr R5, R14 */
		/* 82198E44h case    4:*/		regs.R5 = regs.R14;
		/* 82198E44h case    4:*/		return 0x82198E48;
		  /* 82198E48h */ case    5:  		/* mr R4, R26 */
		/* 82198E48h case    5:*/		regs.R4 = regs.R26;
		/* 82198E48h case    5:*/		return 0x82198E4C;
		  /* 82198E4Ch */ case    6:  		/* mr R3, R21 */
		/* 82198E4Ch case    6:*/		regs.R3 = regs.R21;
		/* 82198E4Ch case    6:*/		return 0x82198E50;
		  /* 82198E50h */ case    7:  		/* bl 609312 */
		/* 82198E50h case    7:*/		regs.LR = 0x82198E54; return 0x8222DA70;
		/* 82198E50h case    7:*/		return 0x82198E54;
		  /* 82198E54h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198E54h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198E54h case    8:*/		return 0x82198E58;
		  /* 82198E58h */ case    9:  		/* bc 12, CR0_EQ, 1020 */
		/* 82198E58h case    9:*/		if ( regs.CR[0].eq ) { return 0x82199254;  }
		/* 82198E58h case    9:*/		return 0x82198E5C;
		  /* 82198E5Ch */ case   10:  		/* lwz R11, <#[R22]> */
		/* 82198E5Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82198E5Ch case   10:*/		return 0x82198E60;
		  /* 82198E60h */ case   11:  		/* mr R29, R18 */
		/* 82198E60h case   11:*/		regs.R29 = regs.R18;
		/* 82198E60h case   11:*/		return 0x82198E64;
		  /* 82198E64h */ case   12:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 82198E64h case   12:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 82198E64h case   12:*/		return 0x82198E68;
		  /* 82198E68h */ case   13:  		/* bc 12, CR0_EQ, 408 */
		/* 82198E68h case   13:*/		if ( regs.CR[0].eq ) { return 0x82199000;  }
		/* 82198E68h case   13:*/		return 0x82198E6C;
		  /* 82198E6Ch */ case   14:  		/* mr R28, R18 */
		/* 82198E6Ch case   14:*/		regs.R28 = regs.R18;
		/* 82198E6Ch case   14:*/		return 0x82198E70;
		  /* 82198E70h */ case   15:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 82198E70h case   15:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 82198E70h case   15:*/		return 0x82198E74;
		  /* 82198E74h */ case   16:  		/* srw R11, R11, R28 */
		/* 82198E74h case   16:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 82198E74h case   16:*/		return 0x82198E78;
		  /* 82198E78h */ case   17:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82198E78h case   17:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82198E78h case   17:*/		return 0x82198E7C;
		  /* 82198E7Ch */ case   18:  		/* addi R11, R11, 11 */
		/* 82198E7Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB);
		/* 82198E7Ch case   18:*/		return 0x82198E80;
		  /* 82198E80h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82198E80h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82198E80h case   19:*/		return 0x82198E84;
		  /* 82198E84h */ case   20:  		/* lwzx R11, <#[R11 + R26]> */
		/* 82198E84h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82198E84h case   20:*/		return 0x82198E88;
		  /* 82198E88h */ case   21:  		/* lwz R31, <#[R11 + 12]> */
		/* 82198E88h case   21:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 82198E88h case   21:*/		return 0x82198E8C;
		  /* 82198E8Ch */ case   22:  		/* lwz R11, <#[R31 + 8]> */
		/* 82198E8Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82198E8Ch case   22:*/		return 0x82198E90;
		  /* 82198E90h */ case   23:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 82198E90h case   23:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 82198E90h case   23:*/		return 0x82198E94;
		  /* 82198E94h */ case   24:  		/* cmplwi CR6, R10, 2304 */
		/* 82198E94h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000900);
		/* 82198E94h case   24:*/		return 0x82198E98;
		  /* 82198E98h */ case   25:  		/* bc 4, CR6_EQ, 360 */
		/* 82198E98h case   25:*/		if ( !regs.CR[6].eq ) { return 0x82199000;  }
		/* 82198E98h case   25:*/		return 0x82198E9C;
		  /* 82198E9Ch */ case   26:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82198E9Ch case   26:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82198E9Ch case   26:*/		return 0x82198EA0;
		  /* 82198EA0h */ case   27:  		/* bc 4, CR0_EQ, 352 */
		/* 82198EA0h case   27:*/		if ( !regs.CR[0].eq ) { return 0x82199000;  }
		/* 82198EA0h case   27:*/		return 0x82198EA4;
		  /* 82198EA4h */ case   28:  		/* lwz R3, <#[R31 + 52]> */
		/* 82198EA4h case   28:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 82198EA4h case   28:*/		return 0x82198EA8;
		  /* 82198EA8h */ case   29:  		/* fmr FR1, FR28 */
		/* 82198EA8h case   29:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 82198EA8h case   29:*/		return 0x82198EAC;
		  /* 82198EACh */ case   30:  		/* bl -209148 */
		/* 82198EACh case   30:*/		regs.LR = 0x82198EB0; return 0x82165DB0;
		/* 82198EACh case   30:*/		return 0x82198EB0;
		  /* 82198EB0h */ case   31:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198EB0h case   31:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198EB0h case   31:*/		return 0x82198EB4;
		  /* 82198EB4h */ case   32:  		/* bc 12, CR0_EQ, 332 */
		/* 82198EB4h case   32:*/		if ( regs.CR[0].eq ) { return 0x82199000;  }
		/* 82198EB4h case   32:*/		return 0x82198EB8;
		  /* 82198EB8h */ case   33:  		/* lwz R10, <#[R31 + 4]> */
		/* 82198EB8h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82198EB8h case   33:*/		return 0x82198EBC;
		  /* 82198EBCh */ case   34:  		/* cmplwi CR6, R10, 0 */
		/* 82198EBCh case   34:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82198EBCh case   34:*/		return 0x82198EC0;
		  /* 82198EC0h */ case   35:  		/* bc 12, CR6_EQ, 32 */
		/* 82198EC0h case   35:*/		if ( regs.CR[6].eq ) { return 0x82198EE0;  }
		/* 82198EC0h case   35:*/		return 0x82198EC4;
		  /* 82198EC4h */ case   36:  		/* lwz R11, <#[R10 + 16]> */
		/* 82198EC4h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 82198EC4h case   36:*/		return 0x82198EC8;
		  /* 82198EC8h */ case   37:  		/* cmplwi CR6, R11, 0 */
		/* 82198EC8h case   37:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82198EC8h case   37:*/		return 0x82198ECC;
		  /* 82198ECCh */ case   38:  		/* bc 12, CR6_EQ, 12 */
		/* 82198ECCh case   38:*/		if ( regs.CR[6].eq ) { return 0x82198ED8;  }
		/* 82198ECCh case   38:*/		return 0x82198ED0;
		  /* 82198ED0h */ case   39:  		/* cmplw CR6, R11, R26 */
		/* 82198ED0h case   39:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 82198ED0h case   39:*/		return 0x82198ED4;
		  /* 82198ED4h */ case   40:  		/* bc 4, CR6_EQ, 300 */
		/* 82198ED4h case   40:*/		if ( !regs.CR[6].eq ) { return 0x82199000;  }
		/* 82198ED4h case   40:*/		return 0x82198ED8;
	}
	return 0x82198ED8;
} // Block from 82198E34h-82198ED8h (41 instructions)

//////////////////////////////////////////////////////
// Block at 82198ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198ED8);
		  /* 82198ED8h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 82198ED8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82198ED8h case    0:*/		return 0x82198EDC;
		  /* 82198EDCh */ case    1:  		/* b -32 */
		/* 82198EDCh case    1:*/		return 0x82198EBC;
		/* 82198EDCh case    1:*/		return 0x82198EE0;
	}
	return 0x82198EE0;
} // Block from 82198ED8h-82198EE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82198EE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198EE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198EE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198EE0);
		  /* 82198EE0h */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 82198EE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82198EE0h case    0:*/		return 0x82198EE4;
		  /* 82198EE4h */ case    1:  		/* mr R5, R29 */
		/* 82198EE4h case    1:*/		regs.R5 = regs.R29;
		/* 82198EE4h case    1:*/		return 0x82198EE8;
		  /* 82198EE8h */ case    2:  		/* mr R3, R21 */
		/* 82198EE8h case    2:*/		regs.R3 = regs.R21;
		/* 82198EE8h case    2:*/		return 0x82198EEC;
		  /* 82198EECh */ case    3:  		/* lwz R4, <#[R1 + 80]> */
		/* 82198EECh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 82198EECh case    3:*/		return 0x82198EF0;
		  /* 82198EF0h */ case    4:  		/* stw R11, <#[R1 + 124]> */
		/* 82198EF0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 82198EF0h case    4:*/		return 0x82198EF4;
		  /* 82198EF4h */ case    5:  		/* lwz R11, <#[R31 + 48]> */
		/* 82198EF4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82198EF4h case    5:*/		return 0x82198EF8;
		  /* 82198EF8h */ case    6:  		/* stw R11, <#[R1 + 116]> */
		/* 82198EF8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 82198EF8h case    6:*/		return 0x82198EFC;
		  /* 82198EFCh */ case    7:  		/* bl 346756 */
		/* 82198EFCh case    7:*/		regs.LR = 0x82198F00; return 0x821ED980;
		/* 82198EFCh case    7:*/		return 0x82198F00;
		  /* 82198F00h */ case    8:  		/* stw R3, <#[R1 + 96]> */
		/* 82198F00h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 82198F00h case    8:*/		return 0x82198F04;
		  /* 82198F04h */ case    9:  		/* addi R6, R1, 96 */
		/* 82198F04h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 82198F04h case    9:*/		return 0x82198F08;
		  /* 82198F08h */ case   10:  		/* addi R5, R1, 116 */
		/* 82198F08h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x74);
		/* 82198F08h case   10:*/		return 0x82198F0C;
		  /* 82198F0Ch */ case   11:  		/* addi R4, R1, 124 */
		/* 82198F0Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x7C);
		/* 82198F0Ch case   11:*/		return 0x82198F10;
		  /* 82198F10h */ case   12:  		/* mr R3, R21 */
		/* 82198F10h case   12:*/		regs.R3 = regs.R21;
		/* 82198F10h case   12:*/		return 0x82198F14;
		  /* 82198F14h */ case   13:  		/* bl 27220 */
		/* 82198F14h case   13:*/		regs.LR = 0x82198F18; return 0x8219F968;
		/* 82198F14h case   13:*/		return 0x82198F18;
		  /* 82198F18h */ case   14:  		/* mr R30, R3 */
		/* 82198F18h case   14:*/		regs.R30 = regs.R3;
		/* 82198F18h case   14:*/		return 0x82198F1C;
		  /* 82198F1Ch */ case   15:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198F1Ch case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198F1Ch case   15:*/		return 0x82198F20;
		  /* 82198F20h */ case   16:  		/* bc 12, CR0_EQ, 44 */
		/* 82198F20h case   16:*/		if ( regs.CR[0].eq ) { return 0x82198F4C;  }
		/* 82198F20h case   16:*/		return 0x82198F24;
		  /* 82198F24h */ case   17:  		/* addi R10, R1, 176 */
		/* 82198F24h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xB0);
		/* 82198F24h case   17:*/		return 0x82198F28;
		  /* 82198F28h */ case   18:  		/* lwz R8, <#[R1 + 96]> */
		/* 82198F28h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 82198F28h case   18:*/		return 0x82198F2C;
		  /* 82198F2Ch */ case   19:  		/* mr R9, R14 */
		/* 82198F2Ch case   19:*/		regs.R9 = regs.R14;
		/* 82198F2Ch case   19:*/		return 0x82198F30;
		  /* 82198F30h */ case   20:  		/* lwz R6, <#[R1 + 116]> */
		/* 82198F30h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000074) );
		/* 82198F30h case   20:*/		return 0x82198F34;
		  /* 82198F34h */ case   21:  		/* mr R7, R31 */
		/* 82198F34h case   21:*/		regs.R7 = regs.R31;
		/* 82198F34h case   21:*/		return 0x82198F38;
		  /* 82198F38h */ case   22:  		/* lwz R4, <#[R1 + 124]> */
		/* 82198F38h case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 82198F38h case   22:*/		return 0x82198F3C;
		  /* 82198F3Ch */ case   23:  		/* mr R5, R31 */
		/* 82198F3Ch case   23:*/		regs.R5 = regs.R31;
		/* 82198F3Ch case   23:*/		return 0x82198F40;
		  /* 82198F40h */ case   24:  		/* mr R3, R21 */
		/* 82198F40h case   24:*/		regs.R3 = regs.R21;
		/* 82198F40h case   24:*/		return 0x82198F44;
		  /* 82198F44h */ case   25:  		/* bl 9380 */
		/* 82198F44h case   25:*/		regs.LR = 0x82198F48; return 0x8219B3E8;
		/* 82198F44h case   25:*/		return 0x82198F48;
		  /* 82198F48h */ case   26:  		/* mr R30, R3 */
		/* 82198F48h case   26:*/		regs.R30 = regs.R3;
		/* 82198F48h case   26:*/		return 0x82198F4C;
	}
	return 0x82198F4C;
} // Block from 82198EE0h-82198F4Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 82198F4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198F4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198F4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198F4C);
		  /* 82198F4Ch */ case    0:  		/* lwz R4, <#[R1 + 96]> */
		/* 82198F4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 82198F4Ch case    0:*/		return 0x82198F50;
		  /* 82198F50h */ case    1:  		/* lwz R11, <#[R4 + 12]> */
		/* 82198F50h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82198F50h case    1:*/		return 0x82198F54;
		  /* 82198F54h */ case    2:  		/* addi R10, R11, 4 */
		/* 82198F54h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82198F54h case    2:*/		return 0x82198F58;
		  /* 82198F58h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 82198F58h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82198F58h case    3:*/		return 0x82198F5C;
		  /* 82198F5Ch */ case    4:  		/* b 12 */
		/* 82198F5Ch case    4:*/		return 0x82198F68;
		/* 82198F5Ch case    4:*/		return 0x82198F60;
		  /* 82198F60h */ case    5:  		/* addi R10, R11, 8 */
		/* 82198F60h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 82198F60h case    5:*/		return 0x82198F64;
		  /* 82198F64h */ case    6:  		/* lwz R11, <#[R11 + 8]> */
		/* 82198F64h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82198F64h case    6:*/		return 0x82198F68;
	}
	return 0x82198F68;
} // Block from 82198F4Ch-82198F68h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82198F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198F68);
		  /* 82198F68h */ case    0:  		/* cmplw CR6, R11, R4 */
		/* 82198F68h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 82198F68h case    0:*/		return 0x82198F6C;
		  /* 82198F6Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82198F6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82198F60;  }
		/* 82198F6Ch case    1:*/		return 0x82198F70;
		  /* 82198F70h */ case    2:  		/* lwz R11, <#[R11 + 8]> */
		/* 82198F70h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82198F70h case    2:*/		return 0x82198F74;
		  /* 82198F74h */ case    3:  		/* li R6, 26 */
		/* 82198F74h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1A);
		/* 82198F74h case    3:*/		return 0x82198F78;
		  /* 82198F78h */ case    4:  		/* li R5, 20 */
		/* 82198F78h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x14);
		/* 82198F78h case    4:*/		return 0x82198F7C;
		  /* 82198F7Ch */ case    5:  		/* mr R3, R21 */
		/* 82198F7Ch case    5:*/		regs.R3 = regs.R21;
		/* 82198F7Ch case    5:*/		return 0x82198F80;
		  /* 82198F80h */ case    6:  		/* stw R11, <#[R10]> */
		/* 82198F80h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82198F80h case    6:*/		return 0x82198F84;
		  /* 82198F84h */ case    7:  		/* bl -213740 */
		/* 82198F84h case    7:*/		regs.LR = 0x82198F88; return 0x82164C98;
		/* 82198F84h case    7:*/		return 0x82198F88;
		  /* 82198F88h */ case    8:  		/* rlwinm. R11, R30, 0, 24, 31 */
		/* 82198F88h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R30);
		/* 82198F88h case    8:*/		return 0x82198F8C;
		  /* 82198F8Ch */ case    9:  		/* bc 12, CR0_EQ, 116 */
		/* 82198F8Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82199000;  }
		/* 82198F8Ch case    9:*/		return 0x82198F90;
		  /* 82198F90h */ case   10:  		/* li R7, 0 */
		/* 82198F90h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82198F90h case   10:*/		return 0x82198F94;
		  /* 82198F94h */ case   11:  		/* li R6, 1 */
		/* 82198F94h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82198F94h case   11:*/		return 0x82198F98;
		  /* 82198F98h */ case   12:  		/* mr R5, R26 */
		/* 82198F98h case   12:*/		regs.R5 = regs.R26;
		/* 82198F98h case   12:*/		return 0x82198F9C;
		  /* 82198F9Ch */ case   13:  		/* mr R4, R31 */
		/* 82198F9Ch case   13:*/		regs.R4 = regs.R31;
		/* 82198F9Ch case   13:*/		return 0x82198FA0;
		  /* 82198FA0h */ case   14:  		/* mr R3, R21 */
		/* 82198FA0h case   14:*/		regs.R3 = regs.R21;
		/* 82198FA0h case   14:*/		return 0x82198FA4;
		  /* 82198FA4h */ case   15:  		/* bl 608972 */
		/* 82198FA4h case   15:*/		regs.LR = 0x82198FA8; return 0x8222DA70;
		/* 82198FA4h case   15:*/		return 0x82198FA8;
		  /* 82198FA8h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198FA8h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198FA8h case   16:*/		return 0x82198FAC;
		  /* 82198FACh */ case   17:  		/* bc 12, CR0_EQ, 84 */
		/* 82198FACh case   17:*/		if ( regs.CR[0].eq ) { return 0x82199000;  }
		/* 82198FACh case   17:*/		return 0x82198FB0;
		  /* 82198FB0h */ case   18:  		/* lwz R11, <#[R1 + 80]> */
		/* 82198FB0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82198FB0h case   18:*/		return 0x82198FB4;
		  /* 82198FB4h */ case   19:  		/* mr R3, R31 */
		/* 82198FB4h case   19:*/		regs.R3 = regs.R31;
		/* 82198FB4h case   19:*/		return 0x82198FB8;
		  /* 82198FB8h */ case   20:  		/* lwz R4, <#[R11 + 12]> */
		/* 82198FB8h case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 82198FB8h case   20:*/		return 0x82198FBC;
		  /* 82198FBCh */ case   21:  		/* bl 577796 */
		/* 82198FBCh case   21:*/		regs.LR = 0x82198FC0; return 0x822260C0;
		/* 82198FBCh case   21:*/		return 0x82198FC0;
		  /* 82198FC0h */ case   22:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198FC0h case   22:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198FC0h case   22:*/		return 0x82198FC4;
		  /* 82198FC4h */ case   23:  		/* bc 4, CR0_EQ, 36 */
		/* 82198FC4h case   23:*/		if ( !regs.CR[0].eq ) { return 0x82198FE8;  }
		/* 82198FC4h case   23:*/		return 0x82198FC8;
		  /* 82198FC8h */ case   24:  		/* lwz R11, <#[R1 + 80]> */
		/* 82198FC8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82198FC8h case   24:*/		return 0x82198FCC;
		  /* 82198FCCh */ case   25:  		/* li R6, 0 */
		/* 82198FCCh case   25:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82198FCCh case   25:*/		return 0x82198FD0;
		  /* 82198FD0h */ case   26:  		/* mr R5, R31 */
		/* 82198FD0h case   26:*/		regs.R5 = regs.R31;
		/* 82198FD0h case   26:*/		return 0x82198FD4;
		  /* 82198FD4h */ case   27:  		/* mr R3, R21 */
		/* 82198FD4h case   27:*/		regs.R3 = regs.R21;
		/* 82198FD4h case   27:*/		return 0x82198FD8;
		  /* 82198FD8h */ case   28:  		/* lwz R4, <#[R11 + 12]> */
		/* 82198FD8h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 82198FD8h case   28:*/		return 0x82198FDC;
		  /* 82198FDCh */ case   29:  		/* bl 603276 */
		/* 82198FDCh case   29:*/		regs.LR = 0x82198FE0; return 0x8222C468;
		/* 82198FDCh case   29:*/		return 0x82198FE0;
		  /* 82198FE0h */ case   30:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82198FE0h case   30:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82198FE0h case   30:*/		return 0x82198FE4;
		  /* 82198FE4h */ case   31:  		/* bc 12, CR0_EQ, 28 */
		/* 82198FE4h case   31:*/		if ( regs.CR[0].eq ) { return 0x82199000;  }
		/* 82198FE4h case   31:*/		return 0x82198FE8;
	}
	return 0x82198FE8;
} // Block from 82198F68h-82198FE8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82198FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82198FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82198FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82198FE8);
		  /* 82198FE8h */ case    0:  		/* lwz R11, <#[R22]> */
		/* 82198FE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82198FE8h case    0:*/		return 0x82198FEC;
		  /* 82198FECh */ case    1:  		/* addi R29, R29, 1 */
		/* 82198FECh case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82198FECh case    1:*/		return 0x82198FF0;
		  /* 82198FF0h */ case    2:  		/* addi R28, R28, 2 */
		/* 82198FF0h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x2);
		/* 82198FF0h case    2:*/		return 0x82198FF4;
		  /* 82198FF4h */ case    3:  		/* rlwinm R10, R11, 7, 29, 31 */
		/* 82198FF4h case    3:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R11);
		/* 82198FF4h case    3:*/		return 0x82198FF8;
		  /* 82198FF8h */ case    4:  		/* cmplw CR6, R29, R10 */
		/* 82198FF8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 82198FF8h case    4:*/		return 0x82198FFC;
		  /* 82198FFCh */ case    5:  		/* bc 12, CR6_LT, -396 */
		/* 82198FFCh case    5:*/		if ( regs.CR[6].lt ) { return 0x82198E70;  }
		/* 82198FFCh case    5:*/		return 0x82199000;
	}
	return 0x82199000;
} // Block from 82198FE8h-82199000h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82199000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199000);
		  /* 82199000h */ case    0:  		/* lwz R11, <#[R22]> */
		/* 82199000h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82199000h case    0:*/		return 0x82199004;
		  /* 82199004h */ case    1:  		/* rlwinm R10, R11, 7, 29, 31 */
		/* 82199004h case    1:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R11);
		/* 82199004h case    1:*/		return 0x82199008;
		  /* 82199008h */ case    2:  		/* cmplw CR6, R29, R10 */
		/* 82199008h case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 82199008h case    2:*/		return 0x8219900C;
		  /* 8219900Ch */ case    3:  		/* bc 12, CR6_LT, 584 */
		/* 8219900Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82199254;  }
		/* 8219900Ch case    3:*/		return 0x82199010;
		  /* 82199010h */ case    4:  		/* mr R28, R18 */
		/* 82199010h case    4:*/		regs.R28 = regs.R18;
		/* 82199010h case    4:*/		return 0x82199014;
		  /* 82199014h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 82199014h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82199014h case    5:*/		return 0x82199018;
		  /* 82199018h */ case    6:  		/* bc 12, CR6_EQ, 3332 */
		/* 82199018h case    6:*/		if ( regs.CR[6].eq ) { return 0x82199D1C;  }
		/* 82199018h case    6:*/		return 0x8219901C;
		  /* 8219901Ch */ case    7:  		/* mr R27, R18 */
		/* 8219901Ch case    7:*/		regs.R27 = regs.R18;
		/* 8219901Ch case    7:*/		return 0x82199020;
		  /* 82199020h */ case    8:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 82199020h case    8:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 82199020h case    8:*/		return 0x82199024;
		  /* 82199024h */ case    9:  		/* lwz R4, <#[R1 + 80]> */
		/* 82199024h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 82199024h case    9:*/		return 0x82199028;
		  /* 82199028h */ case   10:  		/* mr R5, R28 */
		/* 82199028h case   10:*/		regs.R5 = regs.R28;
		/* 82199028h case   10:*/		return 0x8219902C;
		  /* 8219902Ch */ case   11:  		/* srw R11, R11, R27 */
		/* 8219902Ch case   11:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8219902Ch case   11:*/		return 0x82199030;
		  /* 82199030h */ case   12:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82199030h case   12:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82199030h case   12:*/		return 0x82199034;
		  /* 82199034h */ case   13:  		/* mr R3, R21 */
		/* 82199034h case   13:*/		regs.R3 = regs.R21;
		/* 82199034h case   13:*/		return 0x82199038;
		  /* 82199038h */ case   14:  		/* addi R11, R11, 11 */
		/* 82199038h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB);
		/* 82199038h case   14:*/		return 0x8219903C;
		  /* 8219903Ch */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8219903Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8219903Ch case   15:*/		return 0x82199040;
		  /* 82199040h */ case   16:  		/* lwzx R29, <#[R11 + R26]> */
		/* 82199040h case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82199040h case   16:*/		return 0x82199044;
		  /* 82199044h */ case   17:  		/* lwz R31, <#[R29 + 12]> */
		/* 82199044h case   17:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x0000000C) );
		/* 82199044h case   17:*/		return 0x82199048;
		  /* 82199048h */ case   18:  		/* lwz R11, <#[R31 + 44]> */
		/* 82199048h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82199048h case   18:*/		return 0x8219904C;
		  /* 8219904Ch */ case   19:  		/* stw R11, <#[R1 + 132]> */
		/* 8219904Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 8219904Ch case   19:*/		return 0x82199050;
		  /* 82199050h */ case   20:  		/* lwz R11, <#[R31 + 48]> */
		/* 82199050h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82199050h case   20:*/		return 0x82199054;
		  /* 82199054h */ case   21:  		/* stw R11, <#[R1 + 136]> */
		/* 82199054h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82199054h case   21:*/		return 0x82199058;
		  /* 82199058h */ case   22:  		/* bl 346408 */
		/* 82199058h case   22:*/		regs.LR = 0x8219905C; return 0x821ED980;
		/* 82199058h case   22:*/		return 0x8219905C;
		  /* 8219905Ch */ case   23:  		/* stw R3, <#[R1 + 128]> */
		/* 8219905Ch case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000080) );
		/* 8219905Ch case   23:*/		return 0x82199060;
		  /* 82199060h */ case   24:  		/* addi R6, R1, 128 */
		/* 82199060h case   24:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 82199060h case   24:*/		return 0x82199064;
		  /* 82199064h */ case   25:  		/* addi R5, R1, 136 */
		/* 82199064h case   25:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x88);
		/* 82199064h case   25:*/		return 0x82199068;
		  /* 82199068h */ case   26:  		/* addi R4, R1, 132 */
		/* 82199068h case   26:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x84);
		/* 82199068h case   26:*/		return 0x8219906C;
		  /* 8219906Ch */ case   27:  		/* mr R3, R21 */
		/* 8219906Ch case   27:*/		regs.R3 = regs.R21;
		/* 8219906Ch case   27:*/		return 0x82199070;
		  /* 82199070h */ case   28:  		/* bl 26872 */
		/* 82199070h case   28:*/		regs.LR = 0x82199074; return 0x8219F968;
		/* 82199070h case   28:*/		return 0x82199074;
		  /* 82199074h */ case   29:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82199074h case   29:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82199074h case   29:*/		return 0x82199078;
		  /* 82199078h */ case   30:  		/* bc 12, CR0_EQ, 4744 */
		/* 82199078h case   30:*/		if ( regs.CR[0].eq ) { return 0x8219A300;  }
		/* 82199078h case   30:*/		return 0x8219907C;
		  /* 8219907Ch */ case   31:  		/* lwz R11, <#[R1 + 80]> */
		/* 8219907Ch case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8219907Ch case   31:*/		return 0x82199080;
		  /* 82199080h */ case   32:  		/* mr R3, R31 */
		/* 82199080h case   32:*/		regs.R3 = regs.R31;
		/* 82199080h case   32:*/		return 0x82199084;
		  /* 82199084h */ case   33:  		/* lwz R4, <#[R11 + 12]> */
		/* 82199084h case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 82199084h case   33:*/		return 0x82199088;
		  /* 82199088h */ case   34:  		/* bl 577592 */
		/* 82199088h case   34:*/		regs.LR = 0x8219908C; return 0x822260C0;
		/* 82199088h case   34:*/		return 0x8219908C;
		  /* 8219908Ch */ case   35:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219908Ch case   35:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219908Ch case   35:*/		return 0x82199090;
		  /* 82199090h */ case   36:  		/* bc 4, CR0_EQ, 28 */
		/* 82199090h case   36:*/		if ( !regs.CR[0].eq ) { return 0x821990AC;  }
		/* 82199090h case   36:*/		return 0x82199094;
		  /* 82199094h */ case   37:  		/* lwz R11, <#[R1 + 80]> */
		/* 82199094h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82199094h case   37:*/		return 0x82199098;
		  /* 82199098h */ case   38:  		/* li R6, 0 */
		/* 82199098h case   38:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82199098h case   38:*/		return 0x8219909C;
		  /* 8219909Ch */ case   39:  		/* mr R5, R31 */
		/* 8219909Ch case   39:*/		regs.R5 = regs.R31;
		/* 8219909Ch case   39:*/		return 0x821990A0;
		  /* 821990A0h */ case   40:  		/* mr R3, R21 */
		/* 821990A0h case   40:*/		regs.R3 = regs.R21;
		/* 821990A0h case   40:*/		return 0x821990A4;
		  /* 821990A4h */ case   41:  		/* lwz R4, <#[R11 + 12]> */
		/* 821990A4h case   41:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 821990A4h case   41:*/		return 0x821990A8;
		  /* 821990A8h */ case   42:  		/* bl 609176 */
		/* 821990A8h case   42:*/		regs.LR = 0x821990AC; return 0x8222DC40;
		/* 821990A8h case   42:*/		return 0x821990AC;
	}
	return 0x821990AC;
} // Block from 82199000h-821990ACh (43 instructions)

//////////////////////////////////////////////////////
// Block at 821990ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821990AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821990AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821990AC);
		  /* 821990ACh */ case    0:  		/* lwz R4, <#[R31 + 44]> */
		/* 821990ACh case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000002C) );
		/* 821990ACh case    0:*/		return 0x821990B0;
		  /* 821990B0h */ case    1:  		/* lwz R11, <#[R1 + 132]> */
		/* 821990B0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 821990B0h case    1:*/		return 0x821990B4;
		  /* 821990B4h */ case    2:  		/* cmplw CR6, R11, R4 */
		/* 821990B4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 821990B4h case    2:*/		return 0x821990B8;
		  /* 821990B8h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 821990B8h case    3:*/		if ( regs.CR[6].eq ) { return 0x821990DC;  }
		/* 821990B8h case    3:*/		return 0x821990BC;
		  /* 821990BCh */ case    4:  		/* mr R5, R21 */
		/* 821990BCh case    4:*/		regs.R5 = regs.R21;
		/* 821990BCh case    4:*/		return 0x821990C0;
		  /* 821990C0h */ case    5:  		/* mr R3, R31 */
		/* 821990C0h case    5:*/		regs.R3 = regs.R31;
		/* 821990C0h case    5:*/		return 0x821990C4;
		  /* 821990C4h */ case    6:  		/* mr R30, R11 */
		/* 821990C4h case    6:*/		regs.R30 = regs.R11;
		/* 821990C4h case    6:*/		return 0x821990C8;
		  /* 821990C8h */ case    7:  		/* bl -133048 */
		/* 821990C8h case    7:*/		regs.LR = 0x821990CC; return 0x82178910;
		/* 821990C8h case    7:*/		return 0x821990CC;
		  /* 821990CCh */ case    8:  		/* mr R4, R30 */
		/* 821990CCh case    8:*/		regs.R4 = regs.R30;
		/* 821990CCh case    8:*/		return 0x821990D0;
		  /* 821990D0h */ case    9:  		/* mr R3, R31 */
		/* 821990D0h case    9:*/		regs.R3 = regs.R31;
		/* 821990D0h case    9:*/		return 0x821990D4;
		  /* 821990D4h */ case   10:  		/* bl -134924 */
		/* 821990D4h case   10:*/		regs.LR = 0x821990D8; return 0x821781C8;
		/* 821990D4h case   10:*/		return 0x821990D8;
		  /* 821990D8h */ case   11:  		/* stw R3, <#[R31 + 44]> */
		/* 821990D8h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821990D8h case   11:*/		return 0x821990DC;
	}
	return 0x821990DC;
} // Block from 821990ACh-821990DCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 821990DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821990DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821990DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821990DC);
		  /* 821990DCh */ case    0:  		/* lwz R4, <#[R31 + 48]> */
		/* 821990DCh case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000030) );
		/* 821990DCh case    0:*/		return 0x821990E0;
		  /* 821990E0h */ case    1:  		/* lwz R11, <#[R1 + 136]> */
		/* 821990E0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 821990E0h case    1:*/		return 0x821990E4;
		  /* 821990E4h */ case    2:  		/* cmplw CR6, R11, R4 */
		/* 821990E4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 821990E4h case    2:*/		return 0x821990E8;
		  /* 821990E8h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 821990E8h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219910C;  }
		/* 821990E8h case    3:*/		return 0x821990EC;
		  /* 821990ECh */ case    4:  		/* mr R5, R21 */
		/* 821990ECh case    4:*/		regs.R5 = regs.R21;
		/* 821990ECh case    4:*/		return 0x821990F0;
		  /* 821990F0h */ case    5:  		/* mr R3, R31 */
		/* 821990F0h case    5:*/		regs.R3 = regs.R31;
		/* 821990F0h case    5:*/		return 0x821990F4;
		  /* 821990F4h */ case    6:  		/* mr R30, R11 */
		/* 821990F4h case    6:*/		regs.R30 = regs.R11;
		/* 821990F4h case    6:*/		return 0x821990F8;
		  /* 821990F8h */ case    7:  		/* bl -133096 */
		/* 821990F8h case    7:*/		regs.LR = 0x821990FC; return 0x82178910;
		/* 821990F8h case    7:*/		return 0x821990FC;
		  /* 821990FCh */ case    8:  		/* mr R4, R30 */
		/* 821990FCh case    8:*/		regs.R4 = regs.R30;
		/* 821990FCh case    8:*/		return 0x82199100;
		  /* 82199100h */ case    9:  		/* mr R3, R31 */
		/* 82199100h case    9:*/		regs.R3 = regs.R31;
		/* 82199100h case    9:*/		return 0x82199104;
		  /* 82199104h */ case   10:  		/* bl -134972 */
		/* 82199104h case   10:*/		regs.LR = 0x82199108; return 0x821781C8;
		/* 82199104h case   10:*/		return 0x82199108;
		  /* 82199108h */ case   11:  		/* stw R3, <#[R31 + 48]> */
		/* 82199108h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82199108h case   11:*/		return 0x8219910C;
	}
	return 0x8219910C;
} // Block from 821990DCh-8219910Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219910Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219910C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219910C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219910C);
		  /* 8219910Ch */ case    0:  		/* mr R5, R21 */
		/* 8219910Ch case    0:*/		regs.R5 = regs.R21;
		/* 8219910Ch case    0:*/		return 0x82199110;
		  /* 82199110h */ case    1:  		/* lwz R4, <#[R31 + 52]> */
		/* 82199110h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000034) );
		/* 82199110h case    1:*/		return 0x82199114;
		  /* 82199114h */ case    2:  		/* mr R3, R31 */
		/* 82199114h case    2:*/		regs.R3 = regs.R31;
		/* 82199114h case    2:*/		return 0x82199118;
		  /* 82199118h */ case    3:  		/* lwz R30, <#[R1 + 128]> */
		/* 82199118h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000080) );
		/* 82199118h case    3:*/		return 0x8219911C;
		  /* 8219911Ch */ case    4:  		/* bl -133132 */
		/* 8219911Ch case    4:*/		regs.LR = 0x82199120; return 0x82178910;
		/* 8219911Ch case    4:*/		return 0x82199120;
		  /* 82199120h */ case    5:  		/* mr R4, R30 */
		/* 82199120h case    5:*/		regs.R4 = regs.R30;
		/* 82199120h case    5:*/		return 0x82199124;
		  /* 82199124h */ case    6:  		/* mr R3, R31 */
		/* 82199124h case    6:*/		regs.R3 = regs.R31;
		/* 82199124h case    6:*/		return 0x82199128;
		  /* 82199128h */ case    7:  		/* bl -135008 */
		/* 82199128h case    7:*/		regs.LR = 0x8219912C; return 0x821781C8;
		/* 82199128h case    7:*/		return 0x8219912C;
		  /* 8219912Ch */ case    8:  		/* stw R3, <#[R31 + 52]> */
		/* 8219912Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 8219912Ch case    8:*/		return 0x82199130;
		  /* 82199130h */ case    9:  		/* lwz R30, <#[R14]> */
		/* 82199130h case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R14 + 0x00000000) );
		/* 82199130h case    9:*/		return 0x82199134;
		  /* 82199134h */ case   10:  		/* cmplwi CR6, R30, 0 */
		/* 82199134h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82199134h case   10:*/		return 0x82199138;
		  /* 82199138h */ case   11:  		/* bc 12, CR6_EQ, 2948 */
		/* 82199138h case   11:*/		if ( regs.CR[6].eq ) { return 0x82199CBC;  }
		/* 82199138h case   11:*/		return 0x8219913C;
		  /* 8219913Ch */ case   12:  		/* lwz R11, <#[R30]> */
		/* 8219913Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8219913Ch case   12:*/		return 0x82199140;
		  /* 82199140h */ case   13:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82199140h case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82199140h case   13:*/		return 0x82199144;
		  /* 82199144h */ case   14:  		/* bc 4, CR0_EQ, 56 */
		/* 82199144h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8219917C;  }
		/* 82199144h case   14:*/		return 0x82199148;
		  /* 82199148h */ case   15:  		/* mr R3, R31 */
		/* 82199148h case   15:*/		regs.R3 = regs.R31;
		/* 82199148h case   15:*/		return 0x8219914C;
		  /* 8219914Ch */ case   16:  		/* lwz R4, <#[R30 + 12]> */
		/* 8219914Ch case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219914Ch case   16:*/		return 0x82199150;
		  /* 82199150h */ case   17:  		/* bl 577392 */
		/* 82199150h case   17:*/		regs.LR = 0x82199154; return 0x822260C0;
		/* 82199150h case   17:*/		return 0x82199154;
		  /* 82199154h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82199154h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82199154h case   18:*/		return 0x82199158;
		  /* 82199158h */ case   19:  		/* bc 4, CR0_EQ, 24 */
		/* 82199158h case   19:*/		if ( !regs.CR[0].eq ) { return 0x82199170;  }
		/* 82199158h case   19:*/		return 0x8219915C;
		  /* 8219915Ch */ case   20:  		/* li R6, 0 */
		/* 8219915Ch case   20:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8219915Ch case   20:*/		return 0x82199160;
		  /* 82199160h */ case   21:  		/* lwz R4, <#[R30 + 12]> */
		/* 82199160h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 82199160h case   21:*/		return 0x82199164;
		  /* 82199164h */ case   22:  		/* mr R5, R31 */
		/* 82199164h case   22:*/		regs.R5 = regs.R31;
		/* 82199164h case   22:*/		return 0x82199168;
		  /* 82199168h */ case   23:  		/* mr R3, R21 */
		/* 82199168h case   23:*/		regs.R3 = regs.R21;
		/* 82199168h case   23:*/		return 0x8219916C;
		  /* 8219916Ch */ case   24:  		/* bl 608980 */
		/* 8219916Ch case   24:*/		regs.LR = 0x82199170; return 0x8222DC40;
		/* 8219916Ch case   24:*/		return 0x82199170;
	}
	return 0x82199170;
} // Block from 8219910Ch-82199170h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82199170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199170);
		  /* 82199170h */ case    0:  		/* mr R4, R30 */
		/* 82199170h case    0:*/		regs.R4 = regs.R30;
		/* 82199170h case    0:*/		return 0x82199174;
		  /* 82199174h */ case    1:  		/* mr R3, R31 */
		/* 82199174h case    1:*/		regs.R3 = regs.R31;
		/* 82199174h case    1:*/		return 0x82199178;
		  /* 82199178h */ case    2:  		/* bl -135088 */
		/* 82199178h case    2:*/		regs.LR = 0x8219917C; return 0x821781C8;
		/* 82199178h case    2:*/		return 0x8219917C;
	}
	return 0x8219917C;
} // Block from 82199170h-8219917Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219917Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219917C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219917C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219917C);
		  /* 8219917Ch */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 8219917Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 8219917Ch case    0:*/		return 0x82199180;
		  /* 82199180h */ case    1:  		/* b -76 */
		/* 82199180h case    1:*/		return 0x82199134;
		/* 82199180h case    1:*/		return 0x82199184;
	}
	return 0x82199184;
} // Block from 8219917Ch-82199184h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82199184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199184);
		  /* 82199184h */ case    0:  		/* cmplwi CR6, R11, 18 */
		/* 82199184h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000012);
		/* 82199184h case    0:*/		return 0x82199188;
		  /* 82199188h */ case    1:  		/* bc 4, CR6_EQ, 204 */
		/* 82199188h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82199254;  }
		/* 82199188h case    1:*/		return 0x8219918C;
		  /* 8219918Ch */ case    2:  		/* rlwinm. R11, R7, 0, 31, 31 */
		/* 8219918Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R7);
		/* 8219918Ch case    2:*/		return 0x82199190;
		  /* 82199190h */ case    3:  		/* bc 4, CR0_EQ, 196 */
		/* 82199190h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82199254;  }
		/* 82199190h case    3:*/		return 0x82199194;
		  /* 82199194h */ case    4:  		/* lwz R3, <#[R26 + 52]> */
		/* 82199194h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x00000034) );
		/* 82199194h case    4:*/		return 0x82199198;
		  /* 82199198h */ case    5:  		/* fmr FR1, FR28 */
		/* 82199198h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 82199198h case    5:*/		return 0x8219919C;
		  /* 8219919Ch */ case    6:  		/* bl -209900 */
		/* 8219919Ch case    6:*/		regs.LR = 0x821991A0; return 0x82165DB0;
		/* 8219919Ch case    6:*/		return 0x821991A0;
		  /* 821991A0h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821991A0h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821991A0h case    7:*/		return 0x821991A4;
		  /* 821991A4h */ case    8:  		/* bc 12, CR0_EQ, 176 */
		/* 821991A4h case    8:*/		if ( regs.CR[0].eq ) { return 0x82199254;  }
		/* 821991A4h case    8:*/		return 0x821991A8;
		  /* 821991A8h */ case    9:  		/* lwz R11, <#[R14 + 8]> */
		/* 821991A8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 821991A8h case    9:*/		return 0x821991AC;
		  /* 821991ACh */ case   10:  		/* rlwinm R11, R11, 0, 15, 17 */
		/* 821991ACh case   10:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R11);
		/* 821991ACh case   10:*/		return 0x821991B0;
		  /* 821991B0h */ case   11:  		/* cmplwi CR6, R11, 16384 */
		/* 821991B0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00004000);
		/* 821991B0h case   11:*/		return 0x821991B4;
		  /* 821991B4h */ case   12:  		/* bc 4, CR6_EQ, 160 */
		/* 821991B4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82199254;  }
		/* 821991B4h case   12:*/		return 0x821991B8;
		  /* 821991B8h */ case   13:  		/* lwz R11, <#[R22]> */
		/* 821991B8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 821991B8h case   13:*/		return 0x821991BC;
		  /* 821991BCh */ case   14:  		/* lis R10, 512 */
		/* 821991BCh case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x200);
		/* 821991BCh case   14:*/		return 0x821991C0;
		  /* 821991C0h */ case   15:  		/* rlwinm R11, R11, 0, 4, 6 */
		/* 821991C0h case   15:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821991C0h case   15:*/		return 0x821991C4;
		  /* 821991C4h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 821991C4h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821991C4h case   16:*/		return 0x821991C8;
		  /* 821991C8h */ case   17:  		/* bc 4, CR6_EQ, 140 */
		/* 821991C8h case   17:*/		if ( !regs.CR[6].eq ) { return 0x82199254;  }
		/* 821991C8h case   17:*/		return 0x821991CC;
		  /* 821991CCh */ case   18:  		/* lwz R11, <#[R1 + 80]> */
		/* 821991CCh case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821991CCh case   18:*/		return 0x821991D0;
		  /* 821991D0h */ case   19:  		/* lwz R11, <#[R11 + 12]> */
		/* 821991D0h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821991D0h case   19:*/		return 0x821991D4;
		  /* 821991D4h */ case   20:  		/* cmplw CR6, R11, R26 */
		/* 821991D4h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 821991D4h case   20:*/		return 0x821991D8;
		  /* 821991D8h */ case   21:  		/* bc 12, CR6_EQ, 124 */
		/* 821991D8h case   21:*/		if ( regs.CR[6].eq ) { return 0x82199254;  }
		/* 821991D8h case   21:*/		return 0x821991DC;
		  /* 821991DCh */ case   22:  		/* li R7, 0 */
		/* 821991DCh case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821991DCh case   22:*/		return 0x821991E0;
		  /* 821991E0h */ case   23:  		/* li R6, 1 */
		/* 821991E0h case   23:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821991E0h case   23:*/		return 0x821991E4;
		  /* 821991E4h */ case   24:  		/* mr R5, R14 */
		/* 821991E4h case   24:*/		regs.R5 = regs.R14;
		/* 821991E4h case   24:*/		return 0x821991E8;
		  /* 821991E8h */ case   25:  		/* mr R4, R26 */
		/* 821991E8h case   25:*/		regs.R4 = regs.R26;
		/* 821991E8h case   25:*/		return 0x821991EC;
		  /* 821991ECh */ case   26:  		/* mr R3, R21 */
		/* 821991ECh case   26:*/		regs.R3 = regs.R21;
		/* 821991ECh case   26:*/		return 0x821991F0;
		  /* 821991F0h */ case   27:  		/* bl 608384 */
		/* 821991F0h case   27:*/		regs.LR = 0x821991F4; return 0x8222DA70;
		/* 821991F0h case   27:*/		return 0x821991F4;
		  /* 821991F4h */ case   28:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821991F4h case   28:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821991F4h case   28:*/		return 0x821991F8;
		  /* 821991F8h */ case   29:  		/* bc 12, CR0_EQ, 92 */
		/* 821991F8h case   29:*/		if ( regs.CR[0].eq ) { return 0x82199254;  }
		/* 821991F8h case   29:*/		return 0x821991FC;
		  /* 821991FCh */ case   30:  		/* lwz R11, <#[R26 + 44]> */
		/* 821991FCh case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000002C) );
		/* 821991FCh case   30:*/		return 0x82199200;
		  /* 82199200h */ case   31:  		/* addi R6, R1, 80 */
		/* 82199200h case   31:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 82199200h case   31:*/		return 0x82199204;
		  /* 82199204h */ case   32:  		/* lwz R10, <#[R26 + 48]> */
		/* 82199204h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000030) );
		/* 82199204h case   32:*/		return 0x82199208;
		  /* 82199208h */ case   33:  		/* addi R5, R1, 88 */
		/* 82199208h case   33:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 82199208h case   33:*/		return 0x8219920C;
		  /* 8219920Ch */ case   34:  		/* addi R4, R1, 108 */
		/* 8219920Ch case   34:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x6C);
		/* 8219920Ch case   34:*/		return 0x82199210;
		  /* 82199210h */ case   35:  		/* mr R3, R21 */
		/* 82199210h case   35:*/		regs.R3 = regs.R21;
		/* 82199210h case   35:*/		return 0x82199214;
		  /* 82199214h */ case   36:  		/* stw R11, <#[R1 + 108]> */
		/* 82199214h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82199214h case   36:*/		return 0x82199218;
		  /* 82199218h */ case   37:  		/* stw R10, <#[R1 + 88]> */
		/* 82199218h case   37:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82199218h case   37:*/		return 0x8219921C;
		  /* 8219921Ch */ case   38:  		/* bl 26444 */
		/* 8219921Ch case   38:*/		regs.LR = 0x82199220; return 0x8219F968;
		/* 8219921Ch case   38:*/		return 0x82199220;
		  /* 82199220h */ case   39:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82199220h case   39:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82199220h case   39:*/		return 0x82199224;
		  /* 82199224h */ case   40:  		/* bc 12, CR0_EQ, 48 */
		/* 82199224h case   40:*/		if ( regs.CR[0].eq ) { return 0x82199254;  }
		/* 82199224h case   40:*/		return 0x82199228;
		  /* 82199228h */ case   41:  		/* addi R10, R1, 172 */
		/* 82199228h case   41:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xAC);
		/* 82199228h case   41:*/		return 0x8219922C;
		  /* 8219922Ch */ case   42:  		/* lwz R8, <#[R1 + 80]> */
		/* 8219922Ch case   42:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8219922Ch case   42:*/		return 0x82199230;
		  /* 82199230h */ case   43:  		/* mr R9, R14 */
		/* 82199230h case   43:*/		regs.R9 = regs.R14;
		/* 82199230h case   43:*/		return 0x82199234;
		  /* 82199234h */ case   44:  		/* lwz R6, <#[R1 + 88]> */
		/* 82199234h case   44:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 82199234h case   44:*/		return 0x82199238;
		  /* 82199238h */ case   45:  		/* mr R7, R26 */
		/* 82199238h case   45:*/		regs.R7 = regs.R26;
		/* 82199238h case   45:*/		return 0x8219923C;
		  /* 8219923Ch */ case   46:  		/* lwz R4, <#[R1 + 108]> */
		/* 8219923Ch case   46:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000006C) );
		/* 8219923Ch case   46:*/		return 0x82199240;
		  /* 82199240h */ case   47:  		/* mr R5, R26 */
		/* 82199240h case   47:*/		regs.R5 = regs.R26;
		/* 82199240h case   47:*/		return 0x82199244;
		  /* 82199244h */ case   48:  		/* mr R3, R21 */
		/* 82199244h case   48:*/		regs.R3 = regs.R21;
		/* 82199244h case   48:*/		return 0x82199248;
		  /* 82199248h */ case   49:  		/* bl 8608 */
		/* 82199248h case   49:*/		regs.LR = 0x8219924C; return 0x8219B3E8;
		/* 82199248h case   49:*/		return 0x8219924C;
		  /* 8219924Ch */ case   50:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219924Ch case   50:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219924Ch case   50:*/		return 0x82199250;
		  /* 82199250h */ case   51:  		/* bc 4, CR0_EQ, 3168 */
		/* 82199250h case   51:*/		if ( !regs.CR[0].eq ) { return 0x82199EB0;  }
		/* 82199250h case   51:*/		return 0x82199254;
	}
	return 0x82199254;
} // Block from 82199184h-82199254h (52 instructions)

//////////////////////////////////////////////////////
// Block at 82199254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199254);
		  /* 82199254h */ case    0:  		/* addi R23, R23, 1 */
		/* 82199254h case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 82199254h case    0:*/		return 0x82199258;
		  /* 82199258h */ case    1:  		/* addi R25, R25, 4 */
		/* 82199258h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82199258h case    1:*/		return 0x8219925C;
		  /* 8219925Ch */ case    2:  		/* addi R27, R27, -4 */
		/* 8219925Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0xFFFFFFFC);
		/* 8219925Ch case    2:*/		return 0x82199260;
		  /* 82199260h */ case    3:  		/* b -1368 */
		/* 82199260h case    3:*/		return 0x82198D08;
		/* 82199260h case    3:*/		return 0x82199264;
	}
	return 0x82199264;
} // Block from 82199254h-82199264h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82199264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199264);
		  /* 82199264h */ case    0:  		/* rlwinm R11, R29, 0, 31, 31 */
		/* 82199264h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R29);
		/* 82199264h case    0:*/		return 0x82199268;
		  /* 82199268h */ case    1:  		/* rlwinm R10, R29, 31, 1, 31 */
		/* 82199268h case    1:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R29);
		/* 82199268h case    1:*/		return 0x8219926C;
		  /* 8219926Ch */ case    2:  		/* add R11, R10, R11 */
		/* 8219926Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219926Ch case    2:*/		return 0x82199270;
		  /* 82199270h */ case    3:  		/* subf R11, R29, R11 */
		/* 82199270h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82199270h case    3:*/		return 0x82199274;
		  /* 82199274h */ case    4:  		/* add R11, R11, R28 */
		/* 82199274h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 82199274h case    4:*/		return 0x82199278;
		  /* 82199278h */ case    5:  		/* addi R11, R11, 1 */
		/* 82199278h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82199278h case    5:*/		return 0x8219927C;
		  /* 8219927Ch */ case    6:  		/* cmplw CR6, R28, R11 */
		/* 8219927Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8219927Ch case    6:*/		return 0x82199280;
		  /* 82199280h */ case    7:  		/* bc 4, CR6_LT, -6968 */
		/* 82199280h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82197748;  }
		/* 82199280h case    7:*/		return 0x82199284;
		  /* 82199284h */ case    8:  		/* lwz R6, <#[R14 + 4]> */
		/* 82199284h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R14 + 0x00000004) );
		/* 82199284h case    8:*/		return 0x82199288;
		  /* 82199288h */ case    9:  		/* cmplwi CR6, R6, 0 */
		/* 82199288h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82199288h case    9:*/		return 0x8219928C;
		  /* 8219928Ch */ case   10:  		/* bc 12, CR6_EQ, -6980 */
		/* 8219928Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82197748;  }
		/* 8219928Ch case   10:*/		return 0x82199290;
		  /* 82199290h */ case   11:  		/* lwz R29, <#[R6 + 16]> */
		/* 82199290h case   11:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R6 + 0x00000010) );
		/* 82199290h case   11:*/		return 0x82199294;
		  /* 82199294h */ case   12:  		/* cmplwi CR6, R29, 0 */
		/* 82199294h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82199294h case   12:*/		return 0x82199298;
		  /* 82199298h */ case   13:  		/* bc 12, CR6_EQ, 16 */
		/* 82199298h case   13:*/		if ( regs.CR[6].eq ) { return 0x821992A8;  }
		/* 82199298h case   13:*/		return 0x8219929C;
		  /* 8219929Ch */ case   14:  		/* lwz R11, <#[R6]> */
		/* 8219929Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 8219929Ch case   14:*/		return 0x821992A0;
		  /* 821992A0h */ case   15:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821992A0h case   15:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821992A0h case   15:*/		return 0x821992A4;
		  /* 821992A4h */ case   16:  		/* bc 4, CR0_EQ, 3508 */
		/* 821992A4h case   16:*/		if ( !regs.CR[0].eq ) { return 0x8219A058;  }
		/* 821992A4h case   16:*/		return 0x821992A8;
	}
	return 0x821992A8;
} // Block from 82199264h-821992A8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821992A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821992A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821992A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821992A8);
		  /* 821992A8h */ case    0:  		/* lwz R6, <#[R6 + 8]> */
		/* 821992A8h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000008) );
		/* 821992A8h case    0:*/		return 0x821992AC;
		  /* 821992ACh */ case    1:  		/* b -36 */
		/* 821992ACh case    1:*/		return 0x82199288;
		/* 821992ACh case    1:*/		return 0x821992B0;
	}
	return 0x821992B0;
} // Block from 821992A8h-821992B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821992B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821992B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821992B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821992B0);
		  /* 821992B0h */ case    0:  		/* lwz R10, <#[R20 + 28]> */
		/* 821992B0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x0000001C) );
		/* 821992B0h case    0:*/		return 0x821992B4;
		  /* 821992B4h */ case    1:  		/* addi R11, R20, 24 */
		/* 821992B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R20,0x18);
		/* 821992B4h case    1:*/		return 0x821992B8;
		  /* 821992B8h */ case    2:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 821992B8h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 821992B8h case    2:*/		return 0x821992BC;
		  /* 821992BCh */ case    3:  		/* addic R9, R9, -1 */
		/* 821992BCh case    3:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821992BCh case    3:*/		return 0x821992C0;
		  /* 821992C0h */ case    4:  		/* subfe R9, R9, R9 */
		/* 821992C0h case    4:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821992C0h case    4:*/		return 0x821992C4;
		  /* 821992C4h */ case    5:  		/* and R10, R9, R10 */
		/* 821992C4h case    5:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821992C4h case    5:*/		return 0x821992C8;
		  /* 821992C8h */ case    6:  		/* cmplw CR6, R14, R10 */
		/* 821992C8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R14,regs.R10);
		/* 821992C8h case    6:*/		return 0x821992CC;
		  /* 821992CCh */ case    7:  		/* bc 12, CR6_EQ, -7000 */
		/* 821992CCh case    7:*/		if ( regs.CR[6].eq ) { return 0x82197774;  }
		/* 821992CCh case    7:*/		return 0x821992D0;
		  /* 821992D0h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 821992D0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821992D0h case    8:*/		return 0x821992D4;
		  /* 821992D4h */ case    9:  		/* b -6996 */
		/* 821992D4h case    9:*/		return 0x82197780;
		/* 821992D4h case    9:*/		return 0x821992D8;
	}
	return 0x821992D8;
} // Block from 821992B0h-821992D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821992D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821992D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821992D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821992D8);
		  /* 821992D8h */ case    0:  		/* mr R4, R14 */
		/* 821992D8h case    0:*/		regs.R4 = regs.R14;
		/* 821992D8h case    0:*/		return 0x821992DC;
		  /* 821992DCh */ case    1:  		/* mr R3, R21 */
		/* 821992DCh case    1:*/		regs.R3 = regs.R21;
		/* 821992DCh case    1:*/		return 0x821992E0;
		  /* 821992E0h */ case    2:  		/* bl 598896 */
		/* 821992E0h case    2:*/		regs.LR = 0x821992E4; return 0x8222B650;
		/* 821992E0h case    2:*/		return 0x821992E4;
		  /* 821992E4h */ case    3:  		/* b -7768 */
		/* 821992E4h case    3:*/		return 0x8219748C;
		/* 821992E4h case    3:*/		return 0x821992E8;
	}
	return 0x821992E8;
} // Block from 821992D8h-821992E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821992E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821992E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821992E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821992E8);
		  /* 821992E8h */ case    0:  		/* li R6, 1 */
		/* 821992E8h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821992E8h case    0:*/		return 0x821992EC;
		  /* 821992ECh */ case    1:  		/* li R5, 0 */
		/* 821992ECh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821992ECh case    1:*/		return 0x821992F0;
		  /* 821992F0h */ case    2:  		/* mr R4, R14 */
		/* 821992F0h case    2:*/		regs.R4 = regs.R14;
		/* 821992F0h case    2:*/		return 0x821992F4;
		  /* 821992F4h */ case    3:  		/* mr R3, R21 */
		/* 821992F4h case    3:*/		regs.R3 = regs.R21;
		/* 821992F4h case    3:*/		return 0x821992F8;
		  /* 821992F8h */ case    4:  		/* bl 598224 */
		/* 821992F8h case    4:*/		regs.LR = 0x821992FC; return 0x8222B3C8;
		/* 821992F8h case    4:*/		return 0x821992FC;
		  /* 821992FCh */ case    5:  		/* stb R19, <#[R1 + 84]> */
		/* 821992FCh case    5:*/		cpu::mem::store8( regs, regs.R19, (uint32)(regs.R1 + 0x00000054) );
		/* 821992FCh case    5:*/		return 0x82199300;
		  /* 82199300h */ case    6:  		/* b -7796 */
		/* 82199300h case    6:*/		return 0x8219748C;
		/* 82199300h case    6:*/		return 0x82199304;
		  /* 82199304h */ case    7:  		/* addi R9, R7, 8 */
		/* 82199304h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R7,0x8);
		/* 82199304h case    7:*/		return 0x82199308;
		  /* 82199308h */ case    8:  		/* lwz R7, <#[R7 + 8]> */
		/* 82199308h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000008) );
		/* 82199308h case    8:*/		return 0x8219930C;
	}
	return 0x8219930C;
} // Block from 821992E8h-8219930Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219930Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219930C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219930C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219930C);
		  /* 8219930Ch */ case    0:  		/* cmplw CR6, R7, R11 */
		/* 8219930Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 8219930Ch case    0:*/		return 0x82199310;
		  /* 82199310h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82199310h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82199304;  }
		/* 82199310h case    1:*/		return 0x82199314;
		  /* 82199314h */ case    2:  		/* lwz R7, <#[R11 + 8]> */
		/* 82199314h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 82199314h case    2:*/		return 0x82199318;
		  /* 82199318h */ case    3:  		/* li R6, 7 */
		/* 82199318h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x7);
		/* 82199318h case    3:*/		return 0x8219931C;
		  /* 8219931Ch */ case    4:  		/* stw R7, <#[R9]> */
		/* 8219931Ch case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8219931Ch case    4:*/		return 0x82199320;
		  /* 82199320h */ case    5:  		/* lwz R9, <#[R10 + 4]> */
		/* 82199320h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82199320h case    5:*/		return 0x82199324;
		  /* 82199324h */ case    6:  		/* stw R9, <#[R11 + 8]> */
		/* 82199324h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82199324h case    6:*/		return 0x82199328;
		  /* 82199328h */ case    7:  		/* stw R11, <#[R10 + 4]> */
		/* 82199328h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82199328h case    7:*/		return 0x8219932C;
		  /* 8219932Ch */ case    8:  		/* stw R10, <#[R11 + 12]> */
		/* 8219932Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219932Ch case    8:*/		return 0x82199330;
		  /* 82199330h */ case    9:  		/* lwz R10, <#[R11]> */
		/* 82199330h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199330h case    9:*/		return 0x82199334;
		  /* 82199334h */ case   10:  		/* lwz R9, <#[R8]> */
		/* 82199334h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 82199334h case   10:*/		return 0x82199338;
		  /* 82199338h */ case   11:  		/* rlwimi R9, R10, 0, 0, 26 */
		/* 82199338h case   11:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R9,regs.R10);
		/* 82199338h case   11:*/		return 0x8219933C;
		  /* 8219933Ch */ case   12:  		/* stw R9, <#[R11]> */
		/* 8219933Ch case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8219933Ch case   12:*/		return 0x82199340;
		  /* 82199340h */ case   13:  		/* rlwinm R10, R9, 0, 0, 31 */
		/* 82199340h case   13:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R9);
		/* 82199340h case   13:*/		return 0x82199344;
		  /* 82199344h */ case   14:  		/* lwz R9, <#[R8]> */
		/* 82199344h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 82199344h case   14:*/		return 0x82199348;
		  /* 82199348h */ case   15:  		/* rlwinm R9, R9, 27, 24, 31 */
		/* 82199348h case   15:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R9);
		/* 82199348h case   15:*/		return 0x8219934C;
		  /* 8219934Ch */ case   16:  		/* rlwinm R8, R10, 22, 29, 30 */
		/* 8219934Ch case   16:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R8,regs.R10);
		/* 8219934Ch case   16:*/		return 0x82199350;
		  /* 82199350h */ case   17:  		/* rlwinm R7, R10, 24, 29, 30 */
		/* 82199350h case   17:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R7,regs.R10);
		/* 82199350h case   17:*/		return 0x82199354;
		  /* 82199354h */ case   18:  		/* srw R8, R9, R8 */
		/* 82199354h case   18:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 82199354h case   18:*/		return 0x82199358;
		  /* 82199358h */ case   19:  		/* srw R7, R9, R7 */
		/* 82199358h case   19:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R9,regs.R7);
		/* 82199358h case   19:*/		return 0x8219935C;
		  /* 8219935Ch */ case   20:  		/* rlwimi R7, R8, 2, 28, 29 */
		/* 8219935Ch case   20:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R7,regs.R8);
		/* 8219935Ch case   20:*/		return 0x82199360;
		  /* 82199360h */ case   21:  		/* rlwinm R8, R10, 26, 29, 30 */
		/* 82199360h case   21:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R8,regs.R10);
		/* 82199360h case   21:*/		return 0x82199364;
		  /* 82199364h */ case   22:  		/* rlwinm R5, R10, 28, 29, 30 */
		/* 82199364h case   22:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R5,regs.R10);
		/* 82199364h case   22:*/		return 0x82199368;
		  /* 82199368h */ case   23:  		/* srw R8, R9, R8 */
		/* 82199368h case   23:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 82199368h case   23:*/		return 0x8219936C;
		  /* 8219936Ch */ case   24:  		/* rlwinm R7, R7, 0, 28, 31 */
		/* 8219936Ch case   24:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R7,regs.R7);
		/* 8219936Ch case   24:*/		return 0x82199370;
		  /* 82199370h */ case   25:  		/* srw R9, R9, R5 */
		/* 82199370h case   25:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 82199370h case   25:*/		return 0x82199374;
		  /* 82199374h */ case   26:  		/* rlwimi R8, R7, 2, 0, 29 */
		/* 82199374h case   26:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R8,regs.R7);
		/* 82199374h case   26:*/		return 0x82199378;
		  /* 82199378h */ case   27:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 82199378h case   27:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 82199378h case   27:*/		return 0x8219937C;
		  /* 8219937Ch */ case   28:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 8219937Ch case   28:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 8219937Ch case   28:*/		return 0x82199380;
		  /* 82199380h */ case   29:  		/* rlwinm R9, R9, 5, 0, 26 */
		/* 82199380h case   29:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R9);
		/* 82199380h case   29:*/		return 0x82199384;
		  /* 82199384h */ case   30:  		/* or R10, R9, R10 */
		/* 82199384h case   30:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82199384h case   30:*/		return 0x82199388;
		  /* 82199388h */ case   31:  		/* stw R10, <#[R11]> */
		/* 82199388h case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199388h case   31:*/		return 0x8219938C;
		  /* 8219938Ch */ case   32:  		/* lwz R11, <#[R14 + 8]> */
		/* 8219938Ch case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 8219938Ch case   32:*/		return 0x82199390;
		  /* 82199390h */ case   33:  		/* rlwimi R11, R6, 10, 18, 24 */
		/* 82199390h case   33:*/		cpu::op::rlwimi<0,10,18,24>(regs,&regs.R11,regs.R6);
		/* 82199390h case   33:*/		return 0x82199394;
		  /* 82199394h */ case   34:  		/* stw R11, <#[R14 + 8]> */
		/* 82199394h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199394h case   34:*/		return 0x82199398;
		  /* 82199398h */ case   35:  		/* lwz R30, <#[R31]> */
		/* 82199398h case   35:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 82199398h case   35:*/		return 0x8219939C;
		  /* 8219939Ch */ case   36:  		/* cmplwi CR6, R30, 0 */
		/* 8219939Ch case   36:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219939Ch case   36:*/		return 0x821993A0;
		  /* 821993A0h */ case   37:  		/* bc 12, CR6_EQ, 36 */
		/* 821993A0h case   37:*/		if ( regs.CR[6].eq ) { return 0x821993C4;  }
		/* 821993A0h case   37:*/		return 0x821993A4;
		  /* 821993A4h */ case   38:  		/* lwz R11, <#[R30]> */
		/* 821993A4h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821993A4h case   38:*/		return 0x821993A8;
		  /* 821993A8h */ case   39:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821993A8h case   39:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821993A8h case   39:*/		return 0x821993AC;
		  /* 821993ACh */ case   40:  		/* bc 4, CR0_EQ, 16 */
		/* 821993ACh case   40:*/		if ( !regs.CR[0].eq ) { return 0x821993BC;  }
		/* 821993ACh case   40:*/		return 0x821993B0;
		  /* 821993B0h */ case   41:  		/* mr R4, R30 */
		/* 821993B0h case   41:*/		regs.R4 = regs.R30;
		/* 821993B0h case   41:*/		return 0x821993B4;
		  /* 821993B4h */ case   42:  		/* mr R3, R14 */
		/* 821993B4h case   42:*/		regs.R3 = regs.R14;
		/* 821993B4h case   42:*/		return 0x821993B8;
		  /* 821993B8h */ case   43:  		/* bl -135664 */
		/* 821993B8h case   43:*/		regs.LR = 0x821993BC; return 0x821781C8;
		/* 821993B8h case   43:*/		return 0x821993BC;
	}
	return 0x821993BC;
} // Block from 8219930Ch-821993BCh (44 instructions)

//////////////////////////////////////////////////////
// Block at 821993BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821993BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821993BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821993BC);
		  /* 821993BCh */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 821993BCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 821993BCh case    0:*/		return 0x821993C0;
		  /* 821993C0h */ case    1:  		/* b -36 */
		/* 821993C0h case    1:*/		return 0x8219939C;
		/* 821993C0h case    1:*/		return 0x821993C4;
	}
	return 0x821993C4;
} // Block from 821993BCh-821993C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821993C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821993C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821993C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821993C4);
		  /* 821993C4h */ case    0:  		/* mr R3, R31 */
		/* 821993C4h case    0:*/		regs.R3 = regs.R31;
		/* 821993C4h case    0:*/		return 0x821993C8;
		  /* 821993C8h */ case    1:  		/* bl -215624 */
		/* 821993C8h case    1:*/		regs.LR = 0x821993CC; return 0x82164980;
		/* 821993C8h case    1:*/		return 0x821993CC;
		  /* 821993CCh */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821993CCh case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821993CCh case    2:*/		return 0x821993D0;
		  /* 821993D0h */ case    3:  		/* bc 12, CR0_EQ, -8004 */
		/* 821993D0h case    3:*/		if ( regs.CR[0].eq ) { return 0x8219748C;  }
		/* 821993D0h case    3:*/		return 0x821993D4;
		  /* 821993D4h */ case    4:  		/* mr R4, R31 */
		/* 821993D4h case    4:*/		regs.R4 = regs.R31;
		/* 821993D4h case    4:*/		return 0x821993D8;
		  /* 821993D8h */ case    5:  		/* b 728 */
		/* 821993D8h case    5:*/		return 0x821996B0;
		/* 821993D8h case    5:*/		return 0x821993DC;
	}
	return 0x821993DC;
} // Block from 821993C4h-821993DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821993DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821993DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821993DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821993DC);
		  /* 821993DCh */ case    0:  		/* li R7, 0 */
		/* 821993DCh case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821993DCh case    0:*/		return 0x821993E0;
		  /* 821993E0h */ case    1:  		/* li R6, 1 */
		/* 821993E0h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821993E0h case    1:*/		return 0x821993E4;
		  /* 821993E4h */ case    2:  		/* mr R5, R24 */
		/* 821993E4h case    2:*/		regs.R5 = regs.R24;
		/* 821993E4h case    2:*/		return 0x821993E8;
		  /* 821993E8h */ case    3:  		/* mr R4, R28 */
		/* 821993E8h case    3:*/		regs.R4 = regs.R28;
		/* 821993E8h case    3:*/		return 0x821993EC;
		  /* 821993ECh */ case    4:  		/* mr R3, R21 */
		/* 821993ECh case    4:*/		regs.R3 = regs.R21;
		/* 821993ECh case    4:*/		return 0x821993F0;
		  /* 821993F0h */ case    5:  		/* bl 608152 */
		/* 821993F0h case    5:*/		regs.LR = 0x821993F4; return 0x8222DB88;
		/* 821993F0h case    5:*/		return 0x821993F4;
		  /* 821993F4h */ case    6:  		/* lwz R6, <#[R1 + 160]> */
		/* 821993F4h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x000000A0) );
		/* 821993F4h case    6:*/		return 0x821993F8;
		  /* 821993F8h */ case    7:  		/* rlwinm R11, R26, 27, 29, 30 */
		/* 821993F8h case    7:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R11,regs.R26);
		/* 821993F8h case    7:*/		return 0x821993FC;
		  /* 821993FCh */ case    8:  		/* lwz R7, <#[R1 + 164]> */
		/* 821993FCh case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000A4) );
		/* 821993FCh case    8:*/		return 0x82199400;
		  /* 82199400h */ case    9:  		/* rlwinm R10, R26, 29, 29, 30 */
		/* 82199400h case    9:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R10,regs.R26);
		/* 82199400h case    9:*/		return 0x82199404;
		  /* 82199404h */ case   10:  		/* lwz R8, <#[R1 + 168]> */
		/* 82199404h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000A8) );
		/* 82199404h case   10:*/		return 0x82199408;
		  /* 82199408h */ case   11:  		/* rlwinm R9, R26, 31, 29, 30 */
		/* 82199408h case   11:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R9,regs.R26);
		/* 82199408h case   11:*/		return 0x8219940C;
		  /* 8219940Ch */ case   12:  		/* rlwinm R30, R26, 1, 29, 30 */
		/* 8219940Ch case   12:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R30,regs.R26);
		/* 8219940Ch case   12:*/		return 0x82199410;
		  /* 82199410h */ case   13:  		/* mr R5, R24 */
		/* 82199410h case   13:*/		regs.R5 = regs.R24;
		/* 82199410h case   13:*/		return 0x82199414;
		  /* 82199414h */ case   14:  		/* li R4, 1 */
		/* 82199414h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82199414h case   14:*/		return 0x82199418;
		  /* 82199418h */ case   15:  		/* mr R3, R21 */
		/* 82199418h case   15:*/		regs.R3 = regs.R21;
		/* 82199418h case   15:*/		return 0x8219941C;
		  /* 8219941Ch */ case   16:  		/* lwz R27, <#[R6]> */
		/* 8219941Ch case   16:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R6 + 0x00000000) );
		/* 8219941Ch case   16:*/		return 0x82199420;
		  /* 82199420h */ case   17:  		/* rlwinm R23, R27, 27, 24, 31 */
		/* 82199420h case   17:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R23,regs.R27);
		/* 82199420h case   17:*/		return 0x82199424;
		  /* 82199424h */ case   18:  		/* rlwinm R27, R27, 0, 27, 18 */
		/* 82199424h case   18:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R27,regs.R27);
		/* 82199424h case   18:*/		return 0x82199428;
		  /* 82199428h */ case   19:  		/* srw R22, R23, R11 */
		/* 82199428h case   19:*/		cpu::op::srw<0>(regs,&regs.R22,regs.R23,regs.R11);
		/* 82199428h case   19:*/		return 0x8219942C;
		  /* 8219942Ch */ case   20:  		/* srw R17, R23, R10 */
		/* 8219942Ch case   20:*/		cpu::op::srw<0>(regs,&regs.R17,regs.R23,regs.R10);
		/* 8219942Ch case   20:*/		return 0x82199430;
		  /* 82199430h */ case   21:  		/* rlwimi R17, R22, 2, 28, 29 */
		/* 82199430h case   21:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R17,regs.R22);
		/* 82199430h case   21:*/		return 0x82199434;
		  /* 82199434h */ case   22:  		/* srw R22, R23, R9 */
		/* 82199434h case   22:*/		cpu::op::srw<0>(regs,&regs.R22,regs.R23,regs.R9);
		/* 82199434h case   22:*/		return 0x82199438;
		  /* 82199438h */ case   23:  		/* rlwinm R17, R17, 0, 28, 31 */
		/* 82199438h case   23:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R17,regs.R17);
		/* 82199438h case   23:*/		return 0x8219943C;
		  /* 8219943Ch */ case   24:  		/* srw R23, R23, R30 */
		/* 8219943Ch case   24:*/		cpu::op::srw<0>(regs,&regs.R23,regs.R23,regs.R30);
		/* 8219943Ch case   24:*/		return 0x82199440;
		  /* 82199440h */ case   25:  		/* rlwimi R22, R17, 2, 0, 29 */
		/* 82199440h case   25:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R22,regs.R17);
		/* 82199440h case   25:*/		return 0x82199444;
		  /* 82199444h */ case   26:  		/* rlwimi R23, R22, 2, 0, 29 */
		/* 82199444h case   26:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R23,regs.R22);
		/* 82199444h case   26:*/		return 0x82199448;
		  /* 82199448h */ case   27:  		/* rlwinm R23, R23, 5, 0, 26 */
		/* 82199448h case   27:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R23,regs.R23);
		/* 82199448h case   27:*/		return 0x8219944C;
		  /* 8219944Ch */ case   28:  		/* or R27, R23, R27 */
		/* 8219944Ch case   28:*/		cpu::op::or<0>(regs,&regs.R27,regs.R23,regs.R27);
		/* 8219944Ch case   28:*/		return 0x82199450;
		  /* 82199450h */ case   29:  		/* stw R27, <#[R6]> */
		/* 82199450h case   29:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R6 + 0x00000000) );
		/* 82199450h case   29:*/		return 0x82199454;
		  /* 82199454h */ case   30:  		/* lwz R27, <#[R7]> */
		/* 82199454h case   30:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R7 + 0x00000000) );
		/* 82199454h case   30:*/		return 0x82199458;
		  /* 82199458h */ case   31:  		/* rlwinm R23, R27, 27, 24, 31 */
		/* 82199458h case   31:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R23,regs.R27);
		/* 82199458h case   31:*/		return 0x8219945C;
		  /* 8219945Ch */ case   32:  		/* srw R11, R23, R11 */
		/* 8219945Ch case   32:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R23,regs.R11);
		/* 8219945Ch case   32:*/		return 0x82199460;
		  /* 82199460h */ case   33:  		/* srw R10, R23, R10 */
		/* 82199460h case   33:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R23,regs.R10);
		/* 82199460h case   33:*/		return 0x82199464;
		  /* 82199464h */ case   34:  		/* rlwimi R10, R11, 2, 28, 29 */
		/* 82199464h case   34:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R10,regs.R11);
		/* 82199464h case   34:*/		return 0x82199468;
		  /* 82199468h */ case   35:  		/* srw R11, R23, R9 */
		/* 82199468h case   35:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R23,regs.R9);
		/* 82199468h case   35:*/		return 0x8219946C;
		  /* 8219946Ch */ case   36:  		/* rlwinm R10, R10, 0, 28, 31 */
		/* 8219946Ch case   36:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R10);
		/* 8219946Ch case   36:*/		return 0x82199470;
		  /* 82199470h */ case   37:  		/* srw R9, R23, R30 */
		/* 82199470h case   37:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R23,regs.R30);
		/* 82199470h case   37:*/		return 0x82199474;
		  /* 82199474h */ case   38:  		/* rlwimi R11, R10, 2, 0, 29 */
		/* 82199474h case   38:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82199474h case   38:*/		return 0x82199478;
		  /* 82199478h */ case   39:  		/* rlwinm R27, R27, 0, 27, 18 */
		/* 82199478h case   39:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R27,regs.R27);
		/* 82199478h case   39:*/		return 0x8219947C;
		  /* 8219947Ch */ case   40:  		/* rlwimi R9, R11, 2, 0, 29 */
		/* 8219947Ch case   40:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 8219947Ch case   40:*/		return 0x82199480;
		  /* 82199480h */ case   41:  		/* rlwinm R11, R9, 5, 0, 26 */
		/* 82199480h case   41:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R9);
		/* 82199480h case   41:*/		return 0x82199484;
		  /* 82199484h */ case   42:  		/* or R11, R11, R27 */
		/* 82199484h case   42:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 82199484h case   42:*/		return 0x82199488;
		  /* 82199488h */ case   43:  		/* stw R11, <#[R7]> */
		/* 82199488h case   43:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82199488h case   43:*/		return 0x8219948C;
		  /* 8219948Ch */ case   44:  		/* bl -9932 */
		/* 8219948Ch case   44:*/		regs.LR = 0x82199490; return 0x82196DC0;
		/* 8219948Ch case   44:*/		return 0x82199490;
		  /* 82199490h */ case   45:  		/* lwz R30, <#[R24]> */
		/* 82199490h case   45:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R24 + 0x00000000) );
		/* 82199490h case   45:*/		return 0x82199494;
		  /* 82199494h */ case   46:  		/* mr R27, R3 */
		/* 82199494h case   46:*/		regs.R27 = regs.R3;
		/* 82199494h case   46:*/		return 0x82199498;
		  /* 82199498h */ case   47:  		/* cmplwi CR6, R30, 0 */
		/* 82199498h case   47:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82199498h case   47:*/		return 0x8219949C;
		  /* 8219949Ch */ case   48:  		/* bc 12, CR6_EQ, 36 */
		/* 8219949Ch case   48:*/		if ( regs.CR[6].eq ) { return 0x821994C0;  }
		/* 8219949Ch case   48:*/		return 0x821994A0;
		  /* 821994A0h */ case   49:  		/* lwz R11, <#[R30]> */
		/* 821994A0h case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821994A0h case   49:*/		return 0x821994A4;
		  /* 821994A4h */ case   50:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821994A4h case   50:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821994A4h case   50:*/		return 0x821994A8;
		  /* 821994A8h */ case   51:  		/* bc 4, CR0_EQ, 16 */
		/* 821994A8h case   51:*/		if ( !regs.CR[0].eq ) { return 0x821994B8;  }
		/* 821994A8h case   51:*/		return 0x821994AC;
		  /* 821994ACh */ case   52:  		/* mr R4, R30 */
		/* 821994ACh case   52:*/		regs.R4 = regs.R30;
		/* 821994ACh case   52:*/		return 0x821994B0;
		  /* 821994B0h */ case   53:  		/* mr R3, R27 */
		/* 821994B0h case   53:*/		regs.R3 = regs.R27;
		/* 821994B0h case   53:*/		return 0x821994B4;
		  /* 821994B4h */ case   54:  		/* bl -135916 */
		/* 821994B4h case   54:*/		regs.LR = 0x821994B8; return 0x821781C8;
		/* 821994B4h case   54:*/		return 0x821994B8;
	}
	return 0x821994B8;
} // Block from 821993DCh-821994B8h (55 instructions)

//////////////////////////////////////////////////////
// Block at 821994B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821994B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821994B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821994B8);
		  /* 821994B8h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 821994B8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 821994B8h case    0:*/		return 0x821994BC;
		  /* 821994BCh */ case    1:  		/* b -36 */
		/* 821994BCh case    1:*/		return 0x82199498;
		/* 821994BCh case    1:*/		return 0x821994C0;
	}
	return 0x821994C0;
} // Block from 821994B8h-821994C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821994C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821994C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821994C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821994C0);
		  /* 821994C0h */ case    0:  		/* lwz R30, <#[R28]> */
		/* 821994C0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 821994C0h case    0:*/		return 0x821994C4;
		  /* 821994C4h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 821994C4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821994C4h case    1:*/		return 0x821994C8;
		  /* 821994C8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 821994C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x821994EC;  }
		/* 821994C8h case    2:*/		return 0x821994CC;
		  /* 821994CCh */ case    3:  		/* lwz R11, <#[R30]> */
		/* 821994CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821994CCh case    3:*/		return 0x821994D0;
		  /* 821994D0h */ case    4:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821994D0h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821994D0h case    4:*/		return 0x821994D4;
		  /* 821994D4h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 821994D4h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821994E4;  }
		/* 821994D4h case    5:*/		return 0x821994D8;
		  /* 821994D8h */ case    6:  		/* mr R4, R30 */
		/* 821994D8h case    6:*/		regs.R4 = regs.R30;
		/* 821994D8h case    6:*/		return 0x821994DC;
		  /* 821994DCh */ case    7:  		/* mr R3, R27 */
		/* 821994DCh case    7:*/		regs.R3 = regs.R27;
		/* 821994DCh case    7:*/		return 0x821994E0;
		  /* 821994E0h */ case    8:  		/* bl -135960 */
		/* 821994E0h case    8:*/		regs.LR = 0x821994E4; return 0x821781C8;
		/* 821994E0h case    8:*/		return 0x821994E4;
	}
	return 0x821994E4;
} // Block from 821994C0h-821994E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821994E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821994E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821994E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821994E4);
		  /* 821994E4h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 821994E4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 821994E4h case    0:*/		return 0x821994E8;
		  /* 821994E8h */ case    1:  		/* b -36 */
		/* 821994E8h case    1:*/		return 0x821994C4;
		/* 821994E8h case    1:*/		return 0x821994EC;
	}
	return 0x821994EC;
} // Block from 821994E4h-821994ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821994ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821994EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821994EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821994EC);
		  /* 821994ECh */ case    0:  		/* addi R8, R24, 4 */
		/* 821994ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R24,0x4);
		/* 821994ECh case    0:*/		return 0x821994F0;
		  /* 821994F0h */ case    1:  		/* lwz R11, <#[R8]> */
		/* 821994F0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821994F0h case    1:*/		return 0x821994F4;
		  /* 821994F4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821994F4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821994F4h case    2:*/		return 0x821994F8;
		  /* 821994F8h */ case    3:  		/* bc 12, CR6_EQ, 176 */
		/* 821994F8h case    3:*/		if ( regs.CR[6].eq ) { return 0x821995A8;  }
		/* 821994F8h case    3:*/		return 0x821994FC;
		  /* 821994FCh */ case    4:  		/* lwz R10, <#[R11 + 16]> */
		/* 821994FCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821994FCh case    4:*/		return 0x82199500;
		  /* 82199500h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 82199500h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82199500h case    5:*/		return 0x82199504;
		  /* 82199504h */ case    6:  		/* bc 12, CR6_EQ, 144 */
		/* 82199504h case    6:*/		if ( regs.CR[6].eq ) { return 0x82199594;  }
		/* 82199504h case    6:*/		return 0x82199508;
		  /* 82199508h */ case    7:  		/* lwz R10, <#[R11 + 12]> */
		/* 82199508h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82199508h case    7:*/		return 0x8219950C;
		  /* 8219950Ch */ case    8:  		/* addi R10, R10, 4 */
		/* 8219950Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8219950Ch case    8:*/		return 0x82199510;
		  /* 82199510h */ case    9:  		/* lwz R9, <#[R10]> */
		/* 82199510h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82199510h case    9:*/		return 0x82199514;
		  /* 82199514h */ case   10:  		/* b 12 */
		/* 82199514h case   10:*/		return 0x82199520;
		/* 82199514h case   10:*/		return 0x82199518;
		  /* 82199518h */ case   11:  		/* addi R10, R9, 8 */
		/* 82199518h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 82199518h case   11:*/		return 0x8219951C;
		  /* 8219951Ch */ case   12:  		/* lwz R9, <#[R9 + 8]> */
		/* 8219951Ch case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 8219951Ch case   12:*/		return 0x82199520;
	}
	return 0x82199520;
} // Block from 821994ECh-82199520h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82199520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199520);
		  /* 82199520h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82199520h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82199520h case    0:*/		return 0x82199524;
		  /* 82199524h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82199524h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82199518;  }
		/* 82199524h case    1:*/		return 0x82199528;
		  /* 82199528h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 82199528h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82199528h case    2:*/		return 0x8219952C;
		  /* 8219952Ch */ case    3:  		/* stw R9, <#[R10]> */
		/* 8219952Ch case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8219952Ch case    3:*/		return 0x82199530;
		  /* 82199530h */ case    4:  		/* lwz R10, <#[R14 + 4]> */
		/* 82199530h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000004) );
		/* 82199530h case    4:*/		return 0x82199534;
		  /* 82199534h */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 82199534h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82199534h case    5:*/		return 0x82199538;
		  /* 82199538h */ case    6:  		/* stw R11, <#[R14 + 4]> */
		/* 82199538h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 82199538h case    6:*/		return 0x8219953C;
		  /* 8219953Ch */ case    7:  		/* stw R14, <#[R11 + 12]> */
		/* 8219953Ch case    7:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219953Ch case    7:*/		return 0x82199540;
		  /* 82199540h */ case    8:  		/* lwz R10, <#[R11]> */
		/* 82199540h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199540h case    8:*/		return 0x82199544;
		  /* 82199544h */ case    9:  		/* rlwinm. R9, R10, 0, 4, 6 */
		/* 82199544h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R10);
		/* 82199544h case    9:*/		return 0x82199548;
		  /* 82199548h */ case   10:  		/* bc 12, CR0_EQ, 76 */
		/* 82199548h case   10:*/		if ( regs.CR[0].eq ) { return 0x82199594;  }
		/* 82199548h case   10:*/		return 0x8219954C;
		  /* 8219954Ch */ case   11:  		/* lwz R9, <#[R31]> */
		/* 8219954Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8219954Ch case   11:*/		return 0x82199550;
		  /* 82199550h */ case   12:  		/* rlwinm R7, R10, 22, 29, 30 */
		/* 82199550h case   12:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R7,regs.R10);
		/* 82199550h case   12:*/		return 0x82199554;
		  /* 82199554h */ case   13:  		/* rlwinm R6, R10, 24, 29, 30 */
		/* 82199554h case   13:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R6,regs.R10);
		/* 82199554h case   13:*/		return 0x82199558;
		  /* 82199558h */ case   14:  		/* rlwinm R9, R9, 27, 24, 31 */
		/* 82199558h case   14:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R9);
		/* 82199558h case   14:*/		return 0x8219955C;
		  /* 8219955Ch */ case   15:  		/* rlwinm R5, R10, 26, 29, 30 */
		/* 8219955Ch case   15:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R5,regs.R10);
		/* 8219955Ch case   15:*/		return 0x82199560;
		  /* 82199560h */ case   16:  		/* srw R7, R9, R7 */
		/* 82199560h case   16:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R9,regs.R7);
		/* 82199560h case   16:*/		return 0x82199564;
		  /* 82199564h */ case   17:  		/* srw R6, R9, R6 */
		/* 82199564h case   17:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R9,regs.R6);
		/* 82199564h case   17:*/		return 0x82199568;
		  /* 82199568h */ case   18:  		/* rlwimi R6, R7, 2, 28, 29 */
		/* 82199568h case   18:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R6,regs.R7);
		/* 82199568h case   18:*/		return 0x8219956C;
		  /* 8219956Ch */ case   19:  		/* srw R7, R9, R5 */
		/* 8219956Ch case   19:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R9,regs.R5);
		/* 8219956Ch case   19:*/		return 0x82199570;
		  /* 82199570h */ case   20:  		/* rlwinm R5, R10, 28, 29, 30 */
		/* 82199570h case   20:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R5,regs.R10);
		/* 82199570h case   20:*/		return 0x82199574;
		  /* 82199574h */ case   21:  		/* rlwinm R6, R6, 0, 28, 31 */
		/* 82199574h case   21:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R6,regs.R6);
		/* 82199574h case   21:*/		return 0x82199578;
		  /* 82199578h */ case   22:  		/* srw R9, R9, R5 */
		/* 82199578h case   22:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 82199578h case   22:*/		return 0x8219957C;
		  /* 8219957Ch */ case   23:  		/* rlwimi R7, R6, 2, 0, 29 */
		/* 8219957Ch case   23:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R7,regs.R6);
		/* 8219957Ch case   23:*/		return 0x82199580;
		  /* 82199580h */ case   24:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 82199580h case   24:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 82199580h case   24:*/		return 0x82199584;
		  /* 82199584h */ case   25:  		/* rlwimi R9, R7, 2, 0, 29 */
		/* 82199584h case   25:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 82199584h case   25:*/		return 0x82199588;
		  /* 82199588h */ case   26:  		/* rlwinm R9, R9, 5, 0, 26 */
		/* 82199588h case   26:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R9);
		/* 82199588h case   26:*/		return 0x8219958C;
		  /* 8219958Ch */ case   27:  		/* or R10, R9, R10 */
		/* 8219958Ch case   27:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8219958Ch case   27:*/		return 0x82199590;
		  /* 82199590h */ case   28:  		/* stw R10, <#[R11]> */
		/* 82199590h case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199590h case   28:*/		return 0x82199594;
	}
	return 0x82199594;
} // Block from 82199520h-82199594h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82199594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199594);
		  /* 82199594h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 82199594h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 82199594h case    0:*/		return 0x82199598;
		  /* 82199598h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 82199598h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82199598h case    1:*/		return 0x8219959C;
		  /* 8219959Ch */ case    2:  		/* bc 4, CR6_EQ, -172 */
		/* 8219959Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x821994F0;  }
		/* 8219959Ch case    2:*/		return 0x821995A0;
		  /* 821995A0h */ case    3:  		/* addi R8, R11, 8 */
		/* 821995A0h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 821995A0h case    3:*/		return 0x821995A4;
		  /* 821995A4h */ case    4:  		/* b -180 */
		/* 821995A4h case    4:*/		return 0x821994F0;
		/* 821995A4h case    4:*/		return 0x821995A8;
	}
	return 0x821995A8;
} // Block from 82199594h-821995A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821995A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821995A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821995A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821995A8);
		  /* 821995A8h */ case    0:  		/* lwz R10, <#[R29]> */
		/* 821995A8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 821995A8h case    0:*/		return 0x821995AC;
		  /* 821995ACh */ case    1:  		/* mr R9, R18 */
		/* 821995ACh case    1:*/		regs.R9 = regs.R18;
		/* 821995ACh case    1:*/		return 0x821995B0;
		  /* 821995B0h */ case    2:  		/* mr R11, R18 */
		/* 821995B0h case    2:*/		regs.R11 = regs.R18;
		/* 821995B0h case    2:*/		return 0x821995B4;
		  /* 821995B4h */ case    3:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 821995B4h case    3:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 821995B4h case    3:*/		return 0x821995B8;
		  /* 821995B8h */ case    4:  		/* bc 12, CR0_EQ, 60 */
		/* 821995B8h case    4:*/		if ( regs.CR[0].eq ) { return 0x821995F4;  }
		/* 821995B8h case    4:*/		return 0x821995BC;
		  /* 821995BCh */ case    5:  		/* lwz R8, <#[R29]> */
		/* 821995BCh case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000000) );
		/* 821995BCh case    5:*/		return 0x821995C0;
		  /* 821995C0h */ case    6:  		/* mr R10, R18 */
		/* 821995C0h case    6:*/		regs.R10 = regs.R18;
		/* 821995C0h case    6:*/		return 0x821995C4;
		  /* 821995C4h */ case    7:  		/* rlwinm R8, R8, 7, 29, 31 */
		/* 821995C4h case    7:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R8,regs.R8);
		/* 821995C4h case    7:*/		return 0x821995C8;
		  /* 821995C8h */ case    8:  		/* srw R7, R26, R10 */
		/* 821995C8h case    8:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R26,regs.R10);
		/* 821995C8h case    8:*/		return 0x821995CC;
		  /* 821995CCh */ case    9:  		/* rlwinm R7, R7, 1, 29, 30 */
		/* 821995CCh case    9:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R7,regs.R7);
		/* 821995CCh case    9:*/		return 0x821995D0;
		  /* 821995D0h */ case   10:  		/* li R6, 3 */
		/* 821995D0h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 821995D0h case   10:*/		return 0x821995D4;
		  /* 821995D4h */ case   11:  		/* addi R10, R10, 2 */
		/* 821995D4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 821995D4h case   11:*/		return 0x821995D8;
		  /* 821995D8h */ case   12:  		/* slw R6, R6, R7 */
		/* 821995D8h case   12:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R6,regs.R7);
		/* 821995D8h case   12:*/		return 0x821995DC;
		  /* 821995DCh */ case   13:  		/* slw R7, R11, R7 */
		/* 821995DCh case   13:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R11,regs.R7);
		/* 821995DCh case   13:*/		return 0x821995E0;
		  /* 821995E0h */ case   14:  		/* andc R9, R9, R6 */
		/* 821995E0h case   14:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 821995E0h case   14:*/		return 0x821995E4;
		  /* 821995E4h */ case   15:  		/* addi R11, R11, 1 */
		/* 821995E4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821995E4h case   15:*/		return 0x821995E8;
		  /* 821995E8h */ case   16:  		/* or R9, R9, R7 */
		/* 821995E8h case   16:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 821995E8h case   16:*/		return 0x821995EC;
		  /* 821995ECh */ case   17:  		/* cmplw CR6, R11, R8 */
		/* 821995ECh case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821995ECh case   17:*/		return 0x821995F0;
		  /* 821995F0h */ case   18:  		/* bc 12, CR6_LT, -40 */
		/* 821995F0h case   18:*/		if ( regs.CR[6].lt ) { return 0x821995C8;  }
		/* 821995F0h case   18:*/		return 0x821995F4;
	}
	return 0x821995F4;
} // Block from 821995A8h-821995F4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821995F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821995F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821995F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821995F4);
		  /* 821995F4h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 821995F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821995F4h case    0:*/		return 0x821995F8;
		  /* 821995F8h */ case    1:  		/* addi R11, R11, 4 */
		/* 821995F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821995F8h case    1:*/		return 0x821995FC;
		  /* 821995FCh */ case    2:  		/* lwz R10, <#[R11]> */
		/* 821995FCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821995FCh case    2:*/		return 0x82199600;
		  /* 82199600h */ case    3:  		/* b 12 */
		/* 82199600h case    3:*/		return 0x8219960C;
		/* 82199600h case    3:*/		return 0x82199604;
		  /* 82199604h */ case    4:  		/* addi R11, R10, 8 */
		/* 82199604h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82199604h case    4:*/		return 0x82199608;
		  /* 82199608h */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 82199608h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 82199608h case    5:*/		return 0x8219960C;
	}
	return 0x8219960C;
} // Block from 821995F4h-8219960Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219960Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219960C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219960C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219960C);
		  /* 8219960Ch */ case    0:  		/* cmplw CR6, R10, R29 */
		/* 8219960Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 8219960Ch case    0:*/		return 0x82199610;
		  /* 82199610h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82199610h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82199604;  }
		/* 82199610h case    1:*/		return 0x82199614;
		  /* 82199614h */ case    2:  		/* lwz R10, <#[R29 + 8]> */
		/* 82199614h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 82199614h case    2:*/		return 0x82199618;
		  /* 82199618h */ case    3:  		/* mr R3, R27 */
		/* 82199618h case    3:*/		regs.R3 = regs.R27;
		/* 82199618h case    3:*/		return 0x8219961C;
		  /* 8219961Ch */ case    4:  		/* stw R10, <#[R11]> */
		/* 8219961Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219961Ch case    4:*/		return 0x82199620;
		  /* 82199620h */ case    5:  		/* lwz R11, <#[R27 + 4]> */
		/* 82199620h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82199620h case    5:*/		return 0x82199624;
		  /* 82199624h */ case    6:  		/* stw R11, <#[R29 + 8]> */
		/* 82199624h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82199624h case    6:*/		return 0x82199628;
		  /* 82199628h */ case    7:  		/* stw R29, <#[R27 + 4]> */
		/* 82199628h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + 0x00000004) );
		/* 82199628h case    7:*/		return 0x8219962C;
		  /* 8219962Ch */ case    8:  		/* stw R27, <#[R29 + 12]> */
		/* 8219962Ch case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R29 + 0x0000000C) );
		/* 8219962Ch case    8:*/		return 0x82199630;
		  /* 82199630h */ case    9:  		/* lwz R11, <#[R29]> */
		/* 82199630h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82199630h case    9:*/		return 0x82199634;
		  /* 82199634h */ case   10:  		/* rlwimi R11, R9, 5, 19, 26 */
		/* 82199634h case   10:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R9);
		/* 82199634h case   10:*/		return 0x82199638;
		  /* 82199638h */ case   11:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 82199638h case   11:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 82199638h case   11:*/		return 0x8219963C;
		  /* 8219963Ch */ case   12:  		/* stw R11, <#[R29]> */
		/* 8219963Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8219963Ch case   12:*/		return 0x82199640;
		  /* 82199640h */ case   13:  		/* bl -135880 */
		/* 82199640h case   13:*/		regs.LR = 0x82199644; return 0x82178378;
		/* 82199640h case   13:*/		return 0x82199644;
		  /* 82199644h */ case   14:  		/* lwz R11, <#[R27 + 8]> */
		/* 82199644h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 82199644h case   14:*/		return 0x82199648;
		  /* 82199648h */ case   15:  		/* oris R11, R11, 256 */
		/* 82199648h case   15:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82199648h case   15:*/		return 0x8219964C;
		  /* 8219964Ch */ case   16:  		/* stw R11, <#[R27 + 8]> */
		/* 8219964Ch case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219964Ch case   16:*/		return 0x82199650;
		  /* 82199650h */ case   17:  		/* lwz R11, <#[R14 + 8]> */
		/* 82199650h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199650h case   17:*/		return 0x82199654;
		  /* 82199654h */ case   18:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82199654h case   18:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82199654h case   18:*/		return 0x82199658;
		  /* 82199658h */ case   19:  		/* lwz R11, <#[R24 + 8]> */
		/* 82199658h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 82199658h case   19:*/		return 0x8219965C;
		  /* 8219965Ch */ case   20:  		/* bc 4, CR0_EQ, 28 */
		/* 8219965Ch case   20:*/		if ( !regs.CR[0].eq ) { return 0x82199678;  }
		/* 8219965Ch case   20:*/		return 0x82199660;
		  /* 82199660h */ case   21:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82199660h case   21:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82199660h case   21:*/		return 0x82199664;
		  /* 82199664h */ case   22:  		/* bc 12, CR0_EQ, 52 */
		/* 82199664h case   22:*/		if ( regs.CR[0].eq ) { return 0x82199698;  }
		/* 82199664h case   22:*/		return 0x82199668;
		  /* 82199668h */ case   23:  		/* mr R4, R14 */
		/* 82199668h case   23:*/		regs.R4 = regs.R14;
		/* 82199668h case   23:*/		return 0x8219966C;
		  /* 8219966Ch */ case   24:  		/* mr R3, R21 */
		/* 8219966Ch case   24:*/		regs.R3 = regs.R21;
		/* 8219966Ch case   24:*/		return 0x82199670;
		  /* 82199670h */ case   25:  		/* bl 118328 */
		/* 82199670h case   25:*/		regs.LR = 0x82199674; return 0x821B64A8;
		/* 82199670h case   25:*/		return 0x82199674;
		  /* 82199674h */ case   26:  		/* b 36 */
		/* 82199674h case   26:*/		return 0x82199698;
		/* 82199674h case   26:*/		return 0x82199678;
	}
	return 0x82199678;
} // Block from 8219960Ch-82199678h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82199678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199678);
		  /* 82199678h */ case    0:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82199678h case    0:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82199678h case    0:*/		return 0x8219967C;
		  /* 8219967Ch */ case    1:  		/* bc 4, CR0_EQ, 28 */
		/* 8219967Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x82199698;  }
		/* 8219967Ch case    1:*/		return 0x82199680;
		  /* 82199680h */ case    2:  		/* mr R3, R14 */
		/* 82199680h case    2:*/		regs.R3 = regs.R14;
		/* 82199680h case    2:*/		return 0x82199684;
		  /* 82199684h */ case    3:  		/* bl -142852 */
		/* 82199684h case    3:*/		regs.LR = 0x82199688; return 0x82176880;
		/* 82199684h case    3:*/		return 0x82199688;
		  /* 82199688h */ case    4:  		/* or. R4, R3, R3 */
		/* 82199688h case    4:*/		cpu::op::or<1>(regs,&regs.R4,regs.R3,regs.R3);
		/* 82199688h case    4:*/		return 0x8219968C;
		  /* 8219968Ch */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 8219968Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82199698;  }
		/* 8219968Ch case    5:*/		return 0x82199690;
		  /* 82199690h */ case    6:  		/* mr R3, R21 */
		/* 82199690h case    6:*/		regs.R3 = regs.R21;
		/* 82199690h case    6:*/		return 0x82199694;
		  /* 82199694h */ case    7:  		/* bl 119732 */
		/* 82199694h case    7:*/		regs.LR = 0x82199698; return 0x821B6A48;
		/* 82199694h case    7:*/		return 0x82199698;
	}
	return 0x82199698;
} // Block from 82199678h-82199698h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82199698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199698);
		  /* 82199698h */ case    0:  		/* li R6, 1 */
		/* 82199698h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82199698h case    0:*/		return 0x8219969C;
		  /* 8219969Ch */ case    1:  		/* li R5, 0 */
		/* 8219969Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219969Ch case    1:*/		return 0x821996A0;
		  /* 821996A0h */ case    2:  		/* mr R4, R24 */
		/* 821996A0h case    2:*/		regs.R4 = regs.R24;
		/* 821996A0h case    2:*/		return 0x821996A4;
		  /* 821996A4h */ case    3:  		/* mr R3, R21 */
		/* 821996A4h case    3:*/		regs.R3 = regs.R21;
		/* 821996A4h case    3:*/		return 0x821996A8;
		  /* 821996A8h */ case    4:  		/* bl 597280 */
		/* 821996A8h case    4:*/		regs.LR = 0x821996AC; return 0x8222B3C8;
		/* 821996A8h case    4:*/		return 0x821996AC;
		  /* 821996ACh */ case    5:  		/* mr R4, R25 */
		/* 821996ACh case    5:*/		regs.R4 = regs.R25;
		/* 821996ACh case    5:*/		return 0x821996B0;
	}
	return 0x821996B0;
} // Block from 82199698h-821996B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821996B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821996B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821996B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821996B0);
		  /* 821996B0h */ case    0:  		/* li R6, 1 */
		/* 821996B0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821996B0h case    0:*/		return 0x821996B4;
		  /* 821996B4h */ case    1:  		/* li R5, 0 */
		/* 821996B4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821996B4h case    1:*/		return 0x821996B8;
		  /* 821996B8h */ case    2:  		/* mr R3, R21 */
		/* 821996B8h case    2:*/		regs.R3 = regs.R21;
		/* 821996B8h case    2:*/		return 0x821996BC;
		  /* 821996BCh */ case    3:  		/* bl 597260 */
		/* 821996BCh case    3:*/		regs.LR = 0x821996C0; return 0x8222B3C8;
		/* 821996BCh case    3:*/		return 0x821996C0;
		  /* 821996C0h */ case    4:  		/* b -8756 */
		/* 821996C0h case    4:*/		return 0x8219748C;
		/* 821996C0h case    4:*/		return 0x821996C4;
	}
	return 0x821996C4;
} // Block from 821996B0h-821996C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821996C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821996C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821996C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821996C4);
		  /* 821996C4h */ case    0:  		/* lwz R30, <#[R14 + 4]> */
		/* 821996C4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R14 + 0x00000004) );
		/* 821996C4h case    0:*/		return 0x821996C8;
		  /* 821996C8h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 821996C8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821996C8h case    1:*/		return 0x821996CC;
		  /* 821996CCh */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 821996CCh case    2:*/		if ( regs.CR[6].eq ) { return 0x821996FC;  }
		/* 821996CCh case    2:*/		return 0x821996D0;
		  /* 821996D0h */ case    3:  		/* lwz R3, <#[R30 + 16]> */
		/* 821996D0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000010) );
		/* 821996D0h case    3:*/		return 0x821996D4;
		  /* 821996D4h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 821996D4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821996D4h case    4:*/		return 0x821996D8;
		  /* 821996D8h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 821996D8h case    5:*/		if ( regs.CR[6].eq ) { return 0x821996F4;  }
		/* 821996D8h case    5:*/		return 0x821996DC;
		  /* 821996DCh */ case    6:  		/* lwz R11, <#[R30]> */
		/* 821996DCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821996DCh case    6:*/		return 0x821996E0;
		  /* 821996E0h */ case    7:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821996E0h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821996E0h case    7:*/		return 0x821996E4;
		  /* 821996E4h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821996E4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821996F4;  }
		/* 821996E4h case    8:*/		return 0x821996E8;
		  /* 821996E8h */ case    9:  		/* mr R5, R25 */
		/* 821996E8h case    9:*/		regs.R5 = regs.R25;
		/* 821996E8h case    9:*/		return 0x821996EC;
		  /* 821996ECh */ case   10:  		/* mr R4, R31 */
		/* 821996ECh case   10:*/		regs.R4 = regs.R31;
		/* 821996ECh case   10:*/		return 0x821996F0;
		  /* 821996F0h */ case   11:  		/* bl -136288 */
		/* 821996F0h case   11:*/		regs.LR = 0x821996F4; return 0x82178290;
		/* 821996F0h case   11:*/		return 0x821996F4;
	}
	return 0x821996F4;
} // Block from 821996C4h-821996F4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821996F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821996F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821996F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821996F4);
		  /* 821996F4h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 821996F4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 821996F4h case    0:*/		return 0x821996F8;
		  /* 821996F8h */ case    1:  		/* b -48 */
		/* 821996F8h case    1:*/		return 0x821996C8;
		/* 821996F8h case    1:*/		return 0x821996FC;
	}
	return 0x821996FC;
} // Block from 821996F4h-821996FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821996FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821996FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821996FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821996FC);
		  /* 821996FCh */ case    0:  		/* mr R4, R31 */
		/* 821996FCh case    0:*/		regs.R4 = regs.R31;
		/* 821996FCh case    0:*/		return 0x82199700;
		  /* 82199700h */ case    1:  		/* mr R3, R25 */
		/* 82199700h case    1:*/		regs.R3 = regs.R25;
		/* 82199700h case    1:*/		return 0x82199704;
		  /* 82199704h */ case    2:  		/* bl -136964 */
		/* 82199704h case    2:*/		regs.LR = 0x82199708; return 0x82178000;
		/* 82199704h case    2:*/		return 0x82199708;
		  /* 82199708h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82199708h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82199708h case    3:*/		return 0x8219970C;
		  /* 8219970Ch */ case    4:  		/* li R4, 0 */
		/* 8219970Ch case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8219970Ch case    4:*/		return 0x82199710;
		  /* 82199710h */ case    5:  		/* rlwimi R11, R28, 25, 4, 6 */
		/* 82199710h case    5:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R28);
		/* 82199710h case    5:*/		return 0x82199714;
		  /* 82199714h */ case    6:  		/* mr R30, R3 */
		/* 82199714h case    6:*/		regs.R30 = regs.R3;
		/* 82199714h case    6:*/		return 0x82199718;
		  /* 82199718h */ case    7:  		/* stw R11, <#[R3]> */
		/* 82199718h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82199718h case    7:*/		return 0x8219971C;
		  /* 8219971Ch */ case    8:  		/* bl -138332 */
		/* 8219971Ch case    8:*/		regs.LR = 0x82199720; return 0x82177AC0;
		/* 8219971Ch case    8:*/		return 0x82199720;
		  /* 82199720h */ case    9:  		/* lwz R10, <#[R30]> */
		/* 82199720h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82199720h case    9:*/		return 0x82199724;
		  /* 82199724h */ case   10:  		/* li R11, 57 */
		/* 82199724h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x39);
		/* 82199724h case   10:*/		return 0x82199728;
		  /* 82199728h */ case   11:  		/* mr R4, R30 */
		/* 82199728h case   11:*/		regs.R4 = regs.R30;
		/* 82199728h case   11:*/		return 0x8219972C;
		  /* 8219972Ch */ case   12:  		/* rlwimi R10, R11, 7, 19, 26 */
		/* 8219972Ch case   12:*/		cpu::op::rlwimi<0,7,19,26>(regs,&regs.R10,regs.R11);
		/* 8219972Ch case   12:*/		return 0x82199730;
		  /* 82199730h */ case   13:  		/* stw R10, <#[R30]> */
		/* 82199730h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82199730h case   13:*/		return 0x82199734;
		  /* 82199734h */ case   14:  		/* lwz R3, <#[R19 + 16]> */
		/* 82199734h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R19 + 0x00000010) );
		/* 82199734h case   14:*/		return 0x82199738;
		  /* 82199738h */ case   15:  		/* bl -136560 */
		/* 82199738h case   15:*/		regs.LR = 0x8219973C; return 0x821781C8;
		/* 82199738h case   15:*/		return 0x8219973C;
		  /* 8219973Ch */ case   16:  		/* mr R3, R31 */
		/* 8219973Ch case   16:*/		regs.R3 = regs.R31;
		/* 8219973Ch case   16:*/		return 0x82199740;
		  /* 82199740h */ case   17:  		/* bl -136136 */
		/* 82199740h case   17:*/		regs.LR = 0x82199744; return 0x82178378;
		/* 82199740h case   17:*/		return 0x82199744;
		  /* 82199744h */ case   18:  		/* lwz R8, <#[R31 + 16]> */
		/* 82199744h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 82199744h case   18:*/		return 0x82199748;
		  /* 82199748h */ case   19:  		/* addi R11, R1, 192 */
		/* 82199748h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 82199748h case   19:*/		return 0x8219974C;
		  /* 8219974Ch */ case   20:  		/* rlwinm R8, R8, 0, 13, 10 */
		/* 8219974Ch case   20:*/		cpu::op::rlwinm<0,0,13,10>(regs,&regs.R8,regs.R8);
		/* 8219974Ch case   20:*/		return 0x82199750;
		  /* 82199750h */ case   21:  		/* lis R9, 16384 */
		/* 82199750h case   21:*/		cpu::op::lis<0>(regs,&regs.R9,0x4000);
		/* 82199750h case   21:*/		return 0x82199754;
		  /* 82199754h */ case   22:  		/* stw R8, <#[R31 + 16]> */
		/* 82199754h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000010) );
		/* 82199754h case   22:*/		return 0x82199758;
		  /* 82199758h */ case   23:  		/* li R10, 1 */
		/* 82199758h case   23:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82199758h case   23:*/		return 0x8219975C;
		  /* 8219975Ch */ case   24:  		/* lwzx R11, <#[R29 + R11]> */
		/* 8219975Ch case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8219975Ch case   24:*/		return 0x82199760;
		  /* 82199760h */ case   25:  		/* rlwimi R11, R20, 0, 0, 27 */
		/* 82199760h case   25:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R11,regs.R20);
		/* 82199760h case   25:*/		return 0x82199764;
		  /* 82199764h */ case   26:  		/* rlwimi R9, R11, 13, 7, 18 */
		/* 82199764h case   26:*/		cpu::op::rlwimi<0,13,7,18>(regs,&regs.R9,regs.R11);
		/* 82199764h case   26:*/		return 0x82199768;
		  /* 82199768h */ case   27:  		/* lwz R11, <#[R31 + 8]> */
		/* 82199768h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82199768h case   27:*/		return 0x8219976C;
		  /* 8219976Ch */ case   28:  		/* rlwimi R11, R10, 5, 26, 26 */
		/* 8219976Ch case   28:*/		cpu::op::rlwimi<0,5,26,26>(regs,&regs.R11,regs.R10);
		/* 8219976Ch case   28:*/		return 0x82199770;
		  /* 82199770h */ case   29:  		/* rlwimi R11, R10, 5, 8, 8 */
		/* 82199770h case   29:*/		cpu::op::rlwimi<0,5,8,8>(regs,&regs.R11,regs.R10);
		/* 82199770h case   29:*/		return 0x82199774;
		  /* 82199774h */ case   30:  		/* stw R11, <#[R31 + 8]> */
		/* 82199774h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82199774h case   30:*/		return 0x82199778;
		  /* 82199778h */ case   31:  		/* lwz R11, <#[R30]> */
		/* 82199778h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82199778h case   31:*/		return 0x8219977C;
		  /* 8219977Ch */ case   32:  		/* rlwinm R11, R11, 0, 19, 6 */
		/* 8219977Ch case   32:*/		cpu::op::rlwinm<0,0,19,6>(regs,&regs.R11,regs.R11);
		/* 8219977Ch case   32:*/		return 0x82199780;
		  /* 82199780h */ case   33:  		/* or R11, R9, R11 */
		/* 82199780h case   33:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82199780h case   33:*/		return 0x82199784;
		  /* 82199784h */ case   34:  		/* stw R11, <#[R30]> */
		/* 82199784h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82199784h case   34:*/		return 0x82199788;
		  /* 82199788h */ case   35:  		/* lwz R11, <#[R16]> */
		/* 82199788h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82199788h case   35:*/		return 0x8219978C;
		  /* 8219978Ch */ case   36:  		/* rlwinm. R4, R11, 0, 27, 31 */
		/* 8219978Ch case   36:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R4,regs.R11);
		/* 8219978Ch case   36:*/		return 0x82199790;
		  /* 82199790h */ case   37:  		/* bc 12, CR0_EQ, 32 */
		/* 82199790h case   37:*/		if ( regs.CR[0].eq ) { return 0x821997B0;  }
		/* 82199790h case   37:*/		return 0x82199794;
		  /* 82199794h */ case   38:  		/* lwz R30, <#[R31 + 48]> */
		/* 82199794h case   38:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000030) );
		/* 82199794h case   38:*/		return 0x82199798;
		  /* 82199798h */ case   39:  		/* lwz R3, <#[R31 + 44]> */
		/* 82199798h case   39:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 82199798h case   39:*/		return 0x8219979C;
		  /* 8219979Ch */ case   40:  		/* bl -138460 */
		/* 8219979Ch case   40:*/		regs.LR = 0x821997A0; return 0x82177AC0;
		/* 8219979Ch case   40:*/		return 0x821997A0;
		  /* 821997A0h */ case   41:  		/* lwz R11, <#[R16]> */
		/* 821997A0h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 821997A0h case   41:*/		return 0x821997A4;
		  /* 821997A4h */ case   42:  		/* mr R3, R30 */
		/* 821997A4h case   42:*/		regs.R3 = regs.R30;
		/* 821997A4h case   42:*/		return 0x821997A8;
		  /* 821997A8h */ case   43:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 821997A8h case   43:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 821997A8h case   43:*/		return 0x821997AC;
		  /* 821997ACh */ case   44:  		/* bl -138476 */
		/* 821997ACh case   44:*/		regs.LR = 0x821997B0; return 0x82177AC0;
		/* 821997ACh case   44:*/		return 0x821997B0;
	}
	return 0x821997B0;
} // Block from 821996FCh-821997B0h (45 instructions)

//////////////////////////////////////////////////////
// Block at 821997B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821997B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821997B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821997B0);
		  /* 821997B0h */ case    0:  		/* addic. R26, R26, -1 */
		/* 821997B0h case    0:*/		cpu::op::addic<1>(regs,&regs.R26,regs.R26,0xFFFFFFFF);
		/* 821997B0h case    0:*/		return 0x821997B4;
		  /* 821997B4h */ case    1:  		/* addi R27, R27, 2 */
		/* 821997B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x2);
		/* 821997B4h case    1:*/		return 0x821997B8;
		  /* 821997B8h */ case    2:  		/* addi R29, R29, 4 */
		/* 821997B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 821997B8h case    2:*/		return 0x821997BC;
		  /* 821997BCh */ case    3:  		/* bc 4, CR0_EQ, -4996 */
		/* 821997BCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x82198438;  }
		/* 821997BCh case    3:*/		return 0x821997C0;
	}
	return 0x821997C0;
} // Block from 821997B0h-821997C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821997C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821997C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821997C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821997C0);
		  /* 821997C0h */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 821997C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 821997C0h case    0:*/		return 0x821997C4;
		  /* 821997C4h */ case    1:  		/* mr R5, R25 */
		/* 821997C4h case    1:*/		regs.R5 = regs.R25;
		/* 821997C4h case    1:*/		return 0x821997C8;
		  /* 821997C8h */ case    2:  		/* mr R4, R19 */
		/* 821997C8h case    2:*/		regs.R4 = regs.R19;
		/* 821997C8h case    2:*/		return 0x821997CC;
		  /* 821997CCh */ case    3:  		/* rlwinm R11, R11, 0, 27, 25 */
		/* 821997CCh case    3:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R11,regs.R11);
		/* 821997CCh case    3:*/		return 0x821997D0;
		  /* 821997D0h */ case    4:  		/* stw R11, <#[R14 + 8]> */
		/* 821997D0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 821997D0h case    4:*/		return 0x821997D4;
		  /* 821997D4h */ case    5:  		/* lwz R3, <#[R19 + 16]> */
		/* 821997D4h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R19 + 0x00000010) );
		/* 821997D4h case    5:*/		return 0x821997D8;
		  /* 821997D8h */ case    6:  		/* bl -134856 */
		/* 821997D8h case    6:*/		regs.LR = 0x821997DC; return 0x82178910;
		/* 821997D8h case    6:*/		return 0x821997DC;
		  /* 821997DCh */ case    7:  		/* li R6, 1 */
		/* 821997DCh case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821997DCh case    7:*/		return 0x821997E0;
		  /* 821997E0h */ case    8:  		/* li R5, 0 */
		/* 821997E0h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821997E0h case    8:*/		return 0x821997E4;
		  /* 821997E4h */ case    9:  		/* mr R4, R14 */
		/* 821997E4h case    9:*/		regs.R4 = regs.R14;
		/* 821997E4h case    9:*/		return 0x821997E8;
		  /* 821997E8h */ case   10:  		/* mr R3, R25 */
		/* 821997E8h case   10:*/		regs.R3 = regs.R25;
		/* 821997E8h case   10:*/		return 0x821997EC;
		  /* 821997ECh */ case   11:  		/* bl 596956 */
		/* 821997ECh case   11:*/		regs.LR = 0x821997F0; return 0x8222B3C8;
		/* 821997ECh case   11:*/		return 0x821997F0;
		  /* 821997F0h */ case   12:  		/* li R6, 1 */
		/* 821997F0h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821997F0h case   12:*/		return 0x821997F4;
		  /* 821997F4h */ case   13:  		/* li R5, 0 */
		/* 821997F4h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821997F4h case   13:*/		return 0x821997F8;
		  /* 821997F8h */ case   14:  		/* mr R4, R15 */
		/* 821997F8h case   14:*/		regs.R4 = regs.R15;
		/* 821997F8h case   14:*/		return 0x821997FC;
		  /* 821997FCh */ case   15:  		/* mr R3, R25 */
		/* 821997FCh case   15:*/		regs.R3 = regs.R25;
		/* 821997FCh case   15:*/		return 0x82199800;
		  /* 82199800h */ case   16:  		/* bl 596936 */
		/* 82199800h case   16:*/		regs.LR = 0x82199804; return 0x8222B3C8;
		/* 82199800h case   16:*/		return 0x82199804;
		  /* 82199804h */ case   17:  		/* lwz R21, <#[R1 + 484]> */
		/* 82199804h case   17:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x000001E4) );
		/* 82199804h case   17:*/		return 0x82199808;
		  /* 82199808h */ case   18:  		/* lwz R20, <#[R1 + 100]> */
		/* 82199808h case   18:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x00000064) );
		/* 82199808h case   18:*/		return 0x8219980C;
		  /* 8219980Ch */ case   19:  		/* li R19, 1 */
		/* 8219980Ch case   19:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 8219980Ch case   19:*/		return 0x82199810;
		  /* 82199810h */ case   20:  		/* li R18, 0 */
		/* 82199810h case   20:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 82199810h case   20:*/		return 0x82199814;
		  /* 82199814h */ case   21:  		/* b -9096 */
		/* 82199814h case   21:*/		return 0x8219748C;
		/* 82199814h case   21:*/		return 0x82199818;
	}
	return 0x82199818;
} // Block from 821997C0h-82199818h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82199818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199818);
		  /* 82199818h */ case    0:  		/* li R8, 1 */
		/* 82199818h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82199818h case    0:*/		return 0x8219981C;
		  /* 8219981Ch */ case    1:  		/* li R7, 0 */
		/* 8219981Ch case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219981Ch case    1:*/		return 0x82199820;
		  /* 82199820h */ case    2:  		/* li R6, 120 */
		/* 82199820h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x78);
		/* 82199820h case    2:*/		return 0x82199824;
		  /* 82199824h */ case    3:  		/* addi R5, R20, 16 */
		/* 82199824h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R20,0x10);
		/* 82199824h case    3:*/		return 0x82199828;
		  /* 82199828h */ case    4:  		/* mr R4, R20 */
		/* 82199828h case    4:*/		regs.R4 = regs.R20;
		/* 82199828h case    4:*/		return 0x8219982C;
		  /* 8219982Ch */ case    5:  		/* mr R3, R21 */
		/* 8219982Ch case    5:*/		regs.R3 = regs.R21;
		/* 8219982Ch case    5:*/		return 0x82199830;
		  /* 82199830h */ case    6:  		/* bl 569704 */
		/* 82199830h case    6:*/		regs.LR = 0x82199834; return 0x82224998;
		/* 82199830h case    6:*/		return 0x82199834;
		  /* 82199834h */ case    7:  		/* mr R29, R3 */
		/* 82199834h case    7:*/		regs.R29 = regs.R3;
		/* 82199834h case    7:*/		return 0x82199838;
		  /* 82199838h */ case    8:  		/* fcmpu CR6, FR31, FR28 */
		/* 82199838h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR28);
		/* 82199838h case    8:*/		return 0x8219983C;
		  /* 8219983Ch */ case    9:  		/* mr R3, R21 */
		/* 8219983Ch case    9:*/		regs.R3 = regs.R21;
		/* 8219983Ch case    9:*/		return 0x82199840;
		  /* 82199840h */ case   10:  		/* bc 4, CR6_EQ, 80 */
		/* 82199840h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82199890;  }
		/* 82199840h case   10:*/		return 0x82199844;
		  /* 82199844h */ case   11:  		/* mr R4, R29 */
		/* 82199844h case   11:*/		regs.R4 = regs.R29;
		/* 82199844h case   11:*/		return 0x82199848;
		  /* 82199848h */ case   12:  		/* bl -137288 */
		/* 82199848h case   12:*/		regs.LR = 0x8219984C; return 0x82178000;
		/* 82199848h case   12:*/		return 0x8219984C;
		  /* 8219984Ch */ case   13:  		/* lwz R11, <#[R3]> */
		/* 8219984Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8219984Ch case   13:*/		return 0x82199850;
		  /* 82199850h */ case   14:  		/* li R4, 6 */
		/* 82199850h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x6);
		/* 82199850h case   14:*/		return 0x82199854;
		  /* 82199854h */ case   15:  		/* rlwimi R11, R31, 25, 4, 6 */
		/* 82199854h case   15:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R31);
		/* 82199854h case   15:*/		return 0x82199858;
		  /* 82199858h */ case   16:  		/* mr R30, R3 */
		/* 82199858h case   16:*/		regs.R30 = regs.R3;
		/* 82199858h case   16:*/		return 0x8219985C;
		  /* 8219985Ch */ case   17:  		/* stw R11, <#[R3]> */
		/* 8219985Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8219985Ch case   17:*/		return 0x82199860;
		  /* 82199860h */ case   18:  		/* bl -138656 */
		/* 82199860h case   18:*/		regs.LR = 0x82199864; return 0x82177AC0;
		/* 82199860h case   18:*/		return 0x82199864;
		  /* 82199864h */ case   19:  		/* lwz R11, <#[R30]> */
		/* 82199864h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82199864h case   19:*/		return 0x82199868;
		  /* 82199868h */ case   20:  		/* mr R7, R16 */
		/* 82199868h case   20:*/		regs.R7 = regs.R16;
		/* 82199868h case   20:*/		return 0x8219986C;
		  /* 8219986Ch */ case   21:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 8219986Ch case   21:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 8219986Ch case   21:*/		return 0x82199870;
		  /* 82199870h */ case   22:  		/* mr R5, R14 */
		/* 82199870h case   22:*/		regs.R5 = regs.R14;
		/* 82199870h case   22:*/		return 0x82199874;
		  /* 82199874h */ case   23:  		/* stw R11, <#[R30]> */
		/* 82199874h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82199874h case   23:*/		return 0x82199878;
		  /* 82199878h */ case   24:  		/* li R4, 0 */
		/* 82199878h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82199878h case   24:*/		return 0x8219987C;
		  /* 8219987Ch */ case   25:  		/* mr R3, R21 */
		/* 8219987Ch case   25:*/		regs.R3 = regs.R21;
		/* 8219987Ch case   25:*/		return 0x82199880;
		  /* 82199880h */ case   26:  		/* mr R6, R30 */
		/* 82199880h case   26:*/		regs.R6 = regs.R30;
		/* 82199880h case   26:*/		return 0x82199884;
		  /* 82199884h */ case   27:  		/* bl -11364 */
		/* 82199884h case   27:*/		regs.LR = 0x82199888; return 0x82196C20;
		/* 82199884h case   27:*/		return 0x82199888;
		  /* 82199888h */ case   28:  		/* mr R31, R3 */
		/* 82199888h case   28:*/		regs.R31 = regs.R3;
		/* 82199888h case   28:*/		return 0x8219988C;
		  /* 8219988Ch */ case   29:  		/* b 232 */
		/* 8219988Ch case   29:*/		return 0x82199974;
		/* 8219988Ch case   29:*/		return 0x82199890;
	}
	return 0x82199890;
} // Block from 82199818h-82199890h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82199890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199890);
		  /* 82199890h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 82199890h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82199890h case    0:*/		return 0x82199894;
		  /* 82199894h */ case    1:  		/* li R6, 0 */
		/* 82199894h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82199894h case    1:*/		return 0x82199898;
		  /* 82199898h */ case    2:  		/* li R4, 120 */
		/* 82199898h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x78);
		/* 82199898h case    2:*/		return 0x8219989C;
		  /* 8219989Ch */ case    3:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8219989Ch case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8219989Ch case    3:*/		return 0x821998A0;
		  /* 821998A0h */ case    4:  		/* bl -218224 */
		/* 821998A0h case    4:*/		regs.LR = 0x821998A4; return 0x82164430;
		/* 821998A0h case    4:*/		return 0x821998A4;
		  /* 821998A4h */ case    5:  		/* addi R11, R29, -4 */
		/* 821998A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFC);
		/* 821998A4h case    5:*/		return 0x821998A8;
		  /* 821998A8h */ case    6:  		/* li R4, 1 */
		/* 821998A8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821998A8h case    6:*/		return 0x821998AC;
		  /* 821998ACh */ case    7:  		/* fmr FR4, FR29 */
		/* 821998ACh case    7:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR29);
		/* 821998ACh case    7:*/		return 0x821998B0;
		  /* 821998B0h */ case    8:  		/* add R11, R3, R11 */
		/* 821998B0h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821998B0h case    8:*/		return 0x821998B4;
		  /* 821998B4h */ case    9:  		/* fmr FR3, FR29 */
		/* 821998B4h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR29);
		/* 821998B4h case    9:*/		return 0x821998B8;
		  /* 821998B8h */ case   10:  		/* mr R3, R21 */
		/* 821998B8h case   10:*/		regs.R3 = regs.R21;
		/* 821998B8h case   10:*/		return 0x821998BC;
		  /* 821998BCh */ case   11:  		/* fmr FR2, FR29 */
		/* 821998BCh case   11:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR29);
		/* 821998BCh case   11:*/		return 0x821998C0;
		  /* 821998C0h */ case   12:  		/* fmr FR1, FR29 */
		/* 821998C0h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 821998C0h case   12:*/		return 0x821998C4;
		  /* 821998C4h */ case   13:  		/* lwz R10, <#[R11]> */
		/* 821998C4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821998C4h case   13:*/		return 0x821998C8;
		  /* 821998C8h */ case   14:  		/* ori R10, R10, 1 */
		/* 821998C8h case   14:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821998C8h case   14:*/		return 0x821998CC;
		  /* 821998CCh */ case   15:  		/* stw R10, <#[R11]> */
		/* 821998CCh case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821998CCh case   15:*/		return 0x821998D0;
		  /* 821998D0h */ case   16:  		/* bl 594568 */
		/* 821998D0h case   16:*/		regs.LR = 0x821998D4; return 0x8222AB58;
		/* 821998D0h case   16:*/		return 0x821998D4;
		  /* 821998D4h */ case   17:  		/* mr R30, R3 */
		/* 821998D4h case   17:*/		regs.R30 = regs.R3;
		/* 821998D4h case   17:*/		return 0x821998D8;
		  /* 821998D8h */ case   18:  		/* mr R3, R21 */
		/* 821998D8h case   18:*/		regs.R3 = regs.R21;
		/* 821998D8h case   18:*/		return 0x821998DC;
		  /* 821998DCh */ case   19:  		/* mr R4, R30 */
		/* 821998DCh case   19:*/		regs.R4 = regs.R30;
		/* 821998DCh case   19:*/		return 0x821998E0;
		  /* 821998E0h */ case   20:  		/* bl -137440 */
		/* 821998E0h case   20:*/		regs.LR = 0x821998E4; return 0x82178000;
		/* 821998E0h case   20:*/		return 0x821998E4;
		  /* 821998E4h */ case   21:  		/* lwz R11, <#[R3]> */
		/* 821998E4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821998E4h case   21:*/		return 0x821998E8;
		  /* 821998E8h */ case   22:  		/* rlwinm R31, R31, 25, 4, 6 */
		/* 821998E8h case   22:*/		cpu::op::rlwinm<0,25,4,6>(regs,&regs.R31,regs.R31);
		/* 821998E8h case   22:*/		return 0x821998EC;
		  /* 821998ECh */ case   23:  		/* rlwinm R11, R11, 0, 7, 3 */
		/* 821998ECh case   23:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R11,regs.R11);
		/* 821998ECh case   23:*/		return 0x821998F0;
		  /* 821998F0h */ case   24:  		/* li R4, 0 */
		/* 821998F0h case   24:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821998F0h case   24:*/		return 0x821998F4;
		  /* 821998F4h */ case   25:  		/* or R11, R11, R31 */
		/* 821998F4h case   25:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 821998F4h case   25:*/		return 0x821998F8;
		  /* 821998F8h */ case   26:  		/* mr R28, R3 */
		/* 821998F8h case   26:*/		regs.R28 = regs.R3;
		/* 821998F8h case   26:*/		return 0x821998FC;
		  /* 821998FCh */ case   27:  		/* stw R11, <#[R3]> */
		/* 821998FCh case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821998FCh case   27:*/		return 0x82199900;
		  /* 82199900h */ case   28:  		/* bl -138816 */
		/* 82199900h case   28:*/		regs.LR = 0x82199904; return 0x82177AC0;
		/* 82199900h case   28:*/		return 0x82199904;
		  /* 82199904h */ case   29:  		/* lwz R11, <#[R28]> */
		/* 82199904h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82199904h case   29:*/		return 0x82199908;
		  /* 82199908h */ case   30:  		/* mr R4, R29 */
		/* 82199908h case   30:*/		regs.R4 = regs.R29;
		/* 82199908h case   30:*/		return 0x8219990C;
		  /* 8219990Ch */ case   31:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 8219990Ch case   31:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 8219990Ch case   31:*/		return 0x82199910;
		  /* 82199910h */ case   32:  		/* mr R3, R21 */
		/* 82199910h case   32:*/		regs.R3 = regs.R21;
		/* 82199910h case   32:*/		return 0x82199914;
		  /* 82199914h */ case   33:  		/* stw R11, <#[R28]> */
		/* 82199914h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82199914h case   33:*/		return 0x82199918;
		  /* 82199918h */ case   34:  		/* bl -137496 */
		/* 82199918h case   34:*/		regs.LR = 0x8219991C; return 0x82178000;
		/* 82199918h case   34:*/		return 0x8219991C;
		  /* 8219991Ch */ case   35:  		/* lwz R11, <#[R3]> */
		/* 8219991Ch case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8219991Ch case   35:*/		return 0x82199920;
		  /* 82199920h */ case   36:  		/* li R4, 2 */
		/* 82199920h case   36:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82199920h case   36:*/		return 0x82199924;
		  /* 82199924h */ case   37:  		/* rlwinm R11, R11, 0, 7, 3 */
		/* 82199924h case   37:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R11,regs.R11);
		/* 82199924h case   37:*/		return 0x82199928;
		  /* 82199928h */ case   38:  		/* mr R27, R3 */
		/* 82199928h case   38:*/		regs.R27 = regs.R3;
		/* 82199928h case   38:*/		return 0x8219992C;
		  /* 8219992Ch */ case   39:  		/* or R11, R11, R31 */
		/* 8219992Ch case   39:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8219992Ch case   39:*/		return 0x82199930;
		  /* 82199930h */ case   40:  		/* stw R11, <#[R3]> */
		/* 82199930h case   40:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82199930h case   40:*/		return 0x82199934;
		  /* 82199934h */ case   41:  		/* bl -138868 */
		/* 82199934h case   41:*/		regs.LR = 0x82199938; return 0x82177AC0;
		/* 82199934h case   41:*/		return 0x82199938;
		  /* 82199938h */ case   42:  		/* lwz R11, <#[R27]> */
		/* 82199938h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82199938h case   42:*/		return 0x8219993C;
		  /* 8219993Ch */ case   43:  		/* mr R7, R28 */
		/* 8219993Ch case   43:*/		regs.R7 = regs.R28;
		/* 8219993Ch case   43:*/		return 0x82199940;
		  /* 82199940h */ case   44:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 82199940h case   44:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 82199940h case   44:*/		return 0x82199944;
		  /* 82199944h */ case   45:  		/* mr R5, R14 */
		/* 82199944h case   45:*/		regs.R5 = regs.R14;
		/* 82199944h case   45:*/		return 0x82199948;
		  /* 82199948h */ case   46:  		/* stw R11, <#[R27]> */
		/* 82199948h case   46:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 82199948h case   46:*/		return 0x8219994C;
		  /* 8219994Ch */ case   47:  		/* li R4, 0 */
		/* 8219994Ch case   47:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8219994Ch case   47:*/		return 0x82199950;
		  /* 82199950h */ case   48:  		/* mr R3, R21 */
		/* 82199950h case   48:*/		regs.R3 = regs.R21;
		/* 82199950h case   48:*/		return 0x82199954;
		  /* 82199954h */ case   49:  		/* mr R6, R27 */
		/* 82199954h case   49:*/		regs.R6 = regs.R27;
		/* 82199954h case   49:*/		return 0x82199958;
		  /* 82199958h */ case   50:  		/* bl -11368 */
		/* 82199958h case   50:*/		regs.LR = 0x8219995C; return 0x82196CF0;
		/* 82199958h case   50:*/		return 0x8219995C;
		  /* 8219995Ch */ case   51:  		/* mr R31, R3 */
		/* 8219995Ch case   51:*/		regs.R31 = regs.R3;
		/* 8219995Ch case   51:*/		return 0x82199960;
		  /* 82199960h */ case   52:  		/* mr R3, R30 */
		/* 82199960h case   52:*/		regs.R3 = regs.R30;
		/* 82199960h case   52:*/		return 0x82199964;
		  /* 82199964h */ case   53:  		/* bl -13748 */
		/* 82199964h case   53:*/		regs.LR = 0x82199968; return 0x821963B0;
		/* 82199964h case   53:*/		return 0x82199968;
		  /* 82199968h */ case   54:  		/* lwz R11, <#[R30 + 8]> */
		/* 82199968h case   54:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82199968h case   54:*/		return 0x8219996C;
		  /* 8219996Ch */ case   55:  		/* oris R11, R11, 256 */
		/* 8219996Ch case   55:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 8219996Ch case   55:*/		return 0x82199970;
		  /* 82199970h */ case   56:  		/* stw R11, <#[R30 + 8]> */
		/* 82199970h case   56:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82199970h case   56:*/		return 0x82199974;
	}
	return 0x82199974;
} // Block from 82199890h-82199974h (57 instructions)

//////////////////////////////////////////////////////
// Block at 82199974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199974);
		  /* 82199974h */ case    0:  		/* lwz R11, <#[R31 + 44]> */
		/* 82199974h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82199974h case    0:*/		return 0x82199978;
		  /* 82199978h */ case    1:  		/* addi R7, R14, 4 */
		/* 82199978h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R14,0x4);
		/* 82199978h case    1:*/		return 0x8219997C;
		  /* 8219997Ch */ case    2:  		/* lwz R10, <#[R11]> */
		/* 8219997Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219997Ch case    2:*/		return 0x82199980;
		  /* 82199980h */ case    3:  		/* oris R10, R10, 16384 */
		/* 82199980h case    3:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x4000);
		/* 82199980h case    3:*/		return 0x82199984;
		  /* 82199984h */ case    4:  		/* stw R10, <#[R11]> */
		/* 82199984h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199984h case    4:*/		return 0x82199988;
		  /* 82199988h */ case    5:  		/* lwz R11, <#[R31 + 44]> */
		/* 82199988h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82199988h case    5:*/		return 0x8219998C;
		  /* 8219998Ch */ case    6:  		/* lwz R10, <#[R11]> */
		/* 8219998Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219998Ch case    6:*/		return 0x82199990;
		  /* 82199990h */ case    7:  		/* rlwinm R10, R10, 0, 19, 6 */
		/* 82199990h case    7:*/		cpu::op::rlwinm<0,0,19,6>(regs,&regs.R10,regs.R10);
		/* 82199990h case    7:*/		return 0x82199994;
		  /* 82199994h */ case    8:  		/* stw R10, <#[R11]> */
		/* 82199994h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199994h case    8:*/		return 0x82199998;
		  /* 82199998h */ case    9:  		/* lwz R11, <#[R7]> */
		/* 82199998h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82199998h case    9:*/		return 0x8219999C;
		  /* 8219999Ch */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 8219999Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219999Ch case   10:*/		return 0x821999A0;
		  /* 821999A0h */ case   11:  		/* bc 12, CR6_EQ, 188 */
		/* 821999A0h case   11:*/		if ( regs.CR[6].eq ) { return 0x82199A5C;  }
		/* 821999A0h case   11:*/		return 0x821999A4;
		  /* 821999A4h */ case   12:  		/* lwz R10, <#[R11 + 16]> */
		/* 821999A4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821999A4h case   12:*/		return 0x821999A8;
		  /* 821999A8h */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 821999A8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821999A8h case   13:*/		return 0x821999AC;
		  /* 821999ACh */ case   14:  		/* bc 12, CR6_EQ, 156 */
		/* 821999ACh case   14:*/		if ( regs.CR[6].eq ) { return 0x82199A48;  }
		/* 821999ACh case   14:*/		return 0x821999B0;
		  /* 821999B0h */ case   15:  		/* lwz R10, <#[R11 + 12]> */
		/* 821999B0h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821999B0h case   15:*/		return 0x821999B4;
		  /* 821999B4h */ case   16:  		/* addi R10, R10, 4 */
		/* 821999B4h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821999B4h case   16:*/		return 0x821999B8;
		  /* 821999B8h */ case   17:  		/* lwz R9, <#[R10]> */
		/* 821999B8h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821999B8h case   17:*/		return 0x821999BC;
		  /* 821999BCh */ case   18:  		/* b 12 */
		/* 821999BCh case   18:*/		return 0x821999C8;
		/* 821999BCh case   18:*/		return 0x821999C0;
		  /* 821999C0h */ case   19:  		/* addi R10, R9, 8 */
		/* 821999C0h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821999C0h case   19:*/		return 0x821999C4;
		  /* 821999C4h */ case   20:  		/* lwz R9, <#[R9 + 8]> */
		/* 821999C4h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821999C4h case   20:*/		return 0x821999C8;
	}
	return 0x821999C8;
} // Block from 82199974h-821999C8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821999C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821999C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821999C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821999C8);
		  /* 821999C8h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 821999C8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821999C8h case    0:*/		return 0x821999CC;
		  /* 821999CCh */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821999CCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821999C0;  }
		/* 821999CCh case    1:*/		return 0x821999D0;
		  /* 821999D0h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 821999D0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821999D0h case    2:*/		return 0x821999D4;
		  /* 821999D4h */ case    3:  		/* fcmpu CR6, FR31, FR30 */
		/* 821999D4h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR30);
		/* 821999D4h case    3:*/		return 0x821999D8;
		  /* 821999D8h */ case    4:  		/* stw R9, <#[R10]> */
		/* 821999D8h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821999D8h case    4:*/		return 0x821999DC;
		  /* 821999DCh */ case    5:  		/* lwz R10, <#[R31 + 4]> */
		/* 821999DCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821999DCh case    5:*/		return 0x821999E0;
		  /* 821999E0h */ case    6:  		/* stw R10, <#[R11 + 8]> */
		/* 821999E0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821999E0h case    6:*/		return 0x821999E4;
		  /* 821999E4h */ case    7:  		/* stw R11, <#[R31 + 4]> */
		/* 821999E4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821999E4h case    7:*/		return 0x821999E8;
		  /* 821999E8h */ case    8:  		/* stw R31, <#[R11 + 12]> */
		/* 821999E8h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 821999E8h case    8:*/		return 0x821999EC;
		  /* 821999ECh */ case    9:  		/* bc 4, CR6_EQ, 92 */
		/* 821999ECh case    9:*/		if ( !regs.CR[6].eq ) { return 0x82199A48;  }
		/* 821999ECh case    9:*/		return 0x821999F0;
		  /* 821999F0h */ case   10:  		/* lwz R8, <#[R11]> */
		/* 821999F0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821999F0h case   10:*/		return 0x821999F4;
		  /* 821999F4h */ case   11:  		/* rlwinm. R10, R8, 0, 4, 6 */
		/* 821999F4h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R8);
		/* 821999F4h case   11:*/		return 0x821999F8;
		  /* 821999F8h */ case   12:  		/* bc 12, CR0_EQ, 80 */
		/* 821999F8h case   12:*/		if ( regs.CR[0].eq ) { return 0x82199A48;  }
		/* 821999F8h case   12:*/		return 0x821999FC;
		  /* 821999FCh */ case   13:  		/* rlwinm R10, R8, 0, 30, 30 */
		/* 821999FCh case   13:*/		cpu::op::rlwinm<0,0,30,30>(regs,&regs.R10,regs.R8);
		/* 821999FCh case   13:*/		return 0x82199A00;
		  /* 82199A00h */ case   14:  		/* li R9, 4 */
		/* 82199A00h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 82199A00h case   14:*/		return 0x82199A04;
		  /* 82199A04h */ case   15:  		/* addic R10, R10, -1 */
		/* 82199A04h case   15:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82199A04h case   15:*/		return 0x82199A08;
		  /* 82199A08h */ case   16:  		/* rlwinm R10, R8, 0, 27, 31 */
		/* 82199A08h case   16:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R8);
		/* 82199A08h case   16:*/		return 0x82199A0C;
		  /* 82199A0Ch */ case   17:  		/* subfe R6, R6, R6 */
		/* 82199A0Ch case   17:*/		cpu::op::subfe<0>(regs,&regs.R6,regs.R6,regs.R6);
		/* 82199A0Ch case   17:*/		return 0x82199A10;
		  /* 82199A10h */ case   18:  		/* and R9, R6, R9 */
		/* 82199A10h case   18:*/		cpu::op::and<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 82199A10h case   18:*/		return 0x82199A14;
		  /* 82199A14h */ case   19:  		/* and R6, R10, R9 */
		/* 82199A14h case   19:*/		cpu::op::and<0>(regs,&regs.R6,regs.R10,regs.R9);
		/* 82199A14h case   19:*/		return 0x82199A18;
		  /* 82199A18h */ case   20:  		/* rlwinm. R6, R6, 0, 29, 29 */
		/* 82199A18h case   20:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R6,regs.R6);
		/* 82199A18h case   20:*/		return 0x82199A1C;
		  /* 82199A1Ch */ case   21:  		/* bc 12, CR0_EQ, 12 */
		/* 82199A1Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x82199A28;  }
		/* 82199A1Ch case   21:*/		return 0x82199A20;
		  /* 82199A20h */ case   22:  		/* addi R9, R9, -4 */
		/* 82199A20h case   22:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFC);
		/* 82199A20h case   22:*/		return 0x82199A24;
		  /* 82199A24h */ case   23:  		/* addi R10, R10, -4 */
		/* 82199A24h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 82199A24h case   23:*/		return 0x82199A28;
	}
	return 0x82199A28;
} // Block from 821999C8h-82199A28h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82199A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199A28);
		  /* 82199A28h */ case    0:  		/* rlwinm. R6, R9, 0, 31, 31 */
		/* 82199A28h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R6,regs.R9);
		/* 82199A28h case    0:*/		return 0x82199A2C;
		  /* 82199A2Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82199A2Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82199A3C;  }
		/* 82199A2Ch case    1:*/		return 0x82199A30;
		  /* 82199A30h */ case    2:  		/* rlwinm. R6, R10, 0, 30, 30 */
		/* 82199A30h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R6,regs.R10);
		/* 82199A30h case    2:*/		return 0x82199A34;
		  /* 82199A34h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 82199A34h case    3:*/		if ( regs.CR[0].eq ) { return 0x82199A3C;  }
		/* 82199A34h case    3:*/		return 0x82199A38;
		  /* 82199A38h */ case    4:  		/* addi R10, R10, -2 */
		/* 82199A38h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 82199A38h case    4:*/		return 0x82199A3C;
	}
	return 0x82199A3C;
} // Block from 82199A28h-82199A3Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82199A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199A3C);
		  /* 82199A3Ch */ case    0:  		/* or R10, R10, R9 */
		/* 82199A3Ch case    0:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82199A3Ch case    0:*/		return 0x82199A40;
		  /* 82199A40h */ case    1:  		/* rlwimi R10, R8, 0, 0, 26 */
		/* 82199A40h case    1:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R10,regs.R8);
		/* 82199A40h case    1:*/		return 0x82199A44;
		  /* 82199A44h */ case    2:  		/* stw R10, <#[R11]> */
		/* 82199A44h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199A44h case    2:*/		return 0x82199A48;
	}
	return 0x82199A48;
} // Block from 82199A3Ch-82199A48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82199A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199A48);
		  /* 82199A48h */ case    0:  		/* lwz R10, <#[R7]> */
		/* 82199A48h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 82199A48h case    0:*/		return 0x82199A4C;
		  /* 82199A4Ch */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 82199A4Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82199A4Ch case    1:*/		return 0x82199A50;
		  /* 82199A50h */ case    2:  		/* bc 4, CR6_EQ, -184 */
		/* 82199A50h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82199998;  }
		/* 82199A50h case    2:*/		return 0x82199A54;
		  /* 82199A54h */ case    3:  		/* addi R7, R11, 8 */
		/* 82199A54h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x8);
		/* 82199A54h case    3:*/		return 0x82199A58;
		  /* 82199A58h */ case    4:  		/* b -192 */
		/* 82199A58h case    4:*/		return 0x82199998;
		/* 82199A58h case    4:*/		return 0x82199A5C;
	}
	return 0x82199A5C;
} // Block from 82199A48h-82199A5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82199A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199A5C);
		  /* 82199A5Ch */ case    0:  		/* lwz R30, <#[R14]> */
		/* 82199A5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R14 + 0x00000000) );
		/* 82199A5Ch case    0:*/		return 0x82199A60;
		  /* 82199A60h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82199A60h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82199A60h case    1:*/		return 0x82199A64;
		  /* 82199A64h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 82199A64h case    2:*/		if ( regs.CR[6].eq ) { return 0x82199A88;  }
		/* 82199A64h case    2:*/		return 0x82199A68;
		  /* 82199A68h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 82199A68h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82199A68h case    3:*/		return 0x82199A6C;
		  /* 82199A6Ch */ case    4:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82199A6Ch case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82199A6Ch case    4:*/		return 0x82199A70;
		  /* 82199A70h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82199A70h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82199A80;  }
		/* 82199A70h case    5:*/		return 0x82199A74;
		  /* 82199A74h */ case    6:  		/* mr R4, R30 */
		/* 82199A74h case    6:*/		regs.R4 = regs.R30;
		/* 82199A74h case    6:*/		return 0x82199A78;
		  /* 82199A78h */ case    7:  		/* mr R3, R31 */
		/* 82199A78h case    7:*/		regs.R3 = regs.R31;
		/* 82199A78h case    7:*/		return 0x82199A7C;
		  /* 82199A7Ch */ case    8:  		/* bl -137396 */
		/* 82199A7Ch case    8:*/		regs.LR = 0x82199A80; return 0x821781C8;
		/* 82199A7Ch case    8:*/		return 0x82199A80;
	}
	return 0x82199A80;
} // Block from 82199A5Ch-82199A80h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82199A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199A80);
		  /* 82199A80h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 82199A80h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 82199A80h case    0:*/		return 0x82199A84;
		  /* 82199A84h */ case    1:  		/* b -36 */
		/* 82199A84h case    1:*/		return 0x82199A60;
		/* 82199A84h case    1:*/		return 0x82199A88;
	}
	return 0x82199A88;
} // Block from 82199A80h-82199A88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82199A88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199A88);
		  /* 82199A88h */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82199A88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199A88h case    0:*/		return 0x82199A8C;
		  /* 82199A8Ch */ case    1:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 82199A8Ch case    1:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82199A8Ch case    1:*/		return 0x82199A90;
		  /* 82199A90h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 82199A90h case    2:*/		if ( regs.CR[0].eq ) { return 0x82199AAC;  }
		/* 82199A90h case    2:*/		return 0x82199A94;
		  /* 82199A94h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 82199A94h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82199A94h case    3:*/		return 0x82199A98;
		  /* 82199A98h */ case    4:  		/* ori R11, R11, 32 */
		/* 82199A98h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82199A98h case    4:*/		return 0x82199A9C;
		  /* 82199A9Ch */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 82199A9Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82199A9Ch case    5:*/		return 0x82199AA0;
		  /* 82199AA0h */ case    6:  		/* lwz R11, <#[R14 + 8]> */
		/* 82199AA0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199AA0h case    6:*/		return 0x82199AA4;
		  /* 82199AA4h */ case    7:  		/* rlwinm R11, R11, 0, 27, 25 */
		/* 82199AA4h case    7:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R11,regs.R11);
		/* 82199AA4h case    7:*/		return 0x82199AA8;
		  /* 82199AA8h */ case    8:  		/* stw R11, <#[R14 + 8]> */
		/* 82199AA8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199AA8h case    8:*/		return 0x82199AAC;
	}
	return 0x82199AAC;
} // Block from 82199A88h-82199AACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82199AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199AAC);
		  /* 82199AACh */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82199AACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199AACh case    0:*/		return 0x82199AB0;
		  /* 82199AB0h */ case    1:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 82199AB0h case    1:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 82199AB0h case    1:*/		return 0x82199AB4;
		  /* 82199AB4h */ case    2:  		/* bc 12, CR0_EQ, 64 */
		/* 82199AB4h case    2:*/		if ( regs.CR[0].eq ) { return 0x82199AF4;  }
		/* 82199AB4h case    2:*/		return 0x82199AB8;
		  /* 82199AB8h */ case    3:  		/* lwz R9, <#[R31 + 8]> */
		/* 82199AB8h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82199AB8h case    3:*/		return 0x82199ABC;
		  /* 82199ABCh */ case    4:  		/* li R10, 4 */
		/* 82199ABCh case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82199ABCh case    4:*/		return 0x82199AC0;
		  /* 82199AC0h */ case    5:  		/* addi R11, R20, 92 */
		/* 82199AC0h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R20,0x5C);
		/* 82199AC0h case    5:*/		return 0x82199AC4;
		  /* 82199AC4h */ case    6:  		/* oris R9, R9, 512 */
		/* 82199AC4h case    6:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x200);
		/* 82199AC4h case    6:*/		return 0x82199AC8;
		  /* 82199AC8h */ case    7:  		/* stw R9, <#[R31 + 8]> */
		/* 82199AC8h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82199AC8h case    7:*/		return 0x82199ACC;
		  /* 82199ACCh */ case    8:  		/* mtspr CTR, R10 */
		/* 82199ACCh case    8:*/		regs.CTR = regs.R10;
		/* 82199ACCh case    8:*/		return 0x82199AD0;
		  /* 82199AD0h */ case    9:  		/* lwz R10, <#[R14 + 8]> */
		/* 82199AD0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000008) );
		/* 82199AD0h case    9:*/		return 0x82199AD4;
		  /* 82199AD4h */ case   10:  		/* rlwinm R10, R10, 0, 7, 5 */
		/* 82199AD4h case   10:*/		cpu::op::rlwinm<0,0,7,5>(regs,&regs.R10,regs.R10);
		/* 82199AD4h case   10:*/		return 0x82199AD8;
		  /* 82199AD8h */ case   11:  		/* stw R10, <#[R14 + 8]> */
		/* 82199AD8h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R14 + 0x00000008) );
		/* 82199AD8h case   11:*/		return 0x82199ADC;
		  /* 82199ADCh */ case   12:  		/* lwz R10, <#[R11]> */
		/* 82199ADCh case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199ADCh case   12:*/		return 0x82199AE0;
		  /* 82199AE0h */ case   13:  		/* cmplw CR6, R10, R14 */
		/* 82199AE0h case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R14);
		/* 82199AE0h case   13:*/		return 0x82199AE4;
		  /* 82199AE4h */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 82199AE4h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82199AEC;  }
		/* 82199AE4h case   14:*/		return 0x82199AE8;
		  /* 82199AE8h */ case   15:  		/* stw R31, <#[R11]> */
		/* 82199AE8h case   15:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82199AE8h case   15:*/		return 0x82199AEC;
	}
	return 0x82199AEC;
} // Block from 82199AACh-82199AECh (16 instructions)

//////////////////////////////////////////////////////
// Block at 82199AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199AEC);
		  /* 82199AECh */ case    0:  		/* addi R11, R11, 4 */
		/* 82199AECh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82199AECh case    0:*/		return 0x82199AF0;
		  /* 82199AF0h */ case    1:  		/* bc 16, CR0_LT, -20 */
		/* 82199AF0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82199ADC;  }
		/* 82199AF0h case    1:*/		return 0x82199AF4;
	}
	return 0x82199AF4;
} // Block from 82199AECh-82199AF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82199AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199AF4);
		  /* 82199AF4h */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82199AF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199AF4h case    0:*/		return 0x82199AF8;
		  /* 82199AF8h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82199AF8h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82199AF8h case    1:*/		return 0x82199AFC;
		  /* 82199AFCh */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82199AFCh case    2:*/		if ( regs.CR[0].eq ) { return 0x82199B0C;  }
		/* 82199AFCh case    2:*/		return 0x82199B00;
		  /* 82199B00h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 82199B00h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82199B00h case    3:*/		return 0x82199B04;
		  /* 82199B04h */ case    4:  		/* ori R11, R11, 1 */
		/* 82199B04h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82199B04h case    4:*/		return 0x82199B08;
		  /* 82199B08h */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 82199B08h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82199B08h case    5:*/		return 0x82199B0C;
	}
	return 0x82199B0C;
} // Block from 82199AF4h-82199B0Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82199B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199B0C);
		  /* 82199B0Ch */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 82199B0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82199B0Ch case    0:*/		return 0x82199B10;
		  /* 82199B10h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 82199B10h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 82199B10h case    1:*/		return 0x82199B14;
		  /* 82199B14h */ case    2:  		/* cmplwi CR6, R11, 14464 */
		/* 82199B14h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003880);
		/* 82199B14h case    2:*/		return 0x82199B18;
		  /* 82199B18h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82199B18h case    3:*/		if ( regs.CR[6].eq ) { return 0x82199B30;  }
		/* 82199B18h case    3:*/		return 0x82199B1C;
		  /* 82199B1Ch */ case    4:  		/* mr R3, R29 */
		/* 82199B1Ch case    4:*/		regs.R3 = regs.R29;
		/* 82199B1Ch case    4:*/		return 0x82199B20;
		  /* 82199B20h */ case    5:  		/* bl -137128 */
		/* 82199B20h case    5:*/		regs.LR = 0x82199B24; return 0x82178378;
		/* 82199B20h case    5:*/		return 0x82199B24;
		  /* 82199B24h */ case    6:  		/* lwz R11, <#[R29 + 8]> */
		/* 82199B24h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82199B24h case    6:*/		return 0x82199B28;
		  /* 82199B28h */ case    7:  		/* oris R11, R11, 256 */
		/* 82199B28h case    7:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82199B28h case    7:*/		return 0x82199B2C;
		  /* 82199B2Ch */ case    8:  		/* stw R11, <#[R29 + 8]> */
		/* 82199B2Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82199B2Ch case    8:*/		return 0x82199B30;
	}
	return 0x82199B30;
} // Block from 82199B0Ch-82199B30h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82199B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199B30);
		  /* 82199B30h */ case    0:  		/* mr R3, R31 */
		/* 82199B30h case    0:*/		regs.R3 = regs.R31;
		/* 82199B30h case    0:*/		return 0x82199B34;
		  /* 82199B34h */ case    1:  		/* bl -137148 */
		/* 82199B34h case    1:*/		regs.LR = 0x82199B38; return 0x82178378;
		/* 82199B34h case    1:*/		return 0x82199B38;
		  /* 82199B38h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 82199B38h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82199B38h case    2:*/		return 0x82199B3C;
		  /* 82199B3Ch */ case    3:  		/* oris R11, R11, 256 */
		/* 82199B3Ch case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82199B3Ch case    3:*/		return 0x82199B40;
		  /* 82199B40h */ case    4:  		/* stw R11, <#[R31 + 8]> */
		/* 82199B40h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82199B40h case    4:*/		return 0x82199B44;
		  /* 82199B44h */ case    5:  		/* lwz R11, <#[R14 + 8]> */
		/* 82199B44h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199B44h case    5:*/		return 0x82199B48;
		  /* 82199B48h */ case    6:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82199B48h case    6:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82199B48h case    6:*/		return 0x82199B4C;
		  /* 82199B4Ch */ case    7:  		/* bc 12, CR0_EQ, 1284 */
		/* 82199B4Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x8219A050;  }
		/* 82199B4Ch case    7:*/		return 0x82199B50;
		  /* 82199B50h */ case    8:  		/* mr R4, R31 */
		/* 82199B50h case    8:*/		regs.R4 = regs.R31;
		/* 82199B50h case    8:*/		return 0x82199B54;
		  /* 82199B54h */ case    9:  		/* mr R3, R21 */
		/* 82199B54h case    9:*/		regs.R3 = regs.R21;
		/* 82199B54h case    9:*/		return 0x82199B58;
		  /* 82199B58h */ case   10:  		/* bl 117072 */
		/* 82199B58h case   10:*/		regs.LR = 0x82199B5C; return 0x821B64A8;
		/* 82199B58h case   10:*/		return 0x82199B5C;
		  /* 82199B5Ch */ case   11:  		/* b 1268 */
		/* 82199B5Ch case   11:*/		return 0x8219A050;
		/* 82199B5Ch case   11:*/		return 0x82199B60;
		  /* 82199B60h */ case   12:  		/* addi R10, R9, 8 */
		/* 82199B60h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 82199B60h case   12:*/		return 0x82199B64;
		  /* 82199B64h */ case   13:  		/* lwz R9, <#[R9 + 8]> */
		/* 82199B64h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82199B64h case   13:*/		return 0x82199B68;
	}
	return 0x82199B68;
} // Block from 82199B30h-82199B68h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82199B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199B68);
		  /* 82199B68h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82199B68h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82199B68h case    0:*/		return 0x82199B6C;
		  /* 82199B6Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82199B6Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82199B60;  }
		/* 82199B6Ch case    1:*/		return 0x82199B70;
		  /* 82199B70h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 82199B70h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82199B70h case    2:*/		return 0x82199B74;
		  /* 82199B74h */ case    3:  		/* stw R9, <#[R10]> */
		/* 82199B74h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82199B74h case    3:*/		return 0x82199B78;
		  /* 82199B78h */ case    4:  		/* lwz R10, <#[R15 + 4]> */
		/* 82199B78h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000004) );
		/* 82199B78h case    4:*/		return 0x82199B7C;
		  /* 82199B7Ch */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 82199B7Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82199B7Ch case    5:*/		return 0x82199B80;
		  /* 82199B80h */ case    6:  		/* stw R11, <#[R15 + 4]> */
		/* 82199B80h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x00000004) );
		/* 82199B80h case    6:*/		return 0x82199B84;
		  /* 82199B84h */ case    7:  		/* stw R15, <#[R11 + 12]> */
		/* 82199B84h case    7:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x0000000C) );
		/* 82199B84h case    7:*/		return 0x82199B88;
		  /* 82199B88h */ case    8:  		/* lwz R8, <#[R11]> */
		/* 82199B88h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82199B88h case    8:*/		return 0x82199B8C;
		  /* 82199B8Ch */ case    9:  		/* rlwinm. R10, R8, 0, 4, 6 */
		/* 82199B8Ch case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R8);
		/* 82199B8Ch case    9:*/		return 0x82199B90;
		  /* 82199B90h */ case   10:  		/* bc 12, CR0_EQ, 84 */
		/* 82199B90h case   10:*/		if ( regs.CR[0].eq ) { return 0x82199BE4;  }
		/* 82199B90h case   10:*/		return 0x82199B94;
		  /* 82199B94h */ case   11:  		/* rlwinm. R6, R25, 0, 29, 29 */
		/* 82199B94h case   11:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R6,regs.R25);
		/* 82199B94h case   11:*/		return 0x82199B98;
		  /* 82199B98h */ case   12:  		/* rlwinm R10, R8, 0, 27, 31 */
		/* 82199B98h case   12:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R8);
		/* 82199B98h case   12:*/		return 0x82199B9C;
		  /* 82199B9Ch */ case   13:  		/* mr R9, R25 */
		/* 82199B9Ch case   13:*/		regs.R9 = regs.R25;
		/* 82199B9Ch case   13:*/		return 0x82199BA0;
		  /* 82199BA0h */ case   14:  		/* bc 12, CR0_EQ, 16 */
		/* 82199BA0h case   14:*/		if ( regs.CR[0].eq ) { return 0x82199BB0;  }
		/* 82199BA0h case   14:*/		return 0x82199BA4;
		  /* 82199BA4h */ case   15:  		/* rlwinm. R6, R10, 0, 30, 30 */
		/* 82199BA4h case   15:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R6,regs.R10);
		/* 82199BA4h case   15:*/		return 0x82199BA8;
		  /* 82199BA8h */ case   16:  		/* bc 12, CR0_EQ, 8 */
		/* 82199BA8h case   16:*/		if ( regs.CR[0].eq ) { return 0x82199BB0;  }
		/* 82199BA8h case   16:*/		return 0x82199BAC;
		  /* 82199BACh */ case   17:  		/* addi R9, R25, -4 */
		/* 82199BACh case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R25,0xFFFFFFFC);
		/* 82199BACh case   17:*/		return 0x82199BB0;
	}
	return 0x82199BB0;
} // Block from 82199B68h-82199BB0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82199BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199BB0);
		  /* 82199BB0h */ case    0:  		/* and R6, R9, R10 */
		/* 82199BB0h case    0:*/		cpu::op::and<0>(regs,&regs.R6,regs.R9,regs.R10);
		/* 82199BB0h case    0:*/		return 0x82199BB4;
		  /* 82199BB4h */ case    1:  		/* rlwinm. R6, R6, 0, 29, 29 */
		/* 82199BB4h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R6,regs.R6);
		/* 82199BB4h case    1:*/		return 0x82199BB8;
		  /* 82199BB8h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82199BB8h case    2:*/		if ( regs.CR[0].eq ) { return 0x82199BC4;  }
		/* 82199BB8h case    2:*/		return 0x82199BBC;
		  /* 82199BBCh */ case    3:  		/* addi R9, R9, -4 */
		/* 82199BBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFC);
		/* 82199BBCh case    3:*/		return 0x82199BC0;
		  /* 82199BC0h */ case    4:  		/* addi R10, R10, -4 */
		/* 82199BC0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 82199BC0h case    4:*/		return 0x82199BC4;
	}
	return 0x82199BC4;
} // Block from 82199BB0h-82199BC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82199BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199BC4);
		  /* 82199BC4h */ case    0:  		/* rlwinm. R6, R9, 0, 31, 31 */
		/* 82199BC4h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R6,regs.R9);
		/* 82199BC4h case    0:*/		return 0x82199BC8;
		  /* 82199BC8h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82199BC8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82199BD8;  }
		/* 82199BC8h case    1:*/		return 0x82199BCC;
		  /* 82199BCCh */ case    2:  		/* rlwinm. R6, R10, 0, 30, 30 */
		/* 82199BCCh case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R6,regs.R10);
		/* 82199BCCh case    2:*/		return 0x82199BD0;
		  /* 82199BD0h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 82199BD0h case    3:*/		if ( regs.CR[0].eq ) { return 0x82199BD8;  }
		/* 82199BD0h case    3:*/		return 0x82199BD4;
		  /* 82199BD4h */ case    4:  		/* addi R10, R10, -2 */
		/* 82199BD4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 82199BD4h case    4:*/		return 0x82199BD8;
	}
	return 0x82199BD8;
} // Block from 82199BC4h-82199BD8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82199BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199BD8);
		  /* 82199BD8h */ case    0:  		/* or R10, R9, R10 */
		/* 82199BD8h case    0:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82199BD8h case    0:*/		return 0x82199BDC;
		  /* 82199BDCh */ case    1:  		/* rlwimi R10, R8, 0, 0, 26 */
		/* 82199BDCh case    1:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R10,regs.R8);
		/* 82199BDCh case    1:*/		return 0x82199BE0;
		  /* 82199BE0h */ case    2:  		/* stw R10, <#[R11]> */
		/* 82199BE0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199BE0h case    2:*/		return 0x82199BE4;
	}
	return 0x82199BE4;
} // Block from 82199BD8h-82199BE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82199BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199BE4);
		  /* 82199BE4h */ case    0:  		/* lwz R10, <#[R7]> */
		/* 82199BE4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 82199BE4h case    0:*/		return 0x82199BE8;
		  /* 82199BE8h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 82199BE8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82199BE8h case    1:*/		return 0x82199BEC;
		  /* 82199BECh */ case    2:  		/* bc 4, CR6_EQ, -4640 */
		/* 82199BECh case    2:*/		if ( !regs.CR[6].eq ) { return 0x821989CC;  }
		/* 82199BECh case    2:*/		return 0x82199BF0;
		  /* 82199BF0h */ case    3:  		/* addi R7, R11, 8 */
		/* 82199BF0h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x8);
		/* 82199BF0h case    3:*/		return 0x82199BF4;
		  /* 82199BF4h */ case    4:  		/* b -4648 */
		/* 82199BF4h case    4:*/		return 0x821989CC;
		/* 82199BF4h case    4:*/		return 0x82199BF8;
	}
	return 0x82199BF8;
} // Block from 82199BE4h-82199BF8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82199BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199BF8);
		  /* 82199BF8h */ case    0:  		/* lwz R31, <#[R14]> */
		/* 82199BF8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R14 + 0x00000000) );
		/* 82199BF8h case    0:*/		return 0x82199BFC;
		  /* 82199BFCh */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 82199BFCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82199BFCh case    1:*/		return 0x82199C00;
		  /* 82199C00h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 82199C00h case    2:*/		if ( regs.CR[6].eq ) { return 0x82199C24;  }
		/* 82199C00h case    2:*/		return 0x82199C04;
		  /* 82199C04h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 82199C04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82199C04h case    3:*/		return 0x82199C08;
		  /* 82199C08h */ case    4:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 82199C08h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 82199C08h case    4:*/		return 0x82199C0C;
		  /* 82199C0Ch */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82199C0Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x82199C1C;  }
		/* 82199C0Ch case    5:*/		return 0x82199C10;
		  /* 82199C10h */ case    6:  		/* mr R4, R31 */
		/* 82199C10h case    6:*/		regs.R4 = regs.R31;
		/* 82199C10h case    6:*/		return 0x82199C14;
		  /* 82199C14h */ case    7:  		/* mr R3, R15 */
		/* 82199C14h case    7:*/		regs.R3 = regs.R15;
		/* 82199C14h case    7:*/		return 0x82199C18;
		  /* 82199C18h */ case    8:  		/* bl -137808 */
		/* 82199C18h case    8:*/		regs.LR = 0x82199C1C; return 0x821781C8;
		/* 82199C18h case    8:*/		return 0x82199C1C;
	}
	return 0x82199C1C;
} // Block from 82199BF8h-82199C1Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82199C1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199C1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199C1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199C1C);
		  /* 82199C1Ch */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 82199C1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 82199C1Ch case    0:*/		return 0x82199C20;
		  /* 82199C20h */ case    1:  		/* b -36 */
		/* 82199C20h case    1:*/		return 0x82199BFC;
		/* 82199C20h case    1:*/		return 0x82199C24;
	}
	return 0x82199C24;
} // Block from 82199C1Ch-82199C24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82199C24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199C24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199C24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199C24);
		  /* 82199C24h */ case    0:  		/* mr R3, R15 */
		/* 82199C24h case    0:*/		regs.R3 = regs.R15;
		/* 82199C24h case    0:*/		return 0x82199C28;
		  /* 82199C28h */ case    1:  		/* bl -137392 */
		/* 82199C28h case    1:*/		regs.LR = 0x82199C2C; return 0x82178378;
		/* 82199C28h case    1:*/		return 0x82199C2C;
		  /* 82199C2Ch */ case    2:  		/* lwz R11, <#[R14 + 8]> */
		/* 82199C2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199C2Ch case    2:*/		return 0x82199C30;
		  /* 82199C30h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82199C30h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82199C30h case    3:*/		return 0x82199C34;
		  /* 82199C34h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82199C34h case    4:*/		if ( regs.CR[0].eq ) { return 0x82199C44;  }
		/* 82199C34h case    4:*/		return 0x82199C38;
		  /* 82199C38h */ case    5:  		/* lwz R11, <#[R15 + 8]> */
		/* 82199C38h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 82199C38h case    5:*/		return 0x82199C3C;
		  /* 82199C3Ch */ case    6:  		/* ori R11, R11, 1 */
		/* 82199C3Ch case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82199C3Ch case    6:*/		return 0x82199C40;
		  /* 82199C40h */ case    7:  		/* stw R11, <#[R15 + 8]> */
		/* 82199C40h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 82199C40h case    7:*/		return 0x82199C44;
	}
	return 0x82199C44;
} // Block from 82199C24h-82199C44h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82199C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199C44);
		  /* 82199C44h */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82199C44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199C44h case    0:*/		return 0x82199C48;
		  /* 82199C48h */ case    1:  		/* rlwinm. R11, R11, 7, 31, 31 */
		/* 82199C48h case    1:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R11);
		/* 82199C48h case    1:*/		return 0x82199C4C;
		  /* 82199C4Ch */ case    2:  		/* bc 12, CR0_EQ, 64 */
		/* 82199C4Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x82199C8C;  }
		/* 82199C4Ch case    2:*/		return 0x82199C50;
		  /* 82199C50h */ case    3:  		/* lwz R9, <#[R15 + 8]> */
		/* 82199C50h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R15 + 0x00000008) );
		/* 82199C50h case    3:*/		return 0x82199C54;
		  /* 82199C54h */ case    4:  		/* li R10, 4 */
		/* 82199C54h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 82199C54h case    4:*/		return 0x82199C58;
		  /* 82199C58h */ case    5:  		/* addi R11, R20, 92 */
		/* 82199C58h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R20,0x5C);
		/* 82199C58h case    5:*/		return 0x82199C5C;
		  /* 82199C5Ch */ case    6:  		/* oris R9, R9, 512 */
		/* 82199C5Ch case    6:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R9,0x200);
		/* 82199C5Ch case    6:*/		return 0x82199C60;
		  /* 82199C60h */ case    7:  		/* stw R9, <#[R15 + 8]> */
		/* 82199C60h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R15 + 0x00000008) );
		/* 82199C60h case    7:*/		return 0x82199C64;
		  /* 82199C64h */ case    8:  		/* mtspr CTR, R10 */
		/* 82199C64h case    8:*/		regs.CTR = regs.R10;
		/* 82199C64h case    8:*/		return 0x82199C68;
		  /* 82199C68h */ case    9:  		/* lwz R10, <#[R14 + 8]> */
		/* 82199C68h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000008) );
		/* 82199C68h case    9:*/		return 0x82199C6C;
		  /* 82199C6Ch */ case   10:  		/* rlwinm R10, R10, 0, 7, 5 */
		/* 82199C6Ch case   10:*/		cpu::op::rlwinm<0,0,7,5>(regs,&regs.R10,regs.R10);
		/* 82199C6Ch case   10:*/		return 0x82199C70;
		  /* 82199C70h */ case   11:  		/* stw R10, <#[R14 + 8]> */
		/* 82199C70h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R14 + 0x00000008) );
		/* 82199C70h case   11:*/		return 0x82199C74;
		  /* 82199C74h */ case   12:  		/* lwz R10, <#[R11]> */
		/* 82199C74h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199C74h case   12:*/		return 0x82199C78;
		  /* 82199C78h */ case   13:  		/* cmplw CR6, R10, R14 */
		/* 82199C78h case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R14);
		/* 82199C78h case   13:*/		return 0x82199C7C;
		  /* 82199C7Ch */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 82199C7Ch case   14:*/		if ( !regs.CR[6].eq ) { return 0x82199C84;  }
		/* 82199C7Ch case   14:*/		return 0x82199C80;
		  /* 82199C80h */ case   15:  		/* stw R15, <#[R11]> */
		/* 82199C80h case   15:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000000) );
		/* 82199C80h case   15:*/		return 0x82199C84;
	}
	return 0x82199C84;
} // Block from 82199C44h-82199C84h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82199C84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199C84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199C84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199C84);
		  /* 82199C84h */ case    0:  		/* addi R11, R11, 4 */
		/* 82199C84h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82199C84h case    0:*/		return 0x82199C88;
		  /* 82199C88h */ case    1:  		/* bc 16, CR0_LT, -20 */
		/* 82199C88h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82199C74;  }
		/* 82199C88h case    1:*/		return 0x82199C8C;
	}
	return 0x82199C8C;
} // Block from 82199C84h-82199C8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82199C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199C8C);
		  /* 82199C8Ch */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82199C8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199C8Ch case    0:*/		return 0x82199C90;
		  /* 82199C90h */ case    1:  		/* rlwinm R11, R11, 0, 27, 25 */
		/* 82199C90h case    1:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R11,regs.R11);
		/* 82199C90h case    1:*/		return 0x82199C94;
		  /* 82199C94h */ case    2:  		/* stw R11, <#[R14 + 8]> */
		/* 82199C94h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199C94h case    2:*/		return 0x82199C98;
		  /* 82199C98h */ case    3:  		/* lwz R11, <#[R15 + 8]> */
		/* 82199C98h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 82199C98h case    3:*/		return 0x82199C9C;
		  /* 82199C9Ch */ case    4:  		/* rlwinm. R10, R11, 9, 31, 31 */
		/* 82199C9Ch case    4:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R11);
		/* 82199C9Ch case    4:*/		return 0x82199CA0;
		  /* 82199CA0h */ case    5:  		/* bc 12, CR0_EQ, 944 */
		/* 82199CA0h case    5:*/		if ( regs.CR[0].eq ) { return 0x8219A050;  }
		/* 82199CA0h case    5:*/		return 0x82199CA4;
		  /* 82199CA4h */ case    6:  		/* lwz R10, <#[R15 + 16]> */
		/* 82199CA4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000010) );
		/* 82199CA4h case    6:*/		return 0x82199CA8;
		  /* 82199CA8h */ case    7:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 82199CA8h case    7:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 82199CA8h case    7:*/		return 0x82199CAC;
		  /* 82199CACh */ case    8:  		/* rlwinm R10, R10, 0, 13, 10 */
		/* 82199CACh case    8:*/		cpu::op::rlwinm<0,0,13,10>(regs,&regs.R10,regs.R10);
		/* 82199CACh case    8:*/		return 0x82199CB0;
		  /* 82199CB0h */ case    9:  		/* stw R11, <#[R15 + 8]> */
		/* 82199CB0h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 82199CB0h case    9:*/		return 0x82199CB4;
		  /* 82199CB4h */ case   10:  		/* stw R10, <#[R15 + 16]> */
		/* 82199CB4h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R15 + 0x00000010) );
		/* 82199CB4h case   10:*/		return 0x82199CB8;
		  /* 82199CB8h */ case   11:  		/* b 920 */
		/* 82199CB8h case   11:*/		return 0x8219A050;
		/* 82199CB8h case   11:*/		return 0x82199CBC;
	}
	return 0x82199CBC;
} // Block from 82199C8Ch-82199CBCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 82199CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199CBC);
		  /* 82199CBCh */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82199CBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199CBCh case    0:*/		return 0x82199CC0;
		  /* 82199CC0h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82199CC0h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82199CC0h case    1:*/		return 0x82199CC4;
		  /* 82199CC4h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 82199CC4h case    2:*/		if ( regs.CR[0].eq ) { return 0x82199CE0;  }
		/* 82199CC4h case    2:*/		return 0x82199CC8;
		  /* 82199CC8h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 82199CC8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82199CC8h case    3:*/		return 0x82199CCC;
		  /* 82199CCCh */ case    4:  		/* ori R11, R11, 1 */
		/* 82199CCCh case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82199CCCh case    4:*/		return 0x82199CD0;
		  /* 82199CD0h */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 82199CD0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82199CD0h case    5:*/		return 0x82199CD4;
		  /* 82199CD4h */ case    6:  		/* lwz R11, <#[R29]> */
		/* 82199CD4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82199CD4h case    6:*/		return 0x82199CD8;
		  /* 82199CD8h */ case    7:  		/* ori R11, R11, 1 */
		/* 82199CD8h case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82199CD8h case    7:*/		return 0x82199CDC;
		  /* 82199CDCh */ case    8:  		/* stw R11, <#[R29]> */
		/* 82199CDCh case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82199CDCh case    8:*/		return 0x82199CE0;
	}
	return 0x82199CE0;
} // Block from 82199CBCh-82199CE0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82199CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199CE0);
		  /* 82199CE0h */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 82199CE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 82199CE0h case    0:*/		return 0x82199CE4;
		  /* 82199CE4h */ case    1:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82199CE4h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82199CE4h case    1:*/		return 0x82199CE8;
		  /* 82199CE8h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 82199CE8h case    2:*/		if ( regs.CR[0].eq ) { return 0x82199D04;  }
		/* 82199CE8h case    2:*/		return 0x82199CEC;
		  /* 82199CECh */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 82199CECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82199CECh case    3:*/		return 0x82199CF0;
		  /* 82199CF0h */ case    4:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 82199CF0h case    4:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 82199CF0h case    4:*/		return 0x82199CF4;
		  /* 82199CF4h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82199CF4h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82199D04;  }
		/* 82199CF4h case    5:*/		return 0x82199CF8;
		  /* 82199CF8h */ case    6:  		/* mr R4, R31 */
		/* 82199CF8h case    6:*/		regs.R4 = regs.R31;
		/* 82199CF8h case    6:*/		return 0x82199CFC;
		  /* 82199CFCh */ case    7:  		/* mr R3, R21 */
		/* 82199CFCh case    7:*/		regs.R3 = regs.R21;
		/* 82199CFCh case    7:*/		return 0x82199D00;
		  /* 82199D00h */ case    8:  		/* bl 118088 */
		/* 82199D00h case    8:*/		regs.LR = 0x82199D04; return 0x821B6A48;
		/* 82199D00h case    8:*/		return 0x82199D04;
	}
	return 0x82199D04;
} // Block from 82199CE0h-82199D04h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82199D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199D04);
		  /* 82199D04h */ case    0:  		/* lwz R11, <#[R22]> */
		/* 82199D04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 82199D04h case    0:*/		return 0x82199D08;
		  /* 82199D08h */ case    1:  		/* addi R28, R28, 1 */
		/* 82199D08h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82199D08h case    1:*/		return 0x82199D0C;
		  /* 82199D0Ch */ case    2:  		/* addi R27, R27, 2 */
		/* 82199D0Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x2);
		/* 82199D0Ch case    2:*/		return 0x82199D10;
		  /* 82199D10h */ case    3:  		/* rlwinm R10, R11, 7, 29, 31 */
		/* 82199D10h case    3:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R11);
		/* 82199D10h case    3:*/		return 0x82199D14;
		  /* 82199D14h */ case    4:  		/* cmplw CR6, R28, R10 */
		/* 82199D14h case    4:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 82199D14h case    4:*/		return 0x82199D18;
		  /* 82199D18h */ case    5:  		/* bc 12, CR6_LT, -3320 */
		/* 82199D18h case    5:*/		if ( regs.CR[6].lt ) { return 0x82199020;  }
		/* 82199D18h case    5:*/		return 0x82199D1C;
	}
	return 0x82199D1C;
} // Block from 82199D04h-82199D1Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82199D1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199D1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199D1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199D1C);
		  /* 82199D1Ch */ case    0:  		/* mr R7, R24 */
		/* 82199D1Ch case    0:*/		regs.R7 = regs.R24;
		/* 82199D1Ch case    0:*/		return 0x82199D20;
		  /* 82199D20h */ case    1:  		/* lwz R11, <#[R7]> */
		/* 82199D20h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82199D20h case    1:*/		return 0x82199D24;
		  /* 82199D24h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82199D24h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82199D24h case    2:*/		return 0x82199D28;
		  /* 82199D28h */ case    3:  		/* bc 12, CR6_EQ, 348 */
		/* 82199D28h case    3:*/		if ( regs.CR[6].eq ) { return 0x82199E84;  }
		/* 82199D28h case    3:*/		return 0x82199D2C;
		  /* 82199D2Ch */ case    4:  		/* lwz R10, <#[R11 + 16]> */
		/* 82199D2Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82199D2Ch case    4:*/		return 0x82199D30;
		  /* 82199D30h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 82199D30h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82199D30h case    5:*/		return 0x82199D34;
		  /* 82199D34h */ case    6:  		/* bc 12, CR6_EQ, 316 */
		/* 82199D34h case    6:*/		if ( regs.CR[6].eq ) { return 0x82199E70;  }
		/* 82199D34h case    6:*/		return 0x82199D38;
		  /* 82199D38h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 82199D38h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199D38h case    7:*/		return 0x82199D3C;
		  /* 82199D3Ch */ case    8:  		/* rlwinm. R9, R10, 7, 29, 31 */
		/* 82199D3Ch case    8:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R9,regs.R10);
		/* 82199D3Ch case    8:*/		return 0x82199D40;
		  /* 82199D40h */ case    9:  		/* bc 12, CR0_EQ, 304 */
		/* 82199D40h case    9:*/		if ( regs.CR[0].eq ) { return 0x82199E70;  }
		/* 82199D40h case    9:*/		return 0x82199D44;
		  /* 82199D44h */ case   10:  		/* addic. R9, R9, -1 */
		/* 82199D44h case   10:*/		cpu::op::addic<1>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82199D44h case   10:*/		return 0x82199D48;
		  /* 82199D48h */ case   11:  		/* bc 4, CR0_EQ, 132 */
		/* 82199D48h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82199DCC;  }
		/* 82199D48h case   11:*/		return 0x82199D4C;
		  /* 82199D4Ch */ case   12:  		/* lwz R8, <#[R22]> */
		/* 82199D4Ch case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R22 + 0x00000000) );
		/* 82199D4Ch case   12:*/		return 0x82199D50;
		  /* 82199D50h */ case   13:  		/* rlwinm R10, R10, 28, 29, 30 */
		/* 82199D50h case   13:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R10,regs.R10);
		/* 82199D50h case   13:*/		return 0x82199D54;
		  /* 82199D54h */ case   14:  		/* lwz R9, <#[R11 + 12]> */
		/* 82199D54h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82199D54h case   14:*/		return 0x82199D58;
		  /* 82199D58h */ case   15:  		/* rlwinm R8, R8, 27, 24, 31 */
		/* 82199D58h case   15:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R8);
		/* 82199D58h case   15:*/		return 0x82199D5C;
		  /* 82199D5Ch */ case   16:  		/* srw R10, R8, R10 */
		/* 82199D5Ch case   16:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82199D5Ch case   16:*/		return 0x82199D60;
		  /* 82199D60h */ case   17:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 82199D60h case   17:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 82199D60h case   17:*/		return 0x82199D64;
		  /* 82199D64h */ case   18:  		/* addi R8, R10, 11 */
		/* 82199D64h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0xB);
		/* 82199D64h case   18:*/		return 0x82199D68;
		  /* 82199D68h */ case   19:  		/* addi R10, R9, 4 */
		/* 82199D68h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x4);
		/* 82199D68h case   19:*/		return 0x82199D6C;
		  /* 82199D6Ch */ case   20:  		/* lwz R9, <#[R9 + 4]> */
		/* 82199D6Ch case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82199D6Ch case   20:*/		return 0x82199D70;
		  /* 82199D70h */ case   21:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82199D70h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82199D70h case   21:*/		return 0x82199D74;
		  /* 82199D74h */ case   22:  		/* lwzx R8, <#[R8 + R26]> */
		/* 82199D74h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R26 + 0x00000000) );
		/* 82199D74h case   22:*/		return 0x82199D78;
		  /* 82199D78h */ case   23:  		/* lwz R8, <#[R8 + 12]> */
		/* 82199D78h case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 82199D78h case   23:*/		return 0x82199D7C;
		  /* 82199D7Ch */ case   24:  		/* b 12 */
		/* 82199D7Ch case   24:*/		return 0x82199D88;
		/* 82199D7Ch case   24:*/		return 0x82199D80;
		  /* 82199D80h */ case   25:  		/* addi R10, R9, 8 */
		/* 82199D80h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 82199D80h case   25:*/		return 0x82199D84;
		  /* 82199D84h */ case   26:  		/* lwz R9, <#[R9 + 8]> */
		/* 82199D84h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82199D84h case   26:*/		return 0x82199D88;
	}
	return 0x82199D88;
} // Block from 82199D1Ch-82199D88h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82199D88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199D88);
		  /* 82199D88h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82199D88h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82199D88h case    0:*/		return 0x82199D8C;
		  /* 82199D8Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82199D8Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82199D80;  }
		/* 82199D8Ch case    1:*/		return 0x82199D90;
		  /* 82199D90h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 82199D90h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82199D90h case    2:*/		return 0x82199D94;
		  /* 82199D94h */ case    3:  		/* stw R9, <#[R10]> */
		/* 82199D94h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82199D94h case    3:*/		return 0x82199D98;
		  /* 82199D98h */ case    4:  		/* lwz R10, <#[R8 + 4]> */
		/* 82199D98h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 82199D98h case    4:*/		return 0x82199D9C;
		  /* 82199D9Ch */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 82199D9Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82199D9Ch case    5:*/		return 0x82199DA0;
		  /* 82199DA0h */ case    6:  		/* stw R11, <#[R8 + 4]> */
		/* 82199DA0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 82199DA0h case    6:*/		return 0x82199DA4;
		  /* 82199DA4h */ case    7:  		/* stw R8, <#[R11 + 12]> */
		/* 82199DA4h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82199DA4h case    7:*/		return 0x82199DA8;
		  /* 82199DA8h */ case    8:  		/* lwz R10, <#[R11]> */
		/* 82199DA8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199DA8h case    8:*/		return 0x82199DAC;
		  /* 82199DACh */ case    9:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 82199DACh case    9:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 82199DACh case    9:*/		return 0x82199DB0;
		  /* 82199DB0h */ case   10:  		/* stw R10, <#[R11]> */
		/* 82199DB0h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199DB0h case   10:*/		return 0x82199DB4;
		  /* 82199DB4h */ case   11:  		/* lwz R9, <#[R8 + 8]> */
		/* 82199DB4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000008) );
		/* 82199DB4h case   11:*/		return 0x82199DB8;
		  /* 82199DB8h */ case   12:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82199DB8h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82199DB8h case   12:*/		return 0x82199DBC;
		  /* 82199DBCh */ case   13:  		/* bc 12, CR0_EQ, 180 */
		/* 82199DBCh case   13:*/		if ( regs.CR[0].eq ) { return 0x82199E70;  }
		/* 82199DBCh case   13:*/		return 0x82199DC0;
		  /* 82199DC0h */ case   14:  		/* ori R10, R10, 1 */
		/* 82199DC0h case   14:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82199DC0h case   14:*/		return 0x82199DC4;
		  /* 82199DC4h */ case   15:  		/* stw R10, <#[R11]> */
		/* 82199DC4h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199DC4h case   15:*/		return 0x82199DC8;
		  /* 82199DC8h */ case   16:  		/* b 168 */
		/* 82199DC8h case   16:*/		return 0x82199E70;
		/* 82199DC8h case   16:*/		return 0x82199DCC;
	}
	return 0x82199DCC;
} // Block from 82199D88h-82199DCCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82199DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199DCC);
		  /* 82199DCCh */ case    0:  		/* lwz R10, <#[R11 + 12]> */
		/* 82199DCCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82199DCCh case    0:*/		return 0x82199DD0;
		  /* 82199DD0h */ case    1:  		/* addi R10, R10, 4 */
		/* 82199DD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82199DD0h case    1:*/		return 0x82199DD4;
		  /* 82199DD4h */ case    2:  		/* lwz R9, <#[R10]> */
		/* 82199DD4h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82199DD4h case    2:*/		return 0x82199DD8;
		  /* 82199DD8h */ case    3:  		/* b 12 */
		/* 82199DD8h case    3:*/		return 0x82199DE4;
		/* 82199DD8h case    3:*/		return 0x82199DDC;
		  /* 82199DDCh */ case    4:  		/* addi R10, R9, 8 */
		/* 82199DDCh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 82199DDCh case    4:*/		return 0x82199DE0;
		  /* 82199DE0h */ case    5:  		/* lwz R9, <#[R9 + 8]> */
		/* 82199DE0h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82199DE0h case    5:*/		return 0x82199DE4;
	}
	return 0x82199DE4;
} // Block from 82199DCCh-82199DE4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82199DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199DE4);
		  /* 82199DE4h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82199DE4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82199DE4h case    0:*/		return 0x82199DE8;
		  /* 82199DE8h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82199DE8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82199DDC;  }
		/* 82199DE8h case    1:*/		return 0x82199DEC;
		  /* 82199DECh */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 82199DECh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82199DECh case    2:*/		return 0x82199DF0;
		  /* 82199DF0h */ case    3:  		/* stw R9, <#[R10]> */
		/* 82199DF0h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82199DF0h case    3:*/		return 0x82199DF4;
		  /* 82199DF4h */ case    4:  		/* lwz R10, <#[R26 + 4]> */
		/* 82199DF4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 82199DF4h case    4:*/		return 0x82199DF8;
		  /* 82199DF8h */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 82199DF8h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82199DF8h case    5:*/		return 0x82199DFC;
		  /* 82199DFCh */ case    6:  		/* stw R11, <#[R26 + 4]> */
		/* 82199DFCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82199DFCh case    6:*/		return 0x82199E00;
		  /* 82199E00h */ case    7:  		/* stw R26, <#[R11 + 12]> */
		/* 82199E00h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000000C) );
		/* 82199E00h case    7:*/		return 0x82199E04;
		  /* 82199E04h */ case    8:  		/* lwz R10, <#[R11]> */
		/* 82199E04h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199E04h case    8:*/		return 0x82199E08;
		  /* 82199E08h */ case    9:  		/* lwz R9, <#[R22]> */
		/* 82199E08h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000000) );
		/* 82199E08h case    9:*/		return 0x82199E0C;
		  /* 82199E0Ch */ case   10:  		/* rlwinm R10, R10, 27, 24, 31 */
		/* 82199E0Ch case   10:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R10);
		/* 82199E0Ch case   10:*/		return 0x82199E10;
		  /* 82199E10h */ case   11:  		/* lwz R8, <#[R11]> */
		/* 82199E10h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82199E10h case   11:*/		return 0x82199E14;
		  /* 82199E14h */ case   12:  		/* rlwinm R9, R9, 27, 24, 31 */
		/* 82199E14h case   12:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R9);
		/* 82199E14h case   12:*/		return 0x82199E18;
		  /* 82199E18h */ case   13:  		/* rlwinm R6, R10, 27, 29, 30 */
		/* 82199E18h case   13:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R6,regs.R10);
		/* 82199E18h case   13:*/		return 0x82199E1C;
		  /* 82199E1Ch */ case   14:  		/* rlwinm R5, R10, 29, 29, 30 */
		/* 82199E1Ch case   14:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R5,regs.R10);
		/* 82199E1Ch case   14:*/		return 0x82199E20;
		  /* 82199E20h */ case   15:  		/* srw R6, R9, R6 */
		/* 82199E20h case   15:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R9,regs.R6);
		/* 82199E20h case   15:*/		return 0x82199E24;
		  /* 82199E24h */ case   16:  		/* srw R5, R9, R5 */
		/* 82199E24h case   16:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R9,regs.R5);
		/* 82199E24h case   16:*/		return 0x82199E28;
		  /* 82199E28h */ case   17:  		/* rlwimi R5, R6, 2, 28, 29 */
		/* 82199E28h case   17:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R5,regs.R6);
		/* 82199E28h case   17:*/		return 0x82199E2C;
		  /* 82199E2Ch */ case   18:  		/* rlwinm R6, R10, 31, 29, 30 */
		/* 82199E2Ch case   18:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R6,regs.R10);
		/* 82199E2Ch case   18:*/		return 0x82199E30;
		  /* 82199E30h */ case   19:  		/* rlwinm R10, R10, 1, 29, 30 */
		/* 82199E30h case   19:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R10,regs.R10);
		/* 82199E30h case   19:*/		return 0x82199E34;
		  /* 82199E34h */ case   20:  		/* srw R6, R9, R6 */
		/* 82199E34h case   20:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R9,regs.R6);
		/* 82199E34h case   20:*/		return 0x82199E38;
		  /* 82199E38h */ case   21:  		/* rlwinm R5, R5, 0, 28, 31 */
		/* 82199E38h case   21:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R5,regs.R5);
		/* 82199E38h case   21:*/		return 0x82199E3C;
		  /* 82199E3Ch */ case   22:  		/* srw R10, R9, R10 */
		/* 82199E3Ch case   22:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82199E3Ch case   22:*/		return 0x82199E40;
		  /* 82199E40h */ case   23:  		/* rlwimi R6, R5, 2, 0, 29 */
		/* 82199E40h case   23:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R6,regs.R5);
		/* 82199E40h case   23:*/		return 0x82199E44;
		  /* 82199E44h */ case   24:  		/* rlwinm R9, R8, 0, 27, 18 */
		/* 82199E44h case   24:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R9,regs.R8);
		/* 82199E44h case   24:*/		return 0x82199E48;
		  /* 82199E48h */ case   25:  		/* rlwimi R10, R6, 2, 0, 29 */
		/* 82199E48h case   25:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 82199E48h case   25:*/		return 0x82199E4C;
		  /* 82199E4Ch */ case   26:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 82199E4Ch case   26:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 82199E4Ch case   26:*/		return 0x82199E50;
		  /* 82199E50h */ case   27:  		/* or R10, R10, R9 */
		/* 82199E50h case   27:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82199E50h case   27:*/		return 0x82199E54;
		  /* 82199E54h */ case   28:  		/* stw R10, <#[R11]> */
		/* 82199E54h case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199E54h case   28:*/		return 0x82199E58;
		  /* 82199E58h */ case   29:  		/* lwz R9, <#[R14 + 8]> */
		/* 82199E58h case   29:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R14 + 0x00000008) );
		/* 82199E58h case   29:*/		return 0x82199E5C;
		  /* 82199E5Ch */ case   30:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82199E5Ch case   30:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82199E5Ch case   30:*/		return 0x82199E60;
		  /* 82199E60h */ case   31:  		/* bc 12, CR0_EQ, 16 */
		/* 82199E60h case   31:*/		if ( regs.CR[0].eq ) { return 0x82199E70;  }
		/* 82199E60h case   31:*/		return 0x82199E64;
		  /* 82199E64h */ case   32:  		/* addi R9, R10, -1 */
		/* 82199E64h case   32:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 82199E64h case   32:*/		return 0x82199E68;
		  /* 82199E68h */ case   33:  		/* rlwimi R9, R10, 0, 0, 26 */
		/* 82199E68h case   33:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R9,regs.R10);
		/* 82199E68h case   33:*/		return 0x82199E6C;
		  /* 82199E6Ch */ case   34:  		/* stw R9, <#[R11]> */
		/* 82199E6Ch case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82199E6Ch case   34:*/		return 0x82199E70;
	}
	return 0x82199E70;
} // Block from 82199DE4h-82199E70h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82199E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199E70);
		  /* 82199E70h */ case    0:  		/* lwz R10, <#[R7]> */
		/* 82199E70h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 82199E70h case    0:*/		return 0x82199E74;
		  /* 82199E74h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 82199E74h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82199E74h case    1:*/		return 0x82199E78;
		  /* 82199E78h */ case    2:  		/* bc 4, CR6_EQ, -344 */
		/* 82199E78h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82199D20;  }
		/* 82199E78h case    2:*/		return 0x82199E7C;
		  /* 82199E7Ch */ case    3:  		/* addi R7, R11, 8 */
		/* 82199E7Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x8);
		/* 82199E7Ch case    3:*/		return 0x82199E80;
		  /* 82199E80h */ case    4:  		/* b -352 */
		/* 82199E80h case    4:*/		return 0x82199D20;
		/* 82199E80h case    4:*/		return 0x82199E84;
	}
	return 0x82199E84;
} // Block from 82199E70h-82199E84h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82199E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199E84);
		  /* 82199E84h */ case    0:  		/* li R6, 1 */
		/* 82199E84h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82199E84h case    0:*/		return 0x82199E88;
		  /* 82199E88h */ case    1:  		/* li R5, 0 */
		/* 82199E88h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82199E88h case    1:*/		return 0x82199E8C;
		  /* 82199E8Ch */ case    2:  		/* mr R4, R14 */
		/* 82199E8Ch case    2:*/		regs.R4 = regs.R14;
		/* 82199E8Ch case    2:*/		return 0x82199E90;
		  /* 82199E90h */ case    3:  		/* mr R3, R21 */
		/* 82199E90h case    3:*/		regs.R3 = regs.R21;
		/* 82199E90h case    3:*/		return 0x82199E94;
		  /* 82199E94h */ case    4:  		/* bl 595252 */
		/* 82199E94h case    4:*/		regs.LR = 0x82199E98; return 0x8222B3C8;
		/* 82199E94h case    4:*/		return 0x82199E98;
		  /* 82199E98h */ case    5:  		/* mr R3, R26 */
		/* 82199E98h case    5:*/		regs.R3 = regs.R26;
		/* 82199E98h case    5:*/		return 0x82199E9C;
		  /* 82199E9Ch */ case    6:  		/* bl -218396 */
		/* 82199E9Ch case    6:*/		regs.LR = 0x82199EA0; return 0x82164980;
		/* 82199E9Ch case    6:*/		return 0x82199EA0;
		  /* 82199EA0h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82199EA0h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82199EA0h case    7:*/		return 0x82199EA4;
		  /* 82199EA4h */ case    8:  		/* bc 12, CR0_EQ, -10776 */
		/* 82199EA4h case    8:*/		if ( regs.CR[0].eq ) { return 0x8219748C;  }
		/* 82199EA4h case    8:*/		return 0x82199EA8;
		  /* 82199EA8h */ case    9:  		/* mr R4, R26 */
		/* 82199EA8h case    9:*/		regs.R4 = regs.R26;
		/* 82199EA8h case    9:*/		return 0x82199EAC;
		  /* 82199EACh */ case   10:  		/* b -2044 */
		/* 82199EACh case   10:*/		return 0x821996B0;
		/* 82199EACh case   10:*/		return 0x82199EB0;
	}
	return 0x82199EB0;
} // Block from 82199E84h-82199EB0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82199EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199EB0);
		  /* 82199EB0h */ case    0:  		/* li R7, 0 */
		/* 82199EB0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82199EB0h case    0:*/		return 0x82199EB4;
		  /* 82199EB4h */ case    1:  		/* li R6, 1 */
		/* 82199EB4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82199EB4h case    1:*/		return 0x82199EB8;
		  /* 82199EB8h */ case    2:  		/* mr R5, R14 */
		/* 82199EB8h case    2:*/		regs.R5 = regs.R14;
		/* 82199EB8h case    2:*/		return 0x82199EBC;
		  /* 82199EBCh */ case    3:  		/* mr R4, R26 */
		/* 82199EBCh case    3:*/		regs.R4 = regs.R26;
		/* 82199EBCh case    3:*/		return 0x82199EC0;
		  /* 82199EC0h */ case    4:  		/* mr R3, R21 */
		/* 82199EC0h case    4:*/		regs.R3 = regs.R21;
		/* 82199EC0h case    4:*/		return 0x82199EC4;
		  /* 82199EC4h */ case    5:  		/* bl 605380 */
		/* 82199EC4h case    5:*/		regs.LR = 0x82199EC8; return 0x8222DB88;
		/* 82199EC4h case    5:*/		return 0x82199EC8;
		  /* 82199EC8h */ case    6:  		/* lwz R11, <#[R26 + 44]> */
		/* 82199EC8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000002C) );
		/* 82199EC8h case    6:*/		return 0x82199ECC;
		  /* 82199ECCh */ case    7:  		/* lwz R10, <#[R1 + 108]> */
		/* 82199ECCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000006C) );
		/* 82199ECCh case    7:*/		return 0x82199ED0;
		  /* 82199ED0h */ case    8:  		/* cmplw CR6, R10, R11 */
		/* 82199ED0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82199ED0h case    8:*/		return 0x82199ED4;
		  /* 82199ED4h */ case    9:  		/* bc 12, CR6_EQ, 44 */
		/* 82199ED4h case    9:*/		if ( regs.CR[6].eq ) { return 0x82199F00;  }
		/* 82199ED4h case    9:*/		return 0x82199ED8;
		  /* 82199ED8h */ case   10:  		/* lwz R4, <#[R1 + 88]> */
		/* 82199ED8h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 82199ED8h case   10:*/		return 0x82199EDC;
		  /* 82199EDCh */ case   11:  		/* mr R3, R21 */
		/* 82199EDCh case   11:*/		regs.R3 = regs.R21;
		/* 82199EDCh case   11:*/		return 0x82199EE0;
		  /* 82199EE0h */ case   12:  		/* lwz R5, <#[R4 + 12]> */
		/* 82199EE0h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x0000000C) );
		/* 82199EE0h case   12:*/		return 0x82199EE4;
		  /* 82199EE4h */ case   13:  		/* bl -167412 */
		/* 82199EE4h case   13:*/		regs.LR = 0x82199EE8; return 0x821710F0;
		/* 82199EE4h case   13:*/		return 0x82199EE8;
		  /* 82199EE8h */ case   14:  		/* stw R3, <#[R1 + 88]> */
		/* 82199EE8h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 82199EE8h case   14:*/		return 0x82199EEC;
		  /* 82199EECh */ case   15:  		/* mr R6, R21 */
		/* 82199EECh case   15:*/		regs.R6 = regs.R21;
		/* 82199EECh case   15:*/		return 0x82199EF0;
		  /* 82199EF0h */ case   16:  		/* li R4, 0 */
		/* 82199EF0h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82199EF0h case   16:*/		return 0x82199EF4;
		  /* 82199EF4h */ case   17:  		/* lwz R5, <#[R1 + 108]> */
		/* 82199EF4h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000006C) );
		/* 82199EF4h case   17:*/		return 0x82199EF8;
		  /* 82199EF8h */ case   18:  		/* mr R3, R26 */
		/* 82199EF8h case   18:*/		regs.R3 = regs.R26;
		/* 82199EF8h case   18:*/		return 0x82199EFC;
		  /* 82199EFCh */ case   19:  		/* bl -131332 */
		/* 82199EFCh case   19:*/		regs.LR = 0x82199F00; return 0x82179DF8;
		/* 82199EFCh case   19:*/		return 0x82199F00;
	}
	return 0x82199F00;
} // Block from 82199EB0h-82199F00h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82199F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199F00);
		  /* 82199F00h */ case    0:  		/* lwz R11, <#[R26 + 48]> */
		/* 82199F00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000030) );
		/* 82199F00h case    0:*/		return 0x82199F04;
		  /* 82199F04h */ case    1:  		/* lwz R5, <#[R1 + 88]> */
		/* 82199F04h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 82199F04h case    1:*/		return 0x82199F08;
		  /* 82199F08h */ case    2:  		/* cmplw CR6, R5, R11 */
		/* 82199F08h case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 82199F08h case    2:*/		return 0x82199F0C;
		  /* 82199F0Ch */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 82199F0Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82199F20;  }
		/* 82199F0Ch case    3:*/		return 0x82199F10;
		  /* 82199F10h */ case    4:  		/* mr R6, R21 */
		/* 82199F10h case    4:*/		regs.R6 = regs.R21;
		/* 82199F10h case    4:*/		return 0x82199F14;
		  /* 82199F14h */ case    5:  		/* li R4, 1 */
		/* 82199F14h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82199F14h case    5:*/		return 0x82199F18;
		  /* 82199F18h */ case    6:  		/* mr R3, R26 */
		/* 82199F18h case    6:*/		regs.R3 = regs.R26;
		/* 82199F18h case    6:*/		return 0x82199F1C;
		  /* 82199F1Ch */ case    7:  		/* bl -131364 */
		/* 82199F1Ch case    7:*/		regs.LR = 0x82199F20; return 0x82179DF8;
		/* 82199F1Ch case    7:*/		return 0x82199F20;
	}
	return 0x82199F20;
} // Block from 82199F00h-82199F20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82199F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199F20);
		  /* 82199F20h */ case    0:  		/* mr R6, R21 */
		/* 82199F20h case    0:*/		regs.R6 = regs.R21;
		/* 82199F20h case    0:*/		return 0x82199F24;
		  /* 82199F24h */ case    1:  		/* lwz R5, <#[R1 + 80]> */
		/* 82199F24h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 82199F24h case    1:*/		return 0x82199F28;
		  /* 82199F28h */ case    2:  		/* li R4, 2 */
		/* 82199F28h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82199F28h case    2:*/		return 0x82199F2C;
		  /* 82199F2Ch */ case    3:  		/* mr R3, R26 */
		/* 82199F2Ch case    3:*/		regs.R3 = regs.R26;
		/* 82199F2Ch case    3:*/		return 0x82199F30;
		  /* 82199F30h */ case    4:  		/* bl -131384 */
		/* 82199F30h case    4:*/		regs.LR = 0x82199F34; return 0x82179DF8;
		/* 82199F30h case    4:*/		return 0x82199F34;
		  /* 82199F34h */ case    5:  		/* mr R8, R14 */
		/* 82199F34h case    5:*/		regs.R8 = regs.R14;
		/* 82199F34h case    5:*/		return 0x82199F38;
		  /* 82199F38h */ case    6:  		/* lwz R11, <#[R8]> */
		/* 82199F38h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82199F38h case    6:*/		return 0x82199F3C;
		  /* 82199F3Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82199F3Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82199F3Ch case    7:*/		return 0x82199F40;
		  /* 82199F40h */ case    8:  		/* bc 12, CR6_EQ, 88 */
		/* 82199F40h case    8:*/		if ( regs.CR[6].eq ) { return 0x82199F98;  }
		/* 82199F40h case    8:*/		return 0x82199F44;
		  /* 82199F44h */ case    9:  		/* lwz R10, <#[R11]> */
		/* 82199F44h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199F44h case    9:*/		return 0x82199F48;
		  /* 82199F48h */ case   10:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 82199F48h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 82199F48h case   10:*/		return 0x82199F4C;
		  /* 82199F4Ch */ case   11:  		/* bc 4, CR0_EQ, 56 */
		/* 82199F4Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x82199F84;  }
		/* 82199F4Ch case   11:*/		return 0x82199F50;
		  /* 82199F50h */ case   12:  		/* lwz R10, <#[R11 + 16]> */
		/* 82199F50h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82199F50h case   12:*/		return 0x82199F54;
		  /* 82199F54h */ case   13:  		/* lwz R9, <#[R10]> */
		/* 82199F54h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82199F54h case   13:*/		return 0x82199F58;
		  /* 82199F58h */ case   14:  		/* b 12 */
		/* 82199F58h case   14:*/		return 0x82199F64;
		/* 82199F58h case   14:*/		return 0x82199F5C;
		  /* 82199F5Ch */ case   15:  		/* addi R10, R9, 4 */
		/* 82199F5Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x4);
		/* 82199F5Ch case   15:*/		return 0x82199F60;
		  /* 82199F60h */ case   16:  		/* lwz R9, <#[R9 + 4]> */
		/* 82199F60h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 82199F60h case   16:*/		return 0x82199F64;
	}
	return 0x82199F64;
} // Block from 82199F20h-82199F64h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82199F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199F64);
		  /* 82199F64h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82199F64h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82199F64h case    0:*/		return 0x82199F68;
		  /* 82199F68h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82199F68h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82199F5C;  }
		/* 82199F68h case    1:*/		return 0x82199F6C;
		  /* 82199F6Ch */ case    2:  		/* lwz R9, <#[R11 + 4]> */
		/* 82199F6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82199F6Ch case    2:*/		return 0x82199F70;
		  /* 82199F70h */ case    3:  		/* stw R9, <#[R10]> */
		/* 82199F70h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82199F70h case    3:*/		return 0x82199F74;
		  /* 82199F74h */ case    4:  		/* lwz R10, <#[R26]> */
		/* 82199F74h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 82199F74h case    4:*/		return 0x82199F78;
		  /* 82199F78h */ case    5:  		/* stw R10, <#[R11 + 4]> */
		/* 82199F78h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82199F78h case    5:*/		return 0x82199F7C;
		  /* 82199F7Ch */ case    6:  		/* stw R11, <#[R26]> */
		/* 82199F7Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82199F7Ch case    6:*/		return 0x82199F80;
		  /* 82199F80h */ case    7:  		/* stw R26, <#[R11 + 16]> */
		/* 82199F80h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000010) );
		/* 82199F80h case    7:*/		return 0x82199F84;
	}
	return 0x82199F84;
} // Block from 82199F64h-82199F84h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82199F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199F84);
		  /* 82199F84h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 82199F84h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 82199F84h case    0:*/		return 0x82199F88;
		  /* 82199F88h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 82199F88h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82199F88h case    1:*/		return 0x82199F8C;
		  /* 82199F8Ch */ case    2:  		/* bc 4, CR6_EQ, -84 */
		/* 82199F8Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82199F38;  }
		/* 82199F8Ch case    2:*/		return 0x82199F90;
		  /* 82199F90h */ case    3:  		/* addi R8, R11, 4 */
		/* 82199F90h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x4);
		/* 82199F90h case    3:*/		return 0x82199F94;
		  /* 82199F94h */ case    4:  		/* b -92 */
		/* 82199F94h case    4:*/		return 0x82199F38;
		/* 82199F94h case    4:*/		return 0x82199F98;
	}
	return 0x82199F98;
} // Block from 82199F84h-82199F98h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82199F98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199F98);
		  /* 82199F98h */ case    0:  		/* addi R8, R14, 4 */
		/* 82199F98h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R14,0x4);
		/* 82199F98h case    0:*/		return 0x82199F9C;
		  /* 82199F9Ch */ case    1:  		/* lwz R11, <#[R8]> */
		/* 82199F9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82199F9Ch case    1:*/		return 0x82199FA0;
		  /* 82199FA0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82199FA0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82199FA0h case    2:*/		return 0x82199FA4;
		  /* 82199FA4h */ case    3:  		/* bc 12, CR6_EQ, 112 */
		/* 82199FA4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219A014;  }
		/* 82199FA4h case    3:*/		return 0x82199FA8;
		  /* 82199FA8h */ case    4:  		/* lwz R10, <#[R11 + 16]> */
		/* 82199FA8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82199FA8h case    4:*/		return 0x82199FAC;
		  /* 82199FACh */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 82199FACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82199FACh case    5:*/		return 0x82199FB0;
		  /* 82199FB0h */ case    6:  		/* bc 12, CR6_EQ, 80 */
		/* 82199FB0h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219A000;  }
		/* 82199FB0h case    6:*/		return 0x82199FB4;
		  /* 82199FB4h */ case    7:  		/* lwz R10, <#[R11 + 12]> */
		/* 82199FB4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82199FB4h case    7:*/		return 0x82199FB8;
		  /* 82199FB8h */ case    8:  		/* addi R10, R10, 4 */
		/* 82199FB8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82199FB8h case    8:*/		return 0x82199FBC;
		  /* 82199FBCh */ case    9:  		/* lwz R9, <#[R10]> */
		/* 82199FBCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82199FBCh case    9:*/		return 0x82199FC0;
		  /* 82199FC0h */ case   10:  		/* b 12 */
		/* 82199FC0h case   10:*/		return 0x82199FCC;
		/* 82199FC0h case   10:*/		return 0x82199FC4;
		  /* 82199FC4h */ case   11:  		/* addi R10, R9, 8 */
		/* 82199FC4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 82199FC4h case   11:*/		return 0x82199FC8;
		  /* 82199FC8h */ case   12:  		/* lwz R9, <#[R9 + 8]> */
		/* 82199FC8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 82199FC8h case   12:*/		return 0x82199FCC;
	}
	return 0x82199FCC;
} // Block from 82199F98h-82199FCCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 82199FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82199FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82199FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82199FCC);
		  /* 82199FCCh */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 82199FCCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 82199FCCh case    0:*/		return 0x82199FD0;
		  /* 82199FD0h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 82199FD0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82199FC4;  }
		/* 82199FD0h case    1:*/		return 0x82199FD4;
		  /* 82199FD4h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 82199FD4h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82199FD4h case    2:*/		return 0x82199FD8;
		  /* 82199FD8h */ case    3:  		/* stw R9, <#[R10]> */
		/* 82199FD8h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82199FD8h case    3:*/		return 0x82199FDC;
		  /* 82199FDCh */ case    4:  		/* lwz R10, <#[R26 + 4]> */
		/* 82199FDCh case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 82199FDCh case    4:*/		return 0x82199FE0;
		  /* 82199FE0h */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 82199FE0h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82199FE0h case    5:*/		return 0x82199FE4;
		  /* 82199FE4h */ case    6:  		/* stw R11, <#[R26 + 4]> */
		/* 82199FE4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82199FE4h case    6:*/		return 0x82199FE8;
		  /* 82199FE8h */ case    7:  		/* stw R26, <#[R11 + 12]> */
		/* 82199FE8h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000000C) );
		/* 82199FE8h case    7:*/		return 0x82199FEC;
		  /* 82199FECh */ case    8:  		/* lwz R10, <#[R11]> */
		/* 82199FECh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199FECh case    8:*/		return 0x82199FF0;
		  /* 82199FF0h */ case    9:  		/* rlwinm. R9, R10, 0, 4, 6 */
		/* 82199FF0h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R10);
		/* 82199FF0h case    9:*/		return 0x82199FF4;
		  /* 82199FF4h */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 82199FF4h case   10:*/		if ( regs.CR[0].eq ) { return 0x8219A000;  }
		/* 82199FF4h case   10:*/		return 0x82199FF8;
		  /* 82199FF8h */ case   11:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 82199FF8h case   11:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 82199FF8h case   11:*/		return 0x82199FFC;
		  /* 82199FFCh */ case   12:  		/* stw R10, <#[R11]> */
		/* 82199FFCh case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82199FFCh case   12:*/		return 0x8219A000;
	}
	return 0x8219A000;
} // Block from 82199FCCh-8219A000h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219A000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A000);
		  /* 8219A000h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 8219A000h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8219A000h case    0:*/		return 0x8219A004;
		  /* 8219A004h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 8219A004h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8219A004h case    1:*/		return 0x8219A008;
		  /* 8219A008h */ case    2:  		/* bc 4, CR6_EQ, -108 */
		/* 8219A008h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82199F9C;  }
		/* 8219A008h case    2:*/		return 0x8219A00C;
		  /* 8219A00Ch */ case    3:  		/* addi R8, R11, 8 */
		/* 8219A00Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8219A00Ch case    3:*/		return 0x8219A010;
		  /* 8219A010h */ case    4:  		/* b -116 */
		/* 8219A010h case    4:*/		return 0x82199F9C;
		/* 8219A010h case    4:*/		return 0x8219A014;
	}
	return 0x8219A014;
} // Block from 8219A000h-8219A014h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219A014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A014);
		  /* 8219A014h */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 8219A014h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 8219A014h case    0:*/		return 0x8219A018;
		  /* 8219A018h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219A018h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A018h case    1:*/		return 0x8219A01C;
		  /* 8219A01Ch */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8219A01Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8219A02C;  }
		/* 8219A01Ch case    2:*/		return 0x8219A020;
		  /* 8219A020h */ case    3:  		/* lwz R11, <#[R26 + 8]> */
		/* 8219A020h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8219A020h case    3:*/		return 0x8219A024;
		  /* 8219A024h */ case    4:  		/* ori R11, R11, 1 */
		/* 8219A024h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219A024h case    4:*/		return 0x8219A028;
		  /* 8219A028h */ case    5:  		/* stw R11, <#[R26 + 8]> */
		/* 8219A028h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8219A028h case    5:*/		return 0x8219A02C;
	}
	return 0x8219A02C;
} // Block from 8219A014h-8219A02Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219A02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A02C);
		  /* 8219A02Ch */ case    0:  		/* lwz R11, <#[R14 + 8]> */
		/* 8219A02Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000008) );
		/* 8219A02Ch case    0:*/		return 0x8219A030;
		  /* 8219A030h */ case    1:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8219A030h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A030h case    1:*/		return 0x8219A034;
		  /* 8219A034h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 8219A034h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219A050;  }
		/* 8219A034h case    2:*/		return 0x8219A038;
		  /* 8219A038h */ case    3:  		/* lwz R11, <#[R26 + 8]> */
		/* 8219A038h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8219A038h case    3:*/		return 0x8219A03C;
		  /* 8219A03Ch */ case    4:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8219A03Ch case    4:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A03Ch case    4:*/		return 0x8219A040;
		  /* 8219A040h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 8219A040h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8219A050;  }
		/* 8219A040h case    5:*/		return 0x8219A044;
		  /* 8219A044h */ case    6:  		/* mr R4, R26 */
		/* 8219A044h case    6:*/		regs.R4 = regs.R26;
		/* 8219A044h case    6:*/		return 0x8219A048;
		  /* 8219A048h */ case    7:  		/* mr R3, R21 */
		/* 8219A048h case    7:*/		regs.R3 = regs.R21;
		/* 8219A048h case    7:*/		return 0x8219A04C;
		  /* 8219A04Ch */ case    8:  		/* bl 117244 */
		/* 8219A04Ch case    8:*/		regs.LR = 0x8219A050; return 0x821B6A48;
		/* 8219A04Ch case    8:*/		return 0x8219A050;
	}
	return 0x8219A050;
} // Block from 8219A02Ch-8219A050h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219A050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A050);
		  /* 8219A050h */ case    0:  		/* mr R4, R14 */
		/* 8219A050h case    0:*/		regs.R4 = regs.R14;
		/* 8219A050h case    0:*/		return 0x8219A054;
		  /* 8219A054h */ case    1:  		/* b -2468 */
		/* 8219A054h case    1:*/		return 0x821996B0;
		/* 8219A054h case    1:*/		return 0x8219A058;
	}
	return 0x8219A058;
} // Block from 8219A050h-8219A058h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219A058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A058);
		  /* 8219A058h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219A058h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219A058h case    0:*/		return 0x8219A05C;
		  /* 8219A05Ch */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219A05Ch case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219A05Ch case    1:*/		return 0x8219A060;
		  /* 8219A060h */ case    2:  		/* cmplwi CR6, R11, 128 */
		/* 8219A060h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8219A060h case    2:*/		return 0x8219A064;
		  /* 8219A064h */ case    3:  		/* bc 4, CR6_EQ, 680 */
		/* 8219A064h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219A30C;  }
		/* 8219A064h case    3:*/		return 0x8219A068;
		  /* 8219A068h */ case    4:  		/* lwz R7, <#[R29 + 44]> */
		/* 8219A068h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R29 + 0x0000002C) );
		/* 8219A068h case    4:*/		return 0x8219A06C;
		  /* 8219A06Ch */ case    5:  		/* cmplw CR6, R7, R6 */
		/* 8219A06Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8219A06Ch case    5:*/		return 0x8219A070;
		  /* 8219A070h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 8219A070h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219A078;  }
		/* 8219A070h case    6:*/		return 0x8219A074;
		  /* 8219A074h */ case    7:  		/* lwz R7, <#[R29 + 48]> */
		/* 8219A074h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R29 + 0x00000030) );
		/* 8219A074h case    7:*/		return 0x8219A078;
	}
	return 0x8219A078;
} // Block from 8219A058h-8219A078h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219A078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A078);
		  /* 8219A078h */ case    0:  		/* addi R8, R1, 144 */
		/* 8219A078h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x90);
		/* 8219A078h case    0:*/		return 0x8219A07C;
		  /* 8219A07Ch */ case    1:  		/* mr R5, R14 */
		/* 8219A07Ch case    1:*/		regs.R5 = regs.R14;
		/* 8219A07Ch case    1:*/		return 0x8219A080;
		  /* 8219A080h */ case    2:  		/* mr R4, R29 */
		/* 8219A080h case    2:*/		regs.R4 = regs.R29;
		/* 8219A080h case    2:*/		return 0x8219A084;
		  /* 8219A084h */ case    3:  		/* mr R3, R21 */
		/* 8219A084h case    3:*/		regs.R3 = regs.R21;
		/* 8219A084h case    3:*/		return 0x8219A088;
		  /* 8219A088h */ case    4:  		/* bl -15112 */
		/* 8219A088h case    4:*/		regs.LR = 0x8219A08C; return 0x82196580;
		/* 8219A088h case    4:*/		return 0x8219A08C;
		  /* 8219A08Ch */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219A08Ch case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219A08Ch case    5:*/		return 0x8219A090;
		  /* 8219A090h */ case    6:  		/* mr R3, R21 */
		/* 8219A090h case    6:*/		regs.R3 = regs.R21;
		/* 8219A090h case    6:*/		return 0x8219A094;
		  /* 8219A094h */ case    7:  		/* bc 12, CR0_EQ, 644 */
		/* 8219A094h case    7:*/		if ( regs.CR[0].eq ) { return 0x8219A318;  }
		/* 8219A094h case    7:*/		return 0x8219A098;
		  /* 8219A098h */ case    8:  		/* li R7, 0 */
		/* 8219A098h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219A098h case    8:*/		return 0x8219A09C;
		  /* 8219A09Ch */ case    9:  		/* li R6, 1 */
		/* 8219A09Ch case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8219A09Ch case    9:*/		return 0x8219A0A0;
		  /* 8219A0A0h */ case   10:  		/* mr R5, R29 */
		/* 8219A0A0h case   10:*/		regs.R5 = regs.R29;
		/* 8219A0A0h case   10:*/		return 0x8219A0A4;
		  /* 8219A0A4h */ case   11:  		/* mr R4, R14 */
		/* 8219A0A4h case   11:*/		regs.R4 = regs.R14;
		/* 8219A0A4h case   11:*/		return 0x8219A0A8;
		  /* 8219A0A8h */ case   12:  		/* bl 604896 */
		/* 8219A0A8h case   12:*/		regs.LR = 0x8219A0AC; return 0x8222DB88;
		/* 8219A0A8h case   12:*/		return 0x8219A0AC;
		  /* 8219A0ACh */ case   13:  		/* mr R5, R29 */
		/* 8219A0ACh case   13:*/		regs.R5 = regs.R29;
		/* 8219A0ACh case   13:*/		return 0x8219A0B0;
		  /* 8219A0B0h */ case   14:  		/* li R4, 1 */
		/* 8219A0B0h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8219A0B0h case   14:*/		return 0x8219A0B4;
		  /* 8219A0B4h */ case   15:  		/* lwz R8, <#[R1 + 152]> */
		/* 8219A0B4h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000098) );
		/* 8219A0B4h case   15:*/		return 0x8219A0B8;
		  /* 8219A0B8h */ case   16:  		/* mr R3, R21 */
		/* 8219A0B8h case   16:*/		regs.R3 = regs.R21;
		/* 8219A0B8h case   16:*/		return 0x8219A0BC;
		  /* 8219A0BCh */ case   17:  		/* lwz R7, <#[R1 + 148]> */
		/* 8219A0BCh case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000094) );
		/* 8219A0BCh case   17:*/		return 0x8219A0C0;
		  /* 8219A0C0h */ case   18:  		/* lwz R6, <#[R1 + 144]> */
		/* 8219A0C0h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000090) );
		/* 8219A0C0h case   18:*/		return 0x8219A0C4;
		  /* 8219A0C4h */ case   19:  		/* bl -13060 */
		/* 8219A0C4h case   19:*/		regs.LR = 0x8219A0C8; return 0x82196DC0;
		/* 8219A0C4h case   19:*/		return 0x8219A0C8;
		  /* 8219A0C8h */ case   20:  		/* lwz R31, <#[R29]> */
		/* 8219A0C8h case   20:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 8219A0C8h case   20:*/		return 0x8219A0CC;
		  /* 8219A0CCh */ case   21:  		/* mr R30, R3 */
		/* 8219A0CCh case   21:*/		regs.R30 = regs.R3;
		/* 8219A0CCh case   21:*/		return 0x8219A0D0;
		  /* 8219A0D0h */ case   22:  		/* cmplwi CR6, R31, 0 */
		/* 8219A0D0h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219A0D0h case   22:*/		return 0x8219A0D4;
		  /* 8219A0D4h */ case   23:  		/* bc 12, CR6_EQ, 36 */
		/* 8219A0D4h case   23:*/		if ( regs.CR[6].eq ) { return 0x8219A0F8;  }
		/* 8219A0D4h case   23:*/		return 0x8219A0D8;
		  /* 8219A0D8h */ case   24:  		/* lwz R11, <#[R31]> */
		/* 8219A0D8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219A0D8h case   24:*/		return 0x8219A0DC;
		  /* 8219A0DCh */ case   25:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 8219A0DCh case   25:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8219A0DCh case   25:*/		return 0x8219A0E0;
		  /* 8219A0E0h */ case   26:  		/* bc 4, CR0_EQ, 16 */
		/* 8219A0E0h case   26:*/		if ( !regs.CR[0].eq ) { return 0x8219A0F0;  }
		/* 8219A0E0h case   26:*/		return 0x8219A0E4;
		  /* 8219A0E4h */ case   27:  		/* mr R4, R31 */
		/* 8219A0E4h case   27:*/		regs.R4 = regs.R31;
		/* 8219A0E4h case   27:*/		return 0x8219A0E8;
		  /* 8219A0E8h */ case   28:  		/* mr R3, R30 */
		/* 8219A0E8h case   28:*/		regs.R3 = regs.R30;
		/* 8219A0E8h case   28:*/		return 0x8219A0EC;
		  /* 8219A0ECh */ case   29:  		/* bl -139044 */
		/* 8219A0ECh case   29:*/		regs.LR = 0x8219A0F0; return 0x821781C8;
		/* 8219A0ECh case   29:*/		return 0x8219A0F0;
	}
	return 0x8219A0F0;
} // Block from 8219A078h-8219A0F0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8219A0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A0F0);
		  /* 8219A0F0h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 8219A0F0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 8219A0F0h case    0:*/		return 0x8219A0F4;
		  /* 8219A0F4h */ case    1:  		/* b -36 */
		/* 8219A0F4h case    1:*/		return 0x8219A0D0;
		/* 8219A0F4h case    1:*/		return 0x8219A0F8;
	}
	return 0x8219A0F8;
} // Block from 8219A0F0h-8219A0F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219A0F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A0F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A0F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A0F8);
		  /* 8219A0F8h */ case    0:  		/* lwz R31, <#[R14]> */
		/* 8219A0F8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R14 + 0x00000000) );
		/* 8219A0F8h case    0:*/		return 0x8219A0FC;
		  /* 8219A0FCh */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 8219A0FCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219A0FCh case    1:*/		return 0x8219A100;
		  /* 8219A100h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 8219A100h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219A124;  }
		/* 8219A100h case    2:*/		return 0x8219A104;
		  /* 8219A104h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 8219A104h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219A104h case    3:*/		return 0x8219A108;
		  /* 8219A108h */ case    4:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 8219A108h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8219A108h case    4:*/		return 0x8219A10C;
		  /* 8219A10Ch */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 8219A10Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x8219A11C;  }
		/* 8219A10Ch case    5:*/		return 0x8219A110;
		  /* 8219A110h */ case    6:  		/* mr R4, R31 */
		/* 8219A110h case    6:*/		regs.R4 = regs.R31;
		/* 8219A110h case    6:*/		return 0x8219A114;
		  /* 8219A114h */ case    7:  		/* mr R3, R30 */
		/* 8219A114h case    7:*/		regs.R3 = regs.R30;
		/* 8219A114h case    7:*/		return 0x8219A118;
		  /* 8219A118h */ case    8:  		/* bl -139088 */
		/* 8219A118h case    8:*/		regs.LR = 0x8219A11C; return 0x821781C8;
		/* 8219A118h case    8:*/		return 0x8219A11C;
	}
	return 0x8219A11C;
} // Block from 8219A0F8h-8219A11Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219A11Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A11C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A11C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A11C);
		  /* 8219A11Ch */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 8219A11Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 8219A11Ch case    0:*/		return 0x8219A120;
		  /* 8219A120h */ case    1:  		/* b -36 */
		/* 8219A120h case    1:*/		return 0x8219A0FC;
		/* 8219A120h case    1:*/		return 0x8219A124;
	}
	return 0x8219A124;
} // Block from 8219A11Ch-8219A124h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219A124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A124);
		  /* 8219A124h */ case    0:  		/* addi R8, R29, 4 */
		/* 8219A124h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R29,0x4);
		/* 8219A124h case    0:*/		return 0x8219A128;
		  /* 8219A128h */ case    1:  		/* lwz R11, <#[R8]> */
		/* 8219A128h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8219A128h case    1:*/		return 0x8219A12C;
		  /* 8219A12Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8219A12Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219A12Ch case    2:*/		return 0x8219A130;
		  /* 8219A130h */ case    3:  		/* bc 12, CR6_EQ, 92 */
		/* 8219A130h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219A18C;  }
		/* 8219A130h case    3:*/		return 0x8219A134;
		  /* 8219A134h */ case    4:  		/* lwz R10, <#[R11 + 16]> */
		/* 8219A134h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8219A134h case    4:*/		return 0x8219A138;
		  /* 8219A138h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 8219A138h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219A138h case    5:*/		return 0x8219A13C;
		  /* 8219A13Ch */ case    6:  		/* bc 12, CR6_EQ, 60 */
		/* 8219A13Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8219A178;  }
		/* 8219A13Ch case    6:*/		return 0x8219A140;
		  /* 8219A140h */ case    7:  		/* lwz R10, <#[R11 + 12]> */
		/* 8219A140h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219A140h case    7:*/		return 0x8219A144;
		  /* 8219A144h */ case    8:  		/* addi R10, R10, 4 */
		/* 8219A144h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8219A144h case    8:*/		return 0x8219A148;
		  /* 8219A148h */ case    9:  		/* lwz R9, <#[R10]> */
		/* 8219A148h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8219A148h case    9:*/		return 0x8219A14C;
		  /* 8219A14Ch */ case   10:  		/* b 12 */
		/* 8219A14Ch case   10:*/		return 0x8219A158;
		/* 8219A14Ch case   10:*/		return 0x8219A150;
		  /* 8219A150h */ case   11:  		/* addi R10, R9, 8 */
		/* 8219A150h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 8219A150h case   11:*/		return 0x8219A154;
		  /* 8219A154h */ case   12:  		/* lwz R9, <#[R9 + 8]> */
		/* 8219A154h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 8219A154h case   12:*/		return 0x8219A158;
	}
	return 0x8219A158;
} // Block from 8219A124h-8219A158h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219A158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A158);
		  /* 8219A158h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 8219A158h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8219A158h case    0:*/		return 0x8219A15C;
		  /* 8219A15Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8219A15Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219A150;  }
		/* 8219A15Ch case    1:*/		return 0x8219A160;
		  /* 8219A160h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 8219A160h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8219A160h case    2:*/		return 0x8219A164;
		  /* 8219A164h */ case    3:  		/* stw R9, <#[R10]> */
		/* 8219A164h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8219A164h case    3:*/		return 0x8219A168;
		  /* 8219A168h */ case    4:  		/* lwz R10, <#[R30 + 4]> */
		/* 8219A168h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8219A168h case    4:*/		return 0x8219A16C;
		  /* 8219A16Ch */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 8219A16Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8219A16Ch case    5:*/		return 0x8219A170;
		  /* 8219A170h */ case    6:  		/* stw R11, <#[R30 + 4]> */
		/* 8219A170h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8219A170h case    6:*/		return 0x8219A174;
		  /* 8219A174h */ case    7:  		/* stw R30, <#[R11 + 12]> */
		/* 8219A174h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219A174h case    7:*/		return 0x8219A178;
	}
	return 0x8219A178;
} // Block from 8219A158h-8219A178h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219A178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A178);
		  /* 8219A178h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 8219A178h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8219A178h case    0:*/		return 0x8219A17C;
		  /* 8219A17Ch */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 8219A17Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8219A17Ch case    1:*/		return 0x8219A180;
		  /* 8219A180h */ case    2:  		/* bc 4, CR6_EQ, -88 */
		/* 8219A180h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8219A128;  }
		/* 8219A180h case    2:*/		return 0x8219A184;
		  /* 8219A184h */ case    3:  		/* addi R8, R11, 8 */
		/* 8219A184h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 8219A184h case    3:*/		return 0x8219A188;
		  /* 8219A188h */ case    4:  		/* b -96 */
		/* 8219A188h case    4:*/		return 0x8219A128;
		/* 8219A188h case    4:*/		return 0x8219A18C;
	}
	return 0x8219A18C;
} // Block from 8219A178h-8219A18Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219A18Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A18C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A18C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A18C);
		  /* 8219A18Ch */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219A18Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219A18Ch case    0:*/		return 0x8219A190;
		  /* 8219A190h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219A190h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A190h case    1:*/		return 0x8219A194;
		  /* 8219A194h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8219A194h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219A1A4;  }
		/* 8219A194h case    2:*/		return 0x8219A198;
		  /* 8219A198h */ case    3:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219A198h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219A198h case    3:*/		return 0x8219A19C;
		  /* 8219A19Ch */ case    4:  		/* ori R11, R11, 1 */
		/* 8219A19Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219A19Ch case    4:*/		return 0x8219A1A0;
		  /* 8219A1A0h */ case    5:  		/* stw R11, <#[R30 + 8]> */
		/* 8219A1A0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219A1A0h case    5:*/		return 0x8219A1A4;
	}
	return 0x8219A1A4;
} // Block from 8219A18Ch-8219A1A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219A1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A1A4);
		  /* 8219A1A4h */ case    0:  		/* mr R3, R30 */
		/* 8219A1A4h case    0:*/		regs.R3 = regs.R30;
		/* 8219A1A4h case    0:*/		return 0x8219A1A8;
		  /* 8219A1A8h */ case    1:  		/* bl -138800 */
		/* 8219A1A8h case    1:*/		regs.LR = 0x8219A1AC; return 0x82178378;
		/* 8219A1A8h case    1:*/		return 0x8219A1AC;
		  /* 8219A1ACh */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219A1ACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219A1ACh case    2:*/		return 0x8219A1B0;
		  /* 8219A1B0h */ case    3:  		/* oris R11, R11, 256 */
		/* 8219A1B0h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 8219A1B0h case    3:*/		return 0x8219A1B4;
		  /* 8219A1B4h */ case    4:  		/* stw R11, <#[R30 + 8]> */
		/* 8219A1B4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219A1B4h case    4:*/		return 0x8219A1B8;
		  /* 8219A1B8h */ case    5:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219A1B8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219A1B8h case    5:*/		return 0x8219A1BC;
		  /* 8219A1BCh */ case    6:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8219A1BCh case    6:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A1BCh case    6:*/		return 0x8219A1C0;
		  /* 8219A1C0h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 8219A1C0h case    7:*/		if ( regs.CR[0].eq ) { return 0x8219A1D0;  }
		/* 8219A1C0h case    7:*/		return 0x8219A1C4;
		  /* 8219A1C4h */ case    8:  		/* mr R4, R30 */
		/* 8219A1C4h case    8:*/		regs.R4 = regs.R30;
		/* 8219A1C4h case    8:*/		return 0x8219A1C8;
		  /* 8219A1C8h */ case    9:  		/* mr R3, R21 */
		/* 8219A1C8h case    9:*/		regs.R3 = regs.R21;
		/* 8219A1C8h case    9:*/		return 0x8219A1CC;
		  /* 8219A1CCh */ case   10:  		/* bl 116860 */
		/* 8219A1CCh case   10:*/		regs.LR = 0x8219A1D0; return 0x821B6A48;
		/* 8219A1CCh case   10:*/		return 0x8219A1D0;
	}
	return 0x8219A1D0;
} // Block from 8219A1A4h-8219A1D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219A1D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A1D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A1D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A1D0);
		  /* 8219A1D0h */ case    0:  		/* mr R4, R29 */
		/* 8219A1D0h case    0:*/		regs.R4 = regs.R29;
		/* 8219A1D0h case    0:*/		return 0x8219A1D4;
		  /* 8219A1D4h */ case    1:  		/* b -2852 */
		/* 8219A1D4h case    1:*/		return 0x821996B0;
		/* 8219A1D4h case    1:*/		return 0x8219A1D8;
	}
	return 0x8219A1D8;
} // Block from 8219A1D0h-8219A1D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219A1D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A1D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A1D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A1D8);
		  /* 8219A1D8h */ case    0:  		/* bc 12, CR0_EQ, 80 */
		/* 8219A1D8h case    0:*/		if ( regs.CR[0].eq ) { return 0x8219A228;  }
		/* 8219A1D8h case    0:*/		return 0x8219A1DC;
		  /* 8219A1DCh */ case    1:  		/* addi R30, R20, 16 */
		/* 8219A1DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R20,0x10);
		/* 8219A1DCh case    1:*/		return 0x8219A1E0;
		  /* 8219A1E0h */ case    2:  		/* lwz R11, <#[R30 + 4]> */
		/* 8219A1E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8219A1E0h case    2:*/		return 0x8219A1E4;
		  /* 8219A1E4h */ case    3:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219A1E4h case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219A1E4h case    3:*/		return 0x8219A1E8;
		  /* 8219A1E8h */ case    4:  		/* addic R10, R10, -1 */
		/* 8219A1E8h case    4:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219A1E8h case    4:*/		return 0x8219A1EC;
		  /* 8219A1ECh */ case    5:  		/* subfe R10, R10, R10 */
		/* 8219A1ECh case    5:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8219A1ECh case    5:*/		return 0x8219A1F0;
		  /* 8219A1F0h */ case    6:  		/* and R31, R10, R11 */
		/* 8219A1F0h case    6:*/		cpu::op::and<0>(regs,&regs.R31,regs.R10,regs.R11);
		/* 8219A1F0h case    6:*/		return 0x8219A1F4;
		  /* 8219A1F4h */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 8219A1F4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219A1F4h case    7:*/		return 0x8219A1F8;
		  /* 8219A1F8h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 8219A1F8h case    8:*/		if ( regs.CR[6].eq ) { return 0x8219A228;  }
		/* 8219A1F8h case    8:*/		return 0x8219A1FC;
		  /* 8219A1FCh */ case    9:  		/* mr R3, R31 */
		/* 8219A1FCh case    9:*/		regs.R3 = regs.R31;
		/* 8219A1FCh case    9:*/		return 0x8219A200;
		  /* 8219A200h */ case   10:  		/* bl -219264 */
		/* 8219A200h case   10:*/		regs.LR = 0x8219A204; return 0x82164980;
		/* 8219A200h case   10:*/		return 0x8219A204;
		  /* 8219A204h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219A204h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219A204h case   11:*/		return 0x8219A208;
		  /* 8219A208h */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 8219A208h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8219A218;  }
		/* 8219A208h case   12:*/		return 0x8219A20C;
		  /* 8219A20Ch */ case   13:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8219A20Ch case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8219A20Ch case   13:*/		return 0x8219A210;
		  /* 8219A210h */ case   14:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219A210h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219A210h case   14:*/		return 0x8219A214;
		  /* 8219A214h */ case   15:  		/* b -48 */
		/* 8219A214h case   15:*/		return 0x8219A1E4;
		/* 8219A214h case   15:*/		return 0x8219A218;
	}
	return 0x8219A218;
} // Block from 8219A1D8h-8219A218h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219A218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A218);
		  /* 8219A218h */ case    0:  		/* mr R4, R31 */
		/* 8219A218h case    0:*/		regs.R4 = regs.R31;
		/* 8219A218h case    0:*/		return 0x8219A21C;
		  /* 8219A21Ch */ case    1:  		/* mr R3, R21 */
		/* 8219A21Ch case    1:*/		regs.R3 = regs.R21;
		/* 8219A21Ch case    1:*/		return 0x8219A220;
		  /* 8219A220h */ case    2:  		/* bl 594992 */
		/* 8219A220h case    2:*/		regs.LR = 0x8219A224; return 0x8222B650;
		/* 8219A220h case    2:*/		return 0x8219A224;
		  /* 8219A224h */ case    3:  		/* b -68 */
		/* 8219A224h case    3:*/		return 0x8219A1E0;
		/* 8219A224h case    3:*/		return 0x8219A228;
	}
	return 0x8219A228;
} // Block from 8219A218h-8219A228h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219A228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A228);
		  /* 8219A228h */ case    0:  		/* rlwinm R11, R20, 0, 0, 30 */
		/* 8219A228h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R20);
		/* 8219A228h case    0:*/		return 0x8219A22C;
		  /* 8219A22Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219A22Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219A22Ch case    1:*/		return 0x8219A230;
		  /* 8219A230h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219A230h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219A230h case    2:*/		return 0x8219A234;
		  /* 8219A234h */ case    3:  		/* bc 4, CR0_EQ, 20 */
		/* 8219A234h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219A248;  }
		/* 8219A234h case    3:*/		return 0x8219A238;
		  /* 8219A238h */ case    4:  		/* mr R20, R11 */
		/* 8219A238h case    4:*/		regs.R20 = regs.R11;
		/* 8219A238h case    4:*/		return 0x8219A23C;
		  /* 8219A23Ch */ case    5:  		/* stw R11, <#[R1 + 100]> */
		/* 8219A23Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8219A23Ch case    5:*/		return 0x8219A240;
		  /* 8219A240h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8219A240h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219A240h case    6:*/		return 0x8219A244;
		  /* 8219A244h */ case    7:  		/* bc 4, CR6_EQ, -11704 */
		/* 8219A244h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8219748C;  }
		/* 8219A244h case    7:*/		return 0x8219A248;
	}
	return 0x8219A248;
} // Block from 8219A228h-8219A248h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219A248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A248);
		  /* 8219A248h */ case    0:  		/* lwz R11, <#[R21 + 4]> */
		/* 8219A248h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 8219A248h case    0:*/		return 0x8219A24C;
		  /* 8219A24Ch */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219A24Ch case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219A24Ch case    1:*/		return 0x8219A250;
		  /* 8219A250h */ case    2:  		/* addic R10, R10, -1 */
		/* 8219A250h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219A250h case    2:*/		return 0x8219A254;
		  /* 8219A254h */ case    3:  		/* subfe R10, R10, R10 */
		/* 8219A254h case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8219A254h case    3:*/		return 0x8219A258;
		  /* 8219A258h */ case    4:  		/* and R11, R10, R11 */
		/* 8219A258h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219A258h case    4:*/		return 0x8219A25C;
		  /* 8219A25Ch */ case    5:  		/* lwz R11, <#[R11 + 20]> */
		/* 8219A25Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8219A25Ch case    5:*/		return 0x8219A260;
		  /* 8219A260h */ case    6:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219A260h case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219A260h case    6:*/		return 0x8219A264;
		  /* 8219A264h */ case    7:  		/* addic R10, R10, -1 */
		/* 8219A264h case    7:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219A264h case    7:*/		return 0x8219A268;
		  /* 8219A268h */ case    8:  		/* subfe R10, R10, R10 */
		/* 8219A268h case    8:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8219A268h case    8:*/		return 0x8219A26C;
		  /* 8219A26Ch */ case    9:  		/* and R24, R10, R11 */
		/* 8219A26Ch case    9:*/		cpu::op::and<0>(regs,&regs.R24,regs.R10,regs.R11);
		/* 8219A26Ch case    9:*/		return 0x8219A270;
		  /* 8219A270h */ case   10:  		/* cmplwi CR6, R24, 0 */
		/* 8219A270h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8219A270h case   10:*/		return 0x8219A274;
		  /* 8219A274h */ case   11:  		/* bc 12, CR6_EQ, 2704 */
		/* 8219A274h case   11:*/		if ( regs.CR[6].eq ) { return 0x8219AD04;  }
		/* 8219A274h case   11:*/		return 0x8219A278;
		  /* 8219A278h */ case   12:  		/* lwz R11, <#[R24 + 8]> */
		/* 8219A278h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 8219A278h case   12:*/		return 0x8219A27C;
		  /* 8219A27Ch */ case   13:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219A27Ch case   13:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219A27Ch case   13:*/		return 0x8219A280;
		  /* 8219A280h */ case   14:  		/* cmplwi CR6, R11, 15872 */
		/* 8219A280h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 8219A280h case   14:*/		return 0x8219A284;
		  /* 8219A284h */ case   15:  		/* bc 4, CR6_EQ, 2676 */
		/* 8219A284h case   15:*/		if ( !regs.CR[6].eq ) { return 0x8219ACF8;  }
		/* 8219A284h case   15:*/		return 0x8219A288;
		  /* 8219A288h */ case   16:  		/* mr R4, R21 */
		/* 8219A288h case   16:*/		regs.R4 = regs.R21;
		/* 8219A288h case   16:*/		return 0x8219A28C;
		  /* 8219A28Ch */ case   17:  		/* mr R3, R24 */
		/* 8219A28Ch case   17:*/		regs.R3 = regs.R24;
		/* 8219A28Ch case   17:*/		return 0x8219A290;
		  /* 8219A290h */ case   18:  		/* bl -140168 */
		/* 8219A290h case   18:*/		regs.LR = 0x8219A294; return 0x82177F08;
		/* 8219A290h case   18:*/		return 0x8219A294;
		  /* 8219A294h */ case   19:  		/* lwz R11, <#[R21 + 12]> */
		/* 8219A294h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000000C) );
		/* 8219A294h case   19:*/		return 0x8219A298;
		  /* 8219A298h */ case   20:  		/* mulli R10, R3, 40 */
		/* 8219A298h case   20:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R3,0x28);
		/* 8219A298h case   20:*/		return 0x8219A29C;
		  /* 8219A29Ch */ case   21:  		/* add R23, R10, R11 */
		/* 8219A29Ch case   21:*/		cpu::op::add<0>(regs,&regs.R23,regs.R10,regs.R11);
		/* 8219A29Ch case   21:*/		return 0x8219A2A0;
		  /* 8219A2A0h */ case   22:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8219A2A0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219A2A0h case   22:*/		return 0x8219A2A4;
		  /* 8219A2A4h */ case   23:  		/* mr R26, R3 */
		/* 8219A2A4h case   23:*/		regs.R26 = regs.R3;
		/* 8219A2A4h case   23:*/		return 0x8219A2A8;
		  /* 8219A2A8h */ case   24:  		/* rlwinm. R10, R11, 0, 12, 12 */
		/* 8219A2A8h case   24:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R10,regs.R11);
		/* 8219A2A8h case   24:*/		return 0x8219A2AC;
		  /* 8219A2ACh */ case   25:  		/* bc 12, CR0_EQ, 16 */
		/* 8219A2ACh case   25:*/		if ( regs.CR[0].eq ) { return 0x8219A2BC;  }
		/* 8219A2ACh case   25:*/		return 0x8219A2B0;
		  /* 8219A2B0h */ case   26:  		/* lwz R10, <#[R23 + 4]> */
		/* 8219A2B0h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000004) );
		/* 8219A2B0h case   26:*/		return 0x8219A2B4;
		  /* 8219A2B4h */ case   27:  		/* rlwinm. R10, R10, 0, 25, 27 */
		/* 8219A2B4h case   27:*/		cpu::op::rlwinm<1,0,25,27>(regs,&regs.R10,regs.R10);
		/* 8219A2B4h case   27:*/		return 0x8219A2B8;
		  /* 8219A2B8h */ case   28:  		/* bc 4, CR0_EQ, 2624 */
		/* 8219A2B8h case   28:*/		if ( !regs.CR[0].eq ) { return 0x8219ACF8;  }
		/* 8219A2B8h case   28:*/		return 0x8219A2BC;
	}
	return 0x8219A2BC;
} // Block from 8219A248h-8219A2BCh (29 instructions)

//////////////////////////////////////////////////////
// Block at 8219A2BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A2BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A2BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A2BC);
		  /* 8219A2BCh */ case    0:  		/* lwz R10, <#[R23 + 36]> */
		/* 8219A2BCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000024) );
		/* 8219A2BCh case    0:*/		return 0x8219A2C0;
		  /* 8219A2C0h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 8219A2C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219A2C0h case    1:*/		return 0x8219A2C4;
		  /* 8219A2C4h */ case    2:  		/* bc 4, CR6_EQ, 2612 */
		/* 8219A2C4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8219ACF8;  }
		/* 8219A2C4h case    2:*/		return 0x8219A2C8;
		  /* 8219A2C8h */ case    3:  		/* rlwinm R10, R11, 29, 18, 31 */
		/* 8219A2C8h case    3:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R10,regs.R11);
		/* 8219A2C8h case    3:*/		return 0x8219A2CC;
		  /* 8219A2CCh */ case    4:  		/* mr R28, R18 */
		/* 8219A2CCh case    4:*/		regs.R28 = regs.R18;
		/* 8219A2CCh case    4:*/		return 0x8219A2D0;
		  /* 8219A2D0h */ case    5:  		/* mr R11, R18 */
		/* 8219A2D0h case    5:*/		regs.R11 = regs.R18;
		/* 8219A2D0h case    5:*/		return 0x8219A2D4;
		  /* 8219A2D4h */ case    6:  		/* cmplw CR6, R28, R10 */
		/* 8219A2D4h case    6:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 8219A2D4h case    6:*/		return 0x8219A2D8;
		  /* 8219A2D8h */ case    7:  		/* bc 4, CR6_LT, 72 */
		/* 8219A2D8h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8219A320;  }
		/* 8219A2D8h case    7:*/		return 0x8219A2DC;
		  /* 8219A2DCh */ case    8:  		/* lwz R9, <#[R23 + 28]> */
		/* 8219A2DCh case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x0000001C) );
		/* 8219A2DCh case    8:*/		return 0x8219A2E0;
		  /* 8219A2E0h */ case    9:  		/* lis R8, 4 */
		/* 8219A2E0h case    9:*/		cpu::op::lis<0>(regs,&regs.R8,0x4);
		/* 8219A2E0h case    9:*/		return 0x8219A2E4;
		  /* 8219A2E4h */ case   10:  		/* lwzx R9, <#[R9 + R11]> */
		/* 8219A2E4h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 8219A2E4h case   10:*/		return 0x8219A2E8;
		  /* 8219A2E8h */ case   11:  		/* rlwinm R9, R9, 0, 12, 13 */
		/* 8219A2E8h case   11:*/		cpu::op::rlwinm<0,0,12,13>(regs,&regs.R9,regs.R9);
		/* 8219A2E8h case   11:*/		return 0x8219A2EC;
		  /* 8219A2ECh */ case   12:  		/* cmplw CR6, R9, R8 */
		/* 8219A2ECh case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8219A2ECh case   12:*/		return 0x8219A2F0;
		  /* 8219A2F0h */ case   13:  		/* bc 4, CR6_EQ, 892 */
		/* 8219A2F0h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8219A66C;  }
		/* 8219A2F0h case   13:*/		return 0x8219A2F4;
		  /* 8219A2F4h */ case   14:  		/* addi R28, R28, 1 */
		/* 8219A2F4h case   14:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8219A2F4h case   14:*/		return 0x8219A2F8;
		  /* 8219A2F8h */ case   15:  		/* addi R11, R11, 8 */
		/* 8219A2F8h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8219A2F8h case   15:*/		return 0x8219A2FC;
		  /* 8219A2FCh */ case   16:  		/* b -40 */
		/* 8219A2FCh case   16:*/		return 0x8219A2D4;
		/* 8219A2FCh case   16:*/		return 0x8219A300;
	}
	return 0x8219A300;
} // Block from 8219A2BCh-8219A300h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219A300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A300);
		  /* 8219A300h */ case    0:  		/* li R4, 4800 */
		/* 8219A300h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8219A300h case    0:*/		return 0x8219A304;
		  /* 8219A304h */ case    1:  		/* mr R3, R21 */
		/* 8219A304h case    1:*/		regs.R3 = regs.R21;
		/* 8219A304h case    1:*/		return 0x8219A308;
		  /* 8219A308h */ case    2:  		/* bl -296096 */
		/* 8219A308h case    2:*/		regs.LR = 0x8219A30C; return 0x82151E68;
		/* 8219A308h case    2:*/		return 0x8219A30C;
	}
	return 0x8219A30C;
} // Block from 8219A300h-8219A30Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219A30Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A30C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A30C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A30C);
		  /* 8219A30Ch */ case    0:  		/* li R4, 4800 */
		/* 8219A30Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8219A30Ch case    0:*/		return 0x8219A310;
		  /* 8219A310h */ case    1:  		/* mr R3, R21 */
		/* 8219A310h case    1:*/		regs.R3 = regs.R21;
		/* 8219A310h case    1:*/		return 0x8219A314;
		  /* 8219A314h */ case    2:  		/* bl -296108 */
		/* 8219A314h case    2:*/		regs.LR = 0x8219A318; return 0x82151E68;
		/* 8219A314h case    2:*/		return 0x8219A318;
	}
	return 0x8219A318;
} // Block from 8219A30Ch-8219A318h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219A318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A318);
		  /* 8219A318h */ case    0:  		/* li R4, 4800 */
		/* 8219A318h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8219A318h case    0:*/		return 0x8219A31C;
		  /* 8219A31Ch */ case    1:  		/* bl -296116 */
		/* 8219A31Ch case    1:*/		regs.LR = 0x8219A320; return 0x82151E68;
		/* 8219A31Ch case    1:*/		return 0x8219A320;
	}
	return 0x8219A320;
} // Block from 8219A318h-8219A320h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219A320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A320);
		  /* 8219A320h */ case    0:  		/* lwz R11, <#[R23]> */
		/* 8219A320h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8219A320h case    0:*/		return 0x8219A324;
		  /* 8219A324h */ case    1:  		/* rlwinm R11, R11, 29, 18, 31 */
		/* 8219A324h case    1:*/		cpu::op::rlwinm<0,29,18,31>(regs,&regs.R11,regs.R11);
		/* 8219A324h case    1:*/		return 0x8219A328;
		  /* 8219A328h */ case    2:  		/* cmplw CR6, R28, R11 */
		/* 8219A328h case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8219A328h case    2:*/		return 0x8219A32C;
		  /* 8219A32Ch */ case    3:  		/* bc 4, CR6_EQ, 2508 */
		/* 8219A32Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219ACF8;  }
		/* 8219A32Ch case    3:*/		return 0x8219A330;
		  /* 8219A330h */ case    4:  		/* lwz R11, <#[R21 + 4]> */
		/* 8219A330h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 8219A330h case    4:*/		return 0x8219A334;
		  /* 8219A334h */ case    5:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219A334h case    5:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219A334h case    5:*/		return 0x8219A338;
		  /* 8219A338h */ case    6:  		/* addic R10, R10, -1 */
		/* 8219A338h case    6:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219A338h case    6:*/		return 0x8219A33C;
		  /* 8219A33Ch */ case    7:  		/* subfe R10, R10, R10 */
		/* 8219A33Ch case    7:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8219A33Ch case    7:*/		return 0x8219A340;
		  /* 8219A340h */ case    8:  		/* and R11, R10, R11 */
		/* 8219A340h case    8:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219A340h case    8:*/		return 0x8219A344;
		  /* 8219A344h */ case    9:  		/* lwz R11, <#[R11 + 20]> */
		/* 8219A344h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 8219A344h case    9:*/		return 0x8219A348;
		  /* 8219A348h */ case   10:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219A348h case   10:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219A348h case   10:*/		return 0x8219A34C;
		  /* 8219A34Ch */ case   11:  		/* addic R10, R10, -1 */
		/* 8219A34Ch case   11:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219A34Ch case   11:*/		return 0x8219A350;
		  /* 8219A350h */ case   12:  		/* subfe R10, R10, R10 */
		/* 8219A350h case   12:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8219A350h case   12:*/		return 0x8219A354;
		  /* 8219A354h */ case   13:  		/* and R28, R10, R11 */
		/* 8219A354h case   13:*/		cpu::op::and<0>(regs,&regs.R28,regs.R10,regs.R11);
		/* 8219A354h case   13:*/		return 0x8219A358;
		  /* 8219A358h */ case   14:  		/* cmplwi CR6, R28, 0 */
		/* 8219A358h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8219A358h case   14:*/		return 0x8219A35C;
		  /* 8219A35Ch */ case   15:  		/* bc 12, CR6_EQ, 1372 */
		/* 8219A35Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x8219A8B8;  }
		/* 8219A35Ch case   15:*/		return 0x8219A360;
		  /* 8219A360h */ case   16:  		/* lwz R11, <#[R28 + 8]> */
		/* 8219A360h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8219A360h case   16:*/		return 0x8219A364;
		  /* 8219A364h */ case   17:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219A364h case   17:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219A364h case   17:*/		return 0x8219A368;
		  /* 8219A368h */ case   18:  		/* cmplwi CR6, R11, 15872 */
		/* 8219A368h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 8219A368h case   18:*/		return 0x8219A36C;
		  /* 8219A36Ch */ case   19:  		/* bc 4, CR6_EQ, 876 */
		/* 8219A36Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x8219A6D8;  }
		/* 8219A36Ch case   19:*/		return 0x8219A370;
		  /* 8219A370h */ case   20:  		/* mr R4, R21 */
		/* 8219A370h case   20:*/		regs.R4 = regs.R21;
		/* 8219A370h case   20:*/		return 0x8219A374;
		  /* 8219A374h */ case   21:  		/* mr R3, R28 */
		/* 8219A374h case   21:*/		regs.R3 = regs.R28;
		/* 8219A374h case   21:*/		return 0x8219A378;
		  /* 8219A378h */ case   22:  		/* bl -140400 */
		/* 8219A378h case   22:*/		regs.LR = 0x8219A37C; return 0x82177F08;
		/* 8219A378h case   22:*/		return 0x8219A37C;
		  /* 8219A37Ch */ case   23:  		/* cmplw CR6, R26, R3 */
		/* 8219A37Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R3);
		/* 8219A37Ch case   23:*/		return 0x8219A380;
		  /* 8219A380h */ case   24:  		/* bc 4, CR6_EQ, 856 */
		/* 8219A380h case   24:*/		if ( !regs.CR[6].eq ) { return 0x8219A6D8;  }
		/* 8219A380h case   24:*/		return 0x8219A384;
		  /* 8219A384h */ case   25:  		/* lwz R27, <#[R28 + 4]> */
		/* 8219A384h case   25:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R28 + 0x00000004) );
		/* 8219A384h case   25:*/		return 0x8219A388;
		  /* 8219A388h */ case   26:  		/* cmplwi CR6, R27, 0 */
		/* 8219A388h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8219A388h case   26:*/		return 0x8219A38C;
		  /* 8219A38Ch */ case   27:  		/* bc 12, CR6_EQ, 844 */
		/* 8219A38Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x8219A6D8;  }
		/* 8219A38Ch case   27:*/		return 0x8219A390;
		  /* 8219A390h */ case   28:  		/* lwz R29, <#[R27 + 16]> */
		/* 8219A390h case   28:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R27 + 0x00000010) );
		/* 8219A390h case   28:*/		return 0x8219A394;
		  /* 8219A394h */ case   29:  		/* cmplwi CR6, R29, 0 */
		/* 8219A394h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8219A394h case   29:*/		return 0x8219A398;
		  /* 8219A398h */ case   30:  		/* bc 12, CR6_EQ, 824 */
		/* 8219A398h case   30:*/		if ( regs.CR[6].eq ) { return 0x8219A6D0;  }
		/* 8219A398h case   30:*/		return 0x8219A39C;
		  /* 8219A39Ch */ case   31:  		/* lwz R30, <#[R29 + 8]> */
		/* 8219A39Ch case   31:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000008) );
		/* 8219A39Ch case   31:*/		return 0x8219A3A0;
		  /* 8219A3A0h */ case   32:  		/* rlwinm R11, R30, 25, 25, 31 */
		/* 8219A3A0h case   32:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R30);
		/* 8219A3A0h case   32:*/		return 0x8219A3A4;
		  /* 8219A3A4h */ case   33:  		/* cmplwi CR6, R11, 59 */
		/* 8219A3A4h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003B);
		/* 8219A3A4h case   33:*/		return 0x8219A3A8;
		  /* 8219A3A8h */ case   34:  		/* bc 12, CR6_EQ, 44 */
		/* 8219A3A8h case   34:*/		if ( regs.CR[6].eq ) { return 0x8219A3D4;  }
		/* 8219A3A8h case   34:*/		return 0x8219A3AC;
		  /* 8219A3ACh */ case   35:  		/* cmplwi CR6, R11, 60 */
		/* 8219A3ACh case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003C);
		/* 8219A3ACh case   35:*/		return 0x8219A3B0;
		  /* 8219A3B0h */ case   36:  		/* bc 12, CR6_EQ, 36 */
		/* 8219A3B0h case   36:*/		if ( regs.CR[6].eq ) { return 0x8219A3D4;  }
		/* 8219A3B0h case   36:*/		return 0x8219A3B4;
		  /* 8219A3B4h */ case   37:  		/* cmplwi CR6, R11, 21 */
		/* 8219A3B4h case   37:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 8219A3B4h case   37:*/		return 0x8219A3B8;
		  /* 8219A3B8h */ case   38:  		/* bc 12, CR6_EQ, 28 */
		/* 8219A3B8h case   38:*/		if ( regs.CR[6].eq ) { return 0x8219A3D4;  }
		/* 8219A3B8h case   38:*/		return 0x8219A3BC;
		  /* 8219A3BCh */ case   39:  		/* cmplwi CR6, R11, 22 */
		/* 8219A3BCh case   39:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000016);
		/* 8219A3BCh case   39:*/		return 0x8219A3C0;
		  /* 8219A3C0h */ case   40:  		/* bc 12, CR6_EQ, 20 */
		/* 8219A3C0h case   40:*/		if ( regs.CR[6].eq ) { return 0x8219A3D4;  }
		/* 8219A3C0h case   40:*/		return 0x8219A3C4;
		  /* 8219A3C4h */ case   41:  		/* cmplwi CR6, R11, 117 */
		/* 8219A3C4h case   41:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000075);
		/* 8219A3C4h case   41:*/		return 0x8219A3C8;
		  /* 8219A3C8h */ case   42:  		/* bc 12, CR6_EQ, 12 */
		/* 8219A3C8h case   42:*/		if ( regs.CR[6].eq ) { return 0x8219A3D4;  }
		/* 8219A3C8h case   42:*/		return 0x8219A3CC;
		  /* 8219A3CCh */ case   43:  		/* cmplwi CR6, R11, 90 */
		/* 8219A3CCh case   43:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005A);
		/* 8219A3CCh case   43:*/		return 0x8219A3D0;
		  /* 8219A3D0h */ case   44:  		/* bc 4, CR6_EQ, 668 */
		/* 8219A3D0h case   44:*/		if ( !regs.CR[6].eq ) { return 0x8219A66C;  }
		/* 8219A3D0h case   44:*/		return 0x8219A3D4;
	}
	return 0x8219A3D4;
} // Block from 8219A320h-8219A3D4h (45 instructions)

//////////////////////////////////////////////////////
// Block at 8219A3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A3D4);
		  /* 8219A3D4h */ case    0:  		/* lwz R31, <#[R29 + 28]> */
		/* 8219A3D4h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x0000001C) );
		/* 8219A3D4h case    0:*/		return 0x8219A3D8;
		  /* 8219A3D8h */ case    1:  		/* lbz R11, <#[R31 + 76]> */
		/* 8219A3D8h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8219A3D8h case    1:*/		return 0x8219A3DC;
		  /* 8219A3DCh */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219A3DCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A3DCh case    2:*/		return 0x8219A3E0;
		  /* 8219A3E0h */ case    3:  		/* bc 4, CR0_EQ, 652 */
		/* 8219A3E0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219A66C;  }
		/* 8219A3E0h case    3:*/		return 0x8219A3E4;
		  /* 8219A3E4h */ case    4:  		/* mr R3, R29 */
		/* 8219A3E4h case    4:*/		regs.R3 = regs.R29;
		/* 8219A3E4h case    4:*/		return 0x8219A3E8;
		  /* 8219A3E8h */ case    5:  		/* bl -222008 */
		/* 8219A3E8h case    5:*/		regs.LR = 0x8219A3EC; return 0x821640B0;
		/* 8219A3E8h case    5:*/		return 0x8219A3EC;
		  /* 8219A3ECh */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219A3ECh case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219A3ECh case    6:*/		return 0x8219A3F0;
		  /* 8219A3F0h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8219A3F0h case    7:*/		if ( regs.CR[0].eq ) { return 0x8219A3FC;  }
		/* 8219A3F0h case    7:*/		return 0x8219A3F4;
		  /* 8219A3F4h */ case    8:  		/* rlwinm. R11, R30, 15, 31, 31 */
		/* 8219A3F4h case    8:*/		cpu::op::rlwinm<1,15,31,31>(regs,&regs.R11,regs.R30);
		/* 8219A3F4h case    8:*/		return 0x8219A3F8;
		  /* 8219A3F8h */ case    9:  		/* bc 4, CR0_EQ, 628 */
		/* 8219A3F8h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8219A66C;  }
		/* 8219A3F8h case    9:*/		return 0x8219A3FC;
	}
	return 0x8219A3FC;
} // Block from 8219A3D4h-8219A3FCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219A3FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A3FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A3FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A3FC);
		  /* 8219A3FCh */ case    0:  		/* lwz R11, <#[R31 + 48]> */
		/* 8219A3FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8219A3FCh case    0:*/		return 0x8219A400;
		  /* 8219A400h */ case    1:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 8219A400h case    1:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A400h case    1:*/		return 0x8219A404;
		  /* 8219A404h */ case    2:  		/* bc 12, CR0_EQ, 472 */
		/* 8219A404h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219A5DC;  }
		/* 8219A404h case    2:*/		return 0x8219A408;
		  /* 8219A408h */ case    3:  		/* lwz R11, <#[R21 + 44]> */
		/* 8219A408h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000002C) );
		/* 8219A408h case    3:*/		return 0x8219A40C;
		  /* 8219A40Ch */ case    4:  		/* rlwinm. R11, R11, 0, 16, 16 */
		/* 8219A40Ch case    4:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R11);
		/* 8219A40Ch case    4:*/		return 0x8219A410;
		  /* 8219A410h */ case    5:  		/* bc 4, CR0_EQ, 604 */
		/* 8219A410h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8219A66C;  }
		/* 8219A410h case    5:*/		return 0x8219A414;
		  /* 8219A414h */ case    6:  		/* lwz R11, <#[R21 + 92]> */
		/* 8219A414h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000005C) );
		/* 8219A414h case    6:*/		return 0x8219A418;
		  /* 8219A418h */ case    7:  		/* lis R10, -32231 */
		/* 8219A418h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8219);
		/* 8219A418h case    7:*/		return 0x8219A41C;
		  /* 8219A41Ch */ case    8:  		/* mr R6, R21 */
		/* 8219A41Ch case    8:*/		regs.R6 = regs.R21;
		/* 8219A41Ch case    8:*/		return 0x8219A420;
		  /* 8219A420h */ case    9:  		/* addi R5, R10, 28352 */
		/* 8219A420h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x6EC0);
		/* 8219A420h case    9:*/		return 0x8219A424;
		  /* 8219A424h */ case   10:  		/* addi R4, R11, 1 */
		/* 8219A424h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1);
		/* 8219A424h case   10:*/		return 0x8219A428;
		  /* 8219A428h */ case   11:  		/* addi R3, R1, 80 */
		/* 8219A428h case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8219A428h case   11:*/		return 0x8219A42C;
		  /* 8219A42Ch */ case   12:  		/* bl -16684 */
		/* 8219A42Ch case   12:*/		regs.LR = 0x8219A430; return 0x82196300;
		/* 8219A42Ch case   12:*/		return 0x8219A430;
		  /* 8219A430h */ case   13:  		/* lwz R10, <#[R1 + 80]> */
		/* 8219A430h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8219A430h case   13:*/		return 0x8219A434;
		  /* 8219A434h */ case   14:  		/* nor R11, R10, R10 */
		/* 8219A434h case   14:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R10,regs.R10);
		/* 8219A434h case   14:*/		return 0x8219A438;
		  /* 8219A438h */ case   15:  		/* addi R9, R10, 4 */
		/* 8219A438h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8219A438h case   15:*/		return 0x8219A43C;
		  /* 8219A43Ch */ case   16:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219A43Ch case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A43Ch case   16:*/		return 0x8219A440;
		  /* 8219A440h */ case   17:  		/* lwz R11, <#[R31 + 48]> */
		/* 8219A440h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8219A440h case   17:*/		return 0x8219A444;
		  /* 8219A444h */ case   18:  		/* rlwinm R11, R11, 0, 13, 31 */
		/* 8219A444h case   18:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R11,regs.R11);
		/* 8219A444h case   18:*/		return 0x8219A448;
		  /* 8219A448h */ case   19:  		/* bc 4, CR0_EQ, 8 */
		/* 8219A448h case   19:*/		if ( !regs.CR[0].eq ) { return 0x8219A450;  }
		/* 8219A448h case   19:*/		return 0x8219A44C;
		  /* 8219A44Ch */ case   20:  		/* addi R9, R1, 80 */
		/* 8219A44Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 8219A44Ch case   20:*/		return 0x8219A450;
	}
	return 0x8219A450;
} // Block from 8219A3FCh-8219A450h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8219A450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A450);
		  /* 8219A450h */ case    0:  		/* addi R11, R11, 1 */
		/* 8219A450h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219A450h case    0:*/		return 0x8219A454;
		  /* 8219A454h */ case    1:  		/* rlwinm R10, R11, 29, 3, 29 */
		/* 8219A454h case    1:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R11);
		/* 8219A454h case    1:*/		return 0x8219A458;
		  /* 8219A458h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8219A458h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219A458h case    2:*/		return 0x8219A45C;
		  /* 8219A45Ch */ case    3:  		/* slw R11, R19, R11 */
		/* 8219A45Ch case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R19,regs.R11);
		/* 8219A45Ch case    3:*/		return 0x8219A460;
		  /* 8219A460h */ case    4:  		/* lwzx R8, <#[R10 + R9]> */
		/* 8219A460h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8219A460h case    4:*/		return 0x8219A464;
		  /* 8219A464h */ case    5:  		/* or R11, R11, R8 */
		/* 8219A464h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8219A464h case    5:*/		return 0x8219A468;
		  /* 8219A468h */ case    6:  		/* stwx R11, <#[R10 + R9]> */
		/* 8219A468h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8219A468h case    6:*/		return 0x8219A46C;
		  /* 8219A46Ch */ case    7:  		/* lwz R11, <#[R21 + 4]> */
		/* 8219A46Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 8219A46Ch case    7:*/		return 0x8219A470;
		  /* 8219A470h */ case    8:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219A470h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219A470h case    8:*/		return 0x8219A474;
		  /* 8219A474h */ case    9:  		/* bc 4, CR0_EQ, 256 */
		/* 8219A474h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8219A574;  }
		/* 8219A474h case    9:*/		return 0x8219A478;
		  /* 8219A478h */ case   10:  		/* mr R31, R11 */
		/* 8219A478h case   10:*/		regs.R31 = regs.R11;
		/* 8219A478h case   10:*/		return 0x8219A47C;
		  /* 8219A47Ch */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 8219A47Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8219A47Ch case   11:*/		return 0x8219A480;
		  /* 8219A480h */ case   12:  		/* bc 12, CR0_EQ, 244 */
		/* 8219A480h case   12:*/		if ( regs.CR[0].eq ) { return 0x8219A574;  }
		/* 8219A480h case   12:*/		return 0x8219A484;
		  /* 8219A484h */ case   13:  		/* lwz R30, <#[R1 + 80]> */
		/* 8219A484h case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8219A484h case   13:*/		return 0x8219A488;
		  /* 8219A488h */ case   14:  		/* lwz R11, <#[R31 + 76]> */
		/* 8219A488h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8219A488h case   14:*/		return 0x8219A48C;
		  /* 8219A48Ch */ case   15:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 8219A48Ch case   15:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A48Ch case   15:*/		return 0x8219A490;
		  /* 8219A490h */ case   16:  		/* bc 12, CR0_EQ, 196 */
		/* 8219A490h case   16:*/		if ( regs.CR[0].eq ) { return 0x8219A554;  }
		/* 8219A490h case   16:*/		return 0x8219A494;
		  /* 8219A494h */ case   17:  		/* mr R3, R31 */
		/* 8219A494h case   17:*/		regs.R3 = regs.R31;
		/* 8219A494h case   17:*/		return 0x8219A498;
		  /* 8219A498h */ case   18:  		/* bl -221512 */
		/* 8219A498h case   18:*/		regs.LR = 0x8219A49C; return 0x82164350;
		/* 8219A498h case   18:*/		return 0x8219A49C;
		  /* 8219A49Ch */ case   19:  		/* nor R11, R30, R30 */
		/* 8219A49Ch case   19:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R30,regs.R30);
		/* 8219A49Ch case   19:*/		return 0x8219A4A0;
		  /* 8219A4A0h */ case   20:  		/* lwz R10, <#[R3 + 48]> */
		/* 8219A4A0h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000030) );
		/* 8219A4A0h case   20:*/		return 0x8219A4A4;
		  /* 8219A4A4h */ case   21:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 8219A4A4h case   21:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8219A4A4h case   21:*/		return 0x8219A4A8;
		  /* 8219A4A8h */ case   22:  		/* rlwinm R11, R10, 0, 13, 31 */
		/* 8219A4A8h case   22:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R11,regs.R10);
		/* 8219A4A8h case   22:*/		return 0x8219A4AC;
		  /* 8219A4ACh */ case   23:  		/* addi R10, R30, 4 */
		/* 8219A4ACh case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x4);
		/* 8219A4ACh case   23:*/		return 0x8219A4B0;
		  /* 8219A4B0h */ case   24:  		/* bc 4, CR0_EQ, 8 */
		/* 8219A4B0h case   24:*/		if ( !regs.CR[0].eq ) { return 0x8219A4B8;  }
		/* 8219A4B0h case   24:*/		return 0x8219A4B4;
		  /* 8219A4B4h */ case   25:  		/* addi R10, R1, 80 */
		/* 8219A4B4h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 8219A4B4h case   25:*/		return 0x8219A4B8;
	}
	return 0x8219A4B8;
} // Block from 8219A450h-8219A4B8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8219A4B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A4B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A4B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A4B8);
		  /* 8219A4B8h */ case    0:  		/* addi R11, R11, 1 */
		/* 8219A4B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219A4B8h case    0:*/		return 0x8219A4BC;
		  /* 8219A4BCh */ case    1:  		/* rlwinm R8, R11, 29, 3, 29 */
		/* 8219A4BCh case    1:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R8,regs.R11);
		/* 8219A4BCh case    1:*/		return 0x8219A4C0;
		  /* 8219A4C0h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8219A4C0h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219A4C0h case    2:*/		return 0x8219A4C4;
		  /* 8219A4C4h */ case    3:  		/* lwzx R10, <#[R8 + R10]> */
		/* 8219A4C4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8219A4C4h case    3:*/		return 0x8219A4C8;
		  /* 8219A4C8h */ case    4:  		/* srw R11, R10, R11 */
		/* 8219A4C8h case    4:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219A4C8h case    4:*/		return 0x8219A4CC;
		  /* 8219A4CCh */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219A4CCh case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A4CCh case    5:*/		return 0x8219A4D0;
		  /* 8219A4D0h */ case    6:  		/* bc 12, CR0_EQ, 132 */
		/* 8219A4D0h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219A554;  }
		/* 8219A4D0h case    6:*/		return 0x8219A4D4;
		  /* 8219A4D4h */ case    7:  		/* lwz R11, <#[R31 + 48]> */
		/* 8219A4D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8219A4D4h case    7:*/		return 0x8219A4D8;
		  /* 8219A4D8h */ case    8:  		/* cmplwi CR6, R9, 0 */
		/* 8219A4D8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8219A4D8h case    8:*/		return 0x8219A4DC;
		  /* 8219A4DCh */ case    9:  		/* addi R9, R30, 4 */
		/* 8219A4DCh case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x4);
		/* 8219A4DCh case    9:*/		return 0x8219A4E0;
		  /* 8219A4E0h */ case   10:  		/* rlwinm R11, R11, 0, 13, 31 */
		/* 8219A4E0h case   10:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R11,regs.R11);
		/* 8219A4E0h case   10:*/		return 0x8219A4E4;
		  /* 8219A4E4h */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 8219A4E4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8219A4EC;  }
		/* 8219A4E4h case   11:*/		return 0x8219A4E8;
		  /* 8219A4E8h */ case   12:  		/* addi R9, R1, 80 */
		/* 8219A4E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 8219A4E8h case   12:*/		return 0x8219A4EC;
	}
	return 0x8219A4EC;
} // Block from 8219A4B8h-8219A4ECh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219A4ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A4EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A4EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A4EC);
		  /* 8219A4ECh */ case    0:  		/* addi R11, R11, 1 */
		/* 8219A4ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219A4ECh case    0:*/		return 0x8219A4F0;
		  /* 8219A4F0h */ case    1:  		/* rlwinm R10, R11, 29, 3, 29 */
		/* 8219A4F0h case    1:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R11);
		/* 8219A4F0h case    1:*/		return 0x8219A4F4;
		  /* 8219A4F4h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8219A4F4h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219A4F4h case    2:*/		return 0x8219A4F8;
		  /* 8219A4F8h */ case    3:  		/* slw R11, R19, R11 */
		/* 8219A4F8h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R19,regs.R11);
		/* 8219A4F8h case    3:*/		return 0x8219A4FC;
		  /* 8219A4FCh */ case    4:  		/* lwzx R8, <#[R10 + R9]> */
		/* 8219A4FCh case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8219A4FCh case    4:*/		return 0x8219A500;
		  /* 8219A500h */ case    5:  		/* or R11, R11, R8 */
		/* 8219A500h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8219A500h case    5:*/		return 0x8219A504;
		  /* 8219A504h */ case    6:  		/* stwx R11, <#[R10 + R9]> */
		/* 8219A504h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8219A504h case    6:*/		return 0x8219A508;
		  /* 8219A508h */ case    7:  		/* lwz R11, <#[R31 + 48]> */
		/* 8219A508h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8219A508h case    7:*/		return 0x8219A50C;
		  /* 8219A50Ch */ case    8:  		/* rlwinm. R10, R11, 0, 6, 6 */
		/* 8219A50Ch case    8:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R10,regs.R11);
		/* 8219A50Ch case    8:*/		return 0x8219A510;
		  /* 8219A510h */ case    9:  		/* bc 4, CR0_EQ, 348 */
		/* 8219A510h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8219A66C;  }
		/* 8219A510h case    9:*/		return 0x8219A514;
		  /* 8219A514h */ case   10:  		/* rlwinm. R11, R11, 8, 31, 31 */
		/* 8219A514h case   10:*/		cpu::op::rlwinm<1,8,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A514h case   10:*/		return 0x8219A518;
		  /* 8219A518h */ case   11:  		/* bc 4, CR0_EQ, 44 */
		/* 8219A518h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8219A544;  }
		/* 8219A518h case   11:*/		return 0x8219A51C;
		  /* 8219A51Ch */ case   12:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219A51Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219A51Ch case   12:*/		return 0x8219A520;
		  /* 8219A520h */ case   13:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219A520h case   13:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219A520h case   13:*/		return 0x8219A524;
		  /* 8219A524h */ case   14:  		/* cmplwi CR6, R11, 21 */
		/* 8219A524h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 8219A524h case   14:*/		return 0x8219A528;
		  /* 8219A528h */ case   15:  		/* bc 12, CR6_LT, 16 */
		/* 8219A528h case   15:*/		if ( regs.CR[6].lt ) { return 0x8219A538;  }
		/* 8219A528h case   15:*/		return 0x8219A52C;
		  /* 8219A52Ch */ case   16:  		/* cmplwi CR6, R11, 24 */
		/* 8219A52Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 8219A52Ch case   16:*/		return 0x8219A530;
		  /* 8219A530h */ case   17:  		/* mr R11, R19 */
		/* 8219A530h case   17:*/		regs.R11 = regs.R19;
		/* 8219A530h case   17:*/		return 0x8219A534;
		  /* 8219A534h */ case   18:  		/* bc 4, CR6_GT, 8 */
		/* 8219A534h case   18:*/		if ( !regs.CR[6].gt ) { return 0x8219A53C;  }
		/* 8219A534h case   18:*/		return 0x8219A538;
	}
	return 0x8219A538;
} // Block from 8219A4ECh-8219A538h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8219A538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A538);
		  /* 8219A538h */ case    0:  		/* mr R11, R18 */
		/* 8219A538h case    0:*/		regs.R11 = regs.R18;
		/* 8219A538h case    0:*/		return 0x8219A53C;
	}
	return 0x8219A53C;
} // Block from 8219A538h-8219A53Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219A53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A53C);
		  /* 8219A53Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219A53Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219A53Ch case    0:*/		return 0x8219A540;
		  /* 8219A540h */ case    1:  		/* bc 12, CR0_EQ, 300 */
		/* 8219A540h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219A66C;  }
		/* 8219A540h case    1:*/		return 0x8219A544;
	}
	return 0x8219A544;
} // Block from 8219A53Ch-8219A544h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219A544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A544);
		  /* 8219A544h */ case    0:  		/* lbz R11, <#[R31 + 76]> */
		/* 8219A544h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8219A544h case    0:*/		return 0x8219A548;
		  /* 8219A548h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219A548h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A548h case    1:*/		return 0x8219A54C;
		  /* 8219A54Ch */ case    2:  		/* bc 4, CR0_EQ, 288 */
		/* 8219A54Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x8219A66C;  }
		/* 8219A54Ch case    2:*/		return 0x8219A550;
		  /* 8219A550h */ case    3:  		/* lwz R30, <#[R1 + 80]> */
		/* 8219A550h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8219A550h case    3:*/		return 0x8219A554;
	}
	return 0x8219A554;
} // Block from 8219A544h-8219A554h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219A554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A554);
		  /* 8219A554h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8219A554h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8219A554h case    0:*/		return 0x8219A558;
		  /* 8219A558h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219A558h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219A558h case    1:*/		return 0x8219A55C;
		  /* 8219A55Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219A55Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219A55Ch case    2:*/		return 0x8219A560;
		  /* 8219A560h */ case    3:  		/* bc 4, CR0_EQ, 24 */
		/* 8219A560h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219A578;  }
		/* 8219A560h case    3:*/		return 0x8219A564;
		  /* 8219A564h */ case    4:  		/* mr R31, R11 */
		/* 8219A564h case    4:*/		regs.R31 = regs.R11;
		/* 8219A564h case    4:*/		return 0x8219A568;
		  /* 8219A568h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8219A568h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219A568h case    5:*/		return 0x8219A56C;
		  /* 8219A56Ch */ case    6:  		/* bc 4, CR6_EQ, -228 */
		/* 8219A56Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219A488;  }
		/* 8219A56Ch case    6:*/		return 0x8219A570;
		  /* 8219A570h */ case    7:  		/* b 8 */
		/* 8219A570h case    7:*/		return 0x8219A578;
		/* 8219A570h case    7:*/		return 0x8219A574;
	}
	return 0x8219A574;
} // Block from 8219A554h-8219A574h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219A574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A574);
		  /* 8219A574h */ case    0:  		/* lwz R30, <#[R1 + 80]> */
		/* 8219A574h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 8219A574h case    0:*/		return 0x8219A578;
	}
	return 0x8219A578;
} // Block from 8219A574h-8219A578h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219A578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A578);
		  /* 8219A578h */ case    0:  		/* lwz R9, <#[R28 + 4]> */
		/* 8219A578h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000004) );
		/* 8219A578h case    0:*/		return 0x8219A57C;
		  /* 8219A57Ch */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 8219A57Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8219A57Ch case    1:*/		return 0x8219A580;
		  /* 8219A580h */ case    2:  		/* bc 12, CR6_EQ, 92 */
		/* 8219A580h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219A5DC;  }
		/* 8219A580h case    2:*/		return 0x8219A584;
		  /* 8219A584h */ case    3:  		/* lwz R11, <#[R9 + 16]> */
		/* 8219A584h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 8219A584h case    3:*/		return 0x8219A588;
		  /* 8219A588h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219A588h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219A588h case    4:*/		return 0x8219A58C;
		  /* 8219A58Ch */ case    5:  		/* bc 12, CR6_EQ, 72 */
		/* 8219A58Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8219A5D4;  }
		/* 8219A58Ch case    5:*/		return 0x8219A590;
		  /* 8219A590h */ case    6:  		/* cmplw CR6, R9, R27 */
		/* 8219A590h case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R27);
		/* 8219A590h case    6:*/		return 0x8219A594;
		  /* 8219A594h */ case    7:  		/* bc 12, CR6_EQ, 64 */
		/* 8219A594h case    7:*/		if ( regs.CR[6].eq ) { return 0x8219A5D4;  }
		/* 8219A594h case    7:*/		return 0x8219A598;
		  /* 8219A598h */ case    8:  		/* lwz R11, <#[R11 + 28]> */
		/* 8219A598h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 8219A598h case    8:*/		return 0x8219A59C;
		  /* 8219A59Ch */ case    9:  		/* nor R10, R30, R30 */
		/* 8219A59Ch case    9:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R30,regs.R30);
		/* 8219A59Ch case    9:*/		return 0x8219A5A0;
		  /* 8219A5A0h */ case   10:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 8219A5A0h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8219A5A0h case   10:*/		return 0x8219A5A4;
		  /* 8219A5A4h */ case   11:  		/* lwz R11, <#[R11 + 48]> */
		/* 8219A5A4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 8219A5A4h case   11:*/		return 0x8219A5A8;
		  /* 8219A5A8h */ case   12:  		/* addi R10, R30, 4 */
		/* 8219A5A8h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x4);
		/* 8219A5A8h case   12:*/		return 0x8219A5AC;
		  /* 8219A5ACh */ case   13:  		/* rlwinm R11, R11, 0, 13, 31 */
		/* 8219A5ACh case   13:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R11,regs.R11);
		/* 8219A5ACh case   13:*/		return 0x8219A5B0;
		  /* 8219A5B0h */ case   14:  		/* bc 4, CR0_EQ, 8 */
		/* 8219A5B0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8219A5B8;  }
		/* 8219A5B0h case   14:*/		return 0x8219A5B4;
		  /* 8219A5B4h */ case   15:  		/* addi R10, R1, 80 */
		/* 8219A5B4h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 8219A5B4h case   15:*/		return 0x8219A5B8;
	}
	return 0x8219A5B8;
} // Block from 8219A578h-8219A5B8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219A5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A5B8);
		  /* 8219A5B8h */ case    0:  		/* addi R11, R11, 1 */
		/* 8219A5B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219A5B8h case    0:*/		return 0x8219A5BC;
		  /* 8219A5BCh */ case    1:  		/* rlwinm R8, R11, 29, 3, 29 */
		/* 8219A5BCh case    1:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R8,regs.R11);
		/* 8219A5BCh case    1:*/		return 0x8219A5C0;
		  /* 8219A5C0h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8219A5C0h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219A5C0h case    2:*/		return 0x8219A5C4;
		  /* 8219A5C4h */ case    3:  		/* lwzx R10, <#[R8 + R10]> */
		/* 8219A5C4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 8219A5C4h case    3:*/		return 0x8219A5C8;
		  /* 8219A5C8h */ case    4:  		/* srw R11, R10, R11 */
		/* 8219A5C8h case    4:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219A5C8h case    4:*/		return 0x8219A5CC;
		  /* 8219A5CCh */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219A5CCh case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A5CCh case    5:*/		return 0x8219A5D0;
		  /* 8219A5D0h */ case    6:  		/* bc 4, CR0_EQ, 156 */
		/* 8219A5D0h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8219A66C;  }
		/* 8219A5D0h case    6:*/		return 0x8219A5D4;
	}
	return 0x8219A5D4;
} // Block from 8219A5B8h-8219A5D4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219A5D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A5D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A5D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A5D4);
		  /* 8219A5D4h */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 8219A5D4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 8219A5D4h case    0:*/		return 0x8219A5D8;
		  /* 8219A5D8h */ case    1:  		/* b -92 */
		/* 8219A5D8h case    1:*/		return 0x8219A57C;
		/* 8219A5D8h case    1:*/		return 0x8219A5DC;
	}
	return 0x8219A5DC;
} // Block from 8219A5D4h-8219A5DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219A5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A5DC);
		  /* 8219A5DCh */ case    0:  		/* lwz R30, <#[R29 + 4]> */
		/* 8219A5DCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000004) );
		/* 8219A5DCh case    0:*/		return 0x8219A5E0;
		  /* 8219A5E0h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 8219A5E0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219A5E0h case    1:*/		return 0x8219A5E4;
		  /* 8219A5E4h */ case    2:  		/* bc 12, CR6_EQ, 236 */
		/* 8219A5E4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219A6D0;  }
		/* 8219A5E4h case    2:*/		return 0x8219A5E8;
		  /* 8219A5E8h */ case    3:  		/* lwz R31, <#[R30 + 16]> */
		/* 8219A5E8h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 8219A5E8h case    3:*/		return 0x8219A5EC;
		  /* 8219A5ECh */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8219A5ECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219A5ECh case    4:*/		return 0x8219A5F0;
		  /* 8219A5F0h */ case    5:  		/* bc 12, CR6_EQ, 216 */
		/* 8219A5F0h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219A6C8;  }
		/* 8219A5F0h case    5:*/		return 0x8219A5F4;
		  /* 8219A5F4h */ case    6:  		/* lwz R10, <#[R30]> */
		/* 8219A5F4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8219A5F4h case    6:*/		return 0x8219A5F8;
		  /* 8219A5F8h */ case    7:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 8219A5F8h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 8219A5F8h case    7:*/		return 0x8219A5FC;
		  /* 8219A5FCh */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 8219A5FCh case    8:*/		if ( regs.CR[0].eq ) { return 0x8219A60C;  }
		/* 8219A5FCh case    8:*/		return 0x8219A600;
		  /* 8219A600h */ case    9:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 8219A600h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 8219A600h case    9:*/		return 0x8219A604;
		  /* 8219A604h */ case   10:  		/* mr R11, R19 */
		/* 8219A604h case   10:*/		regs.R11 = regs.R19;
		/* 8219A604h case   10:*/		return 0x8219A608;
		  /* 8219A608h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 8219A608h case   11:*/		if ( regs.CR[0].eq ) { return 0x8219A610;  }
		/* 8219A608h case   11:*/		return 0x8219A60C;
	}
	return 0x8219A60C;
} // Block from 8219A5DCh-8219A60Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219A60Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A60C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A60C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A60C);
		  /* 8219A60Ch */ case    0:  		/* mr R11, R18 */
		/* 8219A60Ch case    0:*/		regs.R11 = regs.R18;
		/* 8219A60Ch case    0:*/		return 0x8219A610;
	}
	return 0x8219A610;
} // Block from 8219A60Ch-8219A610h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219A610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A610);
		  /* 8219A610h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219A610h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219A610h case    0:*/		return 0x8219A614;
		  /* 8219A614h */ case    1:  		/* bc 12, CR0_EQ, 156 */
		/* 8219A614h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219A6B0;  }
		/* 8219A614h case    1:*/		return 0x8219A618;
		  /* 8219A618h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219A618h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219A618h case    2:*/		return 0x8219A61C;
		  /* 8219A61Ch */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219A61Ch case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219A61Ch case    3:*/		return 0x8219A620;
		  /* 8219A620h */ case    4:  		/* cmplwi CR6, R11, 90 */
		/* 8219A620h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005A);
		/* 8219A620h case    4:*/		return 0x8219A624;
		  /* 8219A624h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 8219A624h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219A634;  }
		/* 8219A624h case    5:*/		return 0x8219A628;
		  /* 8219A628h */ case    6:  		/* cmplwi CR6, R11, 87 */
		/* 8219A628h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000057);
		/* 8219A628h case    6:*/		return 0x8219A62C;
		  /* 8219A62Ch */ case    7:  		/* mr R11, R18 */
		/* 8219A62Ch case    7:*/		regs.R11 = regs.R18;
		/* 8219A62Ch case    7:*/		return 0x8219A630;
		  /* 8219A630h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 8219A630h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8219A638;  }
		/* 8219A630h case    8:*/		return 0x8219A634;
	}
	return 0x8219A634;
} // Block from 8219A610h-8219A634h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219A634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A634);
		  /* 8219A634h */ case    0:  		/* mr R11, R19 */
		/* 8219A634h case    0:*/		regs.R11 = regs.R19;
		/* 8219A634h case    0:*/		return 0x8219A638;
	}
	return 0x8219A638;
} // Block from 8219A634h-8219A638h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219A638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A638);
		  /* 8219A638h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219A638h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219A638h case    0:*/		return 0x8219A63C;
		  /* 8219A63Ch */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8219A63Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219A66C;  }
		/* 8219A63Ch case    1:*/		return 0x8219A640;
		  /* 8219A640h */ case    2:  		/* mr R3, R31 */
		/* 8219A640h case    2:*/		regs.R3 = regs.R31;
		/* 8219A640h case    2:*/		return 0x8219A644;
		  /* 8219A644h */ case    3:  		/* bl -222284 */
		/* 8219A644h case    3:*/		regs.LR = 0x8219A648; return 0x821641F8;
		/* 8219A644h case    3:*/		return 0x8219A648;
		  /* 8219A648h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219A648h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219A648h case    4:*/		return 0x8219A64C;
		  /* 8219A64Ch */ case    5:  		/* bc 12, CR0_EQ, 124 */
		/* 8219A64Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8219A6C8;  }
		/* 8219A64Ch case    5:*/		return 0x8219A650;
		  /* 8219A650h */ case    6:  		/* mr R4, R21 */
		/* 8219A650h case    6:*/		regs.R4 = regs.R21;
		/* 8219A650h case    6:*/		return 0x8219A654;
		  /* 8219A654h */ case    7:  		/* mr R3, R31 */
		/* 8219A654h case    7:*/		regs.R3 = regs.R31;
		/* 8219A654h case    7:*/		return 0x8219A658;
		  /* 8219A658h */ case    8:  		/* bl -220880 */
		/* 8219A658h case    8:*/		regs.LR = 0x8219A65C; return 0x82164788;
		/* 8219A658h case    8:*/		return 0x8219A65C;
		  /* 8219A65Ch */ case    9:  		/* cmpwi CR6, R3, 8 */
		/* 8219A65Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000008);
		/* 8219A65Ch case    9:*/		return 0x8219A660;
		  /* 8219A660h */ case   10:  		/* bc 12, CR6_LT, 104 */
		/* 8219A660h case   10:*/		if ( regs.CR[6].lt ) { return 0x8219A6C8;  }
		/* 8219A660h case   10:*/		return 0x8219A664;
		  /* 8219A664h */ case   11:  		/* cmpwi CR6, R3, 9 */
		/* 8219A664h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000009);
		/* 8219A664h case   11:*/		return 0x8219A668;
		  /* 8219A668h */ case   12:  		/* bc 12, CR6_GT, 96 */
		/* 8219A668h case   12:*/		if ( regs.CR[6].gt ) { return 0x8219A6C8;  }
		/* 8219A668h case   12:*/		return 0x8219A66C;
	}
	return 0x8219A66C;
} // Block from 8219A638h-8219A66Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219A66Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A66C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A66C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A66C);
		  /* 8219A66Ch */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 8219A66Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8219A66Ch case    0:*/		return 0x8219A670;
		  /* 8219A670h */ case    1:  		/* mr R28, R18 */
		/* 8219A670h case    1:*/		regs.R28 = regs.R18;
		/* 8219A670h case    1:*/		return 0x8219A674;
		  /* 8219A674h */ case    2:  		/* rlwinm. R11, R11, 0, 25, 27 */
		/* 8219A674h case    2:*/		cpu::op::rlwinm<1,0,25,27>(regs,&regs.R11,regs.R11);
		/* 8219A674h case    2:*/		return 0x8219A678;
		  /* 8219A678h */ case    3:  		/* bc 4, CR0_EQ, -856 */
		/* 8219A678h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219A320;  }
		/* 8219A678h case    3:*/		return 0x8219A67C;
		  /* 8219A67Ch */ case    4:  		/* lwz R11, <#[R24 + 4]> */
		/* 8219A67Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 8219A67Ch case    4:*/		return 0x8219A680;
		  /* 8219A680h */ case    5:  		/* addi R31, R24, 4 */
		/* 8219A680h case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R24,0x4);
		/* 8219A680h case    5:*/		return 0x8219A684;
		  /* 8219A684h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8219A684h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219A684h case    6:*/		return 0x8219A688;
		  /* 8219A688h */ case    7:  		/* bc 12, CR6_EQ, 92 */
		/* 8219A688h case    7:*/		if ( regs.CR[6].eq ) { return 0x8219A6E4;  }
		/* 8219A688h case    7:*/		return 0x8219A68C;
		  /* 8219A68Ch */ case    8:  		/* lwz R30, <#[R11 + 16]> */
		/* 8219A68Ch case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000010) );
		/* 8219A68Ch case    8:*/		return 0x8219A690;
		  /* 8219A690h */ case    9:  		/* cmplwi CR6, R30, 0 */
		/* 8219A690h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219A690h case    9:*/		return 0x8219A694;
		  /* 8219A694h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 8219A694h case   10:*/		if ( regs.CR[6].eq ) { return 0x8219A6A8;  }
		/* 8219A694h case   10:*/		return 0x8219A698;
		  /* 8219A698h */ case   11:  		/* lwz R10, <#[R30 + 8]> */
		/* 8219A698h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8219A698h case   11:*/		return 0x8219A69C;
		  /* 8219A69Ch */ case   12:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 8219A69Ch case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 8219A69Ch case   12:*/		return 0x8219A6A0;
		  /* 8219A6A0h */ case   13:  		/* cmplwi CR6, R10, 13568 */
		/* 8219A6A0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003500);
		/* 8219A6A0h case   13:*/		return 0x8219A6A4;
		  /* 8219A6A4h */ case   14:  		/* bc 12, CR6_EQ, 216 */
		/* 8219A6A4h case   14:*/		if ( regs.CR[6].eq ) { return 0x8219A77C;  }
		/* 8219A6A4h case   14:*/		return 0x8219A6A8;
	}
	return 0x8219A6A8;
} // Block from 8219A66Ch-8219A6A8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219A6A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A6A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A6A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A6A8);
		  /* 8219A6A8h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219A6A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219A6A8h case    0:*/		return 0x8219A6AC;
		  /* 8219A6ACh */ case    1:  		/* b -40 */
		/* 8219A6ACh case    1:*/		return 0x8219A684;
		/* 8219A6ACh case    1:*/		return 0x8219A6B0;
	}
	return 0x8219A6B0;
} // Block from 8219A6A8h-8219A6B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219A6B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A6B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A6B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A6B0);
		  /* 8219A6B0h */ case    0:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 8219A6B0h case    0:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 8219A6B0h case    0:*/		return 0x8219A6B4;
		  /* 8219A6B4h */ case    1:  		/* bc 12, CR0_EQ, -72 */
		/* 8219A6B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219A66C;  }
		/* 8219A6B4h case    1:*/		return 0x8219A6B8;
		  /* 8219A6B8h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219A6B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219A6B8h case    2:*/		return 0x8219A6BC;
		  /* 8219A6BCh */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219A6BCh case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219A6BCh case    3:*/		return 0x8219A6C0;
		  /* 8219A6C0h */ case    4:  		/* cmplwi CR6, R11, 14336 */
		/* 8219A6C0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 8219A6C0h case    4:*/		return 0x8219A6C4;
		  /* 8219A6C4h */ case    5:  		/* bc 4, CR6_EQ, -88 */
		/* 8219A6C4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219A66C;  }
		/* 8219A6C4h case    5:*/		return 0x8219A6C8;
	}
	return 0x8219A6C8;
} // Block from 8219A6B0h-8219A6C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219A6C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A6C8);
		  /* 8219A6C8h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 8219A6C8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 8219A6C8h case    0:*/		return 0x8219A6CC;
		  /* 8219A6CCh */ case    1:  		/* b -236 */
		/* 8219A6CCh case    1:*/		return 0x8219A5E0;
		/* 8219A6CCh case    1:*/		return 0x8219A6D0;
	}
	return 0x8219A6D0;
} // Block from 8219A6C8h-8219A6D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219A6D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A6D0);
		  /* 8219A6D0h */ case    0:  		/* lwz R27, <#[R27 + 8]> */
		/* 8219A6D0h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000008) );
		/* 8219A6D0h case    0:*/		return 0x8219A6D4;
		  /* 8219A6D4h */ case    1:  		/* b -844 */
		/* 8219A6D4h case    1:*/		return 0x8219A388;
		/* 8219A6D4h case    1:*/		return 0x8219A6D8;
	}
	return 0x8219A6D8;
} // Block from 8219A6D0h-8219A6D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219A6D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A6D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A6D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A6D8);
		  /* 8219A6D8h */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 8219A6D8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 8219A6D8h case    0:*/		return 0x8219A6DC;
		  /* 8219A6DCh */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219A6DCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219A6DCh case    1:*/		return 0x8219A6E0;
		  /* 8219A6E0h */ case    2:  		/* b -920 */
		/* 8219A6E0h case    2:*/		return 0x8219A348;
		/* 8219A6E0h case    2:*/		return 0x8219A6E4;
	}
	return 0x8219A6E4;
} // Block from 8219A6D8h-8219A6E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219A6E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A6E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A6E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A6E4);
		  /* 8219A6E4h */ case    0:  		/* lwz R11, <#[R21 + 4]> */
		/* 8219A6E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 8219A6E4h case    0:*/		return 0x8219A6E8;
		  /* 8219A6E8h */ case    1:  		/* li R8, 1 */
		/* 8219A6E8h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8219A6E8h case    1:*/		return 0x8219A6EC;
		  /* 8219A6ECh */ case    2:  		/* li R7, 1 */
		/* 8219A6ECh case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8219A6ECh case    2:*/		return 0x8219A6F0;
		  /* 8219A6F0h */ case    3:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219A6F0h case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219A6F0h case    3:*/		return 0x8219A6F4;
		  /* 8219A6F4h */ case    4:  		/* li R6, 106 */
		/* 8219A6F4h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x6A);
		/* 8219A6F4h case    4:*/		return 0x8219A6F8;
		  /* 8219A6F8h */ case    5:  		/* addic R10, R10, -1 */
		/* 8219A6F8h case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219A6F8h case    5:*/		return 0x8219A6FC;
		  /* 8219A6FCh */ case    6:  		/* li R5, 0 */
		/* 8219A6FCh case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219A6FCh case    6:*/		return 0x8219A700;
		  /* 8219A700h */ case    7:  		/* subfe R10, R10, R10 */
		/* 8219A700h case    7:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8219A700h case    7:*/		return 0x8219A704;
		  /* 8219A704h */ case    8:  		/* mr R3, R21 */
		/* 8219A704h case    8:*/		regs.R3 = regs.R21;
		/* 8219A704h case    8:*/		return 0x8219A708;
		  /* 8219A708h */ case    9:  		/* and R4, R10, R11 */
		/* 8219A708h case    9:*/		cpu::op::and<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 8219A708h case    9:*/		return 0x8219A70C;
		  /* 8219A70Ch */ case   10:  		/* bl 565900 */
		/* 8219A70Ch case   10:*/		regs.LR = 0x8219A710; return 0x82224998;
		/* 8219A70Ch case   10:*/		return 0x8219A710;
		  /* 8219A710h */ case   11:  		/* lwz R10, <#[R21 + 4]> */
		/* 8219A710h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000004) );
		/* 8219A710h case   11:*/		return 0x8219A714;
		  /* 8219A714h */ case   12:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 8219A714h case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 8219A714h case   12:*/		return 0x8219A718;
		  /* 8219A718h */ case   13:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 8219A718h case   13:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 8219A718h case   13:*/		return 0x8219A71C;
		  /* 8219A71Ch */ case   14:  		/* addi R11, R11, 36 */
		/* 8219A71Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 8219A71Ch case   14:*/		return 0x8219A720;
		  /* 8219A720h */ case   15:  		/* addic R9, R9, -1 */
		/* 8219A720h case   15:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8219A720h case   15:*/		return 0x8219A724;
		  /* 8219A724h */ case   16:  		/* addi R7, R11, -36 */
		/* 8219A724h case   16:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 8219A724h case   16:*/		return 0x8219A728;
		  /* 8219A728h */ case   17:  		/* subfe R8, R9, R9 */
		/* 8219A728h case   17:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R9,regs.R9);
		/* 8219A728h case   17:*/		return 0x8219A72C;
		  /* 8219A72Ch */ case   18:  		/* addi R9, R11, 4 */
		/* 8219A72Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8219A72Ch case   18:*/		return 0x8219A730;
		  /* 8219A730h */ case   19:  		/* and R10, R8, R10 */
		/* 8219A730h case   19:*/		cpu::op::and<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8219A730h case   19:*/		return 0x8219A734;
		  /* 8219A734h */ case   20:  		/* mr R30, R3 */
		/* 8219A734h case   20:*/		regs.R30 = regs.R3;
		/* 8219A734h case   20:*/		return 0x8219A738;
		  /* 8219A738h */ case   21:  		/* addi R8, R10, 24 */
		/* 8219A738h case   21:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x18);
		/* 8219A738h case   21:*/		return 0x8219A73C;
		  /* 8219A73Ch */ case   22:  		/* mr R4, R24 */
		/* 8219A73Ch case   22:*/		regs.R4 = regs.R24;
		/* 8219A73Ch case   22:*/		return 0x8219A740;
		  /* 8219A740h */ case   23:  		/* addi R8, R8, 4 */
		/* 8219A740h case   23:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8219A740h case   23:*/		return 0x8219A744;
		  /* 8219A744h */ case   24:  		/* lwz R6, <#[R10 + 28]> */
		/* 8219A744h case   24:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x0000001C) );
		/* 8219A744h case   24:*/		return 0x8219A748;
		  /* 8219A748h */ case   25:  		/* mr R3, R21 */
		/* 8219A748h case   25:*/		regs.R3 = regs.R21;
		/* 8219A748h case   25:*/		return 0x8219A74C;
		  /* 8219A74Ch */ case   26:  		/* ori R8, R8, 1 */
		/* 8219A74Ch case   26:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8219A74Ch case   26:*/		return 0x8219A750;
		  /* 8219A750h */ case   27:  		/* stw R6, <#[R11 + 4]> */
		/* 8219A750h case   27:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 8219A750h case   27:*/		return 0x8219A754;
		  /* 8219A754h */ case   28:  		/* lwz R6, <#[R10 + 28]> */
		/* 8219A754h case   28:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x0000001C) );
		/* 8219A754h case   28:*/		return 0x8219A758;
		  /* 8219A758h */ case   29:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 8219A758h case   29:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 8219A758h case   29:*/		return 0x8219A75C;
		  /* 8219A75Ch */ case   30:  		/* stw R9, <#[R6 + 36]> */
		/* 8219A75Ch case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000024) );
		/* 8219A75Ch case   30:*/		return 0x8219A760;
		  /* 8219A760h */ case   31:  		/* stw R8, <#[R11]> */
		/* 8219A760h case   31:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8219A760h case   31:*/		return 0x8219A764;
		  /* 8219A764h */ case   32:  		/* stw R7, <#[R10 + 28]> */
		/* 8219A764h case   32:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x0000001C) );
		/* 8219A764h case   32:*/		return 0x8219A768;
		  /* 8219A768h */ case   33:  		/* bl -141160 */
		/* 8219A768h case   33:*/		regs.LR = 0x8219A76C; return 0x82178000;
		/* 8219A768h case   33:*/		return 0x8219A76C;
		  /* 8219A76Ch */ case   34:  		/* mr R5, R3 */
		/* 8219A76Ch case   34:*/		regs.R5 = regs.R3;
		/* 8219A76Ch case   34:*/		return 0x8219A770;
		  /* 8219A770h */ case   35:  		/* li R4, 0 */
		/* 8219A770h case   35:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8219A770h case   35:*/		return 0x8219A774;
		  /* 8219A774h */ case   36:  		/* mr R3, R30 */
		/* 8219A774h case   36:*/		regs.R3 = regs.R30;
		/* 8219A774h case   36:*/		return 0x8219A778;
		  /* 8219A778h */ case   37:  		/* bl -172232 */
		/* 8219A778h case   37:*/		regs.LR = 0x8219A77C; return 0x821706B0;
		/* 8219A778h case   37:*/		return 0x8219A77C;
	}
	return 0x8219A77C;
} // Block from 8219A6E4h-8219A77Ch (38 instructions)

//////////////////////////////////////////////////////
// Block at 8219A77Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A77C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A77C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A77C);
		  /* 8219A77Ch */ case    0:  		/* mr R29, R31 */
		/* 8219A77Ch case    0:*/		regs.R29 = regs.R31;
		/* 8219A77Ch case    0:*/		return 0x8219A780;
		  /* 8219A780h */ case    1:  		/* lwz R31, <#[R29]> */
		/* 8219A780h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 8219A780h case    1:*/		return 0x8219A784;
		  /* 8219A784h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 8219A784h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219A784h case    2:*/		return 0x8219A788;
		  /* 8219A788h */ case    3:  		/* bc 12, CR6_EQ, 268 */
		/* 8219A788h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219A894;  }
		/* 8219A788h case    3:*/		return 0x8219A78C;
		  /* 8219A78Ch */ case    4:  		/* lwz R11, <#[R31 + 16]> */
		/* 8219A78Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8219A78Ch case    4:*/		return 0x8219A790;
		  /* 8219A790h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8219A790h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219A790h case    5:*/		return 0x8219A794;
		  /* 8219A794h */ case    6:  		/* bc 12, CR6_EQ, 236 */
		/* 8219A794h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219A880;  }
		/* 8219A794h case    6:*/		return 0x8219A798;
		  /* 8219A798h */ case    7:  		/* cmplw CR6, R11, R30 */
		/* 8219A798h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8219A798h case    7:*/		return 0x8219A79C;
		  /* 8219A79Ch */ case    8:  		/* bc 12, CR6_EQ, 228 */
		/* 8219A79Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x8219A880;  }
		/* 8219A79Ch case    8:*/		return 0x8219A7A0;
		  /* 8219A7A0h */ case    9:  		/* lwz R10, <#[R21 + 4]> */
		/* 8219A7A0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000004) );
		/* 8219A7A0h case    9:*/		return 0x8219A7A4;
		  /* 8219A7A4h */ case   10:  		/* lwz R4, <#[R11 + 28]> */
		/* 8219A7A4h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000001C) );
		/* 8219A7A4h case   10:*/		return 0x8219A7A8;
		  /* 8219A7A8h */ case   11:  		/* rlwinm R11, R10, 0, 31, 31 */
		/* 8219A7A8h case   11:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R10);
		/* 8219A7A8h case   11:*/		return 0x8219A7AC;
		  /* 8219A7ACh */ case   12:  		/* addic R11, R11, -1 */
		/* 8219A7ACh case   12:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8219A7ACh case   12:*/		return 0x8219A7B0;
		  /* 8219A7B0h */ case   13:  		/* subfe R11, R11, R11 */
		/* 8219A7B0h case   13:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8219A7B0h case   13:*/		return 0x8219A7B4;
		  /* 8219A7B4h */ case   14:  		/* and R11, R11, R10 */
		/* 8219A7B4h case   14:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219A7B4h case   14:*/		return 0x8219A7B8;
		  /* 8219A7B8h */ case   15:  		/* cmplw CR6, R4, R11 */
		/* 8219A7B8h case   15:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8219A7B8h case   15:*/		return 0x8219A7BC;
		  /* 8219A7BCh */ case   16:  		/* bc 4, CR6_EQ, 64 */
		/* 8219A7BCh case   16:*/		if ( !regs.CR[6].eq ) { return 0x8219A7FC;  }
		/* 8219A7BCh case   16:*/		return 0x8219A7C0;
		  /* 8219A7C0h */ case   17:  		/* lwz R11, <#[R31 + 12]> */
		/* 8219A7C0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219A7C0h case   17:*/		return 0x8219A7C4;
		  /* 8219A7C4h */ case   18:  		/* addi R11, R11, 4 */
		/* 8219A7C4h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219A7C4h case   18:*/		return 0x8219A7C8;
		  /* 8219A7C8h */ case   19:  		/* lwz R10, <#[R11]> */
		/* 8219A7C8h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219A7C8h case   19:*/		return 0x8219A7CC;
		  /* 8219A7CCh */ case   20:  		/* b 12 */
		/* 8219A7CCh case   20:*/		return 0x8219A7D8;
		/* 8219A7CCh case   20:*/		return 0x8219A7D0;
		  /* 8219A7D0h */ case   21:  		/* addi R11, R10, 8 */
		/* 8219A7D0h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 8219A7D0h case   21:*/		return 0x8219A7D4;
		  /* 8219A7D4h */ case   22:  		/* lwz R10, <#[R10 + 8]> */
		/* 8219A7D4h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8219A7D4h case   22:*/		return 0x8219A7D8;
	}
	return 0x8219A7D8;
} // Block from 8219A77Ch-8219A7D8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219A7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A7D8);
		  /* 8219A7D8h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 8219A7D8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8219A7D8h case    0:*/		return 0x8219A7DC;
		  /* 8219A7DCh */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8219A7DCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219A7D0;  }
		/* 8219A7DCh case    1:*/		return 0x8219A7E0;
		  /* 8219A7E0h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219A7E0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219A7E0h case    2:*/		return 0x8219A7E4;
		  /* 8219A7E4h */ case    3:  		/* stw R10, <#[R11]> */
		/* 8219A7E4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219A7E4h case    3:*/		return 0x8219A7E8;
		  /* 8219A7E8h */ case    4:  		/* lwz R11, <#[R30 + 4]> */
		/* 8219A7E8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8219A7E8h case    4:*/		return 0x8219A7EC;
		  /* 8219A7ECh */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 8219A7ECh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219A7ECh case    5:*/		return 0x8219A7F0;
		  /* 8219A7F0h */ case    6:  		/* stw R31, <#[R30 + 4]> */
		/* 8219A7F0h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 8219A7F0h case    6:*/		return 0x8219A7F4;
		  /* 8219A7F4h */ case    7:  		/* stw R30, <#[R31 + 12]> */
		/* 8219A7F4h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219A7F4h case    7:*/		return 0x8219A7F8;
		  /* 8219A7F8h */ case    8:  		/* b 136 */
		/* 8219A7F8h case    8:*/		return 0x8219A880;
		/* 8219A7F8h case    8:*/		return 0x8219A7FC;
	}
	return 0x8219A7FC;
} // Block from 8219A7D8h-8219A7FCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219A7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A7FC);
		  /* 8219A7FCh */ case    0:  		/* li R8, 1 */
		/* 8219A7FCh case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8219A7FCh case    0:*/		return 0x8219A800;
		  /* 8219A800h */ case    1:  		/* li R7, 0 */
		/* 8219A800h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219A800h case    1:*/		return 0x8219A804;
		  /* 8219A804h */ case    2:  		/* li R6, 0 */
		/* 8219A804h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8219A804h case    2:*/		return 0x8219A808;
		  /* 8219A808h */ case    3:  		/* mr R5, R30 */
		/* 8219A808h case    3:*/		regs.R5 = regs.R30;
		/* 8219A808h case    3:*/		return 0x8219A80C;
		  /* 8219A80Ch */ case    4:  		/* mr R3, R21 */
		/* 8219A80Ch case    4:*/		regs.R3 = regs.R21;
		/* 8219A80Ch case    4:*/		return 0x8219A810;
		  /* 8219A810h */ case    5:  		/* bl 114816 */
		/* 8219A810h case    5:*/		regs.LR = 0x8219A814; return 0x821B6890;
		/* 8219A810h case    5:*/		return 0x8219A814;
		  /* 8219A814h */ case    6:  		/* lwz R11, <#[R3 + 16]> */
		/* 8219A814h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8219A814h case    6:*/		return 0x8219A818;
		  /* 8219A818h */ case    7:  		/* rlwinm. R10, R11, 0, 16, 31 */
		/* 8219A818h case    7:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R10,regs.R11);
		/* 8219A818h case    7:*/		return 0x8219A81C;
		  /* 8219A81Ch */ case    8:  		/* bc 4, CR0_EQ, 44 */
		/* 8219A81Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x8219A848;  }
		/* 8219A81Ch case    8:*/		return 0x8219A820;
		  /* 8219A820h */ case    9:  		/* rlwimi R11, R19, 16, 13, 15 */
		/* 8219A820h case    9:*/		cpu::op::rlwimi<0,16,13,15>(regs,&regs.R11,regs.R19);
		/* 8219A820h case    9:*/		return 0x8219A824;
		  /* 8219A824h */ case   10:  		/* stw R11, <#[R3 + 16]> */
		/* 8219A824h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8219A824h case   10:*/		return 0x8219A828;
		  /* 8219A828h */ case   11:  		/* lwz R11, <#[R21 + 116]> */
		/* 8219A828h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000074) );
		/* 8219A828h case   11:*/		return 0x8219A82C;
		  /* 8219A82Ch */ case   12:  		/* lhz R10, <#[R3 + 16]> */
		/* 8219A82Ch case   12:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 8219A82Ch case   12:*/		return 0x8219A830;
		  /* 8219A830h */ case   13:  		/* addi R11, R11, 1 */
		/* 8219A830h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219A830h case   13:*/		return 0x8219A834;
		  /* 8219A834h */ case   14:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 8219A834h case   14:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 8219A834h case   14:*/		return 0x8219A838;
		  /* 8219A838h */ case   15:  		/* sth R11, <#[R3 + 18]> */
		/* 8219A838h case   15:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00000012) );
		/* 8219A838h case   15:*/		return 0x8219A83C;
		  /* 8219A83Ch */ case   16:  		/* lwz R11, <#[R21 + 116]> */
		/* 8219A83Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000074) );
		/* 8219A83Ch case   16:*/		return 0x8219A840;
		  /* 8219A840h */ case   17:  		/* add R11, R10, R11 */
		/* 8219A840h case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219A840h case   17:*/		return 0x8219A844;
		  /* 8219A844h */ case   18:  		/* stw R11, <#[R21 + 116]> */
		/* 8219A844h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000074) );
		/* 8219A844h case   18:*/		return 0x8219A848;
	}
	return 0x8219A848;
} // Block from 8219A7FCh-8219A848h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8219A848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A848);
		  /* 8219A848h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8219A848h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219A848h case    0:*/		return 0x8219A84C;
		  /* 8219A84Ch */ case    1:  		/* addi R11, R11, 4 */
		/* 8219A84Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219A84Ch case    1:*/		return 0x8219A850;
		  /* 8219A850h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 8219A850h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219A850h case    2:*/		return 0x8219A854;
		  /* 8219A854h */ case    3:  		/* b 12 */
		/* 8219A854h case    3:*/		return 0x8219A860;
		/* 8219A854h case    3:*/		return 0x8219A858;
		  /* 8219A858h */ case    4:  		/* addi R11, R10, 8 */
		/* 8219A858h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 8219A858h case    4:*/		return 0x8219A85C;
		  /* 8219A85Ch */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 8219A85Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8219A85Ch case    5:*/		return 0x8219A860;
	}
	return 0x8219A860;
} // Block from 8219A848h-8219A860h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219A860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A860);
		  /* 8219A860h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 8219A860h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8219A860h case    0:*/		return 0x8219A864;
		  /* 8219A864h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8219A864h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219A858;  }
		/* 8219A864h case    1:*/		return 0x8219A868;
		  /* 8219A868h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219A868h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219A868h case    2:*/		return 0x8219A86C;
		  /* 8219A86Ch */ case    3:  		/* stw R10, <#[R11]> */
		/* 8219A86Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219A86Ch case    3:*/		return 0x8219A870;
		  /* 8219A870h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 8219A870h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219A870h case    4:*/		return 0x8219A874;
		  /* 8219A874h */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 8219A874h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219A874h case    5:*/		return 0x8219A878;
		  /* 8219A878h */ case    6:  		/* stw R31, <#[R3 + 4]> */
		/* 8219A878h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000004) );
		/* 8219A878h case    6:*/		return 0x8219A87C;
		  /* 8219A87Ch */ case    7:  		/* stw R3, <#[R31 + 12]> */
		/* 8219A87Ch case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219A87Ch case    7:*/		return 0x8219A880;
	}
	return 0x8219A880;
} // Block from 8219A860h-8219A880h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219A880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A880);
		  /* 8219A880h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8219A880h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8219A880h case    0:*/		return 0x8219A884;
		  /* 8219A884h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 8219A884h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8219A884h case    1:*/		return 0x8219A888;
		  /* 8219A888h */ case    2:  		/* bc 4, CR6_EQ, -264 */
		/* 8219A888h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8219A780;  }
		/* 8219A888h case    2:*/		return 0x8219A88C;
		  /* 8219A88Ch */ case    3:  		/* addi R29, R31, 8 */
		/* 8219A88Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x8);
		/* 8219A88Ch case    3:*/		return 0x8219A890;
		  /* 8219A890h */ case    4:  		/* b -272 */
		/* 8219A890h case    4:*/		return 0x8219A780;
		/* 8219A890h case    4:*/		return 0x8219A894;
	}
	return 0x8219A894;
} // Block from 8219A880h-8219A894h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219A894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A894);
		  /* 8219A894h */ case    0:  		/* mr R3, R30 */
		/* 8219A894h case    0:*/		regs.R3 = regs.R30;
		/* 8219A894h case    0:*/		return 0x8219A898;
		  /* 8219A898h */ case    1:  		/* bl -140576 */
		/* 8219A898h case    1:*/		regs.LR = 0x8219A89C; return 0x82178378;
		/* 8219A898h case    1:*/		return 0x8219A89C;
		  /* 8219A89Ch */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219A89Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219A89Ch case    2:*/		return 0x8219A8A0;
		  /* 8219A8A0h */ case    3:  		/* mr R4, R30 */
		/* 8219A8A0h case    3:*/		regs.R4 = regs.R30;
		/* 8219A8A0h case    3:*/		return 0x8219A8A4;
		  /* 8219A8A4h */ case    4:  		/* oris R11, R11, 256 */
		/* 8219A8A4h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 8219A8A4h case    4:*/		return 0x8219A8A8;
		  /* 8219A8A8h */ case    5:  		/* mr R3, R21 */
		/* 8219A8A8h case    5:*/		regs.R3 = regs.R21;
		/* 8219A8A8h case    5:*/		return 0x8219A8AC;
		  /* 8219A8ACh */ case    6:  		/* stw R11, <#[R30 + 8]> */
		/* 8219A8ACh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219A8ACh case    6:*/		return 0x8219A8B0;
		  /* 8219A8B0h */ case    7:  		/* bl 113656 */
		/* 8219A8B0h case    7:*/		regs.LR = 0x8219A8B4; return 0x821B64A8;
		/* 8219A8B0h case    7:*/		return 0x8219A8B4;
		  /* 8219A8B4h */ case    8:  		/* b -1428 */
		/* 8219A8B4h case    8:*/		return 0x8219A320;
		/* 8219A8B4h case    8:*/		return 0x8219A8B8;
	}
	return 0x8219A8B8;
} // Block from 8219A894h-8219A8B8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219A8B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A8B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A8B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A8B8);
		  /* 8219A8B8h */ case    0:  		/* addi R25, R24, 4 */
		/* 8219A8B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R24,0x4);
		/* 8219A8B8h case    0:*/		return 0x8219A8BC;
		  /* 8219A8BCh */ case    1:  		/* lwz R26, <#[R25]> */
		/* 8219A8BCh case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R25 + 0x00000000) );
		/* 8219A8BCh case    1:*/		return 0x8219A8C0;
		  /* 8219A8C0h */ case    2:  		/* cmplwi CR6, R26, 0 */
		/* 8219A8C0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8219A8C0h case    2:*/		return 0x8219A8C4;
		  /* 8219A8C4h */ case    3:  		/* bc 12, CR6_EQ, 1064 */
		/* 8219A8C4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219ACEC;  }
		/* 8219A8C4h case    3:*/		return 0x8219A8C8;
		  /* 8219A8C8h */ case    4:  		/* lwz R27, <#[R26 + 16]> */
		/* 8219A8C8h case    4:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R26 + 0x00000010) );
		/* 8219A8C8h case    4:*/		return 0x8219A8CC;
		  /* 8219A8CCh */ case    5:  		/* cmplwi CR6, R27, 0 */
		/* 8219A8CCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8219A8CCh case    5:*/		return 0x8219A8D0;
		  /* 8219A8D0h */ case    6:  		/* bc 12, CR6_EQ, 1032 */
		/* 8219A8D0h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219ACD8;  }
		/* 8219A8D0h case    6:*/		return 0x8219A8D4;
		  /* 8219A8D4h */ case    7:  		/* lwz R11, <#[R27 + 8]> */
		/* 8219A8D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219A8D4h case    7:*/		return 0x8219A8D8;
		  /* 8219A8D8h */ case    8:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219A8D8h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219A8D8h case    8:*/		return 0x8219A8DC;
		  /* 8219A8DCh */ case    9:  		/* cmplwi CR6, R11, 117 */
		/* 8219A8DCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000075);
		/* 8219A8DCh case    9:*/		return 0x8219A8E0;
		  /* 8219A8E0h */ case   10:  		/* bc 12, CR6_EQ, 1016 */
		/* 8219A8E0h case   10:*/		if ( regs.CR[6].eq ) { return 0x8219ACD8;  }
		/* 8219A8E0h case   10:*/		return 0x8219A8E4;
		  /* 8219A8E4h */ case   11:  		/* cmplwi CR6, R11, 59 */
		/* 8219A8E4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003B);
		/* 8219A8E4h case   11:*/		return 0x8219A8E8;
		  /* 8219A8E8h */ case   12:  		/* bc 12, CR6_EQ, 28 */
		/* 8219A8E8h case   12:*/		if ( regs.CR[6].eq ) { return 0x8219A904;  }
		/* 8219A8E8h case   12:*/		return 0x8219A8EC;
		  /* 8219A8ECh */ case   13:  		/* cmplwi CR6, R11, 60 */
		/* 8219A8ECh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003C);
		/* 8219A8ECh case   13:*/		return 0x8219A8F0;
		  /* 8219A8F0h */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 8219A8F0h case   14:*/		if ( regs.CR[6].eq ) { return 0x8219A904;  }
		/* 8219A8F0h case   14:*/		return 0x8219A8F4;
		  /* 8219A8F4h */ case   15:  		/* cmplwi CR6, R11, 21 */
		/* 8219A8F4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 8219A8F4h case   15:*/		return 0x8219A8F8;
		  /* 8219A8F8h */ case   16:  		/* bc 12, CR6_EQ, 12 */
		/* 8219A8F8h case   16:*/		if ( regs.CR[6].eq ) { return 0x8219A904;  }
		/* 8219A8F8h case   16:*/		return 0x8219A8FC;
		  /* 8219A8FCh */ case   17:  		/* cmplwi CR6, R11, 22 */
		/* 8219A8FCh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000016);
		/* 8219A8FCh case   17:*/		return 0x8219A900;
		  /* 8219A900h */ case   18:  		/* bc 4, CR6_EQ, 984 */
		/* 8219A900h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8219ACD8;  }
		/* 8219A900h case   18:*/		return 0x8219A904;
	}
	return 0x8219A904;
} // Block from 8219A8B8h-8219A904h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8219A904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A904);
		  /* 8219A904h */ case    0:  		/* lwz R30, <#[R27 + 28]> */
		/* 8219A904h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x0000001C) );
		/* 8219A904h case    0:*/		return 0x8219A908;
		  /* 8219A908h */ case    1:  		/* li R8, 0 */
		/* 8219A908h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8219A908h case    1:*/		return 0x8219A90C;
		  /* 8219A90Ch */ case    2:  		/* li R7, 0 */
		/* 8219A90Ch case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219A90Ch case    2:*/		return 0x8219A910;
		  /* 8219A910h */ case    3:  		/* li R6, 117 */
		/* 8219A910h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 8219A910h case    3:*/		return 0x8219A914;
		  /* 8219A914h */ case    4:  		/* li R5, 0 */
		/* 8219A914h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219A914h case    4:*/		return 0x8219A918;
		  /* 8219A918h */ case    5:  		/* mr R4, R30 */
		/* 8219A918h case    5:*/		regs.R4 = regs.R30;
		/* 8219A918h case    5:*/		return 0x8219A91C;
		  /* 8219A91Ch */ case    6:  		/* mr R3, R21 */
		/* 8219A91Ch case    6:*/		regs.R3 = regs.R21;
		/* 8219A91Ch case    6:*/		return 0x8219A920;
		  /* 8219A920h */ case    7:  		/* bl 565368 */
		/* 8219A920h case    7:*/		regs.LR = 0x8219A924; return 0x82224998;
		/* 8219A920h case    7:*/		return 0x8219A924;
		  /* 8219A924h */ case    8:  		/* lwz R8, <#[R30 + 36]> */
		/* 8219A924h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000024) );
		/* 8219A924h case    8:*/		return 0x8219A928;
		  /* 8219A928h */ case    9:  		/* rlwinm R9, R3, 0, 0, 30 */
		/* 8219A928h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R3);
		/* 8219A928h case    9:*/		return 0x8219A92C;
		  /* 8219A92Ch */ case   10:  		/* addi R11, R30, 32 */
		/* 8219A92Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x20);
		/* 8219A92Ch case   10:*/		return 0x8219A930;
		  /* 8219A930h */ case   11:  		/* mr R4, R26 */
		/* 8219A930h case   11:*/		regs.R4 = regs.R26;
		/* 8219A930h case   11:*/		return 0x8219A934;
		  /* 8219A934h */ case   12:  		/* addi R10, R11, 4 */
		/* 8219A934h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8219A934h case   12:*/		return 0x8219A938;
		  /* 8219A938h */ case   13:  		/* addi R11, R9, 36 */
		/* 8219A938h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x24);
		/* 8219A938h case   13:*/		return 0x8219A93C;
		  /* 8219A93Ch */ case   14:  		/* stw R8, <#[R9 + 40]> */
		/* 8219A93Ch case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000028) );
		/* 8219A93Ch case   14:*/		return 0x8219A940;
		  /* 8219A940h */ case   15:  		/* ori R7, R10, 1 */
		/* 8219A940h case   15:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R10,0x1);
		/* 8219A940h case   15:*/		return 0x8219A944;
		  /* 8219A944h */ case   16:  		/* addi R10, R11, 4 */
		/* 8219A944h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8219A944h case   16:*/		return 0x8219A948;
		  /* 8219A948h */ case   17:  		/* addi R11, R11, -36 */
		/* 8219A948h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFDC);
		/* 8219A948h case   17:*/		return 0x8219A94C;
		  /* 8219A94Ch */ case   18:  		/* lwz R8, <#[R30 + 36]> */
		/* 8219A94Ch case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000024) );
		/* 8219A94Ch case   18:*/		return 0x8219A950;
		  /* 8219A950h */ case   19:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 8219A950h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 8219A950h case   19:*/		return 0x8219A954;
		  /* 8219A954h */ case   20:  		/* stw R10, <#[R8 + 36]> */
		/* 8219A954h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000024) );
		/* 8219A954h case   20:*/		return 0x8219A958;
		  /* 8219A958h */ case   21:  		/* stw R7, <#[R9 + 36]> */
		/* 8219A958h case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000024) );
		/* 8219A958h case   21:*/		return 0x8219A95C;
		  /* 8219A95Ch */ case   22:  		/* stw R11, <#[R30 + 36]> */
		/* 8219A95Ch case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 8219A95Ch case   22:*/		return 0x8219A960;
		  /* 8219A960h */ case   23:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219A960h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219A960h case   23:*/		return 0x8219A964;
		  /* 8219A964h */ case   24:  		/* oris R11, R11, 768 */
		/* 8219A964h case   24:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x300);
		/* 8219A964h case   24:*/		return 0x8219A968;
		  /* 8219A968h */ case   25:  		/* stw R11, <#[R3 + 8]> */
		/* 8219A968h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219A968h case   25:*/		return 0x8219A96C;
		  /* 8219A96Ch */ case   26:  		/* bl -141220 */
		/* 8219A96Ch case   26:*/		regs.LR = 0x8219A970; return 0x821781C8;
		/* 8219A96Ch case   26:*/		return 0x8219A970;
		  /* 8219A970h */ case   27:  		/* lwz R11, <#[R30 + 48]> */
		/* 8219A970h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8219A970h case   27:*/		return 0x8219A974;
		  /* 8219A974h */ case   28:  		/* mr R28, R3 */
		/* 8219A974h case   28:*/		regs.R28 = regs.R3;
		/* 8219A974h case   28:*/		return 0x8219A978;
		  /* 8219A978h */ case   29:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 8219A978h case   29:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A978h case   29:*/		return 0x8219A97C;
		  /* 8219A97Ch */ case   30:  		/* bc 12, CR0_EQ, 548 */
		/* 8219A97Ch case   30:*/		if ( regs.CR[0].eq ) { return 0x8219ABA0;  }
		/* 8219A97Ch case   30:*/		return 0x8219A980;
		  /* 8219A980h */ case   31:  		/* lwz R11, <#[R21 + 92]> */
		/* 8219A980h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000005C) );
		/* 8219A980h case   31:*/		return 0x8219A984;
		  /* 8219A984h */ case   32:  		/* lis R10, -32231 */
		/* 8219A984h case   32:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8219);
		/* 8219A984h case   32:*/		return 0x8219A988;
		  /* 8219A988h */ case   33:  		/* mr R6, R21 */
		/* 8219A988h case   33:*/		regs.R6 = regs.R21;
		/* 8219A988h case   33:*/		return 0x8219A98C;
		  /* 8219A98Ch */ case   34:  		/* addi R5, R10, 28352 */
		/* 8219A98Ch case   34:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x6EC0);
		/* 8219A98Ch case   34:*/		return 0x8219A990;
		  /* 8219A990h */ case   35:  		/* addi R4, R11, 1 */
		/* 8219A990h case   35:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1);
		/* 8219A990h case   35:*/		return 0x8219A994;
		  /* 8219A994h */ case   36:  		/* addi R3, R1, 88 */
		/* 8219A994h case   36:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 8219A994h case   36:*/		return 0x8219A998;
		  /* 8219A998h */ case   37:  		/* bl -18072 */
		/* 8219A998h case   37:*/		regs.LR = 0x8219A99C; return 0x82196300;
		/* 8219A998h case   37:*/		return 0x8219A99C;
		  /* 8219A99Ch */ case   38:  		/* lwz R10, <#[R1 + 88]> */
		/* 8219A99Ch case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8219A99Ch case   38:*/		return 0x8219A9A0;
		  /* 8219A9A0h */ case   39:  		/* nor R11, R10, R10 */
		/* 8219A9A0h case   39:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R10,regs.R10);
		/* 8219A9A0h case   39:*/		return 0x8219A9A4;
		  /* 8219A9A4h */ case   40:  		/* addi R9, R10, 4 */
		/* 8219A9A4h case   40:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8219A9A4h case   40:*/		return 0x8219A9A8;
		  /* 8219A9A8h */ case   41:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219A9A8h case   41:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A9A8h case   41:*/		return 0x8219A9AC;
		  /* 8219A9ACh */ case   42:  		/* lwz R11, <#[R30 + 48]> */
		/* 8219A9ACh case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 8219A9ACh case   42:*/		return 0x8219A9B0;
		  /* 8219A9B0h */ case   43:  		/* rlwinm R11, R11, 0, 13, 31 */
		/* 8219A9B0h case   43:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R11,regs.R11);
		/* 8219A9B0h case   43:*/		return 0x8219A9B4;
		  /* 8219A9B4h */ case   44:  		/* bc 4, CR0_EQ, 8 */
		/* 8219A9B4h case   44:*/		if ( !regs.CR[0].eq ) { return 0x8219A9BC;  }
		/* 8219A9B4h case   44:*/		return 0x8219A9B8;
		  /* 8219A9B8h */ case   45:  		/* addi R9, R1, 88 */
		/* 8219A9B8h case   45:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 8219A9B8h case   45:*/		return 0x8219A9BC;
	}
	return 0x8219A9BC;
} // Block from 8219A904h-8219A9BCh (46 instructions)

//////////////////////////////////////////////////////
// Block at 8219A9BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219A9BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219A9BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219A9BC);
		  /* 8219A9BCh */ case    0:  		/* addi R11, R11, 1 */
		/* 8219A9BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219A9BCh case    0:*/		return 0x8219A9C0;
		  /* 8219A9C0h */ case    1:  		/* mr R29, R18 */
		/* 8219A9C0h case    1:*/		regs.R29 = regs.R18;
		/* 8219A9C0h case    1:*/		return 0x8219A9C4;
		  /* 8219A9C4h */ case    2:  		/* rlwinm R10, R11, 29, 3, 29 */
		/* 8219A9C4h case    2:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R11);
		/* 8219A9C4h case    2:*/		return 0x8219A9C8;
		  /* 8219A9C8h */ case    3:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8219A9C8h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219A9C8h case    3:*/		return 0x8219A9CC;
		  /* 8219A9CCh */ case    4:  		/* slw R11, R19, R11 */
		/* 8219A9CCh case    4:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R19,regs.R11);
		/* 8219A9CCh case    4:*/		return 0x8219A9D0;
		  /* 8219A9D0h */ case    5:  		/* lwzx R8, <#[R10 + R9]> */
		/* 8219A9D0h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8219A9D0h case    5:*/		return 0x8219A9D4;
		  /* 8219A9D4h */ case    6:  		/* or R11, R11, R8 */
		/* 8219A9D4h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8219A9D4h case    6:*/		return 0x8219A9D8;
		  /* 8219A9D8h */ case    7:  		/* stwx R11, <#[R10 + R9]> */
		/* 8219A9D8h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8219A9D8h case    7:*/		return 0x8219A9DC;
		  /* 8219A9DCh */ case    8:  		/* lwz R31, <#[R21 + 4]> */
		/* 8219A9DCh case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R21 + 0x00000004) );
		/* 8219A9DCh case    8:*/		return 0x8219A9E0;
		  /* 8219A9E0h */ case    9:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8219A9E0h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8219A9E0h case    9:*/		return 0x8219A9E4;
		  /* 8219A9E4h */ case   10:  		/* bc 4, CR0_EQ, 444 */
		/* 8219A9E4h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8219ABA0;  }
		/* 8219A9E4h case   10:*/		return 0x8219A9E8;
		  /* 8219A9E8h */ case   11:  		/* cmplwi CR0, R31, 0 */
		/* 8219A9E8h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 8219A9E8h case   11:*/		return 0x8219A9EC;
		  /* 8219A9ECh */ case   12:  		/* bc 12, CR0_EQ, 436 */
		/* 8219A9ECh case   12:*/		if ( regs.CR[0].eq ) { return 0x8219ABA0;  }
		/* 8219A9ECh case   12:*/		return 0x8219A9F0;
		  /* 8219A9F0h */ case   13:  		/* lwz R11, <#[R31 + 76]> */
		/* 8219A9F0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8219A9F0h case   13:*/		return 0x8219A9F4;
		  /* 8219A9F4h */ case   14:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 8219A9F4h case   14:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 8219A9F4h case   14:*/		return 0x8219A9F8;
		  /* 8219A9F8h */ case   15:  		/* bc 12, CR0_EQ, 400 */
		/* 8219A9F8h case   15:*/		if ( regs.CR[0].eq ) { return 0x8219AB88;  }
		/* 8219A9F8h case   15:*/		return 0x8219A9FC;
		  /* 8219A9FCh */ case   16:  		/* mr R3, R31 */
		/* 8219A9FCh case   16:*/		regs.R3 = regs.R31;
		/* 8219A9FCh case   16:*/		return 0x8219AA00;
		  /* 8219AA00h */ case   17:  		/* bl -222896 */
		/* 8219AA00h case   17:*/		regs.LR = 0x8219AA04; return 0x82164350;
		/* 8219AA00h case   17:*/		return 0x8219AA04;
		  /* 8219AA04h */ case   18:  		/* lwz R8, <#[R1 + 88]> */
		/* 8219AA04h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000058) );
		/* 8219AA04h case   18:*/		return 0x8219AA08;
		  /* 8219AA08h */ case   19:  		/* lwz R11, <#[R3 + 48]> */
		/* 8219AA08h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 8219AA08h case   19:*/		return 0x8219AA0C;
		  /* 8219AA0Ch */ case   20:  		/* nor R10, R8, R8 */
		/* 8219AA0Ch case   20:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R8,regs.R8);
		/* 8219AA0Ch case   20:*/		return 0x8219AA10;
		  /* 8219AA10h */ case   21:  		/* rlwinm R11, R11, 0, 13, 31 */
		/* 8219AA10h case   21:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R11,regs.R11);
		/* 8219AA10h case   21:*/		return 0x8219AA14;
		  /* 8219AA14h */ case   22:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 8219AA14h case   22:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 8219AA14h case   22:*/		return 0x8219AA18;
		  /* 8219AA18h */ case   23:  		/* addi R10, R8, 4 */
		/* 8219AA18h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0x4);
		/* 8219AA18h case   23:*/		return 0x8219AA1C;
		  /* 8219AA1Ch */ case   24:  		/* bc 4, CR0_EQ, 8 */
		/* 8219AA1Ch case   24:*/		if ( !regs.CR[0].eq ) { return 0x8219AA24;  }
		/* 8219AA1Ch case   24:*/		return 0x8219AA20;
		  /* 8219AA20h */ case   25:  		/* addi R10, R1, 88 */
		/* 8219AA20h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x58);
		/* 8219AA20h case   25:*/		return 0x8219AA24;
	}
	return 0x8219AA24;
} // Block from 8219A9BCh-8219AA24h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8219AA24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AA24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AA24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AA24);
		  /* 8219AA24h */ case    0:  		/* addi R11, R11, 1 */
		/* 8219AA24h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219AA24h case    0:*/		return 0x8219AA28;
		  /* 8219AA28h */ case    1:  		/* rlwinm R7, R11, 29, 3, 29 */
		/* 8219AA28h case    1:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R7,regs.R11);
		/* 8219AA28h case    1:*/		return 0x8219AA2C;
		  /* 8219AA2Ch */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8219AA2Ch case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219AA2Ch case    2:*/		return 0x8219AA30;
		  /* 8219AA30h */ case    3:  		/* lwzx R10, <#[R7 + R10]> */
		/* 8219AA30h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8219AA30h case    3:*/		return 0x8219AA34;
		  /* 8219AA34h */ case    4:  		/* srw R11, R10, R11 */
		/* 8219AA34h case    4:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219AA34h case    4:*/		return 0x8219AA38;
		  /* 8219AA38h */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219AA38h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219AA38h case    5:*/		return 0x8219AA3C;
		  /* 8219AA3Ch */ case    6:  		/* bc 12, CR0_EQ, 332 */
		/* 8219AA3Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x8219AB88;  }
		/* 8219AA3Ch case    6:*/		return 0x8219AA40;
		  /* 8219AA40h */ case    7:  		/* lwz R11, <#[R31 + 48]> */
		/* 8219AA40h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 8219AA40h case    7:*/		return 0x8219AA44;
		  /* 8219AA44h */ case    8:  		/* cmplwi CR6, R9, 0 */
		/* 8219AA44h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8219AA44h case    8:*/		return 0x8219AA48;
		  /* 8219AA48h */ case    9:  		/* addi R9, R8, 4 */
		/* 8219AA48h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0x4);
		/* 8219AA48h case    9:*/		return 0x8219AA4C;
		  /* 8219AA4Ch */ case   10:  		/* rlwinm R11, R11, 0, 13, 31 */
		/* 8219AA4Ch case   10:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R11,regs.R11);
		/* 8219AA4Ch case   10:*/		return 0x8219AA50;
		  /* 8219AA50h */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 8219AA50h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8219AA58;  }
		/* 8219AA50h case   11:*/		return 0x8219AA54;
		  /* 8219AA54h */ case   12:  		/* addi R9, R1, 88 */
		/* 8219AA54h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 8219AA54h case   12:*/		return 0x8219AA58;
	}
	return 0x8219AA58;
} // Block from 8219AA24h-8219AA58h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219AA58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AA58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AA58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AA58);
		  /* 8219AA58h */ case    0:  		/* addi R11, R11, 1 */
		/* 8219AA58h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219AA58h case    0:*/		return 0x8219AA5C;
		  /* 8219AA5Ch */ case    1:  		/* rlwinm R10, R11, 29, 3, 29 */
		/* 8219AA5Ch case    1:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R11);
		/* 8219AA5Ch case    1:*/		return 0x8219AA60;
		  /* 8219AA60h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8219AA60h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219AA60h case    2:*/		return 0x8219AA64;
		  /* 8219AA64h */ case    3:  		/* slw R11, R19, R11 */
		/* 8219AA64h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R19,regs.R11);
		/* 8219AA64h case    3:*/		return 0x8219AA68;
		  /* 8219AA68h */ case    4:  		/* lwzx R8, <#[R10 + R9]> */
		/* 8219AA68h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8219AA68h case    4:*/		return 0x8219AA6C;
		  /* 8219AA6Ch */ case    5:  		/* or R11, R11, R8 */
		/* 8219AA6Ch case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8219AA6Ch case    5:*/		return 0x8219AA70;
		  /* 8219AA70h */ case    6:  		/* stwx R11, <#[R10 + R9]> */
		/* 8219AA70h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 8219AA70h case    6:*/		return 0x8219AA74;
		  /* 8219AA74h */ case    7:  		/* lwz R10, <#[R27 + 8]> */
		/* 8219AA74h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 8219AA74h case    7:*/		return 0x8219AA78;
		  /* 8219AA78h */ case    8:  		/* lwz R11, <#[R31 + 76]> */
		/* 8219AA78h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8219AA78h case    8:*/		return 0x8219AA7C;
		  /* 8219AA7Ch */ case    9:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 8219AA7Ch case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 8219AA7Ch case    9:*/		return 0x8219AA80;
		  /* 8219AA80h */ case   10:  		/* rlwinm R9, R11, 9, 31, 31 */
		/* 8219AA80h case   10:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R9,regs.R11);
		/* 8219AA80h case   10:*/		return 0x8219AA84;
		  /* 8219AA84h */ case   11:  		/* cmplwi CR6, R10, 59 */
		/* 8219AA84h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000003B);
		/* 8219AA84h case   11:*/		return 0x8219AA88;
		  /* 8219AA88h */ case   12:  		/* bc 12, CR6_EQ, 12 */
		/* 8219AA88h case   12:*/		if ( regs.CR[6].eq ) { return 0x8219AA94;  }
		/* 8219AA88h case   12:*/		return 0x8219AA8C;
		  /* 8219AA8Ch */ case   13:  		/* cmplwi CR6, R10, 21 */
		/* 8219AA8Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000015);
		/* 8219AA8Ch case   13:*/		return 0x8219AA90;
		  /* 8219AA90h */ case   14:  		/* bc 4, CR6_EQ, 16 */
		/* 8219AA90h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8219AAA0;  }
		/* 8219AA90h case   14:*/		return 0x8219AA94;
	}
	return 0x8219AA94;
} // Block from 8219AA58h-8219AA94h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219AA94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AA94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AA94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AA94);
		  /* 8219AA94h */ case    0:  		/* rlwinm R10, R9, 0, 24, 31 */
		/* 8219AA94h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R9);
		/* 8219AA94h case    0:*/		return 0x8219AA98;
		  /* 8219AA98h */ case    1:  		/* cntlzw R10, R10 */
		/* 8219AA98h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8219AA98h case    1:*/		return 0x8219AA9C;
		  /* 8219AA9Ch */ case    2:  		/* rlwinm R9, R10, 27, 31, 31 */
		/* 8219AA9Ch case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R9,regs.R10);
		/* 8219AA9Ch case    2:*/		return 0x8219AAA0;
	}
	return 0x8219AAA0;
} // Block from 8219AA94h-8219AAA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219AAA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AAA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AAA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AAA0);
		  /* 8219AAA0h */ case    0:  		/* rlwinm. R10, R29, 0, 24, 31 */
		/* 8219AAA0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R29);
		/* 8219AAA0h case    0:*/		return 0x8219AAA4;
		  /* 8219AAA4h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219AAA4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219AAB4;  }
		/* 8219AAA4h case    1:*/		return 0x8219AAA8;
		  /* 8219AAA8h */ case    2:  		/* rlwinm R10, R9, 0, 24, 31 */
		/* 8219AAA8h case    2:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R9);
		/* 8219AAA8h case    2:*/		return 0x8219AAAC;
		  /* 8219AAACh */ case    3:  		/* cntlzw R10, R10 */
		/* 8219AAACh case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8219AAACh case    3:*/		return 0x8219AAB0;
		  /* 8219AAB0h */ case    4:  		/* rlwinm R9, R10, 27, 31, 31 */
		/* 8219AAB0h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R9,regs.R10);
		/* 8219AAB0h case    4:*/		return 0x8219AAB4;
	}
	return 0x8219AAB4;
} // Block from 8219AAA0h-8219AAB4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219AAB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AAB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AAB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AAB4);
		  /* 8219AAB4h */ case    0:  		/* lwz R10, <#[R31 + 48]> */
		/* 8219AAB4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 8219AAB4h case    0:*/		return 0x8219AAB8;
		  /* 8219AAB8h */ case    1:  		/* rlwinm. R8, R10, 8, 31, 31 */
		/* 8219AAB8h case    1:*/		cpu::op::rlwinm<1,8,31,31>(regs,&regs.R8,regs.R10);
		/* 8219AAB8h case    1:*/		return 0x8219AABC;
		  /* 8219AABCh */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 8219AABCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x8219AAC8;  }
		/* 8219AABCh case    2:*/		return 0x8219AAC0;
		  /* 8219AAC0h */ case    3:  		/* oris R10, R10, 256 */
		/* 8219AAC0h case    3:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x100);
		/* 8219AAC0h case    3:*/		return 0x8219AAC4;
		  /* 8219AAC4h */ case    4:  		/* stw R10, <#[R31 + 48]> */
		/* 8219AAC4h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 8219AAC4h case    4:*/		return 0x8219AAC8;
	}
	return 0x8219AAC8;
} // Block from 8219AAB4h-8219AAC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219AAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AAC8);
		  /* 8219AAC8h */ case    0:  		/* rlwinm R10, R9, 0, 24, 31 */
		/* 8219AAC8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R9);
		/* 8219AAC8h case    0:*/		return 0x8219AACC;
		  /* 8219AACCh */ case    1:  		/* lwz R9, <#[R31 + 48]> */
		/* 8219AACCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000030) );
		/* 8219AACCh case    1:*/		return 0x8219AAD0;
		  /* 8219AAD0h */ case    2:  		/* stw R30, <#[R31 + 108]> */
		/* 8219AAD0h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000006C) );
		/* 8219AAD0h case    2:*/		return 0x8219AAD4;
		  /* 8219AAD4h */ case    3:  		/* mr R3, R31 */
		/* 8219AAD4h case    3:*/		regs.R3 = regs.R31;
		/* 8219AAD4h case    3:*/		return 0x8219AAD8;
		  /* 8219AAD8h */ case    4:  		/* rlwimi R11, R10, 25, 6, 6 */
		/* 8219AAD8h case    4:*/		cpu::op::rlwimi<0,25,6,6>(regs,&regs.R11,regs.R10);
		/* 8219AAD8h case    4:*/		return 0x8219AADC;
		  /* 8219AADCh */ case    5:  		/* stw R28, <#[R31 + 72]> */
		/* 8219AADCh case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000048) );
		/* 8219AADCh case    5:*/		return 0x8219AAE0;
		  /* 8219AAE0h */ case    6:  		/* oris R10, R9, 384 */
		/* 8219AAE0h case    6:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R9,0x180);
		/* 8219AAE0h case    6:*/		return 0x8219AAE4;
		  /* 8219AAE4h */ case    7:  		/* oris R11, R11, 256 */
		/* 8219AAE4h case    7:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 8219AAE4h case    7:*/		return 0x8219AAE8;
		  /* 8219AAE8h */ case    8:  		/* stw R10, <#[R31 + 48]> */
		/* 8219AAE8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 8219AAE8h case    8:*/		return 0x8219AAEC;
		  /* 8219AAECh */ case    9:  		/* stw R11, <#[R31 + 76]> */
		/* 8219AAECh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8219AAECh case    9:*/		return 0x8219AAF0;
		  /* 8219AAF0h */ case   10:  		/* bl -223136 */
		/* 8219AAF0h case   10:*/		regs.LR = 0x8219AAF4; return 0x82164350;
		/* 8219AAF0h case   10:*/		return 0x8219AAF4;
		  /* 8219AAF4h */ case   11:  		/* cmplw CR6, R3, R30 */
		/* 8219AAF4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R30);
		/* 8219AAF4h case   11:*/		return 0x8219AAF8;
		  /* 8219AAF8h */ case   12:  		/* bc 4, CR6_EQ, 144 */
		/* 8219AAF8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8219AB88;  }
		/* 8219AAF8h case   12:*/		return 0x8219AAFC;
		  /* 8219AAFCh */ case   13:  		/* lwz R11, <#[R30 + 76]> */
		/* 8219AAFCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 8219AAFCh case   13:*/		return 0x8219AB00;
		  /* 8219AB00h */ case   14:  		/* rlwinm. R10, R11, 10, 31, 31 */
		/* 8219AB00h case   14:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R11);
		/* 8219AB00h case   14:*/		return 0x8219AB04;
		  /* 8219AB04h */ case   15:  		/* bc 12, CR0_EQ, 48 */
		/* 8219AB04h case   15:*/		if ( regs.CR[0].eq ) { return 0x8219AB34;  }
		/* 8219AB04h case   15:*/		return 0x8219AB08;
		  /* 8219AB08h */ case   16:  		/* mr R3, R30 */
		/* 8219AB08h case   16:*/		regs.R3 = regs.R30;
		/* 8219AB08h case   16:*/		return 0x8219AB0C;
		  /* 8219AB0Ch */ case   17:  		/* rlwinm R22, R11, 9, 31, 31 */
		/* 8219AB0Ch case   17:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R22,regs.R11);
		/* 8219AB0Ch case   17:*/		return 0x8219AB10;
		  /* 8219AB10h */ case   18:  		/* bl -223168 */
		/* 8219AB10h case   18:*/		regs.LR = 0x8219AB14; return 0x82164350;
		/* 8219AB10h case   18:*/		return 0x8219AB14;
		  /* 8219AB14h */ case   19:  		/* lwz R10, <#[R31 + 48]> */
		/* 8219AB14h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 8219AB14h case   19:*/		return 0x8219AB18;
		  /* 8219AB18h */ case   20:  		/* lwz R11, <#[R31 + 76]> */
		/* 8219AB18h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8219AB18h case   20:*/		return 0x8219AB1C;
		  /* 8219AB1Ch */ case   21:  		/* oris R10, R10, 128 */
		/* 8219AB1Ch case   21:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x80);
		/* 8219AB1Ch case   21:*/		return 0x8219AB20;
		  /* 8219AB20h */ case   22:  		/* stw R3, <#[R31 + 112]> */
		/* 8219AB20h case   22:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000070) );
		/* 8219AB20h case   22:*/		return 0x8219AB24;
		  /* 8219AB24h */ case   23:  		/* rlwimi R11, R22, 23, 8, 8 */
		/* 8219AB24h case   23:*/		cpu::op::rlwimi<0,23,8,8>(regs,&regs.R11,regs.R22);
		/* 8219AB24h case   23:*/		return 0x8219AB28;
		  /* 8219AB28h */ case   24:  		/* stw R10, <#[R31 + 48]> */
		/* 8219AB28h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 8219AB28h case   24:*/		return 0x8219AB2C;
		  /* 8219AB2Ch */ case   25:  		/* oris R11, R11, 64 */
		/* 8219AB2Ch case   25:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x40);
		/* 8219AB2Ch case   25:*/		return 0x8219AB30;
		  /* 8219AB30h */ case   26:  		/* b 12 */
		/* 8219AB30h case   26:*/		return 0x8219AB3C;
		/* 8219AB30h case   26:*/		return 0x8219AB34;
	}
	return 0x8219AB34;
} // Block from 8219AAC8h-8219AB34h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8219AB34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AB34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AB34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AB34);
		  /* 8219AB34h */ case    0:  		/* lwz R11, <#[R31 + 76]> */
		/* 8219AB34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8219AB34h case    0:*/		return 0x8219AB38;
		  /* 8219AB38h */ case    1:  		/* rlwinm R11, R11, 0, 10, 8 */
		/* 8219AB38h case    1:*/		cpu::op::rlwinm<0,0,10,8>(regs,&regs.R11,regs.R11);
		/* 8219AB38h case    1:*/		return 0x8219AB3C;
	}
	return 0x8219AB3C;
} // Block from 8219AB34h-8219AB3Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219AB3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AB3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AB3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AB3C);
		  /* 8219AB3Ch */ case    0:  		/* stw R11, <#[R31 + 76]> */
		/* 8219AB3Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 8219AB3Ch case    0:*/		return 0x8219AB40;
		  /* 8219AB40h */ case    1:  		/* lwz R11, <#[R27 + 8]> */
		/* 8219AB40h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219AB40h case    1:*/		return 0x8219AB44;
		  /* 8219AB44h */ case    2:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219AB44h case    2:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219AB44h case    2:*/		return 0x8219AB48;
		  /* 8219AB48h */ case    3:  		/* cmplwi CR6, R11, 21 */
		/* 8219AB48h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 8219AB48h case    3:*/		return 0x8219AB4C;
		  /* 8219AB4Ch */ case    4:  		/* bc 12, CR6_LT, 16 */
		/* 8219AB4Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8219AB5C;  }
		/* 8219AB4Ch case    4:*/		return 0x8219AB50;
		  /* 8219AB50h */ case    5:  		/* cmplwi CR6, R11, 24 */
		/* 8219AB50h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 8219AB50h case    5:*/		return 0x8219AB54;
		  /* 8219AB54h */ case    6:  		/* mr R11, R19 */
		/* 8219AB54h case    6:*/		regs.R11 = regs.R19;
		/* 8219AB54h case    6:*/		return 0x8219AB58;
		  /* 8219AB58h */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 8219AB58h case    7:*/		if ( !regs.CR[6].gt ) { return 0x8219AB60;  }
		/* 8219AB58h case    7:*/		return 0x8219AB5C;
	}
	return 0x8219AB5C;
} // Block from 8219AB3Ch-8219AB5Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219AB5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AB5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AB5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AB5C);
		  /* 8219AB5Ch */ case    0:  		/* mr R11, R18 */
		/* 8219AB5Ch case    0:*/		regs.R11 = regs.R18;
		/* 8219AB5Ch case    0:*/		return 0x8219AB60;
	}
	return 0x8219AB60;
} // Block from 8219AB5Ch-8219AB60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219AB60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AB60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AB60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AB60);
		  /* 8219AB60h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219AB60h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219AB60h case    0:*/		return 0x8219AB64;
		  /* 8219AB64h */ case    1:  		/* bc 12, CR0_EQ, 36 */
		/* 8219AB64h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219AB88;  }
		/* 8219AB64h case    1:*/		return 0x8219AB68;
		  /* 8219AB68h */ case    2:  		/* lwz R11, <#[R31 + 96]> */
		/* 8219AB68h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000060) );
		/* 8219AB68h case    2:*/		return 0x8219AB6C;
		  /* 8219AB6Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8219AB6Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219AB6Ch case    3:*/		return 0x8219AB70;
		  /* 8219AB70h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 8219AB70h case    4:*/		if ( regs.CR[6].eq ) { return 0x8219AB88;  }
		/* 8219AB70h case    4:*/		return 0x8219AB74;
		  /* 8219AB74h */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219AB74h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219AB74h case    5:*/		return 0x8219AB78;
		  /* 8219AB78h */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219AB78h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219AB78h case    6:*/		return 0x8219AB7C;
		  /* 8219AB7Ch */ case    7:  		/* cmplwi CR6, R11, 8064 */
		/* 8219AB7Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001F80);
		/* 8219AB7Ch case    7:*/		return 0x8219AB80;
		  /* 8219AB80h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 8219AB80h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8219AB88;  }
		/* 8219AB80h case    8:*/		return 0x8219AB84;
		  /* 8219AB84h */ case    9:  		/* mr R29, R19 */
		/* 8219AB84h case    9:*/		regs.R29 = regs.R19;
		/* 8219AB84h case    9:*/		return 0x8219AB88;
	}
	return 0x8219AB88;
} // Block from 8219AB60h-8219AB88h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219AB88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AB88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AB88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AB88);
		  /* 8219AB88h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 8219AB88h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 8219AB88h case    0:*/		return 0x8219AB8C;
		  /* 8219AB8Ch */ case    1:  		/* lwz R31, <#[R11 + 4]> */
		/* 8219AB8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 8219AB8Ch case    1:*/		return 0x8219AB90;
		  /* 8219AB90h */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 8219AB90h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 8219AB90h case    2:*/		return 0x8219AB94;
		  /* 8219AB94h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 8219AB94h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219ABA0;  }
		/* 8219AB94h case    3:*/		return 0x8219AB98;
		  /* 8219AB98h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 8219AB98h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219AB98h case    4:*/		return 0x8219AB9C;
		  /* 8219AB9Ch */ case    5:  		/* bc 4, CR6_EQ, -428 */
		/* 8219AB9Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219A9F0;  }
		/* 8219AB9Ch case    5:*/		return 0x8219ABA0;
	}
	return 0x8219ABA0;
} // Block from 8219AB88h-8219ABA0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219ABA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ABA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ABA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ABA0);
		  /* 8219ABA0h */ case    0:  		/* addi R28, R27, 4 */
		/* 8219ABA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R27,0x4);
		/* 8219ABA0h case    0:*/		return 0x8219ABA4;
		  /* 8219ABA4h */ case    1:  		/* lwz R29, <#[R28]> */
		/* 8219ABA4h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x00000000) );
		/* 8219ABA4h case    1:*/		return 0x8219ABA8;
		  /* 8219ABA8h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 8219ABA8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8219ABA8h case    2:*/		return 0x8219ABAC;
		  /* 8219ABACh */ case    3:  		/* bc 12, CR6_EQ, 232 */
		/* 8219ABACh case    3:*/		if ( regs.CR[6].eq ) { return 0x8219AC94;  }
		/* 8219ABACh case    3:*/		return 0x8219ABB0;
		  /* 8219ABB0h */ case    4:  		/* lwz R31, <#[R29 + 16]> */
		/* 8219ABB0h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000010) );
		/* 8219ABB0h case    4:*/		return 0x8219ABB4;
		  /* 8219ABB4h */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 8219ABB4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219ABB4h case    5:*/		return 0x8219ABB8;
		  /* 8219ABB8h */ case    6:  		/* bc 12, CR6_EQ, 116 */
		/* 8219ABB8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219AC2C;  }
		/* 8219ABB8h case    6:*/		return 0x8219ABBC;
		  /* 8219ABBCh */ case    7:  		/* lwz R11, <#[R29]> */
		/* 8219ABBCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8219ABBCh case    7:*/		return 0x8219ABC0;
		  /* 8219ABC0h */ case    8:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8219ABC0h case    8:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8219ABC0h case    8:*/		return 0x8219ABC4;
		  /* 8219ABC4h */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 8219ABC4h case    9:*/		if ( regs.CR[0].eq ) { return 0x8219ABD4;  }
		/* 8219ABC4h case    9:*/		return 0x8219ABC8;
		  /* 8219ABC8h */ case   10:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 8219ABC8h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8219ABC8h case   10:*/		return 0x8219ABCC;
		  /* 8219ABCCh */ case   11:  		/* mr R11, R19 */
		/* 8219ABCCh case   11:*/		regs.R11 = regs.R19;
		/* 8219ABCCh case   11:*/		return 0x8219ABD0;
		  /* 8219ABD0h */ case   12:  		/* bc 12, CR0_EQ, 8 */
		/* 8219ABD0h case   12:*/		if ( regs.CR[0].eq ) { return 0x8219ABD8;  }
		/* 8219ABD0h case   12:*/		return 0x8219ABD4;
	}
	return 0x8219ABD4;
} // Block from 8219ABA0h-8219ABD4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219ABD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ABD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ABD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ABD4);
		  /* 8219ABD4h */ case    0:  		/* mr R11, R18 */
		/* 8219ABD4h case    0:*/		regs.R11 = regs.R18;
		/* 8219ABD4h case    0:*/		return 0x8219ABD8;
	}
	return 0x8219ABD8;
} // Block from 8219ABD4h-8219ABD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219ABD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ABD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ABD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ABD8);
		  /* 8219ABD8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219ABD8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219ABD8h case    0:*/		return 0x8219ABDC;
		  /* 8219ABDCh */ case    1:  		/* bc 12, CR0_EQ, 100 */
		/* 8219ABDCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8219AC40;  }
		/* 8219ABDCh case    1:*/		return 0x8219ABE0;
		  /* 8219ABE0h */ case    2:  		/* lwz R11, <#[R27 + 8]> */
		/* 8219ABE0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219ABE0h case    2:*/		return 0x8219ABE4;
		  /* 8219ABE4h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219ABE4h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219ABE4h case    3:*/		return 0x8219ABE8;
		  /* 8219ABE8h */ case    4:  		/* cmplwi CR6, R11, 7552 */
		/* 8219ABE8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001D80);
		/* 8219ABE8h case    4:*/		return 0x8219ABEC;
		  /* 8219ABECh */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 8219ABECh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219AC00;  }
		/* 8219ABECh case    5:*/		return 0x8219ABF0;
		  /* 8219ABF0h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219ABF0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219ABF0h case    6:*/		return 0x8219ABF4;
		  /* 8219ABF4h */ case    7:  		/* nor R10, R11, R11 */
		/* 8219ABF4h case    7:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 8219ABF4h case    7:*/		return 0x8219ABF8;
		  /* 8219ABF8h */ case    8:  		/* rlwimi R10, R11, 0, 14, 12 */
		/* 8219ABF8h case    8:*/		cpu::op::rlwimi<0,0,14,12>(regs,&regs.R10,regs.R11);
		/* 8219ABF8h case    8:*/		return 0x8219ABFC;
		  /* 8219ABFCh */ case    9:  		/* stw R10, <#[R31 + 8]> */
		/* 8219ABFCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219ABFCh case    9:*/		return 0x8219AC00;
	}
	return 0x8219AC00;
} // Block from 8219ABD8h-8219AC00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219AC00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AC00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AC00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AC00);
		  /* 8219AC00h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219AC00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219AC00h case    0:*/		return 0x8219AC04;
		  /* 8219AC04h */ case    1:  		/* mr R4, R24 */
		/* 8219AC04h case    1:*/		regs.R4 = regs.R24;
		/* 8219AC04h case    1:*/		return 0x8219AC08;
		  /* 8219AC08h */ case    2:  		/* mr R3, R21 */
		/* 8219AC08h case    2:*/		regs.R3 = regs.R21;
		/* 8219AC08h case    2:*/		return 0x8219AC0C;
		  /* 8219AC0Ch */ case    3:  		/* rlwinm R11, R11, 0, 15, 13 */
		/* 8219AC0Ch case    3:*/		cpu::op::rlwinm<0,0,15,13>(regs,&regs.R11,regs.R11);
		/* 8219AC0Ch case    3:*/		return 0x8219AC10;
		  /* 8219AC10h */ case    4:  		/* stw R11, <#[R31 + 8]> */
		/* 8219AC10h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219AC10h case    4:*/		return 0x8219AC14;
		  /* 8219AC14h */ case    5:  		/* bl -142356 */
		/* 8219AC14h case    5:*/		regs.LR = 0x8219AC18; return 0x82178000;
		/* 8219AC14h case    5:*/		return 0x8219AC18;
		  /* 8219AC18h */ case    6:  		/* mr R5, R3 */
		/* 8219AC18h case    6:*/		regs.R5 = regs.R3;
		/* 8219AC18h case    6:*/		return 0x8219AC1C;
		  /* 8219AC1Ch */ case    7:  		/* li R4, 0 */
		/* 8219AC1Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8219AC1Ch case    7:*/		return 0x8219AC20;
		  /* 8219AC20h */ case    8:  		/* mr R3, R31 */
		/* 8219AC20h case    8:*/		regs.R3 = regs.R31;
		/* 8219AC20h case    8:*/		return 0x8219AC24;
		  /* 8219AC24h */ case    9:  		/* mr R6, R21 */
		/* 8219AC24h case    9:*/		regs.R6 = regs.R21;
		/* 8219AC24h case    9:*/		return 0x8219AC28;
		  /* 8219AC28h */ case   10:  		/* bl -134704 */
		/* 8219AC28h case   10:*/		regs.LR = 0x8219AC2C; return 0x82179DF8;
		/* 8219AC28h case   10:*/		return 0x8219AC2C;
	}
	return 0x8219AC2C;
} // Block from 8219AC00h-8219AC2Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219AC2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AC2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AC2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AC2C);
		  /* 8219AC2Ch */ case    0:  		/* lwz R11, <#[R28]> */
		/* 8219AC2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8219AC2Ch case    0:*/		return 0x8219AC30;
		  /* 8219AC30h */ case    1:  		/* cmplw CR6, R11, R29 */
		/* 8219AC30h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 8219AC30h case    1:*/		return 0x8219AC34;
		  /* 8219AC34h */ case    2:  		/* bc 4, CR6_EQ, -144 */
		/* 8219AC34h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8219ABA4;  }
		/* 8219AC34h case    2:*/		return 0x8219AC38;
		  /* 8219AC38h */ case    3:  		/* addi R28, R29, 8 */
		/* 8219AC38h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R29,0x8);
		/* 8219AC38h case    3:*/		return 0x8219AC3C;
		  /* 8219AC3Ch */ case    4:  		/* b -152 */
		/* 8219AC3Ch case    4:*/		return 0x8219ABA4;
		/* 8219AC3Ch case    4:*/		return 0x8219AC40;
	}
	return 0x8219AC40;
} // Block from 8219AC2Ch-8219AC40h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219AC40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AC40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AC40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AC40);
		  /* 8219AC40h */ case    0:  		/* addi R30, R31, 4 */
		/* 8219AC40h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x4);
		/* 8219AC40h case    0:*/		return 0x8219AC44;
		  /* 8219AC44h */ case    1:  		/* lwz R31, <#[R30]> */
		/* 8219AC44h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 8219AC44h case    1:*/		return 0x8219AC48;
		  /* 8219AC48h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 8219AC48h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219AC48h case    2:*/		return 0x8219AC4C;
		  /* 8219AC4Ch */ case    3:  		/* bc 12, CR6_EQ, -32 */
		/* 8219AC4Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8219AC2C;  }
		/* 8219AC4Ch case    3:*/		return 0x8219AC50;
		  /* 8219AC50h */ case    4:  		/* lwz R4, <#[R31 + 16]> */
		/* 8219AC50h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 8219AC50h case    4:*/		return 0x8219AC54;
		  /* 8219AC54h */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 8219AC54h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8219AC54h case    5:*/		return 0x8219AC58;
		  /* 8219AC58h */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 8219AC58h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219AC80;  }
		/* 8219AC58h case    6:*/		return 0x8219AC5C;
		  /* 8219AC5Ch */ case    7:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219AC5Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219AC5Ch case    7:*/		return 0x8219AC60;
		  /* 8219AC60h */ case    8:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219AC60h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219AC60h case    8:*/		return 0x8219AC64;
		  /* 8219AC64h */ case    9:  		/* cmplwi CR6, R11, 64 */
		/* 8219AC64h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000040);
		/* 8219AC64h case    9:*/		return 0x8219AC68;
		  /* 8219AC68h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 8219AC68h case   10:*/		if ( regs.CR[6].eq ) { return 0x8219AC74;  }
		/* 8219AC68h case   10:*/		return 0x8219AC6C;
		  /* 8219AC6Ch */ case   11:  		/* cmplwi CR6, R11, 63 */
		/* 8219AC6Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003F);
		/* 8219AC6Ch case   11:*/		return 0x8219AC70;
		  /* 8219AC70h */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 8219AC70h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8219AC80;  }
		/* 8219AC70h case   12:*/		return 0x8219AC74;
	}
	return 0x8219AC74;
} // Block from 8219AC40h-8219AC74h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219AC74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AC74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AC74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AC74);
		  /* 8219AC74h */ case    0:  		/* li R5, 1 */
		/* 8219AC74h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8219AC74h case    0:*/		return 0x8219AC78;
		  /* 8219AC78h */ case    1:  		/* mr R3, R21 */
		/* 8219AC78h case    1:*/		regs.R3 = regs.R21;
		/* 8219AC78h case    1:*/		return 0x8219AC7C;
		  /* 8219AC7Ch */ case    2:  		/* bl -141260 */
		/* 8219AC7Ch case    2:*/		regs.LR = 0x8219AC80; return 0x821784B0;
		/* 8219AC7Ch case    2:*/		return 0x8219AC80;
	}
	return 0x8219AC80;
} // Block from 8219AC74h-8219AC80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219AC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AC80);
		  /* 8219AC80h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8219AC80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8219AC80h case    0:*/		return 0x8219AC84;
		  /* 8219AC84h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 8219AC84h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8219AC84h case    1:*/		return 0x8219AC88;
		  /* 8219AC88h */ case    2:  		/* bc 4, CR6_EQ, -68 */
		/* 8219AC88h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8219AC44;  }
		/* 8219AC88h case    2:*/		return 0x8219AC8C;
		  /* 8219AC8Ch */ case    3:  		/* addi R30, R31, 8 */
		/* 8219AC8Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x8);
		/* 8219AC8Ch case    3:*/		return 0x8219AC90;
		  /* 8219AC90h */ case    4:  		/* b -76 */
		/* 8219AC90h case    4:*/		return 0x8219AC44;
		/* 8219AC90h case    4:*/		return 0x8219AC94;
	}
	return 0x8219AC94;
} // Block from 8219AC80h-8219AC94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219AC94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AC94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AC94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AC94);
		  /* 8219AC94h */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 8219AC94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219AC94h case    0:*/		return 0x8219AC98;
		  /* 8219AC98h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219AC98h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219AC98h case    1:*/		return 0x8219AC9C;
		  /* 8219AC9Ch */ case    2:  		/* cmplwi CR6, R11, 21 */
		/* 8219AC9Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000015);
		/* 8219AC9Ch case    2:*/		return 0x8219ACA0;
		  /* 8219ACA0h */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 8219ACA0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8219ACB0;  }
		/* 8219ACA0h case    3:*/		return 0x8219ACA4;
		  /* 8219ACA4h */ case    4:  		/* cmplwi CR6, R11, 24 */
		/* 8219ACA4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 8219ACA4h case    4:*/		return 0x8219ACA8;
		  /* 8219ACA8h */ case    5:  		/* mr R11, R19 */
		/* 8219ACA8h case    5:*/		regs.R11 = regs.R19;
		/* 8219ACA8h case    5:*/		return 0x8219ACAC;
		  /* 8219ACACh */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 8219ACACh case    6:*/		if ( !regs.CR[6].gt ) { return 0x8219ACB4;  }
		/* 8219ACACh case    6:*/		return 0x8219ACB0;
	}
	return 0x8219ACB0;
} // Block from 8219AC94h-8219ACB0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219ACB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ACB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ACB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ACB0);
		  /* 8219ACB0h */ case    0:  		/* mr R11, R18 */
		/* 8219ACB0h case    0:*/		regs.R11 = regs.R18;
		/* 8219ACB0h case    0:*/		return 0x8219ACB4;
	}
	return 0x8219ACB4;
} // Block from 8219ACB0h-8219ACB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219ACB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ACB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ACB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ACB4);
		  /* 8219ACB4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219ACB4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219ACB4h case    0:*/		return 0x8219ACB8;
		  /* 8219ACB8h */ case    1:  		/* li R5, 0 */
		/* 8219ACB8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219ACB8h case    1:*/		return 0x8219ACBC;
		  /* 8219ACBCh */ case    2:  		/* mr R4, R27 */
		/* 8219ACBCh case    2:*/		regs.R4 = regs.R27;
		/* 8219ACBCh case    2:*/		return 0x8219ACC0;
		  /* 8219ACC0h */ case    3:  		/* mr R3, R21 */
		/* 8219ACC0h case    3:*/		regs.R3 = regs.R21;
		/* 8219ACC0h case    3:*/		return 0x8219ACC4;
		  /* 8219ACC4h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 8219ACC4h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219ACD0;  }
		/* 8219ACC4h case    4:*/		return 0x8219ACC8;
		  /* 8219ACC8h */ case    5:  		/* bl -141336 */
		/* 8219ACC8h case    5:*/		regs.LR = 0x8219ACCC; return 0x821784B0;
		/* 8219ACC8h case    5:*/		return 0x8219ACCC;
		  /* 8219ACCCh */ case    6:  		/* b 12 */
		/* 8219ACCCh case    6:*/		return 0x8219ACD8;
		/* 8219ACCCh case    6:*/		return 0x8219ACD0;
	}
	return 0x8219ACD0;
} // Block from 8219ACB4h-8219ACD0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219ACD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ACD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ACD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ACD0);
		  /* 8219ACD0h */ case    0:  		/* li R6, 1 */
		/* 8219ACD0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8219ACD0h case    0:*/		return 0x8219ACD4;
		  /* 8219ACD4h */ case    1:  		/* bl 591604 */
		/* 8219ACD4h case    1:*/		regs.LR = 0x8219ACD8; return 0x8222B3C8;
		/* 8219ACD4h case    1:*/		return 0x8219ACD8;
	}
	return 0x8219ACD8;
} // Block from 8219ACD0h-8219ACD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219ACD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ACD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ACD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ACD8);
		  /* 8219ACD8h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 8219ACD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8219ACD8h case    0:*/		return 0x8219ACDC;
		  /* 8219ACDCh */ case    1:  		/* cmplw CR6, R11, R26 */
		/* 8219ACDCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 8219ACDCh case    1:*/		return 0x8219ACE0;
		  /* 8219ACE0h */ case    2:  		/* bc 4, CR6_EQ, -1060 */
		/* 8219ACE0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8219A8BC;  }
		/* 8219ACE0h case    2:*/		return 0x8219ACE4;
		  /* 8219ACE4h */ case    3:  		/* addi R25, R26, 8 */
		/* 8219ACE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R26,0x8);
		/* 8219ACE4h case    3:*/		return 0x8219ACE8;
		  /* 8219ACE8h */ case    4:  		/* b -1068 */
		/* 8219ACE8h case    4:*/		return 0x8219A8BC;
		/* 8219ACE8h case    4:*/		return 0x8219ACEC;
	}
	return 0x8219ACEC;
} // Block from 8219ACD8h-8219ACECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219ACECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ACEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ACEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ACEC);
		  /* 8219ACECh */ case    0:  		/* lwz R11, <#[R23 + 4]> */
		/* 8219ACECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8219ACECh case    0:*/		return 0x8219ACF0;
		  /* 8219ACF0h */ case    1:  		/* rlwinm R11, R11, 0, 28, 24 */
		/* 8219ACF0h case    1:*/		cpu::op::rlwinm<0,0,28,24>(regs,&regs.R11,regs.R11);
		/* 8219ACF0h case    1:*/		return 0x8219ACF4;
		  /* 8219ACF4h */ case    2:  		/* stw R11, <#[R23 + 4]> */
		/* 8219ACF4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 8219ACF4h case    2:*/		return 0x8219ACF8;
	}
	return 0x8219ACF8;
} // Block from 8219ACECh-8219ACF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219ACF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ACF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ACF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ACF8);
		  /* 8219ACF8h */ case    0:  		/* rlwinm R11, R24, 0, 0, 30 */
		/* 8219ACF8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R24);
		/* 8219ACF8h case    0:*/		return 0x8219ACFC;
		  /* 8219ACFCh */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219ACFCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219ACFCh case    1:*/		return 0x8219AD00;
		  /* 8219AD00h */ case    2:  		/* b -2720 */
		/* 8219AD00h case    2:*/		return 0x8219A260;
		/* 8219AD00h case    2:*/		return 0x8219AD04;
	}
	return 0x8219AD04;
} // Block from 8219ACF8h-8219AD04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219AD04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AD04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AD04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AD04);
		  /* 8219AD04h */ case    0:  		/* lwz R11, <#[R21 + 44]> */
		/* 8219AD04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000002C) );
		/* 8219AD04h case    0:*/		return 0x8219AD08;
		  /* 8219AD08h */ case    1:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 8219AD08h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 8219AD08h case    1:*/		return 0x8219AD0C;
		  /* 8219AD0Ch */ case    2:  		/* bc 12, CR0_EQ, 800 */
		/* 8219AD0Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x8219B02C;  }
		/* 8219AD0Ch case    2:*/		return 0x8219AD10;
		  /* 8219AD10h */ case    3:  		/* lwz R11, <#[R21 + 4]> */
		/* 8219AD10h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 8219AD10h case    3:*/		return 0x8219AD14;
		  /* 8219AD14h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219AD14h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219AD14h case    4:*/		return 0x8219AD18;
		  /* 8219AD18h */ case    5:  		/* bc 4, CR0_EQ, 788 */
		/* 8219AD18h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8219B02C;  }
		/* 8219AD18h case    5:*/		return 0x8219AD1C;
		  /* 8219AD1Ch */ case    6:  		/* mr R24, R11 */
		/* 8219AD1Ch case    6:*/		regs.R24 = regs.R11;
		/* 8219AD1Ch case    6:*/		return 0x8219AD20;
		  /* 8219AD20h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 8219AD20h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8219AD20h case    7:*/		return 0x8219AD24;
		  /* 8219AD24h */ case    8:  		/* bc 12, CR0_EQ, 776 */
		/* 8219AD24h case    8:*/		if ( regs.CR[0].eq ) { return 0x8219B02C;  }
		/* 8219AD24h case    8:*/		return 0x8219AD28;
		  /* 8219AD28h */ case    9:  		/* lwz R11, <#[R24 + 28]> */
		/* 8219AD28h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000001C) );
		/* 8219AD28h case    9:*/		return 0x8219AD2C;
		  /* 8219AD2Ch */ case   10:  		/* addi R25, R24, 24 */
		/* 8219AD2Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R24,0x18);
		/* 8219AD2Ch case   10:*/		return 0x8219AD30;
		  /* 8219AD30h */ case   11:  		/* mr R26, R18 */
		/* 8219AD30h case   11:*/		regs.R26 = regs.R18;
		/* 8219AD30h case   11:*/		return 0x8219AD34;
		  /* 8219AD34h */ case   12:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219AD34h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219AD34h case   12:*/		return 0x8219AD38;
		  /* 8219AD38h */ case   13:  		/* bc 4, CR0_EQ, 728 */
		/* 8219AD38h case   13:*/		if ( !regs.CR[0].eq ) { return 0x8219B010;  }
		/* 8219AD38h case   13:*/		return 0x8219AD3C;
		  /* 8219AD3Ch */ case   14:  		/* mr R29, R11 */
		/* 8219AD3Ch case   14:*/		regs.R29 = regs.R11;
		/* 8219AD3Ch case   14:*/		return 0x8219AD40;
		  /* 8219AD40h */ case   15:  		/* cmplwi CR0, R11, 0 */
		/* 8219AD40h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8219AD40h case   15:*/		return 0x8219AD44;
		  /* 8219AD44h */ case   16:  		/* bc 12, CR0_EQ, 716 */
		/* 8219AD44h case   16:*/		if ( regs.CR[0].eq ) { return 0x8219B010;  }
		/* 8219AD44h case   16:*/		return 0x8219AD48;
		  /* 8219AD48h */ case   17:  		/* lwz R31, <#[R29 + 8]> */
		/* 8219AD48h case   17:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000008) );
		/* 8219AD48h case   17:*/		return 0x8219AD4C;
		  /* 8219AD4Ch */ case   18:  		/* rlwinm R11, R31, 0, 18, 24 */
		/* 8219AD4Ch case   18:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R31);
		/* 8219AD4Ch case   18:*/		return 0x8219AD50;
		  /* 8219AD50h */ case   19:  		/* cmplwi CR6, R11, 13312 */
		/* 8219AD50h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003400);
		/* 8219AD50h case   19:*/		return 0x8219AD54;
		  /* 8219AD54h */ case   20:  		/* bc 4, CR6_EQ, 592 */
		/* 8219AD54h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8219AFA4;  }
		/* 8219AD54h case   20:*/		return 0x8219AD58;
		  /* 8219AD58h */ case   21:  		/* mr R4, R21 */
		/* 8219AD58h case   21:*/		regs.R4 = regs.R21;
		/* 8219AD58h case   21:*/		return 0x8219AD5C;
		  /* 8219AD5Ch */ case   22:  		/* mr R3, R29 */
		/* 8219AD5Ch case   22:*/		regs.R3 = regs.R29;
		/* 8219AD5Ch case   22:*/		return 0x8219AD60;
		  /* 8219AD60h */ case   23:  		/* bl -143008 */
		/* 8219AD60h case   23:*/		regs.LR = 0x8219AD64; return 0x82177EC0;
		/* 8219AD60h case   23:*/		return 0x8219AD64;
		  /* 8219AD64h */ case   24:  		/* lwz R11, <#[R3 + 4]> */
		/* 8219AD64h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219AD64h case   24:*/		return 0x8219AD68;
		  /* 8219AD68h */ case   25:  		/* rlwinm. R10, R11, 0, 10, 10 */
		/* 8219AD68h case   25:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R10,regs.R11);
		/* 8219AD68h case   25:*/		return 0x8219AD6C;
		  /* 8219AD6Ch */ case   26:  		/* bc 12, CR0_EQ, 228 */
		/* 8219AD6Ch case   26:*/		if ( regs.CR[0].eq ) { return 0x8219AE50;  }
		/* 8219AD6Ch case   26:*/		return 0x8219AD70;
		  /* 8219AD70h */ case   27:  		/* lwz R30, <#[R29 + 44]> */
		/* 8219AD70h case   27:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x0000002C) );
		/* 8219AD70h case   27:*/		return 0x8219AD74;
		  /* 8219AD74h */ case   28:  		/* lwz R11, <#[R30 + 12]> */
		/* 8219AD74h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219AD74h case   28:*/		return 0x8219AD78;
		  /* 8219AD78h */ case   29:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219AD78h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219AD78h case   29:*/		return 0x8219AD7C;
		  /* 8219AD7Ch */ case   30:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219AD7Ch case   30:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219AD7Ch case   30:*/		return 0x8219AD80;
		  /* 8219AD80h */ case   31:  		/* cmplwi CR6, R11, 14080 */
		/* 8219AD80h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 8219AD80h case   31:*/		return 0x8219AD84;
		  /* 8219AD84h */ case   32:  		/* bc 4, CR6_EQ, 20 */
		/* 8219AD84h case   32:*/		if ( !regs.CR[6].eq ) { return 0x8219AD98;  }
		/* 8219AD84h case   32:*/		return 0x8219AD88;
		  /* 8219AD88h */ case   33:  		/* mr R3, R29 */
		/* 8219AD88h case   33:*/		regs.R3 = regs.R29;
		/* 8219AD88h case   33:*/		return 0x8219AD8C;
		  /* 8219AD8Ch */ case   34:  		/* bl -148748 */
		/* 8219AD8Ch case   34:*/		regs.LR = 0x8219AD90; return 0x82176880;
		/* 8219AD8Ch case   34:*/		return 0x8219AD90;
		  /* 8219AD90h */ case   35:  		/* cmplwi CR0, R3, 0 */
		/* 8219AD90h case   35:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8219AD90h case   35:*/		return 0x8219AD94;
		  /* 8219AD94h */ case   36:  		/* bc 4, CR0_EQ, 528 */
		/* 8219AD94h case   36:*/		if ( !regs.CR[0].eq ) { return 0x8219AFA4;  }
		/* 8219AD94h case   36:*/		return 0x8219AD98;
	}
	return 0x8219AD98;
} // Block from 8219AD04h-8219AD98h (37 instructions)

//////////////////////////////////////////////////////
// Block at 8219AD98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AD98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AD98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AD98);
		  /* 8219AD98h */ case    0:  		/* addi R28, R29, 4 */
		/* 8219AD98h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R29,0x4);
		/* 8219AD98h case    0:*/		return 0x8219AD9C;
		  /* 8219AD9Ch */ case    1:  		/* lwz R31, <#[R28]> */
		/* 8219AD9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 8219AD9Ch case    1:*/		return 0x8219ADA0;
		  /* 8219ADA0h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 8219ADA0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219ADA0h case    2:*/		return 0x8219ADA4;
		  /* 8219ADA4h */ case    3:  		/* bc 12, CR6_EQ, 140 */
		/* 8219ADA4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219AE30;  }
		/* 8219ADA4h case    3:*/		return 0x8219ADA8;
		  /* 8219ADA8h */ case    4:  		/* lwz R11, <#[R31 + 16]> */
		/* 8219ADA8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8219ADA8h case    4:*/		return 0x8219ADAC;
		  /* 8219ADACh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8219ADACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219ADACh case    5:*/		return 0x8219ADB0;
		  /* 8219ADB0h */ case    6:  		/* bc 12, CR6_EQ, 108 */
		/* 8219ADB0h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219AE1C;  }
		/* 8219ADB0h case    6:*/		return 0x8219ADB4;
		  /* 8219ADB4h */ case    7:  		/* lwz R11, <#[R31 + 12]> */
		/* 8219ADB4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219ADB4h case    7:*/		return 0x8219ADB8;
		  /* 8219ADB8h */ case    8:  		/* lwz R9, <#[R30 + 12]> */
		/* 8219ADB8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219ADB8h case    8:*/		return 0x8219ADBC;
		  /* 8219ADBCh */ case    9:  		/* addi R11, R11, 4 */
		/* 8219ADBCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219ADBCh case    9:*/		return 0x8219ADC0;
		  /* 8219ADC0h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 8219ADC0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219ADC0h case   10:*/		return 0x8219ADC4;
		  /* 8219ADC4h */ case   11:  		/* b 12 */
		/* 8219ADC4h case   11:*/		return 0x8219ADD0;
		/* 8219ADC4h case   11:*/		return 0x8219ADC8;
		  /* 8219ADC8h */ case   12:  		/* addi R11, R10, 8 */
		/* 8219ADC8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 8219ADC8h case   12:*/		return 0x8219ADCC;
		  /* 8219ADCCh */ case   13:  		/* lwz R10, <#[R10 + 8]> */
		/* 8219ADCCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8219ADCCh case   13:*/		return 0x8219ADD0;
	}
	return 0x8219ADD0;
} // Block from 8219AD98h-8219ADD0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219ADD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ADD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ADD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ADD0);
		  /* 8219ADD0h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 8219ADD0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8219ADD0h case    0:*/		return 0x8219ADD4;
		  /* 8219ADD4h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8219ADD4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219ADC8;  }
		/* 8219ADD4h case    1:*/		return 0x8219ADD8;
		  /* 8219ADD8h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219ADD8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219ADD8h case    2:*/		return 0x8219ADDC;
		  /* 8219ADDCh */ case    3:  		/* mr R3, R31 */
		/* 8219ADDCh case    3:*/		regs.R3 = regs.R31;
		/* 8219ADDCh case    3:*/		return 0x8219ADE0;
		  /* 8219ADE0h */ case    4:  		/* stw R10, <#[R11]> */
		/* 8219ADE0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219ADE0h case    4:*/		return 0x8219ADE4;
		  /* 8219ADE4h */ case    5:  		/* lwz R11, <#[R9 + 4]> */
		/* 8219ADE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8219ADE4h case    5:*/		return 0x8219ADE8;
		  /* 8219ADE8h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 8219ADE8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219ADE8h case    6:*/		return 0x8219ADEC;
		  /* 8219ADECh */ case    7:  		/* stw R31, <#[R9 + 4]> */
		/* 8219ADECh case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R9 + 0x00000004) );
		/* 8219ADECh case    7:*/		return 0x8219ADF0;
		  /* 8219ADF0h */ case    8:  		/* stw R9, <#[R31 + 12]> */
		/* 8219ADF0h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219ADF0h case    8:*/		return 0x8219ADF4;
		  /* 8219ADF4h */ case    9:  		/* lwz R11, <#[R30]> */
		/* 8219ADF4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8219ADF4h case    9:*/		return 0x8219ADF8;
		  /* 8219ADF8h */ case   10:  		/* rlwinm R4, R11, 27, 24, 31 */
		/* 8219ADF8h case   10:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R4,regs.R11);
		/* 8219ADF8h case   10:*/		return 0x8219ADFC;
		  /* 8219ADFCh */ case   11:  		/* bl -172180 */
		/* 8219ADFCh case   11:*/		regs.LR = 0x8219AE00; return 0x82170D68;
		/* 8219ADFCh case   11:*/		return 0x8219AE00;
		  /* 8219AE00h */ case   12:  		/* lwz R11, <#[R30]> */
		/* 8219AE00h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8219AE00h case   12:*/		return 0x8219AE04;
		  /* 8219AE04h */ case   13:  		/* rlwinm R3, R11, 0, 27, 31 */
		/* 8219AE04h case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R3,regs.R11);
		/* 8219AE04h case   13:*/		return 0x8219AE08;
		  /* 8219AE08h */ case   14:  		/* lwz R27, <#[R31]> */
		/* 8219AE08h case   14:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x00000000) );
		/* 8219AE08h case   14:*/		return 0x8219AE0C;
		  /* 8219AE0Ch */ case   15:  		/* rlwinm R4, R27, 0, 27, 31 */
		/* 8219AE0Ch case   15:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R27);
		/* 8219AE0Ch case   15:*/		return 0x8219AE10;
		  /* 8219AE10h */ case   16:  		/* bl -144280 */
		/* 8219AE10h case   16:*/		regs.LR = 0x8219AE14; return 0x82177A78;
		/* 8219AE10h case   16:*/		return 0x8219AE14;
		  /* 8219AE14h */ case   17:  		/* rlwimi R3, R27, 0, 0, 26 */
		/* 8219AE14h case   17:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R3,regs.R27);
		/* 8219AE14h case   17:*/		return 0x8219AE18;
		  /* 8219AE18h */ case   18:  		/* stw R3, <#[R31]> */
		/* 8219AE18h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8219AE18h case   18:*/		return 0x8219AE1C;
	}
	return 0x8219AE1C;
} // Block from 8219ADD0h-8219AE1Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8219AE1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AE1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AE1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AE1C);
		  /* 8219AE1Ch */ case    0:  		/* lwz R11, <#[R28]> */
		/* 8219AE1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8219AE1Ch case    0:*/		return 0x8219AE20;
		  /* 8219AE20h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 8219AE20h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8219AE20h case    1:*/		return 0x8219AE24;
		  /* 8219AE24h */ case    2:  		/* bc 4, CR6_EQ, -136 */
		/* 8219AE24h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8219AD9C;  }
		/* 8219AE24h case    2:*/		return 0x8219AE28;
		  /* 8219AE28h */ case    3:  		/* addi R28, R31, 8 */
		/* 8219AE28h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x8);
		/* 8219AE28h case    3:*/		return 0x8219AE2C;
		  /* 8219AE2Ch */ case    4:  		/* b -144 */
		/* 8219AE2Ch case    4:*/		return 0x8219AD9C;
		/* 8219AE2Ch case    4:*/		return 0x8219AE30;
	}
	return 0x8219AE30;
} // Block from 8219AE1Ch-8219AE30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219AE30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AE30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AE30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AE30);
		  /* 8219AE30h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219AE30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219AE30h case    0:*/		return 0x8219AE34;
		  /* 8219AE34h */ case    1:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8219AE34h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219AE34h case    1:*/		return 0x8219AE38;
		  /* 8219AE38h */ case    2:  		/* bc 12, CR0_EQ, 344 */
		/* 8219AE38h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219AF90;  }
		/* 8219AE38h case    2:*/		return 0x8219AE3C;
		  /* 8219AE3Ch */ case    3:  		/* lwz R4, <#[R30 + 12]> */
		/* 8219AE3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219AE3Ch case    3:*/		return 0x8219AE40;
		  /* 8219AE40h */ case    4:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219AE40h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219AE40h case    4:*/		return 0x8219AE44;
		  /* 8219AE44h */ case    5:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8219AE44h case    5:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219AE44h case    5:*/		return 0x8219AE48;
		  /* 8219AE48h */ case    6:  		/* bc 4, CR0_EQ, 328 */
		/* 8219AE48h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8219AF90;  }
		/* 8219AE48h case    6:*/		return 0x8219AE4C;
		  /* 8219AE4Ch */ case    7:  		/* b 316 */
		/* 8219AE4Ch case    7:*/		return 0x8219AF88;
		/* 8219AE4Ch case    7:*/		return 0x8219AE50;
	}
	return 0x8219AE50;
} // Block from 8219AE30h-8219AE50h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219AE50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AE50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AE50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AE50);
		  /* 8219AE50h */ case    0:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8219AE50h case    0:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8219AE50h case    0:*/		return 0x8219AE54;
		  /* 8219AE54h */ case    1:  		/* bc 12, CR0_EQ, 336 */
		/* 8219AE54h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219AFA4;  }
		/* 8219AE54h case    1:*/		return 0x8219AE58;
		  /* 8219AE58h */ case    2:  		/* lwz R27, <#[R29 + 44]> */
		/* 8219AE58h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R29 + 0x0000002C) );
		/* 8219AE58h case    2:*/		return 0x8219AE5C;
		  /* 8219AE5Ch */ case    3:  		/* lwz R30, <#[R27 + 12]> */
		/* 8219AE5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x0000000C) );
		/* 8219AE5Ch case    3:*/		return 0x8219AE60;
		  /* 8219AE60h */ case    4:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219AE60h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219AE60h case    4:*/		return 0x8219AE64;
		  /* 8219AE64h */ case    5:  		/* xor R11, R11, R31 */
		/* 8219AE64h case    5:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8219AE64h case    5:*/		return 0x8219AE68;
		  /* 8219AE68h */ case    6:  		/* rlwinm. R11, R11, 0, 15, 17 */
		/* 8219AE68h case    6:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R11,regs.R11);
		/* 8219AE68h case    6:*/		return 0x8219AE6C;
		  /* 8219AE6Ch */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 8219AE6Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x8219AE80;  }
		/* 8219AE6Ch case    7:*/		return 0x8219AE70;
		  /* 8219AE70h */ case    8:  		/* mr R3, R29 */
		/* 8219AE70h case    8:*/		regs.R3 = regs.R29;
		/* 8219AE70h case    8:*/		return 0x8219AE74;
		  /* 8219AE74h */ case    9:  		/* bl -148980 */
		/* 8219AE74h case    9:*/		regs.LR = 0x8219AE78; return 0x82176880;
		/* 8219AE74h case    9:*/		return 0x8219AE78;
		  /* 8219AE78h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 8219AE78h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8219AE78h case   10:*/		return 0x8219AE7C;
		  /* 8219AE7Ch */ case   11:  		/* bc 4, CR0_EQ, 296 */
		/* 8219AE7Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x8219AFA4;  }
		/* 8219AE7Ch case   11:*/		return 0x8219AE80;
	}
	return 0x8219AE80;
} // Block from 8219AE50h-8219AE80h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219AE80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AE80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AE80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AE80);
		  /* 8219AE80h */ case    0:  		/* lwz R31, <#[R30 + 4]> */
		/* 8219AE80h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 8219AE80h case    0:*/		return 0x8219AE84;
		  /* 8219AE84h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 8219AE84h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219AE84h case    1:*/		return 0x8219AE88;
		  /* 8219AE88h */ case    2:  		/* bc 12, CR6_EQ, 80 */
		/* 8219AE88h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219AED8;  }
		/* 8219AE88h case    2:*/		return 0x8219AE8C;
		  /* 8219AE8Ch */ case    3:  		/* lwz R3, <#[R31 + 16]> */
		/* 8219AE8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 8219AE8Ch case    3:*/		return 0x8219AE90;
		  /* 8219AE90h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 8219AE90h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8219AE90h case    4:*/		return 0x8219AE94;
		  /* 8219AE94h */ case    5:  		/* bc 12, CR6_EQ, 60 */
		/* 8219AE94h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219AED0;  }
		/* 8219AE94h case    5:*/		return 0x8219AE98;
		  /* 8219AE98h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 8219AE98h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219AE98h case    6:*/		return 0x8219AE9C;
		  /* 8219AE9Ch */ case    7:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 8219AE9Ch case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8219AE9Ch case    7:*/		return 0x8219AEA0;
		  /* 8219AEA0h */ case    8:  		/* bc 12, CR0_EQ, 48 */
		/* 8219AEA0h case    8:*/		if ( regs.CR[0].eq ) { return 0x8219AED0;  }
		/* 8219AEA0h case    8:*/		return 0x8219AEA4;
		  /* 8219AEA4h */ case    9:  		/* cmplw CR6, R3, R29 */
		/* 8219AEA4h case    9:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R29);
		/* 8219AEA4h case    9:*/		return 0x8219AEA8;
		  /* 8219AEA8h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 8219AEA8h case   10:*/		if ( regs.CR[6].eq ) { return 0x8219AED0;  }
		/* 8219AEA8h case   10:*/		return 0x8219AEAC;
		  /* 8219AEACh */ case   11:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219AEACh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219AEACh case   11:*/		return 0x8219AEB0;
		  /* 8219AEB0h */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219AEB0h case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219AEB0h case   12:*/		return 0x8219AEB4;
		  /* 8219AEB4h */ case   13:  		/* cmplwi CR6, R11, 13312 */
		/* 8219AEB4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003400);
		/* 8219AEB4h case   13:*/		return 0x8219AEB8;
		  /* 8219AEB8h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 8219AEB8h case   14:*/		if ( regs.CR[6].eq ) { return 0x8219AED0;  }
		/* 8219AEB8h case   14:*/		return 0x8219AEBC;
		  /* 8219AEBCh */ case   15:  		/* mr R4, R21 */
		/* 8219AEBCh case   15:*/		regs.R4 = regs.R21;
		/* 8219AEBCh case   15:*/		return 0x8219AEC0;
		  /* 8219AEC0h */ case   16:  		/* bl -143360 */
		/* 8219AEC0h case   16:*/		regs.LR = 0x8219AEC4; return 0x82177EC0;
		/* 8219AEC0h case   16:*/		return 0x8219AEC4;
		  /* 8219AEC4h */ case   17:  		/* lwz R11, <#[R3 + 4]> */
		/* 8219AEC4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219AEC4h case   17:*/		return 0x8219AEC8;
		  /* 8219AEC8h */ case   18:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 8219AEC8h case   18:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 8219AEC8h case   18:*/		return 0x8219AECC;
		  /* 8219AECCh */ case   19:  		/* bc 12, CR0_EQ, 216 */
		/* 8219AECCh case   19:*/		if ( regs.CR[0].eq ) { return 0x8219AFA4;  }
		/* 8219AECCh case   19:*/		return 0x8219AED0;
	}
	return 0x8219AED0;
} // Block from 8219AE80h-8219AED0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219AED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AED0);
		  /* 8219AED0h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8219AED0h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8219AED0h case    0:*/		return 0x8219AED4;
		  /* 8219AED4h */ case    1:  		/* b -80 */
		/* 8219AED4h case    1:*/		return 0x8219AE84;
		/* 8219AED4h case    1:*/		return 0x8219AED8;
	}
	return 0x8219AED8;
} // Block from 8219AED0h-8219AED8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219AED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AED8);
		  /* 8219AED8h */ case    0:  		/* addi R28, R29, 4 */
		/* 8219AED8h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R29,0x4);
		/* 8219AED8h case    0:*/		return 0x8219AEDC;
		  /* 8219AEDCh */ case    1:  		/* lwz R31, <#[R28]> */
		/* 8219AEDCh case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 8219AEDCh case    1:*/		return 0x8219AEE0;
		  /* 8219AEE0h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 8219AEE0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219AEE0h case    2:*/		return 0x8219AEE4;
		  /* 8219AEE4h */ case    3:  		/* bc 12, CR6_EQ, 136 */
		/* 8219AEE4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219AF6C;  }
		/* 8219AEE4h case    3:*/		return 0x8219AEE8;
		  /* 8219AEE8h */ case    4:  		/* lwz R11, <#[R31 + 16]> */
		/* 8219AEE8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8219AEE8h case    4:*/		return 0x8219AEEC;
		  /* 8219AEECh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8219AEECh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219AEECh case    5:*/		return 0x8219AEF0;
		  /* 8219AEF0h */ case    6:  		/* bc 12, CR6_EQ, 104 */
		/* 8219AEF0h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219AF58;  }
		/* 8219AEF0h case    6:*/		return 0x8219AEF4;
		  /* 8219AEF4h */ case    7:  		/* lwz R11, <#[R31 + 12]> */
		/* 8219AEF4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219AEF4h case    7:*/		return 0x8219AEF8;
		  /* 8219AEF8h */ case    8:  		/* addi R11, R11, 4 */
		/* 8219AEF8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219AEF8h case    8:*/		return 0x8219AEFC;
		  /* 8219AEFCh */ case    9:  		/* lwz R10, <#[R11]> */
		/* 8219AEFCh case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219AEFCh case    9:*/		return 0x8219AF00;
		  /* 8219AF00h */ case   10:  		/* b 12 */
		/* 8219AF00h case   10:*/		return 0x8219AF0C;
		/* 8219AF00h case   10:*/		return 0x8219AF04;
		  /* 8219AF04h */ case   11:  		/* addi R11, R10, 8 */
		/* 8219AF04h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 8219AF04h case   11:*/		return 0x8219AF08;
		  /* 8219AF08h */ case   12:  		/* lwz R10, <#[R10 + 8]> */
		/* 8219AF08h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8219AF08h case   12:*/		return 0x8219AF0C;
	}
	return 0x8219AF0C;
} // Block from 8219AED8h-8219AF0Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219AF0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AF0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AF0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AF0C);
		  /* 8219AF0Ch */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 8219AF0Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8219AF0Ch case    0:*/		return 0x8219AF10;
		  /* 8219AF10h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8219AF10h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219AF04;  }
		/* 8219AF10h case    1:*/		return 0x8219AF14;
		  /* 8219AF14h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219AF14h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219AF14h case    2:*/		return 0x8219AF18;
		  /* 8219AF18h */ case    3:  		/* mr R3, R31 */
		/* 8219AF18h case    3:*/		regs.R3 = regs.R31;
		/* 8219AF18h case    3:*/		return 0x8219AF1C;
		  /* 8219AF1Ch */ case    4:  		/* stw R10, <#[R11]> */
		/* 8219AF1Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219AF1Ch case    4:*/		return 0x8219AF20;
		  /* 8219AF20h */ case    5:  		/* lwz R11, <#[R30 + 4]> */
		/* 8219AF20h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8219AF20h case    5:*/		return 0x8219AF24;
		  /* 8219AF24h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 8219AF24h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219AF24h case    6:*/		return 0x8219AF28;
		  /* 8219AF28h */ case    7:  		/* stw R31, <#[R30 + 4]> */
		/* 8219AF28h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 8219AF28h case    7:*/		return 0x8219AF2C;
		  /* 8219AF2Ch */ case    8:  		/* stw R30, <#[R31 + 12]> */
		/* 8219AF2Ch case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219AF2Ch case    8:*/		return 0x8219AF30;
		  /* 8219AF30h */ case    9:  		/* lwz R11, <#[R27]> */
		/* 8219AF30h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8219AF30h case    9:*/		return 0x8219AF34;
		  /* 8219AF34h */ case   10:  		/* rlwinm R4, R11, 27, 24, 31 */
		/* 8219AF34h case   10:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R4,regs.R11);
		/* 8219AF34h case   10:*/		return 0x8219AF38;
		  /* 8219AF38h */ case   11:  		/* bl -172496 */
		/* 8219AF38h case   11:*/		regs.LR = 0x8219AF3C; return 0x82170D68;
		/* 8219AF38h case   11:*/		return 0x8219AF3C;
		  /* 8219AF3Ch */ case   12:  		/* lwz R11, <#[R27]> */
		/* 8219AF3Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8219AF3Ch case   12:*/		return 0x8219AF40;
		  /* 8219AF40h */ case   13:  		/* rlwinm R3, R11, 0, 27, 31 */
		/* 8219AF40h case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R3,regs.R11);
		/* 8219AF40h case   13:*/		return 0x8219AF44;
		  /* 8219AF44h */ case   14:  		/* lwz R23, <#[R31]> */
		/* 8219AF44h case   14:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R31 + 0x00000000) );
		/* 8219AF44h case   14:*/		return 0x8219AF48;
		  /* 8219AF48h */ case   15:  		/* rlwinm R4, R23, 0, 27, 31 */
		/* 8219AF48h case   15:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R23);
		/* 8219AF48h case   15:*/		return 0x8219AF4C;
		  /* 8219AF4Ch */ case   16:  		/* bl -144596 */
		/* 8219AF4Ch case   16:*/		regs.LR = 0x8219AF50; return 0x82177A78;
		/* 8219AF4Ch case   16:*/		return 0x8219AF50;
		  /* 8219AF50h */ case   17:  		/* rlwimi R3, R23, 0, 0, 26 */
		/* 8219AF50h case   17:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R3,regs.R23);
		/* 8219AF50h case   17:*/		return 0x8219AF54;
		  /* 8219AF54h */ case   18:  		/* stw R3, <#[R31]> */
		/* 8219AF54h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8219AF54h case   18:*/		return 0x8219AF58;
	}
	return 0x8219AF58;
} // Block from 8219AF0Ch-8219AF58h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8219AF58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AF58);
		  /* 8219AF58h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 8219AF58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8219AF58h case    0:*/		return 0x8219AF5C;
		  /* 8219AF5Ch */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 8219AF5Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 8219AF5Ch case    1:*/		return 0x8219AF60;
		  /* 8219AF60h */ case    2:  		/* bc 4, CR6_EQ, -132 */
		/* 8219AF60h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8219AEDC;  }
		/* 8219AF60h case    2:*/		return 0x8219AF64;
		  /* 8219AF64h */ case    3:  		/* addi R28, R31, 8 */
		/* 8219AF64h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x8);
		/* 8219AF64h case    3:*/		return 0x8219AF68;
		  /* 8219AF68h */ case    4:  		/* b -140 */
		/* 8219AF68h case    4:*/		return 0x8219AEDC;
		/* 8219AF68h case    4:*/		return 0x8219AF6C;
	}
	return 0x8219AF6C;
} // Block from 8219AF58h-8219AF6Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219AF6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AF6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AF6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AF6C);
		  /* 8219AF6Ch */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219AF6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219AF6Ch case    0:*/		return 0x8219AF70;
		  /* 8219AF70h */ case    1:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8219AF70h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219AF70h case    1:*/		return 0x8219AF74;
		  /* 8219AF74h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 8219AF74h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219AF90;  }
		/* 8219AF74h case    2:*/		return 0x8219AF78;
		  /* 8219AF78h */ case    3:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219AF78h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219AF78h case    3:*/		return 0x8219AF7C;
		  /* 8219AF7Ch */ case    4:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8219AF7Ch case    4:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219AF7Ch case    4:*/		return 0x8219AF80;
		  /* 8219AF80h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 8219AF80h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8219AF90;  }
		/* 8219AF80h case    5:*/		return 0x8219AF84;
		  /* 8219AF84h */ case    6:  		/* mr R4, R30 */
		/* 8219AF84h case    6:*/		regs.R4 = regs.R30;
		/* 8219AF84h case    6:*/		return 0x8219AF88;
	}
	return 0x8219AF88;
} // Block from 8219AF6Ch-8219AF88h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219AF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AF88);
		  /* 8219AF88h */ case    0:  		/* mr R3, R21 */
		/* 8219AF88h case    0:*/		regs.R3 = regs.R21;
		/* 8219AF88h case    0:*/		return 0x8219AF8C;
		  /* 8219AF8Ch */ case    1:  		/* bl 113340 */
		/* 8219AF8Ch case    1:*/		regs.LR = 0x8219AF90; return 0x821B6A48;
		/* 8219AF8Ch case    1:*/		return 0x8219AF90;
	}
	return 0x8219AF90;
} // Block from 8219AF88h-8219AF90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219AF90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AF90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AF90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AF90);
		  /* 8219AF90h */ case    0:  		/* li R6, 1 */
		/* 8219AF90h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8219AF90h case    0:*/		return 0x8219AF94;
		  /* 8219AF94h */ case    1:  		/* li R5, 0 */
		/* 8219AF94h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219AF94h case    1:*/		return 0x8219AF98;
		  /* 8219AF98h */ case    2:  		/* mr R4, R29 */
		/* 8219AF98h case    2:*/		regs.R4 = regs.R29;
		/* 8219AF98h case    2:*/		return 0x8219AF9C;
		  /* 8219AF9Ch */ case    3:  		/* mr R3, R21 */
		/* 8219AF9Ch case    3:*/		regs.R3 = regs.R21;
		/* 8219AF9Ch case    3:*/		return 0x8219AFA0;
		  /* 8219AFA0h */ case    4:  		/* bl 590888 */
		/* 8219AFA0h case    4:*/		regs.LR = 0x8219AFA4; return 0x8222B3C8;
		/* 8219AFA0h case    4:*/		return 0x8219AFA4;
	}
	return 0x8219AFA4;
} // Block from 8219AF90h-8219AFA4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219AFA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AFA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AFA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AFA4);
		  /* 8219AFA4h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 8219AFA4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8219AFA4h case    0:*/		return 0x8219AFA8;
		  /* 8219AFA8h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 8219AFA8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219AFDC;  }
		/* 8219AFA8h case    1:*/		return 0x8219AFAC;
		  /* 8219AFACh */ case    2:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 8219AFACh case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 8219AFACh case    2:*/		return 0x8219AFB0;
		  /* 8219AFB0h */ case    3:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219AFB0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219AFB0h case    3:*/		return 0x8219AFB4;
		  /* 8219AFB4h */ case    4:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219AFB4h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219AFB4h case    4:*/		return 0x8219AFB8;
		  /* 8219AFB8h */ case    5:  		/* addic R10, R10, -1 */
		/* 8219AFB8h case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219AFB8h case    5:*/		return 0x8219AFBC;
		  /* 8219AFBCh */ case    6:  		/* subfe R10, R10, R10 */
		/* 8219AFBCh case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8219AFBCh case    6:*/		return 0x8219AFC0;
		  /* 8219AFC0h */ case    7:  		/* and R10, R10, R11 */
		/* 8219AFC0h case    7:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8219AFC0h case    7:*/		return 0x8219AFC4;
		  /* 8219AFC4h */ case    8:  		/* cmplw CR6, R29, R10 */
		/* 8219AFC4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 8219AFC4h case    8:*/		return 0x8219AFC8;
		  /* 8219AFC8h */ case    9:  		/* bc 4, CR6_EQ, 52 */
		/* 8219AFC8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219AFFC;  }
		/* 8219AFC8h case    9:*/		return 0x8219AFCC;
		  /* 8219AFCCh */ case   10:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 8219AFCCh case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 8219AFCCh case   10:*/		return 0x8219AFD0;
		  /* 8219AFD0h */ case   11:  		/* mr R26, R29 */
		/* 8219AFD0h case   11:*/		regs.R26 = regs.R29;
		/* 8219AFD0h case   11:*/		return 0x8219AFD4;
		  /* 8219AFD4h */ case   12:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219AFD4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219AFD4h case   12:*/		return 0x8219AFD8;
		  /* 8219AFD8h */ case   13:  		/* b 36 */
		/* 8219AFD8h case   13:*/		return 0x8219AFFC;
		/* 8219AFD8h case   13:*/		return 0x8219AFDC;
	}
	return 0x8219AFDC;
} // Block from 8219AFA4h-8219AFDCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219AFDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AFDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AFDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AFDC);
		  /* 8219AFDCh */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 8219AFDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 8219AFDCh case    0:*/		return 0x8219AFE0;
		  /* 8219AFE0h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219AFE0h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219AFE0h case    1:*/		return 0x8219AFE4;
		  /* 8219AFE4h */ case    2:  		/* addic R10, R10, -1 */
		/* 8219AFE4h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219AFE4h case    2:*/		return 0x8219AFE8;
		  /* 8219AFE8h */ case    3:  		/* subfe R10, R10, R10 */
		/* 8219AFE8h case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8219AFE8h case    3:*/		return 0x8219AFEC;
		  /* 8219AFECh */ case    4:  		/* and R11, R10, R11 */
		/* 8219AFECh case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219AFECh case    4:*/		return 0x8219AFF0;
		  /* 8219AFF0h */ case    5:  		/* cmplw CR6, R29, R11 */
		/* 8219AFF0h case    5:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8219AFF0h case    5:*/		return 0x8219AFF4;
		  /* 8219AFF4h */ case    6:  		/* bc 12, CR6_EQ, -40 */
		/* 8219AFF4h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219AFCC;  }
		/* 8219AFF4h case    6:*/		return 0x8219AFF8;
		  /* 8219AFF8h */ case    7:  		/* lwz R11, <#[R25 + 4]> */
		/* 8219AFF8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 8219AFF8h case    7:*/		return 0x8219AFFC;
	}
	return 0x8219AFFC;
} // Block from 8219AFDCh-8219AFFCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219AFFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219AFFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219AFFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219AFFC);
		  /* 8219AFFCh */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219AFFCh case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219AFFCh case    0:*/		return 0x8219B000;
		  /* 8219B000h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 8219B000h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219B010;  }
		/* 8219B000h case    1:*/		return 0x8219B004;
		  /* 8219B004h */ case    2:  		/* mr R29, R11 */
		/* 8219B004h case    2:*/		regs.R29 = regs.R11;
		/* 8219B004h case    2:*/		return 0x8219B008;
		  /* 8219B008h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8219B008h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219B008h case    3:*/		return 0x8219B00C;
		  /* 8219B00Ch */ case    4:  		/* bc 4, CR6_EQ, -708 */
		/* 8219B00Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x8219AD48;  }
		/* 8219B00Ch case    4:*/		return 0x8219B010;
	}
	return 0x8219B010;
} // Block from 8219AFFCh-8219B010h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219B010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B010);
		  /* 8219B010h */ case    0:  		/* rlwinm R11, R24, 0, 0, 30 */
		/* 8219B010h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R24);
		/* 8219B010h case    0:*/		return 0x8219B014;
		  /* 8219B014h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219B014h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219B014h case    1:*/		return 0x8219B018;
		  /* 8219B018h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219B018h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219B018h case    2:*/		return 0x8219B01C;
		  /* 8219B01Ch */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8219B01Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219B02C;  }
		/* 8219B01Ch case    3:*/		return 0x8219B020;
		  /* 8219B020h */ case    4:  		/* mr R24, R11 */
		/* 8219B020h case    4:*/		regs.R24 = regs.R11;
		/* 8219B020h case    4:*/		return 0x8219B024;
		  /* 8219B024h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8219B024h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219B024h case    5:*/		return 0x8219B028;
		  /* 8219B028h */ case    6:  		/* bc 4, CR6_EQ, -768 */
		/* 8219B028h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219AD28;  }
		/* 8219B028h case    6:*/		return 0x8219B02C;
	}
	return 0x8219B02C;
} // Block from 8219B010h-8219B02Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219B02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B02C);
		  /* 8219B02Ch */ case    0:  		/* addi R1, R1, 464 */
		/* 8219B02Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1D0);
		/* 8219B02Ch case    0:*/		return 0x8219B030;
		  /* 8219B030h */ case    1:  		/* addi R12, R1, -152 */
		/* 8219B030h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFF68);
		/* 8219B030h case    1:*/		return 0x8219B034;
		  /* 8219B034h */ case    2:  		/* bl -1088472 */
		/* 8219B034h case    2:*/		regs.LR = 0x8219B038; return 0x8209145C;
		/* 8219B034h case    2:*/		return 0x8219B038;
		  /* 8219B038h */ case    3:  		/* b -1088968 */
		/* 8219B038h case    3:*/		return 0x82091270;
		/* 8219B038h case    3:*/		return 0x8219B03C;
		  /* 8219B03Ch */ case    4:  		/* nop */
		/* 8219B03Ch case    4:*/		cpu::op::nop();
		/* 8219B03Ch case    4:*/		return 0x8219B040;
		  /* 8219B040h */ case    5:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219B040h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219B040h case    5:*/		return 0x8219B044;
		  /* 8219B044h */ case    6:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8219B044h case    6:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8219B044h case    6:*/		return 0x8219B048;
		  /* 8219B048h */ case    7:  		/* bc 12, CR0_EQ, 48 */
		/* 8219B048h case    7:*/		if ( regs.CR[0].eq ) { return 0x8219B078;  }
		/* 8219B048h case    7:*/		return 0x8219B04C;
		  /* 8219B04Ch */ case    8:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219B04Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219B04Ch case    8:*/		return 0x8219B050;
		  /* 8219B050h */ case    9:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8219B050h case    9:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8219B050h case    9:*/		return 0x8219B054;
		  /* 8219B054h */ case   10:  		/* bc 12, CR0_EQ, 36 */
		/* 8219B054h case   10:*/		if ( regs.CR[0].eq ) { return 0x8219B078;  }
		/* 8219B054h case   10:*/		return 0x8219B058;
		  /* 8219B058h */ case   11:  		/* lwz R11, <#[R3 + 20]> */
		/* 8219B058h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 8219B058h case   11:*/		return 0x8219B05C;
		  /* 8219B05Ch */ case   12:  		/* lwz R10, <#[R4 + 20]> */
		/* 8219B05Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 8219B05Ch case   12:*/		return 0x8219B060;
		  /* 8219B060h */ case   13:  		/* rlwinm R11, R11, 0, 0, 28 */
		/* 8219B060h case   13:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R11,regs.R11);
		/* 8219B060h case   13:*/		return 0x8219B064;
		  /* 8219B064h */ case   14:  		/* rlwinm R10, R10, 0, 0, 28 */
		/* 8219B064h case   14:*/		cpu::op::rlwinm<0,0,0,28>(regs,&regs.R10,regs.R10);
		/* 8219B064h case   14:*/		return 0x8219B068;
		  /* 8219B068h */ case   15:  		/* subfc R11, R11, R10 */
		/* 8219B068h case   15:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219B068h case   15:*/		return 0x8219B06C;
		  /* 8219B06Ch */ case   16:  		/* subfe R11, R11, R11 */
		/* 8219B06Ch case   16:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8219B06Ch case   16:*/		return 0x8219B070;
		  /* 8219B070h */ case   17:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 8219B070h case   17:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 8219B070h case   17:*/		return 0x8219B074;
		  /* 8219B074h */ case   18:  		/* bclr 20, CR0_LT */
		/* 8219B074h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219B074h case   18:*/		return 0x8219B078;
	}
	return 0x8219B078;
} // Block from 8219B02Ch-8219B078h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8219B078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B078);
		  /* 8219B078h */ case    0:  		/* b 569416 */
		/* 8219B078h case    0:*/		return 0x822260C0;
		/* 8219B078h case    0:*/		return 0x8219B07C;
		  /* 8219B07Ch */ case    1:  		/* nop */
		/* 8219B07Ch case    1:*/		cpu::op::nop();
		/* 8219B07Ch case    1:*/		return 0x8219B080;
		  /* 8219B080h */ case    2:  		/* rlwinm. R10, R4, 0, 31, 31 */
		/* 8219B080h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R4);
		/* 8219B080h case    2:*/		return 0x8219B084;
		  /* 8219B084h */ case    3:  		/* rlwinm R11, R3, 0, 30, 31 */
		/* 8219B084h case    3:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R3);
		/* 8219B084h case    3:*/		return 0x8219B088;
		  /* 8219B088h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 8219B088h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219B094;  }
		/* 8219B088h case    4:*/		return 0x8219B08C;
		  /* 8219B08Ch */ case    5:  		/* rlwinm R11, R3, 0, 31, 31 */
		/* 8219B08Ch case    5:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R3);
		/* 8219B08Ch case    5:*/		return 0x8219B090;
		  /* 8219B090h */ case    6:  		/* ori R11, R11, 2 */
		/* 8219B090h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8219B090h case    6:*/		return 0x8219B094;
	}
	return 0x8219B094;
} // Block from 8219B078h-8219B094h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219B094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B094);
		  /* 8219B094h */ case    0:  		/* rlwinm. R10, R4, 0, 30, 30 */
		/* 8219B094h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R4);
		/* 8219B094h case    0:*/		return 0x8219B098;
		  /* 8219B098h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219B098h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219B0A8;  }
		/* 8219B098h case    1:*/		return 0x8219B09C;
		  /* 8219B09Ch */ case    2:  		/* cmplwi CR6, R11, 3 */
		/* 8219B09Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8219B09Ch case    2:*/		return 0x8219B0A0;
		  /* 8219B0A0h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 8219B0A0h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219B0A8;  }
		/* 8219B0A0h case    3:*/		return 0x8219B0A4;
		  /* 8219B0A4h */ case    4:  		/* li R11, 2 */
		/* 8219B0A4h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8219B0A4h case    4:*/		return 0x8219B0A8;
	}
	return 0x8219B0A8;
} // Block from 8219B094h-8219B0A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219B0A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B0A8);
		  /* 8219B0A8h */ case    0:  		/* rlwinm. R10, R4, 0, 29, 29 */
		/* 8219B0A8h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R4);
		/* 8219B0A8h case    0:*/		return 0x8219B0AC;
		  /* 8219B0ACh */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 8219B0ACh case    1:*/		if ( regs.CR[0].eq ) { return 0x8219B0CC;  }
		/* 8219B0ACh case    1:*/		return 0x8219B0B0;
		  /* 8219B0B0h */ case    2:  		/* cmplwi CR6, R11, 3 */
		/* 8219B0B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8219B0B0h case    2:*/		return 0x8219B0B4;
		  /* 8219B0B4h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 8219B0B4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219B0CC;  }
		/* 8219B0B4h case    3:*/		return 0x8219B0B8;
		  /* 8219B0B8h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219B0B8h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219B0B8h case    4:*/		return 0x8219B0BC;
		  /* 8219B0BCh */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 8219B0BCh case    5:*/		if ( regs.CR[0].eq ) { return 0x8219B0C8;  }
		/* 8219B0BCh case    5:*/		return 0x8219B0C0;
		  /* 8219B0C0h */ case    6:  		/* li R11, 2 */
		/* 8219B0C0h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 8219B0C0h case    6:*/		return 0x8219B0C4;
		  /* 8219B0C4h */ case    7:  		/* b 8 */
		/* 8219B0C4h case    7:*/		return 0x8219B0CC;
		/* 8219B0C4h case    7:*/		return 0x8219B0C8;
	}
	return 0x8219B0C8;
} // Block from 8219B0A8h-8219B0C8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219B0C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B0C8);
		  /* 8219B0C8h */ case    0:  		/* rlwinm R11, R11, 31, 31, 31 */
		/* 8219B0C8h case    0:*/		cpu::op::rlwinm<0,31,31,31>(regs,&regs.R11,regs.R11);
		/* 8219B0C8h case    0:*/		return 0x8219B0CC;
	}
	return 0x8219B0CC;
} // Block from 8219B0C8h-8219B0CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B0CC);
		  /* 8219B0CCh */ case    0:  		/* rlwinm R10, R3, 0, 0, 29 */
		/* 8219B0CCh case    0:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R3);
		/* 8219B0CCh case    0:*/		return 0x8219B0D0;
		  /* 8219B0D0h */ case    1:  		/* or R3, R10, R11 */
		/* 8219B0D0h case    1:*/		cpu::op::or<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8219B0D0h case    1:*/		return 0x8219B0D4;
		  /* 8219B0D4h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8219B0D4h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219B0D4h case    2:*/		return 0x8219B0D8;
	}
	return 0x8219B0D8;
} // Block from 8219B0CCh-8219B0D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B0D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B0D8);
		  /* 8219B0D8h */ case    0:  		/* mfspr R12, LR */
		/* 8219B0D8h case    0:*/		regs.R12 = regs.LR;
		/* 8219B0D8h case    0:*/		return 0x8219B0DC;
		  /* 8219B0DCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219B0DCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219B0DCh case    1:*/		return 0x8219B0E0;
		  /* 8219B0E0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8219B0E0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219B0E0h case    2:*/		return 0x8219B0E4;
		  /* 8219B0E4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8219B0E4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8219B0E4h case    3:*/		return 0x8219B0E8;
		  /* 8219B0E8h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8219B0E8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8219B0E8h case    4:*/		return 0x8219B0EC;
		  /* 8219B0ECh */ case    5:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 8219B0ECh case    5:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 8219B0ECh case    5:*/		return 0x8219B0F0;
		  /* 8219B0F0h */ case    6:  		/* mr R31, R3 */
		/* 8219B0F0h case    6:*/		regs.R31 = regs.R3;
		/* 8219B0F0h case    6:*/		return 0x8219B0F4;
		  /* 8219B0F4h */ case    7:  		/* lwz R3, <#[R3 + 12]> */
		/* 8219B0F4h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 8219B0F4h case    7:*/		return 0x8219B0F8;
		  /* 8219B0F8h */ case    8:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 8219B0F8h case    8:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 8219B0F8h case    8:*/		return 0x8219B0FC;
		  /* 8219B0FCh */ case    9:  		/* srw R11, R11, R10 */
		/* 8219B0FCh case    9:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219B0FCh case    9:*/		return 0x8219B100;
		  /* 8219B100h */ case   10:  		/* rlwinm R4, R11, 0, 30, 31 */
		/* 8219B100h case   10:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R11);
		/* 8219B100h case   10:*/		return 0x8219B104;
		  /* 8219B104h */ case   11:  		/* bl 139108 */
		/* 8219B104h case   11:*/		regs.LR = 0x8219B108; return 0x821BD068;
		/* 8219B104h case   11:*/		return 0x8219B108;
		  /* 8219B108h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 8219B108h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219B108h case   12:*/		return 0x8219B10C;
		  /* 8219B10Ch */ case   13:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 8219B10Ch case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 8219B10Ch case   13:*/		return 0x8219B110;
		  /* 8219B110h */ case   14:  		/* bl -144 */
		/* 8219B110h case   14:*/		regs.LR = 0x8219B114; return 0x8219B080;
		/* 8219B110h case   14:*/		return 0x8219B114;
		  /* 8219B114h */ case   15:  		/* addi R1, R1, 96 */
		/* 8219B114h case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8219B114h case   15:*/		return 0x8219B118;
		  /* 8219B118h */ case   16:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219B118h case   16:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219B118h case   16:*/		return 0x8219B11C;
		  /* 8219B11Ch */ case   17:  		/* mtspr LR, R12 */
		/* 8219B11Ch case   17:*/		regs.LR = regs.R12;
		/* 8219B11Ch case   17:*/		return 0x8219B120;
		  /* 8219B120h */ case   18:  		/* ld R31, <#[R1 - 16]> */
		/* 8219B120h case   18:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219B120h case   18:*/		return 0x8219B124;
		  /* 8219B124h */ case   19:  		/* bclr 20, CR0_LT */
		/* 8219B124h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219B124h case   19:*/		return 0x8219B128;
	}
	return 0x8219B128;
} // Block from 8219B0D8h-8219B128h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219B128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B128);
		  /* 8219B128h */ case    0:  		/* mfspr R12, LR */
		/* 8219B128h case    0:*/		regs.R12 = regs.LR;
		/* 8219B128h case    0:*/		return 0x8219B12C;
		  /* 8219B12Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219B12Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219B12Ch case    1:*/		return 0x8219B130;
		  /* 8219B130h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8219B130h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8219B130h case    2:*/		return 0x8219B134;
		  /* 8219B134h */ case    3:  		/* bl -92 */
		/* 8219B134h case    3:*/		regs.LR = 0x8219B138; return 0x8219B0D8;
		/* 8219B134h case    3:*/		return 0x8219B138;
		  /* 8219B138h */ case    4:  		/* rlwinm R11, R3, 0, 30, 31 */
		/* 8219B138h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R3);
		/* 8219B138h case    4:*/		return 0x8219B13C;
		  /* 8219B13Ch */ case    5:  		/* addi R11, R11, -3 */
		/* 8219B13Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFD);
		/* 8219B13Ch case    5:*/		return 0x8219B140;
		  /* 8219B140h */ case    6:  		/* cntlzw R11, R11 */
		/* 8219B140h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8219B140h case    6:*/		return 0x8219B144;
		  /* 8219B144h */ case    7:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 8219B144h case    7:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 8219B144h case    7:*/		return 0x8219B148;
		  /* 8219B148h */ case    8:  		/* addi R1, R1, 96 */
		/* 8219B148h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8219B148h case    8:*/		return 0x8219B14C;
		  /* 8219B14Ch */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219B14Ch case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219B14Ch case    9:*/		return 0x8219B150;
		  /* 8219B150h */ case   10:  		/* mtspr LR, R12 */
		/* 8219B150h case   10:*/		regs.LR = regs.R12;
		/* 8219B150h case   10:*/		return 0x8219B154;
		  /* 8219B154h */ case   11:  		/* bclr 20, CR0_LT */
		/* 8219B154h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219B154h case   11:*/		return 0x8219B158;
	}
	return 0x8219B158;
} // Block from 8219B128h-8219B158h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219B158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B158);
		  /* 8219B158h */ case    0:  		/* mfspr R12, LR */
		/* 8219B158h case    0:*/		regs.R12 = regs.LR;
		/* 8219B158h case    0:*/		return 0x8219B15C;
		  /* 8219B15Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219B15Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219B15Ch case    1:*/		return 0x8219B160;
		  /* 8219B160h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8219B160h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8219B160h case    2:*/		return 0x8219B164;
		  /* 8219B164h */ case    3:  		/* lwz R10, <#[R3 + 548]> */
		/* 8219B164h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000224) );
		/* 8219B164h case    3:*/		return 0x8219B168;
		  /* 8219B168h */ case    4:  		/* lwz R11, <#[R3 + 552]> */
		/* 8219B168h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000228) );
		/* 8219B168h case    4:*/		return 0x8219B16C;
		  /* 8219B16Ch */ case    5:  		/* addi R10, R10, 1 */
		/* 8219B16Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8219B16Ch case    5:*/		return 0x8219B170;
		  /* 8219B170h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8219B170h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219B170h case    6:*/		return 0x8219B174;
		  /* 8219B174h */ case    7:  		/* stw R10, <#[R3 + 548]> */
		/* 8219B174h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000224) );
		/* 8219B174h case    7:*/		return 0x8219B178;
		  /* 8219B178h */ case    8:  		/* bc 12, CR6_EQ, 40 */
		/* 8219B178h case    8:*/		if ( regs.CR[6].eq ) { return 0x8219B1A0;  }
		/* 8219B178h case    8:*/		return 0x8219B17C;
		  /* 8219B17Ch */ case    9:  		/* lwz R9, <#[R11]> */
		/* 8219B17Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8219B17Ch case    9:*/		return 0x8219B180;
		  /* 8219B180h */ case   10:  		/* cmplw CR6, R10, R9 */
		/* 8219B180h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8219B180h case   10:*/		return 0x8219B184;
		  /* 8219B184h */ case   11:  		/* bc 12, CR6_LT, 28 */
		/* 8219B184h case   11:*/		if ( regs.CR[6].lt ) { return 0x8219B1A0;  }
		/* 8219B184h case   11:*/		return 0x8219B188;
		  /* 8219B188h */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219B188h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219B188h case   12:*/		return 0x8219B18C;
		  /* 8219B18Ch */ case   13:  		/* cmplw CR6, R10, R11 */
		/* 8219B18Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8219B18Ch case   13:*/		return 0x8219B190;
		  /* 8219B190h */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 8219B190h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8219B198;  }
		/* 8219B190h case   14:*/		return 0x8219B194;
		  /* 8219B194h */ case   15:  		/* bl -300724 */
		/* 8219B194h case   15:*/		regs.LR = 0x8219B198; return 0x82151AE0;
		/* 8219B194h case   15:*/		return 0x8219B198;
	}
	return 0x8219B198;
} // Block from 8219B158h-8219B198h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219B198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B198);
		  /* 8219B198h */ case    0:  		/* li R3, 0 */
		/* 8219B198h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219B198h case    0:*/		return 0x8219B19C;
		  /* 8219B19Ch */ case    1:  		/* b 8 */
		/* 8219B19Ch case    1:*/		return 0x8219B1A4;
		/* 8219B19Ch case    1:*/		return 0x8219B1A0;
	}
	return 0x8219B1A0;
} // Block from 8219B198h-8219B1A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B1A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B1A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B1A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B1A0);
		  /* 8219B1A0h */ case    0:  		/* li R3, 1 */
		/* 8219B1A0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219B1A0h case    0:*/		return 0x8219B1A4;
	}
	return 0x8219B1A4;
} // Block from 8219B1A0h-8219B1A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B1A4);
		  /* 8219B1A4h */ case    0:  		/* addi R1, R1, 96 */
		/* 8219B1A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8219B1A4h case    0:*/		return 0x8219B1A8;
		  /* 8219B1A8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219B1A8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219B1A8h case    1:*/		return 0x8219B1AC;
		  /* 8219B1ACh */ case    2:  		/* mtspr LR, R12 */
		/* 8219B1ACh case    2:*/		regs.LR = regs.R12;
		/* 8219B1ACh case    2:*/		return 0x8219B1B0;
		  /* 8219B1B0h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8219B1B0h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219B1B0h case    3:*/		return 0x8219B1B4;
	}
	return 0x8219B1B4;
} // Block from 8219B1A4h-8219B1B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219B1B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B1B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B1B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B1B4);
		  /* 8219B1B4h */ case    0:  		/* nop */
		/* 8219B1B4h case    0:*/		cpu::op::nop();
		/* 8219B1B4h case    0:*/		return 0x8219B1B8;
	}
	return 0x8219B1B8;
} // Block from 8219B1B4h-8219B1B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B1B8);
		  /* 8219B1B8h */ case    0:  		/* mfspr R12, LR */
		/* 8219B1B8h case    0:*/		regs.R12 = regs.LR;
		/* 8219B1B8h case    0:*/		return 0x8219B1BC;
		  /* 8219B1BCh */ case    1:  		/* bl -1089380 */
		/* 8219B1BCh case    1:*/		regs.LR = 0x8219B1C0; return 0x82091258;
		/* 8219B1BCh case    1:*/		return 0x8219B1C0;
		  /* 8219B1C0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8219B1C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8219B1C0h case    2:*/		return 0x8219B1C4;
		  /* 8219B1C4h */ case    3:  		/* lwz R11, <#[R4 + 16]> */
		/* 8219B1C4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 8219B1C4h case    3:*/		return 0x8219B1C8;
		  /* 8219B1C8h */ case    4:  		/* mr R30, R4 */
		/* 8219B1C8h case    4:*/		regs.R30 = regs.R4;
		/* 8219B1C8h case    4:*/		return 0x8219B1CC;
		  /* 8219B1CCh */ case    5:  		/* mr R29, R5 */
		/* 8219B1CCh case    5:*/		regs.R29 = regs.R5;
		/* 8219B1CCh case    5:*/		return 0x8219B1D0;
		  /* 8219B1D0h */ case    6:  		/* mr R28, R6 */
		/* 8219B1D0h case    6:*/		regs.R28 = regs.R6;
		/* 8219B1D0h case    6:*/		return 0x8219B1D4;
		  /* 8219B1D4h */ case    7:  		/* li R31, 0 */
		/* 8219B1D4h case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8219B1D4h case    7:*/		return 0x8219B1D8;
		  /* 8219B1D8h */ case    8:  		/* rlwinm. R10, R11, 0, 29, 31 */
		/* 8219B1D8h case    8:*/		cpu::op::rlwinm<1,0,29,31>(regs,&regs.R10,regs.R11);
		/* 8219B1D8h case    8:*/		return 0x8219B1DC;
		  /* 8219B1DCh */ case    9:  		/* bc 12, CR0_EQ, 44 */
		/* 8219B1DCh case    9:*/		if ( regs.CR[0].eq ) { return 0x8219B208;  }
		/* 8219B1DCh case    9:*/		return 0x8219B1E0;
		  /* 8219B1E0h */ case   10:  		/* mr R11, R4 */
		/* 8219B1E0h case   10:*/		regs.R11 = regs.R4;
		/* 8219B1E0h case   10:*/		return 0x8219B1E4;
		  /* 8219B1E4h */ case   11:  		/* lwz R9, <#[R11]> */
		/* 8219B1E4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8219B1E4h case   11:*/		return 0x8219B1E8;
		  /* 8219B1E8h */ case   12:  		/* cmplw CR6, R9, R29 */
		/* 8219B1E8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R29);
		/* 8219B1E8h case   12:*/		return 0x8219B1EC;
		  /* 8219B1ECh */ case   13:  		/* bc 12, CR6_EQ, 28 */
		/* 8219B1ECh case   13:*/		if ( regs.CR[6].eq ) { return 0x8219B208;  }
		/* 8219B1ECh case   13:*/		return 0x8219B1F0;
		  /* 8219B1F0h */ case   14:  		/* lwz R9, <#[R30 + 16]> */
		/* 8219B1F0h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 8219B1F0h case   14:*/		return 0x8219B1F4;
		  /* 8219B1F4h */ case   15:  		/* addi R31, R31, 1 */
		/* 8219B1F4h case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8219B1F4h case   15:*/		return 0x8219B1F8;
		  /* 8219B1F8h */ case   16:  		/* addi R11, R11, 4 */
		/* 8219B1F8h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219B1F8h case   16:*/		return 0x8219B1FC;
		  /* 8219B1FCh */ case   17:  		/* rlwinm R9, R9, 0, 29, 31 */
		/* 8219B1FCh case   17:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R9,regs.R9);
		/* 8219B1FCh case   17:*/		return 0x8219B200;
		  /* 8219B200h */ case   18:  		/* cmplw CR6, R31, R9 */
		/* 8219B200h case   18:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 8219B200h case   18:*/		return 0x8219B204;
		  /* 8219B204h */ case   19:  		/* bc 12, CR6_LT, -32 */
		/* 8219B204h case   19:*/		if ( regs.CR[6].lt ) { return 0x8219B1E4;  }
		/* 8219B204h case   19:*/		return 0x8219B208;
	}
	return 0x8219B208;
} // Block from 8219B1B8h-8219B208h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219B208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B208);
		  /* 8219B208h */ case    0:  		/* cmplw CR6, R31, R10 */
		/* 8219B208h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 8219B208h case    0:*/		return 0x8219B20C;
		  /* 8219B20Ch */ case    1:  		/* bc 4, CR6_EQ, 92 */
		/* 8219B20Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219B268;  }
		/* 8219B20Ch case    1:*/		return 0x8219B210;
		  /* 8219B210h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219B210h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219B210h case    2:*/		return 0x8219B214;
		  /* 8219B214h */ case    3:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 8219B214h case    3:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 8219B214h case    3:*/		return 0x8219B218;
		  /* 8219B218h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 8219B218h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219B228;  }
		/* 8219B218h case    4:*/		return 0x8219B21C;
		  /* 8219B21Ch */ case    5:  		/* mr R4, R29 */
		/* 8219B21Ch case    5:*/		regs.R4 = regs.R29;
		/* 8219B21Ch case    5:*/		return 0x8219B220;
		  /* 8219B220h */ case    6:  		/* lwz R5, <#[R3 + 660]> */
		/* 8219B220h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R3 + 0x00000294) );
		/* 8219B220h case    6:*/		return 0x8219B224;
		  /* 8219B224h */ case    7:  		/* bl 137012 */
		/* 8219B224h case    7:*/		regs.LR = 0x8219B228; return 0x821BC958;
		/* 8219B224h case    7:*/		return 0x8219B228;
	}
	return 0x8219B228;
} // Block from 8219B208h-8219B228h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219B228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B228);
		  /* 8219B228h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219B228h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219B228h case    0:*/		return 0x8219B22C;
		  /* 8219B22Ch */ case    1:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 8219B22Ch case    1:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 8219B22Ch case    1:*/		return 0x8219B230;
		  /* 8219B230h */ case    2:  		/* subf. R11, R28, R11 */
		/* 8219B230h case    2:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R28,regs.R11);
		/* 8219B230h case    2:*/		return 0x8219B234;
		  /* 8219B234h */ case    3:  		/* mtspr CTR, R11 */
		/* 8219B234h case    3:*/		regs.CTR = regs.R11;
		/* 8219B234h case    3:*/		return 0x8219B238;
		  /* 8219B238h */ case    4:  		/* bc 12, CR0_EQ, 36 */
		/* 8219B238h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219B25C;  }
		/* 8219B238h case    4:*/		return 0x8219B23C;
		  /* 8219B23Ch */ case    5:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 8219B23Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 8219B23Ch case    5:*/		return 0x8219B240;
		  /* 8219B240h */ case    6:  		/* add R11, R11, R30 */
		/* 8219B240h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8219B240h case    6:*/		return 0x8219B244;
		  /* 8219B244h */ case    7:  		/* addi R11, R11, -4 */
		/* 8219B244h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8219B244h case    7:*/		return 0x8219B248;
		  /* 8219B248h */ case    8:  		/* cmplwi CR6, R31, 4 */
		/* 8219B248h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000004);
		/* 8219B248h case    8:*/		return 0x8219B24C;
		  /* 8219B24Ch */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 8219B24Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x8219B274;  }
		/* 8219B24Ch case    9:*/		return 0x8219B250;
		  /* 8219B250h */ case   10:  		/* stwu R29, <#[R11 + 4]> */
		/* 8219B250h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8219B250h case   10:*/		return 0x8219B254;
		  /* 8219B254h */ case   11:  		/* addi R31, R31, 1 */
		/* 8219B254h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8219B254h case   11:*/		return 0x8219B258;
		  /* 8219B258h */ case   12:  		/* bc 16, CR0_LT, -16 */
		/* 8219B258h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8219B248;  }
		/* 8219B258h case   12:*/		return 0x8219B25C;
	}
	return 0x8219B25C;
} // Block from 8219B228h-8219B25Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219B25Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B25C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B25C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B25C);
		  /* 8219B25Ch */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219B25Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219B25Ch case    0:*/		return 0x8219B260;
		  /* 8219B260h */ case    1:  		/* rlwimi R31, R11, 0, 0, 28 */
		/* 8219B260h case    1:*/		cpu::op::rlwimi<0,0,0,28>(regs,&regs.R31,regs.R11);
		/* 8219B260h case    1:*/		return 0x8219B264;
		  /* 8219B264h */ case    2:  		/* stw R31, <#[R30 + 16]> */
		/* 8219B264h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 8219B264h case    2:*/		return 0x8219B268;
	}
	return 0x8219B268;
} // Block from 8219B25Ch-8219B268h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B268);
		  /* 8219B268h */ case    0:  		/* li R3, 1 */
		/* 8219B268h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219B268h case    0:*/		return 0x8219B26C;
		  /* 8219B26Ch */ case    1:  		/* addi R1, R1, 128 */
		/* 8219B26Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8219B26Ch case    1:*/		return 0x8219B270;
		  /* 8219B270h */ case    2:  		/* b -1089480 */
		/* 8219B270h case    2:*/		return 0x820912A8;
		/* 8219B270h case    2:*/		return 0x8219B274;
	}
	return 0x8219B274;
} // Block from 8219B268h-8219B274h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B274);
		  /* 8219B274h */ case    0:  		/* li R3, 0 */
		/* 8219B274h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219B274h case    0:*/		return 0x8219B278;
		  /* 8219B278h */ case    1:  		/* b -12 */
		/* 8219B278h case    1:*/		return 0x8219B26C;
		/* 8219B278h case    1:*/		return 0x8219B27C;
		  /* 8219B27Ch */ case    2:  		/* nop */
		/* 8219B27Ch case    2:*/		cpu::op::nop();
		/* 8219B27Ch case    2:*/		return 0x8219B280;
	}
	return 0x8219B280;
} // Block from 8219B274h-8219B280h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B280);
		  /* 8219B280h */ case    0:  		/* mfspr R12, LR */
		/* 8219B280h case    0:*/		regs.R12 = regs.LR;
		/* 8219B280h case    0:*/		return 0x8219B284;
		  /* 8219B284h */ case    1:  		/* bl -1089596 */
		/* 8219B284h case    1:*/		regs.LR = 0x8219B288; return 0x82091248;
		/* 8219B284h case    1:*/		return 0x8219B288;
		  /* 8219B288h */ case    2:  		/* stfd FR31, <#[R1 - 80]> */
		/* 8219B288h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFB0) );
		/* 8219B288h case    2:*/		return 0x8219B28C;
		  /* 8219B28Ch */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 8219B28Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8219B28Ch case    3:*/		return 0x8219B290;
		  /* 8219B290h */ case    4:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219B290h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219B290h case    4:*/		return 0x8219B294;
		  /* 8219B294h */ case    5:  		/* mr R28, R4 */
		/* 8219B294h case    5:*/		regs.R28 = regs.R4;
		/* 8219B294h case    5:*/		return 0x8219B298;
		  /* 8219B298h */ case    6:  		/* mr R26, R6 */
		/* 8219B298h case    6:*/		regs.R26 = regs.R6;
		/* 8219B298h case    6:*/		return 0x8219B29C;
		  /* 8219B29Ch */ case    7:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219B29Ch case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219B29Ch case    7:*/		return 0x8219B2A0;
		  /* 8219B2A0h */ case    8:  		/* mr R27, R7 */
		/* 8219B2A0h case    8:*/		regs.R27 = regs.R7;
		/* 8219B2A0h case    8:*/		return 0x8219B2A4;
		  /* 8219B2A4h */ case    9:  		/* cmplwi CR6, R11, 15872 */
		/* 8219B2A4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 8219B2A4h case    9:*/		return 0x8219B2A8;
		  /* 8219B2A8h */ case   10:  		/* bc 4, CR6_EQ, 28 */
		/* 8219B2A8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8219B2C4;  }
		/* 8219B2A8h case   10:*/		return 0x8219B2AC;
		  /* 8219B2ACh */ case   11:  		/* rlwinm R11, R7, 0, 30, 30 */
		/* 8219B2ACh case   11:*/		cpu::op::rlwinm<0,0,30,30>(regs,&regs.R11,regs.R7);
		/* 8219B2ACh case   11:*/		return 0x8219B2B0;
		  /* 8219B2B0h */ case   12:  		/* subfic R11, R11, 0 */
		/* 8219B2B0h case   12:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 8219B2B0h case   12:*/		return 0x8219B2B4;
		  /* 8219B2B4h */ case   13:  		/* subfe R11, R11, R11 */
		/* 8219B2B4h case   13:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8219B2B4h case   13:*/		return 0x8219B2B8;
		  /* 8219B2B8h */ case   14:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 8219B2B8h case   14:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8219B2B8h case   14:*/		return 0x8219B2BC;
		  /* 8219B2BCh */ case   15:  		/* addi R3, R11, 1 */
		/* 8219B2BCh case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 8219B2BCh case   15:*/		return 0x8219B2C0;
		  /* 8219B2C0h */ case   16:  		/* b 132 */
		/* 8219B2C0h case   16:*/		return 0x8219B344;
		/* 8219B2C0h case   16:*/		return 0x8219B2C4;
	}
	return 0x8219B2C4;
} // Block from 8219B280h-8219B2C4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219B2C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B2C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B2C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B2C4);
		  /* 8219B2C4h */ case    0:  		/* li R24, 0 */
		/* 8219B2C4h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8219B2C4h case    0:*/		return 0x8219B2C8;
		  /* 8219B2C8h */ case    1:  		/* li R25, 0 */
		/* 8219B2C8h case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8219B2C8h case    1:*/		return 0x8219B2CC;
		  /* 8219B2CCh */ case    2:  		/* cmplwi CR6, R5, 0 */
		/* 8219B2CCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8219B2CCh case    2:*/		return 0x8219B2D0;
		  /* 8219B2D0h */ case    3:  		/* bc 12, CR6_EQ, 92 */
		/* 8219B2D0h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219B32C;  }
		/* 8219B2D0h case    3:*/		return 0x8219B2D4;
		  /* 8219B2D4h */ case    4:  		/* lis R11, -32256 */
		/* 8219B2D4h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8219B2D4h case    4:*/		return 0x8219B2D8;
		  /* 8219B2D8h */ case    5:  		/* li R31, 0 */
		/* 8219B2D8h case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8219B2D8h case    5:*/		return 0x8219B2DC;
		  /* 8219B2DCh */ case    6:  		/* mr R30, R8 */
		/* 8219B2DCh case    6:*/		regs.R30 = regs.R8;
		/* 8219B2DCh case    6:*/		return 0x8219B2E0;
		  /* 8219B2E0h */ case    7:  		/* mr R29, R5 */
		/* 8219B2E0h case    7:*/		regs.R29 = regs.R5;
		/* 8219B2E0h case    7:*/		return 0x8219B2E4;
		  /* 8219B2E4h */ case    8:  		/* lfs FR31, <#[R11 + 1816]> */
		/* 8219B2E4h case    8:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000718) );
		/* 8219B2E4h case    8:*/		return 0x8219B2E8;
		  /* 8219B2E8h */ case    9:  		/* srw R11, R26, R31 */
		/* 8219B2E8h case    9:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R26,regs.R31);
		/* 8219B2E8h case    9:*/		return 0x8219B2EC;
		  /* 8219B2ECh */ case   10:  		/* mr R5, R27 */
		/* 8219B2ECh case   10:*/		regs.R5 = regs.R27;
		/* 8219B2ECh case   10:*/		return 0x8219B2F0;
		  /* 8219B2F0h */ case   11:  		/* rlwinm R4, R11, 0, 30, 31 */
		/* 8219B2F0h case   11:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R11);
		/* 8219B2F0h case   11:*/		return 0x8219B2F4;
		  /* 8219B2F4h */ case   12:  		/* mr R3, R28 */
		/* 8219B2F4h case   12:*/		regs.R3 = regs.R28;
		/* 8219B2F4h case   12:*/		return 0x8219B2F8;
		  /* 8219B2F8h */ case   13:  		/* bl 549776 */
		/* 8219B2F8h case   13:*/		regs.LR = 0x8219B2FC; return 0x82221688;
		/* 8219B2F8h case   13:*/		return 0x8219B2FC;
		  /* 8219B2FCh */ case   14:  		/* stfs FR1, <#[R30]> */
		/* 8219B2FCh case   14:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R30 + 0x00000000) );
		/* 8219B2FCh case   14:*/		return 0x8219B300;
		  /* 8219B300h */ case   15:  		/* fcmpu CR6, FR1, FR31 */
		/* 8219B300h case   15:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 8219B300h case   15:*/		return 0x8219B304;
		  /* 8219B304h */ case   16:  		/* bc 4, CR6_LT, 12 */
		/* 8219B304h case   16:*/		if ( !regs.CR[6].lt ) { return 0x8219B310;  }
		/* 8219B304h case   16:*/		return 0x8219B308;
		  /* 8219B308h */ case   17:  		/* li R25, 1 */
		/* 8219B308h case   17:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8219B308h case   17:*/		return 0x8219B30C;
		  /* 8219B30Ch */ case   18:  		/* b 16 */
		/* 8219B30Ch case   18:*/		return 0x8219B31C;
		/* 8219B30Ch case   18:*/		return 0x8219B310;
	}
	return 0x8219B310;
} // Block from 8219B2C4h-8219B310h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8219B310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B310);
		  /* 8219B310h */ case    0:  		/* fcmpu CR6, FR1, FR31 */
		/* 8219B310h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 8219B310h case    0:*/		return 0x8219B314;
		  /* 8219B314h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 8219B314h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8219B31C;  }
		/* 8219B314h case    1:*/		return 0x8219B318;
		  /* 8219B318h */ case    2:  		/* li R24, 1 */
		/* 8219B318h case    2:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8219B318h case    2:*/		return 0x8219B31C;
	}
	return 0x8219B31C;
} // Block from 8219B310h-8219B31Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B31Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B31C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B31C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B31C);
		  /* 8219B31Ch */ case    0:  		/* addic. R29, R29, -1 */
		/* 8219B31Ch case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 8219B31Ch case    0:*/		return 0x8219B320;
		  /* 8219B320h */ case    1:  		/* addi R31, R31, 2 */
		/* 8219B320h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x2);
		/* 8219B320h case    1:*/		return 0x8219B324;
		  /* 8219B324h */ case    2:  		/* addi R30, R30, 4 */
		/* 8219B324h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8219B324h case    2:*/		return 0x8219B328;
		  /* 8219B328h */ case    3:  		/* bc 4, CR0_EQ, -64 */
		/* 8219B328h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219B2E8;  }
		/* 8219B328h case    3:*/		return 0x8219B32C;
	}
	return 0x8219B32C;
} // Block from 8219B31Ch-8219B32Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219B32Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B32C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B32C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B32C);
		  /* 8219B32Ch */ case    0:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 8219B32Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 8219B32Ch case    0:*/		return 0x8219B330;
		  /* 8219B330h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219B330h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219B340;  }
		/* 8219B330h case    1:*/		return 0x8219B334;
		  /* 8219B334h */ case    2:  		/* rlwinm. R11, R24, 0, 24, 31 */
		/* 8219B334h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R24);
		/* 8219B334h case    2:*/		return 0x8219B338;
		  /* 8219B338h */ case    3:  		/* li R3, 1 */
		/* 8219B338h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219B338h case    3:*/		return 0x8219B33C;
		  /* 8219B33Ch */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 8219B33Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219B344;  }
		/* 8219B33Ch case    4:*/		return 0x8219B340;
	}
	return 0x8219B340;
} // Block from 8219B32Ch-8219B340h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219B340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B340);
		  /* 8219B340h */ case    0:  		/* li R3, 2 */
		/* 8219B340h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8219B340h case    0:*/		return 0x8219B344;
	}
	return 0x8219B344;
} // Block from 8219B340h-8219B344h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B344);
		  /* 8219B344h */ case    0:  		/* addi R1, R1, 160 */
		/* 8219B344h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8219B344h case    0:*/		return 0x8219B348;
		  /* 8219B348h */ case    1:  		/* lfd FR31, <#[R1 - 80]> */
		/* 8219B348h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFB0) );
		/* 8219B348h case    1:*/		return 0x8219B34C;
		  /* 8219B34Ch */ case    2:  		/* b -1089716 */
		/* 8219B34Ch case    2:*/		return 0x82091298;
		/* 8219B34Ch case    2:*/		return 0x8219B350;
		  /* 8219B350h */ case    3:  		/* lis R8, -32256 */
		/* 8219B350h case    3:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 8219B350h case    3:*/		return 0x8219B354;
		  /* 8219B354h */ case    4:  		/* mr R11, R6 */
		/* 8219B354h case    4:*/		regs.R11 = regs.R6;
		/* 8219B354h case    4:*/		return 0x8219B358;
		  /* 8219B358h */ case    5:  		/* li R9, 0 */
		/* 8219B358h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219B358h case    5:*/		return 0x8219B35C;
		  /* 8219B35Ch */ case    6:  		/* li R10, 0 */
		/* 8219B35Ch case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219B35Ch case    6:*/		return 0x8219B360;
		  /* 8219B360h */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 8219B360h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8219B360h case    7:*/		return 0x8219B364;
		  /* 8219B364h */ case    8:  		/* lfs FR0, <#[R8 + 1816]> */
		/* 8219B364h case    8:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R8 + 0x00000718) );
		/* 8219B364h case    8:*/		return 0x8219B368;
		  /* 8219B368h */ case    9:  		/* bc 12, CR6_EQ, 48 */
		/* 8219B368h case    9:*/		if ( regs.CR[6].eq ) { return 0x8219B398;  }
		/* 8219B368h case    9:*/		return 0x8219B36C;
		  /* 8219B36Ch */ case   10:  		/* mtspr CTR, R5 */
		/* 8219B36Ch case   10:*/		regs.CTR = regs.R5;
		/* 8219B36Ch case   10:*/		return 0x8219B370;
		  /* 8219B370h */ case   11:  		/* lfs FR13, <#[R4]> */
		/* 8219B370h case   11:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R4 + 0x00000000) );
		/* 8219B370h case   11:*/		return 0x8219B374;
		  /* 8219B374h */ case   12:  		/* fcmpu CR6, FR13, FR0 */
		/* 8219B374h case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 8219B374h case   12:*/		return 0x8219B378;
		  /* 8219B378h */ case   13:  		/* bc 4, CR6_LT, 12 */
		/* 8219B378h case   13:*/		if ( !regs.CR[6].lt ) { return 0x8219B384;  }
		/* 8219B378h case   13:*/		return 0x8219B37C;
		  /* 8219B37Ch */ case   14:  		/* li R10, 1 */
		/* 8219B37Ch case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219B37Ch case   14:*/		return 0x8219B380;
		  /* 8219B380h */ case   15:  		/* b 16 */
		/* 8219B380h case   15:*/		return 0x8219B390;
		/* 8219B380h case   15:*/		return 0x8219B384;
	}
	return 0x8219B384;
} // Block from 8219B344h-8219B384h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219B384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B384);
		  /* 8219B384h */ case    0:  		/* fcmpu CR6, FR13, FR0 */
		/* 8219B384h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 8219B384h case    0:*/		return 0x8219B388;
		  /* 8219B388h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 8219B388h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8219B390;  }
		/* 8219B388h case    1:*/		return 0x8219B38C;
		  /* 8219B38Ch */ case    2:  		/* li R9, 1 */
		/* 8219B38Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8219B38Ch case    2:*/		return 0x8219B390;
	}
	return 0x8219B390;
} // Block from 8219B384h-8219B390h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B390);
		  /* 8219B390h */ case    0:  		/* addi R4, R4, 4 */
		/* 8219B390h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 8219B390h case    0:*/		return 0x8219B394;
		  /* 8219B394h */ case    1:  		/* bc 16, CR0_LT, -36 */
		/* 8219B394h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8219B370;  }
		/* 8219B394h case    1:*/		return 0x8219B398;
	}
	return 0x8219B398;
} // Block from 8219B390h-8219B398h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B398);
		  /* 8219B398h */ case    0:  		/* cmplwi CR6, R7, 0 */
		/* 8219B398h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8219B398h case    0:*/		return 0x8219B39C;
		  /* 8219B39Ch */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 8219B39Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8219B3CC;  }
		/* 8219B39Ch case    1:*/		return 0x8219B3A0;
		  /* 8219B3A0h */ case    2:  		/* mtspr CTR, R7 */
		/* 8219B3A0h case    2:*/		regs.CTR = regs.R7;
		/* 8219B3A0h case    2:*/		return 0x8219B3A4;
		  /* 8219B3A4h */ case    3:  		/* lfs FR13, <#[R11]> */
		/* 8219B3A4h case    3:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000000) );
		/* 8219B3A4h case    3:*/		return 0x8219B3A8;
		  /* 8219B3A8h */ case    4:  		/* fcmpu CR6, FR13, FR0 */
		/* 8219B3A8h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 8219B3A8h case    4:*/		return 0x8219B3AC;
		  /* 8219B3ACh */ case    5:  		/* bc 4, CR6_LT, 12 */
		/* 8219B3ACh case    5:*/		if ( !regs.CR[6].lt ) { return 0x8219B3B8;  }
		/* 8219B3ACh case    5:*/		return 0x8219B3B0;
		  /* 8219B3B0h */ case    6:  		/* li R10, 1 */
		/* 8219B3B0h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219B3B0h case    6:*/		return 0x8219B3B4;
		  /* 8219B3B4h */ case    7:  		/* b 16 */
		/* 8219B3B4h case    7:*/		return 0x8219B3C4;
		/* 8219B3B4h case    7:*/		return 0x8219B3B8;
	}
	return 0x8219B3B8;
} // Block from 8219B398h-8219B3B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219B3B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B3B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B3B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B3B8);
		  /* 8219B3B8h */ case    0:  		/* fcmpu CR6, FR13, FR0 */
		/* 8219B3B8h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 8219B3B8h case    0:*/		return 0x8219B3BC;
		  /* 8219B3BCh */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 8219B3BCh case    1:*/		if ( !regs.CR[6].gt ) { return 0x8219B3C4;  }
		/* 8219B3BCh case    1:*/		return 0x8219B3C0;
		  /* 8219B3C0h */ case    2:  		/* li R9, 1 */
		/* 8219B3C0h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8219B3C0h case    2:*/		return 0x8219B3C4;
	}
	return 0x8219B3C4;
} // Block from 8219B3B8h-8219B3C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B3C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B3C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B3C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B3C4);
		  /* 8219B3C4h */ case    0:  		/* addi R11, R11, 4 */
		/* 8219B3C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219B3C4h case    0:*/		return 0x8219B3C8;
		  /* 8219B3C8h */ case    1:  		/* bc 16, CR0_LT, -36 */
		/* 8219B3C8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8219B3A4;  }
		/* 8219B3C8h case    1:*/		return 0x8219B3CC;
	}
	return 0x8219B3CC;
} // Block from 8219B3C4h-8219B3CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B3CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B3CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B3CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B3CC);
		  /* 8219B3CCh */ case    0:  		/* rlwinm. R11, R10, 0, 24, 31 */
		/* 8219B3CCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R10);
		/* 8219B3CCh case    0:*/		return 0x8219B3D0;
		  /* 8219B3D0h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219B3D0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219B3E0;  }
		/* 8219B3D0h case    1:*/		return 0x8219B3D4;
		  /* 8219B3D4h */ case    2:  		/* rlwinm. R11, R9, 0, 24, 31 */
		/* 8219B3D4h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R9);
		/* 8219B3D4h case    2:*/		return 0x8219B3D8;
		  /* 8219B3D8h */ case    3:  		/* li R3, 1 */
		/* 8219B3D8h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219B3D8h case    3:*/		return 0x8219B3DC;
		  /* 8219B3DCh */ case    4:  		/* bclr 4, CR0_EQ */
		/* 8219B3DCh case    4:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8219B3DCh case    4:*/		return 0x8219B3E0;
	}
	return 0x8219B3E0;
} // Block from 8219B3CCh-8219B3E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219B3E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B3E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B3E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B3E0);
		  /* 8219B3E0h */ case    0:  		/* li R3, 2 */
		/* 8219B3E0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 8219B3E0h case    0:*/		return 0x8219B3E4;
		  /* 8219B3E4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8219B3E4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219B3E4h case    1:*/		return 0x8219B3E8;
	}
	return 0x8219B3E8;
} // Block from 8219B3E0h-8219B3E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B3E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B3E8);
		  /* 8219B3E8h */ case    0:  		/* mfspr R12, LR */
		/* 8219B3E8h case    0:*/		regs.R12 = regs.LR;
		/* 8219B3E8h case    0:*/		return 0x8219B3EC;
		  /* 8219B3ECh */ case    1:  		/* bl -1089956 */
		/* 8219B3ECh case    1:*/		regs.LR = 0x8219B3F0; return 0x82091248;
		/* 8219B3ECh case    1:*/		return 0x8219B3F0;
		  /* 8219B3F0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8219B3F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8219B3F0h case    2:*/		return 0x8219B3F4;
		  /* 8219B3F4h */ case    3:  		/* lwz R11, <#[R4]> */
		/* 8219B3F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8219B3F4h case    3:*/		return 0x8219B3F8;
		  /* 8219B3F8h */ case    4:  		/* mr R31, R6 */
		/* 8219B3F8h case    4:*/		regs.R31 = regs.R6;
		/* 8219B3F8h case    4:*/		return 0x8219B3FC;
		  /* 8219B3FCh */ case    5:  		/* mr R29, R7 */
		/* 8219B3FCh case    5:*/		regs.R29 = regs.R7;
		/* 8219B3FCh case    5:*/		return 0x8219B400;
		  /* 8219B400h */ case    6:  		/* mr R26, R8 */
		/* 8219B400h case    6:*/		regs.R26 = regs.R8;
		/* 8219B400h case    6:*/		return 0x8219B404;
		  /* 8219B404h */ case    7:  		/* mr R25, R9 */
		/* 8219B404h case    7:*/		regs.R25 = regs.R9;
		/* 8219B404h case    7:*/		return 0x8219B408;
		  /* 8219B408h */ case    8:  		/* mr R24, R10 */
		/* 8219B408h case    8:*/		regs.R24 = regs.R10;
		/* 8219B408h case    8:*/		return 0x8219B40C;
		  /* 8219B40Ch */ case    9:  		/* li R30, 0 */
		/* 8219B40Ch case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8219B40Ch case    9:*/		return 0x8219B410;
		  /* 8219B410h */ case   10:  		/* li R28, 0 */
		/* 8219B410h case   10:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8219B410h case   10:*/		return 0x8219B414;
		  /* 8219B414h */ case   11:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 8219B414h case   11:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 8219B414h case   11:*/		return 0x8219B418;
		  /* 8219B418h */ case   12:  		/* li R27, -1 */
		/* 8219B418h case   12:*/		cpu::op::li<0>(regs,&regs.R27,0xFFFFFFFF);
		/* 8219B418h case   12:*/		return 0x8219B41C;
		  /* 8219B41Ch */ case   13:  		/* bc 12, CR0_EQ, 76 */
		/* 8219B41Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x8219B468;  }
		/* 8219B41Ch case   13:*/		return 0x8219B420;
		  /* 8219B420h */ case   14:  		/* lwz R10, <#[R4 + 12]> */
		/* 8219B420h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000000C) );
		/* 8219B420h case   14:*/		return 0x8219B424;
		  /* 8219B424h */ case   15:  		/* lwz R10, <#[R10 + 8]> */
		/* 8219B424h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8219B424h case   15:*/		return 0x8219B428;
		  /* 8219B428h */ case   16:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 8219B428h case   16:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 8219B428h case   16:*/		return 0x8219B42C;
		  /* 8219B42Ch */ case   17:  		/* cmplwi CR6, R10, 125 */
		/* 8219B42Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007D);
		/* 8219B42Ch case   17:*/		return 0x8219B430;
		  /* 8219B430h */ case   18:  		/* bc 12, CR6_EQ, 16 */
		/* 8219B430h case   18:*/		if ( regs.CR[6].eq ) { return 0x8219B440;  }
		/* 8219B430h case   18:*/		return 0x8219B434;
		  /* 8219B434h */ case   19:  		/* cmplwi CR6, R10, 124 */
		/* 8219B434h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 8219B434h case   19:*/		return 0x8219B438;
		  /* 8219B438h */ case   20:  		/* li R10, 0 */
		/* 8219B438h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219B438h case   20:*/		return 0x8219B43C;
		  /* 8219B43Ch */ case   21:  		/* bc 4, CR6_EQ, 8 */
		/* 8219B43Ch case   21:*/		if ( !regs.CR[6].eq ) { return 0x8219B444;  }
		/* 8219B43Ch case   21:*/		return 0x8219B440;
	}
	return 0x8219B440;
} // Block from 8219B3E8h-8219B440h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8219B440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B440);
		  /* 8219B440h */ case    0:  		/* li R10, 1 */
		/* 8219B440h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219B440h case    0:*/		return 0x8219B444;
	}
	return 0x8219B444;
} // Block from 8219B440h-8219B444h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B444);
		  /* 8219B444h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8219B444h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8219B444h case    0:*/		return 0x8219B448;
		  /* 8219B448h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8219B448h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219B454;  }
		/* 8219B448h case    1:*/		return 0x8219B44C;
		  /* 8219B44Ch */ case    2:  		/* mr R28, R11 */
		/* 8219B44Ch case    2:*/		regs.R28 = regs.R11;
		/* 8219B44Ch case    2:*/		return 0x8219B450;
		  /* 8219B450h */ case    3:  		/* mr R27, R11 */
		/* 8219B450h case    3:*/		regs.R27 = regs.R11;
		/* 8219B450h case    3:*/		return 0x8219B454;
	}
	return 0x8219B454;
} // Block from 8219B444h-8219B454h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219B454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B454);
		  /* 8219B454h */ case    0:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 8219B454h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 8219B454h case    0:*/		return 0x8219B458;
		  /* 8219B458h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219B458h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219B468;  }
		/* 8219B458h case    1:*/		return 0x8219B45C;
		  /* 8219B45Ch */ case    2:  		/* mr R3, R5 */
		/* 8219B45Ch case    2:*/		regs.R3 = regs.R5;
		/* 8219B45Ch case    2:*/		return 0x8219B460;
		  /* 8219B460h */ case    3:  		/* bl -145736 */
		/* 8219B460h case    3:*/		regs.LR = 0x8219B464; return 0x82177B18;
		/* 8219B460h case    3:*/		return 0x8219B464;
		  /* 8219B464h */ case    4:  		/* mr R30, R3 */
		/* 8219B464h case    4:*/		regs.R30 = regs.R3;
		/* 8219B464h case    4:*/		return 0x8219B468;
	}
	return 0x8219B468;
} // Block from 8219B454h-8219B468h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219B468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B468);
		  /* 8219B468h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8219B468h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219B468h case    0:*/		return 0x8219B46C;
		  /* 8219B46Ch */ case    1:  		/* rlwinm. R10, R11, 0, 27, 28 */
		/* 8219B46Ch case    1:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R11);
		/* 8219B46Ch case    1:*/		return 0x8219B470;
		  /* 8219B470h */ case    2:  		/* bc 12, CR0_EQ, 100 */
		/* 8219B470h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219B4D4;  }
		/* 8219B470h case    2:*/		return 0x8219B474;
		  /* 8219B474h */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 8219B474h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219B474h case    3:*/		return 0x8219B478;
		  /* 8219B478h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219B478h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219B478h case    4:*/		return 0x8219B47C;
		  /* 8219B47Ch */ case    5:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219B47Ch case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219B47Ch case    5:*/		return 0x8219B480;
		  /* 8219B480h */ case    6:  		/* cmplwi CR6, R11, 125 */
		/* 8219B480h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219B480h case    6:*/		return 0x8219B484;
		  /* 8219B484h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 8219B484h case    7:*/		if ( regs.CR[6].eq ) { return 0x8219B494;  }
		/* 8219B484h case    7:*/		return 0x8219B488;
		  /* 8219B488h */ case    8:  		/* cmplwi CR6, R11, 124 */
		/* 8219B488h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219B488h case    8:*/		return 0x8219B48C;
		  /* 8219B48Ch */ case    9:  		/* li R11, 0 */
		/* 8219B48Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219B48Ch case    9:*/		return 0x8219B490;
		  /* 8219B490h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 8219B490h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8219B498;  }
		/* 8219B490h case   10:*/		return 0x8219B494;
	}
	return 0x8219B494;
} // Block from 8219B468h-8219B494h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219B494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B494);
		  /* 8219B494h */ case    0:  		/* li R11, 1 */
		/* 8219B494h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219B494h case    0:*/		return 0x8219B498;
	}
	return 0x8219B498;
} // Block from 8219B494h-8219B498h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B498);
		  /* 8219B498h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219B498h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219B498h case    0:*/		return 0x8219B49C;
		  /* 8219B49Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8219B49Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219B4A8;  }
		/* 8219B49Ch case    1:*/		return 0x8219B4A0;
		  /* 8219B4A0h */ case    2:  		/* or R28, R10, R28 */
		/* 8219B4A0h case    2:*/		cpu::op::or<0>(regs,&regs.R28,regs.R10,regs.R28);
		/* 8219B4A0h case    2:*/		return 0x8219B4A4;
		  /* 8219B4A4h */ case    3:  		/* and R27, R10, R27 */
		/* 8219B4A4h case    3:*/		cpu::op::and<0>(regs,&regs.R27,regs.R10,regs.R27);
		/* 8219B4A4h case    3:*/		return 0x8219B4A8;
	}
	return 0x8219B4A8;
} // Block from 8219B498h-8219B4A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219B4A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B4A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B4A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B4A8);
		  /* 8219B4A8h */ case    0:  		/* rlwinm. R11, R10, 0, 28, 28 */
		/* 8219B4A8h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R10);
		/* 8219B4A8h case    0:*/		return 0x8219B4AC;
		  /* 8219B4ACh */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 8219B4ACh case    1:*/		if ( regs.CR[0].eq ) { return 0x8219B4D4;  }
		/* 8219B4ACh case    1:*/		return 0x8219B4B0;
		  /* 8219B4B0h */ case    2:  		/* mr R3, R29 */
		/* 8219B4B0h case    2:*/		regs.R3 = regs.R29;
		/* 8219B4B0h case    2:*/		return 0x8219B4B4;
		  /* 8219B4B4h */ case    3:  		/* bl -145820 */
		/* 8219B4B4h case    3:*/		regs.LR = 0x8219B4B8; return 0x82177B18;
		/* 8219B4B4h case    3:*/		return 0x8219B4B8;
		  /* 8219B4B8h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 8219B4B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219B4B8h case    4:*/		return 0x8219B4BC;
		  /* 8219B4BCh */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 8219B4BCh case    5:*/		if ( regs.CR[6].eq ) { return 0x8219B4D0;  }
		/* 8219B4BCh case    5:*/		return 0x8219B4C0;
		  /* 8219B4C0h */ case    6:  		/* cmplw CR6, R3, R30 */
		/* 8219B4C0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R30);
		/* 8219B4C0h case    6:*/		return 0x8219B4C4;
		  /* 8219B4C4h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 8219B4C4h case    7:*/		if ( regs.CR[6].eq ) { return 0x8219B4D0;  }
		/* 8219B4C4h case    7:*/		return 0x8219B4C8;
		  /* 8219B4C8h */ case    8:  		/* li R3, 0 */
		/* 8219B4C8h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219B4C8h case    8:*/		return 0x8219B4CC;
		  /* 8219B4CCh */ case    9:  		/* b 132 */
		/* 8219B4CCh case    9:*/		return 0x8219B550;
		/* 8219B4CCh case    9:*/		return 0x8219B4D0;
	}
	return 0x8219B4D0;
} // Block from 8219B4A8h-8219B4D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219B4D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B4D0);
		  /* 8219B4D0h */ case    0:  		/* mr R30, R3 */
		/* 8219B4D0h case    0:*/		regs.R30 = regs.R3;
		/* 8219B4D0h case    0:*/		return 0x8219B4D4;
	}
	return 0x8219B4D4;
} // Block from 8219B4D0h-8219B4D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B4D4);
		  /* 8219B4D4h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 8219B4D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8219B4D4h case    0:*/		return 0x8219B4D8;
		  /* 8219B4D8h */ case    1:  		/* rlwinm. R10, R11, 0, 27, 28 */
		/* 8219B4D8h case    1:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R11);
		/* 8219B4D8h case    1:*/		return 0x8219B4DC;
		  /* 8219B4DCh */ case    2:  		/* bc 12, CR0_EQ, 92 */
		/* 8219B4DCh case    2:*/		if ( regs.CR[0].eq ) { return 0x8219B538;  }
		/* 8219B4DCh case    2:*/		return 0x8219B4E0;
		  /* 8219B4E0h */ case    3:  		/* lwz R11, <#[R26 + 12]> */
		/* 8219B4E0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000C) );
		/* 8219B4E0h case    3:*/		return 0x8219B4E4;
		  /* 8219B4E4h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219B4E4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219B4E4h case    4:*/		return 0x8219B4E8;
		  /* 8219B4E8h */ case    5:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219B4E8h case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219B4E8h case    5:*/		return 0x8219B4EC;
		  /* 8219B4ECh */ case    6:  		/* cmplwi CR6, R11, 125 */
		/* 8219B4ECh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219B4ECh case    6:*/		return 0x8219B4F0;
		  /* 8219B4F0h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 8219B4F0h case    7:*/		if ( regs.CR[6].eq ) { return 0x8219B500;  }
		/* 8219B4F0h case    7:*/		return 0x8219B4F4;
		  /* 8219B4F4h */ case    8:  		/* cmplwi CR6, R11, 124 */
		/* 8219B4F4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219B4F4h case    8:*/		return 0x8219B4F8;
		  /* 8219B4F8h */ case    9:  		/* li R11, 0 */
		/* 8219B4F8h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219B4F8h case    9:*/		return 0x8219B4FC;
		  /* 8219B4FCh */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 8219B4FCh case   10:*/		if ( !regs.CR[6].eq ) { return 0x8219B504;  }
		/* 8219B4FCh case   10:*/		return 0x8219B500;
	}
	return 0x8219B500;
} // Block from 8219B4D4h-8219B500h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219B500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B500);
		  /* 8219B500h */ case    0:  		/* li R11, 1 */
		/* 8219B500h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219B500h case    0:*/		return 0x8219B504;
	}
	return 0x8219B504;
} // Block from 8219B500h-8219B504h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B504);
		  /* 8219B504h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219B504h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219B504h case    0:*/		return 0x8219B508;
		  /* 8219B508h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8219B508h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219B514;  }
		/* 8219B508h case    1:*/		return 0x8219B50C;
		  /* 8219B50Ch */ case    2:  		/* or R28, R10, R28 */
		/* 8219B50Ch case    2:*/		cpu::op::or<0>(regs,&regs.R28,regs.R10,regs.R28);
		/* 8219B50Ch case    2:*/		return 0x8219B510;
		  /* 8219B510h */ case    3:  		/* and R27, R10, R27 */
		/* 8219B510h case    3:*/		cpu::op::and<0>(regs,&regs.R27,regs.R10,regs.R27);
		/* 8219B510h case    3:*/		return 0x8219B514;
	}
	return 0x8219B514;
} // Block from 8219B504h-8219B514h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219B514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B514);
		  /* 8219B514h */ case    0:  		/* rlwinm. R11, R10, 0, 28, 28 */
		/* 8219B514h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R10);
		/* 8219B514h case    0:*/		return 0x8219B518;
		  /* 8219B518h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 8219B518h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219B538;  }
		/* 8219B518h case    1:*/		return 0x8219B51C;
		  /* 8219B51Ch */ case    2:  		/* mr R3, R25 */
		/* 8219B51Ch case    2:*/		regs.R3 = regs.R25;
		/* 8219B51Ch case    2:*/		return 0x8219B520;
		  /* 8219B520h */ case    3:  		/* bl -145928 */
		/* 8219B520h case    3:*/		regs.LR = 0x8219B524; return 0x82177B18;
		/* 8219B520h case    3:*/		return 0x8219B524;
		  /* 8219B524h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 8219B524h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219B524h case    4:*/		return 0x8219B528;
		  /* 8219B528h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8219B528h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219B534;  }
		/* 8219B528h case    5:*/		return 0x8219B52C;
		  /* 8219B52Ch */ case    6:  		/* cmplw CR6, R3, R30 */
		/* 8219B52Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R30);
		/* 8219B52Ch case    6:*/		return 0x8219B530;
		  /* 8219B530h */ case    7:  		/* bc 4, CR6_EQ, -104 */
		/* 8219B530h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8219B4C8;  }
		/* 8219B530h case    7:*/		return 0x8219B534;
	}
	return 0x8219B534;
} // Block from 8219B514h-8219B534h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219B534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B534);
		  /* 8219B534h */ case    0:  		/* mr R30, R3 */
		/* 8219B534h case    0:*/		regs.R30 = regs.R3;
		/* 8219B534h case    0:*/		return 0x8219B538;
	}
	return 0x8219B538;
} // Block from 8219B534h-8219B538h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B538);
		  /* 8219B538h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 8219B538h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8219B538h case    0:*/		return 0x8219B53C;
		  /* 8219B53Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8219B53Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8219B548;  }
		/* 8219B53Ch case    1:*/		return 0x8219B540;
		  /* 8219B540h */ case    2:  		/* cmplw CR6, R28, R27 */
		/* 8219B540h case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R27);
		/* 8219B540h case    2:*/		return 0x8219B544;
		  /* 8219B544h */ case    3:  		/* bc 4, CR6_EQ, -124 */
		/* 8219B544h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219B4C8;  }
		/* 8219B544h case    3:*/		return 0x8219B548;
	}
	return 0x8219B548;
} // Block from 8219B538h-8219B548h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219B548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B548);
		  /* 8219B548h */ case    0:  		/* stw R30, <#[R24]> */
		/* 8219B548h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R24 + 0x00000000) );
		/* 8219B548h case    0:*/		return 0x8219B54C;
		  /* 8219B54Ch */ case    1:  		/* li R3, 1 */
		/* 8219B54Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219B54Ch case    1:*/		return 0x8219B550;
	}
	return 0x8219B550;
} // Block from 8219B548h-8219B550h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B550);
		  /* 8219B550h */ case    0:  		/* addi R1, R1, 160 */
		/* 8219B550h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8219B550h case    0:*/		return 0x8219B554;
		  /* 8219B554h */ case    1:  		/* b -1090236 */
		/* 8219B554h case    1:*/		return 0x82091298;
		/* 8219B554h case    1:*/		return 0x8219B558;
	}
	return 0x8219B558;
} // Block from 8219B550h-8219B558h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B558);
		  /* 8219B558h */ case    0:  		/* mfspr R12, LR */
		/* 8219B558h case    0:*/		regs.R12 = regs.LR;
		/* 8219B558h case    0:*/		return 0x8219B55C;
		  /* 8219B55Ch */ case    1:  		/* bl -1090316 */
		/* 8219B55Ch case    1:*/		regs.LR = 0x8219B560; return 0x82091250;
		/* 8219B55Ch case    1:*/		return 0x8219B560;
		  /* 8219B560h */ case    2:  		/* li R3, 0 */
		/* 8219B560h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219B560h case    2:*/		return 0x8219B564;
		  /* 8219B564h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 8219B564h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8219B564h case    3:*/		return 0x8219B568;
		  /* 8219B568h */ case    4:  		/* bc 12, CR6_EQ, 128 */
		/* 8219B568h case    4:*/		if ( regs.CR[6].eq ) { return 0x8219B5E8;  }
		/* 8219B568h case    4:*/		return 0x8219B56C;
		  /* 8219B56Ch */ case    5:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219B56Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219B56Ch case    5:*/		return 0x8219B570;
		  /* 8219B570h */ case    6:  		/* addi R29, R4, 44 */
		/* 8219B570h case    6:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R4,0x2C);
		/* 8219B570h case    6:*/		return 0x8219B574;
		  /* 8219B574h */ case    7:  		/* li R28, 0 */
		/* 8219B574h case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8219B574h case    7:*/		return 0x8219B578;
		  /* 8219B578h */ case    8:  		/* rlwinm R27, R11, 13, 29, 31 */
		/* 8219B578h case    8:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R27,regs.R11);
		/* 8219B578h case    8:*/		return 0x8219B57C;
		  /* 8219B57Ch */ case    9:  		/* mr R30, R29 */
		/* 8219B57Ch case    9:*/		regs.R30 = regs.R29;
		/* 8219B57Ch case    9:*/		return 0x8219B580;
		  /* 8219B580h */ case   10:  		/* cmplw CR6, R28, R27 */
		/* 8219B580h case   10:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R27);
		/* 8219B580h case   10:*/		return 0x8219B584;
		  /* 8219B584h */ case   11:  		/* bc 4, CR6_LT, 108 */
		/* 8219B584h case   11:*/		if ( !regs.CR[6].lt ) { return 0x8219B5F0;  }
		/* 8219B584h case   11:*/		return 0x8219B588;
		  /* 8219B588h */ case   12:  		/* lwz R10, <#[R30]> */
		/* 8219B588h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8219B588h case   12:*/		return 0x8219B58C;
		  /* 8219B58Ch */ case   13:  		/* li R8, 0 */
		/* 8219B58Ch case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8219B58Ch case   13:*/		return 0x8219B590;
		  /* 8219B590h */ case   14:  		/* mr R9, R29 */
		/* 8219B590h case   14:*/		regs.R9 = regs.R29;
		/* 8219B590h case   14:*/		return 0x8219B594;
		  /* 8219B594h */ case   15:  		/* lwz R31, <#[R10 + 12]> */
		/* 8219B594h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219B594h case   15:*/		return 0x8219B598;
		  /* 8219B598h */ case   16:  		/* cmplw CR6, R8, R27 */
		/* 8219B598h case   16:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R27);
		/* 8219B598h case   16:*/		return 0x8219B59C;
		  /* 8219B59Ch */ case   17:  		/* bc 4, CR6_LT, 40 */
		/* 8219B59Ch case   17:*/		if ( !regs.CR[6].lt ) { return 0x8219B5C4;  }
		/* 8219B59Ch case   17:*/		return 0x8219B5A0;
		  /* 8219B5A0h */ case   18:  		/* lwz R11, <#[R9]> */
		/* 8219B5A0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8219B5A0h case   18:*/		return 0x8219B5A4;
		  /* 8219B5A4h */ case   19:  		/* cmplw CR6, R10, R11 */
		/* 8219B5A4h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8219B5A4h case   19:*/		return 0x8219B5A8;
		  /* 8219B5A8h */ case   20:  		/* bc 12, CR6_EQ, 40 */
		/* 8219B5A8h case   20:*/		if ( regs.CR[6].eq ) { return 0x8219B5D0;  }
		/* 8219B5A8h case   20:*/		return 0x8219B5AC;
		  /* 8219B5ACh */ case   21:  		/* lwz R26, <#[R11 + 12]> */
		/* 8219B5ACh case   21:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219B5ACh case   21:*/		return 0x8219B5B0;
		  /* 8219B5B0h */ case   22:  		/* cmplw CR6, R26, R31 */
		/* 8219B5B0h case   22:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R31);
		/* 8219B5B0h case   22:*/		return 0x8219B5B4;
		  /* 8219B5B4h */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 8219B5B4h case   23:*/		if ( regs.CR[6].eq ) { return 0x8219B5C8;  }
		/* 8219B5B4h case   23:*/		return 0x8219B5B8;
		  /* 8219B5B8h */ case   24:  		/* addi R8, R8, 1 */
		/* 8219B5B8h case   24:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8219B5B8h case   24:*/		return 0x8219B5BC;
		  /* 8219B5BCh */ case   25:  		/* addi R9, R9, 4 */
		/* 8219B5BCh case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8219B5BCh case   25:*/		return 0x8219B5C0;
		  /* 8219B5C0h */ case   26:  		/* b -40 */
		/* 8219B5C0h case   26:*/		return 0x8219B598;
		/* 8219B5C0h case   26:*/		return 0x8219B5C4;
	}
	return 0x8219B5C4;
} // Block from 8219B558h-8219B5C4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8219B5C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B5C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B5C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B5C4);
		  /* 8219B5C4h */ case    0:  		/* li R11, 0 */
		/* 8219B5C4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219B5C4h case    0:*/		return 0x8219B5C8;
	}
	return 0x8219B5C8;
} // Block from 8219B5C4h-8219B5C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B5C8);
		  /* 8219B5C8h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 8219B5C8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8219B5C8h case    0:*/		return 0x8219B5CC;
		  /* 8219B5CCh */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8219B5CCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219B5DC;  }
		/* 8219B5CCh case    1:*/		return 0x8219B5D0;
	}
	return 0x8219B5D0;
} // Block from 8219B5C8h-8219B5D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B5D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B5D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B5D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B5D0);
		  /* 8219B5D0h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219B5D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219B5D0h case    0:*/		return 0x8219B5D4;
		  /* 8219B5D4h */ case    1:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 8219B5D4h case    1:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 8219B5D4h case    1:*/		return 0x8219B5D8;
		  /* 8219B5D8h */ case    2:  		/* add R3, R11, R3 */
		/* 8219B5D8h case    2:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 8219B5D8h case    2:*/		return 0x8219B5DC;
	}
	return 0x8219B5DC;
} // Block from 8219B5D0h-8219B5DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B5DC);
		  /* 8219B5DCh */ case    0:  		/* addi R28, R28, 1 */
		/* 8219B5DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8219B5DCh case    0:*/		return 0x8219B5E0;
		  /* 8219B5E0h */ case    1:  		/* addi R30, R30, 4 */
		/* 8219B5E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8219B5E0h case    1:*/		return 0x8219B5E4;
		  /* 8219B5E4h */ case    2:  		/* b -100 */
		/* 8219B5E4h case    2:*/		return 0x8219B580;
		/* 8219B5E4h case    2:*/		return 0x8219B5E8;
	}
	return 0x8219B5E8;
} // Block from 8219B5DCh-8219B5E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B5E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B5E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B5E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B5E8);
		  /* 8219B5E8h */ case    0:  		/* lwz R11, <#[R5 + 8]> */
		/* 8219B5E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 8219B5E8h case    0:*/		return 0x8219B5EC;
		  /* 8219B5ECh */ case    1:  		/* rlwinm R3, R11, 18, 29, 31 */
		/* 8219B5ECh case    1:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R3,regs.R11);
		/* 8219B5ECh case    1:*/		return 0x8219B5F0;
	}
	return 0x8219B5F0;
} // Block from 8219B5E8h-8219B5F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B5F0);
		  /* 8219B5F0h */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 8219B5F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8219B5F0h case    0:*/		return 0x8219B5F4;
		  /* 8219B5F4h */ case    1:  		/* bc 12, CR6_EQ, 196 */
		/* 8219B5F4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219B6B8;  }
		/* 8219B5F4h case    1:*/		return 0x8219B5F8;
		  /* 8219B5F8h */ case    2:  		/* lwz R11, <#[R6 + 8]> */
		/* 8219B5F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 8219B5F8h case    2:*/		return 0x8219B5FC;
		  /* 8219B5FCh */ case    3:  		/* addi R31, R6, 44 */
		/* 8219B5FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R6,0x2C);
		/* 8219B5FCh case    3:*/		return 0x8219B600;
		  /* 8219B600h */ case    4:  		/* li R30, 0 */
		/* 8219B600h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8219B600h case    4:*/		return 0x8219B604;
		  /* 8219B604h */ case    5:  		/* rlwinm R29, R11, 13, 29, 31 */
		/* 8219B604h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R29,regs.R11);
		/* 8219B604h case    5:*/		return 0x8219B608;
		  /* 8219B608h */ case    6:  		/* mr R6, R31 */
		/* 8219B608h case    6:*/		regs.R6 = regs.R31;
		/* 8219B608h case    6:*/		return 0x8219B60C;
		  /* 8219B60Ch */ case    7:  		/* cmplw CR6, R30, R29 */
		/* 8219B60Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 8219B60Ch case    7:*/		return 0x8219B610;
		  /* 8219B610h */ case    8:  		/* bc 4, CR6_LT, 188 */
		/* 8219B610h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8219B6CC;  }
		/* 8219B610h case    8:*/		return 0x8219B614;
		  /* 8219B614h */ case    9:  		/* lwz R8, <#[R6]> */
		/* 8219B614h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R6 + 0x00000000) );
		/* 8219B614h case    9:*/		return 0x8219B618;
		  /* 8219B618h */ case   10:  		/* lwz R7, <#[R8 + 12]> */
		/* 8219B618h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x0000000C) );
		/* 8219B618h case   10:*/		return 0x8219B61C;
		  /* 8219B61Ch */ case   11:  		/* cmplw CR6, R7, R5 */
		/* 8219B61Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R5);
		/* 8219B61Ch case   11:*/		return 0x8219B620;
		  /* 8219B620h */ case   12:  		/* bc 12, CR6_EQ, 140 */
		/* 8219B620h case   12:*/		if ( regs.CR[6].eq ) { return 0x8219B6AC;  }
		/* 8219B620h case   12:*/		return 0x8219B624;
		  /* 8219B624h */ case   13:  		/* li R9, 0 */
		/* 8219B624h case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219B624h case   13:*/		return 0x8219B628;
		  /* 8219B628h */ case   14:  		/* mr R10, R31 */
		/* 8219B628h case   14:*/		regs.R10 = regs.R31;
		/* 8219B628h case   14:*/		return 0x8219B62C;
		  /* 8219B62Ch */ case   15:  		/* cmplw CR6, R9, R29 */
		/* 8219B62Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R29);
		/* 8219B62Ch case   15:*/		return 0x8219B630;
		  /* 8219B630h */ case   16:  		/* bc 4, CR6_LT, 40 */
		/* 8219B630h case   16:*/		if ( !regs.CR[6].lt ) { return 0x8219B658;  }
		/* 8219B630h case   16:*/		return 0x8219B634;
		  /* 8219B634h */ case   17:  		/* lwz R11, <#[R10]> */
		/* 8219B634h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8219B634h case   17:*/		return 0x8219B638;
		  /* 8219B638h */ case   18:  		/* cmplw CR6, R8, R11 */
		/* 8219B638h case   18:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8219B638h case   18:*/		return 0x8219B63C;
		  /* 8219B63Ch */ case   19:  		/* bc 12, CR6_EQ, 40 */
		/* 8219B63Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x8219B664;  }
		/* 8219B63Ch case   19:*/		return 0x8219B640;
		  /* 8219B640h */ case   20:  		/* lwz R28, <#[R11 + 12]> */
		/* 8219B640h case   20:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219B640h case   20:*/		return 0x8219B644;
		  /* 8219B644h */ case   21:  		/* cmplw CR6, R28, R7 */
		/* 8219B644h case   21:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R7);
		/* 8219B644h case   21:*/		return 0x8219B648;
		  /* 8219B648h */ case   22:  		/* bc 12, CR6_EQ, 20 */
		/* 8219B648h case   22:*/		if ( regs.CR[6].eq ) { return 0x8219B65C;  }
		/* 8219B648h case   22:*/		return 0x8219B64C;
		  /* 8219B64Ch */ case   23:  		/* addi R9, R9, 1 */
		/* 8219B64Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8219B64Ch case   23:*/		return 0x8219B650;
		  /* 8219B650h */ case   24:  		/* addi R10, R10, 4 */
		/* 8219B650h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8219B650h case   24:*/		return 0x8219B654;
		  /* 8219B654h */ case   25:  		/* b -40 */
		/* 8219B654h case   25:*/		return 0x8219B62C;
		/* 8219B654h case   25:*/		return 0x8219B658;
	}
	return 0x8219B658;
} // Block from 8219B5F0h-8219B658h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8219B658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B658);
		  /* 8219B658h */ case    0:  		/* li R11, 0 */
		/* 8219B658h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219B658h case    0:*/		return 0x8219B65C;
	}
	return 0x8219B65C;
} // Block from 8219B658h-8219B65Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B65Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B65C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B65C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B65C);
		  /* 8219B65Ch */ case    0:  		/* cmplw CR6, R8, R11 */
		/* 8219B65Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8219B65Ch case    0:*/		return 0x8219B660;
		  /* 8219B660h */ case    1:  		/* bc 4, CR6_EQ, 76 */
		/* 8219B660h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219B6AC;  }
		/* 8219B660h case    1:*/		return 0x8219B664;
	}
	return 0x8219B664;
} // Block from 8219B65Ch-8219B664h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B664);
		  /* 8219B664h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 8219B664h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8219B664h case    0:*/		return 0x8219B668;
		  /* 8219B668h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 8219B668h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219B6A0;  }
		/* 8219B668h case    1:*/		return 0x8219B66C;
		  /* 8219B66Ch */ case    2:  		/* lwz R9, <#[R4 + 8]> */
		/* 8219B66Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000008) );
		/* 8219B66Ch case    2:*/		return 0x8219B670;
		  /* 8219B670h */ case    3:  		/* li R11, 0 */
		/* 8219B670h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219B670h case    3:*/		return 0x8219B674;
		  /* 8219B674h */ case    4:  		/* addi R10, R4, 44 */
		/* 8219B674h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x2C);
		/* 8219B674h case    4:*/		return 0x8219B678;
		  /* 8219B678h */ case    5:  		/* rlwinm R9, R9, 13, 29, 31 */
		/* 8219B678h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R9,regs.R9);
		/* 8219B678h case    5:*/		return 0x8219B67C;
		  /* 8219B67Ch */ case    6:  		/* cmplw CR6, R11, R9 */
		/* 8219B67Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8219B67Ch case    6:*/		return 0x8219B680;
		  /* 8219B680h */ case    7:  		/* bc 4, CR6_LT, 32 */
		/* 8219B680h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8219B6A0;  }
		/* 8219B680h case    7:*/		return 0x8219B684;
		  /* 8219B684h */ case    8:  		/* lwz R8, <#[R10]> */
		/* 8219B684h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8219B684h case    8:*/		return 0x8219B688;
		  /* 8219B688h */ case    9:  		/* lwz R8, <#[R8 + 12]> */
		/* 8219B688h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 8219B688h case    9:*/		return 0x8219B68C;
		  /* 8219B68Ch */ case   10:  		/* cmplw CR6, R8, R7 */
		/* 8219B68Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8219B68Ch case   10:*/		return 0x8219B690;
		  /* 8219B690h */ case   11:  		/* bc 12, CR6_EQ, 28 */
		/* 8219B690h case   11:*/		if ( regs.CR[6].eq ) { return 0x8219B6AC;  }
		/* 8219B690h case   11:*/		return 0x8219B694;
		  /* 8219B694h */ case   12:  		/* addi R11, R11, 1 */
		/* 8219B694h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219B694h case   12:*/		return 0x8219B698;
		  /* 8219B698h */ case   13:  		/* addi R10, R10, 4 */
		/* 8219B698h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 8219B698h case   13:*/		return 0x8219B69C;
		  /* 8219B69Ch */ case   14:  		/* b -32 */
		/* 8219B69Ch case   14:*/		return 0x8219B67C;
		/* 8219B69Ch case   14:*/		return 0x8219B6A0;
	}
	return 0x8219B6A0;
} // Block from 8219B664h-8219B6A0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219B6A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B6A0);
		  /* 8219B6A0h */ case    0:  		/* lwz R11, <#[R7 + 8]> */
		/* 8219B6A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 8219B6A0h case    0:*/		return 0x8219B6A4;
		  /* 8219B6A4h */ case    1:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 8219B6A4h case    1:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 8219B6A4h case    1:*/		return 0x8219B6A8;
		  /* 8219B6A8h */ case    2:  		/* add R3, R11, R3 */
		/* 8219B6A8h case    2:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 8219B6A8h case    2:*/		return 0x8219B6AC;
	}
	return 0x8219B6AC;
} // Block from 8219B6A0h-8219B6ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B6ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B6AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B6AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B6AC);
		  /* 8219B6ACh */ case    0:  		/* addi R30, R30, 1 */
		/* 8219B6ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8219B6ACh case    0:*/		return 0x8219B6B0;
		  /* 8219B6B0h */ case    1:  		/* addi R6, R6, 4 */
		/* 8219B6B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 8219B6B0h case    1:*/		return 0x8219B6B4;
		  /* 8219B6B4h */ case    2:  		/* b -168 */
		/* 8219B6B4h case    2:*/		return 0x8219B60C;
		/* 8219B6B4h case    2:*/		return 0x8219B6B8;
	}
	return 0x8219B6B8;
} // Block from 8219B6ACh-8219B6B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B6B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B6B8);
		  /* 8219B6B8h */ case    0:  		/* cmplwi CR6, R7, 0 */
		/* 8219B6B8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8219B6B8h case    0:*/		return 0x8219B6BC;
		  /* 8219B6BCh */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8219B6BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8219B6CC;  }
		/* 8219B6BCh case    1:*/		return 0x8219B6C0;
		  /* 8219B6C0h */ case    2:  		/* lwz R11, <#[R7 + 8]> */
		/* 8219B6C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 8219B6C0h case    2:*/		return 0x8219B6C4;
		  /* 8219B6C4h */ case    3:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 8219B6C4h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 8219B6C4h case    3:*/		return 0x8219B6C8;
		  /* 8219B6C8h */ case    4:  		/* add R3, R11, R3 */
		/* 8219B6C8h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 8219B6C8h case    4:*/		return 0x8219B6CC;
	}
	return 0x8219B6CC;
} // Block from 8219B6B8h-8219B6CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219B6CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B6CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B6CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B6CC);
		  /* 8219B6CCh */ case    0:  		/* b -1090604 */
		/* 8219B6CCh case    0:*/		return 0x820912A0;
		/* 8219B6CCh case    0:*/		return 0x8219B6D0;
	}
	return 0x8219B6D0;
} // Block from 8219B6CCh-8219B6D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B6D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B6D0);
		  /* 8219B6D0h */ case    0:  		/* mfspr R12, LR */
		/* 8219B6D0h case    0:*/		regs.R12 = regs.LR;
		/* 8219B6D0h case    0:*/		return 0x8219B6D4;
		  /* 8219B6D4h */ case    1:  		/* bl -1090680 */
		/* 8219B6D4h case    1:*/		regs.LR = 0x8219B6D8; return 0x8209125C;
		/* 8219B6D4h case    1:*/		return 0x8219B6D8;
		  /* 8219B6D8h */ case    2:  		/* lwz R30, <#[R4 + 4]> */
		/* 8219B6D8h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x00000004) );
		/* 8219B6D8h case    2:*/		return 0x8219B6DC;
		  /* 8219B6DCh */ case    3:  		/* li R3, 0 */
		/* 8219B6DCh case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219B6DCh case    3:*/		return 0x8219B6E0;
		  /* 8219B6E0h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 8219B6E0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219B6E0h case    4:*/		return 0x8219B6E4;
		  /* 8219B6E4h */ case    5:  		/* bc 12, CR6_EQ, 228 */
		/* 8219B6E4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219B7C8;  }
		/* 8219B6E4h case    5:*/		return 0x8219B6E8;
		  /* 8219B6E8h */ case    6:  		/* lwz R6, <#[R30 + 16]> */
		/* 8219B6E8h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000010) );
		/* 8219B6E8h case    6:*/		return 0x8219B6EC;
		  /* 8219B6ECh */ case    7:  		/* cmplwi CR6, R6, 0 */
		/* 8219B6ECh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8219B6ECh case    7:*/		return 0x8219B6F0;
		  /* 8219B6F0h */ case    8:  		/* bc 12, CR6_EQ, 208 */
		/* 8219B6F0h case    8:*/		if ( regs.CR[6].eq ) { return 0x8219B7C0;  }
		/* 8219B6F0h case    8:*/		return 0x8219B6F4;
		  /* 8219B6F4h */ case    9:  		/* lwz R11, <#[R30]> */
		/* 8219B6F4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8219B6F4h case    9:*/		return 0x8219B6F8;
		  /* 8219B6F8h */ case   10:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 8219B6F8h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 8219B6F8h case   10:*/		return 0x8219B6FC;
		  /* 8219B6FCh */ case   11:  		/* bc 12, CR0_EQ, 196 */
		/* 8219B6FCh case   11:*/		if ( regs.CR[0].eq ) { return 0x8219B7C0;  }
		/* 8219B6FCh case   11:*/		return 0x8219B700;
		  /* 8219B700h */ case   12:  		/* lwz R11, <#[R6 + 8]> */
		/* 8219B700h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 8219B700h case   12:*/		return 0x8219B704;
		  /* 8219B704h */ case   13:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219B704h case   13:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219B704h case   13:*/		return 0x8219B708;
		  /* 8219B708h */ case   14:  		/* cmplwi CR6, R11, 128 */
		/* 8219B708h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 8219B708h case   14:*/		return 0x8219B70C;
		  /* 8219B70Ch */ case   15:  		/* bc 4, CR6_EQ, 180 */
		/* 8219B70Ch case   15:*/		if ( !regs.CR[6].eq ) { return 0x8219B7C0;  }
		/* 8219B70Ch case   15:*/		return 0x8219B710;
		  /* 8219B710h */ case   16:  		/* lwz R31, <#[R5 + 4]> */
		/* 8219B710h case   16:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + 0x00000004) );
		/* 8219B710h case   16:*/		return 0x8219B714;
		  /* 8219B714h */ case   17:  		/* cmplwi CR6, R31, 0 */
		/* 8219B714h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219B714h case   17:*/		return 0x8219B718;
		  /* 8219B718h */ case   18:  		/* bc 12, CR6_EQ, 168 */
		/* 8219B718h case   18:*/		if ( regs.CR[6].eq ) { return 0x8219B7C0;  }
		/* 8219B718h case   18:*/		return 0x8219B71C;
		  /* 8219B71Ch */ case   19:  		/* lwz R11, <#[R31 + 16]> */
		/* 8219B71Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8219B71Ch case   19:*/		return 0x8219B720;
		  /* 8219B720h */ case   20:  		/* cmplwi CR6, R11, 0 */
		/* 8219B720h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219B720h case   20:*/		return 0x8219B724;
		  /* 8219B724h */ case   21:  		/* bc 12, CR6_EQ, 148 */
		/* 8219B724h case   21:*/		if ( regs.CR[6].eq ) { return 0x8219B7B8;  }
		/* 8219B724h case   21:*/		return 0x8219B728;
		  /* 8219B728h */ case   22:  		/* lwz R10, <#[R31]> */
		/* 8219B728h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8219B728h case   22:*/		return 0x8219B72C;
		  /* 8219B72Ch */ case   23:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 8219B72Ch case   23:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 8219B72Ch case   23:*/		return 0x8219B730;
		  /* 8219B730h */ case   24:  		/* bc 12, CR0_EQ, 136 */
		/* 8219B730h case   24:*/		if ( regs.CR[0].eq ) { return 0x8219B7B8;  }
		/* 8219B730h case   24:*/		return 0x8219B734;
		  /* 8219B734h */ case   25:  		/* lwz R10, <#[R11 + 8]> */
		/* 8219B734h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8219B734h case   25:*/		return 0x8219B738;
		  /* 8219B738h */ case   26:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 8219B738h case   26:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 8219B738h case   26:*/		return 0x8219B73C;
		  /* 8219B73Ch */ case   27:  		/* cmplwi CR6, R10, 128 */
		/* 8219B73Ch case   27:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000080);
		/* 8219B73Ch case   27:*/		return 0x8219B740;
		  /* 8219B740h */ case   28:  		/* bc 4, CR6_EQ, 120 */
		/* 8219B740h case   28:*/		if ( !regs.CR[6].eq ) { return 0x8219B7B8;  }
		/* 8219B740h case   28:*/		return 0x8219B744;
		  /* 8219B744h */ case   29:  		/* cmplw CR6, R6, R11 */
		/* 8219B744h case   29:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 8219B744h case   29:*/		return 0x8219B748;
		  /* 8219B748h */ case   30:  		/* bc 4, CR6_EQ, 12 */
		/* 8219B748h case   30:*/		if ( !regs.CR[6].eq ) { return 0x8219B754;  }
		/* 8219B748h case   30:*/		return 0x8219B74C;
		  /* 8219B74Ch */ case   31:  		/* ori R3, R3, 4 */
		/* 8219B74Ch case   31:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4);
		/* 8219B74Ch case   31:*/		return 0x8219B750;
		  /* 8219B750h */ case   32:  		/* b 104 */
		/* 8219B750h case   32:*/		return 0x8219B7B8;
		/* 8219B750h case   32:*/		return 0x8219B754;
	}
	return 0x8219B754;
} // Block from 8219B6D0h-8219B754h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8219B754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B754);
		  /* 8219B754h */ case    0:  		/* lwz R10, <#[R6 + 44]> */
		/* 8219B754h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x0000002C) );
		/* 8219B754h case    0:*/		return 0x8219B758;
		  /* 8219B758h */ case    1:  		/* lwz R8, <#[R11 + 44]> */
		/* 8219B758h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000002C) );
		/* 8219B758h case    1:*/		return 0x8219B75C;
		  /* 8219B75Ch */ case    2:  		/* lwz R9, <#[R6 + 48]> */
		/* 8219B75Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000030) );
		/* 8219B75Ch case    2:*/		return 0x8219B760;
		  /* 8219B760h */ case    3:  		/* lwz R29, <#[R11 + 48]> */
		/* 8219B760h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000030) );
		/* 8219B760h case    3:*/		return 0x8219B764;
		  /* 8219B764h */ case    4:  		/* lwz R10, <#[R10 + 12]> */
		/* 8219B764h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219B764h case    4:*/		return 0x8219B768;
		  /* 8219B768h */ case    5:  		/* lwz R7, <#[R8 + 12]> */
		/* 8219B768h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x0000000C) );
		/* 8219B768h case    5:*/		return 0x8219B76C;
		  /* 8219B76Ch */ case    6:  		/* lwz R9, <#[R9 + 12]> */
		/* 8219B76Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000000C) );
		/* 8219B76Ch case    6:*/		return 0x8219B770;
		  /* 8219B770h */ case    7:  		/* cmplw CR6, R10, R4 */
		/* 8219B770h case    7:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 8219B770h case    7:*/		return 0x8219B774;
		  /* 8219B774h */ case    8:  		/* lwz R8, <#[R29 + 12]> */
		/* 8219B774h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x0000000C) );
		/* 8219B774h case    8:*/		return 0x8219B778;
		  /* 8219B778h */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 8219B778h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219B78C;  }
		/* 8219B778h case    9:*/		return 0x8219B77C;
		  /* 8219B77Ch */ case   10:  		/* cmplw CR6, R7, R5 */
		/* 8219B77Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R5);
		/* 8219B77Ch case   10:*/		return 0x8219B780;
		  /* 8219B780h */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 8219B780h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8219B78C;  }
		/* 8219B780h case   11:*/		return 0x8219B784;
		  /* 8219B784h */ case   12:  		/* cmplw CR6, R9, R8 */
		/* 8219B784h case   12:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 8219B784h case   12:*/		return 0x8219B788;
		  /* 8219B788h */ case   13:  		/* bc 12, CR6_EQ, 28 */
		/* 8219B788h case   13:*/		if ( regs.CR[6].eq ) { return 0x8219B7A4;  }
		/* 8219B788h case   13:*/		return 0x8219B78C;
	}
	return 0x8219B78C;
} // Block from 8219B754h-8219B78Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219B78Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B78C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B78C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B78C);
		  /* 8219B78Ch */ case    0:  		/* cmplw CR6, R9, R4 */
		/* 8219B78Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 8219B78Ch case    0:*/		return 0x8219B790;
		  /* 8219B790h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 8219B790h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219B7AC;  }
		/* 8219B790h case    1:*/		return 0x8219B794;
		  /* 8219B794h */ case    2:  		/* cmplw CR6, R8, R5 */
		/* 8219B794h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R5);
		/* 8219B794h case    2:*/		return 0x8219B798;
		  /* 8219B798h */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 8219B798h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219B7AC;  }
		/* 8219B798h case    3:*/		return 0x8219B79C;
		  /* 8219B79Ch */ case    4:  		/* cmplw CR6, R10, R7 */
		/* 8219B79Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8219B79Ch case    4:*/		return 0x8219B7A0;
		  /* 8219B7A0h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 8219B7A0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219B7AC;  }
		/* 8219B7A0h case    5:*/		return 0x8219B7A4;
	}
	return 0x8219B7A4;
} // Block from 8219B78Ch-8219B7A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219B7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B7A4);
		  /* 8219B7A4h */ case    0:  		/* ori R3, R3, 2 */
		/* 8219B7A4h case    0:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x2);
		/* 8219B7A4h case    0:*/		return 0x8219B7A8;
		  /* 8219B7A8h */ case    1:  		/* b 16 */
		/* 8219B7A8h case    1:*/		return 0x8219B7B8;
		/* 8219B7A8h case    1:*/		return 0x8219B7AC;
	}
	return 0x8219B7AC;
} // Block from 8219B7A4h-8219B7ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B7ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B7AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B7AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B7AC);
		  /* 8219B7ACh */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 8219B7ACh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8219B7ACh case    0:*/		return 0x8219B7B0;
		  /* 8219B7B0h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 8219B7B0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219B7B8;  }
		/* 8219B7B0h case    1:*/		return 0x8219B7B4;
		  /* 8219B7B4h */ case    2:  		/* ori R3, R3, 1 */
		/* 8219B7B4h case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x1);
		/* 8219B7B4h case    2:*/		return 0x8219B7B8;
	}
	return 0x8219B7B8;
} // Block from 8219B7ACh-8219B7B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B7B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B7B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B7B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B7B8);
		  /* 8219B7B8h */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 8219B7B8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 8219B7B8h case    0:*/		return 0x8219B7BC;
		  /* 8219B7BCh */ case    1:  		/* b -168 */
		/* 8219B7BCh case    1:*/		return 0x8219B714;
		/* 8219B7BCh case    1:*/		return 0x8219B7C0;
	}
	return 0x8219B7C0;
} // Block from 8219B7B8h-8219B7C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B7C0);
		  /* 8219B7C0h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 8219B7C0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 8219B7C0h case    0:*/		return 0x8219B7C4;
		  /* 8219B7C4h */ case    1:  		/* b -228 */
		/* 8219B7C4h case    1:*/		return 0x8219B6E0;
		/* 8219B7C4h case    1:*/		return 0x8219B7C8;
	}
	return 0x8219B7C8;
} // Block from 8219B7C0h-8219B7C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B7C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B7C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B7C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B7C8);
		  /* 8219B7C8h */ case    0:  		/* b -1090844 */
		/* 8219B7C8h case    0:*/		return 0x820912AC;
		/* 8219B7C8h case    0:*/		return 0x8219B7CC;
		  /* 8219B7CCh */ case    1:  		/* nop */
		/* 8219B7CCh case    1:*/		cpu::op::nop();
		/* 8219B7CCh case    1:*/		return 0x8219B7D0;
	}
	return 0x8219B7D0;
} // Block from 8219B7C8h-8219B7D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B7D0);
		  /* 8219B7D0h */ case    0:  		/* mfspr R12, LR */
		/* 8219B7D0h case    0:*/		regs.R12 = regs.LR;
		/* 8219B7D0h case    0:*/		return 0x8219B7D4;
		  /* 8219B7D4h */ case    1:  		/* bl -1090948 */
		/* 8219B7D4h case    1:*/		regs.LR = 0x8219B7D8; return 0x82091250;
		/* 8219B7D4h case    1:*/		return 0x8219B7D8;
		  /* 8219B7D8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219B7D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219B7D8h case    2:*/		return 0x8219B7DC;
		  /* 8219B7DCh */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219B7DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219B7DCh case    3:*/		return 0x8219B7E0;
		  /* 8219B7E0h */ case    4:  		/* mr R29, R3 */
		/* 8219B7E0h case    4:*/		regs.R29 = regs.R3;
		/* 8219B7E0h case    4:*/		return 0x8219B7E4;
		  /* 8219B7E4h */ case    5:  		/* rlwinm. R30, R11, 13, 29, 31 */
		/* 8219B7E4h case    5:*/		cpu::op::rlwinm<1,13,29,31>(regs,&regs.R30,regs.R11);
		/* 8219B7E4h case    5:*/		return 0x8219B7E8;
		  /* 8219B7E8h */ case    6:  		/* bc 12, CR0_EQ, 68 */
		/* 8219B7E8h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219B82C;  }
		/* 8219B7E8h case    6:*/		return 0x8219B7EC;
		  /* 8219B7ECh */ case    7:  		/* mr R31, R5 */
		/* 8219B7ECh case    7:*/		regs.R31 = regs.R5;
		/* 8219B7ECh case    7:*/		return 0x8219B7F0;
		  /* 8219B7F0h */ case    8:  		/* addi R28, R3, 40 */
		/* 8219B7F0h case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R3,0x28);
		/* 8219B7F0h case    8:*/		return 0x8219B7F4;
		  /* 8219B7F4h */ case    9:  		/* subf R27, R5, R6 */
		/* 8219B7F4h case    9:*/		cpu::op::subf<0>(regs,&regs.R27,regs.R5,regs.R6);
		/* 8219B7F4h case    9:*/		return 0x8219B7F8;
		  /* 8219B7F8h */ case   10:  		/* subf R26, R5, R4 */
		/* 8219B7F8h case   10:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R5,regs.R4);
		/* 8219B7F8h case   10:*/		return 0x8219B7FC;
		  /* 8219B7FCh */ case   11:  		/* li R10, 1 */
		/* 8219B7FCh case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219B7FCh case   11:*/		return 0x8219B800;
		  /* 8219B800h */ case   12:  		/* lwzu R3, <#[R28 + 4]> */
		/* 8219B800h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000004) );
		regs.R28 = (uint32)(regs.R28 + 0x00000004);
		/* 8219B800h case   12:*/		return 0x8219B804;
		  /* 8219B804h */ case   13:  		/* li R9, 0 */
		/* 8219B804h case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219B804h case   13:*/		return 0x8219B808;
		  /* 8219B808h */ case   14:  		/* lwz R8, <#[R29 + 28]> */
		/* 8219B808h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x0000001C) );
		/* 8219B808h case   14:*/		return 0x8219B80C;
		  /* 8219B80Ch */ case   15:  		/* add R7, R27, R31 */
		/* 8219B80Ch case   15:*/		cpu::op::add<0>(regs,&regs.R7,regs.R27,regs.R31);
		/* 8219B80Ch case   15:*/		return 0x8219B810;
		  /* 8219B810h */ case   16:  		/* mr R6, R31 */
		/* 8219B810h case   16:*/		regs.R6 = regs.R31;
		/* 8219B810h case   16:*/		return 0x8219B814;
		  /* 8219B814h */ case   17:  		/* add R5, R26, R31 */
		/* 8219B814h case   17:*/		cpu::op::add<0>(regs,&regs.R5,regs.R26,regs.R31);
		/* 8219B814h case   17:*/		return 0x8219B818;
		  /* 8219B818h */ case   18:  		/* li R4, 0 */
		/* 8219B818h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8219B818h case   18:*/		return 0x8219B81C;
		  /* 8219B81Ch */ case   19:  		/* bl 556212 */
		/* 8219B81Ch case   19:*/		regs.LR = 0x8219B820; return 0x822234D0;
		/* 8219B81Ch case   19:*/		return 0x8219B820;
		  /* 8219B820h */ case   20:  		/* addic. R30, R30, -1 */
		/* 8219B820h case   20:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 8219B820h case   20:*/		return 0x8219B824;
		  /* 8219B824h */ case   21:  		/* addi R31, R31, 4 */
		/* 8219B824h case   21:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8219B824h case   21:*/		return 0x8219B828;
		  /* 8219B828h */ case   22:  		/* bc 4, CR0_EQ, -44 */
		/* 8219B828h case   22:*/		if ( !regs.CR[0].eq ) { return 0x8219B7FC;  }
		/* 8219B828h case   22:*/		return 0x8219B82C;
	}
	return 0x8219B82C;
} // Block from 8219B7D0h-8219B82Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219B82Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B82C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B82C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B82C);
		  /* 8219B82Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 8219B82Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219B82Ch case    0:*/		return 0x8219B830;
		  /* 8219B830h */ case    1:  		/* b -1090960 */
		/* 8219B830h case    1:*/		return 0x820912A0;
		/* 8219B830h case    1:*/		return 0x8219B834;
		  /* 8219B834h */ case    2:  		/* nop */
		/* 8219B834h case    2:*/		cpu::op::nop();
		/* 8219B834h case    2:*/		return 0x8219B838;
	}
	return 0x8219B838;
} // Block from 8219B82Ch-8219B838h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219B838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B838);
		  /* 8219B838h */ case    0:  		/* mfspr R12, LR */
		/* 8219B838h case    0:*/		regs.R12 = regs.LR;
		/* 8219B838h case    0:*/		return 0x8219B83C;
		  /* 8219B83Ch */ case    1:  		/* bl -1091100 */
		/* 8219B83Ch case    1:*/		regs.LR = 0x8219B840; return 0x82091220;
		/* 8219B83Ch case    1:*/		return 0x8219B840;
		  /* 8219B840h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 8219B840h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8219B840h case    2:*/		return 0x8219B844;
		  /* 8219B844h */ case    3:  		/* stwu R1, <#[R1 - 240]> */
		/* 8219B844h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 8219B844h case    3:*/		return 0x8219B848;
		  /* 8219B848h */ case    4:  		/* lwz R14, <#[R1 + 340]> */
		/* 8219B848h case    4:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x00000154) );
		/* 8219B848h case    4:*/		return 0x8219B84C;
		  /* 8219B84Ch */ case    5:  		/* li R30, 0 */
		/* 8219B84Ch case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8219B84Ch case    5:*/		return 0x8219B850;
		  /* 8219B850h */ case    6:  		/* mr R20, R4 */
		/* 8219B850h case    6:*/		regs.R20 = regs.R4;
		/* 8219B850h case    6:*/		return 0x8219B854;
		  /* 8219B854h */ case    7:  		/* mr R17, R5 */
		/* 8219B854h case    7:*/		regs.R17 = regs.R5;
		/* 8219B854h case    7:*/		return 0x8219B858;
		  /* 8219B858h */ case    8:  		/* mr R24, R6 */
		/* 8219B858h case    8:*/		regs.R24 = regs.R6;
		/* 8219B858h case    8:*/		return 0x8219B85C;
		  /* 8219B85Ch */ case    9:  		/* mr R16, R7 */
		/* 8219B85Ch case    9:*/		regs.R16 = regs.R7;
		/* 8219B85Ch case    9:*/		return 0x8219B860;
		  /* 8219B860h */ case   10:  		/* mr R21, R8 */
		/* 8219B860h case   10:*/		regs.R21 = regs.R8;
		/* 8219B860h case   10:*/		return 0x8219B864;
		  /* 8219B864h */ case   11:  		/* stw R30, <#[R14]> */
		/* 8219B864h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R14 + 0x00000000) );
		/* 8219B864h case   11:*/		return 0x8219B868;
		  /* 8219B868h */ case   12:  		/* mr R26, R9 */
		/* 8219B868h case   12:*/		regs.R26 = regs.R9;
		/* 8219B868h case   12:*/		return 0x8219B86C;
		  /* 8219B86Ch */ case   13:  		/* mr R23, R10 */
		/* 8219B86Ch case   13:*/		regs.R23 = regs.R10;
		/* 8219B86Ch case   13:*/		return 0x8219B870;
		  /* 8219B870h */ case   14:  		/* cmplwi CR6, R8, 0 */
		/* 8219B870h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8219B870h case   14:*/		return 0x8219B874;
		  /* 8219B874h */ case   15:  		/* mr R15, R30 */
		/* 8219B874h case   15:*/		regs.R15 = regs.R30;
		/* 8219B874h case   15:*/		return 0x8219B878;
		  /* 8219B878h */ case   16:  		/* mr R22, R30 */
		/* 8219B878h case   16:*/		regs.R22 = regs.R30;
		/* 8219B878h case   16:*/		return 0x8219B87C;
		  /* 8219B87Ch */ case   17:  		/* bc 12, CR6_EQ, 260 */
		/* 8219B87Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x8219B980;  }
		/* 8219B87Ch case   17:*/		return 0x8219B880;
		  /* 8219B880h */ case   18:  		/* lwz R18, <#[R1 + 324]> */
		/* 8219B880h case   18:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000144) );
		/* 8219B880h case   18:*/		return 0x8219B884;
		  /* 8219B884h */ case   19:  		/* mr R19, R30 */
		/* 8219B884h case   19:*/		regs.R19 = regs.R30;
		/* 8219B884h case   19:*/		return 0x8219B888;
		  /* 8219B888h */ case   20:  		/* li R25, 0 */
		/* 8219B888h case   20:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8219B888h case   20:*/		return 0x8219B88C;
		  /* 8219B88Ch */ case   21:  		/* li R27, 0 */
		/* 8219B88Ch case   21:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8219B88Ch case   21:*/		return 0x8219B890;
		  /* 8219B890h */ case   22:  		/* cmplwi CR6, R20, 0 */
		/* 8219B890h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 8219B890h case   22:*/		return 0x8219B894;
		  /* 8219B894h */ case   23:  		/* bc 12, CR6_EQ, 156 */
		/* 8219B894h case   23:*/		if ( regs.CR[6].eq ) { return 0x8219B930;  }
		/* 8219B894h case   23:*/		return 0x8219B898;
		  /* 8219B898h */ case   24:  		/* mr R31, R24 */
		/* 8219B898h case   24:*/		regs.R31 = regs.R24;
		/* 8219B898h case   24:*/		return 0x8219B89C;
		  /* 8219B89Ch */ case   25:  		/* subf R29, R24, R16 */
		/* 8219B89Ch case   25:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R24,regs.R16);
		/* 8219B89Ch case   25:*/		return 0x8219B8A0;
		  /* 8219B8A0h */ case   26:  		/* subf R28, R24, R17 */
		/* 8219B8A0h case   26:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R24,regs.R17);
		/* 8219B8A0h case   26:*/		return 0x8219B8A4;
		  /* 8219B8A4h */ case   27:  		/* lwzx R3, <#[R28 + R31]> */
		/* 8219B8A4h case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + regs.R31 + 0x00000000) );
		/* 8219B8A4h case   27:*/		return 0x8219B8A8;
		  /* 8219B8A8h */ case   28:  		/* lwzx R11, <#[R30 + R26]> */
		/* 8219B8A8h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R26 + 0x00000000) );
		/* 8219B8A8h case   28:*/		return 0x8219B8AC;
		  /* 8219B8ACh */ case   29:  		/* cmplw CR6, R3, R11 */
		/* 8219B8ACh case   29:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8219B8ACh case   29:*/		return 0x8219B8B0;
		  /* 8219B8B0h */ case   30:  		/* bc 4, CR6_EQ, 40 */
		/* 8219B8B0h case   30:*/		if ( !regs.CR[6].eq ) { return 0x8219B8D8;  }
		/* 8219B8B0h case   30:*/		return 0x8219B8B4;
		  /* 8219B8B4h */ case   31:  		/* lwzx R10, <#[R29 + R31]> */
		/* 8219B8B4h case   31:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 8219B8B4h case   31:*/		return 0x8219B8B8;
		  /* 8219B8B8h */ case   32:  		/* lwzx R9, <#[R30 + R18]> */
		/* 8219B8B8h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + regs.R18 + 0x00000000) );
		/* 8219B8B8h case   32:*/		return 0x8219B8BC;
		  /* 8219B8BCh */ case   33:  		/* cmplw CR6, R10, R9 */
		/* 8219B8BCh case   33:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8219B8BCh case   33:*/		return 0x8219B8C0;
		  /* 8219B8C0h */ case   34:  		/* bc 4, CR6_EQ, 24 */
		/* 8219B8C0h case   34:*/		if ( !regs.CR[6].eq ) { return 0x8219B8D8;  }
		/* 8219B8C0h case   34:*/		return 0x8219B8C4;
		  /* 8219B8C4h */ case   35:  		/* lwz R10, <#[R31]> */
		/* 8219B8C4h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8219B8C4h case   35:*/		return 0x8219B8C8;
		  /* 8219B8C8h */ case   36:  		/* li R25, 1 */
		/* 8219B8C8h case   36:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8219B8C8h case   36:*/		return 0x8219B8CC;
		  /* 8219B8CCh */ case   37:  		/* lwzx R9, <#[R30 + R23]> */
		/* 8219B8CCh case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + regs.R23 + 0x00000000) );
		/* 8219B8CCh case   37:*/		return 0x8219B8D0;
		  /* 8219B8D0h */ case   38:  		/* cmpw CR6, R10, R9 */
		/* 8219B8D0h case   38:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 8219B8D0h case   38:*/		return 0x8219B8D4;
		  /* 8219B8D4h */ case   39:  		/* bc 12, CR6_EQ, 92 */
		/* 8219B8D4h case   39:*/		if ( regs.CR[6].eq ) { return 0x8219B930;  }
		/* 8219B8D4h case   39:*/		return 0x8219B8D8;
	}
	return 0x8219B8D8;
} // Block from 8219B838h-8219B8D8h (40 instructions)

//////////////////////////////////////////////////////
// Block at 8219B8D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B8D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B8D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B8D8);
		  /* 8219B8D8h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219B8D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219B8D8h case    0:*/		return 0x8219B8DC;
		  /* 8219B8DCh */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219B8DCh case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219B8DCh case    1:*/		return 0x8219B8E0;
		  /* 8219B8E0h */ case    2:  		/* cmplwi CR6, R11, 16000 */
		/* 8219B8E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8219B8E0h case    2:*/		return 0x8219B8E4;
		  /* 8219B8E4h */ case    3:  		/* bc 4, CR6_EQ, 60 */
		/* 8219B8E4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219B920;  }
		/* 8219B8E4h case    3:*/		return 0x8219B8E8;
		  /* 8219B8E8h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219B8E8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219B8E8h case    4:*/		return 0x8219B8EC;
		  /* 8219B8ECh */ case    5:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219B8ECh case    5:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219B8ECh case    5:*/		return 0x8219B8F0;
		  /* 8219B8F0h */ case    6:  		/* cmplwi CR6, R11, 16000 */
		/* 8219B8F0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8219B8F0h case    6:*/		return 0x8219B8F4;
		  /* 8219B8F4h */ case    7:  		/* bc 4, CR6_EQ, 44 */
		/* 8219B8F4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8219B920;  }
		/* 8219B8F4h case    7:*/		return 0x8219B8F8;
		  /* 8219B8F8h */ case    8:  		/* lwzx R5, <#[R29 + R31]> */
		/* 8219B8F8h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 8219B8F8h case    8:*/		return 0x8219B8FC;
		  /* 8219B8FCh */ case    9:  		/* lwz R4, <#[R31]> */
		/* 8219B8FCh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 8219B8FCh case    9:*/		return 0x8219B900;
		  /* 8219B900h */ case   10:  		/* bl 548232 */
		/* 8219B900h case   10:*/		regs.LR = 0x8219B904; return 0x82221688;
		/* 8219B900h case   10:*/		return 0x8219B904;
		  /* 8219B904h */ case   11:  		/* lwzx R5, <#[R30 + R18]> */
		/* 8219B904h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + regs.R18 + 0x00000000) );
		/* 8219B904h case   11:*/		return 0x8219B908;
		  /* 8219B908h */ case   12:  		/* fmr FR31, FR1 */
		/* 8219B908h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 8219B908h case   12:*/		return 0x8219B90C;
		  /* 8219B90Ch */ case   13:  		/* lwzx R4, <#[R30 + R23]> */
		/* 8219B90Ch case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + regs.R23 + 0x00000000) );
		/* 8219B90Ch case   13:*/		return 0x8219B910;
		  /* 8219B910h */ case   14:  		/* lwzx R3, <#[R30 + R26]> */
		/* 8219B910h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + regs.R26 + 0x00000000) );
		/* 8219B910h case   14:*/		return 0x8219B914;
		  /* 8219B914h */ case   15:  		/* bl 548212 */
		/* 8219B914h case   15:*/		regs.LR = 0x8219B918; return 0x82221688;
		/* 8219B914h case   15:*/		return 0x8219B918;
		  /* 8219B918h */ case   16:  		/* fcmpu CR6, FR31, FR1 */
		/* 8219B918h case   16:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR1);
		/* 8219B918h case   16:*/		return 0x8219B91C;
		  /* 8219B91Ch */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 8219B91Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x8219B930;  }
		/* 8219B91Ch case   17:*/		return 0x8219B920;
	}
	return 0x8219B920;
} // Block from 8219B8D8h-8219B920h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219B920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B920);
		  /* 8219B920h */ case    0:  		/* addi R27, R27, 1 */
		/* 8219B920h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8219B920h case    0:*/		return 0x8219B924;
		  /* 8219B924h */ case    1:  		/* addi R31, R31, 4 */
		/* 8219B924h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8219B924h case    1:*/		return 0x8219B928;
		  /* 8219B928h */ case    2:  		/* cmplw CR6, R27, R20 */
		/* 8219B928h case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R20);
		/* 8219B928h case    2:*/		return 0x8219B92C;
		  /* 8219B92Ch */ case    3:  		/* bc 12, CR6_LT, -136 */
		/* 8219B92Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8219B8A4;  }
		/* 8219B92Ch case    3:*/		return 0x8219B930;
	}
	return 0x8219B930;
} // Block from 8219B920h-8219B930h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219B930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B930);
		  /* 8219B930h */ case    0:  		/* cmplw CR6, R27, R20 */
		/* 8219B930h case    0:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R20);
		/* 8219B930h case    0:*/		return 0x8219B934;
		  /* 8219B934h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 8219B934h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219B958;  }
		/* 8219B934h case    1:*/		return 0x8219B938;
		  /* 8219B938h */ case    2:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 8219B938h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 8219B938h case    2:*/		return 0x8219B93C;
		  /* 8219B93Ch */ case    3:  		/* bc 12, CR0_EQ, 92 */
		/* 8219B93Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x8219B998;  }
		/* 8219B93Ch case    3:*/		return 0x8219B940;
		  /* 8219B940h */ case    4:  		/* li R11, 1 */
		/* 8219B940h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219B940h case    4:*/		return 0x8219B944;
		  /* 8219B944h */ case    5:  		/* lwz R10, <#[R14]> */
		/* 8219B944h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000000) );
		/* 8219B944h case    5:*/		return 0x8219B948;
		  /* 8219B948h */ case    6:  		/* slw R11, R11, R22 */
		/* 8219B948h case    6:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R22);
		/* 8219B948h case    6:*/		return 0x8219B94C;
		  /* 8219B94Ch */ case    7:  		/* or R11, R11, R10 */
		/* 8219B94Ch case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219B94Ch case    7:*/		return 0x8219B950;
		  /* 8219B950h */ case    8:  		/* stw R11, <#[R14]> */
		/* 8219B950h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 8219B950h case    8:*/		return 0x8219B954;
		  /* 8219B954h */ case    9:  		/* b 24 */
		/* 8219B954h case    9:*/		return 0x8219B96C;
		/* 8219B954h case    9:*/		return 0x8219B958;
	}
	return 0x8219B958;
} // Block from 8219B930h-8219B958h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219B958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B958);
		  /* 8219B958h */ case    0:  		/* li R11, 3 */
		/* 8219B958h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8219B958h case    0:*/		return 0x8219B95C;
		  /* 8219B95Ch */ case    1:  		/* slw R10, R27, R19 */
		/* 8219B95Ch case    1:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R27,regs.R19);
		/* 8219B95Ch case    1:*/		return 0x8219B960;
		  /* 8219B960h */ case    2:  		/* slw R11, R11, R19 */
		/* 8219B960h case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R19);
		/* 8219B960h case    2:*/		return 0x8219B964;
		  /* 8219B964h */ case    3:  		/* andc R11, R15, R11 */
		/* 8219B964h case    3:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R15,regs.R11);
		/* 8219B964h case    3:*/		return 0x8219B968;
		  /* 8219B968h */ case    4:  		/* or R15, R11, R10 */
		/* 8219B968h case    4:*/		cpu::op::or<0>(regs,&regs.R15,regs.R11,regs.R10);
		/* 8219B968h case    4:*/		return 0x8219B96C;
	}
	return 0x8219B96C;
} // Block from 8219B958h-8219B96Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219B96Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B96C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B96C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B96C);
		  /* 8219B96Ch */ case    0:  		/* addi R22, R22, 1 */
		/* 8219B96Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 8219B96Ch case    0:*/		return 0x8219B970;
		  /* 8219B970h */ case    1:  		/* addi R30, R30, 4 */
		/* 8219B970h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8219B970h case    1:*/		return 0x8219B974;
		  /* 8219B974h */ case    2:  		/* addi R19, R19, 2 */
		/* 8219B974h case    2:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x2);
		/* 8219B974h case    2:*/		return 0x8219B978;
		  /* 8219B978h */ case    3:  		/* cmplw CR6, R22, R21 */
		/* 8219B978h case    3:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R21);
		/* 8219B978h case    3:*/		return 0x8219B97C;
		  /* 8219B97Ch */ case    4:  		/* bc 12, CR6_LT, -244 */
		/* 8219B97Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8219B888;  }
		/* 8219B97Ch case    4:*/		return 0x8219B980;
	}
	return 0x8219B980;
} // Block from 8219B96Ch-8219B980h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219B980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B980);
		  /* 8219B980h */ case    0:  		/* lwz R11, <#[R1 + 332]> */
		/* 8219B980h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000014C) );
		/* 8219B980h case    0:*/		return 0x8219B984;
		  /* 8219B984h */ case    1:  		/* li R3, 1 */
		/* 8219B984h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219B984h case    1:*/		return 0x8219B988;
		  /* 8219B988h */ case    2:  		/* stw R15, <#[R11]> */
		/* 8219B988h case    2:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R11 + 0x00000000) );
		/* 8219B988h case    2:*/		return 0x8219B98C;
		  /* 8219B98Ch */ case    3:  		/* addi R1, R1, 240 */
		/* 8219B98Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 8219B98Ch case    3:*/		return 0x8219B990;
		  /* 8219B990h */ case    4:  		/* lfd FR31, <#[R1 - 160]> */
		/* 8219B990h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8219B990h case    4:*/		return 0x8219B994;
		  /* 8219B994h */ case    5:  		/* b -1091364 */
		/* 8219B994h case    5:*/		return 0x82091270;
		/* 8219B994h case    5:*/		return 0x8219B998;
	}
	return 0x8219B998;
} // Block from 8219B980h-8219B998h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219B998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B998);
		  /* 8219B998h */ case    0:  		/* li R3, 0 */
		/* 8219B998h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219B998h case    0:*/		return 0x8219B99C;
		  /* 8219B99Ch */ case    1:  		/* b -16 */
		/* 8219B99Ch case    1:*/		return 0x8219B98C;
		/* 8219B99Ch case    1:*/		return 0x8219B9A0;
		  /* 8219B9A0h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8219B9A0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8219B9A0h case    2:*/		return 0x8219B9A4;
		  /* 8219B9A4h */ case    3:  		/* li R8, 0 */
		/* 8219B9A4h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8219B9A4h case    3:*/		return 0x8219B9A8;
		  /* 8219B9A8h */ case    4:  		/* lwz R9, <#[R4]> */
		/* 8219B9A8h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000000) );
		/* 8219B9A8h case    4:*/		return 0x8219B9AC;
		  /* 8219B9ACh */ case    5:  		/* lwz R11, <#[R11 + 32]> */
		/* 8219B9ACh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 8219B9ACh case    5:*/		return 0x8219B9B0;
		  /* 8219B9B0h */ case    6:  		/* b 32 */
		/* 8219B9B0h case    6:*/		return 0x8219B9D0;
		/* 8219B9B0h case    6:*/		return 0x8219B9B4;
		  /* 8219B9B4h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 8219B9B4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219B9B4h case    7:*/		return 0x8219B9B8;
		  /* 8219B9B8h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 8219B9B8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8219B9B8h case    8:*/		return 0x8219B9BC;
		  /* 8219B9BCh */ case    9:  		/* rlwinm R10, R10, 19, 16, 31 */
		/* 8219B9BCh case    9:*/		cpu::op::rlwinm<0,19,16,31>(regs,&regs.R10,regs.R10);
		/* 8219B9BCh case    9:*/		return 0x8219B9C0;
		  /* 8219B9C0h */ case   10:  		/* cmplw CR6, R10, R8 */
		/* 8219B9C0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 8219B9C0h case   10:*/		return 0x8219B9C4;
		  /* 8219B9C4h */ case   11:  		/* bc 4, CR6_GT, 8 */
		/* 8219B9C4h case   11:*/		if ( !regs.CR[6].gt ) { return 0x8219B9CC;  }
		/* 8219B9C4h case   11:*/		return 0x8219B9C8;
		  /* 8219B9C8h */ case   12:  		/* mr R8, R10 */
		/* 8219B9C8h case   12:*/		regs.R8 = regs.R10;
		/* 8219B9C8h case   12:*/		return 0x8219B9CC;
	}
	return 0x8219B9CC;
} // Block from 8219B998h-8219B9CCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219B9CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B9CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B9CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B9CC);
		  /* 8219B9CCh */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219B9CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219B9CCh case    0:*/		return 0x8219B9D0;
	}
	return 0x8219B9D0;
} // Block from 8219B9CCh-8219B9D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B9D0);
		  /* 8219B9D0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8219B9D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219B9D0h case    0:*/		return 0x8219B9D4;
		  /* 8219B9D4h */ case    1:  		/* bc 4, CR6_EQ, -32 */
		/* 8219B9D4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219B9B4;  }
		/* 8219B9D4h case    1:*/		return 0x8219B9D8;
	}
	return 0x8219B9D8;
} // Block from 8219B9D0h-8219B9D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219B9D8h
// Function '?IsLocatedAfter_Sequenced@Instruction@D3DXShader@@QAA_NPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B9D8);
		  /* 8219B9D8h */ case    0:  		/* lwz R10, <#[R9 + 32]> */
		/* 8219B9D8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000020) );
		/* 8219B9D8h case    0:*/		return 0x8219B9DC;
		  /* 8219B9DCh */ case    1:  		/* b 32 */
		/* 8219B9DCh case    1:*/		return 0x8219B9FC;
		/* 8219B9DCh case    1:*/		return 0x8219B9E0;
		  /* 8219B9E0h */ case    2:  		/* lwz R9, <#[R10]> */
		/* 8219B9E0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8219B9E0h case    2:*/		return 0x8219B9E4;
		  /* 8219B9E4h */ case    3:  		/* lwz R9, <#[R9]> */
		/* 8219B9E4h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 8219B9E4h case    3:*/		return 0x8219B9E8;
		  /* 8219B9E8h */ case    4:  		/* rlwinm R9, R9, 19, 16, 31 */
		/* 8219B9E8h case    4:*/		cpu::op::rlwinm<0,19,16,31>(regs,&regs.R9,regs.R9);
		/* 8219B9E8h case    4:*/		return 0x8219B9EC;
		  /* 8219B9ECh */ case    5:  		/* cmplw CR6, R9, R11 */
		/* 8219B9ECh case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8219B9ECh case    5:*/		return 0x8219B9F0;
		  /* 8219B9F0h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 8219B9F0h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8219B9F8;  }
		/* 8219B9F0h case    6:*/		return 0x8219B9F4;
		  /* 8219B9F4h */ case    7:  		/* mr R11, R9 */
		/* 8219B9F4h case    7:*/		regs.R11 = regs.R9;
		/* 8219B9F4h case    7:*/		return 0x8219B9F8;
	}
	return 0x8219B9F8;
} // Block from 8219B9D8h-8219B9F8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219B9F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B9F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B9F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B9F8);
		  /* 8219B9F8h */ case    0:  		/* lwz R10, <#[R10 + 4]> */
		/* 8219B9F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 8219B9F8h case    0:*/		return 0x8219B9FC;
	}
	return 0x8219B9FC;
} // Block from 8219B9F8h-8219B9FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219B9FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219B9FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219B9FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219B9FC);
		  /* 8219B9FCh */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8219B9FCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219B9FCh case    0:*/		return 0x8219BA00;
		  /* 8219BA00h */ case    1:  		/* bc 4, CR6_EQ, -32 */
		/* 8219BA00h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219B9E0;  }
		/* 8219BA00h case    1:*/		return 0x8219BA04;
		  /* 8219BA04h */ case    2:  		/* cmplw CR6, R8, R11 */
		/* 8219BA04h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8219BA04h case    2:*/		return 0x8219BA08;
		  /* 8219BA08h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8219BA08h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219BA14;  }
		/* 8219BA08h case    3:*/		return 0x8219BA0C;
		  /* 8219BA0Ch */ case    4:  		/* li R3, 0 */
		/* 8219BA0Ch case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219BA0Ch case    4:*/		return 0x8219BA10;
		  /* 8219BA10h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8219BA10h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219BA10h case    5:*/		return 0x8219BA14;
	}
	return 0x8219BA14;
} // Block from 8219B9FCh-8219BA14h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219BA14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BA14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BA14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BA14);
		  /* 8219BA14h */ case    0:  		/* subfc R11, R8, R11 */
		/* 8219BA14h case    0:*/		cpu::op::subfc<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8219BA14h case    0:*/		return 0x8219BA18;
	}
	return 0x8219BA18;
} // Block from 8219BA14h-8219BA18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BA18h
// Function '?ApplyModifiersToConstraints@D3DXShader@@YAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BA18);
		  /* 8219BA18h */ case    0:  		/* subfe R11, R11, R11 */
		/* 8219BA18h case    0:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8219BA18h case    0:*/		return 0x8219BA1C;
		  /* 8219BA1Ch */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219BA1Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219BA1Ch case    1:*/		return 0x8219BA20;
		  /* 8219BA20h */ case    2:  		/* addi R3, R11, 1 */
		/* 8219BA20h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 8219BA20h case    2:*/		return 0x8219BA24;
		  /* 8219BA24h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8219BA24h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219BA24h case    3:*/		return 0x8219BA28;
	}
	return 0x8219BA28;
} // Block from 8219BA18h-8219BA28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219BA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BA28);
		  /* 8219BA28h */ case    0:  		/* mfspr R12, LR */
		/* 8219BA28h case    0:*/		regs.R12 = regs.LR;
		/* 8219BA28h case    0:*/		return 0x8219BA2C;
		  /* 8219BA2Ch */ case    1:  		/* bl -1091540 */
		/* 8219BA2Ch case    1:*/		regs.LR = 0x8219BA30; return 0x82091258;
		/* 8219BA2Ch case    1:*/		return 0x8219BA30;
		  /* 8219BA30h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8219BA30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8219BA30h case    2:*/		return 0x8219BA34;
		  /* 8219BA34h */ case    3:  		/* mr R28, R3 */
		/* 8219BA34h case    3:*/		regs.R28 = regs.R3;
		/* 8219BA34h case    3:*/		return 0x8219BA38;
		  /* 8219BA38h */ case    4:  		/* mr R31, R4 */
		/* 8219BA38h case    4:*/		regs.R31 = regs.R4;
		/* 8219BA38h case    4:*/		return 0x8219BA3C;
		  /* 8219BA3Ch */ case    5:  		/* mr R29, R5 */
		/* 8219BA3Ch case    5:*/		regs.R29 = regs.R5;
		/* 8219BA3Ch case    5:*/		return 0x8219BA40;
		  /* 8219BA40h */ case    6:  		/* cmplw CR6, R4, R5 */
		/* 8219BA40h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 8219BA40h case    6:*/		return 0x8219BA44;
		  /* 8219BA44h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 8219BA44h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8219BA50;  }
		/* 8219BA44h case    7:*/		return 0x8219BA48;
		  /* 8219BA48h */ case    8:  		/* li R3, 1 */
		/* 8219BA48h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219BA48h case    8:*/		return 0x8219BA4C;
		  /* 8219BA4Ch */ case    9:  		/* b 112 */
		/* 8219BA4Ch case    9:*/		return 0x8219BABC;
		/* 8219BA4Ch case    9:*/		return 0x8219BA50;
	}
	return 0x8219BA50;
} // Block from 8219BA28h-8219BA50h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219BA50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BA50);
		  /* 8219BA50h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219BA50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219BA50h case    0:*/		return 0x8219BA54;
		  /* 8219BA54h */ case    1:  		/* rlwinm. R10, R11, 0, 16, 16 */
		/* 8219BA54h case    1:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R11);
		/* 8219BA54h case    1:*/		return 0x8219BA58;
		  /* 8219BA58h */ case    2:  		/* bc 4, CR0_EQ, 96 */
		/* 8219BA58h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8219BAB8;  }
		/* 8219BA58h case    2:*/		return 0x8219BA5C;
		  /* 8219BA5Ch */ case    3:  		/* ori R11, R11, 32768 */
		/* 8219BA5Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8219BA5Ch case    3:*/		return 0x8219BA60;
		  /* 8219BA60h */ case    4:  		/* lwz R30, <#[R31 + 20]> */
		/* 8219BA60h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 8219BA60h case    4:*/		return 0x8219BA64;
		  /* 8219BA64h */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 8219BA64h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219BA64h case    5:*/		return 0x8219BA68;
		  /* 8219BA68h */ case    6:  		/* b 32 */
		/* 8219BA68h case    6:*/		return 0x8219BA88;
		/* 8219BA68h case    6:*/		return 0x8219BA6C;
		  /* 8219BA6Ch */ case    7:  		/* mr R5, R29 */
		/* 8219BA6Ch case    7:*/		regs.R5 = regs.R29;
		/* 8219BA6Ch case    7:*/		return 0x8219BA70;
	}
	return 0x8219BA70;
} // Block from 8219BA50h-8219BA70h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219BA70h
// Function '?GetConstraintFlags@Dependency@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BA70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BA70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BA70);
		  /* 8219BA70h */ case    0:  		/* lwz R4, <#[R30]> */
		/* 8219BA70h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 8219BA70h case    0:*/		return 0x8219BA74;
		  /* 8219BA74h */ case    1:  		/* mr R3, R28 */
		/* 8219BA74h case    1:*/		regs.R3 = regs.R28;
		/* 8219BA74h case    1:*/		return 0x8219BA78;
		  /* 8219BA78h */ case    2:  		/* bl -80 */
		/* 8219BA78h case    2:*/		regs.LR = 0x8219BA7C; return 0x8219BA28;
		/* 8219BA78h case    2:*/		return 0x8219BA7C;
		  /* 8219BA7Ch */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219BA7Ch case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219BA7Ch case    3:*/		return 0x8219BA80;
		  /* 8219BA80h */ case    4:  		/* bc 4, CR0_EQ, -56 */
		/* 8219BA80h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219BA48;  }
		/* 8219BA80h case    4:*/		return 0x8219BA84;
		  /* 8219BA84h */ case    5:  		/* lwz R30, <#[R30 + 4]> */
		/* 8219BA84h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 8219BA84h case    5:*/		return 0x8219BA88;
	}
	return 0x8219BA88;
} // Block from 8219BA70h-8219BA88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219BA88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BA88);
		  /* 8219BA88h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8219BA88h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219BA88h case    0:*/		return 0x8219BA8C;
		  /* 8219BA8Ch */ case    1:  		/* bc 4, CR6_EQ, -32 */
		/* 8219BA8Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219BA6C;  }
		/* 8219BA8Ch case    1:*/		return 0x8219BA90;
		  /* 8219BA90h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8219BA90h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219BA90h case    2:*/		return 0x8219BA94;
		  /* 8219BA94h */ case    3:  		/* rlwinm. R11, R11, 0, 3, 18 */
		/* 8219BA94h case    3:*/		cpu::op::rlwinm<1,0,3,18>(regs,&regs.R11,regs.R11);
		/* 8219BA94h case    3:*/		return 0x8219BA98;
		  /* 8219BA98h */ case    4:  		/* bc 4, CR0_EQ, 32 */
		/* 8219BA98h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219BAB8;  }
		/* 8219BA98h case    4:*/		return 0x8219BA9C;
		  /* 8219BA9Ch */ case    5:  		/* mr R5, R29 */
		/* 8219BA9Ch case    5:*/		regs.R5 = regs.R29;
		/* 8219BA9Ch case    5:*/		return 0x8219BAA0;
		  /* 8219BAA0h */ case    6:  		/* lwz R4, <#[R31 + 24]> */
		/* 8219BAA0h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 8219BAA0h case    6:*/		return 0x8219BAA4;
		  /* 8219BAA4h */ case    7:  		/* mr R3, R28 */
		/* 8219BAA4h case    7:*/		regs.R3 = regs.R28;
		/* 8219BAA4h case    7:*/		return 0x8219BAA8;
		  /* 8219BAA8h */ case    8:  		/* bl -128 */
		/* 8219BAA8h case    8:*/		regs.LR = 0x8219BAAC; return 0x8219BA28;
		/* 8219BAA8h case    8:*/		return 0x8219BAAC;
		  /* 8219BAACh */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219BAACh case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219BAACh case    9:*/		return 0x8219BAB0;
		  /* 8219BAB0h */ case   10:  		/* li R3, 1 */
		/* 8219BAB0h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219BAB0h case   10:*/		return 0x8219BAB4;
		  /* 8219BAB4h */ case   11:  		/* bc 4, CR0_EQ, 8 */
		/* 8219BAB4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x8219BABC;  }
		/* 8219BAB4h case   11:*/		return 0x8219BAB8;
	}
	return 0x8219BAB8;
} // Block from 8219BA88h-8219BAB8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219BAB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BAB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BAB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BAB8);
		  /* 8219BAB8h */ case    0:  		/* li R3, 0 */
		/* 8219BAB8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219BAB8h case    0:*/		return 0x8219BABC;
	}
	return 0x8219BABC;
} // Block from 8219BAB8h-8219BABCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BABC);
		  /* 8219BABCh */ case    0:  		/* addi R1, R1, 128 */
		/* 8219BABCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8219BABCh case    0:*/		return 0x8219BAC0;
	}
	return 0x8219BAC0;
} // Block from 8219BABCh-8219BAC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BAC0h
// Function '?IsAlwaysZero@Dependency@D3DXShader@@QAA_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BAC0);
		  /* 8219BAC0h */ case    0:  		/* b -1091608 */
		/* 8219BAC0h case    0:*/		return 0x820912A8;
		/* 8219BAC0h case    0:*/		return 0x8219BAC4;
		  /* 8219BAC4h */ case    1:  		/* nop */
		/* 8219BAC4h case    1:*/		cpu::op::nop();
		/* 8219BAC4h case    1:*/		return 0x8219BAC8;
	}
	return 0x8219BAC8;
} // Block from 8219BAC0h-8219BAC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219BAC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BAC8);
		  /* 8219BAC8h */ case    0:  		/* mfspr R12, LR */
		/* 8219BAC8h case    0:*/		regs.R12 = regs.LR;
		/* 8219BAC8h case    0:*/		return 0x8219BACC;
		  /* 8219BACCh */ case    1:  		/* bl -1091696 */
		/* 8219BACCh case    1:*/		regs.LR = 0x8219BAD0; return 0x8209125C;
		/* 8219BACCh case    1:*/		return 0x8219BAD0;
		  /* 8219BAD0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8219BAD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8219BAD0h case    2:*/		return 0x8219BAD4;
		  /* 8219BAD4h */ case    3:  		/* mr R29, R3 */
		/* 8219BAD4h case    3:*/		regs.R29 = regs.R3;
		/* 8219BAD4h case    3:*/		return 0x8219BAD8;
		  /* 8219BAD8h */ case    4:  		/* mr R31, R4 */
		/* 8219BAD8h case    4:*/		regs.R31 = regs.R4;
		/* 8219BAD8h case    4:*/		return 0x8219BADC;
		  /* 8219BADCh */ case    5:  		/* b 64 */
		/* 8219BADCh case    5:*/		return 0x8219BB1C;
		/* 8219BADCh case    5:*/		return 0x8219BAE0;
		  /* 8219BAE0h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219BAE0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219BAE0h case    6:*/		return 0x8219BAE4;
		  /* 8219BAE4h */ case    7:  		/* lwz R30, <#[R31 + 20]> */
		/* 8219BAE4h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 8219BAE4h case    7:*/		return 0x8219BAE8;
		  /* 8219BAE8h */ case    8:  		/* rlwinm R11, R11, 0, 17, 15 */
		/* 8219BAE8h case    8:*/		cpu::op::rlwinm<0,0,17,15>(regs,&regs.R11,regs.R11);
		/* 8219BAE8h case    8:*/		return 0x8219BAEC;
		  /* 8219BAECh */ case    9:  		/* stw R11, <#[R31 + 8]> */
		/* 8219BAECh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219BAECh case    9:*/		return 0x8219BAF0;
	}
	return 0x8219BAF0;
} // Block from 8219BAC8h-8219BAF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219BAF0h
// Function '?IsTransformationEnabled@Compiler@D3DXShader@@QAA_NW4DebugOption@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BAF0);
		  /* 8219BAF0h */ case    0:  		/* b 20 */
		/* 8219BAF0h case    0:*/		return 0x8219BB04;
		/* 8219BAF0h case    0:*/		return 0x8219BAF4;
		  /* 8219BAF4h */ case    1:  		/* mr R3, R29 */
		/* 8219BAF4h case    1:*/		regs.R3 = regs.R29;
		/* 8219BAF4h case    1:*/		return 0x8219BAF8;
		  /* 8219BAF8h */ case    2:  		/* lwz R4, <#[R30]> */
		/* 8219BAF8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 8219BAF8h case    2:*/		return 0x8219BAFC;
		  /* 8219BAFCh */ case    3:  		/* bl -52 */
		/* 8219BAFCh case    3:*/		regs.LR = 0x8219BB00; return 0x8219BAC8;
		/* 8219BAFCh case    3:*/		return 0x8219BB00;
		  /* 8219BB00h */ case    4:  		/* lwz R30, <#[R30 + 4]> */
		/* 8219BB00h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 8219BB00h case    4:*/		return 0x8219BB04;
	}
	return 0x8219BB04;
} // Block from 8219BAF0h-8219BB04h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219BB04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BB04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BB04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BB04);
		  /* 8219BB04h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8219BB04h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219BB04h case    0:*/		return 0x8219BB08;
		  /* 8219BB08h */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 8219BB08h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219BAF4;  }
		/* 8219BB08h case    1:*/		return 0x8219BB0C;
		  /* 8219BB0Ch */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8219BB0Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219BB0Ch case    2:*/		return 0x8219BB10;
		  /* 8219BB10h */ case    3:  		/* rlwinm. R11, R11, 0, 3, 18 */
		/* 8219BB10h case    3:*/		cpu::op::rlwinm<1,0,3,18>(regs,&regs.R11,regs.R11);
		/* 8219BB10h case    3:*/		return 0x8219BB14;
		  /* 8219BB14h */ case    4:  		/* bc 4, CR0_EQ, 20 */
		/* 8219BB14h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219BB28;  }
		/* 8219BB14h case    4:*/		return 0x8219BB18;
		  /* 8219BB18h */ case    5:  		/* lwz R31, <#[R31 + 24]> */
		/* 8219BB18h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000018) );
		/* 8219BB18h case    5:*/		return 0x8219BB1C;
	}
	return 0x8219BB1C;
} // Block from 8219BB04h-8219BB1Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219BB1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BB1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BB1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BB1C);
		  /* 8219BB1Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219BB1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219BB1Ch case    0:*/		return 0x8219BB20;
		  /* 8219BB20h */ case    1:  		/* rlwinm. R11, R11, 0, 16, 16 */
		/* 8219BB20h case    1:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R11);
		/* 8219BB20h case    1:*/		return 0x8219BB24;
		  /* 8219BB24h */ case    2:  		/* bc 4, CR0_EQ, -68 */
		/* 8219BB24h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8219BAE0;  }
		/* 8219BB24h case    2:*/		return 0x8219BB28;
	}
	return 0x8219BB28;
} // Block from 8219BB1Ch-8219BB28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219BB28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BB28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BB28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BB28);
		  /* 8219BB28h */ case    0:  		/* addi R1, R1, 112 */
		/* 8219BB28h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8219BB28h case    0:*/		return 0x8219BB2C;
		  /* 8219BB2Ch */ case    1:  		/* b -1091712 */
		/* 8219BB2Ch case    1:*/		return 0x820912AC;
		/* 8219BB2Ch case    1:*/		return 0x8219BB30;
		  /* 8219BB30h */ case    2:  		/* lwz R11, <#[R4 + 32]> */
		/* 8219BB30h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000020) );
		/* 8219BB30h case    2:*/		return 0x8219BB34;
		  /* 8219BB34h */ case    3:  		/* addi R6, R4, 32 */
		/* 8219BB34h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R4,0x20);
		/* 8219BB34h case    3:*/		return 0x8219BB38;
		  /* 8219BB38h */ case    4:  		/* b 116 */
		/* 8219BB38h case    4:*/		return 0x8219BBAC;
		/* 8219BB38h case    4:*/		return 0x8219BB3C;
		  /* 8219BB3Ch */ case    5:  		/* lwz R9, <#[R11]> */
		/* 8219BB3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8219BB3Ch case    5:*/		return 0x8219BB40;
		  /* 8219BB40h */ case    6:  		/* li R10, 0 */
		/* 8219BB40h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219BB40h case    6:*/		return 0x8219BB44;
		  /* 8219BB44h */ case    7:  		/* lwz R8, <#[R9]> */
		/* 8219BB44h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 8219BB44h case    7:*/		return 0x8219BB48;
		  /* 8219BB48h */ case    8:  		/* rlwinm. R7, R8, 0, 19, 31 */
		/* 8219BB48h case    8:*/		cpu::op::rlwinm<1,0,19,31>(regs,&regs.R7,regs.R8);
		/* 8219BB48h case    8:*/		return 0x8219BB4C;
		  /* 8219BB4Ch */ case    9:  		/* bc 12, CR0_EQ, 72 */
		/* 8219BB4Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8219BB94;  }
		/* 8219BB4Ch case    9:*/		return 0x8219BB50;
	}
	return 0x8219BB50;
} // Block from 8219BB28h-8219BB50h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219BB50h
// Function '?AddMergeDefinitionWorker@Compiler@D3DXShader@@AAA_NPAUMergeGroupInfo@2@PAVInstruction@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BB50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BB50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BB50);
		  /* 8219BB50h */ case    0:  		/* addi R8, R9, 24 */
		/* 8219BB50h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x18);
		/* 8219BB50h case    0:*/		return 0x8219BB54;
		  /* 8219BB54h */ case    1:  		/* lwz R3, <#[R8]> */
		/* 8219BB54h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + 0x00000000) );
		/* 8219BB54h case    1:*/		return 0x8219BB58;
		  /* 8219BB58h */ case    2:  		/* cmplw CR6, R3, R4 */
		/* 8219BB58h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 8219BB58h case    2:*/		return 0x8219BB5C;
		  /* 8219BB5Ch */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 8219BB5Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8219BB74;  }
		/* 8219BB5Ch case    3:*/		return 0x8219BB60;
		  /* 8219BB60h */ case    4:  		/* addi R10, R10, 1 */
		/* 8219BB60h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8219BB60h case    4:*/		return 0x8219BB64;
		  /* 8219BB64h */ case    5:  		/* addi R8, R8, 4 */
		/* 8219BB64h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8219BB64h case    5:*/		return 0x8219BB68;
		  /* 8219BB68h */ case    6:  		/* cmplw CR6, R10, R7 */
		/* 8219BB68h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8219BB68h case    6:*/		return 0x8219BB6C;
		  /* 8219BB6Ch */ case    7:  		/* bc 12, CR6_LT, -24 */
		/* 8219BB6Ch case    7:*/		if ( regs.CR[6].lt ) { return 0x8219BB54;  }
		/* 8219BB6Ch case    7:*/		return 0x8219BB70;
		  /* 8219BB70h */ case    8:  		/* b 36 */
		/* 8219BB70h case    8:*/		return 0x8219BB94;
		/* 8219BB70h case    8:*/		return 0x8219BB74;
	}
	return 0x8219BB74;
} // Block from 8219BB50h-8219BB74h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219BB74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BB74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BB74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BB74);
		  /* 8219BB74h */ case    0:  		/* addi R8, R10, 6 */
		/* 8219BB74h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x6);
		/* 8219BB74h case    0:*/		return 0x8219BB78;
		  /* 8219BB78h */ case    1:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 8219BB78h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 8219BB78h case    1:*/		return 0x8219BB7C;
		  /* 8219BB7Ch */ case    2:  		/* stwx R5, <#[R8 + R9]> */
		/* 8219BB7Ch case    2:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8219BB7Ch case    2:*/		return 0x8219BB80;
		  /* 8219BB80h */ case    3:  		/* lwz R8, <#[R11 + 4]> */
		/* 8219BB80h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8219BB80h case    3:*/		return 0x8219BB84;
		  /* 8219BB84h */ case    4:  		/* stw R8, <#[R6]> */
		/* 8219BB84h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000000) );
		/* 8219BB84h case    4:*/		return 0x8219BB88;
		  /* 8219BB88h */ case    5:  		/* lwz R8, <#[R5 + 32]> */
		/* 8219BB88h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000020) );
		/* 8219BB88h case    5:*/		return 0x8219BB8C;
		  /* 8219BB8Ch */ case    6:  		/* stw R8, <#[R11 + 4]> */
		/* 8219BB8Ch case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8219BB8Ch case    6:*/		return 0x8219BB90;
		  /* 8219BB90h */ case    7:  		/* stw R11, <#[R5 + 32]> */
		/* 8219BB90h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000020) );
		/* 8219BB90h case    7:*/		return 0x8219BB94;
	}
	return 0x8219BB94;
} // Block from 8219BB74h-8219BB94h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219BB94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BB94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BB94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BB94);
		  /* 8219BB94h */ case    0:  		/* lwz R9, <#[R9]> */
		/* 8219BB94h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 8219BB94h case    0:*/		return 0x8219BB98;
		  /* 8219BB98h */ case    1:  		/* rlwinm R9, R9, 0, 19, 31 */
		/* 8219BB98h case    1:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R9,regs.R9);
		/* 8219BB98h case    1:*/		return 0x8219BB9C;
		  /* 8219BB9Ch */ case    2:  		/* cmplw CR6, R10, R9 */
		/* 8219BB9Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8219BB9Ch case    2:*/		return 0x8219BBA0;
		  /* 8219BBA0h */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 8219BBA0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219BBA8;  }
		/* 8219BBA0h case    3:*/		return 0x8219BBA4;
		  /* 8219BBA4h */ case    4:  		/* addi R6, R11, 4 */
		/* 8219BBA4h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x4);
		/* 8219BBA4h case    4:*/		return 0x8219BBA8;
	}
	return 0x8219BBA8;
} // Block from 8219BB94h-8219BBA8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219BBA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BBA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BBA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BBA8);
		  /* 8219BBA8h */ case    0:  		/* lwz R11, <#[R6]> */
		/* 8219BBA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 8219BBA8h case    0:*/		return 0x8219BBAC;
	}
	return 0x8219BBAC;
} // Block from 8219BBA8h-8219BBACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BBACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BBAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BBAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BBAC);
		  /* 8219BBACh */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8219BBACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219BBACh case    0:*/		return 0x8219BBB0;
		  /* 8219BBB0h */ case    1:  		/* bc 4, CR6_EQ, -116 */
		/* 8219BBB0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219BB3C;  }
		/* 8219BBB0h case    1:*/		return 0x8219BBB4;
		  /* 8219BBB4h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8219BBB4h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219BBB4h case    2:*/		return 0x8219BBB8;
	}
	return 0x8219BBB8;
} // Block from 8219BBACh-8219BBB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219BBB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BBB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BBB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BBB8);
		  /* 8219BBB8h */ case    0:  		/* lwz R7, <#[R4 + 32]> */
		/* 8219BBB8h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000020) );
		/* 8219BBB8h case    0:*/		return 0x8219BBBC;
		  /* 8219BBBCh */ case    1:  		/* li R3, 0 */
		/* 8219BBBCh case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219BBBCh case    1:*/		return 0x8219BBC0;
		  /* 8219BBC0h */ case    2:  		/* b 80 */
		/* 8219BBC0h case    2:*/		return 0x8219BC10;
		/* 8219BBC0h case    2:*/		return 0x8219BBC4;
		  /* 8219BBC4h */ case    3:  		/* lwz R11, <#[R7]> */
		/* 8219BBC4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 8219BBC4h case    3:*/		return 0x8219BBC8;
		  /* 8219BBC8h */ case    4:  		/* li R10, 0 */
		/* 8219BBC8h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219BBC8h case    4:*/		return 0x8219BBCC;
		  /* 8219BBCCh */ case    5:  		/* lwz R8, <#[R11]> */
		/* 8219BBCCh case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8219BBCCh case    5:*/		return 0x8219BBD0;
		  /* 8219BBD0h */ case    6:  		/* rlwinm. R9, R8, 0, 19, 31 */
		/* 8219BBD0h case    6:*/		cpu::op::rlwinm<1,0,19,31>(regs,&regs.R9,regs.R8);
		/* 8219BBD0h case    6:*/		return 0x8219BBD4;
		  /* 8219BBD4h */ case    7:  		/* bc 12, CR0_EQ, 56 */
		/* 8219BBD4h case    7:*/		if ( regs.CR[0].eq ) { return 0x8219BC0C;  }
		/* 8219BBD4h case    7:*/		return 0x8219BBD8;
		  /* 8219BBD8h */ case    8:  		/* addi R11, R11, 24 */
		/* 8219BBD8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 8219BBD8h case    8:*/		return 0x8219BBDC;
		  /* 8219BBDCh */ case    9:  		/* lwz R6, <#[R11]> */
		/* 8219BBDCh case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8219BBDCh case    9:*/		return 0x8219BBE0;
		  /* 8219BBE0h */ case   10:  		/* cmplw CR6, R5, R6 */
		/* 8219BBE0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 8219BBE0h case   10:*/		return 0x8219BBE4;
		  /* 8219BBE4h */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 8219BBE4h case   11:*/		if ( regs.CR[6].eq ) { return 0x8219BBFC;  }
		/* 8219BBE4h case   11:*/		return 0x8219BBE8;
		  /* 8219BBE8h */ case   12:  		/* addi R10, R10, 1 */
		/* 8219BBE8h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8219BBE8h case   12:*/		return 0x8219BBEC;
		  /* 8219BBECh */ case   13:  		/* addi R11, R11, 4 */
		/* 8219BBECh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219BBECh case   13:*/		return 0x8219BBF0;
		  /* 8219BBF0h */ case   14:  		/* cmplw CR6, R10, R9 */
		/* 8219BBF0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 8219BBF0h case   14:*/		return 0x8219BBF4;
		  /* 8219BBF4h */ case   15:  		/* bc 12, CR6_LT, -24 */
		/* 8219BBF4h case   15:*/		if ( regs.CR[6].lt ) { return 0x8219BBDC;  }
		/* 8219BBF4h case   15:*/		return 0x8219BBF8;
		  /* 8219BBF8h */ case   16:  		/* b 20 */
		/* 8219BBF8h case   16:*/		return 0x8219BC0C;
		/* 8219BBF8h case   16:*/		return 0x8219BBFC;
	}
	return 0x8219BBFC;
} // Block from 8219BBB8h-8219BBFCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219BBFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BBFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BBFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BBFC);
		  /* 8219BBFCh */ case    0:  		/* rlwinm R11, R8, 19, 16, 31 */
		/* 8219BBFCh case    0:*/		cpu::op::rlwinm<0,19,16,31>(regs,&regs.R11,regs.R8);
		/* 8219BBFCh case    0:*/		return 0x8219BC00;
		  /* 8219BC00h */ case    1:  		/* cmplw CR6, R11, R3 */
		/* 8219BC00h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 8219BC00h case    1:*/		return 0x8219BC04;
		  /* 8219BC04h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 8219BC04h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8219BC0C;  }
		/* 8219BC04h case    2:*/		return 0x8219BC08;
		  /* 8219BC08h */ case    3:  		/* mr R3, R11 */
		/* 8219BC08h case    3:*/		regs.R3 = regs.R11;
		/* 8219BC08h case    3:*/		return 0x8219BC0C;
	}
	return 0x8219BC0C;
} // Block from 8219BBFCh-8219BC0Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219BC0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BC0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BC0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BC0C);
		  /* 8219BC0Ch */ case    0:  		/* lwz R7, <#[R7 + 4]> */
		/* 8219BC0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 8219BC0Ch case    0:*/		return 0x8219BC10;
	}
	return 0x8219BC10;
} // Block from 8219BC0Ch-8219BC10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BC10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BC10);
		  /* 8219BC10h */ case    0:  		/* cmplwi CR6, R7, 0 */
		/* 8219BC10h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 8219BC10h case    0:*/		return 0x8219BC14;
		  /* 8219BC14h */ case    1:  		/* bc 4, CR6_EQ, -80 */
		/* 8219BC14h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219BBC4;  }
		/* 8219BC14h case    1:*/		return 0x8219BC18;
	}
	return 0x8219BC18;
} // Block from 8219BC10h-8219BC18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219BC18h
// Function '?ExamineConstant@Compiler@D3DXShader@@AAAIPAVInstruction@2@IIIQAM@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BC18);
		  /* 8219BC18h */ case    0:  		/* bclr 20, CR0_LT */
		/* 8219BC18h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219BC18h case    0:*/		return 0x8219BC1C;
	}
	return 0x8219BC1C;
} // Block from 8219BC18h-8219BC1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BC1C);
		  /* 8219BC1Ch */ case    0:  		/* nop */
		/* 8219BC1Ch case    0:*/		cpu::op::nop();
		/* 8219BC1Ch case    0:*/		return 0x8219BC20;
	}
	return 0x8219BC20;
} // Block from 8219BC1Ch-8219BC20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BC20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BC20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BC20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BC20);
		  /* 8219BC20h */ case    0:  		/* mfspr R12, LR */
		/* 8219BC20h case    0:*/		regs.R12 = regs.LR;
		/* 8219BC20h case    0:*/		return 0x8219BC24;
		  /* 8219BC24h */ case    1:  		/* bl -1092040 */
		/* 8219BC24h case    1:*/		regs.LR = 0x8219BC28; return 0x8209125C;
		/* 8219BC24h case    1:*/		return 0x8219BC28;
		  /* 8219BC28h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8219BC28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8219BC28h case    2:*/		return 0x8219BC2C;
		  /* 8219BC2Ch */ case    3:  		/* lwz R30, <#[R4 + 8]> */
		/* 8219BC2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x00000008) );
		/* 8219BC2Ch case    3:*/		return 0x8219BC30;
		  /* 8219BC30h */ case    4:  		/* mr R10, R4 */
		/* 8219BC30h case    4:*/		regs.R10 = regs.R4;
		/* 8219BC30h case    4:*/		return 0x8219BC34;
		  /* 8219BC34h */ case    5:  		/* mr R29, R5 */
		/* 8219BC34h case    5:*/		regs.R29 = regs.R5;
		/* 8219BC34h case    5:*/		return 0x8219BC38;
		  /* 8219BC38h */ case    6:  		/* rlwinm R11, R30, 25, 25, 31 */
		/* 8219BC38h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R30);
		/* 8219BC38h case    6:*/		return 0x8219BC3C;
		  /* 8219BC3Ch */ case    7:  		/* li R31, 6 */
		/* 8219BC3Ch case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x6);
		/* 8219BC3Ch case    7:*/		return 0x8219BC40;
		  /* 8219BC40h */ case    8:  		/* cmpwi CR6, R11, 3 */
		/* 8219BC40h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 8219BC40h case    8:*/		return 0x8219BC44;
		  /* 8219BC44h */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 8219BC44h case    9:*/		if ( regs.CR[6].eq ) { return 0x8219BC6C;  }
		/* 8219BC44h case    9:*/		return 0x8219BC48;
		  /* 8219BC48h */ case   10:  		/* cmpwi CR6, R11, 100 */
		/* 8219BC48h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000064);
		/* 8219BC48h case   10:*/		return 0x8219BC4C;
		  /* 8219BC4Ch */ case   11:  		/* bc 12, CR6_EQ, 148 */
		/* 8219BC4Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x8219BCE0;  }
		/* 8219BC4Ch case   11:*/		return 0x8219BC50;
		  /* 8219BC50h */ case   12:  		/* cmpwi CR6, R11, 110 */
		/* 8219BC50h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006E);
		/* 8219BC50h case   12:*/		return 0x8219BC54;
		  /* 8219BC54h */ case   13:  		/* bc 12, CR6_EQ, 84 */
		/* 8219BC54h case   13:*/		if ( regs.CR[6].eq ) { return 0x8219BCA8;  }
		/* 8219BC54h case   13:*/		return 0x8219BC58;
		  /* 8219BC58h */ case   14:  		/* cmpwi CR6, R11, 113 */
		/* 8219BC58h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000071);
		/* 8219BC58h case   14:*/		return 0x8219BC5C;
		  /* 8219BC5Ch */ case   15:  		/* bc 12, CR6_EQ, 76 */
		/* 8219BC5Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x8219BCA8;  }
		/* 8219BC5Ch case   15:*/		return 0x8219BC60;
		  /* 8219BC60h */ case   16:  		/* cmpwi CR6, R11, 124 */
		/* 8219BC60h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000007C);
		/* 8219BC60h case   16:*/		return 0x8219BC64;
		  /* 8219BC64h */ case   17:  		/* bc 4, CR6_EQ, 40 */
		/* 8219BC64h case   17:*/		if ( !regs.CR[6].eq ) { return 0x8219BC8C;  }
		/* 8219BC64h case   17:*/		return 0x8219BC68;
		  /* 8219BC68h */ case   18:  		/* b 64 */
		/* 8219BC68h case   18:*/		return 0x8219BCA8;
		/* 8219BC68h case   18:*/		return 0x8219BC6C;
	}
	return 0x8219BC6C;
} // Block from 8219BC20h-8219BC6Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8219BC6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BC6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BC6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BC6C);
		  /* 8219BC6Ch */ case    0:  		/* rlwinm R11, R30, 0, 15, 17 */
		/* 8219BC6Ch case    0:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R30);
		/* 8219BC6Ch case    0:*/		return 0x8219BC70;
		  /* 8219BC70h */ case    1:  		/* cmplwi CR6, R11, 16384 */
		/* 8219BC70h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00004000);
		/* 8219BC70h case    1:*/		return 0x8219BC74;
		  /* 8219BC74h */ case    2:  		/* bc 4, CR6_EQ, 24 */
		/* 8219BC74h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8219BC8C;  }
		/* 8219BC74h case    2:*/		return 0x8219BC78;
		  /* 8219BC78h */ case    3:  		/* lwz R4, <#[R10 + 48]> */
		/* 8219BC78h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000030) );
		/* 8219BC78h case    3:*/		return 0x8219BC7C;
		  /* 8219BC7Ch */ case    4:  		/* lwz R3, <#[R10 + 44]> */
		/* 8219BC7Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x0000002C) );
		/* 8219BC7Ch case    4:*/		return 0x8219BC80;
		  /* 8219BC80h */ case    5:  		/* bl -227832 */
		/* 8219BC80h case    5:*/		regs.LR = 0x8219BC84; return 0x82164288;
		/* 8219BC80h case    5:*/		return 0x8219BC84;
		  /* 8219BC84h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219BC84h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219BC84h case    6:*/		return 0x8219BC88;
		  /* 8219BC88h */ case    7:  		/* bc 4, CR0_EQ, 32 */
		/* 8219BC88h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8219BCA8;  }
		/* 8219BC88h case    7:*/		return 0x8219BC8C;
	}
	return 0x8219BC8C;
} // Block from 8219BC6Ch-8219BC8Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219BC8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BC8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BC8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BC8C);
		  /* 8219BC8Ch */ case    0:  		/* rlwinm R11, R30, 18, 29, 31 */
		/* 8219BC8Ch case    0:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R30);
		/* 8219BC8Ch case    0:*/		return 0x8219BC90;
		  /* 8219BC90h */ case    1:  		/* cmplwi CR6, R11, 2 */
		/* 8219BC90h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 8219BC90h case    1:*/		return 0x8219BC94;
		  /* 8219BC94h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 8219BC94h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219BCD0;  }
		/* 8219BC94h case    2:*/		return 0x8219BC98;
		  /* 8219BC98h */ case    3:  		/* cmplwi CR6, R11, 3 */
		/* 8219BC98h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8219BC98h case    3:*/		return 0x8219BC9C;
		  /* 8219BC9Ch */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 8219BC9Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8219BCBC;  }
		/* 8219BC9Ch case    4:*/		return 0x8219BCA0;
		  /* 8219BCA0h */ case    5:  		/* cmplwi CR6, R11, 4 */
		/* 8219BCA0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8219BCA0h case    5:*/		return 0x8219BCA4;
		  /* 8219BCA4h */ case    6:  		/* bc 4, CR6_EQ, 60 */
		/* 8219BCA4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219BCE0;  }
		/* 8219BCA4h case    6:*/		return 0x8219BCA8;
	}
	return 0x8219BCA8;
} // Block from 8219BC8Ch-8219BCA8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219BCA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BCA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BCA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BCA8);
		  /* 8219BCA8h */ case    0:  		/* subfic R11, R29, 0 */
		/* 8219BCA8h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R29,0x0);
		/* 8219BCA8h case    0:*/		return 0x8219BCAC;
		  /* 8219BCACh */ case    1:  		/* li R10, 2 */
		/* 8219BCACh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 8219BCACh case    1:*/		return 0x8219BCB0;
		  /* 8219BCB0h */ case    2:  		/* subfe R11, R11, R11 */
		/* 8219BCB0h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8219BCB0h case    2:*/		return 0x8219BCB4;
		  /* 8219BCB4h */ case    3:  		/* and R31, R11, R10 */
		/* 8219BCB4h case    3:*/		cpu::op::and<0>(regs,&regs.R31,regs.R11,regs.R10);
		/* 8219BCB4h case    3:*/		return 0x8219BCB8;
		  /* 8219BCB8h */ case    4:  		/* b 40 */
		/* 8219BCB8h case    4:*/		return 0x8219BCE0;
		/* 8219BCB8h case    4:*/		return 0x8219BCBC;
	}
	return 0x8219BCBC;
} // Block from 8219BCA8h-8219BCBCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219BCBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BCBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BCBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BCBC);
		  /* 8219BCBCh */ case    0:  		/* subfic R11, R29, 0 */
		/* 8219BCBCh case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R29,0x0);
		/* 8219BCBCh case    0:*/		return 0x8219BCC0;
		  /* 8219BCC0h */ case    1:  		/* subfe R11, R11, R11 */
		/* 8219BCC0h case    1:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8219BCC0h case    1:*/		return 0x8219BCC4;
		  /* 8219BCC4h */ case    2:  		/* rlwinm R11, R11, 0, 30, 30 */
		/* 8219BCC4h case    2:*/		cpu::op::rlwinm<0,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8219BCC4h case    2:*/		return 0x8219BCC8;
		  /* 8219BCC8h */ case    3:  		/* addi R31, R11, 1 */
		/* 8219BCC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x1);
		/* 8219BCC8h case    3:*/		return 0x8219BCCC;
		  /* 8219BCCCh */ case    4:  		/* b 20 */
		/* 8219BCCCh case    4:*/		return 0x8219BCE0;
		/* 8219BCCCh case    4:*/		return 0x8219BCD0;
	}
	return 0x8219BCD0;
} // Block from 8219BCBCh-8219BCD0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219BCD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BCD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BCD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BCD0);
		  /* 8219BCD0h */ case    0:  		/* cntlzw R11, R29 */
		/* 8219BCD0h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R29);
		/* 8219BCD0h case    0:*/		return 0x8219BCD4;
		  /* 8219BCD4h */ case    1:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8219BCD4h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8219BCD4h case    1:*/		return 0x8219BCD8;
		  /* 8219BCD8h */ case    2:  		/* xori R11, R11, 1 */
		/* 8219BCD8h case    2:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219BCD8h case    2:*/		return 0x8219BCDC;
		  /* 8219BCDCh */ case    3:  		/* addi R31, R11, 4 */
		/* 8219BCDCh case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4);
		/* 8219BCDCh case    3:*/		return 0x8219BCE0;
	}
	return 0x8219BCE0;
} // Block from 8219BCD0h-8219BCE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219BCE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BCE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BCE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BCE0);
		  /* 8219BCE0h */ case    0:  		/* mr R3, R31 */
		/* 8219BCE0h case    0:*/		regs.R3 = regs.R31;
		/* 8219BCE0h case    0:*/		return 0x8219BCE4;
		  /* 8219BCE4h */ case    1:  		/* addi R1, R1, 112 */
		/* 8219BCE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8219BCE4h case    1:*/		return 0x8219BCE8;
	}
	return 0x8219BCE8;
} // Block from 8219BCE0h-8219BCE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219BCE8h
// Function '?ExamineConstantPair@Compiler@D3DXShader@@AAAIQAMI0I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BCE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BCE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BCE8);
		  /* 8219BCE8h */ case    0:  		/* b -1092156 */
		/* 8219BCE8h case    0:*/		return 0x820912AC;
		/* 8219BCE8h case    0:*/		return 0x8219BCEC;
		  /* 8219BCECh */ case    1:  		/* nop */
		/* 8219BCECh case    1:*/		cpu::op::nop();
		/* 8219BCECh case    1:*/		return 0x8219BCF0;
	}
	return 0x8219BCF0;
} // Block from 8219BCE8h-8219BCF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219BCF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BCF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BCF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BCF0);
		  /* 8219BCF0h */ case    0:  		/* mfspr R12, LR */
		/* 8219BCF0h case    0:*/		regs.R12 = regs.LR;
		/* 8219BCF0h case    0:*/		return 0x8219BCF4;
		  /* 8219BCF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219BCF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219BCF4h case    1:*/		return 0x8219BCF8;
		  /* 8219BCF8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8219BCF8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219BCF8h case    2:*/		return 0x8219BCFC;
		  /* 8219BCFCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8219BCFCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8219BCFCh case    3:*/		return 0x8219BD00;
		  /* 8219BD00h */ case    4:  		/* mr R31, R3 */
		/* 8219BD00h case    4:*/		regs.R31 = regs.R3;
		/* 8219BD00h case    4:*/		return 0x8219BD04;
		  /* 8219BD04h */ case    5:  		/* bl -175956 */
		/* 8219BD04h case    5:*/		regs.LR = 0x8219BD08; return 0x82170DB0;
		/* 8219BD04h case    5:*/		return 0x8219BD08;
		  /* 8219BD08h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219BD08h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219BD08h case    6:*/		return 0x8219BD0C;
		  /* 8219BD0Ch */ case    7:  		/* bc 4, CR0_EQ, 24 */
		/* 8219BD0Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x8219BD24;  }
		/* 8219BD0Ch case    7:*/		return 0x8219BD10;
		  /* 8219BD10h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219BD10h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219BD10h case    8:*/		return 0x8219BD14;
		  /* 8219BD14h */ case    9:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219BD14h case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219BD14h case    9:*/		return 0x8219BD18;
		  /* 8219BD18h */ case   10:  		/* cmplwi CR6, R11, 12800 */
		/* 8219BD18h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003200);
		/* 8219BD18h case   10:*/		return 0x8219BD1C;
		  /* 8219BD1Ch */ case   11:  		/* li R11, 0 */
		/* 8219BD1Ch case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219BD1Ch case   11:*/		return 0x8219BD20;
		  /* 8219BD20h */ case   12:  		/* bc 4, CR6_EQ, 8 */
		/* 8219BD20h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8219BD28;  }
		/* 8219BD20h case   12:*/		return 0x8219BD24;
	}
	return 0x8219BD24;
} // Block from 8219BCF0h-8219BD24h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219BD24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BD24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BD24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BD24);
		  /* 8219BD24h */ case    0:  		/* li R11, 1 */
		/* 8219BD24h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219BD24h case    0:*/		return 0x8219BD28;
	}
	return 0x8219BD28;
} // Block from 8219BD24h-8219BD28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BD28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BD28);
		  /* 8219BD28h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8219BD28h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8219BD28h case    0:*/		return 0x8219BD2C;
		  /* 8219BD2Ch */ case    1:  		/* addi R1, R1, 96 */
		/* 8219BD2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8219BD2Ch case    1:*/		return 0x8219BD30;
		  /* 8219BD30h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219BD30h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219BD30h case    2:*/		return 0x8219BD34;
		  /* 8219BD34h */ case    3:  		/* mtspr LR, R12 */
		/* 8219BD34h case    3:*/		regs.LR = regs.R12;
		/* 8219BD34h case    3:*/		return 0x8219BD38;
		  /* 8219BD38h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8219BD38h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219BD38h case    4:*/		return 0x8219BD3C;
		  /* 8219BD3Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8219BD3Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219BD3Ch case    5:*/		return 0x8219BD40;
	}
	return 0x8219BD40;
} // Block from 8219BD28h-8219BD40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219BD40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BD40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BD40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BD40);
		  /* 8219BD40h */ case    0:  		/* mfspr R12, LR */
		/* 8219BD40h case    0:*/		regs.R12 = regs.LR;
		/* 8219BD40h case    0:*/		return 0x8219BD44;
		  /* 8219BD44h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219BD44h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219BD44h case    1:*/		return 0x8219BD48;
		  /* 8219BD48h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8219BD48h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219BD48h case    2:*/		return 0x8219BD4C;
		  /* 8219BD4Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8219BD4Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8219BD4Ch case    3:*/		return 0x8219BD50;
		  /* 8219BD50h */ case    4:  		/* mr R31, R3 */
		/* 8219BD50h case    4:*/		regs.R31 = regs.R3;
		/* 8219BD50h case    4:*/		return 0x8219BD54;
		  /* 8219BD54h */ case    5:  		/* mr R3, R4 */
		/* 8219BD54h case    5:*/		regs.R3 = regs.R4;
		/* 8219BD54h case    5:*/		return 0x8219BD58;
		  /* 8219BD58h */ case    6:  		/* li R6, 0 */
		/* 8219BD58h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8219BD58h case    6:*/		return 0x8219BD5C;
		  /* 8219BD5Ch */ case    7:  		/* li R5, 0 */
		/* 8219BD5Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219BD5Ch case    7:*/		return 0x8219BD60;
		  /* 8219BD60h */ case    8:  		/* li R4, 85 */
		/* 8219BD60h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x55);
		/* 8219BD60h case    8:*/		return 0x8219BD64;
		  /* 8219BD64h */ case    9:  		/* bl -227636 */
		/* 8219BD64h case    9:*/		regs.LR = 0x8219BD68; return 0x82164430;
		/* 8219BD64h case    9:*/		return 0x8219BD68;
		  /* 8219BD68h */ case   10:  		/* addi R11, R31, -20 */
		/* 8219BD68h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFEC);
		/* 8219BD68h case   10:*/		return 0x8219BD6C;
		  /* 8219BD6Ch */ case   11:  		/* add R3, R3, R11 */
		/* 8219BD6Ch case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 8219BD6Ch case   11:*/		return 0x8219BD70;
		  /* 8219BD70h */ case   12:  		/* addi R1, R1, 96 */
		/* 8219BD70h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8219BD70h case   12:*/		return 0x8219BD74;
		  /* 8219BD74h */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219BD74h case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219BD74h case   13:*/		return 0x8219BD78;
		  /* 8219BD78h */ case   14:  		/* mtspr LR, R12 */
		/* 8219BD78h case   14:*/		regs.LR = regs.R12;
		/* 8219BD78h case   14:*/		return 0x8219BD7C;
		  /* 8219BD7Ch */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 8219BD7Ch case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219BD7Ch case   15:*/		return 0x8219BD80;
	}
	return 0x8219BD80;
} // Block from 8219BD40h-8219BD80h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219BD80h
// Function '?CanCombineRelativeOperands@Compiler@D3DXShader@@AAA_NPAVDependency@2@PAVInstruction@2@0101PAPAV42@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BD80);
		  /* 8219BD80h */ case    0:  		/* bclr 20, CR0_LT */
		/* 8219BD80h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219BD80h case    0:*/		return 0x8219BD84;
	}
	return 0x8219BD84;
} // Block from 8219BD80h-8219BD84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BD84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BD84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BD84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BD84);
		  /* 8219BD84h */ case    0:  		/* nop */
		/* 8219BD84h case    0:*/		cpu::op::nop();
		/* 8219BD84h case    0:*/		return 0x8219BD88;
	}
	return 0x8219BD88;
} // Block from 8219BD84h-8219BD88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BD88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BD88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BD88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BD88);
		  /* 8219BD88h */ case    0:  		/* mfspr R12, LR */
		/* 8219BD88h case    0:*/		regs.R12 = regs.LR;
		/* 8219BD88h case    0:*/		return 0x8219BD8C;
		  /* 8219BD8Ch */ case    1:  		/* bl -1092416 */
		/* 8219BD8Ch case    1:*/		regs.LR = 0x8219BD90; return 0x8209124C;
		/* 8219BD8Ch case    1:*/		return 0x8219BD90;
		  /* 8219BD90h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219BD90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219BD90h case    2:*/		return 0x8219BD94;
		  /* 8219BD94h */ case    3:  		/* lwz R11, <#[R5 + 8]> */
		/* 8219BD94h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 8219BD94h case    3:*/		return 0x8219BD98;
		  /* 8219BD98h */ case    4:  		/* mr R27, R3 */
		/* 8219BD98h case    4:*/		regs.R27 = regs.R3;
		/* 8219BD98h case    4:*/		return 0x8219BD9C;
		  /* 8219BD9Ch */ case    5:  		/* mr R26, R4 */
		/* 8219BD9Ch case    5:*/		regs.R26 = regs.R4;
		/* 8219BD9Ch case    5:*/		return 0x8219BDA0;
		  /* 8219BDA0h */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219BDA0h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219BDA0h case    6:*/		return 0x8219BDA4;
		  /* 8219BDA4h */ case    7:  		/* mr R28, R5 */
		/* 8219BDA4h case    7:*/		regs.R28 = regs.R5;
		/* 8219BDA4h case    7:*/		return 0x8219BDA8;
		  /* 8219BDA8h */ case    8:  		/* mr R25, R6 */
		/* 8219BDA8h case    8:*/		regs.R25 = regs.R6;
		/* 8219BDA8h case    8:*/		return 0x8219BDAC;
		  /* 8219BDACh */ case    9:  		/* cmplwi CR6, R11, 14080 */
		/* 8219BDACh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 8219BDACh case    9:*/		return 0x8219BDB0;
		  /* 8219BDB0h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 8219BDB0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8219BDBC;  }
		/* 8219BDB0h case   10:*/		return 0x8219BDB4;
		  /* 8219BDB4h */ case   11:  		/* mr R30, R5 */
		/* 8219BDB4h case   11:*/		regs.R30 = regs.R5;
		/* 8219BDB4h case   11:*/		return 0x8219BDB8;
		  /* 8219BDB8h */ case   12:  		/* b 68 */
		/* 8219BDB8h case   12:*/		return 0x8219BDFC;
		/* 8219BDB8h case   12:*/		return 0x8219BDBC;
	}
	return 0x8219BDBC;
} // Block from 8219BD88h-8219BDBCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219BDBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BDBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BDBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BDBC);
		  /* 8219BDBCh */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 8219BDBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8219BDBCh case    0:*/		return 0x8219BDC0;
		  /* 8219BDC0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8219BDC0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219BDC0h case    1:*/		return 0x8219BDC4;
		  /* 8219BDC4h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 8219BDC4h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219BDF8;  }
		/* 8219BDC4h case    2:*/		return 0x8219BDC8;
		  /* 8219BDC8h */ case    3:  		/* lwz R30, <#[R11 + 16]> */
		/* 8219BDC8h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000010) );
		/* 8219BDC8h case    3:*/		return 0x8219BDCC;
		  /* 8219BDCCh */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 8219BDCCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219BDCCh case    4:*/		return 0x8219BDD0;
		  /* 8219BDD0h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 8219BDD0h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219BDF0;  }
		/* 8219BDD0h case    5:*/		return 0x8219BDD4;
		  /* 8219BDD4h */ case    6:  		/* lwz R10, <#[R30 + 8]> */
		/* 8219BDD4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8219BDD4h case    6:*/		return 0x8219BDD8;
		  /* 8219BDD8h */ case    7:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 8219BDD8h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 8219BDD8h case    7:*/		return 0x8219BDDC;
		  /* 8219BDDCh */ case    8:  		/* cmplwi CR6, R10, 14080 */
		/* 8219BDDCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 8219BDDCh case    8:*/		return 0x8219BDE0;
		  /* 8219BDE0h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 8219BDE0h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219BDF0;  }
		/* 8219BDE0h case    9:*/		return 0x8219BDE4;
		  /* 8219BDE4h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 8219BDE4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219BDE4h case   10:*/		return 0x8219BDE8;
		  /* 8219BDE8h */ case   11:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 8219BDE8h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 8219BDE8h case   11:*/		return 0x8219BDEC;
		  /* 8219BDECh */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 8219BDECh case   12:*/		if ( !regs.CR[0].eq ) { return 0x8219BDFC;  }
		/* 8219BDECh case   12:*/		return 0x8219BDF0;
	}
	return 0x8219BDF0;
} // Block from 8219BDBCh-8219BDF0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219BDF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BDF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BDF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BDF0);
		  /* 8219BDF0h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219BDF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219BDF0h case    0:*/		return 0x8219BDF4;
		  /* 8219BDF4h */ case    1:  		/* b -52 */
		/* 8219BDF4h case    1:*/		return 0x8219BDC0;
		/* 8219BDF4h case    1:*/		return 0x8219BDF8;
	}
	return 0x8219BDF8;
} // Block from 8219BDF0h-8219BDF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219BDF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BDF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BDF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BDF8);
		  /* 8219BDF8h */ case    0:  		/* li R30, 0 */
		/* 8219BDF8h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8219BDF8h case    0:*/		return 0x8219BDFC;
	}
	return 0x8219BDFC;
} // Block from 8219BDF8h-8219BDFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BDFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BDFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BDFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BDFC);
		  /* 8219BDFCh */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8219BDFCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219BDFCh case    0:*/		return 0x8219BE00;
		  /* 8219BE00h */ case    1:  		/* bc 12, CR6_EQ, 132 */
		/* 8219BE00h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219BE84;  }
		/* 8219BE00h case    1:*/		return 0x8219BE04;
		  /* 8219BE04h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219BE04h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219BE04h case    2:*/		return 0x8219BE08;
		  /* 8219BE08h */ case    3:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 8219BE08h case    3:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 8219BE08h case    3:*/		return 0x8219BE0C;
		  /* 8219BE0Ch */ case    4:  		/* bc 12, CR0_EQ, 24 */
		/* 8219BE0Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x8219BE24;  }
		/* 8219BE0Ch case    4:*/		return 0x8219BE10;
		  /* 8219BE10h */ case    5:  		/* mr R4, R30 */
		/* 8219BE10h case    5:*/		regs.R4 = regs.R30;
		/* 8219BE10h case    5:*/		return 0x8219BE14;
		  /* 8219BE14h */ case    6:  		/* lwz R5, <#[R27 + 660]> */
		/* 8219BE14h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x00000294) );
		/* 8219BE14h case    6:*/		return 0x8219BE18;
		  /* 8219BE18h */ case    7:  		/* mr R3, R27 */
		/* 8219BE18h case    7:*/		regs.R3 = regs.R27;
		/* 8219BE18h case    7:*/		return 0x8219BE1C;
		  /* 8219BE1Ch */ case    8:  		/* bl 133948 */
		/* 8219BE1Ch case    8:*/		regs.LR = 0x8219BE20; return 0x821BC958;
		/* 8219BE1Ch case    8:*/		return 0x8219BE20;
		  /* 8219BE20h */ case    9:  		/* mr R30, R3 */
		/* 8219BE20h case    9:*/		regs.R30 = regs.R3;
		/* 8219BE20h case    9:*/		return 0x8219BE24;
	}
	return 0x8219BE24;
} // Block from 8219BDFCh-8219BE24h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219BE24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BE24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BE24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BE24);
		  /* 8219BE24h */ case    0:  		/* li R29, 0 */
		/* 8219BE24h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8219BE24h case    0:*/		return 0x8219BE28;
		  /* 8219BE28h */ case    1:  		/* addi R31, R30, 44 */
		/* 8219BE28h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R30,0x2C);
		/* 8219BE28h case    1:*/		return 0x8219BE2C;
		  /* 8219BE2Ch */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219BE2Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219BE2Ch case    2:*/		return 0x8219BE30;
		  /* 8219BE30h */ case    3:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 8219BE30h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 8219BE30h case    3:*/		return 0x8219BE34;
		  /* 8219BE34h */ case    4:  		/* cmplw CR6, R29, R11 */
		/* 8219BE34h case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 8219BE34h case    4:*/		return 0x8219BE38;
		  /* 8219BE38h */ case    5:  		/* bc 4, CR6_LT, 68 */
		/* 8219BE38h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8219BE7C;  }
		/* 8219BE38h case    5:*/		return 0x8219BE3C;
		  /* 8219BE3Ch */ case    6:  		/* lwz R11, <#[R31]> */
		/* 8219BE3Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219BE3Ch case    6:*/		return 0x8219BE40;
		  /* 8219BE40h */ case    7:  		/* mr R4, R26 */
		/* 8219BE40h case    7:*/		regs.R4 = regs.R26;
		/* 8219BE40h case    7:*/		return 0x8219BE44;
		  /* 8219BE44h */ case    8:  		/* mr R3, R27 */
		/* 8219BE44h case    8:*/		regs.R3 = regs.R27;
		/* 8219BE44h case    8:*/		return 0x8219BE48;
		  /* 8219BE48h */ case    9:  		/* lwz R5, <#[R11 + 12]> */
		/* 8219BE48h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219BE48h case    9:*/		return 0x8219BE4C;
		  /* 8219BE4Ch */ case   10:  		/* subf R11, R5, R28 */
		/* 8219BE4Ch case   10:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R5,regs.R28);
		/* 8219BE4Ch case   10:*/		return 0x8219BE50;
		  /* 8219BE50h */ case   11:  		/* addic R11, R11, -1 */
		/* 8219BE50h case   11:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8219BE50h case   11:*/		return 0x8219BE54;
		  /* 8219BE54h */ case   12:  		/* subfe R11, R11, R11 */
		/* 8219BE54h case   12:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8219BE54h case   12:*/		return 0x8219BE58;
		  /* 8219BE58h */ case   13:  		/* and R6, R11, R25 */
		/* 8219BE58h case   13:*/		cpu::op::and<0>(regs,&regs.R6,regs.R11,regs.R25);
		/* 8219BE58h case   13:*/		return 0x8219BE5C;
		  /* 8219BE5Ch */ case   14:  		/* bl -3236 */
		/* 8219BE5Ch case   14:*/		regs.LR = 0x8219BE60; return 0x8219B1B8;
		/* 8219BE5Ch case   14:*/		return 0x8219BE60;
		  /* 8219BE60h */ case   15:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219BE60h case   15:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219BE60h case   15:*/		return 0x8219BE64;
		  /* 8219BE64h */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 8219BE64h case   16:*/		if ( regs.CR[0].eq ) { return 0x8219BE74;  }
		/* 8219BE64h case   16:*/		return 0x8219BE68;
		  /* 8219BE68h */ case   17:  		/* addi R29, R29, 1 */
		/* 8219BE68h case   17:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8219BE68h case   17:*/		return 0x8219BE6C;
		  /* 8219BE6Ch */ case   18:  		/* addi R31, R31, 4 */
		/* 8219BE6Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8219BE6Ch case   18:*/		return 0x8219BE70;
		  /* 8219BE70h */ case   19:  		/* b -68 */
		/* 8219BE70h case   19:*/		return 0x8219BE2C;
		/* 8219BE70h case   19:*/		return 0x8219BE74;
	}
	return 0x8219BE74;
} // Block from 8219BE24h-8219BE74h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219BE74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BE74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BE74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BE74);
		  /* 8219BE74h */ case    0:  		/* li R3, 0 */
		/* 8219BE74h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219BE74h case    0:*/		return 0x8219BE78;
		  /* 8219BE78h */ case    1:  		/* b 32 */
		/* 8219BE78h case    1:*/		return 0x8219BE98;
		/* 8219BE78h case    1:*/		return 0x8219BE7C;
	}
	return 0x8219BE7C;
} // Block from 8219BE74h-8219BE7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219BE7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BE7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BE7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BE7C);
		  /* 8219BE7Ch */ case    0:  		/* li R3, 1 */
		/* 8219BE7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219BE7Ch case    0:*/		return 0x8219BE80;
		  /* 8219BE80h */ case    1:  		/* b 24 */
		/* 8219BE80h case    1:*/		return 0x8219BE98;
		/* 8219BE80h case    1:*/		return 0x8219BE84;
	}
	return 0x8219BE84;
} // Block from 8219BE7Ch-8219BE84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219BE84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BE84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BE84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BE84);
		  /* 8219BE84h */ case    0:  		/* mr R6, R25 */
		/* 8219BE84h case    0:*/		regs.R6 = regs.R25;
		/* 8219BE84h case    0:*/		return 0x8219BE88;
		  /* 8219BE88h */ case    1:  		/* mr R5, R28 */
		/* 8219BE88h case    1:*/		regs.R5 = regs.R28;
		/* 8219BE88h case    1:*/		return 0x8219BE8C;
		  /* 8219BE8Ch */ case    2:  		/* mr R4, R26 */
		/* 8219BE8Ch case    2:*/		regs.R4 = regs.R26;
		/* 8219BE8Ch case    2:*/		return 0x8219BE90;
		  /* 8219BE90h */ case    3:  		/* mr R3, R27 */
		/* 8219BE90h case    3:*/		regs.R3 = regs.R27;
		/* 8219BE90h case    3:*/		return 0x8219BE94;
		  /* 8219BE94h */ case    4:  		/* bl -3292 */
		/* 8219BE94h case    4:*/		regs.LR = 0x8219BE98; return 0x8219B1B8;
		/* 8219BE94h case    4:*/		return 0x8219BE98;
	}
	return 0x8219BE98;
} // Block from 8219BE84h-8219BE98h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219BE98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BE98);
		  /* 8219BE98h */ case    0:  		/* addi R1, R1, 144 */
		/* 8219BE98h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219BE98h case    0:*/		return 0x8219BE9C;
		  /* 8219BE9Ch */ case    1:  		/* b -1092608 */
		/* 8219BE9Ch case    1:*/		return 0x8209129C;
		/* 8219BE9Ch case    1:*/		return 0x8219BEA0;
	}
	return 0x8219BEA0;
} // Block from 8219BE98h-8219BEA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219BEA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BEA0);
		  /* 8219BEA0h */ case    0:  		/* mfspr R12, LR */
		/* 8219BEA0h case    0:*/		regs.R12 = regs.LR;
		/* 8219BEA0h case    0:*/		return 0x8219BEA4;
		  /* 8219BEA4h */ case    1:  		/* bl -1092688 */
		/* 8219BEA4h case    1:*/		regs.LR = 0x8219BEA8; return 0x82091254;
		/* 8219BEA4h case    1:*/		return 0x8219BEA8;
		  /* 8219BEA8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8219BEA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8219BEA8h case    2:*/		return 0x8219BEAC;
		  /* 8219BEACh */ case    3:  		/* mr R29, R3 */
		/* 8219BEACh case    3:*/		regs.R29 = regs.R3;
		/* 8219BEACh case    3:*/		return 0x8219BEB0;
		  /* 8219BEB0h */ case    4:  		/* mr R31, R4 */
		/* 8219BEB0h case    4:*/		regs.R31 = regs.R4;
		/* 8219BEB0h case    4:*/		return 0x8219BEB4;
		  /* 8219BEB4h */ case    5:  		/* mr R27, R5 */
		/* 8219BEB4h case    5:*/		regs.R27 = regs.R5;
		/* 8219BEB4h case    5:*/		return 0x8219BEB8;
		  /* 8219BEB8h */ case    6:  		/* mr R30, R6 */
		/* 8219BEB8h case    6:*/		regs.R30 = regs.R6;
		/* 8219BEB8h case    6:*/		return 0x8219BEBC;
		  /* 8219BEBCh */ case    7:  		/* mr R28, R8 */
		/* 8219BEBCh case    7:*/		regs.R28 = regs.R8;
		/* 8219BEBCh case    7:*/		return 0x8219BEC0;
		  /* 8219BEC0h */ case    8:  		/* cmplw CR6, R6, R4 */
		/* 8219BEC0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R4);
		/* 8219BEC0h case    8:*/		return 0x8219BEC4;
		  /* 8219BEC4h */ case    9:  		/* bc 4, CR6_EQ, 28 */
		/* 8219BEC4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219BEE0;  }
		/* 8219BEC4h case    9:*/		return 0x8219BEC8;
		  /* 8219BEC8h */ case   10:  		/* lwz R11, <#[R28]> */
		/* 8219BEC8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8219BEC8h case   10:*/		return 0x8219BECC;
		  /* 8219BECCh */ case   11:  		/* ori R11, R11, 2048 */
		/* 8219BECCh case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 8219BECCh case   11:*/		return 0x8219BED0;
		  /* 8219BED0h */ case   12:  		/* stw R31, <#[R28 + 4]> */
		/* 8219BED0h case   12:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x00000004) );
		/* 8219BED0h case   12:*/		return 0x8219BED4;
		  /* 8219BED4h */ case   13:  		/* li R3, 1 */
		/* 8219BED4h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219BED4h case   13:*/		return 0x8219BED8;
		  /* 8219BED8h */ case   14:  		/* stw R11, <#[R28]> */
		/* 8219BED8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8219BED8h case   14:*/		return 0x8219BEDC;
		  /* 8219BEDCh */ case   15:  		/* b 176 */
		/* 8219BEDCh case   15:*/		return 0x8219BF8C;
		/* 8219BEDCh case   15:*/		return 0x8219BEE0;
	}
	return 0x8219BEE0;
} // Block from 8219BEA0h-8219BEE0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219BEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BEE0);
		  /* 8219BEE0h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219BEE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219BEE0h case    0:*/		return 0x8219BEE4;
		  /* 8219BEE4h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219BEE4h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219BEE4h case    1:*/		return 0x8219BEE8;
		  /* 8219BEE8h */ case    2:  		/* cmplwi CR6, R11, 14080 */
		/* 8219BEE8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 8219BEE8h case    2:*/		return 0x8219BEEC;
		  /* 8219BEECh */ case    3:  		/* bc 12, CR6_EQ, 156 */
		/* 8219BEECh case    3:*/		if ( regs.CR[6].eq ) { return 0x8219BF88;  }
		/* 8219BEECh case    3:*/		return 0x8219BEF0;
	}
	return 0x8219BEF0;
} // Block from 8219BEE0h-8219BEF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219BEF0h
// Function '?ComputeMergeComponents@Compiler@D3DXShader@@AAAIPAVInstruction@2@000@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BEF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BEF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BEF0);
		  /* 8219BEF0h */ case    0:  		/* li R6, 1 */
		/* 8219BEF0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8219BEF0h case    0:*/		return 0x8219BEF4;
		  /* 8219BEF4h */ case    1:  		/* mr R5, R7 */
		/* 8219BEF4h case    1:*/		regs.R5 = regs.R7;
		/* 8219BEF4h case    1:*/		return 0x8219BEF8;
		  /* 8219BEF8h */ case    2:  		/* mr R4, R31 */
		/* 8219BEF8h case    2:*/		regs.R4 = regs.R31;
		/* 8219BEF8h case    2:*/		return 0x8219BEFC;
		  /* 8219BEFCh */ case    3:  		/* mr R3, R29 */
		/* 8219BEFCh case    3:*/		regs.R3 = regs.R29;
		/* 8219BEFCh case    3:*/		return 0x8219BF00;
		  /* 8219BF00h */ case    4:  		/* bl 591208 */
		/* 8219BF00h case    4:*/		regs.LR = 0x8219BF04; return 0x8222C468;
		/* 8219BF00h case    4:*/		return 0x8219BF04;
		  /* 8219BF04h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219BF04h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219BF04h case    5:*/		return 0x8219BF08;
		  /* 8219BF08h */ case    6:  		/* bc 12, CR0_EQ, 128 */
		/* 8219BF08h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219BF88;  }
		/* 8219BF08h case    6:*/		return 0x8219BF0C;
		  /* 8219BF0Ch */ case    7:  		/* lwz R11, <#[R31]> */
		/* 8219BF0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219BF0Ch case    7:*/		return 0x8219BF10;
		  /* 8219BF10h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8219BF10h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219BF10h case    8:*/		return 0x8219BF14;
		  /* 8219BF14h */ case    9:  		/* bc 12, CR6_EQ, 32 */
		/* 8219BF14h case    9:*/		if ( regs.CR[6].eq ) { return 0x8219BF34;  }
		/* 8219BF14h case    9:*/		return 0x8219BF18;
		  /* 8219BF18h */ case   10:  		/* lwz R10, <#[R11 + 12]> */
		/* 8219BF18h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219BF18h case   10:*/		return 0x8219BF1C;
		  /* 8219BF1Ch */ case   11:  		/* cmplw CR6, R10, R30 */
		/* 8219BF1Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 8219BF1Ch case   11:*/		return 0x8219BF20;
		  /* 8219BF20h */ case   12:  		/* bc 12, CR6_EQ, 12 */
		/* 8219BF20h case   12:*/		if ( regs.CR[6].eq ) { return 0x8219BF2C;  }
		/* 8219BF20h case   12:*/		return 0x8219BF24;
		  /* 8219BF24h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219BF24h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219BF24h case   13:*/		return 0x8219BF28;
		  /* 8219BF28h */ case   14:  		/* b -24 */
		/* 8219BF28h case   14:*/		return 0x8219BF10;
		/* 8219BF28h case   14:*/		return 0x8219BF2C;
	}
	return 0x8219BF2C;
} // Block from 8219BEF0h-8219BF2Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219BF2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BF2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BF2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BF2C);
		  /* 8219BF2Ch */ case    0:  		/* li R11, 1 */
		/* 8219BF2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219BF2Ch case    0:*/		return 0x8219BF30;
		  /* 8219BF30h */ case    1:  		/* b 8 */
		/* 8219BF30h case    1:*/		return 0x8219BF38;
		/* 8219BF30h case    1:*/		return 0x8219BF34;
	}
	return 0x8219BF34;
} // Block from 8219BF2Ch-8219BF34h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219BF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BF34);
		  /* 8219BF34h */ case    0:  		/* li R11, 0 */
		/* 8219BF34h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219BF34h case    0:*/		return 0x8219BF38;
	}
	return 0x8219BF38;
} // Block from 8219BF34h-8219BF38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BF38);
		  /* 8219BF38h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219BF38h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219BF38h case    0:*/		return 0x8219BF3C;
		  /* 8219BF3Ch */ case    1:  		/* bc 4, CR0_EQ, -116 */
		/* 8219BF3Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219BEC8;  }
		/* 8219BF3Ch case    1:*/		return 0x8219BF40;
		  /* 8219BF40h */ case    2:  		/* li R6, 1 */
		/* 8219BF40h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8219BF40h case    2:*/		return 0x8219BF44;
		  /* 8219BF44h */ case    3:  		/* mr R5, R31 */
		/* 8219BF44h case    3:*/		regs.R5 = regs.R31;
		/* 8219BF44h case    3:*/		return 0x8219BF48;
		  /* 8219BF48h */ case    4:  		/* mr R4, R30 */
		/* 8219BF48h case    4:*/		regs.R4 = regs.R30;
		/* 8219BF48h case    4:*/		return 0x8219BF4C;
		  /* 8219BF4Ch */ case    5:  		/* mr R3, R29 */
		/* 8219BF4Ch case    5:*/		regs.R3 = regs.R29;
		/* 8219BF4Ch case    5:*/		return 0x8219BF50;
		  /* 8219BF50h */ case    6:  		/* bl 591128 */
		/* 8219BF50h case    6:*/		regs.LR = 0x8219BF54; return 0x8222C468;
		/* 8219BF50h case    6:*/		return 0x8219BF54;
		  /* 8219BF54h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219BF54h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219BF54h case    7:*/		return 0x8219BF58;
		  /* 8219BF58h */ case    8:  		/* bc 12, CR0_EQ, 48 */
		/* 8219BF58h case    8:*/		if ( regs.CR[0].eq ) { return 0x8219BF88;  }
		/* 8219BF58h case    8:*/		return 0x8219BF5C;
		  /* 8219BF5Ch */ case    9:  		/* mr R7, R30 */
		/* 8219BF5Ch case    9:*/		regs.R7 = regs.R30;
		/* 8219BF5Ch case    9:*/		return 0x8219BF60;
		  /* 8219BF60h */ case   10:  		/* li R6, 0 */
		/* 8219BF60h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8219BF60h case   10:*/		return 0x8219BF64;
		  /* 8219BF64h */ case   11:  		/* mr R5, R27 */
		/* 8219BF64h case   11:*/		regs.R5 = regs.R27;
		/* 8219BF64h case   11:*/		return 0x8219BF68;
		  /* 8219BF68h */ case   12:  		/* mr R4, R31 */
		/* 8219BF68h case   12:*/		regs.R4 = regs.R31;
		/* 8219BF68h case   12:*/		return 0x8219BF6C;
		  /* 8219BF6Ch */ case   13:  		/* mr R3, R29 */
		/* 8219BF6Ch case   13:*/		regs.R3 = regs.R29;
		/* 8219BF6Ch case   13:*/		return 0x8219BF70;
		  /* 8219BF70h */ case   14:  		/* bl -2584 */
		/* 8219BF70h case   14:*/		regs.LR = 0x8219BF74; return 0x8219B558;
		/* 8219BF70h case   14:*/		return 0x8219BF74;
		  /* 8219BF74h */ case   15:  		/* cmplwi CR6, R3, 4 */
		/* 8219BF74h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000004);
		/* 8219BF74h case   15:*/		return 0x8219BF78;
		  /* 8219BF78h */ case   16:  		/* bc 12, CR6_GT, 16 */
		/* 8219BF78h case   16:*/		if ( regs.CR[6].gt ) { return 0x8219BF88;  }
		/* 8219BF78h case   16:*/		return 0x8219BF7C;
		  /* 8219BF7Ch */ case   17:  		/* lwz R11, <#[R28]> */
		/* 8219BF7Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8219BF7Ch case   17:*/		return 0x8219BF80;
		  /* 8219BF80h */ case   18:  		/* rlwinm R11, R11, 0, 21, 19 */
		/* 8219BF80h case   18:*/		cpu::op::rlwinm<0,0,21,19>(regs,&regs.R11,regs.R11);
		/* 8219BF80h case   18:*/		return 0x8219BF84;
		  /* 8219BF84h */ case   19:  		/* b -180 */
		/* 8219BF84h case   19:*/		return 0x8219BED0;
		/* 8219BF84h case   19:*/		return 0x8219BF88;
	}
	return 0x8219BF88;
} // Block from 8219BF38h-8219BF88h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219BF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BF88);
		  /* 8219BF88h */ case    0:  		/* li R3, 0 */
		/* 8219BF88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219BF88h case    0:*/		return 0x8219BF8C;
	}
	return 0x8219BF8C;
} // Block from 8219BF88h-8219BF8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BF8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BF8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BF8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BF8C);
		  /* 8219BF8Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8219BF8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8219BF8Ch case    0:*/		return 0x8219BF90;
		  /* 8219BF90h */ case    1:  		/* b -1092844 */
		/* 8219BF90h case    1:*/		return 0x820912A4;
		/* 8219BF90h case    1:*/		return 0x8219BF94;
		  /* 8219BF94h */ case    2:  		/* nop */
		/* 8219BF94h case    2:*/		cpu::op::nop();
		/* 8219BF94h case    2:*/		return 0x8219BF98;
	}
	return 0x8219BF98;
} // Block from 8219BF8Ch-8219BF98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219BF98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BF98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BF98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BF98);
		  /* 8219BF98h */ case    0:  		/* mfspr R12, LR */
		/* 8219BF98h case    0:*/		regs.R12 = regs.LR;
		/* 8219BF98h case    0:*/		return 0x8219BF9C;
		  /* 8219BF9Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219BF9Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219BF9Ch case    1:*/		return 0x8219BFA0;
		  /* 8219BFA0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8219BFA0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219BFA0h case    2:*/		return 0x8219BFA4;
		  /* 8219BFA4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8219BFA4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8219BFA4h case    3:*/		return 0x8219BFA8;
		  /* 8219BFA8h */ case    4:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219BFA8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219BFA8h case    4:*/		return 0x8219BFAC;
		  /* 8219BFACh */ case    5:  		/* rlwinm. R10, R11, 7, 31, 31 */
		/* 8219BFACh case    5:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R10,regs.R11);
		/* 8219BFACh case    5:*/		return 0x8219BFB0;
		  /* 8219BFB0h */ case    6:  		/* bc 4, CR0_EQ, 116 */
		/* 8219BFB0h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8219C024;  }
		/* 8219BFB0h case    6:*/		return 0x8219BFB4;
		  /* 8219BFB4h */ case    7:  		/* rlwinm. R10, R11, 27, 31, 31 */
		/* 8219BFB4h case    7:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R10,regs.R11);
		/* 8219BFB4h case    7:*/		return 0x8219BFB8;
		  /* 8219BFB8h */ case    8:  		/* bc 4, CR0_EQ, 108 */
		/* 8219BFB8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8219C024;  }
		/* 8219BFB8h case    8:*/		return 0x8219BFBC;
		  /* 8219BFBCh */ case    9:  		/* rlwinm R31, R11, 25, 25, 31 */
		/* 8219BFBCh case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R31,regs.R11);
		/* 8219BFBCh case    9:*/		return 0x8219BFC0;
		  /* 8219BFC0h */ case   10:  		/* cmplwi CR6, R31, 1 */
		/* 8219BFC0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000001);
		/* 8219BFC0h case   10:*/		return 0x8219BFC4;
		  /* 8219BFC4h */ case   11:  		/* bc 12, CR6_LT, 16 */
		/* 8219BFC4h case   11:*/		if ( regs.CR[6].lt ) { return 0x8219BFD4;  }
		/* 8219BFC4h case   11:*/		return 0x8219BFC8;
		  /* 8219BFC8h */ case   12:  		/* cmplwi CR6, R31, 102 */
		/* 8219BFC8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000066);
		/* 8219BFC8h case   12:*/		return 0x8219BFCC;
		  /* 8219BFCCh */ case   13:  		/* li R11, 1 */
		/* 8219BFCCh case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219BFCCh case   13:*/		return 0x8219BFD0;
		  /* 8219BFD0h */ case   14:  		/* bc 4, CR6_GT, 8 */
		/* 8219BFD0h case   14:*/		if ( !regs.CR[6].gt ) { return 0x8219BFD8;  }
		/* 8219BFD0h case   14:*/		return 0x8219BFD4;
	}
	return 0x8219BFD4;
} // Block from 8219BF98h-8219BFD4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219BFD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BFD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BFD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BFD4);
		  /* 8219BFD4h */ case    0:  		/* li R11, 0 */
		/* 8219BFD4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219BFD4h case    0:*/		return 0x8219BFD8;
	}
	return 0x8219BFD8;
} // Block from 8219BFD4h-8219BFD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219BFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219BFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219BFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219BFD8);
		  /* 8219BFD8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219BFD8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219BFD8h case    0:*/		return 0x8219BFDC;
		  /* 8219BFDCh */ case    1:  		/* bc 12, CR0_EQ, 72 */
		/* 8219BFDCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8219C024;  }
		/* 8219BFDCh case    1:*/		return 0x8219BFE0;
		  /* 8219BFE0h */ case    2:  		/* mr R3, R4 */
		/* 8219BFE0h case    2:*/		regs.R3 = regs.R4;
		/* 8219BFE0h case    2:*/		return 0x8219BFE4;
		  /* 8219BFE4h */ case    3:  		/* bl -226916 */
		/* 8219BFE4h case    3:*/		regs.LR = 0x8219BFE8; return 0x82164980;
		/* 8219BFE4h case    3:*/		return 0x8219BFE8;
		  /* 8219BFE8h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219BFE8h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219BFE8h case    4:*/		return 0x8219BFEC;
		  /* 8219BFECh */ case    5:  		/* bc 4, CR0_EQ, 56 */
		/* 8219BFECh case    5:*/		if ( !regs.CR[0].eq ) { return 0x8219C024;  }
		/* 8219BFECh case    5:*/		return 0x8219BFF0;
		  /* 8219BFF0h */ case    6:  		/* cmplwi CR6, R31, 96 */
		/* 8219BFF0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000060);
		/* 8219BFF0h case    6:*/		return 0x8219BFF4;
		  /* 8219BFF4h */ case    7:  		/* bc 12, CR6_EQ, 48 */
		/* 8219BFF4h case    7:*/		if ( regs.CR[6].eq ) { return 0x8219C024;  }
		/* 8219BFF4h case    7:*/		return 0x8219BFF8;
		  /* 8219BFF8h */ case    8:  		/* cmplwi CR6, R31, 97 */
		/* 8219BFF8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000061);
		/* 8219BFF8h case    8:*/		return 0x8219BFFC;
		  /* 8219BFFCh */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 8219BFFCh case    9:*/		if ( regs.CR[6].eq ) { return 0x8219C014;  }
		/* 8219BFFCh case    9:*/		return 0x8219C000;
		  /* 8219C000h */ case   10:  		/* cmplwi CR6, R31, 99 */
		/* 8219C000h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000063);
		/* 8219C000h case   10:*/		return 0x8219C004;
		  /* 8219C004h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 8219C004h case   11:*/		if ( regs.CR[6].eq ) { return 0x8219C014;  }
		/* 8219C004h case   11:*/		return 0x8219C008;
		  /* 8219C008h */ case   12:  		/* cmplwi CR6, R31, 100 */
		/* 8219C008h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000064);
		/* 8219C008h case   12:*/		return 0x8219C00C;
		  /* 8219C00Ch */ case   13:  		/* li R11, 0 */
		/* 8219C00Ch case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219C00Ch case   13:*/		return 0x8219C010;
		  /* 8219C010h */ case   14:  		/* bc 4, CR6_EQ, 8 */
		/* 8219C010h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8219C018;  }
		/* 8219C010h case   14:*/		return 0x8219C014;
	}
	return 0x8219C014;
} // Block from 8219BFD8h-8219C014h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219C014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C014);
		  /* 8219C014h */ case    0:  		/* li R11, 1 */
		/* 8219C014h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219C014h case    0:*/		return 0x8219C018;
	}
	return 0x8219C018;
} // Block from 8219C014h-8219C018h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C018);
		  /* 8219C018h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219C018h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219C018h case    0:*/		return 0x8219C01C;
		  /* 8219C01Ch */ case    1:  		/* li R11, 0 */
		/* 8219C01Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219C01Ch case    1:*/		return 0x8219C020;
		  /* 8219C020h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 8219C020h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219C028;  }
		/* 8219C020h case    2:*/		return 0x8219C024;
	}
	return 0x8219C024;
} // Block from 8219C018h-8219C024h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219C024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C024);
		  /* 8219C024h */ case    0:  		/* li R11, 1 */
		/* 8219C024h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219C024h case    0:*/		return 0x8219C028;
	}
	return 0x8219C028;
} // Block from 8219C024h-8219C028h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C028);
		  /* 8219C028h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8219C028h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8219C028h case    0:*/		return 0x8219C02C;
		  /* 8219C02Ch */ case    1:  		/* addi R1, R1, 96 */
		/* 8219C02Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8219C02Ch case    1:*/		return 0x8219C030;
		  /* 8219C030h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219C030h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219C030h case    2:*/		return 0x8219C034;
		  /* 8219C034h */ case    3:  		/* mtspr LR, R12 */
		/* 8219C034h case    3:*/		regs.LR = regs.R12;
		/* 8219C034h case    3:*/		return 0x8219C038;
		  /* 8219C038h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8219C038h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219C038h case    4:*/		return 0x8219C03C;
		  /* 8219C03Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8219C03Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219C03Ch case    5:*/		return 0x8219C040;
	}
	return 0x8219C040;
} // Block from 8219C028h-8219C040h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219C040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C040);
		  /* 8219C040h */ case    0:  		/* std R3, <#[R1 + 16]> */
		/* 8219C040h case    0:*/		cpu::mem::store64( regs, regs.R3, (uint32)(regs.R1 + 0x00000010) );
		/* 8219C040h case    0:*/		return 0x8219C044;
		  /* 8219C044h */ case    1:  		/* lwz R10, <#[R1 + 16]> */
		/* 8219C044h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000010) );
		/* 8219C044h case    1:*/		return 0x8219C048;
		  /* 8219C048h */ case    2:  		/* std R4, <#[R1 + 24]> */
		/* 8219C048h case    2:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R1 + 0x00000018) );
		/* 8219C048h case    2:*/		return 0x8219C04C;
		  /* 8219C04Ch */ case    3:  		/* lwz R11, <#[R10 + 8]> */
		/* 8219C04Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8219C04Ch case    3:*/		return 0x8219C050;
		  /* 8219C050h */ case    4:  		/* rlwinm. R9, R11, 9, 31, 31 */
		/* 8219C050h case    4:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R9,regs.R11);
		/* 8219C050h case    4:*/		return 0x8219C054;
		  /* 8219C054h */ case    5:  		/* bc 4, CR0_EQ, 104 */
		/* 8219C054h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8219C0BC;  }
		/* 8219C054h case    5:*/		return 0x8219C058;
		  /* 8219C058h */ case    6:  		/* rlwinm R11, R11, 0, 15, 17 */
		/* 8219C058h case    6:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R11);
		/* 8219C058h case    6:*/		return 0x8219C05C;
		  /* 8219C05Ch */ case    7:  		/* cmplwi CR6, R11, 16384 */
		/* 8219C05Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00004000);
		/* 8219C05Ch case    7:*/		return 0x8219C060;
		  /* 8219C060h */ case    8:  		/* bc 4, CR6_EQ, 92 */
		/* 8219C060h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8219C0BC;  }
		/* 8219C060h case    8:*/		return 0x8219C064;
		  /* 8219C064h */ case    9:  		/* lwz R11, <#[R1 + 24]> */
		/* 8219C064h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000018) );
		/* 8219C064h case    9:*/		return 0x8219C068;
	}
	return 0x8219C068;
} // Block from 8219C040h-8219C068h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219C068h
// Function '?ComputeMULCombinationValue@Compiler@D3DXShader@@AAAIPAVInstruction@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C068);
		  /* 8219C068h */ case    0:  		/* rlwinm. R11, R11, 0, 27, 30 */
		/* 8219C068h case    0:*/		cpu::op::rlwinm<1,0,27,30>(regs,&regs.R11,regs.R11);
		/* 8219C068h case    0:*/		return 0x8219C06C;
		  /* 8219C06Ch */ case    1:  		/* bc 4, CR0_EQ, 80 */
		/* 8219C06Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219C0BC;  }
		/* 8219C06Ch case    1:*/		return 0x8219C070;
		  /* 8219C070h */ case    2:  		/* lwz R11, <#[R10 + 4]> */
		/* 8219C070h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8219C070h case    2:*/		return 0x8219C074;
		  /* 8219C074h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8219C074h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219C074h case    3:*/		return 0x8219C078;
		  /* 8219C078h */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 8219C078h case    4:*/		if ( regs.CR[6].eq ) { return 0x8219C0AC;  }
		/* 8219C078h case    4:*/		return 0x8219C07C;
		  /* 8219C07Ch */ case    5:  		/* lwz R10, <#[R11 + 16]> */
		/* 8219C07Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8219C07Ch case    5:*/		return 0x8219C080;
		  /* 8219C080h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 8219C080h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219C080h case    6:*/		return 0x8219C084;
		  /* 8219C084h */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 8219C084h case    7:*/		if ( regs.CR[6].eq ) { return 0x8219C0A4;  }
		/* 8219C084h case    7:*/		return 0x8219C088;
		  /* 8219C088h */ case    8:  		/* lwz R9, <#[R10 + 8]> */
		/* 8219C088h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 8219C088h case    8:*/		return 0x8219C08C;
		  /* 8219C08Ch */ case    9:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 8219C08Ch case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 8219C08Ch case    9:*/		return 0x8219C090;
		  /* 8219C090h */ case   10:  		/* cmplwi CR6, R9, 14080 */
		/* 8219C090h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003700);
		/* 8219C090h case   10:*/		return 0x8219C094;
		  /* 8219C094h */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 8219C094h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8219C0A4;  }
		/* 8219C094h case   11:*/		return 0x8219C098;
		  /* 8219C098h */ case   12:  		/* lwz R9, <#[R11]> */
		/* 8219C098h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8219C098h case   12:*/		return 0x8219C09C;
		  /* 8219C09Ch */ case   13:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 8219C09Ch case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 8219C09Ch case   13:*/		return 0x8219C0A0;
		  /* 8219C0A0h */ case   14:  		/* bc 4, CR0_EQ, 16 */
		/* 8219C0A0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8219C0B0;  }
		/* 8219C0A0h case   14:*/		return 0x8219C0A4;
	}
	return 0x8219C0A4;
} // Block from 8219C068h-8219C0A4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219C0A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C0A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C0A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C0A4);
		  /* 8219C0A4h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219C0A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219C0A4h case    0:*/		return 0x8219C0A8;
		  /* 8219C0A8h */ case    1:  		/* b -52 */
		/* 8219C0A8h case    1:*/		return 0x8219C074;
		/* 8219C0A8h case    1:*/		return 0x8219C0AC;
	}
	return 0x8219C0AC;
} // Block from 8219C0A4h-8219C0ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C0ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C0AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C0AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C0AC);
		  /* 8219C0ACh */ case    0:  		/* li R10, 0 */
		/* 8219C0ACh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219C0ACh case    0:*/		return 0x8219C0B0;
	}
	return 0x8219C0B0;
} // Block from 8219C0ACh-8219C0B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C0B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C0B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C0B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C0B0);
		  /* 8219C0B0h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8219C0B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219C0B0h case    0:*/		return 0x8219C0B4;
		  /* 8219C0B4h */ case    1:  		/* li R11, 1 */
		/* 8219C0B4h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219C0B4h case    1:*/		return 0x8219C0B8;
		  /* 8219C0B8h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 8219C0B8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219C0C0;  }
		/* 8219C0B8h case    2:*/		return 0x8219C0BC;
	}
	return 0x8219C0BC;
} // Block from 8219C0B0h-8219C0BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219C0BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C0BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C0BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C0BC);
		  /* 8219C0BCh */ case    0:  		/* li R11, 0 */
		/* 8219C0BCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219C0BCh case    0:*/		return 0x8219C0C0;
	}
	return 0x8219C0C0;
} // Block from 8219C0BCh-8219C0C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C0C0);
		  /* 8219C0C0h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8219C0C0h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8219C0C0h case    0:*/		return 0x8219C0C4;
		  /* 8219C0C4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8219C0C4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219C0C4h case    1:*/		return 0x8219C0C8;
	}
	return 0x8219C0C8;
} // Block from 8219C0C0h-8219C0C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C0C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C0C8);
		  /* 8219C0C8h */ case    0:  		/* mfspr R12, LR */
		/* 8219C0C8h case    0:*/		regs.R12 = regs.LR;
		/* 8219C0C8h case    0:*/		return 0x8219C0CC;
		  /* 8219C0CCh */ case    1:  		/* bl -1093284 */
		/* 8219C0CCh case    1:*/		regs.LR = 0x8219C0D0; return 0x82091228;
		/* 8219C0CCh case    1:*/		return 0x8219C0D0;
		  /* 8219C0D0h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 8219C0D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 8219C0D0h case    2:*/		return 0x8219C0D4;
		  /* 8219C0D4h */ case    3:  		/* lwz R31, <#[R1 + 348]> */
		/* 8219C0D4h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x0000015C) );
		/* 8219C0D4h case    3:*/		return 0x8219C0D8;
		  /* 8219C0D8h */ case    4:  		/* mr R17, R3 */
		/* 8219C0D8h case    4:*/		regs.R17 = regs.R3;
		/* 8219C0D8h case    4:*/		return 0x8219C0DC;
		  /* 8219C0DCh */ case    5:  		/* mr R16, R4 */
		/* 8219C0DCh case    5:*/		regs.R16 = regs.R4;
		/* 8219C0DCh case    5:*/		return 0x8219C0E0;
		  /* 8219C0E0h */ case    6:  		/* mr R30, R5 */
		/* 8219C0E0h case    6:*/		regs.R30 = regs.R5;
		/* 8219C0E0h case    6:*/		return 0x8219C0E4;
		  /* 8219C0E4h */ case    7:  		/* mr R25, R6 */
		/* 8219C0E4h case    7:*/		regs.R25 = regs.R6;
		/* 8219C0E4h case    7:*/		return 0x8219C0E8;
		  /* 8219C0E8h */ case    8:  		/* mr R28, R7 */
		/* 8219C0E8h case    8:*/		regs.R28 = regs.R7;
		/* 8219C0E8h case    8:*/		return 0x8219C0EC;
		  /* 8219C0ECh */ case    9:  		/* mr R18, R8 */
		/* 8219C0ECh case    9:*/		regs.R18 = regs.R8;
		/* 8219C0ECh case    9:*/		return 0x8219C0F0;
		  /* 8219C0F0h */ case   10:  		/* stw R8, <#[R31]> */
		/* 8219C0F0h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8219C0F0h case   10:*/		return 0x8219C0F4;
		  /* 8219C0F4h */ case   11:  		/* rlwinm. R11, R10, 0, 28, 28 */
		/* 8219C0F4h case   11:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R10);
		/* 8219C0F4h case   11:*/		return 0x8219C0F8;
		  /* 8219C0F8h */ case   12:  		/* stw R10, <#[R31 + 4]> */
		/* 8219C0F8h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8219C0F8h case   12:*/		return 0x8219C0FC;
		  /* 8219C0FCh */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 8219C0FCh case   13:*/		if ( regs.CR[0].eq ) { return 0x8219C10C;  }
		/* 8219C0FCh case   13:*/		return 0x8219C100;
		  /* 8219C100h */ case   14:  		/* lwz R3, <#[R1 + 340]> */
		/* 8219C100h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000154) );
		/* 8219C100h case   14:*/		return 0x8219C104;
		  /* 8219C104h */ case   15:  		/* bl -148972 */
		/* 8219C104h case   15:*/		regs.LR = 0x8219C108; return 0x82177B18;
		/* 8219C104h case   15:*/		return 0x8219C108;
		  /* 8219C108h */ case   16:  		/* stw R3, <#[R31 + 8]> */
		/* 8219C108h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8219C108h case   16:*/		return 0x8219C10C;
	}
	return 0x8219C10C;
} // Block from 8219C0C8h-8219C10Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219C10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C10C);
		  /* 8219C10Ch */ case    0:  		/* lwz R20, <#[R31 + 28]> */
		/* 8219C10Ch case    0:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R31 + 0x0000001C) );
		/* 8219C10Ch case    0:*/		return 0x8219C110;
		  /* 8219C110h */ case    1:  		/* li R24, 0 */
		/* 8219C110h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8219C110h case    1:*/		return 0x8219C114;
		  /* 8219C114h */ case    2:  		/* lwz R19, <#[R31 + 160]> */
		/* 8219C114h case    2:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219C114h case    2:*/		return 0x8219C118;
		  /* 8219C118h */ case    3:  		/* li R27, 0 */
		/* 8219C118h case    3:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8219C118h case    3:*/		return 0x8219C11C;
		  /* 8219C11Ch */ case    4:  		/* li R22, 0 */
		/* 8219C11Ch case    4:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 8219C11Ch case    4:*/		return 0x8219C120;
		  /* 8219C120h */ case    5:  		/* li R21, 0 */
		/* 8219C120h case    5:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8219C120h case    5:*/		return 0x8219C124;
		  /* 8219C124h */ case    6:  		/* li R23, 0 */
		/* 8219C124h case    6:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 8219C124h case    6:*/		return 0x8219C128;
		  /* 8219C128h */ case    7:  		/* addi R26, R30, 44 */
		/* 8219C128h case    7:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R30,0x2C);
		/* 8219C128h case    7:*/		return 0x8219C12C;
		  /* 8219C12Ch */ case    8:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219C12Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219C12Ch case    8:*/		return 0x8219C130;
		  /* 8219C130h */ case    9:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 8219C130h case    9:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 8219C130h case    9:*/		return 0x8219C134;
		  /* 8219C134h */ case   10:  		/* cmplw CR6, R23, R11 */
		/* 8219C134h case   10:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R11);
		/* 8219C134h case   10:*/		return 0x8219C138;
		  /* 8219C138h */ case   11:  		/* bc 4, CR6_LT, 640 */
		/* 8219C138h case   11:*/		if ( !regs.CR[6].lt ) { return 0x8219C3B8;  }
		/* 8219C138h case   11:*/		return 0x8219C13C;
		  /* 8219C13Ch */ case   12:  		/* lwz R29, <#[R26]> */
		/* 8219C13Ch case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R26 + 0x00000000) );
		/* 8219C13Ch case   12:*/		return 0x8219C140;
		  /* 8219C140h */ case   13:  		/* li R10, 1 */
		/* 8219C140h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219C140h case   13:*/		return 0x8219C144;
		  /* 8219C144h */ case   14:  		/* li R9, 0 */
		/* 8219C144h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219C144h case   14:*/		return 0x8219C148;
		  /* 8219C148h */ case   15:  		/* lwz R8, <#[R30 + 28]> */
		/* 8219C148h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000001C) );
		/* 8219C148h case   15:*/		return 0x8219C14C;
		  /* 8219C14Ch */ case   16:  		/* addi R7, R1, 80 */
		/* 8219C14Ch case   16:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 8219C14Ch case   16:*/		return 0x8219C150;
		  /* 8219C150h */ case   17:  		/* addi R6, R1, 88 */
		/* 8219C150h case   17:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 8219C150h case   17:*/		return 0x8219C154;
		  /* 8219C154h */ case   18:  		/* addi R5, R1, 84 */
		/* 8219C154h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 8219C154h case   18:*/		return 0x8219C158;
		  /* 8219C158h */ case   19:  		/* mr R4, R25 */
		/* 8219C158h case   19:*/		regs.R4 = regs.R25;
		/* 8219C158h case   19:*/		return 0x8219C15C;
		  /* 8219C15Ch */ case   20:  		/* mr R3, R29 */
		/* 8219C15Ch case   20:*/		regs.R3 = regs.R29;
		/* 8219C15Ch case   20:*/		return 0x8219C160;
		  /* 8219C160h */ case   21:  		/* bl 553840 */
		/* 8219C160h case   21:*/		regs.LR = 0x8219C164; return 0x822234D0;
		/* 8219C160h case   21:*/		return 0x8219C164;
		  /* 8219C164h */ case   22:  		/* lwz R11, <#[R1 + 80]> */
		/* 8219C164h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8219C164h case   22:*/		return 0x8219C168;
	}
	return 0x8219C168;
} // Block from 8219C10Ch-8219C168h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219C168h
// Function '?CollectOperandSources@Instruction@D3DXShader@@QAAXQAPAV12@QAW4Component@2@QAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C168);
		  /* 8219C168h */ case    0:  		/* mr R10, R28 */
		/* 8219C168h case    0:*/		regs.R10 = regs.R28;
		/* 8219C168h case    0:*/		return 0x8219C16C;
		  /* 8219C16Ch */ case    1:  		/* rlwinm. R9, R11, 0, 29, 29 */
		/* 8219C16Ch case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R11);
		/* 8219C16Ch case    1:*/		return 0x8219C170;
		  /* 8219C170h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 8219C170h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219C180;  }
		/* 8219C170h case    2:*/		return 0x8219C174;
		  /* 8219C174h */ case    3:  		/* rlwinm. R9, R28, 0, 30, 30 */
		/* 8219C174h case    3:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R28);
		/* 8219C174h case    3:*/		return 0x8219C178;
		  /* 8219C178h */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 8219C178h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219C180;  }
		/* 8219C178h case    4:*/		return 0x8219C17C;
		  /* 8219C17Ch */ case    5:  		/* addi R11, R11, -4 */
		/* 8219C17Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8219C17Ch case    5:*/		return 0x8219C180;
	}
	return 0x8219C180;
} // Block from 8219C168h-8219C180h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219C180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C180);
		  /* 8219C180h */ case    0:  		/* and R9, R11, R28 */
		/* 8219C180h case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R11,regs.R28);
		/* 8219C180h case    0:*/		return 0x8219C184;
		  /* 8219C184h */ case    1:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 8219C184h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 8219C184h case    1:*/		return 0x8219C188;
		  /* 8219C188h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8219C188h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219C194;  }
		/* 8219C188h case    2:*/		return 0x8219C18C;
		  /* 8219C18Ch */ case    3:  		/* addi R11, R11, -4 */
		/* 8219C18Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8219C18Ch case    3:*/		return 0x8219C190;
		  /* 8219C190h */ case    4:  		/* addi R10, R28, -4 */
		/* 8219C190h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0xFFFFFFFC);
		/* 8219C190h case    4:*/		return 0x8219C194;
	}
	return 0x8219C194;
} // Block from 8219C180h-8219C194h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219C194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C194);
		  /* 8219C194h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 8219C194h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8219C194h case    0:*/		return 0x8219C198;
		  /* 8219C198h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219C198h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219C1A8;  }
		/* 8219C198h case    1:*/		return 0x8219C19C;
		  /* 8219C19Ch */ case    2:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 8219C19Ch case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 8219C19Ch case    2:*/		return 0x8219C1A0;
		  /* 8219C1A0h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 8219C1A0h case    3:*/		if ( regs.CR[0].eq ) { return 0x8219C1A8;  }
		/* 8219C1A0h case    3:*/		return 0x8219C1A4;
		  /* 8219C1A4h */ case    4:  		/* addi R10, R10, -2 */
		/* 8219C1A4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 8219C1A4h case    4:*/		return 0x8219C1A8;
	}
	return 0x8219C1A8;
} // Block from 8219C194h-8219C1A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219C1A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C1A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C1A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C1A8);
		  /* 8219C1A8h */ case    0:  		/* lwz R7, <#[R31]> */
		/* 8219C1A8h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 8219C1A8h case    0:*/		return 0x8219C1AC;
		  /* 8219C1ACh */ case    1:  		/* or R8, R11, R10 */
		/* 8219C1ACh case    1:*/		cpu::op::or<0>(regs,&regs.R8,regs.R11,regs.R10);
		/* 8219C1ACh case    1:*/		return 0x8219C1B0;
		  /* 8219C1B0h */ case    2:  		/* lwz R9, <#[R1 + 84]> */
		/* 8219C1B0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8219C1B0h case    2:*/		return 0x8219C1B4;
		  /* 8219C1B4h */ case    3:  		/* stw R8, <#[R1 + 80]> */
		/* 8219C1B4h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8219C1B4h case    3:*/		return 0x8219C1B8;
		  /* 8219C1B8h */ case    4:  		/* cmplw CR6, R9, R7 */
		/* 8219C1B8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8219C1B8h case    4:*/		return 0x8219C1BC;
		  /* 8219C1BCh */ case    5:  		/* bc 4, CR6_EQ, 104 */
		/* 8219C1BCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219C224;  }
		/* 8219C1BCh case    5:*/		return 0x8219C1C0;
		  /* 8219C1C0h */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 8219C1C0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8219C1C0h case    6:*/		return 0x8219C1C4;
		  /* 8219C1C4h */ case    7:  		/* cmplw CR6, R8, R11 */
		/* 8219C1C4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 8219C1C4h case    7:*/		return 0x8219C1C8;
		  /* 8219C1C8h */ case    8:  		/* bc 4, CR6_EQ, 92 */
		/* 8219C1C8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8219C224;  }
		/* 8219C1C8h case    8:*/		return 0x8219C1CC;
		  /* 8219C1CCh */ case    9:  		/* rlwinm. R11, R8, 0, 28, 28 */
		/* 8219C1CCh case    9:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R8);
		/* 8219C1CCh case    9:*/		return 0x8219C1D0;
	}
	return 0x8219C1D0;
} // Block from 8219C1A8h-8219C1D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219C1D0h
// Function '?FindMERGEMapping@Compiler@D3DXShader@@AAA_NIQAPAVInstruction@2@QAW4Component@2@QAII012PAI3@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C1D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C1D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C1D0);
		  /* 8219C1D0h */ case    0:  		/* bc 12, CR0_EQ, 24 */
		/* 8219C1D0h case    0:*/		if ( regs.CR[0].eq ) { return 0x8219C1E8;  }
		/* 8219C1D0h case    0:*/		return 0x8219C1D4;
		  /* 8219C1D4h */ case    1:  		/* mr R3, R30 */
		/* 8219C1D4h case    1:*/		regs.R3 = regs.R30;
		/* 8219C1D4h case    1:*/		return 0x8219C1D8;
		  /* 8219C1D8h */ case    2:  		/* bl -149184 */
		/* 8219C1D8h case    2:*/		regs.LR = 0x8219C1DC; return 0x82177B18;
		/* 8219C1D8h case    2:*/		return 0x8219C1DC;
		  /* 8219C1DCh */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219C1DCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219C1DCh case    3:*/		return 0x8219C1E0;
		  /* 8219C1E0h */ case    4:  		/* cmplw CR6, R3, R11 */
		/* 8219C1E0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8219C1E0h case    4:*/		return 0x8219C1E4;
		  /* 8219C1E4h */ case    5:  		/* bc 4, CR6_EQ, 56 */
		/* 8219C1E4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219C21C;  }
		/* 8219C1E4h case    5:*/		return 0x8219C1E8;
	}
	return 0x8219C1E8;
} // Block from 8219C1D0h-8219C1E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219C1E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C1E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C1E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C1E8);
		  /* 8219C1E8h */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 8219C1E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8219C1E8h case    0:*/		return 0x8219C1EC;
		  /* 8219C1ECh */ case    1:  		/* cmplwi CR6, R11, 4 */
		/* 8219C1ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8219C1ECh case    1:*/		return 0x8219C1F0;
		  /* 8219C1F0h */ case    2:  		/* bc 12, CR6_EQ, 444 */
		/* 8219C1F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219C3AC;  }
		/* 8219C1F0h case    2:*/		return 0x8219C1F4;
		  /* 8219C1F4h */ case    3:  		/* rlwinm R10, R11, 0, 0, 31 */
		/* 8219C1F4h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R11);
		/* 8219C1F4h case    3:*/		return 0x8219C1F8;
		  /* 8219C1F8h */ case    4:  		/* lwz R9, <#[R1 + 88]> */
		/* 8219C1F8h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 8219C1F8h case    4:*/		return 0x8219C1FC;
		  /* 8219C1FCh */ case    5:  		/* addi R11, R31, 12 */
		/* 8219C1FCh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xC);
		/* 8219C1FCh case    5:*/		return 0x8219C200;
		  /* 8219C200h */ case    6:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8219C200h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8219C200h case    6:*/		return 0x8219C204;
		  /* 8219C204h */ case    7:  		/* li R24, 1 */
		/* 8219C204h case    7:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8219C204h case    7:*/		return 0x8219C208;
		  /* 8219C208h */ case    8:  		/* stwx R9, <#[R10 + R11]> */
		/* 8219C208h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219C208h case    8:*/		return 0x8219C20C;
		  /* 8219C20Ch */ case    9:  		/* lwz R11, <#[R31 + 28]> */
		/* 8219C20Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8219C20Ch case    9:*/		return 0x8219C210;
		  /* 8219C210h */ case   10:  		/* addi R11, R11, 1 */
		/* 8219C210h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219C210h case   10:*/		return 0x8219C214;
		  /* 8219C214h */ case   11:  		/* stw R11, <#[R31 + 28]> */
		/* 8219C214h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8219C214h case   11:*/		return 0x8219C218;
		  /* 8219C218h */ case   12:  		/* b 392 */
		/* 8219C218h case   12:*/		return 0x8219C3A0;
		/* 8219C218h case   12:*/		return 0x8219C21C;
	}
	return 0x8219C21C;
} // Block from 8219C1E8h-8219C21Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219C21Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C21C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C21C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C21C);
		  /* 8219C21Ch */ case    0:  		/* lwz R8, <#[R1 + 80]> */
		/* 8219C21Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8219C21Ch case    0:*/		return 0x8219C220;
		  /* 8219C220h */ case    1:  		/* lwz R9, <#[R1 + 84]> */
		/* 8219C220h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8219C220h case    1:*/		return 0x8219C224;
	}
	return 0x8219C224;
} // Block from 8219C21Ch-8219C224h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C224);
		  /* 8219C224h */ case    0:  		/* rlwinm. R11, R8, 0, 30, 28 */
		/* 8219C224h case    0:*/		cpu::op::rlwinm<1,0,30,28>(regs,&regs.R11,regs.R8);
		/* 8219C224h case    0:*/		return 0x8219C228;
		  /* 8219C228h */ case    1:  		/* bc 4, CR0_EQ, 104 */
		/* 8219C228h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219C290;  }
		/* 8219C228h case    1:*/		return 0x8219C22C;
		  /* 8219C22Ch */ case    2:  		/* lwz R11, <#[R9 + 8]> */
		/* 8219C22Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 8219C22Ch case    2:*/		return 0x8219C230;
		  /* 8219C230h */ case    3:  		/* lwz R10, <#[R16 + 8]> */
		/* 8219C230h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000008) );
		/* 8219C230h case    3:*/		return 0x8219C234;
		  /* 8219C234h */ case    4:  		/* xor R11, R11, R10 */
		/* 8219C234h case    4:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219C234h case    4:*/		return 0x8219C238;
		  /* 8219C238h */ case    5:  		/* rlwinm. R11, R11, 0, 18, 24 */
		/* 8219C238h case    5:*/		cpu::op::rlwinm<1,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219C238h case    5:*/		return 0x8219C23C;
		  /* 8219C23Ch */ case    6:  		/* bc 4, CR0_EQ, 84 */
		/* 8219C23Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x8219C290;  }
		/* 8219C23Ch case    6:*/		return 0x8219C240;
		  /* 8219C240h */ case    7:  		/* lwz R11, <#[R31 + 196]> */
		/* 8219C240h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 8219C240h case    7:*/		return 0x8219C244;
		  /* 8219C244h */ case    8:  		/* addi R11, R11, 1 */
		/* 8219C244h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219C244h case    8:*/		return 0x8219C248;
		  /* 8219C248h */ case    9:  		/* cmplwi CR6, R11, 8 */
		/* 8219C248h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000008);
		/* 8219C248h case    9:*/		return 0x8219C24C;
		  /* 8219C24Ch */ case   10:  		/* bc 4, CR6_LT, 68 */
		/* 8219C24Ch case   10:*/		if ( !regs.CR[6].lt ) { return 0x8219C290;  }
		/* 8219C24Ch case   10:*/		return 0x8219C250;
		  /* 8219C250h */ case   11:  		/* cmplwi CR6, R27, 0 */
		/* 8219C250h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8219C250h case   11:*/		return 0x8219C254;
		  /* 8219C254h */ case   12:  		/* bc 4, CR6_EQ, 352 */
		/* 8219C254h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8219C3B4;  }
		/* 8219C254h case   12:*/		return 0x8219C258;
		  /* 8219C258h */ case   13:  		/* lwz R10, <#[R9 + 4]> */
		/* 8219C258h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 8219C258h case   13:*/		return 0x8219C25C;
		  /* 8219C25Ch */ case   14:  		/* cmplwi CR6, R10, 0 */
		/* 8219C25Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219C25Ch case   14:*/		return 0x8219C260;
		  /* 8219C260h */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 8219C260h case   15:*/		if ( regs.CR[6].eq ) { return 0x8219C280;  }
		/* 8219C260h case   15:*/		return 0x8219C264;
		  /* 8219C264h */ case   16:  		/* lwz R11, <#[R10 + 16]> */
		/* 8219C264h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 8219C264h case   16:*/		return 0x8219C268;
		  /* 8219C268h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 8219C268h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219C268h case   17:*/		return 0x8219C26C;
		  /* 8219C26Ch */ case   18:  		/* bc 12, CR6_EQ, 12 */
		/* 8219C26Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x8219C278;  }
		/* 8219C26Ch case   18:*/		return 0x8219C270;
		  /* 8219C270h */ case   19:  		/* cmplw CR6, R11, R30 */
		/* 8219C270h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 8219C270h case   19:*/		return 0x8219C274;
		  /* 8219C274h */ case   20:  		/* bc 4, CR6_EQ, 28 */
		/* 8219C274h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8219C290;  }
		/* 8219C274h case   20:*/		return 0x8219C278;
	}
	return 0x8219C278;
} // Block from 8219C224h-8219C278h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8219C278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C278);
		  /* 8219C278h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 8219C278h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8219C278h case    0:*/		return 0x8219C27C;
		  /* 8219C27Ch */ case    1:  		/* b -32 */
		/* 8219C27Ch case    1:*/		return 0x8219C25C;
		/* 8219C27Ch case    1:*/		return 0x8219C280;
	}
	return 0x8219C280;
} // Block from 8219C278h-8219C280h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C280);
		  /* 8219C280h */ case    0:  		/* lwz R22, <#[R1 + 88]> */
		/* 8219C280h case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000058) );
		/* 8219C280h case    0:*/		return 0x8219C284;
		  /* 8219C284h */ case    1:  		/* mr R27, R9 */
		/* 8219C284h case    1:*/		regs.R27 = regs.R9;
		/* 8219C284h case    1:*/		return 0x8219C288;
		  /* 8219C288h */ case    2:  		/* mr R21, R8 */
		/* 8219C288h case    2:*/		regs.R21 = regs.R8;
		/* 8219C288h case    2:*/		return 0x8219C28C;
		  /* 8219C28Ch */ case    3:  		/* b 276 */
		/* 8219C28Ch case    3:*/		return 0x8219C3A0;
		/* 8219C28Ch case    3:*/		return 0x8219C290;
	}
	return 0x8219C290;
} // Block from 8219C280h-8219C290h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219C290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C290);
		  /* 8219C290h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8219C290h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8219C290h case    0:*/		return 0x8219C294;
		  /* 8219C294h */ case    1:  		/* rlwinm R9, R25, 1, 0, 30 */
		/* 8219C294h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R25);
		/* 8219C294h case    1:*/		return 0x8219C298;
		  /* 8219C298h */ case    2:  		/* lwz R8, <#[R29 + 12]> */
		/* 8219C298h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x0000000C) );
		/* 8219C298h case    2:*/		return 0x8219C29C;
		  /* 8219C29Ch */ case    3:  		/* mr R10, R28 */
		/* 8219C29Ch case    3:*/		regs.R10 = regs.R28;
		/* 8219C29Ch case    3:*/		return 0x8219C2A0;
		  /* 8219C2A0h */ case    4:  		/* rlwinm R7, R11, 27, 24, 31 */
		/* 8219C2A0h case    4:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R7,regs.R11);
		/* 8219C2A0h case    4:*/		return 0x8219C2A4;
		  /* 8219C2A4h */ case    5:  		/* rlwinm. R6, R11, 0, 29, 29 */
		/* 8219C2A4h case    5:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R6,regs.R11);
		/* 8219C2A4h case    5:*/		return 0x8219C2A8;
		  /* 8219C2A8h */ case    6:  		/* srw R9, R7, R9 */
		/* 8219C2A8h case    6:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8219C2A8h case    6:*/		return 0x8219C2AC;
		  /* 8219C2ACh */ case    7:  		/* stw R8, <#[R1 + 96]> */
		/* 8219C2ACh case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 8219C2ACh case    7:*/		return 0x8219C2B0;
		  /* 8219C2B0h */ case    8:  		/* rlwinm R9, R9, 0, 30, 31 */
		/* 8219C2B0h case    8:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R9);
		/* 8219C2B0h case    8:*/		return 0x8219C2B4;
		  /* 8219C2B4h */ case    9:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8219C2B4h case    9:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219C2B4h case    9:*/		return 0x8219C2B8;
		  /* 8219C2B8h */ case   10:  		/* stw R9, <#[R1 + 100]> */
		/* 8219C2B8h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000064) );
		/* 8219C2B8h case   10:*/		return 0x8219C2BC;
		  /* 8219C2BCh */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 8219C2BCh case   11:*/		if ( regs.CR[0].eq ) { return 0x8219C2CC;  }
		/* 8219C2BCh case   11:*/		return 0x8219C2C0;
		  /* 8219C2C0h */ case   12:  		/* rlwinm. R9, R28, 0, 30, 30 */
		/* 8219C2C0h case   12:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R28);
		/* 8219C2C0h case   12:*/		return 0x8219C2C4;
		  /* 8219C2C4h */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 8219C2C4h case   13:*/		if ( regs.CR[0].eq ) { return 0x8219C2CC;  }
		/* 8219C2C4h case   13:*/		return 0x8219C2C8;
		  /* 8219C2C8h */ case   14:  		/* addi R11, R11, -4 */
		/* 8219C2C8h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8219C2C8h case   14:*/		return 0x8219C2CC;
	}
	return 0x8219C2CC;
} // Block from 8219C290h-8219C2CCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219C2CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C2CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C2CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C2CC);
		  /* 8219C2CCh */ case    0:  		/* and R9, R11, R28 */
		/* 8219C2CCh case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R11,regs.R28);
		/* 8219C2CCh case    0:*/		return 0x8219C2D0;
		  /* 8219C2D0h */ case    1:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 8219C2D0h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 8219C2D0h case    1:*/		return 0x8219C2D4;
		  /* 8219C2D4h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8219C2D4h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219C2E0;  }
		/* 8219C2D4h case    2:*/		return 0x8219C2D8;
		  /* 8219C2D8h */ case    3:  		/* addi R11, R11, -4 */
		/* 8219C2D8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8219C2D8h case    3:*/		return 0x8219C2DC;
		  /* 8219C2DCh */ case    4:  		/* addi R10, R28, -4 */
		/* 8219C2DCh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0xFFFFFFFC);
		/* 8219C2DCh case    4:*/		return 0x8219C2E0;
	}
	return 0x8219C2E0;
} // Block from 8219C2CCh-8219C2E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219C2E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C2E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C2E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C2E0);
		  /* 8219C2E0h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 8219C2E0h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8219C2E0h case    0:*/		return 0x8219C2E4;
		  /* 8219C2E4h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219C2E4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219C2F4;  }
		/* 8219C2E4h case    1:*/		return 0x8219C2E8;
		  /* 8219C2E8h */ case    2:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 8219C2E8h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 8219C2E8h case    2:*/		return 0x8219C2EC;
		  /* 8219C2ECh */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 8219C2ECh case    3:*/		if ( regs.CR[0].eq ) { return 0x8219C2F4;  }
		/* 8219C2ECh case    3:*/		return 0x8219C2F0;
		  /* 8219C2F0h */ case    4:  		/* addi R10, R10, -2 */
		/* 8219C2F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 8219C2F0h case    4:*/		return 0x8219C2F4;
	}
	return 0x8219C2F4;
} // Block from 8219C2E0h-8219C2F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219C2F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C2F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C2F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C2F4);
		  /* 8219C2F4h */ case    0:  		/* or R10, R10, R11 */
		/* 8219C2F4h case    0:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8219C2F4h case    0:*/		return 0x8219C2F8;
		  /* 8219C2F8h */ case    1:  		/* lwz R8, <#[R31 + 160]> */
		/* 8219C2F8h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219C2F8h case    1:*/		return 0x8219C2FC;
		  /* 8219C2FCh */ case    2:  		/* addi R9, R1, 96 */
		/* 8219C2FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 8219C2FCh case    2:*/		return 0x8219C300;
		  /* 8219C300h */ case    3:  		/* stw R30, <#[R1 + 108]> */
		/* 8219C300h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000006C) );
		/* 8219C300h case    3:*/		return 0x8219C304;
		  /* 8219C304h */ case    4:  		/* stw R10, <#[R1 + 104]> */
		/* 8219C304h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 8219C304h case    4:*/		return 0x8219C308;
		  /* 8219C308h */ case    5:  		/* rlwinm R10, R8, 4, 0, 27 */
		/* 8219C308h case    5:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R8);
		/* 8219C308h case    5:*/		return 0x8219C30C;
		  /* 8219C30Ch */ case    6:  		/* addi R11, R31, 32 */
		/* 8219C30Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x20);
		/* 8219C30Ch case    6:*/		return 0x8219C310;
		  /* 8219C310h */ case    7:  		/* add R7, R10, R11 */
		/* 8219C310h case    7:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 8219C310h case    7:*/		return 0x8219C314;
		  /* 8219C314h */ case    8:  		/* lwz R6, <#[R9]> */
		/* 8219C314h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x00000000) );
		/* 8219C314h case    8:*/		return 0x8219C318;
		  /* 8219C318h */ case    9:  		/* stwx R6, <#[R10 + R11]> */
		/* 8219C318h case    9:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219C318h case    9:*/		return 0x8219C31C;
		  /* 8219C31Ch */ case   10:  		/* lwz R11, <#[R9 + 4]> */
		/* 8219C31Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8219C31Ch case   10:*/		return 0x8219C320;
		  /* 8219C320h */ case   11:  		/* stw R11, <#[R7 + 4]> */
		/* 8219C320h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		/* 8219C320h case   11:*/		return 0x8219C324;
		  /* 8219C324h */ case   12:  		/* lwz R11, <#[R9 + 8]> */
		/* 8219C324h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 8219C324h case   12:*/		return 0x8219C328;
		  /* 8219C328h */ case   13:  		/* stw R11, <#[R7 + 8]> */
		/* 8219C328h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 8219C328h case   13:*/		return 0x8219C32C;
		  /* 8219C32Ch */ case   14:  		/* lwz R8, <#[R9 + 12]> */
		/* 8219C32Ch case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 8219C32Ch case   14:*/		return 0x8219C330;
		  /* 8219C330h */ case   15:  		/* stw R8, <#[R7 + 12]> */
		/* 8219C330h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x0000000C) );
		/* 8219C330h case   15:*/		return 0x8219C334;
		  /* 8219C334h */ case   16:  		/* lwz R10, <#[R31 + 160]> */
		/* 8219C334h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219C334h case   16:*/		return 0x8219C338;
	}
	return 0x8219C338;
} // Block from 8219C2F4h-8219C338h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219C338h
// Function '?SortCombineUnrelatedCandidates@Compiler@D3DXShader@@CAHPBX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C338);
		  /* 8219C338h */ case    0:  		/* lwz R3, <#[R1 + 84]> */
		/* 8219C338h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8219C338h case    0:*/		return 0x8219C33C;
		  /* 8219C33Ch */ case    1:  		/* addi R11, R10, 1 */
		/* 8219C33Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 8219C33Ch case    1:*/		return 0x8219C340;
		  /* 8219C340h */ case    2:  		/* stw R11, <#[R31 + 160]> */
		/* 8219C340h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219C340h case    2:*/		return 0x8219C344;
		  /* 8219C344h */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219C344h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219C344h case    3:*/		return 0x8219C348;
		  /* 8219C348h */ case    4:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219C348h case    4:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219C348h case    4:*/		return 0x8219C34C;
		  /* 8219C34Ch */ case    5:  		/* cmplwi CR6, R11, 16000 */
		/* 8219C34Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8219C34Ch case    5:*/		return 0x8219C350;
		  /* 8219C350h */ case    6:  		/* bc 4, CR6_EQ, 80 */
		/* 8219C350h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219C3A0;  }
		/* 8219C350h case    6:*/		return 0x8219C354;
		  /* 8219C354h */ case    7:  		/* lwz R11, <#[R31 + 4]> */
		/* 8219C354h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8219C354h case    7:*/		return 0x8219C358;
		  /* 8219C358h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8219C358h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219C358h case    8:*/		return 0x8219C35C;
		  /* 8219C35Ch */ case    9:  		/* bc 4, CR6_EQ, 68 */
		/* 8219C35Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219C3A0;  }
		/* 8219C35Ch case    9:*/		return 0x8219C360;
		  /* 8219C360h */ case   10:  		/* lwz R11, <#[R31 + 208]> */
		/* 8219C360h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000D0) );
		/* 8219C360h case   10:*/		return 0x8219C364;
		  /* 8219C364h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8219C364h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219C364h case   11:*/		return 0x8219C368;
		  /* 8219C368h */ case   12:  		/* bc 4, CR6_EQ, 56 */
		/* 8219C368h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8219C3A0;  }
		/* 8219C368h case   12:*/		return 0x8219C36C;
		  /* 8219C36Ch */ case   13:  		/* lwz R5, <#[R1 + 80]> */
		/* 8219C36Ch case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8219C36Ch case   13:*/		return 0x8219C370;
		  /* 8219C370h */ case   14:  		/* lwz R4, <#[R1 + 88]> */
		/* 8219C370h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 8219C370h case   14:*/		return 0x8219C374;
		  /* 8219C374h */ case   15:  		/* bl 545556 */
		/* 8219C374h case   15:*/		regs.LR = 0x8219C378; return 0x82221688;
		/* 8219C374h case   15:*/		return 0x8219C378;
		  /* 8219C378h */ case   16:  		/* mr R4, R18 */
		/* 8219C378h case   16:*/		regs.R4 = regs.R18;
		/* 8219C378h case   16:*/		return 0x8219C37C;
		  /* 8219C37Ch */ case   17:  		/* mr R3, R17 */
		/* 8219C37Ch case   17:*/		regs.R3 = regs.R17;
		/* 8219C37Ch case   17:*/		return 0x8219C380;
		  /* 8219C380h */ case   18:  		/* li R6, 0 */
		/* 8219C380h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8219C380h case   18:*/		return 0x8219C384;
		  /* 8219C384h */ case   19:  		/* li R7, 1 */
		/* 8219C384h case   19:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8219C384h case   19:*/		return 0x8219C388;
		  /* 8219C388h */ case   20:  		/* bl 590984 */
		/* 8219C388h case   20:*/		regs.LR = 0x8219C38C; return 0x8222C810;
		/* 8219C388h case   20:*/		return 0x8219C38C;
		  /* 8219C38Ch */ case   21:  		/* stw R3, <#[R31 + 212]> */
		/* 8219C38Ch case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000D4) );
		/* 8219C38Ch case   21:*/		return 0x8219C390;
		  /* 8219C390h */ case   22:  		/* cmpwi CR6, R3, 4 */
		/* 8219C390h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 8219C390h case   22:*/		return 0x8219C394;
		  /* 8219C394h */ case   23:  		/* bc 12, CR6_EQ, 12 */
		/* 8219C394h case   23:*/		if ( regs.CR[6].eq ) { return 0x8219C3A0;  }
		/* 8219C394h case   23:*/		return 0x8219C398;
		  /* 8219C398h */ case   24:  		/* lwz R11, <#[R31 + 160]> */
		/* 8219C398h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219C398h case   24:*/		return 0x8219C39C;
		  /* 8219C39Ch */ case   25:  		/* stw R11, <#[R31 + 208]> */
		/* 8219C39Ch case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000D0) );
		/* 8219C39Ch case   25:*/		return 0x8219C3A0;
	}
	return 0x8219C3A0;
} // Block from 8219C338h-8219C3A0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8219C3A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C3A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C3A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C3A0);
		  /* 8219C3A0h */ case    0:  		/* addi R23, R23, 1 */
		/* 8219C3A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 8219C3A0h case    0:*/		return 0x8219C3A4;
		  /* 8219C3A4h */ case    1:  		/* addi R26, R26, 4 */
		/* 8219C3A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8219C3A4h case    1:*/		return 0x8219C3A8;
		  /* 8219C3A8h */ case    2:  		/* b -636 */
		/* 8219C3A8h case    2:*/		return 0x8219C12C;
		/* 8219C3A8h case    2:*/		return 0x8219C3AC;
	}
	return 0x8219C3AC;
} // Block from 8219C3A0h-8219C3ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219C3ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C3AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C3AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C3AC);
		  /* 8219C3ACh */ case    0:  		/* li R24, 0 */
		/* 8219C3ACh case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8219C3ACh case    0:*/		return 0x8219C3B0;
		  /* 8219C3B0h */ case    1:  		/* b 8 */
		/* 8219C3B0h case    1:*/		return 0x8219C3B8;
		/* 8219C3B0h case    1:*/		return 0x8219C3B4;
	}
	return 0x8219C3B4;
} // Block from 8219C3ACh-8219C3B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C3B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C3B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C3B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C3B4);
		  /* 8219C3B4h */ case    0:  		/* li R27, 0 */
		/* 8219C3B4h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8219C3B4h case    0:*/		return 0x8219C3B8;
	}
	return 0x8219C3B8;
} // Block from 8219C3B4h-8219C3B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C3B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C3B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C3B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C3B8);
		  /* 8219C3B8h */ case    0:  		/* rlwinm. R11, R24, 0, 24, 31 */
		/* 8219C3B8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R24);
		/* 8219C3B8h case    0:*/		return 0x8219C3BC;
		  /* 8219C3BCh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8219C3BCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219C3C8;  }
		/* 8219C3BCh case    1:*/		return 0x8219C3C0;
	}
	return 0x8219C3C0;
} // Block from 8219C3B8h-8219C3C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C3C0h
// Function '?FindPossibleVectorizationInTree_MemoizingSearch@Compiler@D3DXShader@@AAA_NPAUPossibleVectorization@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C3C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C3C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C3C0);
		  /* 8219C3C0h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 8219C3C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8219C3C0h case    0:*/		return 0x8219C3C4;
		  /* 8219C3C4h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 8219C3C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219C408;  }
		/* 8219C3C4h case    1:*/		return 0x8219C3C8;
	}
	return 0x8219C3C8;
} // Block from 8219C3C0h-8219C3C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C3C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C3C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C3C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C3C8);
		  /* 8219C3C8h */ case    0:  		/* lwz R10, <#[R31 + 196]> */
		/* 8219C3C8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000C4) );
		/* 8219C3C8h case    0:*/		return 0x8219C3CC;
		  /* 8219C3CCh */ case    1:  		/* addi R11, R31, 164 */
		/* 8219C3CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xA4);
		/* 8219C3CCh case    1:*/		return 0x8219C3D0;
		  /* 8219C3D0h */ case    2:  		/* cmplwi CR6, R27, 0 */
		/* 8219C3D0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 8219C3D0h case    2:*/		return 0x8219C3D4;
		  /* 8219C3D4h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8219C3D4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8219C3D4h case    3:*/		return 0x8219C3D8;
		  /* 8219C3D8h */ case    4:  		/* stwx R30, <#[R10 + R11]> */
		/* 8219C3D8h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219C3D8h case    4:*/		return 0x8219C3DC;
		  /* 8219C3DCh */ case    5:  		/* lwz R11, <#[R31 + 196]> */
		/* 8219C3DCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 8219C3DCh case    5:*/		return 0x8219C3E0;
		  /* 8219C3E0h */ case    6:  		/* addi R11, R11, 1 */
		/* 8219C3E0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219C3E0h case    6:*/		return 0x8219C3E4;
		  /* 8219C3E4h */ case    7:  		/* stw R11, <#[R31 + 196]> */
		/* 8219C3E4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 8219C3E4h case    7:*/		return 0x8219C3E8;
		  /* 8219C3E8h */ case    8:  		/* bc 12, CR6_EQ, 124 */
		/* 8219C3E8h case    8:*/		if ( regs.CR[6].eq ) { return 0x8219C464;  }
		/* 8219C3E8h case    8:*/		return 0x8219C3EC;
		  /* 8219C3ECh */ case    9:  		/* lwz R11, <#[R31 + 28]> */
		/* 8219C3ECh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8219C3ECh case    9:*/		return 0x8219C3F0;
		  /* 8219C3F0h */ case   10:  		/* mr R30, R27 */
		/* 8219C3F0h case   10:*/		regs.R30 = regs.R27;
		/* 8219C3F0h case   10:*/		return 0x8219C3F4;
		  /* 8219C3F4h */ case   11:  		/* mr R25, R22 */
		/* 8219C3F4h case   11:*/		regs.R25 = regs.R22;
		/* 8219C3F4h case   11:*/		return 0x8219C3F8;
		  /* 8219C3F8h */ case   12:  		/* mr R28, R21 */
		/* 8219C3F8h case   12:*/		regs.R28 = regs.R21;
		/* 8219C3F8h case   12:*/		return 0x8219C3FC;
		  /* 8219C3FCh */ case   13:  		/* cmplwi CR6, R11, 4 */
		/* 8219C3FCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8219C3FCh case   13:*/		return 0x8219C400;
		  /* 8219C400h */ case   14:  		/* bc 4, CR6_EQ, -756 */
		/* 8219C400h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8219C10C;  }
		/* 8219C400h case   14:*/		return 0x8219C404;
		  /* 8219C404h */ case   15:  		/* b 12 */
		/* 8219C404h case   15:*/		return 0x8219C410;
		/* 8219C404h case   15:*/		return 0x8219C408;
	}
	return 0x8219C408;
} // Block from 8219C3C8h-8219C408h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219C408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C408);
		  /* 8219C408h */ case    0:  		/* stw R20, <#[R31 + 28]> */
		/* 8219C408h case    0:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R31 + 0x0000001C) );
		/* 8219C408h case    0:*/		return 0x8219C40C;
		  /* 8219C40Ch */ case    1:  		/* stw R19, <#[R31 + 160]> */
		/* 8219C40Ch case    1:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219C40Ch case    1:*/		return 0x8219C410;
	}
	return 0x8219C410;
} // Block from 8219C408h-8219C410h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C410);
		  /* 8219C410h */ case    0:  		/* li R10, 0 */
		/* 8219C410h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219C410h case    0:*/		return 0x8219C414;
		  /* 8219C414h */ case    1:  		/* stw R28, <#[R1 + 104]> */
		/* 8219C414h case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000068) );
		/* 8219C414h case    1:*/		return 0x8219C418;
		  /* 8219C418h */ case    2:  		/* stw R25, <#[R1 + 100]> */
		/* 8219C418h case    2:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000064) );
		/* 8219C418h case    2:*/		return 0x8219C41C;
		  /* 8219C41Ch */ case    3:  		/* addi R9, R1, 96 */
		/* 8219C41Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 8219C41Ch case    3:*/		return 0x8219C420;
		  /* 8219C420h */ case    4:  		/* stw R10, <#[R1 + 108]> */
		/* 8219C420h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000006C) );
		/* 8219C420h case    4:*/		return 0x8219C424;
		  /* 8219C424h */ case    5:  		/* addi R11, R31, 32 */
		/* 8219C424h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x20);
		/* 8219C424h case    5:*/		return 0x8219C428;
		  /* 8219C428h */ case    6:  		/* stw R30, <#[R1 + 96]> */
		/* 8219C428h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000060) );
		/* 8219C428h case    6:*/		return 0x8219C42C;
		  /* 8219C42Ch */ case    7:  		/* lwz R10, <#[R31 + 160]> */
		/* 8219C42Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219C42Ch case    7:*/		return 0x8219C430;
		  /* 8219C430h */ case    8:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 8219C430h case    8:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 8219C430h case    8:*/		return 0x8219C434;
		  /* 8219C434h */ case    9:  		/* lwz R5, <#[R9]> */
		/* 8219C434h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R9 + 0x00000000) );
		/* 8219C434h case    9:*/		return 0x8219C438;
		  /* 8219C438h */ case   10:  		/* stwx R5, <#[R10 + R11]> */
		/* 8219C438h case   10:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219C438h case   10:*/		return 0x8219C43C;
		  /* 8219C43Ch */ case   11:  		/* add R6, R10, R11 */
		/* 8219C43Ch case   11:*/		cpu::op::add<0>(regs,&regs.R6,regs.R10,regs.R11);
		/* 8219C43Ch case   11:*/		return 0x8219C440;
		  /* 8219C440h */ case   12:  		/* lwz R7, <#[R9 + 4]> */
		/* 8219C440h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000004) );
		/* 8219C440h case   12:*/		return 0x8219C444;
		  /* 8219C444h */ case   13:  		/* lwz R8, <#[R9 + 8]> */
		/* 8219C444h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000008) );
		/* 8219C444h case   13:*/		return 0x8219C448;
		  /* 8219C448h */ case   14:  		/* stw R7, <#[R6 + 4]> */
		/* 8219C448h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000004) );
		/* 8219C448h case   14:*/		return 0x8219C44C;
		  /* 8219C44Ch */ case   15:  		/* lwz R11, <#[R9 + 12]> */
		/* 8219C44Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 8219C44Ch case   15:*/		return 0x8219C450;
		  /* 8219C450h */ case   16:  		/* stw R8, <#[R6 + 8]> */
		/* 8219C450h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000008) );
		/* 8219C450h case   16:*/		return 0x8219C454;
		  /* 8219C454h */ case   17:  		/* stw R11, <#[R6 + 12]> */
		/* 8219C454h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x0000000C) );
		/* 8219C454h case   17:*/		return 0x8219C458;
		  /* 8219C458h */ case   18:  		/* lwz R10, <#[R31 + 160]> */
		/* 8219C458h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219C458h case   18:*/		return 0x8219C45C;
		  /* 8219C45Ch */ case   19:  		/* addi R11, R10, 1 */
		/* 8219C45Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x1);
		/* 8219C45Ch case   19:*/		return 0x8219C460;
	}
	return 0x8219C460;
} // Block from 8219C410h-8219C460h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219C460h
// Function '?FindPossibleVectorizationInTree_Cleanup@Compiler@D3DXShader@@AAAXPAUPossibleVectorization@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C460);
		  /* 8219C460h */ case    0:  		/* stw R11, <#[R31 + 160]> */
		/* 8219C460h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219C460h case    0:*/		return 0x8219C464;
	}
	return 0x8219C464;
} // Block from 8219C460h-8219C464h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C464);
		  /* 8219C464h */ case    0:  		/* addi R1, R1, 256 */
		/* 8219C464h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 8219C464h case    0:*/		return 0x8219C468;
		  /* 8219C468h */ case    1:  		/* b -1094128 */
		/* 8219C468h case    1:*/		return 0x82091278;
		/* 8219C468h case    1:*/		return 0x8219C46C;
		  /* 8219C46Ch */ case    2:  		/* nop */
		/* 8219C46Ch case    2:*/		cpu::op::nop();
		/* 8219C46Ch case    2:*/		return 0x8219C470;
	}
	return 0x8219C470;
} // Block from 8219C464h-8219C470h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219C470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C470);
		  /* 8219C470h */ case    0:  		/* mfspr R12, LR */
		/* 8219C470h case    0:*/		regs.R12 = regs.LR;
		/* 8219C470h case    0:*/		return 0x8219C474;
		  /* 8219C474h */ case    1:  		/* bl -1094176 */
		/* 8219C474h case    1:*/		regs.LR = 0x8219C478; return 0x82091254;
		/* 8219C474h case    1:*/		return 0x8219C478;
		  /* 8219C478h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8219C478h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8219C478h case    2:*/		return 0x8219C47C;
		  /* 8219C47Ch */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219C47Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219C47Ch case    3:*/		return 0x8219C480;
		  /* 8219C480h */ case    4:  		/* mr R28, R3 */
		/* 8219C480h case    4:*/		regs.R28 = regs.R3;
		/* 8219C480h case    4:*/		return 0x8219C484;
		  /* 8219C484h */ case    5:  		/* mr R27, R5 */
		/* 8219C484h case    5:*/		regs.R27 = regs.R5;
		/* 8219C484h case    5:*/		return 0x8219C488;
		  /* 8219C488h */ case    6:  		/* rlwinm R11, R11, 0, 15, 17 */
		/* 8219C488h case    6:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R11);
		/* 8219C488h case    6:*/		return 0x8219C48C;
		  /* 8219C48Ch */ case    7:  		/* cmplwi CR6, R11, 16384 */
		/* 8219C48Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00004000);
		/* 8219C48Ch case    7:*/		return 0x8219C490;
		  /* 8219C490h */ case    8:  		/* bc 12, CR6_EQ, 252 */
		/* 8219C490h case    8:*/		if ( regs.CR[6].eq ) { return 0x8219C58C;  }
		/* 8219C490h case    8:*/		return 0x8219C494;
		  /* 8219C494h */ case    9:  		/* lwz R9, <#[R4 + 4]> */
		/* 8219C494h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000004) );
		/* 8219C494h case    9:*/		return 0x8219C498;
		  /* 8219C498h */ case   10:  		/* mr R11, R9 */
		/* 8219C498h case   10:*/		regs.R11 = regs.R9;
		/* 8219C498h case   10:*/		return 0x8219C49C;
		  /* 8219C49Ch */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8219C49Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219C49Ch case   11:*/		return 0x8219C4A0;
		  /* 8219C4A0h */ case   12:  		/* bc 12, CR6_EQ, 60 */
		/* 8219C4A0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8219C4DC;  }
		/* 8219C4A0h case   12:*/		return 0x8219C4A4;
		  /* 8219C4A4h */ case   13:  		/* lwz R10, <#[R11 + 16]> */
		/* 8219C4A4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8219C4A4h case   13:*/		return 0x8219C4A8;
		  /* 8219C4A8h */ case   14:  		/* cmplwi CR6, R10, 0 */
		/* 8219C4A8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219C4A8h case   14:*/		return 0x8219C4AC;
		  /* 8219C4ACh */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 8219C4ACh case   15:*/		if ( regs.CR[6].eq ) { return 0x8219C4CC;  }
		/* 8219C4ACh case   15:*/		return 0x8219C4B0;
		  /* 8219C4B0h */ case   16:  		/* lwz R8, <#[R10 + 8]> */
		/* 8219C4B0h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 8219C4B0h case   16:*/		return 0x8219C4B4;
		  /* 8219C4B4h */ case   17:  		/* rlwinm R8, R8, 0, 18, 24 */
		/* 8219C4B4h case   17:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R8,regs.R8);
		/* 8219C4B4h case   17:*/		return 0x8219C4B8;
		  /* 8219C4B8h */ case   18:  		/* cmplwi CR6, R8, 14080 */
		/* 8219C4B8h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00003700);
		/* 8219C4B8h case   18:*/		return 0x8219C4BC;
		  /* 8219C4BCh */ case   19:  		/* bc 4, CR6_EQ, 16 */
		/* 8219C4BCh case   19:*/		if ( !regs.CR[6].eq ) { return 0x8219C4CC;  }
		/* 8219C4BCh case   19:*/		return 0x8219C4C0;
		  /* 8219C4C0h */ case   20:  		/* lwz R8, <#[R11]> */
		/* 8219C4C0h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8219C4C0h case   20:*/		return 0x8219C4C4;
		  /* 8219C4C4h */ case   21:  		/* rlwinm. R8, R8, 0, 4, 6 */
		/* 8219C4C4h case   21:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R8);
		/* 8219C4C4h case   21:*/		return 0x8219C4C8;
	}
	return 0x8219C4C8;
} // Block from 8219C470h-8219C4C8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8219C4C8h
// Function '?RedirectPossibleVectorizationLinks@Compiler@D3DXShader@@AAAXPAVInstruction@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C4C8);
		  /* 8219C4C8h */ case    0:  		/* bc 4, CR0_EQ, 12 */
		/* 8219C4C8h case    0:*/		if ( !regs.CR[0].eq ) { return 0x8219C4D4;  }
		/* 8219C4C8h case    0:*/		return 0x8219C4CC;
	}
	return 0x8219C4CC;
} // Block from 8219C4C8h-8219C4CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C4CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C4CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C4CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C4CC);
		  /* 8219C4CCh */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219C4CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219C4CCh case    0:*/		return 0x8219C4D0;
		  /* 8219C4D0h */ case    1:  		/* b -52 */
		/* 8219C4D0h case    1:*/		return 0x8219C49C;
		/* 8219C4D0h case    1:*/		return 0x8219C4D4;
	}
	return 0x8219C4D4;
} // Block from 8219C4CCh-8219C4D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C4D4);
		  /* 8219C4D4h */ case    0:  		/* mr R29, R10 */
		/* 8219C4D4h case    0:*/		regs.R29 = regs.R10;
		/* 8219C4D4h case    0:*/		return 0x8219C4D8;
		  /* 8219C4D8h */ case    1:  		/* b 8 */
		/* 8219C4D8h case    1:*/		return 0x8219C4E0;
		/* 8219C4D8h case    1:*/		return 0x8219C4DC;
	}
	return 0x8219C4DC;
} // Block from 8219C4D4h-8219C4DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C4DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C4DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C4DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C4DC);
		  /* 8219C4DCh */ case    0:  		/* li R29, 0 */
		/* 8219C4DCh case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8219C4DCh case    0:*/		return 0x8219C4E0;
	}
	return 0x8219C4E0;
} // Block from 8219C4DCh-8219C4E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C4E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C4E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C4E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C4E0);
		  /* 8219C4E0h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8219C4E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8219C4E0h case    0:*/		return 0x8219C4E4;
		  /* 8219C4E4h */ case    1:  		/* bc 12, CR6_EQ, 168 */
		/* 8219C4E4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219C58C;  }
		/* 8219C4E4h case    1:*/		return 0x8219C4E8;
		  /* 8219C4E8h */ case    2:  		/* mr R30, R9 */
		/* 8219C4E8h case    2:*/		regs.R30 = regs.R9;
		/* 8219C4E8h case    2:*/		return 0x8219C4EC;
		  /* 8219C4ECh */ case    3:  		/* li R31, 1 */
		/* 8219C4ECh case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 8219C4ECh case    3:*/		return 0x8219C4F0;
		  /* 8219C4F0h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 8219C4F0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219C4F0h case    4:*/		return 0x8219C4F4;
		  /* 8219C4F4h */ case    5:  		/* bc 12, CR6_EQ, 152 */
		/* 8219C4F4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219C58C;  }
		/* 8219C4F4h case    5:*/		return 0x8219C4F8;
		  /* 8219C4F8h */ case    6:  		/* lwz R5, <#[R30 + 16]> */
		/* 8219C4F8h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000010) );
		/* 8219C4F8h case    6:*/		return 0x8219C4FC;
		  /* 8219C4FCh */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 8219C4FCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8219C4FCh case    7:*/		return 0x8219C500;
		  /* 8219C500h */ case    8:  		/* bc 12, CR6_EQ, 124 */
		/* 8219C500h case    8:*/		if ( regs.CR[6].eq ) { return 0x8219C57C;  }
		/* 8219C500h case    8:*/		return 0x8219C504;
		  /* 8219C504h */ case    9:  		/* lwz R7, <#[R30]> */
		/* 8219C504h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000000) );
		/* 8219C504h case    9:*/		return 0x8219C508;
		  /* 8219C508h */ case   10:  		/* rlwinm. R8, R7, 7, 29, 31 */
		/* 8219C508h case   10:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R8,regs.R7);
		/* 8219C508h case   10:*/		return 0x8219C50C;
		  /* 8219C50Ch */ case   11:  		/* bc 12, CR0_EQ, 112 */
		/* 8219C50Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x8219C57C;  }
		/* 8219C50Ch case   11:*/		return 0x8219C510;
		  /* 8219C510h */ case   12:  		/* cmplw CR6, R5, R29 */
		/* 8219C510h case   12:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R29);
		/* 8219C510h case   12:*/		return 0x8219C514;
		  /* 8219C514h */ case   13:  		/* bc 12, CR6_EQ, 104 */
		/* 8219C514h case   13:*/		if ( regs.CR[6].eq ) { return 0x8219C57C;  }
		/* 8219C514h case   13:*/		return 0x8219C518;
		  /* 8219C518h */ case   14:  		/* addic. R11, R8, -1 */
		/* 8219C518h case   14:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R8,0xFFFFFFFF);
		/* 8219C518h case   14:*/		return 0x8219C51C;
		  /* 8219C51Ch */ case   15:  		/* bc 12, CR0_EQ, 96 */
		/* 8219C51Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x8219C57C;  }
		/* 8219C51Ch case   15:*/		return 0x8219C520;
		  /* 8219C520h */ case   16:  		/* li R9, 0 */
		/* 8219C520h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219C520h case   16:*/		return 0x8219C524;
		  /* 8219C524h */ case   17:  		/* li R11, 0 */
		/* 8219C524h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219C524h case   17:*/		return 0x8219C528;
		  /* 8219C528h */ case   18:  		/* cmplwi CR6, R8, 0 */
		/* 8219C528h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8219C528h case   18:*/		return 0x8219C52C;
		  /* 8219C52Ch */ case   19:  		/* bc 12, CR6_EQ, 44 */
		/* 8219C52Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x8219C558;  }
		/* 8219C52Ch case   19:*/		return 0x8219C530;
		  /* 8219C530h */ case   20:  		/* li R10, 0 */
		/* 8219C530h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219C530h case   20:*/		return 0x8219C534;
		  /* 8219C534h */ case   21:  		/* rlwinm R6, R7, 27, 24, 31 */
		/* 8219C534h case   21:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R7);
		/* 8219C534h case   21:*/		return 0x8219C538;
		  /* 8219C538h */ case   22:  		/* addi R11, R11, 1 */
		/* 8219C538h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219C538h case   22:*/		return 0x8219C53C;
		  /* 8219C53Ch */ case   23:  		/* srw R6, R6, R10 */
		/* 8219C53Ch case   23:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R6,regs.R10);
		/* 8219C53Ch case   23:*/		return 0x8219C540;
		  /* 8219C540h */ case   24:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 8219C540h case   24:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 8219C540h case   24:*/		return 0x8219C544;
		  /* 8219C544h */ case   25:  		/* addi R10, R10, 2 */
		/* 8219C544h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8219C544h case   25:*/		return 0x8219C548;
		  /* 8219C548h */ case   26:  		/* slw R6, R31, R6 */
		/* 8219C548h case   26:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R31,regs.R6);
		/* 8219C548h case   26:*/		return 0x8219C54C;
		  /* 8219C54Ch */ case   27:  		/* or R9, R6, R9 */
		/* 8219C54Ch case   27:*/		cpu::op::or<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 8219C54Ch case   27:*/		return 0x8219C550;
	}
	return 0x8219C550;
} // Block from 8219C4E0h-8219C550h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8219C550h
// Function '?FindPossibleVectorizationBenefit@Compiler@D3DXShader@@AAAIPAVInstruction@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C550);
		  /* 8219C550h */ case    0:  		/* cmplw CR6, R11, R8 */
		/* 8219C550h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8219C550h case    0:*/		return 0x8219C554;
		  /* 8219C554h */ case    1:  		/* bc 12, CR6_LT, -32 */
		/* 8219C554h case    1:*/		if ( regs.CR[6].lt ) { return 0x8219C534;  }
		/* 8219C554h case    1:*/		return 0x8219C558;
	}
	return 0x8219C558;
} // Block from 8219C550h-8219C558h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C558);
		  /* 8219C558h */ case    0:  		/* slw R11, R31, R27 */
		/* 8219C558h case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R31,regs.R27);
		/* 8219C558h case    0:*/		return 0x8219C55C;
		  /* 8219C55Ch */ case    1:  		/* and. R11, R11, R9 */
		/* 8219C55Ch case    1:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8219C55Ch case    1:*/		return 0x8219C560;
		  /* 8219C560h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 8219C560h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219C57C;  }
		/* 8219C560h case    2:*/		return 0x8219C564;
		  /* 8219C564h */ case    3:  		/* li R6, 1 */
		/* 8219C564h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8219C564h case    3:*/		return 0x8219C568;
		  /* 8219C568h */ case    4:  		/* mr R4, R29 */
		/* 8219C568h case    4:*/		regs.R4 = regs.R29;
		/* 8219C568h case    4:*/		return 0x8219C56C;
		  /* 8219C56Ch */ case    5:  		/* mr R3, R28 */
		/* 8219C56Ch case    5:*/		regs.R3 = regs.R28;
		/* 8219C56Ch case    5:*/		return 0x8219C570;
		  /* 8219C570h */ case    6:  		/* bl 589560 */
		/* 8219C570h case    6:*/		regs.LR = 0x8219C574; return 0x8222C468;
		/* 8219C570h case    6:*/		return 0x8219C574;
		  /* 8219C574h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219C574h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219C574h case    7:*/		return 0x8219C578;
		  /* 8219C578h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 8219C578h case    8:*/		if ( regs.CR[0].eq ) { return 0x8219C584;  }
		/* 8219C578h case    8:*/		return 0x8219C57C;
	}
	return 0x8219C57C;
} // Block from 8219C558h-8219C57Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219C57Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C57C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C57C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C57C);
		  /* 8219C57Ch */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 8219C57Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 8219C57Ch case    0:*/		return 0x8219C580;
		  /* 8219C580h */ case    1:  		/* b -144 */
		/* 8219C580h case    1:*/		return 0x8219C4F0;
		/* 8219C580h case    1:*/		return 0x8219C584;
	}
	return 0x8219C584;
} // Block from 8219C57Ch-8219C584h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C584);
		  /* 8219C584h */ case    0:  		/* li R3, 0 */
		/* 8219C584h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219C584h case    0:*/		return 0x8219C588;
		  /* 8219C588h */ case    1:  		/* b 8 */
		/* 8219C588h case    1:*/		return 0x8219C590;
		/* 8219C588h case    1:*/		return 0x8219C58C;
	}
	return 0x8219C58C;
} // Block from 8219C584h-8219C58Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C58Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C58C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C58C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C58C);
		  /* 8219C58Ch */ case    0:  		/* li R3, 1 */
		/* 8219C58Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219C58Ch case    0:*/		return 0x8219C590;
	}
	return 0x8219C590;
} // Block from 8219C58Ch-8219C590h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C590);
		  /* 8219C590h */ case    0:  		/* addi R1, R1, 128 */
		/* 8219C590h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8219C590h case    0:*/		return 0x8219C594;
		  /* 8219C594h */ case    1:  		/* b -1094384 */
		/* 8219C594h case    1:*/		return 0x820912A4;
		/* 8219C594h case    1:*/		return 0x8219C598;
	}
	return 0x8219C598;
} // Block from 8219C590h-8219C598h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C598);
		  /* 8219C598h */ case    0:  		/* mfspr R12, LR */
		/* 8219C598h case    0:*/		regs.R12 = regs.LR;
		/* 8219C598h case    0:*/		return 0x8219C59C;
		  /* 8219C59Ch */ case    1:  		/* bl -1094520 */
		/* 8219C59Ch case    1:*/		regs.LR = 0x8219C5A0; return 0x82091224;
		/* 8219C59Ch case    1:*/		return 0x8219C5A0;
		  /* 8219C5A0h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 8219C5A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 8219C5A0h case    2:*/		return 0x8219C5A4;
		  /* 8219C5A4h */ case    3:  		/* lwz R22, <#[R5 + 12]> */
		/* 8219C5A4h case    3:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R5 + 0x0000000C) );
		/* 8219C5A4h case    3:*/		return 0x8219C5A8;
		  /* 8219C5A8h */ case    4:  		/* mr R17, R3 */
		/* 8219C5A8h case    4:*/		regs.R17 = regs.R3;
		/* 8219C5A8h case    4:*/		return 0x8219C5AC;
		  /* 8219C5ACh */ case    5:  		/* lwz R11, <#[R5]> */
		/* 8219C5ACh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8219C5ACh case    5:*/		return 0x8219C5B0;
		  /* 8219C5B0h */ case    6:  		/* mr R25, R4 */
		/* 8219C5B0h case    6:*/		regs.R25 = regs.R4;
		/* 8219C5B0h case    6:*/		return 0x8219C5B4;
		  /* 8219C5B4h */ case    7:  		/* mr R21, R5 */
		/* 8219C5B4h case    7:*/		regs.R21 = regs.R5;
		/* 8219C5B4h case    7:*/		return 0x8219C5B8;
	}
	return 0x8219C5B8;
} // Block from 8219C598h-8219C5B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219C5B8h
// Function '?ComputeVectorizeQueueLevel@Compiler@D3DXShader@@AAAIPAVInstruction@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C5B8);
		  /* 8219C5B8h */ case    0:  		/* rlwinm R24, R11, 0, 27, 31 */
		/* 8219C5B8h case    0:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R24,regs.R11);
		/* 8219C5B8h case    0:*/		return 0x8219C5BC;
		  /* 8219C5BCh */ case    1:  		/* mr R16, R6 */
		/* 8219C5BCh case    1:*/		regs.R16 = regs.R6;
		/* 8219C5BCh case    1:*/		return 0x8219C5C0;
		  /* 8219C5C0h */ case    2:  		/* lwz R11, <#[R22 + 8]> */
		/* 8219C5C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 8219C5C0h case    2:*/		return 0x8219C5C4;
		  /* 8219C5C4h */ case    3:  		/* mr R15, R7 */
		/* 8219C5C4h case    3:*/		regs.R15 = regs.R7;
		/* 8219C5C4h case    3:*/		return 0x8219C5C8;
		  /* 8219C5C8h */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219C5C8h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219C5C8h case    4:*/		return 0x8219C5CC;
		  /* 8219C5CCh */ case    5:  		/* cmplwi CR6, R11, 125 */
		/* 8219C5CCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219C5CCh case    5:*/		return 0x8219C5D0;
		  /* 8219C5D0h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 8219C5D0h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219C5E0;  }
		/* 8219C5D0h case    6:*/		return 0x8219C5D4;
		  /* 8219C5D4h */ case    7:  		/* cmplwi CR6, R11, 124 */
		/* 8219C5D4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219C5D4h case    7:*/		return 0x8219C5D8;
		  /* 8219C5D8h */ case    8:  		/* li R11, 0 */
		/* 8219C5D8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219C5D8h case    8:*/		return 0x8219C5DC;
		  /* 8219C5DCh */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 8219C5DCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219C5E4;  }
		/* 8219C5DCh case    9:*/		return 0x8219C5E0;
	}
	return 0x8219C5E0;
} // Block from 8219C5B8h-8219C5E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219C5E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C5E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C5E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C5E0);
		  /* 8219C5E0h */ case    0:  		/* li R11, 1 */
		/* 8219C5E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219C5E0h case    0:*/		return 0x8219C5E4;
	}
	return 0x8219C5E4;
} // Block from 8219C5E0h-8219C5E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C5E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C5E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C5E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C5E4);
		  /* 8219C5E4h */ case    0:  		/* lwz R27, <#[R25 + 16]> */
		/* 8219C5E4h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R25 + 0x00000010) );
		/* 8219C5E4h case    0:*/		return 0x8219C5E8;
		  /* 8219C5E8h */ case    1:  		/* mr R5, R17 */
		/* 8219C5E8h case    1:*/		regs.R5 = regs.R17;
		/* 8219C5E8h case    1:*/		return 0x8219C5EC;
		  /* 8219C5ECh */ case    2:  		/* mr R4, R22 */
		/* 8219C5ECh case    2:*/		regs.R4 = regs.R22;
		/* 8219C5ECh case    2:*/		return 0x8219C5F0;
		  /* 8219C5F0h */ case    3:  		/* lwz R20, <#[R25 + 12]> */
		/* 8219C5F0h case    3:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R25 + 0x0000000C) );
		/* 8219C5F0h case    3:*/		return 0x8219C5F4;
		  /* 8219C5F4h */ case    4:  		/* mr R3, R27 */
		/* 8219C5F4h case    4:*/		regs.R3 = regs.R27;
		/* 8219C5F4h case    4:*/		return 0x8219C5F8;
		  /* 8219C5F8h */ case    5:  		/* rlwinm R18, R11, 0, 24, 31 */
		/* 8219C5F8h case    5:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R18,regs.R11);
		/* 8219C5F8h case    5:*/		return 0x8219C5FC;
		  /* 8219C5FCh */ case    6:  		/* bl -24940 */
		/* 8219C5FCh case    6:*/		regs.LR = 0x8219C600; return 0x82196490;
		/* 8219C5FCh case    6:*/		return 0x8219C600;
		  /* 8219C600h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219C600h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219C600h case    7:*/		return 0x8219C604;
		  /* 8219C604h */ case    8:  		/* bc 12, CR0_EQ, 796 */
		/* 8219C604h case    8:*/		if ( regs.CR[0].eq ) { return 0x8219C920;  }
		/* 8219C604h case    8:*/		return 0x8219C608;
		  /* 8219C608h */ case    9:  		/* lwz R11, <#[R25]> */
		/* 8219C608h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8219C608h case    9:*/		return 0x8219C60C;
		  /* 8219C60Ch */ case   10:  		/* rlwinm. R23, R24, 0, 27, 28 */
		/* 8219C60Ch case   10:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R23,regs.R24);
		/* 8219C60Ch case   10:*/		return 0x8219C610;
		  /* 8219C610h */ case   11:  		/* rlwinm R10, R11, 0, 27, 31 */
		/* 8219C610h case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R11);
		/* 8219C610h case   11:*/		return 0x8219C614;
		  /* 8219C614h */ case   12:  		/* bc 12, CR0_EQ, 20 */
		/* 8219C614h case   12:*/		if ( regs.CR[0].eq ) { return 0x8219C628;  }
		/* 8219C614h case   12:*/		return 0x8219C618;
		  /* 8219C618h */ case   13:  		/* rlwinm. R11, R10, 0, 27, 28 */
		/* 8219C618h case   13:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R10);
		/* 8219C618h case   13:*/		return 0x8219C61C;
		  /* 8219C61Ch */ case   14:  		/* bc 12, CR0_EQ, 12 */
		/* 8219C61Ch case   14:*/		if ( regs.CR[0].eq ) { return 0x8219C628;  }
		/* 8219C61Ch case   14:*/		return 0x8219C620;
		  /* 8219C620h */ case   15:  		/* li R11, 0 */
		/* 8219C620h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219C620h case   15:*/		return 0x8219C624;
		  /* 8219C624h */ case   16:  		/* b 44 */
		/* 8219C624h case   16:*/		return 0x8219C650;
		/* 8219C624h case   16:*/		return 0x8219C628;
	}
	return 0x8219C628;
} // Block from 8219C5E4h-8219C628h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219C628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C628);
		  /* 8219C628h */ case    0:  		/* rlwinm. R11, R24, 0, 30, 30 */
		/* 8219C628h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R24);
		/* 8219C628h case    0:*/		return 0x8219C62C;
		  /* 8219C62Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8219C62Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219C638;  }
		/* 8219C62Ch case    1:*/		return 0x8219C630;
		  /* 8219C630h */ case    2:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 8219C630h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 8219C630h case    2:*/		return 0x8219C634;
		  /* 8219C634h */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 8219C634h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219C620;  }
		/* 8219C634h case    3:*/		return 0x8219C638;
	}
	return 0x8219C638;
} // Block from 8219C628h-8219C638h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219C638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C638);
		  /* 8219C638h */ case    0:  		/* rlwinm. R11, R24, 0, 29, 29 */
		/* 8219C638h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R24);
		/* 8219C638h case    0:*/		return 0x8219C63C;
		  /* 8219C63Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219C63Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219C64C;  }
		/* 8219C63Ch case    1:*/		return 0x8219C640;
		  /* 8219C640h */ case    2:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 8219C640h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 8219C640h case    2:*/		return 0x8219C644;
		  /* 8219C644h */ case    3:  		/* li R11, 0 */
		/* 8219C644h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219C644h case    3:*/		return 0x8219C648;
		  /* 8219C648h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 8219C648h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219C650;  }
		/* 8219C648h case    4:*/		return 0x8219C64C;
	}
	return 0x8219C64C;
} // Block from 8219C638h-8219C64Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219C64Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C64C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C64C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C64C);
		  /* 8219C64Ch */ case    0:  		/* li R11, 1 */
		/* 8219C64Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219C64Ch case    0:*/		return 0x8219C650;
	}
	return 0x8219C650;
} // Block from 8219C64Ch-8219C650h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C650);
		  /* 8219C650h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219C650h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219C650h case    0:*/		return 0x8219C654;
		  /* 8219C654h */ case    1:  		/* bc 12, CR0_EQ, 716 */
		/* 8219C654h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219C920;  }
		/* 8219C654h case    1:*/		return 0x8219C658;
		  /* 8219C658h */ case    2:  		/* rlwinm. R9, R24, 0, 29, 29 */
		/* 8219C658h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R24);
		/* 8219C658h case    2:*/		return 0x8219C65C;
		  /* 8219C65Ch */ case    3:  		/* mr R11, R24 */
		/* 8219C65Ch case    3:*/		regs.R11 = regs.R24;
		/* 8219C65Ch case    3:*/		return 0x8219C660;
		  /* 8219C660h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 8219C660h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219C670;  }
		/* 8219C660h case    4:*/		return 0x8219C664;
		  /* 8219C664h */ case    5:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 8219C664h case    5:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 8219C664h case    5:*/		return 0x8219C668;
		  /* 8219C668h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 8219C668h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219C670;  }
		/* 8219C668h case    6:*/		return 0x8219C66C;
		  /* 8219C66Ch */ case    7:  		/* addi R11, R24, -4 */
		/* 8219C66Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0xFFFFFFFC);
		/* 8219C66Ch case    7:*/		return 0x8219C670;
	}
	return 0x8219C670;
} // Block from 8219C650h-8219C670h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219C670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C670);
		  /* 8219C670h */ case    0:  		/* and R9, R11, R10 */
		/* 8219C670h case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 8219C670h case    0:*/		return 0x8219C674;
		  /* 8219C674h */ case    1:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 8219C674h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 8219C674h case    1:*/		return 0x8219C678;
		  /* 8219C678h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8219C678h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219C684;  }
		/* 8219C678h case    2:*/		return 0x8219C67C;
		  /* 8219C67Ch */ case    3:  		/* addi R11, R11, -4 */
		/* 8219C67Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8219C67Ch case    3:*/		return 0x8219C680;
		  /* 8219C680h */ case    4:  		/* addi R10, R10, -4 */
		/* 8219C680h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 8219C680h case    4:*/		return 0x8219C684;
	}
	return 0x8219C684;
} // Block from 8219C670h-8219C684h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219C684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C684);
		  /* 8219C684h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 8219C684h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8219C684h case    0:*/		return 0x8219C688;
	}
	return 0x8219C688;
} // Block from 8219C684h-8219C688h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C688h
// Function '?IsVectorizeable@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C688);
		  /* 8219C688h */ case    0:  		/* bc 12, CR0_EQ, 16 */
		/* 8219C688h case    0:*/		if ( regs.CR[0].eq ) { return 0x8219C698;  }
		/* 8219C688h case    0:*/		return 0x8219C68C;
		  /* 8219C68Ch */ case    1:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 8219C68Ch case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 8219C68Ch case    1:*/		return 0x8219C690;
		  /* 8219C690h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 8219C690h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219C698;  }
		/* 8219C690h case    2:*/		return 0x8219C694;
		  /* 8219C694h */ case    3:  		/* addi R10, R10, -2 */
		/* 8219C694h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 8219C694h case    3:*/		return 0x8219C698;
	}
	return 0x8219C698;
} // Block from 8219C688h-8219C698h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219C698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C698);
		  /* 8219C698h */ case    0:  		/* or R26, R11, R10 */
		/* 8219C698h case    0:*/		cpu::op::or<0>(regs,&regs.R26,regs.R11,regs.R10);
		/* 8219C698h case    0:*/		return 0x8219C69C;
		  /* 8219C69Ch */ case    1:  		/* mr R3, R27 */
		/* 8219C69Ch case    1:*/		regs.R3 = regs.R27;
		/* 8219C69Ch case    1:*/		return 0x8219C6A0;
		  /* 8219C6A0h */ case    2:  		/* mr R4, R26 */
		/* 8219C6A0h case    2:*/		regs.R4 = regs.R26;
		/* 8219C6A0h case    2:*/		return 0x8219C6A4;
		  /* 8219C6A4h */ case    3:  		/* bl -25620 */
		/* 8219C6A4h case    3:*/		regs.LR = 0x8219C6A8; return 0x82196290;
		/* 8219C6A4h case    3:*/		return 0x8219C6A8;
		  /* 8219C6A8h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219C6A8h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219C6A8h case    4:*/		return 0x8219C6AC;
		  /* 8219C6ACh */ case    5:  		/* bc 12, CR0_EQ, 628 */
		/* 8219C6ACh case    5:*/		if ( regs.CR[0].eq ) { return 0x8219C920;  }
		/* 8219C6ACh case    5:*/		return 0x8219C6B0;
		  /* 8219C6B0h */ case    6:  		/* lwz R11, <#[R27 + 8]> */
		/* 8219C6B0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219C6B0h case    6:*/		return 0x8219C6B4;
		  /* 8219C6B4h */ case    7:  		/* li R19, 0 */
		/* 8219C6B4h case    7:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8219C6B4h case    7:*/		return 0x8219C6B8;
		  /* 8219C6B8h */ case    8:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 8219C6B8h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 8219C6B8h case    8:*/		return 0x8219C6BC;
		  /* 8219C6BCh */ case    9:  		/* cmplwi CR6, R10, 1 */
		/* 8219C6BCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8219C6BCh case    9:*/		return 0x8219C6C0;
		  /* 8219C6C0h */ case   10:  		/* bc 12, CR6_LT, 16 */
		/* 8219C6C0h case   10:*/		if ( regs.CR[6].lt ) { return 0x8219C6D0;  }
		/* 8219C6C0h case   10:*/		return 0x8219C6C4;
		  /* 8219C6C4h */ case   11:  		/* cmplwi CR6, R10, 102 */
		/* 8219C6C4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000066);
		/* 8219C6C4h case   11:*/		return 0x8219C6C8;
		  /* 8219C6C8h */ case   12:  		/* li R10, 1 */
		/* 8219C6C8h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219C6C8h case   12:*/		return 0x8219C6CC;
		  /* 8219C6CCh */ case   13:  		/* bc 4, CR6_GT, 8 */
		/* 8219C6CCh case   13:*/		if ( !regs.CR[6].gt ) { return 0x8219C6D4;  }
		/* 8219C6CCh case   13:*/		return 0x8219C6D0;
	}
	return 0x8219C6D0;
} // Block from 8219C698h-8219C6D0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219C6D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C6D0);
		  /* 8219C6D0h */ case    0:  		/* li R10, 0 */
		/* 8219C6D0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219C6D0h case    0:*/		return 0x8219C6D4;
	}
	return 0x8219C6D4;
} // Block from 8219C6D0h-8219C6D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C6D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C6D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C6D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C6D4);
		  /* 8219C6D4h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 8219C6D4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 8219C6D4h case    0:*/		return 0x8219C6D8;
	}
	return 0x8219C6D8;
} // Block from 8219C6D4h-8219C6D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C6D8h
// Function '?GetLoopEndInfo@Instruction@D3DXShader@@QAAPAUInstruction_LoopEnd@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C6D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C6D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C6D8);
		  /* 8219C6D8h */ case    0:  		/* bc 12, CR0_EQ, 592 */
		/* 8219C6D8h case    0:*/		if ( regs.CR[0].eq ) { return 0x8219C928;  }
		/* 8219C6D8h case    0:*/		return 0x8219C6DC;
		  /* 8219C6DCh */ case    1:  		/* li R30, 0 */
		/* 8219C6DCh case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8219C6DCh case    1:*/		return 0x8219C6E0;
		  /* 8219C6E0h */ case    2:  		/* li R31, 0 */
		/* 8219C6E0h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8219C6E0h case    2:*/		return 0x8219C6E4;
		  /* 8219C6E4h */ case    3:  		/* li R28, 0 */
		/* 8219C6E4h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8219C6E4h case    3:*/		return 0x8219C6E8;
		  /* 8219C6E8h */ case    4:  		/* li R29, -1 */
		/* 8219C6E8h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0xFFFFFFFF);
		/* 8219C6E8h case    4:*/		return 0x8219C6EC;
		  /* 8219C6ECh */ case    5:  		/* li R10, 0 */
		/* 8219C6ECh case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219C6ECh case    5:*/		return 0x8219C6F0;
		  /* 8219C6F0h */ case    6:  		/* rlwinm R7, R11, 13, 29, 31 */
		/* 8219C6F0h case    6:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R7,regs.R11);
		/* 8219C6F0h case    6:*/		return 0x8219C6F4;
		  /* 8219C6F4h */ case    7:  		/* addi R8, R27, 44 */
		/* 8219C6F4h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R27,0x2C);
		/* 8219C6F4h case    7:*/		return 0x8219C6F8;
		  /* 8219C6F8h */ case    8:  		/* cmplw CR6, R10, R7 */
		/* 8219C6F8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8219C6F8h case    8:*/		return 0x8219C6FC;
		  /* 8219C6FCh */ case    9:  		/* bc 4, CR6_LT, 116 */
		/* 8219C6FCh case    9:*/		if ( !regs.CR[6].lt ) { return 0x8219C770;  }
		/* 8219C6FCh case    9:*/		return 0x8219C700;
		  /* 8219C700h */ case   10:  		/* lwz R11, <#[R8]> */
		/* 8219C700h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8219C700h case   10:*/		return 0x8219C704;
		  /* 8219C704h */ case   11:  		/* cmplw CR6, R11, R25 */
		/* 8219C704h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 8219C704h case   11:*/		return 0x8219C708;
		  /* 8219C708h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 8219C708h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8219C714;  }
		/* 8219C708h case   12:*/		return 0x8219C70C;
		  /* 8219C70Ch */ case   13:  		/* mr R29, R10 */
		/* 8219C70Ch case   13:*/		regs.R29 = regs.R10;
		/* 8219C70Ch case   13:*/		return 0x8219C710;
		  /* 8219C710h */ case   14:  		/* b 84 */
		/* 8219C710h case   14:*/		return 0x8219C764;
		/* 8219C710h case   14:*/		return 0x8219C714;
	}
	return 0x8219C714;
} // Block from 8219C6D8h-8219C714h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219C714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C714);
		  /* 8219C714h */ case    0:  		/* lwz R9, <#[R11 + 12]> */
		/* 8219C714h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219C714h case    0:*/		return 0x8219C718;
		  /* 8219C718h */ case    1:  		/* lwz R9, <#[R9 + 8]> */
		/* 8219C718h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 8219C718h case    1:*/		return 0x8219C71C;
		  /* 8219C71Ch */ case    2:  		/* rlwinm R9, R9, 25, 25, 31 */
		/* 8219C71Ch case    2:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R9);
		/* 8219C71Ch case    2:*/		return 0x8219C720;
	}
	return 0x8219C720;
} // Block from 8219C714h-8219C720h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219C720h
// Function '?AddMergeDefinition@Compiler@D3DXShader@@AAA_NPAUMergeGroupInfo@2@PAVInstruction@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C720);
		  /* 8219C720h */ case    0:  		/* cmplwi CR6, R9, 125 */
		/* 8219C720h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000007D);
		/* 8219C720h case    0:*/		return 0x8219C724;
		  /* 8219C724h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8219C724h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219C734;  }
		/* 8219C724h case    1:*/		return 0x8219C728;
		  /* 8219C728h */ case    2:  		/* cmplwi CR6, R9, 124 */
		/* 8219C728h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000007C);
		/* 8219C728h case    2:*/		return 0x8219C72C;
		  /* 8219C72Ch */ case    3:  		/* li R9, 0 */
		/* 8219C72Ch case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219C72Ch case    3:*/		return 0x8219C730;
		  /* 8219C730h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 8219C730h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8219C738;  }
		/* 8219C730h case    4:*/		return 0x8219C734;
	}
	return 0x8219C734;
} // Block from 8219C720h-8219C734h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219C734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C734);
		  /* 8219C734h */ case    0:  		/* li R9, 1 */
		/* 8219C734h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8219C734h case    0:*/		return 0x8219C738;
	}
	return 0x8219C738;
} // Block from 8219C734h-8219C738h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C738);
		  /* 8219C738h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 8219C738h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 8219C738h case    0:*/		return 0x8219C73C;
		  /* 8219C73Ch */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 8219C73Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219C758;  }
		/* 8219C73Ch case    1:*/		return 0x8219C740;
		  /* 8219C740h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 8219C740h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219C740h case    2:*/		return 0x8219C744;
		  /* 8219C744h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8219C744h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219C750;  }
		/* 8219C744h case    3:*/		return 0x8219C748;
		  /* 8219C748h */ case    4:  		/* mr R28, R11 */
		/* 8219C748h case    4:*/		regs.R28 = regs.R11;
		/* 8219C748h case    4:*/		return 0x8219C74C;
		  /* 8219C74Ch */ case    5:  		/* b 12 */
		/* 8219C74Ch case    5:*/		return 0x8219C758;
		/* 8219C74Ch case    5:*/		return 0x8219C750;
	}
	return 0x8219C750;
} // Block from 8219C738h-8219C750h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219C750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C750);
		  /* 8219C750h */ case    0:  		/* mr R31, R11 */
		/* 8219C750h case    0:*/		regs.R31 = regs.R11;
		/* 8219C750h case    0:*/		return 0x8219C754;
		  /* 8219C754h */ case    1:  		/* mr R30, R10 */
		/* 8219C754h case    1:*/		regs.R30 = regs.R10;
		/* 8219C754h case    1:*/		return 0x8219C758;
	}
	return 0x8219C758;
} // Block from 8219C750h-8219C758h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C758);
		  /* 8219C758h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8219C758h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219C758h case    0:*/		return 0x8219C75C;
		  /* 8219C75Ch */ case    1:  		/* rlwinm R11, R11, 0, 27, 28 */
		/* 8219C75Ch case    1:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R11,regs.R11);
		/* 8219C75Ch case    1:*/		return 0x8219C760;
		  /* 8219C760h */ case    2:  		/* or R19, R11, R19 */
		/* 8219C760h case    2:*/		cpu::op::or<0>(regs,&regs.R19,regs.R11,regs.R19);
		/* 8219C760h case    2:*/		return 0x8219C764;
	}
	return 0x8219C764;
} // Block from 8219C758h-8219C764h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219C764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C764);
		  /* 8219C764h */ case    0:  		/* addi R10, R10, 1 */
		/* 8219C764h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8219C764h case    0:*/		return 0x8219C768;
		  /* 8219C768h */ case    1:  		/* addi R8, R8, 4 */
		/* 8219C768h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 8219C768h case    1:*/		return 0x8219C76C;
		  /* 8219C76Ch */ case    2:  		/* b -116 */
		/* 8219C76Ch case    2:*/		return 0x8219C6F8;
		/* 8219C76Ch case    2:*/		return 0x8219C770;
	}
	return 0x8219C770;
} // Block from 8219C764h-8219C770h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219C770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C770);
		  /* 8219C770h */ case    0:  		/* cmpwi CR6, R29, -1 */
		/* 8219C770h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0xFFFFFFFF);
		/* 8219C770h case    0:*/		return 0x8219C774;
		  /* 8219C774h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8219C774h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219C784;  }
		/* 8219C774h case    1:*/		return 0x8219C778;
		  /* 8219C778h */ case    2:  		/* li R4, 4800 */
		/* 8219C778h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8219C778h case    2:*/		return 0x8219C77C;
		  /* 8219C77Ch */ case    3:  		/* mr R3, R17 */
		/* 8219C77Ch case    3:*/		regs.R3 = regs.R17;
		/* 8219C77Ch case    3:*/		return 0x8219C780;
		  /* 8219C780h */ case    4:  		/* bl -305432 */
		/* 8219C780h case    4:*/		regs.LR = 0x8219C784; return 0x82151E68;
		/* 8219C780h case    4:*/		return 0x8219C784;
	}
	return 0x8219C784;
} // Block from 8219C770h-8219C784h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219C784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C784);
		  /* 8219C784h */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 8219C784h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 8219C784h case    0:*/		return 0x8219C788;
		  /* 8219C788h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 8219C788h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219C7C0;  }
		/* 8219C788h case    1:*/		return 0x8219C78C;
		  /* 8219C78Ch */ case    2:  		/* cmplwi CR6, R19, 0 */
		/* 8219C78Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 8219C78Ch case    2:*/		return 0x8219C790;
		  /* 8219C790h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 8219C790h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219C7C0;  }
		/* 8219C790h case    3:*/		return 0x8219C794;
		  /* 8219C794h */ case    4:  		/* cmplw CR6, R23, R19 */
		/* 8219C794h case    4:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R19);
		/* 8219C794h case    4:*/		return 0x8219C798;
		  /* 8219C798h */ case    5:  		/* bc 4, CR6_EQ, 392 */
		/* 8219C798h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219C920;  }
		/* 8219C798h case    5:*/		return 0x8219C79C;
		  /* 8219C79Ch */ case    6:  		/* rlwinm. R11, R24, 0, 28, 28 */
		/* 8219C79Ch case    6:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R24);
		/* 8219C79Ch case    6:*/		return 0x8219C7A0;
		  /* 8219C7A0h */ case    7:  		/* bc 12, CR0_EQ, 32 */
		/* 8219C7A0h case    7:*/		if ( regs.CR[0].eq ) { return 0x8219C7C0;  }
		/* 8219C7A0h case    7:*/		return 0x8219C7A4;
		  /* 8219C7A4h */ case    8:  		/* mr R3, R20 */
		/* 8219C7A4h case    8:*/		regs.R3 = regs.R20;
		/* 8219C7A4h case    8:*/		return 0x8219C7A8;
		  /* 8219C7A8h */ case    9:  		/* bl -150672 */
		/* 8219C7A8h case    9:*/		regs.LR = 0x8219C7AC; return 0x82177B18;
		/* 8219C7A8h case    9:*/		return 0x8219C7AC;
		  /* 8219C7ACh */ case   10:  		/* mr R25, R3 */
		/* 8219C7ACh case   10:*/		regs.R25 = regs.R3;
		/* 8219C7ACh case   10:*/		return 0x8219C7B0;
		  /* 8219C7B0h */ case   11:  		/* mr R3, R27 */
		/* 8219C7B0h case   11:*/		regs.R3 = regs.R27;
		/* 8219C7B0h case   11:*/		return 0x8219C7B4;
		  /* 8219C7B4h */ case   12:  		/* bl -150684 */
		/* 8219C7B4h case   12:*/		regs.LR = 0x8219C7B8; return 0x82177B18;
		/* 8219C7B4h case   12:*/		return 0x8219C7B8;
		  /* 8219C7B8h */ case   13:  		/* cmplw CR6, R25, R3 */
		/* 8219C7B8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R3);
		/* 8219C7B8h case   13:*/		return 0x8219C7BC;
		  /* 8219C7BCh */ case   14:  		/* bc 4, CR6_EQ, 356 */
		/* 8219C7BCh case   14:*/		if ( !regs.CR[6].eq ) { return 0x8219C920;  }
		/* 8219C7BCh case   14:*/		return 0x8219C7C0;
	}
	return 0x8219C7C0;
} // Block from 8219C784h-8219C7C0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219C7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C7C0);
		  /* 8219C7C0h */ case    0:  		/* rlwinm. R10, R18, 0, 24, 31 */
		/* 8219C7C0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R18);
		/* 8219C7C0h case    0:*/		return 0x8219C7C4;
		  /* 8219C7C4h */ case    1:  		/* bc 12, CR0_EQ, 64 */
		/* 8219C7C4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219C804;  }
		/* 8219C7C4h case    1:*/		return 0x8219C7C8;
		  /* 8219C7C8h */ case    2:  		/* cmplwi CR6, R28, 0 */
		/* 8219C7C8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8219C7C8h case    2:*/		return 0x8219C7CC;
		  /* 8219C7CCh */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 8219C7CCh case    3:*/		if ( regs.CR[6].eq ) { return 0x8219C804;  }
		/* 8219C7CCh case    3:*/		return 0x8219C7D0;
		  /* 8219C7D0h */ case    4:  		/* cmplwi CR6, R29, 0 */
		/* 8219C7D0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8219C7D0h case    4:*/		return 0x8219C7D4;
		  /* 8219C7D4h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8219C7D4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219C7E0;  }
		/* 8219C7D4h case    5:*/		return 0x8219C7D8;
		  /* 8219C7D8h */ case    6:  		/* mr R11, R24 */
		/* 8219C7D8h case    6:*/		regs.R11 = regs.R24;
		/* 8219C7D8h case    6:*/		return 0x8219C7DC;
		  /* 8219C7DCh */ case    7:  		/* b 24 */
		/* 8219C7DCh case    7:*/		return 0x8219C7F4;
		/* 8219C7DCh case    7:*/		return 0x8219C7E0;
	}
	return 0x8219C7E0;
} // Block from 8219C7C0h-8219C7E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219C7E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C7E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C7E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C7E0);
		  /* 8219C7E0h */ case    0:  		/* addi R11, R30, 11 */
		/* 8219C7E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xB);
		/* 8219C7E0h case    0:*/		return 0x8219C7E4;
		  /* 8219C7E4h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8219C7E4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8219C7E4h case    1:*/		return 0x8219C7E8;
		  /* 8219C7E8h */ case    2:  		/* lwzx R11, <#[R11 + R27]> */
		/* 8219C7E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8219C7E8h case    2:*/		return 0x8219C7EC;
		  /* 8219C7ECh */ case    3:  		/* lwz R11, <#[R11]> */
		/* 8219C7ECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219C7ECh case    3:*/		return 0x8219C7F0;
		  /* 8219C7F0h */ case    4:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8219C7F0h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219C7F0h case    4:*/		return 0x8219C7F4;
	}
	return 0x8219C7F4;
} // Block from 8219C7E0h-8219C7F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219C7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C7F4);
		  /* 8219C7F4h */ case    0:  		/* lwz R9, <#[R28]> */
		/* 8219C7F4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000000) );
		/* 8219C7F4h case    0:*/		return 0x8219C7F8;
		  /* 8219C7F8h */ case    1:  		/* xor R11, R9, R11 */
		/* 8219C7F8h case    1:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8219C7F8h case    1:*/		return 0x8219C7FC;
		  /* 8219C7FCh */ case    2:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 8219C7FCh case    2:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 8219C7FCh case    2:*/		return 0x8219C800;
		  /* 8219C800h */ case    3:  		/* bc 4, CR0_EQ, 288 */
		/* 8219C800h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219C920;  }
		/* 8219C800h case    3:*/		return 0x8219C804;
	}
	return 0x8219C804;
} // Block from 8219C7F4h-8219C804h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219C804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C804);
		  /* 8219C804h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8219C804h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219C804h case    0:*/		return 0x8219C808;
		  /* 8219C808h */ case    1:  		/* bc 12, CR6_EQ, 288 */
		/* 8219C808h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219C928;  }
		/* 8219C808h case    1:*/		return 0x8219C80C;
		  /* 8219C80Ch */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 8219C80Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219C80Ch case    2:*/		return 0x8219C810;
		  /* 8219C810h */ case    3:  		/* bc 12, CR6_EQ, 280 */
		/* 8219C810h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219C928;  }
		/* 8219C810h case    3:*/		return 0x8219C814;
		  /* 8219C814h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 8219C814h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219C814h case    4:*/		return 0x8219C818;
		  /* 8219C818h */ case    5:  		/* xor R11, R11, R26 */
		/* 8219C818h case    5:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R26);
		/* 8219C818h case    5:*/		return 0x8219C81C;
		  /* 8219C81Ch */ case    6:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8219C81Ch case    6:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8219C81Ch case    6:*/		return 0x8219C820;
		  /* 8219C820h */ case    7:  		/* bc 12, CR0_EQ, 264 */
		/* 8219C820h case    7:*/		if ( regs.CR[0].eq ) { return 0x8219C928;  }
		/* 8219C820h case    7:*/		return 0x8219C824;
		  /* 8219C824h */ case    8:  		/* lwz R11, <#[R21]> */
		/* 8219C824h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 8219C824h case    8:*/		return 0x8219C828;
		  /* 8219C828h */ case    9:  		/* addi R8, R1, 96 */
		/* 8219C828h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 8219C828h case    9:*/		return 0x8219C82C;
		  /* 8219C82Ch */ case   10:  		/* mr R7, R26 */
		/* 8219C82Ch case   10:*/		regs.R7 = regs.R26;
		/* 8219C82Ch case   10:*/		return 0x8219C830;
		  /* 8219C830h */ case   11:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 8219C830h case   11:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 8219C830h case   11:*/		return 0x8219C834;
		  /* 8219C834h */ case   12:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 8219C834h case   12:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 8219C834h case   12:*/		return 0x8219C838;
	}
	return 0x8219C838;
} // Block from 8219C804h-8219C838h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219C838h
// Function '?CanMergeOperands@Compiler@D3DXShader@@AAA_NPAVInstruction@2@000PAUCombineDependenciesState@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C838);
		  /* 8219C838h */ case    0:  		/* mr R4, R22 */
		/* 8219C838h case    0:*/		regs.R4 = regs.R22;
		/* 8219C838h case    0:*/		return 0x8219C83C;
		  /* 8219C83Ch */ case    1:  		/* mr R3, R17 */
		/* 8219C83Ch case    1:*/		regs.R3 = regs.R17;
		/* 8219C83Ch case    1:*/		return 0x8219C840;
		  /* 8219C840h */ case    2:  		/* bl -5568 */
		/* 8219C840h case    2:*/		regs.LR = 0x8219C844; return 0x8219B280;
		/* 8219C840h case    2:*/		return 0x8219C844;
		  /* 8219C844h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 8219C844h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219C844h case    3:*/		return 0x8219C848;
		  /* 8219C848h */ case    4:  		/* mr R30, R3 */
		/* 8219C848h case    4:*/		regs.R30 = regs.R3;
		/* 8219C848h case    4:*/		return 0x8219C84C;
		  /* 8219C84Ch */ case    5:  		/* lwz R4, <#[R31 + 12]> */
		/* 8219C84Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219C84Ch case    5:*/		return 0x8219C850;
		  /* 8219C850h */ case    6:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 8219C850h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 8219C850h case    6:*/		return 0x8219C854;
		  /* 8219C854h */ case    7:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 8219C854h case    7:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 8219C854h case    7:*/		return 0x8219C858;
		  /* 8219C858h */ case    8:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 8219C858h case    8:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 8219C858h case    8:*/		return 0x8219C85C;
		  /* 8219C85Ch */ case    9:  		/* addi R8, R1, 80 */
		/* 8219C85Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 8219C85Ch case    9:*/		return 0x8219C860;
		  /* 8219C860h */ case   10:  		/* mr R3, R17 */
		/* 8219C860h case   10:*/		regs.R3 = regs.R17;
		/* 8219C860h case   10:*/		return 0x8219C864;
		  /* 8219C864h */ case   11:  		/* bl -5604 */
		/* 8219C864h case   11:*/		regs.LR = 0x8219C868; return 0x8219B280;
		/* 8219C864h case   11:*/		return 0x8219C868;
		  /* 8219C868h */ case   12:  		/* or R11, R3, R30 */
		/* 8219C868h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R3,regs.R30);
		/* 8219C868h case   12:*/		return 0x8219C86C;
		  /* 8219C86Ch */ case   13:  		/* andi. R11, R11, 5 */
		/* 8219C86Ch case   13:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x5);
		/* 8219C86Ch case   13:*/		return 0x8219C870;
		  /* 8219C870h */ case   14:  		/* cmplwi CR6, R11, 5 */
		/* 8219C870h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 8219C870h case   14:*/		return 0x8219C874;
		  /* 8219C874h */ case   15:  		/* bc 12, CR6_EQ, 172 */
		/* 8219C874h case   15:*/		if ( regs.CR[6].eq ) { return 0x8219C920;  }
		/* 8219C874h case   15:*/		return 0x8219C878;
		  /* 8219C878h */ case   16:  		/* cmplwi CR6, R3, 4 */
		/* 8219C878h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000004);
		/* 8219C878h case   16:*/		return 0x8219C87C;
		  /* 8219C87Ch */ case   17:  		/* bc 4, CR6_EQ, 164 */
		/* 8219C87Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x8219C920;  }
		/* 8219C87Ch case   17:*/		return 0x8219C880;
		  /* 8219C880h */ case   18:  		/* rlwinm. R9, R26, 0, 29, 29 */
		/* 8219C880h case   18:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R26);
		/* 8219C880h case   18:*/		return 0x8219C884;
		  /* 8219C884h */ case   19:  		/* li R10, 2 */
		/* 8219C884h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 8219C884h case   19:*/		return 0x8219C888;
		  /* 8219C888h */ case   20:  		/* mr R11, R26 */
		/* 8219C888h case   20:*/		regs.R11 = regs.R26;
		/* 8219C888h case   20:*/		return 0x8219C88C;
		  /* 8219C88Ch */ case   21:  		/* bc 12, CR0_EQ, 8 */
		/* 8219C88Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x8219C894;  }
		/* 8219C88Ch case   21:*/		return 0x8219C890;
		  /* 8219C890h */ case   22:  		/* addi R11, R26, -4 */
		/* 8219C890h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFFFC);
		/* 8219C890h case   22:*/		return 0x8219C894;
	}
	return 0x8219C894;
} // Block from 8219C838h-8219C894h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219C894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C894);
		  /* 8219C894h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 8219C894h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8219C894h case    0:*/		return 0x8219C898;
		  /* 8219C898h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219C898h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219C8A8;  }
		/* 8219C898h case    1:*/		return 0x8219C89C;
		  /* 8219C89Ch */ case    2:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 8219C89Ch case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 8219C89Ch case    2:*/		return 0x8219C8A0;
		  /* 8219C8A0h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 8219C8A0h case    3:*/		if ( regs.CR[0].eq ) { return 0x8219C8A8;  }
		/* 8219C8A0h case    3:*/		return 0x8219C8A4;
		  /* 8219C8A4h */ case    4:  		/* addi R10, R10, -2 */
		/* 8219C8A4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 8219C8A4h case    4:*/		return 0x8219C8A8;
	}
	return 0x8219C8A8;
} // Block from 8219C894h-8219C8A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219C8A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C8A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C8A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C8A8);
		  /* 8219C8A8h */ case    0:  		/* lwz R9, <#[R22 + 8]> */
		/* 8219C8A8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000008) );
		/* 8219C8A8h case    0:*/		return 0x8219C8AC;
		  /* 8219C8ACh */ case    1:  		/* or R26, R11, R10 */
		/* 8219C8ACh case    1:*/		cpu::op::or<0>(regs,&regs.R26,regs.R11,regs.R10);
		/* 8219C8ACh case    1:*/		return 0x8219C8B0;
		  /* 8219C8B0h */ case    2:  		/* rlwinm R11, R9, 0, 18, 24 */
		/* 8219C8B0h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R9);
		/* 8219C8B0h case    2:*/		return 0x8219C8B4;
		  /* 8219C8B4h */ case    3:  		/* cmplwi CR6, R11, 16000 */
		/* 8219C8B4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8219C8B4h case    3:*/		return 0x8219C8B8;
		  /* 8219C8B8h */ case    4:  		/* bc 4, CR6_EQ, 112 */
		/* 8219C8B8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8219C928;  }
		/* 8219C8B8h case    4:*/		return 0x8219C8BC;
		  /* 8219C8BCh */ case    5:  		/* lwz R11, <#[R21]> */
		/* 8219C8BCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 8219C8BCh case    5:*/		return 0x8219C8C0;
		  /* 8219C8C0h */ case    6:  		/* addi R8, R1, 80 */
		/* 8219C8C0h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 8219C8C0h case    6:*/		return 0x8219C8C4;
		  /* 8219C8C4h */ case    7:  		/* mr R7, R26 */
		/* 8219C8C4h case    7:*/		regs.R7 = regs.R26;
		/* 8219C8C4h case    7:*/		return 0x8219C8C8;
		  /* 8219C8C8h */ case    8:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 8219C8C8h case    8:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 8219C8C8h case    8:*/		return 0x8219C8CC;
		  /* 8219C8CCh */ case    9:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 8219C8CCh case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 8219C8CCh case    9:*/		return 0x8219C8D0;
		  /* 8219C8D0h */ case   10:  		/* mr R4, R22 */
		/* 8219C8D0h case   10:*/		regs.R4 = regs.R22;
		/* 8219C8D0h case   10:*/		return 0x8219C8D4;
		  /* 8219C8D4h */ case   11:  		/* mr R3, R17 */
		/* 8219C8D4h case   11:*/		regs.R3 = regs.R17;
		/* 8219C8D4h case   11:*/		return 0x8219C8D8;
		  /* 8219C8D8h */ case   12:  		/* bl -5720 */
		/* 8219C8D8h case   12:*/		regs.LR = 0x8219C8DC; return 0x8219B280;
		/* 8219C8D8h case   12:*/		return 0x8219C8DC;
		  /* 8219C8DCh */ case   13:  		/* lwz R10, <#[R21]> */
		/* 8219C8DCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000000) );
		/* 8219C8DCh case   13:*/		return 0x8219C8E0;
		  /* 8219C8E0h */ case   14:  		/* addi R9, R1, 80 */
		/* 8219C8E0h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 8219C8E0h case   14:*/		return 0x8219C8E4;
		  /* 8219C8E4h */ case   15:  		/* addi R11, R1, 96 */
		/* 8219C8E4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8219C8E4h case   15:*/		return 0x8219C8E8;
		  /* 8219C8E8h */ case   16:  		/* li R8, 0 */
		/* 8219C8E8h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8219C8E8h case   16:*/		return 0x8219C8EC;
		  /* 8219C8ECh */ case   17:  		/* rlwinm. R10, R10, 9, 27, 29 */
		/* 8219C8ECh case   17:*/		cpu::op::rlwinm<1,9,27,29>(regs,&regs.R10,regs.R10);
		/* 8219C8ECh case   17:*/		return 0x8219C8F0;
		  /* 8219C8F0h */ case   18:  		/* bc 12, CR0_EQ, 40 */
		/* 8219C8F0h case   18:*/		if ( regs.CR[0].eq ) { return 0x8219C918;  }
		/* 8219C8F0h case   18:*/		return 0x8219C8F4;
		  /* 8219C8F4h */ case   19:  		/* add R10, R11, R10 */
		/* 8219C8F4h case   19:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8219C8F4h case   19:*/		return 0x8219C8F8;
		  /* 8219C8F8h */ case   20:  		/* lbz R8, <#[R11]> */
		/* 8219C8F8h case   20:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8219C8F8h case   20:*/		return 0x8219C8FC;
		  /* 8219C8FCh */ case   21:  		/* lbz R7, <#[R9]> */
		/* 8219C8FCh case   21:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8219C8FCh case   21:*/		return 0x8219C900;
		  /* 8219C900h */ case   22:  		/* subf. R8, R7, R8 */
		/* 8219C900h case   22:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R7,regs.R8);
		/* 8219C900h case   22:*/		return 0x8219C904;
		  /* 8219C904h */ case   23:  		/* bc 4, CR0_EQ, 20 */
		/* 8219C904h case   23:*/		if ( !regs.CR[0].eq ) { return 0x8219C918;  }
		/* 8219C904h case   23:*/		return 0x8219C908;
		  /* 8219C908h */ case   24:  		/* addi R11, R11, 1 */
		/* 8219C908h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219C908h case   24:*/		return 0x8219C90C;
		  /* 8219C90Ch */ case   25:  		/* addi R9, R9, 1 */
		/* 8219C90Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8219C90Ch case   25:*/		return 0x8219C910;
		  /* 8219C910h */ case   26:  		/* cmpw CR6, R11, R10 */
		/* 8219C910h case   26:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8219C910h case   26:*/		return 0x8219C914;
		  /* 8219C914h */ case   27:  		/* bc 4, CR6_EQ, -28 */
		/* 8219C914h case   27:*/		if ( !regs.CR[6].eq ) { return 0x8219C8F8;  }
		/* 8219C914h case   27:*/		return 0x8219C918;
	}
	return 0x8219C918;
} // Block from 8219C8A8h-8219C918h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8219C918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C918);
		  /* 8219C918h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 8219C918h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 8219C918h case    0:*/		return 0x8219C91C;
		  /* 8219C91Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8219C91Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219C928;  }
		/* 8219C91Ch case    1:*/		return 0x8219C920;
	}
	return 0x8219C920;
} // Block from 8219C918h-8219C920h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C920);
		  /* 8219C920h */ case    0:  		/* li R3, 0 */
		/* 8219C920h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219C920h case    0:*/		return 0x8219C924;
		  /* 8219C924h */ case    1:  		/* b 16 */
		/* 8219C924h case    1:*/		return 0x8219C934;
		/* 8219C924h case    1:*/		return 0x8219C928;
	}
	return 0x8219C928;
} // Block from 8219C920h-8219C928h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C928);
		  /* 8219C928h */ case    0:  		/* stw R19, <#[R15]> */
		/* 8219C928h case    0:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R15 + 0x00000000) );
		/* 8219C928h case    0:*/		return 0x8219C92C;
		  /* 8219C92Ch */ case    1:  		/* li R3, 1 */
		/* 8219C92Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219C92Ch case    1:*/		return 0x8219C930;
	}
	return 0x8219C930;
} // Block from 8219C928h-8219C930h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C930h
// Function '?ExcludeFromVectorizeIdenticalDependents@Compiler@D3DXShader@@AAA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C930);
		  /* 8219C930h */ case    0:  		/* stw R26, <#[R16]> */
		/* 8219C930h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R16 + 0x00000000) );
		/* 8219C930h case    0:*/		return 0x8219C934;
	}
	return 0x8219C934;
} // Block from 8219C930h-8219C934h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C934);
		  /* 8219C934h */ case    0:  		/* addi R1, R1, 256 */
		/* 8219C934h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 8219C934h case    0:*/		return 0x8219C938;
		  /* 8219C938h */ case    1:  		/* b -1095364 */
		/* 8219C938h case    1:*/		return 0x82091274;
		/* 8219C938h case    1:*/		return 0x8219C93C;
		  /* 8219C93Ch */ case    2:  		/* nop */
		/* 8219C93Ch case    2:*/		cpu::op::nop();
		/* 8219C93Ch case    2:*/		return 0x8219C940;
	}
	return 0x8219C940;
} // Block from 8219C934h-8219C940h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219C940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C940);
		  /* 8219C940h */ case    0:  		/* mfspr R12, LR */
		/* 8219C940h case    0:*/		regs.R12 = regs.LR;
		/* 8219C940h case    0:*/		return 0x8219C944;
		  /* 8219C944h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219C944h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219C944h case    1:*/		return 0x8219C948;
		  /* 8219C948h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 8219C948h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8219C948h case    2:*/		return 0x8219C94C;
		  /* 8219C94Ch */ case    3:  		/* lwz R10, <#[R4 + 8]> */
		/* 8219C94Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 8219C94Ch case    3:*/		return 0x8219C950;
		  /* 8219C950h */ case    4:  		/* rlwinm. R11, R10, 7, 31, 31 */
		/* 8219C950h case    4:*/		cpu::op::rlwinm<1,7,31,31>(regs,&regs.R11,regs.R10);
		/* 8219C950h case    4:*/		return 0x8219C954;
		  /* 8219C954h */ case    5:  		/* bc 4, CR0_EQ, 100 */
		/* 8219C954h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8219C9B8;  }
		/* 8219C954h case    5:*/		return 0x8219C958;
		  /* 8219C958h */ case    6:  		/* rlwinm R9, R10, 25, 25, 31 */
		/* 8219C958h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R10);
		/* 8219C958h case    6:*/		return 0x8219C95C;
		  /* 8219C95Ch */ case    7:  		/* cmplwi CR6, R9, 32 */
		/* 8219C95Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000020);
		/* 8219C95Ch case    7:*/		return 0x8219C960;
		  /* 8219C960h */ case    8:  		/* bc 12, CR6_LT, 16 */
		/* 8219C960h case    8:*/		if ( regs.CR[6].lt ) { return 0x8219C970;  }
		/* 8219C960h case    8:*/		return 0x8219C964;
		  /* 8219C964h */ case    9:  		/* cmplwi CR6, R9, 82 */
		/* 8219C964h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000052);
		/* 8219C964h case    9:*/		return 0x8219C968;
		  /* 8219C968h */ case   10:  		/* li R11, 1 */
		/* 8219C968h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219C968h case   10:*/		return 0x8219C96C;
		  /* 8219C96Ch */ case   11:  		/* bc 4, CR6_GT, 8 */
		/* 8219C96Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x8219C974;  }
		/* 8219C96Ch case   11:*/		return 0x8219C970;
	}
	return 0x8219C970;
} // Block from 8219C940h-8219C970h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219C970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C970);
		  /* 8219C970h */ case    0:  		/* li R11, 0 */
		/* 8219C970h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219C970h case    0:*/		return 0x8219C974;
	}
	return 0x8219C974;
} // Block from 8219C970h-8219C974h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C974);
		  /* 8219C974h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219C974h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219C974h case    0:*/		return 0x8219C978;
		  /* 8219C978h */ case    1:  		/* bc 4, CR0_EQ, 64 */
		/* 8219C978h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219C9B8;  }
		/* 8219C978h case    1:*/		return 0x8219C97C;
		  /* 8219C97Ch */ case    2:  		/* rlwinm. R11, R10, 27, 31, 31 */
		/* 8219C97Ch case    2:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R10);
		/* 8219C97Ch case    2:*/		return 0x8219C980;
		  /* 8219C980h */ case    3:  		/* bc 4, CR0_EQ, 56 */
		/* 8219C980h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219C9B8;  }
		/* 8219C980h case    3:*/		return 0x8219C984;
		  /* 8219C984h */ case    4:  		/* cmplwi CR6, R9, 1 */
		/* 8219C984h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 8219C984h case    4:*/		return 0x8219C988;
		  /* 8219C988h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 8219C988h case    5:*/		if ( regs.CR[6].lt ) { return 0x8219C998;  }
		/* 8219C988h case    5:*/		return 0x8219C98C;
		  /* 8219C98Ch */ case    6:  		/* cmplwi CR6, R9, 102 */
		/* 8219C98Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000066);
		/* 8219C98Ch case    6:*/		return 0x8219C990;
		  /* 8219C990h */ case    7:  		/* li R11, 1 */
		/* 8219C990h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219C990h case    7:*/		return 0x8219C994;
		  /* 8219C994h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 8219C994h case    8:*/		if ( !regs.CR[6].gt ) { return 0x8219C99C;  }
		/* 8219C994h case    8:*/		return 0x8219C998;
	}
	return 0x8219C998;
} // Block from 8219C974h-8219C998h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219C998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C998);
		  /* 8219C998h */ case    0:  		/* li R11, 0 */
		/* 8219C998h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219C998h case    0:*/		return 0x8219C99C;
	}
	return 0x8219C99C;
} // Block from 8219C998h-8219C99Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C99Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C99C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C99C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C99C);
		  /* 8219C99Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219C99Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219C99Ch case    0:*/		return 0x8219C9A0;
		  /* 8219C9A0h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8219C9A0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219C9B8;  }
		/* 8219C9A0h case    1:*/		return 0x8219C9A4;
		  /* 8219C9A4h */ case    2:  		/* mr R3, R4 */
		/* 8219C9A4h case    2:*/		regs.R3 = regs.R4;
		/* 8219C9A4h case    2:*/		return 0x8219C9A8;
		  /* 8219C9A8h */ case    3:  		/* bl -229416 */
		/* 8219C9A8h case    3:*/		regs.LR = 0x8219C9AC; return 0x82164980;
		/* 8219C9A8h case    3:*/		return 0x8219C9AC;
		  /* 8219C9ACh */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219C9ACh case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219C9ACh case    4:*/		return 0x8219C9B0;
		  /* 8219C9B0h */ case    5:  		/* li R11, 0 */
		/* 8219C9B0h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219C9B0h case    5:*/		return 0x8219C9B4;
		  /* 8219C9B4h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 8219C9B4h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219C9BC;  }
		/* 8219C9B4h case    6:*/		return 0x8219C9B8;
	}
	return 0x8219C9B8;
} // Block from 8219C99Ch-8219C9B8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219C9B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C9B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C9B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C9B8);
		  /* 8219C9B8h */ case    0:  		/* li R11, 1 */
		/* 8219C9B8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219C9B8h case    0:*/		return 0x8219C9BC;
	}
	return 0x8219C9BC;
} // Block from 8219C9B8h-8219C9BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219C9BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C9BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C9BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C9BC);
		  /* 8219C9BCh */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8219C9BCh case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8219C9BCh case    0:*/		return 0x8219C9C0;
		  /* 8219C9C0h */ case    1:  		/* addi R1, R1, 96 */
		/* 8219C9C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8219C9C0h case    1:*/		return 0x8219C9C4;
		  /* 8219C9C4h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219C9C4h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219C9C4h case    2:*/		return 0x8219C9C8;
		  /* 8219C9C8h */ case    3:  		/* mtspr LR, R12 */
		/* 8219C9C8h case    3:*/		regs.LR = regs.R12;
		/* 8219C9C8h case    3:*/		return 0x8219C9CC;
		  /* 8219C9CCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 8219C9CCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219C9CCh case    4:*/		return 0x8219C9D0;
	}
	return 0x8219C9D0;
} // Block from 8219C9BCh-8219C9D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219C9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C9D0);
		  /* 8219C9D0h */ case    0:  		/* mfspr R12, LR */
		/* 8219C9D0h case    0:*/		regs.R12 = regs.LR;
		/* 8219C9D0h case    0:*/		return 0x8219C9D4;
		  /* 8219C9D4h */ case    1:  		/* bl -1095548 */
		/* 8219C9D4h case    1:*/		regs.LR = 0x8219C9D8; return 0x82091258;
		/* 8219C9D4h case    1:*/		return 0x8219C9D8;
	}
	return 0x8219C9D8;
} // Block from 8219C9D0h-8219C9D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219C9D8h
// Function '?CanUseInSumOfScalars@D3DXShader@@YA_NUAddChainEntry@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C9D8);
		  /* 8219C9D8h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 8219C9D8h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8219C9D8h case    0:*/		return 0x8219C9DC;
		  /* 8219C9DCh */ case    1:  		/* mr R30, R3 */
		/* 8219C9DCh case    1:*/		regs.R30 = regs.R3;
		/* 8219C9DCh case    1:*/		return 0x8219C9E0;
		  /* 8219C9E0h */ case    2:  		/* mr R28, R4 */
		/* 8219C9E0h case    2:*/		regs.R28 = regs.R4;
		/* 8219C9E0h case    2:*/		return 0x8219C9E4;
		  /* 8219C9E4h */ case    3:  		/* cmplw CR6, R3, R4 */
		/* 8219C9E4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R4);
		/* 8219C9E4h case    3:*/		return 0x8219C9E8;
		  /* 8219C9E8h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 8219C9E8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8219C9F4;  }
		/* 8219C9E8h case    4:*/		return 0x8219C9EC;
		  /* 8219C9ECh */ case    5:  		/* li R3, 0 */
		/* 8219C9ECh case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219C9ECh case    5:*/		return 0x8219C9F0;
		  /* 8219C9F0h */ case    6:  		/* b 532 */
		/* 8219C9F0h case    6:*/		return 0x8219CC04;
		/* 8219C9F0h case    6:*/		return 0x8219C9F4;
	}
	return 0x8219C9F4;
} // Block from 8219C9D8h-8219C9F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219C9F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219C9F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219C9F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219C9F4);
		  /* 8219C9F4h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 8219C9F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8219C9F4h case    0:*/		return 0x8219C9F8;
		  /* 8219C9F8h */ case    1:  		/* lwz R9, <#[R28 + 28]> */
		/* 8219C9F8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x0000001C) );
		/* 8219C9F8h case    1:*/		return 0x8219C9FC;
		  /* 8219C9FCh */ case    2:  		/* cmplw CR6, R11, R9 */
		/* 8219C9FCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8219C9FCh case    2:*/		return 0x8219CA00;
		  /* 8219CA00h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 8219CA00h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219CA18;  }
		/* 8219CA00h case    3:*/		return 0x8219CA04;
		  /* 8219CA04h */ case    4:  		/* lwz R10, <#[R9 + 48]> */
		/* 8219CA04h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000030) );
		/* 8219CA04h case    4:*/		return 0x8219CA08;
		  /* 8219CA08h */ case    5:  		/* lwz R11, <#[R11 + 48]> */
		/* 8219CA08h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 8219CA08h case    5:*/		return 0x8219CA0C;
		  /* 8219CA0Ch */ case    6:  		/* rlwinm R10, R10, 0, 13, 31 */
		/* 8219CA0Ch case    6:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R10,regs.R10);
		/* 8219CA0Ch case    6:*/		return 0x8219CA10;
		  /* 8219CA10h */ case    7:  		/* rlwinm R11, R11, 0, 13, 31 */
		/* 8219CA10h case    7:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R11,regs.R11);
		/* 8219CA10h case    7:*/		return 0x8219CA14;
		  /* 8219CA14h */ case    8:  		/* b 492 */
		/* 8219CA14h case    8:*/		return 0x8219CC00;
		/* 8219CA14h case    8:*/		return 0x8219CA18;
	}
	return 0x8219CA18;
} // Block from 8219C9F4h-8219CA18h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219CA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CA18);
		  /* 8219CA18h */ case    0:  		/* rlwinm R10, R30, 0, 0, 19 */
		/* 8219CA18h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R10,regs.R30);
		/* 8219CA18h case    0:*/		return 0x8219CA1C;
		  /* 8219CA1Ch */ case    1:  		/* lwz R10, <#[R10]> */
		/* 8219CA1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8219CA1Ch case    1:*/		return 0x8219CA20;
		  /* 8219CA20h */ case    2:  		/* lwz R29, <#[R10 + 148]> */
		/* 8219CA20h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R10 + 0x00000094) );
		/* 8219CA20h case    2:*/		return 0x8219CA24;
		  /* 8219CA24h */ case    3:  		/* lwz R10, <#[R29 + 564]> */
		/* 8219CA24h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000234) );
		/* 8219CA24h case    3:*/		return 0x8219CA28;
		  /* 8219CA28h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 8219CA28h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8219CA28h case    4:*/		return 0x8219CA2C;
		  /* 8219CA2Ch */ case    5:  		/* bc 4, CR6_EQ, 56 */
		/* 8219CA2Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219CA64;  }
		/* 8219CA2Ch case    5:*/		return 0x8219CA30;
		  /* 8219CA30h */ case    6:  		/* cmplw CR6, R9, R10 */
		/* 8219CA30h case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8219CA30h case    6:*/		return 0x8219CA34;
		  /* 8219CA34h */ case    7:  		/* bc 4, CR6_EQ, 48 */
		/* 8219CA34h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8219CA64;  }
		/* 8219CA34h case    7:*/		return 0x8219CA38;
		  /* 8219CA38h */ case    8:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219CA38h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219CA38h case    8:*/		return 0x8219CA3C;
		  /* 8219CA3Ch */ case    9:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8219CA3Ch case    9:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8219CA3Ch case    9:*/		return 0x8219CA40;
		  /* 8219CA40h */ case   10:  		/* bc 12, CR0_EQ, 356 */
		/* 8219CA40h case   10:*/		if ( regs.CR[0].eq ) { return 0x8219CBA4;  }
		/* 8219CA40h case   10:*/		return 0x8219CA44;
		  /* 8219CA44h */ case   11:  		/* lwz R11, <#[R28 + 8]> */
		/* 8219CA44h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8219CA44h case   11:*/		return 0x8219CA48;
		  /* 8219CA48h */ case   12:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8219CA48h case   12:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8219CA48h case   12:*/		return 0x8219CA4C;
		  /* 8219CA4Ch */ case   13:  		/* bc 12, CR0_EQ, 344 */
		/* 8219CA4Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x8219CBA4;  }
		/* 8219CA4Ch case   13:*/		return 0x8219CA50;
		  /* 8219CA50h */ case   14:  		/* lwz R11, <#[R30 + 20]> */
		/* 8219CA50h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8219CA50h case   14:*/		return 0x8219CA54;
		  /* 8219CA54h */ case   15:  		/* lwz R10, <#[R28 + 20]> */
		/* 8219CA54h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000014) );
		/* 8219CA54h case   15:*/		return 0x8219CA58;
		  /* 8219CA58h */ case   16:  		/* rlwinm R11, R11, 29, 3, 31 */
		/* 8219CA58h case   16:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R11,regs.R11);
		/* 8219CA58h case   16:*/		return 0x8219CA5C;
		  /* 8219CA5Ch */ case   17:  		/* rlwinm R10, R10, 29, 3, 31 */
		/* 8219CA5Ch case   17:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R10,regs.R10);
		/* 8219CA5Ch case   17:*/		return 0x8219CA60;
	}
	return 0x8219CA60;
} // Block from 8219CA18h-8219CA60h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219CA60h
// Function '?FindOperatorChain@Compiler@D3DXShader@@AAAXPAVInstruction@2@0W4Component@2@I01I0PAUAddChainInfo@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CA60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CA60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CA60);
		  /* 8219CA60h */ case    0:  		/* b 416 */
		/* 8219CA60h case    0:*/		return 0x8219CC00;
		/* 8219CA60h case    0:*/		return 0x8219CA64;
	}
	return 0x8219CA64;
} // Block from 8219CA60h-8219CA64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219CA64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CA64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CA64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CA64);
		  /* 8219CA64h */ case    0:  		/* lwz R7, <#[R30 + 8]> */
		/* 8219CA64h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 8219CA64h case    0:*/		return 0x8219CA68;
		  /* 8219CA68h */ case    1:  		/* rlwinm R8, R7, 25, 25, 31 */
		/* 8219CA68h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R8,regs.R7);
		/* 8219CA68h case    1:*/		return 0x8219CA6C;
		  /* 8219CA6Ch */ case    2:  		/* cmplwi CR6, R8, 125 */
		/* 8219CA6Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000007D);
		/* 8219CA6Ch case    2:*/		return 0x8219CA70;
		  /* 8219CA70h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8219CA70h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219CA80;  }
		/* 8219CA70h case    3:*/		return 0x8219CA74;
		  /* 8219CA74h */ case    4:  		/* cmplwi CR6, R8, 124 */
		/* 8219CA74h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000007C);
		/* 8219CA74h case    4:*/		return 0x8219CA78;
		  /* 8219CA78h */ case    5:  		/* li R11, 0 */
		/* 8219CA78h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219CA78h case    5:*/		return 0x8219CA7C;
		  /* 8219CA7Ch */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 8219CA7Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219CA84;  }
		/* 8219CA7Ch case    6:*/		return 0x8219CA80;
	}
	return 0x8219CA80;
} // Block from 8219CA64h-8219CA80h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219CA80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CA80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CA80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CA80);
		  /* 8219CA80h */ case    0:  		/* li R11, 1 */
		/* 8219CA80h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219CA80h case    0:*/		return 0x8219CA84;
	}
	return 0x8219CA84;
} // Block from 8219CA80h-8219CA84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219CA84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CA84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CA84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CA84);
		  /* 8219CA84h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219CA84h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219CA84h case    0:*/		return 0x8219CA88;
		  /* 8219CA88h */ case    1:  		/* bc 12, CR0_EQ, 320 */
		/* 8219CA88h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219CBC8;  }
		/* 8219CA88h case    1:*/		return 0x8219CA8C;
		  /* 8219CA8Ch */ case    2:  		/* lwz R9, <#[R28 + 8]> */
		/* 8219CA8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x00000008) );
		/* 8219CA8Ch case    2:*/		return 0x8219CA90;
		  /* 8219CA90h */ case    3:  		/* rlwinm R10, R9, 25, 25, 31 */
		/* 8219CA90h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R9);
		/* 8219CA90h case    3:*/		return 0x8219CA94;
		  /* 8219CA94h */ case    4:  		/* cmplwi CR6, R10, 125 */
		/* 8219CA94h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007D);
		/* 8219CA94h case    4:*/		return 0x8219CA98;
		  /* 8219CA98h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 8219CA98h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219CAA8;  }
		/* 8219CA98h case    5:*/		return 0x8219CA9C;
		  /* 8219CA9Ch */ case    6:  		/* cmplwi CR6, R10, 124 */
		/* 8219CA9Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 8219CA9Ch case    6:*/		return 0x8219CAA0;
		  /* 8219CAA0h */ case    7:  		/* li R11, 0 */
		/* 8219CAA0h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219CAA0h case    7:*/		return 0x8219CAA4;
		  /* 8219CAA4h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 8219CAA4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8219CAAC;  }
		/* 8219CAA4h case    8:*/		return 0x8219CAA8;
	}
	return 0x8219CAA8;
} // Block from 8219CA84h-8219CAA8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219CAA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CAA8);
		  /* 8219CAA8h */ case    0:  		/* li R11, 1 */
		/* 8219CAA8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219CAA8h case    0:*/		return 0x8219CAAC;
	}
	return 0x8219CAAC;
} // Block from 8219CAA8h-8219CAACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219CAACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CAAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CAAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CAAC);
		  /* 8219CAACh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219CAACh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219CAACh case    0:*/		return 0x8219CAB0;
		  /* 8219CAB0h */ case    1:  		/* bc 12, CR0_EQ, 144 */
		/* 8219CAB0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219CB40;  }
		/* 8219CAB0h case    1:*/		return 0x8219CAB4;
		  /* 8219CAB4h */ case    2:  		/* cmplwi CR6, R8, 124 */
		/* 8219CAB4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x0000007C);
		/* 8219CAB4h case    2:*/		return 0x8219CAB8;
		  /* 8219CAB8h */ case    3:  		/* bc 4, CR6_EQ, 144 */
		/* 8219CAB8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219CB48;  }
		/* 8219CAB8h case    3:*/		return 0x8219CABC;
		  /* 8219CABCh */ case    4:  		/* cmplwi CR6, R10, 124 */
		/* 8219CABCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 8219CABCh case    4:*/		return 0x8219CAC0;
		  /* 8219CAC0h */ case    5:  		/* bc 4, CR6_EQ, 128 */
		/* 8219CAC0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219CB40;  }
		/* 8219CAC0h case    5:*/		return 0x8219CAC4;
		  /* 8219CAC4h */ case    6:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219CAC4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219CAC4h case    6:*/		return 0x8219CAC8;
		  /* 8219CAC8h */ case    7:  		/* mr R3, R29 */
		/* 8219CAC8h case    7:*/		regs.R3 = regs.R29;
		/* 8219CAC8h case    7:*/		return 0x8219CACC;
		  /* 8219CACCh */ case    8:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 8219CACCh case    8:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 8219CACCh case    8:*/		return 0x8219CAD0;
		  /* 8219CAD0h */ case    9:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 8219CAD0h case    9:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 8219CAD0h case    9:*/		return 0x8219CAD4;
		  /* 8219CAD4h */ case   10:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 8219CAD4h case   10:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 8219CAD4h case   10:*/		return 0x8219CAD8;
		  /* 8219CAD8h */ case   11:  		/* bl -231080 */
		/* 8219CAD8h case   11:*/		regs.LR = 0x8219CADC; return 0x82164430;
		/* 8219CAD8h case   11:*/		return 0x8219CADC;
		  /* 8219CADCh */ case   12:  		/* addi R11, R30, -8 */
		/* 8219CADCh case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF8);
		/* 8219CADCh case   12:*/		return 0x8219CAE0;
		  /* 8219CAE0h */ case   13:  		/* lwz R10, <#[R28 + 8]> */
		/* 8219CAE0h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 8219CAE0h case   13:*/		return 0x8219CAE4;
		  /* 8219CAE4h */ case   14:  		/* add R31, R3, R11 */
		/* 8219CAE4h case   14:*/		cpu::op::add<0>(regs,&regs.R31,regs.R3,regs.R11);
		/* 8219CAE4h case   14:*/		return 0x8219CAE8;
		  /* 8219CAE8h */ case   15:  		/* rlwinm R6, R10, 18, 29, 31 */
		/* 8219CAE8h case   15:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R10);
		/* 8219CAE8h case   15:*/		return 0x8219CAEC;
		  /* 8219CAECh */ case   16:  		/* rlwinm R5, R10, 13, 29, 31 */
		/* 8219CAECh case   16:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R10);
		/* 8219CAECh case   16:*/		return 0x8219CAF0;
		  /* 8219CAF0h */ case   17:  		/* rlwinm R4, R10, 25, 25, 31 */
		/* 8219CAF0h case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R10);
		/* 8219CAF0h case   17:*/		return 0x8219CAF4;
		  /* 8219CAF4h */ case   18:  		/* mr R3, R29 */
		/* 8219CAF4h case   18:*/		regs.R3 = regs.R29;
		/* 8219CAF4h case   18:*/		return 0x8219CAF8;
		  /* 8219CAF8h */ case   19:  		/* bl -231112 */
		/* 8219CAF8h case   19:*/		regs.LR = 0x8219CAFC; return 0x82164430;
		/* 8219CAF8h case   19:*/		return 0x8219CAFC;
		  /* 8219CAFCh */ case   20:  		/* lwz R11, <#[R31 + 4]> */
		/* 8219CAFCh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8219CAFCh case   20:*/		return 0x8219CB00;
		  /* 8219CB00h */ case   21:  		/* addi R10, R28, -8 */
		/* 8219CB00h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0xFFFFFFF8);
		/* 8219CB00h case   21:*/		return 0x8219CB04;
		  /* 8219CB04h */ case   22:  		/* rlwinm. R11, R11, 0, 11, 11 */
		/* 8219CB04h case   22:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R11,regs.R11);
		/* 8219CB04h case   22:*/		return 0x8219CB08;
		  /* 8219CB08h */ case   23:  		/* add R10, R3, R10 */
		/* 8219CB08h case   23:*/		cpu::op::add<0>(regs,&regs.R10,regs.R3,regs.R10);
		/* 8219CB08h case   23:*/		return 0x8219CB0C;
		  /* 8219CB0Ch */ case   24:  		/* bc 12, CR0_EQ, 152 */
		/* 8219CB0Ch case   24:*/		if ( regs.CR[0].eq ) { return 0x8219CBA4;  }
		/* 8219CB0Ch case   24:*/		return 0x8219CB10;
		  /* 8219CB10h */ case   25:  		/* lwz R11, <#[R10 + 4]> */
		/* 8219CB10h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 8219CB10h case   25:*/		return 0x8219CB14;
		  /* 8219CB14h */ case   26:  		/* rlwinm. R11, R11, 0, 11, 11 */
		/* 8219CB14h case   26:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R11,regs.R11);
		/* 8219CB14h case   26:*/		return 0x8219CB18;
		  /* 8219CB18h */ case   27:  		/* bc 12, CR0_EQ, 140 */
		/* 8219CB18h case   27:*/		if ( regs.CR[0].eq ) { return 0x8219CBA4;  }
		/* 8219CB18h case   27:*/		return 0x8219CB1C;
		  /* 8219CB1Ch */ case   28:  		/* lwz R11, <#[R31]> */
		/* 8219CB1Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219CB1Ch case   28:*/		return 0x8219CB20;
		  /* 8219CB20h */ case   29:  		/* lwz R10, <#[R10]> */
		/* 8219CB20h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8219CB20h case   29:*/		return 0x8219CB24;
		  /* 8219CB24h */ case   30:  		/* rlwinm R9, R11, 0, 17, 31 */
		/* 8219CB24h case   30:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R9,regs.R11);
		/* 8219CB24h case   30:*/		return 0x8219CB28;
		  /* 8219CB28h */ case   31:  		/* rlwinm R8, R10, 0, 17, 31 */
		/* 8219CB28h case   31:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R8,regs.R10);
		/* 8219CB28h case   31:*/		return 0x8219CB2C;
		  /* 8219CB2Ch */ case   32:  		/* subf. R3, R8, R9 */
		/* 8219CB2Ch case   32:*/		cpu::op::subf<1>(regs,&regs.R3,regs.R8,regs.R9);
		/* 8219CB2Ch case   32:*/		return 0x8219CB30;
		  /* 8219CB30h */ case   33:  		/* bc 4, CR0_EQ, 212 */
		/* 8219CB30h case   33:*/		if ( !regs.CR[0].eq ) { return 0x8219CC04;  }
		/* 8219CB30h case   33:*/		return 0x8219CB34;
		  /* 8219CB34h */ case   34:  		/* rlwinm R10, R10, 17, 18, 31 */
		/* 8219CB34h case   34:*/		cpu::op::rlwinm<0,17,18,31>(regs,&regs.R10,regs.R10);
		/* 8219CB34h case   34:*/		return 0x8219CB38;
		  /* 8219CB38h */ case   35:  		/* rlwinm R11, R11, 17, 18, 31 */
		/* 8219CB38h case   35:*/		cpu::op::rlwinm<0,17,18,31>(regs,&regs.R11,regs.R11);
		/* 8219CB38h case   35:*/		return 0x8219CB3C;
		  /* 8219CB3Ch */ case   36:  		/* b 196 */
		/* 8219CB3Ch case   36:*/		return 0x8219CC00;
		/* 8219CB3Ch case   36:*/		return 0x8219CB40;
	}
	return 0x8219CB40;
} // Block from 8219CAACh-8219CB40h (37 instructions)

//////////////////////////////////////////////////////
// Block at 8219CB40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CB40);
		  /* 8219CB40h */ case    0:  		/* li R3, 1 */
		/* 8219CB40h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219CB40h case    0:*/		return 0x8219CB44;
		  /* 8219CB44h */ case    1:  		/* b 192 */
		/* 8219CB44h case    1:*/		return 0x8219CC04;
		/* 8219CB44h case    1:*/		return 0x8219CB48;
	}
	return 0x8219CB48;
} // Block from 8219CB40h-8219CB48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219CB48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CB48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CB48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CB48);
		  /* 8219CB48h */ case    0:  		/* cmplwi CR6, R10, 124 */
		/* 8219CB48h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 8219CB48h case    0:*/		return 0x8219CB4C;
		  /* 8219CB4Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8219CB4Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219CB58;  }
		/* 8219CB4Ch case    1:*/		return 0x8219CB50;
		  /* 8219CB50h */ case    2:  		/* li R3, -1 */
		/* 8219CB50h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8219CB50h case    2:*/		return 0x8219CB54;
		  /* 8219CB54h */ case    3:  		/* b 176 */
		/* 8219CB54h case    3:*/		return 0x8219CC04;
		/* 8219CB54h case    3:*/		return 0x8219CB58;
	}
	return 0x8219CB58;
} // Block from 8219CB48h-8219CB58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219CB58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CB58);
		  /* 8219CB58h */ case    0:  		/* rlwinm R10, R7, 18, 29, 31 */
		/* 8219CB58h case    0:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R10,regs.R7);
		/* 8219CB58h case    0:*/		return 0x8219CB5C;
		  /* 8219CB5Ch */ case    1:  		/* rlwinm R11, R9, 18, 29, 31 */
		/* 8219CB5Ch case    1:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R9);
		/* 8219CB5Ch case    1:*/		return 0x8219CB60;
		  /* 8219CB60h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8219CB60h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8219CB60h case    2:*/		return 0x8219CB64;
		  /* 8219CB64h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8219CB64h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219CB70;  }
		/* 8219CB64h case    3:*/		return 0x8219CB68;
		  /* 8219CB68h */ case    4:  		/* subf R3, R11, R10 */
		/* 8219CB68h case    4:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8219CB68h case    4:*/		return 0x8219CB6C;
		  /* 8219CB6Ch */ case    5:  		/* b 152 */
		/* 8219CB6Ch case    5:*/		return 0x8219CC04;
		/* 8219CB6Ch case    5:*/		return 0x8219CB70;
	}
	return 0x8219CB70;
} // Block from 8219CB58h-8219CB70h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219CB70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CB70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CB70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CB70);
		  /* 8219CB70h */ case    0:  		/* li R9, 0 */
		/* 8219CB70h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219CB70h case    0:*/		return 0x8219CB74;
		  /* 8219CB74h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 8219CB74h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219CB74h case    1:*/		return 0x8219CB78;
		  /* 8219CB78h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 8219CB78h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219CBA4;  }
		/* 8219CB78h case    2:*/		return 0x8219CB7C;
		  /* 8219CB7Ch */ case    3:  		/* addi R11, R28, 44 */
		/* 8219CB7Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x2C);
		/* 8219CB7Ch case    3:*/		return 0x8219CB80;
		  /* 8219CB80h */ case    4:  		/* subf R8, R28, R30 */
		/* 8219CB80h case    4:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R28,regs.R30);
		/* 8219CB80h case    4:*/		return 0x8219CB84;
		  /* 8219CB84h */ case    5:  		/* lwzx R7, <#[R8 + R11]> */
		/* 8219CB84h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8219CB84h case    5:*/		return 0x8219CB88;
		  /* 8219CB88h */ case    6:  		/* lwz R6, <#[R11]> */
		/* 8219CB88h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8219CB88h case    6:*/		return 0x8219CB8C;
		  /* 8219CB8Ch */ case    7:  		/* subf. R3, R6, R7 */
		/* 8219CB8Ch case    7:*/		cpu::op::subf<1>(regs,&regs.R3,regs.R6,regs.R7);
		/* 8219CB8Ch case    7:*/		return 0x8219CB90;
		  /* 8219CB90h */ case    8:  		/* bc 4, CR0_EQ, 116 */
		/* 8219CB90h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8219CC04;  }
		/* 8219CB90h case    8:*/		return 0x8219CB94;
		  /* 8219CB94h */ case    9:  		/* addi R9, R9, 1 */
		/* 8219CB94h case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8219CB94h case    9:*/		return 0x8219CB98;
		  /* 8219CB98h */ case   10:  		/* addi R11, R11, 4 */
		/* 8219CB98h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219CB98h case   10:*/		return 0x8219CB9C;
		  /* 8219CB9Ch */ case   11:  		/* cmplw CR6, R9, R10 */
		/* 8219CB9Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8219CB9Ch case   11:*/		return 0x8219CBA0;
		  /* 8219CBA0h */ case   12:  		/* bc 12, CR6_LT, -28 */
		/* 8219CBA0h case   12:*/		if ( regs.CR[6].lt ) { return 0x8219CB84;  }
		/* 8219CBA0h case   12:*/		return 0x8219CBA4;
	}
	return 0x8219CBA4;
} // Block from 8219CB70h-8219CBA4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219CBA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CBA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CBA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CBA4);
		  /* 8219CBA4h */ case    0:  		/* mr R4, R28 */
		/* 8219CBA4h case    0:*/		regs.R4 = regs.R28;
		/* 8219CBA4h case    0:*/		return 0x8219CBA8;
		  /* 8219CBA8h */ case    1:  		/* mr R3, R30 */
		/* 8219CBA8h case    1:*/		regs.R3 = regs.R30;
		/* 8219CBA8h case    1:*/		return 0x8219CBAC;
		  /* 8219CBACh */ case    2:  		/* bl 562452 */
		/* 8219CBACh case    2:*/		regs.LR = 0x8219CBB0; return 0x822260C0;
		/* 8219CBACh case    2:*/		return 0x8219CBB0;
		  /* 8219CBB0h */ case    3:  		/* rlwinm R11, R3, 0, 24, 31 */
		/* 8219CBB0h case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219CBB0h case    3:*/		return 0x8219CBB4;
		  /* 8219CBB4h */ case    4:  		/* subfic R11, R11, 0 */
		/* 8219CBB4h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 8219CBB4h case    4:*/		return 0x8219CBB8;
		  /* 8219CBB8h */ case    5:  		/* subfe R11, R11, R11 */
		/* 8219CBB8h case    5:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8219CBB8h case    5:*/		return 0x8219CBBC;
		  /* 8219CBBCh */ case    6:  		/* rlwinm R11, R11, 0, 30, 30 */
		/* 8219CBBCh case    6:*/		cpu::op::rlwinm<0,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8219CBBCh case    6:*/		return 0x8219CBC0;
		  /* 8219CBC0h */ case    7:  		/* addi R3, R11, -1 */
		/* 8219CBC0h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 8219CBC0h case    7:*/		return 0x8219CBC4;
		  /* 8219CBC4h */ case    8:  		/* b 64 */
		/* 8219CBC4h case    8:*/		return 0x8219CC04;
		/* 8219CBC4h case    8:*/		return 0x8219CBC8;
	}
	return 0x8219CBC8;
} // Block from 8219CBA4h-8219CBC8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219CBC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CBC8);
		  /* 8219CBC8h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8219CBC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8219CBC8h case    0:*/		return 0x8219CBCC;
		  /* 8219CBCCh */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219CBCCh case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219CBCCh case    1:*/		return 0x8219CBD0;
		  /* 8219CBD0h */ case    2:  		/* cmplwi CR6, R11, 125 */
		/* 8219CBD0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219CBD0h case    2:*/		return 0x8219CBD4;
		  /* 8219CBD4h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8219CBD4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219CBE4;  }
		/* 8219CBD4h case    3:*/		return 0x8219CBD8;
		  /* 8219CBD8h */ case    4:  		/* cmplwi CR6, R11, 124 */
		/* 8219CBD8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219CBD8h case    4:*/		return 0x8219CBDC;
		  /* 8219CBDCh */ case    5:  		/* li R11, 0 */
		/* 8219CBDCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219CBDCh case    5:*/		return 0x8219CBE0;
		  /* 8219CBE0h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 8219CBE0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219CBE8;  }
		/* 8219CBE0h case    6:*/		return 0x8219CBE4;
	}
	return 0x8219CBE4;
} // Block from 8219CBC8h-8219CBE4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219CBE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CBE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CBE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CBE4);
		  /* 8219CBE4h */ case    0:  		/* li R11, 1 */
		/* 8219CBE4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219CBE4h case    0:*/		return 0x8219CBE8;
	}
	return 0x8219CBE8;
} // Block from 8219CBE4h-8219CBE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219CBE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CBE8);
		  /* 8219CBE8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219CBE8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219CBE8h case    0:*/		return 0x8219CBEC;
		  /* 8219CBECh */ case    1:  		/* bc 4, CR0_EQ, -156 */
		/* 8219CBECh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219CB50;  }
		/* 8219CBECh case    1:*/		return 0x8219CBF0;
		  /* 8219CBF0h */ case    2:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219CBF0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219CBF0h case    2:*/		return 0x8219CBF4;
		  /* 8219CBF4h */ case    3:  		/* lwz R10, <#[R28 + 16]> */
		/* 8219CBF4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 8219CBF4h case    3:*/		return 0x8219CBF8;
		  /* 8219CBF8h */ case    4:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8219CBF8h case    4:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8219CBF8h case    4:*/		return 0x8219CBFC;
		  /* 8219CBFCh */ case    5:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 8219CBFCh case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 8219CBFCh case    5:*/		return 0x8219CC00;
	}
	return 0x8219CC00;
} // Block from 8219CBE8h-8219CC00h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219CC00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CC00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CC00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CC00);
		  /* 8219CC00h */ case    0:  		/* subf R3, R10, R11 */
		/* 8219CC00h case    0:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8219CC00h case    0:*/		return 0x8219CC04;
	}
	return 0x8219CC04;
} // Block from 8219CC00h-8219CC04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219CC04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CC04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CC04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CC04);
		  /* 8219CC04h */ case    0:  		/* addi R1, R1, 128 */
		/* 8219CC04h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8219CC04h case    0:*/		return 0x8219CC08;
		  /* 8219CC08h */ case    1:  		/* b -1096032 */
		/* 8219CC08h case    1:*/		return 0x820912A8;
		/* 8219CC08h case    1:*/		return 0x8219CC0C;
		  /* 8219CC0Ch */ case    2:  		/* nop */
		/* 8219CC0Ch case    2:*/		cpu::op::nop();
		/* 8219CC0Ch case    2:*/		return 0x8219CC10;
	}
	return 0x8219CC10;
} // Block from 8219CC04h-8219CC10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219CC10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CC10);
		  /* 8219CC10h */ case    0:  		/* mfspr R12, LR */
		/* 8219CC10h case    0:*/		regs.R12 = regs.LR;
		/* 8219CC10h case    0:*/		return 0x8219CC14;
		  /* 8219CC14h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219CC14h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219CC14h case    1:*/		return 0x8219CC18;
		  /* 8219CC18h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8219CC18h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8219CC18h case    2:*/		return 0x8219CC1C;
		  /* 8219CC1Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8219CC1Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219CC1Ch case    3:*/		return 0x8219CC20;
		  /* 8219CC20h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8219CC20h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8219CC20h case    4:*/		return 0x8219CC24;
		  /* 8219CC24h */ case    5:  		/* lwz R8, <#[R4]> */
		/* 8219CC24h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 8219CC24h case    5:*/		return 0x8219CC28;
		  /* 8219CC28h */ case    6:  		/* rlwinm R11, R6, 13, 0, 18 */
		/* 8219CC28h case    6:*/		cpu::op::rlwinm<0,13,0,18>(regs,&regs.R11,regs.R6);
		/* 8219CC28h case    6:*/		return 0x8219CC2C;
		  /* 8219CC2Ch */ case    7:  		/* lwz R7, <#[R4 + 8]> */
		/* 8219CC2Ch case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000008) );
		/* 8219CC2Ch case    7:*/		return 0x8219CC30;
		  /* 8219CC30h */ case    8:  		/* mr R9, R3 */
		/* 8219CC30h case    8:*/		regs.R9 = regs.R3;
		/* 8219CC30h case    8:*/		return 0x8219CC34;
		  /* 8219CC34h */ case    9:  		/* rlwinm R10, R8, 0, 0, 18 */
		/* 8219CC34h case    9:*/		cpu::op::rlwinm<0,0,0,18>(regs,&regs.R10,regs.R8);
		/* 8219CC34h case    9:*/		return 0x8219CC38;
		  /* 8219CC38h */ case   10:  		/* ori R7, R7, 16384 */
		/* 8219CC38h case   10:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x4000);
		/* 8219CC38h case   10:*/		return 0x8219CC3C;
		  /* 8219CC3Ch */ case   11:  		/* add R11, R10, R11 */
		/* 8219CC3Ch case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219CC3Ch case   11:*/		return 0x8219CC40;
		  /* 8219CC40h */ case   12:  		/* stw R7, <#[R4 + 8]> */
		/* 8219CC40h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R4 + 0x00000008) );
		/* 8219CC40h case   12:*/		return 0x8219CC44;
		  /* 8219CC44h */ case   13:  		/* mr R31, R4 */
		/* 8219CC44h case   13:*/		regs.R31 = regs.R4;
		/* 8219CC44h case   13:*/		return 0x8219CC48;
		  /* 8219CC48h */ case   14:  		/* rlwimi R11, R8, 0, 19, 2 */
		/* 8219CC48h case   14:*/		cpu::op::rlwimi<0,0,19,2>(regs,&regs.R11,regs.R8);
		/* 8219CC48h case   14:*/		return 0x8219CC4C;
		  /* 8219CC4Ch */ case   15:  		/* stw R11, <#[R4]> */
		/* 8219CC4Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8219CC4Ch case   15:*/		return 0x8219CC50;
		  /* 8219CC50h */ case   16:  		/* lwz R11, <#[R5 + 32]> */
		/* 8219CC50h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000020) );
		/* 8219CC50h case   16:*/		return 0x8219CC54;
		  /* 8219CC54h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 8219CC54h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219CC54h case   17:*/		return 0x8219CC58;
		  /* 8219CC58h */ case   18:  		/* bc 12, CR6_EQ, 96 */
		/* 8219CC58h case   18:*/		if ( regs.CR[6].eq ) { return 0x8219CCB8;  }
		/* 8219CC58h case   18:*/		return 0x8219CC5C;
		  /* 8219CC5Ch */ case   19:  		/* lwz R10, <#[R11 + 4]> */
		/* 8219CC5Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8219CC5Ch case   19:*/		return 0x8219CC60;
		  /* 8219CC60h */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 8219CC60h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219CC60h case   20:*/		return 0x8219CC64;
		  /* 8219CC64h */ case   21:  		/* bc 4, CR6_EQ, 84 */
		/* 8219CC64h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8219CCB8;  }
		/* 8219CC64h case   21:*/		return 0x8219CC68;
		  /* 8219CC68h */ case   22:  		/* lwz R30, <#[R11]> */
		/* 8219CC68h case   22:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 8219CC68h case   22:*/		return 0x8219CC6C;
		  /* 8219CC6Ch */ case   23:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219CC6Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219CC6Ch case   23:*/		return 0x8219CC70;
		  /* 8219CC70h */ case   24:  		/* rlwinm. R11, R11, 0, 18, 18 */
		/* 8219CC70h case   24:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R11,regs.R11);
		/* 8219CC70h case   24:*/		return 0x8219CC74;
		  /* 8219CC74h */ case   25:  		/* bc 12, CR0_EQ, 68 */
		/* 8219CC74h case   25:*/		if ( regs.CR[0].eq ) { return 0x8219CCB8;  }
		/* 8219CC74h case   25:*/		return 0x8219CC78;
		  /* 8219CC78h */ case   26:  		/* mr R5, R30 */
		/* 8219CC78h case   26:*/		regs.R5 = regs.R30;
		/* 8219CC78h case   26:*/		return 0x8219CC7C;
		  /* 8219CC7Ch */ case   27:  		/* bl -4692 */
		/* 8219CC7Ch case   27:*/		regs.LR = 0x8219CC80; return 0x8219BA28;
		/* 8219CC7Ch case   27:*/		return 0x8219CC80;
		  /* 8219CC80h */ case   28:  		/* mr R10, R3 */
		/* 8219CC80h case   28:*/		regs.R10 = regs.R3;
		/* 8219CC80h case   28:*/		return 0x8219CC84;
		  /* 8219CC84h */ case   29:  		/* mr R4, R31 */
		/* 8219CC84h case   29:*/		regs.R4 = regs.R31;
		/* 8219CC84h case   29:*/		return 0x8219CC88;
		  /* 8219CC88h */ case   30:  		/* mr R3, R9 */
		/* 8219CC88h case   30:*/		regs.R3 = regs.R9;
		/* 8219CC88h case   30:*/		return 0x8219CC8C;
		  /* 8219CC8Ch */ case   31:  		/* bl -4548 */
		/* 8219CC8Ch case   31:*/		regs.LR = 0x8219CC90; return 0x8219BAC8;
		/* 8219CC8Ch case   31:*/		return 0x8219CC90;
		  /* 8219CC90h */ case   32:  		/* rlwinm. R11, R10, 0, 24, 31 */
		/* 8219CC90h case   32:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R10);
		/* 8219CC90h case   32:*/		return 0x8219CC94;
		  /* 8219CC94h */ case   33:  		/* bc 4, CR0_EQ, 36 */
		/* 8219CC94h case   33:*/		if ( !regs.CR[0].eq ) { return 0x8219CCB8;  }
		/* 8219CC94h case   33:*/		return 0x8219CC98;
		  /* 8219CC98h */ case   34:  		/* li R5, 49 */
		/* 8219CC98h case   34:*/		cpu::op::li<0>(regs,&regs.R5,0x31);
		/* 8219CC98h case   34:*/		return 0x8219CC9C;
		  /* 8219CC9Ch */ case   35:  		/* li R4, 8 */
		/* 8219CC9Ch case   35:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 8219CC9Ch case   35:*/		return 0x8219CCA0;
		  /* 8219CCA0h */ case   36:  		/* mr R3, R9 */
		/* 8219CCA0h case   36:*/		regs.R3 = regs.R9;
		/* 8219CCA0h case   36:*/		return 0x8219CCA4;
		  /* 8219CCA4h */ case   37:  		/* bl -230324 */
		/* 8219CCA4h case   37:*/		regs.LR = 0x8219CCA8; return 0x821648F0;
		/* 8219CCA4h case   37:*/		return 0x8219CCA8;
		  /* 8219CCA8h */ case   38:  		/* stw R31, <#[R3]> */
		/* 8219CCA8h case   38:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 8219CCA8h case   38:*/		return 0x8219CCAC;
		  /* 8219CCACh */ case   39:  		/* lwz R11, <#[R30 + 20]> */
		/* 8219CCACh case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 8219CCACh case   39:*/		return 0x8219CCB0;
		  /* 8219CCB0h */ case   40:  		/* stw R11, <#[R3 + 4]> */
		/* 8219CCB0h case   40:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219CCB0h case   40:*/		return 0x8219CCB4;
		  /* 8219CCB4h */ case   41:  		/* stw R3, <#[R30 + 20]> */
		/* 8219CCB4h case   41:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000014) );
		/* 8219CCB4h case   41:*/		return 0x8219CCB8;
	}
	return 0x8219CCB8;
} // Block from 8219CC10h-8219CCB8h (42 instructions)

//////////////////////////////////////////////////////
// Block at 8219CCB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CCB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CCB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CCB8);
		  /* 8219CCB8h */ case    0:  		/* addi R1, R1, 112 */
		/* 8219CCB8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8219CCB8h case    0:*/		return 0x8219CCBC;
		  /* 8219CCBCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219CCBCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219CCBCh case    1:*/		return 0x8219CCC0;
		  /* 8219CCC0h */ case    2:  		/* mtspr LR, R12 */
		/* 8219CCC0h case    2:*/		regs.LR = regs.R12;
		/* 8219CCC0h case    2:*/		return 0x8219CCC4;
		  /* 8219CCC4h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8219CCC4h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8219CCC4h case    3:*/		return 0x8219CCC8;
		  /* 8219CCC8h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8219CCC8h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219CCC8h case    4:*/		return 0x8219CCCC;
		  /* 8219CCCCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 8219CCCCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219CCCCh case    5:*/		return 0x8219CCD0;
	}
	return 0x8219CCD0;
} // Block from 8219CCB8h-8219CCD0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219CCD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CCD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CCD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CCD0);
		  /* 8219CCD0h */ case    0:  		/* mr R11, R3 */
		/* 8219CCD0h case    0:*/		regs.R11 = regs.R3;
		/* 8219CCD0h case    0:*/		return 0x8219CCD4;
		  /* 8219CCD4h */ case    1:  		/* lwz R3, <#[R3]> */
		/* 8219CCD4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 8219CCD4h case    1:*/		return 0x8219CCD8;
		  /* 8219CCD8h */ case    2:  		/* mr R10, R4 */
		/* 8219CCD8h case    2:*/		regs.R10 = regs.R4;
		/* 8219CCD8h case    2:*/		return 0x8219CCDC;
		  /* 8219CCDCh */ case    3:  		/* lwz R4, <#[R4]> */
		/* 8219CCDCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000000) );
		/* 8219CCDCh case    3:*/		return 0x8219CCE0;
		  /* 8219CCE0h */ case    4:  		/* lwz R8, <#[R3 + 8]> */
		/* 8219CCE0h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 8219CCE0h case    4:*/		return 0x8219CCE4;
		  /* 8219CCE4h */ case    5:  		/* lwz R9, <#[R4 + 8]> */
		/* 8219CCE4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000008) );
		/* 8219CCE4h case    5:*/		return 0x8219CCE8;
		  /* 8219CCE8h */ case    6:  		/* rlwinm R8, R8, 25, 25, 31 */
		/* 8219CCE8h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R8,regs.R8);
		/* 8219CCE8h case    6:*/		return 0x8219CCEC;
		  /* 8219CCECh */ case    7:  		/* rlwinm R9, R9, 25, 25, 31 */
		/* 8219CCECh case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R9);
		/* 8219CCECh case    7:*/		return 0x8219CCF0;
		  /* 8219CCF0h */ case    8:  		/* subf. R9, R9, R8 */
		/* 8219CCF0h case    8:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8219CCF0h case    8:*/		return 0x8219CCF4;
		  /* 8219CCF4h */ case    9:  		/* bc 12, CR0_EQ, 12 */
		/* 8219CCF4h case    9:*/		if ( regs.CR[0].eq ) { return 0x8219CD00;  }
		/* 8219CCF4h case    9:*/		return 0x8219CCF8;
		  /* 8219CCF8h */ case   10:  		/* mr R3, R9 */
		/* 8219CCF8h case   10:*/		regs.R3 = regs.R9;
		/* 8219CCF8h case   10:*/		return 0x8219CCFC;
		  /* 8219CCFCh */ case   11:  		/* bclr 20, CR0_LT */
		/* 8219CCFCh case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219CCFCh case   11:*/		return 0x8219CD00;
	}
	return 0x8219CD00;
} // Block from 8219CCD0h-8219CD00h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219CD00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CD00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CD00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CD00);
		  /* 8219CD00h */ case    0:  		/* lwz R9, <#[R11 + 20]> */
		/* 8219CD00h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 8219CD00h case    0:*/		return 0x8219CD04;
		  /* 8219CD04h */ case    1:  		/* lwz R8, <#[R10 + 20]> */
		/* 8219CD04h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000014) );
		/* 8219CD04h case    1:*/		return 0x8219CD08;
		  /* 8219CD08h */ case    2:  		/* subf. R9, R8, R9 */
		/* 8219CD08h case    2:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8219CD08h case    2:*/		return 0x8219CD0C;
		  /* 8219CD0Ch */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 8219CD0Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219CCF8;  }
		/* 8219CD0Ch case    3:*/		return 0x8219CD10;
		  /* 8219CD10h */ case    4:  		/* lwz R11, <#[R11 + 24]> */
		/* 8219CD10h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 8219CD10h case    4:*/		return 0x8219CD14;
		  /* 8219CD14h */ case    5:  		/* lwz R10, <#[R10 + 24]> */
		/* 8219CD14h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 8219CD14h case    5:*/		return 0x8219CD18;
		  /* 8219CD18h */ case    6:  		/* subf. R11, R10, R11 */
		/* 8219CD18h case    6:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219CD18h case    6:*/		return 0x8219CD1C;
		  /* 8219CD1Ch */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8219CD1Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x8219CD28;  }
		/* 8219CD1Ch case    7:*/		return 0x8219CD20;
		  /* 8219CD20h */ case    8:  		/* mr R3, R11 */
		/* 8219CD20h case    8:*/		regs.R3 = regs.R11;
		/* 8219CD20h case    8:*/		return 0x8219CD24;
		  /* 8219CD24h */ case    9:  		/* bclr 20, CR0_LT */
		/* 8219CD24h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219CD24h case    9:*/		return 0x8219CD28;
	}
	return 0x8219CD28;
} // Block from 8219CD00h-8219CD28h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219CD28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CD28);
		  /* 8219CD28h */ case    0:  		/* b -856 */
		/* 8219CD28h case    0:*/		return 0x8219C9D0;
		/* 8219CD28h case    0:*/		return 0x8219CD2C;
		  /* 8219CD2Ch */ case    1:  		/* nop */
		/* 8219CD2Ch case    1:*/		cpu::op::nop();
		/* 8219CD2Ch case    1:*/		return 0x8219CD30;
	}
	return 0x8219CD30;
} // Block from 8219CD28h-8219CD30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219CD30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CD30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CD30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CD30);
		  /* 8219CD30h */ case    0:  		/* mfspr R12, LR */
		/* 8219CD30h case    0:*/		regs.R12 = regs.LR;
		/* 8219CD30h case    0:*/		return 0x8219CD34;
		  /* 8219CD34h */ case    1:  		/* bl -1096452 */
		/* 8219CD34h case    1:*/		regs.LR = 0x8219CD38; return 0x82091230;
		/* 8219CD34h case    1:*/		return 0x8219CD38;
		  /* 8219CD38h */ case    2:  		/* stwu R1, <#[R1 - 288]> */
		/* 8219CD38h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 8219CD38h case    2:*/		return 0x8219CD3C;
		  /* 8219CD3Ch */ case    3:  		/* li R19, 0 */
		/* 8219CD3Ch case    3:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8219CD3Ch case    3:*/		return 0x8219CD40;
		  /* 8219CD40h */ case    4:  		/* mr R23, R3 */
		/* 8219CD40h case    4:*/		regs.R23 = regs.R3;
		/* 8219CD40h case    4:*/		return 0x8219CD44;
		  /* 8219CD44h */ case    5:  		/* mr R29, R4 */
		/* 8219CD44h case    5:*/		regs.R29 = regs.R4;
		/* 8219CD44h case    5:*/		return 0x8219CD48;
		  /* 8219CD48h */ case    6:  		/* mr R30, R5 */
		/* 8219CD48h case    6:*/		regs.R30 = regs.R5;
		/* 8219CD48h case    6:*/		return 0x8219CD4C;
		  /* 8219CD4Ch */ case    7:  		/* mr R20, R6 */
		/* 8219CD4Ch case    7:*/		regs.R20 = regs.R6;
		/* 8219CD4Ch case    7:*/		return 0x8219CD50;
		  /* 8219CD50h */ case    8:  		/* mr R18, R7 */
		/* 8219CD50h case    8:*/		regs.R18 = regs.R7;
		/* 8219CD50h case    8:*/		return 0x8219CD54;
		  /* 8219CD54h */ case    9:  		/* mr R24, R8 */
		/* 8219CD54h case    9:*/		regs.R24 = regs.R8;
		/* 8219CD54h case    9:*/		return 0x8219CD58;
		  /* 8219CD58h */ case   10:  		/* addi R28, R5, 44 */
		/* 8219CD58h case   10:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R5,0x2C);
		/* 8219CD58h case   10:*/		return 0x8219CD5C;
		  /* 8219CD5Ch */ case   11:  		/* mr R21, R19 */
		/* 8219CD5Ch case   11:*/		regs.R21 = regs.R19;
		/* 8219CD5Ch case   11:*/		return 0x8219CD60;
		  /* 8219CD60h */ case   12:  		/* mr R26, R19 */
		/* 8219CD60h case   12:*/		regs.R26 = regs.R19;
		/* 8219CD60h case   12:*/		return 0x8219CD64;
		  /* 8219CD64h */ case   13:  		/* subf R25, R5, R4 */
		/* 8219CD64h case   13:*/		cpu::op::subf<0>(regs,&regs.R25,regs.R5,regs.R4);
		/* 8219CD64h case   13:*/		return 0x8219CD68;
		  /* 8219CD68h */ case   14:  		/* mr R31, R19 */
		/* 8219CD68h case   14:*/		regs.R31 = regs.R19;
		/* 8219CD68h case   14:*/		return 0x8219CD6C;
		  /* 8219CD6Ch */ case   15:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219CD6Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219CD6Ch case   15:*/		return 0x8219CD70;
		  /* 8219CD70h */ case   16:  		/* rlwinm R10, R11, 13, 29, 31 */
		/* 8219CD70h case   16:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R10,regs.R11);
		/* 8219CD70h case   16:*/		return 0x8219CD74;
		  /* 8219CD74h */ case   17:  		/* cmplw CR6, R26, R10 */
		/* 8219CD74h case   17:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R10);
		/* 8219CD74h case   17:*/		return 0x8219CD78;
		  /* 8219CD78h */ case   18:  		/* bc 4, CR6_LT, 116 */
		/* 8219CD78h case   18:*/		if ( !regs.CR[6].lt ) { return 0x8219CDEC;  }
		/* 8219CD78h case   18:*/		return 0x8219CD7C;
		  /* 8219CD7Ch */ case   19:  		/* lwzx R11, <#[R25 + R28]> */
		/* 8219CD7Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + regs.R28 + 0x00000000) );
		/* 8219CD7Ch case   19:*/		return 0x8219CD80;
		  /* 8219CD80h */ case   20:  		/* lwz R10, <#[R28]> */
		/* 8219CD80h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 8219CD80h case   20:*/		return 0x8219CD84;
		  /* 8219CD84h */ case   21:  		/* lwz R4, <#[R11 + 12]> */
		/* 8219CD84h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219CD84h case   21:*/		return 0x8219CD88;
		  /* 8219CD88h */ case   22:  		/* lwz R27, <#[R10 + 12]> */
		/* 8219CD88h case   22:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219CD88h case   22:*/		return 0x8219CD8C;
		  /* 8219CD8Ch */ case   23:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219CD8Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219CD8Ch case   23:*/		return 0x8219CD90;
		  /* 8219CD90h */ case   24:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8219CD90h case   24:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219CD90h case   24:*/		return 0x8219CD94;
		  /* 8219CD94h */ case   25:  		/* bc 12, CR0_EQ, 76 */
		/* 8219CD94h case   25:*/		if ( regs.CR[0].eq ) { return 0x8219CDE0;  }
		/* 8219CD94h case   25:*/		return 0x8219CD98;
		  /* 8219CD98h */ case   26:  		/* lwz R11, <#[R27 + 8]> */
		/* 8219CD98h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219CD98h case   26:*/		return 0x8219CD9C;
		  /* 8219CD9Ch */ case   27:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8219CD9Ch case   27:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219CD9Ch case   27:*/		return 0x8219CDA0;
		  /* 8219CDA0h */ case   28:  		/* bc 12, CR0_EQ, 64 */
		/* 8219CDA0h case   28:*/		if ( regs.CR[0].eq ) { return 0x8219CDE0;  }
		/* 8219CDA0h case   28:*/		return 0x8219CDA4;
		  /* 8219CDA4h */ case   29:  		/* addi R11, R1, 128 */
		/* 8219CDA4h case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8219CDA4h case   29:*/		return 0x8219CDA8;
		  /* 8219CDA8h */ case   30:  		/* addi R10, R1, 144 */
		/* 8219CDA8h case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 8219CDA8h case   30:*/		return 0x8219CDAC;
		  /* 8219CDACh */ case   31:  		/* mr R3, R23 */
		/* 8219CDACh case   31:*/		regs.R3 = regs.R23;
		/* 8219CDACh case   31:*/		return 0x8219CDB0;
		  /* 8219CDB0h */ case   32:  		/* stwx R4, <#[R31 + R11]> */
		/* 8219CDB0h case   32:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8219CDB0h case   32:*/		return 0x8219CDB4;
		  /* 8219CDB4h */ case   33:  		/* stwx R27, <#[R31 + R10]> */
		/* 8219CDB4h case   33:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 8219CDB4h case   33:*/		return 0x8219CDB8;
		  /* 8219CDB8h */ case   34:  		/* bl -101856 */
		/* 8219CDB8h case   34:*/		regs.LR = 0x8219CDBC; return 0x82183FD8;
		/* 8219CDB8h case   34:*/		return 0x8219CDBC;
		  /* 8219CDBCh */ case   35:  		/* addi R11, R1, 112 */
		/* 8219CDBCh case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 8219CDBCh case   35:*/		return 0x8219CDC0;
		  /* 8219CDC0h */ case   36:  		/* mr R4, R27 */
		/* 8219CDC0h case   36:*/		regs.R4 = regs.R27;
		/* 8219CDC0h case   36:*/		return 0x8219CDC4;
		  /* 8219CDC4h */ case   37:  		/* stwx R3, <#[R31 + R11]> */
		/* 8219CDC4h case   37:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8219CDC4h case   37:*/		return 0x8219CDC8;
		  /* 8219CDC8h */ case   38:  		/* mr R3, R23 */
		/* 8219CDC8h case   38:*/		regs.R3 = regs.R23;
		/* 8219CDC8h case   38:*/		return 0x8219CDCC;
		  /* 8219CDCCh */ case   39:  		/* bl -101876 */
		/* 8219CDCCh case   39:*/		regs.LR = 0x8219CDD0; return 0x82183FD8;
		/* 8219CDCCh case   39:*/		return 0x8219CDD0;
		  /* 8219CDD0h */ case   40:  		/* addi R11, R1, 96 */
		/* 8219CDD0h case   40:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8219CDD0h case   40:*/		return 0x8219CDD4;
		  /* 8219CDD4h */ case   41:  		/* addi R21, R21, 1 */
		/* 8219CDD4h case   41:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 8219CDD4h case   41:*/		return 0x8219CDD8;
		  /* 8219CDD8h */ case   42:  		/* stwx R3, <#[R31 + R11]> */
		/* 8219CDD8h case   42:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8219CDD8h case   42:*/		return 0x8219CDDC;
		  /* 8219CDDCh */ case   43:  		/* addi R31, R31, 4 */
		/* 8219CDDCh case   43:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8219CDDCh case   43:*/		return 0x8219CDE0;
	}
	return 0x8219CDE0;
} // Block from 8219CD30h-8219CDE0h (44 instructions)

//////////////////////////////////////////////////////
// Block at 8219CDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CDE0);
		  /* 8219CDE0h */ case    0:  		/* addi R26, R26, 1 */
		/* 8219CDE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8219CDE0h case    0:*/		return 0x8219CDE4;
		  /* 8219CDE4h */ case    1:  		/* addi R28, R28, 4 */
		/* 8219CDE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8219CDE4h case    1:*/		return 0x8219CDE8;
		  /* 8219CDE8h */ case    2:  		/* b -124 */
		/* 8219CDE8h case    2:*/		return 0x8219CD6C;
		/* 8219CDE8h case    2:*/		return 0x8219CDEC;
	}
	return 0x8219CDEC;
} // Block from 8219CDE0h-8219CDECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219CDECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CDEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CDEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CDEC);
		  /* 8219CDECh */ case    0:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8219CDECh case    0:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219CDECh case    0:*/		return 0x8219CDF0;
		  /* 8219CDF0h */ case    1:  		/* bc 12, CR0_EQ, 76 */
		/* 8219CDF0h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219CE3C;  }
		/* 8219CDF0h case    1:*/		return 0x8219CDF4;
		  /* 8219CDF4h */ case    2:  		/* rlwinm. R11, R24, 0, 24, 31 */
		/* 8219CDF4h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R24);
		/* 8219CDF4h case    2:*/		return 0x8219CDF8;
		  /* 8219CDF8h */ case    3:  		/* bc 4, CR0_EQ, 68 */
		/* 8219CDF8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219CE3C;  }
		/* 8219CDF8h case    3:*/		return 0x8219CDFC;
		  /* 8219CDFCh */ case    4:  		/* rlwinm R31, R21, 2, 0, 29 */
		/* 8219CDFCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R21);
		/* 8219CDFCh case    4:*/		return 0x8219CE00;
		  /* 8219CE00h */ case    5:  		/* addi R11, R1, 128 */
		/* 8219CE00h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8219CE00h case    5:*/		return 0x8219CE04;
		  /* 8219CE04h */ case    6:  		/* addi R10, R1, 144 */
		/* 8219CE04h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 8219CE04h case    6:*/		return 0x8219CE08;
	}
	return 0x8219CE08;
} // Block from 8219CDECh-8219CE08h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219CE08h
// Function '?CanReplaceCombinedComponent@Compiler@D3DXShader@@AAA_NPAVInstruction@2@W4Component@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CE08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CE08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CE08);
		  /* 8219CE08h */ case    0:  		/* mr R4, R29 */
		/* 8219CE08h case    0:*/		regs.R4 = regs.R29;
		/* 8219CE08h case    0:*/		return 0x8219CE0C;
		  /* 8219CE0Ch */ case    1:  		/* mr R3, R23 */
		/* 8219CE0Ch case    1:*/		regs.R3 = regs.R23;
		/* 8219CE0Ch case    1:*/		return 0x8219CE10;
		  /* 8219CE10h */ case    2:  		/* stwx R29, <#[R31 + R11]> */
		/* 8219CE10h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8219CE10h case    2:*/		return 0x8219CE14;
		  /* 8219CE14h */ case    3:  		/* stwx R30, <#[R31 + R10]> */
		/* 8219CE14h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 8219CE14h case    3:*/		return 0x8219CE18;
		  /* 8219CE18h */ case    4:  		/* bl -101952 */
		/* 8219CE18h case    4:*/		regs.LR = 0x8219CE1C; return 0x82183FD8;
		/* 8219CE18h case    4:*/		return 0x8219CE1C;
		  /* 8219CE1Ch */ case    5:  		/* addi R11, R1, 112 */
		/* 8219CE1Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 8219CE1Ch case    5:*/		return 0x8219CE20;
		  /* 8219CE20h */ case    6:  		/* mr R4, R30 */
		/* 8219CE20h case    6:*/		regs.R4 = regs.R30;
		/* 8219CE20h case    6:*/		return 0x8219CE24;
		  /* 8219CE24h */ case    7:  		/* stwx R3, <#[R31 + R11]> */
		/* 8219CE24h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8219CE24h case    7:*/		return 0x8219CE28;
		  /* 8219CE28h */ case    8:  		/* mr R3, R23 */
		/* 8219CE28h case    8:*/		regs.R3 = regs.R23;
		/* 8219CE28h case    8:*/		return 0x8219CE2C;
		  /* 8219CE2Ch */ case    9:  		/* bl -101972 */
		/* 8219CE2Ch case    9:*/		regs.LR = 0x8219CE30; return 0x82183FD8;
		/* 8219CE2Ch case    9:*/		return 0x8219CE30;
		  /* 8219CE30h */ case   10:  		/* addi R11, R1, 96 */
		/* 8219CE30h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 8219CE30h case   10:*/		return 0x8219CE34;
		  /* 8219CE34h */ case   11:  		/* addi R21, R21, 1 */
		/* 8219CE34h case   11:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 8219CE34h case   11:*/		return 0x8219CE38;
		  /* 8219CE38h */ case   12:  		/* stwx R3, <#[R31 + R11]> */
		/* 8219CE38h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8219CE38h case   12:*/		return 0x8219CE3C;
	}
	return 0x8219CE3C;
} // Block from 8219CE08h-8219CE3Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219CE3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CE3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CE3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CE3C);
		  /* 8219CE3Ch */ case    0:  		/* mr R22, R19 */
		/* 8219CE3Ch case    0:*/		regs.R22 = regs.R19;
		/* 8219CE3Ch case    0:*/		return 0x8219CE40;
		  /* 8219CE40h */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 8219CE40h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 8219CE40h case    1:*/		return 0x8219CE44;
		  /* 8219CE44h */ case    2:  		/* bc 12, CR6_EQ, 664 */
		/* 8219CE44h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219D0DC;  }
		/* 8219CE44h case    2:*/		return 0x8219CE48;
		  /* 8219CE48h */ case    3:  		/* mr R24, R19 */
		/* 8219CE48h case    3:*/		regs.R24 = regs.R19;
		/* 8219CE48h case    3:*/		return 0x8219CE4C;
		  /* 8219CE4Ch */ case    4:  		/* addi R11, R1, 112 */
		/* 8219CE4Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 8219CE4Ch case    4:*/		return 0x8219CE50;
		  /* 8219CE50h */ case    5:  		/* addi R10, R1, 96 */
		/* 8219CE50h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 8219CE50h case    5:*/		return 0x8219CE54;
		  /* 8219CE54h */ case    6:  		/* lwzx R31, <#[R24 + R11]> */
		/* 8219CE54h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + regs.R11 + 0x00000000) );
		/* 8219CE54h case    6:*/		return 0x8219CE58;
		  /* 8219CE58h */ case    7:  		/* lwzx R30, <#[R24 + R10]> */
		/* 8219CE58h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R24 + regs.R10 + 0x00000000) );
		/* 8219CE58h case    7:*/		return 0x8219CE5C;
		  /* 8219CE5Ch */ case    8:  		/* cmplw CR6, R31, R30 */
		/* 8219CE5Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 8219CE5Ch case    8:*/		return 0x8219CE60;
		  /* 8219CE60h */ case    9:  		/* bc 12, CR6_EQ, 620 */
		/* 8219CE60h case    9:*/		if ( regs.CR[6].eq ) { return 0x8219D0CC;  }
		/* 8219CE60h case    9:*/		return 0x8219CE64;
		  /* 8219CE64h */ case   10:  		/* mr R26, R19 */
		/* 8219CE64h case   10:*/		regs.R26 = regs.R19;
		/* 8219CE64h case   10:*/		return 0x8219CE68;
		  /* 8219CE68h */ case   11:  		/* mr R25, R30 */
		/* 8219CE68h case   11:*/		regs.R25 = regs.R30;
		/* 8219CE68h case   11:*/		return 0x8219CE6C;
		  /* 8219CE6Ch */ case   12:  		/* cmplwi CR6, R22, 0 */
		/* 8219CE6Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8219CE6Ch case   12:*/		return 0x8219CE70;
		  /* 8219CE70h */ case   13:  		/* bc 12, CR6_EQ, 104 */
		/* 8219CE70h case   13:*/		if ( regs.CR[6].eq ) { return 0x8219CED8;  }
		/* 8219CE70h case   13:*/		return 0x8219CE74;
		  /* 8219CE74h */ case   14:  		/* mr R11, R19 */
		/* 8219CE74h case   14:*/		regs.R11 = regs.R19;
		/* 8219CE74h case   14:*/		return 0x8219CE78;
		  /* 8219CE78h */ case   15:  		/* mtspr CTR, R22 */
		/* 8219CE78h case   15:*/		regs.CTR = regs.R22;
		/* 8219CE78h case   15:*/		return 0x8219CE7C;
		  /* 8219CE7Ch */ case   16:  		/* lwzx R9, <#[R11 + R20]> */
		/* 8219CE7Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 8219CE7Ch case   16:*/		return 0x8219CE80;
		  /* 8219CE80h */ case   17:  		/* cmplwi CR6, R9, 0 */
		/* 8219CE80h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8219CE80h case   17:*/		return 0x8219CE84;
		  /* 8219CE84h */ case   18:  		/* bc 12, CR6_EQ, 68 */
		/* 8219CE84h case   18:*/		if ( regs.CR[6].eq ) { return 0x8219CEC8;  }
		/* 8219CE84h case   18:*/		return 0x8219CE88;
		  /* 8219CE88h */ case   19:  		/* addi R10, R1, 112 */
		/* 8219CE88h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8219CE88h case   19:*/		return 0x8219CE8C;
		  /* 8219CE8Ch */ case   20:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8219CE8Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8219CE8Ch case   20:*/		return 0x8219CE90;
		  /* 8219CE90h */ case   21:  		/* cmplw CR6, R10, R31 */
		/* 8219CE90h case   21:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8219CE90h case   21:*/		return 0x8219CE94;
		  /* 8219CE94h */ case   22:  		/* bc 12, CR6_EQ, 20 */
		/* 8219CE94h case   22:*/		if ( regs.CR[6].eq ) { return 0x8219CEA8;  }
		/* 8219CE94h case   22:*/		return 0x8219CE98;
		  /* 8219CE98h */ case   23:  		/* addi R8, R1, 96 */
		/* 8219CE98h case   23:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 8219CE98h case   23:*/		return 0x8219CE9C;
		  /* 8219CE9Ch */ case   24:  		/* lwzx R8, <#[R11 + R8]> */
		/* 8219CE9Ch case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 8219CE9Ch case   24:*/		return 0x8219CEA0;
		  /* 8219CEA0h */ case   25:  		/* cmplw CR6, R8, R31 */
		/* 8219CEA0h case   25:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R31);
		/* 8219CEA0h case   25:*/		return 0x8219CEA4;
		  /* 8219CEA4h */ case   26:  		/* bc 4, CR6_EQ, 8 */
		/* 8219CEA4h case   26:*/		if ( !regs.CR[6].eq ) { return 0x8219CEAC;  }
		/* 8219CEA4h case   26:*/		return 0x8219CEA8;
	}
	return 0x8219CEA8;
} // Block from 8219CE3Ch-8219CEA8h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8219CEA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CEA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CEA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CEA8);
		  /* 8219CEA8h */ case    0:  		/* mr R26, R9 */
		/* 8219CEA8h case    0:*/		regs.R26 = regs.R9;
		/* 8219CEA8h case    0:*/		return 0x8219CEAC;
	}
	return 0x8219CEAC;
} // Block from 8219CEA8h-8219CEACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219CEACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CEAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CEAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CEAC);
		  /* 8219CEACh */ case    0:  		/* cmplw CR6, R10, R30 */
		/* 8219CEACh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 8219CEACh case    0:*/		return 0x8219CEB0;
		  /* 8219CEB0h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 8219CEB0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219CEC4;  }
		/* 8219CEB0h case    1:*/		return 0x8219CEB4;
		  /* 8219CEB4h */ case    2:  		/* addi R10, R1, 96 */
		/* 8219CEB4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 8219CEB4h case    2:*/		return 0x8219CEB8;
		  /* 8219CEB8h */ case    3:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8219CEB8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8219CEB8h case    3:*/		return 0x8219CEBC;
		  /* 8219CEBCh */ case    4:  		/* cmplw CR6, R10, R30 */
		/* 8219CEBCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 8219CEBCh case    4:*/		return 0x8219CEC0;
		  /* 8219CEC0h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 8219CEC0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219CEC8;  }
		/* 8219CEC0h case    5:*/		return 0x8219CEC4;
	}
	return 0x8219CEC4;
} // Block from 8219CEACh-8219CEC4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219CEC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CEC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CEC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CEC4);
		  /* 8219CEC4h */ case    0:  		/* mr R25, R9 */
		/* 8219CEC4h case    0:*/		regs.R25 = regs.R9;
		/* 8219CEC4h case    0:*/		return 0x8219CEC8;
	}
	return 0x8219CEC8;
} // Block from 8219CEC4h-8219CEC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219CEC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CEC8);
		  /* 8219CEC8h */ case    0:  		/* addi R11, R11, 4 */
		/* 8219CEC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219CEC8h case    0:*/		return 0x8219CECC;
		  /* 8219CECCh */ case    1:  		/* bc 16, CR0_LT, -80 */
		/* 8219CECCh case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8219CE7C;  }
		/* 8219CECCh case    1:*/		return 0x8219CED0;
		  /* 8219CED0h */ case    2:  		/* cmplwi CR6, R26, 0 */
		/* 8219CED0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8219CED0h case    2:*/		return 0x8219CED4;
		  /* 8219CED4h */ case    3:  		/* bc 4, CR6_EQ, 64 */
		/* 8219CED4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219CF14;  }
		/* 8219CED4h case    3:*/		return 0x8219CED8;
	}
	return 0x8219CED8;
} // Block from 8219CEC8h-8219CED8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219CED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CED8);
		  /* 8219CED8h */ case    0:  		/* mr R3, R23 */
		/* 8219CED8h case    0:*/		regs.R3 = regs.R23;
		/* 8219CED8h case    0:*/		return 0x8219CEDC;
		  /* 8219CEDCh */ case    1:  		/* bl -98092 */
		/* 8219CEDCh case    1:*/		regs.LR = 0x8219CEE0; return 0x82184FB0;
		/* 8219CEDCh case    1:*/		return 0x8219CEE0;
		  /* 8219CEE0h */ case    2:  		/* addi R11, R1, 80 */
		/* 8219CEE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8219CEE0h case    2:*/		return 0x8219CEE4;
		  /* 8219CEE4h */ case    3:  		/* mr R26, R3 */
		/* 8219CEE4h case    3:*/		regs.R26 = regs.R3;
		/* 8219CEE4h case    3:*/		return 0x8219CEE8;
		  /* 8219CEE8h */ case    4:  		/* mr R4, R3 */
		/* 8219CEE8h case    4:*/		regs.R4 = regs.R3;
		/* 8219CEE8h case    4:*/		return 0x8219CEEC;
		  /* 8219CEECh */ case    5:  		/* mr R10, R18 */
		/* 8219CEECh case    5:*/		regs.R10 = regs.R18;
		/* 8219CEECh case    5:*/		return 0x8219CEF0;
		  /* 8219CEF0h */ case    6:  		/* li R9, 0 */
		/* 8219CEF0h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219CEF0h case    6:*/		return 0x8219CEF4;
		  /* 8219CEF4h */ case    7:  		/* stw R19, <#[R11]> */
		/* 8219CEF4h case    7:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000000) );
		/* 8219CEF4h case    7:*/		return 0x8219CEF8;
		  /* 8219CEF8h */ case    8:  		/* li R8, 0 */
		/* 8219CEF8h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8219CEF8h case    8:*/		return 0x8219CEFC;
		  /* 8219CEFCh */ case    9:  		/* li R7, 0 */
		/* 8219CEFCh case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219CEFCh case    9:*/		return 0x8219CF00;
		  /* 8219CF00h */ case   10:  		/* mr R5, R31 */
		/* 8219CF00h case   10:*/		regs.R5 = regs.R31;
		/* 8219CF00h case   10:*/		return 0x8219CF04;
		  /* 8219CF04h */ case   11:  		/* mr R3, R23 */
		/* 8219CF04h case   11:*/		regs.R3 = regs.R23;
		/* 8219CF04h case   11:*/		return 0x8219CF08;
		  /* 8219CF08h */ case   12:  		/* lwz R6, <#[R1 + 80]> */
		/* 8219CF08h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8219CF08h case   12:*/		return 0x8219CF0C;
		  /* 8219CF0Ch */ case   13:  		/* bl -91796 */
		/* 8219CF0Ch case   13:*/		regs.LR = 0x8219CF10; return 0x82186878;
		/* 8219CF0Ch case   13:*/		return 0x8219CF10;
		  /* 8219CF10h */ case   14:  		/* b 12 */
		/* 8219CF10h case   14:*/		return 0x8219CF1C;
		/* 8219CF10h case   14:*/		return 0x8219CF14;
	}
	return 0x8219CF14;
} // Block from 8219CED8h-8219CF14h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219CF14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CF14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CF14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CF14);
		  /* 8219CF14h */ case    0:  		/* cmplw CR6, R26, R25 */
		/* 8219CF14h case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R25);
		/* 8219CF14h case    0:*/		return 0x8219CF18;
		  /* 8219CF18h */ case    1:  		/* bc 12, CR6_EQ, 436 */
		/* 8219CF18h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219D0CC;  }
		/* 8219CF18h case    1:*/		return 0x8219CF1C;
	}
	return 0x8219CF1C;
} // Block from 8219CF14h-8219CF1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219CF1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CF1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CF1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CF1C);
		  /* 8219CF1Ch */ case    0:  		/* cmplwi CR6, R22, 0 */
		/* 8219CF1Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8219CF1Ch case    0:*/		return 0x8219CF20;
		  /* 8219CF20h */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 8219CF20h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219CF74;  }
		/* 8219CF20h case    1:*/		return 0x8219CF24;
		  /* 8219CF24h */ case    2:  		/* mr R11, R19 */
		/* 8219CF24h case    2:*/		regs.R11 = regs.R19;
		/* 8219CF24h case    2:*/		return 0x8219CF28;
		  /* 8219CF28h */ case    3:  		/* mtspr CTR, R22 */
		/* 8219CF28h case    3:*/		regs.CTR = regs.R22;
		/* 8219CF28h case    3:*/		return 0x8219CF2C;
		  /* 8219CF2Ch */ case    4:  		/* addi R10, R1, 112 */
		/* 8219CF2Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8219CF2Ch case    4:*/		return 0x8219CF30;
	}
	return 0x8219CF30;
} // Block from 8219CF1Ch-8219CF30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219CF30h
// Function '?CanReplaceDependency@Compiler@D3DXShader@@AAA_NPAVDependency@2@0PAI1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CF30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CF30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CF30);
		  /* 8219CF30h */ case    0:  		/* lwzx R9, <#[R11 + R10]> */
		/* 8219CF30h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8219CF30h case    0:*/		return 0x8219CF34;
		  /* 8219CF34h */ case    1:  		/* cmplw CR6, R9, R31 */
		/* 8219CF34h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 8219CF34h case    1:*/		return 0x8219CF38;
		  /* 8219CF38h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 8219CF38h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219CF68;  }
		/* 8219CF38h case    2:*/		return 0x8219CF3C;
		  /* 8219CF3Ch */ case    3:  		/* addi R10, R1, 96 */
		/* 8219CF3Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 8219CF3Ch case    3:*/		return 0x8219CF40;
		  /* 8219CF40h */ case    4:  		/* lwzx R10, <#[R11 + R10]> */
		/* 8219CF40h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8219CF40h case    4:*/		return 0x8219CF44;
		  /* 8219CF44h */ case    5:  		/* cmplw CR6, R10, R31 */
		/* 8219CF44h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8219CF44h case    5:*/		return 0x8219CF48;
		  /* 8219CF48h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 8219CF48h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219CF68;  }
		/* 8219CF48h case    6:*/		return 0x8219CF4C;
		  /* 8219CF4Ch */ case    7:  		/* cmplw CR6, R9, R30 */
		/* 8219CF4Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R30);
		/* 8219CF4Ch case    7:*/		return 0x8219CF50;
		  /* 8219CF50h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 8219CF50h case    8:*/		if ( regs.CR[6].eq ) { return 0x8219CF68;  }
		/* 8219CF50h case    8:*/		return 0x8219CF54;
		  /* 8219CF54h */ case    9:  		/* cmplw CR6, R10, R30 */
		/* 8219CF54h case    9:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 8219CF54h case    9:*/		return 0x8219CF58;
		  /* 8219CF58h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 8219CF58h case   10:*/		if ( regs.CR[6].eq ) { return 0x8219CF68;  }
		/* 8219CF58h case   10:*/		return 0x8219CF5C;
		  /* 8219CF5Ch */ case   11:  		/* lwzx R10, <#[R11 + R20]> */
		/* 8219CF5Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 8219CF5Ch case   11:*/		return 0x8219CF60;
		  /* 8219CF60h */ case   12:  		/* cmplw CR6, R10, R25 */
		/* 8219CF60h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R25);
		/* 8219CF60h case   12:*/		return 0x8219CF64;
		  /* 8219CF64h */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 8219CF64h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8219CF6C;  }
		/* 8219CF64h case   13:*/		return 0x8219CF68;
	}
	return 0x8219CF68;
} // Block from 8219CF30h-8219CF68h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219CF68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CF68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CF68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CF68);
		  /* 8219CF68h */ case    0:  		/* stwx R26, <#[R11 + R20]> */
		/* 8219CF68h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + regs.R20 + 0x00000000) );
		/* 8219CF68h case    0:*/		return 0x8219CF6C;
	}
	return 0x8219CF6C;
} // Block from 8219CF68h-8219CF6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219CF6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CF6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CF6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CF6C);
		  /* 8219CF6Ch */ case    0:  		/* addi R11, R11, 4 */
		/* 8219CF6Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219CF6Ch case    0:*/		return 0x8219CF70;
		  /* 8219CF70h */ case    1:  		/* bc 16, CR0_LT, -68 */
		/* 8219CF70h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8219CF2C;  }
		/* 8219CF70h case    1:*/		return 0x8219CF74;
	}
	return 0x8219CF74;
} // Block from 8219CF6Ch-8219CF74h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219CF74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CF74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CF74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CF74);
		  /* 8219CF74h */ case    0:  		/* stwx R26, <#[R24 + R20]> */
		/* 8219CF74h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R24 + regs.R20 + 0x00000000) );
		/* 8219CF74h case    0:*/		return 0x8219CF78;
		  /* 8219CF78h */ case    1:  		/* addi R11, R1, 128 */
		/* 8219CF78h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 8219CF78h case    1:*/		return 0x8219CF7C;
		  /* 8219CF7Ch */ case    2:  		/* mr R3, R23 */
		/* 8219CF7Ch case    2:*/		regs.R3 = regs.R23;
		/* 8219CF7Ch case    2:*/		return 0x8219CF80;
		  /* 8219CF80h */ case    3:  		/* lwzx R4, <#[R24 + R11]> */
		/* 8219CF80h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R24 + regs.R11 + 0x00000000) );
		/* 8219CF80h case    3:*/		return 0x8219CF84;
		  /* 8219CF84h */ case    4:  		/* bl -104036 */
		/* 8219CF84h case    4:*/		regs.LR = 0x8219CF88; return 0x82183920;
		/* 8219CF84h case    4:*/		return 0x8219CF88;
		  /* 8219CF88h */ case    5:  		/* addi R11, R1, 144 */
		/* 8219CF88h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 8219CF88h case    5:*/		return 0x8219CF8C;
		  /* 8219CF8Ch */ case    6:  		/* mr R27, R3 */
		/* 8219CF8Ch case    6:*/		regs.R27 = regs.R3;
		/* 8219CF8Ch case    6:*/		return 0x8219CF90;
		  /* 8219CF90h */ case    7:  		/* mr R3, R23 */
		/* 8219CF90h case    7:*/		regs.R3 = regs.R23;
		/* 8219CF90h case    7:*/		return 0x8219CF94;
		  /* 8219CF94h */ case    8:  		/* lwzx R4, <#[R24 + R11]> */
		/* 8219CF94h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R24 + regs.R11 + 0x00000000) );
		/* 8219CF94h case    8:*/		return 0x8219CF98;
		  /* 8219CF98h */ case    9:  		/* bl -104056 */
		/* 8219CF98h case    9:*/		regs.LR = 0x8219CF9C; return 0x82183920;
		/* 8219CF98h case    9:*/		return 0x8219CF9C;
		  /* 8219CF9Ch */ case   10:  		/* lwz R11, <#[R27 + 8]> */
		/* 8219CF9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219CF9Ch case   10:*/		return 0x8219CFA0;
		  /* 8219CFA0h */ case   11:  		/* mr R28, R3 */
		/* 8219CFA0h case   11:*/		regs.R28 = regs.R3;
		/* 8219CFA0h case   11:*/		return 0x8219CFA4;
		  /* 8219CFA4h */ case   12:  		/* rlwinm R29, R11, 31, 28, 31 */
		/* 8219CFA4h case   12:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R29,regs.R11);
		/* 8219CFA4h case   12:*/		return 0x8219CFA8;
		  /* 8219CFA8h */ case   13:  		/* cmplwi CR6, R29, 0 */
		/* 8219CFA8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8219CFA8h case   13:*/		return 0x8219CFAC;
		  /* 8219CFACh */ case   14:  		/* bc 12, CR6_EQ, 36 */
		/* 8219CFACh case   14:*/		if ( regs.CR[6].eq ) { return 0x8219CFD0;  }
		/* 8219CFACh case   14:*/		return 0x8219CFB0;
		  /* 8219CFB0h */ case   15:  		/* addi R11, R29, -1 */
		/* 8219CFB0h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFF);
		/* 8219CFB0h case   15:*/		return 0x8219CFB4;
		  /* 8219CFB4h */ case   16:  		/* lhz R10, <#[R27 + 18]> */
		/* 8219CFB4h case   16:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000012) );
		/* 8219CFB4h case   16:*/		return 0x8219CFB8;
		  /* 8219CFB8h */ case   17:  		/* andc R11, R29, R11 */
		/* 8219CFB8h case   17:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 8219CFB8h case   17:*/		return 0x8219CFBC;
		  /* 8219CFBCh */ case   18:  		/* cntlzw R11, R11 */
		/* 8219CFBCh case   18:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8219CFBCh case   18:*/		return 0x8219CFC0;
		  /* 8219CFC0h */ case   19:  		/* subf R11, R11, R10 */
		/* 8219CFC0h case   19:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219CFC0h case   19:*/		return 0x8219CFC4;
		  /* 8219CFC4h */ case   20:  		/* addi R4, R11, 31 */
		/* 8219CFC4h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1F);
		/* 8219CFC4h case   20:*/		return 0x8219CFC8;
		  /* 8219CFC8h */ case   21:  		/* mr R11, R4 */
		/* 8219CFC8h case   21:*/		regs.R11 = regs.R4;
		/* 8219CFC8h case   21:*/		return 0x8219CFCC;
		  /* 8219CFCCh */ case   22:  		/* b 12 */
		/* 8219CFCCh case   22:*/		return 0x8219CFD8;
		/* 8219CFCCh case   22:*/		return 0x8219CFD0;
	}
	return 0x8219CFD0;
} // Block from 8219CF74h-8219CFD0h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219CFD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CFD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CFD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CFD0);
		  /* 8219CFD0h */ case    0:  		/* mr R4, R19 */
		/* 8219CFD0h case    0:*/		regs.R4 = regs.R19;
		/* 8219CFD0h case    0:*/		return 0x8219CFD4;
		  /* 8219CFD4h */ case    1:  		/* mr R11, R19 */
		/* 8219CFD4h case    1:*/		regs.R11 = regs.R19;
		/* 8219CFD4h case    1:*/		return 0x8219CFD8;
	}
	return 0x8219CFD8;
} // Block from 8219CFD0h-8219CFD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219CFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219CFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219CFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219CFD8);
		  /* 8219CFD8h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8219CFD8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219CFD8h case    0:*/		return 0x8219CFDC;
		  /* 8219CFDCh */ case    1:  		/* mr R3, R23 */
		/* 8219CFDCh case    1:*/		regs.R3 = regs.R23;
		/* 8219CFDCh case    1:*/		return 0x8219CFE0;
		  /* 8219CFE0h */ case    2:  		/* bc 12, CR6_EQ, 152 */
		/* 8219CFE0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219D078;  }
		/* 8219CFE0h case    2:*/		return 0x8219CFE4;
		  /* 8219CFE4h */ case    3:  		/* bl -104068 */
		/* 8219CFE4h case    3:*/		regs.LR = 0x8219CFE8; return 0x82183960;
		/* 8219CFE4h case    3:*/		return 0x8219CFE8;
		  /* 8219CFE8h */ case    4:  		/* mr R4, R3 */
		/* 8219CFE8h case    4:*/		regs.R4 = regs.R3;
		/* 8219CFE8h case    4:*/		return 0x8219CFEC;
		  /* 8219CFECh */ case    5:  		/* mr R3, R23 */
		/* 8219CFECh case    5:*/		regs.R3 = regs.R23;
		/* 8219CFECh case    5:*/		return 0x8219CFF0;
		  /* 8219CFF0h */ case    6:  		/* bl -103064 */
		/* 8219CFF0h case    6:*/		regs.LR = 0x8219CFF4; return 0x82183D58;
		/* 8219CFF0h case    6:*/		return 0x8219CFF4;
		  /* 8219CFF4h */ case    7:  		/* lwz R11, <#[R28 + 8]> */
		/* 8219CFF4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8219CFF4h case    7:*/		return 0x8219CFF8;
		  /* 8219CFF8h */ case    8:  		/* mr R30, R3 */
		/* 8219CFF8h case    8:*/		regs.R30 = regs.R3;
		/* 8219CFF8h case    8:*/		return 0x8219CFFC;
		  /* 8219CFFCh */ case    9:  		/* rlwinm R31, R11, 31, 28, 31 */
		/* 8219CFFCh case    9:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R31,regs.R11);
		/* 8219CFFCh case    9:*/		return 0x8219D000;
		  /* 8219D000h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 8219D000h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219D000h case   10:*/		return 0x8219D004;
		  /* 8219D004h */ case   11:  		/* bc 12, CR6_EQ, 36 */
		/* 8219D004h case   11:*/		if ( regs.CR[6].eq ) { return 0x8219D028;  }
		/* 8219D004h case   11:*/		return 0x8219D008;
		  /* 8219D008h */ case   12:  		/* addi R11, R31, -1 */
		/* 8219D008h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 8219D008h case   12:*/		return 0x8219D00C;
		  /* 8219D00Ch */ case   13:  		/* lhz R10, <#[R28 + 18]> */
		/* 8219D00Ch case   13:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000012) );
		/* 8219D00Ch case   13:*/		return 0x8219D010;
		  /* 8219D010h */ case   14:  		/* andc R11, R31, R11 */
		/* 8219D010h case   14:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 8219D010h case   14:*/		return 0x8219D014;
		  /* 8219D014h */ case   15:  		/* cntlzw R11, R11 */
		/* 8219D014h case   15:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8219D014h case   15:*/		return 0x8219D018;
		  /* 8219D018h */ case   16:  		/* subf R11, R11, R10 */
		/* 8219D018h case   16:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219D018h case   16:*/		return 0x8219D01C;
		  /* 8219D01Ch */ case   17:  		/* addi R4, R11, 31 */
		/* 8219D01Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1F);
		/* 8219D01Ch case   17:*/		return 0x8219D020;
		  /* 8219D020h */ case   18:  		/* mr R11, R4 */
		/* 8219D020h case   18:*/		regs.R11 = regs.R4;
		/* 8219D020h case   18:*/		return 0x8219D024;
		  /* 8219D024h */ case   19:  		/* b 12 */
		/* 8219D024h case   19:*/		return 0x8219D030;
		/* 8219D024h case   19:*/		return 0x8219D028;
	}
	return 0x8219D028;
} // Block from 8219CFD8h-8219D028h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219D028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D028);
		  /* 8219D028h */ case    0:  		/* mr R4, R19 */
		/* 8219D028h case    0:*/		regs.R4 = regs.R19;
		/* 8219D028h case    0:*/		return 0x8219D02C;
		  /* 8219D02Ch */ case    1:  		/* mr R11, R19 */
		/* 8219D02Ch case    1:*/		regs.R11 = regs.R19;
		/* 8219D02Ch case    1:*/		return 0x8219D030;
	}
	return 0x8219D030;
} // Block from 8219D028h-8219D030h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219D030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D030);
		  /* 8219D030h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8219D030h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219D030h case    0:*/		return 0x8219D034;
		  /* 8219D034h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 8219D034h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219D068;  }
		/* 8219D034h case    1:*/		return 0x8219D038;
		  /* 8219D038h */ case    2:  		/* mr R3, R23 */
		/* 8219D038h case    2:*/		regs.R3 = regs.R23;
		/* 8219D038h case    2:*/		return 0x8219D03C;
		  /* 8219D03Ch */ case    3:  		/* bl -104156 */
		/* 8219D03Ch case    3:*/		regs.LR = 0x8219D040; return 0x82183960;
		/* 8219D03Ch case    3:*/		return 0x8219D040;
		  /* 8219D040h */ case    4:  		/* addi R11, R30, 4 */
		/* 8219D040h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 8219D040h case    4:*/		return 0x8219D044;
		  /* 8219D044h */ case    5:  		/* mr R5, R3 */
		/* 8219D044h case    5:*/		regs.R5 = regs.R3;
		/* 8219D044h case    5:*/		return 0x8219D048;
		  /* 8219D048h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8219D048h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8219D048h case    6:*/		return 0x8219D04C;
		  /* 8219D04Ch */ case    7:  		/* mr R3, R23 */
		/* 8219D04Ch case    7:*/		regs.R3 = regs.R23;
		/* 8219D04Ch case    7:*/		return 0x8219D050;
		  /* 8219D050h */ case    8:  		/* lwzx R4, <#[R11 + R26]> */
		/* 8219D050h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 8219D050h case    8:*/		return 0x8219D054;
		  /* 8219D054h */ case    9:  		/* bl -103196 */
		/* 8219D054h case    9:*/		regs.LR = 0x8219D058; return 0x82183D38;
		/* 8219D054h case    9:*/		return 0x8219D058;
		  /* 8219D058h */ case   10:  		/* addi R11, R31, -1 */
		/* 8219D058h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 8219D058h case   10:*/		return 0x8219D05C;
		  /* 8219D05Ch */ case   11:  		/* andc R11, R31, R11 */
		/* 8219D05Ch case   11:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 8219D05Ch case   11:*/		return 0x8219D060;
		  /* 8219D060h */ case   12:  		/* subf R31, R11, R31 */
		/* 8219D060h case   12:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 8219D060h case   12:*/		return 0x8219D064;
		  /* 8219D064h */ case   13:  		/* b -100 */
		/* 8219D064h case   13:*/		return 0x8219D000;
		/* 8219D064h case   13:*/		return 0x8219D068;
	}
	return 0x8219D068;
} // Block from 8219D030h-8219D068h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219D068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D068);
		  /* 8219D068h */ case    0:  		/* addi R11, R29, -1 */
		/* 8219D068h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFF);
		/* 8219D068h case    0:*/		return 0x8219D06C;
		  /* 8219D06Ch */ case    1:  		/* andc R11, R29, R11 */
		/* 8219D06Ch case    1:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 8219D06Ch case    1:*/		return 0x8219D070;
		  /* 8219D070h */ case    2:  		/* subf R29, R11, R29 */
		/* 8219D070h case    2:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 8219D070h case    2:*/		return 0x8219D074;
		  /* 8219D074h */ case    3:  		/* b -204 */
		/* 8219D074h case    3:*/		return 0x8219CFA8;
		/* 8219D074h case    3:*/		return 0x8219D078;
	}
	return 0x8219D078;
} // Block from 8219D068h-8219D078h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219D078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D078);
		  /* 8219D078h */ case    0:  		/* addi R11, R1, 80 */
		/* 8219D078h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8219D078h case    0:*/		return 0x8219D07C;
		  /* 8219D07Ch */ case    1:  		/* li R9, 0 */
		/* 8219D07Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219D07Ch case    1:*/		return 0x8219D080;
		  /* 8219D080h */ case    2:  		/* li R8, 0 */
		/* 8219D080h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8219D080h case    2:*/		return 0x8219D084;
		  /* 8219D084h */ case    3:  		/* li R7, 0 */
		/* 8219D084h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219D084h case    3:*/		return 0x8219D088;
		  /* 8219D088h */ case    4:  		/* mr R5, R25 */
		/* 8219D088h case    4:*/		regs.R5 = regs.R25;
		/* 8219D088h case    4:*/		return 0x8219D08C;
		  /* 8219D08Ch */ case    5:  		/* stw R19, <#[R11]> */
		/* 8219D08Ch case    5:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000000) );
		/* 8219D08Ch case    5:*/		return 0x8219D090;
		  /* 8219D090h */ case    6:  		/* mr R4, R26 */
		/* 8219D090h case    6:*/		regs.R4 = regs.R26;
		/* 8219D090h case    6:*/		return 0x8219D094;
		  /* 8219D094h */ case    7:  		/* lwz R31, <#[R1 + 80]> */
		/* 8219D094h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 8219D094h case    7:*/		return 0x8219D098;
		  /* 8219D098h */ case    8:  		/* mr R6, R31 */
		/* 8219D098h case    8:*/		regs.R6 = regs.R31;
		/* 8219D098h case    8:*/		return 0x8219D09C;
		  /* 8219D09Ch */ case    9:  		/* bl -92612 */
		/* 8219D09Ch case    9:*/		regs.LR = 0x8219D0A0; return 0x821866D8;
		/* 8219D09Ch case    9:*/		return 0x8219D0A0;
		  /* 8219D0A0h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219D0A0h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219D0A0h case   10:*/		return 0x8219D0A4;
		  /* 8219D0A4h */ case   11:  		/* bc 12, CR0_EQ, 68 */
		/* 8219D0A4h case   11:*/		if ( regs.CR[0].eq ) { return 0x8219D0E8;  }
		/* 8219D0A4h case   11:*/		return 0x8219D0A8;
		  /* 8219D0A8h */ case   12:  		/* mr R10, R18 */
		/* 8219D0A8h case   12:*/		regs.R10 = regs.R18;
		/* 8219D0A8h case   12:*/		return 0x8219D0AC;
		  /* 8219D0ACh */ case   13:  		/* li R9, 0 */
		/* 8219D0ACh case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219D0ACh case   13:*/		return 0x8219D0B0;
		  /* 8219D0B0h */ case   14:  		/* li R8, 0 */
		/* 8219D0B0h case   14:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8219D0B0h case   14:*/		return 0x8219D0B4;
		  /* 8219D0B4h */ case   15:  		/* li R7, 0 */
		/* 8219D0B4h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219D0B4h case   15:*/		return 0x8219D0B8;
		  /* 8219D0B8h */ case   16:  		/* mr R6, R31 */
		/* 8219D0B8h case   16:*/		regs.R6 = regs.R31;
		/* 8219D0B8h case   16:*/		return 0x8219D0BC;
		  /* 8219D0BCh */ case   17:  		/* mr R5, R25 */
		/* 8219D0BCh case   17:*/		regs.R5 = regs.R25;
		/* 8219D0BCh case   17:*/		return 0x8219D0C0;
		  /* 8219D0C0h */ case   18:  		/* mr R4, R26 */
		/* 8219D0C0h case   18:*/		regs.R4 = regs.R26;
		/* 8219D0C0h case   18:*/		return 0x8219D0C4;
		  /* 8219D0C4h */ case   19:  		/* mr R3, R23 */
		/* 8219D0C4h case   19:*/		regs.R3 = regs.R23;
		/* 8219D0C4h case   19:*/		return 0x8219D0C8;
		  /* 8219D0C8h */ case   20:  		/* bl -92240 */
		/* 8219D0C8h case   20:*/		regs.LR = 0x8219D0CC; return 0x82186878;
		/* 8219D0C8h case   20:*/		return 0x8219D0CC;
	}
	return 0x8219D0CC;
} // Block from 8219D078h-8219D0CCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 8219D0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D0CC);
		  /* 8219D0CCh */ case    0:  		/* addi R22, R22, 1 */
		/* 8219D0CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 8219D0CCh case    0:*/		return 0x8219D0D0;
		  /* 8219D0D0h */ case    1:  		/* addi R24, R24, 4 */
		/* 8219D0D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 8219D0D0h case    1:*/		return 0x8219D0D4;
		  /* 8219D0D4h */ case    2:  		/* cmplw CR6, R22, R21 */
		/* 8219D0D4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R21);
		/* 8219D0D4h case    2:*/		return 0x8219D0D8;
		  /* 8219D0D8h */ case    3:  		/* bc 12, CR6_LT, -652 */
		/* 8219D0D8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8219CE4C;  }
		/* 8219D0D8h case    3:*/		return 0x8219D0DC;
	}
	return 0x8219D0DC;
} // Block from 8219D0CCh-8219D0DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219D0DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D0DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D0DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D0DC);
		  /* 8219D0DCh */ case    0:  		/* li R3, 1 */
		/* 8219D0DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219D0DCh case    0:*/		return 0x8219D0E0;
		  /* 8219D0E0h */ case    1:  		/* addi R1, R1, 288 */
		/* 8219D0E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 8219D0E0h case    1:*/		return 0x8219D0E4;
		  /* 8219D0E4h */ case    2:  		/* b -1097316 */
		/* 8219D0E4h case    2:*/		return 0x82091280;
		/* 8219D0E4h case    2:*/		return 0x8219D0E8;
	}
	return 0x8219D0E8;
} // Block from 8219D0DCh-8219D0E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219D0E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D0E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D0E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D0E8);
		  /* 8219D0E8h */ case    0:  		/* li R3, 0 */
		/* 8219D0E8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219D0E8h case    0:*/		return 0x8219D0EC;
		  /* 8219D0ECh */ case    1:  		/* b -12 */
		/* 8219D0ECh case    1:*/		return 0x8219D0E0;
		/* 8219D0ECh case    1:*/		return 0x8219D0F0;
	}
	return 0x8219D0F0;
} // Block from 8219D0E8h-8219D0F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219D0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D0F0);
		  /* 8219D0F0h */ case    0:  		/* mfspr R12, LR */
		/* 8219D0F0h case    0:*/		regs.R12 = regs.LR;
		/* 8219D0F0h case    0:*/		return 0x8219D0F4;
		  /* 8219D0F4h */ case    1:  		/* bl -1097392 */
		/* 8219D0F4h case    1:*/		regs.LR = 0x8219D0F8; return 0x82091244;
		/* 8219D0F4h case    1:*/		return 0x8219D0F8;
		  /* 8219D0F8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8219D0F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8219D0F8h case    2:*/		return 0x8219D0FC;
		  /* 8219D0FCh */ case    3:  		/* mr R31, R3 */
		/* 8219D0FCh case    3:*/		regs.R31 = regs.R3;
		/* 8219D0FCh case    3:*/		return 0x8219D100;
		  /* 8219D100h */ case    4:  		/* mr R30, R4 */
		/* 8219D100h case    4:*/		regs.R30 = regs.R4;
		/* 8219D100h case    4:*/		return 0x8219D104;
		  /* 8219D104h */ case    5:  		/* mr R29, R5 */
		/* 8219D104h case    5:*/		regs.R29 = regs.R5;
		/* 8219D104h case    5:*/		return 0x8219D108;
		  /* 8219D108h */ case    6:  		/* bl -102704 */
		/* 8219D108h case    6:*/		regs.LR = 0x8219D10C; return 0x82183FD8;
		/* 8219D108h case    6:*/		return 0x8219D10C;
		  /* 8219D10Ch */ case    7:  		/* mr R28, R3 */
		/* 8219D10Ch case    7:*/		regs.R28 = regs.R3;
		/* 8219D10Ch case    7:*/		return 0x8219D110;
		  /* 8219D110h */ case    8:  		/* mr R4, R29 */
		/* 8219D110h case    8:*/		regs.R4 = regs.R29;
		/* 8219D110h case    8:*/		return 0x8219D114;
		  /* 8219D114h */ case    9:  		/* mr R3, R31 */
		/* 8219D114h case    9:*/		regs.R3 = regs.R31;
		/* 8219D114h case    9:*/		return 0x8219D118;
		  /* 8219D118h */ case   10:  		/* bl -102720 */
		/* 8219D118h case   10:*/		regs.LR = 0x8219D11C; return 0x82183FD8;
		/* 8219D118h case   10:*/		return 0x8219D11C;
		  /* 8219D11Ch */ case   11:  		/* mr R23, R3 */
		/* 8219D11Ch case   11:*/		regs.R23 = regs.R3;
		/* 8219D11Ch case   11:*/		return 0x8219D120;
		  /* 8219D120h */ case   12:  		/* li R27, 1 */
		/* 8219D120h case   12:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8219D120h case   12:*/		return 0x8219D124;
		  /* 8219D124h */ case   13:  		/* cmplw CR6, R28, R3 */
		/* 8219D124h case   13:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R3);
		/* 8219D124h case   13:*/		return 0x8219D128;
		  /* 8219D128h */ case   14:  		/* bc 12, CR6_EQ, 364 */
		/* 8219D128h case   14:*/		if ( regs.CR[6].eq ) { return 0x8219D294;  }
		/* 8219D128h case   14:*/		return 0x8219D12C;
		  /* 8219D12Ch */ case   15:  		/* mr R3, R31 */
		/* 8219D12Ch case   15:*/		regs.R3 = regs.R31;
		/* 8219D12Ch case   15:*/		return 0x8219D130;
		  /* 8219D130h */ case   16:  		/* bl -98688 */
		/* 8219D130h case   16:*/		regs.LR = 0x8219D134; return 0x82184FB0;
		/* 8219D130h case   16:*/		return 0x8219D134;
		  /* 8219D134h */ case   17:  		/* addi R11, R1, 80 */
		/* 8219D134h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8219D134h case   17:*/		return 0x8219D138;
		  /* 8219D138h */ case   18:  		/* li R24, 0 */
		/* 8219D138h case   18:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8219D138h case   18:*/		return 0x8219D13C;
		  /* 8219D13Ch */ case   19:  		/* mr R26, R3 */
		/* 8219D13Ch case   19:*/		regs.R26 = regs.R3;
		/* 8219D13Ch case   19:*/		return 0x8219D140;
		  /* 8219D140h */ case   20:  		/* mr R4, R3 */
		/* 8219D140h case   20:*/		regs.R4 = regs.R3;
		/* 8219D140h case   20:*/		return 0x8219D144;
		  /* 8219D144h */ case   21:  		/* li R10, 1 */
		/* 8219D144h case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219D144h case   21:*/		return 0x8219D148;
		  /* 8219D148h */ case   22:  		/* stw R24, <#[R11]> */
		/* 8219D148h case   22:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000000) );
		/* 8219D148h case   22:*/		return 0x8219D14C;
		  /* 8219D14Ch */ case   23:  		/* li R9, 0 */
		/* 8219D14Ch case   23:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219D14Ch case   23:*/		return 0x8219D150;
		  /* 8219D150h */ case   24:  		/* li R8, 0 */
		/* 8219D150h case   24:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8219D150h case   24:*/		return 0x8219D154;
		  /* 8219D154h */ case   25:  		/* li R7, 0 */
		/* 8219D154h case   25:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219D154h case   25:*/		return 0x8219D158;
		  /* 8219D158h */ case   26:  		/* mr R5, R28 */
		/* 8219D158h case   26:*/		regs.R5 = regs.R28;
		/* 8219D158h case   26:*/		return 0x8219D15C;
		  /* 8219D15Ch */ case   27:  		/* mr R3, R31 */
		/* 8219D15Ch case   27:*/		regs.R3 = regs.R31;
		/* 8219D15Ch case   27:*/		return 0x8219D160;
		  /* 8219D160h */ case   28:  		/* lwz R6, <#[R1 + 80]> */
		/* 8219D160h case   28:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8219D160h case   28:*/		return 0x8219D164;
		  /* 8219D164h */ case   29:  		/* bl -92396 */
		/* 8219D164h case   29:*/		regs.LR = 0x8219D168; return 0x82186878;
		/* 8219D164h case   29:*/		return 0x8219D168;
		  /* 8219D168h */ case   30:  		/* mr R4, R30 */
		/* 8219D168h case   30:*/		regs.R4 = regs.R30;
		/* 8219D168h case   30:*/		return 0x8219D16C;
		  /* 8219D16Ch */ case   31:  		/* mr R3, R31 */
		/* 8219D16Ch case   31:*/		regs.R3 = regs.R31;
		/* 8219D16Ch case   31:*/		return 0x8219D170;
		  /* 8219D170h */ case   32:  		/* bl -104528 */
		/* 8219D170h case   32:*/		regs.LR = 0x8219D174; return 0x82183920;
		/* 8219D170h case   32:*/		return 0x8219D174;
		  /* 8219D174h */ case   33:  		/* mr R27, R3 */
		/* 8219D174h case   33:*/		regs.R27 = regs.R3;
		/* 8219D174h case   33:*/		return 0x8219D178;
		  /* 8219D178h */ case   34:  		/* mr R4, R29 */
		/* 8219D178h case   34:*/		regs.R4 = regs.R29;
		/* 8219D178h case   34:*/		return 0x8219D17C;
		  /* 8219D17Ch */ case   35:  		/* mr R3, R31 */
		/* 8219D17Ch case   35:*/		regs.R3 = regs.R31;
		/* 8219D17Ch case   35:*/		return 0x8219D180;
		  /* 8219D180h */ case   36:  		/* bl -104544 */
		/* 8219D180h case   36:*/		regs.LR = 0x8219D184; return 0x82183920;
		/* 8219D180h case   36:*/		return 0x8219D184;
		  /* 8219D184h */ case   37:  		/* lwz R11, <#[R27 + 8]> */
		/* 8219D184h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219D184h case   37:*/		return 0x8219D188;
		  /* 8219D188h */ case   38:  		/* mr R25, R3 */
		/* 8219D188h case   38:*/		regs.R25 = regs.R3;
		/* 8219D188h case   38:*/		return 0x8219D18C;
		  /* 8219D18Ch */ case   39:  		/* rlwinm R29, R11, 31, 28, 31 */
		/* 8219D18Ch case   39:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R29,regs.R11);
		/* 8219D18Ch case   39:*/		return 0x8219D190;
		  /* 8219D190h */ case   40:  		/* cmplwi CR6, R29, 0 */
		/* 8219D190h case   40:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8219D190h case   40:*/		return 0x8219D194;
		  /* 8219D194h */ case   41:  		/* bc 12, CR6_EQ, 36 */
		/* 8219D194h case   41:*/		if ( regs.CR[6].eq ) { return 0x8219D1B8;  }
		/* 8219D194h case   41:*/		return 0x8219D198;
		  /* 8219D198h */ case   42:  		/* addi R11, R29, -1 */
		/* 8219D198h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFF);
		/* 8219D198h case   42:*/		return 0x8219D19C;
		  /* 8219D19Ch */ case   43:  		/* lhz R10, <#[R27 + 18]> */
		/* 8219D19Ch case   43:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000012) );
		/* 8219D19Ch case   43:*/		return 0x8219D1A0;
		  /* 8219D1A0h */ case   44:  		/* andc R11, R29, R11 */
		/* 8219D1A0h case   44:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 8219D1A0h case   44:*/		return 0x8219D1A4;
		  /* 8219D1A4h */ case   45:  		/* cntlzw R11, R11 */
		/* 8219D1A4h case   45:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8219D1A4h case   45:*/		return 0x8219D1A8;
		  /* 8219D1A8h */ case   46:  		/* subf R11, R11, R10 */
		/* 8219D1A8h case   46:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219D1A8h case   46:*/		return 0x8219D1AC;
		  /* 8219D1ACh */ case   47:  		/* addi R4, R11, 31 */
		/* 8219D1ACh case   47:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1F);
		/* 8219D1ACh case   47:*/		return 0x8219D1B0;
		  /* 8219D1B0h */ case   48:  		/* mr R11, R4 */
		/* 8219D1B0h case   48:*/		regs.R11 = regs.R4;
		/* 8219D1B0h case   48:*/		return 0x8219D1B4;
		  /* 8219D1B4h */ case   49:  		/* b 12 */
		/* 8219D1B4h case   49:*/		return 0x8219D1C0;
		/* 8219D1B4h case   49:*/		return 0x8219D1B8;
	}
	return 0x8219D1B8;
} // Block from 8219D0F0h-8219D1B8h (50 instructions)

//////////////////////////////////////////////////////
// Block at 8219D1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D1B8);
		  /* 8219D1B8h */ case    0:  		/* mr R4, R24 */
		/* 8219D1B8h case    0:*/		regs.R4 = regs.R24;
		/* 8219D1B8h case    0:*/		return 0x8219D1BC;
		  /* 8219D1BCh */ case    1:  		/* mr R11, R24 */
		/* 8219D1BCh case    1:*/		regs.R11 = regs.R24;
		/* 8219D1BCh case    1:*/		return 0x8219D1C0;
	}
	return 0x8219D1C0;
} // Block from 8219D1B8h-8219D1C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219D1C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D1C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D1C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D1C0);
		  /* 8219D1C0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8219D1C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219D1C0h case    0:*/		return 0x8219D1C4;
		  /* 8219D1C4h */ case    1:  		/* mr R3, R31 */
		/* 8219D1C4h case    1:*/		regs.R3 = regs.R31;
		/* 8219D1C4h case    1:*/		return 0x8219D1C8;
		  /* 8219D1C8h */ case    2:  		/* bc 12, CR6_EQ, 152 */
		/* 8219D1C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219D260;  }
		/* 8219D1C8h case    2:*/		return 0x8219D1CC;
		  /* 8219D1CCh */ case    3:  		/* bl -104556 */
		/* 8219D1CCh case    3:*/		regs.LR = 0x8219D1D0; return 0x82183960;
		/* 8219D1CCh case    3:*/		return 0x8219D1D0;
		  /* 8219D1D0h */ case    4:  		/* mr R4, R3 */
		/* 8219D1D0h case    4:*/		regs.R4 = regs.R3;
		/* 8219D1D0h case    4:*/		return 0x8219D1D4;
		  /* 8219D1D4h */ case    5:  		/* mr R3, R31 */
		/* 8219D1D4h case    5:*/		regs.R3 = regs.R31;
		/* 8219D1D4h case    5:*/		return 0x8219D1D8;
		  /* 8219D1D8h */ case    6:  		/* bl -103552 */
		/* 8219D1D8h case    6:*/		regs.LR = 0x8219D1DC; return 0x82183D58;
		/* 8219D1D8h case    6:*/		return 0x8219D1DC;
		  /* 8219D1DCh */ case    7:  		/* lwz R11, <#[R25 + 8]> */
		/* 8219D1DCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8219D1DCh case    7:*/		return 0x8219D1E0;
		  /* 8219D1E0h */ case    8:  		/* mr R28, R3 */
		/* 8219D1E0h case    8:*/		regs.R28 = regs.R3;
		/* 8219D1E0h case    8:*/		return 0x8219D1E4;
		  /* 8219D1E4h */ case    9:  		/* rlwinm R30, R11, 31, 28, 31 */
		/* 8219D1E4h case    9:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R30,regs.R11);
		/* 8219D1E4h case    9:*/		return 0x8219D1E8;
		  /* 8219D1E8h */ case   10:  		/* cmplwi CR6, R30, 0 */
		/* 8219D1E8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219D1E8h case   10:*/		return 0x8219D1EC;
		  /* 8219D1ECh */ case   11:  		/* bc 12, CR6_EQ, 36 */
		/* 8219D1ECh case   11:*/		if ( regs.CR[6].eq ) { return 0x8219D210;  }
		/* 8219D1ECh case   11:*/		return 0x8219D1F0;
		  /* 8219D1F0h */ case   12:  		/* addi R11, R30, -1 */
		/* 8219D1F0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFF);
		/* 8219D1F0h case   12:*/		return 0x8219D1F4;
		  /* 8219D1F4h */ case   13:  		/* lhz R10, <#[R25 + 18]> */
		/* 8219D1F4h case   13:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000012) );
		/* 8219D1F4h case   13:*/		return 0x8219D1F8;
		  /* 8219D1F8h */ case   14:  		/* andc R11, R30, R11 */
		/* 8219D1F8h case   14:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8219D1F8h case   14:*/		return 0x8219D1FC;
		  /* 8219D1FCh */ case   15:  		/* cntlzw R11, R11 */
		/* 8219D1FCh case   15:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8219D1FCh case   15:*/		return 0x8219D200;
		  /* 8219D200h */ case   16:  		/* subf R11, R11, R10 */
		/* 8219D200h case   16:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219D200h case   16:*/		return 0x8219D204;
		  /* 8219D204h */ case   17:  		/* addi R4, R11, 31 */
		/* 8219D204h case   17:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1F);
		/* 8219D204h case   17:*/		return 0x8219D208;
		  /* 8219D208h */ case   18:  		/* mr R11, R4 */
		/* 8219D208h case   18:*/		regs.R11 = regs.R4;
		/* 8219D208h case   18:*/		return 0x8219D20C;
		  /* 8219D20Ch */ case   19:  		/* b 12 */
		/* 8219D20Ch case   19:*/		return 0x8219D218;
		/* 8219D20Ch case   19:*/		return 0x8219D210;
	}
	return 0x8219D210;
} // Block from 8219D1C0h-8219D210h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219D210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D210);
		  /* 8219D210h */ case    0:  		/* mr R4, R24 */
		/* 8219D210h case    0:*/		regs.R4 = regs.R24;
		/* 8219D210h case    0:*/		return 0x8219D214;
		  /* 8219D214h */ case    1:  		/* mr R11, R24 */
		/* 8219D214h case    1:*/		regs.R11 = regs.R24;
		/* 8219D214h case    1:*/		return 0x8219D218;
	}
	return 0x8219D218;
} // Block from 8219D210h-8219D218h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219D218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D218);
		  /* 8219D218h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8219D218h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219D218h case    0:*/		return 0x8219D21C;
		  /* 8219D21Ch */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 8219D21Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8219D250;  }
		/* 8219D21Ch case    1:*/		return 0x8219D220;
		  /* 8219D220h */ case    2:  		/* mr R3, R31 */
		/* 8219D220h case    2:*/		regs.R3 = regs.R31;
		/* 8219D220h case    2:*/		return 0x8219D224;
		  /* 8219D224h */ case    3:  		/* bl -104644 */
		/* 8219D224h case    3:*/		regs.LR = 0x8219D228; return 0x82183960;
		/* 8219D224h case    3:*/		return 0x8219D228;
		  /* 8219D228h */ case    4:  		/* addi R11, R28, 4 */
		/* 8219D228h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x4);
		/* 8219D228h case    4:*/		return 0x8219D22C;
		  /* 8219D22Ch */ case    5:  		/* mr R5, R3 */
		/* 8219D22Ch case    5:*/		regs.R5 = regs.R3;
		/* 8219D22Ch case    5:*/		return 0x8219D230;
		  /* 8219D230h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8219D230h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8219D230h case    6:*/		return 0x8219D234;
		  /* 8219D234h */ case    7:  		/* mr R3, R31 */
		/* 8219D234h case    7:*/		regs.R3 = regs.R31;
		/* 8219D234h case    7:*/		return 0x8219D238;
		  /* 8219D238h */ case    8:  		/* lwzx R4, <#[R11 + R26]> */
		/* 8219D238h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 8219D238h case    8:*/		return 0x8219D23C;
		  /* 8219D23Ch */ case    9:  		/* bl -103684 */
		/* 8219D23Ch case    9:*/		regs.LR = 0x8219D240; return 0x82183D38;
		/* 8219D23Ch case    9:*/		return 0x8219D240;
		  /* 8219D240h */ case   10:  		/* addi R11, R30, -1 */
		/* 8219D240h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFF);
		/* 8219D240h case   10:*/		return 0x8219D244;
		  /* 8219D244h */ case   11:  		/* andc R11, R30, R11 */
		/* 8219D244h case   11:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 8219D244h case   11:*/		return 0x8219D248;
		  /* 8219D248h */ case   12:  		/* subf R30, R11, R30 */
		/* 8219D248h case   12:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 8219D248h case   12:*/		return 0x8219D24C;
		  /* 8219D24Ch */ case   13:  		/* b -100 */
		/* 8219D24Ch case   13:*/		return 0x8219D1E8;
		/* 8219D24Ch case   13:*/		return 0x8219D250;
	}
	return 0x8219D250;
} // Block from 8219D218h-8219D250h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219D250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D250);
		  /* 8219D250h */ case    0:  		/* addi R11, R29, -1 */
		/* 8219D250h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFF);
		/* 8219D250h case    0:*/		return 0x8219D254;
		  /* 8219D254h */ case    1:  		/* andc R11, R29, R11 */
		/* 8219D254h case    1:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 8219D254h case    1:*/		return 0x8219D258;
		  /* 8219D258h */ case    2:  		/* subf R29, R11, R29 */
		/* 8219D258h case    2:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 8219D258h case    2:*/		return 0x8219D25C;
		  /* 8219D25Ch */ case    3:  		/* b -204 */
		/* 8219D25Ch case    3:*/		return 0x8219D190;
		/* 8219D25Ch case    3:*/		return 0x8219D260;
	}
	return 0x8219D260;
} // Block from 8219D250h-8219D260h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219D260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D260);
		  /* 8219D260h */ case    0:  		/* addi R11, R1, 80 */
		/* 8219D260h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8219D260h case    0:*/		return 0x8219D264;
		  /* 8219D264h */ case    1:  		/* li R9, 0 */
		/* 8219D264h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219D264h case    1:*/		return 0x8219D268;
		  /* 8219D268h */ case    2:  		/* li R8, 0 */
		/* 8219D268h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8219D268h case    2:*/		return 0x8219D26C;
		  /* 8219D26Ch */ case    3:  		/* li R7, 0 */
		/* 8219D26Ch case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219D26Ch case    3:*/		return 0x8219D270;
		  /* 8219D270h */ case    4:  		/* mr R5, R23 */
		/* 8219D270h case    4:*/		regs.R5 = regs.R23;
		/* 8219D270h case    4:*/		return 0x8219D274;
		  /* 8219D274h */ case    5:  		/* stw R24, <#[R11]> */
		/* 8219D274h case    5:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000000) );
		/* 8219D274h case    5:*/		return 0x8219D278;
		  /* 8219D278h */ case    6:  		/* mr R4, R26 */
		/* 8219D278h case    6:*/		regs.R4 = regs.R26;
		/* 8219D278h case    6:*/		return 0x8219D27C;
		  /* 8219D27Ch */ case    7:  		/* lwz R6, <#[R1 + 80]> */
		/* 8219D27Ch case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8219D27Ch case    7:*/		return 0x8219D280;
		  /* 8219D280h */ case    8:  		/* bl -93096 */
		/* 8219D280h case    8:*/		regs.LR = 0x8219D284; return 0x821866D8;
		/* 8219D280h case    8:*/		return 0x8219D284;
		  /* 8219D284h */ case    9:  		/* mr R27, R3 */
		/* 8219D284h case    9:*/		regs.R27 = regs.R3;
		/* 8219D284h case    9:*/		return 0x8219D288;
		  /* 8219D288h */ case   10:  		/* mr R4, R26 */
		/* 8219D288h case   10:*/		regs.R4 = regs.R26;
		/* 8219D288h case   10:*/		return 0x8219D28C;
		  /* 8219D28Ch */ case   11:  		/* mr R3, R31 */
		/* 8219D28Ch case   11:*/		regs.R3 = regs.R31;
		/* 8219D28Ch case   11:*/		return 0x8219D290;
		  /* 8219D290h */ case   12:  		/* bl -101512 */
		/* 8219D290h case   12:*/		regs.LR = 0x8219D294; return 0x82184608;
		/* 8219D290h case   12:*/		return 0x8219D294;
	}
	return 0x8219D294;
} // Block from 8219D260h-8219D294h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219D294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D294);
		  /* 8219D294h */ case    0:  		/* mr R3, R27 */
		/* 8219D294h case    0:*/		regs.R3 = regs.R27;
		/* 8219D294h case    0:*/		return 0x8219D298;
		  /* 8219D298h */ case    1:  		/* addi R1, R1, 176 */
		/* 8219D298h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8219D298h case    1:*/		return 0x8219D29C;
		  /* 8219D29Ch */ case    2:  		/* b -1097736 */
		/* 8219D29Ch case    2:*/		return 0x82091294;
		/* 8219D29Ch case    2:*/		return 0x8219D2A0;
	}
	return 0x8219D2A0;
} // Block from 8219D294h-8219D2A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219D2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D2A0);
		  /* 8219D2A0h */ case    0:  		/* mfspr R12, LR */
		/* 8219D2A0h case    0:*/		regs.R12 = regs.LR;
		/* 8219D2A0h case    0:*/		return 0x8219D2A4;
		  /* 8219D2A4h */ case    1:  		/* bl -1097824 */
		/* 8219D2A4h case    1:*/		regs.LR = 0x8219D2A8; return 0x82091244;
		/* 8219D2A4h case    1:*/		return 0x8219D2A8;
		  /* 8219D2A8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8219D2A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8219D2A8h case    2:*/		return 0x8219D2AC;
		  /* 8219D2ACh */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219D2ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219D2ACh case    3:*/		return 0x8219D2B0;
		  /* 8219D2B0h */ case    4:  		/* mr R24, R3 */
		/* 8219D2B0h case    4:*/		regs.R24 = regs.R3;
		/* 8219D2B0h case    4:*/		return 0x8219D2B4;
		  /* 8219D2B4h */ case    5:  		/* mr R25, R4 */
		/* 8219D2B4h case    5:*/		regs.R25 = regs.R4;
		/* 8219D2B4h case    5:*/		return 0x8219D2B8;
		  /* 8219D2B8h */ case    6:  		/* mr R27, R5 */
		/* 8219D2B8h case    6:*/		regs.R27 = regs.R5;
		/* 8219D2B8h case    6:*/		return 0x8219D2BC;
		  /* 8219D2BCh */ case    7:  		/* mr R30, R6 */
		/* 8219D2BCh case    7:*/		regs.R30 = regs.R6;
		/* 8219D2BCh case    7:*/		return 0x8219D2C0;
		  /* 8219D2C0h */ case    8:  		/* li R23, 0 */
		/* 8219D2C0h case    8:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 8219D2C0h case    8:*/		return 0x8219D2C4;
		  /* 8219D2C4h */ case    9:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 8219D2C4h case    9:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 8219D2C4h case    9:*/		return 0x8219D2C8;
		  /* 8219D2C8h */ case   10:  		/* bc 12, CR0_EQ, 200 */
		/* 8219D2C8h case   10:*/		if ( regs.CR[0].eq ) { return 0x8219D390;  }
		/* 8219D2C8h case   10:*/		return 0x8219D2CC;
		  /* 8219D2CCh */ case   11:  		/* addi R26, R4, 44 */
		/* 8219D2CCh case   11:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R4,0x2C);
		/* 8219D2CCh case   11:*/		return 0x8219D2D0;
		  /* 8219D2D0h */ case   12:  		/* lwz R11, <#[R26]> */
		/* 8219D2D0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8219D2D0h case   12:*/		return 0x8219D2D4;
		  /* 8219D2D4h */ case   13:  		/* li R10, 0 */
		/* 8219D2D4h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219D2D4h case   13:*/		return 0x8219D2D8;
	}
	return 0x8219D2D8;
} // Block from 8219D2A0h-8219D2D8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219D2D8h
// Function '?ExcludedFromVectorizing@Compiler@D3DXShader@@AAA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D2D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D2D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D2D8);
		  /* 8219D2D8h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 8219D2D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8219D2D8h case    0:*/		return 0x8219D2DC;
		  /* 8219D2DCh */ case    1:  		/* lwz R28, <#[R11 + 12]> */
		/* 8219D2DCh case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219D2DCh case    1:*/		return 0x8219D2E0;
		  /* 8219D2E0h */ case    2:  		/* bc 12, CR6_EQ, 56 */
		/* 8219D2E0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219D318;  }
		/* 8219D2E0h case    2:*/		return 0x8219D2E4;
		  /* 8219D2E4h */ case    3:  		/* addi R9, R27, 44 */
		/* 8219D2E4h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0x2C);
		/* 8219D2E4h case    3:*/		return 0x8219D2E8;
		  /* 8219D2E8h */ case    4:  		/* mtspr CTR, R30 */
		/* 8219D2E8h case    4:*/		regs.CTR = regs.R30;
		/* 8219D2E8h case    4:*/		return 0x8219D2EC;
		  /* 8219D2ECh */ case    5:  		/* lwz R11, <#[R9]> */
		/* 8219D2ECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8219D2ECh case    5:*/		return 0x8219D2F0;
		  /* 8219D2F0h */ case    6:  		/* lwz R8, <#[R11 + 12]> */
		/* 8219D2F0h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219D2F0h case    6:*/		return 0x8219D2F4;
		  /* 8219D2F4h */ case    7:  		/* cmplw CR6, R8, R28 */
		/* 8219D2F4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R28);
		/* 8219D2F4h case    7:*/		return 0x8219D2F8;
		  /* 8219D2F8h */ case    8:  		/* bc 4, CR6_EQ, 24 */
		/* 8219D2F8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8219D310;  }
		/* 8219D2F8h case    8:*/		return 0x8219D2FC;
		  /* 8219D2FCh */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8219D2FCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219D2FCh case    9:*/		return 0x8219D300;
		  /* 8219D300h */ case   10:  		/* li R8, 1 */
		/* 8219D300h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8219D300h case   10:*/		return 0x8219D304;
		  /* 8219D304h */ case   11:  		/* rlwinm R11, R11, 27, 30, 31 */
		/* 8219D304h case   11:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R11);
		/* 8219D304h case   11:*/		return 0x8219D308;
		  /* 8219D308h */ case   12:  		/* slw R11, R8, R11 */
		/* 8219D308h case   12:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 8219D308h case   12:*/		return 0x8219D30C;
		  /* 8219D30Ch */ case   13:  		/* or R10, R11, R10 */
		/* 8219D30Ch case   13:*/		cpu::op::or<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8219D30Ch case   13:*/		return 0x8219D310;
	}
	return 0x8219D310;
} // Block from 8219D2D8h-8219D310h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219D310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D310);
		  /* 8219D310h */ case    0:  		/* addi R9, R9, 4 */
		/* 8219D310h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8219D310h case    0:*/		return 0x8219D314;
		  /* 8219D314h */ case    1:  		/* bc 16, CR0_LT, -40 */
		/* 8219D314h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8219D2EC;  }
		/* 8219D314h case    1:*/		return 0x8219D318;
	}
	return 0x8219D318;
} // Block from 8219D310h-8219D318h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219D318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D318);
		  /* 8219D318h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 8219D318h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8219D318h case    0:*/		return 0x8219D31C;
		  /* 8219D31Ch */ case    1:  		/* addi R9, R30, 10 */
		/* 8219D31Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0xA);
		/* 8219D31Ch case    1:*/		return 0x8219D320;
		  /* 8219D320h */ case    2:  		/* rlwinm R8, R11, 31, 28, 31 */
		/* 8219D320h case    2:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R8,regs.R11);
		/* 8219D320h case    2:*/		return 0x8219D324;
		  /* 8219D324h */ case    3:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 8219D324h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 8219D324h case    3:*/		return 0x8219D328;
		  /* 8219D328h */ case    4:  		/* subf R31, R10, R8 */
		/* 8219D328h case    4:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R10,regs.R8);
		/* 8219D328h case    4:*/		return 0x8219D32C;
		  /* 8219D32Ch */ case    5:  		/* add R29, R11, R27 */
		/* 8219D32Ch case    5:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R27);
		/* 8219D32Ch case    5:*/		return 0x8219D330;
		  /* 8219D330h */ case    6:  		/* cmplwi CR6, R31, 0 */
		/* 8219D330h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219D330h case    6:*/		return 0x8219D334;
		  /* 8219D334h */ case    7:  		/* bc 12, CR6_EQ, 68 */
		/* 8219D334h case    7:*/		if ( regs.CR[6].eq ) { return 0x8219D378;  }
		/* 8219D334h case    7:*/		return 0x8219D338;
		  /* 8219D338h */ case    8:  		/* addi R11, R31, -1 */
		/* 8219D338h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 8219D338h case    8:*/		return 0x8219D33C;
		  /* 8219D33Ch */ case    9:  		/* mr R4, R28 */
		/* 8219D33Ch case    9:*/		regs.R4 = regs.R28;
		/* 8219D33Ch case    9:*/		return 0x8219D340;
		  /* 8219D340h */ case   10:  		/* andc R11, R31, R11 */
		/* 8219D340h case   10:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 8219D340h case   10:*/		return 0x8219D344;
		  /* 8219D344h */ case   11:  		/* mr R3, R24 */
		/* 8219D344h case   11:*/		regs.R3 = regs.R24;
		/* 8219D344h case   11:*/		return 0x8219D348;
		  /* 8219D348h */ case   12:  		/* cntlzw R11, R11 */
		/* 8219D348h case   12:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8219D348h case   12:*/		return 0x8219D34C;
		  /* 8219D34Ch */ case   13:  		/* subfic R5, R11, 31 */
		/* 8219D34Ch case   13:*/		cpu::op::subfic<0>(regs,&regs.R5,regs.R11,0x1F);
		/* 8219D34Ch case   13:*/		return 0x8219D350;
		  /* 8219D350h */ case   14:  		/* bl -152128 */
		/* 8219D350h case   14:*/		regs.LR = 0x8219D354; return 0x82178110;
		/* 8219D350h case   14:*/		return 0x8219D354;
		  /* 8219D354h */ case   15:  		/* mr R4, R3 */
		/* 8219D354h case   15:*/		regs.R4 = regs.R3;
		/* 8219D354h case   15:*/		return 0x8219D358;
		  /* 8219D358h */ case   16:  		/* mr R3, R27 */
		/* 8219D358h case   16:*/		regs.R3 = regs.R27;
		/* 8219D358h case   16:*/		return 0x8219D35C;
		  /* 8219D35Ch */ case   17:  		/* bl -151956 */
		/* 8219D35Ch case   17:*/		regs.LR = 0x8219D360; return 0x821781C8;
		/* 8219D35Ch case   17:*/		return 0x8219D360;
		  /* 8219D360h */ case   18:  		/* addi R11, R31, -1 */
		/* 8219D360h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 8219D360h case   18:*/		return 0x8219D364;
		  /* 8219D364h */ case   19:  		/* stwu R3, <#[R29 + 4]> */
		/* 8219D364h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + 0x00000004) );
		regs.R29 = (uint32)(regs.R29 + 0x00000004);
		/* 8219D364h case   19:*/		return 0x8219D368;
	}
	return 0x8219D368;
} // Block from 8219D318h-8219D368h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219D368h
// Function '?SortIdenticalVectorizationCandidates@Compiler@D3DXShader@@CAHPAVInstruction@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D368);
		  /* 8219D368h */ case    0:  		/* addi R30, R30, 1 */
		/* 8219D368h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8219D368h case    0:*/		return 0x8219D36C;
		  /* 8219D36Ch */ case    1:  		/* andc R11, R31, R11 */
		/* 8219D36Ch case    1:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 8219D36Ch case    1:*/		return 0x8219D370;
		  /* 8219D370h */ case    2:  		/* subf R31, R11, R31 */
		/* 8219D370h case    2:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 8219D370h case    2:*/		return 0x8219D374;
		  /* 8219D374h */ case    3:  		/* b -68 */
		/* 8219D374h case    3:*/		return 0x8219D330;
		/* 8219D374h case    3:*/		return 0x8219D378;
	}
	return 0x8219D378;
} // Block from 8219D368h-8219D378h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219D378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D378);
		  /* 8219D378h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 8219D378h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8219D378h case    0:*/		return 0x8219D37C;
		  /* 8219D37Ch */ case    1:  		/* addi R23, R23, 1 */
		/* 8219D37Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 8219D37Ch case    1:*/		return 0x8219D380;
		  /* 8219D380h */ case    2:  		/* addi R26, R26, 4 */
		/* 8219D380h case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 8219D380h case    2:*/		return 0x8219D384;
		  /* 8219D384h */ case    3:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 8219D384h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 8219D384h case    3:*/		return 0x8219D388;
		  /* 8219D388h */ case    4:  		/* cmplw CR6, R23, R11 */
		/* 8219D388h case    4:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R11);
		/* 8219D388h case    4:*/		return 0x8219D38C;
		  /* 8219D38Ch */ case    5:  		/* bc 12, CR6_LT, -188 */
		/* 8219D38Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x8219D2D0;  }
		/* 8219D38Ch case    5:*/		return 0x8219D390;
	}
	return 0x8219D390;
} // Block from 8219D378h-8219D390h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219D390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D390);
		  /* 8219D390h */ case    0:  		/* mr R3, R30 */
		/* 8219D390h case    0:*/		regs.R3 = regs.R30;
		/* 8219D390h case    0:*/		return 0x8219D394;
		  /* 8219D394h */ case    1:  		/* addi R1, R1, 160 */
		/* 8219D394h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8219D394h case    1:*/		return 0x8219D398;
		  /* 8219D398h */ case    2:  		/* b -1097988 */
		/* 8219D398h case    2:*/		return 0x82091294;
		/* 8219D398h case    2:*/		return 0x8219D39C;
		  /* 8219D39Ch */ case    3:  		/* nop */
		/* 8219D39Ch case    3:*/		cpu::op::nop();
		/* 8219D39Ch case    3:*/		return 0x8219D3A0;
	}
	return 0x8219D3A0;
} // Block from 8219D390h-8219D3A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219D3A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D3A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D3A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D3A0);
		  /* 8219D3A0h */ case    0:  		/* mfspr R12, LR */
		/* 8219D3A0h case    0:*/		regs.R12 = regs.LR;
		/* 8219D3A0h case    0:*/		return 0x8219D3A4;
		  /* 8219D3A4h */ case    1:  		/* bl -1098072 */
		/* 8219D3A4h case    1:*/		regs.LR = 0x8219D3A8; return 0x8209124C;
		/* 8219D3A4h case    1:*/		return 0x8219D3A8;
		  /* 8219D3A8h */ case    2:  		/* stfd FR31, <#[R1 - 72]> */
		/* 8219D3A8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 8219D3A8h case    2:*/		return 0x8219D3AC;
		  /* 8219D3ACh */ case    3:  		/* stwu R1, <#[R1 - 192]> */
		/* 8219D3ACh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 8219D3ACh case    3:*/		return 0x8219D3B0;
		  /* 8219D3B0h */ case    4:  		/* lis R11, -32256 */
		/* 8219D3B0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8219D3B0h case    4:*/		return 0x8219D3B4;
		  /* 8219D3B4h */ case    5:  		/* mr R29, R3 */
		/* 8219D3B4h case    5:*/		regs.R29 = regs.R3;
		/* 8219D3B4h case    5:*/		return 0x8219D3B8;
		  /* 8219D3B8h */ case    6:  		/* mr R26, R4 */
		/* 8219D3B8h case    6:*/		regs.R26 = regs.R4;
		/* 8219D3B8h case    6:*/		return 0x8219D3BC;
		  /* 8219D3BCh */ case    7:  		/* mr R25, R5 */
		/* 8219D3BCh case    7:*/		regs.R25 = regs.R5;
		/* 8219D3BCh case    7:*/		return 0x8219D3C0;
		  /* 8219D3C0h */ case    8:  		/* li R27, 0 */
		/* 8219D3C0h case    8:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8219D3C0h case    8:*/		return 0x8219D3C4;
		  /* 8219D3C4h */ case    9:  		/* lfs FR31, <#[R11 + 1816]> */
		/* 8219D3C4h case    9:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000718) );
		/* 8219D3C4h case    9:*/		return 0x8219D3C8;
		  /* 8219D3C8h */ case   10:  		/* addi R28, R4, 44 */
		/* 8219D3C8h case   10:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R4,0x2C);
		/* 8219D3C8h case   10:*/		return 0x8219D3CC;
		  /* 8219D3CCh */ case   11:  		/* lwz R11, <#[R26 + 8]> */
		/* 8219D3CCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 8219D3CCh case   11:*/		return 0x8219D3D0;
		  /* 8219D3D0h */ case   12:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 8219D3D0h case   12:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 8219D3D0h case   12:*/		return 0x8219D3D4;
		  /* 8219D3D4h */ case   13:  		/* cmplw CR6, R27, R11 */
		/* 8219D3D4h case   13:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 8219D3D4h case   13:*/		return 0x8219D3D8;
		  /* 8219D3D8h */ case   14:  		/* bc 4, CR6_LT, 340 */
		/* 8219D3D8h case   14:*/		if ( !regs.CR[6].lt ) { return 0x8219D52C;  }
		/* 8219D3D8h case   14:*/		return 0x8219D3DC;
		  /* 8219D3DCh */ case   15:  		/* lwz R31, <#[R28]> */
		/* 8219D3DCh case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 8219D3DCh case   15:*/		return 0x8219D3E0;
		  /* 8219D3E0h */ case   16:  		/* lwz R4, <#[R31 + 12]> */
		/* 8219D3E0h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219D3E0h case   16:*/		return 0x8219D3E4;
		  /* 8219D3E4h */ case   17:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219D3E4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219D3E4h case   17:*/		return 0x8219D3E8;
		  /* 8219D3E8h */ case   18:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219D3E8h case   18:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219D3E8h case   18:*/		return 0x8219D3EC;
		  /* 8219D3ECh */ case   19:  		/* cmplwi CR6, R11, 16000 */
		/* 8219D3ECh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8219D3ECh case   19:*/		return 0x8219D3F0;
		  /* 8219D3F0h */ case   20:  		/* bc 4, CR6_EQ, 292 */
		/* 8219D3F0h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8219D514;  }
		/* 8219D3F0h case   20:*/		return 0x8219D3F4;
		  /* 8219D3F4h */ case   21:  		/* lwz R11, <#[R31]> */
		/* 8219D3F4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219D3F4h case   21:*/		return 0x8219D3F8;
		  /* 8219D3F8h */ case   22:  		/* addi R8, R1, 96 */
		/* 8219D3F8h case   22:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 8219D3F8h case   22:*/		return 0x8219D3FC;
		  /* 8219D3FCh */ case   23:  		/* mr R3, R29 */
		/* 8219D3FCh case   23:*/		regs.R3 = regs.R29;
		/* 8219D3FCh case   23:*/		return 0x8219D400;
		  /* 8219D400h */ case   24:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 8219D400h case   24:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 8219D400h case   24:*/		return 0x8219D404;
		  /* 8219D404h */ case   25:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 8219D404h case   25:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 8219D404h case   25:*/		return 0x8219D408;
		  /* 8219D408h */ case   26:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 8219D408h case   26:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 8219D408h case   26:*/		return 0x8219D40C;
		  /* 8219D40Ch */ case   27:  		/* bl -8588 */
		/* 8219D40Ch case   27:*/		regs.LR = 0x8219D410; return 0x8219B280;
		/* 8219D40Ch case   27:*/		return 0x8219D410;
		  /* 8219D410h */ case   28:  		/* addi R11, R1, 80 */
		/* 8219D410h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8219D410h case   28:*/		return 0x8219D414;
		  /* 8219D414h */ case   29:  		/* li R10, 0 */
		/* 8219D414h case   29:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219D414h case   29:*/		return 0x8219D418;
		  /* 8219D418h */ case   30:  		/* addi R5, R1, 96 */
		/* 8219D418h case   30:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8219D418h case   30:*/		return 0x8219D41C;
		  /* 8219D41Ch */ case   31:  		/* mr R3, R29 */
		/* 8219D41Ch case   31:*/		regs.R3 = regs.R29;
		/* 8219D41Ch case   31:*/		return 0x8219D420;
		  /* 8219D420h */ case   32:  		/* stw R10, <#[R11]> */
		/* 8219D420h case   32:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219D420h case   32:*/		return 0x8219D424;
		  /* 8219D424h */ case   33:  		/* lwz R11, <#[R31]> */
		/* 8219D424h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219D424h case   33:*/		return 0x8219D428;
		  /* 8219D428h */ case   34:  		/* rlwinm R4, R11, 7, 29, 31 */
		/* 8219D428h case   34:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R4,regs.R11);
		/* 8219D428h case   34:*/		return 0x8219D42C;
		  /* 8219D42Ch */ case   35:  		/* lwz R6, <#[R1 + 80]> */
		/* 8219D42Ch case   35:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8219D42Ch case   35:*/		return 0x8219D430;
		  /* 8219D430h */ case   36:  		/* bl 564232 */
		/* 8219D430h case   36:*/		regs.LR = 0x8219D434; return 0x82227038;
		/* 8219D430h case   36:*/		return 0x8219D434;
		  /* 8219D434h */ case   37:  		/* lwz R11, <#[R31 + 12]> */
		/* 8219D434h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219D434h case   37:*/		return 0x8219D438;
		  /* 8219D438h */ case   38:  		/* mr R30, R3 */
		/* 8219D438h case   38:*/		regs.R30 = regs.R3;
		/* 8219D438h case   38:*/		return 0x8219D43C;
		  /* 8219D43Ch */ case   39:  		/* addi R11, R11, 4 */
		/* 8219D43Ch case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219D43Ch case   39:*/		return 0x8219D440;
		  /* 8219D440h */ case   40:  		/* lwz R10, <#[R11]> */
		/* 8219D440h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219D440h case   40:*/		return 0x8219D444;
		  /* 8219D444h */ case   41:  		/* b 12 */
		/* 8219D444h case   41:*/		return 0x8219D450;
		/* 8219D444h case   41:*/		return 0x8219D448;
		  /* 8219D448h */ case   42:  		/* addi R11, R10, 8 */
		/* 8219D448h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 8219D448h case   42:*/		return 0x8219D44C;
		  /* 8219D44Ch */ case   43:  		/* lwz R10, <#[R10 + 8]> */
		/* 8219D44Ch case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 8219D44Ch case   43:*/		return 0x8219D450;
	}
	return 0x8219D450;
} // Block from 8219D3A0h-8219D450h (44 instructions)

//////////////////////////////////////////////////////
// Block at 8219D450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D450);
		  /* 8219D450h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 8219D450h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 8219D450h case    0:*/		return 0x8219D454;
		  /* 8219D454h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8219D454h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219D448;  }
		/* 8219D454h case    1:*/		return 0x8219D458;
		  /* 8219D458h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219D458h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219D458h case    2:*/		return 0x8219D45C;
		  /* 8219D45Ch */ case    3:  		/* li R9, 57 */
		/* 8219D45Ch case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x39);
		/* 8219D45Ch case    3:*/		return 0x8219D460;
		  /* 8219D460h */ case    4:  		/* mr R3, R30 */
		/* 8219D460h case    4:*/		regs.R3 = regs.R30;
		/* 8219D460h case    4:*/		return 0x8219D464;
		  /* 8219D464h */ case    5:  		/* stw R10, <#[R11]> */
		/* 8219D464h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219D464h case    5:*/		return 0x8219D468;
		  /* 8219D468h */ case    6:  		/* lwz R11, <#[R30 + 4]> */
		/* 8219D468h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8219D468h case    6:*/		return 0x8219D46C;
		  /* 8219D46Ch */ case    7:  		/* stw R11, <#[R31 + 8]> */
		/* 8219D46Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219D46Ch case    7:*/		return 0x8219D470;
		  /* 8219D470h */ case    8:  		/* stw R31, <#[R30 + 4]> */
		/* 8219D470h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 8219D470h case    8:*/		return 0x8219D474;
		  /* 8219D474h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 8219D474h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219D474h case    9:*/		return 0x8219D478;
		  /* 8219D478h */ case   10:  		/* rlwimi R11, R9, 7, 19, 26 */
		/* 8219D478h case   10:*/		cpu::op::rlwimi<0,7,19,26>(regs,&regs.R11,regs.R9);
		/* 8219D478h case   10:*/		return 0x8219D47C;
		  /* 8219D47Ch */ case   11:  		/* stw R30, <#[R31 + 12]> */
		/* 8219D47Ch case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219D47Ch case   11:*/		return 0x8219D480;
		  /* 8219D480h */ case   12:  		/* stw R11, <#[R31]> */
		/* 8219D480h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219D480h case   12:*/		return 0x8219D484;
		  /* 8219D484h */ case   13:  		/* bl -28884 */
		/* 8219D484h case   13:*/		regs.LR = 0x8219D488; return 0x821963B0;
		/* 8219D484h case   13:*/		return 0x8219D488;
		  /* 8219D488h */ case   14:  		/* rlwinm. R11, R25, 0, 29, 29 */
		/* 8219D488h case   14:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R25);
		/* 8219D488h case   14:*/		return 0x8219D48C;
		  /* 8219D48Ch */ case   15:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219D48Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219D48Ch case   15:*/		return 0x8219D490;
		  /* 8219D490h */ case   16:  		/* oris R11, R11, 256 */
		/* 8219D490h case   16:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 8219D490h case   16:*/		return 0x8219D494;
		  /* 8219D494h */ case   17:  		/* stw R11, <#[R30 + 8]> */
		/* 8219D494h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219D494h case   17:*/		return 0x8219D498;
		  /* 8219D498h */ case   18:  		/* bc 12, CR0_EQ, 112 */
		/* 8219D498h case   18:*/		if ( regs.CR[0].eq ) { return 0x8219D508;  }
		/* 8219D498h case   18:*/		return 0x8219D49C;
		  /* 8219D49Ch */ case   19:  		/* lfs FR0, <#[R1 + 96]> */
		/* 8219D49Ch case   19:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 8219D49Ch case   19:*/		return 0x8219D4A0;
		  /* 8219D4A0h */ case   20:  		/* fcmpu CR6, FR0, FR31 */
		/* 8219D4A0h case   20:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 8219D4A0h case   20:*/		return 0x8219D4A4;
		  /* 8219D4A4h */ case   21:  		/* bc 4, CR6_LT, 84 */
		/* 8219D4A4h case   21:*/		if ( !regs.CR[6].lt ) { return 0x8219D4F8;  }
		/* 8219D4A4h case   21:*/		return 0x8219D4A8;
		  /* 8219D4A8h */ case   22:  		/* lwz R10, <#[R31]> */
		/* 8219D4A8h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8219D4A8h case   22:*/		return 0x8219D4AC;
		  /* 8219D4ACh */ case   23:  		/* lis R9, 512 */
		/* 8219D4ACh case   23:*/		cpu::op::lis<0>(regs,&regs.R9,0x200);
		/* 8219D4ACh case   23:*/		return 0x8219D4B0;
		  /* 8219D4B0h */ case   24:  		/* li R11, 1 */
		/* 8219D4B0h case   24:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219D4B0h case   24:*/		return 0x8219D4B4;
		  /* 8219D4B4h */ case   25:  		/* rlwinm R8, R10, 0, 4, 6 */
		/* 8219D4B4h case   25:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R8,regs.R10);
		/* 8219D4B4h case   25:*/		return 0x8219D4B8;
		  /* 8219D4B8h */ case   26:  		/* cmplw CR6, R8, R9 */
		/* 8219D4B8h case   26:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8219D4B8h case   26:*/		return 0x8219D4BC;
		  /* 8219D4BCh */ case   27:  		/* bc 4, CR6_GT, 44 */
		/* 8219D4BCh case   27:*/		if ( !regs.CR[6].gt ) { return 0x8219D4E8;  }
		/* 8219D4BCh case   27:*/		return 0x8219D4C0;
		  /* 8219D4C0h */ case   28:  		/* addi R9, R1, 100 */
		/* 8219D4C0h case   28:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x64);
		/* 8219D4C0h case   28:*/		return 0x8219D4C4;
		  /* 8219D4C4h */ case   29:  		/* lfs FR0, <#[R9]> */
		/* 8219D4C4h case   29:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000000) );
		/* 8219D4C4h case   29:*/		return 0x8219D4C8;
		  /* 8219D4C8h */ case   30:  		/* fcmpu CR6, FR0, FR31 */
		/* 8219D4C8h case   30:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 8219D4C8h case   30:*/		return 0x8219D4CC;
		  /* 8219D4CCh */ case   31:  		/* bc 12, CR6_GT, 84 */
		/* 8219D4CCh case   31:*/		if ( regs.CR[6].gt ) { return 0x8219D520;  }
		/* 8219D4CCh case   31:*/		return 0x8219D4D0;
		  /* 8219D4D0h */ case   32:  		/* lwz R8, <#[R31]> */
		/* 8219D4D0h case   32:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8219D4D0h case   32:*/		return 0x8219D4D4;
		  /* 8219D4D4h */ case   33:  		/* addi R11, R11, 1 */
		/* 8219D4D4h case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219D4D4h case   33:*/		return 0x8219D4D8;
		  /* 8219D4D8h */ case   34:  		/* addi R9, R9, 4 */
		/* 8219D4D8h case   34:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 8219D4D8h case   34:*/		return 0x8219D4DC;
		  /* 8219D4DCh */ case   35:  		/* rlwinm R8, R8, 7, 29, 31 */
		/* 8219D4DCh case   35:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R8,regs.R8);
		/* 8219D4DCh case   35:*/		return 0x8219D4E0;
		  /* 8219D4E0h */ case   36:  		/* cmplw CR6, R11, R8 */
		/* 8219D4E0h case   36:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8219D4E0h case   36:*/		return 0x8219D4E4;
		  /* 8219D4E4h */ case   37:  		/* bc 12, CR6_LT, -32 */
		/* 8219D4E4h case   37:*/		if ( regs.CR[6].lt ) { return 0x8219D4C4;  }
		/* 8219D4E4h case   37:*/		return 0x8219D4E8;
	}
	return 0x8219D4E8;
} // Block from 8219D450h-8219D4E8h (38 instructions)

//////////////////////////////////////////////////////
// Block at 8219D4E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D4E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D4E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D4E8);
		  /* 8219D4E8h */ case    0:  		/* li R11, 3 */
		/* 8219D4E8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 8219D4E8h case    0:*/		return 0x8219D4EC;
		  /* 8219D4ECh */ case    1:  		/* rlwimi R10, R11, 1, 27, 31 */
		/* 8219D4ECh case    1:*/		cpu::op::rlwimi<0,1,27,31>(regs,&regs.R10,regs.R11);
		/* 8219D4ECh case    1:*/		return 0x8219D4F0;
		  /* 8219D4F0h */ case    2:  		/* stw R10, <#[R31]> */
		/* 8219D4F0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8219D4F0h case    2:*/		return 0x8219D4F4;
		  /* 8219D4F4h */ case    3:  		/* b 32 */
		/* 8219D4F4h case    3:*/		return 0x8219D514;
		/* 8219D4F4h case    3:*/		return 0x8219D4F8;
	}
	return 0x8219D4F8;
} // Block from 8219D4E8h-8219D4F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219D4F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D4F8);
		  /* 8219D4F8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8219D4F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219D4F8h case    0:*/		return 0x8219D4FC;
		  /* 8219D4FCh */ case    1:  		/* li R10, 1 */
		/* 8219D4FCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219D4FCh case    1:*/		return 0x8219D500;
		  /* 8219D500h */ case    2:  		/* rlwimi R11, R10, 1, 27, 31 */
		/* 8219D500h case    2:*/		cpu::op::rlwimi<0,1,27,31>(regs,&regs.R11,regs.R10);
		/* 8219D500h case    2:*/		return 0x8219D504;
		  /* 8219D504h */ case    3:  		/* b 12 */
		/* 8219D504h case    3:*/		return 0x8219D510;
		/* 8219D504h case    3:*/		return 0x8219D508;
	}
	return 0x8219D508;
} // Block from 8219D4F8h-8219D508h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219D508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D508);
		  /* 8219D508h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8219D508h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219D508h case    0:*/		return 0x8219D50C;
		  /* 8219D50Ch */ case    1:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 8219D50Ch case    1:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 8219D50Ch case    1:*/		return 0x8219D510;
	}
	return 0x8219D510;
} // Block from 8219D508h-8219D510h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219D510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D510);
		  /* 8219D510h */ case    0:  		/* stw R11, <#[R31]> */
		/* 8219D510h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219D510h case    0:*/		return 0x8219D514;
	}
	return 0x8219D514;
} // Block from 8219D510h-8219D514h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219D514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D514);
		  /* 8219D514h */ case    0:  		/* addi R27, R27, 1 */
		/* 8219D514h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 8219D514h case    0:*/		return 0x8219D518;
		  /* 8219D518h */ case    1:  		/* addi R28, R28, 4 */
		/* 8219D518h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8219D518h case    1:*/		return 0x8219D51C;
		  /* 8219D51Ch */ case    2:  		/* b -336 */
		/* 8219D51Ch case    2:*/		return 0x8219D3CC;
		/* 8219D51Ch case    2:*/		return 0x8219D520;
	}
	return 0x8219D520;
} // Block from 8219D514h-8219D520h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219D520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D520);
		  /* 8219D520h */ case    0:  		/* li R4, 4800 */
		/* 8219D520h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8219D520h case    0:*/		return 0x8219D524;
		  /* 8219D524h */ case    1:  		/* mr R3, R29 */
		/* 8219D524h case    1:*/		regs.R3 = regs.R29;
		/* 8219D524h case    1:*/		return 0x8219D528;
		  /* 8219D528h */ case    2:  		/* bl -308928 */
		/* 8219D528h case    2:*/		regs.LR = 0x8219D52C; return 0x82151E68;
		/* 8219D528h case    2:*/		return 0x8219D52C;
	}
	return 0x8219D52C;
} // Block from 8219D520h-8219D52Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219D52Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D52C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D52C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D52C);
		  /* 8219D52Ch */ case    0:  		/* addi R1, R1, 192 */
		/* 8219D52Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 8219D52Ch case    0:*/		return 0x8219D530;
		  /* 8219D530h */ case    1:  		/* lfd FR31, <#[R1 - 72]> */
		/* 8219D530h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 8219D530h case    1:*/		return 0x8219D534;
		  /* 8219D534h */ case    2:  		/* b -1098392 */
		/* 8219D534h case    2:*/		return 0x8209129C;
		/* 8219D534h case    2:*/		return 0x8219D538;
	}
	return 0x8219D538;
} // Block from 8219D52Ch-8219D538h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219D538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D538);
		  /* 8219D538h */ case    0:  		/* mfspr R12, LR */
		/* 8219D538h case    0:*/		regs.R12 = regs.LR;
		/* 8219D538h case    0:*/		return 0x8219D53C;
		  /* 8219D53Ch */ case    1:  		/* bl -1098472 */
		/* 8219D53Ch case    1:*/		regs.LR = 0x8219D540; return 0x82091254;
		/* 8219D53Ch case    1:*/		return 0x8219D540;
		  /* 8219D540h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219D540h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219D540h case    2:*/		return 0x8219D544;
		  /* 8219D544h */ case    3:  		/* mr R27, R3 */
		/* 8219D544h case    3:*/		regs.R27 = regs.R3;
		/* 8219D544h case    3:*/		return 0x8219D548;
		  /* 8219D548h */ case    4:  		/* mr R29, R4 */
		/* 8219D548h case    4:*/		regs.R29 = regs.R4;
		/* 8219D548h case    4:*/		return 0x8219D54C;
		  /* 8219D54Ch */ case    5:  		/* li R31, 0 */
		/* 8219D54Ch case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8219D54Ch case    5:*/		return 0x8219D550;
		  /* 8219D550h */ case    6:  		/* li R28, 0 */
		/* 8219D550h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8219D550h case    6:*/		return 0x8219D554;
		  /* 8219D554h */ case    7:  		/* addi R30, R4, 44 */
		/* 8219D554h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R4,0x2C);
		/* 8219D554h case    7:*/		return 0x8219D558;
		  /* 8219D558h */ case    8:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219D558h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219D558h case    8:*/		return 0x8219D55C;
		  /* 8219D55Ch */ case    9:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 8219D55Ch case    9:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 8219D55Ch case    9:*/		return 0x8219D560;
		  /* 8219D560h */ case   10:  		/* cmplw CR6, R28, R11 */
		/* 8219D560h case   10:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8219D560h case   10:*/		return 0x8219D564;
		  /* 8219D564h */ case   11:  		/* bc 4, CR6_LT, 96 */
		/* 8219D564h case   11:*/		if ( !regs.CR[6].lt ) { return 0x8219D5C4;  }
		/* 8219D564h case   11:*/		return 0x8219D568;
		  /* 8219D568h */ case   12:  		/* lwz R10, <#[R30]> */
		/* 8219D568h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8219D568h case   12:*/		return 0x8219D56C;
		  /* 8219D56Ch */ case   13:  		/* lwz R4, <#[R10 + 12]> */
		/* 8219D56Ch case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219D56Ch case   13:*/		return 0x8219D570;
		  /* 8219D570h */ case   14:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219D570h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219D570h case   14:*/		return 0x8219D574;
		  /* 8219D574h */ case   15:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219D574h case   15:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219D574h case   15:*/		return 0x8219D578;
		  /* 8219D578h */ case   16:  		/* cmplwi CR6, R11, 125 */
		/* 8219D578h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219D578h case   16:*/		return 0x8219D57C;
		  /* 8219D57Ch */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 8219D57Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x8219D58C;  }
		/* 8219D57Ch case   17:*/		return 0x8219D580;
		  /* 8219D580h */ case   18:  		/* cmplwi CR6, R11, 124 */
		/* 8219D580h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219D580h case   18:*/		return 0x8219D584;
		  /* 8219D584h */ case   19:  		/* li R11, 0 */
		/* 8219D584h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219D584h case   19:*/		return 0x8219D588;
		  /* 8219D588h */ case   20:  		/* bc 4, CR6_EQ, 8 */
		/* 8219D588h case   20:*/		if ( !regs.CR[6].eq ) { return 0x8219D590;  }
		/* 8219D588h case   20:*/		return 0x8219D58C;
	}
	return 0x8219D58C;
} // Block from 8219D538h-8219D58Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8219D58Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D58C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D58C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D58C);
		  /* 8219D58Ch */ case    0:  		/* li R11, 1 */
		/* 8219D58Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219D58Ch case    0:*/		return 0x8219D590;
	}
	return 0x8219D590;
} // Block from 8219D58Ch-8219D590h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219D590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D590);
		  /* 8219D590h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219D590h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219D590h case    0:*/		return 0x8219D594;
		  /* 8219D594h */ case    1:  		/* bc 12, CR0_EQ, 36 */
		/* 8219D594h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219D5B8;  }
		/* 8219D594h case    1:*/		return 0x8219D598;
		  /* 8219D598h */ case    2:  		/* lwz R11, <#[R10]> */
		/* 8219D598h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8219D598h case    2:*/		return 0x8219D59C;
		  /* 8219D59Ch */ case    3:  		/* addi R8, R1, 80 */
		/* 8219D59Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 8219D59Ch case    3:*/		return 0x8219D5A0;
		  /* 8219D5A0h */ case    4:  		/* mr R3, R27 */
		/* 8219D5A0h case    4:*/		regs.R3 = regs.R27;
		/* 8219D5A0h case    4:*/		return 0x8219D5A4;
		  /* 8219D5A4h */ case    5:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 8219D5A4h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 8219D5A4h case    5:*/		return 0x8219D5A8;
	}
	return 0x8219D5A8;
} // Block from 8219D590h-8219D5A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219D5A8h
// Function '?AddDotProductMulCombinationBenefit@Compiler@D3DXShader@@AAAXPAUPossibleVectorization@2@PAVInstruction@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D5A8);
		  /* 8219D5A8h */ case    0:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 8219D5A8h case    0:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 8219D5A8h case    0:*/		return 0x8219D5AC;
		  /* 8219D5ACh */ case    1:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 8219D5ACh case    1:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 8219D5ACh case    1:*/		return 0x8219D5B0;
		  /* 8219D5B0h */ case    2:  		/* bl -9008 */
		/* 8219D5B0h case    2:*/		regs.LR = 0x8219D5B4; return 0x8219B280;
		/* 8219D5B0h case    2:*/		return 0x8219D5B4;
		  /* 8219D5B4h */ case    3:  		/* or R31, R3, R31 */
		/* 8219D5B4h case    3:*/		cpu::op::or<0>(regs,&regs.R31,regs.R3,regs.R31);
		/* 8219D5B4h case    3:*/		return 0x8219D5B8;
	}
	return 0x8219D5B8;
} // Block from 8219D5A8h-8219D5B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219D5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D5B8);
		  /* 8219D5B8h */ case    0:  		/* addi R28, R28, 1 */
		/* 8219D5B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 8219D5B8h case    0:*/		return 0x8219D5BC;
		  /* 8219D5BCh */ case    1:  		/* addi R30, R30, 4 */
		/* 8219D5BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8219D5BCh case    1:*/		return 0x8219D5C0;
		  /* 8219D5C0h */ case    2:  		/* b -104 */
		/* 8219D5C0h case    2:*/		return 0x8219D558;
		/* 8219D5C0h case    2:*/		return 0x8219D5C4;
	}
	return 0x8219D5C4;
} // Block from 8219D5B8h-8219D5C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219D5C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D5C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D5C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D5C4);
		  /* 8219D5C4h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8219D5C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219D5C4h case    0:*/		return 0x8219D5C8;
		  /* 8219D5C8h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 8219D5C8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219D5DC;  }
		/* 8219D5C8h case    1:*/		return 0x8219D5CC;
		  /* 8219D5CCh */ case    2:  		/* mr R5, R31 */
		/* 8219D5CCh case    2:*/		regs.R5 = regs.R31;
		/* 8219D5CCh case    2:*/		return 0x8219D5D0;
		  /* 8219D5D0h */ case    3:  		/* mr R4, R29 */
		/* 8219D5D0h case    3:*/		regs.R4 = regs.R29;
		/* 8219D5D0h case    3:*/		return 0x8219D5D4;
		  /* 8219D5D4h */ case    4:  		/* mr R3, R27 */
		/* 8219D5D4h case    4:*/		regs.R3 = regs.R27;
		/* 8219D5D4h case    4:*/		return 0x8219D5D8;
		  /* 8219D5D8h */ case    5:  		/* bl -568 */
		/* 8219D5D8h case    5:*/		regs.LR = 0x8219D5DC; return 0x8219D3A0;
		/* 8219D5D8h case    5:*/		return 0x8219D5DC;
	}
	return 0x8219D5DC;
} // Block from 8219D5C4h-8219D5DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219D5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D5DC);
		  /* 8219D5DCh */ case    0:  		/* addi R1, R1, 144 */
		/* 8219D5DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219D5DCh case    0:*/		return 0x8219D5E0;
		  /* 8219D5E0h */ case    1:  		/* b -1098556 */
		/* 8219D5E0h case    1:*/		return 0x820912A4;
		/* 8219D5E0h case    1:*/		return 0x8219D5E4;
		  /* 8219D5E4h */ case    2:  		/* nop */
		/* 8219D5E4h case    2:*/		cpu::op::nop();
		/* 8219D5E4h case    2:*/		return 0x8219D5E8;
	}
	return 0x8219D5E8;
} // Block from 8219D5DCh-8219D5E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219D5E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D5E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D5E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D5E8);
		  /* 8219D5E8h */ case    0:  		/* mfspr R12, LR */
		/* 8219D5E8h case    0:*/		regs.R12 = regs.LR;
		/* 8219D5E8h case    0:*/		return 0x8219D5EC;
		  /* 8219D5ECh */ case    1:  		/* bl -1098652 */
		/* 8219D5ECh case    1:*/		regs.LR = 0x8219D5F0; return 0x82091250;
		/* 8219D5ECh case    1:*/		return 0x8219D5F0;
		  /* 8219D5F0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8219D5F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8219D5F0h case    2:*/		return 0x8219D5F4;
		  /* 8219D5F4h */ case    3:  		/* lwz R31, <#[R1 + 252]> */
		/* 8219D5F4h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x000000FC) );
		/* 8219D5F4h case    3:*/		return 0x8219D5F8;
		  /* 8219D5F8h */ case    4:  		/* mr R27, R4 */
		/* 8219D5F8h case    4:*/		regs.R27 = regs.R4;
		/* 8219D5F8h case    4:*/		return 0x8219D5FC;
		  /* 8219D5FCh */ case    5:  		/* mr R28, R3 */
		/* 8219D5FCh case    5:*/		regs.R28 = regs.R3;
		/* 8219D5FCh case    5:*/		return 0x8219D600;
		  /* 8219D600h */ case    6:  		/* lwz R3, <#[R1 + 244]> */
		/* 8219D600h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000000F4) );
		/* 8219D600h case    6:*/		return 0x8219D604;
		  /* 8219D604h */ case    7:  		/* addi R11, R31, 12 */
		/* 8219D604h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xC);
		/* 8219D604h case    7:*/		return 0x8219D608;
		  /* 8219D608h */ case    8:  		/* addi R4, R31, 164 */
		/* 8219D608h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xA4);
		/* 8219D608h case    8:*/		return 0x8219D60C;
		  /* 8219D60Ch */ case    9:  		/* mr R29, R8 */
		/* 8219D60Ch case    9:*/		regs.R29 = regs.R8;
		/* 8219D60Ch case    9:*/		return 0x8219D610;
		  /* 8219D610h */ case   10:  		/* lwz R26, <#[R31 + 28]> */
		/* 8219D610h case   10:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x0000001C) );
		/* 8219D610h case   10:*/		return 0x8219D614;
		  /* 8219D614h */ case   11:  		/* mr R30, R10 */
		/* 8219D614h case   11:*/		regs.R30 = regs.R10;
		/* 8219D614h case   11:*/		return 0x8219D618;
		  /* 8219D618h */ case   12:  		/* stw R3, <#[R1 + 84]> */
		/* 8219D618h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8219D618h case   12:*/		return 0x8219D61C;
		  /* 8219D61Ch */ case   13:  		/* mr R3, R28 */
		/* 8219D61Ch case   13:*/		regs.R3 = regs.R28;
		/* 8219D61Ch case   13:*/		return 0x8219D620;
		  /* 8219D620h */ case   14:  		/* rlwinm R26, R26, 2, 0, 29 */
		/* 8219D620h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R26,regs.R26);
		/* 8219D620h case   14:*/		return 0x8219D624;
		  /* 8219D624h */ case   15:  		/* stw R31, <#[R1 + 92]> */
		/* 8219D624h case   15:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000005C) );
		/* 8219D624h case   15:*/		return 0x8219D628;
		  /* 8219D628h */ case   16:  		/* stwx R9, <#[R26 + R11]> */
		/* 8219D628h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 8219D628h case   16:*/		return 0x8219D62C;
		  /* 8219D62Ch */ case   17:  		/* lwz R11, <#[R31 + 28]> */
		/* 8219D62Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8219D62Ch case   17:*/		return 0x8219D630;
		  /* 8219D630h */ case   18:  		/* addi R11, R11, 1 */
		/* 8219D630h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219D630h case   18:*/		return 0x8219D634;
		  /* 8219D634h */ case   19:  		/* stw R11, <#[R31 + 28]> */
		/* 8219D634h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8219D634h case   19:*/		return 0x8219D638;
		  /* 8219D638h */ case   20:  		/* lwz R11, <#[R31 + 196]> */
		/* 8219D638h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 8219D638h case   20:*/		return 0x8219D63C;
		  /* 8219D63Ch */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8219D63Ch case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8219D63Ch case   21:*/		return 0x8219D640;
		  /* 8219D640h */ case   22:  		/* stwx R27, <#[R11 + R4]> */
		/* 8219D640h case   22:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 8219D640h case   22:*/		return 0x8219D644;
		  /* 8219D644h */ case   23:  		/* mr R4, R27 */
		/* 8219D644h case   23:*/		regs.R4 = regs.R27;
		/* 8219D644h case   23:*/		return 0x8219D648;
		  /* 8219D648h */ case   24:  		/* lwz R11, <#[R31 + 196]> */
		/* 8219D648h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 8219D648h case   24:*/		return 0x8219D64C;
		  /* 8219D64Ch */ case   25:  		/* addi R11, R11, 1 */
		/* 8219D64Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219D64Ch case   25:*/		return 0x8219D650;
		  /* 8219D650h */ case   26:  		/* stw R11, <#[R31 + 196]> */
		/* 8219D650h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 8219D650h case   26:*/		return 0x8219D654;
		  /* 8219D654h */ case   27:  		/* bl -5516 */
		/* 8219D654h case   27:*/		regs.LR = 0x8219D658; return 0x8219C0C8;
		/* 8219D654h case   27:*/		return 0x8219D658;
		  /* 8219D658h */ case   28:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219D658h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219D658h case   28:*/		return 0x8219D65C;
		  /* 8219D65Ch */ case   29:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219D65Ch case   29:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219D65Ch case   29:*/		return 0x8219D660;
		  /* 8219D660h */ case   30:  		/* cmplwi CR6, R11, 256 */
		/* 8219D660h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000100);
		/* 8219D660h case   30:*/		return 0x8219D664;
		  /* 8219D664h */ case   31:  		/* bc 4, CR6_EQ, 372 */
		/* 8219D664h case   31:*/		if ( !regs.CR[6].eq ) { return 0x8219D7D8;  }
		/* 8219D664h case   31:*/		return 0x8219D668;
	}
	return 0x8219D668;
} // Block from 8219D5E8h-8219D668h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8219D668h
// Function '?SortVectorizeDependentInstructionState@Compiler@D3DXShader@@CAHPBX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D668);
		  /* 8219D668h */ case    0:  		/* rlwinm. R11, R30, 0, 30, 28 */
		/* 8219D668h case    0:*/		cpu::op::rlwinm<1,0,30,28>(regs,&regs.R11,regs.R30);
		/* 8219D668h case    0:*/		return 0x8219D66C;
		  /* 8219D66Ch */ case    1:  		/* bc 4, CR0_EQ, 364 */
		/* 8219D66Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219D7D8;  }
		/* 8219D66Ch case    1:*/		return 0x8219D670;
		  /* 8219D670h */ case    2:  		/* lwz R7, <#[R31 + 28]> */
		/* 8219D670h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000001C) );
		/* 8219D670h case    2:*/		return 0x8219D674;
		  /* 8219D674h */ case    3:  		/* cmplwi CR6, R7, 2 */
		/* 8219D674h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000002);
		/* 8219D674h case    3:*/		return 0x8219D678;
		  /* 8219D678h */ case    4:  		/* bc 4, CR6_EQ, 20 */
		/* 8219D678h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8219D68C;  }
		/* 8219D678h case    4:*/		return 0x8219D67C;
		  /* 8219D67Ch */ case    5:  		/* lwz R11, <#[R31 + 160]> */
		/* 8219D67Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219D67Ch case    5:*/		return 0x8219D680;
		  /* 8219D680h */ case    6:  		/* cmplwi CR6, R11, 1 */
		/* 8219D680h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8219D680h case    6:*/		return 0x8219D684;
		  /* 8219D684h */ case    7:  		/* bc 4, CR6_LT, 12 */
		/* 8219D684h case    7:*/		if ( !regs.CR[6].lt ) { return 0x8219D690;  }
		/* 8219D684h case    7:*/		return 0x8219D688;
		  /* 8219D688h */ case    8:  		/* cmplwi CR6, R7, 2 */
		/* 8219D688h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000002);
		/* 8219D688h case    8:*/		return 0x8219D68C;
	}
	return 0x8219D68C;
} // Block from 8219D668h-8219D68Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219D68Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D68C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D68C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D68C);
		  /* 8219D68Ch */ case    0:  		/* bc 4, CR6_GT, 332 */
		/* 8219D68Ch case    0:*/		if ( !regs.CR[6].gt ) { return 0x8219D7D8;  }
		/* 8219D68Ch case    0:*/		return 0x8219D690;
	}
	return 0x8219D690;
} // Block from 8219D68Ch-8219D690h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219D690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D690);
		  /* 8219D690h */ case    0:  		/* lwz R10, <#[R29 + 44]> */
		/* 8219D690h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000002C) );
		/* 8219D690h case    0:*/		return 0x8219D694;
		  /* 8219D694h */ case    1:  		/* lwz R8, <#[R29 + 48]> */
		/* 8219D694h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000030) );
		/* 8219D694h case    1:*/		return 0x8219D698;
		  /* 8219D698h */ case    2:  		/* lwz R9, <#[R10]> */
		/* 8219D698h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8219D698h case    2:*/		return 0x8219D69C;
		  /* 8219D69Ch */ case    3:  		/* rlwinm. R6, R9, 0, 27, 28 */
		/* 8219D69Ch case    3:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R6,regs.R9);
		/* 8219D69Ch case    3:*/		return 0x8219D6A0;
		  /* 8219D6A0h */ case    4:  		/* rlwinm R11, R9, 0, 27, 31 */
		/* 8219D6A0h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R9);
		/* 8219D6A0h case    4:*/		return 0x8219D6A4;
		  /* 8219D6A4h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 8219D6A4h case    5:*/		if ( regs.CR[0].eq ) { return 0x8219D6B8;  }
		/* 8219D6A4h case    5:*/		return 0x8219D6A8;
		  /* 8219D6A8h */ case    6:  		/* rlwinm. R6, R30, 0, 27, 28 */
		/* 8219D6A8h case    6:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R6,regs.R30);
		/* 8219D6A8h case    6:*/		return 0x8219D6AC;
		  /* 8219D6ACh */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8219D6ACh case    7:*/		if ( regs.CR[0].eq ) { return 0x8219D6B8;  }
		/* 8219D6ACh case    7:*/		return 0x8219D6B0;
		  /* 8219D6B0h */ case    8:  		/* li R11, 0 */
		/* 8219D6B0h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219D6B0h case    8:*/		return 0x8219D6B4;
		  /* 8219D6B4h */ case    9:  		/* b 44 */
		/* 8219D6B4h case    9:*/		return 0x8219D6E0;
		/* 8219D6B4h case    9:*/		return 0x8219D6B8;
	}
	return 0x8219D6B8;
} // Block from 8219D690h-8219D6B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219D6B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D6B8);
		  /* 8219D6B8h */ case    0:  		/* rlwinm. R6, R11, 0, 30, 30 */
		/* 8219D6B8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R6,regs.R11);
		/* 8219D6B8h case    0:*/		return 0x8219D6BC;
		  /* 8219D6BCh */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8219D6BCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8219D6C8;  }
		/* 8219D6BCh case    1:*/		return 0x8219D6C0;
		  /* 8219D6C0h */ case    2:  		/* rlwinm. R6, R30, 0, 31, 31 */
		/* 8219D6C0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R6,regs.R30);
		/* 8219D6C0h case    2:*/		return 0x8219D6C4;
		  /* 8219D6C4h */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 8219D6C4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219D6B0;  }
		/* 8219D6C4h case    3:*/		return 0x8219D6C8;
	}
	return 0x8219D6C8;
} // Block from 8219D6B8h-8219D6C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219D6C8h
// Function '?CombineOperandGroups@Compiler@D3DXShader@@AAA_NPAVInstruction@2@0QAPAURegGroupInfo@2@_N2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D6C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D6C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D6C8);
		  /* 8219D6C8h */ case    0:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 8219D6C8h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 8219D6C8h case    0:*/		return 0x8219D6CC;
		  /* 8219D6CCh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219D6CCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8219D6DC;  }
		/* 8219D6CCh case    1:*/		return 0x8219D6D0;
		  /* 8219D6D0h */ case    2:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8219D6D0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8219D6D0h case    2:*/		return 0x8219D6D4;
		  /* 8219D6D4h */ case    3:  		/* li R11, 0 */
		/* 8219D6D4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219D6D4h case    3:*/		return 0x8219D6D8;
		  /* 8219D6D8h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 8219D6D8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219D6E0;  }
		/* 8219D6D8h case    4:*/		return 0x8219D6DC;
	}
	return 0x8219D6DC;
} // Block from 8219D6C8h-8219D6DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219D6DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D6DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D6DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D6DC);
		  /* 8219D6DCh */ case    0:  		/* li R11, 1 */
		/* 8219D6DCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219D6DCh case    0:*/		return 0x8219D6E0;
	}
	return 0x8219D6E0;
} // Block from 8219D6DCh-8219D6E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219D6E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D6E0);
		  /* 8219D6E0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219D6E0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219D6E0h case    0:*/		return 0x8219D6E4;
		  /* 8219D6E4h */ case    1:  		/* bc 4, CR0_EQ, 84 */
		/* 8219D6E4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219D738;  }
		/* 8219D6E4h case    1:*/		return 0x8219D6E8;
		  /* 8219D6E8h */ case    2:  		/* lwz R11, <#[R8]> */
		/* 8219D6E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8219D6E8h case    2:*/		return 0x8219D6EC;
		  /* 8219D6ECh */ case    3:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8219D6ECh case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219D6ECh case    3:*/		return 0x8219D6F0;
		  /* 8219D6F0h */ case    4:  		/* rlwinm. R6, R11, 0, 27, 28 */
		/* 8219D6F0h case    4:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R6,regs.R11);
		/* 8219D6F0h case    4:*/		return 0x8219D6F4;
		  /* 8219D6F4h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 8219D6F4h case    5:*/		if ( regs.CR[0].eq ) { return 0x8219D708;  }
		/* 8219D6F4h case    5:*/		return 0x8219D6F8;
		  /* 8219D6F8h */ case    6:  		/* rlwinm. R6, R30, 0, 27, 28 */
		/* 8219D6F8h case    6:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R6,regs.R30);
		/* 8219D6F8h case    6:*/		return 0x8219D6FC;
		  /* 8219D6FCh */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8219D6FCh case    7:*/		if ( regs.CR[0].eq ) { return 0x8219D708;  }
		/* 8219D6FCh case    7:*/		return 0x8219D700;
		  /* 8219D700h */ case    8:  		/* li R11, 0 */
		/* 8219D700h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219D700h case    8:*/		return 0x8219D704;
		  /* 8219D704h */ case    9:  		/* b 44 */
		/* 8219D704h case    9:*/		return 0x8219D730;
		/* 8219D704h case    9:*/		return 0x8219D708;
	}
	return 0x8219D708;
} // Block from 8219D6E0h-8219D708h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219D708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D708);
		  /* 8219D708h */ case    0:  		/* rlwinm. R6, R11, 0, 30, 30 */
		/* 8219D708h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R6,regs.R11);
		/* 8219D708h case    0:*/		return 0x8219D70C;
		  /* 8219D70Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 8219D70Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219D718;  }
		/* 8219D70Ch case    1:*/		return 0x8219D710;
		  /* 8219D710h */ case    2:  		/* rlwinm. R6, R30, 0, 31, 31 */
		/* 8219D710h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R6,regs.R30);
		/* 8219D710h case    2:*/		return 0x8219D714;
		  /* 8219D714h */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 8219D714h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219D700;  }
		/* 8219D714h case    3:*/		return 0x8219D718;
	}
	return 0x8219D718;
} // Block from 8219D708h-8219D718h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219D718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D718);
		  /* 8219D718h */ case    0:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 8219D718h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 8219D718h case    0:*/		return 0x8219D71C;
		  /* 8219D71Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219D71Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219D72C;  }
		/* 8219D71Ch case    1:*/		return 0x8219D720;
		  /* 8219D720h */ case    2:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 8219D720h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 8219D720h case    2:*/		return 0x8219D724;
		  /* 8219D724h */ case    3:  		/* li R11, 0 */
		/* 8219D724h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219D724h case    3:*/		return 0x8219D728;
		  /* 8219D728h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 8219D728h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219D730;  }
		/* 8219D728h case    4:*/		return 0x8219D72C;
	}
	return 0x8219D72C;
} // Block from 8219D718h-8219D72Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219D72Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D72C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D72C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D72C);
		  /* 8219D72Ch */ case    0:  		/* li R11, 1 */
		/* 8219D72Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219D72Ch case    0:*/		return 0x8219D730;
	}
	return 0x8219D730;
} // Block from 8219D72Ch-8219D730h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219D730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D730);
		  /* 8219D730h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219D730h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219D730h case    0:*/		return 0x8219D734;
		  /* 8219D734h */ case    1:  		/* bc 12, CR0_EQ, 164 */
		/* 8219D734h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219D7D8;  }
		/* 8219D734h case    1:*/		return 0x8219D738;
	}
	return 0x8219D738;
} // Block from 8219D730h-8219D738h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219D738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D738);
		  /* 8219D738h */ case    0:  		/* cmplwi CR6, R7, 2 */
		/* 8219D738h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000002);
		/* 8219D738h case    0:*/		return 0x8219D73C;
		  /* 8219D73Ch */ case    1:  		/* bc 12, CR6_GT, 104 */
		/* 8219D73Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x8219D7A4;  }
		/* 8219D73Ch case    1:*/		return 0x8219D740;
		  /* 8219D740h */ case    2:  		/* lwz R11, <#[R10 + 12]> */
		/* 8219D740h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219D740h case    2:*/		return 0x8219D744;
		  /* 8219D744h */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219D744h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219D744h case    3:*/		return 0x8219D748;
		  /* 8219D748h */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219D748h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219D748h case    4:*/		return 0x8219D74C;
		  /* 8219D74Ch */ case    5:  		/* cmplwi CR6, R11, 125 */
		/* 8219D74Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219D74Ch case    5:*/		return 0x8219D750;
		  /* 8219D750h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 8219D750h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219D760;  }
		/* 8219D750h case    6:*/		return 0x8219D754;
		  /* 8219D754h */ case    7:  		/* cmplwi CR6, R11, 124 */
		/* 8219D754h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219D754h case    7:*/		return 0x8219D758;
		  /* 8219D758h */ case    8:  		/* li R11, 0 */
		/* 8219D758h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219D758h case    8:*/		return 0x8219D75C;
		  /* 8219D75Ch */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 8219D75Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219D764;  }
		/* 8219D75Ch case    9:*/		return 0x8219D760;
	}
	return 0x8219D760;
} // Block from 8219D738h-8219D760h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219D760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D760);
		  /* 8219D760h */ case    0:  		/* li R11, 1 */
		/* 8219D760h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219D760h case    0:*/		return 0x8219D764;
	}
	return 0x8219D764;
} // Block from 8219D760h-8219D764h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219D764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D764);
		  /* 8219D764h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219D764h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219D764h case    0:*/		return 0x8219D768;
		  /* 8219D768h */ case    1:  		/* bc 12, CR0_EQ, 60 */
		/* 8219D768h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219D7A4;  }
		/* 8219D768h case    1:*/		return 0x8219D76C;
		  /* 8219D76Ch */ case    2:  		/* lwz R11, <#[R8 + 12]> */
		/* 8219D76Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000000C) );
		/* 8219D76Ch case    2:*/		return 0x8219D770;
		  /* 8219D770h */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219D770h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219D770h case    3:*/		return 0x8219D774;
		  /* 8219D774h */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219D774h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219D774h case    4:*/		return 0x8219D778;
		  /* 8219D778h */ case    5:  		/* cmplwi CR6, R11, 125 */
		/* 8219D778h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219D778h case    5:*/		return 0x8219D77C;
		  /* 8219D77Ch */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 8219D77Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8219D78C;  }
		/* 8219D77Ch case    6:*/		return 0x8219D780;
		  /* 8219D780h */ case    7:  		/* cmplwi CR6, R11, 124 */
		/* 8219D780h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219D780h case    7:*/		return 0x8219D784;
		  /* 8219D784h */ case    8:  		/* li R11, 0 */
		/* 8219D784h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219D784h case    8:*/		return 0x8219D788;
		  /* 8219D788h */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 8219D788h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219D790;  }
		/* 8219D788h case    9:*/		return 0x8219D78C;
	}
	return 0x8219D78C;
} // Block from 8219D764h-8219D78Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219D78Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D78C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D78C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D78C);
		  /* 8219D78Ch */ case    0:  		/* li R11, 1 */
		/* 8219D78Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219D78Ch case    0:*/		return 0x8219D790;
	}
	return 0x8219D790;
} // Block from 8219D78Ch-8219D790h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219D790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D790);
		  /* 8219D790h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219D790h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219D790h case    0:*/		return 0x8219D794;
		  /* 8219D794h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219D794h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219D7A4;  }
		/* 8219D794h case    1:*/		return 0x8219D798;
		  /* 8219D798h */ case    2:  		/* lwz R11, <#[R8]> */
		/* 8219D798h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8219D798h case    2:*/		return 0x8219D79C;
		  /* 8219D79Ch */ case    3:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 8219D79Ch case    3:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 8219D79Ch case    3:*/		return 0x8219D7A0;
		  /* 8219D7A0h */ case    4:  		/* bc 4, CR0_EQ, 56 */
		/* 8219D7A0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219D7D8;  }
		/* 8219D7A0h case    4:*/		return 0x8219D7A4;
	}
	return 0x8219D7A4;
} // Block from 8219D790h-8219D7A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219D7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D7A4);
		  /* 8219D7A4h */ case    0:  		/* lwz R11, <#[R8]> */
		/* 8219D7A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8219D7A4h case    0:*/		return 0x8219D7A8;
		  /* 8219D7A8h */ case    1:  		/* or R11, R11, R9 */
		/* 8219D7A8h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8219D7A8h case    1:*/		return 0x8219D7AC;
		  /* 8219D7ACh */ case    2:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 8219D7ACh case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 8219D7ACh case    2:*/		return 0x8219D7B0;
		  /* 8219D7B0h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8219D7B0h case    3:*/		if ( regs.CR[0].eq ) { return 0x8219D7C0;  }
		/* 8219D7B0h case    3:*/		return 0x8219D7B4;
		  /* 8219D7B4h */ case    4:  		/* mr R3, R29 */
		/* 8219D7B4h case    4:*/		regs.R3 = regs.R29;
		/* 8219D7B4h case    4:*/		return 0x8219D7B8;
		  /* 8219D7B8h */ case    5:  		/* bl -154784 */
		/* 8219D7B8h case    5:*/		regs.LR = 0x8219D7BC; return 0x82177B18;
		/* 8219D7B8h case    5:*/		return 0x8219D7BC;
		  /* 8219D7BCh */ case    6:  		/* stw R3, <#[R31 + 8]> */
		/* 8219D7BCh case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8219D7BCh case    6:*/		return 0x8219D7C0;
	}
	return 0x8219D7C0;
} // Block from 8219D7A4h-8219D7C0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219D7C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D7C0);
		  /* 8219D7C0h */ case    0:  		/* lwz R11, <#[R31 + 196]> */
		/* 8219D7C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 8219D7C0h case    0:*/		return 0x8219D7C4;
		  /* 8219D7C4h */ case    1:  		/* li R10, 1 */
		/* 8219D7C4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219D7C4h case    1:*/		return 0x8219D7C8;
		  /* 8219D7C8h */ case    2:  		/* lwz R9, <#[R31 + 160]> */
		/* 8219D7C8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219D7C8h case    2:*/		return 0x8219D7CC;
		  /* 8219D7CCh */ case    3:  		/* stb R10, <#[R31 + 204]> */
		/* 8219D7CCh case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x000000CC) );
		/* 8219D7CCh case    3:*/		return 0x8219D7D0;
		  /* 8219D7D0h */ case    4:  		/* subf R11, R9, R11 */
		/* 8219D7D0h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8219D7D0h case    4:*/		return 0x8219D7D4;
		  /* 8219D7D4h */ case    5:  		/* stw R11, <#[R31 + 200]> */
		/* 8219D7D4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000C8) );
		/* 8219D7D4h case    5:*/		return 0x8219D7D8;
	}
	return 0x8219D7D8;
} // Block from 8219D7C0h-8219D7D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219D7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D7D8);
		  /* 8219D7D8h */ case    0:  		/* lwz R11, <#[R31 + 200]> */
		/* 8219D7D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C8) );
		/* 8219D7D8h case    0:*/		return 0x8219D7DC;
		  /* 8219D7DCh */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8219D7DCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8219D7DCh case    1:*/		return 0x8219D7E0;
		  /* 8219D7E0h */ case    2:  		/* bc 12, CR6_GT, 36 */
		/* 8219D7E0h case    2:*/		if ( regs.CR[6].gt ) { return 0x8219D804;  }
		/* 8219D7E0h case    2:*/		return 0x8219D7E4;
		  /* 8219D7E4h */ case    3:  		/* lwz R11, <#[R31 + 28]> */
		/* 8219D7E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 8219D7E4h case    3:*/		return 0x8219D7E8;
		  /* 8219D7E8h */ case    4:  		/* cmplwi CR6, R11, 2 */
		/* 8219D7E8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 8219D7E8h case    4:*/		return 0x8219D7EC;
		  /* 8219D7ECh */ case    5:  		/* bc 4, CR6_GT, 24 */
		/* 8219D7ECh case    5:*/		if ( !regs.CR[6].gt ) { return 0x8219D804;  }
		/* 8219D7ECh case    5:*/		return 0x8219D7F0;
		  /* 8219D7F0h */ case    6:  		/* lwz R11, <#[R31 + 196]> */
		/* 8219D7F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 8219D7F0h case    6:*/		return 0x8219D7F4;
		  /* 8219D7F4h */ case    7:  		/* lwz R10, <#[R31 + 160]> */
		/* 8219D7F4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219D7F4h case    7:*/		return 0x8219D7F8;
		  /* 8219D7F8h */ case    8:  		/* subf R11, R10, R11 */
		/* 8219D7F8h case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219D7F8h case    8:*/		return 0x8219D7FC;
		  /* 8219D7FCh */ case    9:  		/* addi R11, R11, -1 */
		/* 8219D7FCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8219D7FCh case    9:*/		return 0x8219D800;
		  /* 8219D800h */ case   10:  		/* stw R11, <#[R31 + 200]> */
		/* 8219D800h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000000C8) );
		/* 8219D800h case   10:*/		return 0x8219D804;
	}
	return 0x8219D804;
} // Block from 8219D7D8h-8219D804h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219D804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D804);
		  /* 8219D804h */ case    0:  		/* lwz R11, <#[R31 + 200]> */
		/* 8219D804h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C8) );
		/* 8219D804h case    0:*/		return 0x8219D808;
		  /* 8219D808h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 8219D808h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8219D808h case    1:*/		return 0x8219D80C;
		  /* 8219D80Ch */ case    2:  		/* bc 12, CR6_GT, 56 */
		/* 8219D80Ch case    2:*/		if ( regs.CR[6].gt ) { return 0x8219D844;  }
		/* 8219D80Ch case    2:*/		return 0x8219D810;
		  /* 8219D810h */ case    3:  		/* lwz R11, <#[R28 + 664]> */
		/* 8219D810h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000298) );
		/* 8219D810h case    3:*/		return 0x8219D814;
		  /* 8219D814h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219D814h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219D814h case    4:*/		return 0x8219D818;
		  /* 8219D818h */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 8219D818h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219D844;  }
		/* 8219D818h case    5:*/		return 0x8219D81C;
		  /* 8219D81Ch */ case    6:  		/* lwz R10, <#[R31 + 160]> */
		/* 8219D81Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000A0) );
		/* 8219D81Ch case    6:*/		return 0x8219D820;
		  /* 8219D820h */ case    7:  		/* cmplwi CR6, R10, 3 */
		/* 8219D820h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 8219D820h case    7:*/		return 0x8219D824;
		  /* 8219D824h */ case    8:  		/* bc 12, CR6_LT, 32 */
		/* 8219D824h case    8:*/		if ( regs.CR[6].lt ) { return 0x8219D844;  }
		/* 8219D824h case    8:*/		return 0x8219D828;
		  /* 8219D828h */ case    9:  		/* li R11, 0 */
		/* 8219D828h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219D828h case    9:*/		return 0x8219D82C;
		  /* 8219D82Ch */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 8219D82Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219D82Ch case   10:*/		return 0x8219D830;
		  /* 8219D830h */ case   11:  		/* bc 12, CR6_EQ, 20 */
		/* 8219D830h case   11:*/		if ( regs.CR[6].eq ) { return 0x8219D844;  }
		/* 8219D830h case   11:*/		return 0x8219D834;
		  /* 8219D834h */ case   12:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 8219D834h case   12:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 8219D834h case   12:*/		return 0x8219D838;
		  /* 8219D838h */ case   13:  		/* addi R11, R11, 1 */
		/* 8219D838h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219D838h case   13:*/		return 0x8219D83C;
		  /* 8219D83Ch */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 8219D83Ch case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8219D83Ch case   14:*/		return 0x8219D840;
		  /* 8219D840h */ case   15:  		/* bc 12, CR6_LT, -8 */
		/* 8219D840h case   15:*/		if ( regs.CR[6].lt ) { return 0x8219D838;  }
		/* 8219D840h case   15:*/		return 0x8219D844;
	}
	return 0x8219D844;
} // Block from 8219D804h-8219D844h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219D844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D844);
		  /* 8219D844h */ case    0:  		/* addi R1, R1, 160 */
		/* 8219D844h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8219D844h case    0:*/		return 0x8219D848;
		  /* 8219D848h */ case    1:  		/* b -1099176 */
		/* 8219D848h case    1:*/		return 0x820912A0;
		/* 8219D848h case    1:*/		return 0x8219D84C;
		  /* 8219D84Ch */ case    2:  		/* nop */
		/* 8219D84Ch case    2:*/		cpu::op::nop();
		/* 8219D84Ch case    2:*/		return 0x8219D850;
		  /* 8219D850h */ case    3:  		/* lwz R11, <#[R4 + 28]> */
		/* 8219D850h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 8219D850h case    3:*/		return 0x8219D854;
		  /* 8219D854h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219D854h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219D854h case    4:*/		return 0x8219D858;
		  /* 8219D858h */ case    5:  		/* bclr 4, CR0_EQ */
		/* 8219D858h case    5:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8219D858h case    5:*/		return 0x8219D85C;
	}
	return 0x8219D85C;
} // Block from 8219D844h-8219D85Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219D85Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D85C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D85C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D85C);
		  /* 8219D85Ch */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 8219D85Ch case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8219D85Ch case    0:*/		return 0x8219D860;
		  /* 8219D860h */ case    1:  		/* bclr 12, CR0_EQ */
		/* 8219D860h case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8219D860h case    1:*/		return 0x8219D864;
	}
	return 0x8219D864;
} // Block from 8219D85Ch-8219D864h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219D864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D864);
		  /* 8219D864h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 8219D864h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8219D864h case    0:*/		return 0x8219D868;
		  /* 8219D868h */ case    1:  		/* rlwinm R9, R10, 0, 18, 24 */
		/* 8219D868h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R10);
		/* 8219D868h case    1:*/		return 0x8219D86C;
		  /* 8219D86Ch */ case    2:  		/* cmplwi CR6, R9, 3968 */
		/* 8219D86Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000F80);
		/* 8219D86Ch case    2:*/		return 0x8219D870;
		  /* 8219D870h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 8219D870h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219D880;  }
		/* 8219D870h case    3:*/		return 0x8219D874;
		  /* 8219D874h */ case    4:  		/* li R9, 3 */
		/* 8219D874h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 8219D874h case    4:*/		return 0x8219D878;
		  /* 8219D878h */ case    5:  		/* rlwimi R10, R9, 7, 18, 24 */
		/* 8219D878h case    5:*/		cpu::op::rlwimi<0,7,18,24>(regs,&regs.R10,regs.R9);
		/* 8219D878h case    5:*/		return 0x8219D87C;
		  /* 8219D87Ch */ case    6:  		/* stw R10, <#[R11 + 8]> */
		/* 8219D87Ch case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8219D87Ch case    6:*/		return 0x8219D880;
	}
	return 0x8219D880;
} // Block from 8219D864h-8219D880h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219D880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D880);
		  /* 8219D880h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219D880h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219D880h case    0:*/		return 0x8219D884;
		  /* 8219D884h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219D884h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219D884h case    1:*/		return 0x8219D888;
		  /* 8219D888h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219D888h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219D888h case    2:*/		return 0x8219D88C;
		  /* 8219D88Ch */ case    3:  		/* bclr 4, CR0_EQ */
		/* 8219D88Ch case    3:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8219D88Ch case    3:*/		return 0x8219D890;
	}
	return 0x8219D890;
} // Block from 8219D880h-8219D890h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219D890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D890);
		  /* 8219D890h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 8219D890h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219D890h case    0:*/		return 0x8219D894;
		  /* 8219D894h */ case    1:  		/* bc 4, CR6_EQ, -48 */
		/* 8219D894h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219D864;  }
		/* 8219D894h case    1:*/		return 0x8219D898;
		  /* 8219D898h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8219D898h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219D898h case    2:*/		return 0x8219D89C;
	}
	return 0x8219D89C;
} // Block from 8219D890h-8219D89Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219D89Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D89C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D89C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D89C);
		  /* 8219D89Ch */ case    0:  		/* nop */
		/* 8219D89Ch case    0:*/		cpu::op::nop();
		/* 8219D89Ch case    0:*/		return 0x8219D8A0;
	}
	return 0x8219D8A0;
} // Block from 8219D89Ch-8219D8A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219D8A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D8A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D8A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D8A0);
		  /* 8219D8A0h */ case    0:  		/* mfspr R12, LR */
		/* 8219D8A0h case    0:*/		regs.R12 = regs.LR;
		/* 8219D8A0h case    0:*/		return 0x8219D8A4;
		  /* 8219D8A4h */ case    1:  		/* bl -1099364 */
		/* 8219D8A4h case    1:*/		regs.LR = 0x8219D8A8; return 0x82091240;
		/* 8219D8A4h case    1:*/		return 0x8219D8A8;
		  /* 8219D8A8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8219D8A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8219D8A8h case    2:*/		return 0x8219D8AC;
		  /* 8219D8ACh */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8219D8ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219D8ACh case    3:*/		return 0x8219D8B0;
		  /* 8219D8B0h */ case    4:  		/* lwz R10, <#[R4 + 4]> */
		/* 8219D8B0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 8219D8B0h case    4:*/		return 0x8219D8B4;
		  /* 8219D8B4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8219D8B4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219D8B4h case    5:*/		return 0x8219D8B8;
		  /* 8219D8B8h */ case    6:  		/* bc 12, CR6_EQ, 716 */
		/* 8219D8B8h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219DB84;  }
		/* 8219D8B8h case    6:*/		return 0x8219D8BC;
		  /* 8219D8BCh */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 8219D8BCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219D8BCh case    7:*/		return 0x8219D8C0;
		  /* 8219D8C0h */ case    8:  		/* bc 12, CR6_EQ, 724 */
		/* 8219D8C0h case    8:*/		if ( regs.CR[6].eq ) { return 0x8219DB94;  }
		/* 8219D8C0h case    8:*/		return 0x8219D8C4;
		  /* 8219D8C4h */ case    9:  		/* lwz R9, <#[R10]> */
		/* 8219D8C4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8219D8C4h case    9:*/		return 0x8219D8C8;
		  /* 8219D8C8h */ case   10:  		/* lwz R8, <#[R11]> */
		/* 8219D8C8h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 8219D8C8h case   10:*/		return 0x8219D8CC;
		  /* 8219D8CCh */ case   11:  		/* lwz R26, <#[R11 + 12]> */
		/* 8219D8CCh case   11:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219D8CCh case   11:*/		return 0x8219D8D0;
		  /* 8219D8D0h */ case   12:  		/* rlwinm R9, R9, 0, 27, 30 */
		/* 8219D8D0h case   12:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R9,regs.R9);
		/* 8219D8D0h case   12:*/		return 0x8219D8D4;
		  /* 8219D8D4h */ case   13:  		/* rlwinm R11, R8, 0, 27, 30 */
		/* 8219D8D4h case   13:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R11,regs.R8);
		/* 8219D8D4h case   13:*/		return 0x8219D8D8;
		  /* 8219D8D8h */ case   14:  		/* lwz R23, <#[R10 + 12]> */
		/* 8219D8D8h case   14:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219D8D8h case   14:*/		return 0x8219D8DC;
		  /* 8219D8DCh */ case   15:  		/* subf. R3, R9, R11 */
		/* 8219D8DCh case   15:*/		cpu::op::subf<1>(regs,&regs.R3,regs.R9,regs.R11);
		/* 8219D8DCh case   15:*/		return 0x8219D8E0;
		  /* 8219D8E0h */ case   16:  		/* bc 4, CR0_EQ, 712 */
		/* 8219D8E0h case   16:*/		if ( !regs.CR[0].eq ) { return 0x8219DBA8;  }
		/* 8219D8E0h case   16:*/		return 0x8219D8E4;
		  /* 8219D8E4h */ case   17:  		/* cmplw CR6, R26, R23 */
		/* 8219D8E4h case   17:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R23);
		/* 8219D8E4h case   17:*/		return 0x8219D8E8;
		  /* 8219D8E8h */ case   18:  		/* bc 12, CR6_EQ, 676 */
		/* 8219D8E8h case   18:*/		if ( regs.CR[6].eq ) { return 0x8219DB8C;  }
		/* 8219D8E8h case   18:*/		return 0x8219D8EC;
		  /* 8219D8ECh */ case   19:  		/* lwz R11, <#[R23 + 8]> */
		/* 8219D8ECh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000008) );
		/* 8219D8ECh case   19:*/		return 0x8219D8F0;
		  /* 8219D8F0h */ case   20:  		/* lwz R10, <#[R26 + 8]> */
		/* 8219D8F0h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 8219D8F0h case   20:*/		return 0x8219D8F4;
		  /* 8219D8F4h */ case   21:  		/* rlwinm R9, R11, 25, 25, 31 */
		/* 8219D8F4h case   21:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R11);
		/* 8219D8F4h case   21:*/		return 0x8219D8F8;
		  /* 8219D8F8h */ case   22:  		/* rlwinm R8, R10, 25, 25, 31 */
		/* 8219D8F8h case   22:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R8,regs.R10);
		/* 8219D8F8h case   22:*/		return 0x8219D8FC;
		  /* 8219D8FCh */ case   23:  		/* subf. R29, R9, R8 */
		/* 8219D8FCh case   23:*/		cpu::op::subf<1>(regs,&regs.R29,regs.R9,regs.R8);
		/* 8219D8FCh case   23:*/		return 0x8219D900;
		  /* 8219D900h */ case   24:  		/* bc 4, CR0_EQ, 32 */
		/* 8219D900h case   24:*/		if ( !regs.CR[0].eq ) { return 0x8219D920;  }
		/* 8219D900h case   24:*/		return 0x8219D904;
		  /* 8219D904h */ case   25:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 8219D904h case   25:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 8219D904h case   25:*/		return 0x8219D908;
		  /* 8219D908h */ case   26:  		/* rlwinm R8, R11, 0, 31, 31 */
		/* 8219D908h case   26:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R11);
		/* 8219D908h case   26:*/		return 0x8219D90C;
		  /* 8219D90Ch */ case   27:  		/* subf. R29, R8, R9 */
		/* 8219D90Ch case   27:*/		cpu::op::subf<1>(regs,&regs.R29,regs.R8,regs.R9);
		/* 8219D90Ch case   27:*/		return 0x8219D910;
		  /* 8219D910h */ case   28:  		/* bc 4, CR0_EQ, 16 */
		/* 8219D910h case   28:*/		if ( !regs.CR[0].eq ) { return 0x8219D920;  }
		/* 8219D910h case   28:*/		return 0x8219D914;
		  /* 8219D914h */ case   29:  		/* rlwinm R9, R10, 9, 31, 31 */
		/* 8219D914h case   29:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R9,regs.R10);
		/* 8219D914h case   29:*/		return 0x8219D918;
		  /* 8219D918h */ case   30:  		/* rlwinm R11, R11, 9, 31, 31 */
		/* 8219D918h case   30:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219D918h case   30:*/		return 0x8219D91C;
		  /* 8219D91Ch */ case   31:  		/* subf R29, R11, R9 */
		/* 8219D91Ch case   31:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R11,regs.R9);
		/* 8219D91Ch case   31:*/		return 0x8219D920;
	}
	return 0x8219D920;
} // Block from 8219D8A0h-8219D920h (32 instructions)

//////////////////////////////////////////////////////
// Block at 8219D920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D920);
		  /* 8219D920h */ case    0:  		/* rlwinm R11, R26, 0, 0, 19 */
		/* 8219D920h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R26);
		/* 8219D920h case    0:*/		return 0x8219D924;
		  /* 8219D924h */ case    1:  		/* cmpwi CR6, R29, 0 */
		/* 8219D924h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8219D924h case    1:*/		return 0x8219D928;
		  /* 8219D928h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 8219D928h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219D928h case    2:*/		return 0x8219D92C;
		  /* 8219D92Ch */ case    3:  		/* lwz R22, <#[R11 + 148]> */
		/* 8219D92Ch case    3:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R11 + 0x00000094) );
		/* 8219D92Ch case    3:*/		return 0x8219D930;
		  /* 8219D930h */ case    4:  		/* bc 4, CR6_EQ, 588 */
		/* 8219D930h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8219DB7C;  }
		/* 8219D930h case    4:*/		return 0x8219D934;
		  /* 8219D934h */ case    5:  		/* rlwinm. R11, R10, 9, 31, 31 */
		/* 8219D934h case    5:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R10);
		/* 8219D934h case    5:*/		return 0x8219D938;
		  /* 8219D938h */ case    6:  		/* bc 12, CR0_EQ, 48 */
		/* 8219D938h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219D968;  }
		/* 8219D938h case    6:*/		return 0x8219D93C;
		  /* 8219D93Ch */ case    7:  		/* mr R5, R23 */
		/* 8219D93Ch case    7:*/		regs.R5 = regs.R23;
		/* 8219D93Ch case    7:*/		return 0x8219D940;
		  /* 8219D940h */ case    8:  		/* mr R4, R26 */
		/* 8219D940h case    8:*/		regs.R4 = regs.R26;
		/* 8219D940h case    8:*/		return 0x8219D944;
		  /* 8219D944h */ case    9:  		/* mr R3, R22 */
		/* 8219D944h case    9:*/		regs.R3 = regs.R22;
		/* 8219D944h case    9:*/		return 0x8219D948;
		  /* 8219D948h */ case   10:  		/* bl -2136 */
		/* 8219D948h case   10:*/		regs.LR = 0x8219D94C; return 0x8219D0F0;
		/* 8219D948h case   10:*/		return 0x8219D94C;
		  /* 8219D94Ch */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219D94Ch case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219D94Ch case   11:*/		return 0x8219D950;
		  /* 8219D950h */ case   12:  		/* bc 4, CR0_EQ, 24 */
		/* 8219D950h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8219D968;  }
		/* 8219D950h case   12:*/		return 0x8219D954;
		  /* 8219D954h */ case   13:  		/* mr R4, R23 */
		/* 8219D954h case   13:*/		regs.R4 = regs.R23;
		/* 8219D954h case   13:*/		return 0x8219D958;
		  /* 8219D958h */ case   14:  		/* mr R3, R26 */
		/* 8219D958h case   14:*/		regs.R3 = regs.R26;
		/* 8219D958h case   14:*/		return 0x8219D95C;
		  /* 8219D95Ch */ case   15:  		/* bl -3980 */
		/* 8219D95Ch case   15:*/		regs.LR = 0x8219D960; return 0x8219C9D0;
		/* 8219D95Ch case   15:*/		return 0x8219D960;
		  /* 8219D960h */ case   16:  		/* or. R29, R3, R3 */
		/* 8219D960h case   16:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8219D960h case   16:*/		return 0x8219D964;
		  /* 8219D964h */ case   17:  		/* bc 4, CR0_EQ, 536 */
		/* 8219D964h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8219DB7C;  }
		/* 8219D964h case   17:*/		return 0x8219D968;
	}
	return 0x8219D968;
} // Block from 8219D920h-8219D968h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219D968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D968);
		  /* 8219D968h */ case    0:  		/* lwz R10, <#[R26 + 8]> */
		/* 8219D968h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 8219D968h case    0:*/		return 0x8219D96C;
		  /* 8219D96Ch */ case    1:  		/* li R11, 0 */
		/* 8219D96Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219D96Ch case    1:*/		return 0x8219D970;
		  /* 8219D970h */ case    2:  		/* rlwinm R9, R10, 0, 18, 24 */
		/* 8219D970h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R10);
		/* 8219D970h case    2:*/		return 0x8219D974;
		  /* 8219D974h */ case    3:  		/* rlwinm R25, R10, 13, 29, 31 */
		/* 8219D974h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R25,regs.R10);
		/* 8219D974h case    3:*/		return 0x8219D978;
		  /* 8219D978h */ case    4:  		/* cmplwi CR6, R9, 12800 */
		/* 8219D978h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003200);
		/* 8219D978h case    4:*/		return 0x8219D97C;
		  /* 8219D97Ch */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 8219D97Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219D988;  }
		/* 8219D97Ch case    5:*/		return 0x8219D980;
		  /* 8219D980h */ case    6:  		/* li R11, 1 */
		/* 8219D980h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219D980h case    6:*/		return 0x8219D984;
		  /* 8219D984h */ case    7:  		/* li R25, 1 */
		/* 8219D984h case    7:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8219D984h case    7:*/		return 0x8219D988;
	}
	return 0x8219D988;
} // Block from 8219D968h-8219D988h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219D988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D988);
		  /* 8219D988h */ case    0:  		/* mr R24, R11 */
		/* 8219D988h case    0:*/		regs.R24 = regs.R11;
		/* 8219D988h case    0:*/		return 0x8219D98C;
		  /* 8219D98Ch */ case    1:  		/* cmplw CR6, R11, R25 */
		/* 8219D98Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 8219D98Ch case    1:*/		return 0x8219D990;
		  /* 8219D990h */ case    2:  		/* bc 4, CR6_LT, 352 */
		/* 8219D990h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8219DAF0;  }
		/* 8219D990h case    2:*/		return 0x8219D994;
		  /* 8219D994h */ case    3:  		/* addi R11, R11, 11 */
		/* 8219D994h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB);
		/* 8219D994h case    3:*/		return 0x8219D998;
		  /* 8219D998h */ case    4:  		/* subf R27, R23, R26 */
		/* 8219D998h case    4:*/		cpu::op::subf<0>(regs,&regs.R27,regs.R23,regs.R26);
		/* 8219D998h case    4:*/		return 0x8219D99C;
		  /* 8219D99Ch */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8219D99Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8219D99Ch case    5:*/		return 0x8219D9A0;
		  /* 8219D9A0h */ case    6:  		/* add R28, R11, R23 */
		/* 8219D9A0h case    6:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R23);
		/* 8219D9A0h case    6:*/		return 0x8219D9A4;
		  /* 8219D9A4h */ case    7:  		/* lwzx R5, <#[R27 + R28]> */
		/* 8219D9A4h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + regs.R28 + 0x00000000) );
		/* 8219D9A4h case    7:*/		return 0x8219D9A8;
		  /* 8219D9A8h */ case    8:  		/* lwz R4, <#[R28]> */
		/* 8219D9A8h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 8219D9A8h case    8:*/		return 0x8219D9AC;
		  /* 8219D9ACh */ case    9:  		/* lwz R31, <#[R5 + 12]> */
		/* 8219D9ACh case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R5 + 0x0000000C) );
		/* 8219D9ACh case    9:*/		return 0x8219D9B0;
		  /* 8219D9B0h */ case   10:  		/* lwz R30, <#[R4 + 12]> */
		/* 8219D9B0h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x0000000C) );
		/* 8219D9B0h case   10:*/		return 0x8219D9B4;
		  /* 8219D9B4h */ case   11:  		/* cmplw CR6, R31, R30 */
		/* 8219D9B4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 8219D9B4h case   11:*/		return 0x8219D9B8;
		  /* 8219D9B8h */ case   12:  		/* bc 12, CR6_EQ, 268 */
		/* 8219D9B8h case   12:*/		if ( regs.CR[6].eq ) { return 0x8219DAC4;  }
		/* 8219D9B8h case   12:*/		return 0x8219D9BC;
		  /* 8219D9BCh */ case   13:  		/* lwz R6, <#[R30 + 8]> */
		/* 8219D9BCh case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000008) );
		/* 8219D9BCh case   13:*/		return 0x8219D9C0;
		  /* 8219D9C0h */ case   14:  		/* lwz R8, <#[R31 + 8]> */
		/* 8219D9C0h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 8219D9C0h case   14:*/		return 0x8219D9C4;
		  /* 8219D9C4h */ case   15:  		/* rlwinm R10, R6, 25, 25, 31 */
		/* 8219D9C4h case   15:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R6);
		/* 8219D9C4h case   15:*/		return 0x8219D9C8;
		  /* 8219D9C8h */ case   16:  		/* rlwinm R9, R8, 25, 25, 31 */
		/* 8219D9C8h case   16:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R8);
		/* 8219D9C8h case   16:*/		return 0x8219D9CC;
		  /* 8219D9CCh */ case   17:  		/* subf. R29, R10, R9 */
		/* 8219D9CCh case   17:*/		cpu::op::subf<1>(regs,&regs.R29,regs.R10,regs.R9);
		/* 8219D9CCh case   17:*/		return 0x8219D9D0;
		  /* 8219D9D0h */ case   18:  		/* bc 12, CR0_EQ, 100 */
		/* 8219D9D0h case   18:*/		if ( regs.CR[0].eq ) { return 0x8219DA34;  }
		/* 8219D9D0h case   18:*/		return 0x8219D9D4;
		  /* 8219D9D4h */ case   19:  		/* cmplwi CR6, R9, 125 */
		/* 8219D9D4h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000007D);
		/* 8219D9D4h case   19:*/		return 0x8219D9D8;
		  /* 8219D9D8h */ case   20:  		/* bc 12, CR6_EQ, 16 */
		/* 8219D9D8h case   20:*/		if ( regs.CR[6].eq ) { return 0x8219D9E8;  }
		/* 8219D9D8h case   20:*/		return 0x8219D9DC;
		  /* 8219D9DCh */ case   21:  		/* cmplwi CR6, R9, 124 */
		/* 8219D9DCh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000007C);
		/* 8219D9DCh case   21:*/		return 0x8219D9E0;
		  /* 8219D9E0h */ case   22:  		/* li R7, 0 */
		/* 8219D9E0h case   22:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219D9E0h case   22:*/		return 0x8219D9E4;
		  /* 8219D9E4h */ case   23:  		/* bc 4, CR6_EQ, 8 */
		/* 8219D9E4h case   23:*/		if ( !regs.CR[6].eq ) { return 0x8219D9EC;  }
		/* 8219D9E4h case   23:*/		return 0x8219D9E8;
	}
	return 0x8219D9E8;
} // Block from 8219D988h-8219D9E8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8219D9E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D9E8);
		  /* 8219D9E8h */ case    0:  		/* li R7, 1 */
		/* 8219D9E8h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8219D9E8h case    0:*/		return 0x8219D9EC;
	}
	return 0x8219D9EC;
} // Block from 8219D9E8h-8219D9ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219D9ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219D9EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219D9EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219D9EC);
		  /* 8219D9ECh */ case    0:  		/* cmplwi CR6, R10, 125 */
		/* 8219D9ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007D);
		/* 8219D9ECh case    0:*/		return 0x8219D9F0;
		  /* 8219D9F0h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8219D9F0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219DA00;  }
		/* 8219D9F0h case    1:*/		return 0x8219D9F4;
		  /* 8219D9F4h */ case    2:  		/* cmplwi CR6, R10, 124 */
		/* 8219D9F4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 8219D9F4h case    2:*/		return 0x8219D9F8;
		  /* 8219D9F8h */ case    3:  		/* li R11, 0 */
		/* 8219D9F8h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219D9F8h case    3:*/		return 0x8219D9FC;
		  /* 8219D9FCh */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 8219D9FCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x8219DA04;  }
		/* 8219D9FCh case    4:*/		return 0x8219DA00;
	}
	return 0x8219DA00;
} // Block from 8219D9ECh-8219DA00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219DA00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DA00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DA00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DA00);
		  /* 8219DA00h */ case    0:  		/* li R11, 1 */
		/* 8219DA00h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219DA00h case    0:*/		return 0x8219DA04;
	}
	return 0x8219DA04;
} // Block from 8219DA00h-8219DA04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219DA04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DA04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DA04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DA04);
		  /* 8219DA04h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8219DA04h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219DA04h case    0:*/		return 0x8219DA08;
		  /* 8219DA08h */ case    1:  		/* rlwinm R7, R7, 0, 24, 31 */
		/* 8219DA08h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R7,regs.R7);
		/* 8219DA08h case    1:*/		return 0x8219DA0C;
		  /* 8219DA0Ch */ case    2:  		/* cmplw CR6, R7, R11 */
		/* 8219DA0Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 8219DA0Ch case    2:*/		return 0x8219DA10;
		  /* 8219DA10h */ case    3:  		/* bc 4, CR6_EQ, 216 */
		/* 8219DA10h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219DAE8;  }
		/* 8219DA10h case    3:*/		return 0x8219DA14;
		  /* 8219DA14h */ case    4:  		/* addi R10, R10, -125 */
		/* 8219DA14h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFF83);
		/* 8219DA14h case    4:*/		return 0x8219DA18;
		  /* 8219DA18h */ case    5:  		/* addi R11, R9, -125 */
		/* 8219DA18h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFF83);
		/* 8219DA18h case    5:*/		return 0x8219DA1C;
		  /* 8219DA1Ch */ case    6:  		/* cntlzw R10, R10 */
		/* 8219DA1Ch case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8219DA1Ch case    6:*/		return 0x8219DA20;
		  /* 8219DA20h */ case    7:  		/* cntlzw R11, R11 */
		/* 8219DA20h case    7:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8219DA20h case    7:*/		return 0x8219DA24;
		  /* 8219DA24h */ case    8:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 8219DA24h case    8:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 8219DA24h case    8:*/		return 0x8219DA28;
		  /* 8219DA28h */ case    9:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8219DA28h case    9:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8219DA28h case    9:*/		return 0x8219DA2C;
		  /* 8219DA2Ch */ case   10:  		/* cmpw CR6, R11, R10 */
		/* 8219DA2Ch case   10:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 8219DA2Ch case   10:*/		return 0x8219DA30;
		  /* 8219DA30h */ case   11:  		/* bc 4, CR6_EQ, 184 */
		/* 8219DA30h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8219DAE8;  }
		/* 8219DA30h case   11:*/		return 0x8219DA34;
	}
	return 0x8219DA34;
} // Block from 8219DA04h-8219DA34h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219DA34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DA34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DA34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DA34);
		  /* 8219DA34h */ case    0:  		/* cmplwi CR6, R9, 125 */
		/* 8219DA34h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000007D);
		/* 8219DA34h case    0:*/		return 0x8219DA38;
		  /* 8219DA38h */ case    1:  		/* bc 12, CR6_EQ, 140 */
		/* 8219DA38h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219DAC4;  }
		/* 8219DA38h case    1:*/		return 0x8219DA3C;
		  /* 8219DA3Ch */ case    2:  		/* lwz R11, <#[R4]> */
		/* 8219DA3Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8219DA3Ch case    2:*/		return 0x8219DA40;
		  /* 8219DA40h */ case    3:  		/* lwz R10, <#[R5]> */
		/* 8219DA40h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 8219DA40h case    3:*/		return 0x8219DA44;
		  /* 8219DA44h */ case    4:  		/* rlwinm R11, R11, 0, 27, 30 */
		/* 8219DA44h case    4:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R11,regs.R11);
		/* 8219DA44h case    4:*/		return 0x8219DA48;
		  /* 8219DA48h */ case    5:  		/* rlwinm R10, R10, 0, 27, 30 */
		/* 8219DA48h case    5:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R10,regs.R10);
		/* 8219DA48h case    5:*/		return 0x8219DA4C;
		  /* 8219DA4Ch */ case    6:  		/* subf. R29, R11, R10 */
		/* 8219DA4Ch case    6:*/		cpu::op::subf<1>(regs,&regs.R29,regs.R11,regs.R10);
		/* 8219DA4Ch case    6:*/		return 0x8219DA50;
		  /* 8219DA50h */ case    7:  		/* bc 4, CR0_EQ, 300 */
		/* 8219DA50h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8219DB7C;  }
		/* 8219DA50h case    7:*/		return 0x8219DA54;
		  /* 8219DA54h */ case    8:  		/* cmplwi CR6, R9, 124 */
		/* 8219DA54h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000007C);
		/* 8219DA54h case    8:*/		return 0x8219DA58;
		  /* 8219DA58h */ case    9:  		/* bc 4, CR6_EQ, 28 */
		/* 8219DA58h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219DA74;  }
		/* 8219DA58h case    9:*/		return 0x8219DA5C;
		  /* 8219DA5Ch */ case   10:  		/* mr R4, R30 */
		/* 8219DA5Ch case   10:*/		regs.R4 = regs.R30;
		/* 8219DA5Ch case   10:*/		return 0x8219DA60;
		  /* 8219DA60h */ case   11:  		/* mr R3, R31 */
		/* 8219DA60h case   11:*/		regs.R3 = regs.R31;
		/* 8219DA60h case   11:*/		return 0x8219DA64;
		  /* 8219DA64h */ case   12:  		/* bl -4244 */
		/* 8219DA64h case   12:*/		regs.LR = 0x8219DA68; return 0x8219C9D0;
		/* 8219DA64h case   12:*/		return 0x8219DA68;
		  /* 8219DA68h */ case   13:  		/* or. R29, R3, R3 */
		/* 8219DA68h case   13:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8219DA68h case   13:*/		return 0x8219DA6C;
		  /* 8219DA6Ch */ case   14:  		/* bc 4, CR0_EQ, 272 */
		/* 8219DA6Ch case   14:*/		if ( !regs.CR[0].eq ) { return 0x8219DB7C;  }
		/* 8219DA6Ch case   14:*/		return 0x8219DA70;
		  /* 8219DA70h */ case   15:  		/* b 56 */
		/* 8219DA70h case   15:*/		return 0x8219DAA8;
		/* 8219DA70h case   15:*/		return 0x8219DA74;
	}
	return 0x8219DA74;
} // Block from 8219DA34h-8219DA74h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219DA74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DA74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DA74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DA74);
		  /* 8219DA74h */ case    0:  		/* rlwinm R10, R6, 9, 31, 31 */
		/* 8219DA74h case    0:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R10,regs.R6);
		/* 8219DA74h case    0:*/		return 0x8219DA78;
		  /* 8219DA78h */ case    1:  		/* rlwinm R9, R8, 9, 31, 31 */
		/* 8219DA78h case    1:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R9,regs.R8);
		/* 8219DA78h case    1:*/		return 0x8219DA7C;
		  /* 8219DA7Ch */ case    2:  		/* rlwinm R11, R8, 9, 23, 31 */
		/* 8219DA7Ch case    2:*/		cpu::op::rlwinm<0,9,23,31>(regs,&regs.R11,regs.R8);
		/* 8219DA7Ch case    2:*/		return 0x8219DA80;
		  /* 8219DA80h */ case    3:  		/* subf. R29, R10, R9 */
		/* 8219DA80h case    3:*/		cpu::op::subf<1>(regs,&regs.R29,regs.R10,regs.R9);
		/* 8219DA80h case    3:*/		return 0x8219DA84;
		  /* 8219DA84h */ case    4:  		/* bc 4, CR0_EQ, 248 */
		/* 8219DA84h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219DB7C;  }
		/* 8219DA84h case    4:*/		return 0x8219DA88;
	}
	return 0x8219DA88;
} // Block from 8219DA74h-8219DA88h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219DA88h
// Function '?CanMergeGlobalDefs@Compiler@D3DXShader@@AAA_NPAVInstruction@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DA88);
		  /* 8219DA88h */ case    0:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219DA88h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219DA88h case    0:*/		return 0x8219DA8C;
		  /* 8219DA8Ch */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 8219DA8Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219DAA8;  }
		/* 8219DA8Ch case    1:*/		return 0x8219DA90;
		  /* 8219DA90h */ case    2:  		/* mr R5, R30 */
		/* 8219DA90h case    2:*/		regs.R5 = regs.R30;
		/* 8219DA90h case    2:*/		return 0x8219DA94;
		  /* 8219DA94h */ case    3:  		/* mr R4, R31 */
		/* 8219DA94h case    3:*/		regs.R4 = regs.R31;
		/* 8219DA94h case    3:*/		return 0x8219DA98;
		  /* 8219DA98h */ case    4:  		/* mr R3, R22 */
		/* 8219DA98h case    4:*/		regs.R3 = regs.R22;
		/* 8219DA98h case    4:*/		return 0x8219DA9C;
		  /* 8219DA9Ch */ case    5:  		/* bl -2476 */
		/* 8219DA9Ch case    5:*/		regs.LR = 0x8219DAA0; return 0x8219D0F0;
		/* 8219DA9Ch case    5:*/		return 0x8219DAA0;
		  /* 8219DAA0h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219DAA0h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219DAA0h case    6:*/		return 0x8219DAA4;
		  /* 8219DAA4h */ case    7:  		/* bc 12, CR0_EQ, 52 */
		/* 8219DAA4h case    7:*/		if ( regs.CR[0].eq ) { return 0x8219DAD8;  }
		/* 8219DAA4h case    7:*/		return 0x8219DAA8;
	}
	return 0x8219DAA8;
} // Block from 8219DA88h-8219DAA8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219DAA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DAA8);
		  /* 8219DAA8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219DAA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219DAA8h case    0:*/		return 0x8219DAAC;
		  /* 8219DAACh */ case    1:  		/* lwz R9, <#[R30 + 8]> */
		/* 8219DAACh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 8219DAACh case    1:*/		return 0x8219DAB0;
		  /* 8219DAB0h */ case    2:  		/* rlwinm R10, R11, 18, 29, 31 */
		/* 8219DAB0h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R10,regs.R11);
		/* 8219DAB0h case    2:*/		return 0x8219DAB4;
		  /* 8219DAB4h */ case    3:  		/* rlwinm R11, R9, 18, 29, 31 */
		/* 8219DAB4h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R9);
		/* 8219DAB4h case    3:*/		return 0x8219DAB8;
		  /* 8219DAB8h */ case    4:  		/* add R11, R10, R11 */
		/* 8219DAB8h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219DAB8h case    4:*/		return 0x8219DABC;
		  /* 8219DABCh */ case    5:  		/* cmplwi CR6, R11, 4 */
		/* 8219DABCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8219DABCh case    5:*/		return 0x8219DAC0;
		  /* 8219DAC0h */ case    6:  		/* bc 12, CR6_GT, 24 */
		/* 8219DAC0h case    6:*/		if ( regs.CR[6].gt ) { return 0x8219DAD8;  }
		/* 8219DAC0h case    6:*/		return 0x8219DAC4;
	}
	return 0x8219DAC4;
} // Block from 8219DAA8h-8219DAC4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219DAC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DAC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DAC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DAC4);
		  /* 8219DAC4h */ case    0:  		/* addi R24, R24, 1 */
		/* 8219DAC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 8219DAC4h case    0:*/		return 0x8219DAC8;
		  /* 8219DAC8h */ case    1:  		/* addi R28, R28, 4 */
		/* 8219DAC8h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 8219DAC8h case    1:*/		return 0x8219DACC;
		  /* 8219DACCh */ case    2:  		/* cmplw CR6, R24, R25 */
		/* 8219DACCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R25);
		/* 8219DACCh case    2:*/		return 0x8219DAD0;
		  /* 8219DAD0h */ case    3:  		/* bc 12, CR6_LT, -300 */
		/* 8219DAD0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8219D9A4;  }
		/* 8219DAD0h case    3:*/		return 0x8219DAD4;
		  /* 8219DAD4h */ case    4:  		/* b 20 */
		/* 8219DAD4h case    4:*/		return 0x8219DAE8;
		/* 8219DAD4h case    4:*/		return 0x8219DAD8;
	}
	return 0x8219DAD8;
} // Block from 8219DAC4h-8219DAD8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219DAD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DAD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DAD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DAD8);
		  /* 8219DAD8h */ case    0:  		/* mr R4, R30 */
		/* 8219DAD8h case    0:*/		regs.R4 = regs.R30;
		/* 8219DAD8h case    0:*/		return 0x8219DADC;
		  /* 8219DADCh */ case    1:  		/* mr R3, R31 */
		/* 8219DADCh case    1:*/		regs.R3 = regs.R31;
		/* 8219DADCh case    1:*/		return 0x8219DAE0;
		  /* 8219DAE0h */ case    2:  		/* bl -4368 */
		/* 8219DAE0h case    2:*/		regs.LR = 0x8219DAE4; return 0x8219C9D0;
		/* 8219DAE0h case    2:*/		return 0x8219DAE4;
		  /* 8219DAE4h */ case    3:  		/* mr R29, R3 */
		/* 8219DAE4h case    3:*/		regs.R29 = regs.R3;
		/* 8219DAE4h case    3:*/		return 0x8219DAE8;
	}
	return 0x8219DAE8;
} // Block from 8219DAD8h-8219DAE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219DAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DAE8);
		  /* 8219DAE8h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 8219DAE8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8219DAE8h case    0:*/		return 0x8219DAEC;
		  /* 8219DAECh */ case    1:  		/* bc 4, CR6_EQ, 144 */
		/* 8219DAECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219DB7C;  }
		/* 8219DAECh case    1:*/		return 0x8219DAF0;
	}
	return 0x8219DAF0;
} // Block from 8219DAE8h-8219DAF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219DAF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DAF0);
		  /* 8219DAF0h */ case    0:  		/* mr R4, R23 */
		/* 8219DAF0h case    0:*/		regs.R4 = regs.R23;
		/* 8219DAF0h case    0:*/		return 0x8219DAF4;
		  /* 8219DAF4h */ case    1:  		/* mr R3, R26 */
		/* 8219DAF4h case    1:*/		regs.R3 = regs.R26;
		/* 8219DAF4h case    1:*/		return 0x8219DAF8;
		  /* 8219DAF8h */ case    2:  		/* bl 558224 */
		/* 8219DAF8h case    2:*/		regs.LR = 0x8219DAFC; return 0x82225F88;
		/* 8219DAF8h case    2:*/		return 0x8219DAFC;
		  /* 8219DAFCh */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219DAFCh case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219DAFCh case    3:*/		return 0x8219DB00;
		  /* 8219DB00h */ case    4:  		/* bc 4, CR0_EQ, 24 */
		/* 8219DB00h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8219DB18;  }
		/* 8219DB00h case    4:*/		return 0x8219DB04;
		  /* 8219DB04h */ case    5:  		/* mr R4, R23 */
		/* 8219DB04h case    5:*/		regs.R4 = regs.R23;
		/* 8219DB04h case    5:*/		return 0x8219DB08;
		  /* 8219DB08h */ case    6:  		/* mr R3, R26 */
		/* 8219DB08h case    6:*/		regs.R3 = regs.R26;
		/* 8219DB08h case    6:*/		return 0x8219DB0C;
		  /* 8219DB0Ch */ case    7:  		/* bl -4412 */
		/* 8219DB0Ch case    7:*/		regs.LR = 0x8219DB10; return 0x8219C9D0;
		/* 8219DB0Ch case    7:*/		return 0x8219DB10;
		  /* 8219DB10h */ case    8:  		/* or. R29, R3, R3 */
		/* 8219DB10h case    8:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8219DB10h case    8:*/		return 0x8219DB14;
		  /* 8219DB14h */ case    9:  		/* bc 4, CR0_EQ, 104 */
		/* 8219DB14h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8219DB7C;  }
		/* 8219DB14h case    9:*/		return 0x8219DB18;
	}
	return 0x8219DB18;
} // Block from 8219DAF0h-8219DB18h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219DB18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DB18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DB18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DB18);
		  /* 8219DB18h */ case    0:  		/* lwz R11, <#[R23]> */
		/* 8219DB18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8219DB18h case    0:*/		return 0x8219DB1C;
		  /* 8219DB1Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8219DB1Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219DB1Ch case    1:*/		return 0x8219DB20;
		  /* 8219DB20h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 8219DB20h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219DB40;  }
		/* 8219DB20h case    2:*/		return 0x8219DB24;
		  /* 8219DB24h */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 8219DB24h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219DB24h case    3:*/		return 0x8219DB28;
		  /* 8219DB28h */ case    4:  		/* cmplw CR6, R10, R26 */
		/* 8219DB28h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R26);
		/* 8219DB28h case    4:*/		return 0x8219DB2C;
		  /* 8219DB2Ch */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 8219DB2Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x8219DB38;  }
		/* 8219DB2Ch case    5:*/		return 0x8219DB30;
		  /* 8219DB30h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219DB30h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219DB30h case    6:*/		return 0x8219DB34;
		  /* 8219DB34h */ case    7:  		/* b -24 */
		/* 8219DB34h case    7:*/		return 0x8219DB1C;
		/* 8219DB34h case    7:*/		return 0x8219DB38;
	}
	return 0x8219DB38;
} // Block from 8219DB18h-8219DB38h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219DB38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DB38);
		  /* 8219DB38h */ case    0:  		/* li R11, 1 */
		/* 8219DB38h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219DB38h case    0:*/		return 0x8219DB3C;
		  /* 8219DB3Ch */ case    1:  		/* b 8 */
		/* 8219DB3Ch case    1:*/		return 0x8219DB44;
		/* 8219DB3Ch case    1:*/		return 0x8219DB40;
	}
	return 0x8219DB40;
} // Block from 8219DB38h-8219DB40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219DB40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DB40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DB40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DB40);
		  /* 8219DB40h */ case    0:  		/* li R11, 0 */
		/* 8219DB40h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219DB40h case    0:*/		return 0x8219DB44;
	}
	return 0x8219DB44;
} // Block from 8219DB40h-8219DB44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219DB44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DB44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DB44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DB44);
		  /* 8219DB44h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219DB44h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219DB44h case    0:*/		return 0x8219DB48;
		  /* 8219DB48h */ case    1:  		/* bc 4, CR0_EQ, 36 */
		/* 8219DB48h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219DB6C;  }
		/* 8219DB48h case    1:*/		return 0x8219DB4C;
		  /* 8219DB4Ch */ case    2:  		/* li R7, 1 */
		/* 8219DB4Ch case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8219DB4Ch case    2:*/		return 0x8219DB50;
		  /* 8219DB50h */ case    3:  		/* li R6, 1 */
		/* 8219DB50h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8219DB50h case    3:*/		return 0x8219DB54;
		  /* 8219DB54h */ case    4:  		/* mr R5, R23 */
		/* 8219DB54h case    4:*/		regs.R5 = regs.R23;
		/* 8219DB54h case    4:*/		return 0x8219DB58;
		  /* 8219DB58h */ case    5:  		/* mr R4, R26 */
		/* 8219DB58h case    5:*/		regs.R4 = regs.R26;
		/* 8219DB58h case    5:*/		return 0x8219DB5C;
		  /* 8219DB5Ch */ case    6:  		/* mr R3, R22 */
		/* 8219DB5Ch case    6:*/		regs.R3 = regs.R22;
		/* 8219DB5Ch case    6:*/		return 0x8219DB60;
		  /* 8219DB60h */ case    7:  		/* bl 589584 */
		/* 8219DB60h case    7:*/		regs.LR = 0x8219DB64; return 0x8222DA70;
		/* 8219DB60h case    7:*/		return 0x8219DB64;
		  /* 8219DB64h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219DB64h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219DB64h case    8:*/		return 0x8219DB68;
		  /* 8219DB68h */ case    9:  		/* bc 4, CR0_EQ, 20 */
		/* 8219DB68h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8219DB7C;  }
		/* 8219DB68h case    9:*/		return 0x8219DB6C;
	}
	return 0x8219DB6C;
} // Block from 8219DB44h-8219DB6Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219DB6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DB6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DB6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DB6C);
		  /* 8219DB6Ch */ case    0:  		/* mr R4, R23 */
		/* 8219DB6Ch case    0:*/		regs.R4 = regs.R23;
		/* 8219DB6Ch case    0:*/		return 0x8219DB70;
		  /* 8219DB70h */ case    1:  		/* mr R3, R26 */
		/* 8219DB70h case    1:*/		regs.R3 = regs.R26;
		/* 8219DB70h case    1:*/		return 0x8219DB74;
		  /* 8219DB74h */ case    2:  		/* bl -4516 */
		/* 8219DB74h case    2:*/		regs.LR = 0x8219DB78; return 0x8219C9D0;
		/* 8219DB74h case    2:*/		return 0x8219DB78;
		  /* 8219DB78h */ case    3:  		/* mr R29, R3 */
		/* 8219DB78h case    3:*/		regs.R29 = regs.R3;
		/* 8219DB78h case    3:*/		return 0x8219DB7C;
	}
	return 0x8219DB7C;
} // Block from 8219DB6Ch-8219DB7Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219DB7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DB7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DB7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DB7C);
		  /* 8219DB7Ch */ case    0:  		/* mr R3, R29 */
		/* 8219DB7Ch case    0:*/		regs.R3 = regs.R29;
		/* 8219DB7Ch case    0:*/		return 0x8219DB80;
		  /* 8219DB80h */ case    1:  		/* b 40 */
		/* 8219DB80h case    1:*/		return 0x8219DBA8;
		/* 8219DB80h case    1:*/		return 0x8219DB84;
	}
	return 0x8219DB84;
} // Block from 8219DB7Ch-8219DB84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219DB84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DB84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DB84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DB84);
		  /* 8219DB84h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8219DB84h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219DB84h case    0:*/		return 0x8219DB88;
		  /* 8219DB88h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 8219DB88h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219DB94;  }
		/* 8219DB88h case    1:*/		return 0x8219DB8C;
	}
	return 0x8219DB8C;
} // Block from 8219DB84h-8219DB8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219DB8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DB8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DB8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DB8C);
		  /* 8219DB8Ch */ case    0:  		/* li R3, 0 */
		/* 8219DB8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219DB8Ch case    0:*/		return 0x8219DB90;
		  /* 8219DB90h */ case    1:  		/* b 24 */
		/* 8219DB90h case    1:*/		return 0x8219DBA8;
		/* 8219DB90h case    1:*/		return 0x8219DB94;
	}
	return 0x8219DB94;
} // Block from 8219DB8Ch-8219DB94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219DB94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DB94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DB94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DB94);
		  /* 8219DB94h */ case    0:  		/* lwz R11, <#[R4]> */
		/* 8219DB94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8219DB94h case    0:*/		return 0x8219DB98;
		  /* 8219DB98h */ case    1:  		/* lwz R10, <#[R3]> */
		/* 8219DB98h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 8219DB98h case    1:*/		return 0x8219DB9C;
		  /* 8219DB9Ch */ case    2:  		/* lwz R4, <#[R11 + 12]> */
		/* 8219DB9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219DB9Ch case    2:*/		return 0x8219DBA0;
		  /* 8219DBA0h */ case    3:  		/* lwz R3, <#[R10 + 12]> */
		/* 8219DBA0h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219DBA0h case    3:*/		return 0x8219DBA4;
		  /* 8219DBA4h */ case    4:  		/* bl -4564 */
		/* 8219DBA4h case    4:*/		regs.LR = 0x8219DBA8; return 0x8219C9D0;
		/* 8219DBA4h case    4:*/		return 0x8219DBA8;
	}
	return 0x8219DBA8;
} // Block from 8219DB94h-8219DBA8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219DBA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DBA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DBA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DBA8);
		  /* 8219DBA8h */ case    0:  		/* addi R1, R1, 176 */
		/* 8219DBA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8219DBA8h case    0:*/		return 0x8219DBAC;
		  /* 8219DBACh */ case    1:  		/* b -1100060 */
		/* 8219DBACh case    1:*/		return 0x82091290;
		/* 8219DBACh case    1:*/		return 0x8219DBB0;
	}
	return 0x8219DBB0;
} // Block from 8219DBA8h-8219DBB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219DBB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DBB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DBB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DBB0);
		  /* 8219DBB0h */ case    0:  		/* mfspr R12, LR */
		/* 8219DBB0h case    0:*/		regs.R12 = regs.LR;
		/* 8219DBB0h case    0:*/		return 0x8219DBB4;
		  /* 8219DBB4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219DBB4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219DBB4h case    1:*/		return 0x8219DBB8;
		  /* 8219DBB8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8219DBB8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8219DBB8h case    2:*/		return 0x8219DBBC;
		  /* 8219DBBCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8219DBBCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219DBBCh case    3:*/		return 0x8219DBC0;
		  /* 8219DBC0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8219DBC0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8219DBC0h case    4:*/		return 0x8219DBC4;
		  /* 8219DBC4h */ case    5:  		/* mr R31, R3 */
		/* 8219DBC4h case    5:*/		regs.R31 = regs.R3;
		/* 8219DBC4h case    5:*/		return 0x8219DBC8;
		  /* 8219DBC8h */ case    6:  		/* mr R30, R4 */
		/* 8219DBC8h case    6:*/		regs.R30 = regs.R4;
		/* 8219DBC8h case    6:*/		return 0x8219DBCC;
		  /* 8219DBCCh */ case    7:  		/* bl -812 */
		/* 8219DBCCh case    7:*/		regs.LR = 0x8219DBD0; return 0x8219D8A0;
		/* 8219DBCCh case    7:*/		return 0x8219DBD0;
		  /* 8219DBD0h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 8219DBD0h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8219DBD0h case    8:*/		return 0x8219DBD4;
		  /* 8219DBD4h */ case    9:  		/* bc 4, CR0_EQ, 52 */
		/* 8219DBD4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8219DC08;  }
		/* 8219DBD4h case    9:*/		return 0x8219DBD8;
		  /* 8219DBD8h */ case   10:  		/* lwz R11, <#[R31 + 4]> */
		/* 8219DBD8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8219DBD8h case   10:*/		return 0x8219DBDC;
		  /* 8219DBDCh */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8219DBDCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219DBDCh case   11:*/		return 0x8219DBE0;
		  /* 8219DBE0h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 8219DBE0h case   12:*/		if ( regs.CR[6].eq ) { return 0x8219DBF4;  }
		/* 8219DBE0h case   12:*/		return 0x8219DBE4;
		  /* 8219DBE4h */ case   13:  		/* lwz R10, <#[R30 + 4]> */
		/* 8219DBE4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 8219DBE4h case   13:*/		return 0x8219DBE8;
		  /* 8219DBE8h */ case   14:  		/* lwz R3, <#[R11 + 12]> */
		/* 8219DBE8h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219DBE8h case   14:*/		return 0x8219DBEC;
		  /* 8219DBECh */ case   15:  		/* lwz R4, <#[R10 + 12]> */
		/* 8219DBECh case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219DBECh case   15:*/		return 0x8219DBF0;
		  /* 8219DBF0h */ case   16:  		/* b 20 */
		/* 8219DBF0h case   16:*/		return 0x8219DC04;
		/* 8219DBF0h case   16:*/		return 0x8219DBF4;
	}
	return 0x8219DBF4;
} // Block from 8219DBB0h-8219DBF4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219DBF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DBF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DBF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DBF4);
		  /* 8219DBF4h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8219DBF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8219DBF4h case    0:*/		return 0x8219DBF8;
		  /* 8219DBF8h */ case    1:  		/* lwz R10, <#[R31]> */
		/* 8219DBF8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8219DBF8h case    1:*/		return 0x8219DBFC;
		  /* 8219DBFCh */ case    2:  		/* lwz R4, <#[R11 + 12]> */
		/* 8219DBFCh case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219DBFCh case    2:*/		return 0x8219DC00;
		  /* 8219DC00h */ case    3:  		/* lwz R3, <#[R10 + 12]> */
		/* 8219DC00h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x0000000C) );
		/* 8219DC00h case    3:*/		return 0x8219DC04;
	}
	return 0x8219DC04;
} // Block from 8219DBF4h-8219DC04h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219DC04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DC04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DC04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DC04);
		  /* 8219DC04h */ case    0:  		/* bl -4660 */
		/* 8219DC04h case    0:*/		regs.LR = 0x8219DC08; return 0x8219C9D0;
		/* 8219DC04h case    0:*/		return 0x8219DC08;
	}
	return 0x8219DC08;
} // Block from 8219DC04h-8219DC08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219DC08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DC08);
		  /* 8219DC08h */ case    0:  		/* addi R1, R1, 112 */
		/* 8219DC08h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8219DC08h case    0:*/		return 0x8219DC0C;
		  /* 8219DC0Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219DC0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219DC0Ch case    1:*/		return 0x8219DC10;
		  /* 8219DC10h */ case    2:  		/* mtspr LR, R12 */
		/* 8219DC10h case    2:*/		regs.LR = regs.R12;
		/* 8219DC10h case    2:*/		return 0x8219DC14;
		  /* 8219DC14h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8219DC14h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8219DC14h case    3:*/		return 0x8219DC18;
		  /* 8219DC18h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8219DC18h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219DC18h case    4:*/		return 0x8219DC1C;
		  /* 8219DC1Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8219DC1Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219DC1Ch case    5:*/		return 0x8219DC20;
	}
	return 0x8219DC20;
} // Block from 8219DC08h-8219DC20h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219DC20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DC20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DC20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DC20);
		  /* 8219DC20h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 8219DC20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219DC20h case    0:*/		return 0x8219DC24;
		  /* 8219DC24h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219DC24h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219DC24h case    1:*/		return 0x8219DC28;
		  /* 8219DC28h */ case    2:  		/* addic R10, R10, -1 */
		/* 8219DC28h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219DC28h case    2:*/		return 0x8219DC2C;
		  /* 8219DC2Ch */ case    3:  		/* subfe R10, R10, R10 */
		/* 8219DC2Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8219DC2Ch case    3:*/		return 0x8219DC30;
		  /* 8219DC30h */ case    4:  		/* and R11, R10, R11 */
		/* 8219DC30h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219DC30h case    4:*/		return 0x8219DC34;
		  /* 8219DC34h */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219DC34h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219DC34h case    5:*/		return 0x8219DC38;
	}
	return 0x8219DC38;
} // Block from 8219DC20h-8219DC38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219DC38h
// Function '?AddMissingMergeOperands@Compiler@D3DXShader@@AAAIPAVInstruction@2@0I00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DC38);
		  /* 8219DC38h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219DC38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219DC38h case    0:*/		return 0x8219DC3C;
		  /* 8219DC3Ch */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219DC3Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219DC3Ch case    1:*/		return 0x8219DC40;
		  /* 8219DC40h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 8219DC40h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8219DC4C;  }
		/* 8219DC40h case    2:*/		return 0x8219DC44;
		  /* 8219DC44h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8219DC44h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219DC44h case    3:*/		return 0x8219DC48;
		  /* 8219DC48h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 8219DC48h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8219DC60;  }
		/* 8219DC48h case    4:*/		return 0x8219DC4C;
	}
	return 0x8219DC4C;
} // Block from 8219DC38h-8219DC4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219DC4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DC4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DC4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DC4C);
		  /* 8219DC4Ch */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219DC4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219DC4Ch case    0:*/		return 0x8219DC50;
		  /* 8219DC50h */ case    1:  		/* lwz R10, <#[R3 + 12]> */
		/* 8219DC50h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8219DC50h case    1:*/		return 0x8219DC54;
		  /* 8219DC54h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8219DC54h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8219DC54h case    2:*/		return 0x8219DC58;
		  /* 8219DC58h */ case    3:  		/* li R11, 1 */
		/* 8219DC58h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219DC58h case    3:*/		return 0x8219DC5C;
		  /* 8219DC5Ch */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 8219DC5Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8219DC64;  }
		/* 8219DC5Ch case    4:*/		return 0x8219DC60;
	}
	return 0x8219DC60;
} // Block from 8219DC4Ch-8219DC60h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219DC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DC60);
		  /* 8219DC60h */ case    0:  		/* li R11, 0 */
		/* 8219DC60h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219DC60h case    0:*/		return 0x8219DC64;
	}
	return 0x8219DC64;
} // Block from 8219DC60h-8219DC64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219DC64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DC64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DC64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DC64);
		  /* 8219DC64h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 8219DC64h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 8219DC64h case    0:*/		return 0x8219DC68;
		  /* 8219DC68h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8219DC68h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219DC68h case    1:*/		return 0x8219DC6C;
	}
	return 0x8219DC6C;
} // Block from 8219DC64h-8219DC6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219DC6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DC6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DC6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DC6C);
		  /* 8219DC6Ch */ case    0:  		/* nop */
		/* 8219DC6Ch case    0:*/		cpu::op::nop();
		/* 8219DC6Ch case    0:*/		return 0x8219DC70;
		  /* 8219DC70h */ case    1:  		/* lwz R8, <#[R3 + 4]> */
		/* 8219DC70h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000004) );
		/* 8219DC70h case    1:*/		return 0x8219DC74;
		  /* 8219DC74h */ case    2:  		/* mr R11, R3 */
		/* 8219DC74h case    2:*/		regs.R11 = regs.R3;
		/* 8219DC74h case    2:*/		return 0x8219DC78;
		  /* 8219DC78h */ case    3:  		/* lwz R10, <#[R3 + 8]> */
		/* 8219DC78h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8219DC78h case    3:*/		return 0x8219DC7C;
		  /* 8219DC7Ch */ case    4:  		/* rlwinm R9, R8, 0, 31, 31 */
		/* 8219DC7Ch case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R8);
		/* 8219DC7Ch case    4:*/		return 0x8219DC80;
		  /* 8219DC80h */ case    5:  		/* addi R7, R10, 2 */
		/* 8219DC80h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x2);
		/* 8219DC80h case    5:*/		return 0x8219DC84;
		  /* 8219DC84h */ case    6:  		/* addic R6, R9, -1 */
		/* 8219DC84h case    6:*/		cpu::op::addic<0>(regs,&regs.R6,regs.R9,0xFFFFFFFF);
		/* 8219DC84h case    6:*/		return 0x8219DC88;
		  /* 8219DC88h */ case    7:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 8219DC88h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 8219DC88h case    7:*/		return 0x8219DC8C;
		  /* 8219DC8Ch */ case    8:  		/* subfe R6, R6, R6 */
		/* 8219DC8Ch case    8:*/		cpu::op::subfe<0>(regs,&regs.R6,regs.R6,regs.R6);
		/* 8219DC8Ch case    8:*/		return 0x8219DC90;
		  /* 8219DC90h */ case    9:  		/* addic R9, R9, -1 */
		/* 8219DC90h case    9:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8219DC90h case    9:*/		return 0x8219DC94;
		  /* 8219DC94h */ case   10:  		/* and R9, R6, R8 */
		/* 8219DC94h case   10:*/		cpu::op::and<0>(regs,&regs.R9,regs.R6,regs.R8);
		/* 8219DC94h case   10:*/		return 0x8219DC98;
		  /* 8219DC98h */ case   11:  		/* subfe R6, R5, R5 */
		/* 8219DC98h case   11:*/		cpu::op::subfe<0>(regs,&regs.R6,regs.R5,regs.R5);
		/* 8219DC98h case   11:*/		return 0x8219DC9C;
		  /* 8219DC9Ch */ case   12:  		/* addi R10, R10, 1 */
		/* 8219DC9Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8219DC9Ch case   12:*/		return 0x8219DCA0;
		  /* 8219DCA0h */ case   13:  		/* and R8, R6, R8 */
		/* 8219DCA0h case   13:*/		cpu::op::and<0>(regs,&regs.R8,regs.R6,regs.R8);
		/* 8219DCA0h case   13:*/		return 0x8219DCA4;
		  /* 8219DCA4h */ case   14:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 8219DCA4h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 8219DCA4h case   14:*/		return 0x8219DCA8;
		  /* 8219DCA8h */ case   15:  		/* lwzx R3, <#[R7 + R9]> */
		/* 8219DCA8h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 8219DCA8h case   15:*/		return 0x8219DCAC;
		  /* 8219DCACh */ case   16:  		/* stw R10, <#[R11 + 8]> */
		/* 8219DCACh case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8219DCACh case   16:*/		return 0x8219DCB0;
		  /* 8219DCB0h */ case   17:  		/* lwz R8, <#[R8 + 4]> */
		/* 8219DCB0h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 8219DCB0h case   17:*/		return 0x8219DCB4;
		  /* 8219DCB4h */ case   18:  		/* rlwinm. R7, R8, 0, 31, 31 */
		/* 8219DCB4h case   18:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R8);
		/* 8219DCB4h case   18:*/		return 0x8219DCB8;
		  /* 8219DCB8h */ case   19:  		/* bc 4, CR0_EQ, 12 */
		/* 8219DCB8h case   19:*/		if ( !regs.CR[0].eq ) { return 0x8219DCC4;  }
		/* 8219DCB8h case   19:*/		return 0x8219DCBC;
		  /* 8219DCBCh */ case   20:  		/* cmplwi CR6, R8, 0 */
		/* 8219DCBCh case   20:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8219DCBCh case   20:*/		return 0x8219DCC0;
		  /* 8219DCC0h */ case   21:  		/* bc 4, CR6_EQ, 28 */
		/* 8219DCC0h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8219DCDC;  }
		/* 8219DCC0h case   21:*/		return 0x8219DCC4;
	}
	return 0x8219DCC4;
} // Block from 8219DC6Ch-8219DCC4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8219DCC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DCC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DCC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DCC4);
		  /* 8219DCC4h */ case    0:  		/* cmplwi CR6, R10, 10 */
		/* 8219DCC4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000A);
		/* 8219DCC4h case    0:*/		return 0x8219DCC8;
		  /* 8219DCC8h */ case    1:  		/* bclr 4, CR6_EQ */
		/* 8219DCC8h case    1:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8219DCC8h case    1:*/		return 0x8219DCCC;
	}
	return 0x8219DCCC;
} // Block from 8219DCC4h-8219DCCCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219DCCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DCCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DCCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DCCC);
		  /* 8219DCCCh */ case    0:  		/* li R10, 0 */
		/* 8219DCCCh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219DCCCh case    0:*/		return 0x8219DCD0;
		  /* 8219DCD0h */ case    1:  		/* stw R10, <#[R11 + 8]> */
		/* 8219DCD0h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 8219DCD0h case    1:*/		return 0x8219DCD4;
		  /* 8219DCD4h */ case    2:  		/* stw R10, <#[R11 + 12]> */
		/* 8219DCD4h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 8219DCD4h case    2:*/		return 0x8219DCD8;
		  /* 8219DCD8h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8219DCD8h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219DCD8h case    3:*/		return 0x8219DCDC;
	}
	return 0x8219DCDC;
} // Block from 8219DCCCh-8219DCDCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219DCDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DCDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DCDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DCDC);
		  /* 8219DCDCh */ case    0:  		/* cmplwi CR6, R10, 10 */
		/* 8219DCDCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000A);
		/* 8219DCDCh case    0:*/		return 0x8219DCE0;
		  /* 8219DCE0h */ case    1:  		/* bclr 4, CR6_EQ */
		/* 8219DCE0h case    1:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8219DCE0h case    1:*/		return 0x8219DCE4;
	}
	return 0x8219DCE4;
} // Block from 8219DCDCh-8219DCE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219DCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DCE4);
		  /* 8219DCE4h */ case    0:  		/* rlwinm R10, R9, 0, 0, 30 */
		/* 8219DCE4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R9);
		/* 8219DCE4h case    0:*/		return 0x8219DCE8;
		  /* 8219DCE8h */ case    1:  		/* rlwinm R8, R11, 0, 0, 19 */
		/* 8219DCE8h case    1:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R8,regs.R11);
		/* 8219DCE8h case    1:*/		return 0x8219DCEC;
		  /* 8219DCECh */ case    2:  		/* li R7, 0 */
		/* 8219DCECh case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219DCECh case    2:*/		return 0x8219DCF0;
		  /* 8219DCF0h */ case    3:  		/* lwz R6, <#[R10 + 4]> */
		/* 8219DCF0h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 8219DCF0h case    3:*/		return 0x8219DCF4;
		  /* 8219DCF4h */ case    4:  		/* lwz R5, <#[R10]> */
		/* 8219DCF4h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 8219DCF4h case    4:*/		return 0x8219DCF8;
		  /* 8219DCF8h */ case    5:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 8219DCF8h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 8219DCF8h case    5:*/		return 0x8219DCFC;
		  /* 8219DCFCh */ case    6:  		/* stw R5, <#[R6]> */
		/* 8219DCFCh case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R6 + 0x00000000) );
		/* 8219DCFCh case    6:*/		return 0x8219DD00;
		  /* 8219DD00h */ case    7:  		/* lwz R6, <#[R10 + 4]> */
		/* 8219DD00h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 8219DD00h case    7:*/		return 0x8219DD04;
		  /* 8219DD04h */ case    8:  		/* lwz R10, <#[R10]> */
		/* 8219DD04h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8219DD04h case    8:*/		return 0x8219DD08;
		  /* 8219DD08h */ case    9:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 8219DD08h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 8219DD08h case    9:*/		return 0x8219DD0C;
		  /* 8219DD0Ch */ case   10:  		/* stw R6, <#[R10]> */
		/* 8219DD0Ch case   10:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 8219DD0Ch case   10:*/		return 0x8219DD10;
		  /* 8219DD10h */ case   11:  		/* lwz R10, <#[R8]> */
		/* 8219DD10h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 8219DD10h case   11:*/		return 0x8219DD14;
		  /* 8219DD14h */ case   12:  		/* lwz R8, <#[R10 + 44]> */
		/* 8219DD14h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000002C) );
		/* 8219DD14h case   12:*/		return 0x8219DD18;
		  /* 8219DD18h */ case   13:  		/* stw R8, <#[R9]> */
		/* 8219DD18h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 8219DD18h case   13:*/		return 0x8219DD1C;
		  /* 8219DD1Ch */ case   14:  		/* stw R9, <#[R10 + 44]> */
		/* 8219DD1Ch case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x0000002C) );
		/* 8219DD1Ch case   14:*/		return 0x8219DD20;
		  /* 8219DD20h */ case   15:  		/* stw R7, <#[R11 + 8]> */
		/* 8219DD20h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 8219DD20h case   15:*/		return 0x8219DD24;
		  /* 8219DD24h */ case   16:  		/* bclr 20, CR0_LT */
		/* 8219DD24h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219DD24h case   16:*/		return 0x8219DD28;
	}
	return 0x8219DD28;
} // Block from 8219DCE4h-8219DD28h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219DD28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DD28);
		  /* 8219DD28h */ case    0:  		/* li R11, 0 */
		/* 8219DD28h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219DD28h case    0:*/		return 0x8219DD2C;
		  /* 8219DD2Ch */ case    1:  		/* stw R11, <#[R3 + 8]> */
		/* 8219DD2Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219DD2Ch case    1:*/		return 0x8219DD30;
		  /* 8219DD30h */ case    2:  		/* stw R11, <#[R3 + 12]> */
		/* 8219DD30h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8219DD30h case    2:*/		return 0x8219DD34;
		  /* 8219DD34h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8219DD34h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219DD34h case    3:*/		return 0x8219DD38;
	}
	return 0x8219DD38;
} // Block from 8219DD28h-8219DD38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219DD38h
// Function '?CleanConstantOperands@Compiler@D3DXShader@@AAAXPAVInstruction@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DD38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DD38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DD38);
		  /* 8219DD38h */ case    0:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219DD38h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219DD38h case    0:*/		return 0x8219DD3C;
		  /* 8219DD3Ch */ case    1:  		/* addic R10, R10, -1 */
		/* 8219DD3Ch case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219DD3Ch case    1:*/		return 0x8219DD40;
		  /* 8219DD40h */ case    2:  		/* subfe R10, R10, R10 */
		/* 8219DD40h case    2:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8219DD40h case    2:*/		return 0x8219DD44;
		  /* 8219DD44h */ case    3:  		/* and R10, R10, R11 */
		/* 8219DD44h case    3:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8219DD44h case    3:*/		return 0x8219DD48;
		  /* 8219DD48h */ case    4:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 8219DD48h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 8219DD48h case    4:*/		return 0x8219DD4C;
		  /* 8219DD4Ch */ case    5:  		/* lwz R9, <#[R11 + 4]> */
		/* 8219DD4Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8219DD4Ch case    5:*/		return 0x8219DD50;
		  /* 8219DD50h */ case    6:  		/* rlwinm. R8, R9, 0, 31, 31 */
		/* 8219DD50h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R9);
		/* 8219DD50h case    6:*/		return 0x8219DD54;
		  /* 8219DD54h */ case    7:  		/* bclr 4, CR0_EQ */
		/* 8219DD54h case    7:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8219DD54h case    7:*/		return 0x8219DD58;
	}
	return 0x8219DD58;
} // Block from 8219DD38h-8219DD58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219DD58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DD58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DD58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DD58);
		  /* 8219DD58h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 8219DD58h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8219DD58h case    0:*/		return 0x8219DD5C;
		  /* 8219DD5Ch */ case    1:  		/* bclr 12, CR6_EQ */
		/* 8219DD5Ch case    1:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8219DD5Ch case    1:*/		return 0x8219DD60;
	}
	return 0x8219DD60;
} // Block from 8219DD58h-8219DD60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219DD60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DD60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DD60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DD60);
		  /* 8219DD60h */ case    0:  		/* rlwinm R9, R9, 0, 0, 31 */
		/* 8219DD60h case    0:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R9,regs.R9);
		/* 8219DD60h case    0:*/		return 0x8219DD64;
		  /* 8219DD64h */ case    1:  		/* lwz R7, <#[R11]> */
		/* 8219DD64h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8219DD64h case    1:*/		return 0x8219DD68;
		  /* 8219DD68h */ case    2:  		/* rlwinm R8, R3, 0, 0, 19 */
		/* 8219DD68h case    2:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R8,regs.R3);
		/* 8219DD68h case    2:*/		return 0x8219DD6C;
		  /* 8219DD6Ch */ case    3:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 8219DD6Ch case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 8219DD6Ch case    3:*/		return 0x8219DD70;
		  /* 8219DD70h */ case    4:  		/* stw R7, <#[R9]> */
		/* 8219DD70h case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 8219DD70h case    4:*/		return 0x8219DD74;
		  /* 8219DD74h */ case    5:  		/* lwz R9, <#[R11 + 4]> */
		/* 8219DD74h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 8219DD74h case    5:*/		return 0x8219DD78;
		  /* 8219DD78h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 8219DD78h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219DD78h case    6:*/		return 0x8219DD7C;
		  /* 8219DD7Ch */ case    7:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219DD7Ch case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219DD7Ch case    7:*/		return 0x8219DD80;
		  /* 8219DD80h */ case    8:  		/* stw R9, <#[R11]> */
		/* 8219DD80h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8219DD80h case    8:*/		return 0x8219DD84;
		  /* 8219DD84h */ case    9:  		/* lwz R11, <#[R8]> */
		/* 8219DD84h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 8219DD84h case    9:*/		return 0x8219DD88;
		  /* 8219DD88h */ case   10:  		/* lwz R9, <#[R11 + 44]> */
		/* 8219DD88h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000002C) );
		/* 8219DD88h case   10:*/		return 0x8219DD8C;
		  /* 8219DD8Ch */ case   11:  		/* stw R9, <#[R10]> */
		/* 8219DD8Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8219DD8Ch case   11:*/		return 0x8219DD90;
		  /* 8219DD90h */ case   12:  		/* stw R10, <#[R11 + 44]> */
		/* 8219DD90h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000002C) );
		/* 8219DD90h case   12:*/		return 0x8219DD94;
		  /* 8219DD94h */ case   13:  		/* b -96 */
		/* 8219DD94h case   13:*/		return 0x8219DD34;
		/* 8219DD94h case   13:*/		return 0x8219DD98;
		  /* 8219DD98h */ case   14:  		/* bclr 20, CR0_LT */
		/* 8219DD98h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219DD98h case   14:*/		return 0x8219DD9C;
	}
	return 0x8219DD9C;
} // Block from 8219DD60h-8219DD9Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8219DD9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DD9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DD9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DD9C);
		  /* 8219DD9Ch */ case    0:  		/* nop */
		/* 8219DD9Ch case    0:*/		cpu::op::nop();
		/* 8219DD9Ch case    0:*/		return 0x8219DDA0;
	}
	return 0x8219DDA0;
} // Block from 8219DD9Ch-8219DDA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219DDA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DDA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DDA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DDA0);
		  /* 8219DDA0h */ case    0:  		/* mfspr R12, LR */
		/* 8219DDA0h case    0:*/		regs.R12 = regs.LR;
		/* 8219DDA0h case    0:*/		return 0x8219DDA4;
		  /* 8219DDA4h */ case    1:  		/* bl -1100620 */
		/* 8219DDA4h case    1:*/		regs.LR = 0x8219DDA8; return 0x82091258;
		/* 8219DDA4h case    1:*/		return 0x8219DDA8;
		  /* 8219DDA8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8219DDA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8219DDA8h case    2:*/		return 0x8219DDAC;
		  /* 8219DDACh */ case    3:  		/* mr R30, R4 */
		/* 8219DDACh case    3:*/		regs.R30 = regs.R4;
		/* 8219DDACh case    3:*/		return 0x8219DDB0;
		  /* 8219DDB0h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219DDB0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219DDB0h case    4:*/		return 0x8219DDB4;
		  /* 8219DDB4h */ case    5:  		/* mr R29, R5 */
		/* 8219DDB4h case    5:*/		regs.R29 = regs.R5;
		/* 8219DDB4h case    5:*/		return 0x8219DDB8;
		  /* 8219DDB8h */ case    6:  		/* li R5, 0 */
		/* 8219DDB8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219DDB8h case    6:*/		return 0x8219DDBC;
		  /* 8219DDBCh */ case    7:  		/* mr R31, R3 */
		/* 8219DDBCh case    7:*/		regs.R31 = regs.R3;
		/* 8219DDBCh case    7:*/		return 0x8219DDC0;
		  /* 8219DDC0h */ case    8:  		/* bl 552256 */
		/* 8219DDC0h case    8:*/		regs.LR = 0x8219DDC4; return 0x82224B00;
		/* 8219DDC0h case    8:*/		return 0x8219DDC4;
		  /* 8219DDC4h */ case    9:  		/* mr R28, R3 */
		/* 8219DDC4h case    9:*/		regs.R28 = regs.R3;
		/* 8219DDC4h case    9:*/		return 0x8219DDC8;
		  /* 8219DDC8h */ case   10:  		/* mr R4, R3 */
		/* 8219DDC8h case   10:*/		regs.R4 = regs.R3;
		/* 8219DDC8h case   10:*/		return 0x8219DDCC;
		  /* 8219DDCCh */ case   11:  		/* mr R6, R29 */
		/* 8219DDCCh case   11:*/		regs.R6 = regs.R29;
		/* 8219DDCCh case   11:*/		return 0x8219DDD0;
		  /* 8219DDD0h */ case   12:  		/* mr R5, R30 */
		/* 8219DDD0h case   12:*/		regs.R5 = regs.R30;
		/* 8219DDD0h case   12:*/		return 0x8219DDD4;
		  /* 8219DDD4h */ case   13:  		/* mr R3, R31 */
		/* 8219DDD4h case   13:*/		regs.R3 = regs.R31;
		/* 8219DDD4h case   13:*/		return 0x8219DDD8;
		  /* 8219DDD8h */ case   14:  		/* bl -200496 */
		/* 8219DDD8h case   14:*/		regs.LR = 0x8219DDDC; return 0x8216CEA8;
		/* 8219DDD8h case   14:*/		return 0x8219DDDC;
		  /* 8219DDDCh */ case   15:  		/* mr R3, R28 */
		/* 8219DDDCh case   15:*/		regs.R3 = regs.R28;
		/* 8219DDDCh case   15:*/		return 0x8219DDE0;
		  /* 8219DDE0h */ case   16:  		/* addi R1, R1, 128 */
		/* 8219DDE0h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8219DDE0h case   16:*/		return 0x8219DDE4;
		  /* 8219DDE4h */ case   17:  		/* b -1100604 */
		/* 8219DDE4h case   17:*/		return 0x820912A8;
		/* 8219DDE4h case   17:*/		return 0x8219DDE8;
	}
	return 0x8219DDE8;
} // Block from 8219DDA0h-8219DDE8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219DDE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DDE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DDE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DDE8);
		  /* 8219DDE8h */ case    0:  		/* mfspr R12, LR */
		/* 8219DDE8h case    0:*/		regs.R12 = regs.LR;
		/* 8219DDE8h case    0:*/		return 0x8219DDEC;
		  /* 8219DDECh */ case    1:  		/* bl -1100700 */
		/* 8219DDECh case    1:*/		regs.LR = 0x8219DDF0; return 0x82091250;
		/* 8219DDECh case    1:*/		return 0x8219DDF0;
		  /* 8219DDF0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219DDF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219DDF0h case    2:*/		return 0x8219DDF4;
		  /* 8219DDF4h */ case    3:  		/* mr R26, R4 */
		/* 8219DDF4h case    3:*/		regs.R26 = regs.R4;
		/* 8219DDF4h case    3:*/		return 0x8219DDF8;
		  /* 8219DDF8h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219DDF8h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219DDF8h case    4:*/		return 0x8219DDFC;
		  /* 8219DDFCh */ case    5:  		/* mr R27, R5 */
		/* 8219DDFCh case    5:*/		regs.R27 = regs.R5;
		/* 8219DDFCh case    5:*/		return 0x8219DE00;
		  /* 8219DE00h */ case    6:  		/* mr R30, R6 */
		/* 8219DE00h case    6:*/		regs.R30 = regs.R6;
		/* 8219DE00h case    6:*/		return 0x8219DE04;
		  /* 8219DE04h */ case    7:  		/* mr R28, R7 */
		/* 8219DE04h case    7:*/		regs.R28 = regs.R7;
		/* 8219DE04h case    7:*/		return 0x8219DE08;
		  /* 8219DE08h */ case    8:  		/* li R8, 4 */
		/* 8219DE08h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219DE08h case    8:*/		return 0x8219DE0C;
		  /* 8219DE0Ch */ case    9:  		/* li R7, 2 */
		/* 8219DE0Ch case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 8219DE0Ch case    9:*/		return 0x8219DE10;
		  /* 8219DE10h */ case   10:  		/* li R6, 1 */
		/* 8219DE10h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8219DE10h case   10:*/		return 0x8219DE14;
		  /* 8219DE14h */ case   11:  		/* li R5, 0 */
		/* 8219DE14h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219DE14h case   11:*/		return 0x8219DE18;
		  /* 8219DE18h */ case   12:  		/* mr R29, R3 */
		/* 8219DE18h case   12:*/		regs.R29 = regs.R3;
		/* 8219DE18h case   12:*/		return 0x8219DE1C;
		  /* 8219DE1Ch */ case   13:  		/* bl 551804 */
		/* 8219DE1Ch case   13:*/		regs.LR = 0x8219DE20; return 0x82224998;
		/* 8219DE1Ch case   13:*/		return 0x8219DE20;
		  /* 8219DE20h */ case   14:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219DE20h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219DE20h case   14:*/		return 0x8219DE24;
		  /* 8219DE24h */ case   15:  		/* mr R31, R3 */
		/* 8219DE24h case   15:*/		regs.R31 = regs.R3;
		/* 8219DE24h case   15:*/		return 0x8219DE28;
		  /* 8219DE28h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8219DE28h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219DE28h case   16:*/		return 0x8219DE2C;
		  /* 8219DE2Ch */ case   17:  		/* mr R4, R30 */
		/* 8219DE2Ch case   17:*/		regs.R4 = regs.R30;
		/* 8219DE2Ch case   17:*/		return 0x8219DE30;
		  /* 8219DE30h */ case   18:  		/* bc 12, CR6_EQ, 20 */
		/* 8219DE30h case   18:*/		if ( regs.CR[6].eq ) { return 0x8219DE44;  }
		/* 8219DE30h case   18:*/		return 0x8219DE34;
		  /* 8219DE34h */ case   19:  		/* mr R3, R29 */
		/* 8219DE34h case   19:*/		regs.R3 = regs.R29;
		/* 8219DE34h case   19:*/		return 0x8219DE38;
		  /* 8219DE38h */ case   20:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219DE38h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219DE38h case   20:*/		return 0x8219DE3C;
		  /* 8219DE3Ch */ case   21:  		/* bl -183628 */
		/* 8219DE3Ch case   21:*/		regs.LR = 0x8219DE40; return 0x821710F0;
		/* 8219DE3Ch case   21:*/		return 0x8219DE40;
		  /* 8219DE40h */ case   22:  		/* mr R4, R3 */
		/* 8219DE40h case   22:*/		regs.R4 = regs.R3;
		/* 8219DE40h case   22:*/		return 0x8219DE44;
	}
	return 0x8219DE44;
} // Block from 8219DDE8h-8219DE44h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219DE44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DE44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DE44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DE44);
		  /* 8219DE44h */ case    0:  		/* mr R3, R31 */
		/* 8219DE44h case    0:*/		regs.R3 = regs.R31;
		/* 8219DE44h case    0:*/		return 0x8219DE48;
		  /* 8219DE48h */ case    1:  		/* bl -154752 */
		/* 8219DE48h case    1:*/		regs.LR = 0x8219DE4C; return 0x821781C8;
		/* 8219DE48h case    1:*/		return 0x8219DE4C;
		  /* 8219DE4Ch */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 8219DE4Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219DE4Ch case    2:*/		return 0x8219DE50;
		  /* 8219DE50h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 8219DE50h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8219DE50h case    3:*/		return 0x8219DE54;
		  /* 8219DE54h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219DE54h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219DE54h case    4:*/		return 0x8219DE58;
		  /* 8219DE58h */ case    5:  		/* mr R4, R28 */
		/* 8219DE58h case    5:*/		regs.R4 = regs.R28;
		/* 8219DE58h case    5:*/		return 0x8219DE5C;
		  /* 8219DE5Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219DE5Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8219DE70;  }
		/* 8219DE5Ch case    6:*/		return 0x8219DE60;
		  /* 8219DE60h */ case    7:  		/* mr R3, R29 */
		/* 8219DE60h case    7:*/		regs.R3 = regs.R29;
		/* 8219DE60h case    7:*/		return 0x8219DE64;
		  /* 8219DE64h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 8219DE64h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 8219DE64h case    8:*/		return 0x8219DE68;
		  /* 8219DE68h */ case    9:  		/* bl -183672 */
		/* 8219DE68h case    9:*/		regs.LR = 0x8219DE6C; return 0x821710F0;
		/* 8219DE68h case    9:*/		return 0x8219DE6C;
		  /* 8219DE6Ch */ case   10:  		/* mr R4, R3 */
		/* 8219DE6Ch case   10:*/		regs.R4 = regs.R3;
		/* 8219DE6Ch case   10:*/		return 0x8219DE70;
	}
	return 0x8219DE70;
} // Block from 8219DE44h-8219DE70h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219DE70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DE70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DE70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DE70);
		  /* 8219DE70h */ case    0:  		/* mr R3, R31 */
		/* 8219DE70h case    0:*/		regs.R3 = regs.R31;
		/* 8219DE70h case    0:*/		return 0x8219DE74;
		  /* 8219DE74h */ case    1:  		/* bl -154796 */
		/* 8219DE74h case    1:*/		regs.LR = 0x8219DE78; return 0x821781C8;
		/* 8219DE74h case    1:*/		return 0x8219DE78;
		  /* 8219DE78h */ case    2:  		/* lwz R11, <#[R31 + 44]> */
		/* 8219DE78h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219DE78h case    2:*/		return 0x8219DE7C;
		  /* 8219DE7Ch */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 8219DE7Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8219DE7Ch case    3:*/		return 0x8219DE80;
		  /* 8219DE80h */ case    4:  		/* mr R6, R27 */
		/* 8219DE80h case    4:*/		regs.R6 = regs.R27;
		/* 8219DE80h case    4:*/		return 0x8219DE84;
		  /* 8219DE84h */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219DE84h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219DE84h case    5:*/		return 0x8219DE88;
		  /* 8219DE88h */ case    6:  		/* mr R5, R26 */
		/* 8219DE88h case    6:*/		regs.R5 = regs.R26;
		/* 8219DE88h case    6:*/		return 0x8219DE8C;
		  /* 8219DE8Ch */ case    7:  		/* mr R4, R31 */
		/* 8219DE8Ch case    7:*/		regs.R4 = regs.R31;
		/* 8219DE8Ch case    7:*/		return 0x8219DE90;
		  /* 8219DE90h */ case    8:  		/* mr R3, R29 */
		/* 8219DE90h case    8:*/		regs.R3 = regs.R29;
		/* 8219DE90h case    8:*/		return 0x8219DE94;
		  /* 8219DE94h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8219DE94h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219DE94h case    9:*/		return 0x8219DE98;
		  /* 8219DE98h */ case   10:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 8219DE98h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 8219DE98h case   10:*/		return 0x8219DE9C;
		  /* 8219DE9Ch */ case   11:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 8219DE9Ch case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 8219DE9Ch case   11:*/		return 0x8219DEA0;
		  /* 8219DEA0h */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 8219DEA0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219DEA0h case   12:*/		return 0x8219DEA4;
		  /* 8219DEA4h */ case   13:  		/* bl -200700 */
		/* 8219DEA4h case   13:*/		regs.LR = 0x8219DEA8; return 0x8216CEA8;
		/* 8219DEA4h case   13:*/		return 0x8219DEA8;
		  /* 8219DEA8h */ case   14:  		/* mr R3, R31 */
		/* 8219DEA8h case   14:*/		regs.R3 = regs.R31;
		/* 8219DEA8h case   14:*/		return 0x8219DEAC;
		  /* 8219DEACh */ case   15:  		/* addi R1, R1, 144 */
		/* 8219DEACh case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219DEACh case   15:*/		return 0x8219DEB0;
		  /* 8219DEB0h */ case   16:  		/* b -1100816 */
		/* 8219DEB0h case   16:*/		return 0x820912A0;
		/* 8219DEB0h case   16:*/		return 0x8219DEB4;
		  /* 8219DEB4h */ case   17:  		/* nop */
		/* 8219DEB4h case   17:*/		cpu::op::nop();
		/* 8219DEB4h case   17:*/		return 0x8219DEB8;
	}
	return 0x8219DEB8;
} // Block from 8219DE70h-8219DEB8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219DEB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DEB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DEB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DEB8);
		  /* 8219DEB8h */ case    0:  		/* mfspr R12, LR */
		/* 8219DEB8h case    0:*/		regs.R12 = regs.LR;
		/* 8219DEB8h case    0:*/		return 0x8219DEBC;
		  /* 8219DEBCh */ case    1:  		/* bl -1100908 */
		/* 8219DEBCh case    1:*/		regs.LR = 0x8219DEC0; return 0x82091250;
		/* 8219DEBCh case    1:*/		return 0x8219DEC0;
		  /* 8219DEC0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219DEC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219DEC0h case    2:*/		return 0x8219DEC4;
		  /* 8219DEC4h */ case    3:  		/* mr R26, R4 */
		/* 8219DEC4h case    3:*/		regs.R26 = regs.R4;
		/* 8219DEC4h case    3:*/		return 0x8219DEC8;
		  /* 8219DEC8h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219DEC8h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219DEC8h case    4:*/		return 0x8219DECC;
		  /* 8219DECCh */ case    5:  		/* mr R27, R5 */
		/* 8219DECCh case    5:*/		regs.R27 = regs.R5;
		/* 8219DECCh case    5:*/		return 0x8219DED0;
	}
	return 0x8219DED0;
} // Block from 8219DEB8h-8219DED0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219DED0h
// Function '?CleanConstantOperands@Compiler@D3DXShader@@AAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DED0);
		  /* 8219DED0h */ case    0:  		/* mr R30, R6 */
		/* 8219DED0h case    0:*/		regs.R30 = regs.R6;
		/* 8219DED0h case    0:*/		return 0x8219DED4;
		  /* 8219DED4h */ case    1:  		/* mr R28, R7 */
		/* 8219DED4h case    1:*/		regs.R28 = regs.R7;
		/* 8219DED4h case    1:*/		return 0x8219DED8;
		  /* 8219DED8h */ case    2:  		/* li R8, 4 */
		/* 8219DED8h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219DED8h case    2:*/		return 0x8219DEDC;
		  /* 8219DEDCh */ case    3:  		/* li R7, 2 */
		/* 8219DEDCh case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 8219DEDCh case    3:*/		return 0x8219DEE0;
		  /* 8219DEE0h */ case    4:  		/* li R6, 3 */
		/* 8219DEE0h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 8219DEE0h case    4:*/		return 0x8219DEE4;
		  /* 8219DEE4h */ case    5:  		/* li R5, 0 */
		/* 8219DEE4h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219DEE4h case    5:*/		return 0x8219DEE8;
		  /* 8219DEE8h */ case    6:  		/* mr R29, R3 */
		/* 8219DEE8h case    6:*/		regs.R29 = regs.R3;
		/* 8219DEE8h case    6:*/		return 0x8219DEEC;
		  /* 8219DEECh */ case    7:  		/* bl 551596 */
		/* 8219DEECh case    7:*/		regs.LR = 0x8219DEF0; return 0x82224998;
		/* 8219DEECh case    7:*/		return 0x8219DEF0;
		  /* 8219DEF0h */ case    8:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219DEF0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219DEF0h case    8:*/		return 0x8219DEF4;
		  /* 8219DEF4h */ case    9:  		/* mr R31, R3 */
		/* 8219DEF4h case    9:*/		regs.R31 = regs.R3;
		/* 8219DEF4h case    9:*/		return 0x8219DEF8;
		  /* 8219DEF8h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 8219DEF8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219DEF8h case   10:*/		return 0x8219DEFC;
		  /* 8219DEFCh */ case   11:  		/* mr R4, R30 */
		/* 8219DEFCh case   11:*/		regs.R4 = regs.R30;
		/* 8219DEFCh case   11:*/		return 0x8219DF00;
		  /* 8219DF00h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 8219DF00h case   12:*/		if ( regs.CR[6].eq ) { return 0x8219DF14;  }
		/* 8219DF00h case   12:*/		return 0x8219DF04;
		  /* 8219DF04h */ case   13:  		/* mr R3, R29 */
		/* 8219DF04h case   13:*/		regs.R3 = regs.R29;
		/* 8219DF04h case   13:*/		return 0x8219DF08;
		  /* 8219DF08h */ case   14:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219DF08h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219DF08h case   14:*/		return 0x8219DF0C;
		  /* 8219DF0Ch */ case   15:  		/* bl -183836 */
		/* 8219DF0Ch case   15:*/		regs.LR = 0x8219DF10; return 0x821710F0;
		/* 8219DF0Ch case   15:*/		return 0x8219DF10;
		  /* 8219DF10h */ case   16:  		/* mr R4, R3 */
		/* 8219DF10h case   16:*/		regs.R4 = regs.R3;
		/* 8219DF10h case   16:*/		return 0x8219DF14;
	}
	return 0x8219DF14;
} // Block from 8219DED0h-8219DF14h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219DF14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DF14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DF14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DF14);
		  /* 8219DF14h */ case    0:  		/* mr R3, R31 */
		/* 8219DF14h case    0:*/		regs.R3 = regs.R31;
		/* 8219DF14h case    0:*/		return 0x8219DF18;
		  /* 8219DF18h */ case    1:  		/* bl -154960 */
		/* 8219DF18h case    1:*/		regs.LR = 0x8219DF1C; return 0x821781C8;
		/* 8219DF18h case    1:*/		return 0x8219DF1C;
		  /* 8219DF1Ch */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 8219DF1Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219DF1Ch case    2:*/		return 0x8219DF20;
		  /* 8219DF20h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 8219DF20h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8219DF20h case    3:*/		return 0x8219DF24;
		  /* 8219DF24h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219DF24h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219DF24h case    4:*/		return 0x8219DF28;
		  /* 8219DF28h */ case    5:  		/* mr R4, R28 */
		/* 8219DF28h case    5:*/		regs.R4 = regs.R28;
		/* 8219DF28h case    5:*/		return 0x8219DF2C;
		  /* 8219DF2Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219DF2Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8219DF40;  }
		/* 8219DF2Ch case    6:*/		return 0x8219DF30;
		  /* 8219DF30h */ case    7:  		/* mr R3, R29 */
		/* 8219DF30h case    7:*/		regs.R3 = regs.R29;
		/* 8219DF30h case    7:*/		return 0x8219DF34;
		  /* 8219DF34h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 8219DF34h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 8219DF34h case    8:*/		return 0x8219DF38;
		  /* 8219DF38h */ case    9:  		/* bl -183880 */
		/* 8219DF38h case    9:*/		regs.LR = 0x8219DF3C; return 0x821710F0;
		/* 8219DF38h case    9:*/		return 0x8219DF3C;
		  /* 8219DF3Ch */ case   10:  		/* mr R4, R3 */
		/* 8219DF3Ch case   10:*/		regs.R4 = regs.R3;
		/* 8219DF3Ch case   10:*/		return 0x8219DF40;
	}
	return 0x8219DF40;
} // Block from 8219DF14h-8219DF40h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219DF40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DF40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DF40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DF40);
		  /* 8219DF40h */ case    0:  		/* mr R3, R31 */
		/* 8219DF40h case    0:*/		regs.R3 = regs.R31;
		/* 8219DF40h case    0:*/		return 0x8219DF44;
		  /* 8219DF44h */ case    1:  		/* bl -155004 */
		/* 8219DF44h case    1:*/		regs.LR = 0x8219DF48; return 0x821781C8;
		/* 8219DF44h case    1:*/		return 0x8219DF48;
		  /* 8219DF48h */ case    2:  		/* lwz R11, <#[R31 + 44]> */
		/* 8219DF48h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219DF48h case    2:*/		return 0x8219DF4C;
		  /* 8219DF4Ch */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 8219DF4Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8219DF4Ch case    3:*/		return 0x8219DF50;
		  /* 8219DF50h */ case    4:  		/* mr R6, R27 */
		/* 8219DF50h case    4:*/		regs.R6 = regs.R27;
		/* 8219DF50h case    4:*/		return 0x8219DF54;
		  /* 8219DF54h */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219DF54h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219DF54h case    5:*/		return 0x8219DF58;
		  /* 8219DF58h */ case    6:  		/* mr R5, R26 */
		/* 8219DF58h case    6:*/		regs.R5 = regs.R26;
		/* 8219DF58h case    6:*/		return 0x8219DF5C;
		  /* 8219DF5Ch */ case    7:  		/* mr R4, R31 */
		/* 8219DF5Ch case    7:*/		regs.R4 = regs.R31;
		/* 8219DF5Ch case    7:*/		return 0x8219DF60;
		  /* 8219DF60h */ case    8:  		/* mr R3, R29 */
		/* 8219DF60h case    8:*/		regs.R3 = regs.R29;
		/* 8219DF60h case    8:*/		return 0x8219DF64;
		  /* 8219DF64h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8219DF64h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219DF64h case    9:*/		return 0x8219DF68;
		  /* 8219DF68h */ case   10:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 8219DF68h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 8219DF68h case   10:*/		return 0x8219DF6C;
		  /* 8219DF6Ch */ case   11:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 8219DF6Ch case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 8219DF6Ch case   11:*/		return 0x8219DF70;
		  /* 8219DF70h */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 8219DF70h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219DF70h case   12:*/		return 0x8219DF74;
		  /* 8219DF74h */ case   13:  		/* bl -200908 */
		/* 8219DF74h case   13:*/		regs.LR = 0x8219DF78; return 0x8216CEA8;
		/* 8219DF74h case   13:*/		return 0x8219DF78;
		  /* 8219DF78h */ case   14:  		/* mr R3, R31 */
		/* 8219DF78h case   14:*/		regs.R3 = regs.R31;
		/* 8219DF78h case   14:*/		return 0x8219DF7C;
		  /* 8219DF7Ch */ case   15:  		/* addi R1, R1, 144 */
		/* 8219DF7Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219DF7Ch case   15:*/		return 0x8219DF80;
	}
	return 0x8219DF80;
} // Block from 8219DF40h-8219DF80h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219DF80h
// Function '?FindAddChain@Compiler@D3DXShader@@AAAXPAVInstruction@2@0W4Component@2@I01I0PAUAddChainInfo@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DF80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DF80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DF80);
		  /* 8219DF80h */ case    0:  		/* b -1101024 */
		/* 8219DF80h case    0:*/		return 0x820912A0;
		/* 8219DF80h case    0:*/		return 0x8219DF84;
		  /* 8219DF84h */ case    1:  		/* nop */
		/* 8219DF84h case    1:*/		cpu::op::nop();
		/* 8219DF84h case    1:*/		return 0x8219DF88;
	}
	return 0x8219DF88;
} // Block from 8219DF80h-8219DF88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219DF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DF88);
		  /* 8219DF88h */ case    0:  		/* mfspr R12, LR */
		/* 8219DF88h case    0:*/		regs.R12 = regs.LR;
		/* 8219DF88h case    0:*/		return 0x8219DF8C;
		  /* 8219DF8Ch */ case    1:  		/* bl -1101116 */
		/* 8219DF8Ch case    1:*/		regs.LR = 0x8219DF90; return 0x82091250;
		/* 8219DF8Ch case    1:*/		return 0x8219DF90;
		  /* 8219DF90h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219DF90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219DF90h case    2:*/		return 0x8219DF94;
		  /* 8219DF94h */ case    3:  		/* mr R26, R4 */
		/* 8219DF94h case    3:*/		regs.R26 = regs.R4;
		/* 8219DF94h case    3:*/		return 0x8219DF98;
		  /* 8219DF98h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219DF98h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219DF98h case    4:*/		return 0x8219DF9C;
		  /* 8219DF9Ch */ case    5:  		/* mr R27, R5 */
		/* 8219DF9Ch case    5:*/		regs.R27 = regs.R5;
		/* 8219DF9Ch case    5:*/		return 0x8219DFA0;
		  /* 8219DFA0h */ case    6:  		/* mr R30, R6 */
		/* 8219DFA0h case    6:*/		regs.R30 = regs.R6;
		/* 8219DFA0h case    6:*/		return 0x8219DFA4;
		  /* 8219DFA4h */ case    7:  		/* mr R28, R7 */
		/* 8219DFA4h case    7:*/		regs.R28 = regs.R7;
		/* 8219DFA4h case    7:*/		return 0x8219DFA8;
		  /* 8219DFA8h */ case    8:  		/* li R8, 4 */
		/* 8219DFA8h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219DFA8h case    8:*/		return 0x8219DFAC;
		  /* 8219DFACh */ case    9:  		/* li R7, 2 */
		/* 8219DFACh case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 8219DFACh case    9:*/		return 0x8219DFB0;
		  /* 8219DFB0h */ case   10:  		/* li R6, 4 */
		/* 8219DFB0h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8219DFB0h case   10:*/		return 0x8219DFB4;
		  /* 8219DFB4h */ case   11:  		/* li R5, 0 */
		/* 8219DFB4h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219DFB4h case   11:*/		return 0x8219DFB8;
		  /* 8219DFB8h */ case   12:  		/* mr R29, R3 */
		/* 8219DFB8h case   12:*/		regs.R29 = regs.R3;
		/* 8219DFB8h case   12:*/		return 0x8219DFBC;
		  /* 8219DFBCh */ case   13:  		/* bl 551388 */
		/* 8219DFBCh case   13:*/		regs.LR = 0x8219DFC0; return 0x82224998;
		/* 8219DFBCh case   13:*/		return 0x8219DFC0;
		  /* 8219DFC0h */ case   14:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219DFC0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219DFC0h case   14:*/		return 0x8219DFC4;
		  /* 8219DFC4h */ case   15:  		/* mr R31, R3 */
		/* 8219DFC4h case   15:*/		regs.R31 = regs.R3;
		/* 8219DFC4h case   15:*/		return 0x8219DFC8;
		  /* 8219DFC8h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8219DFC8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219DFC8h case   16:*/		return 0x8219DFCC;
		  /* 8219DFCCh */ case   17:  		/* mr R4, R30 */
		/* 8219DFCCh case   17:*/		regs.R4 = regs.R30;
		/* 8219DFCCh case   17:*/		return 0x8219DFD0;
		  /* 8219DFD0h */ case   18:  		/* bc 12, CR6_EQ, 20 */
		/* 8219DFD0h case   18:*/		if ( regs.CR[6].eq ) { return 0x8219DFE4;  }
		/* 8219DFD0h case   18:*/		return 0x8219DFD4;
		  /* 8219DFD4h */ case   19:  		/* mr R3, R29 */
		/* 8219DFD4h case   19:*/		regs.R3 = regs.R29;
		/* 8219DFD4h case   19:*/		return 0x8219DFD8;
		  /* 8219DFD8h */ case   20:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219DFD8h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219DFD8h case   20:*/		return 0x8219DFDC;
		  /* 8219DFDCh */ case   21:  		/* bl -184044 */
		/* 8219DFDCh case   21:*/		regs.LR = 0x8219DFE0; return 0x821710F0;
		/* 8219DFDCh case   21:*/		return 0x8219DFE0;
		  /* 8219DFE0h */ case   22:  		/* mr R4, R3 */
		/* 8219DFE0h case   22:*/		regs.R4 = regs.R3;
		/* 8219DFE0h case   22:*/		return 0x8219DFE4;
	}
	return 0x8219DFE4;
} // Block from 8219DF88h-8219DFE4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219DFE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219DFE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219DFE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219DFE4);
		  /* 8219DFE4h */ case    0:  		/* mr R3, R31 */
		/* 8219DFE4h case    0:*/		regs.R3 = regs.R31;
		/* 8219DFE4h case    0:*/		return 0x8219DFE8;
		  /* 8219DFE8h */ case    1:  		/* bl -155168 */
		/* 8219DFE8h case    1:*/		regs.LR = 0x8219DFEC; return 0x821781C8;
		/* 8219DFE8h case    1:*/		return 0x8219DFEC;
		  /* 8219DFECh */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 8219DFECh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219DFECh case    2:*/		return 0x8219DFF0;
		  /* 8219DFF0h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 8219DFF0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8219DFF0h case    3:*/		return 0x8219DFF4;
		  /* 8219DFF4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219DFF4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219DFF4h case    4:*/		return 0x8219DFF8;
		  /* 8219DFF8h */ case    5:  		/* mr R4, R28 */
		/* 8219DFF8h case    5:*/		regs.R4 = regs.R28;
		/* 8219DFF8h case    5:*/		return 0x8219DFFC;
		  /* 8219DFFCh */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219DFFCh case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E010;  }
		/* 8219DFFCh case    6:*/		return 0x8219E000;
		  /* 8219E000h */ case    7:  		/* mr R3, R29 */
		/* 8219E000h case    7:*/		regs.R3 = regs.R29;
		/* 8219E000h case    7:*/		return 0x8219E004;
		  /* 8219E004h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 8219E004h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 8219E004h case    8:*/		return 0x8219E008;
		  /* 8219E008h */ case    9:  		/* bl -184088 */
		/* 8219E008h case    9:*/		regs.LR = 0x8219E00C; return 0x821710F0;
		/* 8219E008h case    9:*/		return 0x8219E00C;
		  /* 8219E00Ch */ case   10:  		/* mr R4, R3 */
		/* 8219E00Ch case   10:*/		regs.R4 = regs.R3;
		/* 8219E00Ch case   10:*/		return 0x8219E010;
	}
	return 0x8219E010;
} // Block from 8219DFE4h-8219E010h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E010);
		  /* 8219E010h */ case    0:  		/* mr R3, R31 */
		/* 8219E010h case    0:*/		regs.R3 = regs.R31;
		/* 8219E010h case    0:*/		return 0x8219E014;
		  /* 8219E014h */ case    1:  		/* bl -155212 */
		/* 8219E014h case    1:*/		regs.LR = 0x8219E018; return 0x821781C8;
		/* 8219E014h case    1:*/		return 0x8219E018;
		  /* 8219E018h */ case    2:  		/* lwz R11, <#[R31 + 44]> */
		/* 8219E018h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E018h case    2:*/		return 0x8219E01C;
		  /* 8219E01Ch */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 8219E01Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8219E01Ch case    3:*/		return 0x8219E020;
		  /* 8219E020h */ case    4:  		/* mr R6, R27 */
		/* 8219E020h case    4:*/		regs.R6 = regs.R27;
		/* 8219E020h case    4:*/		return 0x8219E024;
		  /* 8219E024h */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219E024h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E024h case    5:*/		return 0x8219E028;
		  /* 8219E028h */ case    6:  		/* mr R5, R26 */
		/* 8219E028h case    6:*/		regs.R5 = regs.R26;
		/* 8219E028h case    6:*/		return 0x8219E02C;
		  /* 8219E02Ch */ case    7:  		/* mr R4, R31 */
		/* 8219E02Ch case    7:*/		regs.R4 = regs.R31;
		/* 8219E02Ch case    7:*/		return 0x8219E030;
		  /* 8219E030h */ case    8:  		/* mr R3, R29 */
		/* 8219E030h case    8:*/		regs.R3 = regs.R29;
		/* 8219E030h case    8:*/		return 0x8219E034;
		  /* 8219E034h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8219E034h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219E034h case    9:*/		return 0x8219E038;
		  /* 8219E038h */ case   10:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 8219E038h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 8219E038h case   10:*/		return 0x8219E03C;
		  /* 8219E03Ch */ case   11:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 8219E03Ch case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 8219E03Ch case   11:*/		return 0x8219E040;
		  /* 8219E040h */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 8219E040h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E040h case   12:*/		return 0x8219E044;
		  /* 8219E044h */ case   13:  		/* bl -201116 */
		/* 8219E044h case   13:*/		regs.LR = 0x8219E048; return 0x8216CEA8;
		/* 8219E044h case   13:*/		return 0x8219E048;
		  /* 8219E048h */ case   14:  		/* mr R3, R31 */
		/* 8219E048h case   14:*/		regs.R3 = regs.R31;
		/* 8219E048h case   14:*/		return 0x8219E04C;
		  /* 8219E04Ch */ case   15:  		/* addi R1, R1, 144 */
		/* 8219E04Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219E04Ch case   15:*/		return 0x8219E050;
		  /* 8219E050h */ case   16:  		/* b -1101232 */
		/* 8219E050h case   16:*/		return 0x820912A0;
		/* 8219E050h case   16:*/		return 0x8219E054;
		  /* 8219E054h */ case   17:  		/* nop */
		/* 8219E054h case   17:*/		cpu::op::nop();
		/* 8219E054h case   17:*/		return 0x8219E058;
	}
	return 0x8219E058;
} // Block from 8219E010h-8219E058h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219E058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E058);
		  /* 8219E058h */ case    0:  		/* mfspr R12, LR */
		/* 8219E058h case    0:*/		regs.R12 = regs.LR;
		/* 8219E058h case    0:*/		return 0x8219E05C;
		  /* 8219E05Ch */ case    1:  		/* bl -1101324 */
		/* 8219E05Ch case    1:*/		regs.LR = 0x8219E060; return 0x82091250;
		/* 8219E05Ch case    1:*/		return 0x8219E060;
		  /* 8219E060h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219E060h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219E060h case    2:*/		return 0x8219E064;
		  /* 8219E064h */ case    3:  		/* mr R26, R4 */
		/* 8219E064h case    3:*/		regs.R26 = regs.R4;
		/* 8219E064h case    3:*/		return 0x8219E068;
		  /* 8219E068h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219E068h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219E068h case    4:*/		return 0x8219E06C;
		  /* 8219E06Ch */ case    5:  		/* mr R27, R5 */
		/* 8219E06Ch case    5:*/		regs.R27 = regs.R5;
		/* 8219E06Ch case    5:*/		return 0x8219E070;
		  /* 8219E070h */ case    6:  		/* mr R30, R6 */
		/* 8219E070h case    6:*/		regs.R30 = regs.R6;
		/* 8219E070h case    6:*/		return 0x8219E074;
		  /* 8219E074h */ case    7:  		/* mr R28, R7 */
		/* 8219E074h case    7:*/		regs.R28 = regs.R7;
		/* 8219E074h case    7:*/		return 0x8219E078;
		  /* 8219E078h */ case    8:  		/* li R8, 4 */
		/* 8219E078h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219E078h case    8:*/		return 0x8219E07C;
		  /* 8219E07Ch */ case    9:  		/* li R7, 2 */
		/* 8219E07Ch case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 8219E07Ch case    9:*/		return 0x8219E080;
		  /* 8219E080h */ case   10:  		/* li R6, 5 */
		/* 8219E080h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x5);
		/* 8219E080h case   10:*/		return 0x8219E084;
		  /* 8219E084h */ case   11:  		/* li R5, 0 */
		/* 8219E084h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219E084h case   11:*/		return 0x8219E088;
		  /* 8219E088h */ case   12:  		/* mr R29, R3 */
		/* 8219E088h case   12:*/		regs.R29 = regs.R3;
		/* 8219E088h case   12:*/		return 0x8219E08C;
		  /* 8219E08Ch */ case   13:  		/* bl 551180 */
		/* 8219E08Ch case   13:*/		regs.LR = 0x8219E090; return 0x82224998;
		/* 8219E08Ch case   13:*/		return 0x8219E090;
		  /* 8219E090h */ case   14:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219E090h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219E090h case   14:*/		return 0x8219E094;
		  /* 8219E094h */ case   15:  		/* mr R31, R3 */
		/* 8219E094h case   15:*/		regs.R31 = regs.R3;
		/* 8219E094h case   15:*/		return 0x8219E098;
		  /* 8219E098h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8219E098h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E098h case   16:*/		return 0x8219E09C;
		  /* 8219E09Ch */ case   17:  		/* mr R4, R30 */
		/* 8219E09Ch case   17:*/		regs.R4 = regs.R30;
		/* 8219E09Ch case   17:*/		return 0x8219E0A0;
		  /* 8219E0A0h */ case   18:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E0A0h case   18:*/		if ( regs.CR[6].eq ) { return 0x8219E0B4;  }
		/* 8219E0A0h case   18:*/		return 0x8219E0A4;
		  /* 8219E0A4h */ case   19:  		/* mr R3, R29 */
		/* 8219E0A4h case   19:*/		regs.R3 = regs.R29;
		/* 8219E0A4h case   19:*/		return 0x8219E0A8;
		  /* 8219E0A8h */ case   20:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219E0A8h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219E0A8h case   20:*/		return 0x8219E0AC;
		  /* 8219E0ACh */ case   21:  		/* bl -184252 */
		/* 8219E0ACh case   21:*/		regs.LR = 0x8219E0B0; return 0x821710F0;
		/* 8219E0ACh case   21:*/		return 0x8219E0B0;
		  /* 8219E0B0h */ case   22:  		/* mr R4, R3 */
		/* 8219E0B0h case   22:*/		regs.R4 = regs.R3;
		/* 8219E0B0h case   22:*/		return 0x8219E0B4;
	}
	return 0x8219E0B4;
} // Block from 8219E058h-8219E0B4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219E0B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E0B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E0B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E0B4);
		  /* 8219E0B4h */ case    0:  		/* mr R3, R31 */
		/* 8219E0B4h case    0:*/		regs.R3 = regs.R31;
		/* 8219E0B4h case    0:*/		return 0x8219E0B8;
		  /* 8219E0B8h */ case    1:  		/* bl -155376 */
		/* 8219E0B8h case    1:*/		regs.LR = 0x8219E0BC; return 0x821781C8;
		/* 8219E0B8h case    1:*/		return 0x8219E0BC;
		  /* 8219E0BCh */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 8219E0BCh case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E0BCh case    2:*/		return 0x8219E0C0;
		  /* 8219E0C0h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 8219E0C0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8219E0C0h case    3:*/		return 0x8219E0C4;
		  /* 8219E0C4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E0C4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E0C4h case    4:*/		return 0x8219E0C8;
		  /* 8219E0C8h */ case    5:  		/* mr R4, R28 */
		/* 8219E0C8h case    5:*/		regs.R4 = regs.R28;
		/* 8219E0C8h case    5:*/		return 0x8219E0CC;
		  /* 8219E0CCh */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E0CCh case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E0E0;  }
		/* 8219E0CCh case    6:*/		return 0x8219E0D0;
		  /* 8219E0D0h */ case    7:  		/* mr R3, R29 */
		/* 8219E0D0h case    7:*/		regs.R3 = regs.R29;
		/* 8219E0D0h case    7:*/		return 0x8219E0D4;
		  /* 8219E0D4h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 8219E0D4h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 8219E0D4h case    8:*/		return 0x8219E0D8;
		  /* 8219E0D8h */ case    9:  		/* bl -184296 */
		/* 8219E0D8h case    9:*/		regs.LR = 0x8219E0DC; return 0x821710F0;
		/* 8219E0D8h case    9:*/		return 0x8219E0DC;
		  /* 8219E0DCh */ case   10:  		/* mr R4, R3 */
		/* 8219E0DCh case   10:*/		regs.R4 = regs.R3;
		/* 8219E0DCh case   10:*/		return 0x8219E0E0;
	}
	return 0x8219E0E0;
} // Block from 8219E0B4h-8219E0E0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E0E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E0E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E0E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E0E0);
		  /* 8219E0E0h */ case    0:  		/* mr R3, R31 */
		/* 8219E0E0h case    0:*/		regs.R3 = regs.R31;
		/* 8219E0E0h case    0:*/		return 0x8219E0E4;
		  /* 8219E0E4h */ case    1:  		/* bl -155420 */
		/* 8219E0E4h case    1:*/		regs.LR = 0x8219E0E8; return 0x821781C8;
		/* 8219E0E4h case    1:*/		return 0x8219E0E8;
		  /* 8219E0E8h */ case    2:  		/* lwz R11, <#[R31 + 44]> */
		/* 8219E0E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E0E8h case    2:*/		return 0x8219E0EC;
		  /* 8219E0ECh */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 8219E0ECh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8219E0ECh case    3:*/		return 0x8219E0F0;
		  /* 8219E0F0h */ case    4:  		/* mr R6, R27 */
		/* 8219E0F0h case    4:*/		regs.R6 = regs.R27;
		/* 8219E0F0h case    4:*/		return 0x8219E0F4;
		  /* 8219E0F4h */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219E0F4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E0F4h case    5:*/		return 0x8219E0F8;
		  /* 8219E0F8h */ case    6:  		/* mr R5, R26 */
		/* 8219E0F8h case    6:*/		regs.R5 = regs.R26;
		/* 8219E0F8h case    6:*/		return 0x8219E0FC;
		  /* 8219E0FCh */ case    7:  		/* mr R4, R31 */
		/* 8219E0FCh case    7:*/		regs.R4 = regs.R31;
		/* 8219E0FCh case    7:*/		return 0x8219E100;
		  /* 8219E100h */ case    8:  		/* mr R3, R29 */
		/* 8219E100h case    8:*/		regs.R3 = regs.R29;
		/* 8219E100h case    8:*/		return 0x8219E104;
		  /* 8219E104h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8219E104h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219E104h case    9:*/		return 0x8219E108;
		  /* 8219E108h */ case   10:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 8219E108h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 8219E108h case   10:*/		return 0x8219E10C;
		  /* 8219E10Ch */ case   11:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 8219E10Ch case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 8219E10Ch case   11:*/		return 0x8219E110;
		  /* 8219E110h */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 8219E110h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E110h case   12:*/		return 0x8219E114;
		  /* 8219E114h */ case   13:  		/* bl -201324 */
		/* 8219E114h case   13:*/		regs.LR = 0x8219E118; return 0x8216CEA8;
		/* 8219E114h case   13:*/		return 0x8219E118;
		  /* 8219E118h */ case   14:  		/* mr R3, R31 */
		/* 8219E118h case   14:*/		regs.R3 = regs.R31;
		/* 8219E118h case   14:*/		return 0x8219E11C;
		  /* 8219E11Ch */ case   15:  		/* addi R1, R1, 144 */
		/* 8219E11Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219E11Ch case   15:*/		return 0x8219E120;
		  /* 8219E120h */ case   16:  		/* b -1101440 */
		/* 8219E120h case   16:*/		return 0x820912A0;
		/* 8219E120h case   16:*/		return 0x8219E124;
		  /* 8219E124h */ case   17:  		/* nop */
		/* 8219E124h case   17:*/		cpu::op::nop();
		/* 8219E124h case   17:*/		return 0x8219E128;
	}
	return 0x8219E128;
} // Block from 8219E0E0h-8219E128h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219E128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E128);
		  /* 8219E128h */ case    0:  		/* mfspr R12, LR */
		/* 8219E128h case    0:*/		regs.R12 = regs.LR;
		/* 8219E128h case    0:*/		return 0x8219E12C;
		  /* 8219E12Ch */ case    1:  		/* bl -1101532 */
		/* 8219E12Ch case    1:*/		regs.LR = 0x8219E130; return 0x82091250;
		/* 8219E12Ch case    1:*/		return 0x8219E130;
		  /* 8219E130h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219E130h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219E130h case    2:*/		return 0x8219E134;
		  /* 8219E134h */ case    3:  		/* mr R26, R4 */
		/* 8219E134h case    3:*/		regs.R26 = regs.R4;
		/* 8219E134h case    3:*/		return 0x8219E138;
		  /* 8219E138h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219E138h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219E138h case    4:*/		return 0x8219E13C;
		  /* 8219E13Ch */ case    5:  		/* mr R27, R5 */
		/* 8219E13Ch case    5:*/		regs.R27 = regs.R5;
		/* 8219E13Ch case    5:*/		return 0x8219E140;
		  /* 8219E140h */ case    6:  		/* mr R30, R6 */
		/* 8219E140h case    6:*/		regs.R30 = regs.R6;
		/* 8219E140h case    6:*/		return 0x8219E144;
		  /* 8219E144h */ case    7:  		/* mr R28, R7 */
		/* 8219E144h case    7:*/		regs.R28 = regs.R7;
		/* 8219E144h case    7:*/		return 0x8219E148;
		  /* 8219E148h */ case    8:  		/* li R8, 4 */
		/* 8219E148h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219E148h case    8:*/		return 0x8219E14C;
		  /* 8219E14Ch */ case    9:  		/* li R7, 2 */
		/* 8219E14Ch case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 8219E14Ch case    9:*/		return 0x8219E150;
		  /* 8219E150h */ case   10:  		/* li R6, 8 */
		/* 8219E150h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x8);
		/* 8219E150h case   10:*/		return 0x8219E154;
		  /* 8219E154h */ case   11:  		/* li R5, 0 */
		/* 8219E154h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219E154h case   11:*/		return 0x8219E158;
		  /* 8219E158h */ case   12:  		/* mr R29, R3 */
		/* 8219E158h case   12:*/		regs.R29 = regs.R3;
		/* 8219E158h case   12:*/		return 0x8219E15C;
		  /* 8219E15Ch */ case   13:  		/* bl 550972 */
		/* 8219E15Ch case   13:*/		regs.LR = 0x8219E160; return 0x82224998;
		/* 8219E15Ch case   13:*/		return 0x8219E160;
		  /* 8219E160h */ case   14:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219E160h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219E160h case   14:*/		return 0x8219E164;
		  /* 8219E164h */ case   15:  		/* mr R31, R3 */
		/* 8219E164h case   15:*/		regs.R31 = regs.R3;
		/* 8219E164h case   15:*/		return 0x8219E168;
		  /* 8219E168h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8219E168h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E168h case   16:*/		return 0x8219E16C;
		  /* 8219E16Ch */ case   17:  		/* mr R4, R30 */
		/* 8219E16Ch case   17:*/		regs.R4 = regs.R30;
		/* 8219E16Ch case   17:*/		return 0x8219E170;
		  /* 8219E170h */ case   18:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E170h case   18:*/		if ( regs.CR[6].eq ) { return 0x8219E184;  }
		/* 8219E170h case   18:*/		return 0x8219E174;
		  /* 8219E174h */ case   19:  		/* mr R3, R29 */
		/* 8219E174h case   19:*/		regs.R3 = regs.R29;
		/* 8219E174h case   19:*/		return 0x8219E178;
		  /* 8219E178h */ case   20:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219E178h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219E178h case   20:*/		return 0x8219E17C;
		  /* 8219E17Ch */ case   21:  		/* bl -184460 */
		/* 8219E17Ch case   21:*/		regs.LR = 0x8219E180; return 0x821710F0;
		/* 8219E17Ch case   21:*/		return 0x8219E180;
		  /* 8219E180h */ case   22:  		/* mr R4, R3 */
		/* 8219E180h case   22:*/		regs.R4 = regs.R3;
		/* 8219E180h case   22:*/		return 0x8219E184;
	}
	return 0x8219E184;
} // Block from 8219E128h-8219E184h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219E184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E184);
		  /* 8219E184h */ case    0:  		/* mr R3, R31 */
		/* 8219E184h case    0:*/		regs.R3 = regs.R31;
		/* 8219E184h case    0:*/		return 0x8219E188;
		  /* 8219E188h */ case    1:  		/* bl -155584 */
		/* 8219E188h case    1:*/		regs.LR = 0x8219E18C; return 0x821781C8;
		/* 8219E188h case    1:*/		return 0x8219E18C;
		  /* 8219E18Ch */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 8219E18Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E18Ch case    2:*/		return 0x8219E190;
		  /* 8219E190h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 8219E190h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8219E190h case    3:*/		return 0x8219E194;
		  /* 8219E194h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E194h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E194h case    4:*/		return 0x8219E198;
		  /* 8219E198h */ case    5:  		/* mr R4, R28 */
		/* 8219E198h case    5:*/		regs.R4 = regs.R28;
		/* 8219E198h case    5:*/		return 0x8219E19C;
		  /* 8219E19Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E19Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E1B0;  }
		/* 8219E19Ch case    6:*/		return 0x8219E1A0;
		  /* 8219E1A0h */ case    7:  		/* mr R3, R29 */
		/* 8219E1A0h case    7:*/		regs.R3 = regs.R29;
		/* 8219E1A0h case    7:*/		return 0x8219E1A4;
		  /* 8219E1A4h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 8219E1A4h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 8219E1A4h case    8:*/		return 0x8219E1A8;
		  /* 8219E1A8h */ case    9:  		/* bl -184504 */
		/* 8219E1A8h case    9:*/		regs.LR = 0x8219E1AC; return 0x821710F0;
		/* 8219E1A8h case    9:*/		return 0x8219E1AC;
		  /* 8219E1ACh */ case   10:  		/* mr R4, R3 */
		/* 8219E1ACh case   10:*/		regs.R4 = regs.R3;
		/* 8219E1ACh case   10:*/		return 0x8219E1B0;
	}
	return 0x8219E1B0;
} // Block from 8219E184h-8219E1B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E1B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E1B0);
		  /* 8219E1B0h */ case    0:  		/* mr R3, R31 */
		/* 8219E1B0h case    0:*/		regs.R3 = regs.R31;
		/* 8219E1B0h case    0:*/		return 0x8219E1B4;
		  /* 8219E1B4h */ case    1:  		/* bl -155628 */
		/* 8219E1B4h case    1:*/		regs.LR = 0x8219E1B8; return 0x821781C8;
		/* 8219E1B4h case    1:*/		return 0x8219E1B8;
		  /* 8219E1B8h */ case    2:  		/* lwz R11, <#[R31 + 44]> */
		/* 8219E1B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E1B8h case    2:*/		return 0x8219E1BC;
		  /* 8219E1BCh */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 8219E1BCh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8219E1BCh case    3:*/		return 0x8219E1C0;
		  /* 8219E1C0h */ case    4:  		/* mr R6, R27 */
		/* 8219E1C0h case    4:*/		regs.R6 = regs.R27;
		/* 8219E1C0h case    4:*/		return 0x8219E1C4;
		  /* 8219E1C4h */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219E1C4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E1C4h case    5:*/		return 0x8219E1C8;
		  /* 8219E1C8h */ case    6:  		/* mr R5, R26 */
		/* 8219E1C8h case    6:*/		regs.R5 = regs.R26;
		/* 8219E1C8h case    6:*/		return 0x8219E1CC;
		  /* 8219E1CCh */ case    7:  		/* mr R4, R31 */
		/* 8219E1CCh case    7:*/		regs.R4 = regs.R31;
		/* 8219E1CCh case    7:*/		return 0x8219E1D0;
		  /* 8219E1D0h */ case    8:  		/* mr R3, R29 */
		/* 8219E1D0h case    8:*/		regs.R3 = regs.R29;
		/* 8219E1D0h case    8:*/		return 0x8219E1D4;
		  /* 8219E1D4h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8219E1D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219E1D4h case    9:*/		return 0x8219E1D8;
		  /* 8219E1D8h */ case   10:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 8219E1D8h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 8219E1D8h case   10:*/		return 0x8219E1DC;
		  /* 8219E1DCh */ case   11:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 8219E1DCh case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 8219E1DCh case   11:*/		return 0x8219E1E0;
		  /* 8219E1E0h */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 8219E1E0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E1E0h case   12:*/		return 0x8219E1E4;
		  /* 8219E1E4h */ case   13:  		/* bl -201532 */
		/* 8219E1E4h case   13:*/		regs.LR = 0x8219E1E8; return 0x8216CEA8;
		/* 8219E1E4h case   13:*/		return 0x8219E1E8;
	}
	return 0x8219E1E8;
} // Block from 8219E1B0h-8219E1E8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219E1E8h
// Function '?CleanVectorizeableCopies@Compiler@D3DXShader@@AAAXPAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E1E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E1E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E1E8);
		  /* 8219E1E8h */ case    0:  		/* mr R3, R31 */
		/* 8219E1E8h case    0:*/		regs.R3 = regs.R31;
		/* 8219E1E8h case    0:*/		return 0x8219E1EC;
		  /* 8219E1ECh */ case    1:  		/* addi R1, R1, 144 */
		/* 8219E1ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219E1ECh case    1:*/		return 0x8219E1F0;
		  /* 8219E1F0h */ case    2:  		/* b -1101648 */
		/* 8219E1F0h case    2:*/		return 0x820912A0;
		/* 8219E1F0h case    2:*/		return 0x8219E1F4;
		  /* 8219E1F4h */ case    3:  		/* nop */
		/* 8219E1F4h case    3:*/		cpu::op::nop();
		/* 8219E1F4h case    3:*/		return 0x8219E1F8;
	}
	return 0x8219E1F8;
} // Block from 8219E1E8h-8219E1F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219E1F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E1F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E1F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E1F8);
		  /* 8219E1F8h */ case    0:  		/* mfspr R12, LR */
		/* 8219E1F8h case    0:*/		regs.R12 = regs.LR;
		/* 8219E1F8h case    0:*/		return 0x8219E1FC;
		  /* 8219E1FCh */ case    1:  		/* bl -1101744 */
		/* 8219E1FCh case    1:*/		regs.LR = 0x8219E200; return 0x8209124C;
		/* 8219E1FCh case    1:*/		return 0x8219E200;
		  /* 8219E200h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219E200h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219E200h case    2:*/		return 0x8219E204;
		  /* 8219E204h */ case    3:  		/* mr R25, R4 */
		/* 8219E204h case    3:*/		regs.R25 = regs.R4;
		/* 8219E204h case    3:*/		return 0x8219E208;
		  /* 8219E208h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219E208h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219E208h case    4:*/		return 0x8219E20C;
		  /* 8219E20Ch */ case    5:  		/* mr R26, R5 */
		/* 8219E20Ch case    5:*/		regs.R26 = regs.R5;
		/* 8219E20Ch case    5:*/		return 0x8219E210;
		  /* 8219E210h */ case    6:  		/* mr R30, R6 */
		/* 8219E210h case    6:*/		regs.R30 = regs.R6;
		/* 8219E210h case    6:*/		return 0x8219E214;
		  /* 8219E214h */ case    7:  		/* mr R28, R7 */
		/* 8219E214h case    7:*/		regs.R28 = regs.R7;
		/* 8219E214h case    7:*/		return 0x8219E218;
		  /* 8219E218h */ case    8:  		/* mr R27, R8 */
		/* 8219E218h case    8:*/		regs.R27 = regs.R8;
		/* 8219E218h case    8:*/		return 0x8219E21C;
		  /* 8219E21Ch */ case    9:  		/* li R8, 4 */
		/* 8219E21Ch case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219E21Ch case    9:*/		return 0x8219E220;
		  /* 8219E220h */ case   10:  		/* li R7, 3 */
		/* 8219E220h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8219E220h case   10:*/		return 0x8219E224;
		  /* 8219E224h */ case   11:  		/* li R6, 13 */
		/* 8219E224h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0xD);
		/* 8219E224h case   11:*/		return 0x8219E228;
		  /* 8219E228h */ case   12:  		/* li R5, 0 */
		/* 8219E228h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219E228h case   12:*/		return 0x8219E22C;
		  /* 8219E22Ch */ case   13:  		/* mr R29, R3 */
		/* 8219E22Ch case   13:*/		regs.R29 = regs.R3;
		/* 8219E22Ch case   13:*/		return 0x8219E230;
		  /* 8219E230h */ case   14:  		/* bl 550760 */
		/* 8219E230h case   14:*/		regs.LR = 0x8219E234; return 0x82224998;
		/* 8219E230h case   14:*/		return 0x8219E234;
		  /* 8219E234h */ case   15:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219E234h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219E234h case   15:*/		return 0x8219E238;
	}
	return 0x8219E238;
} // Block from 8219E1F8h-8219E238h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219E238h
// Function '?SortPossibleVectorizationCandidatesWorker@Compiler@D3DXShader@@CAHPAUPossibleVectorizationCandidate@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E238);
		  /* 8219E238h */ case    0:  		/* mr R31, R3 */
		/* 8219E238h case    0:*/		regs.R31 = regs.R3;
		/* 8219E238h case    0:*/		return 0x8219E23C;
		  /* 8219E23Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8219E23Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E23Ch case    1:*/		return 0x8219E240;
		  /* 8219E240h */ case    2:  		/* mr R4, R30 */
		/* 8219E240h case    2:*/		regs.R4 = regs.R30;
		/* 8219E240h case    2:*/		return 0x8219E244;
		  /* 8219E244h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E244h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219E258;  }
		/* 8219E244h case    3:*/		return 0x8219E248;
		  /* 8219E248h */ case    4:  		/* mr R3, R29 */
		/* 8219E248h case    4:*/		regs.R3 = regs.R29;
		/* 8219E248h case    4:*/		return 0x8219E24C;
		  /* 8219E24Ch */ case    5:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219E24Ch case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219E24Ch case    5:*/		return 0x8219E250;
		  /* 8219E250h */ case    6:  		/* bl -184672 */
		/* 8219E250h case    6:*/		regs.LR = 0x8219E254; return 0x821710F0;
		/* 8219E250h case    6:*/		return 0x8219E254;
		  /* 8219E254h */ case    7:  		/* mr R4, R3 */
		/* 8219E254h case    7:*/		regs.R4 = regs.R3;
		/* 8219E254h case    7:*/		return 0x8219E258;
	}
	return 0x8219E258;
} // Block from 8219E238h-8219E258h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219E258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E258);
		  /* 8219E258h */ case    0:  		/* mr R3, R31 */
		/* 8219E258h case    0:*/		regs.R3 = regs.R31;
		/* 8219E258h case    0:*/		return 0x8219E25C;
		  /* 8219E25Ch */ case    1:  		/* bl -155796 */
		/* 8219E25Ch case    1:*/		regs.LR = 0x8219E260; return 0x821781C8;
		/* 8219E25Ch case    1:*/		return 0x8219E260;
		  /* 8219E260h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 8219E260h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E260h case    2:*/		return 0x8219E264;
		  /* 8219E264h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 8219E264h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8219E264h case    3:*/		return 0x8219E268;
		  /* 8219E268h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E268h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E268h case    4:*/		return 0x8219E26C;
		  /* 8219E26Ch */ case    5:  		/* mr R4, R28 */
		/* 8219E26Ch case    5:*/		regs.R4 = regs.R28;
		/* 8219E26Ch case    5:*/		return 0x8219E270;
		  /* 8219E270h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E270h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E284;  }
		/* 8219E270h case    6:*/		return 0x8219E274;
		  /* 8219E274h */ case    7:  		/* mr R3, R29 */
		/* 8219E274h case    7:*/		regs.R3 = regs.R29;
		/* 8219E274h case    7:*/		return 0x8219E278;
		  /* 8219E278h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 8219E278h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 8219E278h case    8:*/		return 0x8219E27C;
		  /* 8219E27Ch */ case    9:  		/* bl -184716 */
		/* 8219E27Ch case    9:*/		regs.LR = 0x8219E280; return 0x821710F0;
		/* 8219E27Ch case    9:*/		return 0x8219E280;
		  /* 8219E280h */ case   10:  		/* mr R4, R3 */
		/* 8219E280h case   10:*/		regs.R4 = regs.R3;
		/* 8219E280h case   10:*/		return 0x8219E284;
	}
	return 0x8219E284;
} // Block from 8219E258h-8219E284h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E284);
		  /* 8219E284h */ case    0:  		/* mr R3, R31 */
		/* 8219E284h case    0:*/		regs.R3 = regs.R31;
		/* 8219E284h case    0:*/		return 0x8219E288;
		  /* 8219E288h */ case    1:  		/* bl -155840 */
		/* 8219E288h case    1:*/		regs.LR = 0x8219E28C; return 0x821781C8;
		/* 8219E288h case    1:*/		return 0x8219E28C;
		  /* 8219E28Ch */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 8219E28Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8219E28Ch case    2:*/		return 0x8219E290;
		  /* 8219E290h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 8219E290h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 8219E290h case    3:*/		return 0x8219E294;
		  /* 8219E294h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E294h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E294h case    4:*/		return 0x8219E298;
		  /* 8219E298h */ case    5:  		/* mr R4, R27 */
		/* 8219E298h case    5:*/		regs.R4 = regs.R27;
		/* 8219E298h case    5:*/		return 0x8219E29C;
		  /* 8219E29Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E29Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E2B0;  }
		/* 8219E29Ch case    6:*/		return 0x8219E2A0;
		  /* 8219E2A0h */ case    7:  		/* mr R3, R29 */
		/* 8219E2A0h case    7:*/		regs.R3 = regs.R29;
		/* 8219E2A0h case    7:*/		return 0x8219E2A4;
		  /* 8219E2A4h */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 8219E2A4h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 8219E2A4h case    8:*/		return 0x8219E2A8;
		  /* 8219E2A8h */ case    9:  		/* bl -184760 */
		/* 8219E2A8h case    9:*/		regs.LR = 0x8219E2AC; return 0x821710F0;
		/* 8219E2A8h case    9:*/		return 0x8219E2AC;
		  /* 8219E2ACh */ case   10:  		/* mr R4, R3 */
		/* 8219E2ACh case   10:*/		regs.R4 = regs.R3;
		/* 8219E2ACh case   10:*/		return 0x8219E2B0;
	}
	return 0x8219E2B0;
} // Block from 8219E284h-8219E2B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E2B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E2B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E2B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E2B0);
		  /* 8219E2B0h */ case    0:  		/* mr R3, R31 */
		/* 8219E2B0h case    0:*/		regs.R3 = regs.R31;
		/* 8219E2B0h case    0:*/		return 0x8219E2B4;
		  /* 8219E2B4h */ case    1:  		/* bl -155884 */
		/* 8219E2B4h case    1:*/		regs.LR = 0x8219E2B8; return 0x821781C8;
		/* 8219E2B4h case    1:*/		return 0x8219E2B8;
		  /* 8219E2B8h */ case    2:  		/* lwz R11, <#[R31 + 44]> */
		/* 8219E2B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E2B8h case    2:*/		return 0x8219E2BC;
		  /* 8219E2BCh */ case    3:  		/* stw R3, <#[R31 + 52]> */
		/* 8219E2BCh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 8219E2BCh case    3:*/		return 0x8219E2C0;
		  /* 8219E2C0h */ case    4:  		/* mr R6, R26 */
		/* 8219E2C0h case    4:*/		regs.R6 = regs.R26;
		/* 8219E2C0h case    4:*/		return 0x8219E2C4;
		  /* 8219E2C4h */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219E2C4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E2C4h case    5:*/		return 0x8219E2C8;
		  /* 8219E2C8h */ case    6:  		/* mr R5, R25 */
		/* 8219E2C8h case    6:*/		regs.R5 = regs.R25;
		/* 8219E2C8h case    6:*/		return 0x8219E2CC;
		  /* 8219E2CCh */ case    7:  		/* mr R4, R31 */
		/* 8219E2CCh case    7:*/		regs.R4 = regs.R31;
		/* 8219E2CCh case    7:*/		return 0x8219E2D0;
		  /* 8219E2D0h */ case    8:  		/* mr R3, R29 */
		/* 8219E2D0h case    8:*/		regs.R3 = regs.R29;
		/* 8219E2D0h case    8:*/		return 0x8219E2D4;
		  /* 8219E2D4h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8219E2D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219E2D4h case    9:*/		return 0x8219E2D8;
		  /* 8219E2D8h */ case   10:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 8219E2D8h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 8219E2D8h case   10:*/		return 0x8219E2DC;
		  /* 8219E2DCh */ case   11:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 8219E2DCh case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 8219E2DCh case   11:*/		return 0x8219E2E0;
		  /* 8219E2E0h */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 8219E2E0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E2E0h case   12:*/		return 0x8219E2E4;
		  /* 8219E2E4h */ case   13:  		/* bl -201788 */
		/* 8219E2E4h case   13:*/		regs.LR = 0x8219E2E8; return 0x8216CEA8;
		/* 8219E2E4h case   13:*/		return 0x8219E2E8;
		  /* 8219E2E8h */ case   14:  		/* mr R3, R31 */
		/* 8219E2E8h case   14:*/		regs.R3 = regs.R31;
		/* 8219E2E8h case   14:*/		return 0x8219E2EC;
		  /* 8219E2ECh */ case   15:  		/* addi R1, R1, 144 */
		/* 8219E2ECh case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219E2ECh case   15:*/		return 0x8219E2F0;
		  /* 8219E2F0h */ case   16:  		/* b -1101908 */
		/* 8219E2F0h case   16:*/		return 0x8209129C;
		/* 8219E2F0h case   16:*/		return 0x8219E2F4;
		  /* 8219E2F4h */ case   17:  		/* nop */
		/* 8219E2F4h case   17:*/		cpu::op::nop();
		/* 8219E2F4h case   17:*/		return 0x8219E2F8;
	}
	return 0x8219E2F8;
} // Block from 8219E2B0h-8219E2F8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219E2F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E2F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E2F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E2F8);
		  /* 8219E2F8h */ case    0:  		/* mfspr R12, LR */
		/* 8219E2F8h case    0:*/		regs.R12 = regs.LR;
		/* 8219E2F8h case    0:*/		return 0x8219E2FC;
		  /* 8219E2FCh */ case    1:  		/* bl -1102000 */
		/* 8219E2FCh case    1:*/		regs.LR = 0x8219E300; return 0x8209124C;
		/* 8219E2FCh case    1:*/		return 0x8219E300;
		  /* 8219E300h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219E300h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219E300h case    2:*/		return 0x8219E304;
		  /* 8219E304h */ case    3:  		/* mr R25, R4 */
		/* 8219E304h case    3:*/		regs.R25 = regs.R4;
		/* 8219E304h case    3:*/		return 0x8219E308;
		  /* 8219E308h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219E308h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219E308h case    4:*/		return 0x8219E30C;
		  /* 8219E30Ch */ case    5:  		/* mr R26, R5 */
		/* 8219E30Ch case    5:*/		regs.R26 = regs.R5;
		/* 8219E30Ch case    5:*/		return 0x8219E310;
		  /* 8219E310h */ case    6:  		/* mr R30, R6 */
		/* 8219E310h case    6:*/		regs.R30 = regs.R6;
		/* 8219E310h case    6:*/		return 0x8219E314;
		  /* 8219E314h */ case    7:  		/* mr R28, R7 */
		/* 8219E314h case    7:*/		regs.R28 = regs.R7;
		/* 8219E314h case    7:*/		return 0x8219E318;
		  /* 8219E318h */ case    8:  		/* mr R27, R8 */
		/* 8219E318h case    8:*/		regs.R27 = regs.R8;
		/* 8219E318h case    8:*/		return 0x8219E31C;
		  /* 8219E31Ch */ case    9:  		/* li R8, 4 */
		/* 8219E31Ch case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219E31Ch case    9:*/		return 0x8219E320;
		  /* 8219E320h */ case   10:  		/* li R7, 3 */
		/* 8219E320h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8219E320h case   10:*/		return 0x8219E324;
		  /* 8219E324h */ case   11:  		/* li R6, 14 */
		/* 8219E324h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0xE);
		/* 8219E324h case   11:*/		return 0x8219E328;
		  /* 8219E328h */ case   12:  		/* li R5, 0 */
		/* 8219E328h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219E328h case   12:*/		return 0x8219E32C;
		  /* 8219E32Ch */ case   13:  		/* mr R29, R3 */
		/* 8219E32Ch case   13:*/		regs.R29 = regs.R3;
		/* 8219E32Ch case   13:*/		return 0x8219E330;
		  /* 8219E330h */ case   14:  		/* bl 550504 */
		/* 8219E330h case   14:*/		regs.LR = 0x8219E334; return 0x82224998;
		/* 8219E330h case   14:*/		return 0x8219E334;
		  /* 8219E334h */ case   15:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219E334h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219E334h case   15:*/		return 0x8219E338;
		  /* 8219E338h */ case   16:  		/* mr R31, R3 */
		/* 8219E338h case   16:*/		regs.R31 = regs.R3;
		/* 8219E338h case   16:*/		return 0x8219E33C;
		  /* 8219E33Ch */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 8219E33Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E33Ch case   17:*/		return 0x8219E340;
		  /* 8219E340h */ case   18:  		/* mr R4, R30 */
		/* 8219E340h case   18:*/		regs.R4 = regs.R30;
		/* 8219E340h case   18:*/		return 0x8219E344;
		  /* 8219E344h */ case   19:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E344h case   19:*/		if ( regs.CR[6].eq ) { return 0x8219E358;  }
		/* 8219E344h case   19:*/		return 0x8219E348;
		  /* 8219E348h */ case   20:  		/* mr R3, R29 */
		/* 8219E348h case   20:*/		regs.R3 = regs.R29;
		/* 8219E348h case   20:*/		return 0x8219E34C;
		  /* 8219E34Ch */ case   21:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219E34Ch case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219E34Ch case   21:*/		return 0x8219E350;
		  /* 8219E350h */ case   22:  		/* bl -184928 */
		/* 8219E350h case   22:*/		regs.LR = 0x8219E354; return 0x821710F0;
		/* 8219E350h case   22:*/		return 0x8219E354;
		  /* 8219E354h */ case   23:  		/* mr R4, R3 */
		/* 8219E354h case   23:*/		regs.R4 = regs.R3;
		/* 8219E354h case   23:*/		return 0x8219E358;
	}
	return 0x8219E358;
} // Block from 8219E2F8h-8219E358h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8219E358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E358);
		  /* 8219E358h */ case    0:  		/* mr R3, R31 */
		/* 8219E358h case    0:*/		regs.R3 = regs.R31;
		/* 8219E358h case    0:*/		return 0x8219E35C;
		  /* 8219E35Ch */ case    1:  		/* bl -156052 */
		/* 8219E35Ch case    1:*/		regs.LR = 0x8219E360; return 0x821781C8;
		/* 8219E35Ch case    1:*/		return 0x8219E360;
		  /* 8219E360h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 8219E360h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E360h case    2:*/		return 0x8219E364;
		  /* 8219E364h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 8219E364h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8219E364h case    3:*/		return 0x8219E368;
		  /* 8219E368h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E368h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E368h case    4:*/		return 0x8219E36C;
		  /* 8219E36Ch */ case    5:  		/* mr R4, R28 */
		/* 8219E36Ch case    5:*/		regs.R4 = regs.R28;
		/* 8219E36Ch case    5:*/		return 0x8219E370;
		  /* 8219E370h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E370h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E384;  }
		/* 8219E370h case    6:*/		return 0x8219E374;
		  /* 8219E374h */ case    7:  		/* mr R3, R29 */
		/* 8219E374h case    7:*/		regs.R3 = regs.R29;
		/* 8219E374h case    7:*/		return 0x8219E378;
		  /* 8219E378h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 8219E378h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 8219E378h case    8:*/		return 0x8219E37C;
		  /* 8219E37Ch */ case    9:  		/* bl -184972 */
		/* 8219E37Ch case    9:*/		regs.LR = 0x8219E380; return 0x821710F0;
		/* 8219E37Ch case    9:*/		return 0x8219E380;
		  /* 8219E380h */ case   10:  		/* mr R4, R3 */
		/* 8219E380h case   10:*/		regs.R4 = regs.R3;
		/* 8219E380h case   10:*/		return 0x8219E384;
	}
	return 0x8219E384;
} // Block from 8219E358h-8219E384h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E384);
		  /* 8219E384h */ case    0:  		/* mr R3, R31 */
		/* 8219E384h case    0:*/		regs.R3 = regs.R31;
		/* 8219E384h case    0:*/		return 0x8219E388;
		  /* 8219E388h */ case    1:  		/* bl -156096 */
		/* 8219E388h case    1:*/		regs.LR = 0x8219E38C; return 0x821781C8;
		/* 8219E388h case    1:*/		return 0x8219E38C;
		  /* 8219E38Ch */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 8219E38Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8219E38Ch case    2:*/		return 0x8219E390;
		  /* 8219E390h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 8219E390h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 8219E390h case    3:*/		return 0x8219E394;
		  /* 8219E394h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E394h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E394h case    4:*/		return 0x8219E398;
		  /* 8219E398h */ case    5:  		/* mr R4, R27 */
		/* 8219E398h case    5:*/		regs.R4 = regs.R27;
		/* 8219E398h case    5:*/		return 0x8219E39C;
		  /* 8219E39Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E39Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E3B0;  }
		/* 8219E39Ch case    6:*/		return 0x8219E3A0;
		  /* 8219E3A0h */ case    7:  		/* mr R3, R29 */
		/* 8219E3A0h case    7:*/		regs.R3 = regs.R29;
		/* 8219E3A0h case    7:*/		return 0x8219E3A4;
		  /* 8219E3A4h */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 8219E3A4h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 8219E3A4h case    8:*/		return 0x8219E3A8;
		  /* 8219E3A8h */ case    9:  		/* bl -185016 */
		/* 8219E3A8h case    9:*/		regs.LR = 0x8219E3AC; return 0x821710F0;
		/* 8219E3A8h case    9:*/		return 0x8219E3AC;
		  /* 8219E3ACh */ case   10:  		/* mr R4, R3 */
		/* 8219E3ACh case   10:*/		regs.R4 = regs.R3;
		/* 8219E3ACh case   10:*/		return 0x8219E3B0;
	}
	return 0x8219E3B0;
} // Block from 8219E384h-8219E3B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E3B0);
		  /* 8219E3B0h */ case    0:  		/* mr R3, R31 */
		/* 8219E3B0h case    0:*/		regs.R3 = regs.R31;
		/* 8219E3B0h case    0:*/		return 0x8219E3B4;
		  /* 8219E3B4h */ case    1:  		/* bl -156140 */
		/* 8219E3B4h case    1:*/		regs.LR = 0x8219E3B8; return 0x821781C8;
		/* 8219E3B4h case    1:*/		return 0x8219E3B8;
		  /* 8219E3B8h */ case    2:  		/* lwz R11, <#[R31 + 44]> */
		/* 8219E3B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E3B8h case    2:*/		return 0x8219E3BC;
		  /* 8219E3BCh */ case    3:  		/* stw R3, <#[R31 + 52]> */
		/* 8219E3BCh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 8219E3BCh case    3:*/		return 0x8219E3C0;
		  /* 8219E3C0h */ case    4:  		/* mr R6, R26 */
		/* 8219E3C0h case    4:*/		regs.R6 = regs.R26;
		/* 8219E3C0h case    4:*/		return 0x8219E3C4;
		  /* 8219E3C4h */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219E3C4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E3C4h case    5:*/		return 0x8219E3C8;
		  /* 8219E3C8h */ case    6:  		/* mr R5, R25 */
		/* 8219E3C8h case    6:*/		regs.R5 = regs.R25;
		/* 8219E3C8h case    6:*/		return 0x8219E3CC;
		  /* 8219E3CCh */ case    7:  		/* mr R4, R31 */
		/* 8219E3CCh case    7:*/		regs.R4 = regs.R31;
		/* 8219E3CCh case    7:*/		return 0x8219E3D0;
		  /* 8219E3D0h */ case    8:  		/* mr R3, R29 */
		/* 8219E3D0h case    8:*/		regs.R3 = regs.R29;
		/* 8219E3D0h case    8:*/		return 0x8219E3D4;
		  /* 8219E3D4h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8219E3D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219E3D4h case    9:*/		return 0x8219E3D8;
		  /* 8219E3D8h */ case   10:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 8219E3D8h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 8219E3D8h case   10:*/		return 0x8219E3DC;
		  /* 8219E3DCh */ case   11:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 8219E3DCh case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 8219E3DCh case   11:*/		return 0x8219E3E0;
		  /* 8219E3E0h */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 8219E3E0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E3E0h case   12:*/		return 0x8219E3E4;
		  /* 8219E3E4h */ case   13:  		/* bl -202044 */
		/* 8219E3E4h case   13:*/		regs.LR = 0x8219E3E8; return 0x8216CEA8;
		/* 8219E3E4h case   13:*/		return 0x8219E3E8;
		  /* 8219E3E8h */ case   14:  		/* mr R3, R31 */
		/* 8219E3E8h case   14:*/		regs.R3 = regs.R31;
		/* 8219E3E8h case   14:*/		return 0x8219E3EC;
		  /* 8219E3ECh */ case   15:  		/* addi R1, R1, 144 */
		/* 8219E3ECh case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219E3ECh case   15:*/		return 0x8219E3F0;
		  /* 8219E3F0h */ case   16:  		/* b -1102164 */
		/* 8219E3F0h case   16:*/		return 0x8209129C;
		/* 8219E3F0h case   16:*/		return 0x8219E3F4;
		  /* 8219E3F4h */ case   17:  		/* nop */
		/* 8219E3F4h case   17:*/		cpu::op::nop();
		/* 8219E3F4h case   17:*/		return 0x8219E3F8;
	}
	return 0x8219E3F8;
} // Block from 8219E3B0h-8219E3F8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219E3F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E3F8);
		  /* 8219E3F8h */ case    0:  		/* mfspr R12, LR */
		/* 8219E3F8h case    0:*/		regs.R12 = regs.LR;
		/* 8219E3F8h case    0:*/		return 0x8219E3FC;
		  /* 8219E3FCh */ case    1:  		/* bl -1102256 */
		/* 8219E3FCh case    1:*/		regs.LR = 0x8219E400; return 0x8209124C;
		/* 8219E3FCh case    1:*/		return 0x8219E400;
		  /* 8219E400h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219E400h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219E400h case    2:*/		return 0x8219E404;
		  /* 8219E404h */ case    3:  		/* mr R25, R4 */
		/* 8219E404h case    3:*/		regs.R25 = regs.R4;
		/* 8219E404h case    3:*/		return 0x8219E408;
		  /* 8219E408h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219E408h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219E408h case    4:*/		return 0x8219E40C;
		  /* 8219E40Ch */ case    5:  		/* mr R26, R5 */
		/* 8219E40Ch case    5:*/		regs.R26 = regs.R5;
		/* 8219E40Ch case    5:*/		return 0x8219E410;
		  /* 8219E410h */ case    6:  		/* mr R30, R6 */
		/* 8219E410h case    6:*/		regs.R30 = regs.R6;
		/* 8219E410h case    6:*/		return 0x8219E414;
		  /* 8219E414h */ case    7:  		/* mr R28, R7 */
		/* 8219E414h case    7:*/		regs.R28 = regs.R7;
		/* 8219E414h case    7:*/		return 0x8219E418;
		  /* 8219E418h */ case    8:  		/* mr R27, R8 */
		/* 8219E418h case    8:*/		regs.R27 = regs.R8;
		/* 8219E418h case    8:*/		return 0x8219E41C;
		  /* 8219E41Ch */ case    9:  		/* li R8, 4 */
		/* 8219E41Ch case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219E41Ch case    9:*/		return 0x8219E420;
		  /* 8219E420h */ case   10:  		/* li R7, 3 */
		/* 8219E420h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8219E420h case   10:*/		return 0x8219E424;
		  /* 8219E424h */ case   11:  		/* li R6, 15 */
		/* 8219E424h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0xF);
		/* 8219E424h case   11:*/		return 0x8219E428;
		  /* 8219E428h */ case   12:  		/* li R5, 0 */
		/* 8219E428h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219E428h case   12:*/		return 0x8219E42C;
		  /* 8219E42Ch */ case   13:  		/* mr R29, R3 */
		/* 8219E42Ch case   13:*/		regs.R29 = regs.R3;
		/* 8219E42Ch case   13:*/		return 0x8219E430;
		  /* 8219E430h */ case   14:  		/* bl 550248 */
		/* 8219E430h case   14:*/		regs.LR = 0x8219E434; return 0x82224998;
		/* 8219E430h case   14:*/		return 0x8219E434;
		  /* 8219E434h */ case   15:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219E434h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219E434h case   15:*/		return 0x8219E438;
		  /* 8219E438h */ case   16:  		/* mr R31, R3 */
		/* 8219E438h case   16:*/		regs.R31 = regs.R3;
		/* 8219E438h case   16:*/		return 0x8219E43C;
		  /* 8219E43Ch */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 8219E43Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E43Ch case   17:*/		return 0x8219E440;
		  /* 8219E440h */ case   18:  		/* mr R4, R30 */
		/* 8219E440h case   18:*/		regs.R4 = regs.R30;
		/* 8219E440h case   18:*/		return 0x8219E444;
		  /* 8219E444h */ case   19:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E444h case   19:*/		if ( regs.CR[6].eq ) { return 0x8219E458;  }
		/* 8219E444h case   19:*/		return 0x8219E448;
		  /* 8219E448h */ case   20:  		/* mr R3, R29 */
		/* 8219E448h case   20:*/		regs.R3 = regs.R29;
		/* 8219E448h case   20:*/		return 0x8219E44C;
		  /* 8219E44Ch */ case   21:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219E44Ch case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219E44Ch case   21:*/		return 0x8219E450;
		  /* 8219E450h */ case   22:  		/* bl -185184 */
		/* 8219E450h case   22:*/		regs.LR = 0x8219E454; return 0x821710F0;
		/* 8219E450h case   22:*/		return 0x8219E454;
		  /* 8219E454h */ case   23:  		/* mr R4, R3 */
		/* 8219E454h case   23:*/		regs.R4 = regs.R3;
		/* 8219E454h case   23:*/		return 0x8219E458;
	}
	return 0x8219E458;
} // Block from 8219E3F8h-8219E458h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8219E458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E458);
		  /* 8219E458h */ case    0:  		/* mr R3, R31 */
		/* 8219E458h case    0:*/		regs.R3 = regs.R31;
		/* 8219E458h case    0:*/		return 0x8219E45C;
		  /* 8219E45Ch */ case    1:  		/* bl -156308 */
		/* 8219E45Ch case    1:*/		regs.LR = 0x8219E460; return 0x821781C8;
		/* 8219E45Ch case    1:*/		return 0x8219E460;
		  /* 8219E460h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 8219E460h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E460h case    2:*/		return 0x8219E464;
		  /* 8219E464h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 8219E464h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8219E464h case    3:*/		return 0x8219E468;
		  /* 8219E468h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E468h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E468h case    4:*/		return 0x8219E46C;
		  /* 8219E46Ch */ case    5:  		/* mr R4, R28 */
		/* 8219E46Ch case    5:*/		regs.R4 = regs.R28;
		/* 8219E46Ch case    5:*/		return 0x8219E470;
		  /* 8219E470h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E470h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E484;  }
		/* 8219E470h case    6:*/		return 0x8219E474;
		  /* 8219E474h */ case    7:  		/* mr R3, R29 */
		/* 8219E474h case    7:*/		regs.R3 = regs.R29;
		/* 8219E474h case    7:*/		return 0x8219E478;
		  /* 8219E478h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 8219E478h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 8219E478h case    8:*/		return 0x8219E47C;
		  /* 8219E47Ch */ case    9:  		/* bl -185228 */
		/* 8219E47Ch case    9:*/		regs.LR = 0x8219E480; return 0x821710F0;
		/* 8219E47Ch case    9:*/		return 0x8219E480;
		  /* 8219E480h */ case   10:  		/* mr R4, R3 */
		/* 8219E480h case   10:*/		regs.R4 = regs.R3;
		/* 8219E480h case   10:*/		return 0x8219E484;
	}
	return 0x8219E484;
} // Block from 8219E458h-8219E484h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E484);
		  /* 8219E484h */ case    0:  		/* mr R3, R31 */
		/* 8219E484h case    0:*/		regs.R3 = regs.R31;
		/* 8219E484h case    0:*/		return 0x8219E488;
		  /* 8219E488h */ case    1:  		/* bl -156352 */
		/* 8219E488h case    1:*/		regs.LR = 0x8219E48C; return 0x821781C8;
		/* 8219E488h case    1:*/		return 0x8219E48C;
		  /* 8219E48Ch */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 8219E48Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8219E48Ch case    2:*/		return 0x8219E490;
		  /* 8219E490h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 8219E490h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 8219E490h case    3:*/		return 0x8219E494;
		  /* 8219E494h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E494h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E494h case    4:*/		return 0x8219E498;
		  /* 8219E498h */ case    5:  		/* mr R4, R27 */
		/* 8219E498h case    5:*/		regs.R4 = regs.R27;
		/* 8219E498h case    5:*/		return 0x8219E49C;
		  /* 8219E49Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E49Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E4B0;  }
		/* 8219E49Ch case    6:*/		return 0x8219E4A0;
		  /* 8219E4A0h */ case    7:  		/* mr R3, R29 */
		/* 8219E4A0h case    7:*/		regs.R3 = regs.R29;
		/* 8219E4A0h case    7:*/		return 0x8219E4A4;
		  /* 8219E4A4h */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 8219E4A4h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 8219E4A4h case    8:*/		return 0x8219E4A8;
		  /* 8219E4A8h */ case    9:  		/* bl -185272 */
		/* 8219E4A8h case    9:*/		regs.LR = 0x8219E4AC; return 0x821710F0;
		/* 8219E4A8h case    9:*/		return 0x8219E4AC;
		  /* 8219E4ACh */ case   10:  		/* mr R4, R3 */
		/* 8219E4ACh case   10:*/		regs.R4 = regs.R3;
		/* 8219E4ACh case   10:*/		return 0x8219E4B0;
	}
	return 0x8219E4B0;
} // Block from 8219E484h-8219E4B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E4B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E4B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E4B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E4B0);
		  /* 8219E4B0h */ case    0:  		/* mr R3, R31 */
		/* 8219E4B0h case    0:*/		regs.R3 = regs.R31;
		/* 8219E4B0h case    0:*/		return 0x8219E4B4;
		  /* 8219E4B4h */ case    1:  		/* bl -156396 */
		/* 8219E4B4h case    1:*/		regs.LR = 0x8219E4B8; return 0x821781C8;
		/* 8219E4B4h case    1:*/		return 0x8219E4B8;
		  /* 8219E4B8h */ case    2:  		/* lwz R11, <#[R31 + 44]> */
		/* 8219E4B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E4B8h case    2:*/		return 0x8219E4BC;
		  /* 8219E4BCh */ case    3:  		/* stw R3, <#[R31 + 52]> */
		/* 8219E4BCh case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 8219E4BCh case    3:*/		return 0x8219E4C0;
		  /* 8219E4C0h */ case    4:  		/* mr R6, R26 */
		/* 8219E4C0h case    4:*/		regs.R6 = regs.R26;
		/* 8219E4C0h case    4:*/		return 0x8219E4C4;
		  /* 8219E4C4h */ case    5:  		/* lwz R10, <#[R31 + 8]> */
		/* 8219E4C4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E4C4h case    5:*/		return 0x8219E4C8;
		  /* 8219E4C8h */ case    6:  		/* mr R5, R25 */
		/* 8219E4C8h case    6:*/		regs.R5 = regs.R25;
		/* 8219E4C8h case    6:*/		return 0x8219E4CC;
		  /* 8219E4CCh */ case    7:  		/* mr R4, R31 */
		/* 8219E4CCh case    7:*/		regs.R4 = regs.R31;
		/* 8219E4CCh case    7:*/		return 0x8219E4D0;
		  /* 8219E4D0h */ case    8:  		/* mr R3, R29 */
		/* 8219E4D0h case    8:*/		regs.R3 = regs.R29;
		/* 8219E4D0h case    8:*/		return 0x8219E4D4;
		  /* 8219E4D4h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 8219E4D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219E4D4h case    9:*/		return 0x8219E4D8;
		  /* 8219E4D8h */ case   10:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 8219E4D8h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 8219E4D8h case   10:*/		return 0x8219E4DC;
		  /* 8219E4DCh */ case   11:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 8219E4DCh case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 8219E4DCh case   11:*/		return 0x8219E4E0;
		  /* 8219E4E0h */ case   12:  		/* stw R10, <#[R31 + 8]> */
		/* 8219E4E0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E4E0h case   12:*/		return 0x8219E4E4;
		  /* 8219E4E4h */ case   13:  		/* bl -202300 */
		/* 8219E4E4h case   13:*/		regs.LR = 0x8219E4E8; return 0x8216CEA8;
		/* 8219E4E4h case   13:*/		return 0x8219E4E8;
		  /* 8219E4E8h */ case   14:  		/* mr R3, R31 */
		/* 8219E4E8h case   14:*/		regs.R3 = regs.R31;
		/* 8219E4E8h case   14:*/		return 0x8219E4EC;
		  /* 8219E4ECh */ case   15:  		/* addi R1, R1, 144 */
		/* 8219E4ECh case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219E4ECh case   15:*/		return 0x8219E4F0;
		  /* 8219E4F0h */ case   16:  		/* b -1102420 */
		/* 8219E4F0h case   16:*/		return 0x8209129C;
		/* 8219E4F0h case   16:*/		return 0x8219E4F4;
		  /* 8219E4F4h */ case   17:  		/* nop */
		/* 8219E4F4h case   17:*/		cpu::op::nop();
		/* 8219E4F4h case   17:*/		return 0x8219E4F8;
	}
	return 0x8219E4F8;
} // Block from 8219E4B0h-8219E4F8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219E4F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E4F8);
		  /* 8219E4F8h */ case    0:  		/* mfspr R12, LR */
		/* 8219E4F8h case    0:*/		regs.R12 = regs.LR;
		/* 8219E4F8h case    0:*/		return 0x8219E4FC;
		  /* 8219E4FCh */ case    1:  		/* bl -1102508 */
		/* 8219E4FCh case    1:*/		regs.LR = 0x8219E500; return 0x82091250;
		/* 8219E4FCh case    1:*/		return 0x8219E500;
		  /* 8219E500h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219E500h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219E500h case    2:*/		return 0x8219E504;
		  /* 8219E504h */ case    3:  		/* mr R26, R4 */
		/* 8219E504h case    3:*/		regs.R26 = regs.R4;
		/* 8219E504h case    3:*/		return 0x8219E508;
		  /* 8219E508h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219E508h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219E508h case    4:*/		return 0x8219E50C;
		  /* 8219E50Ch */ case    5:  		/* mr R27, R5 */
		/* 8219E50Ch case    5:*/		regs.R27 = regs.R5;
		/* 8219E50Ch case    5:*/		return 0x8219E510;
		  /* 8219E510h */ case    6:  		/* mr R30, R6 */
		/* 8219E510h case    6:*/		regs.R30 = regs.R6;
		/* 8219E510h case    6:*/		return 0x8219E514;
		  /* 8219E514h */ case    7:  		/* mr R28, R7 */
		/* 8219E514h case    7:*/		regs.R28 = regs.R7;
		/* 8219E514h case    7:*/		return 0x8219E518;
		  /* 8219E518h */ case    8:  		/* li R8, 4 */
		/* 8219E518h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219E518h case    8:*/		return 0x8219E51C;
		  /* 8219E51Ch */ case    9:  		/* li R7, 2 */
		/* 8219E51Ch case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 8219E51Ch case    9:*/		return 0x8219E520;
		  /* 8219E520h */ case   10:  		/* li R6, 16 */
		/* 8219E520h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x10);
		/* 8219E520h case   10:*/		return 0x8219E524;
		  /* 8219E524h */ case   11:  		/* li R5, 0 */
		/* 8219E524h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219E524h case   11:*/		return 0x8219E528;
		  /* 8219E528h */ case   12:  		/* mr R29, R3 */
		/* 8219E528h case   12:*/		regs.R29 = regs.R3;
		/* 8219E528h case   12:*/		return 0x8219E52C;
		  /* 8219E52Ch */ case   13:  		/* bl 549996 */
		/* 8219E52Ch case   13:*/		regs.LR = 0x8219E530; return 0x82224998;
		/* 8219E52Ch case   13:*/		return 0x8219E530;
		  /* 8219E530h */ case   14:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219E530h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219E530h case   14:*/		return 0x8219E534;
		  /* 8219E534h */ case   15:  		/* mr R31, R3 */
		/* 8219E534h case   15:*/		regs.R31 = regs.R3;
		/* 8219E534h case   15:*/		return 0x8219E538;
		  /* 8219E538h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8219E538h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E538h case   16:*/		return 0x8219E53C;
		  /* 8219E53Ch */ case   17:  		/* mr R4, R30 */
		/* 8219E53Ch case   17:*/		regs.R4 = regs.R30;
		/* 8219E53Ch case   17:*/		return 0x8219E540;
		  /* 8219E540h */ case   18:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E540h case   18:*/		if ( regs.CR[6].eq ) { return 0x8219E554;  }
		/* 8219E540h case   18:*/		return 0x8219E544;
		  /* 8219E544h */ case   19:  		/* mr R3, R29 */
		/* 8219E544h case   19:*/		regs.R3 = regs.R29;
		/* 8219E544h case   19:*/		return 0x8219E548;
	}
	return 0x8219E548;
} // Block from 8219E4F8h-8219E548h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219E548h
// Function '?SortPossibleVectorizationCandidates@Compiler@D3DXShader@@CAHPBX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E548);
		  /* 8219E548h */ case    0:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219E548h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219E548h case    0:*/		return 0x8219E54C;
		  /* 8219E54Ch */ case    1:  		/* bl -185436 */
		/* 8219E54Ch case    1:*/		regs.LR = 0x8219E550; return 0x821710F0;
		/* 8219E54Ch case    1:*/		return 0x8219E550;
		  /* 8219E550h */ case    2:  		/* mr R4, R3 */
		/* 8219E550h case    2:*/		regs.R4 = regs.R3;
		/* 8219E550h case    2:*/		return 0x8219E554;
	}
	return 0x8219E554;
} // Block from 8219E548h-8219E554h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219E554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E554);
		  /* 8219E554h */ case    0:  		/* mr R3, R31 */
		/* 8219E554h case    0:*/		regs.R3 = regs.R31;
		/* 8219E554h case    0:*/		return 0x8219E558;
		  /* 8219E558h */ case    1:  		/* bl -156560 */
		/* 8219E558h case    1:*/		regs.LR = 0x8219E55C; return 0x821781C8;
		/* 8219E558h case    1:*/		return 0x8219E55C;
		  /* 8219E55Ch */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 8219E55Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E55Ch case    2:*/		return 0x8219E560;
		  /* 8219E560h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 8219E560h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8219E560h case    3:*/		return 0x8219E564;
		  /* 8219E564h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E564h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E564h case    4:*/		return 0x8219E568;
		  /* 8219E568h */ case    5:  		/* mr R4, R28 */
		/* 8219E568h case    5:*/		regs.R4 = regs.R28;
		/* 8219E568h case    5:*/		return 0x8219E56C;
		  /* 8219E56Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E56Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E580;  }
		/* 8219E56Ch case    6:*/		return 0x8219E570;
		  /* 8219E570h */ case    7:  		/* mr R3, R29 */
		/* 8219E570h case    7:*/		regs.R3 = regs.R29;
		/* 8219E570h case    7:*/		return 0x8219E574;
		  /* 8219E574h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 8219E574h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 8219E574h case    8:*/		return 0x8219E578;
		  /* 8219E578h */ case    9:  		/* bl -185480 */
		/* 8219E578h case    9:*/		regs.LR = 0x8219E57C; return 0x821710F0;
		/* 8219E578h case    9:*/		return 0x8219E57C;
		  /* 8219E57Ch */ case   10:  		/* mr R4, R3 */
		/* 8219E57Ch case   10:*/		regs.R4 = regs.R3;
		/* 8219E57Ch case   10:*/		return 0x8219E580;
	}
	return 0x8219E580;
} // Block from 8219E554h-8219E580h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E580);
		  /* 8219E580h */ case    0:  		/* mr R3, R31 */
		/* 8219E580h case    0:*/		regs.R3 = regs.R31;
		/* 8219E580h case    0:*/		return 0x8219E584;
		  /* 8219E584h */ case    1:  		/* bl -156604 */
		/* 8219E584h case    1:*/		regs.LR = 0x8219E588; return 0x821781C8;
		/* 8219E584h case    1:*/		return 0x8219E588;
		  /* 8219E588h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219E588h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E588h case    2:*/		return 0x8219E58C;
		  /* 8219E58Ch */ case    3:  		/* li R10, 1 */
		/* 8219E58Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219E58Ch case    3:*/		return 0x8219E590;
		  /* 8219E590h */ case    4:  		/* stw R3, <#[R31 + 48]> */
		/* 8219E590h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8219E590h case    4:*/		return 0x8219E594;
		  /* 8219E594h */ case    5:  		/* mr R6, R27 */
		/* 8219E594h case    5:*/		regs.R6 = regs.R27;
		/* 8219E594h case    5:*/		return 0x8219E598;
		  /* 8219E598h */ case    6:  		/* rlwimi R11, R10, 14, 15, 17 */
		/* 8219E598h case    6:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R11,regs.R10);
		/* 8219E598h case    6:*/		return 0x8219E59C;
		  /* 8219E59Ch */ case    7:  		/* mr R5, R26 */
		/* 8219E59Ch case    7:*/		regs.R5 = regs.R26;
		/* 8219E59Ch case    7:*/		return 0x8219E5A0;
		  /* 8219E5A0h */ case    8:  		/* stw R11, <#[R31 + 8]> */
		/* 8219E5A0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E5A0h case    8:*/		return 0x8219E5A4;
		  /* 8219E5A4h */ case    9:  		/* mr R4, R31 */
		/* 8219E5A4h case    9:*/		regs.R4 = regs.R31;
		/* 8219E5A4h case    9:*/		return 0x8219E5A8;
		  /* 8219E5A8h */ case   10:  		/* mr R3, R29 */
		/* 8219E5A8h case   10:*/		regs.R3 = regs.R29;
		/* 8219E5A8h case   10:*/		return 0x8219E5AC;
		  /* 8219E5ACh */ case   11:  		/* bl -202500 */
		/* 8219E5ACh case   11:*/		regs.LR = 0x8219E5B0; return 0x8216CEA8;
		/* 8219E5ACh case   11:*/		return 0x8219E5B0;
		  /* 8219E5B0h */ case   12:  		/* mr R3, R31 */
		/* 8219E5B0h case   12:*/		regs.R3 = regs.R31;
		/* 8219E5B0h case   12:*/		return 0x8219E5B4;
		  /* 8219E5B4h */ case   13:  		/* addi R1, R1, 144 */
		/* 8219E5B4h case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219E5B4h case   13:*/		return 0x8219E5B8;
	}
	return 0x8219E5B8;
} // Block from 8219E580h-8219E5B8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219E5B8h
// Function '?IsEmpty@?$Queue@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z$09@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E5B8);
		  /* 8219E5B8h */ case    0:  		/* b -1102616 */
		/* 8219E5B8h case    0:*/		return 0x820912A0;
		/* 8219E5B8h case    0:*/		return 0x8219E5BC;
		  /* 8219E5BCh */ case    1:  		/* nop */
		/* 8219E5BCh case    1:*/		cpu::op::nop();
		/* 8219E5BCh case    1:*/		return 0x8219E5C0;
	}
	return 0x8219E5C0;
} // Block from 8219E5B8h-8219E5C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219E5C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E5C0);
		  /* 8219E5C0h */ case    0:  		/* mfspr R12, LR */
		/* 8219E5C0h case    0:*/		regs.R12 = regs.LR;
		/* 8219E5C0h case    0:*/		return 0x8219E5C4;
		  /* 8219E5C4h */ case    1:  		/* bl -1102708 */
		/* 8219E5C4h case    1:*/		regs.LR = 0x8219E5C8; return 0x82091250;
		/* 8219E5C4h case    1:*/		return 0x8219E5C8;
		  /* 8219E5C8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219E5C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219E5C8h case    2:*/		return 0x8219E5CC;
		  /* 8219E5CCh */ case    3:  		/* mr R26, R4 */
		/* 8219E5CCh case    3:*/		regs.R26 = regs.R4;
		/* 8219E5CCh case    3:*/		return 0x8219E5D0;
		  /* 8219E5D0h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219E5D0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219E5D0h case    4:*/		return 0x8219E5D4;
		  /* 8219E5D4h */ case    5:  		/* mr R27, R5 */
		/* 8219E5D4h case    5:*/		regs.R27 = regs.R5;
		/* 8219E5D4h case    5:*/		return 0x8219E5D8;
		  /* 8219E5D8h */ case    6:  		/* mr R30, R6 */
		/* 8219E5D8h case    6:*/		regs.R30 = regs.R6;
		/* 8219E5D8h case    6:*/		return 0x8219E5DC;
		  /* 8219E5DCh */ case    7:  		/* mr R28, R7 */
		/* 8219E5DCh case    7:*/		regs.R28 = regs.R7;
		/* 8219E5DCh case    7:*/		return 0x8219E5E0;
		  /* 8219E5E0h */ case    8:  		/* li R8, 4 */
		/* 8219E5E0h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219E5E0h case    8:*/		return 0x8219E5E4;
		  /* 8219E5E4h */ case    9:  		/* li R7, 2 */
		/* 8219E5E4h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 8219E5E4h case    9:*/		return 0x8219E5E8;
		  /* 8219E5E8h */ case   10:  		/* li R6, 17 */
		/* 8219E5E8h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x11);
		/* 8219E5E8h case   10:*/		return 0x8219E5EC;
		  /* 8219E5ECh */ case   11:  		/* li R5, 0 */
		/* 8219E5ECh case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219E5ECh case   11:*/		return 0x8219E5F0;
		  /* 8219E5F0h */ case   12:  		/* mr R29, R3 */
		/* 8219E5F0h case   12:*/		regs.R29 = regs.R3;
		/* 8219E5F0h case   12:*/		return 0x8219E5F4;
		  /* 8219E5F4h */ case   13:  		/* bl 549796 */
		/* 8219E5F4h case   13:*/		regs.LR = 0x8219E5F8; return 0x82224998;
		/* 8219E5F4h case   13:*/		return 0x8219E5F8;
		  /* 8219E5F8h */ case   14:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219E5F8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219E5F8h case   14:*/		return 0x8219E5FC;
		  /* 8219E5FCh */ case   15:  		/* mr R31, R3 */
		/* 8219E5FCh case   15:*/		regs.R31 = regs.R3;
		/* 8219E5FCh case   15:*/		return 0x8219E600;
		  /* 8219E600h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8219E600h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E600h case   16:*/		return 0x8219E604;
		  /* 8219E604h */ case   17:  		/* mr R4, R30 */
		/* 8219E604h case   17:*/		regs.R4 = regs.R30;
		/* 8219E604h case   17:*/		return 0x8219E608;
	}
	return 0x8219E608;
} // Block from 8219E5C0h-8219E608h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219E608h
// Function '?RemoveHead@?$Queue@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z$09@D3DXShader@@QAAPAVInstruction@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E608);
		  /* 8219E608h */ case    0:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E608h case    0:*/		if ( regs.CR[6].eq ) { return 0x8219E61C;  }
		/* 8219E608h case    0:*/		return 0x8219E60C;
		  /* 8219E60Ch */ case    1:  		/* mr R3, R29 */
		/* 8219E60Ch case    1:*/		regs.R3 = regs.R29;
		/* 8219E60Ch case    1:*/		return 0x8219E610;
		  /* 8219E610h */ case    2:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219E610h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219E610h case    2:*/		return 0x8219E614;
		  /* 8219E614h */ case    3:  		/* bl -185636 */
		/* 8219E614h case    3:*/		regs.LR = 0x8219E618; return 0x821710F0;
		/* 8219E614h case    3:*/		return 0x8219E618;
		  /* 8219E618h */ case    4:  		/* mr R4, R3 */
		/* 8219E618h case    4:*/		regs.R4 = regs.R3;
		/* 8219E618h case    4:*/		return 0x8219E61C;
	}
	return 0x8219E61C;
} // Block from 8219E608h-8219E61Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219E61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E61C);
		  /* 8219E61Ch */ case    0:  		/* mr R3, R31 */
		/* 8219E61Ch case    0:*/		regs.R3 = regs.R31;
		/* 8219E61Ch case    0:*/		return 0x8219E620;
		  /* 8219E620h */ case    1:  		/* bl -156760 */
		/* 8219E620h case    1:*/		regs.LR = 0x8219E624; return 0x821781C8;
		/* 8219E620h case    1:*/		return 0x8219E624;
		  /* 8219E624h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 8219E624h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E624h case    2:*/		return 0x8219E628;
		  /* 8219E628h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 8219E628h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8219E628h case    3:*/		return 0x8219E62C;
		  /* 8219E62Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E62Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E62Ch case    4:*/		return 0x8219E630;
		  /* 8219E630h */ case    5:  		/* mr R4, R28 */
		/* 8219E630h case    5:*/		regs.R4 = regs.R28;
		/* 8219E630h case    5:*/		return 0x8219E634;
		  /* 8219E634h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E634h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E648;  }
		/* 8219E634h case    6:*/		return 0x8219E638;
		  /* 8219E638h */ case    7:  		/* mr R3, R29 */
		/* 8219E638h case    7:*/		regs.R3 = regs.R29;
		/* 8219E638h case    7:*/		return 0x8219E63C;
		  /* 8219E63Ch */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 8219E63Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 8219E63Ch case    8:*/		return 0x8219E640;
		  /* 8219E640h */ case    9:  		/* bl -185680 */
		/* 8219E640h case    9:*/		regs.LR = 0x8219E644; return 0x821710F0;
		/* 8219E640h case    9:*/		return 0x8219E644;
		  /* 8219E644h */ case   10:  		/* mr R4, R3 */
		/* 8219E644h case   10:*/		regs.R4 = regs.R3;
		/* 8219E644h case   10:*/		return 0x8219E648;
	}
	return 0x8219E648;
} // Block from 8219E61Ch-8219E648h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E648);
		  /* 8219E648h */ case    0:  		/* mr R3, R31 */
		/* 8219E648h case    0:*/		regs.R3 = regs.R31;
		/* 8219E648h case    0:*/		return 0x8219E64C;
		  /* 8219E64Ch */ case    1:  		/* bl -156804 */
		/* 8219E64Ch case    1:*/		regs.LR = 0x8219E650; return 0x821781C8;
		/* 8219E64Ch case    1:*/		return 0x8219E650;
		  /* 8219E650h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219E650h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E650h case    2:*/		return 0x8219E654;
		  /* 8219E654h */ case    3:  		/* li R10, 1 */
		/* 8219E654h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219E654h case    3:*/		return 0x8219E658;
		  /* 8219E658h */ case    4:  		/* stw R3, <#[R31 + 48]> */
		/* 8219E658h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8219E658h case    4:*/		return 0x8219E65C;
		  /* 8219E65Ch */ case    5:  		/* mr R6, R27 */
		/* 8219E65Ch case    5:*/		regs.R6 = regs.R27;
		/* 8219E65Ch case    5:*/		return 0x8219E660;
		  /* 8219E660h */ case    6:  		/* rlwimi R11, R10, 14, 15, 17 */
		/* 8219E660h case    6:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R11,regs.R10);
		/* 8219E660h case    6:*/		return 0x8219E664;
		  /* 8219E664h */ case    7:  		/* mr R5, R26 */
		/* 8219E664h case    7:*/		regs.R5 = regs.R26;
		/* 8219E664h case    7:*/		return 0x8219E668;
		  /* 8219E668h */ case    8:  		/* stw R11, <#[R31 + 8]> */
		/* 8219E668h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E668h case    8:*/		return 0x8219E66C;
		  /* 8219E66Ch */ case    9:  		/* mr R4, R31 */
		/* 8219E66Ch case    9:*/		regs.R4 = regs.R31;
		/* 8219E66Ch case    9:*/		return 0x8219E670;
		  /* 8219E670h */ case   10:  		/* mr R3, R29 */
		/* 8219E670h case   10:*/		regs.R3 = regs.R29;
		/* 8219E670h case   10:*/		return 0x8219E674;
		  /* 8219E674h */ case   11:  		/* bl -202700 */
		/* 8219E674h case   11:*/		regs.LR = 0x8219E678; return 0x8216CEA8;
		/* 8219E674h case   11:*/		return 0x8219E678;
		  /* 8219E678h */ case   12:  		/* mr R3, R31 */
		/* 8219E678h case   12:*/		regs.R3 = regs.R31;
		/* 8219E678h case   12:*/		return 0x8219E67C;
		  /* 8219E67Ch */ case   13:  		/* addi R1, R1, 144 */
		/* 8219E67Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219E67Ch case   13:*/		return 0x8219E680;
		  /* 8219E680h */ case   14:  		/* b -1102816 */
		/* 8219E680h case   14:*/		return 0x820912A0;
		/* 8219E680h case   14:*/		return 0x8219E684;
		  /* 8219E684h */ case   15:  		/* nop */
		/* 8219E684h case   15:*/		cpu::op::nop();
		/* 8219E684h case   15:*/		return 0x8219E688;
	}
	return 0x8219E688;
} // Block from 8219E648h-8219E688h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219E688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E688);
		  /* 8219E688h */ case    0:  		/* mfspr R12, LR */
		/* 8219E688h case    0:*/		regs.R12 = regs.LR;
		/* 8219E688h case    0:*/		return 0x8219E68C;
		  /* 8219E68Ch */ case    1:  		/* bl -1102912 */
		/* 8219E68Ch case    1:*/		regs.LR = 0x8219E690; return 0x8209124C;
		/* 8219E68Ch case    1:*/		return 0x8219E690;
		  /* 8219E690h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219E690h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219E690h case    2:*/		return 0x8219E694;
		  /* 8219E694h */ case    3:  		/* mr R25, R4 */
		/* 8219E694h case    3:*/		regs.R25 = regs.R4;
		/* 8219E694h case    3:*/		return 0x8219E698;
		  /* 8219E698h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219E698h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219E698h case    4:*/		return 0x8219E69C;
		  /* 8219E69Ch */ case    5:  		/* mr R26, R5 */
		/* 8219E69Ch case    5:*/		regs.R26 = regs.R5;
		/* 8219E69Ch case    5:*/		return 0x8219E6A0;
		  /* 8219E6A0h */ case    6:  		/* mr R30, R6 */
		/* 8219E6A0h case    6:*/		regs.R30 = regs.R6;
		/* 8219E6A0h case    6:*/		return 0x8219E6A4;
		  /* 8219E6A4h */ case    7:  		/* mr R28, R7 */
		/* 8219E6A4h case    7:*/		regs.R28 = regs.R7;
		/* 8219E6A4h case    7:*/		return 0x8219E6A8;
		  /* 8219E6A8h */ case    8:  		/* mr R27, R8 */
		/* 8219E6A8h case    8:*/		regs.R27 = regs.R8;
		/* 8219E6A8h case    8:*/		return 0x8219E6AC;
		  /* 8219E6ACh */ case    9:  		/* li R8, 4 */
		/* 8219E6ACh case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219E6ACh case    9:*/		return 0x8219E6B0;
		  /* 8219E6B0h */ case   10:  		/* li R7, 3 */
		/* 8219E6B0h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 8219E6B0h case   10:*/		return 0x8219E6B4;
		  /* 8219E6B4h */ case   11:  		/* li R6, 18 */
		/* 8219E6B4h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x12);
		/* 8219E6B4h case   11:*/		return 0x8219E6B8;
		  /* 8219E6B8h */ case   12:  		/* li R5, 0 */
		/* 8219E6B8h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219E6B8h case   12:*/		return 0x8219E6BC;
		  /* 8219E6BCh */ case   13:  		/* mr R29, R3 */
		/* 8219E6BCh case   13:*/		regs.R29 = regs.R3;
		/* 8219E6BCh case   13:*/		return 0x8219E6C0;
	}
	return 0x8219E6C0;
} // Block from 8219E688h-8219E6C0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219E6C0h
// Function '?RemoveAll@?$Queue@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z$09@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E6C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E6C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E6C0);
		  /* 8219E6C0h */ case    0:  		/* bl 549592 */
		/* 8219E6C0h case    0:*/		regs.LR = 0x8219E6C4; return 0x82224998;
		/* 8219E6C0h case    0:*/		return 0x8219E6C4;
		  /* 8219E6C4h */ case    1:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219E6C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219E6C4h case    1:*/		return 0x8219E6C8;
		  /* 8219E6C8h */ case    2:  		/* mr R31, R3 */
		/* 8219E6C8h case    2:*/		regs.R31 = regs.R3;
		/* 8219E6C8h case    2:*/		return 0x8219E6CC;
		  /* 8219E6CCh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8219E6CCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E6CCh case    3:*/		return 0x8219E6D0;
		  /* 8219E6D0h */ case    4:  		/* mr R4, R30 */
		/* 8219E6D0h case    4:*/		regs.R4 = regs.R30;
		/* 8219E6D0h case    4:*/		return 0x8219E6D4;
		  /* 8219E6D4h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E6D4h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219E6E8;  }
		/* 8219E6D4h case    5:*/		return 0x8219E6D8;
		  /* 8219E6D8h */ case    6:  		/* mr R3, R29 */
		/* 8219E6D8h case    6:*/		regs.R3 = regs.R29;
		/* 8219E6D8h case    6:*/		return 0x8219E6DC;
		  /* 8219E6DCh */ case    7:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219E6DCh case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219E6DCh case    7:*/		return 0x8219E6E0;
		  /* 8219E6E0h */ case    8:  		/* bl -185840 */
		/* 8219E6E0h case    8:*/		regs.LR = 0x8219E6E4; return 0x821710F0;
		/* 8219E6E0h case    8:*/		return 0x8219E6E4;
		  /* 8219E6E4h */ case    9:  		/* mr R4, R3 */
		/* 8219E6E4h case    9:*/		regs.R4 = regs.R3;
		/* 8219E6E4h case    9:*/		return 0x8219E6E8;
	}
	return 0x8219E6E8;
} // Block from 8219E6C0h-8219E6E8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219E6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E6E8);
		  /* 8219E6E8h */ case    0:  		/* mr R3, R31 */
		/* 8219E6E8h case    0:*/		regs.R3 = regs.R31;
		/* 8219E6E8h case    0:*/		return 0x8219E6EC;
		  /* 8219E6ECh */ case    1:  		/* bl -156964 */
		/* 8219E6ECh case    1:*/		regs.LR = 0x8219E6F0; return 0x821781C8;
		/* 8219E6ECh case    1:*/		return 0x8219E6F0;
		  /* 8219E6F0h */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 8219E6F0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E6F0h case    2:*/		return 0x8219E6F4;
		  /* 8219E6F4h */ case    3:  		/* lwz R11, <#[R28 + 16]> */
		/* 8219E6F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 8219E6F4h case    3:*/		return 0x8219E6F8;
		  /* 8219E6F8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E6F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E6F8h case    4:*/		return 0x8219E6FC;
		  /* 8219E6FCh */ case    5:  		/* mr R4, R28 */
		/* 8219E6FCh case    5:*/		regs.R4 = regs.R28;
		/* 8219E6FCh case    5:*/		return 0x8219E700;
		  /* 8219E700h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E700h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E714;  }
		/* 8219E700h case    6:*/		return 0x8219E704;
		  /* 8219E704h */ case    7:  		/* mr R3, R29 */
		/* 8219E704h case    7:*/		regs.R3 = regs.R29;
		/* 8219E704h case    7:*/		return 0x8219E708;
		  /* 8219E708h */ case    8:  		/* lwz R5, <#[R28 + 12]> */
		/* 8219E708h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x0000000C) );
		/* 8219E708h case    8:*/		return 0x8219E70C;
		  /* 8219E70Ch */ case    9:  		/* bl -185884 */
		/* 8219E70Ch case    9:*/		regs.LR = 0x8219E710; return 0x821710F0;
		/* 8219E70Ch case    9:*/		return 0x8219E710;
		  /* 8219E710h */ case   10:  		/* mr R4, R3 */
		/* 8219E710h case   10:*/		regs.R4 = regs.R3;
		/* 8219E710h case   10:*/		return 0x8219E714;
	}
	return 0x8219E714;
} // Block from 8219E6E8h-8219E714h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219E714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E714);
		  /* 8219E714h */ case    0:  		/* mr R3, R31 */
		/* 8219E714h case    0:*/		regs.R3 = regs.R31;
		/* 8219E714h case    0:*/		return 0x8219E718;
		  /* 8219E718h */ case    1:  		/* bl -157008 */
		/* 8219E718h case    1:*/		regs.LR = 0x8219E71C; return 0x821781C8;
		/* 8219E718h case    1:*/		return 0x8219E71C;
		  /* 8219E71Ch */ case    2:  		/* stw R3, <#[R31 + 48]> */
		/* 8219E71Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 8219E71Ch case    2:*/		return 0x8219E720;
		  /* 8219E720h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 8219E720h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 8219E720h case    3:*/		return 0x8219E724;
		  /* 8219E724h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8219E724h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E724h case    4:*/		return 0x8219E728;
		  /* 8219E728h */ case    5:  		/* mr R4, R27 */
		/* 8219E728h case    5:*/		regs.R4 = regs.R27;
		/* 8219E728h case    5:*/		return 0x8219E72C;
		  /* 8219E72Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E72Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x8219E740;  }
		/* 8219E72Ch case    6:*/		return 0x8219E730;
		  /* 8219E730h */ case    7:  		/* mr R3, R29 */
		/* 8219E730h case    7:*/		regs.R3 = regs.R29;
		/* 8219E730h case    7:*/		return 0x8219E734;
		  /* 8219E734h */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 8219E734h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 8219E734h case    8:*/		return 0x8219E738;
	}
	return 0x8219E738;
} // Block from 8219E714h-8219E738h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219E738h
// Function '?MakeInstr_MERGE@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E738);
		  /* 8219E738h */ case    0:  		/* bl -185928 */
		/* 8219E738h case    0:*/		regs.LR = 0x8219E73C; return 0x821710F0;
		/* 8219E738h case    0:*/		return 0x8219E73C;
		  /* 8219E73Ch */ case    1:  		/* mr R4, R3 */
		/* 8219E73Ch case    1:*/		regs.R4 = regs.R3;
		/* 8219E73Ch case    1:*/		return 0x8219E740;
	}
	return 0x8219E740;
} // Block from 8219E738h-8219E740h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219E740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E740);
		  /* 8219E740h */ case    0:  		/* mr R3, R31 */
		/* 8219E740h case    0:*/		regs.R3 = regs.R31;
		/* 8219E740h case    0:*/		return 0x8219E744;
		  /* 8219E744h */ case    1:  		/* bl -157052 */
		/* 8219E744h case    1:*/		regs.LR = 0x8219E748; return 0x821781C8;
		/* 8219E744h case    1:*/		return 0x8219E748;
		  /* 8219E748h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219E748h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E748h case    2:*/		return 0x8219E74C;
		  /* 8219E74Ch */ case    3:  		/* li R10, 1 */
		/* 8219E74Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219E74Ch case    3:*/		return 0x8219E750;
		  /* 8219E750h */ case    4:  		/* stw R3, <#[R31 + 52]> */
		/* 8219E750h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000034) );
		/* 8219E750h case    4:*/		return 0x8219E754;
		  /* 8219E754h */ case    5:  		/* mr R6, R26 */
		/* 8219E754h case    5:*/		regs.R6 = regs.R26;
		/* 8219E754h case    5:*/		return 0x8219E758;
		  /* 8219E758h */ case    6:  		/* rlwimi R11, R10, 14, 15, 17 */
		/* 8219E758h case    6:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R11,regs.R10);
		/* 8219E758h case    6:*/		return 0x8219E75C;
		  /* 8219E75Ch */ case    7:  		/* mr R5, R25 */
		/* 8219E75Ch case    7:*/		regs.R5 = regs.R25;
		/* 8219E75Ch case    7:*/		return 0x8219E760;
		  /* 8219E760h */ case    8:  		/* stw R11, <#[R31 + 8]> */
		/* 8219E760h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E760h case    8:*/		return 0x8219E764;
		  /* 8219E764h */ case    9:  		/* mr R4, R31 */
		/* 8219E764h case    9:*/		regs.R4 = regs.R31;
		/* 8219E764h case    9:*/		return 0x8219E768;
		  /* 8219E768h */ case   10:  		/* mr R3, R29 */
		/* 8219E768h case   10:*/		regs.R3 = regs.R29;
		/* 8219E768h case   10:*/		return 0x8219E76C;
		  /* 8219E76Ch */ case   11:  		/* bl -202948 */
		/* 8219E76Ch case   11:*/		regs.LR = 0x8219E770; return 0x8216CEA8;
		/* 8219E76Ch case   11:*/		return 0x8219E770;
		  /* 8219E770h */ case   12:  		/* mr R3, R31 */
		/* 8219E770h case   12:*/		regs.R3 = regs.R31;
		/* 8219E770h case   12:*/		return 0x8219E774;
		  /* 8219E774h */ case   13:  		/* addi R1, R1, 144 */
		/* 8219E774h case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219E774h case   13:*/		return 0x8219E778;
		  /* 8219E778h */ case   14:  		/* b -1103068 */
		/* 8219E778h case   14:*/		return 0x8209129C;
		/* 8219E778h case   14:*/		return 0x8219E77C;
		  /* 8219E77Ch */ case   15:  		/* nop */
		/* 8219E77Ch case   15:*/		cpu::op::nop();
		/* 8219E77Ch case   15:*/		return 0x8219E780;
	}
	return 0x8219E780;
} // Block from 8219E740h-8219E780h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219E780h
// Function '?MakeInstr_V_ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E780);
		  /* 8219E780h */ case    0:  		/* mfspr R12, LR */
		/* 8219E780h case    0:*/		regs.R12 = regs.LR;
		/* 8219E780h case    0:*/		return 0x8219E784;
		  /* 8219E784h */ case    1:  		/* bl -1103152 */
		/* 8219E784h case    1:*/		regs.LR = 0x8219E788; return 0x82091254;
		/* 8219E784h case    1:*/		return 0x8219E788;
		  /* 8219E788h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8219E788h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8219E788h case    2:*/		return 0x8219E78C;
		  /* 8219E78Ch */ case    3:  		/* mr R27, R4 */
		/* 8219E78Ch case    3:*/		regs.R27 = regs.R4;
		/* 8219E78Ch case    3:*/		return 0x8219E790;
		  /* 8219E790h */ case    4:  		/* lwz R4, <#[R5 + 28]> */
		/* 8219E790h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R5 + 0x0000001C) );
		/* 8219E790h case    4:*/		return 0x8219E794;
		  /* 8219E794h */ case    5:  		/* mr R28, R5 */
		/* 8219E794h case    5:*/		regs.R28 = regs.R5;
		/* 8219E794h case    5:*/		return 0x8219E798;
		  /* 8219E798h */ case    6:  		/* mr R30, R6 */
		/* 8219E798h case    6:*/		regs.R30 = regs.R6;
		/* 8219E798h case    6:*/		return 0x8219E79C;
		  /* 8219E79Ch */ case    7:  		/* li R8, 4 */
		/* 8219E79Ch case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8219E79Ch case    7:*/		return 0x8219E7A0;
		  /* 8219E7A0h */ case    8:  		/* li R7, 1 */
		/* 8219E7A0h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8219E7A0h case    8:*/		return 0x8219E7A4;
		  /* 8219E7A4h */ case    9:  		/* li R6, 20 */
		/* 8219E7A4h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x14);
		/* 8219E7A4h case    9:*/		return 0x8219E7A8;
		  /* 8219E7A8h */ case   10:  		/* li R5, 0 */
		/* 8219E7A8h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219E7A8h case   10:*/		return 0x8219E7AC;
		  /* 8219E7ACh */ case   11:  		/* mr R29, R3 */
		/* 8219E7ACh case   11:*/		regs.R29 = regs.R3;
		/* 8219E7ACh case   11:*/		return 0x8219E7B0;
		  /* 8219E7B0h */ case   12:  		/* bl 549352 */
		/* 8219E7B0h case   12:*/		regs.LR = 0x8219E7B4; return 0x82224998;
		/* 8219E7B0h case   12:*/		return 0x8219E7B4;
		  /* 8219E7B4h */ case   13:  		/* lwz R11, <#[R30 + 16]> */
		/* 8219E7B4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 8219E7B4h case   13:*/		return 0x8219E7B8;
		  /* 8219E7B8h */ case   14:  		/* mr R31, R3 */
		/* 8219E7B8h case   14:*/		regs.R31 = regs.R3;
		/* 8219E7B8h case   14:*/		return 0x8219E7BC;
		  /* 8219E7BCh */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 8219E7BCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E7BCh case   15:*/		return 0x8219E7C0;
		  /* 8219E7C0h */ case   16:  		/* mr R4, R30 */
		/* 8219E7C0h case   16:*/		regs.R4 = regs.R30;
		/* 8219E7C0h case   16:*/		return 0x8219E7C4;
		  /* 8219E7C4h */ case   17:  		/* bc 12, CR6_EQ, 20 */
		/* 8219E7C4h case   17:*/		if ( regs.CR[6].eq ) { return 0x8219E7D8;  }
		/* 8219E7C4h case   17:*/		return 0x8219E7C8;
		  /* 8219E7C8h */ case   18:  		/* mr R3, R29 */
		/* 8219E7C8h case   18:*/		regs.R3 = regs.R29;
		/* 8219E7C8h case   18:*/		return 0x8219E7CC;
		  /* 8219E7CCh */ case   19:  		/* lwz R5, <#[R30 + 12]> */
		/* 8219E7CCh case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8219E7CCh case   19:*/		return 0x8219E7D0;
		  /* 8219E7D0h */ case   20:  		/* bl -186080 */
		/* 8219E7D0h case   20:*/		regs.LR = 0x8219E7D4; return 0x821710F0;
		/* 8219E7D0h case   20:*/		return 0x8219E7D4;
		  /* 8219E7D4h */ case   21:  		/* mr R4, R3 */
		/* 8219E7D4h case   21:*/		regs.R4 = regs.R3;
		/* 8219E7D4h case   21:*/		return 0x8219E7D8;
	}
	return 0x8219E7D8;
} // Block from 8219E780h-8219E7D8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8219E7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E7D8);
		  /* 8219E7D8h */ case    0:  		/* mr R3, R31 */
		/* 8219E7D8h case    0:*/		regs.R3 = regs.R31;
		/* 8219E7D8h case    0:*/		return 0x8219E7DC;
		  /* 8219E7DCh */ case    1:  		/* bl -157204 */
		/* 8219E7DCh case    1:*/		regs.LR = 0x8219E7E0; return 0x821781C8;
		/* 8219E7DCh case    1:*/		return 0x8219E7E0;
		  /* 8219E7E0h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219E7E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E7E0h case    2:*/		return 0x8219E7E4;
		  /* 8219E7E4h */ case    3:  		/* li R10, 1 */
		/* 8219E7E4h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219E7E4h case    3:*/		return 0x8219E7E8;
		  /* 8219E7E8h */ case    4:  		/* stw R3, <#[R31 + 44]> */
		/* 8219E7E8h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 8219E7E8h case    4:*/		return 0x8219E7EC;
		  /* 8219E7ECh */ case    5:  		/* mr R6, R28 */
		/* 8219E7ECh case    5:*/		regs.R6 = regs.R28;
		/* 8219E7ECh case    5:*/		return 0x8219E7F0;
		  /* 8219E7F0h */ case    6:  		/* rlwimi R11, R10, 14, 15, 17 */
		/* 8219E7F0h case    6:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R11,regs.R10);
		/* 8219E7F0h case    6:*/		return 0x8219E7F4;
		  /* 8219E7F4h */ case    7:  		/* mr R5, R27 */
		/* 8219E7F4h case    7:*/		regs.R5 = regs.R27;
		/* 8219E7F4h case    7:*/		return 0x8219E7F8;
		  /* 8219E7F8h */ case    8:  		/* stw R11, <#[R31 + 8]> */
		/* 8219E7F8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219E7F8h case    8:*/		return 0x8219E7FC;
		  /* 8219E7FCh */ case    9:  		/* mr R4, R31 */
		/* 8219E7FCh case    9:*/		regs.R4 = regs.R31;
		/* 8219E7FCh case    9:*/		return 0x8219E800;
		  /* 8219E800h */ case   10:  		/* mr R3, R29 */
		/* 8219E800h case   10:*/		regs.R3 = regs.R29;
		/* 8219E800h case   10:*/		return 0x8219E804;
		  /* 8219E804h */ case   11:  		/* bl -203100 */
		/* 8219E804h case   11:*/		regs.LR = 0x8219E808; return 0x8216CEA8;
		/* 8219E804h case   11:*/		return 0x8219E808;
		  /* 8219E808h */ case   12:  		/* mr R3, R31 */
		/* 8219E808h case   12:*/		regs.R3 = regs.R31;
		/* 8219E808h case   12:*/		return 0x8219E80C;
		  /* 8219E80Ch */ case   13:  		/* addi R1, R1, 128 */
		/* 8219E80Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8219E80Ch case   13:*/		return 0x8219E810;
		  /* 8219E810h */ case   14:  		/* b -1103212 */
		/* 8219E810h case   14:*/		return 0x820912A4;
		/* 8219E810h case   14:*/		return 0x8219E814;
		  /* 8219E814h */ case   15:  		/* nop */
		/* 8219E814h case   15:*/		cpu::op::nop();
		/* 8219E814h case   15:*/		return 0x8219E818;
	}
	return 0x8219E818;
} // Block from 8219E7D8h-8219E818h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219E818h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E818);
		  /* 8219E818h */ case    0:  		/* mfspr R12, LR */
		/* 8219E818h case    0:*/		regs.R12 = regs.LR;
		/* 8219E818h case    0:*/		return 0x8219E81C;
		  /* 8219E81Ch */ case    1:  		/* bl -1103344 */
		/* 8219E81Ch case    1:*/		regs.LR = 0x8219E820; return 0x8209122C;
		/* 8219E81Ch case    1:*/		return 0x8219E820;
		  /* 8219E820h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 8219E820h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 8219E820h case    2:*/		return 0x8219E824;
		  /* 8219E824h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8219E824h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219E824h case    3:*/		return 0x8219E828;
		  /* 8219E828h */ case    4:  		/* mr R31, R3 */
		/* 8219E828h case    4:*/		regs.R31 = regs.R3;
		/* 8219E828h case    4:*/		return 0x8219E82C;
		  /* 8219E82Ch */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219E82Ch case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219E82Ch case    5:*/		return 0x8219E830;
		  /* 8219E830h */ case    6:  		/* bc 4, CR0_EQ, 1156 */
		/* 8219E830h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8219ECB4;  }
		/* 8219E830h case    6:*/		return 0x8219E834;
		  /* 8219E834h */ case    7:  		/* mr R19, R11 */
		/* 8219E834h case    7:*/		regs.R19 = regs.R11;
		/* 8219E834h case    7:*/		return 0x8219E838;
		  /* 8219E838h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 8219E838h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8219E838h case    8:*/		return 0x8219E83C;
		  /* 8219E83Ch */ case    9:  		/* bc 12, CR0_EQ, 1144 */
		/* 8219E83Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x8219ECB4;  }
		/* 8219E83Ch case    9:*/		return 0x8219E840;
		  /* 8219E840h */ case   10:  		/* rlwinm R17, R4, 0, 24, 31 */
		/* 8219E840h case   10:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R17,regs.R4);
		/* 8219E840h case   10:*/		return 0x8219E844;
		  /* 8219E844h */ case   11:  		/* li R21, 1 */
		/* 8219E844h case   11:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 8219E844h case   11:*/		return 0x8219E848;
		  /* 8219E848h */ case   12:  		/* cmplwi CR6, R17, 0 */
		/* 8219E848h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 8219E848h case   12:*/		return 0x8219E84C;
		  /* 8219E84Ch */ case   13:  		/* bc 4, CR6_EQ, 12 */
		/* 8219E84Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x8219E858;  }
		/* 8219E84Ch case   13:*/		return 0x8219E850;
	}
	return 0x8219E850;
} // Block from 8219E818h-8219E850h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219E850h
// Function '?MakeInstr_V_MAX@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E850);
		  /* 8219E850h */ case    0:  		/* lwz R11, <#[R19 + 88]> */
		/* 8219E850h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000058) );
		/* 8219E850h case    0:*/		return 0x8219E854;
		  /* 8219E854h */ case    1:  		/* stw R11, <#[R19 + 84]> */
		/* 8219E854h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000054) );
		/* 8219E854h case    1:*/		return 0x8219E858;
	}
	return 0x8219E858;
} // Block from 8219E850h-8219E858h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219E858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E858);
		  /* 8219E858h */ case    0:  		/* li R4, 0 */
		/* 8219E858h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8219E858h case    0:*/		return 0x8219E85C;
		  /* 8219E85Ch */ case    1:  		/* lwz R5, <#[R31 + 672]> */
		/* 8219E85Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000002A0) );
		/* 8219E85Ch case    1:*/		return 0x8219E860;
		  /* 8219E860h */ case    2:  		/* lwz R3, <#[R19 + 88]> */
		/* 8219E860h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R19 + 0x00000058) );
		/* 8219E860h case    2:*/		return 0x8219E864;
		  /* 8219E864h */ case    3:  		/* bl -194828 */
		/* 8219E864h case    3:*/		regs.LR = 0x8219E868; return 0x8216EF58;
		/* 8219E864h case    3:*/		return 0x8219E868;
		  /* 8219E868h */ case    4:  		/* lwz R11, <#[R31 + 668]> */
		/* 8219E868h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000029C) );
		/* 8219E868h case    4:*/		return 0x8219E86C;
		  /* 8219E86Ch */ case    5:  		/* addi R11, R11, -1 */
		/* 8219E86Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8219E86Ch case    5:*/		return 0x8219E870;
		  /* 8219E870h */ case    6:  		/* cmplw CR6, R3, R11 */
		/* 8219E870h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 8219E870h case    6:*/		return 0x8219E874;
		  /* 8219E874h */ case    7:  		/* bc 12, CR6_GT, 184 */
		/* 8219E874h case    7:*/		if ( regs.CR[6].gt ) { return 0x8219E92C;  }
		/* 8219E874h case    7:*/		return 0x8219E878;
		  /* 8219E878h */ case    8:  		/* lwz R9, <#[R31 + 672]> */
		/* 8219E878h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000002A0) );
		/* 8219E878h case    8:*/		return 0x8219E87C;
		  /* 8219E87Ch */ case    9:  		/* lwz R11, <#[R31 + 684]> */
		/* 8219E87Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002AC) );
		/* 8219E87Ch case    9:*/		return 0x8219E880;
		  /* 8219E880h */ case   10:  		/* mullw R10, R9, R3 */
		/* 8219E880h case   10:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R9,regs.R3);
		/* 8219E880h case   10:*/		return 0x8219E884;
		  /* 8219E884h */ case   11:  		/* lwz R8, <#[R19 + 88]> */
		/* 8219E884h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R19 + 0x00000058) );
		/* 8219E884h case   11:*/		return 0x8219E888;
		  /* 8219E888h */ case   12:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 8219E888h case   12:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 8219E888h case   12:*/		return 0x8219E88C;
		  /* 8219E88Ch */ case   13:  		/* rlwinm R9, R9, 3, 0, 28 */
		/* 8219E88Ch case   13:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R9);
		/* 8219E88Ch case   13:*/		return 0x8219E890;
		  /* 8219E890h */ case   14:  		/* add R11, R10, R11 */
		/* 8219E890h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219E890h case   14:*/		return 0x8219E894;
		  /* 8219E894h */ case   15:  		/* add R10, R9, R11 */
		/* 8219E894h case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R11);
		/* 8219E894h case   15:*/		return 0x8219E898;
		  /* 8219E898h */ case   16:  		/* cmplw CR6, R11, R10 */
		/* 8219E898h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8219E898h case   16:*/		return 0x8219E89C;
		  /* 8219E89Ch */ case   17:  		/* bc 4, CR6_LT, 52 */
		/* 8219E89Ch case   17:*/		if ( !regs.CR[6].lt ) { return 0x8219E8D0;  }
		/* 8219E89Ch case   17:*/		return 0x8219E8A0;
		  /* 8219E8A0h */ case   18:  		/* subf R10, R11, R10 */
		/* 8219E8A0h case   18:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8219E8A0h case   18:*/		return 0x8219E8A4;
		  /* 8219E8A4h */ case   19:  		/* addi R9, R8, -8 */
		/* 8219E8A4h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R8,0xFFFFFFF8);
		/* 8219E8A4h case   19:*/		return 0x8219E8A8;
		  /* 8219E8A8h */ case   20:  		/* addi R10, R10, -1 */
		/* 8219E8A8h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219E8A8h case   20:*/		return 0x8219E8AC;
		  /* 8219E8ACh */ case   21:  		/* addi R11, R11, -8 */
		/* 8219E8ACh case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFF8);
		/* 8219E8ACh case   21:*/		return 0x8219E8B0;
		  /* 8219E8B0h */ case   22:  		/* rlwinm R10, R10, 29, 3, 31 */
		/* 8219E8B0h case   22:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R10,regs.R10);
		/* 8219E8B0h case   22:*/		return 0x8219E8B4;
		  /* 8219E8B4h */ case   23:  		/* addi R10, R10, 1 */
		/* 8219E8B4h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8219E8B4h case   23:*/		return 0x8219E8B8;
		  /* 8219E8B8h */ case   24:  		/* mtspr CTR, R10 */
		/* 8219E8B8h case   24:*/		regs.CTR = regs.R10;
		/* 8219E8B8h case   24:*/		return 0x8219E8BC;
		  /* 8219E8BCh */ case   25:  		/* ldu R10, <#[R9 + 8]> */
		/* 8219E8BCh case   25:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 8219E8BCh case   25:*/		return 0x8219E8C0;
		  /* 8219E8C0h */ case   26:  		/* ld R8, <#[R11 + 8]> */
		/* 8219E8C0h case   26:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 8219E8C0h case   26:*/		return 0x8219E8C4;
		  /* 8219E8C4h */ case   27:  		/* or R10, R10, R8 */
		/* 8219E8C4h case   27:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8219E8C4h case   27:*/		return 0x8219E8C8;
		  /* 8219E8C8h */ case   28:  		/* stdu R10, <#[R11 + 8]> */
		/* 8219E8C8h case   28:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		regs.R11 = (uint32)(regs.R11 + 0x00000008);
		/* 8219E8C8h case   28:*/		return 0x8219E8CC;
		  /* 8219E8CCh */ case   29:  		/* bc 16, CR0_LT, -16 */
		/* 8219E8CCh case   29:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8219E8BC;  }
		/* 8219E8CCh case   29:*/		return 0x8219E8D0;
	}
	return 0x8219E8D0;
} // Block from 8219E858h-8219E8D0h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8219E8D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E8D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E8D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E8D0);
		  /* 8219E8D0h */ case    0:  		/* lwz R9, <#[R31 + 672]> */
		/* 8219E8D0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000002A0) );
		/* 8219E8D0h case    0:*/		return 0x8219E8D4;
		  /* 8219E8D4h */ case    1:  		/* rlwinm R10, R3, 29, 3, 28 */
		/* 8219E8D4h case    1:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R10,regs.R3);
		/* 8219E8D4h case    1:*/		return 0x8219E8D8;
		  /* 8219E8D8h */ case    2:  		/* lwz R11, <#[R31 + 684]> */
		/* 8219E8D8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002AC) );
		/* 8219E8D8h case    2:*/		return 0x8219E8DC;
		  /* 8219E8DCh */ case    3:  		/* rldicl R8, R3, 0, 58 */
		/* 8219E8DCh case    3:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R8,regs.R3);
		/* 8219E8DCh case    3:*/		return 0x8219E8E0;
		  /* 8219E8E0h */ case    4:  		/* mullw R9, R9, R3 */
		/* 8219E8E0h case    4:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R3);
		/* 8219E8E0h case    4:*/		return 0x8219E8E4;
		  /* 8219E8E4h */ case    5:  		/* rlwinm R9, R9, 3, 0, 28 */
		/* 8219E8E4h case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R9);
		/* 8219E8E4h case    5:*/		return 0x8219E8E8;
		  /* 8219E8E8h */ case    6:  		/* sld R8, R21, R8 */
		/* 8219E8E8h case    6:*/		cpu::op::sld<0>(regs,&regs.R8,regs.R21,regs.R8);
		/* 8219E8E8h case    6:*/		return 0x8219E8EC;
		  /* 8219E8ECh */ case    7:  		/* add R11, R9, R11 */
		/* 8219E8ECh case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8219E8ECh case    7:*/		return 0x8219E8F0;
		  /* 8219E8F0h */ case    8:  		/* ldx R9, <#[R10 + R11]> */
		/* 8219E8F0h case    8:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219E8F0h case    8:*/		return 0x8219E8F4;
		  /* 8219E8F4h */ case    9:  		/* subf R9, R8, R9 */
		/* 8219E8F4h case    9:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8219E8F4h case    9:*/		return 0x8219E8F8;
		  /* 8219E8F8h */ case   10:  		/* stdx R9, <#[R10 + R11]> */
		/* 8219E8F8h case   10:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219E8F8h case   10:*/		return 0x8219E8FC;
		  /* 8219E8FCh */ case   11:  		/* lwz R11, <#[R31 + 668]> */
		/* 8219E8FCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000029C) );
		/* 8219E8FCh case   11:*/		return 0x8219E900;
		  /* 8219E900h */ case   12:  		/* addi R30, R11, -1 */
		/* 8219E900h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFF);
		/* 8219E900h case   12:*/		return 0x8219E904;
		  /* 8219E904h */ case   13:  		/* cmplw CR6, R3, R30 */
		/* 8219E904h case   13:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R30);
		/* 8219E904h case   13:*/		return 0x8219E908;
		  /* 8219E908h */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 8219E908h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8219E914;  }
		/* 8219E908h case   14:*/		return 0x8219E90C;
		  /* 8219E90Ch */ case   15:  		/* li R3, -1 */
		/* 8219E90Ch case   15:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 8219E90Ch case   15:*/		return 0x8219E910;
		  /* 8219E910h */ case   16:  		/* b 20 */
		/* 8219E910h case   16:*/		return 0x8219E924;
		/* 8219E910h case   16:*/		return 0x8219E914;
	}
	return 0x8219E914;
} // Block from 8219E8D0h-8219E914h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219E914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E914);
		  /* 8219E914h */ case    0:  		/* addi R4, R3, 1 */
		/* 8219E914h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x1);
		/* 8219E914h case    0:*/		return 0x8219E918;
		  /* 8219E918h */ case    1:  		/* lwz R5, <#[R31 + 672]> */
		/* 8219E918h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x000002A0) );
		/* 8219E918h case    1:*/		return 0x8219E91C;
		  /* 8219E91Ch */ case    2:  		/* lwz R3, <#[R19 + 88]> */
		/* 8219E91Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R19 + 0x00000058) );
		/* 8219E91Ch case    2:*/		return 0x8219E920;
	}
	return 0x8219E920;
} // Block from 8219E914h-8219E920h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219E920h
// Function '?MakeInstr_V_MIN@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E920);
		  /* 8219E920h */ case    0:  		/* bl -195016 */
		/* 8219E920h case    0:*/		regs.LR = 0x8219E924; return 0x8216EF58;
		/* 8219E920h case    0:*/		return 0x8219E924;
	}
	return 0x8219E924;
} // Block from 8219E920h-8219E924h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219E924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E924);
		  /* 8219E924h */ case    0:  		/* cmplw CR6, R3, R30 */
		/* 8219E924h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R30);
		/* 8219E924h case    0:*/		return 0x8219E928;
		  /* 8219E928h */ case    1:  		/* bc 4, CR6_GT, -176 */
		/* 8219E928h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8219E878;  }
		/* 8219E928h case    1:*/		return 0x8219E92C;
	}
	return 0x8219E92C;
} // Block from 8219E924h-8219E92Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219E92Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E92C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E92C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E92C);
		  /* 8219E92Ch */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 8219E92Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8219E92Ch case    0:*/		return 0x8219E930;
		  /* 8219E930h */ case    1:  		/* addi R18, R19, 16 */
		/* 8219E930h case    1:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R19,0x10);
		/* 8219E930h case    1:*/		return 0x8219E934;
		  /* 8219E934h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219E934h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219E934h case    2:*/		return 0x8219E938;
		  /* 8219E938h */ case    3:  		/* bc 4, CR0_EQ, 232 */
		/* 8219E938h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219EA20;  }
		/* 8219E938h case    3:*/		return 0x8219E93C;
		  /* 8219E93Ch */ case    4:  		/* mr R5, R11 */
		/* 8219E93Ch case    4:*/		regs.R5 = regs.R11;
		/* 8219E93Ch case    4:*/		return 0x8219E940;
		  /* 8219E940h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 8219E940h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8219E940h case    5:*/		return 0x8219E944;
		  /* 8219E944h */ case    6:  		/* bc 12, CR0_EQ, 220 */
		/* 8219E944h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219EA20;  }
		/* 8219E944h case    6:*/		return 0x8219E948;
		  /* 8219E948h */ case    7:  		/* lwz R11, <#[R5 + 8]> */
		/* 8219E948h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 8219E948h case    7:*/		return 0x8219E94C;
		  /* 8219E94Ch */ case    8:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219E94Ch case    8:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219E94Ch case    8:*/		return 0x8219E950;
		  /* 8219E950h */ case    9:  		/* cmplwi CR6, R11, 14336 */
		/* 8219E950h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 8219E950h case    9:*/		return 0x8219E954;
		  /* 8219E954h */ case   10:  		/* bc 4, CR6_EQ, 176 */
		/* 8219E954h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8219EA04;  }
		/* 8219E954h case   10:*/		return 0x8219E958;
		  /* 8219E958h */ case   11:  		/* lwz R11, <#[R18 + 4]> */
		/* 8219E958h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 8219E958h case   11:*/		return 0x8219E95C;
		  /* 8219E95Ch */ case   12:  		/* lhz R9, <#[R5 + 18]> */
		/* 8219E95Ch case   12:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000012) );
		/* 8219E95Ch case   12:*/		return 0x8219E960;
		  /* 8219E960h */ case   13:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219E960h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219E960h case   13:*/		return 0x8219E964;
		  /* 8219E964h */ case   14:  		/* bc 4, CR0_EQ, 160 */
		/* 8219E964h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8219EA04;  }
		/* 8219E964h case   14:*/		return 0x8219E968;
		  /* 8219E968h */ case   15:  		/* mr R6, R11 */
		/* 8219E968h case   15:*/		regs.R6 = regs.R11;
		/* 8219E968h case   15:*/		return 0x8219E96C;
		  /* 8219E96Ch */ case   16:  		/* cmplwi CR0, R11, 0 */
		/* 8219E96Ch case   16:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8219E96Ch case   16:*/		return 0x8219E970;
		  /* 8219E970h */ case   17:  		/* bc 12, CR0_EQ, 148 */
		/* 8219E970h case   17:*/		if ( regs.CR[0].eq ) { return 0x8219EA04;  }
		/* 8219E970h case   17:*/		return 0x8219E974;
		  /* 8219E974h */ case   18:  		/* lwz R11, <#[R6 + 8]> */
		/* 8219E974h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 8219E974h case   18:*/		return 0x8219E978;
		  /* 8219E978h */ case   19:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219E978h case   19:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219E978h case   19:*/		return 0x8219E97C;
		  /* 8219E97Ch */ case   20:  		/* cmplwi CR6, R11, 14336 */
		/* 8219E97Ch case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 8219E97Ch case   20:*/		return 0x8219E980;
		  /* 8219E980h */ case   21:  		/* bc 4, CR6_EQ, 104 */
		/* 8219E980h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8219E9E8;  }
		/* 8219E980h case   21:*/		return 0x8219E984;
		  /* 8219E984h */ case   22:  		/* lhz R11, <#[R6 + 18]> */
		/* 8219E984h case   22:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000012) );
		/* 8219E984h case   22:*/		return 0x8219E988;
		  /* 8219E988h */ case   23:  		/* cmplw CR6, R9, R11 */
		/* 8219E988h case   23:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8219E988h case   23:*/		return 0x8219E98C;
		  /* 8219E98Ch */ case   24:  		/* bc 12, CR6_EQ, 92 */
		/* 8219E98Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x8219E9E8;  }
		/* 8219E98Ch case   24:*/		return 0x8219E990;
		  /* 8219E990h */ case   25:  		/* lwz R8, <#[R31 + 672]> */
		/* 8219E990h case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x000002A0) );
		/* 8219E990h case   25:*/		return 0x8219E994;
		  /* 8219E994h */ case   26:  		/* rlwinm R7, R11, 29, 3, 28 */
		/* 8219E994h case   26:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R7,regs.R11);
		/* 8219E994h case   26:*/		return 0x8219E998;
		  /* 8219E998h */ case   27:  		/* lwz R10, <#[R31 + 684]> */
		/* 8219E998h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000002AC) );
		/* 8219E998h case   27:*/		return 0x8219E99C;
		  /* 8219E99Ch */ case   28:  		/* rldicl R4, R11, 0, 58 */
		/* 8219E99Ch case   28:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R4,regs.R11);
		/* 8219E99Ch case   28:*/		return 0x8219E9A0;
		  /* 8219E9A0h */ case   29:  		/* mullw R8, R8, R9 */
		/* 8219E9A0h case   29:*/		cpu::op::mullw<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 8219E9A0h case   29:*/		return 0x8219E9A4;
		  /* 8219E9A4h */ case   30:  		/* rlwinm R8, R8, 3, 0, 28 */
		/* 8219E9A4h case   30:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R8,regs.R8);
		/* 8219E9A4h case   30:*/		return 0x8219E9A8;
		  /* 8219E9A8h */ case   31:  		/* sld R4, R21, R4 */
		/* 8219E9A8h case   31:*/		cpu::op::sld<0>(regs,&regs.R4,regs.R21,regs.R4);
		/* 8219E9A8h case   31:*/		return 0x8219E9AC;
		  /* 8219E9ACh */ case   32:  		/* add R10, R8, R10 */
		/* 8219E9ACh case   32:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 8219E9ACh case   32:*/		return 0x8219E9B0;
		  /* 8219E9B0h */ case   33:  		/* rlwinm R8, R9, 29, 3, 28 */
		/* 8219E9B0h case   33:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R8,regs.R9);
		/* 8219E9B0h case   33:*/		return 0x8219E9B4;
		  /* 8219E9B4h */ case   34:  		/* rldicl R3, R9, 0, 58 */
		/* 8219E9B4h case   34:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R3,regs.R9);
		/* 8219E9B4h case   34:*/		return 0x8219E9B8;
		  /* 8219E9B8h */ case   35:  		/* sld R3, R21, R3 */
		/* 8219E9B8h case   35:*/		cpu::op::sld<0>(regs,&regs.R3,regs.R21,regs.R3);
		/* 8219E9B8h case   35:*/		return 0x8219E9BC;
		  /* 8219E9BCh */ case   36:  		/* ldx R30, <#[R7 + R10]> */
		/* 8219E9BCh case   36:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8219E9BCh case   36:*/		return 0x8219E9C0;
		  /* 8219E9C0h */ case   37:  		/* or R4, R4, R30 */
		/* 8219E9C0h case   37:*/		cpu::op::or<0>(regs,&regs.R4,regs.R4,regs.R30);
		/* 8219E9C0h case   37:*/		return 0x8219E9C4;
		  /* 8219E9C4h */ case   38:  		/* stdx R4, <#[R7 + R10]> */
		/* 8219E9C4h case   38:*/		cpu::mem::store64( regs, regs.R4, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 8219E9C4h case   38:*/		return 0x8219E9C8;
		  /* 8219E9C8h */ case   39:  		/* lwz R10, <#[R31 + 684]> */
		/* 8219E9C8h case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000002AC) );
		/* 8219E9C8h case   39:*/		return 0x8219E9CC;
		  /* 8219E9CCh */ case   40:  		/* lwz R7, <#[R31 + 672]> */
		/* 8219E9CCh case   40:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x000002A0) );
		/* 8219E9CCh case   40:*/		return 0x8219E9D0;
		  /* 8219E9D0h */ case   41:  		/* mullw R11, R7, R11 */
		/* 8219E9D0h case   41:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8219E9D0h case   41:*/		return 0x8219E9D4;
		  /* 8219E9D4h */ case   42:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8219E9D4h case   42:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8219E9D4h case   42:*/		return 0x8219E9D8;
		  /* 8219E9D8h */ case   43:  		/* add R11, R11, R10 */
		/* 8219E9D8h case   43:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219E9D8h case   43:*/		return 0x8219E9DC;
		  /* 8219E9DCh */ case   44:  		/* ldx R10, <#[R8 + R11]> */
		/* 8219E9DCh case   44:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8219E9DCh case   44:*/		return 0x8219E9E0;
		  /* 8219E9E0h */ case   45:  		/* or R10, R3, R10 */
		/* 8219E9E0h case   45:*/		cpu::op::or<0>(regs,&regs.R10,regs.R3,regs.R10);
		/* 8219E9E0h case   45:*/		return 0x8219E9E4;
		  /* 8219E9E4h */ case   46:  		/* stdx R10, <#[R8 + R11]> */
		/* 8219E9E4h case   46:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 8219E9E4h case   46:*/		return 0x8219E9E8;
	}
	return 0x8219E9E8;
} // Block from 8219E92Ch-8219E9E8h (47 instructions)

//////////////////////////////////////////////////////
// Block at 8219E9E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E9E8);
		  /* 8219E9E8h */ case    0:  		/* rlwinm R11, R6, 0, 0, 30 */
		/* 8219E9E8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R6);
		/* 8219E9E8h case    0:*/		return 0x8219E9EC;
		  /* 8219E9ECh */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219E9ECh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219E9ECh case    1:*/		return 0x8219E9F0;
	}
	return 0x8219E9F0;
} // Block from 8219E9E8h-8219E9F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219E9F0h
// Function '?MakeInstr_V_SETE@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219E9F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219E9F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219E9F0);
		  /* 8219E9F0h */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219E9F0h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219E9F0h case    0:*/		return 0x8219E9F4;
		  /* 8219E9F4h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 8219E9F4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219EA04;  }
		/* 8219E9F4h case    1:*/		return 0x8219E9F8;
		  /* 8219E9F8h */ case    2:  		/* mr R6, R11 */
		/* 8219E9F8h case    2:*/		regs.R6 = regs.R11;
		/* 8219E9F8h case    2:*/		return 0x8219E9FC;
		  /* 8219E9FCh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8219E9FCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219E9FCh case    3:*/		return 0x8219EA00;
		  /* 8219EA00h */ case    4:  		/* bc 4, CR6_EQ, -140 */
		/* 8219EA00h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8219E974;  }
		/* 8219EA00h case    4:*/		return 0x8219EA04;
	}
	return 0x8219EA04;
} // Block from 8219E9F0h-8219EA04h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219EA04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EA04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EA04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EA04);
		  /* 8219EA04h */ case    0:  		/* rlwinm R11, R5, 0, 0, 30 */
		/* 8219EA04h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R5);
		/* 8219EA04h case    0:*/		return 0x8219EA08;
		  /* 8219EA08h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219EA08h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219EA08h case    1:*/		return 0x8219EA0C;
		  /* 8219EA0Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219EA0Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219EA0Ch case    2:*/		return 0x8219EA10;
		  /* 8219EA10h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8219EA10h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219EA20;  }
		/* 8219EA10h case    3:*/		return 0x8219EA14;
		  /* 8219EA14h */ case    4:  		/* mr R5, R11 */
		/* 8219EA14h case    4:*/		regs.R5 = regs.R11;
		/* 8219EA14h case    4:*/		return 0x8219EA18;
		  /* 8219EA18h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8219EA18h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219EA18h case    5:*/		return 0x8219EA1C;
		  /* 8219EA1Ch */ case    6:  		/* bc 4, CR6_EQ, -212 */
		/* 8219EA1Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219E948;  }
		/* 8219EA1Ch case    6:*/		return 0x8219EA20;
	}
	return 0x8219EA20;
} // Block from 8219EA04h-8219EA20h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219EA20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EA20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EA20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EA20);
		  /* 8219EA20h */ case    0:  		/* lwz R11, <#[R19 + 28]> */
		/* 8219EA20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x0000001C) );
		/* 8219EA20h case    0:*/		return 0x8219EA24;
		  /* 8219EA24h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219EA24h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219EA24h case    1:*/		return 0x8219EA28;
		  /* 8219EA28h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 8219EA28h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219EA48;  }
		/* 8219EA28h case    2:*/		return 0x8219EA2C;
		  /* 8219EA2Ch */ case    3:  		/* lwz R11, <#[R19 + 36]> */
		/* 8219EA2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000024) );
		/* 8219EA2Ch case    3:*/		return 0x8219EA30;
		  /* 8219EA30h */ case    4:  		/* addi R20, R19, 32 */
		/* 8219EA30h case    4:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R19,0x20);
		/* 8219EA30h case    4:*/		return 0x8219EA34;
		  /* 8219EA34h */ case    5:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 8219EA34h case    5:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219EA34h case    5:*/		return 0x8219EA38;
		  /* 8219EA38h */ case    6:  		/* addic R10, R10, -1 */
		/* 8219EA38h case    6:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219EA38h case    6:*/		return 0x8219EA3C;
		  /* 8219EA3Ch */ case    7:  		/* subfe R10, R10, R10 */
		/* 8219EA3Ch case    7:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8219EA3Ch case    7:*/		return 0x8219EA40;
		  /* 8219EA40h */ case    8:  		/* and R22, R10, R11 */
		/* 8219EA40h case    8:*/		cpu::op::and<0>(regs,&regs.R22,regs.R10,regs.R11);
		/* 8219EA40h case    8:*/		return 0x8219EA44;
		  /* 8219EA44h */ case    9:  		/* b 28 */
		/* 8219EA44h case    9:*/		return 0x8219EA60;
		/* 8219EA44h case    9:*/		return 0x8219EA48;
	}
	return 0x8219EA48;
} // Block from 8219EA20h-8219EA48h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219EA48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EA48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EA48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EA48);
		  /* 8219EA48h */ case    0:  		/* lwz R10, <#[R19 + 28]> */
		/* 8219EA48h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x0000001C) );
		/* 8219EA48h case    0:*/		return 0x8219EA4C;
		  /* 8219EA4Ch */ case    1:  		/* addi R20, R19, 24 */
		/* 8219EA4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R19,0x18);
		/* 8219EA4Ch case    1:*/		return 0x8219EA50;
		  /* 8219EA50h */ case    2:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 8219EA50h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 8219EA50h case    2:*/		return 0x8219EA54;
		  /* 8219EA54h */ case    3:  		/* addic R11, R9, -1 */
		/* 8219EA54h case    3:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 8219EA54h case    3:*/		return 0x8219EA58;
		  /* 8219EA58h */ case    4:  		/* subfe R11, R11, R11 */
		/* 8219EA58h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8219EA58h case    4:*/		return 0x8219EA5C;
		  /* 8219EA5Ch */ case    5:  		/* and R22, R11, R10 */
		/* 8219EA5Ch case    5:*/		cpu::op::and<0>(regs,&regs.R22,regs.R11,regs.R10);
		/* 8219EA5Ch case    5:*/		return 0x8219EA60;
	}
	return 0x8219EA60;
} // Block from 8219EA48h-8219EA60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219EA60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EA60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EA60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EA60);
		  /* 8219EA60h */ case    0:  		/* cmplwi CR6, R22, 0 */
		/* 8219EA60h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8219EA60h case    0:*/		return 0x8219EA64;
		  /* 8219EA64h */ case    1:  		/* bc 12, CR6_EQ, 564 */
		/* 8219EA64h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219EC98;  }
		/* 8219EA64h case    1:*/		return 0x8219EA68;
		  /* 8219EA68h */ case    2:  		/* lwz R11, <#[R22 + 8]> */
		/* 8219EA68h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 8219EA68h case    2:*/		return 0x8219EA6C;
		  /* 8219EA6Ch */ case    3:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 8219EA6Ch case    3:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 8219EA6Ch case    3:*/		return 0x8219EA70;
		  /* 8219EA70h */ case    4:  		/* bc 12, CR0_EQ, 484 */
		/* 8219EA70h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219EC54;  }
		/* 8219EA70h case    4:*/		return 0x8219EA74;
		  /* 8219EA74h */ case    5:  		/* lwz R11, <#[R22 + 16]> */
		/* 8219EA74h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000010) );
		/* 8219EA74h case    5:*/		return 0x8219EA78;
		  /* 8219EA78h */ case    6:  		/* rlwinm R23, R11, 0, 16, 31 */
		/* 8219EA78h case    6:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R23,regs.R11);
		/* 8219EA78h case    6:*/		return 0x8219EA7C;
		  /* 8219EA7Ch */ case    7:  		/* rlwinm R11, R11, 16, 29, 31 */
		/* 8219EA7Ch case    7:*/		cpu::op::rlwinm<0,16,29,31>(regs,&regs.R11,regs.R11);
		/* 8219EA7Ch case    7:*/		return 0x8219EA80;
		  /* 8219EA80h */ case    8:  		/* mr R30, R23 */
		/* 8219EA80h case    8:*/		regs.R30 = regs.R23;
		/* 8219EA80h case    8:*/		return 0x8219EA84;
		  /* 8219EA84h */ case    9:  		/* add R27, R23, R11 */
		/* 8219EA84h case    9:*/		cpu::op::add<0>(regs,&regs.R27,regs.R23,regs.R11);
		/* 8219EA84h case    9:*/		return 0x8219EA88;
		  /* 8219EA88h */ case   10:  		/* cmplw CR6, R23, R27 */
		/* 8219EA88h case   10:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R27);
		/* 8219EA88h case   10:*/		return 0x8219EA8C;
		  /* 8219EA8Ch */ case   11:  		/* bc 4, CR6_LT, 160 */
		/* 8219EA8Ch case   11:*/		if ( !regs.CR[6].lt ) { return 0x8219EB2C;  }
		/* 8219EA8Ch case   11:*/		return 0x8219EA90;
		  /* 8219EA90h */ case   12:  		/* mr R4, R30 */
		/* 8219EA90h case   12:*/		regs.R4 = regs.R30;
		/* 8219EA90h case   12:*/		return 0x8219EA94;
		  /* 8219EA94h */ case   13:  		/* mr R3, R31 */
		/* 8219EA94h case   13:*/		regs.R3 = regs.R31;
		/* 8219EA94h case   13:*/		return 0x8219EA98;
		  /* 8219EA98h */ case   14:  		/* bl -110904 */
		/* 8219EA98h case   14:*/		regs.LR = 0x8219EA9C; return 0x82183960;
		/* 8219EA98h case   14:*/		return 0x8219EA9C;
		  /* 8219EA9Ch */ case   15:  		/* addi R25, R30, 1 */
		/* 8219EA9Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R30,0x1);
		/* 8219EA9Ch case   15:*/		return 0x8219EAA0;
		  /* 8219EAA0h */ case   16:  		/* mr R28, R3 */
		/* 8219EAA0h case   16:*/		regs.R28 = regs.R3;
		/* 8219EAA0h case   16:*/		return 0x8219EAA4;
		  /* 8219EAA4h */ case   17:  		/* mr R30, R25 */
		/* 8219EAA4h case   17:*/		regs.R30 = regs.R25;
		/* 8219EAA4h case   17:*/		return 0x8219EAA8;
		  /* 8219EAA8h */ case   18:  		/* cmplw CR6, R25, R27 */
		/* 8219EAA8h case   18:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R27);
		/* 8219EAA8h case   18:*/		return 0x8219EAAC;
		  /* 8219EAACh */ case   19:  		/* bc 4, CR6_LT, 116 */
		/* 8219EAACh case   19:*/		if ( !regs.CR[6].lt ) { return 0x8219EB20;  }
		/* 8219EAACh case   19:*/		return 0x8219EAB0;
		  /* 8219EAB0h */ case   20:  		/* rldicl R11, R3, 0, 58 */
		/* 8219EAB0h case   20:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R11,regs.R3);
		/* 8219EAB0h case   20:*/		return 0x8219EAB4;
		  /* 8219EAB4h */ case   21:  		/* rlwinm R29, R3, 29, 3, 28 */
		/* 8219EAB4h case   21:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R29,regs.R3);
		/* 8219EAB4h case   21:*/		return 0x8219EAB8;
		  /* 8219EAB8h */ case   22:  		/* sld R26, R21, R11 */
		/* 8219EAB8h case   22:*/		cpu::op::sld<0>(regs,&regs.R26,regs.R21,regs.R11);
		/* 8219EAB8h case   22:*/		return 0x8219EABC;
		  /* 8219EABCh */ case   23:  		/* mr R4, R30 */
		/* 8219EABCh case   23:*/		regs.R4 = regs.R30;
		/* 8219EABCh case   23:*/		return 0x8219EAC0;
	}
	return 0x8219EAC0;
} // Block from 8219EA60h-8219EAC0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8219EAC0h
// Function '?MakeInstr_V_SETNE@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EAC0);
		  /* 8219EAC0h */ case    0:  		/* mr R3, R31 */
		/* 8219EAC0h case    0:*/		regs.R3 = regs.R31;
		/* 8219EAC0h case    0:*/		return 0x8219EAC4;
		  /* 8219EAC4h */ case    1:  		/* bl -110948 */
		/* 8219EAC4h case    1:*/		regs.LR = 0x8219EAC8; return 0x82183960;
		/* 8219EAC4h case    1:*/		return 0x8219EAC8;
		  /* 8219EAC8h */ case    2:  		/* lwz R11, <#[R31 + 672]> */
		/* 8219EAC8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002A0) );
		/* 8219EAC8h case    2:*/		return 0x8219EACC;
		  /* 8219EACCh */ case    3:  		/* lwz R9, <#[R31 + 684]> */
		/* 8219EACCh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000002AC) );
		/* 8219EACCh case    3:*/		return 0x8219EAD0;
		  /* 8219EAD0h */ case    4:  		/* rlwinm R10, R3, 29, 3, 28 */
		/* 8219EAD0h case    4:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R10,regs.R3);
		/* 8219EAD0h case    4:*/		return 0x8219EAD4;
		  /* 8219EAD4h */ case    5:  		/* mullw R11, R11, R28 */
		/* 8219EAD4h case    5:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8219EAD4h case    5:*/		return 0x8219EAD8;
		  /* 8219EAD8h */ case    6:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8219EAD8h case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8219EAD8h case    6:*/		return 0x8219EADC;
		  /* 8219EADCh */ case    7:  		/* addi R30, R30, 1 */
		/* 8219EADCh case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8219EADCh case    7:*/		return 0x8219EAE0;
		  /* 8219EAE0h */ case    8:  		/* add R11, R11, R9 */
		/* 8219EAE0h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8219EAE0h case    8:*/		return 0x8219EAE4;
		  /* 8219EAE4h */ case    9:  		/* rldicl R9, R3, 0, 58 */
		/* 8219EAE4h case    9:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R9,regs.R3);
		/* 8219EAE4h case    9:*/		return 0x8219EAE8;
		  /* 8219EAE8h */ case   10:  		/* cmplw CR6, R30, R27 */
		/* 8219EAE8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R27);
		/* 8219EAE8h case   10:*/		return 0x8219EAEC;
		  /* 8219EAECh */ case   11:  		/* sld R9, R21, R9 */
		/* 8219EAECh case   11:*/		cpu::op::sld<0>(regs,&regs.R9,regs.R21,regs.R9);
		/* 8219EAECh case   11:*/		return 0x8219EAF0;
		  /* 8219EAF0h */ case   12:  		/* ldx R8, <#[R10 + R11]> */
		/* 8219EAF0h case   12:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219EAF0h case   12:*/		return 0x8219EAF4;
		  /* 8219EAF4h */ case   13:  		/* or R9, R9, R8 */
		/* 8219EAF4h case   13:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8219EAF4h case   13:*/		return 0x8219EAF8;
		  /* 8219EAF8h */ case   14:  		/* stdx R9, <#[R10 + R11]> */
		/* 8219EAF8h case   14:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219EAF8h case   14:*/		return 0x8219EAFC;
		  /* 8219EAFCh */ case   15:  		/* lwz R10, <#[R31 + 684]> */
		/* 8219EAFCh case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000002AC) );
		/* 8219EAFCh case   15:*/		return 0x8219EB00;
		  /* 8219EB00h */ case   16:  		/* lwz R11, <#[R31 + 672]> */
		/* 8219EB00h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002A0) );
		/* 8219EB00h case   16:*/		return 0x8219EB04;
		  /* 8219EB04h */ case   17:  		/* mullw R11, R11, R3 */
		/* 8219EB04h case   17:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8219EB04h case   17:*/		return 0x8219EB08;
		  /* 8219EB08h */ case   18:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8219EB08h case   18:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8219EB08h case   18:*/		return 0x8219EB0C;
		  /* 8219EB0Ch */ case   19:  		/* add R11, R11, R10 */
		/* 8219EB0Ch case   19:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219EB0Ch case   19:*/		return 0x8219EB10;
		  /* 8219EB10h */ case   20:  		/* ldx R10, <#[R11 + R29]> */
		/* 8219EB10h case   20:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8219EB10h case   20:*/		return 0x8219EB14;
		  /* 8219EB14h */ case   21:  		/* or R10, R10, R26 */
		/* 8219EB14h case   21:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R26);
		/* 8219EB14h case   21:*/		return 0x8219EB18;
		  /* 8219EB18h */ case   22:  		/* stdx R10, <#[R11 + R29]> */
		/* 8219EB18h case   22:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 8219EB18h case   22:*/		return 0x8219EB1C;
		  /* 8219EB1Ch */ case   23:  		/* bc 12, CR6_LT, -96 */
		/* 8219EB1Ch case   23:*/		if ( regs.CR[6].lt ) { return 0x8219EABC;  }
		/* 8219EB1Ch case   23:*/		return 0x8219EB20;
	}
	return 0x8219EB20;
} // Block from 8219EAC0h-8219EB20h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8219EB20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EB20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EB20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EB20);
		  /* 8219EB20h */ case    0:  		/* mr R30, R25 */
		/* 8219EB20h case    0:*/		regs.R30 = regs.R25;
		/* 8219EB20h case    0:*/		return 0x8219EB24;
		  /* 8219EB24h */ case    1:  		/* cmplw CR6, R25, R27 */
		/* 8219EB24h case    1:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R27);
		/* 8219EB24h case    1:*/		return 0x8219EB28;
		  /* 8219EB28h */ case    2:  		/* bc 12, CR6_LT, -152 */
		/* 8219EB28h case    2:*/		if ( regs.CR[6].lt ) { return 0x8219EA90;  }
		/* 8219EB28h case    2:*/		return 0x8219EB2C;
	}
	return 0x8219EB2C;
} // Block from 8219EB20h-8219EB2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219EB2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EB2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EB2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EB2C);
		  /* 8219EB2Ch */ case    0:  		/* lwz R11, <#[R18 + 4]> */
		/* 8219EB2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + 0x00000004) );
		/* 8219EB2Ch case    0:*/		return 0x8219EB30;
		  /* 8219EB30h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219EB30h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219EB30h case    1:*/		return 0x8219EB34;
		  /* 8219EB34h */ case    2:  		/* bc 4, CR0_EQ, 288 */
		/* 8219EB34h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8219EC54;  }
		/* 8219EB34h case    2:*/		return 0x8219EB38;
		  /* 8219EB38h */ case    3:  		/* mr R25, R11 */
		/* 8219EB38h case    3:*/		regs.R25 = regs.R11;
		/* 8219EB38h case    3:*/		return 0x8219EB3C;
		  /* 8219EB3Ch */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 8219EB3Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8219EB3Ch case    4:*/		return 0x8219EB40;
		  /* 8219EB40h */ case    5:  		/* bc 12, CR0_EQ, 276 */
		/* 8219EB40h case    5:*/		if ( regs.CR[0].eq ) { return 0x8219EC54;  }
		/* 8219EB40h case    5:*/		return 0x8219EB44;
		  /* 8219EB44h */ case    6:  		/* lwz R11, <#[R25 + 8]> */
		/* 8219EB44h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8219EB44h case    6:*/		return 0x8219EB48;
		  /* 8219EB48h */ case    7:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219EB48h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219EB48h case    7:*/		return 0x8219EB4C;
		  /* 8219EB4Ch */ case    8:  		/* cmplwi CR6, R11, 14336 */
		/* 8219EB4Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 8219EB4Ch case    8:*/		return 0x8219EB50;
		  /* 8219EB50h */ case    9:  		/* bc 4, CR6_EQ, 232 */
		/* 8219EB50h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219EC38;  }
		/* 8219EB50h case    9:*/		return 0x8219EB54;
		  /* 8219EB54h */ case   10:  		/* cmplw CR6, R25, R22 */
		/* 8219EB54h case   10:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R22);
		/* 8219EB54h case   10:*/		return 0x8219EB58;
		  /* 8219EB58h */ case   11:  		/* bc 12, CR6_EQ, 224 */
		/* 8219EB58h case   11:*/		if ( regs.CR[6].eq ) { return 0x8219EC38;  }
		/* 8219EB58h case   11:*/		return 0x8219EB5C;
		  /* 8219EB5Ch */ case   12:  		/* lwz R24, <#[R25 + 4]> */
		/* 8219EB5Ch case   12:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R25 + 0x00000004) );
		/* 8219EB5Ch case   12:*/		return 0x8219EB60;
		  /* 8219EB60h */ case   13:  		/* cmplwi CR6, R24, 0 */
		/* 8219EB60h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8219EB60h case   13:*/		return 0x8219EB64;
		  /* 8219EB64h */ case   14:  		/* bc 12, CR6_EQ, 212 */
		/* 8219EB64h case   14:*/		if ( regs.CR[6].eq ) { return 0x8219EC38;  }
		/* 8219EB64h case   14:*/		return 0x8219EB68;
		  /* 8219EB68h */ case   15:  		/* lwz R3, <#[R24 + 16]> */
		/* 8219EB68h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000010) );
		/* 8219EB68h case   15:*/		return 0x8219EB6C;
		  /* 8219EB6Ch */ case   16:  		/* cmplwi CR6, R3, 0 */
		/* 8219EB6Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 8219EB6Ch case   16:*/		return 0x8219EB70;
		  /* 8219EB70h */ case   17:  		/* bc 12, CR6_EQ, 192 */
		/* 8219EB70h case   17:*/		if ( regs.CR[6].eq ) { return 0x8219EC30;  }
		/* 8219EB70h case   17:*/		return 0x8219EB74;
		  /* 8219EB74h */ case   18:  		/* lwz R11, <#[R3 + 28]> */
		/* 8219EB74h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 8219EB74h case   18:*/		return 0x8219EB78;
		  /* 8219EB78h */ case   19:  		/* cmplw CR6, R11, R19 */
		/* 8219EB78h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R19);
		/* 8219EB78h case   19:*/		return 0x8219EB7C;
		  /* 8219EB7Ch */ case   20:  		/* bc 4, CR6_EQ, 180 */
		/* 8219EB7Ch case   20:*/		if ( !regs.CR[6].eq ) { return 0x8219EC30;  }
		/* 8219EB7Ch case   20:*/		return 0x8219EB80;
		  /* 8219EB80h */ case   21:  		/* cmplw CR6, R3, R22 */
		/* 8219EB80h case   21:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R22);
		/* 8219EB80h case   21:*/		return 0x8219EB84;
		  /* 8219EB84h */ case   22:  		/* bc 12, CR6_EQ, 172 */
		/* 8219EB84h case   22:*/		if ( regs.CR[6].eq ) { return 0x8219EC30;  }
		/* 8219EB84h case   22:*/		return 0x8219EB88;
		  /* 8219EB88h */ case   23:  		/* mr R7, R31 */
		/* 8219EB88h case   23:*/		regs.R7 = regs.R31;
		/* 8219EB88h case   23:*/		return 0x8219EB8C;
		  /* 8219EB8Ch */ case   24:  		/* li R6, 1 */
		/* 8219EB8Ch case   24:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8219EB8Ch case   24:*/		return 0x8219EB90;
	}
	return 0x8219EB90;
} // Block from 8219EB2Ch-8219EB90h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8219EB90h
// Function '?MakeInstr_V_CNDE@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@22@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EB90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EB90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EB90);
		  /* 8219EB90h */ case    0:  		/* li R5, 0 */
		/* 8219EB90h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219EB90h case    0:*/		return 0x8219EB94;
		  /* 8219EB94h */ case    1:  		/* mr R4, R22 */
		/* 8219EB94h case    1:*/		regs.R4 = regs.R22;
		/* 8219EB94h case    1:*/		return 0x8219EB98;
		  /* 8219EB98h */ case    2:  		/* bl 577184 */
		/* 8219EB98h case    2:*/		regs.LR = 0x8219EB9C; return 0x8222BA38;
		/* 8219EB98h case    2:*/		return 0x8219EB9C;
		  /* 8219EB9Ch */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219EB9Ch case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219EB9Ch case    3:*/		return 0x8219EBA0;
		  /* 8219EBA0h */ case    4:  		/* bc 12, CR0_EQ, 144 */
		/* 8219EBA0h case    4:*/		if ( regs.CR[0].eq ) { return 0x8219EC30;  }
		/* 8219EBA0h case    4:*/		return 0x8219EBA4;
		  /* 8219EBA4h */ case    5:  		/* mr R3, R31 */
		/* 8219EBA4h case    5:*/		regs.R3 = regs.R31;
		/* 8219EBA4h case    5:*/		return 0x8219EBA8;
		  /* 8219EBA8h */ case    6:  		/* lhz R4, <#[R25 + 18]> */
		/* 8219EBA8h case    6:*/		cpu::mem::load16z( regs, &regs.R4, (uint32)(regs.R25 + 0x00000012) );
		/* 8219EBA8h case    6:*/		return 0x8219EBAC;
		  /* 8219EBACh */ case    7:  		/* bl -111180 */
		/* 8219EBACh case    7:*/		regs.LR = 0x8219EBB0; return 0x82183960;
		/* 8219EBACh case    7:*/		return 0x8219EBB0;
		  /* 8219EBB0h */ case    8:  		/* mr R28, R3 */
		/* 8219EBB0h case    8:*/		regs.R28 = regs.R3;
		/* 8219EBB0h case    8:*/		return 0x8219EBB4;
		  /* 8219EBB4h */ case    9:  		/* mr R30, R23 */
		/* 8219EBB4h case    9:*/		regs.R30 = regs.R23;
		/* 8219EBB4h case    9:*/		return 0x8219EBB8;
		  /* 8219EBB8h */ case   10:  		/* cmplw CR6, R23, R27 */
		/* 8219EBB8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R27);
		/* 8219EBB8h case   10:*/		return 0x8219EBBC;
		  /* 8219EBBCh */ case   11:  		/* bc 4, CR6_LT, 116 */
		/* 8219EBBCh case   11:*/		if ( !regs.CR[6].lt ) { return 0x8219EC30;  }
		/* 8219EBBCh case   11:*/		return 0x8219EBC0;
		  /* 8219EBC0h */ case   12:  		/* rldicl R11, R3, 0, 58 */
		/* 8219EBC0h case   12:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R11,regs.R3);
		/* 8219EBC0h case   12:*/		return 0x8219EBC4;
		  /* 8219EBC4h */ case   13:  		/* rlwinm R29, R3, 29, 3, 28 */
		/* 8219EBC4h case   13:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R29,regs.R3);
		/* 8219EBC4h case   13:*/		return 0x8219EBC8;
		  /* 8219EBC8h */ case   14:  		/* sld R26, R21, R11 */
		/* 8219EBC8h case   14:*/		cpu::op::sld<0>(regs,&regs.R26,regs.R21,regs.R11);
		/* 8219EBC8h case   14:*/		return 0x8219EBCC;
		  /* 8219EBCCh */ case   15:  		/* mr R4, R30 */
		/* 8219EBCCh case   15:*/		regs.R4 = regs.R30;
		/* 8219EBCCh case   15:*/		return 0x8219EBD0;
		  /* 8219EBD0h */ case   16:  		/* mr R3, R31 */
		/* 8219EBD0h case   16:*/		regs.R3 = regs.R31;
		/* 8219EBD0h case   16:*/		return 0x8219EBD4;
		  /* 8219EBD4h */ case   17:  		/* bl -111220 */
		/* 8219EBD4h case   17:*/		regs.LR = 0x8219EBD8; return 0x82183960;
		/* 8219EBD4h case   17:*/		return 0x8219EBD8;
		  /* 8219EBD8h */ case   18:  		/* lwz R11, <#[R31 + 672]> */
		/* 8219EBD8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002A0) );
		/* 8219EBD8h case   18:*/		return 0x8219EBDC;
		  /* 8219EBDCh */ case   19:  		/* lwz R9, <#[R31 + 684]> */
		/* 8219EBDCh case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000002AC) );
		/* 8219EBDCh case   19:*/		return 0x8219EBE0;
		  /* 8219EBE0h */ case   20:  		/* rlwinm R10, R3, 29, 3, 28 */
		/* 8219EBE0h case   20:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R10,regs.R3);
		/* 8219EBE0h case   20:*/		return 0x8219EBE4;
		  /* 8219EBE4h */ case   21:  		/* mullw R11, R11, R3 */
		/* 8219EBE4h case   21:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8219EBE4h case   21:*/		return 0x8219EBE8;
		  /* 8219EBE8h */ case   22:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8219EBE8h case   22:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8219EBE8h case   22:*/		return 0x8219EBEC;
		  /* 8219EBECh */ case   23:  		/* addi R30, R30, 1 */
		/* 8219EBECh case   23:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8219EBECh case   23:*/		return 0x8219EBF0;
		  /* 8219EBF0h */ case   24:  		/* add R11, R11, R9 */
		/* 8219EBF0h case   24:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8219EBF0h case   24:*/		return 0x8219EBF4;
		  /* 8219EBF4h */ case   25:  		/* rldicl R9, R3, 0, 58 */
		/* 8219EBF4h case   25:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R9,regs.R3);
		/* 8219EBF4h case   25:*/		return 0x8219EBF8;
		  /* 8219EBF8h */ case   26:  		/* cmplw CR6, R30, R27 */
		/* 8219EBF8h case   26:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R27);
		/* 8219EBF8h case   26:*/		return 0x8219EBFC;
		  /* 8219EBFCh */ case   27:  		/* sld R8, R21, R9 */
		/* 8219EBFCh case   27:*/		cpu::op::sld<0>(regs,&regs.R8,regs.R21,regs.R9);
		/* 8219EBFCh case   27:*/		return 0x8219EC00;
		  /* 8219EC00h */ case   28:  		/* ldx R9, <#[R29 + R11]> */
		/* 8219EC00h case   28:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8219EC00h case   28:*/		return 0x8219EC04;
		  /* 8219EC04h */ case   29:  		/* or R9, R26, R9 */
		/* 8219EC04h case   29:*/		cpu::op::or<0>(regs,&regs.R9,regs.R26,regs.R9);
		/* 8219EC04h case   29:*/		return 0x8219EC08;
		  /* 8219EC08h */ case   30:  		/* stdx R9, <#[R29 + R11]> */
		/* 8219EC08h case   30:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 8219EC08h case   30:*/		return 0x8219EC0C;
		  /* 8219EC0Ch */ case   31:  		/* lwz R11, <#[R31 + 672]> */
		/* 8219EC0Ch case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002A0) );
		/* 8219EC0Ch case   31:*/		return 0x8219EC10;
		  /* 8219EC10h */ case   32:  		/* mullw R11, R11, R28 */
		/* 8219EC10h case   32:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8219EC10h case   32:*/		return 0x8219EC14;
		  /* 8219EC14h */ case   33:  		/* lwz R9, <#[R31 + 684]> */
		/* 8219EC14h case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000002AC) );
		/* 8219EC14h case   33:*/		return 0x8219EC18;
		  /* 8219EC18h */ case   34:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 8219EC18h case   34:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 8219EC18h case   34:*/		return 0x8219EC1C;
		  /* 8219EC1Ch */ case   35:  		/* add R11, R11, R9 */
		/* 8219EC1Ch case   35:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8219EC1Ch case   35:*/		return 0x8219EC20;
		  /* 8219EC20h */ case   36:  		/* ldx R9, <#[R10 + R11]> */
		/* 8219EC20h case   36:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219EC20h case   36:*/		return 0x8219EC24;
		  /* 8219EC24h */ case   37:  		/* or R9, R8, R9 */
		/* 8219EC24h case   37:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8219EC24h case   37:*/		return 0x8219EC28;
		  /* 8219EC28h */ case   38:  		/* stdx R9, <#[R10 + R11]> */
		/* 8219EC28h case   38:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219EC28h case   38:*/		return 0x8219EC2C;
		  /* 8219EC2Ch */ case   39:  		/* bc 12, CR6_LT, -96 */
		/* 8219EC2Ch case   39:*/		if ( regs.CR[6].lt ) { return 0x8219EBCC;  }
		/* 8219EC2Ch case   39:*/		return 0x8219EC30;
	}
	return 0x8219EC30;
} // Block from 8219EB90h-8219EC30h (40 instructions)

//////////////////////////////////////////////////////
// Block at 8219EC30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EC30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EC30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EC30);
		  /* 8219EC30h */ case    0:  		/* lwz R24, <#[R24 + 8]> */
		/* 8219EC30h case    0:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R24 + 0x00000008) );
		/* 8219EC30h case    0:*/		return 0x8219EC34;
		  /* 8219EC34h */ case    1:  		/* b -212 */
		/* 8219EC34h case    1:*/		return 0x8219EB60;
		/* 8219EC34h case    1:*/		return 0x8219EC38;
	}
	return 0x8219EC38;
} // Block from 8219EC30h-8219EC38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219EC38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EC38);
		  /* 8219EC38h */ case    0:  		/* rlwinm R11, R25, 0, 0, 30 */
		/* 8219EC38h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R25);
		/* 8219EC38h case    0:*/		return 0x8219EC3C;
		  /* 8219EC3Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219EC3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219EC3Ch case    1:*/		return 0x8219EC40;
		  /* 8219EC40h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219EC40h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219EC40h case    2:*/		return 0x8219EC44;
		  /* 8219EC44h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8219EC44h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219EC54;  }
		/* 8219EC44h case    3:*/		return 0x8219EC48;
		  /* 8219EC48h */ case    4:  		/* mr R25, R11 */
		/* 8219EC48h case    4:*/		regs.R25 = regs.R11;
		/* 8219EC48h case    4:*/		return 0x8219EC4C;
		  /* 8219EC4Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8219EC4Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219EC4Ch case    5:*/		return 0x8219EC50;
		  /* 8219EC50h */ case    6:  		/* bc 4, CR6_EQ, -268 */
		/* 8219EC50h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219EB44;  }
		/* 8219EC50h case    6:*/		return 0x8219EC54;
	}
	return 0x8219EC54;
} // Block from 8219EC38h-8219EC54h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219EC54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EC54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EC54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EC54);
		  /* 8219EC54h */ case    0:  		/* rlwinm R11, R22, 0, 0, 30 */
		/* 8219EC54h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R22);
		/* 8219EC54h case    0:*/		return 0x8219EC58;
		  /* 8219EC58h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 8219EC58h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 8219EC58h case    1:*/		return 0x8219EC5C;
		  /* 8219EC5Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219EC5Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219EC5Ch case    2:*/		return 0x8219EC60;
		  /* 8219EC60h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8219EC60h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219EC70;  }
		/* 8219EC60h case    3:*/		return 0x8219EC64;
		  /* 8219EC64h */ case    4:  		/* mr R22, R11 */
		/* 8219EC64h case    4:*/		regs.R22 = regs.R11;
		/* 8219EC64h case    4:*/		return 0x8219EC68;
		  /* 8219EC68h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8219EC68h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219EC68h case    5:*/		return 0x8219EC6C;
		  /* 8219EC6Ch */ case    6:  		/* bc 4, CR6_EQ, -516 */
		/* 8219EC6Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219EA68;  }
		/* 8219EC6Ch case    6:*/		return 0x8219EC70;
	}
	return 0x8219EC70;
} // Block from 8219EC54h-8219EC70h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219EC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EC70);
		  /* 8219EC70h */ case    0:  		/* addi R11, R19, 32 */
		/* 8219EC70h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R19,0x20);
		/* 8219EC70h case    0:*/		return 0x8219EC74;
		  /* 8219EC74h */ case    1:  		/* cmplw CR6, R20, R11 */
		/* 8219EC74h case    1:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R11);
		/* 8219EC74h case    1:*/		return 0x8219EC78;
		  /* 8219EC78h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 8219EC78h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219EC98;  }
		/* 8219EC78h case    2:*/		return 0x8219EC7C;
		  /* 8219EC7Ch */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 8219EC7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8219EC7Ch case    3:*/		return 0x8219EC80;
		  /* 8219EC80h */ case    4:  		/* mr R20, R11 */
		/* 8219EC80h case    4:*/		regs.R20 = regs.R11;
		/* 8219EC80h case    4:*/		return 0x8219EC84;
		  /* 8219EC84h */ case    5:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 8219EC84h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 8219EC84h case    5:*/		return 0x8219EC88;
		  /* 8219EC88h */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 8219EC88h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8219EC98;  }
		/* 8219EC88h case    6:*/		return 0x8219EC8C;
		  /* 8219EC8Ch */ case    7:  		/* mr R22, R10 */
		/* 8219EC8Ch case    7:*/		regs.R22 = regs.R10;
		/* 8219EC8Ch case    7:*/		return 0x8219EC90;
	}
	return 0x8219EC90;
} // Block from 8219EC70h-8219EC90h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219EC90h
// Function '?MakeInstr_V_CNDGE@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@22@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EC90);
		  /* 8219EC90h */ case    0:  		/* cmplwi CR0, R10, 0 */
		/* 8219EC90h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8219EC90h case    0:*/		return 0x8219EC94;
		  /* 8219EC94h */ case    1:  		/* bc 4, CR0_EQ, -556 */
		/* 8219EC94h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219EA68;  }
		/* 8219EC94h case    1:*/		return 0x8219EC98;
	}
	return 0x8219EC98;
} // Block from 8219EC90h-8219EC98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219EC98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EC98);
		  /* 8219EC98h */ case    0:  		/* rlwinm R11, R19, 0, 0, 30 */
		/* 8219EC98h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R19);
		/* 8219EC98h case    0:*/		return 0x8219EC9C;
		  /* 8219EC9Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219EC9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219EC9Ch case    1:*/		return 0x8219ECA0;
		  /* 8219ECA0h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219ECA0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219ECA0h case    2:*/		return 0x8219ECA4;
		  /* 8219ECA4h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 8219ECA4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219ECB4;  }
		/* 8219ECA4h case    3:*/		return 0x8219ECA8;
		  /* 8219ECA8h */ case    4:  		/* mr R19, R11 */
		/* 8219ECA8h case    4:*/		regs.R19 = regs.R11;
		/* 8219ECA8h case    4:*/		return 0x8219ECAC;
		  /* 8219ECACh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 8219ECACh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219ECACh case    5:*/		return 0x8219ECB0;
		  /* 8219ECB0h */ case    6:  		/* bc 4, CR6_EQ, -1128 */
		/* 8219ECB0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219E848;  }
		/* 8219ECB0h case    6:*/		return 0x8219ECB4;
	}
	return 0x8219ECB4;
} // Block from 8219EC98h-8219ECB4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219ECB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ECB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ECB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ECB4);
		  /* 8219ECB4h */ case    0:  		/* addi R1, R1, 208 */
		/* 8219ECB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 8219ECB4h case    0:*/		return 0x8219ECB8;
		  /* 8219ECB8h */ case    1:  		/* b -1104444 */
		/* 8219ECB8h case    1:*/		return 0x8209127C;
		/* 8219ECB8h case    1:*/		return 0x8219ECBC;
		  /* 8219ECBCh */ case    2:  		/* nop */
		/* 8219ECBCh case    2:*/		cpu::op::nop();
		/* 8219ECBCh case    2:*/		return 0x8219ECC0;
	}
	return 0x8219ECC0;
} // Block from 8219ECB4h-8219ECC0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219ECC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ECC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ECC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ECC0);
		  /* 8219ECC0h */ case    0:  		/* mfspr R12, LR */
		/* 8219ECC0h case    0:*/		regs.R12 = regs.LR;
		/* 8219ECC0h case    0:*/		return 0x8219ECC4;
		  /* 8219ECC4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219ECC4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219ECC4h case    1:*/		return 0x8219ECC8;
		  /* 8219ECC8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8219ECC8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8219ECC8h case    2:*/		return 0x8219ECCC;
		  /* 8219ECCCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8219ECCCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219ECCCh case    3:*/		return 0x8219ECD0;
		  /* 8219ECD0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8219ECD0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8219ECD0h case    4:*/		return 0x8219ECD4;
		  /* 8219ECD4h */ case    5:  		/* addi R11, R3, 4 */
		/* 8219ECD4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x4);
		/* 8219ECD4h case    5:*/		return 0x8219ECD8;
		  /* 8219ECD8h */ case    6:  		/* li R10, 0 */
		/* 8219ECD8h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219ECD8h case    6:*/		return 0x8219ECDC;
		  /* 8219ECDCh */ case    7:  		/* ori R11, R11, 1 */
		/* 8219ECDCh case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219ECDCh case    7:*/		return 0x8219ECE0;
		  /* 8219ECE0h */ case    8:  		/* ori R30, R3, 1 */
		/* 8219ECE0h case    8:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R3,0x1);
		/* 8219ECE0h case    8:*/		return 0x8219ECE4;
		  /* 8219ECE4h */ case    9:  		/* stw R10, <#[R3 + 8]> */
		/* 8219ECE4h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8219ECE4h case    9:*/		return 0x8219ECE8;
		  /* 8219ECE8h */ case   10:  		/* stw R11, <#[R3]> */
		/* 8219ECE8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8219ECE8h case   10:*/		return 0x8219ECEC;
		  /* 8219ECECh */ case   11:  		/* li R4, 48 */
		/* 8219ECECh case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x30);
		/* 8219ECECh case   11:*/		return 0x8219ECF0;
		  /* 8219ECF0h */ case   12:  		/* stw R30, <#[R3 + 4]> */
		/* 8219ECF0h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 8219ECF0h case   12:*/		return 0x8219ECF4;
		  /* 8219ECF4h */ case   13:  		/* mr R31, R3 */
		/* 8219ECF4h case   13:*/		regs.R31 = regs.R3;
		/* 8219ECF4h case   13:*/		return 0x8219ECF8;
		  /* 8219ECF8h */ case   14:  		/* stw R10, <#[R3 + 12]> */
		/* 8219ECF8h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 8219ECF8h case   14:*/		return 0x8219ECFC;
		  /* 8219ECFCh */ case   15:  		/* bl -236916 */
		/* 8219ECFCh case   15:*/		regs.LR = 0x8219ED00; return 0x82164F88;
		/* 8219ECFCh case   15:*/		return 0x8219ED00;
		  /* 8219ED00h */ case   16:  		/* lwz R9, <#[R31]> */
		/* 8219ED00h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8219ED00h case   16:*/		return 0x8219ED04;
		  /* 8219ED04h */ case   17:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 8219ED04h case   17:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 8219ED04h case   17:*/		return 0x8219ED08;
		  /* 8219ED08h */ case   18:  		/* addi R10, R11, 4 */
		/* 8219ED08h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8219ED08h case   18:*/		return 0x8219ED0C;
		  /* 8219ED0Ch */ case   19:  		/* stw R9, <#[R11]> */
		/* 8219ED0Ch case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8219ED0Ch case   19:*/		return 0x8219ED10;
		  /* 8219ED10h */ case   20:  		/* lwz R9, <#[R31]> */
		/* 8219ED10h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8219ED10h case   20:*/		return 0x8219ED14;
		  /* 8219ED14h */ case   21:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 8219ED14h case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 8219ED14h case   21:*/		return 0x8219ED18;
		  /* 8219ED18h */ case   22:  		/* stw R11, <#[R9]> */
		/* 8219ED18h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8219ED18h case   22:*/		return 0x8219ED1C;
		  /* 8219ED1Ch */ case   23:  		/* stw R30, <#[R11 + 4]> */
		/* 8219ED1Ch case   23:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 8219ED1Ch case   23:*/		return 0x8219ED20;
		  /* 8219ED20h */ case   24:  		/* stw R10, <#[R31]> */
		/* 8219ED20h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8219ED20h case   24:*/		return 0x8219ED24;
		  /* 8219ED24h */ case   25:  		/* addi R1, R1, 112 */
		/* 8219ED24h case   25:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8219ED24h case   25:*/		return 0x8219ED28;
		  /* 8219ED28h */ case   26:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219ED28h case   26:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219ED28h case   26:*/		return 0x8219ED2C;
		  /* 8219ED2Ch */ case   27:  		/* mtspr LR, R12 */
		/* 8219ED2Ch case   27:*/		regs.LR = regs.R12;
		/* 8219ED2Ch case   27:*/		return 0x8219ED30;
		  /* 8219ED30h */ case   28:  		/* ld R30, <#[R1 - 24]> */
		/* 8219ED30h case   28:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8219ED30h case   28:*/		return 0x8219ED34;
		  /* 8219ED34h */ case   29:  		/* ld R31, <#[R1 - 16]> */
		/* 8219ED34h case   29:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219ED34h case   29:*/		return 0x8219ED38;
		  /* 8219ED38h */ case   30:  		/* bclr 20, CR0_LT */
		/* 8219ED38h case   30:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219ED38h case   30:*/		return 0x8219ED3C;
	}
	return 0x8219ED3C;
} // Block from 8219ECC0h-8219ED3Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 8219ED3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ED3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ED3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ED3C);
		  /* 8219ED3Ch */ case    0:  		/* nop */
		/* 8219ED3Ch case    0:*/		cpu::op::nop();
		/* 8219ED3Ch case    0:*/		return 0x8219ED40;
	}
	return 0x8219ED40;
} // Block from 8219ED3Ch-8219ED40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219ED40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ED40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ED40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ED40);
		  /* 8219ED40h */ case    0:  		/* mfspr R12, LR */
		/* 8219ED40h case    0:*/		regs.R12 = regs.LR;
		/* 8219ED40h case    0:*/		return 0x8219ED44;
		  /* 8219ED44h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219ED44h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219ED44h case    1:*/		return 0x8219ED48;
		  /* 8219ED48h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8219ED48h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8219ED48h case    2:*/		return 0x8219ED4C;
		  /* 8219ED4Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8219ED4Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219ED4Ch case    3:*/		return 0x8219ED50;
		  /* 8219ED50h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8219ED50h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8219ED50h case    4:*/		return 0x8219ED54;
		  /* 8219ED54h */ case    5:  		/* lwz R11, <#[R3 + 12]> */
		/* 8219ED54h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8219ED54h case    5:*/		return 0x8219ED58;
		  /* 8219ED58h */ case    6:  		/* mr R31, R3 */
		/* 8219ED58h case    6:*/		regs.R31 = regs.R3;
		/* 8219ED58h case    6:*/		return 0x8219ED5C;
		  /* 8219ED5Ch */ case    7:  		/* mr R30, R4 */
		/* 8219ED5Ch case    7:*/		regs.R30 = regs.R4;
		/* 8219ED5Ch case    7:*/		return 0x8219ED60;
		  /* 8219ED60h */ case    8:  		/* cmplwi CR6, R11, 10 */
		/* 8219ED60h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 8219ED60h case    8:*/		return 0x8219ED64;
		  /* 8219ED64h */ case    9:  		/* bc 4, CR6_EQ, 64 */
		/* 8219ED64h case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219EDA4;  }
		/* 8219ED64h case    9:*/		return 0x8219ED68;
		  /* 8219ED68h */ case   10:  		/* li R4, 48 */
		/* 8219ED68h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x30);
		/* 8219ED68h case   10:*/		return 0x8219ED6C;
		  /* 8219ED6Ch */ case   11:  		/* bl -237028 */
		/* 8219ED6Ch case   11:*/		regs.LR = 0x8219ED70; return 0x82164F88;
		/* 8219ED6Ch case   11:*/		return 0x8219ED70;
		  /* 8219ED70h */ case   12:  		/* lwz R9, <#[R31]> */
		/* 8219ED70h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8219ED70h case   12:*/		return 0x8219ED74;
		  /* 8219ED74h */ case   13:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 8219ED74h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 8219ED74h case   13:*/		return 0x8219ED78;
		  /* 8219ED78h */ case   14:  		/* ori R8, R31, 1 */
		/* 8219ED78h case   14:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R31,0x1);
		/* 8219ED78h case   14:*/		return 0x8219ED7C;
		  /* 8219ED7Ch */ case   15:  		/* li R7, 0 */
		/* 8219ED7Ch case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219ED7Ch case   15:*/		return 0x8219ED80;
		  /* 8219ED80h */ case   16:  		/* addi R10, R11, 4 */
		/* 8219ED80h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8219ED80h case   16:*/		return 0x8219ED84;
		  /* 8219ED84h */ case   17:  		/* stw R9, <#[R11]> */
		/* 8219ED84h case   17:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8219ED84h case   17:*/		return 0x8219ED88;
		  /* 8219ED88h */ case   18:  		/* lwz R9, <#[R31]> */
		/* 8219ED88h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8219ED88h case   18:*/		return 0x8219ED8C;
		  /* 8219ED8Ch */ case   19:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 8219ED8Ch case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 8219ED8Ch case   19:*/		return 0x8219ED90;
	}
	return 0x8219ED90;
} // Block from 8219ED40h-8219ED90h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219ED90h
// Function '?MakeInstr_V_CNDGT@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@22@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219ED90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219ED90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219ED90);
		  /* 8219ED90h */ case    0:  		/* stw R11, <#[R9]> */
		/* 8219ED90h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8219ED90h case    0:*/		return 0x8219ED94;
		  /* 8219ED94h */ case    1:  		/* stw R8, <#[R11 + 4]> */
		/* 8219ED94h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8219ED94h case    1:*/		return 0x8219ED98;
		  /* 8219ED98h */ case    2:  		/* stw R10, <#[R31]> */
		/* 8219ED98h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8219ED98h case    2:*/		return 0x8219ED9C;
		  /* 8219ED9Ch */ case    3:  		/* stw R7, <#[R31 + 12]> */
		/* 8219ED9Ch case    3:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219ED9Ch case    3:*/		return 0x8219EDA0;
		  /* 8219EDA0h */ case    4:  		/* b 36 */
		/* 8219EDA0h case    4:*/		return 0x8219EDC4;
		/* 8219EDA0h case    4:*/		return 0x8219EDA4;
	}
	return 0x8219EDA4;
} // Block from 8219ED90h-8219EDA4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219EDA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EDA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EDA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EDA4);
		  /* 8219EDA4h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8219EDA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8219EDA4h case    0:*/		return 0x8219EDA8;
		  /* 8219EDA8h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219EDA8h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219EDA8h case    1:*/		return 0x8219EDAC;
		  /* 8219EDACh */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8219EDACh case    2:*/		if ( regs.CR[0].eq ) { return 0x8219EDB8;  }
		/* 8219EDACh case    2:*/		return 0x8219EDB0;
		  /* 8219EDB0h */ case    3:  		/* li R3, 0 */
		/* 8219EDB0h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219EDB0h case    3:*/		return 0x8219EDB4;
		  /* 8219EDB4h */ case    4:  		/* b 16 */
		/* 8219EDB4h case    4:*/		return 0x8219EDC4;
		/* 8219EDB4h case    4:*/		return 0x8219EDB8;
	}
	return 0x8219EDB8;
} // Block from 8219EDA4h-8219EDB8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219EDB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EDB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EDB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EDB8);
		  /* 8219EDB8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8219EDB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219EDB8h case    0:*/		return 0x8219EDBC;
		  /* 8219EDBCh */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219EDBCh case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219EDBCh case    1:*/		return 0x8219EDC0;
		  /* 8219EDC0h */ case    2:  		/* addi R3, R11, -4 */
		/* 8219EDC0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 8219EDC0h case    2:*/		return 0x8219EDC4;
	}
	return 0x8219EDC4;
} // Block from 8219EDB8h-8219EDC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219EDC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EDC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EDC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EDC4);
		  /* 8219EDC4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 8219EDC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219EDC4h case    0:*/		return 0x8219EDC8;
		  /* 8219EDC8h */ case    1:  		/* addi R11, R11, 2 */
		/* 8219EDC8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8219EDC8h case    1:*/		return 0x8219EDCC;
		  /* 8219EDCCh */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8219EDCCh case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8219EDCCh case    2:*/		return 0x8219EDD0;
		  /* 8219EDD0h */ case    3:  		/* stwx R30, <#[R11 + R3]> */
		/* 8219EDD0h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 8219EDD0h case    3:*/		return 0x8219EDD4;
		  /* 8219EDD4h */ case    4:  		/* lwz R11, <#[R31 + 12]> */
		/* 8219EDD4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219EDD4h case    4:*/		return 0x8219EDD8;
		  /* 8219EDD8h */ case    5:  		/* addi R11, R11, 1 */
		/* 8219EDD8h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219EDD8h case    5:*/		return 0x8219EDDC;
		  /* 8219EDDCh */ case    6:  		/* stw R11, <#[R31 + 12]> */
		/* 8219EDDCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219EDDCh case    6:*/		return 0x8219EDE0;
		  /* 8219EDE0h */ case    7:  		/* addi R1, R1, 112 */
		/* 8219EDE0h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8219EDE0h case    7:*/		return 0x8219EDE4;
		  /* 8219EDE4h */ case    8:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219EDE4h case    8:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219EDE4h case    8:*/		return 0x8219EDE8;
		  /* 8219EDE8h */ case    9:  		/* mtspr LR, R12 */
		/* 8219EDE8h case    9:*/		regs.LR = regs.R12;
		/* 8219EDE8h case    9:*/		return 0x8219EDEC;
		  /* 8219EDECh */ case   10:  		/* ld R30, <#[R1 - 24]> */
		/* 8219EDECh case   10:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8219EDECh case   10:*/		return 0x8219EDF0;
		  /* 8219EDF0h */ case   11:  		/* ld R31, <#[R1 - 16]> */
		/* 8219EDF0h case   11:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219EDF0h case   11:*/		return 0x8219EDF4;
		  /* 8219EDF4h */ case   12:  		/* bclr 20, CR0_LT */
		/* 8219EDF4h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219EDF4h case   12:*/		return 0x8219EDF8;
	}
	return 0x8219EDF8;
} // Block from 8219EDC4h-8219EDF8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219EDF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EDF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EDF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EDF8);
		  /* 8219EDF8h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219EDF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219EDF8h case    0:*/		return 0x8219EDFC;
		  /* 8219EDFCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8219EDFCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219EDFCh case    1:*/		return 0x8219EE00;
		  /* 8219EE00h */ case    2:  		/* bc 4, CR6_EQ, 52 */
		/* 8219EE00h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8219EE34;  }
		/* 8219EE00h case    2:*/		return 0x8219EE04;
		  /* 8219EE04h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8219EE04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219EE04h case    3:*/		return 0x8219EE08;
		  /* 8219EE08h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219EE08h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219EE08h case    4:*/		return 0x8219EE0C;
		  /* 8219EE0Ch */ case    5:  		/* lwz R11, <#[R11]> */
		/* 8219EE0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219EE0Ch case    5:*/		return 0x8219EE10;
		  /* 8219EE10h */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219EE10h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219EE10h case    6:*/		return 0x8219EE14;
		  /* 8219EE14h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 8219EE14h case    7:*/		if ( regs.CR[0].eq ) { return 0x8219EE20;  }
		/* 8219EE14h case    7:*/		return 0x8219EE18;
		  /* 8219EE18h */ case    8:  		/* li R11, 0 */
		/* 8219EE18h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219EE18h case    8:*/		return 0x8219EE1C;
		  /* 8219EE1Ch */ case    9:  		/* b 12 */
		/* 8219EE1Ch case    9:*/		return 0x8219EE28;
		/* 8219EE1Ch case    9:*/		return 0x8219EE20;
	}
	return 0x8219EE20;
} // Block from 8219EDF8h-8219EE20h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219EE20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EE20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EE20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EE20);
		  /* 8219EE20h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219EE20h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219EE20h case    0:*/		return 0x8219EE24;
		  /* 8219EE24h */ case    1:  		/* addi R11, R11, -4 */
		/* 8219EE24h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8219EE24h case    1:*/		return 0x8219EE28;
	}
	return 0x8219EE28;
} // Block from 8219EE20h-8219EE28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219EE28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EE28);
		  /* 8219EE28h */ case    0:  		/* stw R11, <#[R3 + 4]> */
		/* 8219EE28h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219EE28h case    0:*/		return 0x8219EE2C;
		  /* 8219EE2Ch */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219EE2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219EE2Ch case    1:*/		return 0x8219EE30;
		  /* 8219EE30h */ case    2:  		/* stw R11, <#[R3 + 8]> */
		/* 8219EE30h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219EE30h case    2:*/		return 0x8219EE34;
	}
	return 0x8219EE34;
} // Block from 8219EE28h-8219EE34h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219EE34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EE34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EE34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EE34);
		  /* 8219EE34h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219EE34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219EE34h case    0:*/		return 0x8219EE38;
		  /* 8219EE38h */ case    1:  		/* lwz R10, <#[R3 + 4]> */
		/* 8219EE38h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8219EE38h case    1:*/		return 0x8219EE3C;
		  /* 8219EE3Ch */ case    2:  		/* addi R11, R11, -1 */
		/* 8219EE3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8219EE3Ch case    2:*/		return 0x8219EE40;
		  /* 8219EE40h */ case    3:  		/* addi R9, R11, 4 */
		/* 8219EE40h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 8219EE40h case    3:*/		return 0x8219EE44;
		  /* 8219EE44h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 8219EE44h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219EE44h case    4:*/		return 0x8219EE48;
		  /* 8219EE48h */ case    5:  		/* rlwinm R11, R9, 2, 0, 29 */
		/* 8219EE48h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R9);
		/* 8219EE48h case    5:*/		return 0x8219EE4C;
		  /* 8219EE4Ch */ case    6:  		/* add R3, R11, R10 */
		/* 8219EE4Ch case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8219EE4Ch case    6:*/		return 0x8219EE50;
		  /* 8219EE50h */ case    7:  		/* bclr 20, CR0_LT */
		/* 8219EE50h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219EE50h case    7:*/		return 0x8219EE54;
	}
	return 0x8219EE54;
} // Block from 8219EE34h-8219EE54h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219EE54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EE54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EE54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EE54);
		  /* 8219EE54h */ case    0:  		/* nop */
		/* 8219EE54h case    0:*/		cpu::op::nop();
		/* 8219EE54h case    0:*/		return 0x8219EE58;
		  /* 8219EE58h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219EE58h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219EE58h case    1:*/		return 0x8219EE5C;
		  /* 8219EE5Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 8219EE5Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219EE5Ch case    2:*/		return 0x8219EE60;
		  /* 8219EE60h */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 8219EE60h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219EE94;  }
		/* 8219EE60h case    3:*/		return 0x8219EE64;
		  /* 8219EE64h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 8219EE64h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219EE64h case    4:*/		return 0x8219EE68;
		  /* 8219EE68h */ case    5:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219EE68h case    5:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219EE68h case    5:*/		return 0x8219EE6C;
		  /* 8219EE6Ch */ case    6:  		/* lwz R11, <#[R11]> */
		/* 8219EE6Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219EE6Ch case    6:*/		return 0x8219EE70;
		  /* 8219EE70h */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 8219EE70h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8219EE70h case    7:*/		return 0x8219EE74;
		  /* 8219EE74h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 8219EE74h case    8:*/		if ( regs.CR[0].eq ) { return 0x8219EE80;  }
		/* 8219EE74h case    8:*/		return 0x8219EE78;
		  /* 8219EE78h */ case    9:  		/* li R11, 0 */
		/* 8219EE78h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219EE78h case    9:*/		return 0x8219EE7C;
		  /* 8219EE7Ch */ case   10:  		/* b 12 */
		/* 8219EE7Ch case   10:*/		return 0x8219EE88;
		/* 8219EE7Ch case   10:*/		return 0x8219EE80;
	}
	return 0x8219EE80;
} // Block from 8219EE54h-8219EE80h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219EE80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EE80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EE80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EE80);
		  /* 8219EE80h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219EE80h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219EE80h case    0:*/		return 0x8219EE84;
		  /* 8219EE84h */ case    1:  		/* addi R11, R11, -4 */
		/* 8219EE84h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8219EE84h case    1:*/		return 0x8219EE88;
	}
	return 0x8219EE88;
} // Block from 8219EE80h-8219EE88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219EE88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EE88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EE88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EE88);
		  /* 8219EE88h */ case    0:  		/* stw R11, <#[R3 + 4]> */
		/* 8219EE88h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219EE88h case    0:*/		return 0x8219EE8C;
		  /* 8219EE8Ch */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219EE8Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219EE8Ch case    1:*/		return 0x8219EE90;
	}
	return 0x8219EE90;
} // Block from 8219EE88h-8219EE90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219EE90h
// Function '?MakeInstr_V_DOT4@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EE90);
		  /* 8219EE90h */ case    0:  		/* stw R11, <#[R3 + 8]> */
		/* 8219EE90h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219EE90h case    0:*/		return 0x8219EE94;
	}
	return 0x8219EE94;
} // Block from 8219EE90h-8219EE94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219EE94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EE94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EE94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EE94);
		  /* 8219EE94h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219EE94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219EE94h case    0:*/		return 0x8219EE98;
		  /* 8219EE98h */ case    1:  		/* lwz R10, <#[R3 + 4]> */
		/* 8219EE98h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 8219EE98h case    1:*/		return 0x8219EE9C;
		  /* 8219EE9Ch */ case    2:  		/* addi R11, R11, -1 */
		/* 8219EE9Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8219EE9Ch case    2:*/		return 0x8219EEA0;
		  /* 8219EEA0h */ case    3:  		/* addi R9, R11, 2 */
		/* 8219EEA0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x2);
		/* 8219EEA0h case    3:*/		return 0x8219EEA4;
		  /* 8219EEA4h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 8219EEA4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219EEA4h case    4:*/		return 0x8219EEA8;
		  /* 8219EEA8h */ case    5:  		/* rlwinm R11, R9, 3, 0, 28 */
		/* 8219EEA8h case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R9);
		/* 8219EEA8h case    5:*/		return 0x8219EEAC;
		  /* 8219EEACh */ case    6:  		/* add R3, R11, R10 */
		/* 8219EEACh case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8219EEACh case    6:*/		return 0x8219EEB0;
		  /* 8219EEB0h */ case    7:  		/* bclr 20, CR0_LT */
		/* 8219EEB0h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219EEB0h case    7:*/		return 0x8219EEB4;
	}
	return 0x8219EEB4;
} // Block from 8219EE94h-8219EEB4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219EEB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EEB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EEB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EEB4);
		  /* 8219EEB4h */ case    0:  		/* nop */
		/* 8219EEB4h case    0:*/		cpu::op::nop();
		/* 8219EEB4h case    0:*/		return 0x8219EEB8;
	}
	return 0x8219EEB8;
} // Block from 8219EEB4h-8219EEB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219EEB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EEB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EEB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EEB8);
		  /* 8219EEB8h */ case    0:  		/* mfspr R12, LR */
		/* 8219EEB8h case    0:*/		regs.R12 = regs.LR;
		/* 8219EEB8h case    0:*/		return 0x8219EEBC;
		  /* 8219EEBCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219EEBCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219EEBCh case    1:*/		return 0x8219EEC0;
		  /* 8219EEC0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 8219EEC0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8219EEC0h case    2:*/		return 0x8219EEC4;
		  /* 8219EEC4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8219EEC4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219EEC4h case    3:*/		return 0x8219EEC8;
		  /* 8219EEC8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 8219EEC8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8219EEC8h case    4:*/		return 0x8219EECC;
		  /* 8219EECCh */ case    5:  		/* mr R31, R3 */
		/* 8219EECCh case    5:*/		regs.R31 = regs.R3;
		/* 8219EECCh case    5:*/		return 0x8219EED0;
		  /* 8219EED0h */ case    6:  		/* cmplwi CR6, R4, 10 */
		/* 8219EED0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000000A);
		/* 8219EED0h case    6:*/		return 0x8219EED4;
		  /* 8219EED4h */ case    7:  		/* mr R30, R4 */
		/* 8219EED4h case    7:*/		regs.R30 = regs.R4;
		/* 8219EED4h case    7:*/		return 0x8219EED8;
		  /* 8219EED8h */ case    8:  		/* bc 12, CR6_GT, 8 */
		/* 8219EED8h case    8:*/		if ( regs.CR[6].gt ) { return 0x8219EEE0;  }
		/* 8219EED8h case    8:*/		return 0x8219EEDC;
		  /* 8219EEDCh */ case    9:  		/* li R30, 10 */
		/* 8219EEDCh case    9:*/		cpu::op::li<0>(regs,&regs.R30,0xA);
		/* 8219EEDCh case    9:*/		return 0x8219EEE0;
	}
	return 0x8219EEE0;
} // Block from 8219EEB8h-8219EEE0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219EEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EEE0);
		  /* 8219EEE0h */ case    0:  		/* addi R11, R30, 2 */
		/* 8219EEE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x2);
		/* 8219EEE0h case    0:*/		return 0x8219EEE4;
		  /* 8219EEE4h */ case    1:  		/* mr R3, R31 */
		/* 8219EEE4h case    1:*/		regs.R3 = regs.R31;
		/* 8219EEE4h case    1:*/		return 0x8219EEE8;
		  /* 8219EEE8h */ case    2:  		/* rlwinm R4, R11, 3, 0, 28 */
		/* 8219EEE8h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R4,regs.R11);
		/* 8219EEE8h case    2:*/		return 0x8219EEEC;
		  /* 8219EEECh */ case    3:  		/* bl -237412 */
		/* 8219EEECh case    3:*/		regs.LR = 0x8219EEF0; return 0x82164F88;
		/* 8219EEECh case    3:*/		return 0x8219EEF0;
		  /* 8219EEF0h */ case    4:  		/* li R9, 0 */
		/* 8219EEF0h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219EEF0h case    4:*/		return 0x8219EEF4;
		  /* 8219EEF4h */ case    5:  		/* stw R30, <#[R3 + 12]> */
		/* 8219EEF4h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x0000000C) );
		/* 8219EEF4h case    5:*/		return 0x8219EEF8;
		  /* 8219EEF8h */ case    6:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 8219EEF8h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 8219EEF8h case    6:*/		return 0x8219EEFC;
		  /* 8219EEFCh */ case    7:  		/* stw R9, <#[R3 + 8]> */
		/* 8219EEFCh case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 8219EEFCh case    7:*/		return 0x8219EF00;
		  /* 8219EF00h */ case    8:  		/* ori R8, R31, 1 */
		/* 8219EF00h case    8:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R31,0x1);
		/* 8219EF00h case    8:*/		return 0x8219EF04;
		  /* 8219EF04h */ case    9:  		/* lwz R9, <#[R31]> */
		/* 8219EF04h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8219EF04h case    9:*/		return 0x8219EF08;
		  /* 8219EF08h */ case   10:  		/* addi R10, R11, 4 */
		/* 8219EF08h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 8219EF08h case   10:*/		return 0x8219EF0C;
		  /* 8219EF0Ch */ case   11:  		/* stw R9, <#[R11]> */
		/* 8219EF0Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8219EF0Ch case   11:*/		return 0x8219EF10;
		  /* 8219EF10h */ case   12:  		/* lwz R9, <#[R31]> */
		/* 8219EF10h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8219EF10h case   12:*/		return 0x8219EF14;
		  /* 8219EF14h */ case   13:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 8219EF14h case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 8219EF14h case   13:*/		return 0x8219EF18;
		  /* 8219EF18h */ case   14:  		/* stw R11, <#[R9]> */
		/* 8219EF18h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8219EF18h case   14:*/		return 0x8219EF1C;
		  /* 8219EF1Ch */ case   15:  		/* stw R8, <#[R11 + 4]> */
		/* 8219EF1Ch case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 8219EF1Ch case   15:*/		return 0x8219EF20;
		  /* 8219EF20h */ case   16:  		/* stw R10, <#[R31]> */
		/* 8219EF20h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8219EF20h case   16:*/		return 0x8219EF24;
		  /* 8219EF24h */ case   17:  		/* addi R1, R1, 112 */
		/* 8219EF24h case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8219EF24h case   17:*/		return 0x8219EF28;
		  /* 8219EF28h */ case   18:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219EF28h case   18:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219EF28h case   18:*/		return 0x8219EF2C;
		  /* 8219EF2Ch */ case   19:  		/* mtspr LR, R12 */
		/* 8219EF2Ch case   19:*/		regs.LR = regs.R12;
		/* 8219EF2Ch case   19:*/		return 0x8219EF30;
		  /* 8219EF30h */ case   20:  		/* ld R30, <#[R1 - 24]> */
		/* 8219EF30h case   20:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8219EF30h case   20:*/		return 0x8219EF34;
		  /* 8219EF34h */ case   21:  		/* ld R31, <#[R1 - 16]> */
		/* 8219EF34h case   21:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219EF34h case   21:*/		return 0x8219EF38;
		  /* 8219EF38h */ case   22:  		/* bclr 20, CR0_LT */
		/* 8219EF38h case   22:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219EF38h case   22:*/		return 0x8219EF3C;
	}
	return 0x8219EF3C;
} // Block from 8219EEE0h-8219EF3Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8219EF3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EF3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EF3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EF3C);
		  /* 8219EF3Ch */ case    0:  		/* nop */
		/* 8219EF3Ch case    0:*/		cpu::op::nop();
		/* 8219EF3Ch case    0:*/		return 0x8219EF40;
	}
	return 0x8219EF40;
} // Block from 8219EF3Ch-8219EF40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219EF40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EF40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EF40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EF40);
		  /* 8219EF40h */ case    0:  		/* mfspr R12, LR */
		/* 8219EF40h case    0:*/		regs.R12 = regs.LR;
		/* 8219EF40h case    0:*/		return 0x8219EF44;
		  /* 8219EF44h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8219EF44h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219EF44h case    1:*/		return 0x8219EF48;
		  /* 8219EF48h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8219EF48h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219EF48h case    2:*/		return 0x8219EF4C;
		  /* 8219EF4Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8219EF4Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8219EF4Ch case    3:*/		return 0x8219EF50;
		  /* 8219EF50h */ case    4:  		/* addic R11, R5, -1 */
		/* 8219EF50h case    4:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R5,0xFFFFFFFF);
		/* 8219EF50h case    4:*/		return 0x8219EF54;
		  /* 8219EF54h */ case    5:  		/* mr R3, R4 */
		/* 8219EF54h case    5:*/		regs.R3 = regs.R4;
		/* 8219EF54h case    5:*/		return 0x8219EF58;
	}
	return 0x8219EF58;
} // Block from 8219EF40h-8219EF58h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219EF58h
// Function '?MakeInstr_V_DOT3@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EF58);
		  /* 8219EF58h */ case    0:  		/* subfe R11, R11, R5 */
		/* 8219EF58h case    0:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 8219EF58h case    0:*/		return 0x8219EF5C;
		  /* 8219EF5Ch */ case    1:  		/* mr R31, R6 */
		/* 8219EF5Ch case    1:*/		regs.R31 = regs.R6;
		/* 8219EF5Ch case    1:*/		return 0x8219EF60;
		  /* 8219EF60h */ case    2:  		/* or R4, R11, R6 */
		/* 8219EF60h case    2:*/		cpu::op::or<0>(regs,&regs.R4,regs.R11,regs.R6);
		/* 8219EF60h case    2:*/		return 0x8219EF64;
		  /* 8219EF64h */ case    3:  		/* bl -548 */
		/* 8219EF64h case    3:*/		regs.LR = 0x8219EF68; return 0x8219ED40;
		/* 8219EF64h case    3:*/		return 0x8219EF68;
		  /* 8219EF68h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219EF68h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219EF68h case    4:*/		return 0x8219EF6C;
		  /* 8219EF6Ch */ case    5:  		/* oris R11, R11, 1024 */
		/* 8219EF6Ch case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 8219EF6Ch case    5:*/		return 0x8219EF70;
		  /* 8219EF70h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 8219EF70h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219EF70h case    6:*/		return 0x8219EF74;
		  /* 8219EF74h */ case    7:  		/* addi R1, R1, 96 */
		/* 8219EF74h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8219EF74h case    7:*/		return 0x8219EF78;
		  /* 8219EF78h */ case    8:  		/* lwz R12, <#[R1 - 8]> */
		/* 8219EF78h case    8:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8219EF78h case    8:*/		return 0x8219EF7C;
		  /* 8219EF7Ch */ case    9:  		/* mtspr LR, R12 */
		/* 8219EF7Ch case    9:*/		regs.LR = regs.R12;
		/* 8219EF7Ch case    9:*/		return 0x8219EF80;
		  /* 8219EF80h */ case   10:  		/* ld R31, <#[R1 - 16]> */
		/* 8219EF80h case   10:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8219EF80h case   10:*/		return 0x8219EF84;
		  /* 8219EF84h */ case   11:  		/* bclr 20, CR0_LT */
		/* 8219EF84h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219EF84h case   11:*/		return 0x8219EF88;
	}
	return 0x8219EF88;
} // Block from 8219EF58h-8219EF88h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219EF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219EF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219EF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219EF88);
		  /* 8219EF88h */ case    0:  		/* mfspr R12, LR */
		/* 8219EF88h case    0:*/		regs.R12 = regs.LR;
		/* 8219EF88h case    0:*/		return 0x8219EF8C;
		  /* 8219EF8Ch */ case    1:  		/* bl -1105212 */
		/* 8219EF8Ch case    1:*/		regs.LR = 0x8219EF90; return 0x82091250;
		/* 8219EF8Ch case    1:*/		return 0x8219EF90;
		  /* 8219EF90h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219EF90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219EF90h case    2:*/		return 0x8219EF94;
		  /* 8219EF94h */ case    3:  		/* addi R5, R1, 80 */
		/* 8219EF94h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8219EF94h case    3:*/		return 0x8219EF98;
		  /* 8219EF98h */ case    4:  		/* mr R28, R3 */
		/* 8219EF98h case    4:*/		regs.R28 = regs.R3;
		/* 8219EF98h case    4:*/		return 0x8219EF9C;
		  /* 8219EF9Ch */ case    5:  		/* lwz R3, <#[R3 + 12]> */
		/* 8219EF9Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 8219EF9Ch case    5:*/		return 0x8219EFA0;
		  /* 8219EFA0h */ case    6:  		/* mr R29, R4 */
		/* 8219EFA0h case    6:*/		regs.R29 = regs.R4;
		/* 8219EFA0h case    6:*/		return 0x8219EFA4;
		  /* 8219EFA4h */ case    7:  		/* bl 558236 */
		/* 8219EFA4h case    7:*/		regs.LR = 0x8219EFA8; return 0x82227440;
		/* 8219EFA4h case    7:*/		return 0x8219EFA8;
		  /* 8219EFA8h */ case    8:  		/* lwz R11, <#[R28]> */
		/* 8219EFA8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8219EFA8h case    8:*/		return 0x8219EFAC;
		  /* 8219EFACh */ case    9:  		/* li R30, 0 */
		/* 8219EFACh case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8219EFACh case    9:*/		return 0x8219EFB0;
		  /* 8219EFB0h */ case   10:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 8219EFB0h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 8219EFB0h case   10:*/		return 0x8219EFB4;
		  /* 8219EFB4h */ case   11:  		/* rlwinm R26, R11, 0, 27, 31 */
		/* 8219EFB4h case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R26,regs.R11);
		/* 8219EFB4h case   11:*/		return 0x8219EFB8;
		  /* 8219EFB8h */ case   12:  		/* bc 12, CR0_EQ, 128 */
		/* 8219EFB8h case   12:*/		if ( regs.CR[0].eq ) { return 0x8219F038;  }
		/* 8219EFB8h case   12:*/		return 0x8219EFBC;
		  /* 8219EFBCh */ case   13:  		/* li R31, 0 */
		/* 8219EFBCh case   13:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8219EFBCh case   13:*/		return 0x8219EFC0;
		  /* 8219EFC0h */ case   14:  		/* addi R27, R29, -8 */
		/* 8219EFC0h case   14:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R29,0xFFFFFFF8);
		/* 8219EFC0h case   14:*/		return 0x8219EFC4;
		  /* 8219EFC4h */ case   15:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 8219EFC4h case   15:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 8219EFC4h case   15:*/		return 0x8219EFC8;
		  /* 8219EFC8h */ case   16:  		/* li R10, 2 */
		/* 8219EFC8h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 8219EFC8h case   16:*/		return 0x8219EFCC;
		  /* 8219EFCCh */ case   17:  		/* srw R11, R11, R31 */
		/* 8219EFCCh case   17:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8219EFCCh case   17:*/		return 0x8219EFD0;
		  /* 8219EFD0h */ case   18:  		/* rlwinm R9, R11, 0, 30, 31 */
		/* 8219EFD0h case   18:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R11);
		/* 8219EFD0h case   18:*/		return 0x8219EFD4;
		  /* 8219EFD4h */ case   19:  		/* addi R8, R1, 80 */
		/* 8219EFD4h case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 8219EFD4h case   19:*/		return 0x8219EFD8;
		  /* 8219EFD8h */ case   20:  		/* rlwinm R11, R9, 1, 0, 30 */
		/* 8219EFD8h case   20:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R9);
		/* 8219EFD8h case   20:*/		return 0x8219EFDC;
		  /* 8219EFDCh */ case   21:  		/* rlwinm R7, R9, 30, 3, 29 */
		/* 8219EFDCh case   21:*/		cpu::op::rlwinm<0,30,3,29>(regs,&regs.R7,regs.R9);
		/* 8219EFDCh case   21:*/		return 0x8219EFE0;
		  /* 8219EFE0h */ case   22:  		/* addi R11, R11, 1 */
		/* 8219EFE0h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219EFE0h case   22:*/		return 0x8219EFE4;
		  /* 8219EFE4h */ case   23:  		/* rlwinm R6, R9, 1, 27, 30 */
		/* 8219EFE4h case   23:*/		cpu::op::rlwinm<0,1,27,30>(regs,&regs.R6,regs.R9);
		/* 8219EFE4h case   23:*/		return 0x8219EFE8;
		  /* 8219EFE8h */ case   24:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8219EFE8h case   24:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219EFE8h case   24:*/		return 0x8219EFEC;
		  /* 8219EFECh */ case   25:  		/* li R5, -1 */
		/* 8219EFECh case   25:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 8219EFECh case   25:*/		return 0x8219EFF0;
		  /* 8219EFF0h */ case   26:  		/* slw R11, R10, R11 */
		/* 8219EFF0h case   26:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219EFF0h case   26:*/		return 0x8219EFF4;
		  /* 8219EFF4h */ case   27:  		/* lwzx R10, <#[R7 + R8]> */
		/* 8219EFF4h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 8219EFF4h case   27:*/		return 0x8219EFF8;
		  /* 8219EFF8h */ case   28:  		/* addi R11, R11, -1 */
		/* 8219EFF8h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8219EFF8h case   28:*/		return 0x8219EFFC;
		  /* 8219EFFCh */ case   29:  		/* slw R8, R5, R6 */
		/* 8219EFFCh case   29:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R5,regs.R6);
		/* 8219EFFCh case   29:*/		return 0x8219F000;
		  /* 8219F000h */ case   30:  		/* and R11, R11, R10 */
		/* 8219F000h case   30:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219F000h case   30:*/		return 0x8219F004;
		  /* 8219F004h */ case   31:  		/* rlwinm R10, R9, 3, 0, 28 */
		/* 8219F004h case   31:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R9);
		/* 8219F004h case   31:*/		return 0x8219F008;
		  /* 8219F008h */ case   32:  		/* and R11, R11, R8 */
		/* 8219F008h case   32:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8219F008h case   32:*/		return 0x8219F00C;
		  /* 8219F00Ch */ case   33:  		/* mr R5, R26 */
		/* 8219F00Ch case   33:*/		regs.R5 = regs.R26;
		/* 8219F00Ch case   33:*/		return 0x8219F010;
		  /* 8219F010h */ case   34:  		/* srw R4, R11, R6 */
		/* 8219F010h case   34:*/		cpu::op::srw<0>(regs,&regs.R4,regs.R11,regs.R6);
		/* 8219F010h case   34:*/		return 0x8219F014;
		  /* 8219F014h */ case   35:  		/* lfdx FR1, <#[R10 + R29]> */
		/* 8219F014h case   35:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 8219F014h case   35:*/		return 0x8219F018;
		  /* 8219F018h */ case   36:  		/* bl 533600 */
		/* 8219F018h case   36:*/		regs.LR = 0x8219F01C; return 0x82221478;
		/* 8219F018h case   36:*/		return 0x8219F01C;
		  /* 8219F01Ch */ case   37:  		/* stfdu FR1, <#[R27 + 8]> */
		/* 8219F01Ch case   37:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R27 + 0x00000008) );
		regs.R27 = (uint32)(regs.R27 + 0x00000008);
		/* 8219F01Ch case   37:*/		return 0x8219F020;
	}
	return 0x8219F020;
} // Block from 8219EF88h-8219F020h (38 instructions)

//////////////////////////////////////////////////////
// Block at 8219F020h
// Function '?MakeInstr_V_DOT2ADD@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@22@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F020);
		  /* 8219F020h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 8219F020h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8219F020h case    0:*/		return 0x8219F024;
		  /* 8219F024h */ case    1:  		/* addi R30, R30, 1 */
		/* 8219F024h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8219F024h case    1:*/		return 0x8219F028;
		  /* 8219F028h */ case    2:  		/* rlwinm R10, R11, 7, 29, 31 */
		/* 8219F028h case    2:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R11);
		/* 8219F028h case    2:*/		return 0x8219F02C;
		  /* 8219F02Ch */ case    3:  		/* addi R31, R31, 2 */
		/* 8219F02Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x2);
		/* 8219F02Ch case    3:*/		return 0x8219F030;
		  /* 8219F030h */ case    4:  		/* cmplw CR6, R30, R10 */
		/* 8219F030h case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 8219F030h case    4:*/		return 0x8219F034;
		  /* 8219F034h */ case    5:  		/* bc 12, CR6_LT, -112 */
		/* 8219F034h case    5:*/		if ( regs.CR[6].lt ) { return 0x8219EFC4;  }
		/* 8219F034h case    5:*/		return 0x8219F038;
	}
	return 0x8219F038;
} // Block from 8219F020h-8219F038h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219F038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F038);
		  /* 8219F038h */ case    0:  		/* addi R1, R1, 144 */
		/* 8219F038h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219F038h case    0:*/		return 0x8219F03C;
		  /* 8219F03Ch */ case    1:  		/* b -1105308 */
		/* 8219F03Ch case    1:*/		return 0x820912A0;
		/* 8219F03Ch case    1:*/		return 0x8219F040;
	}
	return 0x8219F040;
} // Block from 8219F038h-8219F040h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219F040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F040);
		  /* 8219F040h */ case    0:  		/* mfspr R12, LR */
		/* 8219F040h case    0:*/		regs.R12 = regs.LR;
		/* 8219F040h case    0:*/		return 0x8219F044;
		  /* 8219F044h */ case    1:  		/* bl -1105444 */
		/* 8219F044h case    1:*/		regs.LR = 0x8219F048; return 0x82091220;
		/* 8219F044h case    1:*/		return 0x8219F048;
		  /* 8219F048h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 8219F048h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8219F048h case    2:*/		return 0x8219F04C;
		  /* 8219F04Ch */ case    3:  		/* stwu R1, <#[R1 - 256]> */
		/* 8219F04Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 8219F04Ch case    3:*/		return 0x8219F050;
		  /* 8219F050h */ case    4:  		/* mr R15, R4 */
		/* 8219F050h case    4:*/		regs.R15 = regs.R4;
		/* 8219F050h case    4:*/		return 0x8219F054;
		  /* 8219F054h */ case    5:  		/* lwz R11, <#[R5 + 8]> */
		/* 8219F054h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 8219F054h case    5:*/		return 0x8219F058;
		  /* 8219F058h */ case    6:  		/* addi R10, R5, 44 */
		/* 8219F058h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x2C);
		/* 8219F058h case    6:*/		return 0x8219F05C;
		  /* 8219F05Ch */ case    7:  		/* stw R6, <#[R1 + 300]> */
		/* 8219F05Ch case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000012C) );
		/* 8219F05Ch case    7:*/		return 0x8219F060;
		  /* 8219F060h */ case    8:  		/* mr R23, R5 */
		/* 8219F060h case    8:*/		regs.R23 = regs.R5;
		/* 8219F060h case    8:*/		return 0x8219F064;
		  /* 8219F064h */ case    9:  		/* li R26, 0 */
		/* 8219F064h case    9:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8219F064h case    9:*/		return 0x8219F068;
		  /* 8219F068h */ case   10:  		/* subf R5, R5, R15 */
		/* 8219F068h case   10:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R5,regs.R15);
		/* 8219F068h case   10:*/		return 0x8219F06C;
		  /* 8219F06Ch */ case   11:  		/* lwz R8, <#[R15 + 8]> */
		/* 8219F06Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R15 + 0x00000008) );
		/* 8219F06Ch case   11:*/		return 0x8219F070;
		  /* 8219F070h */ case   12:  		/* mr R4, R6 */
		/* 8219F070h case   12:*/		regs.R4 = regs.R6;
		/* 8219F070h case   12:*/		return 0x8219F074;
		  /* 8219F074h */ case   13:  		/* rlwinm R16, R11, 18, 29, 31 */
		/* 8219F074h case   13:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R16,regs.R11);
		/* 8219F074h case   13:*/		return 0x8219F078;
		  /* 8219F078h */ case   14:  		/* stw R5, <#[R1 + 80]> */
		/* 8219F078h case   14:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8219F078h case   14:*/		return 0x8219F07C;
		  /* 8219F07Ch */ case   15:  		/* mr R9, R26 */
		/* 8219F07Ch case   15:*/		regs.R9 = regs.R26;
		/* 8219F07Ch case   15:*/		return 0x8219F080;
		  /* 8219F080h */ case   16:  		/* mr R11, R10 */
		/* 8219F080h case   16:*/		regs.R11 = regs.R10;
		/* 8219F080h case   16:*/		return 0x8219F084;
		  /* 8219F084h */ case   17:  		/* rlwinm R17, R8, 18, 29, 31 */
		/* 8219F084h case   17:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R17,regs.R8);
		/* 8219F084h case   17:*/		return 0x8219F088;
		  /* 8219F088h */ case   18:  		/* rlwinm R6, R8, 13, 29, 31 */
		/* 8219F088h case   18:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R6,regs.R8);
		/* 8219F088h case   18:*/		return 0x8219F08C;
		  /* 8219F08Ch */ case   19:  		/* cmplw CR6, R9, R6 */
		/* 8219F08Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 8219F08Ch case   19:*/		return 0x8219F090;
		  /* 8219F090h */ case   20:  		/* bc 4, CR6_LT, 72 */
		/* 8219F090h case   20:*/		if ( !regs.CR[6].lt ) { return 0x8219F0D8;  }
		/* 8219F090h case   20:*/		return 0x8219F094;
		  /* 8219F094h */ case   21:  		/* lwzx R8, <#[R5 + R11]> */
		/* 8219F094h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 8219F094h case   21:*/		return 0x8219F098;
		  /* 8219F098h */ case   22:  		/* lwz R7, <#[R11]> */
		/* 8219F098h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 8219F098h case   22:*/		return 0x8219F09C;
		  /* 8219F09Ch */ case   23:  		/* lwz R8, <#[R8 + 12]> */
		/* 8219F09Ch case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 8219F09Ch case   23:*/		return 0x8219F0A0;
		  /* 8219F0A0h */ case   24:  		/* lwz R7, <#[R7 + 12]> */
		/* 8219F0A0h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x0000000C) );
		/* 8219F0A0h case   24:*/		return 0x8219F0A4;
		  /* 8219F0A4h */ case   25:  		/* cmplw CR6, R8, R7 */
		/* 8219F0A4h case   25:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 8219F0A4h case   25:*/		return 0x8219F0A8;
		  /* 8219F0A8h */ case   26:  		/* bc 12, CR6_EQ, 36 */
		/* 8219F0A8h case   26:*/		if ( regs.CR[6].eq ) { return 0x8219F0CC;  }
		/* 8219F0A8h case   26:*/		return 0x8219F0AC;
		  /* 8219F0ACh */ case   27:  		/* lwz R8, <#[R8 + 8]> */
		/* 8219F0ACh case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 8219F0ACh case   27:*/		return 0x8219F0B0;
		  /* 8219F0B0h */ case   28:  		/* rlwinm R8, R8, 0, 18, 24 */
		/* 8219F0B0h case   28:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R8,regs.R8);
		/* 8219F0B0h case   28:*/		return 0x8219F0B4;
		  /* 8219F0B4h */ case   29:  		/* cmplwi CR6, R8, 16000 */
		/* 8219F0B4h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00003E80);
		/* 8219F0B4h case   29:*/		return 0x8219F0B8;
		  /* 8219F0B8h */ case   30:  		/* bc 4, CR6_EQ, 1088 */
		/* 8219F0B8h case   30:*/		if ( !regs.CR[6].eq ) { return 0x8219F4F8;  }
		/* 8219F0B8h case   30:*/		return 0x8219F0BC;
		  /* 8219F0BCh */ case   31:  		/* lwz R8, <#[R7 + 8]> */
		/* 8219F0BCh case   31:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000008) );
		/* 8219F0BCh case   31:*/		return 0x8219F0C0;
		  /* 8219F0C0h */ case   32:  		/* rlwinm R8, R8, 0, 18, 24 */
		/* 8219F0C0h case   32:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R8,regs.R8);
		/* 8219F0C0h case   32:*/		return 0x8219F0C4;
		  /* 8219F0C4h */ case   33:  		/* cmplwi CR6, R8, 16000 */
		/* 8219F0C4h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00003E80);
		/* 8219F0C4h case   33:*/		return 0x8219F0C8;
		  /* 8219F0C8h */ case   34:  		/* bc 4, CR6_EQ, 1072 */
		/* 8219F0C8h case   34:*/		if ( !regs.CR[6].eq ) { return 0x8219F4F8;  }
		/* 8219F0C8h case   34:*/		return 0x8219F0CC;
	}
	return 0x8219F0CC;
} // Block from 8219F040h-8219F0CCh (35 instructions)

//////////////////////////////////////////////////////
// Block at 8219F0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F0CC);
		  /* 8219F0CCh */ case    0:  		/* addi R9, R9, 1 */
		/* 8219F0CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8219F0CCh case    0:*/		return 0x8219F0D0;
		  /* 8219F0D0h */ case    1:  		/* addi R11, R11, 4 */
		/* 8219F0D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219F0D0h case    1:*/		return 0x8219F0D4;
		  /* 8219F0D4h */ case    2:  		/* b -72 */
		/* 8219F0D4h case    2:*/		return 0x8219F08C;
		/* 8219F0D4h case    2:*/		return 0x8219F0D8;
	}
	return 0x8219F0D8;
} // Block from 8219F0CCh-8219F0D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219F0D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F0D8);
		  /* 8219F0D8h */ case    0:  		/* lwz R22, <#[R15 + 44]> */
		/* 8219F0D8h case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R15 + 0x0000002C) );
		/* 8219F0D8h case    0:*/		return 0x8219F0DC;
		  /* 8219F0DCh */ case    1:  		/* lwz R21, <#[R10]> */
		/* 8219F0DCh case    1:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R10 + 0x00000000) );
		/* 8219F0DCh case    1:*/		return 0x8219F0E0;
		  /* 8219F0E0h */ case    2:  		/* lwz R11, <#[R22]> */
		/* 8219F0E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8219F0E0h case    2:*/		return 0x8219F0E4;
		  /* 8219F0E4h */ case    3:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 8219F0E4h case    3:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 8219F0E4h case    3:*/		return 0x8219F0E8;
		  /* 8219F0E8h */ case    4:  		/* cmplw CR6, R11, R17 */
		/* 8219F0E8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 8219F0E8h case    4:*/		return 0x8219F0EC;
		  /* 8219F0ECh */ case    5:  		/* bc 4, CR6_EQ, 1036 */
		/* 8219F0ECh case    5:*/		if ( !regs.CR[6].eq ) { return 0x8219F4F8;  }
		/* 8219F0ECh case    5:*/		return 0x8219F0F0;
		  /* 8219F0F0h */ case    6:  		/* lwz R11, <#[R21]> */
		/* 8219F0F0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 8219F0F0h case    6:*/		return 0x8219F0F4;
		  /* 8219F0F4h */ case    7:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 8219F0F4h case    7:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 8219F0F4h case    7:*/		return 0x8219F0F8;
		  /* 8219F0F8h */ case    8:  		/* cmplw CR6, R11, R16 */
		/* 8219F0F8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R16);
		/* 8219F0F8h case    8:*/		return 0x8219F0FC;
		  /* 8219F0FCh */ case    9:  		/* bc 4, CR6_EQ, 1020 */
		/* 8219F0FCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219F4F8;  }
		/* 8219F0FCh case    9:*/		return 0x8219F100;
		  /* 8219F100h */ case   10:  		/* lwz R9, <#[R15 + 4]> */
		/* 8219F100h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R15 + 0x00000004) );
		/* 8219F100h case   10:*/		return 0x8219F104;
		  /* 8219F104h */ case   11:  		/* mr R19, R26 */
		/* 8219F104h case   11:*/		regs.R19 = regs.R26;
		/* 8219F104h case   11:*/		return 0x8219F108;
		  /* 8219F108h */ case   12:  		/* mr R20, R26 */
		/* 8219F108h case   12:*/		regs.R20 = regs.R26;
		/* 8219F108h case   12:*/		return 0x8219F10C;
		  /* 8219F10Ch */ case   13:  		/* li R14, 1 */
		/* 8219F10Ch case   13:*/		cpu::op::li<0>(regs,&regs.R14,0x1);
		/* 8219F10Ch case   13:*/		return 0x8219F110;
		  /* 8219F110h */ case   14:  		/* cmplwi CR6, R9, 0 */
		/* 8219F110h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 8219F110h case   14:*/		return 0x8219F114;
		  /* 8219F114h */ case   15:  		/* bc 12, CR6_EQ, 132 */
		/* 8219F114h case   15:*/		if ( regs.CR[6].eq ) { return 0x8219F198;  }
		/* 8219F114h case   15:*/		return 0x8219F118;
	}
	return 0x8219F118;
} // Block from 8219F0D8h-8219F118h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219F118h
// Function '?MakeInstr_V_MAX4@Compiler@D3DXShader@@QAAPAVInstruction@2@W4PlacementMethod@12@PAV32@PAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F118);
		  /* 8219F118h */ case    0:  		/* lwz R10, <#[R9 + 16]> */
		/* 8219F118h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000010) );
		/* 8219F118h case    0:*/		return 0x8219F11C;
		  /* 8219F11Ch */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 8219F11Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219F11Ch case    1:*/		return 0x8219F120;
		  /* 8219F120h */ case    2:  		/* bc 12, CR6_EQ, 112 */
		/* 8219F120h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219F190;  }
		/* 8219F120h case    2:*/		return 0x8219F124;
		  /* 8219F124h */ case    3:  		/* lwz R8, <#[R9]> */
		/* 8219F124h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 8219F124h case    3:*/		return 0x8219F128;
		  /* 8219F128h */ case    4:  		/* rlwinm. R11, R8, 0, 4, 6 */
		/* 8219F128h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R8);
		/* 8219F128h case    4:*/		return 0x8219F12C;
		  /* 8219F12Ch */ case    5:  		/* bc 12, CR0_EQ, 100 */
		/* 8219F12Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8219F190;  }
		/* 8219F12Ch case    5:*/		return 0x8219F130;
		  /* 8219F130h */ case    6:  		/* lwz R11, <#[R10 + 8]> */
		/* 8219F130h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8219F130h case    6:*/		return 0x8219F134;
		  /* 8219F134h */ case    7:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219F134h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219F134h case    7:*/		return 0x8219F138;
		  /* 8219F138h */ case    8:  		/* cmplwi CR6, R11, 14336 */
		/* 8219F138h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 8219F138h case    8:*/		return 0x8219F13C;
		  /* 8219F13Ch */ case    9:  		/* bc 4, CR6_EQ, 84 */
		/* 8219F13Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x8219F190;  }
		/* 8219F13Ch case    9:*/		return 0x8219F140;
		  /* 8219F140h */ case   10:  		/* lwz R11, <#[R10]> */
		/* 8219F140h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8219F140h case   10:*/		return 0x8219F144;
		  /* 8219F144h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8219F144h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219F144h case   11:*/		return 0x8219F148;
		  /* 8219F148h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 8219F148h case   12:*/		if ( regs.CR[6].eq ) { return 0x8219F15C;  }
		/* 8219F148h case   12:*/		return 0x8219F14C;
		  /* 8219F14Ch */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219F14Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219F14Ch case   13:*/		return 0x8219F150;
		  /* 8219F150h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 8219F150h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219F150h case   14:*/		return 0x8219F154;
		  /* 8219F154h */ case   15:  		/* mr R11, R14 */
		/* 8219F154h case   15:*/		regs.R11 = regs.R14;
		/* 8219F154h case   15:*/		return 0x8219F158;
		  /* 8219F158h */ case   16:  		/* bc 4, CR6_EQ, 8 */
		/* 8219F158h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8219F160;  }
		/* 8219F158h case   16:*/		return 0x8219F15C;
	}
	return 0x8219F15C;
} // Block from 8219F118h-8219F15Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219F15Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F15C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F15C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F15C);
		  /* 8219F15Ch */ case    0:  		/* mr R11, R26 */
		/* 8219F15Ch case    0:*/		regs.R11 = regs.R26;
		/* 8219F15Ch case    0:*/		return 0x8219F160;
	}
	return 0x8219F160;
} // Block from 8219F15Ch-8219F160h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219F160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F160);
		  /* 8219F160h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219F160h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219F160h case    0:*/		return 0x8219F164;
		  /* 8219F164h */ case    1:  		/* bc 4, CR0_EQ, 32 */
		/* 8219F164h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219F184;  }
		/* 8219F164h case    1:*/		return 0x8219F168;
		  /* 8219F168h */ case    2:  		/* lwz R11, <#[R10 + 28]> */
		/* 8219F168h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000001C) );
		/* 8219F168h case    2:*/		return 0x8219F16C;
		  /* 8219F16Ch */ case    3:  		/* lwz R10, <#[R15 + 28]> */
		/* 8219F16Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x0000001C) );
		/* 8219F16Ch case    3:*/		return 0x8219F170;
		  /* 8219F170h */ case    4:  		/* lwz R11, <#[R11 + 76]> */
		/* 8219F170h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 8219F170h case    4:*/		return 0x8219F174;
		  /* 8219F174h */ case    5:  		/* lwz R10, <#[R10 + 76]> */
		/* 8219F174h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000004C) );
		/* 8219F174h case    5:*/		return 0x8219F178;
		  /* 8219F178h */ case    6:  		/* xor R11, R11, R10 */
		/* 8219F178h case    6:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219F178h case    6:*/		return 0x8219F17C;
		  /* 8219F17Ch */ case    7:  		/* rlwinm. R11, R11, 0, 13, 31 */
		/* 8219F17Ch case    7:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R11,regs.R11);
		/* 8219F17Ch case    7:*/		return 0x8219F180;
		  /* 8219F180h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 8219F180h case    8:*/		if ( regs.CR[0].eq ) { return 0x8219F190;  }
		/* 8219F180h case    8:*/		return 0x8219F184;
	}
	return 0x8219F184;
} // Block from 8219F160h-8219F184h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219F184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F184);
		  /* 8219F184h */ case    0:  		/* rlwinm R11, R8, 27, 30, 31 */
		/* 8219F184h case    0:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R8);
		/* 8219F184h case    0:*/		return 0x8219F188;
		  /* 8219F188h */ case    1:  		/* slw R11, R14, R11 */
		/* 8219F188h case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R14,regs.R11);
		/* 8219F188h case    1:*/		return 0x8219F18C;
		  /* 8219F18Ch */ case    2:  		/* or R19, R11, R19 */
		/* 8219F18Ch case    2:*/		cpu::op::or<0>(regs,&regs.R19,regs.R11,regs.R19);
		/* 8219F18Ch case    2:*/		return 0x8219F190;
	}
	return 0x8219F190;
} // Block from 8219F184h-8219F190h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219F190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F190);
		  /* 8219F190h */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 8219F190h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 8219F190h case    0:*/		return 0x8219F194;
		  /* 8219F194h */ case    1:  		/* b -132 */
		/* 8219F194h case    1:*/		return 0x8219F110;
		/* 8219F194h case    1:*/		return 0x8219F198;
	}
	return 0x8219F198;
} // Block from 8219F190h-8219F198h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219F198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F198);
		  /* 8219F198h */ case    0:  		/* lwz R8, <#[R23 + 4]> */
		/* 8219F198h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000004) );
		/* 8219F198h case    0:*/		return 0x8219F19C;
		  /* 8219F19Ch */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 8219F19Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 8219F19Ch case    1:*/		return 0x8219F1A0;
		  /* 8219F1A0h */ case    2:  		/* bc 12, CR6_EQ, 132 */
		/* 8219F1A0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219F224;  }
		/* 8219F1A0h case    2:*/		return 0x8219F1A4;
		  /* 8219F1A4h */ case    3:  		/* lwz R10, <#[R8 + 16]> */
		/* 8219F1A4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000010) );
		/* 8219F1A4h case    3:*/		return 0x8219F1A8;
		  /* 8219F1A8h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 8219F1A8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219F1A8h case    4:*/		return 0x8219F1AC;
		  /* 8219F1ACh */ case    5:  		/* bc 12, CR6_EQ, 112 */
		/* 8219F1ACh case    5:*/		if ( regs.CR[6].eq ) { return 0x8219F21C;  }
		/* 8219F1ACh case    5:*/		return 0x8219F1B0;
	}
	return 0x8219F1B0;
} // Block from 8219F198h-8219F1B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219F1B0h
// Function '?BuildInterferenceFromDependencies@Compiler@D3DXShader@@AAAX_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F1B0);
		  /* 8219F1B0h */ case    0:  		/* lwz R9, <#[R8]> */
		/* 8219F1B0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 8219F1B0h case    0:*/		return 0x8219F1B4;
		  /* 8219F1B4h */ case    1:  		/* rlwinm. R11, R9, 0, 4, 6 */
		/* 8219F1B4h case    1:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R9);
		/* 8219F1B4h case    1:*/		return 0x8219F1B8;
		  /* 8219F1B8h */ case    2:  		/* bc 12, CR0_EQ, 100 */
		/* 8219F1B8h case    2:*/		if ( regs.CR[0].eq ) { return 0x8219F21C;  }
		/* 8219F1B8h case    2:*/		return 0x8219F1BC;
		  /* 8219F1BCh */ case    3:  		/* lwz R11, <#[R10 + 8]> */
		/* 8219F1BCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8219F1BCh case    3:*/		return 0x8219F1C0;
		  /* 8219F1C0h */ case    4:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219F1C0h case    4:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219F1C0h case    4:*/		return 0x8219F1C4;
		  /* 8219F1C4h */ case    5:  		/* cmplwi CR6, R11, 14336 */
		/* 8219F1C4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 8219F1C4h case    5:*/		return 0x8219F1C8;
		  /* 8219F1C8h */ case    6:  		/* bc 4, CR6_EQ, 84 */
		/* 8219F1C8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219F21C;  }
		/* 8219F1C8h case    6:*/		return 0x8219F1CC;
		  /* 8219F1CCh */ case    7:  		/* lwz R11, <#[R10]> */
		/* 8219F1CCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8219F1CCh case    7:*/		return 0x8219F1D0;
		  /* 8219F1D0h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8219F1D0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219F1D0h case    8:*/		return 0x8219F1D4;
		  /* 8219F1D4h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 8219F1D4h case    9:*/		if ( regs.CR[6].eq ) { return 0x8219F1E8;  }
		/* 8219F1D4h case    9:*/		return 0x8219F1D8;
		  /* 8219F1D8h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 8219F1D8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8219F1D8h case   10:*/		return 0x8219F1DC;
		  /* 8219F1DCh */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8219F1DCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219F1DCh case   11:*/		return 0x8219F1E0;
		  /* 8219F1E0h */ case   12:  		/* mr R11, R14 */
		/* 8219F1E0h case   12:*/		regs.R11 = regs.R14;
		/* 8219F1E0h case   12:*/		return 0x8219F1E4;
		  /* 8219F1E4h */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 8219F1E4h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8219F1EC;  }
		/* 8219F1E4h case   13:*/		return 0x8219F1E8;
	}
	return 0x8219F1E8;
} // Block from 8219F1B0h-8219F1E8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8219F1E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F1E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F1E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F1E8);
		  /* 8219F1E8h */ case    0:  		/* mr R11, R26 */
		/* 8219F1E8h case    0:*/		regs.R11 = regs.R26;
		/* 8219F1E8h case    0:*/		return 0x8219F1EC;
	}
	return 0x8219F1EC;
} // Block from 8219F1E8h-8219F1ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219F1ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F1EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F1EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F1EC);
		  /* 8219F1ECh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219F1ECh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219F1ECh case    0:*/		return 0x8219F1F0;
		  /* 8219F1F0h */ case    1:  		/* bc 4, CR0_EQ, 32 */
		/* 8219F1F0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8219F210;  }
		/* 8219F1F0h case    1:*/		return 0x8219F1F4;
		  /* 8219F1F4h */ case    2:  		/* lwz R11, <#[R10 + 28]> */
		/* 8219F1F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000001C) );
		/* 8219F1F4h case    2:*/		return 0x8219F1F8;
		  /* 8219F1F8h */ case    3:  		/* lwz R10, <#[R23 + 28]> */
		/* 8219F1F8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x0000001C) );
		/* 8219F1F8h case    3:*/		return 0x8219F1FC;
		  /* 8219F1FCh */ case    4:  		/* lwz R11, <#[R11 + 76]> */
		/* 8219F1FCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 8219F1FCh case    4:*/		return 0x8219F200;
		  /* 8219F200h */ case    5:  		/* lwz R10, <#[R10 + 76]> */
		/* 8219F200h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000004C) );
		/* 8219F200h case    5:*/		return 0x8219F204;
		  /* 8219F204h */ case    6:  		/* xor R11, R11, R10 */
		/* 8219F204h case    6:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219F204h case    6:*/		return 0x8219F208;
		  /* 8219F208h */ case    7:  		/* rlwinm. R11, R11, 0, 13, 31 */
		/* 8219F208h case    7:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R11,regs.R11);
		/* 8219F208h case    7:*/		return 0x8219F20C;
		  /* 8219F20Ch */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 8219F20Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x8219F21C;  }
		/* 8219F20Ch case    8:*/		return 0x8219F210;
	}
	return 0x8219F210;
} // Block from 8219F1ECh-8219F210h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219F210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F210);
		  /* 8219F210h */ case    0:  		/* rlwinm R11, R9, 27, 30, 31 */
		/* 8219F210h case    0:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R9);
		/* 8219F210h case    0:*/		return 0x8219F214;
		  /* 8219F214h */ case    1:  		/* slw R11, R14, R11 */
		/* 8219F214h case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R14,regs.R11);
		/* 8219F214h case    1:*/		return 0x8219F218;
		  /* 8219F218h */ case    2:  		/* or R20, R11, R20 */
		/* 8219F218h case    2:*/		cpu::op::or<0>(regs,&regs.R20,regs.R11,regs.R20);
		/* 8219F218h case    2:*/		return 0x8219F21C;
	}
	return 0x8219F21C;
} // Block from 8219F210h-8219F21Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219F21Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F21C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F21C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F21C);
		  /* 8219F21Ch */ case    0:  		/* lwz R8, <#[R8 + 8]> */
		/* 8219F21Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 8219F21Ch case    0:*/		return 0x8219F220;
		  /* 8219F220h */ case    1:  		/* b -132 */
		/* 8219F220h case    1:*/		return 0x8219F19C;
		/* 8219F220h case    1:*/		return 0x8219F224;
	}
	return 0x8219F224;
} // Block from 8219F21Ch-8219F224h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219F224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F224);
		  /* 8219F224h */ case    0:  		/* addi R11, R1, 88 */
		/* 8219F224h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x58);
		/* 8219F224h case    0:*/		return 0x8219F228;
		  /* 8219F228h */ case    1:  		/* mr R18, R26 */
		/* 8219F228h case    1:*/		regs.R18 = regs.R26;
		/* 8219F228h case    1:*/		return 0x8219F22C;
		  /* 8219F22Ch */ case    2:  		/* mr R25, R26 */
		/* 8219F22Ch case    2:*/		regs.R25 = regs.R26;
		/* 8219F22Ch case    2:*/		return 0x8219F230;
		  /* 8219F230h */ case    3:  		/* cmplwi CR6, R17, 0 */
		/* 8219F230h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 8219F230h case    3:*/		return 0x8219F234;
		  /* 8219F234h */ case    4:  		/* std R26, <#[R11]> */
		/* 8219F234h case    4:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 8219F234h case    4:*/		return 0x8219F238;
		  /* 8219F238h */ case    5:  		/* bc 12, CR6_EQ, 284 */
		/* 8219F238h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219F354;  }
		/* 8219F238h case    5:*/		return 0x8219F23C;
		  /* 8219F23Ch */ case    6:  		/* mr R24, R26 */
		/* 8219F23Ch case    6:*/		regs.R24 = regs.R26;
		/* 8219F23Ch case    6:*/		return 0x8219F240;
		  /* 8219F240h */ case    7:  		/* slw R11, R14, R25 */
		/* 8219F240h case    7:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R14,regs.R25);
		/* 8219F240h case    7:*/		return 0x8219F244;
		  /* 8219F244h */ case    8:  		/* and. R11, R11, R19 */
		/* 8219F244h case    8:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R19);
		/* 8219F244h case    8:*/		return 0x8219F248;
		  /* 8219F248h */ case    9:  		/* bc 4, CR0_EQ, 248 */
		/* 8219F248h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8219F340;  }
		/* 8219F248h case    9:*/		return 0x8219F24C;
		  /* 8219F24Ch */ case   10:  		/* lwz R11, <#[R22]> */
		/* 8219F24Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8219F24Ch case   10:*/		return 0x8219F250;
		  /* 8219F250h */ case   11:  		/* li R30, 0 */
		/* 8219F250h case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8219F250h case   11:*/		return 0x8219F254;
		  /* 8219F254h */ case   12:  		/* cmplw CR6, R15, R23 */
		/* 8219F254h case   12:*/		cpu::op::cmplw<6>(regs,regs.R15,regs.R23);
		/* 8219F254h case   12:*/		return 0x8219F258;
		  /* 8219F258h */ case   13:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 8219F258h case   13:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 8219F258h case   13:*/		return 0x8219F25C;
		  /* 8219F25Ch */ case   14:  		/* srw R11, R11, R26 */
		/* 8219F25Ch case   14:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R26);
		/* 8219F25Ch case   14:*/		return 0x8219F260;
		  /* 8219F260h */ case   15:  		/* rlwinm R27, R11, 0, 30, 31 */
		/* 8219F260h case   15:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R27,regs.R11);
		/* 8219F260h case   15:*/		return 0x8219F264;
		  /* 8219F264h */ case   16:  		/* bc 4, CR6_EQ, 8 */
		/* 8219F264h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8219F26C;  }
		/* 8219F264h case   16:*/		return 0x8219F268;
		  /* 8219F268h */ case   17:  		/* addi R30, R25, 1 */
		/* 8219F268h case   17:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R25,0x1);
		/* 8219F268h case   17:*/		return 0x8219F26C;
	}
	return 0x8219F26C;
} // Block from 8219F224h-8219F26Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219F26Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F26C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F26C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F26C);
		  /* 8219F26Ch */ case    0:  		/* cmplw CR6, R30, R16 */
		/* 8219F26Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R16);
		/* 8219F26Ch case    0:*/		return 0x8219F270;
		  /* 8219F270h */ case    1:  		/* bc 4, CR6_LT, 208 */
		/* 8219F270h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8219F340;  }
		/* 8219F270h case    1:*/		return 0x8219F274;
		  /* 8219F274h */ case    2:  		/* rlwinm R29, R18, 2, 0, 29 */
		/* 8219F274h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R18);
		/* 8219F274h case    2:*/		return 0x8219F278;
		  /* 8219F278h */ case    3:  		/* rlwinm R28, R30, 1, 0, 30 */
		/* 8219F278h case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R28,regs.R30);
		/* 8219F278h case    3:*/		return 0x8219F27C;
		  /* 8219F27Ch */ case    4:  		/* slw R11, R14, R30 */
		/* 8219F27Ch case    4:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R14,regs.R30);
		/* 8219F27Ch case    4:*/		return 0x8219F280;
		  /* 8219F280h */ case    5:  		/* and. R11, R11, R20 */
		/* 8219F280h case    5:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R20);
		/* 8219F280h case    5:*/		return 0x8219F284;
		  /* 8219F284h */ case    6:  		/* bc 4, CR0_EQ, 172 */
		/* 8219F284h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8219F330;  }
		/* 8219F284h case    6:*/		return 0x8219F288;
		  /* 8219F288h */ case    7:  		/* lwz R11, <#[R21]> */
		/* 8219F288h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 8219F288h case    7:*/		return 0x8219F28C;
		  /* 8219F28Ch */ case    8:  		/* lwz R3, <#[R22 + 12]> */
		/* 8219F28Ch case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x0000000C) );
		/* 8219F28Ch case    8:*/		return 0x8219F290;
		  /* 8219F290h */ case    9:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 8219F290h case    9:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 8219F290h case    9:*/		return 0x8219F294;
		  /* 8219F294h */ case   10:  		/* srw R11, R11, R28 */
		/* 8219F294h case   10:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 8219F294h case   10:*/		return 0x8219F298;
		  /* 8219F298h */ case   11:  		/* rlwinm R31, R11, 0, 30, 31 */
		/* 8219F298h case   11:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R31,regs.R11);
		/* 8219F298h case   11:*/		return 0x8219F29C;
		  /* 8219F29Ch */ case   12:  		/* lwz R11, <#[R3 + 8]> */
		/* 8219F29Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219F29Ch case   12:*/		return 0x8219F2A0;
		  /* 8219F2A0h */ case   13:  		/* subf R10, R27, R31 */
		/* 8219F2A0h case   13:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R27,regs.R31);
		/* 8219F2A0h case   13:*/		return 0x8219F2A4;
		  /* 8219F2A4h */ case   14:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219F2A4h case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219F2A4h case   14:*/		return 0x8219F2A8;
		  /* 8219F2A8h */ case   15:  		/* cntlzw R10, R10 */
		/* 8219F2A8h case   15:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8219F2A8h case   15:*/		return 0x8219F2AC;
		  /* 8219F2ACh */ case   16:  		/* cmplwi CR6, R11, 16000 */
		/* 8219F2ACh case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8219F2ACh case   16:*/		return 0x8219F2B0;
		  /* 8219F2B0h */ case   17:  		/* rlwinm R11, R10, 27, 31, 31 */
		/* 8219F2B0h case   17:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R10);
		/* 8219F2B0h case   17:*/		return 0x8219F2B4;
		  /* 8219F2B4h */ case   18:  		/* bc 4, CR6_EQ, 72 */
		/* 8219F2B4h case   18:*/		if ( !regs.CR[6].eq ) { return 0x8219F2FC;  }
		/* 8219F2B4h case   18:*/		return 0x8219F2B8;
		  /* 8219F2B8h */ case   19:  		/* lwz R11, <#[R22]> */
		/* 8219F2B8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8219F2B8h case   19:*/		return 0x8219F2BC;
		  /* 8219F2BCh */ case   20:  		/* mr R4, R27 */
		/* 8219F2BCh case   20:*/		regs.R4 = regs.R27;
		/* 8219F2BCh case   20:*/		return 0x8219F2C0;
		  /* 8219F2C0h */ case   21:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 8219F2C0h case   21:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 8219F2C0h case   21:*/		return 0x8219F2C4;
		  /* 8219F2C4h */ case   22:  		/* bl 533444 */
		/* 8219F2C4h case   22:*/		regs.LR = 0x8219F2C8; return 0x82221688;
		/* 8219F2C4h case   22:*/		return 0x8219F2C8;
		  /* 8219F2C8h */ case   23:  		/* lwz R11, <#[R21]> */
		/* 8219F2C8h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 8219F2C8h case   23:*/		return 0x8219F2CC;
		  /* 8219F2CCh */ case   24:  		/* mr R4, R31 */
		/* 8219F2CCh case   24:*/		regs.R4 = regs.R31;
		/* 8219F2CCh case   24:*/		return 0x8219F2D0;
		  /* 8219F2D0h */ case   25:  		/* lwz R3, <#[R21 + 12]> */
		/* 8219F2D0h case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x0000000C) );
		/* 8219F2D0h case   25:*/		return 0x8219F2D4;
		  /* 8219F2D4h */ case   26:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 8219F2D4h case   26:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 8219F2D4h case   26:*/		return 0x8219F2D8;
		  /* 8219F2D8h */ case   27:  		/* fmr FR31, FR1 */
		/* 8219F2D8h case   27:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 8219F2D8h case   27:*/		return 0x8219F2DC;
		  /* 8219F2DCh */ case   28:  		/* bl 533420 */
		/* 8219F2DCh case   28:*/		regs.LR = 0x8219F2E0; return 0x82221688;
		/* 8219F2DCh case   28:*/		return 0x8219F2E0;
		  /* 8219F2E0h */ case   29:  		/* fcmpu CR6, FR31, FR1 */
		/* 8219F2E0h case   29:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR1);
		/* 8219F2E0h case   29:*/		return 0x8219F2E4;
		  /* 8219F2E4h */ case   30:  		/* mr R11, R14 */
		/* 8219F2E4h case   30:*/		regs.R11 = regs.R14;
		/* 8219F2E4h case   30:*/		return 0x8219F2E8;
		  /* 8219F2E8h */ case   31:  		/* bc 12, CR6_EQ, 8 */
		/* 8219F2E8h case   31:*/		if ( regs.CR[6].eq ) { return 0x8219F2F0;  }
		/* 8219F2E8h case   31:*/		return 0x8219F2EC;
		  /* 8219F2ECh */ case   32:  		/* li R11, 0 */
		/* 8219F2ECh case   32:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219F2ECh case   32:*/		return 0x8219F2F0;
	}
	return 0x8219F2F0;
} // Block from 8219F26Ch-8219F2F0h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8219F2F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F2F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F2F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F2F0);
		  /* 8219F2F0h */ case    0:  		/* lwz R5, <#[R1 + 80]> */
		/* 8219F2F0h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8219F2F0h case    0:*/		return 0x8219F2F4;
		  /* 8219F2F4h */ case    1:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8219F2F4h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219F2F4h case    1:*/		return 0x8219F2F8;
		  /* 8219F2F8h */ case    2:  		/* lwz R4, <#[R1 + 300]> */
		/* 8219F2F8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000012C) );
		/* 8219F2F8h case    2:*/		return 0x8219F2FC;
	}
	return 0x8219F2FC;
} // Block from 8219F2F0h-8219F2FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219F2FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F2FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F2FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F2FC);
		  /* 8219F2FCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219F2FCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219F2FCh case    0:*/		return 0x8219F300;
		  /* 8219F300h */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 8219F300h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219F330;  }
		/* 8219F300h case    1:*/		return 0x8219F304;
		  /* 8219F304h */ case    2:  		/* rlwinm R10, R29, 29, 3, 28 */
		/* 8219F304h case    2:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R10,regs.R29);
		/* 8219F304h case    2:*/		return 0x8219F308;
		  /* 8219F308h */ case    3:  		/* addi R11, R1, 88 */
		/* 8219F308h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x58);
		/* 8219F308h case    3:*/		return 0x8219F30C;
		  /* 8219F30Ch */ case    4:  		/* add R9, R24, R30 */
		/* 8219F30Ch case    4:*/		cpu::op::add<0>(regs,&regs.R9,regs.R24,regs.R30);
		/* 8219F30Ch case    4:*/		return 0x8219F310;
		  /* 8219F310h */ case    5:  		/* rldicl R8, R29, 0, 58 */
		/* 8219F310h case    5:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R8,regs.R29);
		/* 8219F310h case    5:*/		return 0x8219F314;
		  /* 8219F314h */ case    6:  		/* rldicl R9, R9, 0, 32 */
		/* 8219F314h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R9);
		/* 8219F314h case    6:*/		return 0x8219F318;
		  /* 8219F318h */ case    7:  		/* addi R18, R18, 1 */
		/* 8219F318h case    7:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x1);
		/* 8219F318h case    7:*/		return 0x8219F31C;
		  /* 8219F31Ch */ case    8:  		/* ldx R7, <#[R10 + R11]> */
		/* 8219F31Ch case    8:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219F31Ch case    8:*/		return 0x8219F320;
		  /* 8219F320h */ case    9:  		/* sld R9, R9, R8 */
		/* 8219F320h case    9:*/		cpu::op::sld<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8219F320h case    9:*/		return 0x8219F324;
		  /* 8219F324h */ case   10:  		/* or R9, R9, R7 */
		/* 8219F324h case   10:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8219F324h case   10:*/		return 0x8219F328;
		  /* 8219F328h */ case   11:  		/* addi R29, R29, 4 */
		/* 8219F328h case   11:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8219F328h case   11:*/		return 0x8219F32C;
		  /* 8219F32Ch */ case   12:  		/* stdx R9, <#[R10 + R11]> */
		/* 8219F32Ch case   12:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8219F32Ch case   12:*/		return 0x8219F330;
	}
	return 0x8219F330;
} // Block from 8219F2FCh-8219F330h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8219F330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F330);
		  /* 8219F330h */ case    0:  		/* addi R30, R30, 1 */
		/* 8219F330h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8219F330h case    0:*/		return 0x8219F334;
		  /* 8219F334h */ case    1:  		/* addi R28, R28, 2 */
		/* 8219F334h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x2);
		/* 8219F334h case    1:*/		return 0x8219F338;
		  /* 8219F338h */ case    2:  		/* cmplw CR6, R30, R16 */
		/* 8219F338h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R16);
		/* 8219F338h case    2:*/		return 0x8219F33C;
		  /* 8219F33Ch */ case    3:  		/* bc 12, CR6_LT, -192 */
		/* 8219F33Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x8219F27C;  }
		/* 8219F33Ch case    3:*/		return 0x8219F340;
	}
	return 0x8219F340;
} // Block from 8219F330h-8219F340h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219F340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F340);
		  /* 8219F340h */ case    0:  		/* addi R25, R25, 1 */
		/* 8219F340h case    0:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 8219F340h case    0:*/		return 0x8219F344;
		  /* 8219F344h */ case    1:  		/* addi R26, R26, 2 */
		/* 8219F344h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x2);
		/* 8219F344h case    1:*/		return 0x8219F348;
		  /* 8219F348h */ case    2:  		/* addi R24, R24, 4 */
		/* 8219F348h case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 8219F348h case    2:*/		return 0x8219F34C;
		  /* 8219F34Ch */ case    3:  		/* cmplw CR6, R25, R17 */
		/* 8219F34Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R17);
		/* 8219F34Ch case    3:*/		return 0x8219F350;
		  /* 8219F350h */ case    4:  		/* bc 12, CR6_LT, -272 */
		/* 8219F350h case    4:*/		if ( regs.CR[6].lt ) { return 0x8219F240;  }
		/* 8219F350h case    4:*/		return 0x8219F354;
	}
	return 0x8219F354;
} // Block from 8219F340h-8219F354h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219F354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F354);
		  /* 8219F354h */ case    0:  		/* lwz R11, <#[R15 + 8]> */
		/* 8219F354h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 8219F354h case    0:*/		return 0x8219F358;
		  /* 8219F358h */ case    1:  		/* lis R10, 8 */
		/* 8219F358h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x8);
		/* 8219F358h case    1:*/		return 0x8219F35C;
		  /* 8219F35Ch */ case    2:  		/* mr R17, R14 */
		/* 8219F35Ch case    2:*/		regs.R17 = regs.R14;
		/* 8219F35Ch case    2:*/		return 0x8219F360;
		  /* 8219F360h */ case    3:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 8219F360h case    3:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 8219F360h case    3:*/		return 0x8219F364;
		  /* 8219F364h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 8219F364h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8219F364h case    4:*/		return 0x8219F368;
		  /* 8219F368h */ case    5:  		/* bc 4, CR6_GT, 364 */
		/* 8219F368h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8219F4D4;  }
		/* 8219F368h case    5:*/		return 0x8219F36C;
		  /* 8219F36Ch */ case    6:  		/* addi R20, R23, 48 */
		/* 8219F36Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R23,0x30);
		/* 8219F36Ch case    6:*/		return 0x8219F370;
		  /* 8219F370h */ case    7:  		/* li R21, 2 */
		/* 8219F370h case    7:*/		cpu::op::li<0>(regs,&regs.R21,0x2);
		/* 8219F370h case    7:*/		return 0x8219F374;
		  /* 8219F374h */ case    8:  		/* li R22, -1 */
		/* 8219F374h case    8:*/		cpu::op::li<0>(regs,&regs.R22,0xFFFFFFFF);
		/* 8219F374h case    8:*/		return 0x8219F378;
		  /* 8219F378h */ case    9:  		/* lwzx R24, <#[R20 + R5]> */
		/* 8219F378h case    9:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R20 + regs.R5 + 0x00000000) );
		/* 8219F378h case    9:*/		return 0x8219F37C;
		  /* 8219F37Ch */ case   10:  		/* li R19, 0 */
		/* 8219F37Ch case   10:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8219F37Ch case   10:*/		return 0x8219F380;
		  /* 8219F380h */ case   11:  		/* lwz R23, <#[R20]> */
		/* 8219F380h case   11:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R20 + 0x00000000) );
		/* 8219F380h case   11:*/		return 0x8219F384;
		  /* 8219F384h */ case   12:  		/* cmplwi CR6, R18, 0 */
		/* 8219F384h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 8219F384h case   12:*/		return 0x8219F388;
		  /* 8219F388h */ case   13:  		/* bc 12, CR6_EQ, 308 */
		/* 8219F388h case   13:*/		if ( regs.CR[6].eq ) { return 0x8219F4BC;  }
		/* 8219F388h case   13:*/		return 0x8219F38C;
		  /* 8219F38Ch */ case   14:  		/* rlwinm R11, R18, 2, 0, 29 */
		/* 8219F38Ch case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R18);
		/* 8219F38Ch case   14:*/		return 0x8219F390;
		  /* 8219F390h */ case   15:  		/* li R27, 0 */
		/* 8219F390h case   15:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8219F390h case   15:*/		return 0x8219F394;
		  /* 8219F394h */ case   16:  		/* addi R25, R11, -4 */
		/* 8219F394h case   16:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0xFFFFFFFC);
		/* 8219F394h case   16:*/		return 0x8219F398;
		  /* 8219F398h */ case   17:  		/* addi R10, R27, 3 */
		/* 8219F398h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x3);
		/* 8219F398h case   17:*/		return 0x8219F39C;
		  /* 8219F39Ch */ case   18:  		/* lwz R11, <#[R24]> */
		/* 8219F39Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 8219F39Ch case   18:*/		return 0x8219F3A0;
		  /* 8219F3A0h */ case   19:  		/* rldicl R31, R27, 0, 58 */
		/* 8219F3A0h case   19:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R31,regs.R27);
		/* 8219F3A0h case   19:*/		return 0x8219F3A4;
		  /* 8219F3A4h */ case   20:  		/* lwz R9, <#[R23]> */
		/* 8219F3A4h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000000) );
		/* 8219F3A4h case   20:*/		return 0x8219F3A8;
		  /* 8219F3A8h */ case   21:  		/* rldicl R10, R10, 0, 58 */
		/* 8219F3A8h case   21:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R10,regs.R10);
		/* 8219F3A8h case   21:*/		return 0x8219F3AC;
		  /* 8219F3ACh */ case   22:  		/* lwz R3, <#[R24 + 12]> */
		/* 8219F3ACh case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x0000000C) );
		/* 8219F3ACh case   22:*/		return 0x8219F3B0;
		  /* 8219F3B0h */ case   23:  		/* rlwinm R29, R27, 29, 3, 28 */
		/* 8219F3B0h case   23:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R29,regs.R27);
		/* 8219F3B0h case   23:*/		return 0x8219F3B4;
		  /* 8219F3B4h */ case   24:  		/* sld R10, R21, R10 */
		/* 8219F3B4h case   24:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R21,regs.R10);
		/* 8219F3B4h case   24:*/		return 0x8219F3B8;
		  /* 8219F3B8h */ case   25:  		/* addi R30, R1, 88 */
		/* 8219F3B8h case   25:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x58);
		/* 8219F3B8h case   25:*/		return 0x8219F3BC;
		  /* 8219F3BCh */ case   26:  		/* lwz R8, <#[R3 + 8]> */
		/* 8219F3BCh case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 8219F3BCh case   26:*/		return 0x8219F3C0;
		  /* 8219F3C0h */ case   27:  		/* addi R10, R10, -1 */
		/* 8219F3C0h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8219F3C0h case   27:*/		return 0x8219F3C4;
		  /* 8219F3C4h */ case   28:  		/* sld R7, R22, R31 */
		/* 8219F3C4h case   28:*/		cpu::op::sld<0>(regs,&regs.R7,regs.R22,regs.R31);
		/* 8219F3C4h case   28:*/		return 0x8219F3C8;
		  /* 8219F3C8h */ case   29:  		/* and R26, R10, R7 */
		/* 8219F3C8h case   29:*/		cpu::op::and<0>(regs,&regs.R26,regs.R10,regs.R7);
		/* 8219F3C8h case   29:*/		return 0x8219F3CC;
		  /* 8219F3CCh */ case   30:  		/* ldx R6, <#[R29 + R30]> */
		/* 8219F3CCh case   30:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8219F3CCh case   30:*/		return 0x8219F3D0;
		  /* 8219F3D0h */ case   31:  		/* rlwinm R10, R11, 27, 24, 31 */
		/* 8219F3D0h case   31:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R11);
		/* 8219F3D0h case   31:*/		return 0x8219F3D4;
		  /* 8219F3D4h */ case   32:  		/* and R7, R6, R26 */
		/* 8219F3D4h case   32:*/		cpu::op::and<0>(regs,&regs.R7,regs.R6,regs.R26);
		/* 8219F3D4h case   32:*/		return 0x8219F3D8;
		  /* 8219F3D8h */ case   33:  		/* rlwinm R9, R9, 27, 24, 31 */
		/* 8219F3D8h case   33:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R9);
		/* 8219F3D8h case   33:*/		return 0x8219F3DC;
		  /* 8219F3DCh */ case   34:  		/* srd R7, R7, R31 */
		/* 8219F3DCh case   34:*/		cpu::op::srd<0>(regs,&regs.R7,regs.R7,regs.R31);
		/* 8219F3DCh case   34:*/		return 0x8219F3E0;
		  /* 8219F3E0h */ case   35:  		/* rlwinm R7, R7, 0, 0, 31 */
		/* 8219F3E0h case   35:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R7,regs.R7);
		/* 8219F3E0h case   35:*/		return 0x8219F3E4;
		  /* 8219F3E4h */ case   36:  		/* rlwinm R8, R8, 0, 18, 24 */
		/* 8219F3E4h case   36:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R8,regs.R8);
		/* 8219F3E4h case   36:*/		return 0x8219F3E8;
		  /* 8219F3E8h */ case   37:  		/* rlwinm R6, R7, 31, 1, 30 */
		/* 8219F3E8h case   37:*/		cpu::op::rlwinm<0,31,1,30>(regs,&regs.R6,regs.R7);
		/* 8219F3E8h case   37:*/		return 0x8219F3EC;
		  /* 8219F3ECh */ case   38:  		/* rlwinm R7, R7, 1, 29, 30 */
		/* 8219F3ECh case   38:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R7,regs.R7);
		/* 8219F3ECh case   38:*/		return 0x8219F3F0;
		  /* 8219F3F0h */ case   39:  		/* srw R10, R10, R6 */
		/* 8219F3F0h case   39:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R6);
		/* 8219F3F0h case   39:*/		return 0x8219F3F4;
		  /* 8219F3F4h */ case   40:  		/* srw R9, R9, R7 */
		/* 8219F3F4h case   40:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8219F3F4h case   40:*/		return 0x8219F3F8;
		  /* 8219F3F8h */ case   41:  		/* rlwinm R4, R10, 0, 30, 31 */
		/* 8219F3F8h case   41:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R10);
		/* 8219F3F8h case   41:*/		return 0x8219F3FC;
		  /* 8219F3FCh */ case   42:  		/* rlwinm R28, R9, 0, 30, 31 */
		/* 8219F3FCh case   42:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R28,regs.R9);
		/* 8219F3FCh case   42:*/		return 0x8219F400;
		  /* 8219F400h */ case   43:  		/* cmplwi CR6, R8, 16000 */
		/* 8219F400h case   43:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00003E80);
		/* 8219F400h case   43:*/		return 0x8219F404;
		  /* 8219F404h */ case   44:  		/* subf R10, R4, R28 */
		/* 8219F404h case   44:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R4,regs.R28);
		/* 8219F404h case   44:*/		return 0x8219F408;
		  /* 8219F408h */ case   45:  		/* cntlzw R10, R10 */
		/* 8219F408h case   45:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 8219F408h case   45:*/		return 0x8219F40C;
		  /* 8219F40Ch */ case   46:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 8219F40Ch case   46:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 8219F40Ch case   46:*/		return 0x8219F410;
		  /* 8219F410h */ case   47:  		/* bc 4, CR6_EQ, 60 */
		/* 8219F410h case   47:*/		if ( !regs.CR[6].eq ) { return 0x8219F44C;  }
		/* 8219F410h case   47:*/		return 0x8219F414;
		  /* 8219F414h */ case   48:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 8219F414h case   48:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 8219F414h case   48:*/		return 0x8219F418;
		  /* 8219F418h */ case   49:  		/* bl 533104 */
		/* 8219F418h case   49:*/		regs.LR = 0x8219F41C; return 0x82221688;
		/* 8219F418h case   49:*/		return 0x8219F41C;
		  /* 8219F41Ch */ case   50:  		/* lwz R11, <#[R23]> */
		/* 8219F41Ch case   50:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 8219F41Ch case   50:*/		return 0x8219F420;
		  /* 8219F420h */ case   51:  		/* mr R4, R28 */
		/* 8219F420h case   51:*/		regs.R4 = regs.R28;
		/* 8219F420h case   51:*/		return 0x8219F424;
		  /* 8219F424h */ case   52:  		/* lwz R3, <#[R23 + 12]> */
		/* 8219F424h case   52:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x0000000C) );
		/* 8219F424h case   52:*/		return 0x8219F428;
		  /* 8219F428h */ case   53:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 8219F428h case   53:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 8219F428h case   53:*/		return 0x8219F42C;
		  /* 8219F42Ch */ case   54:  		/* fmr FR31, FR1 */
		/* 8219F42Ch case   54:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 8219F42Ch case   54:*/		return 0x8219F430;
		  /* 8219F430h */ case   55:  		/* bl 533080 */
		/* 8219F430h case   55:*/		regs.LR = 0x8219F434; return 0x82221688;
		/* 8219F430h case   55:*/		return 0x8219F434;
		  /* 8219F434h */ case   56:  		/* fcmpu CR6, FR31, FR1 */
		/* 8219F434h case   56:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR1);
		/* 8219F434h case   56:*/		return 0x8219F438;
		  /* 8219F438h */ case   57:  		/* mr R11, R14 */
		/* 8219F438h case   57:*/		regs.R11 = regs.R14;
		/* 8219F438h case   57:*/		return 0x8219F43C;
		  /* 8219F43Ch */ case   58:  		/* bc 12, CR6_EQ, 8 */
		/* 8219F43Ch case   58:*/		if ( regs.CR[6].eq ) { return 0x8219F444;  }
		/* 8219F43Ch case   58:*/		return 0x8219F440;
		  /* 8219F440h */ case   59:  		/* li R11, 0 */
		/* 8219F440h case   59:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219F440h case   59:*/		return 0x8219F444;
	}
	return 0x8219F444;
} // Block from 8219F354h-8219F444h (60 instructions)

//////////////////////////////////////////////////////
// Block at 8219F444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F444);
		  /* 8219F444h */ case    0:  		/* lwz R5, <#[R1 + 80]> */
		/* 8219F444h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8219F444h case    0:*/		return 0x8219F448;
		  /* 8219F448h */ case    1:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 8219F448h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 8219F448h case    1:*/		return 0x8219F44C;
	}
	return 0x8219F44C;
} // Block from 8219F444h-8219F44Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219F44Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F44C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F44C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F44C);
		  /* 8219F44Ch */ case    0:  		/* rlwinm. R11, R10, 0, 24, 31 */
		/* 8219F44Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R10);
		/* 8219F44Ch case    0:*/		return 0x8219F450;
		  /* 8219F450h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8219F450h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219F460;  }
		/* 8219F450h case    1:*/		return 0x8219F454;
		  /* 8219F454h */ case    2:  		/* addi R19, R19, 1 */
		/* 8219F454h case    2:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 8219F454h case    2:*/		return 0x8219F458;
		  /* 8219F458h */ case    3:  		/* addi R27, R27, 4 */
		/* 8219F458h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 8219F458h case    3:*/		return 0x8219F45C;
		  /* 8219F45Ch */ case    4:  		/* b 84 */
		/* 8219F45Ch case    4:*/		return 0x8219F4B0;
		/* 8219F45Ch case    4:*/		return 0x8219F460;
	}
	return 0x8219F460;
} // Block from 8219F44Ch-8219F460h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219F460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F460);
		  /* 8219F460h */ case    0:  		/* addi R11, R25, 3 */
		/* 8219F460h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0x3);
		/* 8219F460h case    0:*/		return 0x8219F464;
		  /* 8219F464h */ case    1:  		/* ldx R10, <#[R29 + R30]> */
		/* 8219F464h case    1:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8219F464h case    1:*/		return 0x8219F468;
		  /* 8219F468h */ case    2:  		/* rlwinm R9, R25, 29, 3, 28 */
		/* 8219F468h case    2:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R9,regs.R25);
		/* 8219F468h case    2:*/		return 0x8219F46C;
		  /* 8219F46Ch */ case    3:  		/* addi R8, R1, 88 */
		/* 8219F46Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x58);
		/* 8219F46Ch case    3:*/		return 0x8219F470;
		  /* 8219F470h */ case    4:  		/* rldicl R11, R11, 0, 58 */
		/* 8219F470h case    4:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R11,regs.R11);
		/* 8219F470h case    4:*/		return 0x8219F474;
		  /* 8219F474h */ case    5:  		/* andc R10, R10, R26 */
		/* 8219F474h case    5:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R10,regs.R26);
		/* 8219F474h case    5:*/		return 0x8219F478;
		  /* 8219F478h */ case    6:  		/* sld R11, R21, R11 */
		/* 8219F478h case    6:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R21,regs.R11);
		/* 8219F478h case    6:*/		return 0x8219F47C;
		  /* 8219F47Ch */ case    7:  		/* ldx R9, <#[R9 + R8]> */
		/* 8219F47Ch case    7:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8219F47Ch case    7:*/		return 0x8219F480;
		  /* 8219F480h */ case    8:  		/* addi R11, R11, -1 */
		/* 8219F480h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8219F480h case    8:*/		return 0x8219F484;
		  /* 8219F484h */ case    9:  		/* rldicl R8, R25, 0, 58 */
		/* 8219F484h case    9:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R8,regs.R25);
		/* 8219F484h case    9:*/		return 0x8219F488;
		  /* 8219F488h */ case   10:  		/* and R11, R11, R9 */
		/* 8219F488h case   10:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8219F488h case   10:*/		return 0x8219F48C;
		  /* 8219F48Ch */ case   11:  		/* sld R7, R22, R8 */
		/* 8219F48Ch case   11:*/		cpu::op::sld<0>(regs,&regs.R7,regs.R22,regs.R8);
		/* 8219F48Ch case   11:*/		return 0x8219F490;
		  /* 8219F490h */ case   12:  		/* and R11, R11, R7 */
		/* 8219F490h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 8219F490h case   12:*/		return 0x8219F494;
		  /* 8219F494h */ case   13:  		/* addi R18, R18, -1 */
		/* 8219F494h case   13:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0xFFFFFFFF);
		/* 8219F494h case   13:*/		return 0x8219F498;
		  /* 8219F498h */ case   14:  		/* srd R11, R11, R8 */
		/* 8219F498h case   14:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 8219F498h case   14:*/		return 0x8219F49C;
		  /* 8219F49Ch */ case   15:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 8219F49Ch case   15:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 8219F49Ch case   15:*/		return 0x8219F4A0;
		  /* 8219F4A0h */ case   16:  		/* addi R25, R25, -4 */
		/* 8219F4A0h case   16:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xFFFFFFFC);
		/* 8219F4A0h case   16:*/		return 0x8219F4A4;
		  /* 8219F4A4h */ case   17:  		/* sld R11, R11, R31 */
		/* 8219F4A4h case   17:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8219F4A4h case   17:*/		return 0x8219F4A8;
		  /* 8219F4A8h */ case   18:  		/* or R11, R10, R11 */
		/* 8219F4A8h case   18:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8219F4A8h case   18:*/		return 0x8219F4AC;
		  /* 8219F4ACh */ case   19:  		/* stdx R11, <#[R29 + R30]> */
		/* 8219F4ACh case   19:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R29 + regs.R30 + 0x00000000) );
		/* 8219F4ACh case   19:*/		return 0x8219F4B0;
	}
	return 0x8219F4B0;
} // Block from 8219F460h-8219F4B0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219F4B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F4B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F4B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F4B0);
		  /* 8219F4B0h */ case    0:  		/* cmplw CR6, R19, R18 */
		/* 8219F4B0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R19,regs.R18);
		/* 8219F4B0h case    0:*/		return 0x8219F4B4;
		  /* 8219F4B4h */ case    1:  		/* bc 12, CR6_LT, -284 */
		/* 8219F4B4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8219F398;  }
		/* 8219F4B4h case    1:*/		return 0x8219F4B8;
		  /* 8219F4B8h */ case    2:  		/* lwz R4, <#[R1 + 300]> */
		/* 8219F4B8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000012C) );
		/* 8219F4B8h case    2:*/		return 0x8219F4BC;
	}
	return 0x8219F4BC;
} // Block from 8219F4B0h-8219F4BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219F4BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F4BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F4BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F4BC);
		  /* 8219F4BCh */ case    0:  		/* lwz R11, <#[R15 + 8]> */
		/* 8219F4BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000008) );
		/* 8219F4BCh case    0:*/		return 0x8219F4C0;
		  /* 8219F4C0h */ case    1:  		/* addi R17, R17, 1 */
		/* 8219F4C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 8219F4C0h case    1:*/		return 0x8219F4C4;
		  /* 8219F4C4h */ case    2:  		/* addi R20, R20, 4 */
		/* 8219F4C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x4);
		/* 8219F4C4h case    2:*/		return 0x8219F4C8;
		  /* 8219F4C8h */ case    3:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 8219F4C8h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 8219F4C8h case    3:*/		return 0x8219F4CC;
		  /* 8219F4CCh */ case    4:  		/* cmplw CR6, R17, R11 */
		/* 8219F4CCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R17,regs.R11);
		/* 8219F4CCh case    4:*/		return 0x8219F4D0;
		  /* 8219F4D0h */ case    5:  		/* bc 12, CR6_LT, -344 */
		/* 8219F4D0h case    5:*/		if ( regs.CR[6].lt ) { return 0x8219F378;  }
		/* 8219F4D0h case    5:*/		return 0x8219F4D4;
	}
	return 0x8219F4D4;
} // Block from 8219F4BCh-8219F4D4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219F4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F4D4);
		  /* 8219F4D4h */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 8219F4D4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 8219F4D4h case    0:*/		return 0x8219F4D8;
		  /* 8219F4D8h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 8219F4D8h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219F4F8;  }
		/* 8219F4D8h case    1:*/		return 0x8219F4DC;
		  /* 8219F4DCh */ case    2:  		/* lwz R11, <#[R4 + 8]> */
		/* 8219F4DCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219F4DCh case    2:*/		return 0x8219F4E0;
		  /* 8219F4E0h */ case    3:  		/* li R3, 1 */
		/* 8219F4E0h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219F4E0h case    3:*/		return 0x8219F4E4;
		  /* 8219F4E4h */ case    4:  		/* ld R10, <#[R1 + 88]> */
		/* 8219F4E4h case    4:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8219F4E4h case    4:*/		return 0x8219F4E8;
		  /* 8219F4E8h */ case    5:  		/* rlwimi R11, R18, 0, 27, 31 */
		/* 8219F4E8h case    5:*/		cpu::op::rlwimi<0,0,27,31>(regs,&regs.R11,regs.R18);
		/* 8219F4E8h case    5:*/		return 0x8219F4EC;
		  /* 8219F4ECh */ case    6:  		/* stw R11, <#[R4 + 8]> */
		/* 8219F4ECh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8219F4ECh case    6:*/		return 0x8219F4F0;
		  /* 8219F4F0h */ case    7:  		/* std R10, <#[R4]> */
		/* 8219F4F0h case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8219F4F0h case    7:*/		return 0x8219F4F4;
		  /* 8219F4F4h */ case    8:  		/* b 8 */
		/* 8219F4F4h case    8:*/		return 0x8219F4FC;
		/* 8219F4F4h case    8:*/		return 0x8219F4F8;
	}
	return 0x8219F4F8;
} // Block from 8219F4D4h-8219F4F8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219F4F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F4F8);
		  /* 8219F4F8h */ case    0:  		/* li R3, 0 */
		/* 8219F4F8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219F4F8h case    0:*/		return 0x8219F4FC;
	}
	return 0x8219F4FC;
} // Block from 8219F4F8h-8219F4FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219F4FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F4FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F4FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F4FC);
		  /* 8219F4FCh */ case    0:  		/* addi R1, R1, 256 */
		/* 8219F4FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 8219F4FCh case    0:*/		return 0x8219F500;
		  /* 8219F500h */ case    1:  		/* lfd FR31, <#[R1 - 160]> */
		/* 8219F500h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 8219F500h case    1:*/		return 0x8219F504;
		  /* 8219F504h */ case    2:  		/* b -1106580 */
		/* 8219F504h case    2:*/		return 0x82091270;
		/* 8219F504h case    2:*/		return 0x8219F508;
	}
	return 0x8219F508;
} // Block from 8219F4FCh-8219F508h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219F508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F508);
		  /* 8219F508h */ case    0:  		/* mfspr R12, LR */
		/* 8219F508h case    0:*/		regs.R12 = regs.LR;
		/* 8219F508h case    0:*/		return 0x8219F50C;
		  /* 8219F50Ch */ case    1:  		/* bl -1106616 */
		/* 8219F50Ch case    1:*/		regs.LR = 0x8219F510; return 0x82091254;
		/* 8219F50Ch case    1:*/		return 0x8219F510;
		  /* 8219F510h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 8219F510h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 8219F510h case    2:*/		return 0x8219F514;
		  /* 8219F514h */ case    3:  		/* lwz R11, <#[R6 + 8]> */
		/* 8219F514h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 8219F514h case    3:*/		return 0x8219F518;
		  /* 8219F518h */ case    4:  		/* mr R28, R3 */
		/* 8219F518h case    4:*/		regs.R28 = regs.R3;
		/* 8219F518h case    4:*/		return 0x8219F51C;
		  /* 8219F51Ch */ case    5:  		/* mr R3, R4 */
		/* 8219F51Ch case    5:*/		regs.R3 = regs.R4;
		/* 8219F51Ch case    5:*/		return 0x8219F520;
		  /* 8219F520h */ case    6:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 8219F520h case    6:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 8219F520h case    6:*/		return 0x8219F524;
		  /* 8219F524h */ case    7:  		/* mr R31, R4 */
		/* 8219F524h case    7:*/		regs.R31 = regs.R4;
		/* 8219F524h case    7:*/		return 0x8219F528;
		  /* 8219F528h */ case    8:  		/* stw R11, <#[R6 + 8]> */
		/* 8219F528h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000008) );
		/* 8219F528h case    8:*/		return 0x8219F52C;
		  /* 8219F52Ch */ case    9:  		/* mr R30, R5 */
		/* 8219F52Ch case    9:*/		regs.R30 = regs.R5;
		/* 8219F52Ch case    9:*/		return 0x8219F530;
		  /* 8219F530h */ case   10:  		/* mr R29, R6 */
		/* 8219F530h case   10:*/		regs.R29 = regs.R6;
		/* 8219F530h case   10:*/		return 0x8219F534;
		  /* 8219F534h */ case   11:  		/* li R27, 0 */
		/* 8219F534h case   11:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8219F534h case   11:*/		return 0x8219F538;
		  /* 8219F538h */ case   12:  		/* bl -190344 */
		/* 8219F538h case   12:*/		regs.LR = 0x8219F53C; return 0x82170DB0;
		/* 8219F538h case   12:*/		return 0x8219F53C;
		  /* 8219F53Ch */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219F53Ch case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219F53Ch case   13:*/		return 0x8219F540;
		  /* 8219F540h */ case   14:  		/* lwz R11, <#[R31 + 8]> */
		/* 8219F540h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8219F540h case   14:*/		return 0x8219F544;
		  /* 8219F544h */ case   15:  		/* lwz R10, <#[R30 + 8]> */
		/* 8219F544h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 8219F544h case   15:*/		return 0x8219F548;
		  /* 8219F548h */ case   16:  		/* bc 12, CR0_EQ, 212 */
		/* 8219F548h case   16:*/		if ( regs.CR[0].eq ) { return 0x8219F61C;  }
		/* 8219F548h case   16:*/		return 0x8219F54C;
		  /* 8219F54Ch */ case   17:  		/* mr R4, R31 */
		/* 8219F54Ch case   17:*/		regs.R4 = regs.R31;
		/* 8219F54Ch case   17:*/		return 0x8219F550;
		  /* 8219F550h */ case   18:  		/* mr R3, R28 */
		/* 8219F550h case   18:*/		regs.R3 = regs.R28;
		/* 8219F550h case   18:*/		return 0x8219F554;
		  /* 8219F554h */ case   19:  		/* mr R6, R29 */
		/* 8219F554h case   19:*/		regs.R6 = regs.R29;
		/* 8219F554h case   19:*/		return 0x8219F558;
		  /* 8219F558h */ case   20:  		/* mr R5, R30 */
		/* 8219F558h case   20:*/		regs.R5 = regs.R30;
		/* 8219F558h case   20:*/		return 0x8219F55C;
		  /* 8219F55Ch */ case   21:  		/* rlwinm R28, R11, 18, 29, 31 */
		/* 8219F55Ch case   21:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R28,regs.R11);
		/* 8219F55Ch case   21:*/		return 0x8219F560;
		  /* 8219F560h */ case   22:  		/* rlwinm R31, R10, 18, 29, 31 */
		/* 8219F560h case   22:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R31,regs.R10);
		/* 8219F560h case   22:*/		return 0x8219F564;
		  /* 8219F564h */ case   23:  		/* bl -1316 */
		/* 8219F564h case   23:*/		regs.LR = 0x8219F568; return 0x8219F040;
		/* 8219F564h case   23:*/		return 0x8219F568;
		  /* 8219F568h */ case   24:  		/* lwz R11, <#[R29 + 8]> */
		/* 8219F568h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8219F568h case   24:*/		return 0x8219F56C;
		  /* 8219F56Ch */ case   25:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 8219F56Ch case   25:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219F56Ch case   25:*/		return 0x8219F570;
		  /* 8219F570h */ case   26:  		/* bc 12, CR0_EQ, 236 */
		/* 8219F570h case   26:*/		if ( regs.CR[0].eq ) { return 0x8219F65C;  }
		/* 8219F570h case   26:*/		return 0x8219F574;
		  /* 8219F574h */ case   27:  		/* ld R8, <#[R29]> */
		/* 8219F574h case   27:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R29 + 0x00000000) );
		/* 8219F574h case   27:*/		return 0x8219F578;
		  /* 8219F578h */ case   28:  		/* li R9, 0 */
		/* 8219F578h case   28:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219F578h case   28:*/		return 0x8219F57C;
		  /* 8219F57Ch */ case   29:  		/* li R10, 0 */
		/* 8219F57Ch case   29:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219F57Ch case   29:*/		return 0x8219F580;
		  /* 8219F580h */ case   30:  		/* cmplwi CR6, R11, 0 */
		/* 8219F580h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219F580h case   30:*/		return 0x8219F584;
		  /* 8219F584h */ case   31:  		/* std R8, <#[R1 + 80]> */
		/* 8219F584h case   31:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 8219F584h case   31:*/		return 0x8219F588;
		  /* 8219F588h */ case   32:  		/* bc 12, CR6_EQ, 104 */
		/* 8219F588h case   32:*/		if ( regs.CR[6].eq ) { return 0x8219F5F0;  }
		/* 8219F588h case   32:*/		return 0x8219F58C;
		  /* 8219F58Ch */ case   33:  		/* lwz R8, <#[R29 + 8]> */
		/* 8219F58Ch case   33:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000008) );
		/* 8219F58Ch case   33:*/		return 0x8219F590;
		  /* 8219F590h */ case   34:  		/* li R11, 0 */
		/* 8219F590h case   34:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219F590h case   34:*/		return 0x8219F594;
		  /* 8219F594h */ case   35:  		/* rlwinm R7, R8, 0, 27, 31 */
		/* 8219F594h case   35:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R8);
		/* 8219F594h case   35:*/		return 0x8219F598;
		  /* 8219F598h */ case   36:  		/* addi R8, R11, 3 */
		/* 8219F598h case   36:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x3);
		/* 8219F598h case   36:*/		return 0x8219F59C;
		  /* 8219F59Ch */ case   37:  		/* rlwinm R6, R11, 29, 3, 28 */
		/* 8219F59Ch case   37:*/		cpu::op::rlwinm<0,29,3,28>(regs,&regs.R6,regs.R11);
		/* 8219F59Ch case   37:*/		return 0x8219F5A0;
		  /* 8219F5A0h */ case   38:  		/* rldicl R8, R8, 0, 58 */
		/* 8219F5A0h case   38:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R8,regs.R8);
		/* 8219F5A0h case   38:*/		return 0x8219F5A4;
		  /* 8219F5A4h */ case   39:  		/* addi R5, R1, 80 */
		/* 8219F5A4h case   39:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8219F5A4h case   39:*/		return 0x8219F5A8;
		  /* 8219F5A8h */ case   40:  		/* li R4, 2 */
		/* 8219F5A8h case   40:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 8219F5A8h case   40:*/		return 0x8219F5AC;
		  /* 8219F5ACh */ case   41:  		/* rldicl R3, R11, 0, 58 */
		/* 8219F5ACh case   41:*/		cpu::op::rldicl<0,0,58>(regs,&regs.R3,regs.R11);
		/* 8219F5ACh case   41:*/		return 0x8219F5B0;
		  /* 8219F5B0h */ case   42:  		/* sld R8, R4, R8 */
		/* 8219F5B0h case   42:*/		cpu::op::sld<0>(regs,&regs.R8,regs.R4,regs.R8);
		/* 8219F5B0h case   42:*/		return 0x8219F5B4;
		  /* 8219F5B4h */ case   43:  		/* ldx R6, <#[R6 + R5]> */
		/* 8219F5B4h case   43:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R6 + regs.R5 + 0x00000000) );
		/* 8219F5B4h case   43:*/		return 0x8219F5B8;
		  /* 8219F5B8h */ case   44:  		/* addi R8, R8, -1 */
		/* 8219F5B8h case   44:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 8219F5B8h case   44:*/		return 0x8219F5BC;
		  /* 8219F5BCh */ case   45:  		/* li R5, -1 */
		/* 8219F5BCh case   45:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 8219F5BCh case   45:*/		return 0x8219F5C0;
		  /* 8219F5C0h */ case   46:  		/* and R8, R8, R6 */
		/* 8219F5C0h case   46:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 8219F5C0h case   46:*/		return 0x8219F5C4;
		  /* 8219F5C4h */ case   47:  		/* sld R6, R5, R3 */
		/* 8219F5C4h case   47:*/		cpu::op::sld<0>(regs,&regs.R6,regs.R5,regs.R3);
		/* 8219F5C4h case   47:*/		return 0x8219F5C8;
		  /* 8219F5C8h */ case   48:  		/* and R8, R8, R6 */
		/* 8219F5C8h case   48:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 8219F5C8h case   48:*/		return 0x8219F5CC;
		  /* 8219F5CCh */ case   49:  		/* li R6, 1 */
		/* 8219F5CCh case   49:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8219F5CCh case   49:*/		return 0x8219F5D0;
		  /* 8219F5D0h */ case   50:  		/* srd R8, R8, R3 */
		/* 8219F5D0h case   50:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R8,regs.R3);
		/* 8219F5D0h case   50:*/		return 0x8219F5D4;
		  /* 8219F5D4h */ case   51:  		/* rlwinm R8, R8, 0, 30, 31 */
		/* 8219F5D4h case   51:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R8,regs.R8);
		/* 8219F5D4h case   51:*/		return 0x8219F5D8;
		  /* 8219F5D8h */ case   52:  		/* addi R10, R10, 1 */
		/* 8219F5D8h case   52:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8219F5D8h case   52:*/		return 0x8219F5DC;
		  /* 8219F5DCh */ case   53:  		/* slw R8, R6, R8 */
		/* 8219F5DCh case   53:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R6,regs.R8);
		/* 8219F5DCh case   53:*/		return 0x8219F5E0;
		  /* 8219F5E0h */ case   54:  		/* or R9, R8, R9 */
		/* 8219F5E0h case   54:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8219F5E0h case   54:*/		return 0x8219F5E4;
		  /* 8219F5E4h */ case   55:  		/* addi R11, R11, 4 */
		/* 8219F5E4h case   55:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219F5E4h case   55:*/		return 0x8219F5E8;
		  /* 8219F5E8h */ case   56:  		/* cmplw CR6, R10, R7 */
		/* 8219F5E8h case   56:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 8219F5E8h case   56:*/		return 0x8219F5EC;
		  /* 8219F5ECh */ case   57:  		/* bc 12, CR6_LT, -84 */
		/* 8219F5ECh case   57:*/		if ( regs.CR[6].lt ) { return 0x8219F598;  }
		/* 8219F5ECh case   57:*/		return 0x8219F5F0;
	}
	return 0x8219F5F0;
} // Block from 8219F508h-8219F5F0h (58 instructions)

//////////////////////////////////////////////////////
// Block at 8219F5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F5F0);
		  /* 8219F5F0h */ case    0:  		/* lis R11, -28311 */
		/* 8219F5F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 8219F5F0h case    0:*/		return 0x8219F5F4;
		  /* 8219F5F4h */ case    1:  		/* lis R10, 0 */
		/* 8219F5F4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8219F5F4h case    1:*/		return 0x8219F5F8;
		  /* 8219F5F8h */ case    2:  		/* ori R11, R11, 5192 */
		/* 8219F5F8h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 8219F5F8h case    2:*/		return 0x8219F5FC;
		  /* 8219F5FCh */ case    3:  		/* ori R10, R10, 36262 */
		/* 8219F5FCh case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 8219F5FCh case    3:*/		return 0x8219F600;
		  /* 8219F600h */ case    4:  		/* rldicl R9, R9, 0, 32 */
		/* 8219F600h case    4:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R9);
		/* 8219F600h case    4:*/		return 0x8219F604;
		  /* 8219F604h */ case    5:  		/* rldimi R11, R10, 32, 0 */
		/* 8219F604h case    5:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 8219F604h case    5:*/		return 0x8219F608;
		  /* 8219F608h */ case    6:  		/* srd R11, R11, R9 */
		/* 8219F608h case    6:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8219F608h case    6:*/		return 0x8219F60C;
		  /* 8219F60Ch */ case    7:  		/* srd R11, R11, R9 */
		/* 8219F60Ch case    7:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8219F60Ch case    7:*/		return 0x8219F610;
		  /* 8219F610h */ case    8:  		/* srd R11, R11, R9 */
		/* 8219F610h case    8:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8219F610h case    8:*/		return 0x8219F614;
		  /* 8219F614h */ case    9:  		/* rlwinm R27, R11, 0, 29, 31 */
		/* 8219F614h case    9:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R27,regs.R11);
		/* 8219F614h case    9:*/		return 0x8219F618;
		  /* 8219F618h */ case   10:  		/* b 68 */
		/* 8219F618h case   10:*/		return 0x8219F65C;
		/* 8219F618h case   10:*/		return 0x8219F61C;
	}
	return 0x8219F61C;
} // Block from 8219F5F0h-8219F61Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219F61Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F61C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F61C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F61C);
		  /* 8219F61Ch */ case    0:  		/* rlwinm R11, R11, 31, 28, 31 */
		/* 8219F61Ch case    0:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R11,regs.R11);
		/* 8219F61Ch case    0:*/		return 0x8219F620;
		  /* 8219F620h */ case    1:  		/* li R28, 0 */
		/* 8219F620h case    1:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 8219F620h case    1:*/		return 0x8219F624;
		  /* 8219F624h */ case    2:  		/* li R31, 0 */
		/* 8219F624h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8219F624h case    2:*/		return 0x8219F628;
		  /* 8219F628h */ case    3:  		/* rlwinm R10, R10, 31, 28, 31 */
		/* 8219F628h case    3:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R10,regs.R10);
		/* 8219F628h case    3:*/		return 0x8219F62C;
		  /* 8219F62Ch */ case    4:  		/* rlwinm. R9, R11, 0, 30, 31 */
		/* 8219F62Ch case    4:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R9,regs.R11);
		/* 8219F62Ch case    4:*/		return 0x8219F630;
		  /* 8219F630h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 8219F630h case    5:*/		if ( regs.CR[0].eq ) { return 0x8219F638;  }
		/* 8219F630h case    5:*/		return 0x8219F634;
		  /* 8219F634h */ case    6:  		/* li R28, 2 */
		/* 8219F634h case    6:*/		cpu::op::li<0>(regs,&regs.R28,0x2);
		/* 8219F634h case    6:*/		return 0x8219F638;
	}
	return 0x8219F638;
} // Block from 8219F61Ch-8219F638h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219F638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F638);
		  /* 8219F638h */ case    0:  		/* rlwinm. R11, R11, 0, 28, 29 */
		/* 8219F638h case    0:*/		cpu::op::rlwinm<1,0,28,29>(regs,&regs.R11,regs.R11);
		/* 8219F638h case    0:*/		return 0x8219F63C;
		  /* 8219F63Ch */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8219F63Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219F644;  }
		/* 8219F63Ch case    1:*/		return 0x8219F640;
		  /* 8219F640h */ case    2:  		/* addi R28, R28, 2 */
		/* 8219F640h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x2);
		/* 8219F640h case    2:*/		return 0x8219F644;
	}
	return 0x8219F644;
} // Block from 8219F638h-8219F644h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219F644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F644);
		  /* 8219F644h */ case    0:  		/* rlwinm. R11, R10, 0, 30, 31 */
		/* 8219F644h case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R10);
		/* 8219F644h case    0:*/		return 0x8219F648;
		  /* 8219F648h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8219F648h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219F650;  }
		/* 8219F648h case    1:*/		return 0x8219F64C;
		  /* 8219F64Ch */ case    2:  		/* li R31, 2 */
		/* 8219F64Ch case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x2);
		/* 8219F64Ch case    2:*/		return 0x8219F650;
	}
	return 0x8219F650;
} // Block from 8219F644h-8219F650h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219F650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F650);
		  /* 8219F650h */ case    0:  		/* rlwinm. R11, R10, 0, 28, 29 */
		/* 8219F650h case    0:*/		cpu::op::rlwinm<1,0,28,29>(regs,&regs.R11,regs.R10);
		/* 8219F650h case    0:*/		return 0x8219F654;
		  /* 8219F654h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 8219F654h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219F65C;  }
		/* 8219F654h case    1:*/		return 0x8219F658;
	}
	return 0x8219F658;
} // Block from 8219F650h-8219F658h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219F658h
// Function '?Init@?$Queue@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z$09@D3DXShader@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F658);
		  /* 8219F658h */ case    0:  		/* addi R31, R31, 2 */
		/* 8219F658h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x2);
		/* 8219F658h case    0:*/		return 0x8219F65C;
	}
	return 0x8219F65C;
} // Block from 8219F658h-8219F65Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219F65Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F65C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F65C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F65C);
		  /* 8219F65Ch */ case    0:  		/* lwz R10, <#[R29 + 8]> */
		/* 8219F65Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8219F65Ch case    0:*/		return 0x8219F660;
		  /* 8219F660h */ case    1:  		/* subf R11, R27, R31 */
		/* 8219F660h case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R27,regs.R31);
		/* 8219F660h case    1:*/		return 0x8219F664;
		  /* 8219F664h */ case    2:  		/* rlwimi R10, R27, 5, 24, 26 */
		/* 8219F664h case    2:*/		cpu::op::rlwimi<0,5,24,26>(regs,&regs.R10,regs.R27);
		/* 8219F664h case    2:*/		return 0x8219F668;
		  /* 8219F668h */ case    3:  		/* add R3, R11, R28 */
		/* 8219F668h case    3:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 8219F668h case    3:*/		return 0x8219F66C;
		  /* 8219F66Ch */ case    4:  		/* stw R10, <#[R29 + 8]> */
		/* 8219F66Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8219F66Ch case    4:*/		return 0x8219F670;
		  /* 8219F670h */ case    5:  		/* addi R1, R1, 144 */
		/* 8219F670h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8219F670h case    5:*/		return 0x8219F674;
		  /* 8219F674h */ case    6:  		/* b -1106896 */
		/* 8219F674h case    6:*/		return 0x820912A4;
		/* 8219F674h case    6:*/		return 0x8219F678;
	}
	return 0x8219F678;
} // Block from 8219F65Ch-8219F678h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219F678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F678);
		  /* 8219F678h */ case    0:  		/* mfspr R12, LR */
		/* 8219F678h case    0:*/		regs.R12 = regs.LR;
		/* 8219F678h case    0:*/		return 0x8219F67C;
		  /* 8219F67Ch */ case    1:  		/* bl -1107024 */
		/* 8219F67Ch case    1:*/		regs.LR = 0x8219F680; return 0x8209122C;
		/* 8219F67Ch case    1:*/		return 0x8219F680;
		  /* 8219F680h */ case    2:  		/* stfd FR30, <#[R1 - 144]> */
		/* 8219F680h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFF70) );
		/* 8219F680h case    2:*/		return 0x8219F684;
		  /* 8219F684h */ case    3:  		/* stfd FR31, <#[R1 - 136]> */
		/* 8219F684h case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF78) );
		/* 8219F684h case    3:*/		return 0x8219F688;
		  /* 8219F688h */ case    4:  		/* stwu R1, <#[R1 - 272]> */
		/* 8219F688h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEF0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEF0);
		/* 8219F688h case    4:*/		return 0x8219F68C;
		  /* 8219F68Ch */ case    5:  		/* lwz R10, <#[R4 + 8]> */
		/* 8219F68Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 8219F68Ch case    5:*/		return 0x8219F690;
		  /* 8219F690h */ case    6:  		/* mr R20, R3 */
		/* 8219F690h case    6:*/		regs.R20 = regs.R3;
		/* 8219F690h case    6:*/		return 0x8219F694;
		  /* 8219F694h */ case    7:  		/* lwz R18, <#[R5 + 12]> */
		/* 8219F694h case    7:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R5 + 0x0000000C) );
		/* 8219F694h case    7:*/		return 0x8219F698;
		  /* 8219F698h */ case    8:  		/* mr R27, R4 */
		/* 8219F698h case    8:*/		regs.R27 = regs.R4;
		/* 8219F698h case    8:*/		return 0x8219F69C;
		  /* 8219F69Ch */ case    9:  		/* mr R26, R5 */
		/* 8219F69Ch case    9:*/		regs.R26 = regs.R5;
		/* 8219F69Ch case    9:*/		return 0x8219F6A0;
		  /* 8219F6A0h */ case   10:  		/* mr R22, R6 */
		/* 8219F6A0h case   10:*/		regs.R22 = regs.R6;
		/* 8219F6A0h case   10:*/		return 0x8219F6A4;
		  /* 8219F6A4h */ case   11:  		/* mr R17, R7 */
		/* 8219F6A4h case   11:*/		regs.R17 = regs.R7;
		/* 8219F6A4h case   11:*/		return 0x8219F6A8;
		  /* 8219F6A8h */ case   12:  		/* mr R19, R8 */
		/* 8219F6A8h case   12:*/		regs.R19 = regs.R8;
		/* 8219F6A8h case   12:*/		return 0x8219F6AC;
		  /* 8219F6ACh */ case   13:  		/* rlwinm. R11, R10, 25, 25, 31 */
		/* 8219F6ACh case   13:*/		cpu::op::rlwinm<1,25,25,31>(regs,&regs.R11,regs.R10);
		/* 8219F6ACh case   13:*/		return 0x8219F6B0;
		  /* 8219F6B0h */ case   14:  		/* bc 4, CR0_GT, 652 */
		/* 8219F6B0h case   14:*/		if ( !regs.CR[0].gt ) { return 0x8219F93C;  }
		/* 8219F6B0h case   14:*/		return 0x8219F6B4;
		  /* 8219F6B4h */ case   15:  		/* cmpwi CR6, R11, 2 */
		/* 8219F6B4h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8219F6B4h case   15:*/		return 0x8219F6B8;
		  /* 8219F6B8h */ case   16:  		/* bc 12, CR6_GT, 644 */
		/* 8219F6B8h case   16:*/		if ( regs.CR[6].gt ) { return 0x8219F93C;  }
		/* 8219F6B8h case   16:*/		return 0x8219F6BC;
		  /* 8219F6BCh */ case   17:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 8219F6BCh case   17:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8219F6BCh case   17:*/		return 0x8219F6C0;
		  /* 8219F6C0h */ case   18:  		/* bc 4, CR0_EQ, 636 */
		/* 8219F6C0h case   18:*/		if ( !regs.CR[0].eq ) { return 0x8219F93C;  }
		/* 8219F6C0h case   18:*/		return 0x8219F6C4;
		  /* 8219F6C4h */ case   19:  		/* lis R10, -32256 */
		/* 8219F6C4h case   19:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8219F6C4h case   19:*/		return 0x8219F6C8;
		  /* 8219F6C8h */ case   20:  		/* lis R9, -32256 */
		/* 8219F6C8h case   20:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8219F6C8h case   20:*/		return 0x8219F6CC;
		  /* 8219F6CCh */ case   21:  		/* cmplwi CR6, R11, 2 */
		/* 8219F6CCh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 8219F6CCh case   21:*/		return 0x8219F6D0;
		  /* 8219F6D0h */ case   22:  		/* lfs FR31, <#[R10 + 1816]> */
		/* 8219F6D0h case   22:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000718) );
		/* 8219F6D0h case   22:*/		return 0x8219F6D4;
		  /* 8219F6D4h */ case   23:  		/* lfd FR30, <#[R9 + 1808]> */
		/* 8219F6D4h case   23:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R9 + 0x00000710) );
		/* 8219F6D4h case   23:*/		return 0x8219F6D8;
	}
	return 0x8219F6D8;
} // Block from 8219F678h-8219F6D8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 8219F6D8h
// Function '?AddToTail@?$Queue@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z$09@D3DXShader@@QAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F6D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F6D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F6D8);
		  /* 8219F6D8h */ case    0:  		/* bc 4, CR6_EQ, 32 */
		/* 8219F6D8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8219F6F8;  }
		/* 8219F6D8h case    0:*/		return 0x8219F6DC;
		  /* 8219F6DCh */ case    1:  		/* mr R3, R5 */
		/* 8219F6DCh case    1:*/		regs.R3 = regs.R5;
		/* 8219F6DCh case    1:*/		return 0x8219F6E0;
		  /* 8219F6E0h */ case    2:  		/* fmr FR1, FR30 */
		/* 8219F6E0h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 8219F6E0h case    2:*/		return 0x8219F6E4;
		  /* 8219F6E4h */ case    3:  		/* bl -235828 */
		/* 8219F6E4h case    3:*/		regs.LR = 0x8219F6E8; return 0x82165DB0;
		/* 8219F6E4h case    3:*/		return 0x8219F6E8;
		  /* 8219F6E8h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219F6E8h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219F6E8h case    4:*/		return 0x8219F6EC;
		  /* 8219F6ECh */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 8219F6ECh case    5:*/		if ( !regs.CR[0].eq ) { return 0x8219F6F8;  }
		/* 8219F6ECh case    5:*/		return 0x8219F6F0;
		  /* 8219F6F0h */ case    6:  		/* lis R11, -32256 */
		/* 8219F6F0h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8219F6F0h case    6:*/		return 0x8219F6F4;
		  /* 8219F6F4h */ case    7:  		/* lfs FR31, <#[R11 + 1792]> */
		/* 8219F6F4h case    7:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000700) );
		/* 8219F6F4h case    7:*/		return 0x8219F6F8;
	}
	return 0x8219F6F8;
} // Block from 8219F6D8h-8219F6F8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8219F6F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F6F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F6F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F6F8);
		  /* 8219F6F8h */ case    0:  		/* li R24, 0 */
		/* 8219F6F8h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 8219F6F8h case    0:*/		return 0x8219F6FC;
		  /* 8219F6FCh */ case    1:  		/* addi R23, R27, 44 */
		/* 8219F6FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R27,0x2C);
		/* 8219F6FCh case    1:*/		return 0x8219F700;
		  /* 8219F700h */ case    2:  		/* addi R21, R27, 48 */
		/* 8219F700h case    2:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R27,0x30);
		/* 8219F700h case    2:*/		return 0x8219F704;
		  /* 8219F704h */ case    3:  		/* li R25, 1 */
		/* 8219F704h case    3:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8219F704h case    3:*/		return 0x8219F708;
		  /* 8219F708h */ case    4:  		/* lwz R29, <#[R23]> */
		/* 8219F708h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R23 + 0x00000000) );
		/* 8219F708h case    4:*/		return 0x8219F70C;
		  /* 8219F70Ch */ case    5:  		/* lwz R11, <#[R26]> */
		/* 8219F70Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8219F70Ch case    5:*/		return 0x8219F710;
		  /* 8219F710h */ case    6:  		/* lwz R10, <#[R29]> */
		/* 8219F710h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8219F710h case    6:*/		return 0x8219F714;
		  /* 8219F714h */ case    7:  		/* lwz R30, <#[R29 + 12]> */
		/* 8219F714h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x0000000C) );
		/* 8219F714h case    7:*/		return 0x8219F718;
		  /* 8219F718h */ case    8:  		/* xor R11, R11, R10 */
		/* 8219F718h case    8:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219F718h case    8:*/		return 0x8219F71C;
		  /* 8219F71Ch */ case    9:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 8219F71Ch case    9:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219F71Ch case    9:*/		return 0x8219F720;
		  /* 8219F720h */ case   10:  		/* bc 4, CR0_EQ, 520 */
		/* 8219F720h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8219F928;  }
		/* 8219F720h case   10:*/		return 0x8219F724;
		  /* 8219F724h */ case   11:  		/* cmplw CR6, R30, R18 */
		/* 8219F724h case   11:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R18);
		/* 8219F724h case   11:*/		return 0x8219F728;
		  /* 8219F728h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 8219F728h case   12:*/		if ( regs.CR[6].eq ) { return 0x8219F750;  }
		/* 8219F728h case   12:*/		return 0x8219F72C;
		  /* 8219F72Ch */ case   13:  		/* lwz R11, <#[R27 + 8]> */
		/* 8219F72Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 8219F72Ch case   13:*/		return 0x8219F730;
		  /* 8219F730h */ case   14:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219F730h case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219F730h case   14:*/		return 0x8219F734;
		  /* 8219F734h */ case   15:  		/* cmplwi CR6, R11, 256 */
		/* 8219F734h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000100);
		/* 8219F734h case   15:*/		return 0x8219F738;
		  /* 8219F738h */ case   16:  		/* bc 4, CR6_EQ, 496 */
		/* 8219F738h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8219F928;  }
		/* 8219F738h case   16:*/		return 0x8219F73C;
		  /* 8219F73Ch */ case   17:  		/* mr R3, R26 */
		/* 8219F73Ch case   17:*/		regs.R3 = regs.R26;
		/* 8219F73Ch case   17:*/		return 0x8219F740;
		  /* 8219F740h */ case   18:  		/* fmr FR1, FR30 */
		/* 8219F740h case   18:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 8219F740h case   18:*/		return 0x8219F744;
		  /* 8219F744h */ case   19:  		/* bl -235924 */
		/* 8219F744h case   19:*/		regs.LR = 0x8219F748; return 0x82165DB0;
		/* 8219F744h case   19:*/		return 0x8219F748;
		  /* 8219F748h */ case   20:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8219F748h case   20:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8219F748h case   20:*/		return 0x8219F74C;
		  /* 8219F74Ch */ case   21:  		/* bc 12, CR0_EQ, 476 */
		/* 8219F74Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x8219F928;  }
		/* 8219F74Ch case   21:*/		return 0x8219F750;
	}
	return 0x8219F750;
} // Block from 8219F6F8h-8219F750h (22 instructions)

//////////////////////////////////////////////////////
// Block at 8219F750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F750);
		  /* 8219F750h */ case    0:  		/* lwz R31, <#[R21]> */
		/* 8219F750h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R21 + 0x00000000) );
		/* 8219F750h case    0:*/		return 0x8219F754;
		  /* 8219F754h */ case    1:  		/* lwz R11, <#[R31]> */
		/* 8219F754h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219F754h case    1:*/		return 0x8219F758;
		  /* 8219F758h */ case    2:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 8219F758h case    2:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8219F758h case    2:*/		return 0x8219F75C;
		  /* 8219F75Ch */ case    3:  		/* bc 4, CR0_EQ, 460 */
		/* 8219F75Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x8219F928;  }
		/* 8219F75Ch case    3:*/		return 0x8219F760;
		  /* 8219F760h */ case    4:  		/* lwz R28, <#[R31 + 12]> */
		/* 8219F760h case    4:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219F760h case    4:*/		return 0x8219F764;
		  /* 8219F764h */ case    5:  		/* addi R5, R1, 80 */
		/* 8219F764h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 8219F764h case    5:*/		return 0x8219F768;
		  /* 8219F768h */ case    6:  		/* addi R4, R1, 96 */
		/* 8219F768h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8219F768h case    6:*/		return 0x8219F76C;
		  /* 8219F76Ch */ case    7:  		/* mr R3, R28 */
		/* 8219F76Ch case    7:*/		regs.R3 = regs.R28;
		/* 8219F76Ch case    7:*/		return 0x8219F770;
		  /* 8219F770h */ case    8:  		/* bl 556240 */
		/* 8219F770h case    8:*/		regs.LR = 0x8219F774; return 0x82227440;
		/* 8219F770h case    8:*/		return 0x8219F774;
		  /* 8219F774h */ case    9:  		/* li R5, 0 */
		/* 8219F774h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8219F774h case    9:*/		return 0x8219F778;
		  /* 8219F778h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 8219F778h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8219F778h case   10:*/		return 0x8219F77C;
		  /* 8219F77Ch */ case   11:  		/* bc 12, CR0_EQ, 108 */
		/* 8219F77Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x8219F7E8;  }
		/* 8219F77Ch case   11:*/		return 0x8219F780;
		  /* 8219F780h */ case   12:  		/* lwz R8, <#[R29]> */
		/* 8219F780h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000000) );
		/* 8219F780h case   12:*/		return 0x8219F784;
		  /* 8219F784h */ case   13:  		/* li R7, 0 */
		/* 8219F784h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219F784h case   13:*/		return 0x8219F788;
		  /* 8219F788h */ case   14:  		/* rlwinm. R6, R8, 7, 29, 31 */
		/* 8219F788h case   14:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R6,regs.R8);
		/* 8219F788h case   14:*/		return 0x8219F78C;
		  /* 8219F78Ch */ case   15:  		/* bc 12, CR0_EQ, 92 */
		/* 8219F78Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x8219F7E8;  }
		/* 8219F78Ch case   15:*/		return 0x8219F790;
	}
	return 0x8219F790;
} // Block from 8219F750h-8219F790h (16 instructions)

//////////////////////////////////////////////////////
// Block at 8219F790h
// Function '?GetSpaceWorker@?$ArrayList@UPossibleVectorizationCandidate@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@D3DXShader@@AAAPAUArrayListEntry@12@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F790);
		  /* 8219F790h */ case    0:  		/* lwz R10, <#[R31]> */
		/* 8219F790h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8219F790h case    0:*/		return 0x8219F794;
		  /* 8219F794h */ case    1:  		/* li R11, 0 */
		/* 8219F794h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219F794h case    1:*/		return 0x8219F798;
		  /* 8219F798h */ case    2:  		/* rlwinm R9, R10, 27, 24, 31 */
		/* 8219F798h case    2:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R10);
		/* 8219F798h case    2:*/		return 0x8219F79C;
		  /* 8219F79Ch */ case    3:  		/* srw R10, R9, R11 */
		/* 8219F79Ch case    3:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R9,regs.R11);
		/* 8219F79Ch case    3:*/		return 0x8219F7A0;
		  /* 8219F7A0h */ case    4:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 8219F7A0h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 8219F7A0h case    4:*/		return 0x8219F7A4;
		  /* 8219F7A4h */ case    5:  		/* slw R4, R25, R10 */
		/* 8219F7A4h case    5:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R25,regs.R10);
		/* 8219F7A4h case    5:*/		return 0x8219F7A8;
		  /* 8219F7A8h */ case    6:  		/* and. R4, R4, R3 */
		/* 8219F7A8h case    6:*/		cpu::op::and<1>(regs,&regs.R4,regs.R4,regs.R3);
		/* 8219F7A8h case    6:*/		return 0x8219F7AC;
		  /* 8219F7ACh */ case    7:  		/* bc 12, CR0_EQ, 44 */
		/* 8219F7ACh case    7:*/		if ( regs.CR[0].eq ) { return 0x8219F7D8;  }
		/* 8219F7ACh case    7:*/		return 0x8219F7B0;
		  /* 8219F7B0h */ case    8:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 8219F7B0h case    8:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 8219F7B0h case    8:*/		return 0x8219F7B4;
		  /* 8219F7B4h */ case    9:  		/* addi R4, R1, 96 */
		/* 8219F7B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8219F7B4h case    9:*/		return 0x8219F7B8;
		  /* 8219F7B8h */ case   10:  		/* lfdx FR0, <#[R10 + R4]> */
		/* 8219F7B8h case   10:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 8219F7B8h case   10:*/		return 0x8219F7BC;
		  /* 8219F7BCh */ case   11:  		/* fcmpu CR6, FR31, FR0 */
		/* 8219F7BCh case   11:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 8219F7BCh case   11:*/		return 0x8219F7C0;
		  /* 8219F7C0h */ case   12:  		/* bc 4, CR6_EQ, 24 */
		/* 8219F7C0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8219F7D8;  }
		/* 8219F7C0h case   12:*/		return 0x8219F7C4;
		  /* 8219F7C4h */ case   13:  		/* rlwinm R10, R8, 27, 24, 31 */
		/* 8219F7C4h case   13:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R8);
		/* 8219F7C4h case   13:*/		return 0x8219F7C8;
		  /* 8219F7C8h */ case   14:  		/* srw R10, R10, R11 */
		/* 8219F7C8h case   14:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8219F7C8h case   14:*/		return 0x8219F7CC;
		  /* 8219F7CCh */ case   15:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 8219F7CCh case   15:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 8219F7CCh case   15:*/		return 0x8219F7D0;
		  /* 8219F7D0h */ case   16:  		/* slw R10, R25, R10 */
		/* 8219F7D0h case   16:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R25,regs.R10);
		/* 8219F7D0h case   16:*/		return 0x8219F7D4;
		  /* 8219F7D4h */ case   17:  		/* or R5, R10, R5 */
		/* 8219F7D4h case   17:*/		cpu::op::or<0>(regs,&regs.R5,regs.R10,regs.R5);
		/* 8219F7D4h case   17:*/		return 0x8219F7D8;
	}
	return 0x8219F7D8;
} // Block from 8219F790h-8219F7D8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219F7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F7D8);
		  /* 8219F7D8h */ case    0:  		/* addi R7, R7, 1 */
		/* 8219F7D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 8219F7D8h case    0:*/		return 0x8219F7DC;
		  /* 8219F7DCh */ case    1:  		/* addi R11, R11, 2 */
		/* 8219F7DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8219F7DCh case    1:*/		return 0x8219F7E0;
		  /* 8219F7E0h */ case    2:  		/* cmplw CR6, R7, R6 */
		/* 8219F7E0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 8219F7E0h case    2:*/		return 0x8219F7E4;
		  /* 8219F7E4h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 8219F7E4h case    3:*/		if ( regs.CR[6].lt ) { return 0x8219F79C;  }
		/* 8219F7E4h case    3:*/		return 0x8219F7E8;
	}
	return 0x8219F7E8;
} // Block from 8219F7D8h-8219F7E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219F7E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F7E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F7E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F7E8);
		  /* 8219F7E8h */ case    0:  		/* cmplw CR6, R30, R18 */
		/* 8219F7E8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R18);
		/* 8219F7E8h case    0:*/		return 0x8219F7EC;
		  /* 8219F7ECh */ case    1:  		/* bc 4, CR6_EQ, 112 */
		/* 8219F7ECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8219F85C;  }
		/* 8219F7ECh case    1:*/		return 0x8219F7F0;
		  /* 8219F7F0h */ case    2:  		/* lwz R8, <#[R26]> */
		/* 8219F7F0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000000) );
		/* 8219F7F0h case    2:*/		return 0x8219F7F4;
		  /* 8219F7F4h */ case    3:  		/* li R9, 0 */
		/* 8219F7F4h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8219F7F4h case    3:*/		return 0x8219F7F8;
		  /* 8219F7F8h */ case    4:  		/* li R11, 0 */
		/* 8219F7F8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8219F7F8h case    4:*/		return 0x8219F7FC;
		  /* 8219F7FCh */ case    5:  		/* rlwinm. R7, R8, 7, 29, 31 */
		/* 8219F7FCh case    5:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R7,regs.R8);
		/* 8219F7FCh case    5:*/		return 0x8219F800;
		  /* 8219F800h */ case    6:  		/* bc 12, CR0_EQ, 44 */
		/* 8219F800h case    6:*/		if ( regs.CR[0].eq ) { return 0x8219F82C;  }
		/* 8219F800h case    6:*/		return 0x8219F804;
		  /* 8219F804h */ case    7:  		/* li R10, 0 */
		/* 8219F804h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219F804h case    7:*/		return 0x8219F808;
		  /* 8219F808h */ case    8:  		/* rlwinm R6, R8, 27, 24, 31 */
		/* 8219F808h case    8:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R8);
		/* 8219F808h case    8:*/		return 0x8219F80C;
		  /* 8219F80Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 8219F80Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219F80Ch case    9:*/		return 0x8219F810;
		  /* 8219F810h */ case   10:  		/* srw R6, R6, R10 */
		/* 8219F810h case   10:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R6,regs.R10);
		/* 8219F810h case   10:*/		return 0x8219F814;
		  /* 8219F814h */ case   11:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 8219F814h case   11:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 8219F814h case   11:*/		return 0x8219F818;
	}
	return 0x8219F818;
} // Block from 8219F7E8h-8219F818h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219F818h
// Function '?AddToVectorizeQueue@Compiler@D3DXShader@@AAAXPAV?$Queue@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z$09@2@IPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F818);
		  /* 8219F818h */ case    0:  		/* addi R10, R10, 2 */
		/* 8219F818h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 8219F818h case    0:*/		return 0x8219F81C;
		  /* 8219F81Ch */ case    1:  		/* slw R6, R25, R6 */
		/* 8219F81Ch case    1:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R25,regs.R6);
		/* 8219F81Ch case    1:*/		return 0x8219F820;
		  /* 8219F820h */ case    2:  		/* or R9, R6, R9 */
		/* 8219F820h case    2:*/		cpu::op::or<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 8219F820h case    2:*/		return 0x8219F824;
		  /* 8219F824h */ case    3:  		/* cmplw CR6, R11, R7 */
		/* 8219F824h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 8219F824h case    3:*/		return 0x8219F828;
		  /* 8219F828h */ case    4:  		/* bc 12, CR6_LT, -32 */
		/* 8219F828h case    4:*/		if ( regs.CR[6].lt ) { return 0x8219F808;  }
		/* 8219F828h case    4:*/		return 0x8219F82C;
	}
	return 0x8219F82C;
} // Block from 8219F818h-8219F82Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219F82Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F82C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F82C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F82C);
		  /* 8219F82Ch */ case    0:  		/* lis R11, -28311 */
		/* 8219F82Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 8219F82Ch case    0:*/		return 0x8219F830;
		  /* 8219F830h */ case    1:  		/* lis R10, 0 */
		/* 8219F830h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 8219F830h case    1:*/		return 0x8219F834;
		  /* 8219F834h */ case    2:  		/* ori R11, R11, 5192 */
		/* 8219F834h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 8219F834h case    2:*/		return 0x8219F838;
		  /* 8219F838h */ case    3:  		/* ori R10, R10, 36262 */
		/* 8219F838h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 8219F838h case    3:*/		return 0x8219F83C;
		  /* 8219F83Ch */ case    4:  		/* andc R9, R9, R5 */
		/* 8219F83Ch case    4:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 8219F83Ch case    4:*/		return 0x8219F840;
		  /* 8219F840h */ case    5:  		/* rldimi R11, R10, 32, 0 */
		/* 8219F840h case    5:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 8219F840h case    5:*/		return 0x8219F844;
		  /* 8219F844h */ case    6:  		/* rldicl R10, R9, 0, 32 */
		/* 8219F844h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R9);
		/* 8219F844h case    6:*/		return 0x8219F848;
		  /* 8219F848h */ case    7:  		/* srd R11, R11, R10 */
		/* 8219F848h case    7:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219F848h case    7:*/		return 0x8219F84C;
		  /* 8219F84Ch */ case    8:  		/* srd R11, R11, R10 */
		/* 8219F84Ch case    8:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219F84Ch case    8:*/		return 0x8219F850;
		  /* 8219F850h */ case    9:  		/* srd R11, R11, R10 */
		/* 8219F850h case    9:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219F850h case    9:*/		return 0x8219F854;
		  /* 8219F854h */ case   10:  		/* rlwinm R31, R11, 0, 29, 31 */
		/* 8219F854h case   10:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R31,regs.R11);
		/* 8219F854h case   10:*/		return 0x8219F858;
		  /* 8219F858h */ case   11:  		/* b 12 */
		/* 8219F858h case   11:*/		return 0x8219F864;
		/* 8219F858h case   11:*/		return 0x8219F85C;
	}
	return 0x8219F85C;
} // Block from 8219F82Ch-8219F85Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219F85Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F85C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F85C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F85C);
		  /* 8219F85Ch */ case    0:  		/* lwz R11, <#[R26]> */
		/* 8219F85Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8219F85Ch case    0:*/		return 0x8219F860;
	}
	return 0x8219F860;
} // Block from 8219F85Ch-8219F860h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219F860h
// Function '?GetConstantValues@Dependency@D3DXShader@@QAAXQAN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F860);
		  /* 8219F860h */ case    0:  		/* rlwinm R31, R11, 7, 29, 31 */
		/* 8219F860h case    0:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R31,regs.R11);
		/* 8219F860h case    0:*/		return 0x8219F864;
	}
	return 0x8219F864;
} // Block from 8219F860h-8219F864h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219F864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F864);
		  /* 8219F864h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 8219F864h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8219F864h case    0:*/		return 0x8219F868;
		  /* 8219F868h */ case    1:  		/* bc 12, CR6_EQ, 132 */
		/* 8219F868h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219F8EC;  }
		/* 8219F868h case    1:*/		return 0x8219F86C;
		  /* 8219F86Ch */ case    2:  		/* lwz R11, <#[R29]> */
		/* 8219F86Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8219F86Ch case    2:*/		return 0x8219F870;
		  /* 8219F870h */ case    3:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 8219F870h case    3:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 8219F870h case    3:*/		return 0x8219F874;
		  /* 8219F874h */ case    4:  		/* add R11, R11, R31 */
		/* 8219F874h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8219F874h case    4:*/		return 0x8219F878;
		  /* 8219F878h */ case    5:  		/* cmplwi CR6, R11, 4 */
		/* 8219F878h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8219F878h case    5:*/		return 0x8219F87C;
		  /* 8219F87Ch */ case    6:  		/* bc 12, CR6_GT, 172 */
		/* 8219F87Ch case    6:*/		if ( regs.CR[6].gt ) { return 0x8219F928;  }
		/* 8219F87Ch case    6:*/		return 0x8219F880;
		  /* 8219F880h */ case    7:  		/* lwz R11, <#[R27 + 4]> */
		/* 8219F880h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 8219F880h case    7:*/		return 0x8219F884;
		  /* 8219F884h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 8219F884h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219F884h case    8:*/		return 0x8219F888;
		  /* 8219F888h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 8219F888h case    9:*/		if ( regs.CR[6].eq ) { return 0x8219F8BC;  }
		/* 8219F888h case    9:*/		return 0x8219F88C;
		  /* 8219F88Ch */ case   10:  		/* lwz R4, <#[R11 + 16]> */
		/* 8219F88Ch case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000010) );
		/* 8219F88Ch case   10:*/		return 0x8219F890;
		  /* 8219F890h */ case   11:  		/* cmplwi CR6, R4, 0 */
		/* 8219F890h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8219F890h case   11:*/		return 0x8219F894;
		  /* 8219F894h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 8219F894h case   12:*/		if ( regs.CR[6].eq ) { return 0x8219F8B4;  }
		/* 8219F894h case   12:*/		return 0x8219F898;
		  /* 8219F898h */ case   13:  		/* lwz R10, <#[R4 + 8]> */
		/* 8219F898h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 8219F898h case   13:*/		return 0x8219F89C;
		  /* 8219F89Ch */ case   14:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 8219F89Ch case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 8219F89Ch case   14:*/		return 0x8219F8A0;
		  /* 8219F8A0h */ case   15:  		/* cmplwi CR6, R10, 14080 */
		/* 8219F8A0h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 8219F8A0h case   15:*/		return 0x8219F8A4;
		  /* 8219F8A4h */ case   16:  		/* bc 4, CR6_EQ, 16 */
		/* 8219F8A4h case   16:*/		if ( !regs.CR[6].eq ) { return 0x8219F8B4;  }
		/* 8219F8A4h case   16:*/		return 0x8219F8A8;
		  /* 8219F8A8h */ case   17:  		/* lwz R10, <#[R11]> */
		/* 8219F8A8h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8219F8A8h case   17:*/		return 0x8219F8AC;
		  /* 8219F8ACh */ case   18:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 8219F8ACh case   18:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 8219F8ACh case   18:*/		return 0x8219F8B0;
		  /* 8219F8B0h */ case   19:  		/* bc 4, CR0_EQ, 16 */
		/* 8219F8B0h case   19:*/		if ( !regs.CR[0].eq ) { return 0x8219F8C0;  }
		/* 8219F8B0h case   19:*/		return 0x8219F8B4;
	}
	return 0x8219F8B4;
} // Block from 8219F864h-8219F8B4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219F8B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F8B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F8B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F8B4);
		  /* 8219F8B4h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219F8B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219F8B4h case    0:*/		return 0x8219F8B8;
		  /* 8219F8B8h */ case    1:  		/* b -52 */
		/* 8219F8B8h case    1:*/		return 0x8219F884;
		/* 8219F8B8h case    1:*/		return 0x8219F8BC;
	}
	return 0x8219F8BC;
} // Block from 8219F8B4h-8219F8BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219F8BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F8BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F8BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F8BC);
		  /* 8219F8BCh */ case    0:  		/* li R4, 0 */
		/* 8219F8BCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8219F8BCh case    0:*/		return 0x8219F8C0;
	}
	return 0x8219F8C0;
} // Block from 8219F8BCh-8219F8C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219F8C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F8C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F8C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F8C0);
		  /* 8219F8C0h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 8219F8C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8219F8C0h case    0:*/		return 0x8219F8C4;
		  /* 8219F8C4h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 8219F8C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219F8EC;  }
		/* 8219F8C4h case    1:*/		return 0x8219F8C8;
		  /* 8219F8C8h */ case    2:  		/* li R7, 0 */
		/* 8219F8C8h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8219F8C8h case    2:*/		return 0x8219F8CC;
		  /* 8219F8CCh */ case    3:  		/* li R6, 0 */
		/* 8219F8CCh case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8219F8CCh case    3:*/		return 0x8219F8D0;
		  /* 8219F8D0h */ case    4:  		/* mr R5, R27 */
		/* 8219F8D0h case    4:*/		regs.R5 = regs.R27;
		/* 8219F8D0h case    4:*/		return 0x8219F8D4;
		  /* 8219F8D4h */ case    5:  		/* mr R3, R20 */
		/* 8219F8D4h case    5:*/		regs.R3 = regs.R20;
		/* 8219F8D4h case    5:*/		return 0x8219F8D8;
		  /* 8219F8D8h */ case    6:  		/* bl -17280 */
		/* 8219F8D8h case    6:*/		regs.LR = 0x8219F8DC; return 0x8219B558;
		/* 8219F8D8h case    6:*/		return 0x8219F8DC;
		  /* 8219F8DCh */ case    7:  		/* subf R11, R19, R31 */
		/* 8219F8DCh case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R19,regs.R31);
		/* 8219F8DCh case    7:*/		return 0x8219F8E0;
		  /* 8219F8E0h */ case    8:  		/* add R11, R3, R11 */
		/* 8219F8E0h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8219F8E0h case    8:*/		return 0x8219F8E4;
		  /* 8219F8E4h */ case    9:  		/* cmplwi CR6, R11, 4 */
		/* 8219F8E4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 8219F8E4h case    9:*/		return 0x8219F8E8;
		  /* 8219F8E8h */ case   10:  		/* bc 12, CR6_GT, 64 */
		/* 8219F8E8h case   10:*/		if ( regs.CR[6].gt ) { return 0x8219F928;  }
		/* 8219F8E8h case   10:*/		return 0x8219F8EC;
	}
	return 0x8219F8EC;
} // Block from 8219F8C0h-8219F8ECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219F8ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F8EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F8EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F8EC);
		  /* 8219F8ECh */ case    0:  		/* lwz R11, <#[R22]> */
		/* 8219F8ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8219F8ECh case    0:*/		return 0x8219F8F0;
		  /* 8219F8F0h */ case    1:  		/* rlwimi R11, R31, 21, 9, 10 */
		/* 8219F8F0h case    1:*/		cpu::op::rlwimi<0,21,9,10>(regs,&regs.R11,regs.R31);
		/* 8219F8F0h case    1:*/		return 0x8219F8F4;
		  /* 8219F8F4h */ case    2:  		/* stw R11, <#[R22]> */
		/* 8219F8F4h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8219F8F4h case    2:*/		return 0x8219F8F8;
		  /* 8219F8F8h */ case    3:  		/* lwz R10, <#[R28 + 8]> */
		/* 8219F8F8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 8219F8F8h case    3:*/		return 0x8219F8FC;
		  /* 8219F8FCh */ case    4:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 8219F8FCh case    4:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 8219F8FCh case    4:*/		return 0x8219F900;
		  /* 8219F900h */ case    5:  		/* cmplwi CR6, R10, 16000 */
		/* 8219F900h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003E80);
		/* 8219F900h case    5:*/		return 0x8219F904;
		  /* 8219F904h */ case    6:  		/* bc 12, CR6_EQ, 76 */
		/* 8219F904h case    6:*/		if ( regs.CR[6].eq ) { return 0x8219F950;  }
		/* 8219F904h case    6:*/		return 0x8219F908;
		  /* 8219F908h */ case    7:  		/* mr R7, R17 */
		/* 8219F908h case    7:*/		regs.R7 = regs.R17;
		/* 8219F908h case    7:*/		return 0x8219F90C;
		  /* 8219F90Ch */ case    8:  		/* fmr FR1, FR31 */
		/* 8219F90Ch case    8:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8219F90Ch case    8:*/		return 0x8219F910;
		  /* 8219F910h */ case    9:  		/* li R6, 0 */
		/* 8219F910h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8219F910h case    9:*/		return 0x8219F914;
		  /* 8219F914h */ case   10:  		/* mr R4, R28 */
		/* 8219F914h case   10:*/		regs.R4 = regs.R28;
		/* 8219F914h case   10:*/		return 0x8219F918;
	}
	return 0x8219F918;
} // Block from 8219F8ECh-8219F918h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8219F918h
// Function '?FindRedundantComputations@Compiler@D3DXShader@@AAA_NPAVInstruction@2@0PAURedundantComputationState@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F918);
		  /* 8219F918h */ case    0:  		/* mr R3, R20 */
		/* 8219F918h case    0:*/		regs.R3 = regs.R20;
		/* 8219F918h case    0:*/		return 0x8219F91C;
		  /* 8219F91Ch */ case    1:  		/* bl 577268 */
		/* 8219F91Ch case    1:*/		regs.LR = 0x8219F920; return 0x8222C810;
		/* 8219F91Ch case    1:*/		return 0x8219F920;
		  /* 8219F920h */ case    2:  		/* cmpwi CR6, R3, 4 */
		/* 8219F920h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 8219F920h case    2:*/		return 0x8219F924;
		  /* 8219F924h */ case    3:  		/* bc 4, CR6_EQ, 60 */
		/* 8219F924h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219F960;  }
		/* 8219F924h case    3:*/		return 0x8219F928;
	}
	return 0x8219F928;
} // Block from 8219F918h-8219F928h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219F928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F928);
		  /* 8219F928h */ case    0:  		/* addi R24, R24, 1 */
		/* 8219F928h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 8219F928h case    0:*/		return 0x8219F92C;
		  /* 8219F92Ch */ case    1:  		/* addi R23, R23, 4 */
		/* 8219F92Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x4);
		/* 8219F92Ch case    1:*/		return 0x8219F930;
		  /* 8219F930h */ case    2:  		/* addi R21, R21, -4 */
		/* 8219F930h case    2:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0xFFFFFFFC);
		/* 8219F930h case    2:*/		return 0x8219F934;
		  /* 8219F934h */ case    3:  		/* cmplwi CR6, R24, 2 */
		/* 8219F934h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000002);
		/* 8219F934h case    3:*/		return 0x8219F938;
		  /* 8219F938h */ case    4:  		/* bc 12, CR6_LT, -560 */
		/* 8219F938h case    4:*/		if ( regs.CR[6].lt ) { return 0x8219F708;  }
		/* 8219F938h case    4:*/		return 0x8219F93C;
	}
	return 0x8219F93C;
} // Block from 8219F928h-8219F93Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219F93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F93C);
		  /* 8219F93Ch */ case    0:  		/* li R3, 0 */
		/* 8219F93Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219F93Ch case    0:*/		return 0x8219F940;
		  /* 8219F940h */ case    1:  		/* addi R1, R1, 272 */
		/* 8219F940h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x110);
		/* 8219F940h case    1:*/		return 0x8219F944;
		  /* 8219F944h */ case    2:  		/* lfd FR30, <#[R1 - 144]> */
		/* 8219F944h case    2:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFF70) );
		/* 8219F944h case    2:*/		return 0x8219F948;
		  /* 8219F948h */ case    3:  		/* lfd FR31, <#[R1 - 136]> */
		/* 8219F948h case    3:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF78) );
		/* 8219F948h case    3:*/		return 0x8219F94C;
		  /* 8219F94Ch */ case    4:  		/* b -1107664 */
		/* 8219F94Ch case    4:*/		return 0x8209127C;
		/* 8219F94Ch case    4:*/		return 0x8219F950;
	}
	return 0x8219F950;
} // Block from 8219F93Ch-8219F950h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8219F950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F950);
		  /* 8219F950h */ case    0:  		/* rlwimi R11, R24, 20, 11, 11 */
		/* 8219F950h case    0:*/		cpu::op::rlwimi<0,20,11,11>(regs,&regs.R11,regs.R24);
		/* 8219F950h case    0:*/		return 0x8219F954;
		  /* 8219F954h */ case    1:  		/* li R3, 1 */
		/* 8219F954h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219F954h case    1:*/		return 0x8219F958;
		  /* 8219F958h */ case    2:  		/* stw R11, <#[R22]> */
		/* 8219F958h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8219F958h case    2:*/		return 0x8219F95C;
		  /* 8219F95Ch */ case    3:  		/* b -28 */
		/* 8219F95Ch case    3:*/		return 0x8219F940;
		/* 8219F95Ch case    3:*/		return 0x8219F960;
	}
	return 0x8219F960;
} // Block from 8219F950h-8219F960h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219F960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F960);
		  /* 8219F960h */ case    0:  		/* lwz R11, <#[R22]> */
		/* 8219F960h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 8219F960h case    0:*/		return 0x8219F964;
		  /* 8219F964h */ case    1:  		/* b -20 */
		/* 8219F964h case    1:*/		return 0x8219F950;
		/* 8219F964h case    1:*/		return 0x8219F968;
	}
	return 0x8219F968;
} // Block from 8219F960h-8219F968h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219F968h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F968);
		  /* 8219F968h */ case    0:  		/* mfspr R12, LR */
		/* 8219F968h case    0:*/		regs.R12 = regs.LR;
		/* 8219F968h case    0:*/		return 0x8219F96C;
		  /* 8219F96Ch */ case    1:  		/* bl -1107776 */
		/* 8219F96Ch case    1:*/		regs.LR = 0x8219F970; return 0x8209122C;
		/* 8219F96Ch case    1:*/		return 0x8219F970;
		  /* 8219F970h */ case    2:  		/* stfd FR31, <#[R1 - 136]> */
		/* 8219F970h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF78) );
		/* 8219F970h case    2:*/		return 0x8219F974;
		  /* 8219F974h */ case    3:  		/* stwu R1, <#[R1 - 352]> */
		/* 8219F974h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEA0);
		/* 8219F974h case    3:*/		return 0x8219F978;
		  /* 8219F978h */ case    4:  		/* lwz R31, <#[R4]> */
		/* 8219F978h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000000) );
		/* 8219F978h case    4:*/		return 0x8219F97C;
		  /* 8219F97Ch */ case    5:  		/* addi R11, R1, 80 */
		/* 8219F97Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8219F97Ch case    5:*/		return 0x8219F980;
		  /* 8219F980h */ case    6:  		/* li R18, 0 */
		/* 8219F980h case    6:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 8219F980h case    6:*/		return 0x8219F984;
		  /* 8219F984h */ case    7:  		/* lwz R27, <#[R5]> */
		/* 8219F984h case    7:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R5 + 0x00000000) );
		/* 8219F984h case    7:*/		return 0x8219F988;
		  /* 8219F988h */ case    8:  		/* lwz R24, <#[R6]> */
		/* 8219F988h case    8:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R6 + 0x00000000) );
		/* 8219F988h case    8:*/		return 0x8219F98C;
		  /* 8219F98Ch */ case    9:  		/* mr R21, R3 */
		/* 8219F98Ch case    9:*/		regs.R21 = regs.R3;
		/* 8219F98Ch case    9:*/		return 0x8219F990;
		  /* 8219F990h */ case   10:  		/* mr R28, R4 */
		/* 8219F990h case   10:*/		regs.R28 = regs.R4;
		/* 8219F990h case   10:*/		return 0x8219F994;
		  /* 8219F994h */ case   11:  		/* mr R26, R5 */
		/* 8219F994h case   11:*/		regs.R26 = regs.R5;
		/* 8219F994h case   11:*/		return 0x8219F998;
		  /* 8219F998h */ case   12:  		/* lwz R30, <#[R31 + 12]> */
		/* 8219F998h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 8219F998h case   12:*/		return 0x8219F99C;
		  /* 8219F99Ch */ case   13:  		/* mr R23, R6 */
		/* 8219F99Ch case   13:*/		regs.R23 = regs.R6;
		/* 8219F99Ch case   13:*/		return 0x8219F9A0;
		  /* 8219F9A0h */ case   14:  		/* stw R18, <#[R11]> */
		/* 8219F9A0h case   14:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000000) );
		/* 8219F9A0h case   14:*/		return 0x8219F9A4;
		  /* 8219F9A4h */ case   15:  		/* li R17, 1 */
		/* 8219F9A4h case   15:*/		cpu::op::li<0>(regs,&regs.R17,0x1);
		/* 8219F9A4h case   15:*/		return 0x8219F9A8;
		  /* 8219F9A8h */ case   16:  		/* lwz R25, <#[R27 + 12]> */
		/* 8219F9A8h case   16:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R27 + 0x0000000C) );
		/* 8219F9A8h case   16:*/		return 0x8219F9AC;
		  /* 8219F9ACh */ case   17:  		/* mr R29, R18 */
		/* 8219F9ACh case   17:*/		regs.R29 = regs.R18;
		/* 8219F9ACh case   17:*/		return 0x8219F9B0;
		  /* 8219F9B0h */ case   18:  		/* lwz R22, <#[R24 + 12]> */
		/* 8219F9B0h case   18:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R24 + 0x0000000C) );
		/* 8219F9B0h case   18:*/		return 0x8219F9B4;
		  /* 8219F9B4h */ case   19:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219F9B4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219F9B4h case   19:*/		return 0x8219F9B8;
		  /* 8219F9B8h */ case   20:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219F9B8h case   20:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219F9B8h case   20:*/		return 0x8219F9BC;
		  /* 8219F9BCh */ case   21:  		/* cmplwi CR6, R11, 125 */
		/* 8219F9BCh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219F9BCh case   21:*/		return 0x8219F9C0;
		  /* 8219F9C0h */ case   22:  		/* bc 12, CR6_EQ, 16 */
		/* 8219F9C0h case   22:*/		if ( regs.CR[6].eq ) { return 0x8219F9D0;  }
		/* 8219F9C0h case   22:*/		return 0x8219F9C4;
		  /* 8219F9C4h */ case   23:  		/* cmplwi CR6, R11, 124 */
		/* 8219F9C4h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219F9C4h case   23:*/		return 0x8219F9C8;
		  /* 8219F9C8h */ case   24:  		/* mr R11, R18 */
		/* 8219F9C8h case   24:*/		regs.R11 = regs.R18;
		/* 8219F9C8h case   24:*/		return 0x8219F9CC;
		  /* 8219F9CCh */ case   25:  		/* bc 4, CR6_EQ, 8 */
		/* 8219F9CCh case   25:*/		if ( !regs.CR[6].eq ) { return 0x8219F9D4;  }
		/* 8219F9CCh case   25:*/		return 0x8219F9D0;
	}
	return 0x8219F9D0;
} // Block from 8219F968h-8219F9D0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8219F9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F9D0);
		  /* 8219F9D0h */ case    0:  		/* mr R11, R17 */
		/* 8219F9D0h case    0:*/		regs.R11 = regs.R17;
		/* 8219F9D0h case    0:*/		return 0x8219F9D4;
	}
	return 0x8219F9D4;
} // Block from 8219F9D0h-8219F9D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219F9D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219F9D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219F9D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219F9D4);
		  /* 8219F9D4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219F9D4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219F9D4h case    0:*/		return 0x8219F9D8;
		  /* 8219F9D8h */ case    1:  		/* bc 12, CR0_EQ, 64 */
		/* 8219F9D8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219FA18;  }
		/* 8219F9D8h case    1:*/		return 0x8219F9DC;
		  /* 8219F9DCh */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8219F9DCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219F9DCh case    2:*/		return 0x8219F9E0;
		  /* 8219F9E0h */ case    3:  		/* addi R8, R1, 160 */
		/* 8219F9E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xA0);
		/* 8219F9E0h case    3:*/		return 0x8219F9E4;
		  /* 8219F9E4h */ case    4:  		/* mr R4, R30 */
		/* 8219F9E4h case    4:*/		regs.R4 = regs.R30;
		/* 8219F9E4h case    4:*/		return 0x8219F9E8;
		  /* 8219F9E8h */ case    5:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 8219F9E8h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 8219F9E8h case    5:*/		return 0x8219F9EC;
		  /* 8219F9ECh */ case    6:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 8219F9ECh case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 8219F9ECh case    6:*/		return 0x8219F9F0;
		  /* 8219F9F0h */ case    7:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 8219F9F0h case    7:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 8219F9F0h case    7:*/		return 0x8219F9F4;
		  /* 8219F9F4h */ case    8:  		/* mr R3, R21 */
		/* 8219F9F4h case    8:*/		regs.R3 = regs.R21;
		/* 8219F9F4h case    8:*/		return 0x8219F9F8;
		  /* 8219F9F8h */ case    9:  		/* bl -18296 */
		/* 8219F9F8h case    9:*/		regs.LR = 0x8219F9FC; return 0x8219B280;
		/* 8219F9F8h case    9:*/		return 0x8219F9FC;
		  /* 8219F9FCh */ case   10:  		/* lwz R11, <#[R1 + 80]> */
		/* 8219F9FCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8219F9FCh case   10:*/		return 0x8219FA00;
		  /* 8219FA00h */ case   11:  		/* stw R31, <#[R1 + 88]> */
		/* 8219FA00h case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000058) );
		/* 8219FA00h case   11:*/		return 0x8219FA04;
		  /* 8219FA04h */ case   12:  		/* mr R29, R17 */
		/* 8219FA04h case   12:*/		regs.R29 = regs.R17;
		/* 8219FA04h case   12:*/		return 0x8219FA08;
		  /* 8219FA08h */ case   13:  		/* or R11, R3, R11 */
		/* 8219FA08h case   13:*/		cpu::op::or<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8219FA08h case   13:*/		return 0x8219FA0C;
		  /* 8219FA0Ch */ case   14:  		/* stw R30, <#[R1 + 104]> */
		/* 8219FA0Ch case   14:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000068) );
		/* 8219FA0Ch case   14:*/		return 0x8219FA10;
		  /* 8219FA10h */ case   15:  		/* stw R28, <#[R1 + 120]> */
		/* 8219FA10h case   15:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000078) );
		/* 8219FA10h case   15:*/		return 0x8219FA14;
		  /* 8219FA14h */ case   16:  		/* stw R11, <#[R1 + 80]> */
		/* 8219FA14h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8219FA14h case   16:*/		return 0x8219FA18;
	}
	return 0x8219FA18;
} // Block from 8219F9D4h-8219FA18h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219FA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FA18);
		  /* 8219FA18h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 8219FA18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8219FA18h case    0:*/		return 0x8219FA1C;
		  /* 8219FA1Ch */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219FA1Ch case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219FA1Ch case    1:*/		return 0x8219FA20;
		  /* 8219FA20h */ case    2:  		/* cmplwi CR6, R11, 125 */
		/* 8219FA20h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219FA20h case    2:*/		return 0x8219FA24;
		  /* 8219FA24h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8219FA24h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219FA34;  }
		/* 8219FA24h case    3:*/		return 0x8219FA28;
		  /* 8219FA28h */ case    4:  		/* cmplwi CR6, R11, 124 */
		/* 8219FA28h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219FA28h case    4:*/		return 0x8219FA2C;
		  /* 8219FA2Ch */ case    5:  		/* mr R11, R18 */
		/* 8219FA2Ch case    5:*/		regs.R11 = regs.R18;
		/* 8219FA2Ch case    5:*/		return 0x8219FA30;
		  /* 8219FA30h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 8219FA30h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219FA38;  }
		/* 8219FA30h case    6:*/		return 0x8219FA34;
	}
	return 0x8219FA34;
} // Block from 8219FA18h-8219FA34h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219FA34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FA34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FA34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FA34);
		  /* 8219FA34h */ case    0:  		/* mr R11, R17 */
		/* 8219FA34h case    0:*/		regs.R11 = regs.R17;
		/* 8219FA34h case    0:*/		return 0x8219FA38;
	}
	return 0x8219FA38;
} // Block from 8219FA34h-8219FA38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219FA38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FA38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FA38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FA38);
		  /* 8219FA38h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219FA38h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219FA38h case    0:*/		return 0x8219FA3C;
		  /* 8219FA3Ch */ case    1:  		/* bc 12, CR0_EQ, 104 */
		/* 8219FA3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219FAA4;  }
		/* 8219FA3Ch case    1:*/		return 0x8219FA40;
		  /* 8219FA40h */ case    2:  		/* lwz R9, <#[R27]> */
		/* 8219FA40h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 8219FA40h case    2:*/		return 0x8219FA44;
		  /* 8219FA44h */ case    3:  		/* rlwinm R10, R29, 4, 0, 27 */
		/* 8219FA44h case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R29);
		/* 8219FA44h case    3:*/		return 0x8219FA48;
		  /* 8219FA48h */ case    4:  		/* addi R11, R1, 160 */
		/* 8219FA48h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 8219FA48h case    4:*/		return 0x8219FA4C;
		  /* 8219FA4Ch */ case    5:  		/* rlwinm R7, R9, 0, 27, 31 */
		/* 8219FA4Ch case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R9);
		/* 8219FA4Ch case    5:*/		return 0x8219FA50;
		  /* 8219FA50h */ case    6:  		/* rlwinm R6, R9, 27, 24, 31 */
		/* 8219FA50h case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R9);
		/* 8219FA50h case    6:*/		return 0x8219FA54;
		  /* 8219FA54h */ case    7:  		/* rlwinm R5, R9, 7, 29, 31 */
		/* 8219FA54h case    7:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R9);
		/* 8219FA54h case    7:*/		return 0x8219FA58;
		  /* 8219FA58h */ case    8:  		/* add R8, R10, R11 */
		/* 8219FA58h case    8:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 8219FA58h case    8:*/		return 0x8219FA5C;
		  /* 8219FA5Ch */ case    9:  		/* mr R4, R25 */
		/* 8219FA5Ch case    9:*/		regs.R4 = regs.R25;
		/* 8219FA5Ch case    9:*/		return 0x8219FA60;
		  /* 8219FA60h */ case   10:  		/* mr R3, R21 */
		/* 8219FA60h case   10:*/		regs.R3 = regs.R21;
		/* 8219FA60h case   10:*/		return 0x8219FA64;
		  /* 8219FA64h */ case   11:  		/* rlwinm R30, R29, 31, 3, 29 */
		/* 8219FA64h case   11:*/		cpu::op::rlwinm<0,31,3,29>(regs,&regs.R30,regs.R29);
		/* 8219FA64h case   11:*/		return 0x8219FA68;
		  /* 8219FA68h */ case   12:  		/* addi R31, R1, 80 */
		/* 8219FA68h case   12:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x50);
		/* 8219FA68h case   12:*/		return 0x8219FA6C;
		  /* 8219FA6Ch */ case   13:  		/* rlwinm R28, R29, 2, 0, 29 */
		/* 8219FA6Ch case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R29);
		/* 8219FA6Ch case   13:*/		return 0x8219FA70;
		  /* 8219FA70h */ case   14:  		/* bl -18416 */
		/* 8219FA70h case   14:*/		regs.LR = 0x8219FA74; return 0x8219B280;
		/* 8219FA70h case   14:*/		return 0x8219FA74;
		  /* 8219FA74h */ case   15:  		/* rlwinm R11, R29, 2, 27, 29 */
		/* 8219FA74h case   15:*/		cpu::op::rlwinm<0,2,27,29>(regs,&regs.R11,regs.R29);
		/* 8219FA74h case   15:*/		return 0x8219FA78;
		  /* 8219FA78h */ case   16:  		/* lwzx R10, <#[R30 + R31]> */
		/* 8219FA78h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 8219FA78h case   16:*/		return 0x8219FA7C;
		  /* 8219FA7Ch */ case   17:  		/* addi R9, R1, 88 */
		/* 8219FA7Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 8219FA7Ch case   17:*/		return 0x8219FA80;
		  /* 8219FA80h */ case   18:  		/* addi R8, R1, 104 */
		/* 8219FA80h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x68);
		/* 8219FA80h case   18:*/		return 0x8219FA84;
		  /* 8219FA84h */ case   19:  		/* slw R11, R3, R11 */
		/* 8219FA84h case   19:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8219FA84h case   19:*/		return 0x8219FA88;
		  /* 8219FA88h */ case   20:  		/* addi R7, R1, 120 */
		/* 8219FA88h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x78);
		/* 8219FA88h case   20:*/		return 0x8219FA8C;
		  /* 8219FA8Ch */ case   21:  		/* stwx R27, <#[R28 + R9]> */
		/* 8219FA8Ch case   21:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R28 + regs.R9 + 0x00000000) );
		/* 8219FA8Ch case   21:*/		return 0x8219FA90;
		  /* 8219FA90h */ case   22:  		/* or R11, R11, R10 */
		/* 8219FA90h case   22:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219FA90h case   22:*/		return 0x8219FA94;
		  /* 8219FA94h */ case   23:  		/* stwx R25, <#[R28 + R8]> */
		/* 8219FA94h case   23:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R28 + regs.R8 + 0x00000000) );
		/* 8219FA94h case   23:*/		return 0x8219FA98;
		  /* 8219FA98h */ case   24:  		/* addi R29, R29, 1 */
		/* 8219FA98h case   24:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8219FA98h case   24:*/		return 0x8219FA9C;
		  /* 8219FA9Ch */ case   25:  		/* stwx R11, <#[R30 + R31]> */
		/* 8219FA9Ch case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 8219FA9Ch case   25:*/		return 0x8219FAA0;
		  /* 8219FAA0h */ case   26:  		/* stwx R26, <#[R28 + R7]> */
		/* 8219FAA0h case   26:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R28 + regs.R7 + 0x00000000) );
		/* 8219FAA0h case   26:*/		return 0x8219FAA4;
	}
	return 0x8219FAA4;
} // Block from 8219FA38h-8219FAA4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8219FAA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FAA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FAA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FAA4);
		  /* 8219FAA4h */ case    0:  		/* lwz R11, <#[R22 + 8]> */
		/* 8219FAA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 8219FAA4h case    0:*/		return 0x8219FAA8;
		  /* 8219FAA8h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219FAA8h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219FAA8h case    1:*/		return 0x8219FAAC;
		  /* 8219FAACh */ case    2:  		/* cmplwi CR6, R11, 125 */
		/* 8219FAACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219FAACh case    2:*/		return 0x8219FAB0;
		  /* 8219FAB0h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8219FAB0h case    3:*/		if ( regs.CR[6].eq ) { return 0x8219FAC0;  }
		/* 8219FAB0h case    3:*/		return 0x8219FAB4;
		  /* 8219FAB4h */ case    4:  		/* cmplwi CR6, R11, 124 */
		/* 8219FAB4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219FAB4h case    4:*/		return 0x8219FAB8;
		  /* 8219FAB8h */ case    5:  		/* mr R11, R18 */
		/* 8219FAB8h case    5:*/		regs.R11 = regs.R18;
		/* 8219FAB8h case    5:*/		return 0x8219FABC;
		  /* 8219FABCh */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 8219FABCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x8219FAC4;  }
		/* 8219FABCh case    6:*/		return 0x8219FAC0;
	}
	return 0x8219FAC0;
} // Block from 8219FAA4h-8219FAC0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8219FAC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FAC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FAC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FAC0);
		  /* 8219FAC0h */ case    0:  		/* mr R11, R17 */
		/* 8219FAC0h case    0:*/		regs.R11 = regs.R17;
		/* 8219FAC0h case    0:*/		return 0x8219FAC4;
	}
	return 0x8219FAC4;
} // Block from 8219FAC0h-8219FAC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219FAC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FAC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FAC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FAC4);
		  /* 8219FAC4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219FAC4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219FAC4h case    0:*/		return 0x8219FAC8;
		  /* 8219FAC8h */ case    1:  		/* bc 12, CR0_EQ, 104 */
		/* 8219FAC8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219FB30;  }
		/* 8219FAC8h case    1:*/		return 0x8219FACC;
		  /* 8219FACCh */ case    2:  		/* lwz R9, <#[R24]> */
		/* 8219FACCh case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000000) );
		/* 8219FACCh case    2:*/		return 0x8219FAD0;
		  /* 8219FAD0h */ case    3:  		/* rlwinm R10, R29, 4, 0, 27 */
		/* 8219FAD0h case    3:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R29);
		/* 8219FAD0h case    3:*/		return 0x8219FAD4;
		  /* 8219FAD4h */ case    4:  		/* addi R11, R1, 160 */
		/* 8219FAD4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xA0);
		/* 8219FAD4h case    4:*/		return 0x8219FAD8;
		  /* 8219FAD8h */ case    5:  		/* rlwinm R7, R9, 0, 27, 31 */
		/* 8219FAD8h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R9);
		/* 8219FAD8h case    5:*/		return 0x8219FADC;
		  /* 8219FADCh */ case    6:  		/* rlwinm R6, R9, 27, 24, 31 */
		/* 8219FADCh case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R9);
		/* 8219FADCh case    6:*/		return 0x8219FAE0;
		  /* 8219FAE0h */ case    7:  		/* rlwinm R5, R9, 7, 29, 31 */
		/* 8219FAE0h case    7:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R9);
		/* 8219FAE0h case    7:*/		return 0x8219FAE4;
		  /* 8219FAE4h */ case    8:  		/* add R8, R10, R11 */
		/* 8219FAE4h case    8:*/		cpu::op::add<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 8219FAE4h case    8:*/		return 0x8219FAE8;
		  /* 8219FAE8h */ case    9:  		/* mr R4, R22 */
		/* 8219FAE8h case    9:*/		regs.R4 = regs.R22;
		/* 8219FAE8h case    9:*/		return 0x8219FAEC;
		  /* 8219FAECh */ case   10:  		/* mr R3, R21 */
		/* 8219FAECh case   10:*/		regs.R3 = regs.R21;
		/* 8219FAECh case   10:*/		return 0x8219FAF0;
		  /* 8219FAF0h */ case   11:  		/* rlwinm R30, R29, 31, 3, 29 */
		/* 8219FAF0h case   11:*/		cpu::op::rlwinm<0,31,3,29>(regs,&regs.R30,regs.R29);
		/* 8219FAF0h case   11:*/		return 0x8219FAF4;
		  /* 8219FAF4h */ case   12:  		/* addi R31, R1, 80 */
		/* 8219FAF4h case   12:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x50);
		/* 8219FAF4h case   12:*/		return 0x8219FAF8;
		  /* 8219FAF8h */ case   13:  		/* rlwinm R28, R29, 2, 0, 29 */
		/* 8219FAF8h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R29);
		/* 8219FAF8h case   13:*/		return 0x8219FAFC;
		  /* 8219FAFCh */ case   14:  		/* bl -18556 */
		/* 8219FAFCh case   14:*/		regs.LR = 0x8219FB00; return 0x8219B280;
		/* 8219FAFCh case   14:*/		return 0x8219FB00;
		  /* 8219FB00h */ case   15:  		/* rlwinm R11, R29, 2, 27, 29 */
		/* 8219FB00h case   15:*/		cpu::op::rlwinm<0,2,27,29>(regs,&regs.R11,regs.R29);
		/* 8219FB00h case   15:*/		return 0x8219FB04;
		  /* 8219FB04h */ case   16:  		/* lwzx R10, <#[R30 + R31]> */
		/* 8219FB04h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 8219FB04h case   16:*/		return 0x8219FB08;
		  /* 8219FB08h */ case   17:  		/* addi R9, R1, 88 */
		/* 8219FB08h case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 8219FB08h case   17:*/		return 0x8219FB0C;
		  /* 8219FB0Ch */ case   18:  		/* addi R8, R1, 104 */
		/* 8219FB0Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x68);
		/* 8219FB0Ch case   18:*/		return 0x8219FB10;
		  /* 8219FB10h */ case   19:  		/* slw R11, R3, R11 */
		/* 8219FB10h case   19:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 8219FB10h case   19:*/		return 0x8219FB14;
		  /* 8219FB14h */ case   20:  		/* addi R7, R1, 120 */
		/* 8219FB14h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x78);
		/* 8219FB14h case   20:*/		return 0x8219FB18;
		  /* 8219FB18h */ case   21:  		/* stwx R24, <#[R28 + R9]> */
		/* 8219FB18h case   21:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R28 + regs.R9 + 0x00000000) );
		/* 8219FB18h case   21:*/		return 0x8219FB1C;
		  /* 8219FB1Ch */ case   22:  		/* or R11, R11, R10 */
		/* 8219FB1Ch case   22:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8219FB1Ch case   22:*/		return 0x8219FB20;
		  /* 8219FB20h */ case   23:  		/* stwx R22, <#[R28 + R8]> */
		/* 8219FB20h case   23:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R28 + regs.R8 + 0x00000000) );
		/* 8219FB20h case   23:*/		return 0x8219FB24;
		  /* 8219FB24h */ case   24:  		/* addi R29, R29, 1 */
		/* 8219FB24h case   24:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 8219FB24h case   24:*/		return 0x8219FB28;
		  /* 8219FB28h */ case   25:  		/* stwx R11, <#[R30 + R31]> */
		/* 8219FB28h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 8219FB28h case   25:*/		return 0x8219FB2C;
		  /* 8219FB2Ch */ case   26:  		/* stwx R23, <#[R28 + R7]> */
		/* 8219FB2Ch case   26:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R28 + regs.R7 + 0x00000000) );
		/* 8219FB2Ch case   26:*/		return 0x8219FB30;
	}
	return 0x8219FB30;
} // Block from 8219FAC4h-8219FB30h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8219FB30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FB30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FB30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FB30);
		  /* 8219FB30h */ case    0:  		/* cmplwi CR6, R29, 1 */
		/* 8219FB30h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000001);
		/* 8219FB30h case    0:*/		return 0x8219FB34;
		  /* 8219FB34h */ case    1:  		/* bc 12, CR6_EQ, 732 */
		/* 8219FB34h case    1:*/		if ( regs.CR[6].eq ) { return 0x8219FE10;  }
		/* 8219FB34h case    1:*/		return 0x8219FB38;
		  /* 8219FB38h */ case    2:  		/* li R9, 3 */
		/* 8219FB38h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 8219FB38h case    2:*/		return 0x8219FB3C;
		  /* 8219FB3Ch */ case    3:  		/* mr R10, R18 */
		/* 8219FB3Ch case    3:*/		regs.R10 = regs.R18;
		/* 8219FB3Ch case    3:*/		return 0x8219FB40;
		  /* 8219FB40h */ case    4:  		/* mr R11, R18 */
		/* 8219FB40h case    4:*/		regs.R11 = regs.R18;
		/* 8219FB40h case    4:*/		return 0x8219FB44;
		  /* 8219FB44h */ case    5:  		/* li R19, -1 */
		/* 8219FB44h case    5:*/		cpu::op::li<0>(regs,&regs.R19,0xFFFFFFFF);
		/* 8219FB44h case    5:*/		return 0x8219FB48;
		  /* 8219FB48h */ case    6:  		/* mtspr CTR, R9 */
		/* 8219FB48h case    6:*/		regs.CTR = regs.R9;
		/* 8219FB48h case    6:*/		return 0x8219FB4C;
		  /* 8219FB4Ch */ case    7:  		/* addi R9, R11, 3 */
		/* 8219FB4Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 8219FB4Ch case    7:*/		return 0x8219FB50;
		  /* 8219FB50h */ case    8:  		/* rlwinm R8, R11, 29, 3, 29 */
		/* 8219FB50h case    8:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R8,regs.R11);
		/* 8219FB50h case    8:*/		return 0x8219FB54;
		  /* 8219FB54h */ case    9:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8219FB54h case    9:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8219FB54h case    9:*/		return 0x8219FB58;
		  /* 8219FB58h */ case   10:  		/* addi R7, R1, 80 */
		/* 8219FB58h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 8219FB58h case   10:*/		return 0x8219FB5C;
		  /* 8219FB5Ch */ case   11:  		/* li R6, 2 */
		/* 8219FB5Ch case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 8219FB5Ch case   11:*/		return 0x8219FB60;
		  /* 8219FB60h */ case   12:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 8219FB60h case   12:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 8219FB60h case   12:*/		return 0x8219FB64;
		  /* 8219FB64h */ case   13:  		/* slw R9, R6, R9 */
		/* 8219FB64h case   13:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 8219FB64h case   13:*/		return 0x8219FB68;
		  /* 8219FB68h */ case   14:  		/* lwzx R8, <#[R8 + R7]> */
		/* 8219FB68h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 8219FB68h case   14:*/		return 0x8219FB6C;
		  /* 8219FB6Ch */ case   15:  		/* addi R9, R9, -1 */
		/* 8219FB6Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8219FB6Ch case   15:*/		return 0x8219FB70;
		  /* 8219FB70h */ case   16:  		/* slw R7, R19, R5 */
		/* 8219FB70h case   16:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R19,regs.R5);
		/* 8219FB70h case   16:*/		return 0x8219FB74;
		  /* 8219FB74h */ case   17:  		/* and R9, R9, R8 */
		/* 8219FB74h case   17:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8219FB74h case   17:*/		return 0x8219FB78;
		  /* 8219FB78h */ case   18:  		/* addi R11, R11, 4 */
		/* 8219FB78h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8219FB78h case   18:*/		return 0x8219FB7C;
		  /* 8219FB7Ch */ case   19:  		/* and R9, R9, R7 */
		/* 8219FB7Ch case   19:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8219FB7Ch case   19:*/		return 0x8219FB80;
		  /* 8219FB80h */ case   20:  		/* srw R9, R9, R5 */
		/* 8219FB80h case   20:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 8219FB80h case   20:*/		return 0x8219FB84;
		  /* 8219FB84h */ case   21:  		/* or R10, R9, R10 */
		/* 8219FB84h case   21:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8219FB84h case   21:*/		return 0x8219FB88;
		  /* 8219FB88h */ case   22:  		/* bc 16, CR0_LT, -60 */
		/* 8219FB88h case   22:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8219FB4C;  }
		/* 8219FB88h case   22:*/		return 0x8219FB8C;
		  /* 8219FB8Ch */ case   23:  		/* andi. R11, R10, 5 */
		/* 8219FB8Ch case   23:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R10,0x5);
		/* 8219FB8Ch case   23:*/		return 0x8219FB90;
		  /* 8219FB90h */ case   24:  		/* cmplwi CR6, R11, 5 */
		/* 8219FB90h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 8219FB90h case   24:*/		return 0x8219FB94;
		  /* 8219FB94h */ case   25:  		/* bc 4, CR6_EQ, 12 */
		/* 8219FB94h case   25:*/		if ( !regs.CR[6].eq ) { return 0x8219FBA0;  }
		/* 8219FB94h case   25:*/		return 0x8219FB98;
		  /* 8219FB98h */ case   26:  		/* li R3, 0 */
		/* 8219FB98h case   26:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8219FB98h case   26:*/		return 0x8219FB9C;
		  /* 8219FB9Ch */ case   27:  		/* b 632 */
		/* 8219FB9Ch case   27:*/		return 0x8219FE14;
		/* 8219FB9Ch case   27:*/		return 0x8219FBA0;
	}
	return 0x8219FBA0;
} // Block from 8219FB30h-8219FBA0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 8219FBA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FBA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FBA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FBA0);
		  /* 8219FBA0h */ case    0:  		/* rlwinm R22, R10, 0, 29, 29 */
		/* 8219FBA0h case    0:*/		cpu::op::rlwinm<0,0,29,29>(regs,&regs.R22,regs.R10);
		/* 8219FBA0h case    0:*/		return 0x8219FBA4;
		  /* 8219FBA4h */ case    1:  		/* mr R20, R18 */
		/* 8219FBA4h case    1:*/		regs.R20 = regs.R18;
		/* 8219FBA4h case    1:*/		return 0x8219FBA8;
		  /* 8219FBA8h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 8219FBA8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8219FBA8h case    2:*/		return 0x8219FBAC;
		  /* 8219FBACh */ case    3:  		/* bc 12, CR6_EQ, 456 */
		/* 8219FBACh case    3:*/		if ( regs.CR[6].eq ) { return 0x8219FD74;  }
		/* 8219FBACh case    3:*/		return 0x8219FBB0;
		  /* 8219FBB0h */ case    4:  		/* lis R11, -32256 */
		/* 8219FBB0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8219FBB0h case    4:*/		return 0x8219FBB4;
		  /* 8219FBB4h */ case    5:  		/* mr R30, R18 */
		/* 8219FBB4h case    5:*/		regs.R30 = regs.R18;
		/* 8219FBB4h case    5:*/		return 0x8219FBB8;
		  /* 8219FBB8h */ case    6:  		/* lfs FR31, <#[R11 + 1816]> */
		/* 8219FBB8h case    6:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000718) );
		/* 8219FBB8h case    6:*/		return 0x8219FBBC;
		  /* 8219FBBCh */ case    7:  		/* addi R23, R1, 104 */
		/* 8219FBBCh case    7:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R1,0x68);
		/* 8219FBBCh case    7:*/		return 0x8219FBC0;
		  /* 8219FBC0h */ case    8:  		/* lwzx R11, <#[R30 + R23]> */
		/* 8219FBC0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R23 + 0x00000000) );
		/* 8219FBC0h case    8:*/		return 0x8219FBC4;
		  /* 8219FBC4h */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219FBC4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219FBC4h case    9:*/		return 0x8219FBC8;
		  /* 8219FBC8h */ case   10:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219FBC8h case   10:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219FBC8h case   10:*/		return 0x8219FBCC;
		  /* 8219FBCCh */ case   11:  		/* cmplwi CR6, R11, 16000 */
		/* 8219FBCCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8219FBCCh case   11:*/		return 0x8219FBD0;
		  /* 8219FBD0h */ case   12:  		/* bc 4, CR6_EQ, 404 */
		/* 8219FBD0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8219FD64;  }
		/* 8219FBD0h case   12:*/		return 0x8219FBD4;
		  /* 8219FBD4h */ case   13:  		/* addi R26, R1, 88 */
		/* 8219FBD4h case   13:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R1,0x58);
		/* 8219FBD4h case   13:*/		return 0x8219FBD8;
		  /* 8219FBD8h */ case   14:  		/* mr R4, R18 */
		/* 8219FBD8h case   14:*/		regs.R4 = regs.R18;
		/* 8219FBD8h case   14:*/		return 0x8219FBDC;
		  /* 8219FBDCh */ case   15:  		/* mr R27, R18 */
		/* 8219FBDCh case   15:*/		regs.R27 = regs.R18;
		/* 8219FBDCh case   15:*/		return 0x8219FBE0;
		  /* 8219FBE0h */ case   16:  		/* mr R24, R17 */
		/* 8219FBE0h case   16:*/		regs.R24 = regs.R17;
		/* 8219FBE0h case   16:*/		return 0x8219FBE4;
		  /* 8219FBE4h */ case   17:  		/* mr R25, R18 */
		/* 8219FBE4h case   17:*/		regs.R25 = regs.R18;
		/* 8219FBE4h case   17:*/		return 0x8219FBE8;
		  /* 8219FBE8h */ case   18:  		/* lwzx R11, <#[R30 + R26]> */
		/* 8219FBE8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R26 + 0x00000000) );
		/* 8219FBE8h case   18:*/		return 0x8219FBEC;
		  /* 8219FBECh */ case   19:  		/* lwz R11, <#[R11]> */
		/* 8219FBECh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219FBECh case   19:*/		return 0x8219FBF0;
		  /* 8219FBF0h */ case   20:  		/* stfs FR31, <#[R1 + 144]> */
		/* 8219FBF0h case   20:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000090) );
		/* 8219FBF0h case   20:*/		return 0x8219FBF4;
		  /* 8219FBF4h */ case   21:  		/* stfs FR31, <#[R1 + 148]> */
		/* 8219FBF4h case   21:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000094) );
		/* 8219FBF4h case   21:*/		return 0x8219FBF8;
		  /* 8219FBF8h */ case   22:  		/* rlwinm R28, R11, 7, 29, 31 */
		/* 8219FBF8h case   22:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R28,regs.R11);
		/* 8219FBF8h case   22:*/		return 0x8219FBFC;
		  /* 8219FBFCh */ case   23:  		/* stfs FR31, <#[R1 + 152]> */
		/* 8219FBFCh case   23:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000098) );
		/* 8219FBFCh case   23:*/		return 0x8219FC00;
		  /* 8219FC00h */ case   24:  		/* stfs FR31, <#[R1 + 156]> */
		/* 8219FC00h case   24:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R1 + 0x0000009C) );
		/* 8219FC00h case   24:*/		return 0x8219FC04;
		  /* 8219FC04h */ case   25:  		/* slw R11, R17, R28 */
		/* 8219FC04h case   25:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R17,regs.R28);
		/* 8219FC04h case   25:*/		return 0x8219FC08;
		  /* 8219FC08h */ case   26:  		/* addic. R10, R11, -1 */
		/* 8219FC08h case   26:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 8219FC08h case   26:*/		return 0x8219FC0C;
		  /* 8219FC0Ch */ case   27:  		/* bc 12, CR0_EQ, 228 */
		/* 8219FC0Ch case   27:*/		if ( regs.CR[0].eq ) { return 0x8219FCF0;  }
		/* 8219FC0Ch case   27:*/		return 0x8219FC10;
		  /* 8219FC10h */ case   28:  		/* addi R6, R1, 144 */
		/* 8219FC10h case   28:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 8219FC10h case   28:*/		return 0x8219FC14;
		  /* 8219FC14h */ case   29:  		/* mr R7, R19 */
		/* 8219FC14h case   29:*/		regs.R7 = regs.R19;
		/* 8219FC14h case   29:*/		return 0x8219FC18;
		  /* 8219FC18h */ case   30:  		/* stw R19, <#[R1 + 80]> */
		/* 8219FC18h case   30:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000050) );
		/* 8219FC18h case   30:*/		return 0x8219FC1C;
		  /* 8219FC1Ch */ case   31:  		/* mr R11, R18 */
		/* 8219FC1Ch case   31:*/		regs.R11 = regs.R18;
		/* 8219FC1Ch case   31:*/		return 0x8219FC20;
		  /* 8219FC20h */ case   32:  		/* cmplwi CR6, R28, 0 */
		/* 8219FC20h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8219FC20h case   32:*/		return 0x8219FC24;
		  /* 8219FC24h */ case   33:  		/* bc 12, CR6_EQ, 60 */
		/* 8219FC24h case   33:*/		if ( regs.CR[6].eq ) { return 0x8219FC60;  }
		/* 8219FC24h case   33:*/		return 0x8219FC28;
		  /* 8219FC28h */ case   34:  		/* mtspr CTR, R28 */
		/* 8219FC28h case   34:*/		regs.CTR = regs.R28;
		/* 8219FC28h case   34:*/		return 0x8219FC2C;
		  /* 8219FC2Ch */ case   35:  		/* slw R9, R17, R11 */
		/* 8219FC2Ch case   35:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R17,regs.R11);
		/* 8219FC2Ch case   35:*/		return 0x8219FC30;
		  /* 8219FC30h */ case   36:  		/* and. R9, R9, R10 */
		/* 8219FC30h case   36:*/		cpu::op::and<1>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8219FC30h case   36:*/		return 0x8219FC34;
		  /* 8219FC34h */ case   37:  		/* bc 12, CR0_EQ, 32 */
		/* 8219FC34h case   37:*/		if ( regs.CR[0].eq ) { return 0x8219FC54;  }
		/* 8219FC34h case   37:*/		return 0x8219FC38;
		  /* 8219FC38h */ case   38:  		/* add R9, R30, R11 */
		/* 8219FC38h case   38:*/		cpu::op::add<0>(regs,&regs.R9,regs.R30,regs.R11);
		/* 8219FC38h case   38:*/		return 0x8219FC3C;
		  /* 8219FC3Ch */ case   39:  		/* addi R8, R1, 160 */
		/* 8219FC3Ch case   39:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xA0);
		/* 8219FC3Ch case   39:*/		return 0x8219FC40;
		  /* 8219FC40h */ case   40:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 8219FC40h case   40:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 8219FC40h case   40:*/		return 0x8219FC44;
		  /* 8219FC44h */ case   41:  		/* lwzx R9, <#[R9 + R8]> */
		/* 8219FC44h case   41:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 8219FC44h case   41:*/		return 0x8219FC48;
		  /* 8219FC48h */ case   42:  		/* cmplw CR6, R9, R7 */
		/* 8219FC48h case   42:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 8219FC48h case   42:*/		return 0x8219FC4C;
		  /* 8219FC4Ch */ case   43:  		/* bc 12, CR6_GT, 8 */
		/* 8219FC4Ch case   43:*/		if ( regs.CR[6].gt ) { return 0x8219FC54;  }
		/* 8219FC4Ch case   43:*/		return 0x8219FC50;
		  /* 8219FC50h */ case   44:  		/* mr R7, R9 */
		/* 8219FC50h case   44:*/		regs.R7 = regs.R9;
		/* 8219FC50h case   44:*/		return 0x8219FC54;
	}
	return 0x8219FC54;
} // Block from 8219FBA0h-8219FC54h (45 instructions)

//////////////////////////////////////////////////////
// Block at 8219FC54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FC54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FC54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FC54);
		  /* 8219FC54h */ case    0:  		/* addi R11, R11, 1 */
		/* 8219FC54h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8219FC54h case    0:*/		return 0x8219FC58;
		  /* 8219FC58h */ case    1:  		/* bc 16, CR0_LT, -44 */
		/* 8219FC58h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8219FC2C;  }
		/* 8219FC58h case    1:*/		return 0x8219FC5C;
		  /* 8219FC5Ch */ case    2:  		/* stw R7, <#[R1 + 80]> */
		/* 8219FC5Ch case    2:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 8219FC5Ch case    2:*/		return 0x8219FC60;
	}
	return 0x8219FC60;
} // Block from 8219FC54h-8219FC60h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219FC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FC60);
		  /* 8219FC60h */ case    0:  		/* mr R8, R18 */
		/* 8219FC60h case    0:*/		regs.R8 = regs.R18;
		/* 8219FC60h case    0:*/		return 0x8219FC64;
		  /* 8219FC64h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 8219FC64h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 8219FC64h case    1:*/		return 0x8219FC68;
		  /* 8219FC68h */ case    2:  		/* bc 12, CR6_EQ, 84 */
		/* 8219FC68h case    2:*/		if ( regs.CR[6].eq ) { return 0x8219FCBC;  }
		/* 8219FC68h case    2:*/		return 0x8219FC6C;
		  /* 8219FC6Ch */ case    3:  		/* mr R11, R18 */
		/* 8219FC6Ch case    3:*/		regs.R11 = regs.R18;
		/* 8219FC6Ch case    3:*/		return 0x8219FC70;
		  /* 8219FC70h */ case    4:  		/* mtspr CTR, R28 */
		/* 8219FC70h case    4:*/		regs.CTR = regs.R28;
		/* 8219FC70h case    4:*/		return 0x8219FC74;
		  /* 8219FC74h */ case    5:  		/* slw R9, R17, R8 */
		/* 8219FC74h case    5:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R17,regs.R8);
		/* 8219FC74h case    5:*/		return 0x8219FC78;
		  /* 8219FC78h */ case    6:  		/* and. R5, R9, R10 */
		/* 8219FC78h case    6:*/		cpu::op::and<1>(regs,&regs.R5,regs.R9,regs.R10);
		/* 8219FC78h case    6:*/		return 0x8219FC7C;
		  /* 8219FC7Ch */ case    7:  		/* bc 12, CR0_EQ, 52 */
		/* 8219FC7Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x8219FCB0;  }
		/* 8219FC7Ch case    7:*/		return 0x8219FC80;
		  /* 8219FC80h */ case    8:  		/* add R5, R30, R8 */
		/* 8219FC80h case    8:*/		cpu::op::add<0>(regs,&regs.R5,regs.R30,regs.R8);
		/* 8219FC80h case    8:*/		return 0x8219FC84;
		  /* 8219FC84h */ case    9:  		/* addi R3, R1, 160 */
		/* 8219FC84h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xA0);
		/* 8219FC84h case    9:*/		return 0x8219FC88;
		  /* 8219FC88h */ case   10:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 8219FC88h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 8219FC88h case   10:*/		return 0x8219FC8C;
		  /* 8219FC8Ch */ case   11:  		/* lwzx R5, <#[R5 + R3]> */
		/* 8219FC8Ch case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8219FC8Ch case   11:*/		return 0x8219FC90;
		  /* 8219FC90h */ case   12:  		/* cmplw CR6, R5, R7 */
		/* 8219FC90h case   12:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R7);
		/* 8219FC90h case   12:*/		return 0x8219FC94;
		  /* 8219FC94h */ case   13:  		/* bc 4, CR6_EQ, 28 */
		/* 8219FC94h case   13:*/		if ( !regs.CR[6].eq ) { return 0x8219FCB0;  }
		/* 8219FC94h case   13:*/		return 0x8219FC98;
		  /* 8219FC98h */ case   14:  		/* li R5, 3 */
		/* 8219FC98h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 8219FC98h case   14:*/		return 0x8219FC9C;
		  /* 8219FC9Ch */ case   15:  		/* slw R3, R4, R11 */
		/* 8219FC9Ch case   15:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R4,regs.R11);
		/* 8219FC9Ch case   15:*/		return 0x8219FCA0;
		  /* 8219FCA0h */ case   16:  		/* slw R5, R5, R11 */
		/* 8219FCA0h case   16:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R5,regs.R11);
		/* 8219FCA0h case   16:*/		return 0x8219FCA4;
		  /* 8219FCA4h */ case   17:  		/* andc R5, R27, R5 */
		/* 8219FCA4h case   17:*/		cpu::op::andc<0>(regs,&regs.R5,regs.R27,regs.R5);
		/* 8219FCA4h case   17:*/		return 0x8219FCA8;
		  /* 8219FCA8h */ case   18:  		/* subf R10, R9, R10 */
		/* 8219FCA8h case   18:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8219FCA8h case   18:*/		return 0x8219FCAC;
		  /* 8219FCACh */ case   19:  		/* or R27, R5, R3 */
		/* 8219FCACh case   19:*/		cpu::op::or<0>(regs,&regs.R27,regs.R5,regs.R3);
		/* 8219FCACh case   19:*/		return 0x8219FCB0;
	}
	return 0x8219FCB0;
} // Block from 8219FC60h-8219FCB0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8219FCB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FCB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FCB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FCB0);
		  /* 8219FCB0h */ case    0:  		/* addi R8, R8, 1 */
		/* 8219FCB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 8219FCB0h case    0:*/		return 0x8219FCB4;
		  /* 8219FCB4h */ case    1:  		/* addi R11, R11, 2 */
		/* 8219FCB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 8219FCB4h case    1:*/		return 0x8219FCB8;
		  /* 8219FCB8h */ case    2:  		/* bc 16, CR0_LT, -68 */
		/* 8219FCB8h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8219FC74;  }
		/* 8219FCB8h case    2:*/		return 0x8219FCBC;
	}
	return 0x8219FCBC;
} // Block from 8219FCB0h-8219FCBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219FCBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FCBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FCBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FCBC);
		  /* 8219FCBCh */ case    0:  		/* lfs FR0, <#[R1 + 80]> */
		/* 8219FCBCh case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 8219FCBCh case    0:*/		return 0x8219FCC0;
		  /* 8219FCC0h */ case    1:  		/* stfs FR0, <#[R6]> */
		/* 8219FCC0h case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R6 + 0x00000000) );
		/* 8219FCC0h case    1:*/		return 0x8219FCC4;
		  /* 8219FCC4h */ case    2:  		/* fcmpu CR6, FR0, FR31 */
		/* 8219FCC4h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 8219FCC4h case    2:*/		return 0x8219FCC8;
		  /* 8219FCC8h */ case    3:  		/* bc 4, CR6_GT, 12 */
		/* 8219FCC8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8219FCD4;  }
		/* 8219FCC8h case    3:*/		return 0x8219FCCC;
		  /* 8219FCCCh */ case    4:  		/* mr R24, R18 */
		/* 8219FCCCh case    4:*/		regs.R24 = regs.R18;
		/* 8219FCCCh case    4:*/		return 0x8219FCD0;
		  /* 8219FCD0h */ case    5:  		/* b 16 */
		/* 8219FCD0h case    5:*/		return 0x8219FCE0;
		/* 8219FCD0h case    5:*/		return 0x8219FCD4;
	}
	return 0x8219FCD4;
} // Block from 8219FCBCh-8219FCD4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219FCD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FCD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FCD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FCD4);
		  /* 8219FCD4h */ case    0:  		/* fcmpu CR6, FR0, FR31 */
		/* 8219FCD4h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 8219FCD4h case    0:*/		return 0x8219FCD8;
		  /* 8219FCD8h */ case    1:  		/* bc 4, CR6_LT, 8 */
		/* 8219FCD8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x8219FCE0;  }
		/* 8219FCD8h case    1:*/		return 0x8219FCDC;
		  /* 8219FCDCh */ case    2:  		/* mr R25, R17 */
		/* 8219FCDCh case    2:*/		regs.R25 = regs.R17;
		/* 8219FCDCh case    2:*/		return 0x8219FCE0;
	}
	return 0x8219FCE0;
} // Block from 8219FCD4h-8219FCE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219FCE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FCE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FCE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FCE0);
		  /* 8219FCE0h */ case    0:  		/* addi R4, R4, 1 */
		/* 8219FCE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 8219FCE0h case    0:*/		return 0x8219FCE4;
		  /* 8219FCE4h */ case    1:  		/* addi R6, R6, 4 */
		/* 8219FCE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 8219FCE4h case    1:*/		return 0x8219FCE8;
		  /* 8219FCE8h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 8219FCE8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8219FCE8h case    2:*/		return 0x8219FCEC;
		  /* 8219FCECh */ case    3:  		/* bc 4, CR6_EQ, -216 */
		/* 8219FCECh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219FC14;  }
		/* 8219FCECh case    3:*/		return 0x8219FCF0;
	}
	return 0x8219FCF0;
} // Block from 8219FCE0h-8219FCF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219FCF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FCF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FCF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FCF0);
		  /* 8219FCF0h */ case    0:  		/* addi R11, R1, 84 */
		/* 8219FCF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x54);
		/* 8219FCF0h case    0:*/		return 0x8219FCF4;
		  /* 8219FCF4h */ case    1:  		/* addi R5, R1, 144 */
		/* 8219FCF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x90);
		/* 8219FCF4h case    1:*/		return 0x8219FCF8;
		  /* 8219FCF8h */ case    2:  		/* mr R3, R21 */
		/* 8219FCF8h case    2:*/		regs.R3 = regs.R21;
		/* 8219FCF8h case    2:*/		return 0x8219FCFC;
		  /* 8219FCFCh */ case    3:  		/* stw R18, <#[R11]> */
		/* 8219FCFCh case    3:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000000) );
		/* 8219FCFCh case    3:*/		return 0x8219FD00;
		  /* 8219FD00h */ case    4:  		/* lwz R6, <#[R1 + 84]> */
		/* 8219FD00h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 8219FD00h case    4:*/		return 0x8219FD04;
		  /* 8219FD04h */ case    5:  		/* bl 553780 */
		/* 8219FD04h case    5:*/		regs.LR = 0x8219FD08; return 0x82227038;
		/* 8219FD04h case    5:*/		return 0x8219FD08;
		  /* 8219FD08h */ case    6:  		/* mr R4, R3 */
		/* 8219FD08h case    6:*/		regs.R4 = regs.R3;
		/* 8219FD08h case    6:*/		return 0x8219FD0C;
		  /* 8219FD0Ch */ case    7:  		/* stwx R3, <#[R30 + R23]> */
		/* 8219FD0Ch case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + regs.R23 + 0x00000000) );
		/* 8219FD0Ch case    7:*/		return 0x8219FD10;
		  /* 8219FD10h */ case    8:  		/* mr R31, R18 */
		/* 8219FD10h case    8:*/		regs.R31 = regs.R18;
		/* 8219FD10h case    8:*/		return 0x8219FD14;
		  /* 8219FD14h */ case    9:  		/* cmplwi CR6, R22, 0 */
		/* 8219FD14h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 8219FD14h case    9:*/		return 0x8219FD18;
		  /* 8219FD18h */ case   10:  		/* bc 12, CR6_EQ, 28 */
		/* 8219FD18h case   10:*/		if ( regs.CR[6].eq ) { return 0x8219FD34;  }
		/* 8219FD18h case   10:*/		return 0x8219FD1C;
		  /* 8219FD1Ch */ case   11:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 8219FD1Ch case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 8219FD1Ch case   11:*/		return 0x8219FD20;
		  /* 8219FD20h */ case   12:  		/* li R31, 2 */
		/* 8219FD20h case   12:*/		cpu::op::li<0>(regs,&regs.R31,0x2);
		/* 8219FD20h case   12:*/		return 0x8219FD24;
		  /* 8219FD24h */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 8219FD24h case   13:*/		if ( regs.CR[0].eq ) { return 0x8219FD34;  }
		/* 8219FD24h case   13:*/		return 0x8219FD28;
		  /* 8219FD28h */ case   14:  		/* rlwinm. R11, R24, 0, 24, 31 */
		/* 8219FD28h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R24);
		/* 8219FD28h case   14:*/		return 0x8219FD2C;
		  /* 8219FD2Ch */ case   15:  		/* bc 12, CR0_EQ, 244 */
		/* 8219FD2Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x8219FE20;  }
		/* 8219FD2Ch case   15:*/		return 0x8219FD30;
		  /* 8219FD30h */ case   16:  		/* li R31, 6 */
		/* 8219FD30h case   16:*/		cpu::op::li<0>(regs,&regs.R31,0x6);
		/* 8219FD30h case   16:*/		return 0x8219FD34;
	}
	return 0x8219FD34;
} // Block from 8219FCF0h-8219FD34h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219FD34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FD34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FD34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FD34);
		  /* 8219FD34h */ case    0:  		/* mr R3, R21 */
		/* 8219FD34h case    0:*/		regs.R3 = regs.R21;
		/* 8219FD34h case    0:*/		return 0x8219FD38;
		  /* 8219FD38h */ case    1:  		/* bl -163128 */
		/* 8219FD38h case    1:*/		regs.LR = 0x8219FD3C; return 0x82178000;
		/* 8219FD38h case    1:*/		return 0x8219FD3C;
		  /* 8219FD3Ch */ case    2:  		/* lwz R11, <#[R3]> */
		/* 8219FD3Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8219FD3Ch case    2:*/		return 0x8219FD40;
		  /* 8219FD40h */ case    3:  		/* mr R4, R31 */
		/* 8219FD40h case    3:*/		regs.R4 = regs.R31;
		/* 8219FD40h case    3:*/		return 0x8219FD44;
		  /* 8219FD44h */ case    4:  		/* rlwimi R11, R28, 25, 4, 6 */
		/* 8219FD44h case    4:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R28);
		/* 8219FD44h case    4:*/		return 0x8219FD48;
		  /* 8219FD48h */ case    5:  		/* mr R25, R3 */
		/* 8219FD48h case    5:*/		regs.R25 = regs.R3;
		/* 8219FD48h case    5:*/		return 0x8219FD4C;
		  /* 8219FD4Ch */ case    6:  		/* stw R11, <#[R3]> */
		/* 8219FD4Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8219FD4Ch case    6:*/		return 0x8219FD50;
		  /* 8219FD50h */ case    7:  		/* bl -164496 */
		/* 8219FD50h case    7:*/		regs.LR = 0x8219FD54; return 0x82177AC0;
		/* 8219FD50h case    7:*/		return 0x8219FD54;
		  /* 8219FD54h */ case    8:  		/* lwz R11, <#[R25]> */
		/* 8219FD54h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8219FD54h case    8:*/		return 0x8219FD58;
		  /* 8219FD58h */ case    9:  		/* stwx R25, <#[R30 + R26]> */
		/* 8219FD58h case    9:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + regs.R26 + 0x00000000) );
		/* 8219FD58h case    9:*/		return 0x8219FD5C;
		  /* 8219FD5Ch */ case   10:  		/* rlwimi R11, R27, 5, 19, 26 */
		/* 8219FD5Ch case   10:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R27);
		/* 8219FD5Ch case   10:*/		return 0x8219FD60;
		  /* 8219FD60h */ case   11:  		/* stw R11, <#[R25]> */
		/* 8219FD60h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8219FD60h case   11:*/		return 0x8219FD64;
	}
	return 0x8219FD64;
} // Block from 8219FD34h-8219FD64h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8219FD64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FD64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FD64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FD64);
		  /* 8219FD64h */ case    0:  		/* addi R20, R20, 1 */
		/* 8219FD64h case    0:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 8219FD64h case    0:*/		return 0x8219FD68;
		  /* 8219FD68h */ case    1:  		/* addi R30, R30, 4 */
		/* 8219FD68h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8219FD68h case    1:*/		return 0x8219FD6C;
		  /* 8219FD6Ch */ case    2:  		/* cmplw CR6, R20, R29 */
		/* 8219FD6Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R29);
		/* 8219FD6Ch case    2:*/		return 0x8219FD70;
		  /* 8219FD70h */ case    3:  		/* bc 12, CR6_LT, -436 */
		/* 8219FD70h case    3:*/		if ( regs.CR[6].lt ) { return 0x8219FBBC;  }
		/* 8219FD70h case    3:*/		return 0x8219FD74;
	}
	return 0x8219FD74;
} // Block from 8219FD64h-8219FD74h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8219FD74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FD74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FD74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FD74);
		  /* 8219FD74h */ case    0:  		/* cmplwi CR6, R29, 2 */
		/* 8219FD74h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000002);
		/* 8219FD74h case    0:*/		return 0x8219FD78;
		  /* 8219FD78h */ case    1:  		/* bc 4, CR6_GT, 64 */
		/* 8219FD78h case    1:*/		if ( !regs.CR[6].gt ) { return 0x8219FDB8;  }
		/* 8219FD78h case    1:*/		return 0x8219FD7C;
		  /* 8219FD7Ch */ case    2:  		/* lwz R11, <#[R1 + 96]> */
		/* 8219FD7Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 8219FD7Ch case    2:*/		return 0x8219FD80;
		  /* 8219FD80h */ case    3:  		/* lwz R10, <#[R1 + 92]> */
		/* 8219FD80h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 8219FD80h case    3:*/		return 0x8219FD84;
		  /* 8219FD84h */ case    4:  		/* lwz R11, <#[R11]> */
		/* 8219FD84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8219FD84h case    4:*/		return 0x8219FD88;
		  /* 8219FD88h */ case    5:  		/* lwz R9, <#[R10]> */
		/* 8219FD88h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8219FD88h case    5:*/		return 0x8219FD8C;
		  /* 8219FD8Ch */ case    6:  		/* rlwinm R11, R11, 0, 27, 28 */
		/* 8219FD8Ch case    6:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R11,regs.R11);
		/* 8219FD8Ch case    6:*/		return 0x8219FD90;
		  /* 8219FD90h */ case    7:  		/* rlwinm R9, R9, 0, 27, 28 */
		/* 8219FD90h case    7:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R9,regs.R9);
		/* 8219FD90h case    7:*/		return 0x8219FD94;
		  /* 8219FD94h */ case    8:  		/* cmplw CR6, R11, R9 */
		/* 8219FD94h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8219FD94h case    8:*/		return 0x8219FD98;
		  /* 8219FD98h */ case    9:  		/* bc 12, CR6_EQ, 32 */
		/* 8219FD98h case    9:*/		if ( regs.CR[6].eq ) { return 0x8219FDB8;  }
		/* 8219FD98h case    9:*/		return 0x8219FD9C;
		  /* 8219FD9Ch */ case   10:  		/* lwz R9, <#[R1 + 88]> */
		/* 8219FD9Ch case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 8219FD9Ch case   10:*/		return 0x8219FDA0;
		  /* 8219FDA0h */ case   11:  		/* lwz R8, <#[R9]> */
		/* 8219FDA0h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 8219FDA0h case   11:*/		return 0x8219FDA4;
		  /* 8219FDA4h */ case   12:  		/* rlwinm R8, R8, 0, 27, 28 */
		/* 8219FDA4h case   12:*/		cpu::op::rlwinm<0,0,27,28>(regs,&regs.R8,regs.R8);
		/* 8219FDA4h case   12:*/		return 0x8219FDA8;
		  /* 8219FDA8h */ case   13:  		/* cmplw CR6, R11, R8 */
		/* 8219FDA8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 8219FDA8h case   13:*/		return 0x8219FDAC;
		  /* 8219FDACh */ case   14:  		/* bc 4, CR6_EQ, -532 */
		/* 8219FDACh case   14:*/		if ( !regs.CR[6].eq ) { return 0x8219FB98;  }
		/* 8219FDACh case   14:*/		return 0x8219FDB0;
		  /* 8219FDB0h */ case   15:  		/* stw R10, <#[R1 + 88]> */
		/* 8219FDB0h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 8219FDB0h case   15:*/		return 0x8219FDB4;
		  /* 8219FDB4h */ case   16:  		/* stw R9, <#[R1 + 92]> */
		/* 8219FDB4h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 8219FDB4h case   16:*/		return 0x8219FDB8;
	}
	return 0x8219FDB8;
} // Block from 8219FD74h-8219FDB8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8219FDB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FDB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FDB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FDB8);
		  /* 8219FDB8h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 8219FDB8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8219FDB8h case    0:*/		return 0x8219FDBC;
		  /* 8219FDBCh */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 8219FDBCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8219FE10;  }
		/* 8219FDBCh case    1:*/		return 0x8219FDC0;
		  /* 8219FDC0h */ case    2:  		/* mr R31, R18 */
		/* 8219FDC0h case    2:*/		regs.R31 = regs.R18;
		/* 8219FDC0h case    2:*/		return 0x8219FDC4;
		  /* 8219FDC4h */ case    3:  		/* addi R11, R1, 88 */
		/* 8219FDC4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x58);
		/* 8219FDC4h case    3:*/		return 0x8219FDC8;
		  /* 8219FDC8h */ case    4:  		/* addi R10, R1, 120 */
		/* 8219FDC8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x78);
		/* 8219FDC8h case    4:*/		return 0x8219FDCC;
		  /* 8219FDCCh */ case    5:  		/* addi R9, R1, 104 */
		/* 8219FDCCh case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x68);
		/* 8219FDCCh case    5:*/		return 0x8219FDD0;
		  /* 8219FDD0h */ case    6:  		/* lwzx R11, <#[R31 + R11]> */
		/* 8219FDD0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 8219FDD0h case    6:*/		return 0x8219FDD4;
		  /* 8219FDD4h */ case    7:  		/* lwzx R10, <#[R31 + R10]> */
		/* 8219FDD4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R10 + 0x00000000) );
		/* 8219FDD4h case    7:*/		return 0x8219FDD8;
		  /* 8219FDD8h */ case    8:  		/* lwzx R30, <#[R31 + R9]> */
		/* 8219FDD8h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + regs.R9 + 0x00000000) );
		/* 8219FDD8h case    8:*/		return 0x8219FDDC;
		  /* 8219FDDCh */ case    9:  		/* stw R11, <#[R10]> */
		/* 8219FDDCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8219FDDCh case    9:*/		return 0x8219FDE0;
	}
	return 0x8219FDE0;
} // Block from 8219FDB8h-8219FDE0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8219FDE0h
// Function '?CountCombinedOutputs@Compiler@D3DXShader@@AAAIPAVInstruction@2@0PAUCombineInstructionsState@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FDE0);
		  /* 8219FDE0h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219FDE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219FDE0h case    0:*/		return 0x8219FDE4;
		  /* 8219FDE4h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219FDE4h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219FDE4h case    1:*/		return 0x8219FDE8;
		  /* 8219FDE8h */ case    2:  		/* cmplwi CR6, R11, 16000 */
		/* 8219FDE8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8219FDE8h case    2:*/		return 0x8219FDEC;
		  /* 8219FDECh */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 8219FDECh case    3:*/		if ( !regs.CR[6].eq ) { return 0x8219FE04;  }
		/* 8219FDECh case    3:*/		return 0x8219FDF0;
		  /* 8219FDF0h */ case    4:  		/* mr R3, R30 */
		/* 8219FDF0h case    4:*/		regs.R3 = regs.R30;
		/* 8219FDF0h case    4:*/		return 0x8219FDF4;
		  /* 8219FDF4h */ case    5:  		/* bl -39492 */
		/* 8219FDF4h case    5:*/		regs.LR = 0x8219FDF8; return 0x821963B0;
		/* 8219FDF4h case    5:*/		return 0x8219FDF8;
		  /* 8219FDF8h */ case    6:  		/* lwz R11, <#[R30 + 8]> */
		/* 8219FDF8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219FDF8h case    6:*/		return 0x8219FDFC;
		  /* 8219FDFCh */ case    7:  		/* oris R11, R11, 256 */
		/* 8219FDFCh case    7:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 8219FDFCh case    7:*/		return 0x8219FE00;
		  /* 8219FE00h */ case    8:  		/* stw R11, <#[R30 + 8]> */
		/* 8219FE00h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8219FE00h case    8:*/		return 0x8219FE04;
	}
	return 0x8219FE04;
} // Block from 8219FDE0h-8219FE04h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219FE04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FE04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FE04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FE04);
		  /* 8219FE04h */ case    0:  		/* addic. R29, R29, -1 */
		/* 8219FE04h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 8219FE04h case    0:*/		return 0x8219FE08;
		  /* 8219FE08h */ case    1:  		/* addi R31, R31, 4 */
		/* 8219FE08h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8219FE08h case    1:*/		return 0x8219FE0C;
		  /* 8219FE0Ch */ case    2:  		/* bc 4, CR0_EQ, -72 */
		/* 8219FE0Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x8219FDC4;  }
		/* 8219FE0Ch case    2:*/		return 0x8219FE10;
	}
	return 0x8219FE10;
} // Block from 8219FE04h-8219FE10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219FE10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FE10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FE10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FE10);
		  /* 8219FE10h */ case    0:  		/* li R3, 1 */
		/* 8219FE10h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8219FE10h case    0:*/		return 0x8219FE14;
	}
	return 0x8219FE14;
} // Block from 8219FE10h-8219FE14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219FE14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FE14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FE14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FE14);
		  /* 8219FE14h */ case    0:  		/* addi R1, R1, 352 */
		/* 8219FE14h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x160);
		/* 8219FE14h case    0:*/		return 0x8219FE18;
		  /* 8219FE18h */ case    1:  		/* lfd FR31, <#[R1 - 136]> */
		/* 8219FE18h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF78) );
		/* 8219FE18h case    1:*/		return 0x8219FE1C;
		  /* 8219FE1Ch */ case    2:  		/* b -1108896 */
		/* 8219FE1Ch case    2:*/		return 0x8209127C;
		/* 8219FE1Ch case    2:*/		return 0x8219FE20;
	}
	return 0x8219FE20;
} // Block from 8219FE14h-8219FE20h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219FE20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FE20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FE20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FE20);
		  /* 8219FE20h */ case    0:  		/* li R4, 4800 */
		/* 8219FE20h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 8219FE20h case    0:*/		return 0x8219FE24;
		  /* 8219FE24h */ case    1:  		/* mr R3, R21 */
		/* 8219FE24h case    1:*/		regs.R3 = regs.R21;
		/* 8219FE24h case    1:*/		return 0x8219FE28;
		  /* 8219FE28h */ case    2:  		/* bl -319424 */
		/* 8219FE28h case    2:*/		regs.LR = 0x8219FE2C; return 0x82151E68;
		/* 8219FE28h case    2:*/		return 0x8219FE2C;
		  /* 8219FE2Ch */ case    3:  		/* nop */
		/* 8219FE2Ch case    3:*/		cpu::op::nop();
		/* 8219FE2Ch case    3:*/		return 0x8219FE30;
		  /* 8219FE30h */ case    4:  		/* stw R4, <#[R3]> */
		/* 8219FE30h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 8219FE30h case    4:*/		return 0x8219FE34;
		  /* 8219FE34h */ case    5:  		/* li R10, 0 */
		/* 8219FE34h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8219FE34h case    5:*/		return 0x8219FE38;
		  /* 8219FE38h */ case    6:  		/* lwz R11, <#[R4 + 4]> */
		/* 8219FE38h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8219FE38h case    6:*/		return 0x8219FE3C;
		  /* 8219FE3Ch */ case    7:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 8219FE3Ch case    7:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 8219FE3Ch case    7:*/		return 0x8219FE40;
		  /* 8219FE40h */ case    8:  		/* addic R9, R9, -1 */
		/* 8219FE40h case    8:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 8219FE40h case    8:*/		return 0x8219FE44;
		  /* 8219FE44h */ case    9:  		/* stw R10, <#[R3 + 8]> */
		/* 8219FE44h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8219FE44h case    9:*/		return 0x8219FE48;
		  /* 8219FE48h */ case   10:  		/* subfe R9, R9, R9 */
		/* 8219FE48h case   10:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8219FE48h case   10:*/		return 0x8219FE4C;
		  /* 8219FE4Ch */ case   11:  		/* and R11, R9, R11 */
		/* 8219FE4Ch case   11:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8219FE4Ch case   11:*/		return 0x8219FE50;
		  /* 8219FE50h */ case   12:  		/* stw R11, <#[R3 + 4]> */
		/* 8219FE50h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219FE50h case   12:*/		return 0x8219FE54;
		  /* 8219FE54h */ case   13:  		/* lwz R11, <#[R4 + 4]> */
		/* 8219FE54h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8219FE54h case   13:*/		return 0x8219FE58;
		  /* 8219FE58h */ case   14:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 8219FE58h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8219FE58h case   14:*/		return 0x8219FE5C;
		  /* 8219FE5Ch */ case   15:  		/* bc 12, CR0_EQ, 12 */
		/* 8219FE5Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x8219FE68;  }
		/* 8219FE5Ch case   15:*/		return 0x8219FE60;
		  /* 8219FE60h */ case   16:  		/* mr R11, R10 */
		/* 8219FE60h case   16:*/		regs.R11 = regs.R10;
		/* 8219FE60h case   16:*/		return 0x8219FE64;
		  /* 8219FE64h */ case   17:  		/* b 16 */
		/* 8219FE64h case   17:*/		return 0x8219FE74;
		/* 8219FE64h case   17:*/		return 0x8219FE68;
	}
	return 0x8219FE68;
} // Block from 8219FE20h-8219FE68h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8219FE68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FE68);
		  /* 8219FE68h */ case    0:  		/* lwz R11, <#[R4]> */
		/* 8219FE68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8219FE68h case    0:*/		return 0x8219FE6C;
		  /* 8219FE6Ch */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8219FE6Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8219FE6Ch case    1:*/		return 0x8219FE70;
		  /* 8219FE70h */ case    2:  		/* addi R11, R11, -4 */
		/* 8219FE70h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8219FE70h case    2:*/		return 0x8219FE74;
	}
	return 0x8219FE74;
} // Block from 8219FE68h-8219FE74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8219FE74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FE74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FE74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FE74);
		  /* 8219FE74h */ case    0:  		/* stw R11, <#[R3 + 4]> */
		/* 8219FE74h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8219FE74h case    0:*/		return 0x8219FE78;
		  /* 8219FE78h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8219FE78h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8219FE78h case    1:*/		return 0x8219FE7C;
		  /* 8219FE7Ch */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8219FE7Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8219FE8C;  }
		/* 8219FE7Ch case    2:*/		return 0x8219FE80;
		  /* 8219FE80h */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 8219FE80h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 8219FE80h case    3:*/		return 0x8219FE84;
		  /* 8219FE84h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 8219FE84h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8219FE84h case    4:*/		return 0x8219FE88;
		  /* 8219FE88h */ case    5:  		/* bclr 20, CR0_LT */
		/* 8219FE88h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219FE88h case    5:*/		return 0x8219FE8C;
	}
	return 0x8219FE8C;
} // Block from 8219FE74h-8219FE8Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219FE8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FE8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FE8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FE8C);
		  /* 8219FE8Ch */ case    0:  		/* stw R10, <#[R3 + 8]> */
		/* 8219FE8Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8219FE8Ch case    0:*/		return 0x8219FE90;
		  /* 8219FE90h */ case    1:  		/* bclr 20, CR0_LT */
		/* 8219FE90h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8219FE90h case    1:*/		return 0x8219FE94;
	}
	return 0x8219FE94;
} // Block from 8219FE8Ch-8219FE94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8219FE94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FE94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FE94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FE94);
		  /* 8219FE94h */ case    0:  		/* nop */
		/* 8219FE94h case    0:*/		cpu::op::nop();
		/* 8219FE94h case    0:*/		return 0x8219FE98;
	}
	return 0x8219FE98;
} // Block from 8219FE94h-8219FE98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219FE98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FE98);
		  /* 8219FE98h */ case    0:  		/* mfspr R12, LR */
		/* 8219FE98h case    0:*/		regs.R12 = regs.LR;
		/* 8219FE98h case    0:*/		return 0x8219FE9C;
		  /* 8219FE9Ch */ case    1:  		/* bl -1109092 */
		/* 8219FE9Ch case    1:*/		regs.LR = 0x8219FEA0; return 0x82091238;
		/* 8219FE9Ch case    1:*/		return 0x8219FEA0;
		  /* 8219FEA0h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 8219FEA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 8219FEA0h case    2:*/		return 0x8219FEA4;
		  /* 8219FEA4h */ case    3:  		/* mr R22, R10 */
		/* 8219FEA4h case    3:*/		regs.R22 = regs.R10;
		/* 8219FEA4h case    3:*/		return 0x8219FEA8;
		  /* 8219FEA8h */ case    4:  		/* lwz R11, <#[R9]> */
		/* 8219FEA8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8219FEA8h case    4:*/		return 0x8219FEAC;
		  /* 8219FEACh */ case    5:  		/* li R10, 1 */
		/* 8219FEACh case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8219FEACh case    5:*/		return 0x8219FEB0;
		  /* 8219FEB0h */ case    6:  		/* lwz R25, <#[R5 + 12]> */
		/* 8219FEB0h case    6:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R5 + 0x0000000C) );
		/* 8219FEB0h case    6:*/		return 0x8219FEB4;
		  /* 8219FEB4h */ case    7:  		/* li R21, 0 */
		/* 8219FEB4h case    7:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8219FEB4h case    7:*/		return 0x8219FEB8;
		  /* 8219FEB8h */ case    8:  		/* lwz R24, <#[R7 + 12]> */
		/* 8219FEB8h case    8:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R7 + 0x0000000C) );
		/* 8219FEB8h case    8:*/		return 0x8219FEBC;
		  /* 8219FEBCh */ case    9:  		/* rlwimi R11, R10, 0, 30, 31 */
		/* 8219FEBCh case    9:*/		cpu::op::rlwimi<0,0,30,31>(regs,&regs.R11,regs.R10);
		/* 8219FEBCh case    9:*/		return 0x8219FEC0;
		  /* 8219FEC0h */ case   10:  		/* stw R21, <#[R9 + 4]> */
		/* 8219FEC0h case   10:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R9 + 0x00000004) );
		/* 8219FEC0h case   10:*/		return 0x8219FEC4;
		  /* 8219FEC4h */ case   11:  		/* mr R23, R3 */
		/* 8219FEC4h case   11:*/		regs.R23 = regs.R3;
		/* 8219FEC4h case   11:*/		return 0x8219FEC8;
		  /* 8219FEC8h */ case   12:  		/* rlwimi R11, R10, 0, 21, 27 */
		/* 8219FEC8h case   12:*/		cpu::op::rlwimi<0,0,21,27>(regs,&regs.R11,regs.R10);
		/* 8219FEC8h case   12:*/		return 0x8219FECC;
		  /* 8219FECCh */ case   13:  		/* stw R21, <#[R9 + 8]> */
		/* 8219FECCh case   13:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R9 + 0x00000008) );
		/* 8219FECCh case   13:*/		return 0x8219FED0;
		  /* 8219FED0h */ case   14:  		/* mr R29, R4 */
		/* 8219FED0h case   14:*/		regs.R29 = regs.R4;
		/* 8219FED0h case   14:*/		return 0x8219FED4;
		  /* 8219FED4h */ case   15:  		/* rlwimi R11, R10, 0, 12, 16 */
		/* 8219FED4h case   15:*/		cpu::op::rlwimi<0,0,12,16>(regs,&regs.R11,regs.R10);
		/* 8219FED4h case   15:*/		return 0x8219FED8;
		  /* 8219FED8h */ case   16:  		/* mr R26, R5 */
		/* 8219FED8h case   16:*/		regs.R26 = regs.R5;
		/* 8219FED8h case   16:*/		return 0x8219FEDC;
		  /* 8219FEDCh */ case   17:  		/* stw R11, <#[R9]> */
		/* 8219FEDCh case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8219FEDCh case   17:*/		return 0x8219FEE0;
		  /* 8219FEE0h */ case   18:  		/* mr R28, R6 */
		/* 8219FEE0h case   18:*/		regs.R28 = regs.R6;
		/* 8219FEE0h case   18:*/		return 0x8219FEE4;
		  /* 8219FEE4h */ case   19:  		/* lwz R11, <#[R25 + 8]> */
		/* 8219FEE4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8219FEE4h case   19:*/		return 0x8219FEE8;
		  /* 8219FEE8h */ case   20:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219FEE8h case   20:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219FEE8h case   20:*/		return 0x8219FEEC;
		  /* 8219FEECh */ case   21:  		/* mr R27, R7 */
		/* 8219FEECh case   21:*/		regs.R27 = regs.R7;
		/* 8219FEECh case   21:*/		return 0x8219FEF0;
		  /* 8219FEF0h */ case   22:  		/* mr R20, R8 */
		/* 8219FEF0h case   22:*/		regs.R20 = regs.R8;
		/* 8219FEF0h case   22:*/		return 0x8219FEF4;
		  /* 8219FEF4h */ case   23:  		/* mr R31, R9 */
		/* 8219FEF4h case   23:*/		regs.R31 = regs.R9;
		/* 8219FEF4h case   23:*/		return 0x8219FEF8;
		  /* 8219FEF8h */ case   24:  		/* cmplwi CR6, R11, 125 */
		/* 8219FEF8h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219FEF8h case   24:*/		return 0x8219FEFC;
		  /* 8219FEFCh */ case   25:  		/* bc 12, CR6_EQ, 16 */
		/* 8219FEFCh case   25:*/		if ( regs.CR[6].eq ) { return 0x8219FF0C;  }
		/* 8219FEFCh case   25:*/		return 0x8219FF00;
		  /* 8219FF00h */ case   26:  		/* cmplwi CR6, R11, 124 */
		/* 8219FF00h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219FF00h case   26:*/		return 0x8219FF04;
		  /* 8219FF04h */ case   27:  		/* mr R11, R21 */
		/* 8219FF04h case   27:*/		regs.R11 = regs.R21;
		/* 8219FF04h case   27:*/		return 0x8219FF08;
		  /* 8219FF08h */ case   28:  		/* bc 4, CR6_EQ, 8 */
		/* 8219FF08h case   28:*/		if ( !regs.CR[6].eq ) { return 0x8219FF10;  }
		/* 8219FF08h case   28:*/		return 0x8219FF0C;
	}
	return 0x8219FF0C;
} // Block from 8219FE98h-8219FF0Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 8219FF0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FF0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FF0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FF0C);
		  /* 8219FF0Ch */ case    0:  		/* li R11, 1 */
		/* 8219FF0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219FF0Ch case    0:*/		return 0x8219FF10;
	}
	return 0x8219FF10;
} // Block from 8219FF0Ch-8219FF10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219FF10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FF10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FF10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FF10);
		  /* 8219FF10h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219FF10h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219FF10h case    0:*/		return 0x8219FF14;
		  /* 8219FF14h */ case    1:  		/* bc 12, CR0_EQ, 216 */
		/* 8219FF14h case    1:*/		if ( regs.CR[0].eq ) { return 0x8219FFEC;  }
		/* 8219FF14h case    1:*/		return 0x8219FF18;
		  /* 8219FF18h */ case    2:  		/* lwz R11, <#[R24 + 8]> */
		/* 8219FF18h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 8219FF18h case    2:*/		return 0x8219FF1C;
		  /* 8219FF1Ch */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 8219FF1Ch case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 8219FF1Ch case    3:*/		return 0x8219FF20;
		  /* 8219FF20h */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 8219FF20h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 8219FF20h case    4:*/		return 0x8219FF24;
		  /* 8219FF24h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 8219FF24h case    5:*/		if ( regs.CR[6].eq ) { return 0x8219FF34;  }
		/* 8219FF24h case    5:*/		return 0x8219FF28;
		  /* 8219FF28h */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 8219FF28h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 8219FF28h case    6:*/		return 0x8219FF2C;
		  /* 8219FF2Ch */ case    7:  		/* mr R11, R21 */
		/* 8219FF2Ch case    7:*/		regs.R11 = regs.R21;
		/* 8219FF2Ch case    7:*/		return 0x8219FF30;
		  /* 8219FF30h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 8219FF30h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8219FF38;  }
		/* 8219FF30h case    8:*/		return 0x8219FF34;
	}
	return 0x8219FF34;
} // Block from 8219FF10h-8219FF34h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8219FF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FF34);
		  /* 8219FF34h */ case    0:  		/* li R11, 1 */
		/* 8219FF34h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8219FF34h case    0:*/		return 0x8219FF38;
	}
	return 0x8219FF38;
} // Block from 8219FF34h-8219FF38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8219FF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FF38);
		  /* 8219FF38h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8219FF38h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8219FF38h case    0:*/		return 0x8219FF3C;
		  /* 8219FF3Ch */ case    1:  		/* bc 12, CR0_EQ, 176 */
		/* 8219FF3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8219FFEC;  }
		/* 8219FF3Ch case    1:*/		return 0x8219FF40;
		  /* 8219FF40h */ case    2:  		/* lwz R11, <#[R26]> */
		/* 8219FF40h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 8219FF40h case    2:*/		return 0x8219FF44;
		  /* 8219FF44h */ case    3:  		/* addi R8, R1, 96 */
		/* 8219FF44h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 8219FF44h case    3:*/		return 0x8219FF48;
		  /* 8219FF48h */ case    4:  		/* mr R4, R25 */
		/* 8219FF48h case    4:*/		regs.R4 = regs.R25;
		/* 8219FF48h case    4:*/		return 0x8219FF4C;
		  /* 8219FF4Ch */ case    5:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 8219FF4Ch case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 8219FF4Ch case    5:*/		return 0x8219FF50;
	}
	return 0x8219FF50;
} // Block from 8219FF38h-8219FF50h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8219FF50h
// Function '?CanComputeValue@Compiler@D3DXShader@@AAA_NPAVInstruction@2@PAVDependency@2@PAUCombineDependenciesState@2@_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FF50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FF50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FF50);
		  /* 8219FF50h */ case    0:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 8219FF50h case    0:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 8219FF50h case    0:*/		return 0x8219FF54;
		  /* 8219FF54h */ case    1:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 8219FF54h case    1:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 8219FF54h case    1:*/		return 0x8219FF58;
		  /* 8219FF58h */ case    2:  		/* mr R3, R23 */
		/* 8219FF58h case    2:*/		regs.R3 = regs.R23;
		/* 8219FF58h case    2:*/		return 0x8219FF5C;
		  /* 8219FF5Ch */ case    3:  		/* bl -19676 */
		/* 8219FF5Ch case    3:*/		regs.LR = 0x8219FF60; return 0x8219B280;
		/* 8219FF5Ch case    3:*/		return 0x8219FF60;
		  /* 8219FF60h */ case    4:  		/* lwz R11, <#[R31]> */
		/* 8219FF60h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219FF60h case    4:*/		return 0x8219FF64;
		  /* 8219FF64h */ case    5:  		/* addi R8, R1, 80 */
		/* 8219FF64h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 8219FF64h case    5:*/		return 0x8219FF68;
		  /* 8219FF68h */ case    6:  		/* rlwimi R11, R3, 15, 14, 16 */
		/* 8219FF68h case    6:*/		cpu::op::rlwimi<0,15,14,16>(regs,&regs.R11,regs.R3);
		/* 8219FF68h case    6:*/		return 0x8219FF6C;
		  /* 8219FF6Ch */ case    7:  		/* mr R4, R24 */
		/* 8219FF6Ch case    7:*/		regs.R4 = regs.R24;
		/* 8219FF6Ch case    7:*/		return 0x8219FF70;
		  /* 8219FF70h */ case    8:  		/* stw R11, <#[R31]> */
		/* 8219FF70h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219FF70h case    8:*/		return 0x8219FF74;
		  /* 8219FF74h */ case    9:  		/* mr R3, R23 */
		/* 8219FF74h case    9:*/		regs.R3 = regs.R23;
		/* 8219FF74h case    9:*/		return 0x8219FF78;
		  /* 8219FF78h */ case   10:  		/* lwz R11, <#[R27]> */
		/* 8219FF78h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8219FF78h case   10:*/		return 0x8219FF7C;
		  /* 8219FF7Ch */ case   11:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 8219FF7Ch case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 8219FF7Ch case   11:*/		return 0x8219FF80;
		  /* 8219FF80h */ case   12:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 8219FF80h case   12:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 8219FF80h case   12:*/		return 0x8219FF84;
		  /* 8219FF84h */ case   13:  		/* lwz R30, <#[R31]> */
		/* 8219FF84h case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 8219FF84h case   13:*/		return 0x8219FF88;
		  /* 8219FF88h */ case   14:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 8219FF88h case   14:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 8219FF88h case   14:*/		return 0x8219FF8C;
		  /* 8219FF8Ch */ case   15:  		/* bl -19724 */
		/* 8219FF8Ch case   15:*/		regs.LR = 0x8219FF90; return 0x8219B280;
		/* 8219FF8Ch case   15:*/		return 0x8219FF90;
		  /* 8219FF90h */ case   16:  		/* rlwinm R11, R3, 15, 14, 16 */
		/* 8219FF90h case   16:*/		cpu::op::rlwinm<0,15,14,16>(regs,&regs.R11,regs.R3);
		/* 8219FF90h case   16:*/		return 0x8219FF94;
		  /* 8219FF94h */ case   17:  		/* or R30, R11, R30 */
		/* 8219FF94h case   17:*/		cpu::op::or<0>(regs,&regs.R30,regs.R11,regs.R30);
		/* 8219FF94h case   17:*/		return 0x8219FF98;
		  /* 8219FF98h */ case   18:  		/* stw R30, <#[R31]> */
		/* 8219FF98h case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 8219FF98h case   18:*/		return 0x8219FF9C;
		  /* 8219FF9Ch */ case   19:  		/* lwz R11, <#[R25 + 8]> */
		/* 8219FF9Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8219FF9Ch case   19:*/		return 0x8219FFA0;
		  /* 8219FFA0h */ case   20:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219FFA0h case   20:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219FFA0h case   20:*/		return 0x8219FFA4;
		  /* 8219FFA4h */ case   21:  		/* cmplwi CR6, R11, 16000 */
		/* 8219FFA4h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8219FFA4h case   21:*/		return 0x8219FFA8;
		  /* 8219FFA8h */ case   22:  		/* bc 4, CR6_EQ, 68 */
		/* 8219FFA8h case   22:*/		if ( !regs.CR[6].eq ) { return 0x8219FFEC;  }
		/* 8219FFA8h case   22:*/		return 0x8219FFAC;
		  /* 8219FFACh */ case   23:  		/* lwz R11, <#[R24 + 8]> */
		/* 8219FFACh case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 8219FFACh case   23:*/		return 0x8219FFB0;
		  /* 8219FFB0h */ case   24:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219FFB0h case   24:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219FFB0h case   24:*/		return 0x8219FFB4;
		  /* 8219FFB4h */ case   25:  		/* cmplwi CR6, R11, 16000 */
		/* 8219FFB4h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8219FFB4h case   25:*/		return 0x8219FFB8;
		  /* 8219FFB8h */ case   26:  		/* bc 4, CR6_EQ, 52 */
		/* 8219FFB8h case   26:*/		if ( !regs.CR[6].eq ) { return 0x8219FFEC;  }
		/* 8219FFB8h case   26:*/		return 0x8219FFBC;
		  /* 8219FFBCh */ case   27:  		/* lwz R11, <#[R27]> */
		/* 8219FFBCh case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8219FFBCh case   27:*/		return 0x8219FFC0;
		  /* 8219FFC0h */ case   28:  		/* addi R6, R1, 80 */
		/* 8219FFC0h case   28:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 8219FFC0h case   28:*/		return 0x8219FFC4;
		  /* 8219FFC4h */ case   29:  		/* lwz R10, <#[R26]> */
		/* 8219FFC4h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 8219FFC4h case   29:*/		return 0x8219FFC8;
		  /* 8219FFC8h */ case   30:  		/* addi R4, R1, 96 */
		/* 8219FFC8h case   30:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 8219FFC8h case   30:*/		return 0x8219FFCC;
		  /* 8219FFCCh */ case   31:  		/* rlwinm R7, R11, 7, 29, 31 */
		/* 8219FFCCh case   31:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R7,regs.R11);
		/* 8219FFCCh case   31:*/		return 0x8219FFD0;
		  /* 8219FFD0h */ case   32:  		/* rlwinm R5, R10, 7, 29, 31 */
		/* 8219FFD0h case   32:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R10);
		/* 8219FFD0h case   32:*/		return 0x8219FFD4;
		  /* 8219FFD4h */ case   33:  		/* mr R3, R23 */
		/* 8219FFD4h case   33:*/		regs.R3 = regs.R23;
		/* 8219FFD4h case   33:*/		return 0x8219FFD8;
		  /* 8219FFD8h */ case   34:  		/* bl -19592 */
		/* 8219FFD8h case   34:*/		regs.LR = 0x8219FFDC; return 0x8219B350;
		/* 8219FFD8h case   34:*/		return 0x8219FFDC;
		  /* 8219FFDCh */ case   35:  		/* rlwinm R11, R3, 15, 0, 16 */
		/* 8219FFDCh case   35:*/		cpu::op::rlwinm<0,15,0,16>(regs,&regs.R11,regs.R3);
		/* 8219FFDCh case   35:*/		return 0x8219FFE0;
		  /* 8219FFE0h */ case   36:  		/* or R11, R11, R30 */
		/* 8219FFE0h case   36:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8219FFE0h case   36:*/		return 0x8219FFE4;
		  /* 8219FFE4h */ case   37:  		/* rlwimi R11, R30, 0, 17, 13 */
		/* 8219FFE4h case   37:*/		cpu::op::rlwimi<0,0,17,13>(regs,&regs.R11,regs.R30);
		/* 8219FFE4h case   37:*/		return 0x8219FFE8;
		  /* 8219FFE8h */ case   38:  		/* stw R11, <#[R31]> */
		/* 8219FFE8h case   38:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8219FFE8h case   38:*/		return 0x8219FFEC;
	}
	return 0x8219FFEC;
} // Block from 8219FF50h-8219FFECh (39 instructions)

//////////////////////////////////////////////////////
// Block at 8219FFECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8219FFEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8219FFEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8219FFEC);
		  /* 8219FFECh */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 8219FFECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 8219FFECh case    0:*/		return 0x8219FFF0;
		  /* 8219FFF0h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 8219FFF0h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 8219FFF0h case    1:*/		return 0x8219FFF4;
		  /* 8219FFF4h */ case    2:  		/* cmplwi CR6, R11, 16000 */
		/* 8219FFF4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 8219FFF4h case    2:*/		return 0x8219FFF8;
		  /* 8219FFF8h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 8219FFF8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821A0014;  }
		/* 8219FFF8h case    3:*/		return 0x8219FFFC;
		  /* 8219FFFCh */ case    4:  		/* lwz R11, <#[R24 + 8]> */
		/* 8219FFFCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 8219FFFCh case    4:*/		return 0x821A0000;
		  /* 821A0000h */ case    5:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821A0000h case    5:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821A0000h case    5:*/		return 0x821A0004;
		  /* 821A0004h */ case    6:  		/* cmplwi CR6, R11, 16000 */
		/* 821A0004h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821A0004h case    6:*/		return 0x821A0008;
		  /* 821A0008h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 821A0008h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821A0014;  }
		/* 821A0008h case    7:*/		return 0x821A000C;
		  /* 821A000Ch */ case    8:  		/* li R3, 0 */
		/* 821A000Ch case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821A000Ch case    8:*/		return 0x821A0010;
		  /* 821A0010h */ case    9:  		/* b 1264 */
		/* 821A0010h case    9:*/		return 0x821A0500;
		/* 821A0010h case    9:*/		return 0x821A0014;
	}
	return 0x821A0014;
} // Block from 8219FFECh-821A0014h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821A0014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0014);
		  /* 821A0014h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 821A0014h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821A0014h case    0:*/		return 0x821A0018;
		  /* 821A0018h */ case    1:  		/* lwz R10, <#[R27]> */
		/* 821A0018h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 821A0018h case    1:*/		return 0x821A001C;
		  /* 821A001Ch */ case    2:  		/* xor R10, R11, R10 */
		/* 821A001Ch case    2:*/		cpu::op::xor<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 821A001Ch case    2:*/		return 0x821A0020;
		  /* 821A0020h */ case    3:  		/* rlwinm. R10, R10, 0, 27, 30 */
		/* 821A0020h case    3:*/		cpu::op::rlwinm<1,0,27,30>(regs,&regs.R10,regs.R10);
		/* 821A0020h case    3:*/		return 0x821A0024;
		  /* 821A0024h */ case    4:  		/* bc 4, CR0_EQ, 1240 */
		/* 821A0024h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821A04FC;  }
		/* 821A0024h case    4:*/		return 0x821A0028;
		  /* 821A0028h */ case    5:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 821A0028h case    5:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 821A0028h case    5:*/		return 0x821A002C;
		  /* 821A002Ch */ case    6:  		/* bc 12, CR0_EQ, 44 */
		/* 821A002Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x821A0058;  }
		/* 821A002Ch case    6:*/		return 0x821A0030;
		  /* 821A0030h */ case    7:  		/* mr R3, R29 */
		/* 821A0030h case    7:*/		regs.R3 = regs.R29;
		/* 821A0030h case    7:*/		return 0x821A0034;
		  /* 821A0034h */ case    8:  		/* bl -165148 */
		/* 821A0034h case    8:*/		regs.LR = 0x821A0038; return 0x82177B18;
		/* 821A0034h case    8:*/		return 0x821A0038;
		  /* 821A0038h */ case    9:  		/* mr R30, R3 */
		/* 821A0038h case    9:*/		regs.R30 = regs.R3;
		/* 821A0038h case    9:*/		return 0x821A003C;
		  /* 821A003Ch */ case   10:  		/* mr R3, R28 */
		/* 821A003Ch case   10:*/		regs.R3 = regs.R28;
		/* 821A003Ch case   10:*/		return 0x821A0040;
		  /* 821A0040h */ case   11:  		/* bl -165160 */
		/* 821A0040h case   11:*/		regs.LR = 0x821A0044; return 0x82177B18;
		/* 821A0040h case   11:*/		return 0x821A0044;
		  /* 821A0044h */ case   12:  		/* cmplw CR6, R30, R3 */
		/* 821A0044h case   12:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R3);
		/* 821A0044h case   12:*/		return 0x821A0048;
		  /* 821A0048h */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 821A0048h case   13:*/		if ( regs.CR[6].eq ) { return 0x821A0054;  }
		/* 821A0048h case   13:*/		return 0x821A004C;
		  /* 821A004Ch */ case   14:  		/* li R3, 3 */
		/* 821A004Ch case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 821A004Ch case   14:*/		return 0x821A0050;
		  /* 821A0050h */ case   15:  		/* b 1200 */
		/* 821A0050h case   15:*/		return 0x821A0500;
		/* 821A0050h case   15:*/		return 0x821A0054;
	}
	return 0x821A0054;
} // Block from 821A0014h-821A0054h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821A0054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0054);
		  /* 821A0054h */ case    0:  		/* stw R30, <#[R31 + 8]> */
		/* 821A0054h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 821A0054h case    0:*/		return 0x821A0058;
	}
	return 0x821A0058;
} // Block from 821A0054h-821A0058h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A0058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0058);
		  /* 821A0058h */ case    0:  		/* cmplw CR6, R25, R24 */
		/* 821A0058h case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R24);
		/* 821A0058h case    0:*/		return 0x821A005C;
		  /* 821A005Ch */ case    1:  		/* bc 12, CR6_EQ, -80 */
		/* 821A005Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821A000C;  }
		/* 821A005Ch case    1:*/		return 0x821A0060;
		  /* 821A0060h */ case    2:  		/* lwz R11, <#[R25 + 8]> */
		/* 821A0060h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 821A0060h case    2:*/		return 0x821A0064;
		  /* 821A0064h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821A0064h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821A0064h case    3:*/		return 0x821A0068;
		  /* 821A0068h */ case    4:  		/* cmplwi CR6, R11, 14848 */
		/* 821A0068h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A00);
		/* 821A0068h case    4:*/		return 0x821A006C;
		  /* 821A006Ch */ case    5:  		/* bc 12, CR6_EQ, 1168 */
		/* 821A006Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821A04FC;  }
		/* 821A006Ch case    5:*/		return 0x821A0070;
		  /* 821A0070h */ case    6:  		/* lwz R11, <#[R24 + 8]> */
		/* 821A0070h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 821A0070h case    6:*/		return 0x821A0074;
		  /* 821A0074h */ case    7:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821A0074h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821A0074h case    7:*/		return 0x821A0078;
		  /* 821A0078h */ case    8:  		/* cmplwi CR6, R11, 14848 */
		/* 821A0078h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A00);
		/* 821A0078h case    8:*/		return 0x821A007C;
		  /* 821A007Ch */ case    9:  		/* bc 12, CR6_EQ, 1152 */
		/* 821A007Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x821A04FC;  }
		/* 821A007Ch case    9:*/		return 0x821A0080;
		  /* 821A0080h */ case   10:  		/* lwz R11, <#[R31]> */
		/* 821A0080h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0080h case   10:*/		return 0x821A0084;
		  /* 821A0084h */ case   11:  		/* stw R21, <#[R31 + 4]> */
		/* 821A0084h case   11:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R31 + 0x00000004) );
		/* 821A0084h case   11:*/		return 0x821A0088;
		  /* 821A0088h */ case   12:  		/* ori R10, R11, 2 */
		/* 821A0088h case   12:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R11,0x2);
		/* 821A0088h case   12:*/		return 0x821A008C;
		  /* 821A008Ch */ case   13:  		/* stw R10, <#[R31]> */
		/* 821A008Ch case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821A008Ch case   13:*/		return 0x821A0090;
		  /* 821A0090h */ case   14:  		/* lwz R11, <#[R25 + 8]> */
		/* 821A0090h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 821A0090h case   14:*/		return 0x821A0094;
		  /* 821A0094h */ case   15:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821A0094h case   15:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821A0094h case   15:*/		return 0x821A0098;
		  /* 821A0098h */ case   16:  		/* cmplwi CR6, R11, 112 */
		/* 821A0098h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000070);
		/* 821A0098h case   16:*/		return 0x821A009C;
		  /* 821A009Ch */ case   17:  		/* bc 12, CR6_EQ, 36 */
		/* 821A009Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x821A00C0;  }
		/* 821A009Ch case   17:*/		return 0x821A00A0;
		  /* 821A00A0h */ case   18:  		/* cmplwi CR6, R11, 32 */
		/* 821A00A0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 821A00A0h case   18:*/		return 0x821A00A4;
		  /* 821A00A4h */ case   19:  		/* bc 12, CR6_LT, 16 */
		/* 821A00A4h case   19:*/		if ( regs.CR[6].lt ) { return 0x821A00B4;  }
		/* 821A00A4h case   19:*/		return 0x821A00A8;
		  /* 821A00A8h */ case   20:  		/* cmplwi CR6, R11, 82 */
		/* 821A00A8h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 821A00A8h case   20:*/		return 0x821A00AC;
		  /* 821A00ACh */ case   21:  		/* li R11, 1 */
		/* 821A00ACh case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821A00ACh case   21:*/		return 0x821A00B0;
		  /* 821A00B0h */ case   22:  		/* bc 4, CR6_GT, 8 */
		/* 821A00B0h case   22:*/		if ( !regs.CR[6].gt ) { return 0x821A00B8;  }
		/* 821A00B0h case   22:*/		return 0x821A00B4;
	}
	return 0x821A00B4;
} // Block from 821A0058h-821A00B4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821A00B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A00B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A00B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A00B4);
		  /* 821A00B4h */ case    0:  		/* mr R11, R21 */
		/* 821A00B4h case    0:*/		regs.R11 = regs.R21;
		/* 821A00B4h case    0:*/		return 0x821A00B8;
	}
	return 0x821A00B8;
} // Block from 821A00B4h-821A00B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A00B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A00B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A00B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A00B8);
		  /* 821A00B8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821A00B8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821A00B8h case    0:*/		return 0x821A00BC;
		  /* 821A00BCh */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 821A00BCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821A00F0;  }
		/* 821A00BCh case    1:*/		return 0x821A00C0;
	}
	return 0x821A00C0;
} // Block from 821A00B8h-821A00C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821A00C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A00C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A00C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A00C0);
		  /* 821A00C0h */ case    0:  		/* lwz R11, <#[R24 + 8]> */
		/* 821A00C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 821A00C0h case    0:*/		return 0x821A00C4;
		  /* 821A00C4h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821A00C4h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821A00C4h case    1:*/		return 0x821A00C8;
		  /* 821A00C8h */ case    2:  		/* cmplwi CR6, R11, 112 */
		/* 821A00C8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000070);
		/* 821A00C8h case    2:*/		return 0x821A00CC;
		  /* 821A00CCh */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 821A00CCh case    3:*/		if ( regs.CR[6].eq ) { return 0x821A00F8;  }
		/* 821A00CCh case    3:*/		return 0x821A00D0;
		  /* 821A00D0h */ case    4:  		/* cmplwi CR6, R11, 32 */
		/* 821A00D0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 821A00D0h case    4:*/		return 0x821A00D4;
		  /* 821A00D4h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 821A00D4h case    5:*/		if ( regs.CR[6].lt ) { return 0x821A00E4;  }
		/* 821A00D4h case    5:*/		return 0x821A00D8;
		  /* 821A00D8h */ case    6:  		/* cmplwi CR6, R11, 82 */
		/* 821A00D8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 821A00D8h case    6:*/		return 0x821A00DC;
		  /* 821A00DCh */ case    7:  		/* li R11, 1 */
		/* 821A00DCh case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821A00DCh case    7:*/		return 0x821A00E0;
		  /* 821A00E0h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 821A00E0h case    8:*/		if ( !regs.CR[6].gt ) { return 0x821A00E8;  }
		/* 821A00E0h case    8:*/		return 0x821A00E4;
	}
	return 0x821A00E4;
} // Block from 821A00C0h-821A00E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821A00E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A00E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A00E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A00E4);
		  /* 821A00E4h */ case    0:  		/* mr R11, R21 */
		/* 821A00E4h case    0:*/		regs.R11 = regs.R21;
		/* 821A00E4h case    0:*/		return 0x821A00E8;
	}
	return 0x821A00E8;
} // Block from 821A00E4h-821A00E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A00E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A00E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A00E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A00E8);
		  /* 821A00E8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821A00E8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821A00E8h case    0:*/		return 0x821A00EC;
		  /* 821A00ECh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 821A00ECh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821A00F8;  }
		/* 821A00ECh case    1:*/		return 0x821A00F0;
	}
	return 0x821A00F0;
} // Block from 821A00E8h-821A00F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821A00F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A00F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A00F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A00F0);
		  /* 821A00F0h */ case    0:  		/* li R11, 3 */
		/* 821A00F0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 821A00F0h case    0:*/		return 0x821A00F4;
		  /* 821A00F4h */ case    1:  		/* b 8 */
		/* 821A00F4h case    1:*/		return 0x821A00FC;
		/* 821A00F4h case    1:*/		return 0x821A00F8;
	}
	return 0x821A00F8;
} // Block from 821A00F0h-821A00F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821A00F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A00F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A00F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A00F8);
		  /* 821A00F8h */ case    0:  		/* li R11, 1 */
		/* 821A00F8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821A00F8h case    0:*/		return 0x821A00FC;
	}
	return 0x821A00FC;
} // Block from 821A00F8h-821A00FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A00FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A00FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A00FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A00FC);
		  /* 821A00FCh */ case    0:  		/* rlwimi R10, R11, 4, 21, 27 */
		/* 821A00FCh case    0:*/		cpu::op::rlwimi<0,4,21,27>(regs,&regs.R10,regs.R11);
		/* 821A00FCh case    0:*/		return 0x821A0100;
		  /* 821A0100h */ case    1:  		/* stw R10, <#[R31]> */
		/* 821A0100h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0100h case    1:*/		return 0x821A0104;
		  /* 821A0104h */ case    2:  		/* lwz R10, <#[R25 + 8]> */
		/* 821A0104h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 821A0104h case    2:*/		return 0x821A0108;
		  /* 821A0108h */ case    3:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 821A0108h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 821A0108h case    3:*/		return 0x821A010C;
		  /* 821A010Ch */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 821A010Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821A010Ch case    4:*/		return 0x821A0110;
		  /* 821A0110h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 821A0110h case    5:*/		if ( regs.CR[6].eq ) { return 0x821A0120;  }
		/* 821A0110h case    5:*/		return 0x821A0114;
		  /* 821A0114h */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 821A0114h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821A0114h case    6:*/		return 0x821A0118;
		  /* 821A0118h */ case    7:  		/* mr R11, R21 */
		/* 821A0118h case    7:*/		regs.R11 = regs.R21;
		/* 821A0118h case    7:*/		return 0x821A011C;
		  /* 821A011Ch */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 821A011Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x821A0124;  }
		/* 821A011Ch case    8:*/		return 0x821A0120;
	}
	return 0x821A0120;
} // Block from 821A00FCh-821A0120h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821A0120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0120);
		  /* 821A0120h */ case    0:  		/* li R11, 1 */
		/* 821A0120h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821A0120h case    0:*/		return 0x821A0124;
	}
	return 0x821A0124;
} // Block from 821A0120h-821A0124h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A0124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0124);
		  /* 821A0124h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821A0124h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821A0124h case    0:*/		return 0x821A0128;
		  /* 821A0128h */ case    1:  		/* bc 4, CR0_EQ, 980 */
		/* 821A0128h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821A04FC;  }
		/* 821A0128h case    1:*/		return 0x821A012C;
		  /* 821A012Ch */ case    2:  		/* lwz R11, <#[R24 + 8]> */
		/* 821A012Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 821A012Ch case    2:*/		return 0x821A0130;
		  /* 821A0130h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821A0130h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821A0130h case    3:*/		return 0x821A0134;
		  /* 821A0134h */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 821A0134h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821A0134h case    4:*/		return 0x821A0138;
		  /* 821A0138h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 821A0138h case    5:*/		if ( regs.CR[6].eq ) { return 0x821A0148;  }
		/* 821A0138h case    5:*/		return 0x821A013C;
		  /* 821A013Ch */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 821A013Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821A013Ch case    6:*/		return 0x821A0140;
		  /* 821A0140h */ case    7:  		/* mr R11, R21 */
		/* 821A0140h case    7:*/		regs.R11 = regs.R21;
		/* 821A0140h case    7:*/		return 0x821A0144;
		  /* 821A0144h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 821A0144h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821A014C;  }
		/* 821A0144h case    8:*/		return 0x821A0148;
	}
	return 0x821A0148;
} // Block from 821A0124h-821A0148h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821A0148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0148);
		  /* 821A0148h */ case    0:  		/* li R11, 1 */
		/* 821A0148h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821A0148h case    0:*/		return 0x821A014C;
	}
	return 0x821A014C;
} // Block from 821A0148h-821A014Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A014Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A014C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A014C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A014C);
		  /* 821A014Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821A014Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821A014Ch case    0:*/		return 0x821A0150;
		  /* 821A0150h */ case    1:  		/* bc 4, CR0_EQ, 940 */
		/* 821A0150h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821A04FC;  }
		/* 821A0150h case    1:*/		return 0x821A0154;
		  /* 821A0154h */ case    2:  		/* rlwinm. R11, R10, 6, 31, 31 */
		/* 821A0154h case    2:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R10);
		/* 821A0154h case    2:*/		return 0x821A0158;
		  /* 821A0158h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 821A0158h case    3:*/		if ( regs.CR[0].eq ) { return 0x821A0170;  }
		/* 821A0158h case    3:*/		return 0x821A015C;
		  /* 821A015Ch */ case    4:  		/* mr R4, R25 */
		/* 821A015Ch case    4:*/		regs.R4 = regs.R25;
		/* 821A015Ch case    4:*/		return 0x821A0160;
		  /* 821A0160h */ case    5:  		/* lwz R5, <#[R23 + 660]> */
		/* 821A0160h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R23 + 0x00000294) );
		/* 821A0160h case    5:*/		return 0x821A0164;
		  /* 821A0164h */ case    6:  		/* mr R3, R23 */
		/* 821A0164h case    6:*/		regs.R3 = regs.R23;
		/* 821A0164h case    6:*/		return 0x821A0168;
		  /* 821A0168h */ case    7:  		/* bl 116720 */
		/* 821A0168h case    7:*/		regs.LR = 0x821A016C; return 0x821BC958;
		/* 821A0168h case    7:*/		return 0x821A016C;
		  /* 821A016Ch */ case    8:  		/* mr R25, R3 */
		/* 821A016Ch case    8:*/		regs.R25 = regs.R3;
		/* 821A016Ch case    8:*/		return 0x821A0170;
	}
	return 0x821A0170;
} // Block from 821A014Ch-821A0170h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821A0170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0170);
		  /* 821A0170h */ case    0:  		/* lwz R11, <#[R24 + 8]> */
		/* 821A0170h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 821A0170h case    0:*/		return 0x821A0174;
		  /* 821A0174h */ case    1:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821A0174h case    1:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821A0174h case    1:*/		return 0x821A0178;
		  /* 821A0178h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 821A0178h case    2:*/		if ( regs.CR[0].eq ) { return 0x821A0190;  }
		/* 821A0178h case    2:*/		return 0x821A017C;
		  /* 821A017Ch */ case    3:  		/* mr R4, R24 */
		/* 821A017Ch case    3:*/		regs.R4 = regs.R24;
		/* 821A017Ch case    3:*/		return 0x821A0180;
		  /* 821A0180h */ case    4:  		/* lwz R5, <#[R23 + 660]> */
		/* 821A0180h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R23 + 0x00000294) );
		/* 821A0180h case    4:*/		return 0x821A0184;
		  /* 821A0184h */ case    5:  		/* mr R3, R23 */
		/* 821A0184h case    5:*/		regs.R3 = regs.R23;
		/* 821A0184h case    5:*/		return 0x821A0188;
		  /* 821A0188h */ case    6:  		/* bl 116688 */
		/* 821A0188h case    6:*/		regs.LR = 0x821A018C; return 0x821BC958;
		/* 821A0188h case    6:*/		return 0x821A018C;
		  /* 821A018Ch */ case    7:  		/* mr R24, R3 */
		/* 821A018Ch case    7:*/		regs.R24 = regs.R3;
		/* 821A018Ch case    7:*/		return 0x821A0190;
	}
	return 0x821A0190;
} // Block from 821A0170h-821A0190h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821A0190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0190);
		  /* 821A0190h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 821A0190h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821A0190h case    0:*/		return 0x821A0194;
		  /* 821A0194h */ case    1:  		/* rlwinm. R11, R11, 0, 27, 30 */
		/* 821A0194h case    1:*/		cpu::op::rlwinm<1,0,27,30>(regs,&regs.R11,regs.R11);
		/* 821A0194h case    1:*/		return 0x821A0198;
		  /* 821A0198h */ case    2:  		/* bc 4, CR0_EQ, 124 */
		/* 821A0198h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821A0214;  }
		/* 821A0198h case    2:*/		return 0x821A019C;
		  /* 821A019Ch */ case    3:  		/* li R8, 0 */
		/* 821A019Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821A019Ch case    3:*/		return 0x821A01A0;
		  /* 821A01A0h */ case    4:  		/* li R7, 0 */
		/* 821A01A0h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821A01A0h case    4:*/		return 0x821A01A4;
		  /* 821A01A4h */ case    5:  		/* mr R6, R31 */
		/* 821A01A4h case    5:*/		regs.R6 = regs.R31;
		/* 821A01A4h case    5:*/		return 0x821A01A8;
		  /* 821A01A8h */ case    6:  		/* mr R5, R27 */
		/* 821A01A8h case    6:*/		regs.R5 = regs.R27;
		/* 821A01A8h case    6:*/		return 0x821A01AC;
		  /* 821A01ACh */ case    7:  		/* mr R4, R25 */
		/* 821A01ACh case    7:*/		regs.R4 = regs.R25;
		/* 821A01ACh case    7:*/		return 0x821A01B0;
		  /* 821A01B0h */ case    8:  		/* mr R3, R23 */
		/* 821A01B0h case    8:*/		regs.R3 = regs.R23;
		/* 821A01B0h case    8:*/		return 0x821A01B4;
		  /* 821A01B4h */ case    9:  		/* bl -2876 */
		/* 821A01B4h case    9:*/		regs.LR = 0x821A01B8; return 0x8219F678;
		/* 821A01B4h case    9:*/		return 0x821A01B8;
		  /* 821A01B8h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A01B8h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A01B8h case   10:*/		return 0x821A01BC;
		  /* 821A01BCh */ case   11:  		/* bc 12, CR0_EQ, 32 */
		/* 821A01BCh case   11:*/		if ( regs.CR[0].eq ) { return 0x821A01DC;  }
		/* 821A01BCh case   11:*/		return 0x821A01C0;
		  /* 821A01C0h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 821A01C0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A01C0h case   12:*/		return 0x821A01C4;
		  /* 821A01C4h */ case   13:  		/* rlwinm R11, R11, 0, 31, 29 */
		/* 821A01C4h case   13:*/		cpu::op::rlwinm<0,0,31,29>(regs,&regs.R11,regs.R11);
		/* 821A01C4h case   13:*/		return 0x821A01C8;
		  /* 821A01C8h */ case   14:  		/* rlwinm R11, R11, 0, 28, 20 */
		/* 821A01C8h case   14:*/		cpu::op::rlwinm<0,0,28,20>(regs,&regs.R11,regs.R11);
		/* 821A01C8h case   14:*/		return 0x821A01CC;
		  /* 821A01CCh */ case   15:  		/* oris R11, R11, 4 */
		/* 821A01CCh case   15:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821A01CCh case   15:*/		return 0x821A01D0;
		  /* 821A01D0h */ case   16:  		/* li R3, 0 */
		/* 821A01D0h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821A01D0h case   16:*/		return 0x821A01D4;
		  /* 821A01D4h */ case   17:  		/* stw R11, <#[R31]> */
		/* 821A01D4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A01D4h case   17:*/		return 0x821A01D8;
		  /* 821A01D8h */ case   18:  		/* b 808 */
		/* 821A01D8h case   18:*/		return 0x821A0500;
		/* 821A01D8h case   18:*/		return 0x821A01DC;
	}
	return 0x821A01DC;
} // Block from 821A0190h-821A01DCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 821A01DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A01DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A01DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A01DC);
		  /* 821A01DCh */ case    0:  		/* li R8, 0 */
		/* 821A01DCh case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821A01DCh case    0:*/		return 0x821A01E0;
		  /* 821A01E0h */ case    1:  		/* li R7, 0 */
		/* 821A01E0h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821A01E0h case    1:*/		return 0x821A01E4;
		  /* 821A01E4h */ case    2:  		/* mr R6, R31 */
		/* 821A01E4h case    2:*/		regs.R6 = regs.R31;
		/* 821A01E4h case    2:*/		return 0x821A01E8;
		  /* 821A01E8h */ case    3:  		/* mr R5, R26 */
		/* 821A01E8h case    3:*/		regs.R5 = regs.R26;
		/* 821A01E8h case    3:*/		return 0x821A01EC;
		  /* 821A01ECh */ case    4:  		/* mr R4, R24 */
		/* 821A01ECh case    4:*/		regs.R4 = regs.R24;
		/* 821A01ECh case    4:*/		return 0x821A01F0;
		  /* 821A01F0h */ case    5:  		/* mr R3, R23 */
		/* 821A01F0h case    5:*/		regs.R3 = regs.R23;
		/* 821A01F0h case    5:*/		return 0x821A01F4;
		  /* 821A01F4h */ case    6:  		/* bl -2940 */
		/* 821A01F4h case    6:*/		regs.LR = 0x821A01F8; return 0x8219F678;
		/* 821A01F4h case    6:*/		return 0x821A01F8;
		  /* 821A01F8h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A01F8h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A01F8h case    7:*/		return 0x821A01FC;
		  /* 821A01FCh */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 821A01FCh case    8:*/		if ( regs.CR[0].eq ) { return 0x821A0214;  }
		/* 821A01FCh case    8:*/		return 0x821A0200;
		  /* 821A0200h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 821A0200h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0200h case    9:*/		return 0x821A0204;
		  /* 821A0204h */ case   10:  		/* rlwinm R11, R11, 0, 31, 29 */
		/* 821A0204h case   10:*/		cpu::op::rlwinm<0,0,31,29>(regs,&regs.R11,regs.R11);
		/* 821A0204h case   10:*/		return 0x821A0208;
		  /* 821A0208h */ case   11:  		/* rlwinm R11, R11, 0, 28, 20 */
		/* 821A0208h case   11:*/		cpu::op::rlwinm<0,0,28,20>(regs,&regs.R11,regs.R11);
		/* 821A0208h case   11:*/		return 0x821A020C;
		  /* 821A020Ch */ case   12:  		/* oris R11, R11, 8 */
		/* 821A020Ch case   12:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 821A020Ch case   12:*/		return 0x821A0210;
		  /* 821A0210h */ case   13:  		/* b -64 */
		/* 821A0210h case   13:*/		return 0x821A01D0;
		/* 821A0210h case   13:*/		return 0x821A0214;
	}
	return 0x821A0214;
} // Block from 821A01DCh-821A0214h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821A0214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0214);
		  /* 821A0214h */ case    0:  		/* rlwinm. R11, R22, 0, 24, 31 */
		/* 821A0214h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R22);
		/* 821A0214h case    0:*/		return 0x821A0218;
		  /* 821A0218h */ case    1:  		/* bc 12, CR0_EQ, -524 */
		/* 821A0218h case    1:*/		if ( regs.CR[0].eq ) { return 0x821A000C;  }
		/* 821A0218h case    1:*/		return 0x821A021C;
		  /* 821A021Ch */ case    2:  		/* lwz R11, <#[R24 + 8]> */
		/* 821A021Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 821A021Ch case    2:*/		return 0x821A0220;
		  /* 821A0220h */ case    3:  		/* lwz R10, <#[R25 + 8]> */
		/* 821A0220h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 821A0220h case    3:*/		return 0x821A0224;
		  /* 821A0224h */ case    4:  		/* rlwinm R9, R11, 9, 31, 31 */
		/* 821A0224h case    4:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R9,regs.R11);
		/* 821A0224h case    4:*/		return 0x821A0228;
		  /* 821A0228h */ case    5:  		/* rlwinm R11, R10, 9, 31, 31 */
		/* 821A0228h case    5:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R11,regs.R10);
		/* 821A0228h case    5:*/		return 0x821A022C;
		  /* 821A022Ch */ case    6:  		/* cmplw CR6, R11, R9 */
		/* 821A022Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821A022Ch case    6:*/		return 0x821A0230;
		  /* 821A0230h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 821A0230h case    7:*/		if ( regs.CR[6].eq ) { return 0x821A023C;  }
		/* 821A0230h case    7:*/		return 0x821A0234;
		  /* 821A0234h */ case    8:  		/* li R3, 1 */
		/* 821A0234h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821A0234h case    8:*/		return 0x821A0238;
		  /* 821A0238h */ case    9:  		/* b 712 */
		/* 821A0238h case    9:*/		return 0x821A0500;
		/* 821A0238h case    9:*/		return 0x821A023C;
	}
	return 0x821A023C;
} // Block from 821A0214h-821A023Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 821A023Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A023C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A023C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A023C);
		  /* 821A023Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821A023Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821A023Ch case    0:*/		return 0x821A0240;
	}
	return 0x821A0240;
} // Block from 821A023Ch-821A0240h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A0240h
// Function '?CanCombineOperands_FirstTwoCommutative@Compiler@D3DXShader@@AAA_NPAPAVDependency@2@00@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0240);
		  /* 821A0240h */ case    0:  		/* bc 12, CR6_EQ, 28 */
		/* 821A0240h case    0:*/		if ( regs.CR[6].eq ) { return 0x821A025C;  }
		/* 821A0240h case    0:*/		return 0x821A0244;
		  /* 821A0244h */ case    1:  		/* mr R5, R24 */
		/* 821A0244h case    1:*/		regs.R5 = regs.R24;
		/* 821A0244h case    1:*/		return 0x821A0248;
		  /* 821A0248h */ case    2:  		/* mr R4, R25 */
		/* 821A0248h case    2:*/		regs.R4 = regs.R25;
		/* 821A0248h case    2:*/		return 0x821A024C;
		  /* 821A024Ch */ case    3:  		/* mr R3, R23 */
		/* 821A024Ch case    3:*/		regs.R3 = regs.R23;
		/* 821A024Ch case    3:*/		return 0x821A0250;
		  /* 821A0250h */ case    4:  		/* bl -12640 */
		/* 821A0250h case    4:*/		regs.LR = 0x821A0254; return 0x8219D0F0;
		/* 821A0250h case    4:*/		return 0x821A0254;
		  /* 821A0254h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A0254h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A0254h case    5:*/		return 0x821A0258;
		  /* 821A0258h */ case    6:  		/* bc 12, CR0_EQ, -36 */
		/* 821A0258h case    6:*/		if ( regs.CR[0].eq ) { return 0x821A0234;  }
		/* 821A0258h case    6:*/		return 0x821A025C;
	}
	return 0x821A025C;
} // Block from 821A0240h-821A025Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 821A025Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A025C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A025C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A025C);
		  /* 821A025Ch */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 821A025Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 821A025Ch case    0:*/		return 0x821A0260;
		  /* 821A0260h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821A0260h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821A0260h case    1:*/		return 0x821A0264;
		  /* 821A0264h */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 821A0264h case    2:*/		if ( regs.CR[6].eq ) { return 0x821A02A0;  }
		/* 821A0264h case    2:*/		return 0x821A0268;
		  /* 821A0268h */ case    3:  		/* lwz R10, <#[R11 + 16]> */
		/* 821A0268h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821A0268h case    3:*/		return 0x821A026C;
		  /* 821A026Ch */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 821A026Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821A026Ch case    4:*/		return 0x821A0270;
		  /* 821A0270h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 821A0270h case    5:*/		if ( regs.CR[6].eq ) { return 0x821A0290;  }
		/* 821A0270h case    5:*/		return 0x821A0274;
		  /* 821A0274h */ case    6:  		/* lwz R9, <#[R10 + 8]> */
		/* 821A0274h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 821A0274h case    6:*/		return 0x821A0278;
		  /* 821A0278h */ case    7:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 821A0278h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 821A0278h case    7:*/		return 0x821A027C;
		  /* 821A027Ch */ case    8:  		/* cmplwi CR6, R9, 14080 */
		/* 821A027Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003700);
		/* 821A027Ch case    8:*/		return 0x821A0280;
		  /* 821A0280h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 821A0280h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821A0290;  }
		/* 821A0280h case    9:*/		return 0x821A0284;
		  /* 821A0284h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 821A0284h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821A0284h case   10:*/		return 0x821A0288;
		  /* 821A0288h */ case   11:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 821A0288h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 821A0288h case   11:*/		return 0x821A028C;
		  /* 821A028Ch */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 821A028Ch case   12:*/		if ( !regs.CR[0].eq ) { return 0x821A0298;  }
		/* 821A028Ch case   12:*/		return 0x821A0290;
	}
	return 0x821A0290;
} // Block from 821A025Ch-821A0290h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821A0290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0290);
		  /* 821A0290h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821A0290h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821A0290h case    0:*/		return 0x821A0294;
		  /* 821A0294h */ case    1:  		/* b -52 */
		/* 821A0294h case    1:*/		return 0x821A0260;
		/* 821A0294h case    1:*/		return 0x821A0298;
	}
	return 0x821A0298;
} // Block from 821A0290h-821A0298h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821A0298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0298);
		  /* 821A0298h */ case    0:  		/* mr R29, R10 */
		/* 821A0298h case    0:*/		regs.R29 = regs.R10;
		/* 821A0298h case    0:*/		return 0x821A029C;
		  /* 821A029Ch */ case    1:  		/* b 8 */
		/* 821A029Ch case    1:*/		return 0x821A02A4;
		/* 821A029Ch case    1:*/		return 0x821A02A0;
	}
	return 0x821A02A0;
} // Block from 821A0298h-821A02A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821A02A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A02A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A02A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A02A0);
		  /* 821A02A0h */ case    0:  		/* mr R29, R21 */
		/* 821A02A0h case    0:*/		regs.R29 = regs.R21;
		/* 821A02A0h case    0:*/		return 0x821A02A4;
	}
	return 0x821A02A4;
} // Block from 821A02A0h-821A02A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A02A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A02A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A02A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A02A4);
		  /* 821A02A4h */ case    0:  		/* lwz R11, <#[R24 + 4]> */
		/* 821A02A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 821A02A4h case    0:*/		return 0x821A02A8;
		  /* 821A02A8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821A02A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821A02A8h case    1:*/		return 0x821A02AC;
		  /* 821A02ACh */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 821A02ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x821A02E0;  }
		/* 821A02ACh case    2:*/		return 0x821A02B0;
		  /* 821A02B0h */ case    3:  		/* lwz R30, <#[R11 + 16]> */
		/* 821A02B0h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000010) );
		/* 821A02B0h case    3:*/		return 0x821A02B4;
		  /* 821A02B4h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 821A02B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821A02B4h case    4:*/		return 0x821A02B8;
		  /* 821A02B8h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 821A02B8h case    5:*/		if ( regs.CR[6].eq ) { return 0x821A02D8;  }
		/* 821A02B8h case    5:*/		return 0x821A02BC;
		  /* 821A02BCh */ case    6:  		/* lwz R10, <#[R30 + 8]> */
		/* 821A02BCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 821A02BCh case    6:*/		return 0x821A02C0;
		  /* 821A02C0h */ case    7:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821A02C0h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821A02C0h case    7:*/		return 0x821A02C4;
		  /* 821A02C4h */ case    8:  		/* cmplwi CR6, R10, 14080 */
		/* 821A02C4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 821A02C4h case    8:*/		return 0x821A02C8;
		  /* 821A02C8h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 821A02C8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821A02D8;  }
		/* 821A02C8h case    9:*/		return 0x821A02CC;
		  /* 821A02CCh */ case   10:  		/* lwz R10, <#[R11]> */
		/* 821A02CCh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821A02CCh case   10:*/		return 0x821A02D0;
		  /* 821A02D0h */ case   11:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 821A02D0h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 821A02D0h case   11:*/		return 0x821A02D4;
		  /* 821A02D4h */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 821A02D4h case   12:*/		if ( !regs.CR[0].eq ) { return 0x821A02E4;  }
		/* 821A02D4h case   12:*/		return 0x821A02D8;
	}
	return 0x821A02D8;
} // Block from 821A02A4h-821A02D8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821A02D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A02D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A02D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A02D8);
		  /* 821A02D8h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821A02D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821A02D8h case    0:*/		return 0x821A02DC;
		  /* 821A02DCh */ case    1:  		/* b -52 */
		/* 821A02DCh case    1:*/		return 0x821A02A8;
		/* 821A02DCh case    1:*/		return 0x821A02E0;
	}
	return 0x821A02E0;
} // Block from 821A02D8h-821A02E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821A02E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A02E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A02E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A02E0);
		  /* 821A02E0h */ case    0:  		/* mr R30, R21 */
		/* 821A02E0h case    0:*/		regs.R30 = regs.R21;
		/* 821A02E0h case    0:*/		return 0x821A02E4;
	}
	return 0x821A02E4;
} // Block from 821A02E0h-821A02E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A02E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A02E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A02E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A02E4);
		  /* 821A02E4h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 821A02E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821A02E4h case    0:*/		return 0x821A02E8;
		  /* 821A02E8h */ case    1:  		/* bc 12, CR6_EQ, 176 */
		/* 821A02E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821A0398;  }
		/* 821A02E8h case    1:*/		return 0x821A02EC;
		  /* 821A02ECh */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 821A02ECh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821A02ECh case    2:*/		return 0x821A02F0;
		  /* 821A02F0h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 821A02F0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821A02FC;  }
		/* 821A02F0h case    3:*/		return 0x821A02F4;
		  /* 821A02F4h */ case    4:  		/* cmplw CR6, R29, R30 */
		/* 821A02F4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 821A02F4h case    4:*/		return 0x821A02F8;
		  /* 821A02F8h */ case    5:  		/* bc 4, CR6_EQ, -196 */
		/* 821A02F8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821A0234;  }
		/* 821A02F8h case    5:*/		return 0x821A02FC;
	}
	return 0x821A02FC;
} // Block from 821A02E4h-821A02FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821A02FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A02FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A02FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A02FC);
		  /* 821A02FCh */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 821A02FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821A02FCh case    0:*/		return 0x821A0300;
		  /* 821A0300h */ case    1:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821A0300h case    1:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821A0300h case    1:*/		return 0x821A0304;
		  /* 821A0304h */ case    2:  		/* bc 12, CR0_EQ, 88 */
		/* 821A0304h case    2:*/		if ( regs.CR[0].eq ) { return 0x821A035C;  }
		/* 821A0304h case    2:*/		return 0x821A0308;
		  /* 821A0308h */ case    3:  		/* mr R4, R29 */
		/* 821A0308h case    3:*/		regs.R4 = regs.R29;
		/* 821A0308h case    3:*/		return 0x821A030C;
		  /* 821A030Ch */ case    4:  		/* lwz R5, <#[R23 + 660]> */
		/* 821A030Ch case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R23 + 0x00000294) );
		/* 821A030Ch case    4:*/		return 0x821A0310;
		  /* 821A0310h */ case    5:  		/* mr R3, R23 */
		/* 821A0310h case    5:*/		regs.R3 = regs.R23;
		/* 821A0310h case    5:*/		return 0x821A0314;
		  /* 821A0314h */ case    6:  		/* bl 116292 */
		/* 821A0314h case    6:*/		regs.LR = 0x821A0318; return 0x821BC958;
		/* 821A0314h case    6:*/		return 0x821A0318;
		  /* 821A0318h */ case    7:  		/* lwz R11, <#[R24 + 4]> */
		/* 821A0318h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 821A0318h case    7:*/		return 0x821A031C;
		  /* 821A031Ch */ case    8:  		/* mr R29, R3 */
		/* 821A031Ch case    8:*/		regs.R29 = regs.R3;
		/* 821A031Ch case    8:*/		return 0x821A0320;
		  /* 821A0320h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 821A0320h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821A0320h case    9:*/		return 0x821A0324;
		  /* 821A0324h */ case   10:  		/* bc 12, CR6_EQ, 52 */
		/* 821A0324h case   10:*/		if ( regs.CR[6].eq ) { return 0x821A0358;  }
		/* 821A0324h case   10:*/		return 0x821A0328;
		  /* 821A0328h */ case   11:  		/* lwz R30, <#[R11 + 16]> */
		/* 821A0328h case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000010) );
		/* 821A0328h case   11:*/		return 0x821A032C;
		  /* 821A032Ch */ case   12:  		/* cmplwi CR6, R30, 0 */
		/* 821A032Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821A032Ch case   12:*/		return 0x821A0330;
		  /* 821A0330h */ case   13:  		/* bc 12, CR6_EQ, 32 */
		/* 821A0330h case   13:*/		if ( regs.CR[6].eq ) { return 0x821A0350;  }
		/* 821A0330h case   13:*/		return 0x821A0334;
		  /* 821A0334h */ case   14:  		/* lwz R10, <#[R30 + 8]> */
		/* 821A0334h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 821A0334h case   14:*/		return 0x821A0338;
		  /* 821A0338h */ case   15:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821A0338h case   15:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821A0338h case   15:*/		return 0x821A033C;
		  /* 821A033Ch */ case   16:  		/* cmplwi CR6, R10, 14080 */
		/* 821A033Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 821A033Ch case   16:*/		return 0x821A0340;
		  /* 821A0340h */ case   17:  		/* bc 4, CR6_EQ, 16 */
		/* 821A0340h case   17:*/		if ( !regs.CR[6].eq ) { return 0x821A0350;  }
		/* 821A0340h case   17:*/		return 0x821A0344;
		  /* 821A0344h */ case   18:  		/* lwz R10, <#[R11]> */
		/* 821A0344h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821A0344h case   18:*/		return 0x821A0348;
		  /* 821A0348h */ case   19:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 821A0348h case   19:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 821A0348h case   19:*/		return 0x821A034C;
		  /* 821A034Ch */ case   20:  		/* bc 4, CR0_EQ, 16 */
		/* 821A034Ch case   20:*/		if ( !regs.CR[0].eq ) { return 0x821A035C;  }
		/* 821A034Ch case   20:*/		return 0x821A0350;
	}
	return 0x821A0350;
} // Block from 821A02FCh-821A0350h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821A0350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0350);
		  /* 821A0350h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821A0350h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821A0350h case    0:*/		return 0x821A0354;
		  /* 821A0354h */ case    1:  		/* b -52 */
		/* 821A0354h case    1:*/		return 0x821A0320;
		/* 821A0354h case    1:*/		return 0x821A0358;
	}
	return 0x821A0358;
} // Block from 821A0350h-821A0358h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821A0358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0358);
		  /* 821A0358h */ case    0:  		/* mr R30, R21 */
		/* 821A0358h case    0:*/		regs.R30 = regs.R21;
		/* 821A0358h case    0:*/		return 0x821A035C;
	}
	return 0x821A035C;
} // Block from 821A0358h-821A035Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A035Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A035C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A035C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A035C);
		  /* 821A035Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821A035Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A035Ch case    0:*/		return 0x821A0360;
		  /* 821A0360h */ case    1:  		/* mr R8, R31 */
		/* 821A0360h case    1:*/		regs.R8 = regs.R31;
		/* 821A0360h case    1:*/		return 0x821A0364;
		  /* 821A0364h */ case    2:  		/* mr R7, R20 */
		/* 821A0364h case    2:*/		regs.R7 = regs.R20;
		/* 821A0364h case    2:*/		return 0x821A0368;
		  /* 821A0368h */ case    3:  		/* rlwinm R11, R11, 0, 28, 20 */
		/* 821A0368h case    3:*/		cpu::op::rlwinm<0,0,28,20>(regs,&regs.R11,regs.R11);
		/* 821A0368h case    3:*/		return 0x821A036C;
		  /* 821A036Ch */ case    4:  		/* mr R6, R24 */
		/* 821A036Ch case    4:*/		regs.R6 = regs.R24;
		/* 821A036Ch case    4:*/		return 0x821A0370;
		  /* 821A0370h */ case    5:  		/* stw R11, <#[R31]> */
		/* 821A0370h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0370h case    5:*/		return 0x821A0374;
		  /* 821A0374h */ case    6:  		/* mr R5, R25 */
		/* 821A0374h case    6:*/		regs.R5 = regs.R25;
		/* 821A0374h case    6:*/		return 0x821A0378;
		  /* 821A0378h */ case    7:  		/* mr R4, R29 */
		/* 821A0378h case    7:*/		regs.R4 = regs.R29;
		/* 821A0378h case    7:*/		return 0x821A037C;
		  /* 821A037Ch */ case    8:  		/* mr R3, R23 */
		/* 821A037Ch case    8:*/		regs.R3 = regs.R23;
		/* 821A037Ch case    8:*/		return 0x821A0380;
		  /* 821A0380h */ case    9:  		/* bl -17632 */
		/* 821A0380h case    9:*/		regs.LR = 0x821A0384; return 0x8219BEA0;
		/* 821A0380h case    9:*/		return 0x821A0384;
		  /* 821A0384h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A0384h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A0384h case   10:*/		return 0x821A0388;
		  /* 821A0388h */ case   11:  		/* bc 12, CR0_EQ, 372 */
		/* 821A0388h case   11:*/		if ( regs.CR[0].eq ) { return 0x821A04FC;  }
		/* 821A0388h case   11:*/		return 0x821A038C;
		  /* 821A038Ch */ case   12:  		/* lwz R11, <#[R31]> */
		/* 821A038Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A038Ch case   12:*/		return 0x821A0390;
		  /* 821A0390h */ case   13:  		/* rlwinm R11, R11, 0, 20, 18 */
		/* 821A0390h case   13:*/		cpu::op::rlwinm<0,0,20,18>(regs,&regs.R11,regs.R11);
		/* 821A0390h case   13:*/		return 0x821A0394;
		  /* 821A0394h */ case   14:  		/* stw R11, <#[R31]> */
		/* 821A0394h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0394h case   14:*/		return 0x821A0398;
	}
	return 0x821A0398;
} // Block from 821A035Ch-821A0398h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821A0398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0398);
		  /* 821A0398h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821A0398h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821A0398h case    0:*/		return 0x821A039C;
		  /* 821A039Ch */ case    1:  		/* bc 12, CR6_EQ, 96 */
		/* 821A039Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821A03FC;  }
		/* 821A039Ch case    1:*/		return 0x821A03A0;
		  /* 821A03A0h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 821A03A0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821A03A0h case    2:*/		return 0x821A03A4;
		  /* 821A03A4h */ case    3:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821A03A4h case    3:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821A03A4h case    3:*/		return 0x821A03A8;
		  /* 821A03A8h */ case    4:  		/* bc 12, CR0_EQ, 24 */
		/* 821A03A8h case    4:*/		if ( regs.CR[0].eq ) { return 0x821A03C0;  }
		/* 821A03A8h case    4:*/		return 0x821A03AC;
		  /* 821A03ACh */ case    5:  		/* mr R4, R30 */
		/* 821A03ACh case    5:*/		regs.R4 = regs.R30;
		/* 821A03ACh case    5:*/		return 0x821A03B0;
		  /* 821A03B0h */ case    6:  		/* lwz R5, <#[R23 + 660]> */
		/* 821A03B0h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R23 + 0x00000294) );
		/* 821A03B0h case    6:*/		return 0x821A03B4;
		  /* 821A03B4h */ case    7:  		/* mr R3, R23 */
		/* 821A03B4h case    7:*/		regs.R3 = regs.R23;
		/* 821A03B4h case    7:*/		return 0x821A03B8;
		  /* 821A03B8h */ case    8:  		/* bl 116128 */
		/* 821A03B8h case    8:*/		regs.LR = 0x821A03BC; return 0x821BC958;
		/* 821A03B8h case    8:*/		return 0x821A03BC;
		  /* 821A03BCh */ case    9:  		/* mr R30, R3 */
		/* 821A03BCh case    9:*/		regs.R30 = regs.R3;
		/* 821A03BCh case    9:*/		return 0x821A03C0;
	}
	return 0x821A03C0;
} // Block from 821A0398h-821A03C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821A03C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A03C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A03C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A03C0);
		  /* 821A03C0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821A03C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A03C0h case    0:*/		return 0x821A03C4;
		  /* 821A03C4h */ case    1:  		/* mr R8, R31 */
		/* 821A03C4h case    1:*/		regs.R8 = regs.R31;
		/* 821A03C4h case    1:*/		return 0x821A03C8;
		  /* 821A03C8h */ case    2:  		/* mr R7, R20 */
		/* 821A03C8h case    2:*/		regs.R7 = regs.R20;
		/* 821A03C8h case    2:*/		return 0x821A03CC;
		  /* 821A03CCh */ case    3:  		/* rlwinm R11, R11, 0, 28, 20 */
		/* 821A03CCh case    3:*/		cpu::op::rlwinm<0,0,28,20>(regs,&regs.R11,regs.R11);
		/* 821A03CCh case    3:*/		return 0x821A03D0;
		  /* 821A03D0h */ case    4:  		/* mr R6, R25 */
		/* 821A03D0h case    4:*/		regs.R6 = regs.R25;
		/* 821A03D0h case    4:*/		return 0x821A03D4;
		  /* 821A03D4h */ case    5:  		/* stw R11, <#[R31]> */
		/* 821A03D4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A03D4h case    5:*/		return 0x821A03D8;
		  /* 821A03D8h */ case    6:  		/* mr R5, R24 */
		/* 821A03D8h case    6:*/		regs.R5 = regs.R24;
		/* 821A03D8h case    6:*/		return 0x821A03DC;
		  /* 821A03DCh */ case    7:  		/* mr R4, R30 */
		/* 821A03DCh case    7:*/		regs.R4 = regs.R30;
		/* 821A03DCh case    7:*/		return 0x821A03E0;
		  /* 821A03E0h */ case    8:  		/* mr R3, R23 */
		/* 821A03E0h case    8:*/		regs.R3 = regs.R23;
		/* 821A03E0h case    8:*/		return 0x821A03E4;
		  /* 821A03E4h */ case    9:  		/* bl -17732 */
		/* 821A03E4h case    9:*/		regs.LR = 0x821A03E8; return 0x8219BEA0;
		/* 821A03E4h case    9:*/		return 0x821A03E8;
		  /* 821A03E8h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A03E8h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A03E8h case   10:*/		return 0x821A03EC;
		  /* 821A03ECh */ case   11:  		/* bc 12, CR0_EQ, 272 */
		/* 821A03ECh case   11:*/		if ( regs.CR[0].eq ) { return 0x821A04FC;  }
		/* 821A03ECh case   11:*/		return 0x821A03F0;
		  /* 821A03F0h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 821A03F0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A03F0h case   12:*/		return 0x821A03F4;
		  /* 821A03F4h */ case   13:  		/* ori R11, R11, 4096 */
		/* 821A03F4h case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 821A03F4h case   13:*/		return 0x821A03F8;
		  /* 821A03F8h */ case   14:  		/* stw R11, <#[R31]> */
		/* 821A03F8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A03F8h case   14:*/		return 0x821A03FC;
	}
	return 0x821A03FC;
} // Block from 821A03C0h-821A03FCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 821A03FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A03FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A03FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A03FC);
		  /* 821A03FCh */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 821A03FCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821A03FCh case    0:*/		return 0x821A0400;
		  /* 821A0400h */ case    1:  		/* bc 4, CR6_EQ, 76 */
		/* 821A0400h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821A044C;  }
		/* 821A0400h case    1:*/		return 0x821A0404;
		  /* 821A0404h */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 821A0404h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821A0404h case    2:*/		return 0x821A0408;
		  /* 821A0408h */ case    3:  		/* bc 4, CR6_EQ, 68 */
		/* 821A0408h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821A044C;  }
		/* 821A0408h case    3:*/		return 0x821A040C;
		  /* 821A040Ch */ case    4:  		/* lwz R10, <#[R24 + 8]> */
		/* 821A040Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000008) );
		/* 821A040Ch case    4:*/		return 0x821A0410;
		  /* 821A0410h */ case    5:  		/* lwz R11, <#[R25 + 8]> */
		/* 821A0410h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 821A0410h case    5:*/		return 0x821A0414;
		  /* 821A0414h */ case    6:  		/* rlwinm R8, R10, 18, 29, 31 */
		/* 821A0414h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R8,regs.R10);
		/* 821A0414h case    6:*/		return 0x821A0418;
		  /* 821A0418h */ case    7:  		/* rlwinm R9, R11, 18, 29, 31 */
		/* 821A0418h case    7:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R9,regs.R11);
		/* 821A0418h case    7:*/		return 0x821A041C;
		  /* 821A041Ch */ case    8:  		/* add R9, R8, R9 */
		/* 821A041Ch case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821A041Ch case    8:*/		return 0x821A0420;
		  /* 821A0420h */ case    9:  		/* cmplwi CR6, R9, 4 */
		/* 821A0420h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000004);
		/* 821A0420h case    9:*/		return 0x821A0424;
		  /* 821A0424h */ case   10:  		/* bc 12, CR6_GT, 216 */
		/* 821A0424h case   10:*/		if ( regs.CR[6].gt ) { return 0x821A04FC;  }
		/* 821A0424h case   10:*/		return 0x821A0428;
		  /* 821A0428h */ case   11:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821A0428h case   11:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821A0428h case   11:*/		return 0x821A042C;
		  /* 821A042Ch */ case   12:  		/* cmplwi CR6, R11, 14080 */
		/* 821A042Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 821A042Ch case   12:*/		return 0x821A0430;
		  /* 821A0430h */ case   13:  		/* bc 12, CR6_EQ, 16 */
		/* 821A0430h case   13:*/		if ( regs.CR[6].eq ) { return 0x821A0440;  }
		/* 821A0430h case   13:*/		return 0x821A0434;
		  /* 821A0434h */ case   14:  		/* rlwinm R11, R10, 0, 18, 24 */
		/* 821A0434h case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R10);
		/* 821A0434h case   14:*/		return 0x821A0438;
		  /* 821A0438h */ case   15:  		/* cmplwi CR6, R11, 14080 */
		/* 821A0438h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 821A0438h case   15:*/		return 0x821A043C;
		  /* 821A043Ch */ case   16:  		/* bc 4, CR6_EQ, 16 */
		/* 821A043Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x821A044C;  }
		/* 821A043Ch case   16:*/		return 0x821A0440;
	}
	return 0x821A0440;
} // Block from 821A03FCh-821A0440h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821A0440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0440);
		  /* 821A0440h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821A0440h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0440h case    0:*/		return 0x821A0444;
		  /* 821A0444h */ case    1:  		/* rlwinm R11, R11, 0, 28, 20 */
		/* 821A0444h case    1:*/		cpu::op::rlwinm<0,0,28,20>(regs,&regs.R11,regs.R11);
		/* 821A0444h case    1:*/		return 0x821A0448;
		  /* 821A0448h */ case    2:  		/* stw R11, <#[R31]> */
		/* 821A0448h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0448h case    2:*/		return 0x821A044C;
	}
	return 0x821A044C;
} // Block from 821A0440h-821A044Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821A044Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A044C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A044C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A044C);
		  /* 821A044Ch */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 821A044Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 821A044Ch case    0:*/		return 0x821A0450;
		  /* 821A0450h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821A0450h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821A0450h case    1:*/		return 0x821A0454;
		  /* 821A0454h */ case    2:  		/* cmplwi CR6, R11, 110 */
		/* 821A0454h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006E);
		/* 821A0454h case    2:*/		return 0x821A0458;
		  /* 821A0458h */ case    3:  		/* bc 4, CR6_EQ, 108 */
		/* 821A0458h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821A04C4;  }
		/* 821A0458h case    3:*/		return 0x821A045C;
		  /* 821A045Ch */ case    4:  		/* lwz R10, <#[R24 + 8]> */
		/* 821A045Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000008) );
		/* 821A045Ch case    4:*/		return 0x821A0460;
		  /* 821A0460h */ case    5:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821A0460h case    5:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821A0460h case    5:*/		return 0x821A0464;
		  /* 821A0464h */ case    6:  		/* cmplwi CR6, R10, 14080 */
		/* 821A0464h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 821A0464h case    6:*/		return 0x821A0468;
		  /* 821A0468h */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 821A0468h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821A0490;  }
		/* 821A0468h case    7:*/		return 0x821A046C;
		  /* 821A046Ch */ case    8:  		/* li R7, 1 */
		/* 821A046Ch case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821A046Ch case    8:*/		return 0x821A0470;
		  /* 821A0470h */ case    9:  		/* li R6, 1 */
		/* 821A0470h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821A0470h case    9:*/		return 0x821A0474;
		  /* 821A0474h */ case   10:  		/* mr R5, R24 */
		/* 821A0474h case   10:*/		regs.R5 = regs.R24;
		/* 821A0474h case   10:*/		return 0x821A0478;
		  /* 821A0478h */ case   11:  		/* mr R4, R25 */
		/* 821A0478h case   11:*/		regs.R4 = regs.R25;
		/* 821A0478h case   11:*/		return 0x821A047C;
		  /* 821A047Ch */ case   12:  		/* mr R3, R23 */
		/* 821A047Ch case   12:*/		regs.R3 = regs.R23;
		/* 821A047Ch case   12:*/		return 0x821A0480;
		  /* 821A0480h */ case   13:  		/* bl 579056 */
		/* 821A0480h case   13:*/		regs.LR = 0x821A0484; return 0x8222DA70;
		/* 821A0480h case   13:*/		return 0x821A0484;
		  /* 821A0484h */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A0484h case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A0484h case   14:*/		return 0x821A0488;
		  /* 821A0488h */ case   15:  		/* bc 4, CR0_EQ, -1148 */
		/* 821A0488h case   15:*/		if ( !regs.CR[0].eq ) { return 0x821A000C;  }
		/* 821A0488h case   15:*/		return 0x821A048C;
		  /* 821A048Ch */ case   16:  		/* b -600 */
		/* 821A048Ch case   16:*/		return 0x821A0234;
		/* 821A048Ch case   16:*/		return 0x821A0490;
	}
	return 0x821A0490;
} // Block from 821A044Ch-821A0490h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821A0490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0490);
		  /* 821A0490h */ case    0:  		/* cmplwi CR6, R11, 110 */
		/* 821A0490h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006E);
		/* 821A0490h case    0:*/		return 0x821A0494;
		  /* 821A0494h */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 821A0494h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821A04C4;  }
		/* 821A0494h case    1:*/		return 0x821A0498;
		  /* 821A0498h */ case    2:  		/* lwz R11, <#[R24 + 8]> */
		/* 821A0498h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 821A0498h case    2:*/		return 0x821A049C;
		  /* 821A049Ch */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821A049Ch case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821A049Ch case    3:*/		return 0x821A04A0;
		  /* 821A04A0h */ case    4:  		/* cmplwi CR6, R11, 14336 */
		/* 821A04A0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821A04A0h case    4:*/		return 0x821A04A4;
		  /* 821A04A4h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 821A04A4h case    5:*/		if ( regs.CR[6].eq ) { return 0x821A04C4;  }
		/* 821A04A4h case    5:*/		return 0x821A04A8;
		  /* 821A04A8h */ case    6:  		/* li R6, 1 */
		/* 821A04A8h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821A04A8h case    6:*/		return 0x821A04AC;
		  /* 821A04ACh */ case    7:  		/* mr R5, R25 */
		/* 821A04ACh case    7:*/		regs.R5 = regs.R25;
		/* 821A04ACh case    7:*/		return 0x821A04B0;
		  /* 821A04B0h */ case    8:  		/* mr R4, R24 */
		/* 821A04B0h case    8:*/		regs.R4 = regs.R24;
		/* 821A04B0h case    8:*/		return 0x821A04B4;
		  /* 821A04B4h */ case    9:  		/* mr R3, R23 */
		/* 821A04B4h case    9:*/		regs.R3 = regs.R23;
		/* 821A04B4h case    9:*/		return 0x821A04B8;
		  /* 821A04B8h */ case   10:  		/* bl 573360 */
		/* 821A04B8h case   10:*/		regs.LR = 0x821A04BC; return 0x8222C468;
		/* 821A04B8h case   10:*/		return 0x821A04BC;
		  /* 821A04BCh */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A04BCh case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A04BCh case   11:*/		return 0x821A04C0;
		  /* 821A04C0h */ case   12:  		/* bc 12, CR0_EQ, -652 */
		/* 821A04C0h case   12:*/		if ( regs.CR[0].eq ) { return 0x821A0234;  }
		/* 821A04C0h case   12:*/		return 0x821A04C4;
	}
	return 0x821A04C4;
} // Block from 821A0490h-821A04C4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821A04C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A04C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A04C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A04C4);
		  /* 821A04C4h */ case    0:  		/* lwz R11, <#[R24 + 8]> */
		/* 821A04C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 821A04C4h case    0:*/		return 0x821A04C8;
		  /* 821A04C8h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821A04C8h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821A04C8h case    1:*/		return 0x821A04CC;
		  /* 821A04CCh */ case    2:  		/* cmplwi CR6, R11, 14080 */
		/* 821A04CCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 821A04CCh case    2:*/		return 0x821A04D0;
		  /* 821A04D0h */ case    3:  		/* bc 4, CR6_EQ, -1220 */
		/* 821A04D0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821A000C;  }
		/* 821A04D0h case    3:*/		return 0x821A04D4;
		  /* 821A04D4h */ case    4:  		/* lwz R11, <#[R25 + 8]> */
		/* 821A04D4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 821A04D4h case    4:*/		return 0x821A04D8;
		  /* 821A04D8h */ case    5:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821A04D8h case    5:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821A04D8h case    5:*/		return 0x821A04DC;
		  /* 821A04DCh */ case    6:  		/* cmplwi CR6, R11, 14336 */
		/* 821A04DCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821A04DCh case    6:*/		return 0x821A04E0;
		  /* 821A04E0h */ case    7:  		/* bc 12, CR6_EQ, -1236 */
		/* 821A04E0h case    7:*/		if ( regs.CR[6].eq ) { return 0x821A000C;  }
		/* 821A04E0h case    7:*/		return 0x821A04E4;
		  /* 821A04E4h */ case    8:  		/* li R6, 1 */
		/* 821A04E4h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821A04E4h case    8:*/		return 0x821A04E8;
		  /* 821A04E8h */ case    9:  		/* mr R5, R24 */
		/* 821A04E8h case    9:*/		regs.R5 = regs.R24;
		/* 821A04E8h case    9:*/		return 0x821A04EC;
		  /* 821A04ECh */ case   10:  		/* mr R4, R25 */
		/* 821A04ECh case   10:*/		regs.R4 = regs.R25;
		/* 821A04ECh case   10:*/		return 0x821A04F0;
		  /* 821A04F0h */ case   11:  		/* mr R3, R23 */
		/* 821A04F0h case   11:*/		regs.R3 = regs.R23;
		/* 821A04F0h case   11:*/		return 0x821A04F4;
		  /* 821A04F4h */ case   12:  		/* bl 573300 */
		/* 821A04F4h case   12:*/		regs.LR = 0x821A04F8; return 0x8222C468;
		/* 821A04F4h case   12:*/		return 0x821A04F8;
		  /* 821A04F8h */ case   13:  		/* b -116 */
		/* 821A04F8h case   13:*/		return 0x821A0484;
		/* 821A04F8h case   13:*/		return 0x821A04FC;
	}
	return 0x821A04FC;
} // Block from 821A04C4h-821A04FCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 821A04FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A04FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A04FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A04FC);
		  /* 821A04FCh */ case    0:  		/* li R3, 2 */
		/* 821A04FCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 821A04FCh case    0:*/		return 0x821A0500;
	}
	return 0x821A0500;
} // Block from 821A04FCh-821A0500h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A0500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0500);
		  /* 821A0500h */ case    0:  		/* addi R1, R1, 224 */
		/* 821A0500h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 821A0500h case    0:*/		return 0x821A0504;
		  /* 821A0504h */ case    1:  		/* b -1110652 */
		/* 821A0504h case    1:*/		return 0x82091288;
		/* 821A0504h case    1:*/		return 0x821A0508;
	}
	return 0x821A0508;
} // Block from 821A0500h-821A0508h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821A0508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0508);
		  /* 821A0508h */ case    0:  		/* mfspr R12, LR */
		/* 821A0508h case    0:*/		regs.R12 = regs.LR;
		/* 821A0508h case    0:*/		return 0x821A050C;
		  /* 821A050Ch */ case    1:  		/* bl -1110728 */
		/* 821A050Ch case    1:*/		regs.LR = 0x821A0510; return 0x82091244;
		/* 821A050Ch case    1:*/		return 0x821A0510;
		  /* 821A0510h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 821A0510h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821A0510h case    2:*/		return 0x821A0514;
		  /* 821A0514h */ case    3:  		/* li R10, 1 */
		/* 821A0514h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821A0514h case    3:*/		return 0x821A0518;
		  /* 821A0518h */ case    4:  		/* mr R28, R3 */
		/* 821A0518h case    4:*/		regs.R28 = regs.R3;
		/* 821A0518h case    4:*/		return 0x821A051C;
		  /* 821A051Ch */ case    5:  		/* mr R24, R4 */
		/* 821A051Ch case    5:*/		regs.R24 = regs.R4;
		/* 821A051Ch case    5:*/		return 0x821A0520;
		  /* 821A0520h */ case    6:  		/* mr R27, R5 */
		/* 821A0520h case    6:*/		regs.R27 = regs.R5;
		/* 821A0520h case    6:*/		return 0x821A0524;
		  /* 821A0524h */ case    7:  		/* mr R23, R6 */
		/* 821A0524h case    7:*/		regs.R23 = regs.R6;
		/* 821A0524h case    7:*/		return 0x821A0528;
		  /* 821A0528h */ case    8:  		/* mr R25, R7 */
		/* 821A0528h case    8:*/		regs.R25 = regs.R7;
		/* 821A0528h case    8:*/		return 0x821A052C;
		  /* 821A052Ch */ case    9:  		/* mr R29, R8 */
		/* 821A052Ch case    9:*/		regs.R29 = regs.R8;
		/* 821A052Ch case    9:*/		return 0x821A0530;
		  /* 821A0530h */ case   10:  		/* mr R31, R9 */
		/* 821A0530h case   10:*/		regs.R31 = regs.R9;
		/* 821A0530h case   10:*/		return 0x821A0534;
		  /* 821A0534h */ case   11:  		/* bl -1692 */
		/* 821A0534h case   11:*/		regs.LR = 0x821A0538; return 0x8219FE98;
		/* 821A0534h case   11:*/		return 0x821A0538;
		  /* 821A0538h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 821A0538h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 821A0538h case   12:*/		return 0x821A053C;
		  /* 821A053Ch */ case   13:  		/* bc 12, CR0_EQ, 496 */
		/* 821A053Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x821A072C;  }
		/* 821A053Ch case   13:*/		return 0x821A0540;
		  /* 821A0540h */ case   14:  		/* cmpwi CR6, R3, 3 */
		/* 821A0540h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 821A0540h case   14:*/		return 0x821A0544;
		  /* 821A0544h */ case   15:  		/* bc 4, CR6_EQ, 12 */
		/* 821A0544h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821A0550;  }
		/* 821A0544h case   15:*/		return 0x821A0548;
		  /* 821A0548h */ case   16:  		/* li R3, 0 */
		/* 821A0548h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821A0548h case   16:*/		return 0x821A054C;
		  /* 821A054Ch */ case   17:  		/* b 484 */
		/* 821A054Ch case   17:*/		return 0x821A0730;
		/* 821A054Ch case   17:*/		return 0x821A0550;
	}
	return 0x821A0550;
} // Block from 821A0508h-821A0550h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821A0550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0550);
		  /* 821A0550h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821A0550h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0550h case    0:*/		return 0x821A0554;
		  /* 821A0554h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821A0554h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821A0554h case    1:*/		return 0x821A0558;
		  /* 821A0558h */ case    2:  		/* stw R11, <#[R31]> */
		/* 821A0558h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0558h case    2:*/		return 0x821A055C;
		  /* 821A055Ch */ case    3:  		/* lwz R10, <#[R27]> */
		/* 821A055Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 821A055Ch case    3:*/		return 0x821A0560;
		  /* 821A0560h */ case    4:  		/* lwz R9, <#[R25]> */
		/* 821A0560h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000000) );
		/* 821A0560h case    4:*/		return 0x821A0564;
		  /* 821A0564h */ case    5:  		/* rlwinm R9, R9, 7, 29, 31 */
		/* 821A0564h case    5:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R9,regs.R9);
		/* 821A0564h case    5:*/		return 0x821A0568;
		  /* 821A0568h */ case    6:  		/* rlwinm R10, R10, 7, 29, 31 */
		/* 821A0568h case    6:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R10,regs.R10);
		/* 821A0568h case    6:*/		return 0x821A056C;
		  /* 821A056Ch */ case    7:  		/* lwz R30, <#[R27 + 12]> */
		/* 821A056Ch case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x0000000C) );
		/* 821A056Ch case    7:*/		return 0x821A0570;
		  /* 821A0570h */ case    8:  		/* lwz R26, <#[R25 + 12]> */
		/* 821A0570h case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R25 + 0x0000000C) );
		/* 821A0570h case    8:*/		return 0x821A0574;
		  /* 821A0574h */ case    9:  		/* add R10, R10, R9 */
		/* 821A0574h case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821A0574h case    9:*/		return 0x821A0578;
		  /* 821A0578h */ case   10:  		/* cmplwi CR6, R10, 4 */
		/* 821A0578h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 821A0578h case   10:*/		return 0x821A057C;
		  /* 821A057Ch */ case   11:  		/* bc 12, CR6_GT, -52 */
		/* 821A057Ch case   11:*/		if ( regs.CR[6].gt ) { return 0x821A0548;  }
		/* 821A057Ch case   11:*/		return 0x821A0580;
		  /* 821A0580h */ case   12:  		/* rlwinm R11, R11, 0, 30, 28 */
		/* 821A0580h case   12:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R11,regs.R11);
		/* 821A0580h case   12:*/		return 0x821A0584;
		  /* 821A0584h */ case   13:  		/* mr R3, R30 */
		/* 821A0584h case   13:*/		regs.R3 = regs.R30;
		/* 821A0584h case   13:*/		return 0x821A0588;
		  /* 821A0588h */ case   14:  		/* stw R11, <#[R31]> */
		/* 821A0588h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0588h case   14:*/		return 0x821A058C;
		  /* 821A058Ch */ case   15:  		/* bl -191972 */
		/* 821A058Ch case   15:*/		regs.LR = 0x821A0590; return 0x821717A8;
		/* 821A058Ch case   15:*/		return 0x821A0590;
		  /* 821A0590h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A0590h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A0590h case   16:*/		return 0x821A0594;
		  /* 821A0594h */ case   17:  		/* bc 12, CR0_EQ, 64 */
		/* 821A0594h case   17:*/		if ( regs.CR[0].eq ) { return 0x821A05D4;  }
		/* 821A0594h case   17:*/		return 0x821A0598;
		  /* 821A0598h */ case   18:  		/* mr R4, R29 */
		/* 821A0598h case   18:*/		regs.R4 = regs.R29;
		/* 821A0598h case   18:*/		return 0x821A059C;
		  /* 821A059Ch */ case   19:  		/* mr R3, R30 */
		/* 821A059Ch case   19:*/		regs.R3 = regs.R30;
		/* 821A059Ch case   19:*/		return 0x821A05A0;
		  /* 821A05A0h */ case   20:  		/* bl 547616 */
		/* 821A05A0h case   20:*/		regs.LR = 0x821A05A4; return 0x822260C0;
		/* 821A05A0h case   20:*/		return 0x821A05A4;
		  /* 821A05A4h */ case   21:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A05A4h case   21:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A05A4h case   21:*/		return 0x821A05A8;
		  /* 821A05A8h */ case   22:  		/* bc 12, CR0_EQ, 44 */
		/* 821A05A8h case   22:*/		if ( regs.CR[0].eq ) { return 0x821A05D4;  }
		/* 821A05A8h case   22:*/		return 0x821A05AC;
		  /* 821A05ACh */ case   23:  		/* li R6, 1 */
		/* 821A05ACh case   23:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821A05ACh case   23:*/		return 0x821A05B0;
		  /* 821A05B0h */ case   24:  		/* mr R5, R29 */
		/* 821A05B0h case   24:*/		regs.R5 = regs.R29;
		/* 821A05B0h case   24:*/		return 0x821A05B4;
		  /* 821A05B4h */ case   25:  		/* mr R4, R30 */
		/* 821A05B4h case   25:*/		regs.R4 = regs.R30;
		/* 821A05B4h case   25:*/		return 0x821A05B8;
		  /* 821A05B8h */ case   26:  		/* mr R3, R28 */
		/* 821A05B8h case   26:*/		regs.R3 = regs.R28;
		/* 821A05B8h case   26:*/		return 0x821A05BC;
		  /* 821A05BCh */ case   27:  		/* bl 573100 */
		/* 821A05BCh case   27:*/		regs.LR = 0x821A05C0; return 0x8222C468;
		/* 821A05BCh case   27:*/		return 0x821A05C0;
		  /* 821A05C0h */ case   28:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A05C0h case   28:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A05C0h case   28:*/		return 0x821A05C4;
		  /* 821A05C4h */ case   29:  		/* bc 12, CR0_EQ, -124 */
		/* 821A05C4h case   29:*/		if ( regs.CR[0].eq ) { return 0x821A0548;  }
		/* 821A05C4h case   29:*/		return 0x821A05C8;
		  /* 821A05C8h */ case   30:  		/* lwz R11, <#[R31]> */
		/* 821A05C8h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A05C8h case   30:*/		return 0x821A05CC;
		  /* 821A05CCh */ case   31:  		/* ori R11, R11, 4 */
		/* 821A05CCh case   31:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821A05CCh case   31:*/		return 0x821A05D0;
		  /* 821A05D0h */ case   32:  		/* stw R11, <#[R31]> */
		/* 821A05D0h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A05D0h case   32:*/		return 0x821A05D4;
	}
	return 0x821A05D4;
} // Block from 821A0550h-821A05D4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821A05D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A05D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A05D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A05D4);
		  /* 821A05D4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821A05D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A05D4h case    0:*/		return 0x821A05D8;
		  /* 821A05D8h */ case    1:  		/* mr R3, R26 */
		/* 821A05D8h case    1:*/		regs.R3 = regs.R26;
		/* 821A05D8h case    1:*/		return 0x821A05DC;
		  /* 821A05DCh */ case    2:  		/* rlwinm R11, R11, 0, 29, 27 */
		/* 821A05DCh case    2:*/		cpu::op::rlwinm<0,0,29,27>(regs,&regs.R11,regs.R11);
		/* 821A05DCh case    2:*/		return 0x821A05E0;
		  /* 821A05E0h */ case    3:  		/* stw R11, <#[R31]> */
		/* 821A05E0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A05E0h case    3:*/		return 0x821A05E4;
		  /* 821A05E4h */ case    4:  		/* bl -192060 */
		/* 821A05E4h case    4:*/		regs.LR = 0x821A05E8; return 0x821717A8;
		/* 821A05E4h case    4:*/		return 0x821A05E8;
		  /* 821A05E8h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A05E8h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A05E8h case    5:*/		return 0x821A05EC;
		  /* 821A05ECh */ case    6:  		/* bc 12, CR0_EQ, 64 */
		/* 821A05ECh case    6:*/		if ( regs.CR[0].eq ) { return 0x821A062C;  }
		/* 821A05ECh case    6:*/		return 0x821A05F0;
		  /* 821A05F0h */ case    7:  		/* mr R4, R29 */
		/* 821A05F0h case    7:*/		regs.R4 = regs.R29;
		/* 821A05F0h case    7:*/		return 0x821A05F4;
		  /* 821A05F4h */ case    8:  		/* mr R3, R26 */
		/* 821A05F4h case    8:*/		regs.R3 = regs.R26;
		/* 821A05F4h case    8:*/		return 0x821A05F8;
		  /* 821A05F8h */ case    9:  		/* bl 547528 */
		/* 821A05F8h case    9:*/		regs.LR = 0x821A05FC; return 0x822260C0;
		/* 821A05F8h case    9:*/		return 0x821A05FC;
		  /* 821A05FCh */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A05FCh case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A05FCh case   10:*/		return 0x821A0600;
		  /* 821A0600h */ case   11:  		/* bc 12, CR0_EQ, 44 */
		/* 821A0600h case   11:*/		if ( regs.CR[0].eq ) { return 0x821A062C;  }
		/* 821A0600h case   11:*/		return 0x821A0604;
		  /* 821A0604h */ case   12:  		/* li R6, 1 */
		/* 821A0604h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821A0604h case   12:*/		return 0x821A0608;
		  /* 821A0608h */ case   13:  		/* mr R5, R29 */
		/* 821A0608h case   13:*/		regs.R5 = regs.R29;
		/* 821A0608h case   13:*/		return 0x821A060C;
		  /* 821A060Ch */ case   14:  		/* mr R4, R26 */
		/* 821A060Ch case   14:*/		regs.R4 = regs.R26;
		/* 821A060Ch case   14:*/		return 0x821A0610;
		  /* 821A0610h */ case   15:  		/* mr R3, R28 */
		/* 821A0610h case   15:*/		regs.R3 = regs.R28;
		/* 821A0610h case   15:*/		return 0x821A0614;
		  /* 821A0614h */ case   16:  		/* bl 573012 */
		/* 821A0614h case   16:*/		regs.LR = 0x821A0618; return 0x8222C468;
		/* 821A0614h case   16:*/		return 0x821A0618;
		  /* 821A0618h */ case   17:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A0618h case   17:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A0618h case   17:*/		return 0x821A061C;
		  /* 821A061Ch */ case   18:  		/* bc 12, CR0_EQ, -212 */
		/* 821A061Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x821A0548;  }
		/* 821A061Ch case   18:*/		return 0x821A0620;
		  /* 821A0620h */ case   19:  		/* lwz R11, <#[R31]> */
		/* 821A0620h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0620h case   19:*/		return 0x821A0624;
		  /* 821A0624h */ case   20:  		/* ori R11, R11, 8 */
		/* 821A0624h case   20:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 821A0624h case   20:*/		return 0x821A0628;
		  /* 821A0628h */ case   21:  		/* stw R11, <#[R31]> */
		/* 821A0628h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0628h case   21:*/		return 0x821A062C;
	}
	return 0x821A062C;
} // Block from 821A05D4h-821A062Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 821A062Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A062C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A062C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A062C);
		  /* 821A062Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821A062Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A062Ch case    0:*/		return 0x821A0630;
		  /* 821A0630h */ case    1:  		/* rlwinm R9, R11, 0, 19, 17 */
		/* 821A0630h case    1:*/		cpu::op::rlwinm<0,0,19,17>(regs,&regs.R9,regs.R11);
		/* 821A0630h case    1:*/		return 0x821A0634;
		  /* 821A0634h */ case    2:  		/* stw R9, <#[R31]> */
		/* 821A0634h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0634h case    2:*/		return 0x821A0638;
		  /* 821A0638h */ case    3:  		/* lwz R11, <#[R30 + 8]> */
		/* 821A0638h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821A0638h case    3:*/		return 0x821A063C;
		  /* 821A063Ch */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821A063Ch case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821A063Ch case    4:*/		return 0x821A0640;
		  /* 821A0640h */ case    5:  		/* cmplwi CR6, R11, 125 */
		/* 821A0640h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821A0640h case    5:*/		return 0x821A0644;
		  /* 821A0644h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 821A0644h case    6:*/		if ( regs.CR[6].eq ) { return 0x821A0654;  }
		/* 821A0644h case    6:*/		return 0x821A0648;
		  /* 821A0648h */ case    7:  		/* cmplwi CR6, R11, 124 */
		/* 821A0648h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821A0648h case    7:*/		return 0x821A064C;
		  /* 821A064Ch */ case    8:  		/* li R11, 0 */
		/* 821A064Ch case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821A064Ch case    8:*/		return 0x821A0650;
		  /* 821A0650h */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 821A0650h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821A0658;  }
		/* 821A0650h case    9:*/		return 0x821A0654;
	}
	return 0x821A0654;
} // Block from 821A062Ch-821A0654h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821A0654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0654);
		  /* 821A0654h */ case    0:  		/* li R11, 1 */
		/* 821A0654h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821A0654h case    0:*/		return 0x821A0658;
	}
	return 0x821A0658;
} // Block from 821A0654h-821A0658h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A0658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0658);
		  /* 821A0658h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821A0658h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821A0658h case    0:*/		return 0x821A065C;
		  /* 821A065Ch */ case    1:  		/* bc 12, CR0_EQ, 92 */
		/* 821A065Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821A06B8;  }
		/* 821A065Ch case    1:*/		return 0x821A0660;
		  /* 821A0660h */ case    2:  		/* lwz R11, <#[R26 + 8]> */
		/* 821A0660h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821A0660h case    2:*/		return 0x821A0664;
		  /* 821A0664h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821A0664h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821A0664h case    3:*/		return 0x821A0668;
		  /* 821A0668h */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 821A0668h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821A0668h case    4:*/		return 0x821A066C;
		  /* 821A066Ch */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 821A066Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821A067C;  }
		/* 821A066Ch case    5:*/		return 0x821A0670;
		  /* 821A0670h */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 821A0670h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821A0670h case    6:*/		return 0x821A0674;
		  /* 821A0674h */ case    7:  		/* li R11, 0 */
		/* 821A0674h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821A0674h case    7:*/		return 0x821A0678;
		  /* 821A0678h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 821A0678h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821A0680;  }
		/* 821A0678h case    8:*/		return 0x821A067C;
	}
	return 0x821A067C;
} // Block from 821A0658h-821A067Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 821A067Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A067C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A067C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A067C);
		  /* 821A067Ch */ case    0:  		/* li R11, 1 */
		/* 821A067Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821A067Ch case    0:*/		return 0x821A0680;
	}
	return 0x821A0680;
} // Block from 821A067Ch-821A0680h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A0680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0680);
		  /* 821A0680h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821A0680h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821A0680h case    0:*/		return 0x821A0684;
		  /* 821A0684h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 821A0684h case    1:*/		if ( regs.CR[0].eq ) { return 0x821A06B8;  }
		/* 821A0684h case    1:*/		return 0x821A0688;
		  /* 821A0688h */ case    2:  		/* lwz R11, <#[R27]> */
		/* 821A0688h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821A0688h case    2:*/		return 0x821A068C;
		  /* 821A068Ch */ case    3:  		/* lwz R10, <#[R25]> */
		/* 821A068Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 821A068Ch case    3:*/		return 0x821A0690;
		  /* 821A0690h */ case    4:  		/* rlwinm R8, R11, 31, 1, 31 */
		/* 821A0690h case    4:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R8,regs.R11);
		/* 821A0690h case    4:*/		return 0x821A0694;
		  /* 821A0694h */ case    5:  		/* rlwinm R7, R10, 31, 1, 31 */
		/* 821A0694h case    5:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R7,regs.R10);
		/* 821A0694h case    5:*/		return 0x821A0698;
		  /* 821A0698h */ case    6:  		/* xor R8, R7, R8 */
		/* 821A0698h case    6:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 821A0698h case    6:*/		return 0x821A069C;
		  /* 821A069Ch */ case    7:  		/* rlwinm. R8, R8, 0, 31, 31 */
		/* 821A069Ch case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R8);
		/* 821A069Ch case    7:*/		return 0x821A06A0;
		  /* 821A06A0h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821A06A0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821A06B0;  }
		/* 821A06A0h case    8:*/		return 0x821A06A4;
		  /* 821A06A4h */ case    9:  		/* xor R11, R10, R11 */
		/* 821A06A4h case    9:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821A06A4h case    9:*/		return 0x821A06A8;
		  /* 821A06A8h */ case   10:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 821A06A8h case   10:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 821A06A8h case   10:*/		return 0x821A06AC;
		  /* 821A06ACh */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 821A06ACh case   11:*/		if ( regs.CR[0].eq ) { return 0x821A06B8;  }
		/* 821A06ACh case   11:*/		return 0x821A06B0;
	}
	return 0x821A06B0;
} // Block from 821A0680h-821A06B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821A06B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A06B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A06B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A06B0);
		  /* 821A06B0h */ case    0:  		/* ori R11, R9, 8192 */
		/* 821A06B0h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R9,0x2000);
		/* 821A06B0h case    0:*/		return 0x821A06B4;
		  /* 821A06B4h */ case    1:  		/* b 76 */
		/* 821A06B4h case    1:*/		return 0x821A0700;
		/* 821A06B4h case    1:*/		return 0x821A06B8;
	}
	return 0x821A06B8;
} // Block from 821A06B0h-821A06B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821A06B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A06B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A06B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A06B8);
		  /* 821A06B8h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 821A06B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821A06B8h case    0:*/		return 0x821A06BC;
		  /* 821A06BCh */ case    1:  		/* li R30, 0 */
		/* 821A06BCh case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821A06BCh case    1:*/		return 0x821A06C0;
		  /* 821A06C0h */ case    2:  		/* li R29, 0 */
		/* 821A06C0h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821A06C0h case    2:*/		return 0x821A06C4;
		  /* 821A06C4h */ case    3:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 821A06C4h case    3:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 821A06C4h case    3:*/		return 0x821A06C8;
		  /* 821A06C8h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 821A06C8h case    4:*/		if ( regs.CR[0].eq ) { return 0x821A06D8;  }
		/* 821A06C8h case    4:*/		return 0x821A06CC;
		  /* 821A06CCh */ case    5:  		/* mr R3, R24 */
		/* 821A06CCh case    5:*/		regs.R3 = regs.R24;
		/* 821A06CCh case    5:*/		return 0x821A06D0;
		  /* 821A06D0h */ case    6:  		/* bl -166840 */
		/* 821A06D0h case    6:*/		regs.LR = 0x821A06D4; return 0x82177B18;
		/* 821A06D0h case    6:*/		return 0x821A06D4;
		  /* 821A06D4h */ case    7:  		/* mr R30, R3 */
		/* 821A06D4h case    7:*/		regs.R30 = regs.R3;
		/* 821A06D4h case    7:*/		return 0x821A06D8;
	}
	return 0x821A06D8;
} // Block from 821A06B8h-821A06D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821A06D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A06D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A06D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A06D8);
		  /* 821A06D8h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 821A06D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 821A06D8h case    0:*/		return 0x821A06DC;
		  /* 821A06DCh */ case    1:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 821A06DCh case    1:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 821A06DCh case    1:*/		return 0x821A06E0;
		  /* 821A06E0h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 821A06E0h case    2:*/		if ( regs.CR[0].eq ) { return 0x821A06F0;  }
		/* 821A06E0h case    2:*/		return 0x821A06E4;
		  /* 821A06E4h */ case    3:  		/* mr R3, R23 */
		/* 821A06E4h case    3:*/		regs.R3 = regs.R23;
		/* 821A06E4h case    3:*/		return 0x821A06E8;
		  /* 821A06E8h */ case    4:  		/* bl -166864 */
		/* 821A06E8h case    4:*/		regs.LR = 0x821A06EC; return 0x82177B18;
		/* 821A06E8h case    4:*/		return 0x821A06EC;
		  /* 821A06ECh */ case    5:  		/* mr R29, R3 */
		/* 821A06ECh case    5:*/		regs.R29 = regs.R3;
		/* 821A06ECh case    5:*/		return 0x821A06F0;
	}
	return 0x821A06F0;
} // Block from 821A06D8h-821A06F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821A06F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A06F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A06F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A06F0);
		  /* 821A06F0h */ case    0:  		/* cmplw CR6, R30, R29 */
		/* 821A06F0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 821A06F0h case    0:*/		return 0x821A06F4;
		  /* 821A06F4h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 821A06F4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821A0708;  }
		/* 821A06F4h case    1:*/		return 0x821A06F8;
		  /* 821A06F8h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 821A06F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A06F8h case    2:*/		return 0x821A06FC;
		  /* 821A06FCh */ case    3:  		/* ori R11, R11, 8192 */
		/* 821A06FCh case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 821A06FCh case    3:*/		return 0x821A0700;
	}
	return 0x821A0700;
} // Block from 821A06F0h-821A0700h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821A0700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0700);
		  /* 821A0700h */ case    0:  		/* stw R11, <#[R31]> */
		/* 821A0700h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0700h case    0:*/		return 0x821A0704;
		  /* 821A0704h */ case    1:  		/* b 8 */
		/* 821A0704h case    1:*/		return 0x821A070C;
		/* 821A0704h case    1:*/		return 0x821A0708;
	}
	return 0x821A0708;
} // Block from 821A0700h-821A0708h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821A0708h
// Function '?CanCombineSimpleDependencies@Compiler@D3DXShader@@AAA?AW4CanCombineResult@2@PAVInstruction@2@PAVDependency@2@010PAUCombineDependenciesState@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0708);
		  /* 821A0708h */ case    0:  		/* stw R30, <#[R31 + 8]> */
		/* 821A0708h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 821A0708h case    0:*/		return 0x821A070C;
	}
	return 0x821A070C;
} // Block from 821A0708h-821A070Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A070Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A070C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A070C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A070C);
		  /* 821A070Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821A070Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A070Ch case    0:*/		return 0x821A0710;
		  /* 821A0710h */ case    1:  		/* rlwinm. R10, R11, 0, 18, 18 */
		/* 821A0710h case    1:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R10,regs.R11);
		/* 821A0710h case    1:*/		return 0x821A0714;
		  /* 821A0714h */ case    2:  		/* li R10, 5 */
		/* 821A0714h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x5);
		/* 821A0714h case    2:*/		return 0x821A0718;
		  /* 821A0718h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 821A0718h case    3:*/		if ( regs.CR[0].eq ) { return 0x821A0724;  }
		/* 821A0718h case    3:*/		return 0x821A071C;
		  /* 821A071Ch */ case    4:  		/* rlwimi R11, R10, 6, 21, 27 */
		/* 821A071Ch case    4:*/		cpu::op::rlwimi<0,6,21,27>(regs,&regs.R11,regs.R10);
		/* 821A071Ch case    4:*/		return 0x821A0720;
		  /* 821A0720h */ case    5:  		/* b 8 */
		/* 821A0720h case    5:*/		return 0x821A0728;
		/* 821A0720h case    5:*/		return 0x821A0724;
	}
	return 0x821A0724;
} // Block from 821A070Ch-821A0724h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821A0724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0724);
		  /* 821A0724h */ case    0:  		/* rlwimi R11, R10, 5, 21, 27 */
		/* 821A0724h case    0:*/		cpu::op::rlwimi<0,5,21,27>(regs,&regs.R11,regs.R10);
		/* 821A0724h case    0:*/		return 0x821A0728;
	}
	return 0x821A0728;
} // Block from 821A0724h-821A0728h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A0728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0728);
		  /* 821A0728h */ case    0:  		/* stw R11, <#[R31]> */
		/* 821A0728h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0728h case    0:*/		return 0x821A072C;
	}
	return 0x821A072C;
} // Block from 821A0728h-821A072Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A072Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A072C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A072C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A072C);
		  /* 821A072Ch */ case    0:  		/* li R3, 1 */
		/* 821A072Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821A072Ch case    0:*/		return 0x821A0730;
	}
	return 0x821A0730;
} // Block from 821A072Ch-821A0730h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A0730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0730);
		  /* 821A0730h */ case    0:  		/* addi R1, R1, 160 */
		/* 821A0730h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821A0730h case    0:*/		return 0x821A0734;
		  /* 821A0734h */ case    1:  		/* b -1111200 */
		/* 821A0734h case    1:*/		return 0x82091294;
		/* 821A0734h case    1:*/		return 0x821A0738;
	}
	return 0x821A0738;
} // Block from 821A0730h-821A0738h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821A0738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0738);
		  /* 821A0738h */ case    0:  		/* mfspr R12, LR */
		/* 821A0738h case    0:*/		regs.R12 = regs.LR;
		/* 821A0738h case    0:*/		return 0x821A073C;
		  /* 821A073Ch */ case    1:  		/* bl -1111304 */
		/* 821A073Ch case    1:*/		regs.LR = 0x821A0740; return 0x82091234;
		/* 821A073Ch case    1:*/		return 0x821A0740;
		  /* 821A0740h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 821A0740h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 821A0740h case    2:*/		return 0x821A0744;
		  /* 821A0744h */ case    3:  		/* lwz R31, <#[R1 + 324]> */
		/* 821A0744h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000144) );
		/* 821A0744h case    3:*/		return 0x821A0748;
		  /* 821A0748h */ case    4:  		/* mr R28, R7 */
		/* 821A0748h case    4:*/		regs.R28 = regs.R7;
		/* 821A0748h case    4:*/		return 0x821A074C;
		  /* 821A074Ch */ case    5:  		/* mr R26, R8 */
		/* 821A074Ch case    5:*/		regs.R26 = regs.R8;
		/* 821A074Ch case    5:*/		return 0x821A0750;
		  /* 821A0750h */ case    6:  		/* mr R21, R6 */
		/* 821A0750h case    6:*/		regs.R21 = regs.R6;
		/* 821A0750h case    6:*/		return 0x821A0754;
		  /* 821A0754h */ case    7:  		/* mr R24, R9 */
		/* 821A0754h case    7:*/		regs.R24 = regs.R9;
		/* 821A0754h case    7:*/		return 0x821A0758;
		  /* 821A0758h */ case    8:  		/* mr R8, R10 */
		/* 821A0758h case    8:*/		regs.R8 = regs.R10;
		/* 821A0758h case    8:*/		return 0x821A075C;
		  /* 821A075Ch */ case    9:  		/* mr R7, R26 */
		/* 821A075Ch case    9:*/		regs.R7 = regs.R26;
		/* 821A075Ch case    9:*/		return 0x821A0760;
		  /* 821A0760h */ case   10:  		/* mr R9, R31 */
		/* 821A0760h case   10:*/		regs.R9 = regs.R31;
		/* 821A0760h case   10:*/		return 0x821A0764;
		  /* 821A0764h */ case   11:  		/* mr R6, R28 */
		/* 821A0764h case   11:*/		regs.R6 = regs.R28;
		/* 821A0764h case   11:*/		return 0x821A0768;
		  /* 821A0768h */ case   12:  		/* mr R30, R3 */
		/* 821A0768h case   12:*/		regs.R30 = regs.R3;
		/* 821A0768h case   12:*/		return 0x821A076C;
		  /* 821A076Ch */ case   13:  		/* mr R29, R4 */
		/* 821A076Ch case   13:*/		regs.R29 = regs.R4;
		/* 821A076Ch case   13:*/		return 0x821A0770;
		  /* 821A0770h */ case   14:  		/* mr R22, R5 */
		/* 821A0770h case   14:*/		regs.R22 = regs.R5;
		/* 821A0770h case   14:*/		return 0x821A0774;
		  /* 821A0774h */ case   15:  		/* mr R27, R10 */
		/* 821A0774h case   15:*/		regs.R27 = regs.R10;
		/* 821A0774h case   15:*/		return 0x821A0778;
		  /* 821A0778h */ case   16:  		/* li R23, 0 */
		/* 821A0778h case   16:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 821A0778h case   16:*/		return 0x821A077C;
		  /* 821A077Ch */ case   17:  		/* bl -628 */
		/* 821A077Ch case   17:*/		regs.LR = 0x821A0780; return 0x821A0508;
		/* 821A077Ch case   17:*/		return 0x821A0780;
		  /* 821A0780h */ case   18:  		/* lwz R25, <#[R1 + 332]> */
		/* 821A0780h case   18:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x0000014C) );
		/* 821A0780h case   18:*/		return 0x821A0784;
		  /* 821A0784h */ case   19:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A0784h case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A0784h case   19:*/		return 0x821A0788;
		  /* 821A0788h */ case   20:  		/* lwz R20, <#[R1 + 316]> */
		/* 821A0788h case   20:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x0000013C) );
		/* 821A0788h case   20:*/		return 0x821A078C;
		  /* 821A078Ch */ case   21:  		/* lwz R19, <#[R1 + 308]> */
		/* 821A078Ch case   21:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R1 + 0x00000134) );
		/* 821A078Ch case   21:*/		return 0x821A0790;
		  /* 821A0790h */ case   22:  		/* bc 12, CR0_EQ, 112 */
		/* 821A0790h case   22:*/		if ( regs.CR[0].eq ) { return 0x821A0800;  }
		/* 821A0790h case   22:*/		return 0x821A0794;
		  /* 821A0794h */ case   23:  		/* mr R9, R25 */
		/* 821A0794h case   23:*/		regs.R9 = regs.R25;
		/* 821A0794h case   23:*/		return 0x821A0798;
		  /* 821A0798h */ case   24:  		/* mr R8, R27 */
		/* 821A0798h case   24:*/		regs.R8 = regs.R27;
		/* 821A0798h case   24:*/		return 0x821A079C;
		  /* 821A079Ch */ case   25:  		/* mr R7, R24 */
		/* 821A079Ch case   25:*/		regs.R7 = regs.R24;
		/* 821A079Ch case   25:*/		return 0x821A07A0;
		  /* 821A07A0h */ case   26:  		/* mr R6, R28 */
		/* 821A07A0h case   26:*/		regs.R6 = regs.R28;
		/* 821A07A0h case   26:*/		return 0x821A07A4;
		  /* 821A07A4h */ case   27:  		/* mr R5, R21 */
		/* 821A07A4h case   27:*/		regs.R5 = regs.R21;
		/* 821A07A4h case   27:*/		return 0x821A07A8;
		  /* 821A07A8h */ case   28:  		/* mr R4, R29 */
		/* 821A07A8h case   28:*/		regs.R4 = regs.R29;
		/* 821A07A8h case   28:*/		return 0x821A07AC;
		  /* 821A07ACh */ case   29:  		/* mr R3, R30 */
		/* 821A07ACh case   29:*/		regs.R3 = regs.R30;
		/* 821A07ACh case   29:*/		return 0x821A07B0;
		  /* 821A07B0h */ case   30:  		/* bl -680 */
		/* 821A07B0h case   30:*/		regs.LR = 0x821A07B4; return 0x821A0508;
		/* 821A07B0h case   30:*/		return 0x821A07B4;
		  /* 821A07B4h */ case   31:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A07B4h case   31:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A07B4h case   31:*/		return 0x821A07B8;
		  /* 821A07B8h */ case   32:  		/* bc 12, CR0_EQ, 72 */
		/* 821A07B8h case   32:*/		if ( regs.CR[0].eq ) { return 0x821A0800;  }
		/* 821A07B8h case   32:*/		return 0x821A07BC;
		  /* 821A07BCh */ case   33:  		/* lwz R10, <#[R31 + 8]> */
		/* 821A07BCh case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821A07BCh case   33:*/		return 0x821A07C0;
		  /* 821A07C0h */ case   34:  		/* cmplwi CR6, R10, 0 */
		/* 821A07C0h case   34:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821A07C0h case   34:*/		return 0x821A07C4;
		  /* 821A07C4h */ case   35:  		/* bc 12, CR6_EQ, 48 */
		/* 821A07C4h case   35:*/		if ( regs.CR[6].eq ) { return 0x821A07F4;  }
		/* 821A07C4h case   35:*/		return 0x821A07C8;
		  /* 821A07C8h */ case   36:  		/* lwz R11, <#[R25 + 8]> */
		/* 821A07C8h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 821A07C8h case   36:*/		return 0x821A07CC;
		  /* 821A07CCh */ case   37:  		/* cmplwi CR6, R11, 0 */
		/* 821A07CCh case   37:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821A07CCh case   37:*/		return 0x821A07D0;
		  /* 821A07D0h */ case   38:  		/* bc 12, CR6_EQ, 36 */
		/* 821A07D0h case   38:*/		if ( regs.CR[6].eq ) { return 0x821A07F4;  }
		/* 821A07D0h case   38:*/		return 0x821A07D4;
		  /* 821A07D4h */ case   39:  		/* lwz R9, <#[R31]> */
		/* 821A07D4h case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821A07D4h case   39:*/		return 0x821A07D8;
		  /* 821A07D8h */ case   40:  		/* rlwinm. R9, R9, 0, 21, 27 */
		/* 821A07D8h case   40:*/		cpu::op::rlwinm<1,0,21,27>(regs,&regs.R9,regs.R9);
		/* 821A07D8h case   40:*/		return 0x821A07DC;
		  /* 821A07DCh */ case   41:  		/* bc 4, CR0_EQ, 36 */
		/* 821A07DCh case   41:*/		if ( !regs.CR[0].eq ) { return 0x821A0800;  }
		/* 821A07DCh case   41:*/		return 0x821A07E0;
		  /* 821A07E0h */ case   42:  		/* lwz R9, <#[R25]> */
		/* 821A07E0h case   42:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000000) );
		/* 821A07E0h case   42:*/		return 0x821A07E4;
		  /* 821A07E4h */ case   43:  		/* rlwinm. R9, R9, 0, 21, 27 */
		/* 821A07E4h case   43:*/		cpu::op::rlwinm<1,0,21,27>(regs,&regs.R9,regs.R9);
		/* 821A07E4h case   43:*/		return 0x821A07E8;
		  /* 821A07E8h */ case   44:  		/* bc 4, CR0_EQ, 24 */
		/* 821A07E8h case   44:*/		if ( !regs.CR[0].eq ) { return 0x821A0800;  }
		/* 821A07E8h case   44:*/		return 0x821A07EC;
		  /* 821A07ECh */ case   45:  		/* cmplw CR6, R10, R11 */
		/* 821A07ECh case   45:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821A07ECh case   45:*/		return 0x821A07F0;
		  /* 821A07F0h */ case   46:  		/* bc 4, CR6_EQ, 16 */
		/* 821A07F0h case   46:*/		if ( !regs.CR[6].eq ) { return 0x821A0800;  }
		/* 821A07F0h case   46:*/		return 0x821A07F4;
	}
	return 0x821A07F4;
} // Block from 821A0738h-821A07F4h (47 instructions)

//////////////////////////////////////////////////////
// Block at 821A07F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A07F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A07F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A07F4);
		  /* 821A07F4h */ case    0:  		/* stw R26, <#[R19]> */
		/* 821A07F4h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R19 + 0x00000000) );
		/* 821A07F4h case    0:*/		return 0x821A07F8;
		  /* 821A07F8h */ case    1:  		/* li R23, 1 */
		/* 821A07F8h case    1:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 821A07F8h case    1:*/		return 0x821A07FC;
		  /* 821A07FCh */ case    2:  		/* stw R24, <#[R20]> */
		/* 821A07FCh case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R20 + 0x00000000) );
		/* 821A07FCh case    2:*/		return 0x821A0800;
	}
	return 0x821A0800;
} // Block from 821A07F4h-821A0800h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821A0800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0800);
		  /* 821A0800h */ case    0:  		/* addi R9, R1, 80 */
		/* 821A0800h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 821A0800h case    0:*/		return 0x821A0804;
		  /* 821A0804h */ case    1:  		/* mr R8, R27 */
		/* 821A0804h case    1:*/		regs.R8 = regs.R27;
		/* 821A0804h case    1:*/		return 0x821A0808;
		  /* 821A0808h */ case    2:  		/* mr R7, R24 */
		/* 821A0808h case    2:*/		regs.R7 = regs.R24;
		/* 821A0808h case    2:*/		return 0x821A080C;
		  /* 821A080Ch */ case    3:  		/* mr R6, R28 */
		/* 821A080Ch case    3:*/		regs.R6 = regs.R28;
		/* 821A080Ch case    3:*/		return 0x821A0810;
		  /* 821A0810h */ case    4:  		/* mr R5, R22 */
		/* 821A0810h case    4:*/		regs.R5 = regs.R22;
		/* 821A0810h case    4:*/		return 0x821A0814;
		  /* 821A0814h */ case    5:  		/* mr R4, R29 */
		/* 821A0814h case    5:*/		regs.R4 = regs.R29;
		/* 821A0814h case    5:*/		return 0x821A0818;
		  /* 821A0818h */ case    6:  		/* mr R3, R30 */
		/* 821A0818h case    6:*/		regs.R3 = regs.R30;
		/* 821A0818h case    6:*/		return 0x821A081C;
		  /* 821A081Ch */ case    7:  		/* bl -788 */
		/* 821A081Ch case    7:*/		regs.LR = 0x821A0820; return 0x821A0508;
		/* 821A081Ch case    7:*/		return 0x821A0820;
		  /* 821A0820h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A0820h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A0820h case    8:*/		return 0x821A0824;
		  /* 821A0824h */ case    9:  		/* bc 12, CR0_EQ, 192 */
		/* 821A0824h case    9:*/		if ( regs.CR[0].eq ) { return 0x821A08E4;  }
		/* 821A0824h case    9:*/		return 0x821A0828;
		  /* 821A0828h */ case   10:  		/* addi R9, R1, 96 */
		/* 821A0828h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 821A0828h case   10:*/		return 0x821A082C;
		  /* 821A082Ch */ case   11:  		/* mr R8, R27 */
		/* 821A082Ch case   11:*/		regs.R8 = regs.R27;
		/* 821A082Ch case   11:*/		return 0x821A0830;
		  /* 821A0830h */ case   12:  		/* mr R7, R26 */
		/* 821A0830h case   12:*/		regs.R7 = regs.R26;
		/* 821A0830h case   12:*/		return 0x821A0834;
		  /* 821A0834h */ case   13:  		/* mr R6, R28 */
		/* 821A0834h case   13:*/		regs.R6 = regs.R28;
		/* 821A0834h case   13:*/		return 0x821A0838;
		  /* 821A0838h */ case   14:  		/* mr R5, R21 */
		/* 821A0838h case   14:*/		regs.R5 = regs.R21;
		/* 821A0838h case   14:*/		return 0x821A083C;
		  /* 821A083Ch */ case   15:  		/* mr R4, R29 */
		/* 821A083Ch case   15:*/		regs.R4 = regs.R29;
		/* 821A083Ch case   15:*/		return 0x821A0840;
		  /* 821A0840h */ case   16:  		/* mr R3, R30 */
		/* 821A0840h case   16:*/		regs.R3 = regs.R30;
		/* 821A0840h case   16:*/		return 0x821A0844;
		  /* 821A0844h */ case   17:  		/* bl -828 */
		/* 821A0844h case   17:*/		regs.LR = 0x821A0848; return 0x821A0508;
		/* 821A0844h case   17:*/		return 0x821A0848;
		  /* 821A0848h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821A0848h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821A0848h case   18:*/		return 0x821A084C;
		  /* 821A084Ch */ case   19:  		/* bc 12, CR0_EQ, 152 */
		/* 821A084Ch case   19:*/		if ( regs.CR[0].eq ) { return 0x821A08E4;  }
		/* 821A084Ch case   19:*/		return 0x821A0850;
		  /* 821A0850h */ case   20:  		/* lwz R7, <#[R1 + 80]> */
		/* 821A0850h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 821A0850h case   20:*/		return 0x821A0854;
		  /* 821A0854h */ case   21:  		/* rlwinm. R11, R23, 0, 24, 31 */
		/* 821A0854h case   21:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R23);
		/* 821A0854h case   21:*/		return 0x821A0858;
		  /* 821A0858h */ case   22:  		/* lwz R6, <#[R1 + 96]> */
		/* 821A0858h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 821A0858h case   22:*/		return 0x821A085C;
		  /* 821A085Ch */ case   23:  		/* bc 12, CR0_EQ, 44 */
		/* 821A085Ch case   23:*/		if ( regs.CR[0].eq ) { return 0x821A0888;  }
		/* 821A085Ch case   23:*/		return 0x821A0860;
		  /* 821A0860h */ case   24:  		/* lwz R11, <#[R31]> */
		/* 821A0860h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0860h case   24:*/		return 0x821A0864;
		  /* 821A0864h */ case   25:  		/* rlwinm R8, R6, 28, 25, 31 */
		/* 821A0864h case   25:*/		cpu::op::rlwinm<0,28,25,31>(regs,&regs.R8,regs.R6);
		/* 821A0864h case   25:*/		return 0x821A0868;
		  /* 821A0868h */ case   26:  		/* lwz R5, <#[R25]> */
		/* 821A0868h case   26:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R25 + 0x00000000) );
		/* 821A0868h case   26:*/		return 0x821A086C;
		  /* 821A086Ch */ case   27:  		/* rlwinm R9, R7, 28, 25, 31 */
		/* 821A086Ch case   27:*/		cpu::op::rlwinm<0,28,25,31>(regs,&regs.R9,regs.R7);
		/* 821A086Ch case   27:*/		return 0x821A0870;
		  /* 821A0870h */ case   28:  		/* rlwinm R10, R11, 28, 25, 31 */
		/* 821A0870h case   28:*/		cpu::op::rlwinm<0,28,25,31>(regs,&regs.R10,regs.R11);
		/* 821A0870h case   28:*/		return 0x821A0874;
		  /* 821A0874h */ case   29:  		/* rlwinm R11, R5, 28, 25, 31 */
		/* 821A0874h case   29:*/		cpu::op::rlwinm<0,28,25,31>(regs,&regs.R11,regs.R5);
		/* 821A0874h case   29:*/		return 0x821A0878;
		  /* 821A0878h */ case   30:  		/* add R9, R8, R9 */
		/* 821A0878h case   30:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821A0878h case   30:*/		return 0x821A087C;
		  /* 821A087Ch */ case   31:  		/* add R11, R10, R11 */
		/* 821A087Ch case   31:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821A087Ch case   31:*/		return 0x821A0880;
		  /* 821A0880h */ case   32:  		/* cmplw CR6, R9, R11 */
		/* 821A0880h case   32:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821A0880h case   32:*/		return 0x821A0884;
		  /* 821A0884h */ case   33:  		/* bc 4, CR6_LT, 96 */
		/* 821A0884h case   33:*/		if ( !regs.CR[6].lt ) { return 0x821A08E4;  }
		/* 821A0884h case   33:*/		return 0x821A0888;
	}
	return 0x821A0888;
} // Block from 821A0800h-821A0888h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821A0888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0888);
		  /* 821A0888h */ case    0:  		/* lwz R11, <#[R1 + 88]> */
		/* 821A0888h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 821A0888h case    0:*/		return 0x821A088C;
		  /* 821A088Ch */ case    1:  		/* lwz R10, <#[R1 + 104]> */
		/* 821A088Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 821A088Ch case    1:*/		return 0x821A0890;
		  /* 821A0890h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821A0890h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821A0890h case    2:*/		return 0x821A0894;
		  /* 821A0894h */ case    3:  		/* bc 12, CR6_EQ, 36 */
		/* 821A0894h case    3:*/		if ( regs.CR[6].eq ) { return 0x821A08B8;  }
		/* 821A0894h case    3:*/		return 0x821A0898;
		  /* 821A0898h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 821A0898h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821A0898h case    4:*/		return 0x821A089C;
		  /* 821A089Ch */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 821A089Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821A08B8;  }
		/* 821A089Ch case    5:*/		return 0x821A08A0;
		  /* 821A08A0h */ case    6:  		/* rlwinm. R9, R7, 0, 21, 27 */
		/* 821A08A0h case    6:*/		cpu::op::rlwinm<1,0,21,27>(regs,&regs.R9,regs.R7);
		/* 821A08A0h case    6:*/		return 0x821A08A4;
		  /* 821A08A4h */ case    7:  		/* bc 4, CR0_EQ, 64 */
		/* 821A08A4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x821A08E4;  }
		/* 821A08A4h case    7:*/		return 0x821A08A8;
		  /* 821A08A8h */ case    8:  		/* rlwinm. R9, R6, 0, 21, 27 */
		/* 821A08A8h case    8:*/		cpu::op::rlwinm<1,0,21,27>(regs,&regs.R9,regs.R6);
		/* 821A08A8h case    8:*/		return 0x821A08AC;
		  /* 821A08ACh */ case    9:  		/* bc 4, CR0_EQ, 56 */
		/* 821A08ACh case    9:*/		if ( !regs.CR[0].eq ) { return 0x821A08E4;  }
		/* 821A08ACh case    9:*/		return 0x821A08B0;
		  /* 821A08B0h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 821A08B0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821A08B0h case   10:*/		return 0x821A08B4;
		  /* 821A08B4h */ case   11:  		/* bc 4, CR6_EQ, 48 */
		/* 821A08B4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821A08E4;  }
		/* 821A08B4h case   11:*/		return 0x821A08B8;
	}
	return 0x821A08B8;
} // Block from 821A0888h-821A08B8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821A08B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A08B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A08B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A08B8);
		  /* 821A08B8h */ case    0:  		/* lwz R9, <#[R1 + 84]> */
		/* 821A08B8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 821A08B8h case    0:*/		return 0x821A08BC;
		  /* 821A08BCh */ case    1:  		/* li R23, 1 */
		/* 821A08BCh case    1:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 821A08BCh case    1:*/		return 0x821A08C0;
		  /* 821A08C0h */ case    2:  		/* lwz R8, <#[R1 + 100]> */
		/* 821A08C0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000064) );
		/* 821A08C0h case    2:*/		return 0x821A08C4;
		  /* 821A08C4h */ case    3:  		/* stw R24, <#[R19]> */
		/* 821A08C4h case    3:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R19 + 0x00000000) );
		/* 821A08C4h case    3:*/		return 0x821A08C8;
		  /* 821A08C8h */ case    4:  		/* stw R26, <#[R20]> */
		/* 821A08C8h case    4:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R20 + 0x00000000) );
		/* 821A08C8h case    4:*/		return 0x821A08CC;
		  /* 821A08CCh */ case    5:  		/* stw R7, <#[R31]> */
		/* 821A08CCh case    5:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000000) );
		/* 821A08CCh case    5:*/		return 0x821A08D0;
		  /* 821A08D0h */ case    6:  		/* stw R9, <#[R31 + 4]> */
		/* 821A08D0h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 821A08D0h case    6:*/		return 0x821A08D4;
		  /* 821A08D4h */ case    7:  		/* stw R11, <#[R31 + 8]> */
		/* 821A08D4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821A08D4h case    7:*/		return 0x821A08D8;
		  /* 821A08D8h */ case    8:  		/* stw R6, <#[R25]> */
		/* 821A08D8h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R25 + 0x00000000) );
		/* 821A08D8h case    8:*/		return 0x821A08DC;
		  /* 821A08DCh */ case    9:  		/* stw R8, <#[R25 + 4]> */
		/* 821A08DCh case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R25 + 0x00000004) );
		/* 821A08DCh case    9:*/		return 0x821A08E0;
		  /* 821A08E0h */ case   10:  		/* stw R10, <#[R25 + 8]> */
		/* 821A08E0h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 821A08E0h case   10:*/		return 0x821A08E4;
	}
	return 0x821A08E4;
} // Block from 821A08B8h-821A08E4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821A08E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A08E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A08E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A08E4);
		  /* 821A08E4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821A08E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A08E4h case    0:*/		return 0x821A08E8;
		  /* 821A08E8h */ case    1:  		/* rlwinm. R10, R23, 0, 24, 31 */
		/* 821A08E8h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R23);
		/* 821A08E8h case    1:*/		return 0x821A08EC;
		  /* 821A08ECh */ case    2:  		/* rlwinm R11, R11, 0, 17, 13 */
		/* 821A08ECh case    2:*/		cpu::op::rlwinm<0,0,17,13>(regs,&regs.R11,regs.R11);
		/* 821A08ECh case    2:*/		return 0x821A08F0;
		  /* 821A08F0h */ case    3:  		/* stw R11, <#[R31]> */
		/* 821A08F0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A08F0h case    3:*/		return 0x821A08F4;
		  /* 821A08F4h */ case    4:  		/* bc 12, CR0_EQ, 436 */
		/* 821A08F4h case    4:*/		if ( regs.CR[0].eq ) { return 0x821A0AA8;  }
		/* 821A08F4h case    4:*/		return 0x821A08F8;
		  /* 821A08F8h */ case    5:  		/* rlwinm. R11, R11, 0, 21, 27 */
		/* 821A08F8h case    5:*/		cpu::op::rlwinm<1,0,21,27>(regs,&regs.R11,regs.R11);
		/* 821A08F8h case    5:*/		return 0x821A08FC;
		  /* 821A08FCh */ case    6:  		/* bc 4, CR0_EQ, 428 */
		/* 821A08FCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x821A0AA8;  }
		/* 821A08FCh case    6:*/		return 0x821A0900;
		  /* 821A0900h */ case    7:  		/* lwz R11, <#[R25]> */
		/* 821A0900h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 821A0900h case    7:*/		return 0x821A0904;
		  /* 821A0904h */ case    8:  		/* rlwinm. R11, R11, 0, 21, 27 */
		/* 821A0904h case    8:*/		cpu::op::rlwinm<1,0,21,27>(regs,&regs.R11,regs.R11);
		/* 821A0904h case    8:*/		return 0x821A0908;
		  /* 821A0908h */ case    9:  		/* bc 4, CR0_EQ, 416 */
		/* 821A0908h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821A0AA8;  }
		/* 821A0908h case    9:*/		return 0x821A090C;
		  /* 821A090Ch */ case   10:  		/* lwz R4, <#[R22 + 12]> */
		/* 821A090Ch case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x0000000C) );
		/* 821A090Ch case   10:*/		return 0x821A0910;
		  /* 821A0910h */ case   11:  		/* lwz R29, <#[R21 + 12]> */
		/* 821A0910h case   11:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R21 + 0x0000000C) );
		/* 821A0910h case   11:*/		return 0x821A0914;
		  /* 821A0914h */ case   12:  		/* lwz R11, <#[R4 + 8]> */
		/* 821A0914h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821A0914h case   12:*/		return 0x821A0918;
		  /* 821A0918h */ case   13:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821A0918h case   13:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821A0918h case   13:*/		return 0x821A091C;
		  /* 821A091Ch */ case   14:  		/* cmplwi CR6, R11, 125 */
		/* 821A091Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821A091Ch case   14:*/		return 0x821A0920;
		  /* 821A0920h */ case   15:  		/* bc 12, CR6_EQ, 16 */
		/* 821A0920h case   15:*/		if ( regs.CR[6].eq ) { return 0x821A0930;  }
		/* 821A0920h case   15:*/		return 0x821A0924;
		  /* 821A0924h */ case   16:  		/* cmplwi CR6, R11, 124 */
		/* 821A0924h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821A0924h case   16:*/		return 0x821A0928;
		  /* 821A0928h */ case   17:  		/* li R11, 0 */
		/* 821A0928h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821A0928h case   17:*/		return 0x821A092C;
		  /* 821A092Ch */ case   18:  		/* bc 4, CR6_EQ, 8 */
		/* 821A092Ch case   18:*/		if ( !regs.CR[6].eq ) { return 0x821A0934;  }
		/* 821A092Ch case   18:*/		return 0x821A0930;
	}
	return 0x821A0930;
} // Block from 821A08E4h-821A0930h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821A0930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0930);
		  /* 821A0930h */ case    0:  		/* li R11, 1 */
		/* 821A0930h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821A0930h case    0:*/		return 0x821A0934;
	}
	return 0x821A0934;
} // Block from 821A0930h-821A0934h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A0934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0934);
		  /* 821A0934h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821A0934h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821A0934h case    0:*/		return 0x821A0938;
		  /* 821A0938h */ case    1:  		/* bc 12, CR0_EQ, 368 */
		/* 821A0938h case    1:*/		if ( regs.CR[0].eq ) { return 0x821A0AA8;  }
		/* 821A0938h case    1:*/		return 0x821A093C;
		  /* 821A093Ch */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 821A093Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821A093Ch case    2:*/		return 0x821A0940;
		  /* 821A0940h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821A0940h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821A0940h case    3:*/		return 0x821A0944;
		  /* 821A0944h */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 821A0944h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821A0944h case    4:*/		return 0x821A0948;
		  /* 821A0948h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 821A0948h case    5:*/		if ( regs.CR[6].eq ) { return 0x821A0958;  }
		/* 821A0948h case    5:*/		return 0x821A094C;
		  /* 821A094Ch */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 821A094Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821A094Ch case    6:*/		return 0x821A0950;
		  /* 821A0950h */ case    7:  		/* li R11, 0 */
		/* 821A0950h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821A0950h case    7:*/		return 0x821A0954;
		  /* 821A0954h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 821A0954h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821A095C;  }
		/* 821A0954h case    8:*/		return 0x821A0958;
	}
	return 0x821A0958;
} // Block from 821A0934h-821A0958h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821A0958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0958);
		  /* 821A0958h */ case    0:  		/* li R11, 1 */
		/* 821A0958h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821A0958h case    0:*/		return 0x821A095C;
	}
	return 0x821A095C;
} // Block from 821A0958h-821A095Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A095Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A095C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A095C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A095C);
		  /* 821A095Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821A095Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821A095Ch case    0:*/		return 0x821A0960;
		  /* 821A0960h */ case    1:  		/* bc 12, CR0_EQ, 328 */
		/* 821A0960h case    1:*/		if ( regs.CR[0].eq ) { return 0x821A0AA8;  }
		/* 821A0960h case    1:*/		return 0x821A0964;
		  /* 821A0964h */ case    2:  		/* lwz R11, <#[R22]> */
		/* 821A0964h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 821A0964h case    2:*/		return 0x821A0968;
		  /* 821A0968h */ case    3:  		/* addi R8, R1, 80 */
		/* 821A0968h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 821A0968h case    3:*/		return 0x821A096C;
		  /* 821A096Ch */ case    4:  		/* mr R3, R30 */
		/* 821A096Ch case    4:*/		regs.R3 = regs.R30;
		/* 821A096Ch case    4:*/		return 0x821A0970;
		  /* 821A0970h */ case    5:  		/* lwz R28, <#[R26 + 12]> */
		/* 821A0970h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R26 + 0x0000000C) );
		/* 821A0970h case    5:*/		return 0x821A0974;
		  /* 821A0974h */ case    6:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 821A0974h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 821A0974h case    6:*/		return 0x821A0978;
		  /* 821A0978h */ case    7:  		/* lwz R27, <#[R24 + 12]> */
		/* 821A0978h case    7:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R24 + 0x0000000C) );
		/* 821A0978h case    7:*/		return 0x821A097C;
		  /* 821A097Ch */ case    8:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 821A097Ch case    8:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 821A097Ch case    8:*/		return 0x821A0980;
		  /* 821A0980h */ case    9:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 821A0980h case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 821A0980h case    9:*/		return 0x821A0984;
		  /* 821A0984h */ case   10:  		/* bl -22276 */
		/* 821A0984h case   10:*/		regs.LR = 0x821A0988; return 0x8219B280;
		/* 821A0984h case   10:*/		return 0x821A0988;
		  /* 821A0988h */ case   11:  		/* lwz R11, <#[R31]> */
		/* 821A0988h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0988h case   11:*/		return 0x821A098C;
		  /* 821A098Ch */ case   12:  		/* addi R8, R1, 96 */
		/* 821A098Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 821A098Ch case   12:*/		return 0x821A0990;
		  /* 821A0990h */ case   13:  		/* rlwimi R11, R3, 15, 14, 16 */
		/* 821A0990h case   13:*/		cpu::op::rlwimi<0,15,14,16>(regs,&regs.R11,regs.R3);
		/* 821A0990h case   13:*/		return 0x821A0994;
		  /* 821A0994h */ case   14:  		/* mr R4, R29 */
		/* 821A0994h case   14:*/		regs.R4 = regs.R29;
		/* 821A0994h case   14:*/		return 0x821A0998;
		  /* 821A0998h */ case   15:  		/* stw R11, <#[R31]> */
		/* 821A0998h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0998h case   15:*/		return 0x821A099C;
		  /* 821A099Ch */ case   16:  		/* mr R3, R30 */
		/* 821A099Ch case   16:*/		regs.R3 = regs.R30;
		/* 821A099Ch case   16:*/		return 0x821A09A0;
		  /* 821A09A0h */ case   17:  		/* lwz R11, <#[R21]> */
		/* 821A09A0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 821A09A0h case   17:*/		return 0x821A09A4;
		  /* 821A09A4h */ case   18:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 821A09A4h case   18:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 821A09A4h case   18:*/		return 0x821A09A8;
		  /* 821A09A8h */ case   19:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 821A09A8h case   19:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 821A09A8h case   19:*/		return 0x821A09AC;
		  /* 821A09ACh */ case   20:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 821A09ACh case   20:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 821A09ACh case   20:*/		return 0x821A09B0;
		  /* 821A09B0h */ case   21:  		/* bl -22320 */
		/* 821A09B0h case   21:*/		regs.LR = 0x821A09B4; return 0x8219B280;
		/* 821A09B0h case   21:*/		return 0x821A09B4;
		  /* 821A09B4h */ case   22:  		/* lwz R11, <#[R31]> */
		/* 821A09B4h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A09B4h case   22:*/		return 0x821A09B8;
		  /* 821A09B8h */ case   23:  		/* rlwinm R10, R3, 15, 14, 16 */
		/* 821A09B8h case   23:*/		cpu::op::rlwinm<0,15,14,16>(regs,&regs.R10,regs.R3);
		/* 821A09B8h case   23:*/		return 0x821A09BC;
		  /* 821A09BCh */ case   24:  		/* addi R6, R1, 96 */
		/* 821A09BCh case   24:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 821A09BCh case   24:*/		return 0x821A09C0;
		  /* 821A09C0h */ case   25:  		/* or R29, R10, R11 */
		/* 821A09C0h case   25:*/		cpu::op::or<0>(regs,&regs.R29,regs.R10,regs.R11);
		/* 821A09C0h case   25:*/		return 0x821A09C4;
		  /* 821A09C4h */ case   26:  		/* addi R4, R1, 80 */
		/* 821A09C4h case   26:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 821A09C4h case   26:*/		return 0x821A09C8;
		  /* 821A09C8h */ case   27:  		/* stw R29, <#[R31]> */
		/* 821A09C8h case   27:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 821A09C8h case   27:*/		return 0x821A09CC;
		  /* 821A09CCh */ case   28:  		/* mr R3, R30 */
		/* 821A09CCh case   28:*/		regs.R3 = regs.R30;
		/* 821A09CCh case   28:*/		return 0x821A09D0;
		  /* 821A09D0h */ case   29:  		/* lwz R10, <#[R21]> */
		/* 821A09D0h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000000) );
		/* 821A09D0h case   29:*/		return 0x821A09D4;
		  /* 821A09D4h */ case   30:  		/* lwz R11, <#[R22]> */
		/* 821A09D4h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 821A09D4h case   30:*/		return 0x821A09D8;
		  /* 821A09D8h */ case   31:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 821A09D8h case   31:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 821A09D8h case   31:*/		return 0x821A09DC;
		  /* 821A09DCh */ case   32:  		/* rlwinm R7, R10, 7, 29, 31 */
		/* 821A09DCh case   32:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R7,regs.R10);
		/* 821A09DCh case   32:*/		return 0x821A09E0;
		  /* 821A09E0h */ case   33:  		/* bl -22160 */
		/* 821A09E0h case   33:*/		regs.LR = 0x821A09E4; return 0x8219B350;
		/* 821A09E0h case   33:*/		return 0x821A09E4;
		  /* 821A09E4h */ case   34:  		/* rlwinm R11, R3, 15, 0, 16 */
		/* 821A09E4h case   34:*/		cpu::op::rlwinm<0,15,0,16>(regs,&regs.R11,regs.R3);
		/* 821A09E4h case   34:*/		return 0x821A09E8;
		  /* 821A09E8h */ case   35:  		/* addi R8, R1, 80 */
		/* 821A09E8h case   35:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 821A09E8h case   35:*/		return 0x821A09EC;
		  /* 821A09ECh */ case   36:  		/* or R11, R11, R29 */
		/* 821A09ECh case   36:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 821A09ECh case   36:*/		return 0x821A09F0;
		  /* 821A09F0h */ case   37:  		/* mr R4, R28 */
		/* 821A09F0h case   37:*/		regs.R4 = regs.R28;
		/* 821A09F0h case   37:*/		return 0x821A09F4;
		  /* 821A09F4h */ case   38:  		/* rlwimi R11, R29, 0, 17, 13 */
		/* 821A09F4h case   38:*/		cpu::op::rlwimi<0,0,17,13>(regs,&regs.R11,regs.R29);
		/* 821A09F4h case   38:*/		return 0x821A09F8;
		  /* 821A09F8h */ case   39:  		/* mr R3, R30 */
		/* 821A09F8h case   39:*/		regs.R3 = regs.R30;
		/* 821A09F8h case   39:*/		return 0x821A09FC;
		  /* 821A09FCh */ case   40:  		/* stw R11, <#[R31]> */
		/* 821A09FCh case   40:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A09FCh case   40:*/		return 0x821A0A00;
		  /* 821A0A00h */ case   41:  		/* lwz R11, <#[R26]> */
		/* 821A0A00h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821A0A00h case   41:*/		return 0x821A0A04;
		  /* 821A0A04h */ case   42:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 821A0A04h case   42:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 821A0A04h case   42:*/		return 0x821A0A08;
		  /* 821A0A08h */ case   43:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 821A0A08h case   43:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 821A0A08h case   43:*/		return 0x821A0A0C;
		  /* 821A0A0Ch */ case   44:  		/* lwz R29, <#[R31]> */
		/* 821A0A0Ch case   44:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0A0Ch case   44:*/		return 0x821A0A10;
		  /* 821A0A10h */ case   45:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 821A0A10h case   45:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 821A0A10h case   45:*/		return 0x821A0A14;
		  /* 821A0A14h */ case   46:  		/* bl -22420 */
		/* 821A0A14h case   46:*/		regs.LR = 0x821A0A18; return 0x8219B280;
		/* 821A0A14h case   46:*/		return 0x821A0A18;
		  /* 821A0A18h */ case   47:  		/* rlwinm R11, R3, 15, 14, 16 */
		/* 821A0A18h case   47:*/		cpu::op::rlwinm<0,15,14,16>(regs,&regs.R11,regs.R3);
		/* 821A0A18h case   47:*/		return 0x821A0A1C;
		  /* 821A0A1Ch */ case   48:  		/* addi R8, R1, 96 */
		/* 821A0A1Ch case   48:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x60);
		/* 821A0A1Ch case   48:*/		return 0x821A0A20;
		  /* 821A0A20h */ case   49:  		/* or R11, R11, R29 */
		/* 821A0A20h case   49:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 821A0A20h case   49:*/		return 0x821A0A24;
		  /* 821A0A24h */ case   50:  		/* mr R4, R27 */
		/* 821A0A24h case   50:*/		regs.R4 = regs.R27;
		/* 821A0A24h case   50:*/		return 0x821A0A28;
		  /* 821A0A28h */ case   51:  		/* stw R11, <#[R31]> */
		/* 821A0A28h case   51:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0A28h case   51:*/		return 0x821A0A2C;
		  /* 821A0A2Ch */ case   52:  		/* mr R3, R30 */
		/* 821A0A2Ch case   52:*/		regs.R3 = regs.R30;
		/* 821A0A2Ch case   52:*/		return 0x821A0A30;
		  /* 821A0A30h */ case   53:  		/* lwz R11, <#[R24]> */
		/* 821A0A30h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821A0A30h case   53:*/		return 0x821A0A34;
		  /* 821A0A34h */ case   54:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 821A0A34h case   54:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 821A0A34h case   54:*/		return 0x821A0A38;
		  /* 821A0A38h */ case   55:  		/* rlwinm R6, R11, 27, 24, 31 */
		/* 821A0A38h case   55:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R11);
		/* 821A0A38h case   55:*/		return 0x821A0A3C;
		  /* 821A0A3Ch */ case   56:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 821A0A3Ch case   56:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 821A0A3Ch case   56:*/		return 0x821A0A40;
		  /* 821A0A40h */ case   57:  		/* bl -22464 */
		/* 821A0A40h case   57:*/		regs.LR = 0x821A0A44; return 0x8219B280;
		/* 821A0A40h case   57:*/		return 0x821A0A44;
		  /* 821A0A44h */ case   58:  		/* lwz R11, <#[R31]> */
		/* 821A0A44h case   58:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0A44h case   58:*/		return 0x821A0A48;
		  /* 821A0A48h */ case   59:  		/* rlwinm R10, R3, 15, 14, 16 */
		/* 821A0A48h case   59:*/		cpu::op::rlwinm<0,15,14,16>(regs,&regs.R10,regs.R3);
		/* 821A0A48h case   59:*/		return 0x821A0A4C;
		  /* 821A0A4Ch */ case   60:  		/* addi R6, R1, 96 */
		/* 821A0A4Ch case   60:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 821A0A4Ch case   60:*/		return 0x821A0A50;
		  /* 821A0A50h */ case   61:  		/* or R29, R10, R11 */
		/* 821A0A50h case   61:*/		cpu::op::or<0>(regs,&regs.R29,regs.R10,regs.R11);
		/* 821A0A50h case   61:*/		return 0x821A0A54;
		  /* 821A0A54h */ case   62:  		/* addi R4, R1, 80 */
		/* 821A0A54h case   62:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 821A0A54h case   62:*/		return 0x821A0A58;
		  /* 821A0A58h */ case   63:  		/* stw R29, <#[R31]> */
		/* 821A0A58h case   63:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0A58h case   63:*/		return 0x821A0A5C;
		  /* 821A0A5Ch */ case   64:  		/* mr R3, R30 */
		/* 821A0A5Ch case   64:*/		regs.R3 = regs.R30;
		/* 821A0A5Ch case   64:*/		return 0x821A0A60;
		  /* 821A0A60h */ case   65:  		/* lwz R10, <#[R24]> */
		/* 821A0A60h case   65:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 821A0A60h case   65:*/		return 0x821A0A64;
		  /* 821A0A64h */ case   66:  		/* lwz R11, <#[R26]> */
		/* 821A0A64h case   66:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821A0A64h case   66:*/		return 0x821A0A68;
		  /* 821A0A68h */ case   67:  		/* rlwinm R5, R11, 7, 29, 31 */
		/* 821A0A68h case   67:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R5,regs.R11);
		/* 821A0A68h case   67:*/		return 0x821A0A6C;
		  /* 821A0A6Ch */ case   68:  		/* rlwinm R7, R10, 7, 29, 31 */
		/* 821A0A6Ch case   68:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R7,regs.R10);
		/* 821A0A6Ch case   68:*/		return 0x821A0A70;
		  /* 821A0A70h */ case   69:  		/* bl -22304 */
		/* 821A0A70h case   69:*/		regs.LR = 0x821A0A74; return 0x8219B350;
		/* 821A0A70h case   69:*/		return 0x821A0A74;
		  /* 821A0A74h */ case   70:  		/* rlwinm R11, R3, 15, 0, 16 */
		/* 821A0A74h case   70:*/		cpu::op::rlwinm<0,15,0,16>(regs,&regs.R11,regs.R3);
		/* 821A0A74h case   70:*/		return 0x821A0A78;
		  /* 821A0A78h */ case   71:  		/* rlwinm R10, R29, 0, 0, 31 */
		/* 821A0A78h case   71:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R29);
		/* 821A0A78h case   71:*/		return 0x821A0A7C;
		  /* 821A0A7Ch */ case   72:  		/* or R11, R11, R29 */
		/* 821A0A7Ch case   72:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 821A0A7Ch case   72:*/		return 0x821A0A80;
		  /* 821A0A80h */ case   73:  		/* lis R9, 2 */
		/* 821A0A80h case   73:*/		cpu::op::lis<0>(regs,&regs.R9,0x2);
		/* 821A0A80h case   73:*/		return 0x821A0A84;
		  /* 821A0A84h */ case   74:  		/* rlwimi R11, R10, 0, 17, 13 */
		/* 821A0A84h case   74:*/		cpu::op::rlwimi<0,0,17,13>(regs,&regs.R11,regs.R10);
		/* 821A0A84h case   74:*/		return 0x821A0A88;
		  /* 821A0A88h */ case   75:  		/* ori R9, R9, 32768 */
		/* 821A0A88h case   75:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x8000);
		/* 821A0A88h case   75:*/		return 0x821A0A8C;
		  /* 821A0A8Ch */ case   76:  		/* rlwinm R10, R11, 0, 14, 16 */
		/* 821A0A8Ch case   76:*/		cpu::op::rlwinm<0,0,14,16>(regs,&regs.R10,regs.R11);
		/* 821A0A8Ch case   76:*/		return 0x821A0A90;
		  /* 821A0A90h */ case   77:  		/* stw R11, <#[R31]> */
		/* 821A0A90h case   77:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0A90h case   77:*/		return 0x821A0A94;
		  /* 821A0A94h */ case   78:  		/* rlwinm R10, R10, 0, 16, 14 */
		/* 821A0A94h case   78:*/		cpu::op::rlwinm<0,0,16,14>(regs,&regs.R10,regs.R10);
		/* 821A0A94h case   78:*/		return 0x821A0A98;
		  /* 821A0A98h */ case   79:  		/* subf R11, R10, R9 */
		/* 821A0A98h case   79:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R9);
		/* 821A0A98h case   79:*/		return 0x821A0A9C;
		  /* 821A0A9Ch */ case   80:  		/* subfic R11, R11, 0 */
		/* 821A0A9Ch case   80:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 821A0A9Ch case   80:*/		return 0x821A0AA0;
		  /* 821A0AA0h */ case   81:  		/* subfe R11, R11, R11 */
		/* 821A0AA0h case   81:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 821A0AA0h case   81:*/		return 0x821A0AA4;
		  /* 821A0AA4h */ case   82:  		/* and R23, R11, R23 */
		/* 821A0AA4h case   82:*/		cpu::op::and<0>(regs,&regs.R23,regs.R11,regs.R23);
		/* 821A0AA4h case   82:*/		return 0x821A0AA8;
	}
	return 0x821A0AA8;
} // Block from 821A095Ch-821A0AA8h (83 instructions)

//////////////////////////////////////////////////////
// Block at 821A0AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0AA8);
		  /* 821A0AA8h */ case    0:  		/* mr R3, R23 */
		/* 821A0AA8h case    0:*/		regs.R3 = regs.R23;
		/* 821A0AA8h case    0:*/		return 0x821A0AAC;
		  /* 821A0AACh */ case    1:  		/* addi R1, R1, 224 */
		/* 821A0AACh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 821A0AACh case    1:*/		return 0x821A0AB0;
		  /* 821A0AB0h */ case    2:  		/* b -1112108 */
		/* 821A0AB0h case    2:*/		return 0x82091284;
		/* 821A0AB0h case    2:*/		return 0x821A0AB4;
		  /* 821A0AB4h */ case    3:  		/* nop */
		/* 821A0AB4h case    3:*/		cpu::op::nop();
		/* 821A0AB4h case    3:*/		return 0x821A0AB8;
	}
	return 0x821A0AB8;
} // Block from 821A0AA8h-821A0AB8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821A0AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0AB8);
		  /* 821A0AB8h */ case    0:  		/* mfspr R12, LR */
		/* 821A0AB8h case    0:*/		regs.R12 = regs.LR;
		/* 821A0AB8h case    0:*/		return 0x821A0ABC;
		  /* 821A0ABCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821A0ABCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821A0ABCh case    1:*/		return 0x821A0AC0;
		  /* 821A0AC0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821A0AC0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821A0AC0h case    2:*/		return 0x821A0AC4;
		  /* 821A0AC4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821A0AC4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821A0AC4h case    3:*/		return 0x821A0AC8;
		  /* 821A0AC8h */ case    4:  		/* lwz R11, <#[R4 + 8]> */
		/* 821A0AC8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821A0AC8h case    4:*/		return 0x821A0ACC;
		  /* 821A0ACCh */ case    5:  		/* mr R31, R4 */
		/* 821A0ACCh case    5:*/		regs.R31 = regs.R4;
		/* 821A0ACCh case    5:*/		return 0x821A0AD0;
		  /* 821A0AD0h */ case    6:  		/* rlwinm. R10, R11, 6, 31, 31 */
		/* 821A0AD0h case    6:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R11);
		/* 821A0AD0h case    6:*/		return 0x821A0AD4;
		  /* 821A0AD4h */ case    7:  		/* bc 4, CR0_EQ, 100 */
		/* 821A0AD4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x821A0B38;  }
		/* 821A0AD4h case    7:*/		return 0x821A0AD8;
		  /* 821A0AD8h */ case    8:  		/* oris R11, R11, 1024 */
		/* 821A0AD8h case    8:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 821A0AD8h case    8:*/		return 0x821A0ADC;
		  /* 821A0ADCh */ case    9:  		/* stw R11, <#[R4 + 8]> */
		/* 821A0ADCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821A0ADCh case    9:*/		return 0x821A0AE0;
		  /* 821A0AE0h */ case   10:  		/* lwz R3, <#[R3 + 652]> */
		/* 821A0AE0h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000028C) );
		/* 821A0AE0h case   10:*/		return 0x821A0AE4;
		  /* 821A0AE4h */ case   11:  		/* lwz R11, <#[R3 + 4]> */
		/* 821A0AE4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821A0AE4h case   11:*/		return 0x821A0AE8;
		  /* 821A0AE8h */ case   12:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821A0AE8h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821A0AE8h case   12:*/		return 0x821A0AEC;
		  /* 821A0AECh */ case   13:  		/* bc 4, CR0_EQ, 40 */
		/* 821A0AECh case   13:*/		if ( !regs.CR[0].eq ) { return 0x821A0B14;  }
		/* 821A0AECh case   13:*/		return 0x821A0AF0;
		  /* 821A0AF0h */ case   14:  		/* lwz R11, <#[R3]> */
		/* 821A0AF0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821A0AF0h case   14:*/		return 0x821A0AF4;
		  /* 821A0AF4h */ case   15:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821A0AF4h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821A0AF4h case   15:*/		return 0x821A0AF8;
		  /* 821A0AF8h */ case   16:  		/* addic. R11, R11, -4 */
		/* 821A0AF8h case   16:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821A0AF8h case   16:*/		return 0x821A0AFC;
		  /* 821A0AFCh */ case   17:  		/* bc 12, CR0_EQ, 24 */
		/* 821A0AFCh case   17:*/		if ( regs.CR[0].eq ) { return 0x821A0B14;  }
		/* 821A0AFCh case   17:*/		return 0x821A0B00;
		  /* 821A0B00h */ case   18:  		/* lwz R10, <#[R11 + 8]> */
		/* 821A0B00h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821A0B00h case   18:*/		return 0x821A0B04;
		  /* 821A0B04h */ case   19:  		/* lwz R9, <#[R11 + 12]> */
		/* 821A0B04h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821A0B04h case   19:*/		return 0x821A0B08;
		  /* 821A0B08h */ case   20:  		/* addi R10, R10, 1 */
		/* 821A0B08h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821A0B08h case   20:*/		return 0x821A0B0C;
		  /* 821A0B0Ch */ case   21:  		/* cmplw CR6, R10, R9 */
		/* 821A0B0Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821A0B0Ch case   21:*/		return 0x821A0B10;
		  /* 821A0B10h */ case   22:  		/* bc 4, CR6_GT, 16 */
		/* 821A0B10h case   22:*/		if ( !regs.CR[6].gt ) { return 0x821A0B20;  }
		/* 821A0B10h case   22:*/		return 0x821A0B14;
	}
	return 0x821A0B14;
} // Block from 821A0AB8h-821A0B14h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821A0B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0B14);
		  /* 821A0B14h */ case    0:  		/* li R4, 1 */
		/* 821A0B14h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821A0B14h case    0:*/		return 0x821A0B18;
		  /* 821A0B18h */ case    1:  		/* bl -80464 */
		/* 821A0B18h case    1:*/		regs.LR = 0x821A0B1C; return 0x8218D0C8;
		/* 821A0B18h case    1:*/		return 0x821A0B1C;
		  /* 821A0B1Ch */ case    2:  		/* mr R11, R3 */
		/* 821A0B1Ch case    2:*/		regs.R11 = regs.R3;
		/* 821A0B1Ch case    2:*/		return 0x821A0B20;
	}
	return 0x821A0B20;
} // Block from 821A0B14h-821A0B20h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821A0B20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0B20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0B20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0B20);
		  /* 821A0B20h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 821A0B20h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821A0B20h case    0:*/		return 0x821A0B24;
		  /* 821A0B24h */ case    1:  		/* addi R9, R10, 4 */
		/* 821A0B24h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821A0B24h case    1:*/		return 0x821A0B28;
		  /* 821A0B28h */ case    2:  		/* addi R8, R10, 1 */
		/* 821A0B28h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x1);
		/* 821A0B28h case    2:*/		return 0x821A0B2C;
		  /* 821A0B2Ch */ case    3:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 821A0B2Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 821A0B2Ch case    3:*/		return 0x821A0B30;
		  /* 821A0B30h */ case    4:  		/* stw R8, <#[R11 + 8]> */
		/* 821A0B30h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 821A0B30h case    4:*/		return 0x821A0B34;
		  /* 821A0B34h */ case    5:  		/* stwx R31, <#[R10 + R11]> */
		/* 821A0B34h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821A0B34h case    5:*/		return 0x821A0B38;
	}
	return 0x821A0B38;
} // Block from 821A0B20h-821A0B38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821A0B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0B38);
		  /* 821A0B38h */ case    0:  		/* addi R1, R1, 96 */
		/* 821A0B38h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821A0B38h case    0:*/		return 0x821A0B3C;
		  /* 821A0B3Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821A0B3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821A0B3Ch case    1:*/		return 0x821A0B40;
		  /* 821A0B40h */ case    2:  		/* mtspr LR, R12 */
		/* 821A0B40h case    2:*/		regs.LR = regs.R12;
		/* 821A0B40h case    2:*/		return 0x821A0B44;
		  /* 821A0B44h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821A0B44h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821A0B44h case    3:*/		return 0x821A0B48;
		  /* 821A0B48h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821A0B48h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821A0B48h case    4:*/		return 0x821A0B4C;
	}
	return 0x821A0B4C;
} // Block from 821A0B38h-821A0B4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821A0B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0B4C);
		  /* 821A0B4Ch */ case    0:  		/* nop */
		/* 821A0B4Ch case    0:*/		cpu::op::nop();
		/* 821A0B4Ch case    0:*/		return 0x821A0B50;
	}
	return 0x821A0B50;
} // Block from 821A0B4Ch-821A0B50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821A0B50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821A0B50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821A0B50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821A0B50);
		  /* 821A0B50h */ case    0:  		/* mfspr R12, LR */
		/* 821A0B50h case    0:*/		regs.R12 = regs.LR;
		/* 821A0B50h case    0:*/		return 0x821A0B54;
		  /* 821A0B54h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821A0B54h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821A0B54h case    1:*/		return 0x821A0B58;
		  /* 821A0B58h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821A0B58h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821A0B58h case    2:*/		return 0x821A0B5C;
		  /* 821A0B5Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821A0B5Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821A0B5Ch case    3:*/		return 0x821A0B60;
		  /* 821A0B60h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821A0B60h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821A0B60h case    4:*/		return 0x821A0B64;
		  /* 821A0B64h */ case    5:  		/* lwz R31, <#[R4 + 4]> */
		/* 821A0B64h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000004) );
		/* 821A0B64h case    5:*/		return 0x821A0B68;
		  /* 821A0B68h */ case    6:  		/* mr R30, R3 */
		/* 821A0B68h case    6:*/		regs.R30 = regs.R3;
		/* 821A0B68h case    6:*/		return 0x821A0B6C;
		  /* 821A0B6Ch */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 821A0B6Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821A0B6Ch case    7:*/		return 0x821A0B70;
		  /* 821A0B70h */ case    8:  		/* bc 12, CR6_EQ, 44 */
		/* 821A0B70h case    8:*/		if ( regs.CR[6].eq ) { return 0x821A0B9C;  }
		/* 821A0B70h case    8:*/		return 0x821A0B74;
		  /* 821A0B74h */ case    9:  		/* lwz R4, <#[R31 + 16]> */
		/* 821A0B74h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 821A0B74h case    9:*/		return 0x821A0B78;
		  /* 821A0B78h */ case   10:  		/* cmplwi CR6, R4, 0 */
		/* 821A0B78h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821A0B78h case   10:*/		return 0x821A0B7C;
		  /* 821A0B7Ch */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 821A0B7Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x821A0B94;  }
		/* 821A0B7Ch case   11:*/		return 0x821A0B80;
		  /* 821A0B80h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 821A0B80h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821A0B80h case   12:*/		return 0x821A0B84;
		  /* 821A0B84h */ case   13:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821A0B84h case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821A0B84h case   13:*/		return 0x821A0B88;
		  /* 821A0B88h */ case   14:  		/* bc 12, CR0_EQ, 12 */
		/* 821A0B88h case   14:*/		if ( regs.CR[0].eq ) { return 0x821A0B94;  }
		/* 821A0B88h case   14:*/		return 0x821A0B8C;
		  /* 821A0B8Ch */ case   15:  		/* mr R3, R30 */
		/* 821A0B8Ch case   15:*/		regs.R3 = regs.R30;
		/* 821A0B8Ch case   15:*/		return 0x821A0B90;
		  /* 821A0B90h */ case   16:  		/* bl -216 */
		/* 821A0B90h case   16:*/		regs.LR = 0x821A0B94; return 0x821A0AB8;
		/* 821A0B90h case   16:*/		return 0x821A0B94;
	}
	return 0x821A0B94;
} // Block from 821A0B50h-821A0B94h (17 instructions)

