#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 820C0160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0160);
		  /* 820C0160h */ case    0:  		/* lwz R25, <#[R23 + 44]> */
		/* 820C0160h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R23 + 0x0000002C) );
		/* 820C0160h case    0:*/		return 0x820C0164;
		  /* 820C0164h */ case    1:  		/* mr R21, R29 */
		/* 820C0164h case    1:*/		regs.R21 = regs.R29;
		/* 820C0164h case    1:*/		return 0x820C0168;
		  /* 820C0168h */ case    2:  		/* li R17, 1 */
		/* 820C0168h case    2:*/		cpu::op::li<0>(regs,&regs.R17,0x1);
		/* 820C0168h case    2:*/		return 0x820C016C;
		  /* 820C016Ch */ case    3:  		/* mr R24, R27 */
		/* 820C016Ch case    3:*/		regs.R24 = regs.R27;
		/* 820C016Ch case    3:*/		return 0x820C0170;
		  /* 820C0170h */ case    4:  		/* cmplwi CR6, R25, 0 */
		/* 820C0170h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820C0170h case    4:*/		return 0x820C0174;
		  /* 820C0174h */ case    5:  		/* bc 12, CR6_EQ, 824 */
		/* 820C0174h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C04AC;  }
		/* 820C0174h case    5:*/		return 0x820C0178;
		  /* 820C0178h */ case    6:  		/* lis R10, -32256 */
		/* 820C0178h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820C0178h case    6:*/		return 0x820C017C;
		  /* 820C017Ch */ case    7:  		/* lis R11, -32255 */
		/* 820C017Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C017Ch case    7:*/		return 0x820C0180;
		  /* 820C0180h */ case    8:  		/* addi R19, R11, 9448 */
		/* 820C0180h case    8:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R11,0x24E8);
		/* 820C0180h case    8:*/		return 0x820C0184;
		  /* 820C0184h */ case    9:  		/* lfd FR31, <#[R10 + 1808]> */
		/* 820C0184h case    9:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000710) );
		/* 820C0184h case    9:*/		return 0x820C0188;
		  /* 820C0188h */ case   10:  		/* lwz R26, <#[R25 + 8]> */
		/* 820C0188h case   10:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R25 + 0x00000008) );
		/* 820C0188h case   10:*/		return 0x820C018C;
		  /* 820C018Ch */ case   11:  		/* mr R28, R16 */
		/* 820C018Ch case   11:*/		regs.R28 = regs.R16;
		/* 820C018Ch case   11:*/		return 0x820C0190;
		  /* 820C0190h */ case   12:  		/* lwz R25, <#[R25 + 12]> */
		/* 820C0190h case   12:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R25 + 0x0000000C) );
		/* 820C0190h case   12:*/		return 0x820C0194;
		  /* 820C0194h */ case   13:  		/* cmplwi CR6, R25, 0 */
		/* 820C0194h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820C0194h case   13:*/		return 0x820C0198;
		  /* 820C0198h */ case   14:  		/* bc 12, CR6_EQ, 36 */
		/* 820C0198h case   14:*/		if ( regs.CR[6].eq ) { return 0x820C01BC;  }
		/* 820C0198h case   14:*/		return 0x820C019C;
		  /* 820C019Ch */ case   15:  		/* lwz R11, <#[R25 + 8]> */
		/* 820C019Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820C019Ch case   15:*/		return 0x820C01A0;
		  /* 820C01A0h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 820C01A0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C01A0h case   16:*/		return 0x820C01A4;
		  /* 820C01A4h */ case   17:  		/* bc 12, CR6_EQ, 24 */
		/* 820C01A4h case   17:*/		if ( regs.CR[6].eq ) { return 0x820C01BC;  }
		/* 820C01A4h case   17:*/		return 0x820C01A8;
		  /* 820C01A8h */ case   18:  		/* lwz R10, <#[R11 + 4]> */
		/* 820C01A8h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820C01A8h case   18:*/		return 0x820C01AC;
		  /* 820C01ACh */ case   19:  		/* cmpwi CR6, R10, 12 */
		/* 820C01ACh case   19:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000C);
		/* 820C01ACh case   19:*/		return 0x820C01B0;
		  /* 820C01B0h */ case   20:  		/* bc 4, CR6_EQ, 12 */
		/* 820C01B0h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820C01BC;  }
		/* 820C01B0h case   20:*/		return 0x820C01B4;
		  /* 820C01B4h */ case   21:  		/* lwz R25, <#[R25 + 12]> */
		/* 820C01B4h case   21:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R25 + 0x0000000C) );
		/* 820C01B4h case   21:*/		return 0x820C01B8;
		  /* 820C01B8h */ case   22:  		/* mr R28, R11 */
		/* 820C01B8h case   22:*/		regs.R28 = regs.R11;
		/* 820C01B8h case   22:*/		return 0x820C01BC;
	}
	return 0x820C01BC;
} // Block from 820C0160h-820C01BCh (23 instructions)

//////////////////////////////////////////////////////
// Block at 820C01BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C01BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C01BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C01BC);
		  /* 820C01BCh */ case    0:  		/* lwz R11, <#[R1 + 380]> */
		/* 820C01BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000017C) );
		/* 820C01BCh case    0:*/		return 0x820C01C0;
		  /* 820C01C0h */ case    1:  		/* lwz R30, <#[R26 + 24]> */
		/* 820C01C0h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000018) );
		/* 820C01C0h case    1:*/		return 0x820C01C4;
		  /* 820C01C4h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 820C01C4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C01C4h case    2:*/		return 0x820C01C8;
		  /* 820C01C8h */ case    3:  		/* bc 12, CR6_EQ, 540 */
		/* 820C01C8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C03E4;  }
		/* 820C01C8h case    3:*/		return 0x820C01CC;
		  /* 820C01CCh */ case    4:  		/* lwz R11, <#[R1 + 388]> */
		/* 820C01CCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000184) );
		/* 820C01CCh case    4:*/		return 0x820C01D0;
		  /* 820C01D0h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 820C01D0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C01D0h case    5:*/		return 0x820C01D4;
		  /* 820C01D4h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 820C01D4h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C01E4;  }
		/* 820C01D4h case    6:*/		return 0x820C01D8;
		  /* 820C01D8h */ case    7:  		/* lwz R11, <#[R30 + 44]> */
		/* 820C01D8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 820C01D8h case    7:*/		return 0x820C01DC;
		  /* 820C01DCh */ case    8:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 820C01DCh case    8:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 820C01DCh case    8:*/		return 0x820C01E0;
		  /* 820C01E0h */ case    9:  		/* bc 4, CR0_EQ, 516 */
		/* 820C01E0h case    9:*/		if ( !regs.CR[0].eq ) { return 0x820C03E4;  }
		/* 820C01E0h case    9:*/		return 0x820C01E4;
	}
	return 0x820C01E4;
} // Block from 820C01BCh-820C01E4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C01E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C01E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C01E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C01E4);
		  /* 820C01E4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820C01E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820C01E4h case    0:*/		return 0x820C01E8;
		  /* 820C01E8h */ case    1:  		/* lwz R10, <#[R30 + 44]> */
		/* 820C01E8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000002C) );
		/* 820C01E8h case    1:*/		return 0x820C01EC;
		  /* 820C01ECh */ case    2:  		/* rlwinm. R9, R10, 0, 25, 25 */
		/* 820C01ECh case    2:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R9,regs.R10);
		/* 820C01ECh case    2:*/		return 0x820C01F0;
		  /* 820C01F0h */ case    3:  		/* lwz R27, <#[R11 + 116]> */
		/* 820C01F0h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000074) );
		/* 820C01F0h case    3:*/		return 0x820C01F4;
		  /* 820C01F4h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 820C01F4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C0200;  }
		/* 820C01F4h case    4:*/		return 0x820C01F8;
		  /* 820C01F8h */ case    5:  		/* lwz R27, <#[R11 + 124]> */
		/* 820C01F8h case    5:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x0000007C) );
		/* 820C01F8h case    5:*/		return 0x820C01FC;
		  /* 820C01FCh */ case    6:  		/* b 16 */
		/* 820C01FCh case    6:*/		return 0x820C020C;
		/* 820C01FCh case    6:*/		return 0x820C0200;
	}
	return 0x820C0200;
} // Block from 820C01E4h-820C0200h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C0200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0200);
		  /* 820C0200h */ case    0:  		/* rlwinm. R10, R10, 0, 27, 27 */
		/* 820C0200h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R10);
		/* 820C0200h case    0:*/		return 0x820C0204;
		  /* 820C0204h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 820C0204h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C020C;  }
		/* 820C0204h case    1:*/		return 0x820C0208;
		  /* 820C0208h */ case    2:  		/* lwz R27, <#[R11 + 128]> */
		/* 820C0208h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000080) );
		/* 820C0208h case    2:*/		return 0x820C020C;
	}
	return 0x820C020C;
} // Block from 820C0200h-820C020Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C020Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C020C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C020C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C020C);
		  /* 820C020Ch */ case    0:  		/* lwz R6, <#[R30 + 20]> */
		/* 820C020Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000014) );
		/* 820C020Ch case    0:*/		return 0x820C0210;
		  /* 820C0210h */ case    1:  		/* mr R29, R16 */
		/* 820C0210h case    1:*/		regs.R29 = regs.R16;
		/* 820C0210h case    1:*/		return 0x820C0214;
		  /* 820C0214h */ case    2:  		/* cmplwi CR6, R6, 0 */
		/* 820C0214h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820C0214h case    2:*/		return 0x820C0218;
		  /* 820C0218h */ case    3:  		/* bc 12, CR6_EQ, 120 */
		/* 820C0218h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C0290;  }
		/* 820C0218h case    3:*/		return 0x820C021C;
		  /* 820C021Ch */ case    4:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C021Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C021Ch case    4:*/		return 0x820C0220;
		  /* 820C0220h */ case    5:  		/* li R6, 0 */
		/* 820C0220h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C0220h case    5:*/		return 0x820C0224;
		  /* 820C0224h */ case    6:  		/* li R5, 0 */
		/* 820C0224h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C0224h case    6:*/		return 0x820C0228;
		  /* 820C0228h */ case    7:  		/* lwz R3, <#[R31 + 8]> */
		/* 820C0228h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0228h case    7:*/		return 0x820C022C;
		  /* 820C022Ch */ case    8:  		/* mr R4, R27 */
		/* 820C022Ch case    8:*/		regs.R4 = regs.R27;
		/* 820C022Ch case    8:*/		return 0x820C0230;
		  /* 820C0230h */ case    9:  		/* fmr FR1, FR31 */
		/* 820C0230h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820C0230h case    9:*/		return 0x820C0234;
		  /* 820C0234h */ case   10:  		/* add R28, R29, R11 */
		/* 820C0234h case   10:*/		cpu::op::add<0>(regs,&regs.R28,regs.R29,regs.R11);
		/* 820C0234h case   10:*/		return 0x820C0238;
		  /* 820C0238h */ case   11:  		/* bl 249840 */
		/* 820C0238h case   11:*/		regs.LR = 0x820C023C; return 0x820FD228;
		/* 820C0238h case   11:*/		return 0x820C023C;
		  /* 820C023Ch */ case   12:  		/* lwz R11, <#[R31 + 8]> */
		/* 820C023Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820C023Ch case   12:*/		return 0x820C0240;
		  /* 820C0240h */ case   13:  		/* lwz R10, <#[R11 + 8]> */
		/* 820C0240h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820C0240h case   13:*/		return 0x820C0244;
		  /* 820C0244h */ case   14:  		/* cmplw CR6, R3, R10 */
		/* 820C0244h case   14:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C0244h case   14:*/		return 0x820C0248;
		  /* 820C0248h */ case   15:  		/* bc 4, CR6_LT, 20 */
		/* 820C0248h case   15:*/		if ( !regs.CR[6].lt ) { return 0x820C025C;  }
		/* 820C0248h case   15:*/		return 0x820C024C;
		  /* 820C024Ch */ case   16:  		/* lwz R11, <#[R11 + 20]> */
		/* 820C024Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820C024Ch case   16:*/		return 0x820C0250;
		  /* 820C0250h */ case   17:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820C0250h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820C0250h case   17:*/		return 0x820C0254;
		  /* 820C0254h */ case   18:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820C0254h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C0254h case   18:*/		return 0x820C0258;
		  /* 820C0258h */ case   19:  		/* b 8 */
		/* 820C0258h case   19:*/		return 0x820C0260;
		/* 820C0258h case   19:*/		return 0x820C025C;
	}
	return 0x820C025C;
} // Block from 820C020Ch-820C025Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C025Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C025C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C025C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C025C);
		  /* 820C025Ch */ case    0:  		/* mr R11, R16 */
		/* 820C025Ch case    0:*/		regs.R11 = regs.R16;
		/* 820C025Ch case    0:*/		return 0x820C0260;
	}
	return 0x820C0260;
} // Block from 820C025Ch-820C0260h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C0260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0260);
		  /* 820C0260h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C0260h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C0260h case    0:*/		return 0x820C0264;
		  /* 820C0264h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820C0264h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C0274;  }
		/* 820C0264h case    1:*/		return 0x820C0268;
		  /* 820C0268h */ case    2:  		/* stw R28, <#[R11 + 48]> */
		/* 820C0268h case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000030) );
		/* 820C0268h case    2:*/		return 0x820C026C;
		  /* 820C026Ch */ case    3:  		/* stw R26, <#[R11 + 96]> */
		/* 820C026Ch case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000060) );
		/* 820C026Ch case    3:*/		return 0x820C0270;
		  /* 820C0270h */ case    4:  		/* stw R29, <#[R11 + 100]> */
		/* 820C0270h case    4:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000064) );
		/* 820C0270h case    4:*/		return 0x820C0274;
	}
	return 0x820C0274;
} // Block from 820C0260h-820C0274h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C0274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0274);
		  /* 820C0274h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C0274h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0274h case    0:*/		return 0x820C0278;
		  /* 820C0278h */ case    1:  		/* rlwinm R10, R28, 2, 0, 29 */
		/* 820C0278h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R28);
		/* 820C0278h case    1:*/		return 0x820C027C;
		  /* 820C027Ch */ case    2:  		/* addi R29, R29, 1 */
		/* 820C027Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820C027Ch case    2:*/		return 0x820C0280;
		  /* 820C0280h */ case    3:  		/* stwx R3, <#[R10 + R11]> */
		/* 820C0280h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820C0280h case    3:*/		return 0x820C0284;
		  /* 820C0284h */ case    4:  		/* lwz R6, <#[R30 + 20]> */
		/* 820C0284h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000014) );
		/* 820C0284h case    4:*/		return 0x820C0288;
		  /* 820C0288h */ case    5:  		/* cmplw CR6, R29, R6 */
		/* 820C0288h case    5:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R6);
		/* 820C0288h case    5:*/		return 0x820C028C;
		  /* 820C028Ch */ case    6:  		/* bc 12, CR6_LT, -112 */
		/* 820C028Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x820C021C;  }
		/* 820C028Ch case    6:*/		return 0x820C0290;
	}
	return 0x820C0290;
} // Block from 820C0274h-820C0290h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C0290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0290);
		  /* 820C0290h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820C0290h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0290h case    0:*/		return 0x820C0294;
		  /* 820C0294h */ case    1:  		/* lwz R11, <#[R11 + 116]> */
		/* 820C0294h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000074) );
		/* 820C0294h case    1:*/		return 0x820C0298;
		  /* 820C0298h */ case    2:  		/* cmplw CR6, R11, R27 */
		/* 820C0298h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820C0298h case    2:*/		return 0x820C029C;
		  /* 820C029Ch */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 820C029Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820C02C4;  }
		/* 820C029Ch case    3:*/		return 0x820C02A0;
		  /* 820C02A0h */ case    4:  		/* lwz R10, <#[R30 + 16]> */
		/* 820C02A0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 820C02A0h case    4:*/		return 0x820C02A4;
		  /* 820C02A4h */ case    5:  		/* mr R3, R31 */
		/* 820C02A4h case    5:*/		regs.R3 = regs.R31;
		/* 820C02A4h case    5:*/		return 0x820C02A8;
		  /* 820C02A8h */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C02A8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C02A8h case    6:*/		return 0x820C02AC;
		  /* 820C02ACh */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C02ACh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C02ACh case    7:*/		return 0x820C02B0;
		  /* 820C02B0h */ case    8:  		/* lwz R4, <#[R30 + 48]> */
		/* 820C02B0h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000030) );
		/* 820C02B0h case    8:*/		return 0x820C02B4;
		  /* 820C02B4h */ case    9:  		/* add R5, R10, R11 */
		/* 820C02B4h case    9:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 820C02B4h case    9:*/		return 0x820C02B8;
		  /* 820C02B8h */ case   10:  		/* bl -48608 */
		/* 820C02B8h case   10:*/		regs.LR = 0x820C02BC; return 0x820B44D8;
		/* 820C02B8h case   10:*/		return 0x820C02BC;
		  /* 820C02BCh */ case   11:  		/* or. R29, R3, R3 */
		/* 820C02BCh case   11:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C02BCh case   11:*/		return 0x820C02C0;
		  /* 820C02C0h */ case   12:  		/* bc 12, CR0_LT, 2596 */
		/* 820C02C0h case   12:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C02C0h case   12:*/		return 0x820C02C4;
	}
	return 0x820C02C4;
} // Block from 820C0290h-820C02C4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C02C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C02C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C02C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C02C4);
		  /* 820C02C4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820C02C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820C02C4h case    0:*/		return 0x820C02C8;
		  /* 820C02C8h */ case    1:  		/* lwz R10, <#[R11 + 124]> */
		/* 820C02C8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000007C) );
		/* 820C02C8h case    1:*/		return 0x820C02CC;
		  /* 820C02CCh */ case    2:  		/* cmplw CR6, R10, R27 */
		/* 820C02CCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R27);
		/* 820C02CCh case    2:*/		return 0x820C02D0;
		  /* 820C02D0h */ case    3:  		/* bc 4, CR6_EQ, 76 */
		/* 820C02D0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C031C;  }
		/* 820C02D0h case    3:*/		return 0x820C02D4;
		  /* 820C02D4h */ case    4:  		/* lwz R10, <#[R30 + 16]> */
		/* 820C02D4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 820C02D4h case    4:*/		return 0x820C02D8;
		  /* 820C02D8h */ case    5:  		/* li R9, 0 */
		/* 820C02D8h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C02D8h case    5:*/		return 0x820C02DC;
		  /* 820C02DCh */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C02DCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C02DCh case    6:*/		return 0x820C02E0;
		  /* 820C02E0h */ case    7:  		/* li R8, 0 */
		/* 820C02E0h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C02E0h case    7:*/		return 0x820C02E4;
		  /* 820C02E4h */ case    8:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 820C02E4h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 820C02E4h case    8:*/		return 0x820C02E8;
		  /* 820C02E8h */ case    9:  		/* lwz R10, <#[R30 + 64]> */
		/* 820C02E8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000040) );
		/* 820C02E8h case    9:*/		return 0x820C02EC;
		  /* 820C02ECh */ case   10:  		/* li R7, 1 */
		/* 820C02ECh case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820C02ECh case   10:*/		return 0x820C02F0;
		  /* 820C02F0h */ case   11:  		/* lwz R4, <#[R30 + 48]> */
		/* 820C02F0h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000030) );
		/* 820C02F0h case   11:*/		return 0x820C02F4;
		  /* 820C02F4h */ case   12:  		/* mr R6, R27 */
		/* 820C02F4h case   12:*/		regs.R6 = regs.R27;
		/* 820C02F4h case   12:*/		return 0x820C02F8;
		  /* 820C02F8h */ case   13:  		/* add R5, R5, R11 */
		/* 820C02F8h case   13:*/		cpu::op::add<0>(regs,&regs.R5,regs.R5,regs.R11);
		/* 820C02F8h case   13:*/		return 0x820C02FC;
		  /* 820C02FCh */ case   14:  		/* mr R3, R31 */
		/* 820C02FCh case   14:*/		regs.R3 = regs.R31;
		/* 820C02FCh case   14:*/		return 0x820C0300;
		  /* 820C0300h */ case   15:  		/* bl -47728 */
		/* 820C0300h case   15:*/		regs.LR = 0x820C0304; return 0x820B4890;
		/* 820C0300h case   15:*/		return 0x820C0304;
		  /* 820C0304h */ case   16:  		/* or. R29, R3, R3 */
		/* 820C0304h case   16:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C0304h case   16:*/		return 0x820C0308;
		  /* 820C0308h */ case   17:  		/* bc 12, CR0_LT, 2524 */
		/* 820C0308h case   17:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C0308h case   17:*/		return 0x820C030C;
		  /* 820C030Ch */ case   18:  		/* mr R4, R30 */
		/* 820C030Ch case   18:*/		regs.R4 = regs.R30;
		/* 820C030Ch case   18:*/		return 0x820C0310;
		  /* 820C0310h */ case   19:  		/* mr R3, R31 */
		/* 820C0310h case   19:*/		regs.R3 = regs.R31;
		/* 820C0310h case   19:*/		return 0x820C0314;
		  /* 820C0314h */ case   20:  		/* bl -72388 */
		/* 820C0314h case   20:*/		regs.LR = 0x820C0318; return 0x820AE850;
		/* 820C0314h case   20:*/		return 0x820C0318;
		  /* 820C0318h */ case   21:  		/* b 368 */
		/* 820C0318h case   21:*/		return 0x820C0488;
		/* 820C0318h case   21:*/		return 0x820C031C;
	}
	return 0x820C031C;
} // Block from 820C02C4h-820C031Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C031Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C031C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C031C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C031C);
		  /* 820C031Ch */ case    0:  		/* lwz R11, <#[R11 + 128]> */
		/* 820C031Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000080) );
		/* 820C031Ch case    0:*/		return 0x820C0320;
		  /* 820C0320h */ case    1:  		/* cmplw CR6, R11, R27 */
		/* 820C0320h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 820C0320h case    1:*/		return 0x820C0324;
		  /* 820C0324h */ case    2:  		/* bc 4, CR6_EQ, 364 */
		/* 820C0324h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C0490;  }
		/* 820C0324h case    2:*/		return 0x820C0328;
		  /* 820C0328h */ case    3:  		/* lwz R10, <#[R30 + 16]> */
		/* 820C0328h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 820C0328h case    3:*/		return 0x820C032C;
		  /* 820C032Ch */ case    4:  		/* li R8, 0 */
		/* 820C032Ch case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C032Ch case    4:*/		return 0x820C0330;
		  /* 820C0330h */ case    5:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C0330h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0330h case    5:*/		return 0x820C0334;
		  /* 820C0334h */ case    6:  		/* li R7, 0 */
		/* 820C0334h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C0334h case    6:*/		return 0x820C0338;
		  /* 820C0338h */ case    7:  		/* rlwinm R5, R10, 2, 0, 29 */
		/* 820C0338h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R10);
		/* 820C0338h case    7:*/		return 0x820C033C;
		  /* 820C033Ch */ case    8:  		/* lwz R10, <#[R30 + 64]> */
		/* 820C033Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000040) );
		/* 820C033Ch case    8:*/		return 0x820C0340;
		  /* 820C0340h */ case    9:  		/* mr R6, R27 */
		/* 820C0340h case    9:*/		regs.R6 = regs.R27;
		/* 820C0340h case    9:*/		return 0x820C0344;
		  /* 820C0344h */ case   10:  		/* lwz R9, <#[R30 + 60]> */
		/* 820C0344h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000003C) );
		/* 820C0344h case   10:*/		return 0x820C0348;
		  /* 820C0348h */ case   11:  		/* mr R3, R31 */
		/* 820C0348h case   11:*/		regs.R3 = regs.R31;
		/* 820C0348h case   11:*/		return 0x820C034C;
		  /* 820C034Ch */ case   12:  		/* lwz R4, <#[R30 + 48]> */
		/* 820C034Ch case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000030) );
		/* 820C034Ch case   12:*/		return 0x820C0350;
		  /* 820C0350h */ case   13:  		/* add R5, R5, R11 */
		/* 820C0350h case   13:*/		cpu::op::add<0>(regs,&regs.R5,regs.R5,regs.R11);
		/* 820C0350h case   13:*/		return 0x820C0354;
		  /* 820C0354h */ case   14:  		/* bl -47812 */
		/* 820C0354h case   14:*/		regs.LR = 0x820C0358; return 0x820B4890;
		/* 820C0354h case   14:*/		return 0x820C0358;
	}
	return 0x820C0358;
} // Block from 820C031Ch-820C0358h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C0358h
// Function '?EmitFor@CCompiler@D3DXShader@@IAAJPAVCNode@2@000@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0358);
		  /* 820C0358h */ case    0:  		/* or. R29, R3, R3 */
		/* 820C0358h case    0:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C0358h case    0:*/		return 0x820C035C;
		  /* 820C035Ch */ case    1:  		/* bc 12, CR0_LT, 2440 */
		/* 820C035Ch case    1:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C035Ch case    1:*/		return 0x820C0360;
		  /* 820C0360h */ case    2:  		/* lwz R10, <#[R30 + 16]> */
		/* 820C0360h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 820C0360h case    2:*/		return 0x820C0364;
		  /* 820C0364h */ case    3:  		/* mr R3, R31 */
		/* 820C0364h case    3:*/		regs.R3 = regs.R31;
		/* 820C0364h case    3:*/		return 0x820C0368;
		  /* 820C0368h */ case    4:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C0368h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0368h case    4:*/		return 0x820C036C;
		  /* 820C036Ch */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C036Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C036Ch case    5:*/		return 0x820C0370;
		  /* 820C0370h */ case    6:  		/* lwz R5, <#[R30 + 20]> */
		/* 820C0370h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000014) );
		/* 820C0370h case    6:*/		return 0x820C0374;
		  /* 820C0374h */ case    7:  		/* add R4, R10, R11 */
		/* 820C0374h case    7:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R11);
		/* 820C0374h case    7:*/		return 0x820C0378;
		  /* 820C0378h */ case    8:  		/* bl -67664 */
		/* 820C0378h case    8:*/		regs.LR = 0x820C037C; return 0x820AFB28;
		/* 820C0378h case    8:*/		return 0x820C037C;
		  /* 820C037Ch */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820C037Ch case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C037Ch case    9:*/		return 0x820C0380;
		  /* 820C0380h */ case   10:  		/* bc 12, CR0_EQ, 64 */
		/* 820C0380h case   10:*/		if ( regs.CR[0].eq ) { return 0x820C03C0;  }
		/* 820C0380h case   10:*/		return 0x820C0384;
		  /* 820C0384h */ case   11:  		/* mr R11, R16 */
		/* 820C0384h case   11:*/		regs.R11 = regs.R16;
		/* 820C0384h case   11:*/		return 0x820C0388;
		  /* 820C0388h */ case   12:  		/* cmplwi CR6, R5, 0 */
		/* 820C0388h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820C0388h case   12:*/		return 0x820C038C;
		  /* 820C038Ch */ case   13:  		/* bc 12, CR6_EQ, 260 */
		/* 820C038Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820C0490;  }
		/* 820C038Ch case   13:*/		return 0x820C0390;
		  /* 820C0390h */ case   14:  		/* rlwinm R10, R22, 2, 0, 29 */
		/* 820C0390h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R22);
		/* 820C0390h case   14:*/		return 0x820C0394;
		  /* 820C0394h */ case   15:  		/* add R10, R10, R15 */
		/* 820C0394h case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R15);
		/* 820C0394h case   15:*/		return 0x820C0398;
		  /* 820C0398h */ case   16:  		/* addi R10, R10, -4 */
		/* 820C0398h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 820C0398h case   16:*/		return 0x820C039C;
		  /* 820C039Ch */ case   17:  		/* lwz R9, <#[R30 + 16]> */
		/* 820C039Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 820C039Ch case   17:*/		return 0x820C03A0;
		  /* 820C03A0h */ case   18:  		/* addi R22, R22, 1 */
		/* 820C03A0h case   18:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 820C03A0h case   18:*/		return 0x820C03A4;
		  /* 820C03A4h */ case   19:  		/* add R9, R11, R9 */
		/* 820C03A4h case   19:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 820C03A4h case   19:*/		return 0x820C03A8;
		  /* 820C03A8h */ case   20:  		/* addi R11, R11, 1 */
		/* 820C03A8h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C03A8h case   20:*/		return 0x820C03AC;
		  /* 820C03ACh */ case   21:  		/* stwu R9, <#[R10 + 4]> */
		/* 820C03ACh case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C03ACh case   21:*/		return 0x820C03B0;
		  /* 820C03B0h */ case   22:  		/* lwz R9, <#[R30 + 20]> */
		/* 820C03B0h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000014) );
		/* 820C03B0h case   22:*/		return 0x820C03B4;
		  /* 820C03B4h */ case   23:  		/* cmplw CR6, R11, R9 */
		/* 820C03B4h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820C03B4h case   23:*/		return 0x820C03B8;
		  /* 820C03B8h */ case   24:  		/* bc 12, CR6_LT, -28 */
		/* 820C03B8h case   24:*/		if ( regs.CR[6].lt ) { return 0x820C039C;  }
		/* 820C03B8h case   24:*/		return 0x820C03BC;
		  /* 820C03BCh */ case   25:  		/* b 212 */
		/* 820C03BCh case   25:*/		return 0x820C0490;
		/* 820C03BCh case   25:*/		return 0x820C03C0;
	}
	return 0x820C03C0;
} // Block from 820C0358h-820C03C0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820C03C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C03C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C03C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C03C0);
		  /* 820C03C0h */ case    0:  		/* lwz R11, <#[R26 + 20]> */
		/* 820C03C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 820C03C0h case    0:*/		return 0x820C03C4;
		  /* 820C03C4h */ case    1:  		/* mr R6, R19 */
		/* 820C03C4h case    1:*/		regs.R6 = regs.R19;
		/* 820C03C4h case    1:*/		return 0x820C03C8;
		  /* 820C03C8h */ case    2:  		/* li R5, 3502 */
		/* 820C03C8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0xDAE);
		/* 820C03C8h case    2:*/		return 0x820C03CC;
		  /* 820C03CCh */ case    3:  		/* lwz R7, <#[R1 + 348]> */
		/* 820C03CCh case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000015C) );
		/* 820C03CCh case    3:*/		return 0x820C03D0;
		  /* 820C03D0h */ case    4:  		/* mr R4, R30 */
		/* 820C03D0h case    4:*/		regs.R4 = regs.R30;
		/* 820C03D0h case    4:*/		return 0x820C03D4;
		  /* 820C03D4h */ case    5:  		/* mr R3, R31 */
		/* 820C03D4h case    5:*/		regs.R3 = regs.R31;
		/* 820C03D4h case    5:*/		return 0x820C03D8;
		  /* 820C03D8h */ case    6:  		/* lwz R8, <#[R11 + 24]> */
		/* 820C03D8h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000018) );
		/* 820C03D8h case    6:*/		return 0x820C03DC;
		  /* 820C03DCh */ case    7:  		/* bl -63980 */
		/* 820C03DCh case    7:*/		regs.LR = 0x820C03E0; return 0x820B09F0;
		/* 820C03DCh case    7:*/		return 0x820C03E0;
		  /* 820C03E0h */ case    8:  		/* b 176 */
		/* 820C03E0h case    8:*/		return 0x820C0490;
		/* 820C03E0h case    8:*/		return 0x820C03E4;
	}
	return 0x820C03E4;
} // Block from 820C03C0h-820C03E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C03E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C03E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C03E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C03E4);
		  /* 820C03E4h */ case    0:  		/* li R5, 0 */
		/* 820C03E4h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C03E4h case    0:*/		return 0x820C03E8;
		  /* 820C03E8h */ case    1:  		/* mr R4, R26 */
		/* 820C03E8h case    1:*/		regs.R4 = regs.R26;
		/* 820C03E8h case    1:*/		return 0x820C03EC;
		  /* 820C03ECh */ case    2:  		/* mr R3, R31 */
		/* 820C03ECh case    2:*/		regs.R3 = regs.R31;
		/* 820C03ECh case    2:*/		return 0x820C03F0;
		  /* 820C03F0h */ case    3:  		/* bl -2384 */
		/* 820C03F0h case    3:*/		regs.LR = 0x820C03F4; return 0x820BFAA0;
		/* 820C03F0h case    3:*/		return 0x820C03F4;
		  /* 820C03F4h */ case    4:  		/* or. R29, R3, R3 */
		/* 820C03F4h case    4:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C03F4h case    4:*/		return 0x820C03F8;
		  /* 820C03F8h */ case    5:  		/* bc 12, CR0_LT, 2284 */
		/* 820C03F8h case    5:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C03F8h case    5:*/		return 0x820C03FC;
		  /* 820C03FCh */ case    6:  		/* cmplwi CR6, R21, 0 */
		/* 820C03FCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C03FCh case    6:*/		return 0x820C0400;
		  /* 820C0400h */ case    7:  		/* bc 12, CR6_EQ, 120 */
		/* 820C0400h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C0478;  }
		/* 820C0400h case    7:*/		return 0x820C0404;
		  /* 820C0404h */ case    8:  		/* lwz R28, <#[R21 + 8]> */
		/* 820C0404h case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R21 + 0x00000008) );
		/* 820C0404h case    8:*/		return 0x820C0408;
		  /* 820C0408h */ case    9:  		/* cmplwi CR6, R28, 0 */
		/* 820C0408h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C0408h case    9:*/		return 0x820C040C;
		  /* 820C040Ch */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 820C040Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820C042C;  }
		/* 820C040Ch case   10:*/		return 0x820C0410;
		  /* 820C0410h */ case   11:  		/* li R6, 0 */
		/* 820C0410h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C0410h case   11:*/		return 0x820C0414;
		  /* 820C0414h */ case   12:  		/* mr R5, R24 */
		/* 820C0414h case   12:*/		regs.R5 = regs.R24;
		/* 820C0414h case   12:*/		return 0x820C0418;
		  /* 820C0418h */ case   13:  		/* mr R4, R28 */
		/* 820C0418h case   13:*/		regs.R4 = regs.R28;
		/* 820C0418h case   13:*/		return 0x820C041C;
		  /* 820C041Ch */ case   14:  		/* mr R3, R31 */
		/* 820C041Ch case   14:*/		regs.R3 = regs.R31;
		/* 820C041Ch case   14:*/		return 0x820C0420;
		  /* 820C0420h */ case   15:  		/* bl 2760 */
		/* 820C0420h case   15:*/		regs.LR = 0x820C0424; return 0x820C0EE8;
		/* 820C0420h case   15:*/		return 0x820C0424;
		  /* 820C0424h */ case   16:  		/* or. R29, R3, R3 */
		/* 820C0424h case   16:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C0424h case   16:*/		return 0x820C0428;
		  /* 820C0428h */ case   17:  		/* bc 12, CR0_LT, 2236 */
		/* 820C0428h case   17:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C0428h case   17:*/		return 0x820C042C;
	}
	return 0x820C042C;
} // Block from 820C03E4h-820C042Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 820C042Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C042C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C042C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C042C);
		  /* 820C042Ch */ case    0:  		/* lwz R11, <#[R30 + 44]> */
		/* 820C042Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 820C042Ch case    0:*/		return 0x820C0430;
		  /* 820C0430h */ case    1:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 820C0430h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 820C0430h case    1:*/		return 0x820C0434;
		  /* 820C0434h */ case    2:  		/* bc 12, CR0_EQ, 60 */
		/* 820C0434h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C0470;  }
		/* 820C0434h case    2:*/		return 0x820C0438;
		  /* 820C0438h */ case    3:  		/* lwz R10, <#[R30 + 16]> */
		/* 820C0438h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 820C0438h case    3:*/		return 0x820C043C;
		  /* 820C043Ch */ case    4:  		/* li R9, 0 */
		/* 820C043Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C043Ch case    4:*/		return 0x820C0440;
		  /* 820C0440h */ case    5:  		/* lwz R5, <#[R30 + 20]> */
		/* 820C0440h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000014) );
		/* 820C0440h case    5:*/		return 0x820C0444;
		  /* 820C0444h */ case    6:  		/* li R8, 0 */
		/* 820C0444h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C0444h case    6:*/		return 0x820C0448;
		  /* 820C0448h */ case    7:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C0448h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0448h case    7:*/		return 0x820C044C;
		  /* 820C044Ch */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C044Ch case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C044Ch case    8:*/		return 0x820C0450;
		  /* 820C0450h */ case    9:  		/* rlwimi R5, R17, 28, 0, 11 */
		/* 820C0450h case    9:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R5,regs.R17);
		/* 820C0450h case    9:*/		return 0x820C0454;
		  /* 820C0454h */ case   10:  		/* mr R7, R24 */
		/* 820C0454h case   10:*/		regs.R7 = regs.R24;
		/* 820C0454h case   10:*/		return 0x820C0458;
		  /* 820C0458h */ case   11:  		/* add R6, R10, R11 */
		/* 820C0458h case   11:*/		cpu::op::add<0>(regs,&regs.R6,regs.R10,regs.R11);
		/* 820C0458h case   11:*/		return 0x820C045C;
		  /* 820C045Ch */ case   12:  		/* mr R4, R28 */
		/* 820C045Ch case   12:*/		regs.R4 = regs.R28;
		/* 820C045Ch case   12:*/		return 0x820C0460;
		  /* 820C0460h */ case   13:  		/* mr R3, R31 */
		/* 820C0460h case   13:*/		regs.R3 = regs.R31;
		/* 820C0460h case   13:*/		return 0x820C0464;
		  /* 820C0464h */ case   14:  		/* bl -63836 */
		/* 820C0464h case   14:*/		regs.LR = 0x820C0468; return 0x820B0B08;
		/* 820C0464h case   14:*/		return 0x820C0468;
		  /* 820C0468h */ case   15:  		/* or. R29, R3, R3 */
		/* 820C0468h case   15:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C0468h case   15:*/		return 0x820C046C;
		  /* 820C046Ch */ case   16:  		/* bc 12, CR0_LT, 2168 */
		/* 820C046Ch case   16:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C046Ch case   16:*/		return 0x820C0470;
	}
	return 0x820C0470;
} // Block from 820C042Ch-820C0470h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C0470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0470);
		  /* 820C0470h */ case    0:  		/* lwz R21, <#[R21 + 12]> */
		/* 820C0470h case    0:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R21 + 0x0000000C) );
		/* 820C0470h case    0:*/		return 0x820C0474;
		  /* 820C0474h */ case    1:  		/* b 28 */
		/* 820C0474h case    1:*/		return 0x820C0490;
		/* 820C0474h case    1:*/		return 0x820C0478;
	}
	return 0x820C0478;
} // Block from 820C0470h-820C0478h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C0478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0478);
		  /* 820C0478h */ case    0:  		/* li R5, 0 */
		/* 820C0478h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C0478h case    0:*/		return 0x820C047C;
		  /* 820C047Ch */ case    1:  		/* mr R4, R28 */
		/* 820C047Ch case    1:*/		regs.R4 = regs.R28;
		/* 820C047Ch case    1:*/		return 0x820C0480;
		  /* 820C0480h */ case    2:  		/* mr R3, R31 */
		/* 820C0480h case    2:*/		regs.R3 = regs.R31;
		/* 820C0480h case    2:*/		return 0x820C0484;
		  /* 820C0484h */ case    3:  		/* bl -2532 */
		/* 820C0484h case    3:*/		regs.LR = 0x820C0488; return 0x820BFAA0;
		/* 820C0484h case    3:*/		return 0x820C0488;
	}
	return 0x820C0488;
} // Block from 820C0478h-820C0488h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C0488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0488);
		  /* 820C0488h */ case    0:  		/* or. R29, R3, R3 */
		/* 820C0488h case    0:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C0488h case    0:*/		return 0x820C048C;
		  /* 820C048Ch */ case    1:  		/* bc 12, CR0_LT, 2136 */
		/* 820C048Ch case    1:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C048Ch case    1:*/		return 0x820C0490;
	}
	return 0x820C0490;
} // Block from 820C0488h-820C0490h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C0490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0490);
		  /* 820C0490h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820C0490h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C0490h case    0:*/		return 0x820C0494;
		  /* 820C0494h */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 820C0494h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820C0494h case    1:*/		return 0x820C0498;
		  /* 820C0498h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0498h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0498h case    2:*/		return 0x820C049C;
		  /* 820C049Ch */ case    3:  		/* add R24, R11, R24 */
		/* 820C049Ch case    3:*/		cpu::op::add<0>(regs,&regs.R24,regs.R11,regs.R24);
		/* 820C049Ch case    3:*/		return 0x820C04A0;
		  /* 820C04A0h */ case    4:  		/* bc 4, CR6_EQ, -792 */
		/* 820C04A0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C0188;  }
		/* 820C04A0h case    4:*/		return 0x820C04A4;
		  /* 820C04A4h */ case    5:  		/* lwz R27, <#[R1 + 148]> */
		/* 820C04A4h case    5:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000094) );
		/* 820C04A4h case    5:*/		return 0x820C04A8;
		  /* 820C04A8h */ case    6:  		/* lwz R19, <#[R1 + 144]> */
		/* 820C04A8h case    6:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R1 + 0x00000090) );
		/* 820C04A8h case    6:*/		return 0x820C04AC;
	}
	return 0x820C04AC;
} // Block from 820C0490h-820C04ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C04ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C04AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C04AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C04AC);
		  /* 820C04ACh */ case    0:  		/* lwz R25, <#[R1 + 380]> */
		/* 820C04ACh case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x0000017C) );
		/* 820C04ACh case    0:*/		return 0x820C04B0;
		  /* 820C04B0h */ case    1:  		/* cmpwi CR6, R25, 0 */
		/* 820C04B0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 820C04B0h case    1:*/		return 0x820C04B4;
		  /* 820C04B4h */ case    2:  		/* bc 12, CR6_EQ, 536 */
		/* 820C04B4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C06CC;  }
		/* 820C04B4h case    2:*/		return 0x820C04B8;
		  /* 820C04B8h */ case    3:  		/* mr R29, R16 */
		/* 820C04B8h case    3:*/		regs.R29 = regs.R16;
		/* 820C04B8h case    3:*/		return 0x820C04BC;
		  /* 820C04BCh */ case    4:  		/* cmplwi CR6, R22, 0 */
		/* 820C04BCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820C04BCh case    4:*/		return 0x820C04C0;
		  /* 820C04C0h */ case    5:  		/* bc 12, CR6_EQ, 84 */
		/* 820C04C0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C0514;  }
		/* 820C04C0h case    5:*/		return 0x820C04C4;
		  /* 820C04C4h */ case    6:  		/* mr R30, R15 */
		/* 820C04C4h case    6:*/		regs.R30 = regs.R15;
		/* 820C04C4h case    6:*/		return 0x820C04C8;
		  /* 820C04C8h */ case    7:  		/* lwz R3, <#[R31 + 8]> */
		/* 820C04C8h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820C04C8h case    7:*/		return 0x820C04CC;
		  /* 820C04CCh */ case    8:  		/* li R5, 1 */
		/* 820C04CCh case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820C04CCh case    8:*/		return 0x820C04D0;
		  /* 820C04D0h */ case    9:  		/* lwz R11, <#[R30]> */
		/* 820C04D0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C04D0h case    9:*/		return 0x820C04D4;
		  /* 820C04D4h */ case   10:  		/* lwz R10, <#[R31 + 24]> */
		/* 820C04D4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820C04D4h case   10:*/		return 0x820C04D8;
	}
	return 0x820C04D8;
} // Block from 820C04ACh-820C04D8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C04D8h
// Function '?EmitStatement@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C04D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C04D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C04D8);
		  /* 820C04D8h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C04D8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C04D8h case    0:*/		return 0x820C04DC;
		  /* 820C04DCh */ case    1:  		/* lwz R9, <#[R3]> */
		/* 820C04DCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 820C04DCh case    1:*/		return 0x820C04E0;
		  /* 820C04E0h */ case    2:  		/* lwz R8, <#[R3 + 20]> */
		/* 820C04E0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 820C04E0h case    2:*/		return 0x820C04E4;
		  /* 820C04E4h */ case    3:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820C04E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C04E4h case    3:*/		return 0x820C04E8;
		  /* 820C04E8h */ case    4:  		/* lwz R10, <#[R9 + 4]> */
		/* 820C04E8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 820C04E8h case    4:*/		return 0x820C04EC;
		  /* 820C04ECh */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C04ECh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C04ECh case    5:*/		return 0x820C04F0;
		  /* 820C04F0h */ case    6:  		/* lwzx R4, <#[R11 + R8]> */
		/* 820C04F0h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820C04F0h case    6:*/		return 0x820C04F4;
		  /* 820C04F4h */ case    7:  		/* mtspr CTR, R10 */
		/* 820C04F4h case    7:*/		regs.CTR = regs.R10;
		/* 820C04F4h case    7:*/		return 0x820C04F8;
		  /* 820C04F8h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820C04F8h case    8:*/		if ( 1 ) { regs.LR = 0x820C04FC; return (uint32)regs.CTR; }
		/* 820C04F8h case    8:*/		return 0x820C04FC;
		  /* 820C04FCh */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820C04FCh case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C04FCh case    9:*/		return 0x820C0500;
		  /* 820C0500h */ case   10:  		/* bc 12, CR0_LT, 648 */
		/* 820C0500h case   10:*/		if ( regs.CR[0].lt ) { return 0x820C0788;  }
		/* 820C0500h case   10:*/		return 0x820C0504;
		  /* 820C0504h */ case   11:  		/* addi R29, R29, 1 */
		/* 820C0504h case   11:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820C0504h case   11:*/		return 0x820C0508;
		  /* 820C0508h */ case   12:  		/* addi R30, R30, 4 */
		/* 820C0508h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C0508h case   12:*/		return 0x820C050C;
		  /* 820C050Ch */ case   13:  		/* cmplw CR6, R29, R22 */
		/* 820C050Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R22);
		/* 820C050Ch case   13:*/		return 0x820C0510;
		  /* 820C0510h */ case   14:  		/* bc 12, CR6_LT, -72 */
		/* 820C0510h case   14:*/		if ( regs.CR[6].lt ) { return 0x820C04C8;  }
		/* 820C0510h case   14:*/		return 0x820C0514;
	}
	return 0x820C0514;
} // Block from 820C04D8h-820C0514h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C0514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0514);
		  /* 820C0514h */ case    0:  		/* lis R11, -32245 */
		/* 820C0514h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820B);
		/* 820C0514h case    0:*/		return 0x820C0518;
		  /* 820C0518h */ case    1:  		/* mr R6, R31 */
		/* 820C0518h case    1:*/		regs.R6 = regs.R31;
		/* 820C0518h case    1:*/		return 0x820C051C;
		  /* 820C051Ch */ case    2:  		/* mr R5, R22 */
		/* 820C051Ch case    2:*/		regs.R5 = regs.R22;
		/* 820C051Ch case    2:*/		return 0x820C0520;
		  /* 820C0520h */ case    3:  		/* mr R4, R15 */
		/* 820C0520h case    3:*/		regs.R4 = regs.R15;
		/* 820C0520h case    3:*/		return 0x820C0524;
		  /* 820C0524h */ case    4:  		/* addi R3, R11, 1040 */
		/* 820C0524h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x410);
		/* 820C0524h case    4:*/		return 0x820C0528;
		  /* 820C0528h */ case    5:  		/* bl 252280 */
		/* 820C0528h case    5:*/		regs.LR = 0x820C052C; return 0x820FDEA0;
		/* 820C0528h case    5:*/		return 0x820C052C;
		  /* 820C052Ch */ case    6:  		/* mr R6, R16 */
		/* 820C052Ch case    6:*/		regs.R6 = regs.R16;
		/* 820C052Ch case    6:*/		return 0x820C0530;
		  /* 820C0530h */ case    7:  		/* cmplwi CR6, R22, 0 */
		/* 820C0530h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820C0530h case    7:*/		return 0x820C0534;
		  /* 820C0534h */ case    8:  		/* bc 12, CR6_EQ, 408 */
		/* 820C0534h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C06CC;  }
		/* 820C0534h case    8:*/		return 0x820C0538;
		  /* 820C0538h */ case    9:  		/* lwz R11, <#[R15]> */
		/* 820C0538h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 820C0538h case    9:*/		return 0x820C053C;
		  /* 820C053Ch */ case   10:  		/* cmplwi CR6, R22, 1 */
		/* 820C053Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000001);
		/* 820C053Ch case   10:*/		return 0x820C0540;
		  /* 820C0540h */ case   11:  		/* lwz R8, <#[R31 + 24]> */
		/* 820C0540h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0540h case   11:*/		return 0x820C0544;
		  /* 820C0544h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0544h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0544h case   12:*/		return 0x820C0548;
		  /* 820C0548h */ case   13:  		/* lwz R10, <#[R31 + 8]> */
		/* 820C0548h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0548h case   13:*/		return 0x820C054C;
		  /* 820C054Ch */ case   14:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820C054Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820C054Ch case   14:*/		return 0x820C0550;
		  /* 820C0550h */ case   15:  		/* lwz R7, <#[R10 + 20]> */
		/* 820C0550h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000014) );
		/* 820C0550h case   15:*/		return 0x820C0554;
		  /* 820C0554h */ case   16:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0554h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0554h case   16:*/		return 0x820C0558;
		  /* 820C0558h */ case   17:  		/* lwzx R10, <#[R11 + R7]> */
		/* 820C0558h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820C0558h case   17:*/		return 0x820C055C;
		  /* 820C055Ch */ case   18:  		/* bc 4, CR6_GT, 368 */
		/* 820C055Ch case   18:*/		if ( !regs.CR[6].gt ) { return 0x820C06CC;  }
		/* 820C055Ch case   18:*/		return 0x820C0560;
		  /* 820C0560h */ case   19:  		/* addi R30, R22, -1 */
		/* 820C0560h case   19:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R22,0xFFFFFFFF);
		/* 820C0560h case   19:*/		return 0x820C0564;
		  /* 820C0564h */ case   20:  		/* addi R28, R15, 4 */
		/* 820C0564h case   20:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R15,0x4);
		/* 820C0564h case   20:*/		return 0x820C0568;
		  /* 820C0568h */ case   21:  		/* mr R9, R28 */
		/* 820C0568h case   21:*/		regs.R9 = regs.R28;
		/* 820C0568h case   21:*/		return 0x820C056C;
		  /* 820C056Ch */ case   22:  		/* mtspr CTR, R30 */
		/* 820C056Ch case   22:*/		regs.CTR = regs.R30;
		/* 820C056Ch case   22:*/		return 0x820C0570;
		  /* 820C0570h */ case   23:  		/* lwz R11, <#[R9]> */
		/* 820C0570h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820C0570h case   23:*/		return 0x820C0574;
		  /* 820C0574h */ case   24:  		/* lwz R5, <#[R10 + 108]> */
		/* 820C0574h case   24:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x0000006C) );
		/* 820C0574h case   24:*/		return 0x820C0578;
		  /* 820C0578h */ case   25:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0578h case   25:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0578h case   25:*/		return 0x820C057C;
		  /* 820C057Ch */ case   26:  		/* lwzx R11, <#[R11 + R8]> */
		/* 820C057Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820C057Ch case   26:*/		return 0x820C0580;
		  /* 820C0580h */ case   27:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0580h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0580h case   27:*/		return 0x820C0584;
		  /* 820C0584h */ case   28:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820C0584h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820C0584h case   28:*/		return 0x820C0588;
		  /* 820C0588h */ case   29:  		/* lwz R4, <#[R11 + 108]> */
		/* 820C0588h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000006C) );
		/* 820C0588h case   29:*/		return 0x820C058C;
		  /* 820C058Ch */ case   30:  		/* cmplw CR6, R5, R4 */
		/* 820C058Ch case   30:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 820C058Ch case   30:*/		return 0x820C0590;
		  /* 820C0590h */ case   31:  		/* bc 4, CR6_EQ, 44 */
		/* 820C0590h case   31:*/		if ( !regs.CR[6].eq ) { return 0x820C05BC;  }
		/* 820C0590h case   31:*/		return 0x820C0594;
		  /* 820C0594h */ case   32:  		/* lwz R5, <#[R10 + 16]> */
		/* 820C0594h case   32:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000010) );
		/* 820C0594h case   32:*/		return 0x820C0598;
		  /* 820C0598h */ case   33:  		/* lwz R4, <#[R11 + 16]> */
		/* 820C0598h case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000010) );
		/* 820C0598h case   33:*/		return 0x820C059C;
		  /* 820C059Ch */ case   34:  		/* cmplw CR6, R5, R4 */
		/* 820C059Ch case   34:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 820C059Ch case   34:*/		return 0x820C05A0;
		  /* 820C05A0h */ case   35:  		/* bc 4, CR6_EQ, 28 */
		/* 820C05A0h case   35:*/		if ( !regs.CR[6].eq ) { return 0x820C05BC;  }
		/* 820C05A0h case   35:*/		return 0x820C05A4;
		  /* 820C05A4h */ case   36:  		/* lwz R5, <#[R10]> */
		/* 820C05A4h case   36:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x00000000) );
		/* 820C05A4h case   36:*/		return 0x820C05A8;
		  /* 820C05A8h */ case   37:  		/* lwz R4, <#[R11]> */
		/* 820C05A8h case   37:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820C05A8h case   37:*/		return 0x820C05AC;
		  /* 820C05ACh */ case   38:  		/* cmplw CR6, R5, R4 */
		/* 820C05ACh case   38:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R4);
		/* 820C05ACh case   38:*/		return 0x820C05B0;
		  /* 820C05B0h */ case   39:  		/* bc 4, CR6_EQ, 12 */
		/* 820C05B0h case   39:*/		if ( !regs.CR[6].eq ) { return 0x820C05BC;  }
		/* 820C05B0h case   39:*/		return 0x820C05B4;
		  /* 820C05B4h */ case   40:  		/* addi R6, R6, 1 */
		/* 820C05B4h case   40:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820C05B4h case   40:*/		return 0x820C05B8;
		  /* 820C05B8h */ case   41:  		/* b 8 */
		/* 820C05B8h case   41:*/		return 0x820C05C0;
		/* 820C05B8h case   41:*/		return 0x820C05BC;
	}
	return 0x820C05BC;
} // Block from 820C0514h-820C05BCh (42 instructions)

//////////////////////////////////////////////////////
// Block at 820C05BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C05BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C05BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C05BC);
		  /* 820C05BCh */ case    0:  		/* mr R10, R11 */
		/* 820C05BCh case    0:*/		regs.R10 = regs.R11;
		/* 820C05BCh case    0:*/		return 0x820C05C0;
	}
	return 0x820C05C0;
} // Block from 820C05BCh-820C05C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C05C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C05C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C05C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C05C0);
		  /* 820C05C0h */ case    0:  		/* addi R9, R9, 4 */
		/* 820C05C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820C05C0h case    0:*/		return 0x820C05C4;
		  /* 820C05C4h */ case    1:  		/* bc 16, CR0_LT, -84 */
		/* 820C05C4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C0570;  }
		/* 820C05C4h case    1:*/		return 0x820C05C8;
		  /* 820C05C8h */ case    2:  		/* cmplwi CR6, R6, 0 */
		/* 820C05C8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820C05C8h case    2:*/		return 0x820C05CC;
		  /* 820C05CCh */ case    3:  		/* bc 12, CR6_EQ, 256 */
		/* 820C05CCh case    3:*/		if ( regs.CR[6].eq ) { return 0x820C06CC;  }
		/* 820C05CCh case    3:*/		return 0x820C05D0;
		  /* 820C05D0h */ case    4:  		/* rlwinm R29, R6, 2, 0, 29 */
		/* 820C05D0h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R6);
		/* 820C05D0h case    4:*/		return 0x820C05D4;
		  /* 820C05D4h */ case    5:  		/* lis R4, 9345 */
		/* 820C05D4h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C05D4h case    5:*/		return 0x820C05D8;
		  /* 820C05D8h */ case    6:  		/* mr R3, R29 */
		/* 820C05D8h case    6:*/		regs.R3 = regs.R29;
		/* 820C05D8h case    6:*/		return 0x820C05DC;
		  /* 820C05DCh */ case    7:  		/* bl -230364 */
		/* 820C05DCh case    7:*/		regs.LR = 0x820C05E0; return 0x82088200;
		/* 820C05DCh case    7:*/		return 0x820C05E0;
		  /* 820C05E0h */ case    8:  		/* or. R26, R3, R3 */
		/* 820C05E0h case    8:*/		cpu::op::or<1>(regs,&regs.R26,regs.R3,regs.R3);
		/* 820C05E0h case    8:*/		return 0x820C05E4;
		  /* 820C05E4h */ case    9:  		/* stw R26, <#[R1 + 152]> */
		/* 820C05E4h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000098) );
		/* 820C05E4h case    9:*/		return 0x820C05E8;
		  /* 820C05E8h */ case   10:  		/* bc 12, CR0_EQ, 1892 */
		/* 820C05E8h case   10:*/		if ( regs.CR[0].eq ) { return 0x820C0D4C;  }
		/* 820C05E8h case   10:*/		return 0x820C05EC;
		  /* 820C05ECh */ case   11:  		/* lis R4, 9345 */
		/* 820C05ECh case   11:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C05ECh case   11:*/		return 0x820C05F0;
		  /* 820C05F0h */ case   12:  		/* mr R3, R29 */
		/* 820C05F0h case   12:*/		regs.R3 = regs.R29;
		/* 820C05F0h case   12:*/		return 0x820C05F4;
		  /* 820C05F4h */ case   13:  		/* bl -230388 */
		/* 820C05F4h case   13:*/		regs.LR = 0x820C05F8; return 0x82088200;
		/* 820C05F4h case   13:*/		return 0x820C05F8;
		  /* 820C05F8h */ case   14:  		/* or. R14, R3, R3 */
		/* 820C05F8h case   14:*/		cpu::op::or<1>(regs,&regs.R14,regs.R3,regs.R3);
		/* 820C05F8h case   14:*/		return 0x820C05FC;
		  /* 820C05FCh */ case   15:  		/* bc 12, CR0_EQ, 1872 */
		/* 820C05FCh case   15:*/		if ( regs.CR[0].eq ) { return 0x820C0D4C;  }
		/* 820C05FCh case   15:*/		return 0x820C0600;
		  /* 820C0600h */ case   16:  		/* lwz R11, <#[R15]> */
		/* 820C0600h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 820C0600h case   16:*/		return 0x820C0604;
		  /* 820C0604h */ case   17:  		/* mr R5, R16 */
		/* 820C0604h case   17:*/		regs.R5 = regs.R16;
		/* 820C0604h case   17:*/		return 0x820C0608;
		  /* 820C0608h */ case   18:  		/* lwz R9, <#[R31 + 24]> */
		/* 820C0608h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0608h case   18:*/		return 0x820C060C;
		  /* 820C060Ch */ case   19:  		/* mr R10, R14 */
		/* 820C060Ch case   19:*/		regs.R10 = regs.R14;
		/* 820C060Ch case   19:*/		return 0x820C0610;
		  /* 820C0610h */ case   20:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 820C0610h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 820C0610h case   20:*/		return 0x820C0614;
		  /* 820C0614h */ case   21:  		/* lwz R7, <#[R31 + 8]> */
		/* 820C0614h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0614h case   21:*/		return 0x820C0618;
		  /* 820C0618h */ case   22:  		/* mtspr CTR, R30 */
		/* 820C0618h case   22:*/		regs.CTR = regs.R30;
		/* 820C0618h case   22:*/		return 0x820C061C;
		  /* 820C061Ch */ case   23:  		/* mr R4, R28 */
		/* 820C061Ch case   23:*/		regs.R4 = regs.R28;
		/* 820C061Ch case   23:*/		return 0x820C0620;
		  /* 820C0620h */ case   24:  		/* subf R3, R14, R26 */
		/* 820C0620h case   24:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R14,regs.R26);
		/* 820C0620h case   24:*/		return 0x820C0624;
		  /* 820C0624h */ case   25:  		/* lwzx R9, <#[R8 + R9]> */
		/* 820C0624h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820C0624h case   25:*/		return 0x820C0628;
		  /* 820C0628h */ case   26:  		/* lwz R8, <#[R7 + 20]> */
		/* 820C0628h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000014) );
		/* 820C0628h case   26:*/		return 0x820C062C;
		  /* 820C062Ch */ case   27:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C062Ch case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C062Ch case   27:*/		return 0x820C0630;
		  /* 820C0630h */ case   28:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820C0630h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820C0630h case   28:*/		return 0x820C0634;
		  /* 820C0634h */ case   29:  		/* lwz R6, <#[R4]> */
		/* 820C0634h case   29:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R4 + 0x00000000) );
		/* 820C0634h case   29:*/		return 0x820C0638;
		  /* 820C0638h */ case   30:  		/* lwz R8, <#[R31 + 24]> */
		/* 820C0638h case   30:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0638h case   30:*/		return 0x820C063C;
		  /* 820C063Ch */ case   31:  		/* rlwinm R7, R6, 2, 0, 29 */
		/* 820C063Ch case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R6);
		/* 820C063Ch case   31:*/		return 0x820C0640;
		  /* 820C0640h */ case   32:  		/* lwz R30, <#[R31 + 8]> */
		/* 820C0640h case   32:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0640h case   32:*/		return 0x820C0644;
		  /* 820C0644h */ case   33:  		/* lwz R29, <#[R9 + 108]> */
		/* 820C0644h case   33:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + 0x0000006C) );
		/* 820C0644h case   33:*/		return 0x820C0648;
		  /* 820C0648h */ case   34:  		/* lwzx R7, <#[R7 + R8]> */
		/* 820C0648h case   34:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R8 + 0x00000000) );
		/* 820C0648h case   34:*/		return 0x820C064C;
		  /* 820C064Ch */ case   35:  		/* lwz R8, <#[R30 + 20]> */
		/* 820C064Ch case   35:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000014) );
		/* 820C064Ch case   35:*/		return 0x820C0650;
		  /* 820C0650h */ case   36:  		/* rlwinm R30, R7, 2, 0, 29 */
		/* 820C0650h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R7);
		/* 820C0650h case   36:*/		return 0x820C0654;
		  /* 820C0654h */ case   37:  		/* lwzx R8, <#[R30 + R8]> */
		/* 820C0654h case   37:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + regs.R8 + 0x00000000) );
		/* 820C0654h case   37:*/		return 0x820C0658;
		  /* 820C0658h */ case   38:  		/* lwz R30, <#[R8 + 108]> */
		/* 820C0658h case   38:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R8 + 0x0000006C) );
		/* 820C0658h case   38:*/		return 0x820C065C;
		  /* 820C065Ch */ case   39:  		/* cmplw CR6, R29, R30 */
		/* 820C065Ch case   39:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R30);
		/* 820C065Ch case   39:*/		return 0x820C0660;
		  /* 820C0660h */ case   40:  		/* bc 4, CR6_EQ, 52 */
		/* 820C0660h case   40:*/		if ( !regs.CR[6].eq ) { return 0x820C0694;  }
		/* 820C0660h case   40:*/		return 0x820C0664;
		  /* 820C0664h */ case   41:  		/* lwz R30, <#[R9 + 16]> */
		/* 820C0664h case   41:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x00000010) );
		/* 820C0664h case   41:*/		return 0x820C0668;
		  /* 820C0668h */ case   42:  		/* lwz R29, <#[R8 + 16]> */
		/* 820C0668h case   42:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R8 + 0x00000010) );
		/* 820C0668h case   42:*/		return 0x820C066C;
		  /* 820C066Ch */ case   43:  		/* cmplw CR6, R30, R29 */
		/* 820C066Ch case   43:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 820C066Ch case   43:*/		return 0x820C0670;
		  /* 820C0670h */ case   44:  		/* bc 4, CR6_EQ, 36 */
		/* 820C0670h case   44:*/		if ( !regs.CR[6].eq ) { return 0x820C0694;  }
		/* 820C0670h case   44:*/		return 0x820C0674;
		  /* 820C0674h */ case   45:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 820C0674h case   45:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 820C0674h case   45:*/		return 0x820C0678;
		  /* 820C0678h */ case   46:  		/* stwx R7, <#[R3 + R10]> */
		/* 820C0678h case   46:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 820C0678h case   46:*/		return 0x820C067C;
		  /* 820C067Ch */ case   47:  		/* lwz R7, <#[R31 + 24]> */
		/* 820C067Ch case   47:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 820C067Ch case   47:*/		return 0x820C0680;
		  /* 820C0680h */ case   48:  		/* addi R5, R5, 1 */
		/* 820C0680h case   48:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 820C0680h case   48:*/		return 0x820C0684;
		  /* 820C0684h */ case   49:  		/* lwzx R8, <#[R8 + R7]> */
		/* 820C0684h case   49:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 820C0684h case   49:*/		return 0x820C0688;
		  /* 820C0688h */ case   50:  		/* stw R8, <#[R10]> */
		/* 820C0688h case   50:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820C0688h case   50:*/		return 0x820C068C;
		  /* 820C068Ch */ case   51:  		/* addi R10, R10, 4 */
		/* 820C068Ch case   51:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C068Ch case   51:*/		return 0x820C0690;
		  /* 820C0690h */ case   52:  		/* b 12 */
		/* 820C0690h case   52:*/		return 0x820C069C;
		/* 820C0690h case   52:*/		return 0x820C0694;
	}
	return 0x820C0694;
} // Block from 820C05C0h-820C0694h (53 instructions)

//////////////////////////////////////////////////////
// Block at 820C0694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0694);
		  /* 820C0694h */ case    0:  		/* mr R11, R6 */
		/* 820C0694h case    0:*/		regs.R11 = regs.R6;
		/* 820C0694h case    0:*/		return 0x820C0698;
		  /* 820C0698h */ case    1:  		/* mr R9, R8 */
		/* 820C0698h case    1:*/		regs.R9 = regs.R8;
		/* 820C0698h case    1:*/		return 0x820C069C;
	}
	return 0x820C069C;
} // Block from 820C0694h-820C069Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C069Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C069C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C069C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C069C);
		  /* 820C069Ch */ case    0:  		/* addi R4, R4, 4 */
		/* 820C069Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 820C069Ch case    0:*/		return 0x820C06A0;
		  /* 820C06A0h */ case    1:  		/* bc 16, CR0_LT, -108 */
		/* 820C06A0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C0634;  }
		/* 820C06A0h case    1:*/		return 0x820C06A4;
		  /* 820C06A4h */ case    2:  		/* li R9, 0 */
		/* 820C06A4h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C06A4h case    2:*/		return 0x820C06A8;
		  /* 820C06A8h */ case    3:  		/* rlwimi R5, R17, 28, 0, 11 */
		/* 820C06A8h case    3:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R5,regs.R17);
		/* 820C06A8h case    3:*/		return 0x820C06AC;
		  /* 820C06ACh */ case    4:  		/* li R8, 0 */
		/* 820C06ACh case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C06ACh case    4:*/		return 0x820C06B0;
		  /* 820C06B0h */ case    5:  		/* mr R7, R14 */
		/* 820C06B0h case    5:*/		regs.R7 = regs.R14;
		/* 820C06B0h case    5:*/		return 0x820C06B4;
		  /* 820C06B4h */ case    6:  		/* mr R6, R26 */
		/* 820C06B4h case    6:*/		regs.R6 = regs.R26;
		/* 820C06B4h case    6:*/		return 0x820C06B8;
		  /* 820C06B8h */ case    7:  		/* mr R4, R23 */
		/* 820C06B8h case    7:*/		regs.R4 = regs.R23;
		/* 820C06B8h case    7:*/		return 0x820C06BC;
		  /* 820C06BCh */ case    8:  		/* mr R3, R31 */
		/* 820C06BCh case    8:*/		regs.R3 = regs.R31;
		/* 820C06BCh case    8:*/		return 0x820C06C0;
		  /* 820C06C0h */ case    9:  		/* bl -64440 */
		/* 820C06C0h case    9:*/		regs.LR = 0x820C06C4; return 0x820B0B08;
		/* 820C06C0h case    9:*/		return 0x820C06C4;
		  /* 820C06C4h */ case   10:  		/* or. R29, R3, R3 */
		/* 820C06C4h case   10:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C06C4h case   10:*/		return 0x820C06C8;
		  /* 820C06C8h */ case   11:  		/* bc 12, CR0_LT, 1564 */
		/* 820C06C8h case   11:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C06C8h case   11:*/		return 0x820C06CC;
	}
	return 0x820C06CC;
} // Block from 820C069Ch-820C06CCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C06CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C06CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C06CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C06CC);
		  /* 820C06CCh */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 820C06CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820C06CCh case    0:*/		return 0x820C06D0;
		  /* 820C06D0h */ case    1:  		/* cmpwi CR6, R25, 0 */
		/* 820C06D0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 820C06D0h case    1:*/		return 0x820C06D4;
		  /* 820C06D4h */ case    2:  		/* lwz R11, <#[R11 + 28]> */
		/* 820C06D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 820C06D4h case    2:*/		return 0x820C06D8;
		  /* 820C06D8h */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 820C06D8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C0708;  }
		/* 820C06D8h case    3:*/		return 0x820C06DC;
		  /* 820C06DCh */ case    4:  		/* rlwinm R30, R11, 2, 0, 29 */
		/* 820C06DCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R11);
		/* 820C06DCh case    4:*/		return 0x820C06E0;
		  /* 820C06E0h */ case    5:  		/* lis R4, 9345 */
		/* 820C06E0h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C06E0h case    5:*/		return 0x820C06E4;
		  /* 820C06E4h */ case    6:  		/* mr R3, R30 */
		/* 820C06E4h case    6:*/		regs.R3 = regs.R30;
		/* 820C06E4h case    6:*/		return 0x820C06E8;
		  /* 820C06E8h */ case    7:  		/* bl -230632 */
		/* 820C06E8h case    7:*/		regs.LR = 0x820C06EC; return 0x82088200;
		/* 820C06E8h case    7:*/		return 0x820C06EC;
		  /* 820C06ECh */ case    8:  		/* or. R19, R3, R3 */
		/* 820C06ECh case    8:*/		cpu::op::or<1>(regs,&regs.R19,regs.R3,regs.R3);
		/* 820C06ECh case    8:*/		return 0x820C06F0;
		  /* 820C06F0h */ case    9:  		/* stw R19, <#[R1 + 144]> */
		/* 820C06F0h case    9:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x00000090) );
		/* 820C06F0h case    9:*/		return 0x820C06F4;
		  /* 820C06F4h */ case   10:  		/* bc 12, CR0_EQ, 1624 */
		/* 820C06F4h case   10:*/		if ( regs.CR[0].eq ) { return 0x820C0D4C;  }
		/* 820C06F4h case   10:*/		return 0x820C06F8;
		  /* 820C06F8h */ case   11:  		/* mr R5, R30 */
		/* 820C06F8h case   11:*/		regs.R5 = regs.R30;
		/* 820C06F8h case   11:*/		return 0x820C06FC;
		  /* 820C06FCh */ case   12:  		/* lwz R4, <#[R31 + 24]> */
		/* 820C06FCh case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820C06FCh case   12:*/		return 0x820C0700;
		  /* 820C0700h */ case   13:  		/* mr R3, R19 */
		/* 820C0700h case   13:*/		regs.R3 = regs.R19;
		/* 820C0700h case   13:*/		return 0x820C0704;
		  /* 820C0704h */ case   14:  		/* bl -191828 */
		/* 820C0704h case   14:*/		regs.LR = 0x820C0708; return 0x820919B0;
		/* 820C0704h case   14:*/		return 0x820C0708;
	}
	return 0x820C0708;
} // Block from 820C06CCh-820C0708h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C0708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0708);
		  /* 820C0708h */ case    0:  		/* lwz R30, <#[R31 + 80]> */
		/* 820C0708h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000050) );
		/* 820C0708h case    0:*/		return 0x820C070C;
		  /* 820C070Ch */ case    1:  		/* mr R5, R19 */
		/* 820C070Ch case    1:*/		regs.R5 = regs.R19;
		/* 820C070Ch case    1:*/		return 0x820C0710;
		  /* 820C0710h */ case    2:  		/* stw R16, <#[R31 + 80]> */
		/* 820C0710h case    2:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R31 + 0x00000050) );
		/* 820C0710h case    2:*/		return 0x820C0714;
		  /* 820C0714h */ case    3:  		/* mr R3, R31 */
		/* 820C0714h case    3:*/		regs.R3 = regs.R31;
		/* 820C0714h case    3:*/		return 0x820C0718;
		  /* 820C0718h */ case    4:  		/* stw R17, <#[R23 + 72]> */
		/* 820C0718h case    4:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R23 + 0x00000048) );
		/* 820C0718h case    4:*/		return 0x820C071C;
		  /* 820C071Ch */ case    5:  		/* lwz R4, <#[R23 + 48]> */
		/* 820C071Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000030) );
		/* 820C071Ch case    5:*/		return 0x820C0720;
		  /* 820C0720h */ case    6:  		/* bl -3200 */
		/* 820C0720h case    6:*/		regs.LR = 0x820C0724; return 0x820BFAA0;
		/* 820C0720h case    6:*/		return 0x820C0724;
		  /* 820C0724h */ case    7:  		/* lwz R11, <#[R31 + 80]> */
		/* 820C0724h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000050) );
		/* 820C0724h case    7:*/		return 0x820C0728;
		  /* 820C0728h */ case    8:  		/* mr R29, R3 */
		/* 820C0728h case    8:*/		regs.R29 = regs.R3;
		/* 820C0728h case    8:*/		return 0x820C072C;
		  /* 820C072Ch */ case    9:  		/* cmpwi CR6, R11, 0 */
		/* 820C072Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C072Ch case    9:*/		return 0x820C0730;
		  /* 820C0730h */ case   10:  		/* bc 4, CR6_EQ, 20 */
		/* 820C0730h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820C0744;  }
		/* 820C0730h case   10:*/		return 0x820C0734;
		  /* 820C0734h */ case   11:  		/* lwz R11, <#[R31 + 84]> */
		/* 820C0734h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820C0734h case   11:*/		return 0x820C0738;
		  /* 820C0738h */ case   12:  		/* cmpwi CR6, R11, 0 */
		/* 820C0738h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C0738h case   12:*/		return 0x820C073C;
		  /* 820C073Ch */ case   13:  		/* mr R11, R16 */
		/* 820C073Ch case   13:*/		regs.R11 = regs.R16;
		/* 820C073Ch case   13:*/		return 0x820C0740;
		  /* 820C0740h */ case   14:  		/* bc 12, CR6_EQ, 8 */
		/* 820C0740h case   14:*/		if ( regs.CR[6].eq ) { return 0x820C0748;  }
		/* 820C0740h case   14:*/		return 0x820C0744;
	}
	return 0x820C0744;
} // Block from 820C0708h-820C0744h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C0744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0744);
		  /* 820C0744h */ case    0:  		/* mr R11, R17 */
		/* 820C0744h case    0:*/		regs.R11 = regs.R17;
		/* 820C0744h case    0:*/		return 0x820C0748;
	}
	return 0x820C0748;
} // Block from 820C0744h-820C0748h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C0748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0748);
		  /* 820C0748h */ case    0:  		/* stw R30, <#[R31 + 80]> */
		/* 820C0748h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000050) );
		/* 820C0748h case    0:*/		return 0x820C074C;
		  /* 820C074Ch */ case    1:  		/* cmpwi CR6, R29, 0 */
		/* 820C074Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820C074Ch case    1:*/		return 0x820C0750;
		  /* 820C0750h */ case    2:  		/* stw R16, <#[R23 + 72]> */
		/* 820C0750h case    2:*/		cpu::mem::store32( regs, regs.R16, (uint32)(regs.R23 + 0x00000048) );
		/* 820C0750h case    2:*/		return 0x820C0754;
		  /* 820C0754h */ case    3:  		/* bc 12, CR6_LT, 1424 */
		/* 820C0754h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C0CE4;  }
		/* 820C0754h case    3:*/		return 0x820C0758;
		  /* 820C0758h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820C0758h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C0758h case    4:*/		return 0x820C075C;
		  /* 820C075Ch */ case    5:  		/* bc 4, CR6_EQ, 56 */
		/* 820C075Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C0794;  }
		/* 820C075Ch case    5:*/		return 0x820C0760;
		  /* 820C0760h */ case    6:  		/* lwz R11, <#[R23 + 20]> */
		/* 820C0760h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000014) );
		/* 820C0760h case    6:*/		return 0x820C0764;
		  /* 820C0764h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820C0764h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C0764h case    7:*/		return 0x820C0768;
		  /* 820C0768h */ case    8:  		/* bc 4, CR6_GT, 44 */
		/* 820C0768h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820C0794;  }
		/* 820C0768h case    8:*/		return 0x820C076C;
		  /* 820C076Ch */ case    9:  		/* lis R11, -32255 */
		/* 820C076Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C076Ch case    9:*/		return 0x820C0770;
		  /* 820C0770h */ case   10:  		/* lwz R7, <#[R1 + 348]> */
		/* 820C0770h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000015C) );
		/* 820C0770h case   10:*/		return 0x820C0774;
		  /* 820C0774h */ case   11:  		/* li R5, 3507 */
		/* 820C0774h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0xDB3);
		/* 820C0774h case   11:*/		return 0x820C0778;
		  /* 820C0778h */ case   12:  		/* addi R6, R11, 9412 */
		/* 820C0778h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x24C4);
		/* 820C0778h case   12:*/		return 0x820C077C;
		  /* 820C077Ch */ case   13:  		/* mr R4, R23 */
		/* 820C077Ch case   13:*/		regs.R4 = regs.R23;
		/* 820C077Ch case   13:*/		return 0x820C0780;
		  /* 820C0780h */ case   14:  		/* mr R3, R31 */
		/* 820C0780h case   14:*/		regs.R3 = regs.R31;
		/* 820C0780h case   14:*/		return 0x820C0784;
		  /* 820C0784h */ case   15:  		/* bl -64916 */
		/* 820C0784h case   15:*/		regs.LR = 0x820C0788; return 0x820B09F0;
		/* 820C0784h case   15:*/		return 0x820C0788;
	}
	return 0x820C0788;
} // Block from 820C0748h-820C0788h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C0788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0788);
		  /* 820C0788h */ case    0:  		/* lis R29, -32768 */
		/* 820C0788h case    0:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8000);
		/* 820C0788h case    0:*/		return 0x820C078C;
		  /* 820C078Ch */ case    1:  		/* ori R29, R29, 16389 */
		/* 820C078Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0x4005);
		/* 820C078Ch case    1:*/		return 0x820C0790;
		  /* 820C0790h */ case    2:  		/* b 1364 */
		/* 820C0790h case    2:*/		return 0x820C0CE4;
		/* 820C0790h case    2:*/		return 0x820C0794;
	}
	return 0x820C0794;
} // Block from 820C0788h-820C0794h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C0794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0794);
		  /* 820C0794h */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 820C0794h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 820C0794h case    0:*/		return 0x820C0798;
		  /* 820C0798h */ case    1:  		/* bc 12, CR6_EQ, 408 */
		/* 820C0798h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C0930;  }
		/* 820C0798h case    1:*/		return 0x820C079C;
		  /* 820C079Ch */ case    2:  		/* lwz R10, <#[R23 + 20]> */
		/* 820C079Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000014) );
		/* 820C079Ch case    2:*/		return 0x820C07A0;
		  /* 820C07A0h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 820C07A0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C07A0h case    3:*/		return 0x820C07A4;
		  /* 820C07A4h */ case    4:  		/* bc 12, CR6_EQ, 496 */
		/* 820C07A4h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C0994;  }
		/* 820C07A4h case    4:*/		return 0x820C07A8;
		  /* 820C07A8h */ case    5:  		/* lwz R11, <#[R31 + 84]> */
		/* 820C07A8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820C07A8h case    5:*/		return 0x820C07AC;
		  /* 820C07ACh */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 820C07ACh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C07ACh case    6:*/		return 0x820C07B0;
		  /* 820C07B0h */ case    7:  		/* bc 12, CR6_EQ, 56 */
		/* 820C07B0h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C07E8;  }
		/* 820C07B0h case    7:*/		return 0x820C07B4;
		  /* 820C07B4h */ case    8:  		/* mr R11, R16 */
		/* 820C07B4h case    8:*/		regs.R11 = regs.R16;
		/* 820C07B4h case    8:*/		return 0x820C07B8;
		  /* 820C07B8h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 820C07B8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C07B8h case    9:*/		return 0x820C07BC;
		  /* 820C07BCh */ case   10:  		/* bc 12, CR6_EQ, 44 */
		/* 820C07BCh case   10:*/		if ( regs.CR[6].eq ) { return 0x820C07E8;  }
		/* 820C07BCh case   10:*/		return 0x820C07C0;
		  /* 820C07C0h */ case   11:  		/* lwz R10, <#[R23 + 16]> */
		/* 820C07C0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000010) );
		/* 820C07C0h case   11:*/		return 0x820C07C4;
		  /* 820C07C4h */ case   12:  		/* lwz R9, <#[R31 + 24]> */
		/* 820C07C4h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 820C07C4h case   12:*/		return 0x820C07C8;
		  /* 820C07C8h */ case   13:  		/* add R10, R10, R11 */
		/* 820C07C8h case   13:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C07C8h case   13:*/		return 0x820C07CC;
		  /* 820C07CCh */ case   14:  		/* lwz R8, <#[R31 + 36]> */
		/* 820C07CCh case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000024) );
		/* 820C07CCh case   14:*/		return 0x820C07D0;
		  /* 820C07D0h */ case   15:  		/* addi R11, R11, 1 */
		/* 820C07D0h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C07D0h case   15:*/		return 0x820C07D4;
		  /* 820C07D4h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C07D4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C07D4h case   16:*/		return 0x820C07D8;
		  /* 820C07D8h */ case   17:  		/* stwx R8, <#[R10 + R9]> */
		/* 820C07D8h case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820C07D8h case   17:*/		return 0x820C07DC;
		  /* 820C07DCh */ case   18:  		/* lwz R10, <#[R23 + 20]> */
		/* 820C07DCh case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000014) );
		/* 820C07DCh case   18:*/		return 0x820C07E0;
		  /* 820C07E0h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820C07E0h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C07E0h case   19:*/		return 0x820C07E4;
		  /* 820C07E4h */ case   20:  		/* bc 12, CR6_LT, -36 */
		/* 820C07E4h case   20:*/		if ( regs.CR[6].lt ) { return 0x820C07C0;  }
		/* 820C07E4h case   20:*/		return 0x820C07E8;
	}
	return 0x820C07E8;
} // Block from 820C0794h-820C07E8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C07E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C07E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C07E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C07E8);
		  /* 820C07E8h */ case    0:  		/* lwz R11, <#[R23 + 16]> */
		/* 820C07E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 820C07E8h case    0:*/		return 0x820C07EC;
		  /* 820C07ECh */ case    1:  		/* li R9, 0 */
		/* 820C07ECh case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C07ECh case    1:*/		return 0x820C07F0;
		  /* 820C07F0h */ case    2:  		/* lwz R10, <#[R31 + 24]> */
		/* 820C07F0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820C07F0h case    2:*/		return 0x820C07F4;
		  /* 820C07F4h */ case    3:  		/* li R8, 0 */
		/* 820C07F4h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C07F4h case    3:*/		return 0x820C07F8;
		  /* 820C07F8h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C07F8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C07F8h case    4:*/		return 0x820C07FC;
		  /* 820C07FCh */ case    5:  		/* lwz R5, <#[R23 + 20]> */
		/* 820C07FCh case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R23 + 0x00000014) );
		/* 820C07FCh case    5:*/		return 0x820C0800;
		  /* 820C0800h */ case    6:  		/* mr R4, R23 */
		/* 820C0800h case    6:*/		regs.R4 = regs.R23;
		/* 820C0800h case    6:*/		return 0x820C0804;
		  /* 820C0804h */ case    7:  		/* add R7, R11, R10 */
		/* 820C0804h case    7:*/		cpu::op::add<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 820C0804h case    7:*/		return 0x820C0808;
		  /* 820C0808h */ case    8:  		/* rlwimi R5, R17, 28, 0, 11 */
		/* 820C0808h case    8:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R5,regs.R17);
		/* 820C0808h case    8:*/		return 0x820C080C;
		  /* 820C080Ch */ case    9:  		/* mr R3, R31 */
		/* 820C080Ch case    9:*/		regs.R3 = regs.R31;
		/* 820C080Ch case    9:*/		return 0x820C0810;
		  /* 820C0810h */ case   10:  		/* mr R6, R7 */
		/* 820C0810h case   10:*/		regs.R6 = regs.R7;
		/* 820C0810h case   10:*/		return 0x820C0814;
		  /* 820C0814h */ case   11:  		/* bl -64780 */
		/* 820C0814h case   11:*/		regs.LR = 0x820C0818; return 0x820B0B08;
		/* 820C0814h case   11:*/		return 0x820C0818;
		  /* 820C0818h */ case   12:  		/* or. R29, R3, R3 */
		/* 820C0818h case   12:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C0818h case   12:*/		return 0x820C081C;
		  /* 820C081Ch */ case   13:  		/* bc 12, CR0_LT, 1224 */
		/* 820C081Ch case   13:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C081Ch case   13:*/		return 0x820C0820;
		  /* 820C0820h */ case   14:  		/* lwz R11, <#[R23 + 16]> */
		/* 820C0820h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 820C0820h case   14:*/		return 0x820C0824;
		  /* 820C0824h */ case   15:  		/* mr R3, R31 */
		/* 820C0824h case   15:*/		regs.R3 = regs.R31;
		/* 820C0824h case   15:*/		return 0x820C0828;
		  /* 820C0828h */ case   16:  		/* lwz R10, <#[R31 + 24]> */
		/* 820C0828h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0828h case   16:*/		return 0x820C082C;
		  /* 820C082Ch */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C082Ch case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C082Ch case   17:*/		return 0x820C0830;
		  /* 820C0830h */ case   18:  		/* lwz R6, <#[R23 + 20]> */
		/* 820C0830h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R23 + 0x00000014) );
		/* 820C0830h case   18:*/		return 0x820C0834;
		  /* 820C0834h */ case   19:  		/* lwz R4, <#[R23 + 40]> */
		/* 820C0834h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000028) );
		/* 820C0834h case   19:*/		return 0x820C0838;
		  /* 820C0838h */ case   20:  		/* add R5, R11, R10 */
		/* 820C0838h case   20:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R10);
		/* 820C0838h case   20:*/		return 0x820C083C;
		  /* 820C083Ch */ case   21:  		/* bl -50020 */
		/* 820C083Ch case   21:*/		regs.LR = 0x820C0840; return 0x820B44D8;
		/* 820C083Ch case   21:*/		return 0x820C0840;
		  /* 820C0840h */ case   22:  		/* or. R29, R3, R3 */
		/* 820C0840h case   22:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C0840h case   22:*/		return 0x820C0844;
		  /* 820C0844h */ case   23:  		/* bc 12, CR0_LT, 1184 */
		/* 820C0844h case   23:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C0844h case   23:*/		return 0x820C0848;
		  /* 820C0848h */ case   24:  		/* lwz R11, <#[R23 + 16]> */
		/* 820C0848h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 820C0848h case   24:*/		return 0x820C084C;
		  /* 820C084Ch */ case   25:  		/* li R10, 0 */
		/* 820C084Ch case   25:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C084Ch case   25:*/		return 0x820C0850;
		  /* 820C0850h */ case   26:  		/* lwz R30, <#[R31 + 8]> */
		/* 820C0850h case   26:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0850h case   26:*/		return 0x820C0854;
		  /* 820C0854h */ case   27:  		/* li R8, 1 */
		/* 820C0854h case   27:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820C0854h case   27:*/		return 0x820C0858;
		  /* 820C0858h */ case   28:  		/* lwz R6, <#[R31 + 24]> */
		/* 820C0858h case   28:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0858h case   28:*/		return 0x820C085C;
		  /* 820C085Ch */ case   29:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C085Ch case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C085Ch case   29:*/		return 0x820C0860;
		  /* 820C0860h */ case   30:  		/* li R7, 0 */
		/* 820C0860h case   30:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C0860h case   30:*/		return 0x820C0864;
		  /* 820C0864h */ case   31:  		/* lwz R9, <#[R23 + 56]> */
		/* 820C0864h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000038) );
		/* 820C0864h case   31:*/		return 0x820C0868;
		  /* 820C0868h */ case   32:  		/* add R5, R11, R6 */
		/* 820C0868h case   32:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R6);
		/* 820C0868h case   32:*/		return 0x820C086C;
		  /* 820C086Ch */ case   33:  		/* lwz R4, <#[R23 + 40]> */
		/* 820C086Ch case   33:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R23 + 0x00000028) );
		/* 820C086Ch case   33:*/		return 0x820C0870;
		  /* 820C0870h */ case   34:  		/* mr R3, R31 */
		/* 820C0870h case   34:*/		regs.R3 = regs.R31;
		/* 820C0870h case   34:*/		return 0x820C0874;
		  /* 820C0874h */ case   35:  		/* lwz R6, <#[R30 + 132]> */
		/* 820C0874h case   35:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000084) );
		/* 820C0874h case   35:*/		return 0x820C0878;
		  /* 820C0878h */ case   36:  		/* bl -49128 */
		/* 820C0878h case   36:*/		regs.LR = 0x820C087C; return 0x820B4890;
		/* 820C0878h case   36:*/		return 0x820C087C;
		  /* 820C087Ch */ case   37:  		/* or. R29, R3, R3 */
		/* 820C087Ch case   37:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C087Ch case   37:*/		return 0x820C0880;
		  /* 820C0880h */ case   38:  		/* bc 12, CR0_LT, 1124 */
		/* 820C0880h case   38:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C0880h case   38:*/		return 0x820C0884;
		  /* 820C0884h */ case   39:  		/* lwz R11, <#[R23 + 16]> */
		/* 820C0884h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 820C0884h case   39:*/		return 0x820C0888;
		  /* 820C0888h */ case   40:  		/* mr R3, R31 */
		/* 820C0888h case   40:*/		regs.R3 = regs.R31;
		/* 820C0888h case   40:*/		return 0x820C088C;
		  /* 820C088Ch */ case   41:  		/* lwz R10, <#[R31 + 24]> */
		/* 820C088Ch case   41:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820C088Ch case   41:*/		return 0x820C0890;
		  /* 820C0890h */ case   42:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0890h case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0890h case   42:*/		return 0x820C0894;
		  /* 820C0894h */ case   43:  		/* lwz R5, <#[R23 + 20]> */
		/* 820C0894h case   43:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R23 + 0x00000014) );
		/* 820C0894h case   43:*/		return 0x820C0898;
		  /* 820C0898h */ case   44:  		/* add R4, R11, R10 */
		/* 820C0898h case   44:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 820C0898h case   44:*/		return 0x820C089C;
		  /* 820C089Ch */ case   45:  		/* bl -68980 */
		/* 820C089Ch case   45:*/		regs.LR = 0x820C08A0; return 0x820AFB28;
		/* 820C089Ch case   45:*/		return 0x820C08A0;
		  /* 820C08A0h */ case   46:  		/* cmpwi CR0, R3, 0 */
		/* 820C08A0h case   46:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C08A0h case   46:*/		return 0x820C08A4;
		  /* 820C08A4h */ case   47:  		/* bc 12, CR0_EQ, 108 */
		/* 820C08A4h case   47:*/		if ( regs.CR[0].eq ) { return 0x820C0910;  }
		/* 820C08A4h case   47:*/		return 0x820C08A8;
		  /* 820C08A8h */ case   48:  		/* mr R30, R16 */
		/* 820C08A8h case   48:*/		regs.R30 = regs.R16;
		/* 820C08A8h case   48:*/		return 0x820C08AC;
		  /* 820C08ACh */ case   49:  		/* cmplwi CR6, R5, 0 */
		/* 820C08ACh case   49:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820C08ACh case   49:*/		return 0x820C08B0;
		  /* 820C08B0h */ case   50:  		/* bc 12, CR6_EQ, 228 */
		/* 820C08B0h case   50:*/		if ( regs.CR[6].eq ) { return 0x820C0994;  }
		/* 820C08B0h case   50:*/		return 0x820C08B4;
		  /* 820C08B4h */ case   51:  		/* lwz R11, <#[R23 + 16]> */
		/* 820C08B4h case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 820C08B4h case   51:*/		return 0x820C08B8;
		  /* 820C08B8h */ case   52:  		/* li R5, 1 */
		/* 820C08B8h case   52:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820C08B8h case   52:*/		return 0x820C08BC;
		  /* 820C08BCh */ case   53:  		/* lwz R3, <#[R31 + 8]> */
		/* 820C08BCh case   53:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820C08BCh case   53:*/		return 0x820C08C0;
		  /* 820C08C0h */ case   54:  		/* add R11, R11, R30 */
		/* 820C08C0h case   54:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820C08C0h case   54:*/		return 0x820C08C4;
		  /* 820C08C4h */ case   55:  		/* lwz R10, <#[R31 + 24]> */
		/* 820C08C4h case   55:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820C08C4h case   55:*/		return 0x820C08C8;
		  /* 820C08C8h */ case   56:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C08C8h case   56:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C08C8h case   56:*/		return 0x820C08CC;
		  /* 820C08CCh */ case   57:  		/* lwz R9, <#[R3]> */
		/* 820C08CCh case   57:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 820C08CCh case   57:*/		return 0x820C08D0;
		  /* 820C08D0h */ case   58:  		/* lwz R8, <#[R3 + 20]> */
		/* 820C08D0h case   58:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 820C08D0h case   58:*/		return 0x820C08D4;
		  /* 820C08D4h */ case   59:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820C08D4h case   59:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C08D4h case   59:*/		return 0x820C08D8;
		  /* 820C08D8h */ case   60:  		/* lwz R10, <#[R9 + 4]> */
		/* 820C08D8h case   60:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 820C08D8h case   60:*/		return 0x820C08DC;
		  /* 820C08DCh */ case   61:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C08DCh case   61:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C08DCh case   61:*/		return 0x820C08E0;
		  /* 820C08E0h */ case   62:  		/* lwzx R4, <#[R11 + R8]> */
		/* 820C08E0h case   62:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820C08E0h case   62:*/		return 0x820C08E4;
		  /* 820C08E4h */ case   63:  		/* mtspr CTR, R10 */
		/* 820C08E4h case   63:*/		regs.CTR = regs.R10;
		/* 820C08E4h case   63:*/		return 0x820C08E8;
		  /* 820C08E8h */ case   64:  		/* bcctrl 20, CR0_LT */
		/* 820C08E8h case   64:*/		if ( 1 ) { regs.LR = 0x820C08EC; return (uint32)regs.CTR; }
		/* 820C08E8h case   64:*/		return 0x820C08EC;
		  /* 820C08ECh */ case   65:  		/* cmpwi CR0, R3, 0 */
		/* 820C08ECh case   65:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C08ECh case   65:*/		return 0x820C08F0;
		  /* 820C08F0h */ case   66:  		/* bc 12, CR0_LT, 24 */
		/* 820C08F0h case   66:*/		if ( regs.CR[0].lt ) { return 0x820C0908;  }
		/* 820C08F0h case   66:*/		return 0x820C08F4;
		  /* 820C08F4h */ case   67:  		/* lwz R11, <#[R23 + 20]> */
		/* 820C08F4h case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000014) );
		/* 820C08F4h case   67:*/		return 0x820C08F8;
		  /* 820C08F8h */ case   68:  		/* addi R30, R30, 1 */
		/* 820C08F8h case   68:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820C08F8h case   68:*/		return 0x820C08FC;
		  /* 820C08FCh */ case   69:  		/* cmplw CR6, R30, R11 */
		/* 820C08FCh case   69:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820C08FCh case   69:*/		return 0x820C0900;
		  /* 820C0900h */ case   70:  		/* bc 12, CR6_LT, -76 */
		/* 820C0900h case   70:*/		if ( regs.CR[6].lt ) { return 0x820C08B4;  }
		/* 820C0900h case   70:*/		return 0x820C0904;
		  /* 820C0904h */ case   71:  		/* b 144 */
		/* 820C0904h case   71:*/		return 0x820C0994;
		/* 820C0904h case   71:*/		return 0x820C0908;
	}
	return 0x820C0908;
} // Block from 820C07E8h-820C0908h (72 instructions)

//////////////////////////////////////////////////////
// Block at 820C0908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0908);
		  /* 820C0908h */ case    0:  		/* stw R17, <#[R31 + 76]> */
		/* 820C0908h case    0:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R31 + 0x0000004C) );
		/* 820C0908h case    0:*/		return 0x820C090C;
		  /* 820C090Ch */ case    1:  		/* b 136 */
		/* 820C090Ch case    1:*/		return 0x820C0994;
		/* 820C090Ch case    1:*/		return 0x820C0910;
	}
	return 0x820C0910;
} // Block from 820C0908h-820C0910h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C0910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0910);
		  /* 820C0910h */ case    0:  		/* lis R11, -32255 */
		/* 820C0910h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C0910h case    0:*/		return 0x820C0914;
		  /* 820C0914h */ case    1:  		/* lwz R7, <#[R1 + 348]> */
		/* 820C0914h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000015C) );
		/* 820C0914h case    1:*/		return 0x820C0918;
		  /* 820C0918h */ case    2:  		/* li R5, 3503 */
		/* 820C0918h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0xDAF);
		/* 820C0918h case    2:*/		return 0x820C091C;
		  /* 820C091Ch */ case    3:  		/* addi R6, R11, 9364 */
		/* 820C091Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2494);
		/* 820C091Ch case    3:*/		return 0x820C0920;
		  /* 820C0920h */ case    4:  		/* mr R4, R23 */
		/* 820C0920h case    4:*/		regs.R4 = regs.R23;
		/* 820C0920h case    4:*/		return 0x820C0924;
		  /* 820C0924h */ case    5:  		/* mr R3, R31 */
		/* 820C0924h case    5:*/		regs.R3 = regs.R31;
		/* 820C0924h case    5:*/		return 0x820C0928;
		  /* 820C0928h */ case    6:  		/* bl -65336 */
		/* 820C0928h case    6:*/		regs.LR = 0x820C092C; return 0x820B09F0;
		/* 820C0928h case    6:*/		return 0x820C092C;
		  /* 820C092Ch */ case    7:  		/* b 104 */
		/* 820C092Ch case    7:*/		return 0x820C0994;
		/* 820C092Ch case    7:*/		return 0x820C0930;
	}
	return 0x820C0930;
} // Block from 820C0910h-820C0930h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C0930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0930);
		  /* 820C0930h */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 820C0930h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 820C0930h case    0:*/		return 0x820C0934;
		  /* 820C0934h */ case    1:  		/* bc 12, CR6_EQ, 96 */
		/* 820C0934h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C0994;  }
		/* 820C0934h case    1:*/		return 0x820C0938;
		  /* 820C0938h */ case    2:  		/* lwz R11, <#[R31 + 84]> */
		/* 820C0938h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820C0938h case    2:*/		return 0x820C093C;
		  /* 820C093Ch */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820C093Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C093Ch case    3:*/		return 0x820C0940;
		  /* 820C0940h */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 820C0940h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C0974;  }
		/* 820C0940h case    4:*/		return 0x820C0944;
		  /* 820C0944h */ case    5:  		/* lwz R10, <#[R23 + 20]> */
		/* 820C0944h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000014) );
		/* 820C0944h case    5:*/		return 0x820C0948;
		  /* 820C0948h */ case    6:  		/* mr R11, R16 */
		/* 820C0948h case    6:*/		regs.R11 = regs.R16;
		/* 820C0948h case    6:*/		return 0x820C094C;
		  /* 820C094Ch */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 820C094Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C094Ch case    7:*/		return 0x820C0950;
		  /* 820C0950h */ case    8:  		/* bc 4, CR6_GT, 68 */
		/* 820C0950h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820C0994;  }
		/* 820C0950h case    8:*/		return 0x820C0954;
		  /* 820C0954h */ case    9:  		/* addi R10, R18, -4 */
		/* 820C0954h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R18,0xFFFFFFFC);
		/* 820C0954h case    9:*/		return 0x820C0958;
		  /* 820C0958h */ case   10:  		/* lwz R9, <#[R31 + 36]> */
		/* 820C0958h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000024) );
		/* 820C0958h case   10:*/		return 0x820C095C;
		  /* 820C095Ch */ case   11:  		/* addi R11, R11, 1 */
		/* 820C095Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C095Ch case   11:*/		return 0x820C0960;
		  /* 820C0960h */ case   12:  		/* stwu R9, <#[R10 + 4]> */
		/* 820C0960h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C0960h case   12:*/		return 0x820C0964;
		  /* 820C0964h */ case   13:  		/* lwz R9, <#[R23 + 20]> */
		/* 820C0964h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 820C0964h case   13:*/		return 0x820C0968;
		  /* 820C0968h */ case   14:  		/* cmplw CR6, R11, R9 */
		/* 820C0968h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820C0968h case   14:*/		return 0x820C096C;
		  /* 820C096Ch */ case   15:  		/* bc 12, CR6_LT, -20 */
		/* 820C096Ch case   15:*/		if ( regs.CR[6].lt ) { return 0x820C0958;  }
		/* 820C096Ch case   15:*/		return 0x820C0970;
		  /* 820C0970h */ case   16:  		/* b 36 */
		/* 820C0970h case   16:*/		return 0x820C0994;
		/* 820C0970h case   16:*/		return 0x820C0974;
	}
	return 0x820C0974;
} // Block from 820C0930h-820C0974h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C0974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0974);
		  /* 820C0974h */ case    0:  		/* lwz R11, <#[R23 + 16]> */
		/* 820C0974h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000010) );
		/* 820C0974h case    0:*/		return 0x820C0978;
		  /* 820C0978h */ case    1:  		/* mr R3, R18 */
		/* 820C0978h case    1:*/		regs.R3 = regs.R18;
		/* 820C0978h case    1:*/		return 0x820C097C;
		  /* 820C097Ch */ case    2:  		/* lwz R9, <#[R23 + 20]> */
		/* 820C097Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000014) );
		/* 820C097Ch case    2:*/		return 0x820C0980;
		  /* 820C0980h */ case    3:  		/* lwz R10, <#[R31 + 24]> */
		/* 820C0980h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0980h case    3:*/		return 0x820C0984;
		  /* 820C0984h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0984h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0984h case    4:*/		return 0x820C0988;
		  /* 820C0988h */ case    5:  		/* rlwinm R5, R9, 2, 0, 29 */
		/* 820C0988h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R9);
		/* 820C0988h case    5:*/		return 0x820C098C;
		  /* 820C098Ch */ case    6:  		/* add R4, R11, R10 */
		/* 820C098Ch case    6:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 820C098Ch case    6:*/		return 0x820C0990;
		  /* 820C0990h */ case    7:  		/* bl -192480 */
		/* 820C0990h case    7:*/		regs.LR = 0x820C0994; return 0x820919B0;
		/* 820C0990h case    7:*/		return 0x820C0994;
	}
	return 0x820C0994;
} // Block from 820C0974h-820C0994h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C0994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0994);
		  /* 820C0994h */ case    0:  		/* lwz R24, <#[R23 + 44]> */
		/* 820C0994h case    0:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R23 + 0x0000002C) );
		/* 820C0994h case    0:*/		return 0x820C0998;
		  /* 820C0998h */ case    1:  		/* mr R23, R27 */
		/* 820C0998h case    1:*/		regs.R23 = regs.R27;
		/* 820C0998h case    1:*/		return 0x820C099C;
		  /* 820C099Ch */ case    2:  		/* cmplwi CR6, R24, 0 */
		/* 820C099Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820C099Ch case    2:*/		return 0x820C09A0;
		  /* 820C09A0h */ case    3:  		/* bc 12, CR6_EQ, 832 */
		/* 820C09A0h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C0CE0;  }
		/* 820C09A0h case    3:*/		return 0x820C09A4;
		  /* 820C09A4h */ case    4:  		/* lis R10, -32255 */
		/* 820C09A4h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C09A4h case    4:*/		return 0x820C09A8;
		  /* 820C09A8h */ case    5:  		/* lis R11, -32255 */
		/* 820C09A8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C09A8h case    5:*/		return 0x820C09AC;
		  /* 820C09ACh */ case    6:  		/* addi R22, R10, 9360 */
		/* 820C09ACh case    6:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R10,0x2490);
		/* 820C09ACh case    6:*/		return 0x820C09B0;
		  /* 820C09B0h */ case    7:  		/* addi R21, R11, 9312 */
		/* 820C09B0h case    7:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R11,0x2460);
		/* 820C09B0h case    7:*/		return 0x820C09B4;
		  /* 820C09B4h */ case    8:  		/* lwz R25, <#[R24 + 8]> */
		/* 820C09B4h case    8:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R24 + 0x00000008) );
		/* 820C09B4h case    8:*/		return 0x820C09B8;
		  /* 820C09B8h */ case    9:  		/* lwz R24, <#[R24 + 12]> */
		/* 820C09B8h case    9:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R24 + 0x0000000C) );
		/* 820C09B8h case    9:*/		return 0x820C09BC;
		  /* 820C09BCh */ case   10:  		/* cmplwi CR6, R24, 0 */
		/* 820C09BCh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820C09BCh case   10:*/		return 0x820C09C0;
		  /* 820C09C0h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 820C09C0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C09E0;  }
		/* 820C09C0h case   11:*/		return 0x820C09C4;
		  /* 820C09C4h */ case   12:  		/* lwz R11, <#[R24 + 8]> */
		/* 820C09C4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 820C09C4h case   12:*/		return 0x820C09C8;
		  /* 820C09C8h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 820C09C8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C09C8h case   13:*/		return 0x820C09CC;
		  /* 820C09CCh */ case   14:  		/* bc 12, CR6_EQ, 20 */
		/* 820C09CCh case   14:*/		if ( regs.CR[6].eq ) { return 0x820C09E0;  }
		/* 820C09CCh case   14:*/		return 0x820C09D0;
		  /* 820C09D0h */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 820C09D0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820C09D0h case   15:*/		return 0x820C09D4;
		  /* 820C09D4h */ case   16:  		/* cmpwi CR6, R11, 12 */
		/* 820C09D4h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000C);
		/* 820C09D4h case   16:*/		return 0x820C09D8;
		  /* 820C09D8h */ case   17:  		/* bc 4, CR6_EQ, 8 */
		/* 820C09D8h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820C09E0;  }
		/* 820C09D8h case   17:*/		return 0x820C09DC;
		  /* 820C09DCh */ case   18:  		/* lwz R24, <#[R24 + 12]> */
		/* 820C09DCh case   18:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R24 + 0x0000000C) );
		/* 820C09DCh case   18:*/		return 0x820C09E0;
	}
	return 0x820C09E0;
} // Block from 820C0994h-820C09E0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820C09E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C09E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C09E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C09E0);
		  /* 820C09E0h */ case    0:  		/* lwz R30, <#[R25 + 24]> */
		/* 820C09E0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R25 + 0x00000018) );
		/* 820C09E0h case    0:*/		return 0x820C09E4;
		  /* 820C09E4h */ case    1:  		/* lwz R11, <#[R30 + 44]> */
		/* 820C09E4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 820C09E4h case    1:*/		return 0x820C09E8;
		  /* 820C09E8h */ case    2:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820C09E8h case    2:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820C09E8h case    2:*/		return 0x820C09EC;
		  /* 820C09ECh */ case    3:  		/* bc 12, CR0_EQ, 564 */
		/* 820C09ECh case    3:*/		if ( regs.CR[0].eq ) { return 0x820C0C20;  }
		/* 820C09ECh case    3:*/		return 0x820C09F0;
		  /* 820C09F0h */ case    4:  		/* lwz R11, <#[R31 + 84]> */
		/* 820C09F0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 820C09F0h case    4:*/		return 0x820C09F4;
		  /* 820C09F4h */ case    5:  		/* lwz R28, <#[R25 + 20]> */
		/* 820C09F4h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R25 + 0x00000014) );
		/* 820C09F4h case    5:*/		return 0x820C09F8;
		  /* 820C09F8h */ case    6:  		/* lwz R5, <#[R30 + 20]> */
		/* 820C09F8h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000014) );
		/* 820C09F8h case    6:*/		return 0x820C09FC;
		  /* 820C09FCh */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820C09FCh case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C09FCh case    7:*/		return 0x820C0A00;
		  /* 820C0A00h */ case    8:  		/* bc 12, CR6_EQ, 60 */
		/* 820C0A00h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C0A3C;  }
		/* 820C0A00h case    8:*/		return 0x820C0A04;
		  /* 820C0A04h */ case    9:  		/* mr R11, R16 */
		/* 820C0A04h case    9:*/		regs.R11 = regs.R16;
		/* 820C0A04h case    9:*/		return 0x820C0A08;
		  /* 820C0A08h */ case   10:  		/* cmplwi CR6, R5, 0 */
		/* 820C0A08h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820C0A08h case   10:*/		return 0x820C0A0C;
		  /* 820C0A0Ch */ case   11:  		/* bc 12, CR6_EQ, 152 */
		/* 820C0A0Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820C0AA4;  }
		/* 820C0A0Ch case   11:*/		return 0x820C0A10;
		  /* 820C0A10h */ case   12:  		/* lwz R10, <#[R30 + 16]> */
		/* 820C0A10h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 820C0A10h case   12:*/		return 0x820C0A14;
		  /* 820C0A14h */ case   13:  		/* lwz R9, <#[R31 + 24]> */
		/* 820C0A14h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0A14h case   13:*/		return 0x820C0A18;
		  /* 820C0A18h */ case   14:  		/* add R10, R11, R10 */
		/* 820C0A18h case   14:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820C0A18h case   14:*/		return 0x820C0A1C;
		  /* 820C0A1Ch */ case   15:  		/* lwz R8, <#[R31 + 36]> */
		/* 820C0A1Ch case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000024) );
		/* 820C0A1Ch case   15:*/		return 0x820C0A20;
		  /* 820C0A20h */ case   16:  		/* addi R11, R11, 1 */
		/* 820C0A20h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C0A20h case   16:*/		return 0x820C0A24;
		  /* 820C0A24h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C0A24h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C0A24h case   17:*/		return 0x820C0A28;
		  /* 820C0A28h */ case   18:  		/* stwx R8, <#[R10 + R9]> */
		/* 820C0A28h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820C0A28h case   18:*/		return 0x820C0A2C;
		  /* 820C0A2Ch */ case   19:  		/* lwz R5, <#[R30 + 20]> */
		/* 820C0A2Ch case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000014) );
		/* 820C0A2Ch case   19:*/		return 0x820C0A30;
		  /* 820C0A30h */ case   20:  		/* cmplw CR6, R11, R5 */
		/* 820C0A30h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 820C0A30h case   20:*/		return 0x820C0A34;
		  /* 820C0A34h */ case   21:  		/* bc 12, CR6_LT, -36 */
		/* 820C0A34h case   21:*/		if ( regs.CR[6].lt ) { return 0x820C0A10;  }
		/* 820C0A34h case   21:*/		return 0x820C0A38;
		  /* 820C0A38h */ case   22:  		/* b 108 */
		/* 820C0A38h case   22:*/		return 0x820C0AA4;
		/* 820C0A38h case   22:*/		return 0x820C0A3C;
	}
	return 0x820C0A3C;
} // Block from 820C09E0h-820C0A3Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 820C0A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0A3C);
		  /* 820C0A3Ch */ case    0:  		/* mr R9, R16 */
		/* 820C0A3Ch case    0:*/		regs.R9 = regs.R16;
		/* 820C0A3Ch case    0:*/		return 0x820C0A40;
	}
	return 0x820C0A40;
} // Block from 820C0A3Ch-820C0A40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C0A40h
// Function '?EmitFunction@CCompiler@D3DXShader@@IAAJPBDPAVCNode@2@1PAIHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0A40);
		  /* 820C0A40h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820C0A40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820C0A40h case    0:*/		return 0x820C0A44;
		  /* 820C0A44h */ case    1:  		/* bc 12, CR6_EQ, 96 */
		/* 820C0A44h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C0AA4;  }
		/* 820C0A44h case    1:*/		return 0x820C0A48;
		  /* 820C0A48h */ case    2:  		/* lwz R8, <#[R30 + 16]> */
		/* 820C0A48h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000010) );
		/* 820C0A48h case    2:*/		return 0x820C0A4C;
		  /* 820C0A4Ch */ case    3:  		/* lwz R7, <#[R31 + 24]> */
		/* 820C0A4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0A4Ch case    3:*/		return 0x820C0A50;
		  /* 820C0A50h */ case    4:  		/* lwz R10, <#[R31 + 8]> */
		/* 820C0A50h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0A50h case    4:*/		return 0x820C0A54;
		  /* 820C0A54h */ case    5:  		/* add R11, R8, R9 */
		/* 820C0A54h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R9);
		/* 820C0A54h case    5:*/		return 0x820C0A58;
		  /* 820C0A58h */ case    6:  		/* lwz R6, <#[R10 + 8]> */
		/* 820C0A58h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000008) );
		/* 820C0A58h case    6:*/		return 0x820C0A5C;
		  /* 820C0A5Ch */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0A5Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0A5Ch case    7:*/		return 0x820C0A60;
		  /* 820C0A60h */ case    8:  		/* lwzx R11, <#[R11 + R7]> */
		/* 820C0A60h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 820C0A60h case    8:*/		return 0x820C0A64;
		  /* 820C0A64h */ case    9:  		/* cmplw CR6, R11, R6 */
		/* 820C0A64h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 820C0A64h case    9:*/		return 0x820C0A68;
		  /* 820C0A68h */ case   10:  		/* bc 4, CR6_LT, 20 */
		/* 820C0A68h case   10:*/		if ( !regs.CR[6].lt ) { return 0x820C0A7C;  }
		/* 820C0A68h case   10:*/		return 0x820C0A6C;
		  /* 820C0A6Ch */ case   11:  		/* lwz R6, <#[R10 + 20]> */
		/* 820C0A6Ch case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000014) );
		/* 820C0A6Ch case   11:*/		return 0x820C0A70;
		  /* 820C0A70h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0A70h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0A70h case   12:*/		return 0x820C0A74;
		  /* 820C0A74h */ case   13:  		/* lwzx R11, <#[R6 + R11]> */
		/* 820C0A74h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820C0A74h case   13:*/		return 0x820C0A78;
		  /* 820C0A78h */ case   14:  		/* b 8 */
		/* 820C0A78h case   14:*/		return 0x820C0A80;
		/* 820C0A78h case   14:*/		return 0x820C0A7C;
	}
	return 0x820C0A7C;
} // Block from 820C0A40h-820C0A7Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C0A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0A7C);
		  /* 820C0A7Ch */ case    0:  		/* mr R11, R16 */
		/* 820C0A7Ch case    0:*/		regs.R11 = regs.R16;
		/* 820C0A7Ch case    0:*/		return 0x820C0A80;
	}
	return 0x820C0A80;
} // Block from 820C0A7Ch-820C0A80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C0A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0A80);
		  /* 820C0A80h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C0A80h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C0A80h case    0:*/		return 0x820C0A84;
		  /* 820C0A84h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820C0A84h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C0A98;  }
		/* 820C0A84h case    1:*/		return 0x820C0A88;
		  /* 820C0A88h */ case    2:  		/* lwz R6, <#[R10 + 116]> */
		/* 820C0A88h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000074) );
		/* 820C0A88h case    2:*/		return 0x820C0A8C;
		  /* 820C0A8Ch */ case    3:  		/* lwz R4, <#[R11 + 4]> */
		/* 820C0A8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 820C0A8Ch case    3:*/		return 0x820C0A90;
		  /* 820C0A90h */ case    4:  		/* cmplw CR6, R6, R4 */
		/* 820C0A90h case    4:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R4);
		/* 820C0A90h case    4:*/		return 0x820C0A94;
		  /* 820C0A94h */ case    5:  		/* bc 12, CR6_EQ, 660 */
		/* 820C0A94h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C0D28;  }
		/* 820C0A94h case    5:*/		return 0x820C0A98;
	}
	return 0x820C0A98;
} // Block from 820C0A80h-820C0A98h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C0A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0A98);
		  /* 820C0A98h */ case    0:  		/* addi R9, R9, 1 */
		/* 820C0A98h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C0A98h case    0:*/		return 0x820C0A9C;
		  /* 820C0A9Ch */ case    1:  		/* cmplw CR6, R9, R5 */
		/* 820C0A9Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 820C0A9Ch case    1:*/		return 0x820C0AA0;
		  /* 820C0AA0h */ case    2:  		/* bc 12, CR6_LT, -76 */
		/* 820C0AA0h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C0A54;  }
		/* 820C0AA0h case    2:*/		return 0x820C0AA4;
	}
	return 0x820C0AA4;
} // Block from 820C0A98h-820C0AA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C0AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0AA4);
		  /* 820C0AA4h */ case    0:  		/* lwz R11, <#[R1 + 380]> */
		/* 820C0AA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000017C) );
		/* 820C0AA4h case    0:*/		return 0x820C0AA8;
		  /* 820C0AA8h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820C0AA8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C0AA8h case    1:*/		return 0x820C0AAC;
		  /* 820C0AACh */ case    2:  		/* bc 12, CR6_EQ, 328 */
		/* 820C0AACh case    2:*/		if ( regs.CR[6].eq ) { return 0x820C0BF4;  }
		/* 820C0AACh case    2:*/		return 0x820C0AB0;
		  /* 820C0AB0h */ case    3:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C0AB0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C0AB0h case    3:*/		return 0x820C0AB4;
		  /* 820C0AB4h */ case    4:  		/* li R9, 0 */
		/* 820C0AB4h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C0AB4h case    4:*/		return 0x820C0AB8;
		  /* 820C0AB8h */ case    5:  		/* lwz R10, <#[R31 + 24]> */
		/* 820C0AB8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0AB8h case    5:*/		return 0x820C0ABC;
		  /* 820C0ABCh */ case    6:  		/* rlwimi R5, R17, 28, 0, 11 */
		/* 820C0ABCh case    6:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R5,regs.R17);
		/* 820C0ABCh case    6:*/		return 0x820C0AC0;
		  /* 820C0AC0h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0AC0h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0AC0h case    7:*/		return 0x820C0AC4;
		  /* 820C0AC4h */ case    8:  		/* li R8, 0 */
		/* 820C0AC4h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C0AC4h case    8:*/		return 0x820C0AC8;
		  /* 820C0AC8h */ case    9:  		/* add R7, R11, R10 */
		/* 820C0AC8h case    9:*/		cpu::op::add<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 820C0AC8h case    9:*/		return 0x820C0ACC;
		  /* 820C0ACCh */ case   10:  		/* mr R4, R30 */
		/* 820C0ACCh case   10:*/		regs.R4 = regs.R30;
		/* 820C0ACCh case   10:*/		return 0x820C0AD0;
		  /* 820C0AD0h */ case   11:  		/* mr R6, R7 */
		/* 820C0AD0h case   11:*/		regs.R6 = regs.R7;
		/* 820C0AD0h case   11:*/		return 0x820C0AD4;
		  /* 820C0AD4h */ case   12:  		/* mr R3, R31 */
		/* 820C0AD4h case   12:*/		regs.R3 = regs.R31;
		/* 820C0AD4h case   12:*/		return 0x820C0AD8;
		  /* 820C0AD8h */ case   13:  		/* bl -65488 */
		/* 820C0AD8h case   13:*/		regs.LR = 0x820C0ADC; return 0x820B0B08;
		/* 820C0AD8h case   13:*/		return 0x820C0ADC;
		  /* 820C0ADCh */ case   14:  		/* or. R29, R3, R3 */
		/* 820C0ADCh case   14:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C0ADCh case   14:*/		return 0x820C0AE0;
		  /* 820C0AE0h */ case   15:  		/* bc 12, CR0_LT, 516 */
		/* 820C0AE0h case   15:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C0AE0h case   15:*/		return 0x820C0AE4;
		  /* 820C0AE4h */ case   16:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C0AE4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C0AE4h case   16:*/		return 0x820C0AE8;
		  /* 820C0AE8h */ case   17:  		/* mr R3, R31 */
		/* 820C0AE8h case   17:*/		regs.R3 = regs.R31;
		/* 820C0AE8h case   17:*/		return 0x820C0AEC;
		  /* 820C0AECh */ case   18:  		/* lwz R10, <#[R31 + 24]> */
		/* 820C0AECh case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0AECh case   18:*/		return 0x820C0AF0;
		  /* 820C0AF0h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0AF0h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0AF0h case   19:*/		return 0x820C0AF4;
		  /* 820C0AF4h */ case   20:  		/* lwz R6, <#[R30 + 20]> */
		/* 820C0AF4h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000014) );
		/* 820C0AF4h case   20:*/		return 0x820C0AF8;
		  /* 820C0AF8h */ case   21:  		/* lwz R4, <#[R30 + 48]> */
		/* 820C0AF8h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000030) );
		/* 820C0AF8h case   21:*/		return 0x820C0AFC;
		  /* 820C0AFCh */ case   22:  		/* add R5, R11, R10 */
		/* 820C0AFCh case   22:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R10);
		/* 820C0AFCh case   22:*/		return 0x820C0B00;
		  /* 820C0B00h */ case   23:  		/* bl -50728 */
		/* 820C0B00h case   23:*/		regs.LR = 0x820C0B04; return 0x820B44D8;
		/* 820C0B00h case   23:*/		return 0x820C0B04;
		  /* 820C0B04h */ case   24:  		/* or. R29, R3, R3 */
		/* 820C0B04h case   24:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C0B04h case   24:*/		return 0x820C0B08;
		  /* 820C0B08h */ case   25:  		/* bc 12, CR0_LT, 476 */
		/* 820C0B08h case   25:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C0B08h case   25:*/		return 0x820C0B0C;
		  /* 820C0B0Ch */ case   26:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C0B0Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C0B0Ch case   26:*/		return 0x820C0B10;
		  /* 820C0B10h */ case   27:  		/* li R10, 0 */
		/* 820C0B10h case   27:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C0B10h case   27:*/		return 0x820C0B14;
		  /* 820C0B14h */ case   28:  		/* lwz R29, <#[R31 + 8]> */
		/* 820C0B14h case   28:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0B14h case   28:*/		return 0x820C0B18;
		  /* 820C0B18h */ case   29:  		/* li R8, 1 */
		/* 820C0B18h case   29:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820C0B18h case   29:*/		return 0x820C0B1C;
		  /* 820C0B1Ch */ case   30:  		/* lwz R6, <#[R31 + 24]> */
		/* 820C0B1Ch case   30:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0B1Ch case   30:*/		return 0x820C0B20;
		  /* 820C0B20h */ case   31:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0B20h case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0B20h case   31:*/		return 0x820C0B24;
		  /* 820C0B24h */ case   32:  		/* li R7, 0 */
		/* 820C0B24h case   32:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C0B24h case   32:*/		return 0x820C0B28;
		  /* 820C0B28h */ case   33:  		/* lwz R9, <#[R30 + 60]> */
		/* 820C0B28h case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000003C) );
		/* 820C0B28h case   33:*/		return 0x820C0B2C;
		  /* 820C0B2Ch */ case   34:  		/* add R5, R11, R6 */
		/* 820C0B2Ch case   34:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R6);
		/* 820C0B2Ch case   34:*/		return 0x820C0B30;
		  /* 820C0B30h */ case   35:  		/* lwz R4, <#[R30 + 48]> */
		/* 820C0B30h case   35:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000030) );
		/* 820C0B30h case   35:*/		return 0x820C0B34;
		  /* 820C0B34h */ case   36:  		/* mr R3, R31 */
		/* 820C0B34h case   36:*/		regs.R3 = regs.R31;
		/* 820C0B34h case   36:*/		return 0x820C0B38;
		  /* 820C0B38h */ case   37:  		/* lwz R6, <#[R29 + 132]> */
		/* 820C0B38h case   37:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000084) );
		/* 820C0B38h case   37:*/		return 0x820C0B3C;
		  /* 820C0B3Ch */ case   38:  		/* bl -49836 */
		/* 820C0B3Ch case   38:*/		regs.LR = 0x820C0B40; return 0x820B4890;
		/* 820C0B3Ch case   38:*/		return 0x820C0B40;
		  /* 820C0B40h */ case   39:  		/* or. R29, R3, R3 */
		/* 820C0B40h case   39:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C0B40h case   39:*/		return 0x820C0B44;
		  /* 820C0B44h */ case   40:  		/* bc 12, CR0_LT, 416 */
		/* 820C0B44h case   40:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C0B44h case   40:*/		return 0x820C0B48;
		  /* 820C0B48h */ case   41:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C0B48h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C0B48h case   41:*/		return 0x820C0B4C;
		  /* 820C0B4Ch */ case   42:  		/* mr R3, R31 */
		/* 820C0B4Ch case   42:*/		regs.R3 = regs.R31;
		/* 820C0B4Ch case   42:*/		return 0x820C0B50;
		  /* 820C0B50h */ case   43:  		/* lwz R10, <#[R31 + 24]> */
		/* 820C0B50h case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0B50h case   43:*/		return 0x820C0B54;
		  /* 820C0B54h */ case   44:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0B54h case   44:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0B54h case   44:*/		return 0x820C0B58;
		  /* 820C0B58h */ case   45:  		/* lwz R5, <#[R30 + 20]> */
		/* 820C0B58h case   45:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000014) );
		/* 820C0B58h case   45:*/		return 0x820C0B5C;
		  /* 820C0B5Ch */ case   46:  		/* add R4, R11, R10 */
		/* 820C0B5Ch case   46:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 820C0B5Ch case   46:*/		return 0x820C0B60;
		  /* 820C0B60h */ case   47:  		/* bl -69688 */
		/* 820C0B60h case   47:*/		regs.LR = 0x820C0B64; return 0x820AFB28;
		/* 820C0B60h case   47:*/		return 0x820C0B64;
		  /* 820C0B64h */ case   48:  		/* cmpwi CR0, R3, 0 */
		/* 820C0B64h case   48:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C0B64h case   48:*/		return 0x820C0B68;
		  /* 820C0B68h */ case   49:  		/* bc 12, CR0_EQ, 108 */
		/* 820C0B68h case   49:*/		if ( regs.CR[0].eq ) { return 0x820C0BD4;  }
		/* 820C0B68h case   49:*/		return 0x820C0B6C;
		  /* 820C0B6Ch */ case   50:  		/* mr R28, R16 */
		/* 820C0B6Ch case   50:*/		regs.R28 = regs.R16;
		/* 820C0B6Ch case   50:*/		return 0x820C0B70;
		  /* 820C0B70h */ case   51:  		/* cmplwi CR6, R5, 0 */
		/* 820C0B70h case   51:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820C0B70h case   51:*/		return 0x820C0B74;
		  /* 820C0B74h */ case   52:  		/* bc 12, CR6_EQ, 172 */
		/* 820C0B74h case   52:*/		if ( regs.CR[6].eq ) { return 0x820C0C20;  }
		/* 820C0B74h case   52:*/		return 0x820C0B78;
		  /* 820C0B78h */ case   53:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C0B78h case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C0B78h case   53:*/		return 0x820C0B7C;
		  /* 820C0B7Ch */ case   54:  		/* li R5, 1 */
		/* 820C0B7Ch case   54:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820C0B7Ch case   54:*/		return 0x820C0B80;
		  /* 820C0B80h */ case   55:  		/* lwz R3, <#[R31 + 8]> */
		/* 820C0B80h case   55:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0B80h case   55:*/		return 0x820C0B84;
		  /* 820C0B84h */ case   56:  		/* add R11, R28, R11 */
		/* 820C0B84h case   56:*/		cpu::op::add<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 820C0B84h case   56:*/		return 0x820C0B88;
		  /* 820C0B88h */ case   57:  		/* lwz R10, <#[R31 + 24]> */
		/* 820C0B88h case   57:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0B88h case   57:*/		return 0x820C0B8C;
		  /* 820C0B8Ch */ case   58:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0B8Ch case   58:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0B8Ch case   58:*/		return 0x820C0B90;
		  /* 820C0B90h */ case   59:  		/* lwz R9, <#[R3]> */
		/* 820C0B90h case   59:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 820C0B90h case   59:*/		return 0x820C0B94;
		  /* 820C0B94h */ case   60:  		/* lwz R8, <#[R3 + 20]> */
		/* 820C0B94h case   60:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 820C0B94h case   60:*/		return 0x820C0B98;
		  /* 820C0B98h */ case   61:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820C0B98h case   61:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C0B98h case   61:*/		return 0x820C0B9C;
		  /* 820C0B9Ch */ case   62:  		/* lwz R10, <#[R9 + 4]> */
		/* 820C0B9Ch case   62:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 820C0B9Ch case   62:*/		return 0x820C0BA0;
		  /* 820C0BA0h */ case   63:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0BA0h case   63:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0BA0h case   63:*/		return 0x820C0BA4;
		  /* 820C0BA4h */ case   64:  		/* lwzx R4, <#[R11 + R8]> */
		/* 820C0BA4h case   64:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820C0BA4h case   64:*/		return 0x820C0BA8;
		  /* 820C0BA8h */ case   65:  		/* mtspr CTR, R10 */
		/* 820C0BA8h case   65:*/		regs.CTR = regs.R10;
		/* 820C0BA8h case   65:*/		return 0x820C0BAC;
		  /* 820C0BACh */ case   66:  		/* bcctrl 20, CR0_LT */
		/* 820C0BACh case   66:*/		if ( 1 ) { regs.LR = 0x820C0BB0; return (uint32)regs.CTR; }
		/* 820C0BACh case   66:*/		return 0x820C0BB0;
		  /* 820C0BB0h */ case   67:  		/* cmpwi CR0, R3, 0 */
		/* 820C0BB0h case   67:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C0BB0h case   67:*/		return 0x820C0BB4;
		  /* 820C0BB4h */ case   68:  		/* bc 12, CR0_LT, 24 */
		/* 820C0BB4h case   68:*/		if ( regs.CR[0].lt ) { return 0x820C0BCC;  }
		/* 820C0BB4h case   68:*/		return 0x820C0BB8;
		  /* 820C0BB8h */ case   69:  		/* lwz R11, <#[R30 + 20]> */
		/* 820C0BB8h case   69:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C0BB8h case   69:*/		return 0x820C0BBC;
		  /* 820C0BBCh */ case   70:  		/* addi R28, R28, 1 */
		/* 820C0BBCh case   70:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820C0BBCh case   70:*/		return 0x820C0BC0;
		  /* 820C0BC0h */ case   71:  		/* cmplw CR6, R28, R11 */
		/* 820C0BC0h case   71:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820C0BC0h case   71:*/		return 0x820C0BC4;
		  /* 820C0BC4h */ case   72:  		/* bc 12, CR6_LT, -76 */
		/* 820C0BC4h case   72:*/		if ( regs.CR[6].lt ) { return 0x820C0B78;  }
		/* 820C0BC4h case   72:*/		return 0x820C0BC8;
		  /* 820C0BC8h */ case   73:  		/* b 88 */
		/* 820C0BC8h case   73:*/		return 0x820C0C20;
		/* 820C0BC8h case   73:*/		return 0x820C0BCC;
	}
	return 0x820C0BCC;
} // Block from 820C0AA4h-820C0BCCh (74 instructions)

//////////////////////////////////////////////////////
// Block at 820C0BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0BCC);
		  /* 820C0BCCh */ case    0:  		/* stw R17, <#[R31 + 76]> */
		/* 820C0BCCh case    0:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R31 + 0x0000004C) );
		/* 820C0BCCh case    0:*/		return 0x820C0BD0;
		  /* 820C0BD0h */ case    1:  		/* b 80 */
		/* 820C0BD0h case    1:*/		return 0x820C0C20;
		/* 820C0BD0h case    1:*/		return 0x820C0BD4;
	}
	return 0x820C0BD4;
} // Block from 820C0BCCh-820C0BD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C0BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0BD4);
		  /* 820C0BD4h */ case    0:  		/* mr R6, R21 */
		/* 820C0BD4h case    0:*/		regs.R6 = regs.R21;
		/* 820C0BD4h case    0:*/		return 0x820C0BD8;
		  /* 820C0BD8h */ case    1:  		/* lwz R8, <#[R28 + 24]> */
		/* 820C0BD8h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000018) );
		/* 820C0BD8h case    1:*/		return 0x820C0BDC;
		  /* 820C0BDCh */ case    2:  		/* li R5, 3503 */
		/* 820C0BDCh case    2:*/		cpu::op::li<0>(regs,&regs.R5,0xDAF);
		/* 820C0BDCh case    2:*/		return 0x820C0BE0;
		  /* 820C0BE0h */ case    3:  		/* lwz R7, <#[R1 + 348]> */
		/* 820C0BE0h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000015C) );
		/* 820C0BE0h case    3:*/		return 0x820C0BE4;
		  /* 820C0BE4h */ case    4:  		/* mr R4, R30 */
		/* 820C0BE4h case    4:*/		regs.R4 = regs.R30;
		/* 820C0BE4h case    4:*/		return 0x820C0BE8;
		  /* 820C0BE8h */ case    5:  		/* mr R3, R31 */
		/* 820C0BE8h case    5:*/		regs.R3 = regs.R31;
		/* 820C0BE8h case    5:*/		return 0x820C0BEC;
		  /* 820C0BECh */ case    6:  		/* bl -66044 */
		/* 820C0BECh case    6:*/		regs.LR = 0x820C0BF0; return 0x820B09F0;
		/* 820C0BECh case    6:*/		return 0x820C0BF0;
		  /* 820C0BF0h */ case    7:  		/* b 48 */
		/* 820C0BF0h case    7:*/		return 0x820C0C20;
		/* 820C0BF0h case    7:*/		return 0x820C0BF4;
	}
	return 0x820C0BF4;
} // Block from 820C0BD4h-820C0BF4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C0BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0BF4);
		  /* 820C0BF4h */ case    0:  		/* cmplwi CR6, R20, 0 */
		/* 820C0BF4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 820C0BF4h case    0:*/		return 0x820C0BF8;
		  /* 820C0BF8h */ case    1:  		/* bc 12, CR6_EQ, 212 */
		/* 820C0BF8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C0CCC;  }
		/* 820C0BF8h case    1:*/		return 0x820C0BFC;
		  /* 820C0BFCh */ case    2:  		/* lwz R4, <#[R20 + 8]> */
		/* 820C0BFCh case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R20 + 0x00000008) );
		/* 820C0BFCh case    2:*/		return 0x820C0C00;
		  /* 820C0C00h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 820C0C00h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C0C00h case    3:*/		return 0x820C0C04;
		  /* 820C0C04h */ case    4:  		/* bc 12, CR6_EQ, 188 */
		/* 820C0C04h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C0CC0;  }
		/* 820C0C04h case    4:*/		return 0x820C0C08;
		  /* 820C0C08h */ case    5:  		/* li R6, 0 */
		/* 820C0C08h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C0C08h case    5:*/		return 0x820C0C0C;
		  /* 820C0C0Ch */ case    6:  		/* li R5, 0 */
		/* 820C0C0Ch case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C0C0Ch case    6:*/		return 0x820C0C10;
		  /* 820C0C10h */ case    7:  		/* mr R3, R31 */
		/* 820C0C10h case    7:*/		regs.R3 = regs.R31;
		/* 820C0C10h case    7:*/		return 0x820C0C14;
		  /* 820C0C14h */ case    8:  		/* bl 724 */
		/* 820C0C14h case    8:*/		regs.LR = 0x820C0C18; return 0x820C0EE8;
		/* 820C0C14h case    8:*/		return 0x820C0C18;
		  /* 820C0C18h */ case    9:  		/* or. R29, R3, R3 */
		/* 820C0C18h case    9:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C0C18h case    9:*/		return 0x820C0C1C;
		  /* 820C0C1Ch */ case   10:  		/* bc 12, CR0_LT, 200 */
		/* 820C0C1Ch case   10:*/		if ( regs.CR[0].lt ) { return 0x820C0CE4;  }
		/* 820C0C1Ch case   10:*/		return 0x820C0C20;
	}
	return 0x820C0C20;
} // Block from 820C0BF4h-820C0C20h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C0C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0C20);
		  /* 820C0C20h */ case    0:  		/* lwz R11, <#[R1 + 380]> */
		/* 820C0C20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000017C) );
		/* 820C0C20h case    0:*/		return 0x820C0C24;
		  /* 820C0C24h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820C0C24h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C0C24h case    1:*/		return 0x820C0C28;
		  /* 820C0C28h */ case    2:  		/* bc 12, CR6_EQ, 152 */
		/* 820C0C28h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C0CC0;  }
		/* 820C0C28h case    2:*/		return 0x820C0C2C;
		  /* 820C0C2Ch */ case    3:  		/* lwz R11, <#[R1 + 388]> */
		/* 820C0C2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000184) );
		/* 820C0C2Ch case    3:*/		return 0x820C0C30;
		  /* 820C0C30h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820C0C30h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C0C30h case    4:*/		return 0x820C0C34;
		  /* 820C0C34h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820C0C34h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C0C44;  }
		/* 820C0C34h case    5:*/		return 0x820C0C38;
		  /* 820C0C38h */ case    6:  		/* lwz R11, <#[R30 + 44]> */
		/* 820C0C38h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 820C0C38h case    6:*/		return 0x820C0C3C;
		  /* 820C0C3Ch */ case    7:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 820C0C3Ch case    7:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 820C0C3Ch case    7:*/		return 0x820C0C40;
		  /* 820C0C40h */ case    8:  		/* bc 4, CR0_EQ, 128 */
		/* 820C0C40h case    8:*/		if ( !regs.CR[0].eq ) { return 0x820C0CC0;  }
		/* 820C0C40h case    8:*/		return 0x820C0C44;
	}
	return 0x820C0C44;
} // Block from 820C0C20h-820C0C44h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C0C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0C44);
		  /* 820C0C44h */ case    0:  		/* lwz R11, <#[R30 + 44]> */
		/* 820C0C44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 820C0C44h case    0:*/		return 0x820C0C48;
		  /* 820C0C48h */ case    1:  		/* rlwinm. R11, R11, 0, 25, 25 */
		/* 820C0C48h case    1:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R11);
		/* 820C0C48h case    1:*/		return 0x820C0C4C;
		  /* 820C0C4Ch */ case    2:  		/* bc 12, CR0_EQ, 128 */
		/* 820C0C4Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820C0CCC;  }
		/* 820C0C4Ch case    2:*/		return 0x820C0C50;
		  /* 820C0C50h */ case    3:  		/* lwz R11, <#[R25 + 20]> */
		/* 820C0C50h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000014) );
		/* 820C0C50h case    3:*/		return 0x820C0C54;
		  /* 820C0C54h */ case    4:  		/* lwz R26, <#[R11 + 24]> */
		/* 820C0C54h case    4:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x00000018) );
		/* 820C0C54h case    4:*/		return 0x820C0C58;
		  /* 820C0C58h */ case    5:  		/* lbz R11, <#[R26]> */
		/* 820C0C58h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820C0C58h case    5:*/		return 0x820C0C5C;
		  /* 820C0C5Ch */ case    6:  		/* cmplwi CR6, R11, 36 */
		/* 820C0C5Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000024);
		/* 820C0C5Ch case    6:*/		return 0x820C0C60;
		  /* 820C0C60h */ case    7:  		/* bc 12, CR6_EQ, 108 */
		/* 820C0C60h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C0CCC;  }
		/* 820C0C60h case    7:*/		return 0x820C0C64;
		  /* 820C0C64h */ case    8:  		/* mr R11, R26 */
		/* 820C0C64h case    8:*/		regs.R11 = regs.R26;
		/* 820C0C64h case    8:*/		return 0x820C0C68;
		  /* 820C0C68h */ case    9:  		/* lbz R10, <#[R11]> */
		/* 820C0C68h case    9:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C0C68h case    9:*/		return 0x820C0C6C;
		  /* 820C0C6Ch */ case   10:  		/* addi R11, R11, 1 */
		/* 820C0C6Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C0C6Ch case   10:*/		return 0x820C0C70;
		  /* 820C0C70h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 820C0C70h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C0C70h case   11:*/		return 0x820C0C74;
		  /* 820C0C74h */ case   12:  		/* bc 4, CR6_EQ, -12 */
		/* 820C0C74h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820C0C68;  }
		/* 820C0C74h case   12:*/		return 0x820C0C78;
		  /* 820C0C78h */ case   13:  		/* subf R11, R26, R11 */
		/* 820C0C78h case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R26,regs.R11);
		/* 820C0C78h case   13:*/		return 0x820C0C7C;
		  /* 820C0C7Ch */ case   14:  		/* lwz R3, <#[R31]> */
		/* 820C0C7Ch case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820C0C7Ch case   14:*/		return 0x820C0C80;
		  /* 820C0C80h */ case   15:  		/* li R5, 1 */
		/* 820C0C80h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820C0C80h case   15:*/		return 0x820C0C84;
		  /* 820C0C84h */ case   16:  		/* addi R11, R11, -1 */
		/* 820C0C84h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820C0C84h case   16:*/		return 0x820C0C88;
		  /* 820C0C88h */ case   17:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 820C0C88h case   17:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 820C0C88h case   17:*/		return 0x820C0C8C;
		  /* 820C0C8Ch */ case   18:  		/* addi R27, R11, 2 */
		/* 820C0C8Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x2);
		/* 820C0C8Ch case   18:*/		return 0x820C0C90;
		  /* 820C0C90h */ case   19:  		/* mr R4, R27 */
		/* 820C0C90h case   19:*/		regs.R4 = regs.R27;
		/* 820C0C90h case   19:*/		return 0x820C0C94;
		  /* 820C0C94h */ case   20:  		/* bl 33868 */
		/* 820C0C94h case   20:*/		regs.LR = 0x820C0C98; return 0x820C90E0;
		/* 820C0C94h case   20:*/		return 0x820C0C98;
		  /* 820C0C98h */ case   21:  		/* or. R28, R3, R3 */
		/* 820C0C98h case   21:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820C0C98h case   21:*/		return 0x820C0C9C;
		  /* 820C0C9Ch */ case   22:  		/* bc 12, CR0_EQ, 176 */
		/* 820C0C9Ch case   22:*/		if ( regs.CR[0].eq ) { return 0x820C0D4C;  }
		/* 820C0C9Ch case   22:*/		return 0x820C0CA0;
		  /* 820C0CA0h */ case   23:  		/* mr R5, R22 */
		/* 820C0CA0h case   23:*/		regs.R5 = regs.R22;
		/* 820C0CA0h case   23:*/		return 0x820C0CA4;
		  /* 820C0CA4h */ case   24:  		/* mr R6, R26 */
		/* 820C0CA4h case   24:*/		regs.R6 = regs.R26;
		/* 820C0CA4h case   24:*/		return 0x820C0CA8;
		  /* 820C0CA8h */ case   25:  		/* mr R4, R27 */
		/* 820C0CA8h case   25:*/		regs.R4 = regs.R27;
		/* 820C0CA8h case   25:*/		return 0x820C0CAC;
		  /* 820C0CACh */ case   26:  		/* mr R3, R28 */
		/* 820C0CACh case   26:*/		regs.R3 = regs.R28;
		/* 820C0CACh case   26:*/		return 0x820C0CB0;
		  /* 820C0CB0h */ case   27:  		/* bl -124528 */
		/* 820C0CB0h case   27:*/		regs.LR = 0x820C0CB4; return 0x820A2640;
		/* 820C0CB0h case   27:*/		return 0x820C0CB4;
		  /* 820C0CB4h */ case   28:  		/* lwz R11, <#[R25 + 20]> */
		/* 820C0CB4h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000014) );
		/* 820C0CB4h case   28:*/		return 0x820C0CB8;
		  /* 820C0CB8h */ case   29:  		/* stw R28, <#[R11 + 24]> */
		/* 820C0CB8h case   29:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000018) );
		/* 820C0CB8h case   29:*/		return 0x820C0CBC;
		  /* 820C0CBCh */ case   30:  		/* b 16 */
		/* 820C0CBCh case   30:*/		return 0x820C0CCC;
		/* 820C0CBCh case   30:*/		return 0x820C0CC0;
	}
	return 0x820C0CC0;
} // Block from 820C0C44h-820C0CC0h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820C0CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0CC0);
		  /* 820C0CC0h */ case    0:  		/* cmplwi CR6, R20, 0 */
		/* 820C0CC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 820C0CC0h case    0:*/		return 0x820C0CC4;
		  /* 820C0CC4h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820C0CC4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C0CCC;  }
		/* 820C0CC4h case    1:*/		return 0x820C0CC8;
		  /* 820C0CC8h */ case    2:  		/* lwz R20, <#[R20 + 12]> */
		/* 820C0CC8h case    2:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R20 + 0x0000000C) );
		/* 820C0CC8h case    2:*/		return 0x820C0CCC;
	}
	return 0x820C0CCC;
} // Block from 820C0CC0h-820C0CCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C0CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0CCC);
		  /* 820C0CCCh */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820C0CCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C0CCCh case    0:*/		return 0x820C0CD0;
		  /* 820C0CD0h */ case    1:  		/* cmplwi CR6, R24, 0 */
		/* 820C0CD0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820C0CD0h case    1:*/		return 0x820C0CD4;
		  /* 820C0CD4h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C0CD4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C0CD4h case    2:*/		return 0x820C0CD8;
		  /* 820C0CD8h */ case    3:  		/* add R23, R11, R23 */
		/* 820C0CD8h case    3:*/		cpu::op::add<0>(regs,&regs.R23,regs.R11,regs.R23);
		/* 820C0CD8h case    3:*/		return 0x820C0CDC;
		  /* 820C0CDCh */ case    4:  		/* bc 4, CR6_EQ, -808 */
		/* 820C0CDCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C09B4;  }
		/* 820C0CDCh case    4:*/		return 0x820C0CE0;
	}
	return 0x820C0CE0;
} // Block from 820C0CCCh-820C0CE0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C0CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0CE0);
		  /* 820C0CE0h */ case    0:  		/* mr R29, R16 */
		/* 820C0CE0h case    0:*/		regs.R29 = regs.R16;
		/* 820C0CE0h case    0:*/		return 0x820C0CE4;
	}
	return 0x820C0CE4;
} // Block from 820C0CE0h-820C0CE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C0CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0CE4);
		  /* 820C0CE4h */ case    0:  		/* lis R4, 9345 */
		/* 820C0CE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C0CE4h case    0:*/		return 0x820C0CE8;
		  /* 820C0CE8h */ case    1:  		/* lwz R3, <#[R1 + 144]> */
		/* 820C0CE8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000090) );
		/* 820C0CE8h case    1:*/		return 0x820C0CEC;
		  /* 820C0CECh */ case    2:  		/* bl -231860 */
		/* 820C0CECh case    2:*/		regs.LR = 0x820C0CF0; return 0x82088338;
		/* 820C0CECh case    2:*/		return 0x820C0CF0;
		  /* 820C0CF0h */ case    3:  		/* lis R4, 9345 */
		/* 820C0CF0h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C0CF0h case    3:*/		return 0x820C0CF4;
		  /* 820C0CF4h */ case    4:  		/* lwz R3, <#[R1 + 148]> */
		/* 820C0CF4h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000094) );
		/* 820C0CF4h case    4:*/		return 0x820C0CF8;
		  /* 820C0CF8h */ case    5:  		/* bl -231872 */
		/* 820C0CF8h case    5:*/		regs.LR = 0x820C0CFC; return 0x82088338;
		/* 820C0CF8h case    5:*/		return 0x820C0CFC;
		  /* 820C0CFCh */ case    6:  		/* lis R4, 9345 */
		/* 820C0CFCh case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C0CFCh case    6:*/		return 0x820C0D00;
		  /* 820C0D00h */ case    7:  		/* mr R3, R15 */
		/* 820C0D00h case    7:*/		regs.R3 = regs.R15;
		/* 820C0D00h case    7:*/		return 0x820C0D04;
		  /* 820C0D04h */ case    8:  		/* bl -231884 */
		/* 820C0D04h case    8:*/		regs.LR = 0x820C0D08; return 0x82088338;
		/* 820C0D04h case    8:*/		return 0x820C0D08;
		  /* 820C0D08h */ case    9:  		/* lis R4, 9345 */
		/* 820C0D08h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C0D08h case    9:*/		return 0x820C0D0C;
		  /* 820C0D0Ch */ case   10:  		/* lwz R3, <#[R1 + 152]> */
		/* 820C0D0Ch case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000098) );
		/* 820C0D0Ch case   10:*/		return 0x820C0D10;
		  /* 820C0D10h */ case   11:  		/* bl -231896 */
		/* 820C0D10h case   11:*/		regs.LR = 0x820C0D14; return 0x82088338;
		/* 820C0D10h case   11:*/		return 0x820C0D14;
		  /* 820C0D14h */ case   12:  		/* lis R4, 9345 */
		/* 820C0D14h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C0D14h case   12:*/		return 0x820C0D18;
		  /* 820C0D18h */ case   13:  		/* mr R3, R14 */
		/* 820C0D18h case   13:*/		regs.R3 = regs.R14;
		/* 820C0D18h case   13:*/		return 0x820C0D1C;
		  /* 820C0D1Ch */ case   14:  		/* bl -231908 */
		/* 820C0D1Ch case   14:*/		regs.LR = 0x820C0D20; return 0x82088338;
		/* 820C0D1Ch case   14:*/		return 0x820C0D20;
		  /* 820C0D20h */ case   15:  		/* mr R3, R29 */
		/* 820C0D20h case   15:*/		regs.R3 = regs.R29;
		/* 820C0D20h case   15:*/		return 0x820C0D24;
		  /* 820C0D24h */ case   16:  		/* b 60 */
		/* 820C0D24h case   16:*/		return 0x820C0D60;
		/* 820C0D24h case   16:*/		return 0x820C0D28;
	}
	return 0x820C0D28;
} // Block from 820C0CE4h-820C0D28h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C0D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0D28);
		  /* 820C0D28h */ case    0:  		/* lis R10, -32255 */
		/* 820C0D28h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C0D28h case    0:*/		return 0x820C0D2C;
		  /* 820C0D2Ch */ case    1:  		/* lwz R8, <#[R28 + 24]> */
		/* 820C0D2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000018) );
		/* 820C0D2Ch case    1:*/		return 0x820C0D30;
		  /* 820C0D30h */ case    2:  		/* li R5, 3508 */
		/* 820C0D30h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0xDB4);
		/* 820C0D30h case    2:*/		return 0x820C0D34;
		  /* 820C0D34h */ case    3:  		/* lwz R7, <#[R1 + 348]> */
		/* 820C0D34h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000015C) );
		/* 820C0D34h case    3:*/		return 0x820C0D38;
		  /* 820C0D38h */ case    4:  		/* addi R6, R10, 9260 */
		/* 820C0D38h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0x242C);
		/* 820C0D38h case    4:*/		return 0x820C0D3C;
		  /* 820C0D3Ch */ case    5:  		/* lwz R4, <#[R11 + 96]> */
		/* 820C0D3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000060) );
		/* 820C0D3Ch case    5:*/		return 0x820C0D40;
		  /* 820C0D40h */ case    6:  		/* mr R3, R31 */
		/* 820C0D40h case    6:*/		regs.R3 = regs.R31;
		/* 820C0D40h case    6:*/		return 0x820C0D44;
		  /* 820C0D44h */ case    7:  		/* bl -66388 */
		/* 820C0D44h case    7:*/		regs.LR = 0x820C0D48; return 0x820B09F0;
		/* 820C0D44h case    7:*/		return 0x820C0D48;
		  /* 820C0D48h */ case    8:  		/* b -100 */
		/* 820C0D48h case    8:*/		return 0x820C0CE4;
		/* 820C0D48h case    8:*/		return 0x820C0D4C;
	}
	return 0x820C0D4C;
} // Block from 820C0D28h-820C0D4Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C0D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0D4C);
		  /* 820C0D4Ch */ case    0:  		/* lis R29, -32761 */
		/* 820C0D4Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8007);
		/* 820C0D4Ch case    0:*/		return 0x820C0D50;
		  /* 820C0D50h */ case    1:  		/* ori R29, R29, 14 */
		/* 820C0D50h case    1:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0xE);
		/* 820C0D50h case    1:*/		return 0x820C0D54;
		  /* 820C0D54h */ case    2:  		/* b -112 */
		/* 820C0D54h case    2:*/		return 0x820C0CE4;
		/* 820C0D54h case    2:*/		return 0x820C0D58;
	}
	return 0x820C0D58;
} // Block from 820C0D4Ch-820C0D58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C0D58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0D58);
		  /* 820C0D58h */ case    0:  		/* lis R3, -32768 */
		/* 820C0D58h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C0D58h case    0:*/		return 0x820C0D5C;
		  /* 820C0D5Ch */ case    1:  		/* ori R3, R3, 16389 */
		/* 820C0D5Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C0D5Ch case    1:*/		return 0x820C0D60;
	}
	return 0x820C0D60;
} // Block from 820C0D58h-820C0D60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C0D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0D60);
		  /* 820C0D60h */ case    0:  		/* addi R1, R1, 320 */
		/* 820C0D60h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x140);
		/* 820C0D60h case    0:*/		return 0x820C0D64;
		  /* 820C0D64h */ case    1:  		/* lfd FR31, <#[R1 - 160]> */
		/* 820C0D64h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820C0D64h case    1:*/		return 0x820C0D68;
		  /* 820C0D68h */ case    2:  		/* b -195320 */
		/* 820C0D68h case    2:*/		return 0x82091270;
		/* 820C0D68h case    2:*/		return 0x820C0D6C;
		  /* 820C0D6Ch */ case    3:  		/* nop */
		/* 820C0D6Ch case    3:*/		cpu::op::nop();
		/* 820C0D6Ch case    3:*/		return 0x820C0D70;
	}
	return 0x820C0D70;
} // Block from 820C0D60h-820C0D70h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C0D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0D70);
		  /* 820C0D70h */ case    0:  		/* mfspr R12, LR */
		/* 820C0D70h case    0:*/		regs.R12 = regs.LR;
		/* 820C0D70h case    0:*/		return 0x820C0D74;
		  /* 820C0D74h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C0D74h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C0D74h case    1:*/		return 0x820C0D78;
		  /* 820C0D78h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C0D78h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C0D78h case    2:*/		return 0x820C0D7C;
		  /* 820C0D7Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C0D7Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C0D7Ch case    3:*/		return 0x820C0D80;
		  /* 820C0D80h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C0D80h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C0D80h case    4:*/		return 0x820C0D84;
		  /* 820C0D84h */ case    5:  		/* lwz R30, <#[R3 + 4]> */
		/* 820C0D84h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 820C0D84h case    5:*/		return 0x820C0D88;
		  /* 820C0D88h */ case    6:  		/* mr R31, R3 */
		/* 820C0D88h case    6:*/		regs.R31 = regs.R3;
		/* 820C0D88h case    6:*/		return 0x820C0D8C;
		  /* 820C0D8Ch */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 820C0D8Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C0D8Ch case    7:*/		return 0x820C0D90;
		  /* 820C0D90h */ case    8:  		/* bc 12, CR6_EQ, 312 */
		/* 820C0D90h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C0EC8;  }
		/* 820C0D90h case    8:*/		return 0x820C0D94;
		  /* 820C0D94h */ case    9:  		/* lwz R11, <#[R30 + 4]> */
		/* 820C0D94h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820C0D94h case    9:*/		return 0x820C0D98;
		  /* 820C0D98h */ case   10:  		/* cmpwi CR6, R11, 4 */
		/* 820C0D98h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 820C0D98h case   10:*/		return 0x820C0D9C;
		  /* 820C0D9Ch */ case   11:  		/* bc 4, CR6_EQ, 300 */
		/* 820C0D9Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x820C0EC8;  }
		/* 820C0D9Ch case   11:*/		return 0x820C0DA0;
		  /* 820C0DA0h */ case   12:  		/* lwz R3, <#[R3 + 8]> */
		/* 820C0DA0h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 820C0DA0h case   12:*/		return 0x820C0DA4;
		  /* 820C0DA4h */ case   13:  		/* cmplwi CR6, R3, 0 */
		/* 820C0DA4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C0DA4h case   13:*/		return 0x820C0DA8;
		  /* 820C0DA8h */ case   14:  		/* bc 4, CR6_EQ, 16 */
		/* 820C0DA8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820C0DB8;  }
		/* 820C0DA8h case   14:*/		return 0x820C0DAC;
		  /* 820C0DACh */ case   15:  		/* lis R3, -32768 */
		/* 820C0DACh case   15:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C0DACh case   15:*/		return 0x820C0DB0;
		  /* 820C0DB0h */ case   16:  		/* ori R3, R3, 16389 */
		/* 820C0DB0h case   16:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C0DB0h case   16:*/		return 0x820C0DB4;
		  /* 820C0DB4h */ case   17:  		/* b 280 */
		/* 820C0DB4h case   17:*/		return 0x820C0ECC;
		/* 820C0DB4h case   17:*/		return 0x820C0DB8;
	}
	return 0x820C0DB8;
} // Block from 820C0D70h-820C0DB8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820C0DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0DB8);
		  /* 820C0DB8h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820C0DB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C0DB8h case    0:*/		return 0x820C0DBC;
		  /* 820C0DBCh */ case    1:  		/* mr R4, R30 */
		/* 820C0DBCh case    1:*/		regs.R4 = regs.R30;
		/* 820C0DBCh case    1:*/		return 0x820C0DC0;
		  /* 820C0DC0h */ case    2:  		/* lwz R7, <#[R31 + 20]> */
		/* 820C0DC0h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 820C0DC0h case    2:*/		return 0x820C0DC4;
		  /* 820C0DC4h */ case    3:  		/* addi R5, R11, 24 */
		/* 820C0DC4h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x18);
		/* 820C0DC4h case    3:*/		return 0x820C0DC8;
		  /* 820C0DC8h */ case    4:  		/* lwz R6, <#[R31 + 16]> */
		/* 820C0DC8h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000010) );
		/* 820C0DC8h case    4:*/		return 0x820C0DCC;
		  /* 820C0DCCh */ case    5:  		/* bl 284812 */
		/* 820C0DCCh case    5:*/		regs.LR = 0x820C0DD0; return 0x82106658;
		/* 820C0DCCh case    5:*/		return 0x820C0DD0;
		  /* 820C0DD0h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C0DD0h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C0DD0h case    6:*/		return 0x820C0DD4;
		  /* 820C0DD4h */ case    7:  		/* bc 12, CR0_LT, 248 */
		/* 820C0DD4h case    7:*/		if ( regs.CR[0].lt ) { return 0x820C0ECC;  }
		/* 820C0DD4h case    7:*/		return 0x820C0DD8;
		  /* 820C0DD8h */ case    8:  		/* lis R4, 9345 */
		/* 820C0DD8h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C0DD8h case    8:*/		return 0x820C0DDC;
		  /* 820C0DDCh */ case    9:  		/* lwz R3, <#[R31 + 24]> */
		/* 820C0DDCh case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0DDCh case    9:*/		return 0x820C0DE0;
		  /* 820C0DE0h */ case   10:  		/* bl -232104 */
		/* 820C0DE0h case   10:*/		regs.LR = 0x820C0DE4; return 0x82088338;
		/* 820C0DE0h case   10:*/		return 0x820C0DE4;
		  /* 820C0DE4h */ case   11:  		/* lwz R11, <#[R30 + 28]> */
		/* 820C0DE4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820C0DE4h case   11:*/		return 0x820C0DE8;
		  /* 820C0DE8h */ case   12:  		/* lis R4, 9345 */
		/* 820C0DE8h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C0DE8h case   12:*/		return 0x820C0DEC;
		  /* 820C0DECh */ case   13:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820C0DECh case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820C0DECh case   13:*/		return 0x820C0DF0;
		  /* 820C0DF0h */ case   14:  		/* bl -232432 */
		/* 820C0DF0h case   14:*/		regs.LR = 0x820C0DF4; return 0x82088200;
		/* 820C0DF0h case   14:*/		return 0x820C0DF4;
		  /* 820C0DF4h */ case   15:  		/* stw R3, <#[R31 + 24]> */
		/* 820C0DF4h case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820C0DF4h case   15:*/		return 0x820C0DF8;
		  /* 820C0DF8h */ case   16:  		/* cmplwi CR0, R3, 0 */
		/* 820C0DF8h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C0DF8h case   16:*/		return 0x820C0DFC;
		  /* 820C0DFCh */ case   17:  		/* bc 4, CR0_EQ, 16 */
		/* 820C0DFCh case   17:*/		if ( !regs.CR[0].eq ) { return 0x820C0E0C;  }
		/* 820C0DFCh case   17:*/		return 0x820C0E00;
		  /* 820C0E00h */ case   18:  		/* lis R3, -32761 */
		/* 820C0E00h case   18:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820C0E00h case   18:*/		return 0x820C0E04;
		  /* 820C0E04h */ case   19:  		/* ori R3, R3, 14 */
		/* 820C0E04h case   19:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820C0E04h case   19:*/		return 0x820C0E08;
		  /* 820C0E08h */ case   20:  		/* b 196 */
		/* 820C0E08h case   20:*/		return 0x820C0ECC;
		/* 820C0E08h case   20:*/		return 0x820C0E0C;
	}
	return 0x820C0E0C;
} // Block from 820C0DB8h-820C0E0Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C0E0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0E0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0E0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0E0C);
		  /* 820C0E0Ch */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 820C0E0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820C0E0Ch case    0:*/		return 0x820C0E10;
		  /* 820C0E10h */ case    1:  		/* li R4, 255 */
		/* 820C0E10h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xFF);
		/* 820C0E10h case    1:*/		return 0x820C0E14;
		  /* 820C0E14h */ case    2:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820C0E14h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820C0E14h case    2:*/		return 0x820C0E18;
		  /* 820C0E18h */ case    3:  		/* bl -195288 */
		/* 820C0E18h case    3:*/		regs.LR = 0x820C0E1C; return 0x82091340;
		/* 820C0E18h case    3:*/		return 0x820C0E1C;
		  /* 820C0E1Ch */ case    4:  		/* lwz R3, <#[R31 + 8]> */
		/* 820C0E1Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0E1Ch case    4:*/		return 0x820C0E20;
		  /* 820C0E20h */ case    5:  		/* lis R11, -32256 */
		/* 820C0E20h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820C0E20h case    5:*/		return 0x820C0E24;
		  /* 820C0E24h */ case    6:  		/* li R6, 0 */
		/* 820C0E24h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C0E24h case    6:*/		return 0x820C0E28;
		  /* 820C0E28h */ case    7:  		/* li R5, 0 */
		/* 820C0E28h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C0E28h case    7:*/		return 0x820C0E2C;
		  /* 820C0E2Ch */ case    8:  		/* lwz R4, <#[R3 + 120]> */
		/* 820C0E2Ch case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820C0E2Ch case    8:*/		return 0x820C0E30;
		  /* 820C0E30h */ case    9:  		/* lfd FR1, <#[R11 + 1848]> */
		/* 820C0E30h case    9:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000738) );
		/* 820C0E30h case    9:*/		return 0x820C0E34;
		  /* 820C0E34h */ case   10:  		/* bl 246772 */
		/* 820C0E34h case   10:*/		regs.LR = 0x820C0E38; return 0x820FD228;
		/* 820C0E34h case   10:*/		return 0x820C0E38;
		  /* 820C0E38h */ case   11:  		/* stw R3, <#[R31 + 32]> */
		/* 820C0E38h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 820C0E38h case   11:*/		return 0x820C0E3C;
		  /* 820C0E3Ch */ case   12:  		/* lis R11, -32256 */
		/* 820C0E3Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820C0E3Ch case   12:*/		return 0x820C0E40;
		  /* 820C0E40h */ case   13:  		/* lwz R3, <#[R31 + 8]> */
		/* 820C0E40h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0E40h case   13:*/		return 0x820C0E44;
		  /* 820C0E44h */ case   14:  		/* li R6, 0 */
		/* 820C0E44h case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C0E44h case   14:*/		return 0x820C0E48;
		  /* 820C0E48h */ case   15:  		/* li R5, 0 */
		/* 820C0E48h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C0E48h case   15:*/		return 0x820C0E4C;
		  /* 820C0E4Ch */ case   16:  		/* lfd FR1, <#[R11 + 1808]> */
		/* 820C0E4Ch case   16:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000710) );
		/* 820C0E4Ch case   16:*/		return 0x820C0E50;
		  /* 820C0E50h */ case   17:  		/* lwz R4, <#[R3 + 120]> */
		/* 820C0E50h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820C0E50h case   17:*/		return 0x820C0E54;
		  /* 820C0E54h */ case   18:  		/* bl 246740 */
		/* 820C0E54h case   18:*/		regs.LR = 0x820C0E58; return 0x820FD228;
		/* 820C0E54h case   18:*/		return 0x820C0E58;
		  /* 820C0E58h */ case   19:  		/* stw R3, <#[R31 + 36]> */
		/* 820C0E58h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000024) );
		/* 820C0E58h case   19:*/		return 0x820C0E5C;
		  /* 820C0E5Ch */ case   20:  		/* lwz R3, <#[R31 + 8]> */
		/* 820C0E5Ch case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820C0E5Ch case   20:*/		return 0x820C0E60;
		  /* 820C0E60h */ case   21:  		/* lis R11, -32255 */
		/* 820C0E60h case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C0E60h case   21:*/		return 0x820C0E64;
		  /* 820C0E64h */ case   22:  		/* li R6, 0 */
		/* 820C0E64h case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C0E64h case   22:*/		return 0x820C0E68;
		  /* 820C0E68h */ case   23:  		/* li R5, 0 */
		/* 820C0E68h case   23:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C0E68h case   23:*/		return 0x820C0E6C;
		  /* 820C0E6Ch */ case   24:  		/* lwz R4, <#[R3 + 120]> */
		/* 820C0E6Ch case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820C0E6Ch case   24:*/		return 0x820C0E70;
		  /* 820C0E70h */ case   25:  		/* lfd FR1, <#[R11 - 24488]> */
		/* 820C0E70h case   25:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0xFFFFA058) );
		/* 820C0E70h case   25:*/		return 0x820C0E74;
		  /* 820C0E74h */ case   26:  		/* bl 246708 */
		/* 820C0E74h case   26:*/		regs.LR = 0x820C0E78; return 0x820FD228;
		/* 820C0E74h case   26:*/		return 0x820C0E78;
		  /* 820C0E78h */ case   27:  		/* lwz R11, <#[R31 + 32]> */
		/* 820C0E78h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820C0E78h case   27:*/		return 0x820C0E7C;
		  /* 820C0E7Ch */ case   28:  		/* li R10, -1 */
		/* 820C0E7Ch case   28:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C0E7Ch case   28:*/		return 0x820C0E80;
		  /* 820C0E80h */ case   29:  		/* stw R3, <#[R31 + 40]> */
		/* 820C0E80h case   29:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 820C0E80h case   29:*/		return 0x820C0E84;
		  /* 820C0E84h */ case   30:  		/* li R9, 1 */
		/* 820C0E84h case   30:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820C0E84h case   30:*/		return 0x820C0E88;
		  /* 820C0E88h */ case   31:  		/* stw R11, <#[R31 + 44]> */
		/* 820C0E88h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820C0E88h case   31:*/		return 0x820C0E8C;
		  /* 820C0E8Ch */ case   32:  		/* stw R10, <#[R31 + 48]> */
		/* 820C0E8Ch case   32:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 820C0E8Ch case   32:*/		return 0x820C0E90;
		  /* 820C0E90h */ case   33:  		/* li R5, 0 */
		/* 820C0E90h case   33:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C0E90h case   33:*/		return 0x820C0E94;
		  /* 820C0E94h */ case   34:  		/* stw R9, <#[R31 + 52]> */
		/* 820C0E94h case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000034) );
		/* 820C0E94h case   34:*/		return 0x820C0E98;
		  /* 820C0E98h */ case   35:  		/* mr R3, R31 */
		/* 820C0E98h case   35:*/		regs.R3 = regs.R31;
		/* 820C0E98h case   35:*/		return 0x820C0E9C;
		  /* 820C0E9Ch */ case   36:  		/* lwz R4, <#[R30 + 40]> */
		/* 820C0E9Ch case   36:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000028) );
		/* 820C0E9Ch case   36:*/		return 0x820C0EA0;
		  /* 820C0EA0h */ case   37:  		/* bl -5120 */
		/* 820C0EA0h case   37:*/		regs.LR = 0x820C0EA4; return 0x820BFAA0;
		/* 820C0EA0h case   37:*/		return 0x820C0EA4;
		  /* 820C0EA4h */ case   38:  		/* cmpwi CR0, R3, 0 */
		/* 820C0EA4h case   38:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C0EA4h case   38:*/		return 0x820C0EA8;
		  /* 820C0EA8h */ case   39:  		/* bc 12, CR0_LT, 36 */
		/* 820C0EA8h case   39:*/		if ( regs.CR[0].lt ) { return 0x820C0ECC;  }
		/* 820C0EA8h case   39:*/		return 0x820C0EAC;
		  /* 820C0EACh */ case   40:  		/* lwz R11, <#[R31 + 76]> */
		/* 820C0EACh case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820C0EACh case   40:*/		return 0x820C0EB0;
		  /* 820C0EB0h */ case   41:  		/* lis R10, -32768 */
		/* 820C0EB0h case   41:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 820C0EB0h case   41:*/		return 0x820C0EB4;
		  /* 820C0EB4h */ case   42:  		/* subfic R11, R11, 0 */
		/* 820C0EB4h case   42:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820C0EB4h case   42:*/		return 0x820C0EB8;
		  /* 820C0EB8h */ case   43:  		/* ori R10, R10, 16389 */
		/* 820C0EB8h case   43:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x4005);
		/* 820C0EB8h case   43:*/		return 0x820C0EBC;
		  /* 820C0EBCh */ case   44:  		/* subfe R11, R11, R11 */
		/* 820C0EBCh case   44:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820C0EBCh case   44:*/		return 0x820C0EC0;
		  /* 820C0EC0h */ case   45:  		/* and R3, R11, R10 */
		/* 820C0EC0h case   45:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820C0EC0h case   45:*/		return 0x820C0EC4;
		  /* 820C0EC4h */ case   46:  		/* b 8 */
		/* 820C0EC4h case   46:*/		return 0x820C0ECC;
		/* 820C0EC4h case   46:*/		return 0x820C0EC8;
	}
	return 0x820C0EC8;
} // Block from 820C0E0Ch-820C0EC8h (47 instructions)

//////////////////////////////////////////////////////
// Block at 820C0EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0EC8);
		  /* 820C0EC8h */ case    0:  		/* li R3, 0 */
		/* 820C0EC8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C0EC8h case    0:*/		return 0x820C0ECC;
	}
	return 0x820C0ECC;
} // Block from 820C0EC8h-820C0ECCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C0ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0ECC);
		  /* 820C0ECCh */ case    0:  		/* addi R1, R1, 112 */
		/* 820C0ECCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C0ECCh case    0:*/		return 0x820C0ED0;
		  /* 820C0ED0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C0ED0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C0ED0h case    1:*/		return 0x820C0ED4;
		  /* 820C0ED4h */ case    2:  		/* mtspr LR, R12 */
		/* 820C0ED4h case    2:*/		regs.LR = regs.R12;
		/* 820C0ED4h case    2:*/		return 0x820C0ED8;
		  /* 820C0ED8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820C0ED8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C0ED8h case    3:*/		return 0x820C0EDC;
		  /* 820C0EDCh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820C0EDCh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C0EDCh case    4:*/		return 0x820C0EE0;
		  /* 820C0EE0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C0EE0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C0EE0h case    5:*/		return 0x820C0EE4;
	}
	return 0x820C0EE4;
} // Block from 820C0ECCh-820C0EE4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C0EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0EE4);
		  /* 820C0EE4h */ case    0:  		/* nop */
		/* 820C0EE4h case    0:*/		cpu::op::nop();
		/* 820C0EE4h case    0:*/		return 0x820C0EE8;
	}
	return 0x820C0EE8;
} // Block from 820C0EE4h-820C0EE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C0EE8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0EE8);
		  /* 820C0EE8h */ case    0:  		/* mfspr R12, LR */
		/* 820C0EE8h case    0:*/		regs.R12 = regs.LR;
		/* 820C0EE8h case    0:*/		return 0x820C0EEC;
		  /* 820C0EECh */ case    1:  		/* bl -195788 */
		/* 820C0EECh case    1:*/		regs.LR = 0x820C0EF0; return 0x82091220;
		/* 820C0EECh case    1:*/		return 0x820C0EF0;
		  /* 820C0EF0h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 820C0EF0h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820C0EF0h case    2:*/		return 0x820C0EF4;
		  /* 820C0EF4h */ case    3:  		/* stwu R1, <#[R1 - 368]> */
		/* 820C0EF4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE90);
		/* 820C0EF4h case    3:*/		return 0x820C0EF8;
		  /* 820C0EF8h */ case    4:  		/* mr R17, R3 */
		/* 820C0EF8h case    4:*/		regs.R17 = regs.R3;
		/* 820C0EF8h case    4:*/		return 0x820C0EFC;
		  /* 820C0EFCh */ case    5:  		/* mr R15, R4 */
		/* 820C0EFCh case    5:*/		regs.R15 = regs.R4;
		/* 820C0EFCh case    5:*/		return 0x820C0F00;
		  /* 820C0F00h */ case    6:  		/* mr R14, R5 */
		/* 820C0F00h case    6:*/		regs.R14 = regs.R5;
		/* 820C0F00h case    6:*/		return 0x820C0F04;
		  /* 820C0F04h */ case    7:  		/* mr R26, R6 */
		/* 820C0F04h case    7:*/		regs.R26 = regs.R6;
		/* 820C0F04h case    7:*/		return 0x820C0F08;
		  /* 820C0F08h */ case    8:  		/* cmplwi CR6, R4, 0 */
		/* 820C0F08h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C0F08h case    8:*/		return 0x820C0F0C;
		  /* 820C0F0Ch */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 820C0F0Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820C0F20;  }
		/* 820C0F0Ch case    9:*/		return 0x820C0F10;
		  /* 820C0F10h */ case   10:  		/* cmplwi CR6, R5, 0 */
		/* 820C0F10h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820C0F10h case   10:*/		return 0x820C0F14;
		  /* 820C0F14h */ case   11:  		/* bc 4, CR6_EQ, 7232 */
		/* 820C0F14h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820C2B54;  }
		/* 820C0F14h case   11:*/		return 0x820C0F18;
		  /* 820C0F18h */ case   12:  		/* li R3, 0 */
		/* 820C0F18h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C0F18h case   12:*/		return 0x820C0F1C;
		  /* 820C0F1Ch */ case   13:  		/* b 7232 */
		/* 820C0F1Ch case   13:*/		return 0x820C2B5C;
		/* 820C0F1Ch case   13:*/		return 0x820C0F20;
	}
	return 0x820C0F20;
} // Block from 820C0EE8h-820C0F20h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C0F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0F20);
		  /* 820C0F20h */ case    0:  		/* lwz R11, <#[R15 + 4]> */
		/* 820C0F20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000004) );
		/* 820C0F20h case    0:*/		return 0x820C0F24;
		  /* 820C0F24h */ case    1:  		/* cmpwi CR6, R11, 14 */
		/* 820C0F24h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 820C0F24h case    1:*/		return 0x820C0F28;
		  /* 820C0F28h */ case    2:  		/* bc 4, CR6_EQ, 7212 */
		/* 820C0F28h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C2B54;  }
		/* 820C0F28h case    2:*/		return 0x820C0F2C;
		  /* 820C0F2Ch */ case    3:  		/* lwz R10, <#[R15 + 24]> */
		/* 820C0F2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000018) );
		/* 820C0F2Ch case    3:*/		return 0x820C0F30;
		  /* 820C0F30h */ case    4:  		/* li R25, 0 */
		/* 820C0F30h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 820C0F30h case    4:*/		return 0x820C0F34;
		  /* 820C0F34h */ case    5:  		/* lwz R9, <#[R15 + 20]> */
		/* 820C0F34h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R15 + 0x00000014) );
		/* 820C0F34h case    5:*/		return 0x820C0F38;
		  /* 820C0F38h */ case    6:  		/* li R24, 0 */
		/* 820C0F38h case    6:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820C0F38h case    6:*/		return 0x820C0F3C;
		  /* 820C0F3Ch */ case    7:  		/* lwz R11, <#[R15 + 32]> */
		/* 820C0F3Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000020) );
		/* 820C0F3Ch case    7:*/		return 0x820C0F40;
		  /* 820C0F40h */ case    8:  		/* li R27, 0 */
		/* 820C0F40h case    8:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820C0F40h case    8:*/		return 0x820C0F44;
		  /* 820C0F44h */ case    9:  		/* li R31, 0 */
		/* 820C0F44h case    9:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C0F44h case    9:*/		return 0x820C0F48;
		  /* 820C0F48h */ case   10:  		/* stw R25, <#[R1 + 128]> */
		/* 820C0F48h case   10:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000080) );
		/* 820C0F48h case   10:*/		return 0x820C0F4C;
		  /* 820C0F4Ch */ case   11:  		/* stw R24, <#[R1 + 132]> */
		/* 820C0F4Ch case   11:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000084) );
		/* 820C0F4Ch case   11:*/		return 0x820C0F50;
		  /* 820C0F50h */ case   12:  		/* li R30, 0 */
		/* 820C0F50h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C0F50h case   12:*/		return 0x820C0F54;
		  /* 820C0F54h */ case   13:  		/* mullw R21, R9, R10 */
		/* 820C0F54h case   13:*/		cpu::op::mullw<0>(regs,&regs.R21,regs.R9,regs.R10);
		/* 820C0F54h case   13:*/		return 0x820C0F58;
		  /* 820C0F58h */ case   14:  		/* li R28, 0 */
		/* 820C0F58h case   14:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820C0F58h case   14:*/		return 0x820C0F5C;
		  /* 820C0F5Ch */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 820C0F5Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C0F5Ch case   15:*/		return 0x820C0F60;
		  /* 820C0F60h */ case   16:  		/* bc 12, CR6_EQ, 32 */
		/* 820C0F60h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C0F80;  }
		/* 820C0F60h case   16:*/		return 0x820C0F64;
		  /* 820C0F64h */ case   17:  		/* lwz R10, <#[R11 + 4]> */
		/* 820C0F64h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820C0F64h case   17:*/		return 0x820C0F68;
		  /* 820C0F68h */ case   18:  		/* cmpwi CR6, R10, 14 */
		/* 820C0F68h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000E);
		/* 820C0F68h case   18:*/		return 0x820C0F6C;
		  /* 820C0F6Ch */ case   19:  		/* bc 4, CR6_EQ, 20 */
		/* 820C0F6Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x820C0F80;  }
		/* 820C0F6Ch case   19:*/		return 0x820C0F70;
		  /* 820C0F70h */ case   20:  		/* lwz R10, <#[R11 + 24]> */
		/* 820C0F70h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 820C0F70h case   20:*/		return 0x820C0F74;
		  /* 820C0F74h */ case   21:  		/* mr R30, R11 */
		/* 820C0F74h case   21:*/		regs.R30 = regs.R11;
		/* 820C0F74h case   21:*/		return 0x820C0F78;
		  /* 820C0F78h */ case   22:  		/* lwz R11, <#[R11 + 20]> */
		/* 820C0F78h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820C0F78h case   22:*/		return 0x820C0F7C;
		  /* 820C0F7Ch */ case   23:  		/* mullw R27, R10, R11 */
		/* 820C0F7Ch case   23:*/		cpu::op::mullw<0>(regs,&regs.R27,regs.R10,regs.R11);
		/* 820C0F7Ch case   23:*/		return 0x820C0F80;
	}
	return 0x820C0F80;
} // Block from 820C0F20h-820C0F80h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820C0F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0F80);
		  /* 820C0F80h */ case    0:  		/* lwz R11, <#[R15 + 36]> */
		/* 820C0F80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000024) );
		/* 820C0F80h case    0:*/		return 0x820C0F84;
		  /* 820C0F84h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C0F84h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C0F84h case    1:*/		return 0x820C0F88;
		  /* 820C0F88h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820C0F88h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C0FA8;  }
		/* 820C0F88h case    2:*/		return 0x820C0F8C;
		  /* 820C0F8Ch */ case    3:  		/* lwz R10, <#[R11 + 4]> */
		/* 820C0F8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820C0F8Ch case    3:*/		return 0x820C0F90;
		  /* 820C0F90h */ case    4:  		/* cmpwi CR6, R10, 14 */
		/* 820C0F90h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000E);
		/* 820C0F90h case    4:*/		return 0x820C0F94;
		  /* 820C0F94h */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 820C0F94h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C0FA8;  }
		/* 820C0F94h case    5:*/		return 0x820C0F98;
		  /* 820C0F98h */ case    6:  		/* lwz R10, <#[R11 + 24]> */
		/* 820C0F98h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 820C0F98h case    6:*/		return 0x820C0F9C;
		  /* 820C0F9Ch */ case    7:  		/* mr R28, R11 */
		/* 820C0F9Ch case    7:*/		regs.R28 = regs.R11;
		/* 820C0F9Ch case    7:*/		return 0x820C0FA0;
		  /* 820C0FA0h */ case    8:  		/* lwz R11, <#[R11 + 20]> */
		/* 820C0FA0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820C0FA0h case    8:*/		return 0x820C0FA4;
		  /* 820C0FA4h */ case    9:  		/* mullw R31, R10, R11 */
		/* 820C0FA4h case    9:*/		cpu::op::mullw<0>(regs,&regs.R31,regs.R10,regs.R11);
		/* 820C0FA4h case    9:*/		return 0x820C0FA8;
	}
	return 0x820C0FA8;
} // Block from 820C0F80h-820C0FA8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C0FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0FA8);
		  /* 820C0FA8h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820C0FA8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C0FA8h case    0:*/		return 0x820C0FAC;
		  /* 820C0FACh */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820C0FACh case    1:*/		if ( regs.CR[6].eq ) { return 0x820C0FC8;  }
		/* 820C0FACh case    1:*/		return 0x820C0FB0;
		  /* 820C0FB0h */ case    2:  		/* mr R4, R27 */
		/* 820C0FB0h case    2:*/		regs.R4 = regs.R27;
		/* 820C0FB0h case    2:*/		return 0x820C0FB4;
		  /* 820C0FB4h */ case    3:  		/* mr R3, R17 */
		/* 820C0FB4h case    3:*/		regs.R3 = regs.R17;
		/* 820C0FB4h case    3:*/		return 0x820C0FB8;
		  /* 820C0FB8h */ case    4:  		/* bl -67664 */
		/* 820C0FB8h case    4:*/		regs.LR = 0x820C0FBC; return 0x820B0768;
		/* 820C0FB8h case    4:*/		return 0x820C0FBC;
		  /* 820C0FBCh */ case    5:  		/* or. R25, R3, R3 */
		/* 820C0FBCh case    5:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 820C0FBCh case    5:*/		return 0x820C0FC0;
		  /* 820C0FC0h */ case    6:  		/* stw R25, <#[R1 + 128]> */
		/* 820C0FC0h case    6:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000080) );
		/* 820C0FC0h case    6:*/		return 0x820C0FC4;
		  /* 820C0FC4h */ case    7:  		/* bc 12, CR0_EQ, 5792 */
		/* 820C0FC4h case    7:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C0FC4h case    7:*/		return 0x820C0FC8;
	}
	return 0x820C0FC8;
} // Block from 820C0FA8h-820C0FC8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C0FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0FC8);
		  /* 820C0FC8h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820C0FC8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C0FC8h case    0:*/		return 0x820C0FCC;
		  /* 820C0FCCh */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820C0FCCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820C0FE8;  }
		/* 820C0FCCh case    1:*/		return 0x820C0FD0;
		  /* 820C0FD0h */ case    2:  		/* mr R4, R31 */
		/* 820C0FD0h case    2:*/		regs.R4 = regs.R31;
		/* 820C0FD0h case    2:*/		return 0x820C0FD4;
		  /* 820C0FD4h */ case    3:  		/* mr R3, R17 */
		/* 820C0FD4h case    3:*/		regs.R3 = regs.R17;
		/* 820C0FD4h case    3:*/		return 0x820C0FD8;
		  /* 820C0FD8h */ case    4:  		/* bl -67696 */
		/* 820C0FD8h case    4:*/		regs.LR = 0x820C0FDC; return 0x820B0768;
		/* 820C0FD8h case    4:*/		return 0x820C0FDC;
		  /* 820C0FDCh */ case    5:  		/* or. R24, R3, R3 */
		/* 820C0FDCh case    5:*/		cpu::op::or<1>(regs,&regs.R24,regs.R3,regs.R3);
		/* 820C0FDCh case    5:*/		return 0x820C0FE0;
		  /* 820C0FE0h */ case    6:  		/* stw R24, <#[R1 + 132]> */
		/* 820C0FE0h case    6:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000084) );
		/* 820C0FE0h case    6:*/		return 0x820C0FE4;
		  /* 820C0FE4h */ case    7:  		/* bc 12, CR0_EQ, 5760 */
		/* 820C0FE4h case    7:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C0FE4h case    7:*/		return 0x820C0FE8;
	}
	return 0x820C0FE8;
} // Block from 820C0FC8h-820C0FE8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C0FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C0FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C0FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C0FE8);
		  /* 820C0FE8h */ case    0:  		/* lwz R11, <#[R15 + 28]> */
		/* 820C0FE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000001C) );
		/* 820C0FE8h case    0:*/		return 0x820C0FEC;
		  /* 820C0FECh */ case    1:  		/* li R20, 1 */
		/* 820C0FECh case    1:*/		cpu::op::li<0>(regs,&regs.R20,0x1);
		/* 820C0FECh case    1:*/		return 0x820C0FF0;
		  /* 820C0FF0h */ case    2:  		/* li R29, 0 */
		/* 820C0FF0h case    2:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C0FF0h case    2:*/		return 0x820C0FF4;
		  /* 820C0FF4h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820C0FF4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C0FF4h case    3:*/		return 0x820C0FF8;
		  /* 820C0FF8h */ case    4:  		/* bc 12, CR6_LT, 40 */
		/* 820C0FF8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C1020;  }
		/* 820C0FF8h case    4:*/		return 0x820C0FFC;
		  /* 820C0FFCh */ case    5:  		/* cmpwi CR6, R11, 3 */
		/* 820C0FFCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 820C0FFCh case    5:*/		return 0x820C1000;
		  /* 820C1000h */ case    6:  		/* bc 4, CR6_GT, 28 */
		/* 820C1000h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820C101C;  }
		/* 820C1000h case    6:*/		return 0x820C1004;
		  /* 820C1004h */ case    7:  		/* cmpwi CR6, R11, 25 */
		/* 820C1004h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000019);
		/* 820C1004h case    7:*/		return 0x820C1008;
		  /* 820C1008h */ case    8:  		/* bc 4, CR6_GT, 24 */
		/* 820C1008h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820C1020;  }
		/* 820C1008h case    8:*/		return 0x820C100C;
		  /* 820C100Ch */ case    9:  		/* cmpwi CR6, R11, 27 */
		/* 820C100Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001B);
		/* 820C100Ch case    9:*/		return 0x820C1010;
		  /* 820C1010h */ case   10:  		/* bc 4, CR6_GT, 88 */
		/* 820C1010h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820C1068;  }
		/* 820C1010h case   10:*/		return 0x820C1014;
		  /* 820C1014h */ case   11:  		/* cmpwi CR6, R11, 29 */
		/* 820C1014h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001D);
		/* 820C1014h case   11:*/		return 0x820C1018;
		  /* 820C1018h */ case   12:  		/* bc 12, CR6_GT, 8 */
		/* 820C1018h case   12:*/		if ( regs.CR[6].gt ) { return 0x820C1020;  }
		/* 820C1018h case   12:*/		return 0x820C101C;
	}
	return 0x820C101C;
} // Block from 820C0FE8h-820C101Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C101Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C101C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C101C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C101C);
		  /* 820C101Ch */ case    0:  		/* mr R29, R26 */
		/* 820C101Ch case    0:*/		regs.R29 = regs.R26;
		/* 820C101Ch case    0:*/		return 0x820C1020;
	}
	return 0x820C1020;
} // Block from 820C101Ch-820C1020h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C1020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1020);
		  /* 820C1020h */ case    0:  		/* lwz R11, <#[R15 + 40]> */
		/* 820C1020h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000028) );
		/* 820C1020h case    0:*/		return 0x820C1024;
		  /* 820C1024h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820C1024h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C1024h case    1:*/		return 0x820C1028;
		  /* 820C1028h */ case    2:  		/* bc 12, CR6_EQ, 72 */
		/* 820C1028h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C1070;  }
		/* 820C1028h case    2:*/		return 0x820C102C;
		  /* 820C102Ch */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 820C102Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C102Ch case    3:*/		return 0x820C1030;
		  /* 820C1030h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1030h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C1050;  }
		/* 820C1030h case    4:*/		return 0x820C1034;
		  /* 820C1034h */ case    5:  		/* mr R6, R29 */
		/* 820C1034h case    5:*/		regs.R6 = regs.R29;
		/* 820C1034h case    5:*/		return 0x820C1038;
		  /* 820C1038h */ case    6:  		/* mr R5, R25 */
		/* 820C1038h case    6:*/		regs.R5 = regs.R25;
		/* 820C1038h case    6:*/		return 0x820C103C;
		  /* 820C103Ch */ case    7:  		/* mr R4, R30 */
		/* 820C103Ch case    7:*/		regs.R4 = regs.R30;
		/* 820C103Ch case    7:*/		return 0x820C1040;
		  /* 820C1040h */ case    8:  		/* mr R3, R17 */
		/* 820C1040h case    8:*/		regs.R3 = regs.R17;
		/* 820C1040h case    8:*/		return 0x820C1044;
		  /* 820C1044h */ case    9:  		/* bl -348 */
		/* 820C1044h case    9:*/		regs.LR = 0x820C1048; return 0x820C0EE8;
		/* 820C1044h case    9:*/		return 0x820C1048;
		  /* 820C1048h */ case   10:  		/* or. R31, R3, R3 */
		/* 820C1048h case   10:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1048h case   10:*/		return 0x820C104C;
		  /* 820C104Ch */ case   11:  		/* bc 12, CR0_LT, 6792 */
		/* 820C104Ch case   11:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C104Ch case   11:*/		return 0x820C1050;
	}
	return 0x820C1050;
} // Block from 820C1020h-820C1050h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C1050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1050);
		  /* 820C1050h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820C1050h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1050h case    0:*/		return 0x820C1054;
		  /* 820C1054h */ case    1:  		/* bc 12, CR6_EQ, 100 */
		/* 820C1054h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C10B8;  }
		/* 820C1054h case    1:*/		return 0x820C1058;
		  /* 820C1058h */ case    2:  		/* li R6, 0 */
		/* 820C1058h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C1058h case    2:*/		return 0x820C105C;
		  /* 820C105Ch */ case    3:  		/* mr R5, R24 */
		/* 820C105Ch case    3:*/		regs.R5 = regs.R24;
		/* 820C105Ch case    3:*/		return 0x820C1060;
		  /* 820C1060h */ case    4:  		/* mr R4, R28 */
		/* 820C1060h case    4:*/		regs.R4 = regs.R28;
		/* 820C1060h case    4:*/		return 0x820C1064;
		  /* 820C1064h */ case    5:  		/* b 68 */
		/* 820C1064h case    5:*/		return 0x820C10A8;
		/* 820C1064h case    5:*/		return 0x820C1068;
	}
	return 0x820C1068;
} // Block from 820C1050h-820C1068h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C1068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1068);
		  /* 820C1068h */ case    0:  		/* mr R29, R20 */
		/* 820C1068h case    0:*/		regs.R29 = regs.R20;
		/* 820C1068h case    0:*/		return 0x820C106C;
		  /* 820C106Ch */ case    1:  		/* b -76 */
		/* 820C106Ch case    1:*/		return 0x820C1020;
		/* 820C106Ch case    1:*/		return 0x820C1070;
	}
	return 0x820C1070;
} // Block from 820C1068h-820C1070h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C1070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1070);
		  /* 820C1070h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820C1070h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1070h case    0:*/		return 0x820C1074;
		  /* 820C1074h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1074h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C1094;  }
		/* 820C1074h case    1:*/		return 0x820C1078;
		  /* 820C1078h */ case    2:  		/* li R6, 0 */
		/* 820C1078h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C1078h case    2:*/		return 0x820C107C;
		  /* 820C107Ch */ case    3:  		/* mr R5, R24 */
		/* 820C107Ch case    3:*/		regs.R5 = regs.R24;
		/* 820C107Ch case    3:*/		return 0x820C1080;
		  /* 820C1080h */ case    4:  		/* mr R4, R28 */
		/* 820C1080h case    4:*/		regs.R4 = regs.R28;
		/* 820C1080h case    4:*/		return 0x820C1084;
		  /* 820C1084h */ case    5:  		/* mr R3, R17 */
		/* 820C1084h case    5:*/		regs.R3 = regs.R17;
		/* 820C1084h case    5:*/		return 0x820C1088;
		  /* 820C1088h */ case    6:  		/* bl -416 */
		/* 820C1088h case    6:*/		regs.LR = 0x820C108C; return 0x820C0EE8;
		/* 820C1088h case    6:*/		return 0x820C108C;
		  /* 820C108Ch */ case    7:  		/* or. R31, R3, R3 */
		/* 820C108Ch case    7:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C108Ch case    7:*/		return 0x820C1090;
		  /* 820C1090h */ case    8:  		/* bc 12, CR0_LT, 6724 */
		/* 820C1090h case    8:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1090h case    8:*/		return 0x820C1094;
	}
	return 0x820C1094;
} // Block from 820C1070h-820C1094h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C1094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1094);
		  /* 820C1094h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820C1094h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C1094h case    0:*/		return 0x820C1098;
		  /* 820C1098h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1098h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C10B8;  }
		/* 820C1098h case    1:*/		return 0x820C109C;
		  /* 820C109Ch */ case    2:  		/* mr R6, R29 */
		/* 820C109Ch case    2:*/		regs.R6 = regs.R29;
		/* 820C109Ch case    2:*/		return 0x820C10A0;
		  /* 820C10A0h */ case    3:  		/* mr R5, R25 */
		/* 820C10A0h case    3:*/		regs.R5 = regs.R25;
		/* 820C10A0h case    3:*/		return 0x820C10A4;
		  /* 820C10A4h */ case    4:  		/* mr R4, R30 */
		/* 820C10A4h case    4:*/		regs.R4 = regs.R30;
		/* 820C10A4h case    4:*/		return 0x820C10A8;
	}
	return 0x820C10A8;
} // Block from 820C1094h-820C10A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C10A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C10A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C10A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C10A8);
		  /* 820C10A8h */ case    0:  		/* mr R3, R17 */
		/* 820C10A8h case    0:*/		regs.R3 = regs.R17;
		/* 820C10A8h case    0:*/		return 0x820C10AC;
		  /* 820C10ACh */ case    1:  		/* bl -452 */
		/* 820C10ACh case    1:*/		regs.LR = 0x820C10B0; return 0x820C0EE8;
		/* 820C10ACh case    1:*/		return 0x820C10B0;
		  /* 820C10B0h */ case    2:  		/* or. R31, R3, R3 */
		/* 820C10B0h case    2:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C10B0h case    2:*/		return 0x820C10B4;
		  /* 820C10B4h */ case    3:  		/* bc 12, CR0_LT, 6688 */
		/* 820C10B4h case    3:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C10B4h case    3:*/		return 0x820C10B8;
	}
	return 0x820C10B8;
} // Block from 820C10A8h-820C10B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C10B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C10B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C10B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C10B8);
		  /* 820C10B8h */ case    0:  		/* lwz R11, <#[R15 + 28]> */
		/* 820C10B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000001C) );
		/* 820C10B8h case    0:*/		return 0x820C10BC;
		  /* 820C10BCh */ case    1:  		/* cmplwi CR6, R11, 32 */
		/* 820C10BCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 820C10BCh case    1:*/		return 0x820C10C0;
		  /* 820C10C0h */ case    2:  		/* bc 12, CR6_GT, 6644 */
		/* 820C10C0h case    2:*/		if ( regs.CR[6].gt ) { return 0x820C2AB4;  }
		/* 820C10C0h case    2:*/		return 0x820C10C4;
		  /* 820C10C4h */ case    3:  		/* lis R10, -32256 */
		/* 820C10C4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820C10C4h case    3:*/		return 0x820C10C8;
		  /* 820C10C8h */ case    4:  		/* li R22, -1 */
		/* 820C10C8h case    4:*/		cpu::op::li<0>(regs,&regs.R22,0xFFFFFFFF);
		/* 820C10C8h case    4:*/		return 0x820C10CC;
		  /* 820C10CCh */ case    5:  		/* li R19, 257 */
		/* 820C10CCh case    5:*/		cpu::op::li<0>(regs,&regs.R19,0x101);
		/* 820C10CCh case    5:*/		return 0x820C10D0;
		  /* 820C10D0h */ case    6:  		/* lfd FR31, <#[R10 + 1808]> */
		/* 820C10D0h case    6:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000710) );
		/* 820C10D0h case    6:*/		return 0x820C10D4;
		  /* 820C10D4h */ case    7:  		/* lis R12, -32255 */
		/* 820C10D4h case    7:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8201);
		/* 820C10D4h case    7:*/		return 0x820C10D8;
		  /* 820C10D8h */ case    8:  		/* rlwinm R0, R11, 1, 0, 30 */
		/* 820C10D8h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R11);
		/* 820C10D8h case    8:*/		return 0x820C10DC;
		  /* 820C10DCh */ case    9:  		/* addi R12, R12, 8496 */
		/* 820C10DCh case    9:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x2130);
		/* 820C10DCh case    9:*/		return 0x820C10E0;
		  /* 820C10E0h */ case   10:  		/* lhzx R0, <#[R12 + R0]> */
		/* 820C10E0h case   10:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 820C10E0h case   10:*/		return 0x820C10E4;
		  /* 820C10E4h */ case   11:  		/* lis R12, -32244 */
		/* 820C10E4h case   11:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF820C);
		/* 820C10E4h case   11:*/		return 0x820C10E8;
		  /* 820C10E8h */ case   12:  		/* addi R12, R12, 4348 */
		/* 820C10E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x10FC);
		/* 820C10E8h case   12:*/		return 0x820C10EC;
		  /* 820C10ECh */ case   13:  		/* ori R0, R0, 0 */
		/* 820C10ECh case   13:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 820C10ECh case   13:*/		return 0x820C10F0;
		  /* 820C10F0h */ case   14:  		/* add R12, R12, R0 */
		/* 820C10F0h case   14:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 820C10F0h case   14:*/		return 0x820C10F4;
		  /* 820C10F4h */ case   15:  		/* mtspr CTR, R12 */
		/* 820C10F4h case   15:*/		regs.CTR = regs.R12;
		/* 820C10F4h case   15:*/		return 0x820C10F8;
		  /* 820C10F8h */ case   16:  		/* bcctr 20, CR0_LT */
		/* 820C10F8h case   16:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820C10F8h case   16:*/		return 0x820C10FC;
		  /* 820C10FCh */ case   17:  		/* cmplwi CR6, R30, 0 */
		/* 820C10FCh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C10FCh case   17:*/		return 0x820C1100;
		  /* 820C1100h */ case   18:  		/* bc 12, CR6_EQ, 224 */
		/* 820C1100h case   18:*/		if ( regs.CR[6].eq ) { return 0x820C11E0;  }
		/* 820C1100h case   18:*/		return 0x820C1104;
		  /* 820C1104h */ case   19:  		/* cmplwi CR6, R14, 0 */
		/* 820C1104h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C1104h case   19:*/		return 0x820C1108;
		  /* 820C1108h */ case   20:  		/* bc 12, CR6_EQ, 6564 */
		/* 820C1108h case   20:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C1108h case   20:*/		return 0x820C110C;
		  /* 820C110Ch */ case   21:  		/* cmplwi CR6, R27, 1 */
		/* 820C110Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000001);
		/* 820C110Ch case   21:*/		return 0x820C1110;
		  /* 820C1110h */ case   22:  		/* bc 4, CR6_EQ, 76 */
		/* 820C1110h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820C115C;  }
		/* 820C1110h case   22:*/		return 0x820C1114;
		  /* 820C1114h */ case   23:  		/* cmplwi CR6, R21, 0 */
		/* 820C1114h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1114h case   23:*/		return 0x820C1118;
		  /* 820C1118h */ case   24:  		/* bc 12, CR6_EQ, 28 */
		/* 820C1118h case   24:*/		if ( regs.CR[6].eq ) { return 0x820C1134;  }
		/* 820C1118h case   24:*/		return 0x820C111C;
		  /* 820C111Ch */ case   25:  		/* lwz R10, <#[R1 + 128]> */
		/* 820C111Ch case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 820C111Ch case   25:*/		return 0x820C1120;
		  /* 820C1120h */ case   26:  		/* addi R11, R14, -4 */
		/* 820C1120h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C1120h case   26:*/		return 0x820C1124;
		  /* 820C1124h */ case   27:  		/* mtspr CTR, R21 */
		/* 820C1124h case   27:*/		regs.CTR = regs.R21;
		/* 820C1124h case   27:*/		return 0x820C1128;
		  /* 820C1128h */ case   28:  		/* lwz R9, <#[R10]> */
		/* 820C1128h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820C1128h case   28:*/		return 0x820C112C;
		  /* 820C112Ch */ case   29:  		/* stwu R9, <#[R11 + 4]> */
		/* 820C112Ch case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C112Ch case   29:*/		return 0x820C1130;
		  /* 820C1130h */ case   30:  		/* bc 16, CR0_LT, -8 */
		/* 820C1130h case   30:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1128;  }
		/* 820C1130h case   30:*/		return 0x820C1134;
	}
	return 0x820C1134;
} // Block from 820C10B8h-820C1134h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820C1134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1134);
		  /* 820C1134h */ case    0:  		/* cmplwi CR6, R14, 0 */
		/* 820C1134h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C1134h case    0:*/		return 0x820C1138;
		  /* 820C1138h */ case    1:  		/* bc 12, CR6_EQ, 6516 */
		/* 820C1138h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C1138h case    1:*/		return 0x820C113C;
		  /* 820C113Ch */ case    2:  		/* lwz R11, <#[R17 + 164]> */
		/* 820C113Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x000000A4) );
		/* 820C113Ch case    2:*/		return 0x820C1140;
		  /* 820C1140h */ case    3:  		/* cmplw CR6, R21, R11 */
		/* 820C1140h case    3:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R11);
		/* 820C1140h case    3:*/		return 0x820C1144;
		  /* 820C1144h */ case    4:  		/* bc 4, CR6_GT, 4796 */
		/* 820C1144h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820C2400;  }
		/* 820C1144h case    4:*/		return 0x820C1148;
		  /* 820C1148h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820C1148h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C1148h case    5:*/		return 0x820C114C;
		  /* 820C114Ch */ case    6:  		/* rlwinm R31, R11, 1, 0, 30 */
		/* 820C114Ch case    6:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R31,regs.R11);
		/* 820C114Ch case    6:*/		return 0x820C1150;
		  /* 820C1150h */ case    7:  		/* bc 4, CR6_EQ, 4736 */
		/* 820C1150h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820C23D0;  }
		/* 820C1150h case    7:*/		return 0x820C1154;
		  /* 820C1154h */ case    8:  		/* li R31, 16 */
		/* 820C1154h case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x10);
		/* 820C1154h case    8:*/		return 0x820C1158;
		  /* 820C1158h */ case    9:  		/* b 4728 */
		/* 820C1158h case    9:*/		return 0x820C23D0;
		/* 820C1158h case    9:*/		return 0x820C115C;
	}
	return 0x820C115C;
} // Block from 820C1134h-820C115Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C115Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C115C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C115C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C115C);
		  /* 820C115Ch */ case    0:  		/* cmplw CR6, R21, R27 */
		/* 820C115Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R27);
		/* 820C115Ch case    0:*/		return 0x820C1160;
		  /* 820C1160h */ case    1:  		/* bc 12, CR6_EQ, 352 */
		/* 820C1160h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C12C0;  }
		/* 820C1160h case    1:*/		return 0x820C1164;
		  /* 820C1164h */ case    2:  		/* lwz R11, <#[R15 + 20]> */
		/* 820C1164h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000014) );
		/* 820C1164h case    2:*/		return 0x820C1168;
		  /* 820C1168h */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 820C1168h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C1168h case    3:*/		return 0x820C116C;
		  /* 820C116Ch */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 820C116Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C1178;  }
		/* 820C116Ch case    4:*/		return 0x820C1170;
		  /* 820C1170h */ case    5:  		/* cmplw CR6, R21, R27 */
		/* 820C1170h case    5:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R27);
		/* 820C1170h case    5:*/		return 0x820C1174;
		  /* 820C1174h */ case    6:  		/* bc 12, CR6_LT, 332 */
		/* 820C1174h case    6:*/		if ( regs.CR[6].lt ) { return 0x820C12C0;  }
		/* 820C1174h case    6:*/		return 0x820C1178;
	}
	return 0x820C1178;
} // Block from 820C115Ch-820C1178h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C1178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1178);
		  /* 820C1178h */ case    0:  		/* lwz R10, <#[R30 + 20]> */
		/* 820C1178h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 820C1178h case    0:*/		return 0x820C117C;
		  /* 820C117Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820C117Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C117Ch case    1:*/		return 0x820C1180;
		  /* 820C1180h */ case    2:  		/* bc 12, CR6_GT, 6476 */
		/* 820C1180h case    2:*/		if ( regs.CR[6].gt ) { return 0x820C2ACC;  }
		/* 820C1180h case    2:*/		return 0x820C1184;
		  /* 820C1184h */ case    3:  		/* lwz R10, <#[R15 + 24]> */
		/* 820C1184h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000018) );
		/* 820C1184h case    3:*/		return 0x820C1188;
		  /* 820C1188h */ case    4:  		/* lwz R9, <#[R30 + 24]> */
		/* 820C1188h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000018) );
		/* 820C1188h case    4:*/		return 0x820C118C;
		  /* 820C118Ch */ case    5:  		/* cmplw CR6, R10, R9 */
		/* 820C118Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820C118Ch case    5:*/		return 0x820C1190;
		  /* 820C1190h */ case    6:  		/* bc 12, CR6_GT, 6460 */
		/* 820C1190h case    6:*/		if ( regs.CR[6].gt ) { return 0x820C2ACC;  }
		/* 820C1190h case    6:*/		return 0x820C1194;
		  /* 820C1194h */ case    7:  		/* li R31, 0 */
		/* 820C1194h case    7:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C1194h case    7:*/		return 0x820C1198;
		  /* 820C1198h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820C1198h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C1198h case    8:*/		return 0x820C119C;
		  /* 820C119Ch */ case    9:  		/* bc 12, CR6_EQ, -104 */
		/* 820C119Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820C1134;  }
		/* 820C119Ch case    9:*/		return 0x820C11A0;
		  /* 820C11A0h */ case   10:  		/* lwz R9, <#[R15 + 24]> */
		/* 820C11A0h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R15 + 0x00000018) );
		/* 820C11A0h case   10:*/		return 0x820C11A4;
		  /* 820C11A4h */ case   11:  		/* lwz R11, <#[R30 + 24]> */
		/* 820C11A4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820C11A4h case   11:*/		return 0x820C11A8;
		  /* 820C11A8h */ case   12:  		/* mullw R10, R9, R31 */
		/* 820C11A8h case   12:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R9,regs.R31);
		/* 820C11A8h case   12:*/		return 0x820C11AC;
		  /* 820C11ACh */ case   13:  		/* lwz R8, <#[R1 + 128]> */
		/* 820C11ACh case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000080) );
		/* 820C11ACh case   13:*/		return 0x820C11B0;
		  /* 820C11B0h */ case   14:  		/* mullw R11, R11, R31 */
		/* 820C11B0h case   14:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820C11B0h case   14:*/		return 0x820C11B4;
		  /* 820C11B4h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C11B4h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C11B4h case   15:*/		return 0x820C11B8;
		  /* 820C11B8h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C11B8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C11B8h case   16:*/		return 0x820C11BC;
		  /* 820C11BCh */ case   17:  		/* rlwinm R5, R9, 2, 0, 29 */
		/* 820C11BCh case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R9);
		/* 820C11BCh case   17:*/		return 0x820C11C0;
		  /* 820C11C0h */ case   18:  		/* add R4, R11, R8 */
		/* 820C11C0h case   18:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R8);
		/* 820C11C0h case   18:*/		return 0x820C11C4;
		  /* 820C11C4h */ case   19:  		/* add R3, R10, R14 */
		/* 820C11C4h case   19:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R14);
		/* 820C11C4h case   19:*/		return 0x820C11C8;
		  /* 820C11C8h */ case   20:  		/* bl -194584 */
		/* 820C11C8h case   20:*/		regs.LR = 0x820C11CC; return 0x820919B0;
		/* 820C11C8h case   20:*/		return 0x820C11CC;
		  /* 820C11CCh */ case   21:  		/* lwz R11, <#[R15 + 20]> */
		/* 820C11CCh case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000014) );
		/* 820C11CCh case   21:*/		return 0x820C11D0;
		  /* 820C11D0h */ case   22:  		/* addi R31, R31, 1 */
		/* 820C11D0h case   22:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820C11D0h case   22:*/		return 0x820C11D4;
		  /* 820C11D4h */ case   23:  		/* cmplw CR6, R31, R11 */
		/* 820C11D4h case   23:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820C11D4h case   23:*/		return 0x820C11D8;
		  /* 820C11D8h */ case   24:  		/* bc 12, CR6_LT, -56 */
		/* 820C11D8h case   24:*/		if ( regs.CR[6].lt ) { return 0x820C11A0;  }
		/* 820C11D8h case   24:*/		return 0x820C11DC;
		  /* 820C11DCh */ case   25:  		/* b -168 */
		/* 820C11DCh case   25:*/		return 0x820C1134;
		/* 820C11DCh case   25:*/		return 0x820C11E0;
	}
	return 0x820C11E0;
} // Block from 820C1178h-820C11E0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820C11E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C11E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C11E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C11E0);
		  /* 820C11E0h */ case    0:  		/* mr R6, R21 */
		/* 820C11E0h case    0:*/		regs.R6 = regs.R21;
		/* 820C11E0h case    0:*/		return 0x820C11E4;
		  /* 820C11E4h */ case    1:  		/* lwz R4, <#[R15 + 32]> */
		/* 820C11E4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R15 + 0x00000020) );
		/* 820C11E4h case    1:*/		return 0x820C11E8;
		  /* 820C11E8h */ case    2:  		/* mr R5, R14 */
		/* 820C11E8h case    2:*/		regs.R5 = regs.R14;
		/* 820C11E8h case    2:*/		return 0x820C11EC;
		  /* 820C11ECh */ case    3:  		/* mr R3, R17 */
		/* 820C11ECh case    3:*/		regs.R3 = regs.R17;
		/* 820C11ECh case    3:*/		return 0x820C11F0;
		  /* 820C11F0h */ case    4:  		/* bl 6520 */
		/* 820C11F0h case    4:*/		regs.LR = 0x820C11F4; return 0x820C2B68;
		/* 820C11F0h case    4:*/		return 0x820C11F4;
		  /* 820C11F4h */ case    5:  		/* b 4428 */
		/* 820C11F4h case    5:*/		return 0x820C2340;
		/* 820C11F4h case    5:*/		return 0x820C11F8;
		  /* 820C11F8h */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 820C11F8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C11F8h case    6:*/		return 0x820C11FC;
		  /* 820C11FCh */ case    7:  		/* bc 12, CR6_EQ, 6352 */
		/* 820C11FCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C11FCh case    7:*/		return 0x820C1200;
		  /* 820C1200h */ case    8:  		/* cmplwi CR6, R28, 0 */
		/* 820C1200h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1200h case    8:*/		return 0x820C1204;
		  /* 820C1204h */ case    9:  		/* bc 12, CR6_EQ, 6344 */
		/* 820C1204h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1204h case    9:*/		return 0x820C1208;
		  /* 820C1208h */ case   10:  		/* cmplwi CR6, R21, 0 */
		/* 820C1208h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1208h case   10:*/		return 0x820C120C;
		  /* 820C120Ch */ case   11:  		/* bc 12, CR6_EQ, -216 */
		/* 820C120Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820C1134;  }
		/* 820C120Ch case   11:*/		return 0x820C1210;
		  /* 820C1210h */ case   12:  		/* lwz R11, <#[R17 + 8]> */
		/* 820C1210h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000008) );
		/* 820C1210h case   12:*/		return 0x820C1214;
		  /* 820C1214h */ case   13:  		/* lwz R10, <#[R25]> */
		/* 820C1214h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 820C1214h case   13:*/		return 0x820C1218;
		  /* 820C1218h */ case   14:  		/* lwz R9, <#[R11 + 8]> */
		/* 820C1218h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820C1218h case   14:*/		return 0x820C121C;
		  /* 820C121Ch */ case   15:  		/* cmplw CR6, R10, R9 */
		/* 820C121Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 820C121Ch case   15:*/		return 0x820C1220;
		  /* 820C1220h */ case   16:  		/* bc 4, CR6_LT, 20 */
		/* 820C1220h case   16:*/		if ( !regs.CR[6].lt ) { return 0x820C1234;  }
		/* 820C1220h case   16:*/		return 0x820C1224;
		  /* 820C1224h */ case   17:  		/* lwz R9, <#[R11 + 20]> */
		/* 820C1224h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820C1224h case   17:*/		return 0x820C1228;
		  /* 820C1228h */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C1228h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C1228h case   18:*/		return 0x820C122C;
		  /* 820C122Ch */ case   19:  		/* lwzx R10, <#[R10 + R9]> */
		/* 820C122Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820C122Ch case   19:*/		return 0x820C1230;
		  /* 820C1230h */ case   20:  		/* b 8 */
		/* 820C1230h case   20:*/		return 0x820C1238;
		/* 820C1230h case   20:*/		return 0x820C1234;
	}
	return 0x820C1234;
} // Block from 820C11E0h-820C1234h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C1234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1234);
		  /* 820C1234h */ case    0:  		/* li R10, 0 */
		/* 820C1234h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C1234h case    0:*/		return 0x820C1238;
	}
	return 0x820C1238;
} // Block from 820C1234h-820C1238h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C1238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1238);
		  /* 820C1238h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820C1238h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C1238h case    0:*/		return 0x820C123C;
		  /* 820C123Ch */ case    1:  		/* bc 12, CR6_EQ, 124 */
		/* 820C123Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820C12B8;  }
		/* 820C123Ch case    1:*/		return 0x820C1240;
		  /* 820C1240h */ case    2:  		/* lwz R9, <#[R11 + 116]> */
		/* 820C1240h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000074) );
		/* 820C1240h case    2:*/		return 0x820C1244;
		  /* 820C1244h */ case    3:  		/* lwz R10, <#[R10 + 4]> */
		/* 820C1244h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 820C1244h case    3:*/		return 0x820C1248;
		  /* 820C1248h */ case    4:  		/* cmplw CR6, R9, R10 */
		/* 820C1248h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820C1248h case    4:*/		return 0x820C124C;
		  /* 820C124Ch */ case    5:  		/* bc 4, CR6_EQ, 108 */
		/* 820C124Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C12B8;  }
		/* 820C124Ch case    5:*/		return 0x820C1250;
		  /* 820C1250h */ case    6:  		/* li R10, 0 */
		/* 820C1250h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C1250h case    6:*/		return 0x820C1254;
		  /* 820C1254h */ case    7:  		/* cmplwi CR6, R21, 0 */
		/* 820C1254h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1254h case    7:*/		return 0x820C1258;
		  /* 820C1258h */ case    8:  		/* bc 12, CR6_EQ, 52 */
		/* 820C1258h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C128C;  }
		/* 820C1258h case    8:*/		return 0x820C125C;
		  /* 820C125Ch */ case    9:  		/* lwz R9, <#[R11 + 20]> */
		/* 820C125Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 820C125Ch case    9:*/		return 0x820C1260;
		  /* 820C1260h */ case   10:  		/* mr R11, R25 */
		/* 820C1260h case   10:*/		regs.R11 = regs.R25;
		/* 820C1260h case   10:*/		return 0x820C1264;
		  /* 820C1264h */ case   11:  		/* lwz R8, <#[R11]> */
		/* 820C1264h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820C1264h case   11:*/		return 0x820C1268;
		  /* 820C1268h */ case   12:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820C1268h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820C1268h case   12:*/		return 0x820C126C;
		  /* 820C126Ch */ case   13:  		/* lwzx R8, <#[R8 + R9]> */
		/* 820C126Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820C126Ch case   13:*/		return 0x820C1270;
		  /* 820C1270h */ case   14:  		/* lwz R8, <#[R8 + 48]> */
		/* 820C1270h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000030) );
		/* 820C1270h case   14:*/		return 0x820C1274;
		  /* 820C1274h */ case   15:  		/* cmpwi CR6, R8, -1 */
		/* 820C1274h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 820C1274h case   15:*/		return 0x820C1278;
		  /* 820C1278h */ case   16:  		/* bc 12, CR6_EQ, 92 */
		/* 820C1278h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C12D4;  }
		/* 820C1278h case   16:*/		return 0x820C127C;
		  /* 820C127Ch */ case   17:  		/* addi R10, R10, 1 */
		/* 820C127Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C127Ch case   17:*/		return 0x820C1280;
		  /* 820C1280h */ case   18:  		/* addi R11, R11, 4 */
		/* 820C1280h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820C1280h case   18:*/		return 0x820C1284;
		  /* 820C1284h */ case   19:  		/* cmplw CR6, R10, R21 */
		/* 820C1284h case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R21);
		/* 820C1284h case   19:*/		return 0x820C1288;
		  /* 820C1288h */ case   20:  		/* bc 12, CR6_LT, -36 */
		/* 820C1288h case   20:*/		if ( regs.CR[6].lt ) { return 0x820C1264;  }
		/* 820C1288h case   20:*/		return 0x820C128C;
	}
	return 0x820C128C;
} // Block from 820C1238h-820C128Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C128Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C128C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C128C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C128C);
		  /* 820C128Ch */ case    0:  		/* mr R5, R21 */
		/* 820C128Ch case    0:*/		regs.R5 = regs.R21;
		/* 820C128Ch case    0:*/		return 0x820C1290;
		  /* 820C1290h */ case    1:  		/* li R8, 0 */
		/* 820C1290h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C1290h case    1:*/		return 0x820C1294;
		  /* 820C1294h */ case    2:  		/* rlwimi R5, R20, 28, 0, 11 */
		/* 820C1294h case    2:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R5,regs.R20);
		/* 820C1294h case    2:*/		return 0x820C1298;
		  /* 820C1298h */ case    3:  		/* mr R7, R24 */
		/* 820C1298h case    3:*/		regs.R7 = regs.R24;
		/* 820C1298h case    3:*/		return 0x820C129C;
		  /* 820C129Ch */ case    4:  		/* li R9, 0 */
		/* 820C129Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C129Ch case    4:*/		return 0x820C12A0;
		  /* 820C12A0h */ case    5:  		/* mr R6, R25 */
		/* 820C12A0h case    5:*/		regs.R6 = regs.R25;
		/* 820C12A0h case    5:*/		return 0x820C12A4;
		  /* 820C12A4h */ case    6:  		/* mr R4, R15 */
		/* 820C12A4h case    6:*/		regs.R4 = regs.R15;
		/* 820C12A4h case    6:*/		return 0x820C12A8;
		  /* 820C12A8h */ case    7:  		/* mr R3, R17 */
		/* 820C12A8h case    7:*/		regs.R3 = regs.R17;
		/* 820C12A8h case    7:*/		return 0x820C12AC;
		  /* 820C12ACh */ case    8:  		/* bl -67492 */
		/* 820C12ACh case    8:*/		regs.LR = 0x820C12B0; return 0x820B0B08;
		/* 820C12ACh case    8:*/		return 0x820C12B0;
		  /* 820C12B0h */ case    9:  		/* or. R31, R3, R3 */
		/* 820C12B0h case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C12B0h case    9:*/		return 0x820C12B4;
		  /* 820C12B4h */ case   10:  		/* bc 12, CR0_LT, 6176 */
		/* 820C12B4h case   10:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C12B4h case   10:*/		return 0x820C12B8;
	}
	return 0x820C12B8;
} // Block from 820C128Ch-820C12B8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C12B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C12B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C12B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C12B8);
		  /* 820C12B8h */ case    0:  		/* cmplwi CR6, R14, 0 */
		/* 820C12B8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C12B8h case    0:*/		return 0x820C12BC;
		  /* 820C12BCh */ case    1:  		/* bc 12, CR6_EQ, 6128 */
		/* 820C12BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C12BCh case    1:*/		return 0x820C12C0;
	}
	return 0x820C12C0;
} // Block from 820C12B8h-820C12C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C12C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C12C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C12C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C12C0);
		  /* 820C12C0h */ case    0:  		/* lwz R4, <#[R1 + 128]> */
		/* 820C12C0h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000080) );
		/* 820C12C0h case    0:*/		return 0x820C12C4;
		  /* 820C12C4h */ case    1:  		/* mr R3, R14 */
		/* 820C12C4h case    1:*/		regs.R3 = regs.R14;
		/* 820C12C4h case    1:*/		return 0x820C12C8;
		  /* 820C12C8h */ case    2:  		/* rlwinm R5, R21, 2, 0, 29 */
		/* 820C12C8h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R21);
		/* 820C12C8h case    2:*/		return 0x820C12CC;
		  /* 820C12CCh */ case    3:  		/* bl -194844 */
		/* 820C12CCh case    3:*/		regs.LR = 0x820C12D0; return 0x820919B0;
		/* 820C12CCh case    3:*/		return 0x820C12D0;
		  /* 820C12D0h */ case    4:  		/* b -412 */
		/* 820C12D0h case    4:*/		return 0x820C1134;
		/* 820C12D0h case    4:*/		return 0x820C12D4;
	}
	return 0x820C12D4;
} // Block from 820C12C0h-820C12D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C12D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C12D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C12D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C12D4);
		  /* 820C12D4h */ case    0:  		/* lis R11, -32255 */
		/* 820C12D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C12D4h case    0:*/		return 0x820C12D8;
		  /* 820C12D8h */ case    1:  		/* mr R4, R15 */
		/* 820C12D8h case    1:*/		regs.R4 = regs.R15;
		/* 820C12D8h case    1:*/		return 0x820C12DC;
		  /* 820C12DCh */ case    2:  		/* addi R6, R11, 9624 */
		/* 820C12DCh case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2598);
		/* 820C12DCh case    2:*/		return 0x820C12E0;
		  /* 820C12E0h */ case    3:  		/* b 6112 */
		/* 820C12E0h case    3:*/		return 0x820C2AC0;
		/* 820C12E0h case    3:*/		return 0x820C12E4;
		  /* 820C12E4h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 820C12E4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C12E4h case    4:*/		return 0x820C12E8;
		  /* 820C12E8h */ case    5:  		/* bc 12, CR6_EQ, 6116 */
		/* 820C12E8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C12E8h case    5:*/		return 0x820C12EC;
		  /* 820C12ECh */ case    6:  		/* cmplwi CR6, R28, 0 */
		/* 820C12ECh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C12ECh case    6:*/		return 0x820C12F0;
		  /* 820C12F0h */ case    7:  		/* bc 12, CR6_EQ, 6108 */
		/* 820C12F0h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C12F0h case    7:*/		return 0x820C12F4;
		  /* 820C12F4h */ case    8:  		/* cmplwi CR6, R21, 0 */
		/* 820C12F4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C12F4h case    8:*/		return 0x820C12F8;
		  /* 820C12F8h */ case    9:  		/* bc 12, CR6_EQ, -452 */
		/* 820C12F8h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C1134;  }
		/* 820C12F8h case    9:*/		return 0x820C12FC;
		  /* 820C12FCh */ case   10:  		/* lwz R9, <#[R17 + 8]> */
		/* 820C12FCh case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0x00000008) );
		/* 820C12FCh case   10:*/		return 0x820C1300;
		  /* 820C1300h */ case   11:  		/* li R10, 0 */
		/* 820C1300h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C1300h case   11:*/		return 0x820C1304;
		  /* 820C1304h */ case   12:  		/* mr R11, R25 */
		/* 820C1304h case   12:*/		regs.R11 = regs.R25;
		/* 820C1304h case   12:*/		return 0x820C1308;
		  /* 820C1308h */ case   13:  		/* lwz R9, <#[R9 + 20]> */
		/* 820C1308h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 820C1308h case   13:*/		return 0x820C130C;
		  /* 820C130Ch */ case   14:  		/* lwz R8, <#[R11]> */
		/* 820C130Ch case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820C130Ch case   14:*/		return 0x820C1310;
		  /* 820C1310h */ case   15:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820C1310h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820C1310h case   15:*/		return 0x820C1314;
		  /* 820C1314h */ case   16:  		/* lwzx R8, <#[R8 + R9]> */
		/* 820C1314h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820C1314h case   16:*/		return 0x820C1318;
		  /* 820C1318h */ case   17:  		/* lwz R8, <#[R8 + 48]> */
		/* 820C1318h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000030) );
		/* 820C1318h case   17:*/		return 0x820C131C;
		  /* 820C131Ch */ case   18:  		/* cmpwi CR6, R8, -1 */
		/* 820C131Ch case   18:*/		cpu::op::cmpwi<6>(regs,regs.R8,0xFFFFFFFF);
		/* 820C131Ch case   18:*/		return 0x820C1320;
		  /* 820C1320h */ case   19:  		/* bc 12, CR6_EQ, -76 */
		/* 820C1320h case   19:*/		if ( regs.CR[6].eq ) { return 0x820C12D4;  }
		/* 820C1320h case   19:*/		return 0x820C1324;
		  /* 820C1324h */ case   20:  		/* addi R10, R10, 1 */
		/* 820C1324h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C1324h case   20:*/		return 0x820C1328;
		  /* 820C1328h */ case   21:  		/* addi R11, R11, 4 */
		/* 820C1328h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820C1328h case   21:*/		return 0x820C132C;
		  /* 820C132Ch */ case   22:  		/* cmplw CR6, R10, R21 */
		/* 820C132Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R21);
		/* 820C132Ch case   22:*/		return 0x820C1330;
		  /* 820C1330h */ case   23:  		/* bc 12, CR6_LT, -36 */
		/* 820C1330h case   23:*/		if ( regs.CR[6].lt ) { return 0x820C130C;  }
		/* 820C1330h case   23:*/		return 0x820C1334;
		  /* 820C1334h */ case   24:  		/* b -168 */
		/* 820C1334h case   24:*/		return 0x820C128C;
		/* 820C1334h case   24:*/		return 0x820C1338;
		  /* 820C1338h */ case   25:  		/* cmplwi CR6, R30, 0 */
		/* 820C1338h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C1338h case   25:*/		return 0x820C133C;
		  /* 820C133Ch */ case   26:  		/* bc 12, CR6_EQ, 6032 */
		/* 820C133Ch case   26:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C133Ch case   26:*/		return 0x820C1340;
		  /* 820C1340h */ case   27:  		/* mr R4, R21 */
		/* 820C1340h case   27:*/		regs.R4 = regs.R21;
		/* 820C1340h case   27:*/		return 0x820C1344;
		  /* 820C1344h */ case   28:  		/* mr R3, R17 */
		/* 820C1344h case   28:*/		regs.R3 = regs.R17;
		/* 820C1344h case   28:*/		return 0x820C1348;
		  /* 820C1348h */ case   29:  		/* bl -68696 */
		/* 820C1348h case   29:*/		regs.LR = 0x820C134C; return 0x820B06F0;
		/* 820C1348h case   29:*/		return 0x820C134C;
		  /* 820C134Ch */ case   30:  		/* or. R8, R3, R3 */
		/* 820C134Ch case   30:*/		cpu::op::or<1>(regs,&regs.R8,regs.R3,regs.R3);
		/* 820C134Ch case   30:*/		return 0x820C1350;
		  /* 820C1350h */ case   31:  		/* bc 12, CR0_EQ, 4884 */
		/* 820C1350h case   31:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C1350h case   31:*/		return 0x820C1354;
		  /* 820C1354h */ case   32:  		/* cmplwi CR6, R21, 0 */
		/* 820C1354h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1354h case   32:*/		return 0x820C1358;
		  /* 820C1358h */ case   33:  		/* bc 12, CR6_EQ, 24 */
		/* 820C1358h case   33:*/		if ( regs.CR[6].eq ) { return 0x820C1370;  }
		/* 820C1358h case   33:*/		return 0x820C135C;
		  /* 820C135Ch */ case   34:  		/* mtspr CTR, R21 */
		/* 820C135Ch case   34:*/		regs.CTR = regs.R21;
		/* 820C135Ch case   34:*/		return 0x820C1360;
		  /* 820C1360h */ case   35:  		/* addi R11, R8, -4 */
		/* 820C1360h case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFC);
		/* 820C1360h case   35:*/		return 0x820C1364;
		  /* 820C1364h */ case   36:  		/* lwz R10, <#[R17 + 32]> */
		/* 820C1364h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000020) );
		/* 820C1364h case   36:*/		return 0x820C1368;
		  /* 820C1368h */ case   37:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1368h case   37:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1368h case   37:*/		return 0x820C136C;
		  /* 820C136Ch */ case   38:  		/* bc 16, CR0_LT, -8 */
		/* 820C136Ch case   38:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1364;  }
		/* 820C136Ch case   38:*/		return 0x820C1370;
	}
	return 0x820C1370;
} // Block from 820C12D4h-820C1370h (39 instructions)

//////////////////////////////////////////////////////
// Block at 820C1370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1370);
		  /* 820C1370h */ case    0:  		/* mr R5, R21 */
		/* 820C1370h case    0:*/		regs.R5 = regs.R21;
		/* 820C1370h case    0:*/		return 0x820C1374;
		  /* 820C1374h */ case    1:  		/* li R11, 129 */
		/* 820C1374h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x81);
		/* 820C1374h case    1:*/		return 0x820C1378;
		  /* 820C1378h */ case    2:  		/* mr R7, R25 */
		/* 820C1378h case    2:*/		regs.R7 = regs.R25;
		/* 820C1378h case    2:*/		return 0x820C137C;
		  /* 820C137Ch */ case    3:  		/* rlwimi R5, R11, 22, 0, 11 */
		/* 820C137Ch case    3:*/		cpu::op::rlwimi<0,22,0,11>(regs,&regs.R5,regs.R11);
		/* 820C137Ch case    3:*/		return 0x820C1380;
		  /* 820C1380h */ case    4:  		/* b -228 */
		/* 820C1380h case    4:*/		return 0x820C129C;
		/* 820C1380h case    4:*/		return 0x820C1384;
		  /* 820C1384h */ case    5:  		/* cmplwi CR6, R30, 0 */
		/* 820C1384h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C1384h case    5:*/		return 0x820C1388;
		  /* 820C1388h */ case    6:  		/* bc 12, CR6_EQ, 5956 */
		/* 820C1388h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1388h case    6:*/		return 0x820C138C;
		  /* 820C138Ch */ case    7:  		/* mr R4, R21 */
		/* 820C138Ch case    7:*/		regs.R4 = regs.R21;
		/* 820C138Ch case    7:*/		return 0x820C1390;
		  /* 820C1390h */ case    8:  		/* mr R3, R17 */
		/* 820C1390h case    8:*/		regs.R3 = regs.R17;
		/* 820C1390h case    8:*/		return 0x820C1394;
		  /* 820C1394h */ case    9:  		/* bl -68772 */
		/* 820C1394h case    9:*/		regs.LR = 0x820C1398; return 0x820B06F0;
		/* 820C1394h case    9:*/		return 0x820C1398;
		  /* 820C1398h */ case   10:  		/* or. R8, R3, R3 */
		/* 820C1398h case   10:*/		cpu::op::or<1>(regs,&regs.R8,regs.R3,regs.R3);
		/* 820C1398h case   10:*/		return 0x820C139C;
		  /* 820C139Ch */ case   11:  		/* bc 12, CR0_EQ, 4808 */
		/* 820C139Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C139Ch case   11:*/		return 0x820C13A0;
		  /* 820C13A0h */ case   12:  		/* cmplwi CR6, R21, 0 */
		/* 820C13A0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C13A0h case   12:*/		return 0x820C13A4;
		  /* 820C13A4h */ case   13:  		/* bc 12, CR6_EQ, -52 */
		/* 820C13A4h case   13:*/		if ( regs.CR[6].eq ) { return 0x820C1370;  }
		/* 820C13A4h case   13:*/		return 0x820C13A8;
		  /* 820C13A8h */ case   14:  		/* mtspr CTR, R21 */
		/* 820C13A8h case   14:*/		regs.CTR = regs.R21;
		/* 820C13A8h case   14:*/		return 0x820C13AC;
		  /* 820C13ACh */ case   15:  		/* addi R11, R8, -4 */
		/* 820C13ACh case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFC);
		/* 820C13ACh case   15:*/		return 0x820C13B0;
		  /* 820C13B0h */ case   16:  		/* lwz R10, <#[R17 + 40]> */
		/* 820C13B0h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000028) );
		/* 820C13B0h case   16:*/		return 0x820C13B4;
		  /* 820C13B4h */ case   17:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C13B4h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C13B4h case   17:*/		return 0x820C13B8;
		  /* 820C13B8h */ case   18:  		/* bc 16, CR0_LT, -8 */
		/* 820C13B8h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C13B0;  }
		/* 820C13B8h case   18:*/		return 0x820C13BC;
		  /* 820C13BCh */ case   19:  		/* b -76 */
		/* 820C13BCh case   19:*/		return 0x820C1370;
		/* 820C13BCh case   19:*/		return 0x820C13C0;
		  /* 820C13C0h */ case   20:  		/* cmplwi CR6, R30, 0 */
		/* 820C13C0h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C13C0h case   20:*/		return 0x820C13C4;
		  /* 820C13C4h */ case   21:  		/* bc 12, CR6_EQ, 5896 */
		/* 820C13C4h case   21:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C13C4h case   21:*/		return 0x820C13C8;
		  /* 820C13C8h */ case   22:  		/* cmplwi CR6, R14, 0 */
		/* 820C13C8h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C13C8h case   22:*/		return 0x820C13CC;
		  /* 820C13CCh */ case   23:  		/* bc 12, CR6_EQ, 5856 */
		/* 820C13CCh case   23:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C13CCh case   23:*/		return 0x820C13D0;
		  /* 820C13D0h */ case   24:  		/* rlwinm R4, R21, 1, 0, 30 */
		/* 820C13D0h case   24:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R4,regs.R21);
		/* 820C13D0h case   24:*/		return 0x820C13D4;
		  /* 820C13D4h */ case   25:  		/* mr R3, R17 */
		/* 820C13D4h case   25:*/		regs.R3 = regs.R17;
		/* 820C13D4h case   25:*/		return 0x820C13D8;
		  /* 820C13D8h */ case   26:  		/* bl -68840 */
		/* 820C13D8h case   26:*/		regs.LR = 0x820C13DC; return 0x820B06F0;
		/* 820C13D8h case   26:*/		return 0x820C13DC;
		  /* 820C13DCh */ case   27:  		/* or. R11, R3, R3 */
		/* 820C13DCh case   27:*/		cpu::op::or<1>(regs,&regs.R11,regs.R3,regs.R3);
		/* 820C13DCh case   27:*/		return 0x820C13E0;
		  /* 820C13E0h */ case   28:  		/* bc 12, CR0_EQ, 4740 */
		/* 820C13E0h case   28:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C13E0h case   28:*/		return 0x820C13E4;
		  /* 820C13E4h */ case   29:  		/* li R10, 2 */
		/* 820C13E4h case   29:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 820C13E4h case   29:*/		return 0x820C13E8;
		  /* 820C13E8h */ case   30:  		/* addi R9, R1, 140 */
		/* 820C13E8h case   30:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x8C);
		/* 820C13E8h case   30:*/		return 0x820C13EC;
		  /* 820C13ECh */ case   31:  		/* rlwinm R8, R21, 2, 0, 29 */
		/* 820C13ECh case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R21);
		/* 820C13ECh case   31:*/		return 0x820C13F0;
		  /* 820C13F0h */ case   32:  		/* mtspr CTR, R10 */
		/* 820C13F0h case   32:*/		regs.CTR = regs.R10;
		/* 820C13F0h case   32:*/		return 0x820C13F4;
		  /* 820C13F4h */ case   33:  		/* stwu R11, <#[R9 + 4]> */
		/* 820C13F4h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C13F4h case   33:*/		return 0x820C13F8;
		  /* 820C13F8h */ case   34:  		/* add R11, R8, R11 */
		/* 820C13F8h case   34:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820C13F8h case   34:*/		return 0x820C13FC;
		  /* 820C13FCh */ case   35:  		/* bc 16, CR0_LT, -8 */
		/* 820C13FCh case   35:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C13F4;  }
		/* 820C13FCh case   35:*/		return 0x820C1400;
		  /* 820C1400h */ case   36:  		/* lwz R29, <#[R1 + 144]> */
		/* 820C1400h case   36:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000090) );
		/* 820C1400h case   36:*/		return 0x820C1404;
		  /* 820C1404h */ case   37:  		/* cmplwi CR6, R21, 0 */
		/* 820C1404h case   37:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1404h case   37:*/		return 0x820C1408;
		  /* 820C1408h */ case   38:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1408h case   38:*/		if ( regs.CR[6].eq ) { return 0x820C1428;  }
		/* 820C1408h case   38:*/		return 0x820C140C;
		  /* 820C140Ch */ case   39:  		/* addi R11, R29, -4 */
		/* 820C140Ch case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFC);
		/* 820C140Ch case   39:*/		return 0x820C1410;
		  /* 820C1410h */ case   40:  		/* mr R10, R22 */
		/* 820C1410h case   40:*/		regs.R10 = regs.R22;
		/* 820C1410h case   40:*/		return 0x820C1414;
		  /* 820C1414h */ case   41:  		/* cmplwi CR0, R21, 0 */
		/* 820C1414h case   41:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1414h case   41:*/		return 0x820C1418;
		  /* 820C1418h */ case   42:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1418h case   42:*/		if ( regs.CR[0].eq ) { return 0x820C1428;  }
		/* 820C1418h case   42:*/		return 0x820C141C;
		  /* 820C141Ch */ case   43:  		/* mtspr CTR, R21 */
		/* 820C141Ch case   43:*/		regs.CTR = regs.R21;
		/* 820C141Ch case   43:*/		return 0x820C1420;
		  /* 820C1420h */ case   44:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1420h case   44:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1420h case   44:*/		return 0x820C1424;
		  /* 820C1424h */ case   45:  		/* bc 16, CR0_LT, -4 */
		/* 820C1424h case   45:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1420;  }
		/* 820C1424h case   45:*/		return 0x820C1428;
	}
	return 0x820C1428;
} // Block from 820C1370h-820C1428h (46 instructions)

//////////////////////////////////////////////////////
// Block at 820C1428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1428);
		  /* 820C1428h */ case    0:  		/* lwz R30, <#[R1 + 148]> */
		/* 820C1428h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000094) );
		/* 820C1428h case    0:*/		return 0x820C142C;
		  /* 820C142Ch */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 820C142Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C142Ch case    1:*/		return 0x820C1430;
		  /* 820C1430h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 820C1430h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C1474;  }
		/* 820C1430h case    2:*/		return 0x820C1434;
		  /* 820C1434h */ case    3:  		/* addi R11, R30, -4 */
		/* 820C1434h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFC);
		/* 820C1434h case    3:*/		return 0x820C1438;
		  /* 820C1438h */ case    4:  		/* mr R10, R22 */
		/* 820C1438h case    4:*/		regs.R10 = regs.R22;
		/* 820C1438h case    4:*/		return 0x820C143C;
		  /* 820C143Ch */ case    5:  		/* cmplwi CR0, R21, 0 */
		/* 820C143Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C143Ch case    5:*/		return 0x820C1440;
		  /* 820C1440h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1440h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C1450;  }
		/* 820C1440h case    6:*/		return 0x820C1444;
		  /* 820C1444h */ case    7:  		/* mtspr CTR, R21 */
		/* 820C1444h case    7:*/		regs.CTR = regs.R21;
		/* 820C1444h case    7:*/		return 0x820C1448;
		  /* 820C1448h */ case    8:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1448h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1448h case    8:*/		return 0x820C144C;
		  /* 820C144Ch */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820C144Ch case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1448;  }
		/* 820C144Ch case    9:*/		return 0x820C1450;
	}
	return 0x820C1450;
} // Block from 820C1428h-820C1450h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C1450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1450);
		  /* 820C1450h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 820C1450h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1450h case    0:*/		return 0x820C1454;
		  /* 820C1454h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1454h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C1474;  }
		/* 820C1454h case    1:*/		return 0x820C1458;
		  /* 820C1458h */ case    2:  		/* addi R11, R14, -4 */
		/* 820C1458h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C1458h case    2:*/		return 0x820C145C;
		  /* 820C145Ch */ case    3:  		/* mr R10, R22 */
		/* 820C145Ch case    3:*/		regs.R10 = regs.R22;
		/* 820C145Ch case    3:*/		return 0x820C1460;
		  /* 820C1460h */ case    4:  		/* cmplwi CR0, R21, 0 */
		/* 820C1460h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1460h case    4:*/		return 0x820C1464;
		  /* 820C1464h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1464h case    5:*/		if ( regs.CR[0].eq ) { return 0x820C1474;  }
		/* 820C1464h case    5:*/		return 0x820C1468;
		  /* 820C1468h */ case    6:  		/* mtspr CTR, R21 */
		/* 820C1468h case    6:*/		regs.CTR = regs.R21;
		/* 820C1468h case    6:*/		return 0x820C146C;
		  /* 820C146Ch */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C146Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C146Ch case    7:*/		return 0x820C1470;
		  /* 820C1470h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820C1470h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C146C;  }
		/* 820C1470h case    8:*/		return 0x820C1474;
	}
	return 0x820C1474;
} // Block from 820C1450h-820C1474h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C1474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1474);
		  /* 820C1474h */ case    0:  		/* mr R8, R21 */
		/* 820C1474h case    0:*/		regs.R8 = regs.R21;
		/* 820C1474h case    0:*/		return 0x820C1478;
		  /* 820C1478h */ case    1:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C1478h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C1478h case    1:*/		return 0x820C147C;
		  /* 820C147Ch */ case    2:  		/* mr R6, R30 */
		/* 820C147Ch case    2:*/		regs.R6 = regs.R30;
		/* 820C147Ch case    2:*/		return 0x820C1480;
		  /* 820C1480h */ case    3:  		/* mr R5, R29 */
		/* 820C1480h case    3:*/		regs.R5 = regs.R29;
		/* 820C1480h case    3:*/		return 0x820C1484;
		  /* 820C1484h */ case    4:  		/* mr R4, R15 */
		/* 820C1484h case    4:*/		regs.R4 = regs.R15;
		/* 820C1484h case    4:*/		return 0x820C1488;
		  /* 820C1488h */ case    5:  		/* mr R3, R17 */
		/* 820C1488h case    5:*/		regs.R3 = regs.R17;
		/* 820C1488h case    5:*/		return 0x820C148C;
		  /* 820C148Ch */ case    6:  		/* bl -53980 */
		/* 820C148Ch case    6:*/		regs.LR = 0x820C1490; return 0x820B41B0;
		/* 820C148Ch case    6:*/		return 0x820C1490;
		  /* 820C1490h */ case    7:  		/* or. R31, R3, R3 */
		/* 820C1490h case    7:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1490h case    7:*/		return 0x820C1494;
		  /* 820C1494h */ case    8:  		/* bc 12, CR0_LT, 5696 */
		/* 820C1494h case    8:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1494h case    8:*/		return 0x820C1498;
		  /* 820C1498h */ case    9:  		/* mr R5, R21 */
		/* 820C1498h case    9:*/		regs.R5 = regs.R21;
		/* 820C1498h case    9:*/		return 0x820C149C;
		  /* 820C149Ch */ case   10:  		/* li R11, 515 */
		/* 820C149Ch case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x203);
		/* 820C149Ch case   10:*/		return 0x820C14A0;
		  /* 820C14A0h */ case   11:  		/* li R9, 23 */
		/* 820C14A0h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C14A0h case   11:*/		return 0x820C14A4;
		  /* 820C14A4h */ case   12:  		/* rlwimi R5, R11, 20, 0, 11 */
		/* 820C14A4h case   12:*/		cpu::op::rlwimi<0,20,0,11>(regs,&regs.R5,regs.R11);
		/* 820C14A4h case   12:*/		return 0x820C14A8;
		  /* 820C14A8h */ case   13:  		/* mr R7, R30 */
		/* 820C14A8h case   13:*/		regs.R7 = regs.R30;
		/* 820C14A8h case   13:*/		return 0x820C14AC;
		  /* 820C14ACh */ case   14:  		/* b 3012 */
		/* 820C14ACh case   14:*/		return 0x820C2070;
		/* 820C14ACh case   14:*/		return 0x820C14B0;
		  /* 820C14B0h */ case   15:  		/* cmplwi CR6, R30, 0 */
		/* 820C14B0h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C14B0h case   15:*/		return 0x820C14B4;
		  /* 820C14B4h */ case   16:  		/* bc 12, CR6_EQ, 5656 */
		/* 820C14B4h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C14B4h case   16:*/		return 0x820C14B8;
		  /* 820C14B8h */ case   17:  		/* cmplwi CR6, R14, 0 */
		/* 820C14B8h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C14B8h case   17:*/		return 0x820C14BC;
		  /* 820C14BCh */ case   18:  		/* bc 12, CR6_EQ, 5616 */
		/* 820C14BCh case   18:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C14BCh case   18:*/		return 0x820C14C0;
		  /* 820C14C0h */ case   19:  		/* cmplwi CR6, R21, 0 */
		/* 820C14C0h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C14C0h case   19:*/		return 0x820C14C4;
		  /* 820C14C4h */ case   20:  		/* bc 12, CR6_EQ, 32 */
		/* 820C14C4h case   20:*/		if ( regs.CR[6].eq ) { return 0x820C14E4;  }
		/* 820C14C4h case   20:*/		return 0x820C14C8;
		  /* 820C14C8h */ case   21:  		/* addi R11, R14, -4 */
		/* 820C14C8h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C14C8h case   21:*/		return 0x820C14CC;
		  /* 820C14CCh */ case   22:  		/* mr R10, R22 */
		/* 820C14CCh case   22:*/		regs.R10 = regs.R22;
		/* 820C14CCh case   22:*/		return 0x820C14D0;
		  /* 820C14D0h */ case   23:  		/* cmplwi CR0, R21, 0 */
		/* 820C14D0h case   23:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C14D0h case   23:*/		return 0x820C14D4;
		  /* 820C14D4h */ case   24:  		/* bc 12, CR0_EQ, 16 */
		/* 820C14D4h case   24:*/		if ( regs.CR[0].eq ) { return 0x820C14E4;  }
		/* 820C14D4h case   24:*/		return 0x820C14D8;
		  /* 820C14D8h */ case   25:  		/* mtspr CTR, R21 */
		/* 820C14D8h case   25:*/		regs.CTR = regs.R21;
		/* 820C14D8h case   25:*/		return 0x820C14DC;
		  /* 820C14DCh */ case   26:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C14DCh case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C14DCh case   26:*/		return 0x820C14E0;
		  /* 820C14E0h */ case   27:  		/* bc 16, CR0_LT, -4 */
		/* 820C14E0h case   27:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C14DC;  }
		/* 820C14E0h case   27:*/		return 0x820C14E4;
	}
	return 0x820C14E4;
} // Block from 820C1474h-820C14E4h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820C14E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C14E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C14E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C14E4);
		  /* 820C14E4h */ case    0:  		/* mr R5, R21 */
		/* 820C14E4h case    0:*/		regs.R5 = regs.R21;
		/* 820C14E4h case    0:*/		return 0x820C14E8;
		  /* 820C14E8h */ case    1:  		/* rlwimi R5, R19, 20, 0, 11 */
		/* 820C14E8h case    1:*/		cpu::op::rlwimi<0,20,0,11>(regs,&regs.R5,regs.R19);
		/* 820C14E8h case    1:*/		return 0x820C14EC;
		  /* 820C14ECh */ case    2:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C14ECh case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C14ECh case    2:*/		return 0x820C14F0;
		  /* 820C14F0h */ case    3:  		/* li R8, 0 */
		/* 820C14F0h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C14F0h case    3:*/		return 0x820C14F4;
		  /* 820C14F4h */ case    4:  		/* li R9, 0 */
		/* 820C14F4h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C14F4h case    4:*/		return 0x820C14F8;
		  /* 820C14F8h */ case    5:  		/* b 2940 */
		/* 820C14F8h case    5:*/		return 0x820C2074;
		/* 820C14F8h case    5:*/		return 0x820C14FC;
		  /* 820C14FCh */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 820C14FCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C14FCh case    6:*/		return 0x820C1500;
		  /* 820C1500h */ case    7:  		/* bc 12, CR6_EQ, 5580 */
		/* 820C1500h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1500h case    7:*/		return 0x820C1504;
		  /* 820C1504h */ case    8:  		/* cmplwi CR6, R14, 0 */
		/* 820C1504h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C1504h case    8:*/		return 0x820C1508;
		  /* 820C1508h */ case    9:  		/* bc 12, CR6_EQ, 5540 */
		/* 820C1508h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C1508h case    9:*/		return 0x820C150C;
		  /* 820C150Ch */ case   10:  		/* cmplwi CR6, R21, 0 */
		/* 820C150Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C150Ch case   10:*/		return 0x820C1510;
		  /* 820C1510h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1510h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C1530;  }
		/* 820C1510h case   11:*/		return 0x820C1514;
		  /* 820C1514h */ case   12:  		/* addi R11, R14, -4 */
		/* 820C1514h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C1514h case   12:*/		return 0x820C1518;
		  /* 820C1518h */ case   13:  		/* mr R10, R22 */
		/* 820C1518h case   13:*/		regs.R10 = regs.R22;
		/* 820C1518h case   13:*/		return 0x820C151C;
		  /* 820C151Ch */ case   14:  		/* cmplwi CR0, R21, 0 */
		/* 820C151Ch case   14:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C151Ch case   14:*/		return 0x820C1520;
		  /* 820C1520h */ case   15:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1520h case   15:*/		if ( regs.CR[0].eq ) { return 0x820C1530;  }
		/* 820C1520h case   15:*/		return 0x820C1524;
		  /* 820C1524h */ case   16:  		/* mtspr CTR, R21 */
		/* 820C1524h case   16:*/		regs.CTR = regs.R21;
		/* 820C1524h case   16:*/		return 0x820C1528;
		  /* 820C1528h */ case   17:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1528h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1528h case   17:*/		return 0x820C152C;
		  /* 820C152Ch */ case   18:  		/* bc 16, CR0_LT, -4 */
		/* 820C152Ch case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1528;  }
		/* 820C152Ch case   18:*/		return 0x820C1530;
	}
	return 0x820C1530;
} // Block from 820C14E4h-820C1530h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820C1530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1530);
		  /* 820C1530h */ case    0:  		/* mr R5, R21 */
		/* 820C1530h case    0:*/		regs.R5 = regs.R21;
		/* 820C1530h case    0:*/		return 0x820C1534;
		  /* 820C1534h */ case    1:  		/* rlwimi R5, R20, 28, 0, 11 */
		/* 820C1534h case    1:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R5,regs.R20);
		/* 820C1534h case    1:*/		return 0x820C1538;
		  /* 820C1538h */ case    2:  		/* b -76 */
		/* 820C1538h case    2:*/		return 0x820C14EC;
		/* 820C1538h case    2:*/		return 0x820C153C;
		  /* 820C153Ch */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 820C153Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C153Ch case    3:*/		return 0x820C1540;
		  /* 820C1540h */ case    4:  		/* bc 12, CR6_EQ, 5516 */
		/* 820C1540h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1540h case    4:*/		return 0x820C1544;
		  /* 820C1544h */ case    5:  		/* cmplwi CR6, R28, 0 */
		/* 820C1544h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1544h case    5:*/		return 0x820C1548;
		  /* 820C1548h */ case    6:  		/* bc 12, CR6_EQ, 5508 */
		/* 820C1548h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1548h case    6:*/		return 0x820C154C;
		  /* 820C154Ch */ case    7:  		/* cmplwi CR6, R14, 0 */
		/* 820C154Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C154Ch case    7:*/		return 0x820C1550;
		  /* 820C1550h */ case    8:  		/* bc 12, CR6_EQ, 5468 */
		/* 820C1550h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C1550h case    8:*/		return 0x820C1554;
		  /* 820C1554h */ case    9:  		/* cmplwi CR6, R21, 0 */
		/* 820C1554h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1554h case    9:*/		return 0x820C1558;
		  /* 820C1558h */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1558h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C1578;  }
		/* 820C1558h case   10:*/		return 0x820C155C;
		  /* 820C155Ch */ case   11:  		/* addi R11, R14, -4 */
		/* 820C155Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C155Ch case   11:*/		return 0x820C1560;
		  /* 820C1560h */ case   12:  		/* mr R10, R22 */
		/* 820C1560h case   12:*/		regs.R10 = regs.R22;
		/* 820C1560h case   12:*/		return 0x820C1564;
		  /* 820C1564h */ case   13:  		/* cmplwi CR0, R21, 0 */
		/* 820C1564h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1564h case   13:*/		return 0x820C1568;
		  /* 820C1568h */ case   14:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1568h case   14:*/		if ( regs.CR[0].eq ) { return 0x820C1578;  }
		/* 820C1568h case   14:*/		return 0x820C156C;
		  /* 820C156Ch */ case   15:  		/* mtspr CTR, R21 */
		/* 820C156Ch case   15:*/		regs.CTR = regs.R21;
		/* 820C156Ch case   15:*/		return 0x820C1570;
		  /* 820C1570h */ case   16:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1570h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1570h case   16:*/		return 0x820C1574;
		  /* 820C1574h */ case   17:  		/* bc 16, CR0_LT, -4 */
		/* 820C1574h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1570;  }
		/* 820C1574h case   17:*/		return 0x820C1578;
	}
	return 0x820C1578;
} // Block from 820C1530h-820C1578h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820C1578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1578);
		  /* 820C1578h */ case    0:  		/* mr R5, R21 */
		/* 820C1578h case    0:*/		regs.R5 = regs.R21;
		/* 820C1578h case    0:*/		return 0x820C157C;
		  /* 820C157Ch */ case    1:  		/* lwz R8, <#[R1 + 132]> */
		/* 820C157Ch case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000084) );
		/* 820C157Ch case    1:*/		return 0x820C1580;
		  /* 820C1580h */ case    2:  		/* li R11, 129 */
		/* 820C1580h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x81);
		/* 820C1580h case    2:*/		return 0x820C1584;
		  /* 820C1584h */ case    3:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C1584h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C1584h case    3:*/		return 0x820C1588;
		  /* 820C1588h */ case    4:  		/* rlwimi R5, R11, 22, 0, 11 */
		/* 820C1588h case    4:*/		cpu::op::rlwimi<0,22,0,11>(regs,&regs.R5,regs.R11);
		/* 820C1588h case    4:*/		return 0x820C158C;
		  /* 820C158Ch */ case    5:  		/* b -152 */
		/* 820C158Ch case    5:*/		return 0x820C14F4;
		/* 820C158Ch case    5:*/		return 0x820C1590;
		  /* 820C1590h */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 820C1590h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C1590h case    6:*/		return 0x820C1594;
		  /* 820C1594h */ case    7:  		/* bc 12, CR6_EQ, 5432 */
		/* 820C1594h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1594h case    7:*/		return 0x820C1598;
		  /* 820C1598h */ case    8:  		/* cmplwi CR6, R28, 0 */
		/* 820C1598h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1598h case    8:*/		return 0x820C159C;
		  /* 820C159Ch */ case    9:  		/* bc 12, CR6_EQ, 5424 */
		/* 820C159Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C159Ch case    9:*/		return 0x820C15A0;
		  /* 820C15A0h */ case   10:  		/* cmplwi CR6, R14, 0 */
		/* 820C15A0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C15A0h case   10:*/		return 0x820C15A4;
		  /* 820C15A4h */ case   11:  		/* bc 12, CR6_EQ, 5384 */
		/* 820C15A4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C15A4h case   11:*/		return 0x820C15A8;
		  /* 820C15A8h */ case   12:  		/* mr R4, R21 */
		/* 820C15A8h case   12:*/		regs.R4 = regs.R21;
		/* 820C15A8h case   12:*/		return 0x820C15AC;
		  /* 820C15ACh */ case   13:  		/* mr R3, R17 */
		/* 820C15ACh case   13:*/		regs.R3 = regs.R17;
		/* 820C15ACh case   13:*/		return 0x820C15B0;
		  /* 820C15B0h */ case   14:  		/* bl -69312 */
		/* 820C15B0h case   14:*/		regs.LR = 0x820C15B4; return 0x820B06F0;
		/* 820C15B0h case   14:*/		return 0x820C15B4;
		  /* 820C15B4h */ case   15:  		/* or. R29, R3, R3 */
		/* 820C15B4h case   15:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C15B4h case   15:*/		return 0x820C15B8;
		  /* 820C15B8h */ case   16:  		/* bc 12, CR0_EQ, 4268 */
		/* 820C15B8h case   16:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C15B8h case   16:*/		return 0x820C15BC;
		  /* 820C15BCh */ case   17:  		/* cmplwi CR6, R21, 0 */
		/* 820C15BCh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C15BCh case   17:*/		return 0x820C15C0;
		  /* 820C15C0h */ case   18:  		/* bc 12, CR6_EQ, 68 */
		/* 820C15C0h case   18:*/		if ( regs.CR[6].eq ) { return 0x820C1604;  }
		/* 820C15C0h case   18:*/		return 0x820C15C4;
		  /* 820C15C4h */ case   19:  		/* addi R11, R29, -4 */
		/* 820C15C4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFC);
		/* 820C15C4h case   19:*/		return 0x820C15C8;
		  /* 820C15C8h */ case   20:  		/* mr R10, R22 */
		/* 820C15C8h case   20:*/		regs.R10 = regs.R22;
		/* 820C15C8h case   20:*/		return 0x820C15CC;
		  /* 820C15CCh */ case   21:  		/* cmplwi CR0, R21, 0 */
		/* 820C15CCh case   21:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C15CCh case   21:*/		return 0x820C15D0;
		  /* 820C15D0h */ case   22:  		/* bc 12, CR0_EQ, 16 */
		/* 820C15D0h case   22:*/		if ( regs.CR[0].eq ) { return 0x820C15E0;  }
		/* 820C15D0h case   22:*/		return 0x820C15D4;
		  /* 820C15D4h */ case   23:  		/* mtspr CTR, R21 */
		/* 820C15D4h case   23:*/		regs.CTR = regs.R21;
		/* 820C15D4h case   23:*/		return 0x820C15D8;
		  /* 820C15D8h */ case   24:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C15D8h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C15D8h case   24:*/		return 0x820C15DC;
		  /* 820C15DCh */ case   25:  		/* bc 16, CR0_LT, -4 */
		/* 820C15DCh case   25:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C15D8;  }
		/* 820C15DCh case   25:*/		return 0x820C15E0;
	}
	return 0x820C15E0;
} // Block from 820C1578h-820C15E0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820C15E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C15E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C15E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C15E0);
		  /* 820C15E0h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 820C15E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C15E0h case    0:*/		return 0x820C15E4;
		  /* 820C15E4h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820C15E4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C1604;  }
		/* 820C15E4h case    1:*/		return 0x820C15E8;
		  /* 820C15E8h */ case    2:  		/* addi R11, R14, -4 */
		/* 820C15E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C15E8h case    2:*/		return 0x820C15EC;
		  /* 820C15ECh */ case    3:  		/* mr R10, R22 */
		/* 820C15ECh case    3:*/		regs.R10 = regs.R22;
		/* 820C15ECh case    3:*/		return 0x820C15F0;
		  /* 820C15F0h */ case    4:  		/* cmplwi CR0, R21, 0 */
		/* 820C15F0h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C15F0h case    4:*/		return 0x820C15F4;
		  /* 820C15F4h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820C15F4h case    5:*/		if ( regs.CR[0].eq ) { return 0x820C1604;  }
		/* 820C15F4h case    5:*/		return 0x820C15F8;
		  /* 820C15F8h */ case    6:  		/* mtspr CTR, R21 */
		/* 820C15F8h case    6:*/		regs.CTR = regs.R21;
		/* 820C15F8h case    6:*/		return 0x820C15FC;
		  /* 820C15FCh */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C15FCh case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C15FCh case    7:*/		return 0x820C1600;
		  /* 820C1600h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820C1600h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C15FC;  }
		/* 820C1600h case    8:*/		return 0x820C1604;
	}
	return 0x820C1604;
} // Block from 820C15E0h-820C1604h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C1604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1604);
		  /* 820C1604h */ case    0:  		/* rlwinm R30, R21, 0, 12, 31 */
		/* 820C1604h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R21);
		/* 820C1604h case    0:*/		return 0x820C1608;
		  /* 820C1608h */ case    1:  		/* lwz R7, <#[R1 + 132]> */
		/* 820C1608h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000084) );
		/* 820C1608h case    1:*/		return 0x820C160C;
		  /* 820C160Ch */ case    2:  		/* li R9, 0 */
		/* 820C160Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C160Ch case    2:*/		return 0x820C1610;
		  /* 820C1610h */ case    3:  		/* li R8, 0 */
		/* 820C1610h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C1610h case    3:*/		return 0x820C1614;
		  /* 820C1614h */ case    4:  		/* mr R6, R29 */
		/* 820C1614h case    4:*/		regs.R6 = regs.R29;
		/* 820C1614h case    4:*/		return 0x820C1618;
		  /* 820C1618h */ case    5:  		/* oris R5, R30, 4112 */
		/* 820C1618h case    5:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1010);
		/* 820C1618h case    5:*/		return 0x820C161C;
		  /* 820C161Ch */ case    6:  		/* mr R4, R15 */
		/* 820C161Ch case    6:*/		regs.R4 = regs.R15;
		/* 820C161Ch case    6:*/		return 0x820C1620;
		  /* 820C1620h */ case    7:  		/* mr R3, R17 */
		/* 820C1620h case    7:*/		regs.R3 = regs.R17;
		/* 820C1620h case    7:*/		return 0x820C1624;
		  /* 820C1624h */ case    8:  		/* bl -68380 */
		/* 820C1624h case    8:*/		regs.LR = 0x820C1628; return 0x820B0B08;
		/* 820C1624h case    8:*/		return 0x820C1628;
		  /* 820C1628h */ case    9:  		/* or. R31, R3, R3 */
		/* 820C1628h case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1628h case    9:*/		return 0x820C162C;
		  /* 820C162Ch */ case   10:  		/* bc 12, CR0_LT, 5288 */
		/* 820C162Ch case   10:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C162Ch case   10:*/		return 0x820C1630;
		  /* 820C1630h */ case   11:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C1630h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C1630h case   11:*/		return 0x820C1634;
		  /* 820C1634h */ case   12:  		/* oris R5, R30, 8256 */
		/* 820C1634h case   12:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2040);
		/* 820C1634h case   12:*/		return 0x820C1638;
		  /* 820C1638h */ case   13:  		/* b 2612 */
		/* 820C1638h case   13:*/		return 0x820C206C;
		/* 820C1638h case   13:*/		return 0x820C163C;
		  /* 820C163Ch */ case   14:  		/* cmplwi CR6, R30, 0 */
		/* 820C163Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C163Ch case   14:*/		return 0x820C1640;
		  /* 820C1640h */ case   15:  		/* bc 12, CR6_EQ, 5260 */
		/* 820C1640h case   15:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1640h case   15:*/		return 0x820C1644;
		  /* 820C1644h */ case   16:  		/* cmplwi CR6, R28, 0 */
		/* 820C1644h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1644h case   16:*/		return 0x820C1648;
		  /* 820C1648h */ case   17:  		/* bc 12, CR6_EQ, 5252 */
		/* 820C1648h case   17:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1648h case   17:*/		return 0x820C164C;
		  /* 820C164Ch */ case   18:  		/* cmplwi CR6, R14, 0 */
		/* 820C164Ch case   18:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C164Ch case   18:*/		return 0x820C1650;
		  /* 820C1650h */ case   19:  		/* bc 12, CR6_EQ, 5212 */
		/* 820C1650h case   19:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C1650h case   19:*/		return 0x820C1654;
		  /* 820C1654h */ case   20:  		/* cmplwi CR6, R21, 0 */
		/* 820C1654h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1654h case   20:*/		return 0x820C1658;
		  /* 820C1658h */ case   21:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1658h case   21:*/		if ( regs.CR[6].eq ) { return 0x820C1678;  }
		/* 820C1658h case   21:*/		return 0x820C165C;
		  /* 820C165Ch */ case   22:  		/* addi R11, R14, -4 */
		/* 820C165Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C165Ch case   22:*/		return 0x820C1660;
		  /* 820C1660h */ case   23:  		/* mr R10, R22 */
		/* 820C1660h case   23:*/		regs.R10 = regs.R22;
		/* 820C1660h case   23:*/		return 0x820C1664;
		  /* 820C1664h */ case   24:  		/* cmplwi CR0, R21, 0 */
		/* 820C1664h case   24:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1664h case   24:*/		return 0x820C1668;
		  /* 820C1668h */ case   25:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1668h case   25:*/		if ( regs.CR[0].eq ) { return 0x820C1678;  }
		/* 820C1668h case   25:*/		return 0x820C166C;
		  /* 820C166Ch */ case   26:  		/* mtspr CTR, R21 */
		/* 820C166Ch case   26:*/		regs.CTR = regs.R21;
		/* 820C166Ch case   26:*/		return 0x820C1670;
		  /* 820C1670h */ case   27:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1670h case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1670h case   27:*/		return 0x820C1674;
		  /* 820C1674h */ case   28:  		/* bc 16, CR0_LT, -4 */
		/* 820C1674h case   28:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1670;  }
		/* 820C1674h case   28:*/		return 0x820C1678;
	}
	return 0x820C1678;
} // Block from 820C1604h-820C1678h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820C1678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1678);
		  /* 820C1678h */ case    0:  		/* lwz R8, <#[R1 + 132]> */
		/* 820C1678h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000084) );
		/* 820C1678h case    0:*/		return 0x820C167C;
		  /* 820C167Ch */ case    1:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C167Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C167Ch case    1:*/		return 0x820C1680;
		  /* 820C1680h */ case    2:  		/* mr R5, R21 */
		/* 820C1680h case    2:*/		regs.R5 = regs.R21;
		/* 820C1680h case    2:*/		return 0x820C1684;
		  /* 820C1684h */ case    3:  		/* li R9, 23 */
		/* 820C1684h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C1684h case    3:*/		return 0x820C1688;
		  /* 820C1688h */ case    4:  		/* rlwimi R5, R19, 21, 0, 11 */
		/* 820C1688h case    4:*/		cpu::op::rlwimi<0,21,0,11>(regs,&regs.R5,regs.R19);
		/* 820C1688h case    4:*/		return 0x820C168C;
		  /* 820C168Ch */ case    5:  		/* b 2536 */
		/* 820C168Ch case    5:*/		return 0x820C2074;
		/* 820C168Ch case    5:*/		return 0x820C1690;
		  /* 820C1690h */ case    6:  		/* cmplwi CR6, R30, 0 */
		/* 820C1690h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C1690h case    6:*/		return 0x820C1694;
		  /* 820C1694h */ case    7:  		/* bc 12, CR6_EQ, 5176 */
		/* 820C1694h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1694h case    7:*/		return 0x820C1698;
		  /* 820C1698h */ case    8:  		/* cmplwi CR6, R28, 0 */
		/* 820C1698h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1698h case    8:*/		return 0x820C169C;
		  /* 820C169Ch */ case    9:  		/* bc 12, CR6_EQ, 5168 */
		/* 820C169Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C169Ch case    9:*/		return 0x820C16A0;
		  /* 820C16A0h */ case   10:  		/* cmplwi CR6, R14, 0 */
		/* 820C16A0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C16A0h case   10:*/		return 0x820C16A4;
		  /* 820C16A4h */ case   11:  		/* bc 12, CR6_EQ, 5128 */
		/* 820C16A4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C16A4h case   11:*/		return 0x820C16A8;
		  /* 820C16A8h */ case   12:  		/* cmplwi CR6, R21, 0 */
		/* 820C16A8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C16A8h case   12:*/		return 0x820C16AC;
		  /* 820C16ACh */ case   13:  		/* bc 12, CR6_EQ, 32 */
		/* 820C16ACh case   13:*/		if ( regs.CR[6].eq ) { return 0x820C16CC;  }
		/* 820C16ACh case   13:*/		return 0x820C16B0;
		  /* 820C16B0h */ case   14:  		/* addi R11, R14, -4 */
		/* 820C16B0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C16B0h case   14:*/		return 0x820C16B4;
		  /* 820C16B4h */ case   15:  		/* mr R10, R22 */
		/* 820C16B4h case   15:*/		regs.R10 = regs.R22;
		/* 820C16B4h case   15:*/		return 0x820C16B8;
		  /* 820C16B8h */ case   16:  		/* cmplwi CR0, R21, 0 */
		/* 820C16B8h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C16B8h case   16:*/		return 0x820C16BC;
		  /* 820C16BCh */ case   17:  		/* bc 12, CR0_EQ, 16 */
		/* 820C16BCh case   17:*/		if ( regs.CR[0].eq ) { return 0x820C16CC;  }
		/* 820C16BCh case   17:*/		return 0x820C16C0;
		  /* 820C16C0h */ case   18:  		/* mtspr CTR, R21 */
		/* 820C16C0h case   18:*/		regs.CTR = regs.R21;
		/* 820C16C0h case   18:*/		return 0x820C16C4;
		  /* 820C16C4h */ case   19:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C16C4h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C16C4h case   19:*/		return 0x820C16C8;
		  /* 820C16C8h */ case   20:  		/* bc 16, CR0_LT, -4 */
		/* 820C16C8h case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C16C4;  }
		/* 820C16C8h case   20:*/		return 0x820C16CC;
	}
	return 0x820C16CC;
} // Block from 820C1678h-820C16CCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C16CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C16CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C16CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C16CC);
		  /* 820C16CCh */ case    0:  		/* lwz R8, <#[R1 + 128]> */
		/* 820C16CCh case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000080) );
		/* 820C16CCh case    0:*/		return 0x820C16D0;
		  /* 820C16D0h */ case    1:  		/* lwz R7, <#[R1 + 132]> */
		/* 820C16D0h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000084) );
		/* 820C16D0h case    1:*/		return 0x820C16D4;
		  /* 820C16D4h */ case    2:  		/* b -84 */
		/* 820C16D4h case    2:*/		return 0x820C1680;
		/* 820C16D4h case    2:*/		return 0x820C16D8;
		  /* 820C16D8h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 820C16D8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C16D8h case    3:*/		return 0x820C16DC;
		  /* 820C16DCh */ case    4:  		/* bc 12, CR6_EQ, 5104 */
		/* 820C16DCh case    4:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C16DCh case    4:*/		return 0x820C16E0;
		  /* 820C16E0h */ case    5:  		/* cmplwi CR6, R28, 0 */
		/* 820C16E0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C16E0h case    5:*/		return 0x820C16E4;
		  /* 820C16E4h */ case    6:  		/* bc 12, CR6_EQ, 5096 */
		/* 820C16E4h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C16E4h case    6:*/		return 0x820C16E8;
		  /* 820C16E8h */ case    7:  		/* cmplwi CR6, R14, 0 */
		/* 820C16E8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C16E8h case    7:*/		return 0x820C16EC;
		  /* 820C16ECh */ case    8:  		/* bc 12, CR6_EQ, 5056 */
		/* 820C16ECh case    8:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C16ECh case    8:*/		return 0x820C16F0;
		  /* 820C16F0h */ case    9:  		/* cmplwi CR6, R21, 0 */
		/* 820C16F0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C16F0h case    9:*/		return 0x820C16F4;
		  /* 820C16F4h */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 820C16F4h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C1714;  }
		/* 820C16F4h case   10:*/		return 0x820C16F8;
		  /* 820C16F8h */ case   11:  		/* addi R11, R14, -4 */
		/* 820C16F8h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C16F8h case   11:*/		return 0x820C16FC;
		  /* 820C16FCh */ case   12:  		/* mr R10, R22 */
		/* 820C16FCh case   12:*/		regs.R10 = regs.R22;
		/* 820C16FCh case   12:*/		return 0x820C1700;
		  /* 820C1700h */ case   13:  		/* cmplwi CR0, R21, 0 */
		/* 820C1700h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1700h case   13:*/		return 0x820C1704;
		  /* 820C1704h */ case   14:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1704h case   14:*/		if ( regs.CR[0].eq ) { return 0x820C1714;  }
		/* 820C1704h case   14:*/		return 0x820C1708;
		  /* 820C1708h */ case   15:  		/* mtspr CTR, R21 */
		/* 820C1708h case   15:*/		regs.CTR = regs.R21;
		/* 820C1708h case   15:*/		return 0x820C170C;
		  /* 820C170Ch */ case   16:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C170Ch case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C170Ch case   16:*/		return 0x820C1710;
		  /* 820C1710h */ case   17:  		/* bc 16, CR0_LT, -4 */
		/* 820C1710h case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C170C;  }
		/* 820C1710h case   17:*/		return 0x820C1714;
	}
	return 0x820C1714;
} // Block from 820C16CCh-820C1714h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820C1714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1714);
		  /* 820C1714h */ case    0:  		/* lwz R8, <#[R1 + 128]> */
		/* 820C1714h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000080) );
		/* 820C1714h case    0:*/		return 0x820C1718;
		  /* 820C1718h */ case    1:  		/* lwz R7, <#[R1 + 132]> */
		/* 820C1718h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000084) );
		/* 820C1718h case    1:*/		return 0x820C171C;
		  /* 820C171Ch */ case    2:  		/* li R11, 515 */
		/* 820C171Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x203);
		/* 820C171Ch case    2:*/		return 0x820C1720;
		  /* 820C1720h */ case    3:  		/* li R9, 23 */
		/* 820C1720h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C1720h case    3:*/		return 0x820C1724;
		  /* 820C1724h */ case    4:  		/* mr R5, R21 */
		/* 820C1724h case    4:*/		regs.R5 = regs.R21;
		/* 820C1724h case    4:*/		return 0x820C1728;
		  /* 820C1728h */ case    5:  		/* rlwimi R5, R11, 20, 0, 11 */
		/* 820C1728h case    5:*/		cpu::op::rlwimi<0,20,0,11>(regs,&regs.R5,regs.R11);
		/* 820C1728h case    5:*/		return 0x820C172C;
		  /* 820C172Ch */ case    6:  		/* b 2376 */
		/* 820C172Ch case    6:*/		return 0x820C2074;
		/* 820C172Ch case    6:*/		return 0x820C1730;
		  /* 820C1730h */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 820C1730h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C1730h case    7:*/		return 0x820C1734;
		  /* 820C1734h */ case    8:  		/* bc 12, CR6_EQ, 5016 */
		/* 820C1734h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1734h case    8:*/		return 0x820C1738;
		  /* 820C1738h */ case    9:  		/* cmplwi CR6, R28, 0 */
		/* 820C1738h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1738h case    9:*/		return 0x820C173C;
		  /* 820C173Ch */ case   10:  		/* bc 12, CR6_EQ, 5008 */
		/* 820C173Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C173Ch case   10:*/		return 0x820C1740;
		  /* 820C1740h */ case   11:  		/* cmplwi CR6, R14, 0 */
		/* 820C1740h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C1740h case   11:*/		return 0x820C1744;
		  /* 820C1744h */ case   12:  		/* bc 12, CR6_EQ, 4968 */
		/* 820C1744h case   12:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C1744h case   12:*/		return 0x820C1748;
		  /* 820C1748h */ case   13:  		/* cmplwi CR6, R21, 0 */
		/* 820C1748h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1748h case   13:*/		return 0x820C174C;
		  /* 820C174Ch */ case   14:  		/* bc 12, CR6_EQ, 32 */
		/* 820C174Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x820C176C;  }
		/* 820C174Ch case   14:*/		return 0x820C1750;
		  /* 820C1750h */ case   15:  		/* addi R11, R14, -4 */
		/* 820C1750h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C1750h case   15:*/		return 0x820C1754;
		  /* 820C1754h */ case   16:  		/* mr R10, R22 */
		/* 820C1754h case   16:*/		regs.R10 = regs.R22;
		/* 820C1754h case   16:*/		return 0x820C1758;
		  /* 820C1758h */ case   17:  		/* cmplwi CR0, R21, 0 */
		/* 820C1758h case   17:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1758h case   17:*/		return 0x820C175C;
		  /* 820C175Ch */ case   18:  		/* bc 12, CR0_EQ, 16 */
		/* 820C175Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x820C176C;  }
		/* 820C175Ch case   18:*/		return 0x820C1760;
		  /* 820C1760h */ case   19:  		/* mtspr CTR, R21 */
		/* 820C1760h case   19:*/		regs.CTR = regs.R21;
		/* 820C1760h case   19:*/		return 0x820C1764;
		  /* 820C1764h */ case   20:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1764h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1764h case   20:*/		return 0x820C1768;
		  /* 820C1768h */ case   21:  		/* bc 16, CR0_LT, -4 */
		/* 820C1768h case   21:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1764;  }
		/* 820C1768h case   21:*/		return 0x820C176C;
	}
	return 0x820C176C;
} // Block from 820C1714h-820C176Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C176Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C176C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C176C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C176C);
		  /* 820C176Ch */ case    0:  		/* lwz R8, <#[R1 + 132]> */
		/* 820C176Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000084) );
		/* 820C176Ch case    0:*/		return 0x820C1770;
		  /* 820C1770h */ case    1:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C1770h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C1770h case    1:*/		return 0x820C1774;
		  /* 820C1774h */ case    2:  		/* b -88 */
		/* 820C1774h case    2:*/		return 0x820C171C;
		/* 820C1774h case    2:*/		return 0x820C1778;
		  /* 820C1778h */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 820C1778h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C1778h case    3:*/		return 0x820C177C;
		  /* 820C177Ch */ case    4:  		/* bc 12, CR6_EQ, 4944 */
		/* 820C177Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C177Ch case    4:*/		return 0x820C1780;
		  /* 820C1780h */ case    5:  		/* cmplwi CR6, R28, 0 */
		/* 820C1780h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1780h case    5:*/		return 0x820C1784;
		  /* 820C1784h */ case    6:  		/* bc 12, CR6_EQ, 4936 */
		/* 820C1784h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1784h case    6:*/		return 0x820C1788;
		  /* 820C1788h */ case    7:  		/* cmplwi CR6, R14, 0 */
		/* 820C1788h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C1788h case    7:*/		return 0x820C178C;
		  /* 820C178Ch */ case    8:  		/* bc 12, CR6_EQ, 4896 */
		/* 820C178Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C178Ch case    8:*/		return 0x820C1790;
		  /* 820C1790h */ case    9:  		/* rlwinm R31, R21, 2, 0, 29 */
		/* 820C1790h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R21);
		/* 820C1790h case    9:*/		return 0x820C1794;
		  /* 820C1794h */ case   10:  		/* mr R3, R17 */
		/* 820C1794h case   10:*/		regs.R3 = regs.R17;
		/* 820C1794h case   10:*/		return 0x820C1798;
		  /* 820C1798h */ case   11:  		/* mr R4, R31 */
		/* 820C1798h case   11:*/		regs.R4 = regs.R31;
		/* 820C1798h case   11:*/		return 0x820C179C;
		  /* 820C179Ch */ case   12:  		/* bl -69804 */
		/* 820C179Ch case   12:*/		regs.LR = 0x820C17A0; return 0x820B06F0;
		/* 820C179Ch case   12:*/		return 0x820C17A0;
		  /* 820C17A0h */ case   13:  		/* cmplwi CR0, R3, 0 */
		/* 820C17A0h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C17A0h case   13:*/		return 0x820C17A4;
		  /* 820C17A4h */ case   14:  		/* bc 12, CR0_EQ, 3776 */
		/* 820C17A4h case   14:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C17A4h case   14:*/		return 0x820C17A8;
	}
	return 0x820C17A8;
} // Block from 820C176Ch-820C17A8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C17A8h
// Function '?EmitProgram@CCompiler@D3DXShader@@IAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C17A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C17A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C17A8);
		  /* 820C17A8h */ case    0:  		/* li R9, 4 */
		/* 820C17A8h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820C17A8h case    0:*/		return 0x820C17AC;
		  /* 820C17ACh */ case    1:  		/* addi R10, R1, 140 */
		/* 820C17ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x8C);
		/* 820C17ACh case    1:*/		return 0x820C17B0;
		  /* 820C17B0h */ case    2:  		/* mr R11, R3 */
		/* 820C17B0h case    2:*/		regs.R11 = regs.R3;
		/* 820C17B0h case    2:*/		return 0x820C17B4;
		  /* 820C17B4h */ case    3:  		/* mtspr CTR, R9 */
		/* 820C17B4h case    3:*/		regs.CTR = regs.R9;
		/* 820C17B4h case    3:*/		return 0x820C17B8;
		  /* 820C17B8h */ case    4:  		/* stwu R11, <#[R10 + 4]> */
		/* 820C17B8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C17B8h case    4:*/		return 0x820C17BC;
		  /* 820C17BCh */ case    5:  		/* add R11, R31, R11 */
		/* 820C17BCh case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820C17BCh case    5:*/		return 0x820C17C0;
		  /* 820C17C0h */ case    6:  		/* bc 16, CR0_LT, -8 */
		/* 820C17C0h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C17B8;  }
		/* 820C17C0h case    6:*/		return 0x820C17C4;
		  /* 820C17C4h */ case    7:  		/* li R11, 0 */
		/* 820C17C4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C17C4h case    7:*/		return 0x820C17C8;
		  /* 820C17C8h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 820C17C8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C17C8h case    8:*/		return 0x820C17CC;
		  /* 820C17CCh */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 820C17CCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820C17E4;  }
		/* 820C17CCh case    9:*/		return 0x820C17D0;
		  /* 820C17D0h */ case   10:  		/* addi R10, R3, -4 */
		/* 820C17D0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0xFFFFFFFC);
		/* 820C17D0h case   10:*/		return 0x820C17D4;
		  /* 820C17D4h */ case   11:  		/* addi R11, R11, 1 */
		/* 820C17D4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C17D4h case   11:*/		return 0x820C17D8;
		  /* 820C17D8h */ case   12:  		/* stwu R22, <#[R10 + 4]> */
		/* 820C17D8h case   12:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C17D8h case   12:*/		return 0x820C17DC;
		  /* 820C17DCh */ case   13:  		/* cmplw CR6, R11, R31 */
		/* 820C17DCh case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820C17DCh case   13:*/		return 0x820C17E0;
		  /* 820C17E0h */ case   14:  		/* bc 12, CR6_LT, -12 */
		/* 820C17E0h case   14:*/		if ( regs.CR[6].lt ) { return 0x820C17D4;  }
		/* 820C17E0h case   14:*/		return 0x820C17E4;
	}
	return 0x820C17E4;
} // Block from 820C17A8h-820C17E4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C17E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C17E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C17E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C17E4);
		  /* 820C17E4h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 820C17E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C17E4h case    0:*/		return 0x820C17E8;
		  /* 820C17E8h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820C17E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C1808;  }
		/* 820C17E8h case    1:*/		return 0x820C17EC;
		  /* 820C17ECh */ case    2:  		/* addi R11, R14, -4 */
		/* 820C17ECh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C17ECh case    2:*/		return 0x820C17F0;
		  /* 820C17F0h */ case    3:  		/* mr R10, R22 */
		/* 820C17F0h case    3:*/		regs.R10 = regs.R22;
		/* 820C17F0h case    3:*/		return 0x820C17F4;
		  /* 820C17F4h */ case    4:  		/* cmplwi CR0, R21, 0 */
		/* 820C17F4h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C17F4h case    4:*/		return 0x820C17F8;
		  /* 820C17F8h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820C17F8h case    5:*/		if ( regs.CR[0].eq ) { return 0x820C1808;  }
		/* 820C17F8h case    5:*/		return 0x820C17FC;
		  /* 820C17FCh */ case    6:  		/* mtspr CTR, R21 */
		/* 820C17FCh case    6:*/		regs.CTR = regs.R21;
		/* 820C17FCh case    6:*/		return 0x820C1800;
		  /* 820C1800h */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1800h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1800h case    7:*/		return 0x820C1804;
		  /* 820C1804h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820C1804h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1800;  }
		/* 820C1804h case    8:*/		return 0x820C1808;
	}
	return 0x820C1808;
} // Block from 820C17E4h-820C1808h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C1808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1808);
		  /* 820C1808h */ case    0:  		/* lwz R29, <#[R1 + 144]> */
		/* 820C1808h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000090) );
		/* 820C1808h case    0:*/		return 0x820C180C;
		  /* 820C180Ch */ case    1:  		/* rlwinm R30, R21, 0, 12, 31 */
		/* 820C180Ch case    1:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R21);
		/* 820C180Ch case    1:*/		return 0x820C1810;
		  /* 820C1810h */ case    2:  		/* li R9, 0 */
		/* 820C1810h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C1810h case    2:*/		return 0x820C1814;
		  /* 820C1814h */ case    3:  		/* lwz R7, <#[R1 + 132]> */
		/* 820C1814h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000084) );
		/* 820C1814h case    3:*/		return 0x820C1818;
		  /* 820C1818h */ case    4:  		/* li R8, 0 */
		/* 820C1818h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C1818h case    4:*/		return 0x820C181C;
		  /* 820C181Ch */ case    5:  		/* mr R6, R29 */
		/* 820C181Ch case    5:*/		regs.R6 = regs.R29;
		/* 820C181Ch case    5:*/		return 0x820C1820;
		  /* 820C1820h */ case    6:  		/* oris R5, R30, 4112 */
		/* 820C1820h case    6:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1010);
		/* 820C1820h case    6:*/		return 0x820C1824;
		  /* 820C1824h */ case    7:  		/* mr R4, R15 */
		/* 820C1824h case    7:*/		regs.R4 = regs.R15;
		/* 820C1824h case    7:*/		return 0x820C1828;
		  /* 820C1828h */ case    8:  		/* mr R3, R17 */
		/* 820C1828h case    8:*/		regs.R3 = regs.R17;
		/* 820C1828h case    8:*/		return 0x820C182C;
		  /* 820C182Ch */ case    9:  		/* bl -68900 */
		/* 820C182Ch case    9:*/		regs.LR = 0x820C1830; return 0x820B0B08;
		/* 820C182Ch case    9:*/		return 0x820C1830;
		  /* 820C1830h */ case   10:  		/* or. R31, R3, R3 */
		/* 820C1830h case   10:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1830h case   10:*/		return 0x820C1834;
		  /* 820C1834h */ case   11:  		/* bc 12, CR0_LT, 4768 */
		/* 820C1834h case   11:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1834h case   11:*/		return 0x820C1838;
		  /* 820C1838h */ case   12:  		/* lwz R27, <#[R1 + 148]> */
		/* 820C1838h case   12:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000094) );
		/* 820C1838h case   12:*/		return 0x820C183C;
		  /* 820C183Ch */ case   13:  		/* li R9, 0 */
		/* 820C183Ch case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C183Ch case   13:*/		return 0x820C1840;
		  /* 820C1840h */ case   14:  		/* mr R8, R29 */
		/* 820C1840h case   14:*/		regs.R8 = regs.R29;
		/* 820C1840h case   14:*/		return 0x820C1844;
		  /* 820C1844h */ case   15:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C1844h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C1844h case   15:*/		return 0x820C1848;
		  /* 820C1848h */ case   16:  		/* mr R6, R27 */
		/* 820C1848h case   16:*/		regs.R6 = regs.R27;
		/* 820C1848h case   16:*/		return 0x820C184C;
		  /* 820C184Ch */ case   17:  		/* oris R5, R30, 8256 */
		/* 820C184Ch case   17:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2040);
		/* 820C184Ch case   17:*/		return 0x820C1850;
		  /* 820C1850h */ case   18:  		/* mr R4, R15 */
		/* 820C1850h case   18:*/		regs.R4 = regs.R15;
		/* 820C1850h case   18:*/		return 0x820C1854;
		  /* 820C1854h */ case   19:  		/* mr R3, R17 */
		/* 820C1854h case   19:*/		regs.R3 = regs.R17;
		/* 820C1854h case   19:*/		return 0x820C1858;
		  /* 820C1858h */ case   20:  		/* bl -68944 */
		/* 820C1858h case   20:*/		regs.LR = 0x820C185C; return 0x820B0B08;
		/* 820C1858h case   20:*/		return 0x820C185C;
		  /* 820C185Ch */ case   21:  		/* or. R31, R3, R3 */
		/* 820C185Ch case   21:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C185Ch case   21:*/		return 0x820C1860;
		  /* 820C1860h */ case   22:  		/* bc 12, CR0_LT, 4724 */
		/* 820C1860h case   22:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1860h case   22:*/		return 0x820C1864;
		  /* 820C1864h */ case   23:  		/* lwz R29, <#[R1 + 156]> */
		/* 820C1864h case   23:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000009C) );
		/* 820C1864h case   23:*/		return 0x820C1868;
		  /* 820C1868h */ case   24:  		/* mr R8, R21 */
		/* 820C1868h case   24:*/		regs.R8 = regs.R21;
		/* 820C1868h case   24:*/		return 0x820C186C;
		  /* 820C186Ch */ case   25:  		/* lwz R28, <#[R1 + 152]> */
		/* 820C186Ch case   25:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000098) );
		/* 820C186Ch case   25:*/		return 0x820C1870;
		  /* 820C1870h */ case   26:  		/* mr R7, R27 */
		/* 820C1870h case   26:*/		regs.R7 = regs.R27;
		/* 820C1870h case   26:*/		return 0x820C1874;
		  /* 820C1874h */ case   27:  		/* mr R6, R29 */
		/* 820C1874h case   27:*/		regs.R6 = regs.R29;
		/* 820C1874h case   27:*/		return 0x820C1878;
		  /* 820C1878h */ case   28:  		/* mr R5, R28 */
		/* 820C1878h case   28:*/		regs.R5 = regs.R28;
		/* 820C1878h case   28:*/		return 0x820C187C;
		  /* 820C187Ch */ case   29:  		/* mr R4, R15 */
		/* 820C187Ch case   29:*/		regs.R4 = regs.R15;
		/* 820C187Ch case   29:*/		return 0x820C1880;
		  /* 820C1880h */ case   30:  		/* mr R3, R17 */
		/* 820C1880h case   30:*/		regs.R3 = regs.R17;
		/* 820C1880h case   30:*/		return 0x820C1884;
		  /* 820C1884h */ case   31:  		/* bl -54996 */
		/* 820C1884h case   31:*/		regs.LR = 0x820C1888; return 0x820B41B0;
		/* 820C1884h case   31:*/		return 0x820C1888;
		  /* 820C1888h */ case   32:  		/* or. R31, R3, R3 */
		/* 820C1888h case   32:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1888h case   32:*/		return 0x820C188C;
		  /* 820C188Ch */ case   33:  		/* bc 12, CR0_LT, 4680 */
		/* 820C188Ch case   33:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C188Ch case   33:*/		return 0x820C1890;
		  /* 820C1890h */ case   34:  		/* li R9, 23 */
		/* 820C1890h case   34:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C1890h case   34:*/		return 0x820C1894;
		  /* 820C1894h */ case   35:  		/* mr R8, R28 */
		/* 820C1894h case   35:*/		regs.R8 = regs.R28;
		/* 820C1894h case   35:*/		return 0x820C1898;
		  /* 820C1898h */ case   36:  		/* mr R7, R29 */
		/* 820C1898h case   36:*/		regs.R7 = regs.R29;
		/* 820C1898h case   36:*/		return 0x820C189C;
		  /* 820C189Ch */ case   37:  		/* oris R5, R30, 8240 */
		/* 820C189Ch case   37:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2030);
		/* 820C189Ch case   37:*/		return 0x820C18A0;
		  /* 820C18A0h */ case   38:  		/* b 2004 */
		/* 820C18A0h case   38:*/		return 0x820C2074;
		/* 820C18A0h case   38:*/		return 0x820C18A4;
		  /* 820C18A4h */ case   39:  		/* cmplwi CR6, R30, 0 */
		/* 820C18A4h case   39:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C18A4h case   39:*/		return 0x820C18A8;
		  /* 820C18A8h */ case   40:  		/* bc 12, CR6_EQ, 4644 */
		/* 820C18A8h case   40:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C18A8h case   40:*/		return 0x820C18AC;
		  /* 820C18ACh */ case   41:  		/* cmplwi CR6, R28, 0 */
		/* 820C18ACh case   41:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C18ACh case   41:*/		return 0x820C18B0;
		  /* 820C18B0h */ case   42:  		/* bc 12, CR6_EQ, 4636 */
		/* 820C18B0h case   42:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C18B0h case   42:*/		return 0x820C18B4;
		  /* 820C18B4h */ case   43:  		/* cmplwi CR6, R14, 0 */
		/* 820C18B4h case   43:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C18B4h case   43:*/		return 0x820C18B8;
		  /* 820C18B8h */ case   44:  		/* bc 12, CR6_EQ, 4596 */
		/* 820C18B8h case   44:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C18B8h case   44:*/		return 0x820C18BC;
		  /* 820C18BCh */ case   45:  		/* rlwinm R31, R21, 2, 0, 29 */
		/* 820C18BCh case   45:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R21);
		/* 820C18BCh case   45:*/		return 0x820C18C0;
		  /* 820C18C0h */ case   46:  		/* mr R3, R17 */
		/* 820C18C0h case   46:*/		regs.R3 = regs.R17;
		/* 820C18C0h case   46:*/		return 0x820C18C4;
		  /* 820C18C4h */ case   47:  		/* mr R4, R31 */
		/* 820C18C4h case   47:*/		regs.R4 = regs.R31;
		/* 820C18C4h case   47:*/		return 0x820C18C8;
		  /* 820C18C8h */ case   48:  		/* bl -70104 */
		/* 820C18C8h case   48:*/		regs.LR = 0x820C18CC; return 0x820B06F0;
		/* 820C18C8h case   48:*/		return 0x820C18CC;
		  /* 820C18CCh */ case   49:  		/* cmplwi CR0, R3, 0 */
		/* 820C18CCh case   49:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C18CCh case   49:*/		return 0x820C18D0;
		  /* 820C18D0h */ case   50:  		/* bc 12, CR0_EQ, 3476 */
		/* 820C18D0h case   50:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C18D0h case   50:*/		return 0x820C18D4;
		  /* 820C18D4h */ case   51:  		/* li R9, 4 */
		/* 820C18D4h case   51:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820C18D4h case   51:*/		return 0x820C18D8;
		  /* 820C18D8h */ case   52:  		/* addi R10, R1, 140 */
		/* 820C18D8h case   52:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x8C);
		/* 820C18D8h case   52:*/		return 0x820C18DC;
		  /* 820C18DCh */ case   53:  		/* mr R11, R3 */
		/* 820C18DCh case   53:*/		regs.R11 = regs.R3;
		/* 820C18DCh case   53:*/		return 0x820C18E0;
		  /* 820C18E0h */ case   54:  		/* mtspr CTR, R9 */
		/* 820C18E0h case   54:*/		regs.CTR = regs.R9;
		/* 820C18E0h case   54:*/		return 0x820C18E4;
		  /* 820C18E4h */ case   55:  		/* stwu R11, <#[R10 + 4]> */
		/* 820C18E4h case   55:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C18E4h case   55:*/		return 0x820C18E8;
		  /* 820C18E8h */ case   56:  		/* add R11, R31, R11 */
		/* 820C18E8h case   56:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820C18E8h case   56:*/		return 0x820C18EC;
		  /* 820C18ECh */ case   57:  		/* bc 16, CR0_LT, -8 */
		/* 820C18ECh case   57:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C18E4;  }
		/* 820C18ECh case   57:*/		return 0x820C18F0;
		  /* 820C18F0h */ case   58:  		/* li R11, 0 */
		/* 820C18F0h case   58:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C18F0h case   58:*/		return 0x820C18F4;
		  /* 820C18F4h */ case   59:  		/* cmplwi CR6, R31, 0 */
		/* 820C18F4h case   59:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C18F4h case   59:*/		return 0x820C18F8;
		  /* 820C18F8h */ case   60:  		/* bc 12, CR6_EQ, 24 */
		/* 820C18F8h case   60:*/		if ( regs.CR[6].eq ) { return 0x820C1910;  }
		/* 820C18F8h case   60:*/		return 0x820C18FC;
		  /* 820C18FCh */ case   61:  		/* addi R10, R3, -4 */
		/* 820C18FCh case   61:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0xFFFFFFFC);
		/* 820C18FCh case   61:*/		return 0x820C1900;
		  /* 820C1900h */ case   62:  		/* addi R11, R11, 1 */
		/* 820C1900h case   62:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C1900h case   62:*/		return 0x820C1904;
		  /* 820C1904h */ case   63:  		/* stwu R22, <#[R10 + 4]> */
		/* 820C1904h case   63:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C1904h case   63:*/		return 0x820C1908;
		  /* 820C1908h */ case   64:  		/* cmplw CR6, R11, R31 */
		/* 820C1908h case   64:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 820C1908h case   64:*/		return 0x820C190C;
		  /* 820C190Ch */ case   65:  		/* bc 12, CR6_LT, -12 */
		/* 820C190Ch case   65:*/		if ( regs.CR[6].lt ) { return 0x820C1900;  }
		/* 820C190Ch case   65:*/		return 0x820C1910;
	}
	return 0x820C1910;
} // Block from 820C1808h-820C1910h (66 instructions)

//////////////////////////////////////////////////////
// Block at 820C1910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1910);
		  /* 820C1910h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 820C1910h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1910h case    0:*/		return 0x820C1914;
		  /* 820C1914h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1914h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C1934;  }
		/* 820C1914h case    1:*/		return 0x820C1918;
		  /* 820C1918h */ case    2:  		/* addi R11, R14, -4 */
		/* 820C1918h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C1918h case    2:*/		return 0x820C191C;
		  /* 820C191Ch */ case    3:  		/* mr R10, R22 */
		/* 820C191Ch case    3:*/		regs.R10 = regs.R22;
		/* 820C191Ch case    3:*/		return 0x820C1920;
	}
	return 0x820C1920;
} // Block from 820C1910h-820C1920h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C1920h
// Function '?EmitExpression@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1920);
		  /* 820C1920h */ case    0:  		/* cmplwi CR0, R21, 0 */
		/* 820C1920h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1920h case    0:*/		return 0x820C1924;
		  /* 820C1924h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1924h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C1934;  }
		/* 820C1924h case    1:*/		return 0x820C1928;
		  /* 820C1928h */ case    2:  		/* mtspr CTR, R21 */
		/* 820C1928h case    2:*/		regs.CTR = regs.R21;
		/* 820C1928h case    2:*/		return 0x820C192C;
		  /* 820C192Ch */ case    3:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C192Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C192Ch case    3:*/		return 0x820C1930;
		  /* 820C1930h */ case    4:  		/* bc 16, CR0_LT, -4 */
		/* 820C1930h case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C192C;  }
		/* 820C1930h case    4:*/		return 0x820C1934;
	}
	return 0x820C1934;
} // Block from 820C1920h-820C1934h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C1934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1934);
		  /* 820C1934h */ case    0:  		/* lwz R29, <#[R1 + 144]> */
		/* 820C1934h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000090) );
		/* 820C1934h case    0:*/		return 0x820C1938;
		  /* 820C1938h */ case    1:  		/* rlwinm R30, R21, 0, 12, 31 */
		/* 820C1938h case    1:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R21);
		/* 820C1938h case    1:*/		return 0x820C193C;
		  /* 820C193Ch */ case    2:  		/* li R9, 0 */
		/* 820C193Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C193Ch case    2:*/		return 0x820C1940;
		  /* 820C1940h */ case    3:  		/* lwz R7, <#[R1 + 132]> */
		/* 820C1940h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000084) );
		/* 820C1940h case    3:*/		return 0x820C1944;
		  /* 820C1944h */ case    4:  		/* li R8, 0 */
		/* 820C1944h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C1944h case    4:*/		return 0x820C1948;
		  /* 820C1948h */ case    5:  		/* mr R6, R29 */
		/* 820C1948h case    5:*/		regs.R6 = regs.R29;
		/* 820C1948h case    5:*/		return 0x820C194C;
		  /* 820C194Ch */ case    6:  		/* oris R5, R30, 4112 */
		/* 820C194Ch case    6:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1010);
		/* 820C194Ch case    6:*/		return 0x820C1950;
		  /* 820C1950h */ case    7:  		/* mr R4, R15 */
		/* 820C1950h case    7:*/		regs.R4 = regs.R15;
		/* 820C1950h case    7:*/		return 0x820C1954;
		  /* 820C1954h */ case    8:  		/* mr R3, R17 */
		/* 820C1954h case    8:*/		regs.R3 = regs.R17;
		/* 820C1954h case    8:*/		return 0x820C1958;
		  /* 820C1958h */ case    9:  		/* bl -69200 */
		/* 820C1958h case    9:*/		regs.LR = 0x820C195C; return 0x820B0B08;
		/* 820C1958h case    9:*/		return 0x820C195C;
		  /* 820C195Ch */ case   10:  		/* or. R31, R3, R3 */
		/* 820C195Ch case   10:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C195Ch case   10:*/		return 0x820C1960;
		  /* 820C1960h */ case   11:  		/* bc 12, CR0_LT, 4468 */
		/* 820C1960h case   11:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1960h case   11:*/		return 0x820C1964;
		  /* 820C1964h */ case   12:  		/* lwz R27, <#[R1 + 148]> */
		/* 820C1964h case   12:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000094) );
		/* 820C1964h case   12:*/		return 0x820C1968;
		  /* 820C1968h */ case   13:  		/* li R9, 0 */
		/* 820C1968h case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C1968h case   13:*/		return 0x820C196C;
		  /* 820C196Ch */ case   14:  		/* mr R8, R29 */
		/* 820C196Ch case   14:*/		regs.R8 = regs.R29;
		/* 820C196Ch case   14:*/		return 0x820C1970;
		  /* 820C1970h */ case   15:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C1970h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C1970h case   15:*/		return 0x820C1974;
		  /* 820C1974h */ case   16:  		/* mr R6, R27 */
		/* 820C1974h case   16:*/		regs.R6 = regs.R27;
		/* 820C1974h case   16:*/		return 0x820C1978;
		  /* 820C1978h */ case   17:  		/* oris R5, R30, 8256 */
		/* 820C1978h case   17:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2040);
		/* 820C1978h case   17:*/		return 0x820C197C;
		  /* 820C197Ch */ case   18:  		/* mr R4, R15 */
		/* 820C197Ch case   18:*/		regs.R4 = regs.R15;
		/* 820C197Ch case   18:*/		return 0x820C1980;
		  /* 820C1980h */ case   19:  		/* mr R3, R17 */
		/* 820C1980h case   19:*/		regs.R3 = regs.R17;
		/* 820C1980h case   19:*/		return 0x820C1984;
		  /* 820C1984h */ case   20:  		/* bl -69244 */
		/* 820C1984h case   20:*/		regs.LR = 0x820C1988; return 0x820B0B08;
		/* 820C1984h case   20:*/		return 0x820C1988;
		  /* 820C1988h */ case   21:  		/* or. R31, R3, R3 */
		/* 820C1988h case   21:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1988h case   21:*/		return 0x820C198C;
		  /* 820C198Ch */ case   22:  		/* bc 12, CR0_LT, 4424 */
		/* 820C198Ch case   22:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C198Ch case   22:*/		return 0x820C1990;
		  /* 820C1990h */ case   23:  		/* lwz R29, <#[R1 + 156]> */
		/* 820C1990h case   23:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x0000009C) );
		/* 820C1990h case   23:*/		return 0x820C1994;
		  /* 820C1994h */ case   24:  		/* mr R8, R21 */
		/* 820C1994h case   24:*/		regs.R8 = regs.R21;
		/* 820C1994h case   24:*/		return 0x820C1998;
		  /* 820C1998h */ case   25:  		/* lwz R28, <#[R1 + 152]> */
		/* 820C1998h case   25:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000098) );
		/* 820C1998h case   25:*/		return 0x820C199C;
		  /* 820C199Ch */ case   26:  		/* mr R7, R27 */
		/* 820C199Ch case   26:*/		regs.R7 = regs.R27;
		/* 820C199Ch case   26:*/		return 0x820C19A0;
		  /* 820C19A0h */ case   27:  		/* mr R6, R29 */
		/* 820C19A0h case   27:*/		regs.R6 = regs.R29;
		/* 820C19A0h case   27:*/		return 0x820C19A4;
		  /* 820C19A4h */ case   28:  		/* mr R5, R28 */
		/* 820C19A4h case   28:*/		regs.R5 = regs.R28;
		/* 820C19A4h case   28:*/		return 0x820C19A8;
		  /* 820C19A8h */ case   29:  		/* mr R4, R15 */
		/* 820C19A8h case   29:*/		regs.R4 = regs.R15;
		/* 820C19A8h case   29:*/		return 0x820C19AC;
		  /* 820C19ACh */ case   30:  		/* mr R3, R17 */
		/* 820C19ACh case   30:*/		regs.R3 = regs.R17;
		/* 820C19ACh case   30:*/		return 0x820C19B0;
		  /* 820C19B0h */ case   31:  		/* bl -55296 */
		/* 820C19B0h case   31:*/		regs.LR = 0x820C19B4; return 0x820B41B0;
		/* 820C19B0h case   31:*/		return 0x820C19B4;
		  /* 820C19B4h */ case   32:  		/* or. R31, R3, R3 */
		/* 820C19B4h case   32:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C19B4h case   32:*/		return 0x820C19B8;
		  /* 820C19B8h */ case   33:  		/* bc 12, CR0_LT, 4380 */
		/* 820C19B8h case   33:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C19B8h case   33:*/		return 0x820C19BC;
		  /* 820C19BCh */ case   34:  		/* mr R8, R28 */
		/* 820C19BCh case   34:*/		regs.R8 = regs.R28;
		/* 820C19BCh case   34:*/		return 0x820C19C0;
		  /* 820C19C0h */ case   35:  		/* li R9, 23 */
		/* 820C19C0h case   35:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C19C0h case   35:*/		return 0x820C19C4;
		  /* 820C19C4h */ case   36:  		/* mr R7, R29 */
		/* 820C19C4h case   36:*/		regs.R7 = regs.R29;
		/* 820C19C4h case   36:*/		return 0x820C19C8;
		  /* 820C19C8h */ case   37:  		/* oris R5, R30, 8224 */
		/* 820C19C8h case   37:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2020);
		/* 820C19C8h case   37:*/		return 0x820C19CC;
		  /* 820C19CCh */ case   38:  		/* b 1704 */
		/* 820C19CCh case   38:*/		return 0x820C2074;
		/* 820C19CCh case   38:*/		return 0x820C19D0;
		  /* 820C19D0h */ case   39:  		/* cmplwi CR6, R30, 0 */
		/* 820C19D0h case   39:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C19D0h case   39:*/		return 0x820C19D4;
		  /* 820C19D4h */ case   40:  		/* bc 12, CR6_EQ, 4344 */
		/* 820C19D4h case   40:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C19D4h case   40:*/		return 0x820C19D8;
		  /* 820C19D8h */ case   41:  		/* cmplwi CR6, R28, 0 */
		/* 820C19D8h case   41:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C19D8h case   41:*/		return 0x820C19DC;
		  /* 820C19DCh */ case   42:  		/* bc 12, CR6_EQ, 4336 */
		/* 820C19DCh case   42:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C19DCh case   42:*/		return 0x820C19E0;
		  /* 820C19E0h */ case   43:  		/* cmplwi CR6, R14, 0 */
		/* 820C19E0h case   43:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C19E0h case   43:*/		return 0x820C19E4;
		  /* 820C19E4h */ case   44:  		/* bc 12, CR6_EQ, 4296 */
		/* 820C19E4h case   44:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C19E4h case   44:*/		return 0x820C19E8;
		  /* 820C19E8h */ case   45:  		/* lwz R31, <#[R1 + 132]> */
		/* 820C19E8h case   45:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000084) );
		/* 820C19E8h case   45:*/		return 0x820C19EC;
		  /* 820C19ECh */ case   46:  		/* li R8, 0 */
		/* 820C19ECh case   46:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C19ECh case   46:*/		return 0x820C19F0;
		  /* 820C19F0h */ case   47:  		/* lwz R26, <#[R1 + 128]> */
		/* 820C19F0h case   47:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000080) );
		/* 820C19F0h case   47:*/		return 0x820C19F4;
		  /* 820C19F4h */ case   48:  		/* cmplwi CR6, R21, 0 */
		/* 820C19F4h case   48:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C19F4h case   48:*/		return 0x820C19F8;
		  /* 820C19F8h */ case   49:  		/* bc 12, CR6_EQ, 120 */
		/* 820C19F8h case   49:*/		if ( regs.CR[6].eq ) { return 0x820C1A70;  }
		/* 820C19F8h case   49:*/		return 0x820C19FC;
		  /* 820C19FCh */ case   50:  		/* lwz R10, <#[R17 + 8]> */
		/* 820C19FCh case   50:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0x00000008) );
		/* 820C19FCh case   50:*/		return 0x820C1A00;
		  /* 820C1A00h */ case   51:  		/* mr R11, R31 */
		/* 820C1A00h case   51:*/		regs.R11 = regs.R31;
		/* 820C1A00h case   51:*/		return 0x820C1A04;
		  /* 820C1A04h */ case   52:  		/* subf R9, R31, R26 */
		/* 820C1A04h case   52:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R31,regs.R26);
		/* 820C1A04h case   52:*/		return 0x820C1A08;
		  /* 820C1A08h */ case   53:  		/* lwz R10, <#[R10 + 20]> */
		/* 820C1A08h case   53:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 820C1A08h case   53:*/		return 0x820C1A0C;
		  /* 820C1A0Ch */ case   54:  		/* lwzx R7, <#[R9 + R11]> */
		/* 820C1A0Ch case   54:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820C1A0Ch case   54:*/		return 0x820C1A10;
		  /* 820C1A10h */ case   55:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820C1A10h case   55:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820C1A10h case   55:*/		return 0x820C1A14;
		  /* 820C1A14h */ case   56:  		/* lwzx R7, <#[R7 + R10]> */
		/* 820C1A14h case   56:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820C1A14h case   56:*/		return 0x820C1A18;
		  /* 820C1A18h */ case   57:  		/* lwz R7, <#[R7]> */
		/* 820C1A18h case   57:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000000) );
		/* 820C1A18h case   57:*/		return 0x820C1A1C;
		  /* 820C1A1Ch */ case   58:  		/* rlwinm. R7, R7, 0, 31, 31 */
		/* 820C1A1Ch case   58:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R7);
		/* 820C1A1Ch case   58:*/		return 0x820C1A20;
		  /* 820C1A20h */ case   59:  		/* bc 12, CR0_EQ, 108 */
		/* 820C1A20h case   59:*/		if ( regs.CR[0].eq ) { return 0x820C1A8C;  }
		/* 820C1A20h case   59:*/		return 0x820C1A24;
		  /* 820C1A24h */ case   60:  		/* lwz R7, <#[R11]> */
		/* 820C1A24h case   60:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820C1A24h case   60:*/		return 0x820C1A28;
		  /* 820C1A28h */ case   61:  		/* rlwinm R7, R7, 2, 0, 29 */
		/* 820C1A28h case   61:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R7);
		/* 820C1A28h case   61:*/		return 0x820C1A2C;
		  /* 820C1A2Ch */ case   62:  		/* lwzx R7, <#[R7 + R10]> */
		/* 820C1A2Ch case   62:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 820C1A2Ch case   62:*/		return 0x820C1A30;
		  /* 820C1A30h */ case   63:  		/* lwz R7, <#[R7]> */
		/* 820C1A30h case   63:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000000) );
		/* 820C1A30h case   63:*/		return 0x820C1A34;
		  /* 820C1A34h */ case   64:  		/* rlwinm. R7, R7, 0, 31, 31 */
		/* 820C1A34h case   64:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R7);
		/* 820C1A34h case   64:*/		return 0x820C1A38;
		  /* 820C1A38h */ case   65:  		/* bc 12, CR0_EQ, 84 */
		/* 820C1A38h case   65:*/		if ( regs.CR[0].eq ) { return 0x820C1A8C;  }
		/* 820C1A38h case   65:*/		return 0x820C1A3C;
		  /* 820C1A3Ch */ case   66:  		/* addi R8, R8, 1 */
		/* 820C1A3Ch case   66:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820C1A3Ch case   66:*/		return 0x820C1A40;
		  /* 820C1A40h */ case   67:  		/* addi R11, R11, 4 */
		/* 820C1A40h case   67:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820C1A40h case   67:*/		return 0x820C1A44;
		  /* 820C1A44h */ case   68:  		/* cmplw CR6, R8, R21 */
		/* 820C1A44h case   68:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R21);
		/* 820C1A44h case   68:*/		return 0x820C1A48;
		  /* 820C1A48h */ case   69:  		/* bc 12, CR6_LT, -60 */
		/* 820C1A48h case   69:*/		if ( regs.CR[6].lt ) { return 0x820C1A0C;  }
		/* 820C1A48h case   69:*/		return 0x820C1A4C;
		  /* 820C1A4Ch */ case   70:  		/* cmplwi CR6, R21, 0 */
		/* 820C1A4Ch case   70:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1A4Ch case   70:*/		return 0x820C1A50;
		  /* 820C1A50h */ case   71:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1A50h case   71:*/		if ( regs.CR[6].eq ) { return 0x820C1A70;  }
		/* 820C1A50h case   71:*/		return 0x820C1A54;
		  /* 820C1A54h */ case   72:  		/* addi R11, R14, -4 */
		/* 820C1A54h case   72:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C1A54h case   72:*/		return 0x820C1A58;
		  /* 820C1A58h */ case   73:  		/* mr R10, R22 */
		/* 820C1A58h case   73:*/		regs.R10 = regs.R22;
		/* 820C1A58h case   73:*/		return 0x820C1A5C;
		  /* 820C1A5Ch */ case   74:  		/* cmplwi CR0, R21, 0 */
		/* 820C1A5Ch case   74:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1A5Ch case   74:*/		return 0x820C1A60;
		  /* 820C1A60h */ case   75:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1A60h case   75:*/		if ( regs.CR[0].eq ) { return 0x820C1A70;  }
		/* 820C1A60h case   75:*/		return 0x820C1A64;
		  /* 820C1A64h */ case   76:  		/* mtspr CTR, R21 */
		/* 820C1A64h case   76:*/		regs.CTR = regs.R21;
		/* 820C1A64h case   76:*/		return 0x820C1A68;
		  /* 820C1A68h */ case   77:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1A68h case   77:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1A68h case   77:*/		return 0x820C1A6C;
		  /* 820C1A6Ch */ case   78:  		/* bc 16, CR0_LT, -4 */
		/* 820C1A6Ch case   78:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1A68;  }
		/* 820C1A6Ch case   78:*/		return 0x820C1A70;
	}
	return 0x820C1A70;
} // Block from 820C1934h-820C1A70h (79 instructions)

//////////////////////////////////////////////////////
// Block at 820C1A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1A70);
		  /* 820C1A70h */ case    0:  		/* mr R5, R21 */
		/* 820C1A70h case    0:*/		regs.R5 = regs.R21;
		/* 820C1A70h case    0:*/		return 0x820C1A74;
		  /* 820C1A74h */ case    1:  		/* li R11, 517 */
		/* 820C1A74h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x205);
		/* 820C1A74h case    1:*/		return 0x820C1A78;
		  /* 820C1A78h */ case    2:  		/* li R9, 23 */
		/* 820C1A78h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C1A78h case    2:*/		return 0x820C1A7C;
		  /* 820C1A7Ch */ case    3:  		/* rlwimi R5, R11, 20, 0, 11 */
		/* 820C1A7Ch case    3:*/		cpu::op::rlwimi<0,20,0,11>(regs,&regs.R5,regs.R11);
		/* 820C1A7Ch case    3:*/		return 0x820C1A80;
		  /* 820C1A80h */ case    4:  		/* mr R8, R31 */
		/* 820C1A80h case    4:*/		regs.R8 = regs.R31;
		/* 820C1A80h case    4:*/		return 0x820C1A84;
		  /* 820C1A84h */ case    5:  		/* mr R7, R26 */
		/* 820C1A84h case    5:*/		regs.R7 = regs.R26;
		/* 820C1A84h case    5:*/		return 0x820C1A88;
		  /* 820C1A88h */ case    6:  		/* b 1516 */
		/* 820C1A88h case    6:*/		return 0x820C2074;
		/* 820C1A88h case    6:*/		return 0x820C1A8C;
	}
	return 0x820C1A8C;
} // Block from 820C1A70h-820C1A8Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C1A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1A8C);
		  /* 820C1A8Ch */ case    0:  		/* mulli R4, R21, 3 */
		/* 820C1A8Ch case    0:*/		cpu::op::mulli<0>(regs,&regs.R4,regs.R21,0x3);
		/* 820C1A8Ch case    0:*/		return 0x820C1A90;
		  /* 820C1A90h */ case    1:  		/* mr R3, R17 */
		/* 820C1A90h case    1:*/		regs.R3 = regs.R17;
		/* 820C1A90h case    1:*/		return 0x820C1A94;
		  /* 820C1A94h */ case    2:  		/* bl -70564 */
		/* 820C1A94h case    2:*/		regs.LR = 0x820C1A98; return 0x820B06F0;
		/* 820C1A94h case    2:*/		return 0x820C1A98;
		  /* 820C1A98h */ case    3:  		/* or. R11, R3, R3 */
		/* 820C1A98h case    3:*/		cpu::op::or<1>(regs,&regs.R11,regs.R3,regs.R3);
		/* 820C1A98h case    3:*/		return 0x820C1A9C;
		  /* 820C1A9Ch */ case    4:  		/* bc 12, CR0_EQ, 3016 */
		/* 820C1A9Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C1A9Ch case    4:*/		return 0x820C1AA0;
		  /* 820C1AA0h */ case    5:  		/* li R10, 3 */
		/* 820C1AA0h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820C1AA0h case    5:*/		return 0x820C1AA4;
		  /* 820C1AA4h */ case    6:  		/* addi R9, R1, 140 */
		/* 820C1AA4h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x8C);
		/* 820C1AA4h case    6:*/		return 0x820C1AA8;
		  /* 820C1AA8h */ case    7:  		/* rlwinm R8, R21, 2, 0, 29 */
		/* 820C1AA8h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R21);
		/* 820C1AA8h case    7:*/		return 0x820C1AAC;
		  /* 820C1AACh */ case    8:  		/* mtspr CTR, R10 */
		/* 820C1AACh case    8:*/		regs.CTR = regs.R10;
		/* 820C1AACh case    8:*/		return 0x820C1AB0;
		  /* 820C1AB0h */ case    9:  		/* stwu R11, <#[R9 + 4]> */
		/* 820C1AB0h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C1AB0h case    9:*/		return 0x820C1AB4;
		  /* 820C1AB4h */ case   10:  		/* add R11, R11, R8 */
		/* 820C1AB4h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820C1AB4h case   10:*/		return 0x820C1AB8;
		  /* 820C1AB8h */ case   11:  		/* bc 16, CR0_LT, -8 */
		/* 820C1AB8h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1AB0;  }
		/* 820C1AB8h case   11:*/		return 0x820C1ABC;
		  /* 820C1ABCh */ case   12:  		/* lwz R28, <#[R1 + 144]> */
		/* 820C1ABCh case   12:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000090) );
		/* 820C1ABCh case   12:*/		return 0x820C1AC0;
		  /* 820C1AC0h */ case   13:  		/* rlwinm. R10, R21, 0, 2, 31 */
		/* 820C1AC0h case   13:*/		cpu::op::rlwinm<1,0,2,31>(regs,&regs.R10,regs.R21);
		/* 820C1AC0h case   13:*/		return 0x820C1AC4;
		  /* 820C1AC4h */ case   14:  		/* rlwinm R11, R21, 2, 0, 29 */
		/* 820C1AC4h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R21);
		/* 820C1AC4h case   14:*/		return 0x820C1AC8;
		  /* 820C1AC8h */ case   15:  		/* addi R9, R28, -4 */
		/* 820C1AC8h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R28,0xFFFFFFFC);
		/* 820C1AC8h case   15:*/		return 0x820C1ACC;
		  /* 820C1ACCh */ case   16:  		/* mr R8, R22 */
		/* 820C1ACCh case   16:*/		regs.R8 = regs.R22;
		/* 820C1ACCh case   16:*/		return 0x820C1AD0;
		  /* 820C1AD0h */ case   17:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1AD0h case   17:*/		if ( regs.CR[0].eq ) { return 0x820C1AE0;  }
		/* 820C1AD0h case   17:*/		return 0x820C1AD4;
		  /* 820C1AD4h */ case   18:  		/* mtspr CTR, R10 */
		/* 820C1AD4h case   18:*/		regs.CTR = regs.R10;
		/* 820C1AD4h case   18:*/		return 0x820C1AD8;
		  /* 820C1AD8h */ case   19:  		/* stwu R8, <#[R9 + 4]> */
		/* 820C1AD8h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C1AD8h case   19:*/		return 0x820C1ADC;
		  /* 820C1ADCh */ case   20:  		/* bc 16, CR0_LT, -4 */
		/* 820C1ADCh case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1AD8;  }
		/* 820C1ADCh case   20:*/		return 0x820C1AE0;
	}
	return 0x820C1AE0;
} // Block from 820C1A8Ch-820C1AE0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C1AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1AE0);
		  /* 820C1AE0h */ case    0:  		/* lwz R27, <#[R1 + 148]> */
		/* 820C1AE0h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000094) );
		/* 820C1AE0h case    0:*/		return 0x820C1AE4;
		  /* 820C1AE4h */ case    1:  		/* rlwinm. R10, R11, 30, 2, 31 */
		/* 820C1AE4h case    1:*/		cpu::op::rlwinm<1,30,2,31>(regs,&regs.R10,regs.R11);
		/* 820C1AE4h case    1:*/		return 0x820C1AE8;
		  /* 820C1AE8h */ case    2:  		/* mr R8, R22 */
		/* 820C1AE8h case    2:*/		regs.R8 = regs.R22;
		/* 820C1AE8h case    2:*/		return 0x820C1AEC;
		  /* 820C1AECh */ case    3:  		/* addi R9, R27, -4 */
		/* 820C1AECh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0xFFFFFFFC);
		/* 820C1AECh case    3:*/		return 0x820C1AF0;
		  /* 820C1AF0h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1AF0h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C1B00;  }
		/* 820C1AF0h case    4:*/		return 0x820C1AF4;
		  /* 820C1AF4h */ case    5:  		/* mtspr CTR, R10 */
		/* 820C1AF4h case    5:*/		regs.CTR = regs.R10;
		/* 820C1AF4h case    5:*/		return 0x820C1AF8;
		  /* 820C1AF8h */ case    6:  		/* stwu R8, <#[R9 + 4]> */
		/* 820C1AF8h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C1AF8h case    6:*/		return 0x820C1AFC;
		  /* 820C1AFCh */ case    7:  		/* bc 16, CR0_LT, -4 */
		/* 820C1AFCh case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1AF8;  }
		/* 820C1AFCh case    7:*/		return 0x820C1B00;
	}
	return 0x820C1B00;
} // Block from 820C1AE0h-820C1B00h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C1B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1B00);
		  /* 820C1B00h */ case    0:  		/* lwz R29, <#[R1 + 152]> */
		/* 820C1B00h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000098) );
		/* 820C1B00h case    0:*/		return 0x820C1B04;
		  /* 820C1B04h */ case    1:  		/* rlwinm. R10, R11, 30, 2, 31 */
		/* 820C1B04h case    1:*/		cpu::op::rlwinm<1,30,2,31>(regs,&regs.R10,regs.R11);
		/* 820C1B04h case    1:*/		return 0x820C1B08;
		  /* 820C1B08h */ case    2:  		/* mr R8, R22 */
		/* 820C1B08h case    2:*/		regs.R8 = regs.R22;
		/* 820C1B08h case    2:*/		return 0x820C1B0C;
		  /* 820C1B0Ch */ case    3:  		/* addi R9, R29, -4 */
		/* 820C1B0Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R29,0xFFFFFFFC);
		/* 820C1B0Ch case    3:*/		return 0x820C1B10;
		  /* 820C1B10h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1B10h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C1B20;  }
		/* 820C1B10h case    4:*/		return 0x820C1B14;
		  /* 820C1B14h */ case    5:  		/* mtspr CTR, R10 */
		/* 820C1B14h case    5:*/		regs.CTR = regs.R10;
		/* 820C1B14h case    5:*/		return 0x820C1B18;
		  /* 820C1B18h */ case    6:  		/* stwu R8, <#[R9 + 4]> */
		/* 820C1B18h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C1B18h case    6:*/		return 0x820C1B1C;
		  /* 820C1B1Ch */ case    7:  		/* bc 16, CR0_LT, -4 */
		/* 820C1B1Ch case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1B18;  }
		/* 820C1B1Ch case    7:*/		return 0x820C1B20;
	}
	return 0x820C1B20;
} // Block from 820C1B00h-820C1B20h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C1B20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1B20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1B20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1B20);
		  /* 820C1B20h */ case    0:  		/* rlwinm. R11, R11, 30, 2, 31 */
		/* 820C1B20h case    0:*/		cpu::op::rlwinm<1,30,2,31>(regs,&regs.R11,regs.R11);
		/* 820C1B20h case    0:*/		return 0x820C1B24;
		  /* 820C1B24h */ case    1:  		/* addi R10, R14, -4 */
		/* 820C1B24h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R14,0xFFFFFFFC);
		/* 820C1B24h case    1:*/		return 0x820C1B28;
		  /* 820C1B28h */ case    2:  		/* mr R9, R22 */
		/* 820C1B28h case    2:*/		regs.R9 = regs.R22;
		/* 820C1B28h case    2:*/		return 0x820C1B2C;
		  /* 820C1B2Ch */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1B2Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820C1B3C;  }
		/* 820C1B2Ch case    3:*/		return 0x820C1B30;
		  /* 820C1B30h */ case    4:  		/* mtspr CTR, R11 */
		/* 820C1B30h case    4:*/		regs.CTR = regs.R11;
		/* 820C1B30h case    4:*/		return 0x820C1B34;
		  /* 820C1B34h */ case    5:  		/* stwu R9, <#[R10 + 4]> */
		/* 820C1B34h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C1B34h case    5:*/		return 0x820C1B38;
		  /* 820C1B38h */ case    6:  		/* bc 16, CR0_LT, -4 */
		/* 820C1B38h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1B34;  }
		/* 820C1B38h case    6:*/		return 0x820C1B3C;
	}
	return 0x820C1B3C;
} // Block from 820C1B20h-820C1B3Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C1B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1B3C);
		  /* 820C1B3Ch */ case    0:  		/* rlwinm R30, R21, 0, 12, 31 */
		/* 820C1B3Ch case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R21);
		/* 820C1B3Ch case    0:*/		return 0x820C1B40;
		  /* 820C1B40h */ case    1:  		/* li R9, 0 */
		/* 820C1B40h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C1B40h case    1:*/		return 0x820C1B44;
		  /* 820C1B44h */ case    2:  		/* mr R8, R31 */
		/* 820C1B44h case    2:*/		regs.R8 = regs.R31;
		/* 820C1B44h case    2:*/		return 0x820C1B48;
		  /* 820C1B48h */ case    3:  		/* mr R7, R26 */
		/* 820C1B48h case    3:*/		regs.R7 = regs.R26;
		/* 820C1B48h case    3:*/		return 0x820C1B4C;
		  /* 820C1B4Ch */ case    4:  		/* mr R6, R28 */
		/* 820C1B4Ch case    4:*/		regs.R6 = regs.R28;
		/* 820C1B4Ch case    4:*/		return 0x820C1B50;
		  /* 820C1B50h */ case    5:  		/* oris R5, R30, 8272 */
		/* 820C1B50h case    5:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2050);
		/* 820C1B50h case    5:*/		return 0x820C1B54;
		  /* 820C1B54h */ case    6:  		/* mr R4, R15 */
		/* 820C1B54h case    6:*/		regs.R4 = regs.R15;
		/* 820C1B54h case    6:*/		return 0x820C1B58;
		  /* 820C1B58h */ case    7:  		/* mr R3, R17 */
		/* 820C1B58h case    7:*/		regs.R3 = regs.R17;
		/* 820C1B58h case    7:*/		return 0x820C1B5C;
		  /* 820C1B5Ch */ case    8:  		/* bl -69716 */
		/* 820C1B5Ch case    8:*/		regs.LR = 0x820C1B60; return 0x820B0B08;
		/* 820C1B5Ch case    8:*/		return 0x820C1B60;
		  /* 820C1B60h */ case    9:  		/* or. R31, R3, R3 */
		/* 820C1B60h case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1B60h case    9:*/		return 0x820C1B64;
		  /* 820C1B64h */ case   10:  		/* bc 12, CR0_LT, 3952 */
		/* 820C1B64h case   10:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1B64h case   10:*/		return 0x820C1B68;
		  /* 820C1B68h */ case   11:  		/* mr R8, R21 */
		/* 820C1B68h case   11:*/		regs.R8 = regs.R21;
		/* 820C1B68h case   11:*/		return 0x820C1B6C;
		  /* 820C1B6Ch */ case   12:  		/* mr R7, R28 */
		/* 820C1B6Ch case   12:*/		regs.R7 = regs.R28;
		/* 820C1B6Ch case   12:*/		return 0x820C1B70;
		  /* 820C1B70h */ case   13:  		/* mr R6, R29 */
		/* 820C1B70h case   13:*/		regs.R6 = regs.R29;
		/* 820C1B70h case   13:*/		return 0x820C1B74;
		  /* 820C1B74h */ case   14:  		/* mr R5, R27 */
		/* 820C1B74h case   14:*/		regs.R5 = regs.R27;
		/* 820C1B74h case   14:*/		return 0x820C1B78;
		  /* 820C1B78h */ case   15:  		/* mr R4, R15 */
		/* 820C1B78h case   15:*/		regs.R4 = regs.R15;
		/* 820C1B78h case   15:*/		return 0x820C1B7C;
		  /* 820C1B7Ch */ case   16:  		/* mr R3, R17 */
		/* 820C1B7Ch case   16:*/		regs.R3 = regs.R17;
		/* 820C1B7Ch case   16:*/		return 0x820C1B80;
		  /* 820C1B80h */ case   17:  		/* bl -55760 */
		/* 820C1B80h case   17:*/		regs.LR = 0x820C1B84; return 0x820B41B0;
		/* 820C1B80h case   17:*/		return 0x820C1B84;
		  /* 820C1B84h */ case   18:  		/* or. R31, R3, R3 */
		/* 820C1B84h case   18:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1B84h case   18:*/		return 0x820C1B88;
		  /* 820C1B88h */ case   19:  		/* bc 12, CR0_LT, 3916 */
		/* 820C1B88h case   19:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1B88h case   19:*/		return 0x820C1B8C;
		  /* 820C1B8Ch */ case   20:  		/* mr R8, R27 */
		/* 820C1B8Ch case   20:*/		regs.R8 = regs.R27;
		/* 820C1B8Ch case   20:*/		return 0x820C1B90;
		  /* 820C1B90h */ case   21:  		/* b -464 */
		/* 820C1B90h case   21:*/		return 0x820C19C0;
		/* 820C1B90h case   21:*/		return 0x820C1B94;
		  /* 820C1B94h */ case   22:  		/* cmplwi CR6, R30, 0 */
		/* 820C1B94h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C1B94h case   22:*/		return 0x820C1B98;
		  /* 820C1B98h */ case   23:  		/* bc 12, CR6_EQ, 3892 */
		/* 820C1B98h case   23:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1B98h case   23:*/		return 0x820C1B9C;
		  /* 820C1B9Ch */ case   24:  		/* cmplwi CR6, R28, 0 */
		/* 820C1B9Ch case   24:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1B9Ch case   24:*/		return 0x820C1BA0;
		  /* 820C1BA0h */ case   25:  		/* bc 12, CR6_EQ, 3884 */
		/* 820C1BA0h case   25:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1BA0h case   25:*/		return 0x820C1BA4;
		  /* 820C1BA4h */ case   26:  		/* cmplwi CR6, R14, 0 */
		/* 820C1BA4h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C1BA4h case   26:*/		return 0x820C1BA8;
		  /* 820C1BA8h */ case   27:  		/* bc 12, CR6_EQ, 3844 */
		/* 820C1BA8h case   27:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C1BA8h case   27:*/		return 0x820C1BAC;
		  /* 820C1BACh */ case   28:  		/* rlwinm R31, R21, 2, 0, 29 */
		/* 820C1BACh case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R21);
		/* 820C1BACh case   28:*/		return 0x820C1BB0;
		  /* 820C1BB0h */ case   29:  		/* mr R3, R17 */
		/* 820C1BB0h case   29:*/		regs.R3 = regs.R17;
		/* 820C1BB0h case   29:*/		return 0x820C1BB4;
		  /* 820C1BB4h */ case   30:  		/* mr R4, R31 */
		/* 820C1BB4h case   30:*/		regs.R4 = regs.R31;
		/* 820C1BB4h case   30:*/		return 0x820C1BB8;
		  /* 820C1BB8h */ case   31:  		/* bl -70856 */
		/* 820C1BB8h case   31:*/		regs.LR = 0x820C1BBC; return 0x820B06F0;
		/* 820C1BB8h case   31:*/		return 0x820C1BBC;
		  /* 820C1BBCh */ case   32:  		/* or. R11, R3, R3 */
		/* 820C1BBCh case   32:*/		cpu::op::or<1>(regs,&regs.R11,regs.R3,regs.R3);
		/* 820C1BBCh case   32:*/		return 0x820C1BC0;
		  /* 820C1BC0h */ case   33:  		/* bc 12, CR0_EQ, 2724 */
		/* 820C1BC0h case   33:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C1BC0h case   33:*/		return 0x820C1BC4;
		  /* 820C1BC4h */ case   34:  		/* li R9, 4 */
		/* 820C1BC4h case   34:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820C1BC4h case   34:*/		return 0x820C1BC8;
		  /* 820C1BC8h */ case   35:  		/* addi R10, R1, 140 */
		/* 820C1BC8h case   35:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x8C);
		/* 820C1BC8h case   35:*/		return 0x820C1BCC;
		  /* 820C1BCCh */ case   36:  		/* mtspr CTR, R9 */
		/* 820C1BCCh case   36:*/		regs.CTR = regs.R9;
		/* 820C1BCCh case   36:*/		return 0x820C1BD0;
		  /* 820C1BD0h */ case   37:  		/* stwu R11, <#[R10 + 4]> */
		/* 820C1BD0h case   37:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C1BD0h case   37:*/		return 0x820C1BD4;
		  /* 820C1BD4h */ case   38:  		/* add R11, R31, R11 */
		/* 820C1BD4h case   38:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 820C1BD4h case   38:*/		return 0x820C1BD8;
		  /* 820C1BD8h */ case   39:  		/* bc 16, CR0_LT, -8 */
		/* 820C1BD8h case   39:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1BD0;  }
		/* 820C1BD8h case   39:*/		return 0x820C1BDC;
		  /* 820C1BDCh */ case   40:  		/* lwz R26, <#[R1 + 144]> */
		/* 820C1BDCh case   40:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000090) );
		/* 820C1BDCh case   40:*/		return 0x820C1BE0;
		  /* 820C1BE0h */ case   41:  		/* cmplwi CR6, R21, 0 */
		/* 820C1BE0h case   41:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1BE0h case   41:*/		return 0x820C1BE4;
		  /* 820C1BE4h */ case   42:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1BE4h case   42:*/		if ( regs.CR[6].eq ) { return 0x820C1C04;  }
		/* 820C1BE4h case   42:*/		return 0x820C1BE8;
		  /* 820C1BE8h */ case   43:  		/* addi R11, R26, -4 */
		/* 820C1BE8h case   43:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFFFC);
		/* 820C1BE8h case   43:*/		return 0x820C1BEC;
		  /* 820C1BECh */ case   44:  		/* mr R10, R22 */
		/* 820C1BECh case   44:*/		regs.R10 = regs.R22;
		/* 820C1BECh case   44:*/		return 0x820C1BF0;
		  /* 820C1BF0h */ case   45:  		/* cmplwi CR0, R21, 0 */
		/* 820C1BF0h case   45:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1BF0h case   45:*/		return 0x820C1BF4;
		  /* 820C1BF4h */ case   46:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1BF4h case   46:*/		if ( regs.CR[0].eq ) { return 0x820C1C04;  }
		/* 820C1BF4h case   46:*/		return 0x820C1BF8;
		  /* 820C1BF8h */ case   47:  		/* mtspr CTR, R21 */
		/* 820C1BF8h case   47:*/		regs.CTR = regs.R21;
		/* 820C1BF8h case   47:*/		return 0x820C1BFC;
		  /* 820C1BFCh */ case   48:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1BFCh case   48:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1BFCh case   48:*/		return 0x820C1C00;
		  /* 820C1C00h */ case   49:  		/* bc 16, CR0_LT, -4 */
		/* 820C1C00h case   49:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1BFC;  }
		/* 820C1C00h case   49:*/		return 0x820C1C04;
	}
	return 0x820C1C04;
} // Block from 820C1B3Ch-820C1C04h (50 instructions)

//////////////////////////////////////////////////////
// Block at 820C1C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1C04);
		  /* 820C1C04h */ case    0:  		/* lwz R27, <#[R1 + 148]> */
		/* 820C1C04h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000094) );
		/* 820C1C04h case    0:*/		return 0x820C1C08;
		  /* 820C1C08h */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 820C1C08h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1C08h case    1:*/		return 0x820C1C0C;
		  /* 820C1C0Ch */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1C0Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C1C2C;  }
		/* 820C1C0Ch case    2:*/		return 0x820C1C10;
		  /* 820C1C10h */ case    3:  		/* addi R11, R27, -4 */
		/* 820C1C10h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFFFFC);
		/* 820C1C10h case    3:*/		return 0x820C1C14;
		  /* 820C1C14h */ case    4:  		/* mr R10, R22 */
		/* 820C1C14h case    4:*/		regs.R10 = regs.R22;
		/* 820C1C14h case    4:*/		return 0x820C1C18;
		  /* 820C1C18h */ case    5:  		/* cmplwi CR0, R21, 0 */
		/* 820C1C18h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1C18h case    5:*/		return 0x820C1C1C;
		  /* 820C1C1Ch */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1C1Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820C1C2C;  }
		/* 820C1C1Ch case    6:*/		return 0x820C1C20;
		  /* 820C1C20h */ case    7:  		/* mtspr CTR, R21 */
		/* 820C1C20h case    7:*/		regs.CTR = regs.R21;
		/* 820C1C20h case    7:*/		return 0x820C1C24;
		  /* 820C1C24h */ case    8:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1C24h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1C24h case    8:*/		return 0x820C1C28;
		  /* 820C1C28h */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820C1C28h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1C24;  }
		/* 820C1C28h case    9:*/		return 0x820C1C2C;
	}
	return 0x820C1C2C;
} // Block from 820C1C04h-820C1C2Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C1C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1C2C);
		  /* 820C1C2Ch */ case    0:  		/* lwz R29, <#[R1 + 152]> */
		/* 820C1C2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000098) );
		/* 820C1C2Ch case    0:*/		return 0x820C1C30;
		  /* 820C1C30h */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 820C1C30h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1C30h case    1:*/		return 0x820C1C34;
		  /* 820C1C34h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1C34h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C1C54;  }
		/* 820C1C34h case    2:*/		return 0x820C1C38;
		  /* 820C1C38h */ case    3:  		/* addi R11, R29, -4 */
		/* 820C1C38h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFC);
		/* 820C1C38h case    3:*/		return 0x820C1C3C;
		  /* 820C1C3Ch */ case    4:  		/* mr R10, R22 */
		/* 820C1C3Ch case    4:*/		regs.R10 = regs.R22;
		/* 820C1C3Ch case    4:*/		return 0x820C1C40;
		  /* 820C1C40h */ case    5:  		/* cmplwi CR0, R21, 0 */
		/* 820C1C40h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1C40h case    5:*/		return 0x820C1C44;
		  /* 820C1C44h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1C44h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C1C54;  }
		/* 820C1C44h case    6:*/		return 0x820C1C48;
		  /* 820C1C48h */ case    7:  		/* mtspr CTR, R21 */
		/* 820C1C48h case    7:*/		regs.CTR = regs.R21;
		/* 820C1C48h case    7:*/		return 0x820C1C4C;
		  /* 820C1C4Ch */ case    8:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1C4Ch case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1C4Ch case    8:*/		return 0x820C1C50;
		  /* 820C1C50h */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820C1C50h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1C4C;  }
		/* 820C1C50h case    9:*/		return 0x820C1C54;
	}
	return 0x820C1C54;
} // Block from 820C1C2Ch-820C1C54h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C1C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1C54);
		  /* 820C1C54h */ case    0:  		/* lwz R28, <#[R1 + 156]> */
		/* 820C1C54h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000009C) );
		/* 820C1C54h case    0:*/		return 0x820C1C58;
		  /* 820C1C58h */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 820C1C58h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1C58h case    1:*/		return 0x820C1C5C;
		  /* 820C1C5Ch */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 820C1C5Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C1CA0;  }
		/* 820C1C5Ch case    2:*/		return 0x820C1C60;
		  /* 820C1C60h */ case    3:  		/* addi R11, R28, -4 */
		/* 820C1C60h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFC);
		/* 820C1C60h case    3:*/		return 0x820C1C64;
		  /* 820C1C64h */ case    4:  		/* mr R10, R22 */
		/* 820C1C64h case    4:*/		regs.R10 = regs.R22;
		/* 820C1C64h case    4:*/		return 0x820C1C68;
		  /* 820C1C68h */ case    5:  		/* cmplwi CR0, R21, 0 */
		/* 820C1C68h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1C68h case    5:*/		return 0x820C1C6C;
		  /* 820C1C6Ch */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1C6Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820C1C7C;  }
		/* 820C1C6Ch case    6:*/		return 0x820C1C70;
		  /* 820C1C70h */ case    7:  		/* mtspr CTR, R21 */
		/* 820C1C70h case    7:*/		regs.CTR = regs.R21;
		/* 820C1C70h case    7:*/		return 0x820C1C74;
		  /* 820C1C74h */ case    8:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1C74h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1C74h case    8:*/		return 0x820C1C78;
		  /* 820C1C78h */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820C1C78h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1C74;  }
		/* 820C1C78h case    9:*/		return 0x820C1C7C;
	}
	return 0x820C1C7C;
} // Block from 820C1C54h-820C1C7Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C1C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1C7C);
		  /* 820C1C7Ch */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 820C1C7Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1C7Ch case    0:*/		return 0x820C1C80;
		  /* 820C1C80h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1C80h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C1CA0;  }
		/* 820C1C80h case    1:*/		return 0x820C1C84;
		  /* 820C1C84h */ case    2:  		/* addi R11, R14, -4 */
		/* 820C1C84h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C1C84h case    2:*/		return 0x820C1C88;
		  /* 820C1C88h */ case    3:  		/* mr R10, R22 */
		/* 820C1C88h case    3:*/		regs.R10 = regs.R22;
		/* 820C1C88h case    3:*/		return 0x820C1C8C;
		  /* 820C1C8Ch */ case    4:  		/* cmplwi CR0, R21, 0 */
		/* 820C1C8Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1C8Ch case    4:*/		return 0x820C1C90;
		  /* 820C1C90h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1C90h case    5:*/		if ( regs.CR[0].eq ) { return 0x820C1CA0;  }
		/* 820C1C90h case    5:*/		return 0x820C1C94;
		  /* 820C1C94h */ case    6:  		/* mtspr CTR, R21 */
		/* 820C1C94h case    6:*/		regs.CTR = regs.R21;
		/* 820C1C94h case    6:*/		return 0x820C1C98;
		  /* 820C1C98h */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1C98h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1C98h case    7:*/		return 0x820C1C9C;
		  /* 820C1C9Ch */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820C1C9Ch case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1C98;  }
		/* 820C1C9Ch case    8:*/		return 0x820C1CA0;
	}
	return 0x820C1CA0;
} // Block from 820C1C7Ch-820C1CA0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C1CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1CA0);
		  /* 820C1CA0h */ case    0:  		/* mr R8, R21 */
		/* 820C1CA0h case    0:*/		regs.R8 = regs.R21;
		/* 820C1CA0h case    0:*/		return 0x820C1CA4;
		  /* 820C1CA4h */ case    1:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C1CA4h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C1CA4h case    1:*/		return 0x820C1CA8;
		  /* 820C1CA8h */ case    2:  		/* li R6, 0 */
		/* 820C1CA8h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C1CA8h case    2:*/		return 0x820C1CAC;
		  /* 820C1CACh */ case    3:  		/* mr R5, R26 */
		/* 820C1CACh case    3:*/		regs.R5 = regs.R26;
		/* 820C1CACh case    3:*/		return 0x820C1CB0;
		  /* 820C1CB0h */ case    4:  		/* mr R4, R15 */
		/* 820C1CB0h case    4:*/		regs.R4 = regs.R15;
		/* 820C1CB0h case    4:*/		return 0x820C1CB4;
		  /* 820C1CB4h */ case    5:  		/* mr R3, R17 */
		/* 820C1CB4h case    5:*/		regs.R3 = regs.R17;
		/* 820C1CB4h case    5:*/		return 0x820C1CB8;
		  /* 820C1CB8h */ case    6:  		/* bl -56072 */
		/* 820C1CB8h case    6:*/		regs.LR = 0x820C1CBC; return 0x820B41B0;
		/* 820C1CB8h case    6:*/		return 0x820C1CBC;
		  /* 820C1CBCh */ case    7:  		/* or. R31, R3, R3 */
		/* 820C1CBCh case    7:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1CBCh case    7:*/		return 0x820C1CC0;
		  /* 820C1CC0h */ case    8:  		/* bc 12, CR0_LT, 3604 */
		/* 820C1CC0h case    8:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1CC0h case    8:*/		return 0x820C1CC4;
		  /* 820C1CC4h */ case    9:  		/* mr R8, R21 */
		/* 820C1CC4h case    9:*/		regs.R8 = regs.R21;
		/* 820C1CC4h case    9:*/		return 0x820C1CC8;
		  /* 820C1CC8h */ case   10:  		/* lwz R7, <#[R1 + 132]> */
		/* 820C1CC8h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000084) );
		/* 820C1CC8h case   10:*/		return 0x820C1CCC;
		  /* 820C1CCCh */ case   11:  		/* li R6, 0 */
		/* 820C1CCCh case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C1CCCh case   11:*/		return 0x820C1CD0;
		  /* 820C1CD0h */ case   12:  		/* mr R5, R27 */
		/* 820C1CD0h case   12:*/		regs.R5 = regs.R27;
		/* 820C1CD0h case   12:*/		return 0x820C1CD4;
		  /* 820C1CD4h */ case   13:  		/* mr R4, R15 */
		/* 820C1CD4h case   13:*/		regs.R4 = regs.R15;
		/* 820C1CD4h case   13:*/		return 0x820C1CD8;
		  /* 820C1CD8h */ case   14:  		/* mr R3, R17 */
		/* 820C1CD8h case   14:*/		regs.R3 = regs.R17;
		/* 820C1CD8h case   14:*/		return 0x820C1CDC;
		  /* 820C1CDCh */ case   15:  		/* bl -56108 */
		/* 820C1CDCh case   15:*/		regs.LR = 0x820C1CE0; return 0x820B41B0;
		/* 820C1CDCh case   15:*/		return 0x820C1CE0;
		  /* 820C1CE0h */ case   16:  		/* or. R31, R3, R3 */
		/* 820C1CE0h case   16:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1CE0h case   16:*/		return 0x820C1CE4;
		  /* 820C1CE4h */ case   17:  		/* bc 12, CR0_LT, 3568 */
		/* 820C1CE4h case   17:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1CE4h case   17:*/		return 0x820C1CE8;
		  /* 820C1CE8h */ case   18:  		/* rlwinm R30, R21, 0, 12, 31 */
		/* 820C1CE8h case   18:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R21);
		/* 820C1CE8h case   18:*/		return 0x820C1CEC;
		  /* 820C1CECh */ case   19:  		/* li R9, 4 */
		/* 820C1CECh case   19:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820C1CECh case   19:*/		return 0x820C1CF0;
		  /* 820C1CF0h */ case   20:  		/* mr R8, R27 */
		/* 820C1CF0h case   20:*/		regs.R8 = regs.R27;
		/* 820C1CF0h case   20:*/		return 0x820C1CF4;
		  /* 820C1CF4h */ case   21:  		/* mr R7, R26 */
		/* 820C1CF4h case   21:*/		regs.R7 = regs.R26;
		/* 820C1CF4h case   21:*/		return 0x820C1CF8;
		  /* 820C1CF8h */ case   22:  		/* mr R6, R29 */
		/* 820C1CF8h case   22:*/		regs.R6 = regs.R29;
		/* 820C1CF8h case   22:*/		return 0x820C1CFC;
		  /* 820C1CFCh */ case   23:  		/* oris R5, R30, 8256 */
		/* 820C1CFCh case   23:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2040);
		/* 820C1CFCh case   23:*/		return 0x820C1D00;
		  /* 820C1D00h */ case   24:  		/* mr R4, R15 */
		/* 820C1D00h case   24:*/		regs.R4 = regs.R15;
		/* 820C1D00h case   24:*/		return 0x820C1D04;
		  /* 820C1D04h */ case   25:  		/* mr R3, R17 */
		/* 820C1D04h case   25:*/		regs.R3 = regs.R17;
		/* 820C1D04h case   25:*/		return 0x820C1D08;
		  /* 820C1D08h */ case   26:  		/* bl -70144 */
		/* 820C1D08h case   26:*/		regs.LR = 0x820C1D0C; return 0x820B0B08;
		/* 820C1D08h case   26:*/		return 0x820C1D0C;
		  /* 820C1D0Ch */ case   27:  		/* or. R31, R3, R3 */
		/* 820C1D0Ch case   27:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1D0Ch case   27:*/		return 0x820C1D10;
		  /* 820C1D10h */ case   28:  		/* bc 12, CR0_LT, 3524 */
		/* 820C1D10h case   28:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1D10h case   28:*/		return 0x820C1D14;
		  /* 820C1D14h */ case   29:  		/* li R9, 8 */
		/* 820C1D14h case   29:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 820C1D14h case   29:*/		return 0x820C1D18;
		  /* 820C1D18h */ case   30:  		/* li R8, 0 */
		/* 820C1D18h case   30:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C1D18h case   30:*/		return 0x820C1D1C;
		  /* 820C1D1Ch */ case   31:  		/* mr R7, R29 */
		/* 820C1D1Ch case   31:*/		regs.R7 = regs.R29;
		/* 820C1D1Ch case   31:*/		return 0x820C1D20;
		  /* 820C1D20h */ case   32:  		/* mr R6, R28 */
		/* 820C1D20h case   32:*/		regs.R6 = regs.R28;
		/* 820C1D20h case   32:*/		return 0x820C1D24;
		  /* 820C1D24h */ case   33:  		/* oris R5, R30, 4112 */
		/* 820C1D24h case   33:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1010);
		/* 820C1D24h case   33:*/		return 0x820C1D28;
		  /* 820C1D28h */ case   34:  		/* mr R4, R15 */
		/* 820C1D28h case   34:*/		regs.R4 = regs.R15;
		/* 820C1D28h case   34:*/		return 0x820C1D2C;
		  /* 820C1D2Ch */ case   35:  		/* mr R3, R17 */
		/* 820C1D2Ch case   35:*/		regs.R3 = regs.R17;
		/* 820C1D2Ch case   35:*/		return 0x820C1D30;
		  /* 820C1D30h */ case   36:  		/* bl -70184 */
		/* 820C1D30h case   36:*/		regs.LR = 0x820C1D34; return 0x820B0B08;
		/* 820C1D30h case   36:*/		return 0x820C1D34;
		  /* 820C1D34h */ case   37:  		/* or. R31, R3, R3 */
		/* 820C1D34h case   37:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1D34h case   37:*/		return 0x820C1D38;
		  /* 820C1D38h */ case   38:  		/* bc 12, CR0_LT, 3484 */
		/* 820C1D38h case   38:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1D38h case   38:*/		return 0x820C1D3C;
		  /* 820C1D3Ch */ case   39:  		/* li R9, 23 */
		/* 820C1D3Ch case   39:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C1D3Ch case   39:*/		return 0x820C1D40;
		  /* 820C1D40h */ case   40:  		/* mr R7, R28 */
		/* 820C1D40h case   40:*/		regs.R7 = regs.R28;
		/* 820C1D40h case   40:*/		return 0x820C1D44;
		  /* 820C1D44h */ case   41:  		/* oris R5, R30, 8224 */
		/* 820C1D44h case   41:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2020);
		/* 820C1D44h case   41:*/		return 0x820C1D48;
		  /* 820C1D48h */ case   42:  		/* b 808 */
		/* 820C1D48h case   42:*/		return 0x820C2070;
		/* 820C1D48h case   42:*/		return 0x820C1D4C;
		  /* 820C1D4Ch */ case   43:  		/* cmplwi CR6, R30, 0 */
		/* 820C1D4Ch case   43:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C1D4Ch case   43:*/		return 0x820C1D50;
		  /* 820C1D50h */ case   44:  		/* bc 12, CR6_EQ, 3452 */
		/* 820C1D50h case   44:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1D50h case   44:*/		return 0x820C1D54;
		  /* 820C1D54h */ case   45:  		/* cmplwi CR6, R28, 0 */
		/* 820C1D54h case   45:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1D54h case   45:*/		return 0x820C1D58;
		  /* 820C1D58h */ case   46:  		/* bc 12, CR6_EQ, 3444 */
		/* 820C1D58h case   46:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1D58h case   46:*/		return 0x820C1D5C;
		  /* 820C1D5Ch */ case   47:  		/* cmplwi CR6, R14, 0 */
		/* 820C1D5Ch case   47:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C1D5Ch case   47:*/		return 0x820C1D60;
		  /* 820C1D60h */ case   48:  		/* bc 12, CR6_EQ, 3404 */
		/* 820C1D60h case   48:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C1D60h case   48:*/		return 0x820C1D64;
		  /* 820C1D64h */ case   49:  		/* cmplwi CR6, R21, 0 */
		/* 820C1D64h case   49:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1D64h case   49:*/		return 0x820C1D68;
		  /* 820C1D68h */ case   50:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1D68h case   50:*/		if ( regs.CR[6].eq ) { return 0x820C1D88;  }
		/* 820C1D68h case   50:*/		return 0x820C1D6C;
		  /* 820C1D6Ch */ case   51:  		/* addi R11, R14, -4 */
		/* 820C1D6Ch case   51:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C1D6Ch case   51:*/		return 0x820C1D70;
		  /* 820C1D70h */ case   52:  		/* mr R10, R22 */
		/* 820C1D70h case   52:*/		regs.R10 = regs.R22;
		/* 820C1D70h case   52:*/		return 0x820C1D74;
		  /* 820C1D74h */ case   53:  		/* cmplwi CR0, R21, 0 */
		/* 820C1D74h case   53:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1D74h case   53:*/		return 0x820C1D78;
		  /* 820C1D78h */ case   54:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1D78h case   54:*/		if ( regs.CR[0].eq ) { return 0x820C1D88;  }
		/* 820C1D78h case   54:*/		return 0x820C1D7C;
		  /* 820C1D7Ch */ case   55:  		/* mtspr CTR, R21 */
		/* 820C1D7Ch case   55:*/		regs.CTR = regs.R21;
		/* 820C1D7Ch case   55:*/		return 0x820C1D80;
		  /* 820C1D80h */ case   56:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1D80h case   56:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1D80h case   56:*/		return 0x820C1D84;
		  /* 820C1D84h */ case   57:  		/* bc 16, CR0_LT, -4 */
		/* 820C1D84h case   57:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1D80;  }
		/* 820C1D84h case   57:*/		return 0x820C1D88;
	}
	return 0x820C1D88;
} // Block from 820C1CA0h-820C1D88h (58 instructions)

//////////////////////////////////////////////////////
// Block at 820C1D88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1D88);
		  /* 820C1D88h */ case    0:  		/* lwz R8, <#[R1 + 132]> */
		/* 820C1D88h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000084) );
		/* 820C1D88h case    0:*/		return 0x820C1D8C;
		  /* 820C1D8Ch */ case    1:  		/* li R11, 517 */
		/* 820C1D8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x205);
		/* 820C1D8Ch case    1:*/		return 0x820C1D90;
		  /* 820C1D90h */ case    2:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C1D90h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C1D90h case    2:*/		return 0x820C1D94;
		  /* 820C1D94h */ case    3:  		/* li R9, 0 */
		/* 820C1D94h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C1D94h case    3:*/		return 0x820C1D98;
		  /* 820C1D98h */ case    4:  		/* b -1652 */
		/* 820C1D98h case    4:*/		return 0x820C1724;
		/* 820C1D98h case    4:*/		return 0x820C1D9C;
		  /* 820C1D9Ch */ case    5:  		/* cmplwi CR6, R30, 0 */
		/* 820C1D9Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C1D9Ch case    5:*/		return 0x820C1DA0;
		  /* 820C1DA0h */ case    6:  		/* bc 12, CR6_EQ, 3372 */
		/* 820C1DA0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1DA0h case    6:*/		return 0x820C1DA4;
		  /* 820C1DA4h */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 820C1DA4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1DA4h case    7:*/		return 0x820C1DA8;
		  /* 820C1DA8h */ case    8:  		/* bc 12, CR6_EQ, 3364 */
		/* 820C1DA8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1DA8h case    8:*/		return 0x820C1DAC;
		  /* 820C1DACh */ case    9:  		/* cmplwi CR6, R14, 0 */
		/* 820C1DACh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C1DACh case    9:*/		return 0x820C1DB0;
		  /* 820C1DB0h */ case   10:  		/* bc 12, CR6_EQ, 3324 */
		/* 820C1DB0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C1DB0h case   10:*/		return 0x820C1DB4;
		  /* 820C1DB4h */ case   11:  		/* mr R4, R21 */
		/* 820C1DB4h case   11:*/		regs.R4 = regs.R21;
		/* 820C1DB4h case   11:*/		return 0x820C1DB8;
		  /* 820C1DB8h */ case   12:  		/* mr R3, R17 */
		/* 820C1DB8h case   12:*/		regs.R3 = regs.R17;
		/* 820C1DB8h case   12:*/		return 0x820C1DBC;
		  /* 820C1DBCh */ case   13:  		/* bl -71372 */
		/* 820C1DBCh case   13:*/		regs.LR = 0x820C1DC0; return 0x820B06F0;
		/* 820C1DBCh case   13:*/		return 0x820C1DC0;
		  /* 820C1DC0h */ case   14:  		/* or. R29, R3, R3 */
		/* 820C1DC0h case   14:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C1DC0h case   14:*/		return 0x820C1DC4;
		  /* 820C1DC4h */ case   15:  		/* bc 12, CR0_EQ, 2208 */
		/* 820C1DC4h case   15:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C1DC4h case   15:*/		return 0x820C1DC8;
		  /* 820C1DC8h */ case   16:  		/* cmplwi CR6, R21, 0 */
		/* 820C1DC8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1DC8h case   16:*/		return 0x820C1DCC;
		  /* 820C1DCCh */ case   17:  		/* bc 12, CR6_EQ, 68 */
		/* 820C1DCCh case   17:*/		if ( regs.CR[6].eq ) { return 0x820C1E10;  }
		/* 820C1DCCh case   17:*/		return 0x820C1DD0;
		  /* 820C1DD0h */ case   18:  		/* addi R11, R29, -4 */
		/* 820C1DD0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFC);
		/* 820C1DD0h case   18:*/		return 0x820C1DD4;
		  /* 820C1DD4h */ case   19:  		/* mr R10, R22 */
		/* 820C1DD4h case   19:*/		regs.R10 = regs.R22;
		/* 820C1DD4h case   19:*/		return 0x820C1DD8;
		  /* 820C1DD8h */ case   20:  		/* cmplwi CR0, R21, 0 */
		/* 820C1DD8h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1DD8h case   20:*/		return 0x820C1DDC;
		  /* 820C1DDCh */ case   21:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1DDCh case   21:*/		if ( regs.CR[0].eq ) { return 0x820C1DEC;  }
		/* 820C1DDCh case   21:*/		return 0x820C1DE0;
		  /* 820C1DE0h */ case   22:  		/* mtspr CTR, R21 */
		/* 820C1DE0h case   22:*/		regs.CTR = regs.R21;
		/* 820C1DE0h case   22:*/		return 0x820C1DE4;
		  /* 820C1DE4h */ case   23:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1DE4h case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1DE4h case   23:*/		return 0x820C1DE8;
		  /* 820C1DE8h */ case   24:  		/* bc 16, CR0_LT, -4 */
		/* 820C1DE8h case   24:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1DE4;  }
		/* 820C1DE8h case   24:*/		return 0x820C1DEC;
	}
	return 0x820C1DEC;
} // Block from 820C1D88h-820C1DECh (25 instructions)

//////////////////////////////////////////////////////
// Block at 820C1DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1DEC);
		  /* 820C1DECh */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 820C1DECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1DECh case    0:*/		return 0x820C1DF0;
		  /* 820C1DF0h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1DF0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C1E10;  }
		/* 820C1DF0h case    1:*/		return 0x820C1DF4;
		  /* 820C1DF4h */ case    2:  		/* addi R11, R14, -4 */
		/* 820C1DF4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C1DF4h case    2:*/		return 0x820C1DF8;
		  /* 820C1DF8h */ case    3:  		/* mr R10, R22 */
		/* 820C1DF8h case    3:*/		regs.R10 = regs.R22;
		/* 820C1DF8h case    3:*/		return 0x820C1DFC;
		  /* 820C1DFCh */ case    4:  		/* cmplwi CR0, R21, 0 */
		/* 820C1DFCh case    4:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1DFCh case    4:*/		return 0x820C1E00;
		  /* 820C1E00h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1E00h case    5:*/		if ( regs.CR[0].eq ) { return 0x820C1E10;  }
		/* 820C1E00h case    5:*/		return 0x820C1E04;
		  /* 820C1E04h */ case    6:  		/* mtspr CTR, R21 */
		/* 820C1E04h case    6:*/		regs.CTR = regs.R21;
		/* 820C1E04h case    6:*/		return 0x820C1E08;
		  /* 820C1E08h */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1E08h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1E08h case    7:*/		return 0x820C1E0C;
		  /* 820C1E0Ch */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820C1E0Ch case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1E08;  }
		/* 820C1E0Ch case    8:*/		return 0x820C1E10;
	}
	return 0x820C1E10;
} // Block from 820C1DECh-820C1E10h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C1E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1E10);
		  /* 820C1E10h */ case    0:  		/* rlwinm R30, R21, 0, 12, 31 */
		/* 820C1E10h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R21);
		/* 820C1E10h case    0:*/		return 0x820C1E14;
		  /* 820C1E14h */ case    1:  		/* lwz R7, <#[R1 + 132]> */
		/* 820C1E14h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000084) );
		/* 820C1E14h case    1:*/		return 0x820C1E18;
		  /* 820C1E18h */ case    2:  		/* li R9, 0 */
		/* 820C1E18h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C1E18h case    2:*/		return 0x820C1E1C;
		  /* 820C1E1Ch */ case    3:  		/* li R8, 0 */
		/* 820C1E1Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C1E1Ch case    3:*/		return 0x820C1E20;
		  /* 820C1E20h */ case    4:  		/* mr R6, R29 */
		/* 820C1E20h case    4:*/		regs.R6 = regs.R29;
		/* 820C1E20h case    4:*/		return 0x820C1E24;
		  /* 820C1E24h */ case    5:  		/* oris R5, R30, 4144 */
		/* 820C1E24h case    5:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1030);
		/* 820C1E24h case    5:*/		return 0x820C1E28;
		  /* 820C1E28h */ case    6:  		/* mr R4, R15 */
		/* 820C1E28h case    6:*/		regs.R4 = regs.R15;
		/* 820C1E28h case    6:*/		return 0x820C1E2C;
		  /* 820C1E2Ch */ case    7:  		/* mr R3, R17 */
		/* 820C1E2Ch case    7:*/		regs.R3 = regs.R17;
		/* 820C1E2Ch case    7:*/		return 0x820C1E30;
		  /* 820C1E30h */ case    8:  		/* bl -70440 */
		/* 820C1E30h case    8:*/		regs.LR = 0x820C1E34; return 0x820B0B08;
		/* 820C1E30h case    8:*/		return 0x820C1E34;
		  /* 820C1E34h */ case    9:  		/* or. R31, R3, R3 */
		/* 820C1E34h case    9:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1E34h case    9:*/		return 0x820C1E38;
		  /* 820C1E38h */ case   10:  		/* bc 12, CR0_LT, 3228 */
		/* 820C1E38h case   10:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1E38h case   10:*/		return 0x820C1E3C;
		  /* 820C1E3Ch */ case   11:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C1E3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C1E3Ch case   11:*/		return 0x820C1E40;
		  /* 820C1E40h */ case   12:  		/* oris R5, R30, 8272 */
		/* 820C1E40h case   12:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2050);
		/* 820C1E40h case   12:*/		return 0x820C1E44;
		  /* 820C1E44h */ case   13:  		/* b 552 */
		/* 820C1E44h case   13:*/		return 0x820C206C;
		/* 820C1E44h case   13:*/		return 0x820C1E48;
		  /* 820C1E48h */ case   14:  		/* cmplwi CR6, R30, 0 */
		/* 820C1E48h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C1E48h case   14:*/		return 0x820C1E4C;
		  /* 820C1E4Ch */ case   15:  		/* bc 12, CR6_EQ, 3200 */
		/* 820C1E4Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1E4Ch case   15:*/		return 0x820C1E50;
		  /* 820C1E50h */ case   16:  		/* cmplwi CR6, R28, 0 */
		/* 820C1E50h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C1E50h case   16:*/		return 0x820C1E54;
		  /* 820C1E54h */ case   17:  		/* bc 12, CR6_EQ, 3192 */
		/* 820C1E54h case   17:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C1E54h case   17:*/		return 0x820C1E58;
		  /* 820C1E58h */ case   18:  		/* cmplwi CR6, R14, 0 */
		/* 820C1E58h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C1E58h case   18:*/		return 0x820C1E5C;
		  /* 820C1E5Ch */ case   19:  		/* bc 12, CR6_EQ, 3152 */
		/* 820C1E5Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C1E5Ch case   19:*/		return 0x820C1E60;
		  /* 820C1E60h */ case   20:  		/* rlwinm R4, R21, 3, 0, 28 */
		/* 820C1E60h case   20:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R4,regs.R21);
		/* 820C1E60h case   20:*/		return 0x820C1E64;
		  /* 820C1E64h */ case   21:  		/* mr R3, R17 */
		/* 820C1E64h case   21:*/		regs.R3 = regs.R17;
		/* 820C1E64h case   21:*/		return 0x820C1E68;
		  /* 820C1E68h */ case   22:  		/* bl -71544 */
		/* 820C1E68h case   22:*/		regs.LR = 0x820C1E6C; return 0x820B06F0;
		/* 820C1E68h case   22:*/		return 0x820C1E6C;
		  /* 820C1E6Ch */ case   23:  		/* or. R11, R3, R3 */
		/* 820C1E6Ch case   23:*/		cpu::op::or<1>(regs,&regs.R11,regs.R3,regs.R3);
		/* 820C1E6Ch case   23:*/		return 0x820C1E70;
		  /* 820C1E70h */ case   24:  		/* bc 12, CR0_EQ, 2036 */
		/* 820C1E70h case   24:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C1E70h case   24:*/		return 0x820C1E74;
		  /* 820C1E74h */ case   25:  		/* li R10, 8 */
		/* 820C1E74h case   25:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 820C1E74h case   25:*/		return 0x820C1E78;
		  /* 820C1E78h */ case   26:  		/* addi R9, R1, 156 */
		/* 820C1E78h case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x9C);
		/* 820C1E78h case   26:*/		return 0x820C1E7C;
		  /* 820C1E7Ch */ case   27:  		/* rlwinm R8, R21, 2, 0, 29 */
		/* 820C1E7Ch case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R21);
		/* 820C1E7Ch case   27:*/		return 0x820C1E80;
		  /* 820C1E80h */ case   28:  		/* mtspr CTR, R10 */
		/* 820C1E80h case   28:*/		regs.CTR = regs.R10;
		/* 820C1E80h case   28:*/		return 0x820C1E84;
		  /* 820C1E84h */ case   29:  		/* stwu R11, <#[R9 + 4]> */
		/* 820C1E84h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C1E84h case   29:*/		return 0x820C1E88;
		  /* 820C1E88h */ case   30:  		/* add R11, R8, R11 */
		/* 820C1E88h case   30:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820C1E88h case   30:*/		return 0x820C1E8C;
		  /* 820C1E8Ch */ case   31:  		/* bc 16, CR0_LT, -8 */
		/* 820C1E8Ch case   31:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1E84;  }
		/* 820C1E8Ch case   31:*/		return 0x820C1E90;
		  /* 820C1E90h */ case   32:  		/* addi R9, R1, 160 */
		/* 820C1E90h case   32:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xA0);
		/* 820C1E90h case   32:*/		return 0x820C1E94;
		  /* 820C1E94h */ case   33:  		/* li R8, 8 */
		/* 820C1E94h case   33:*/		cpu::op::li<0>(regs,&regs.R8,0x8);
		/* 820C1E94h case   33:*/		return 0x820C1E98;
		  /* 820C1E98h */ case   34:  		/* lwz R11, <#[R9]> */
		/* 820C1E98h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820C1E98h case   34:*/		return 0x820C1E9C;
		  /* 820C1E9Ch */ case   35:  		/* cmplwi CR6, R21, 0 */
		/* 820C1E9Ch case   35:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1E9Ch case   35:*/		return 0x820C1EA0;
		  /* 820C1EA0h */ case   36:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1EA0h case   36:*/		if ( regs.CR[6].eq ) { return 0x820C1EC0;  }
		/* 820C1EA0h case   36:*/		return 0x820C1EA4;
		  /* 820C1EA4h */ case   37:  		/* addi R11, R11, -4 */
		/* 820C1EA4h case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820C1EA4h case   37:*/		return 0x820C1EA8;
		  /* 820C1EA8h */ case   38:  		/* mr R10, R22 */
		/* 820C1EA8h case   38:*/		regs.R10 = regs.R22;
		/* 820C1EA8h case   38:*/		return 0x820C1EAC;
		  /* 820C1EACh */ case   39:  		/* cmplwi CR0, R21, 0 */
		/* 820C1EACh case   39:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1EACh case   39:*/		return 0x820C1EB0;
		  /* 820C1EB0h */ case   40:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1EB0h case   40:*/		if ( regs.CR[0].eq ) { return 0x820C1EC0;  }
		/* 820C1EB0h case   40:*/		return 0x820C1EB4;
		  /* 820C1EB4h */ case   41:  		/* mtspr CTR, R21 */
		/* 820C1EB4h case   41:*/		regs.CTR = regs.R21;
		/* 820C1EB4h case   41:*/		return 0x820C1EB8;
		  /* 820C1EB8h */ case   42:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1EB8h case   42:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1EB8h case   42:*/		return 0x820C1EBC;
		  /* 820C1EBCh */ case   43:  		/* bc 16, CR0_LT, -4 */
		/* 820C1EBCh case   43:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1EB8;  }
		/* 820C1EBCh case   43:*/		return 0x820C1EC0;
	}
	return 0x820C1EC0;
} // Block from 820C1E10h-820C1EC0h (44 instructions)

//////////////////////////////////////////////////////
// Block at 820C1EC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1EC0);
		  /* 820C1EC0h */ case    0:  		/* addic. R8, R8, -1 */
		/* 820C1EC0h case    0:*/		cpu::op::addic<1>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820C1EC0h case    0:*/		return 0x820C1EC4;
		  /* 820C1EC4h */ case    1:  		/* addi R9, R9, 4 */
		/* 820C1EC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820C1EC4h case    1:*/		return 0x820C1EC8;
		  /* 820C1EC8h */ case    2:  		/* bc 4, CR0_EQ, -48 */
		/* 820C1EC8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820C1E98;  }
		/* 820C1EC8h case    2:*/		return 0x820C1ECC;
		  /* 820C1ECCh */ case    3:  		/* cmplwi CR6, R21, 0 */
		/* 820C1ECCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C1ECCh case    3:*/		return 0x820C1ED0;
		  /* 820C1ED0h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 820C1ED0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C1EF0;  }
		/* 820C1ED0h case    4:*/		return 0x820C1ED4;
		  /* 820C1ED4h */ case    5:  		/* addi R11, R14, -4 */
		/* 820C1ED4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C1ED4h case    5:*/		return 0x820C1ED8;
		  /* 820C1ED8h */ case    6:  		/* mr R10, R22 */
		/* 820C1ED8h case    6:*/		regs.R10 = regs.R22;
		/* 820C1ED8h case    6:*/		return 0x820C1EDC;
		  /* 820C1EDCh */ case    7:  		/* cmplwi CR0, R21, 0 */
		/* 820C1EDCh case    7:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C1EDCh case    7:*/		return 0x820C1EE0;
		  /* 820C1EE0h */ case    8:  		/* bc 12, CR0_EQ, 16 */
		/* 820C1EE0h case    8:*/		if ( regs.CR[0].eq ) { return 0x820C1EF0;  }
		/* 820C1EE0h case    8:*/		return 0x820C1EE4;
		  /* 820C1EE4h */ case    9:  		/* mtspr CTR, R21 */
		/* 820C1EE4h case    9:*/		regs.CTR = regs.R21;
		/* 820C1EE4h case    9:*/		return 0x820C1EE8;
		  /* 820C1EE8h */ case   10:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C1EE8h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C1EE8h case   10:*/		return 0x820C1EEC;
		  /* 820C1EECh */ case   11:  		/* bc 16, CR0_LT, -4 */
		/* 820C1EECh case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C1EE8;  }
		/* 820C1EECh case   11:*/		return 0x820C1EF0;
	}
	return 0x820C1EF0;
} // Block from 820C1EC0h-820C1EF0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C1EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C1EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C1EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C1EF0);
		  /* 820C1EF0h */ case    0:  		/* rlwinm R30, R21, 0, 12, 31 */
		/* 820C1EF0h case    0:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R21);
		/* 820C1EF0h case    0:*/		return 0x820C1EF4;
		  /* 820C1EF4h */ case    1:  		/* lwz R29, <#[R1 + 160]> */
		/* 820C1EF4h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000A0) );
		/* 820C1EF4h case    1:*/		return 0x820C1EF8;
		  /* 820C1EF8h */ case    2:  		/* lwz R24, <#[R1 + 132]> */
		/* 820C1EF8h case    2:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000084) );
		/* 820C1EF8h case    2:*/		return 0x820C1EFC;
		  /* 820C1EFCh */ case    3:  		/* li R9, 0 */
		/* 820C1EFCh case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C1EFCh case    3:*/		return 0x820C1F00;
		  /* 820C1F00h */ case    4:  		/* lwz R23, <#[R1 + 128]> */
		/* 820C1F00h case    4:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x00000080) );
		/* 820C1F00h case    4:*/		return 0x820C1F04;
		  /* 820C1F04h */ case    5:  		/* oris R25, R30, 8272 */
		/* 820C1F04h case    5:*/		cpu::op::oris<0>(regs,&regs.R25,regs.R30,0x2050);
		/* 820C1F04h case    5:*/		return 0x820C1F08;
		  /* 820C1F08h */ case    6:  		/* mr R8, R24 */
		/* 820C1F08h case    6:*/		regs.R8 = regs.R24;
		/* 820C1F08h case    6:*/		return 0x820C1F0C;
		  /* 820C1F0Ch */ case    7:  		/* mr R7, R23 */
		/* 820C1F0Ch case    7:*/		regs.R7 = regs.R23;
		/* 820C1F0Ch case    7:*/		return 0x820C1F10;
		  /* 820C1F10h */ case    8:  		/* mr R6, R29 */
		/* 820C1F10h case    8:*/		regs.R6 = regs.R29;
		/* 820C1F10h case    8:*/		return 0x820C1F14;
		  /* 820C1F14h */ case    9:  		/* mr R5, R25 */
		/* 820C1F14h case    9:*/		regs.R5 = regs.R25;
		/* 820C1F14h case    9:*/		return 0x820C1F18;
		  /* 820C1F18h */ case   10:  		/* mr R4, R15 */
		/* 820C1F18h case   10:*/		regs.R4 = regs.R15;
		/* 820C1F18h case   10:*/		return 0x820C1F1C;
		  /* 820C1F1Ch */ case   11:  		/* mr R3, R17 */
		/* 820C1F1Ch case   11:*/		regs.R3 = regs.R17;
		/* 820C1F1Ch case   11:*/		return 0x820C1F20;
		  /* 820C1F20h */ case   12:  		/* bl -70680 */
		/* 820C1F20h case   12:*/		regs.LR = 0x820C1F24; return 0x820B0B08;
		/* 820C1F20h case   12:*/		return 0x820C1F24;
		  /* 820C1F24h */ case   13:  		/* or. R31, R3, R3 */
		/* 820C1F24h case   13:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1F24h case   13:*/		return 0x820C1F28;
		  /* 820C1F28h */ case   14:  		/* bc 12, CR0_LT, 2988 */
		/* 820C1F28h case   14:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1F28h case   14:*/		return 0x820C1F2C;
		  /* 820C1F2Ch */ case   15:  		/* lwz R28, <#[R1 + 164]> */
		/* 820C1F2Ch case   15:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000A4) );
		/* 820C1F2Ch case   15:*/		return 0x820C1F30;
		  /* 820C1F30h */ case   16:  		/* oris R27, R30, 4112 */
		/* 820C1F30h case   16:*/		cpu::op::oris<0>(regs,&regs.R27,regs.R30,0x1010);
		/* 820C1F30h case   16:*/		return 0x820C1F34;
		  /* 820C1F34h */ case   17:  		/* li R9, 0 */
		/* 820C1F34h case   17:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C1F34h case   17:*/		return 0x820C1F38;
		  /* 820C1F38h */ case   18:  		/* li R8, 0 */
		/* 820C1F38h case   18:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C1F38h case   18:*/		return 0x820C1F3C;
		  /* 820C1F3Ch */ case   19:  		/* mr R7, R29 */
		/* 820C1F3Ch case   19:*/		regs.R7 = regs.R29;
		/* 820C1F3Ch case   19:*/		return 0x820C1F40;
		  /* 820C1F40h */ case   20:  		/* mr R6, R28 */
		/* 820C1F40h case   20:*/		regs.R6 = regs.R28;
		/* 820C1F40h case   20:*/		return 0x820C1F44;
		  /* 820C1F44h */ case   21:  		/* mr R5, R27 */
		/* 820C1F44h case   21:*/		regs.R5 = regs.R27;
		/* 820C1F44h case   21:*/		return 0x820C1F48;
		  /* 820C1F48h */ case   22:  		/* mr R4, R15 */
		/* 820C1F48h case   22:*/		regs.R4 = regs.R15;
		/* 820C1F48h case   22:*/		return 0x820C1F4C;
		  /* 820C1F4Ch */ case   23:  		/* mr R3, R17 */
		/* 820C1F4Ch case   23:*/		regs.R3 = regs.R17;
		/* 820C1F4Ch case   23:*/		return 0x820C1F50;
		  /* 820C1F50h */ case   24:  		/* bl -70728 */
		/* 820C1F50h case   24:*/		regs.LR = 0x820C1F54; return 0x820B0B08;
		/* 820C1F50h case   24:*/		return 0x820C1F54;
		  /* 820C1F54h */ case   25:  		/* or. R31, R3, R3 */
		/* 820C1F54h case   25:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1F54h case   25:*/		return 0x820C1F58;
		  /* 820C1F58h */ case   26:  		/* bc 12, CR0_LT, 2940 */
		/* 820C1F58h case   26:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1F58h case   26:*/		return 0x820C1F5C;
		  /* 820C1F5Ch */ case   27:  		/* lwz R26, <#[R1 + 168]> */
		/* 820C1F5Ch case   27:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000A8) );
		/* 820C1F5Ch case   27:*/		return 0x820C1F60;
		  /* 820C1F60h */ case   28:  		/* li R9, 23 */
		/* 820C1F60h case   28:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C1F60h case   28:*/		return 0x820C1F64;
		  /* 820C1F64h */ case   29:  		/* mr R8, R28 */
		/* 820C1F64h case   29:*/		regs.R8 = regs.R28;
		/* 820C1F64h case   29:*/		return 0x820C1F68;
		  /* 820C1F68h */ case   30:  		/* mr R7, R29 */
		/* 820C1F68h case   30:*/		regs.R7 = regs.R29;
		/* 820C1F68h case   30:*/		return 0x820C1F6C;
		  /* 820C1F6Ch */ case   31:  		/* mr R6, R26 */
		/* 820C1F6Ch case   31:*/		regs.R6 = regs.R26;
		/* 820C1F6Ch case   31:*/		return 0x820C1F70;
		  /* 820C1F70h */ case   32:  		/* oris R5, R30, 8240 */
		/* 820C1F70h case   32:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2030);
		/* 820C1F70h case   32:*/		return 0x820C1F74;
		  /* 820C1F74h */ case   33:  		/* mr R4, R15 */
		/* 820C1F74h case   33:*/		regs.R4 = regs.R15;
		/* 820C1F74h case   33:*/		return 0x820C1F78;
		  /* 820C1F78h */ case   34:  		/* mr R3, R17 */
		/* 820C1F78h case   34:*/		regs.R3 = regs.R17;
		/* 820C1F78h case   34:*/		return 0x820C1F7C;
		  /* 820C1F7Ch */ case   35:  		/* bl -70772 */
		/* 820C1F7Ch case   35:*/		regs.LR = 0x820C1F80; return 0x820B0B08;
		/* 820C1F7Ch case   35:*/		return 0x820C1F80;
		  /* 820C1F80h */ case   36:  		/* or. R31, R3, R3 */
		/* 820C1F80h case   36:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1F80h case   36:*/		return 0x820C1F84;
		  /* 820C1F84h */ case   37:  		/* bc 12, CR0_LT, 2896 */
		/* 820C1F84h case   37:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1F84h case   37:*/		return 0x820C1F88;
		  /* 820C1F88h */ case   38:  		/* lwz R29, <#[R1 + 172]> */
		/* 820C1F88h case   38:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000AC) );
		/* 820C1F88h case   38:*/		return 0x820C1F8C;
		  /* 820C1F8Ch */ case   39:  		/* li R9, 0 */
		/* 820C1F8Ch case   39:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C1F8Ch case   39:*/		return 0x820C1F90;
		  /* 820C1F90h */ case   40:  		/* li R8, 0 */
		/* 820C1F90h case   40:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C1F90h case   40:*/		return 0x820C1F94;
		  /* 820C1F94h */ case   41:  		/* mr R7, R24 */
		/* 820C1F94h case   41:*/		regs.R7 = regs.R24;
		/* 820C1F94h case   41:*/		return 0x820C1F98;
		  /* 820C1F98h */ case   42:  		/* mr R6, R29 */
		/* 820C1F98h case   42:*/		regs.R6 = regs.R29;
		/* 820C1F98h case   42:*/		return 0x820C1F9C;
		  /* 820C1F9Ch */ case   43:  		/* mr R5, R27 */
		/* 820C1F9Ch case   43:*/		regs.R5 = regs.R27;
		/* 820C1F9Ch case   43:*/		return 0x820C1FA0;
		  /* 820C1FA0h */ case   44:  		/* mr R4, R15 */
		/* 820C1FA0h case   44:*/		regs.R4 = regs.R15;
		/* 820C1FA0h case   44:*/		return 0x820C1FA4;
		  /* 820C1FA4h */ case   45:  		/* mr R3, R17 */
		/* 820C1FA4h case   45:*/		regs.R3 = regs.R17;
		/* 820C1FA4h case   45:*/		return 0x820C1FA8;
		  /* 820C1FA8h */ case   46:  		/* bl -70816 */
		/* 820C1FA8h case   46:*/		regs.LR = 0x820C1FAC; return 0x820B0B08;
		/* 820C1FA8h case   46:*/		return 0x820C1FAC;
		  /* 820C1FACh */ case   47:  		/* or. R31, R3, R3 */
		/* 820C1FACh case   47:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1FACh case   47:*/		return 0x820C1FB0;
		  /* 820C1FB0h */ case   48:  		/* bc 12, CR0_LT, 2852 */
		/* 820C1FB0h case   48:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1FB0h case   48:*/		return 0x820C1FB4;
		  /* 820C1FB4h */ case   49:  		/* lwz R27, <#[R1 + 176]> */
		/* 820C1FB4h case   49:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000B0) );
		/* 820C1FB4h case   49:*/		return 0x820C1FB8;
		  /* 820C1FB8h */ case   50:  		/* mr R9, R21 */
		/* 820C1FB8h case   50:*/		regs.R9 = regs.R21;
		/* 820C1FB8h case   50:*/		return 0x820C1FBC;
		  /* 820C1FBCh */ case   51:  		/* mr R8, R26 */
		/* 820C1FBCh case   51:*/		regs.R8 = regs.R26;
		/* 820C1FBCh case   51:*/		return 0x820C1FC0;
		  /* 820C1FC0h */ case   52:  		/* mr R7, R24 */
		/* 820C1FC0h case   52:*/		regs.R7 = regs.R24;
		/* 820C1FC0h case   52:*/		return 0x820C1FC4;
		  /* 820C1FC4h */ case   53:  		/* mr R6, R29 */
		/* 820C1FC4h case   53:*/		regs.R6 = regs.R29;
		/* 820C1FC4h case   53:*/		return 0x820C1FC8;
		  /* 820C1FC8h */ case   54:  		/* mr R5, R27 */
		/* 820C1FC8h case   54:*/		regs.R5 = regs.R27;
		/* 820C1FC8h case   54:*/		return 0x820C1FCC;
		  /* 820C1FCCh */ case   55:  		/* mr R4, R15 */
		/* 820C1FCCh case   55:*/		regs.R4 = regs.R15;
		/* 820C1FCCh case   55:*/		return 0x820C1FD0;
		  /* 820C1FD0h */ case   56:  		/* mr R3, R17 */
		/* 820C1FD0h case   56:*/		regs.R3 = regs.R17;
		/* 820C1FD0h case   56:*/		return 0x820C1FD4;
		  /* 820C1FD4h */ case   57:  		/* bl -59988 */
		/* 820C1FD4h case   57:*/		regs.LR = 0x820C1FD8; return 0x820B3580;
		/* 820C1FD4h case   57:*/		return 0x820C1FD8;
		  /* 820C1FD8h */ case   58:  		/* or. R31, R3, R3 */
		/* 820C1FD8h case   58:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C1FD8h case   58:*/		return 0x820C1FDC;
		  /* 820C1FDCh */ case   59:  		/* bc 12, CR0_LT, 2808 */
		/* 820C1FDCh case   59:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C1FDCh case   59:*/		return 0x820C1FE0;
		  /* 820C1FE0h */ case   60:  		/* lwz R29, <#[R1 + 180]> */
		/* 820C1FE0h case   60:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000B4) );
		/* 820C1FE0h case   60:*/		return 0x820C1FE4;
		  /* 820C1FE4h */ case   61:  		/* li R9, 64 */
		/* 820C1FE4h case   61:*/		cpu::op::li<0>(regs,&regs.R9,0x40);
		/* 820C1FE4h case   61:*/		return 0x820C1FE8;
		  /* 820C1FE8h */ case   62:  		/* li R8, 0 */
		/* 820C1FE8h case   62:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C1FE8h case   62:*/		return 0x820C1FEC;
		  /* 820C1FECh */ case   63:  		/* mr R7, R27 */
		/* 820C1FECh case   63:*/		regs.R7 = regs.R27;
		/* 820C1FECh case   63:*/		return 0x820C1FF0;
		  /* 820C1FF0h */ case   64:  		/* mr R6, R29 */
		/* 820C1FF0h case   64:*/		regs.R6 = regs.R29;
		/* 820C1FF0h case   64:*/		return 0x820C1FF4;
		  /* 820C1FF4h */ case   65:  		/* oris R5, R30, 4144 */
		/* 820C1FF4h case   65:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1030);
		/* 820C1FF4h case   65:*/		return 0x820C1FF8;
		  /* 820C1FF8h */ case   66:  		/* mr R4, R15 */
		/* 820C1FF8h case   66:*/		regs.R4 = regs.R15;
		/* 820C1FF8h case   66:*/		return 0x820C1FFC;
		  /* 820C1FFCh */ case   67:  		/* mr R3, R17 */
		/* 820C1FFCh case   67:*/		regs.R3 = regs.R17;
		/* 820C1FFCh case   67:*/		return 0x820C2000;
		  /* 820C2000h */ case   68:  		/* bl -70904 */
		/* 820C2000h case   68:*/		regs.LR = 0x820C2004; return 0x820B0B08;
		/* 820C2000h case   68:*/		return 0x820C2004;
		  /* 820C2004h */ case   69:  		/* or. R31, R3, R3 */
		/* 820C2004h case   69:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C2004h case   69:*/		return 0x820C2008;
		  /* 820C2008h */ case   70:  		/* bc 12, CR0_LT, 2764 */
		/* 820C2008h case   70:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C2008h case   70:*/		return 0x820C200C;
		  /* 820C200Ch */ case   71:  		/* lwz R28, <#[R1 + 184]> */
		/* 820C200Ch case   71:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000B8) );
		/* 820C200Ch case   71:*/		return 0x820C2010;
		  /* 820C2010h */ case   72:  		/* li R9, 0 */
		/* 820C2010h case   72:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C2010h case   72:*/		return 0x820C2014;
		  /* 820C2014h */ case   73:  		/* mr R8, R29 */
		/* 820C2014h case   73:*/		regs.R8 = regs.R29;
		/* 820C2014h case   73:*/		return 0x820C2018;
		  /* 820C2018h */ case   74:  		/* mr R7, R23 */
		/* 820C2018h case   74:*/		regs.R7 = regs.R23;
		/* 820C2018h case   74:*/		return 0x820C201C;
		  /* 820C201Ch */ case   75:  		/* mr R6, R28 */
		/* 820C201Ch case   75:*/		regs.R6 = regs.R28;
		/* 820C201Ch case   75:*/		return 0x820C2020;
		  /* 820C2020h */ case   76:  		/* mr R5, R25 */
		/* 820C2020h case   76:*/		regs.R5 = regs.R25;
		/* 820C2020h case   76:*/		return 0x820C2024;
		  /* 820C2024h */ case   77:  		/* mr R4, R15 */
		/* 820C2024h case   77:*/		regs.R4 = regs.R15;
		/* 820C2024h case   77:*/		return 0x820C2028;
		  /* 820C2028h */ case   78:  		/* mr R3, R17 */
		/* 820C2028h case   78:*/		regs.R3 = regs.R17;
		/* 820C2028h case   78:*/		return 0x820C202C;
		  /* 820C202Ch */ case   79:  		/* bl -70948 */
		/* 820C202Ch case   79:*/		regs.LR = 0x820C2030; return 0x820B0B08;
		/* 820C202Ch case   79:*/		return 0x820C2030;
		  /* 820C2030h */ case   80:  		/* or. R31, R3, R3 */
		/* 820C2030h case   80:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C2030h case   80:*/		return 0x820C2034;
		  /* 820C2034h */ case   81:  		/* bc 12, CR0_LT, 2720 */
		/* 820C2034h case   81:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C2034h case   81:*/		return 0x820C2038;
		  /* 820C2038h */ case   82:  		/* lwz R29, <#[R1 + 188]> */
		/* 820C2038h case   82:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000BC) );
		/* 820C2038h case   82:*/		return 0x820C203C;
		  /* 820C203Ch */ case   83:  		/* li R9, 4 */
		/* 820C203Ch case   83:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820C203Ch case   83:*/		return 0x820C2040;
		  /* 820C2040h */ case   84:  		/* li R8, 0 */
		/* 820C2040h case   84:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C2040h case   84:*/		return 0x820C2044;
		  /* 820C2044h */ case   85:  		/* mr R7, R28 */
		/* 820C2044h case   85:*/		regs.R7 = regs.R28;
		/* 820C2044h case   85:*/		return 0x820C2048;
		  /* 820C2048h */ case   86:  		/* mr R6, R29 */
		/* 820C2048h case   86:*/		regs.R6 = regs.R29;
		/* 820C2048h case   86:*/		return 0x820C204C;
		  /* 820C204Ch */ case   87:  		/* oris R5, R30, 4160 */
		/* 820C204Ch case   87:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1040);
		/* 820C204Ch case   87:*/		return 0x820C2050;
		  /* 820C2050h */ case   88:  		/* mr R4, R15 */
		/* 820C2050h case   88:*/		regs.R4 = regs.R15;
		/* 820C2050h case   88:*/		return 0x820C2054;
		  /* 820C2054h */ case   89:  		/* mr R3, R17 */
		/* 820C2054h case   89:*/		regs.R3 = regs.R17;
		/* 820C2054h case   89:*/		return 0x820C2058;
		  /* 820C2058h */ case   90:  		/* bl -70992 */
		/* 820C2058h case   90:*/		regs.LR = 0x820C205C; return 0x820B0B08;
		/* 820C2058h case   90:*/		return 0x820C205C;
		  /* 820C205Ch */ case   91:  		/* or. R31, R3, R3 */
		/* 820C205Ch case   91:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C205Ch case   91:*/		return 0x820C2060;
		  /* 820C2060h */ case   92:  		/* bc 12, CR0_LT, 2676 */
		/* 820C2060h case   92:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C2060h case   92:*/		return 0x820C2064;
		  /* 820C2064h */ case   93:  		/* mr R7, R27 */
		/* 820C2064h case   93:*/		regs.R7 = regs.R27;
		/* 820C2064h case   93:*/		return 0x820C2068;
		  /* 820C2068h */ case   94:  		/* mr R5, R25 */
		/* 820C2068h case   94:*/		regs.R5 = regs.R25;
		/* 820C2068h case   94:*/		return 0x820C206C;
	}
	return 0x820C206C;
} // Block from 820C1EF0h-820C206Ch (95 instructions)

//////////////////////////////////////////////////////
// Block at 820C206Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C206C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C206C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C206C);
		  /* 820C206Ch */ case    0:  		/* li R9, 0 */
		/* 820C206Ch case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C206Ch case    0:*/		return 0x820C2070;
	}
	return 0x820C2070;
} // Block from 820C206Ch-820C2070h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2070);
		  /* 820C2070h */ case    0:  		/* mr R8, R29 */
		/* 820C2070h case    0:*/		regs.R8 = regs.R29;
		/* 820C2070h case    0:*/		return 0x820C2074;
	}
	return 0x820C2074;
} // Block from 820C2070h-820C2074h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2074);
		  /* 820C2074h */ case    0:  		/* mr R6, R14 */
		/* 820C2074h case    0:*/		regs.R6 = regs.R14;
		/* 820C2074h case    0:*/		return 0x820C2078;
		  /* 820C2078h */ case    1:  		/* mr R4, R15 */
		/* 820C2078h case    1:*/		regs.R4 = regs.R15;
		/* 820C2078h case    1:*/		return 0x820C207C;
		  /* 820C207Ch */ case    2:  		/* mr R3, R17 */
		/* 820C207Ch case    2:*/		regs.R3 = regs.R17;
		/* 820C207Ch case    2:*/		return 0x820C2080;
		  /* 820C2080h */ case    3:  		/* bl -71032 */
		/* 820C2080h case    3:*/		regs.LR = 0x820C2084; return 0x820B0B08;
		/* 820C2080h case    3:*/		return 0x820C2084;
		  /* 820C2084h */ case    4:  		/* b 700 */
		/* 820C2084h case    4:*/		return 0x820C2340;
		/* 820C2084h case    4:*/		return 0x820C2088;
		  /* 820C2088h */ case    5:  		/* cmplwi CR6, R28, 0 */
		/* 820C2088h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C2088h case    5:*/		return 0x820C208C;
		  /* 820C208Ch */ case    6:  		/* bc 12, CR6_EQ, 2624 */
		/* 820C208Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C208Ch case    6:*/		return 0x820C2090;
		  /* 820C2090h */ case    7:  		/* mr R10, R24 */
		/* 820C2090h case    7:*/		regs.R10 = regs.R24;
		/* 820C2090h case    7:*/		return 0x820C2094;
		  /* 820C2094h */ case    8:  		/* lwz R9, <#[R30 + 16]> */
		/* 820C2094h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 820C2094h case    8:*/		return 0x820C2098;
		  /* 820C2098h */ case    9:  		/* mr R8, R27 */
		/* 820C2098h case    9:*/		regs.R8 = regs.R27;
		/* 820C2098h case    9:*/		return 0x820C209C;
		  /* 820C209Ch */ case   10:  		/* stw R26, <#[R1 + 84]> */
		/* 820C209Ch case   10:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000054) );
		/* 820C209Ch case   10:*/		return 0x820C20A0;
		  /* 820C20A0h */ case   11:  		/* mr R7, R25 */
		/* 820C20A0h case   11:*/		regs.R7 = regs.R25;
		/* 820C20A0h case   11:*/		return 0x820C20A4;
		  /* 820C20A4h */ case   12:  		/* mr R6, R21 */
		/* 820C20A4h case   12:*/		regs.R6 = regs.R21;
		/* 820C20A4h case   12:*/		return 0x820C20A8;
		  /* 820C20A8h */ case   13:  		/* mr R5, R14 */
		/* 820C20A8h case   13:*/		regs.R5 = regs.R14;
		/* 820C20A8h case   13:*/		return 0x820C20AC;
		  /* 820C20ACh */ case   14:  		/* mr R4, R15 */
		/* 820C20ACh case   14:*/		regs.R4 = regs.R15;
		/* 820C20ACh case   14:*/		return 0x820C20B0;
		  /* 820C20B0h */ case   15:  		/* mr R3, R17 */
		/* 820C20B0h case   15:*/		regs.R3 = regs.R17;
		/* 820C20B0h case   15:*/		return 0x820C20B4;
		  /* 820C20B4h */ case   16:  		/* bl -15500 */
		/* 820C20B4h case   16:*/		regs.LR = 0x820C20B8; return 0x820BE428;
		/* 820C20B4h case   16:*/		return 0x820C20B8;
		  /* 820C20B8h */ case   17:  		/* b 648 */
		/* 820C20B8h case   17:*/		return 0x820C2340;
		/* 820C20B8h case   17:*/		return 0x820C20BC;
		  /* 820C20BCh */ case   18:  		/* cmplwi CR6, R30, 0 */
		/* 820C20BCh case   18:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C20BCh case   18:*/		return 0x820C20C0;
		  /* 820C20C0h */ case   19:  		/* bc 12, CR6_EQ, 2572 */
		/* 820C20C0h case   19:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C20C0h case   19:*/		return 0x820C20C4;
		  /* 820C20C4h */ case   20:  		/* lwz R11, <#[R15 + 36]> */
		/* 820C20C4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000024) );
		/* 820C20C4h case   20:*/		return 0x820C20C8;
		  /* 820C20C8h */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 820C20C8h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C20C8h case   21:*/		return 0x820C20CC;
		  /* 820C20CCh */ case   22:  		/* bc 12, CR6_EQ, 2560 */
		/* 820C20CCh case   22:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C20CCh case   22:*/		return 0x820C20D0;
		  /* 820C20D0h */ case   23:  		/* lwz R10, <#[R11 + 4]> */
		/* 820C20D0h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 820C20D0h case   23:*/		return 0x820C20D4;
		  /* 820C20D4h */ case   24:  		/* cmpwi CR6, R10, 15 */
		/* 820C20D4h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000F);
		/* 820C20D4h case   24:*/		return 0x820C20D8;
		  /* 820C20D8h */ case   25:  		/* bc 4, CR6_EQ, 44 */
		/* 820C20D8h case   25:*/		if ( !regs.CR[6].eq ) { return 0x820C2104;  }
		/* 820C20D8h case   25:*/		return 0x820C20DC;
		  /* 820C20DCh */ case   26:  		/* lwz R10, <#[R11 + 16]> */
		/* 820C20DCh case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820C20DCh case   26:*/		return 0x820C20E0;
		  /* 820C20E0h */ case   27:  		/* cmpwi CR6, R10, 2 */
		/* 820C20E0h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000002);
		/* 820C20E0h case   27:*/		return 0x820C20E4;
		  /* 820C20E4h */ case   28:  		/* bc 4, CR6_EQ, 2536 */
		/* 820C20E4h case   28:*/		if ( !regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C20E4h case   28:*/		return 0x820C20E8;
		  /* 820C20E8h */ case   29:  		/* cmplwi CR6, R14, 0 */
		/* 820C20E8h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C20E8h case   29:*/		return 0x820C20EC;
		  /* 820C20ECh */ case   30:  		/* bc 12, CR6_EQ, 2496 */
		/* 820C20ECh case   30:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C20ECh case   30:*/		return 0x820C20F0;
		  /* 820C20F0h */ case   31:  		/* lwz R11, <#[R11 + 24]> */
		/* 820C20F0h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 820C20F0h case   31:*/		return 0x820C20F4;
		  /* 820C20F4h */ case   32:  		/* lwz R10, <#[R1 + 128]> */
		/* 820C20F4h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000080) );
		/* 820C20F4h case   32:*/		return 0x820C20F8;
		  /* 820C20F8h */ case   33:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C20F8h case   33:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C20F8h case   33:*/		return 0x820C20FC;
		  /* 820C20FCh */ case   34:  		/* add R4, R11, R10 */
		/* 820C20FCh case   34:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R10);
		/* 820C20FCh case   34:*/		return 0x820C2100;
		  /* 820C2100h */ case   35:  		/* b -3644 */
		/* 820C2100h case   35:*/		return 0x820C12C4;
		/* 820C2100h case   35:*/		return 0x820C2104;
	}
	return 0x820C2104;
} // Block from 820C2074h-820C2104h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820C2104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2104);
		  /* 820C2104h */ case    0:  		/* cmpwi CR6, R10, 1 */
		/* 820C2104h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 820C2104h case    0:*/		return 0x820C2108;
		  /* 820C2108h */ case    1:  		/* bc 4, CR6_EQ, 2500 */
		/* 820C2108h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C2108h case    1:*/		return 0x820C210C;
		  /* 820C210Ch */ case    2:  		/* cmplwi CR6, R14, 0 */
		/* 820C210Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C210Ch case    2:*/		return 0x820C2110;
		  /* 820C2110h */ case    3:  		/* bc 12, CR6_EQ, 2460 */
		/* 820C2110h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C2110h case    3:*/		return 0x820C2114;
		  /* 820C2114h */ case    4:  		/* cmplwi CR6, R21, 0 */
		/* 820C2114h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C2114h case    4:*/		return 0x820C2118;
		  /* 820C2118h */ case    5:  		/* bc 12, CR6_EQ, -4068 */
		/* 820C2118h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C1134;  }
		/* 820C2118h case    5:*/		return 0x820C211C;
		  /* 820C211Ch */ case    6:  		/* lwz R9, <#[R1 + 128]> */
		/* 820C211Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000080) );
		/* 820C211Ch case    6:*/		return 0x820C2120;
		  /* 820C2120h */ case    7:  		/* addi R10, R14, -4 */
		/* 820C2120h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R14,0xFFFFFFFC);
		/* 820C2120h case    7:*/		return 0x820C2124;
		  /* 820C2124h */ case    8:  		/* mtspr CTR, R21 */
		/* 820C2124h case    8:*/		regs.CTR = regs.R21;
		/* 820C2124h case    8:*/		return 0x820C2128;
		  /* 820C2128h */ case    9:  		/* lwz R8, <#[R11 + 8]> */
		/* 820C2128h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 820C2128h case    9:*/		return 0x820C212C;
		  /* 820C212Ch */ case   10:  		/* lwz R8, <#[R8 + 24]> */
		/* 820C212Ch case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000018) );
		/* 820C212Ch case   10:*/		return 0x820C2130;
		  /* 820C2130h */ case   11:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 820C2130h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 820C2130h case   11:*/		return 0x820C2134;
		  /* 820C2134h */ case   12:  		/* lwzx R8, <#[R8 + R9]> */
		/* 820C2134h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 820C2134h case   12:*/		return 0x820C2138;
		  /* 820C2138h */ case   13:  		/* stwu R8, <#[R10 + 4]> */
		/* 820C2138h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C2138h case   13:*/		return 0x820C213C;
		  /* 820C213Ch */ case   14:  		/* lwz R11, <#[R11 + 12]> */
		/* 820C213Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C213Ch case   14:*/		return 0x820C2140;
		  /* 820C2140h */ case   15:  		/* bc 16, CR0_LT, -24 */
		/* 820C2140h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2128;  }
		/* 820C2140h case   15:*/		return 0x820C2144;
		  /* 820C2144h */ case   16:  		/* b -4112 */
		/* 820C2144h case   16:*/		return 0x820C1134;
		/* 820C2144h case   16:*/		return 0x820C2148;
		  /* 820C2148h */ case   17:  		/* cmplwi CR6, R30, 0 */
		/* 820C2148h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C2148h case   17:*/		return 0x820C214C;
		  /* 820C214Ch */ case   18:  		/* bc 12, CR6_EQ, 2432 */
		/* 820C214Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C214Ch case   18:*/		return 0x820C2150;
		  /* 820C2150h */ case   19:  		/* cmplwi CR6, R28, 0 */
		/* 820C2150h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C2150h case   19:*/		return 0x820C2154;
		  /* 820C2154h */ case   20:  		/* bc 12, CR6_EQ, 2424 */
		/* 820C2154h case   20:*/		if ( regs.CR[6].eq ) { return 0x820C2ACC;  }
		/* 820C2154h case   20:*/		return 0x820C2158;
		  /* 820C2158h */ case   21:  		/* cmplwi CR6, R14, 0 */
		/* 820C2158h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 820C2158h case   21:*/		return 0x820C215C;
		  /* 820C215Ch */ case   22:  		/* bc 12, CR6_EQ, 2384 */
		/* 820C215Ch case   22:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C215Ch case   22:*/		return 0x820C2160;
		  /* 820C2160h */ case   23:  		/* mulli R4, R21, 3 */
		/* 820C2160h case   23:*/		cpu::op::mulli<0>(regs,&regs.R4,regs.R21,0x3);
		/* 820C2160h case   23:*/		return 0x820C2164;
		  /* 820C2164h */ case   24:  		/* mr R3, R17 */
		/* 820C2164h case   24:*/		regs.R3 = regs.R17;
		/* 820C2164h case   24:*/		return 0x820C2168;
		  /* 820C2168h */ case   25:  		/* bl -72312 */
		/* 820C2168h case   25:*/		regs.LR = 0x820C216C; return 0x820B06F0;
		/* 820C2168h case   25:*/		return 0x820C216C;
		  /* 820C216Ch */ case   26:  		/* or. R11, R3, R3 */
		/* 820C216Ch case   26:*/		cpu::op::or<1>(regs,&regs.R11,regs.R3,regs.R3);
		/* 820C216Ch case   26:*/		return 0x820C2170;
		  /* 820C2170h */ case   27:  		/* bc 12, CR0_EQ, 1268 */
		/* 820C2170h case   27:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C2170h case   27:*/		return 0x820C2174;
		  /* 820C2174h */ case   28:  		/* li R10, 3 */
		/* 820C2174h case   28:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 820C2174h case   28:*/		return 0x820C2178;
		  /* 820C2178h */ case   29:  		/* addi R9, R1, 140 */
		/* 820C2178h case   29:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x8C);
		/* 820C2178h case   29:*/		return 0x820C217C;
		  /* 820C217Ch */ case   30:  		/* rlwinm R24, R21, 2, 0, 29 */
		/* 820C217Ch case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R24,regs.R21);
		/* 820C217Ch case   30:*/		return 0x820C2180;
		  /* 820C2180h */ case   31:  		/* mtspr CTR, R10 */
		/* 820C2180h case   31:*/		regs.CTR = regs.R10;
		/* 820C2180h case   31:*/		return 0x820C2184;
		  /* 820C2184h */ case   32:  		/* stwu R11, <#[R9 + 4]> */
		/* 820C2184h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C2184h case   32:*/		return 0x820C2188;
		  /* 820C2188h */ case   33:  		/* add R11, R24, R11 */
		/* 820C2188h case   33:*/		cpu::op::add<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 820C2188h case   33:*/		return 0x820C218C;
		  /* 820C218Ch */ case   34:  		/* bc 16, CR0_LT, -8 */
		/* 820C218Ch case   34:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2184;  }
		/* 820C218Ch case   34:*/		return 0x820C2190;
		  /* 820C2190h */ case   35:  		/* lwz R25, <#[R1 + 144]> */
		/* 820C2190h case   35:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000090) );
		/* 820C2190h case   35:*/		return 0x820C2194;
		  /* 820C2194h */ case   36:  		/* li R26, 0 */
		/* 820C2194h case   36:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820C2194h case   36:*/		return 0x820C2198;
		  /* 820C2198h */ case   37:  		/* lwz R23, <#[R1 + 132]> */
		/* 820C2198h case   37:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x00000084) );
		/* 820C2198h case   37:*/		return 0x820C219C;
		  /* 820C219Ch */ case   38:  		/* cmplwi CR6, R21, 0 */
		/* 820C219Ch case   38:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C219Ch case   38:*/		return 0x820C21A0;
		  /* 820C21A0h */ case   39:  		/* bc 12, CR6_EQ, 128 */
		/* 820C21A0h case   39:*/		if ( regs.CR[6].eq ) { return 0x820C2220;  }
		/* 820C21A0h case   39:*/		return 0x820C21A4;
		  /* 820C21A4h */ case   40:  		/* lwz R11, <#[R1 + 128]> */
		/* 820C21A4h case   40:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820C21A4h case   40:*/		return 0x820C21A8;
		  /* 820C21A8h */ case   41:  		/* mr R31, R25 */
		/* 820C21A8h case   41:*/		regs.R31 = regs.R25;
		/* 820C21A8h case   41:*/		return 0x820C21AC;
		  /* 820C21ACh */ case   42:  		/* add R29, R24, R23 */
		/* 820C21ACh case   42:*/		cpu::op::add<0>(regs,&regs.R29,regs.R24,regs.R23);
		/* 820C21ACh case   42:*/		return 0x820C21B0;
		  /* 820C21B0h */ case   43:  		/* subf R28, R23, R11 */
		/* 820C21B0h case   43:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R23,regs.R11);
		/* 820C21B0h case   43:*/		return 0x820C21B4;
		  /* 820C21B4h */ case   44:  		/* subf R27, R25, R23 */
		/* 820C21B4h case   44:*/		cpu::op::subf<0>(regs,&regs.R27,regs.R25,regs.R23);
		/* 820C21B4h case   44:*/		return 0x820C21B8;
		  /* 820C21B8h */ case   45:  		/* add R30, R27, R31 */
		/* 820C21B8h case   45:*/		cpu::op::add<0>(regs,&regs.R30,regs.R27,regs.R31);
		/* 820C21B8h case   45:*/		return 0x820C21BC;
		  /* 820C21BCh */ case   46:  		/* addi R5, R1, 160 */
		/* 820C21BCh case   46:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xA0);
		/* 820C21BCh case   46:*/		return 0x820C21C0;
		  /* 820C21C0h */ case   47:  		/* mr R3, R17 */
		/* 820C21C0h case   47:*/		regs.R3 = regs.R17;
		/* 820C21C0h case   47:*/		return 0x820C21C4;
		  /* 820C21C4h */ case   48:  		/* lwzx R4, <#[R28 + R30]> */
		/* 820C21C4h case   48:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + regs.R30 + 0x00000000) );
		/* 820C21C4h case   48:*/		return 0x820C21C8;
		  /* 820C21C8h */ case   49:  		/* bl -78760 */
		/* 820C21C8h case   49:*/		regs.LR = 0x820C21CC; return 0x820AEE20;
		/* 820C21C8h case   49:*/		return 0x820C21CC;
		  /* 820C21CCh */ case   50:  		/* cmpwi CR0, R3, 0 */
		/* 820C21CCh case   50:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C21CCh case   50:*/		return 0x820C21D0;
		  /* 820C21D0h */ case   51:  		/* bc 12, CR0_LT, 80 */
		/* 820C21D0h case   51:*/		if ( regs.CR[0].lt ) { return 0x820C2220;  }
		/* 820C21D0h case   51:*/		return 0x820C21D4;
		  /* 820C21D4h */ case   52:  		/* lfd FR13, <#[R1 + 160]> */
		/* 820C21D4h case   52:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000A0) );
		/* 820C21D4h case   52:*/		return 0x820C21D8;
		  /* 820C21D8h */ case   53:  		/* fcmpu CR6, FR13, FR31 */
		/* 820C21D8h case   53:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 820C21D8h case   53:*/		return 0x820C21DC;
		  /* 820C21DCh */ case   54:  		/* bc 12, CR6_GT, 40 */
		/* 820C21DCh case   54:*/		if ( regs.CR[6].gt ) { return 0x820C2204;  }
		/* 820C21DCh case   54:*/		return 0x820C21E0;
		  /* 820C21E0h */ case   55:  		/* lfd FR0, <#[R1 + 168]> */
		/* 820C21E0h case   55:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000A8) );
		/* 820C21E0h case   55:*/		return 0x820C21E4;
		  /* 820C21E4h */ case   56:  		/* fcmpu CR6, FR0, FR31 */
		/* 820C21E4h case   56:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820C21E4h case   56:*/		return 0x820C21E8;
		  /* 820C21E8h */ case   57:  		/* bc 12, CR6_LT, 28 */
		/* 820C21E8h case   57:*/		if ( regs.CR[6].lt ) { return 0x820C2204;  }
		/* 820C21E8h case   57:*/		return 0x820C21EC;
		  /* 820C21ECh */ case   58:  		/* fcmpu CR6, FR13, FR31 */
		/* 820C21ECh case   58:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR31);
		/* 820C21ECh case   58:*/		return 0x820C21F0;
		  /* 820C21F0h */ case   59:  		/* bc 4, CR6_EQ, 48 */
		/* 820C21F0h case   59:*/		if ( !regs.CR[6].eq ) { return 0x820C2220;  }
		/* 820C21F0h case   59:*/		return 0x820C21F4;
		  /* 820C21F4h */ case   60:  		/* fcmpu CR6, FR0, FR31 */
		/* 820C21F4h case   60:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820C21F4h case   60:*/		return 0x820C21F8;
		  /* 820C21F8h */ case   61:  		/* bc 4, CR6_EQ, 40 */
		/* 820C21F8h case   61:*/		if ( !regs.CR[6].eq ) { return 0x820C2220;  }
		/* 820C21F8h case   61:*/		return 0x820C21FC;
		  /* 820C21FCh */ case   62:  		/* lwz R11, <#[R29]> */
		/* 820C21FCh case   62:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820C21FCh case   62:*/		return 0x820C2200;
		  /* 820C2200h */ case   63:  		/* b 8 */
		/* 820C2200h case   63:*/		return 0x820C2208;
		/* 820C2200h case   63:*/		return 0x820C2204;
	}
	return 0x820C2204;
} // Block from 820C2104h-820C2204h (64 instructions)

//////////////////////////////////////////////////////
// Block at 820C2204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2204);
		  /* 820C2204h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820C2204h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C2204h case    0:*/		return 0x820C2208;
	}
	return 0x820C2208;
} // Block from 820C2204h-820C2208h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2208);
		  /* 820C2208h */ case    0:  		/* addi R26, R26, 1 */
		/* 820C2208h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820C2208h case    0:*/		return 0x820C220C;
		  /* 820C220Ch */ case    1:  		/* stw R11, <#[R31]> */
		/* 820C220Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C220Ch case    1:*/		return 0x820C2210;
		  /* 820C2210h */ case    2:  		/* addi R29, R29, 4 */
		/* 820C2210h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820C2210h case    2:*/		return 0x820C2214;
		  /* 820C2214h */ case    3:  		/* addi R31, R31, 4 */
		/* 820C2214h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820C2214h case    3:*/		return 0x820C2218;
		  /* 820C2218h */ case    4:  		/* cmplw CR6, R26, R21 */
		/* 820C2218h case    4:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R21);
		/* 820C2218h case    4:*/		return 0x820C221C;
		  /* 820C221Ch */ case    5:  		/* bc 12, CR6_LT, -100 */
		/* 820C221Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x820C21B8;  }
		/* 820C221Ch case    5:*/		return 0x820C2220;
	}
	return 0x820C2220;
} // Block from 820C2208h-820C2220h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C2220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2220);
		  /* 820C2220h */ case    0:  		/* cmplw CR6, R26, R21 */
		/* 820C2220h case    0:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R21);
		/* 820C2220h case    0:*/		return 0x820C2224;
		  /* 820C2224h */ case    1:  		/* bc 4, CR6_EQ, 56 */
		/* 820C2224h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C225C;  }
		/* 820C2224h case    1:*/		return 0x820C2228;
		  /* 820C2228h */ case    2:  		/* cmplwi CR6, R21, 0 */
		/* 820C2228h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C2228h case    2:*/		return 0x820C222C;
		  /* 820C222Ch */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 820C222Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820C224C;  }
		/* 820C222Ch case    3:*/		return 0x820C2230;
		  /* 820C2230h */ case    4:  		/* addi R11, R14, -4 */
		/* 820C2230h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xFFFFFFFC);
		/* 820C2230h case    4:*/		return 0x820C2234;
		  /* 820C2234h */ case    5:  		/* mr R10, R22 */
		/* 820C2234h case    5:*/		regs.R10 = regs.R22;
		/* 820C2234h case    5:*/		return 0x820C2238;
		  /* 820C2238h */ case    6:  		/* cmplwi CR0, R21, 0 */
		/* 820C2238h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C2238h case    6:*/		return 0x820C223C;
		  /* 820C223Ch */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 820C223Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820C224C;  }
		/* 820C223Ch case    7:*/		return 0x820C2240;
		  /* 820C2240h */ case    8:  		/* mtspr CTR, R21 */
		/* 820C2240h case    8:*/		regs.CTR = regs.R21;
		/* 820C2240h case    8:*/		return 0x820C2244;
		  /* 820C2244h */ case    9:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C2244h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C2244h case    9:*/		return 0x820C2248;
		  /* 820C2248h */ case   10:  		/* bc 16, CR0_LT, -4 */
		/* 820C2248h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2244;  }
		/* 820C2248h case   10:*/		return 0x820C224C;
	}
	return 0x820C224C;
} // Block from 820C2220h-820C224Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C224Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C224C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C224C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C224C);
		  /* 820C224Ch */ case    0:  		/* mr R5, R21 */
		/* 820C224Ch case    0:*/		regs.R5 = regs.R21;
		/* 820C224Ch case    0:*/		return 0x820C2250;
		  /* 820C2250h */ case    1:  		/* mr R7, R25 */
		/* 820C2250h case    1:*/		regs.R7 = regs.R25;
		/* 820C2250h case    1:*/		return 0x820C2254;
		  /* 820C2254h */ case    2:  		/* rlwimi R5, R20, 28, 0, 11 */
		/* 820C2254h case    2:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R5,regs.R20);
		/* 820C2254h case    2:*/		return 0x820C2258;
		  /* 820C2258h */ case    3:  		/* b -3432 */
		/* 820C2258h case    3:*/		return 0x820C14F0;
		/* 820C2258h case    3:*/		return 0x820C225C;
	}
	return 0x820C225C;
} // Block from 820C224Ch-820C225Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C225Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C225C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C225C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C225C);
		  /* 820C225Ch */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 820C225Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C225Ch case    0:*/		return 0x820C2260;
		  /* 820C2260h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820C2260h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C2280;  }
		/* 820C2260h case    1:*/		return 0x820C2264;
		  /* 820C2264h */ case    2:  		/* addi R11, R25, -4 */
		/* 820C2264h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0xFFFFFFFC);
		/* 820C2264h case    2:*/		return 0x820C2268;
		  /* 820C2268h */ case    3:  		/* mr R10, R22 */
		/* 820C2268h case    3:*/		regs.R10 = regs.R22;
		/* 820C2268h case    3:*/		return 0x820C226C;
		  /* 820C226Ch */ case    4:  		/* cmplwi CR0, R21, 0 */
		/* 820C226Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C226Ch case    4:*/		return 0x820C2270;
		  /* 820C2270h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820C2270h case    5:*/		if ( regs.CR[0].eq ) { return 0x820C2280;  }
		/* 820C2270h case    5:*/		return 0x820C2274;
		  /* 820C2274h */ case    6:  		/* mtspr CTR, R21 */
		/* 820C2274h case    6:*/		regs.CTR = regs.R21;
		/* 820C2274h case    6:*/		return 0x820C2278;
		  /* 820C2278h */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C2278h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C2278h case    7:*/		return 0x820C227C;
		  /* 820C227Ch */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820C227Ch case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2278;  }
		/* 820C227Ch case    8:*/		return 0x820C2280;
	}
	return 0x820C2280;
} // Block from 820C225Ch-820C2280h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C2280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2280);
		  /* 820C2280h */ case    0:  		/* lwz R29, <#[R1 + 148]> */
		/* 820C2280h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000094) );
		/* 820C2280h case    0:*/		return 0x820C2284;
		  /* 820C2284h */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 820C2284h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C2284h case    1:*/		return 0x820C2288;
		  /* 820C2288h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820C2288h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C22A8;  }
		/* 820C2288h case    2:*/		return 0x820C228C;
		  /* 820C228Ch */ case    3:  		/* addi R11, R29, -4 */
		/* 820C228Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFC);
		/* 820C228Ch case    3:*/		return 0x820C2290;
		  /* 820C2290h */ case    4:  		/* mr R10, R22 */
		/* 820C2290h case    4:*/		regs.R10 = regs.R22;
		/* 820C2290h case    4:*/		return 0x820C2294;
		  /* 820C2294h */ case    5:  		/* cmplwi CR0, R21, 0 */
		/* 820C2294h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C2294h case    5:*/		return 0x820C2298;
		  /* 820C2298h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820C2298h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C22A8;  }
		/* 820C2298h case    6:*/		return 0x820C229C;
		  /* 820C229Ch */ case    7:  		/* mtspr CTR, R21 */
		/* 820C229Ch case    7:*/		regs.CTR = regs.R21;
		/* 820C229Ch case    7:*/		return 0x820C22A0;
		  /* 820C22A0h */ case    8:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C22A0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C22A0h case    8:*/		return 0x820C22A4;
		  /* 820C22A4h */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820C22A4h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C22A0;  }
		/* 820C22A4h case    9:*/		return 0x820C22A8;
	}
	return 0x820C22A8;
} // Block from 820C2280h-820C22A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C22A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C22A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C22A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C22A8);
		  /* 820C22A8h */ case    0:  		/* lwz R30, <#[R1 + 152]> */
		/* 820C22A8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000098) );
		/* 820C22A8h case    0:*/		return 0x820C22AC;
		  /* 820C22ACh */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 820C22ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C22ACh case    1:*/		return 0x820C22B0;
		  /* 820C22B0h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820C22B0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C22D0;  }
		/* 820C22B0h case    2:*/		return 0x820C22B4;
		  /* 820C22B4h */ case    3:  		/* addi R11, R30, -4 */
		/* 820C22B4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFC);
		/* 820C22B4h case    3:*/		return 0x820C22B8;
		  /* 820C22B8h */ case    4:  		/* mr R10, R22 */
		/* 820C22B8h case    4:*/		regs.R10 = regs.R22;
		/* 820C22B8h case    4:*/		return 0x820C22BC;
		  /* 820C22BCh */ case    5:  		/* cmplwi CR0, R21, 0 */
		/* 820C22BCh case    5:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 820C22BCh case    5:*/		return 0x820C22C0;
		  /* 820C22C0h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820C22C0h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C22D0;  }
		/* 820C22C0h case    6:*/		return 0x820C22C4;
		  /* 820C22C4h */ case    7:  		/* mtspr CTR, R21 */
		/* 820C22C4h case    7:*/		regs.CTR = regs.R21;
		/* 820C22C4h case    7:*/		return 0x820C22C8;
		  /* 820C22C8h */ case    8:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C22C8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C22C8h case    8:*/		return 0x820C22CC;
		  /* 820C22CCh */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820C22CCh case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C22C8;  }
		/* 820C22CCh case    9:*/		return 0x820C22D0;
	}
	return 0x820C22D0;
} // Block from 820C22A8h-820C22D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C22D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C22D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C22D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C22D0);
		  /* 820C22D0h */ case    0:  		/* mr R8, R21 */
		/* 820C22D0h case    0:*/		regs.R8 = regs.R21;
		/* 820C22D0h case    0:*/		return 0x820C22D4;
		  /* 820C22D4h */ case    1:  		/* lwz R7, <#[R1 + 128]> */
		/* 820C22D4h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000080) );
		/* 820C22D4h case    1:*/		return 0x820C22D8;
		  /* 820C22D8h */ case    2:  		/* mr R6, R29 */
		/* 820C22D8h case    2:*/		regs.R6 = regs.R29;
		/* 820C22D8h case    2:*/		return 0x820C22DC;
		  /* 820C22DCh */ case    3:  		/* mr R5, R25 */
		/* 820C22DCh case    3:*/		regs.R5 = regs.R25;
		/* 820C22DCh case    3:*/		return 0x820C22E0;
		  /* 820C22E0h */ case    4:  		/* mr R4, R15 */
		/* 820C22E0h case    4:*/		regs.R4 = regs.R15;
		/* 820C22E0h case    4:*/		return 0x820C22E4;
		  /* 820C22E4h */ case    5:  		/* mr R3, R17 */
		/* 820C22E4h case    5:*/		regs.R3 = regs.R17;
		/* 820C22E4h case    5:*/		return 0x820C22E8;
		  /* 820C22E8h */ case    6:  		/* bl -57656 */
		/* 820C22E8h case    6:*/		regs.LR = 0x820C22EC; return 0x820B41B0;
		/* 820C22E8h case    6:*/		return 0x820C22EC;
		  /* 820C22ECh */ case    7:  		/* or. R31, R3, R3 */
		/* 820C22ECh case    7:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C22ECh case    7:*/		return 0x820C22F0;
		  /* 820C22F0h */ case    8:  		/* bc 12, CR0_LT, 2020 */
		/* 820C22F0h case    8:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C22F0h case    8:*/		return 0x820C22F4;
		  /* 820C22F4h */ case    9:  		/* mr R5, R21 */
		/* 820C22F4h case    9:*/		regs.R5 = regs.R21;
		/* 820C22F4h case    9:*/		return 0x820C22F8;
		  /* 820C22F8h */ case   10:  		/* li R9, 23 */
		/* 820C22F8h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C22F8h case   10:*/		return 0x820C22FC;
		  /* 820C22FCh */ case   11:  		/* rlwimi R5, R19, 21, 0, 11 */
		/* 820C22FCh case   11:*/		cpu::op::rlwimi<0,21,0,11>(regs,&regs.R5,regs.R19);
		/* 820C22FCh case   11:*/		return 0x820C2300;
		  /* 820C2300h */ case   12:  		/* mr R8, R25 */
		/* 820C2300h case   12:*/		regs.R8 = regs.R25;
		/* 820C2300h case   12:*/		return 0x820C2304;
		  /* 820C2304h */ case   13:  		/* mr R7, R29 */
		/* 820C2304h case   13:*/		regs.R7 = regs.R29;
		/* 820C2304h case   13:*/		return 0x820C2308;
		  /* 820C2308h */ case   14:  		/* mr R6, R30 */
		/* 820C2308h case   14:*/		regs.R6 = regs.R30;
		/* 820C2308h case   14:*/		return 0x820C230C;
		  /* 820C230Ch */ case   15:  		/* mr R4, R15 */
		/* 820C230Ch case   15:*/		regs.R4 = regs.R15;
		/* 820C230Ch case   15:*/		return 0x820C2310;
		  /* 820C2310h */ case   16:  		/* mr R3, R17 */
		/* 820C2310h case   16:*/		regs.R3 = regs.R17;
		/* 820C2310h case   16:*/		return 0x820C2314;
		  /* 820C2314h */ case   17:  		/* bl -71692 */
		/* 820C2314h case   17:*/		regs.LR = 0x820C2318; return 0x820B0B08;
		/* 820C2314h case   17:*/		return 0x820C2318;
		  /* 820C2318h */ case   18:  		/* or. R31, R3, R3 */
		/* 820C2318h case   18:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C2318h case   18:*/		return 0x820C231C;
		  /* 820C231Ch */ case   19:  		/* bc 12, CR0_LT, 1976 */
		/* 820C231Ch case   19:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C231Ch case   19:*/		return 0x820C2320;
		  /* 820C2320h */ case   20:  		/* mr R9, R21 */
		/* 820C2320h case   20:*/		regs.R9 = regs.R21;
		/* 820C2320h case   20:*/		return 0x820C2324;
		  /* 820C2324h */ case   21:  		/* mr R8, R30 */
		/* 820C2324h case   21:*/		regs.R8 = regs.R30;
		/* 820C2324h case   21:*/		return 0x820C2328;
		  /* 820C2328h */ case   22:  		/* mr R7, R23 */
		/* 820C2328h case   22:*/		regs.R7 = regs.R23;
		/* 820C2328h case   22:*/		return 0x820C232C;
		  /* 820C232Ch */ case   23:  		/* add R6, R24, R23 */
		/* 820C232Ch case   23:*/		cpu::op::add<0>(regs,&regs.R6,regs.R24,regs.R23);
		/* 820C232Ch case   23:*/		return 0x820C2330;
		  /* 820C2330h */ case   24:  		/* mr R5, R14 */
		/* 820C2330h case   24:*/		regs.R5 = regs.R14;
		/* 820C2330h case   24:*/		return 0x820C2334;
		  /* 820C2334h */ case   25:  		/* mr R4, R15 */
		/* 820C2334h case   25:*/		regs.R4 = regs.R15;
		/* 820C2334h case   25:*/		return 0x820C2338;
		  /* 820C2338h */ case   26:  		/* mr R3, R17 */
		/* 820C2338h case   26:*/		regs.R3 = regs.R17;
		/* 820C2338h case   26:*/		return 0x820C233C;
		  /* 820C233Ch */ case   27:  		/* bl -60860 */
		/* 820C233Ch case   27:*/		regs.LR = 0x820C2340; return 0x820B3580;
		/* 820C233Ch case   27:*/		return 0x820C2340;
	}
	return 0x820C2340;
} // Block from 820C22D0h-820C2340h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820C2340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2340);
		  /* 820C2340h */ case    0:  		/* or. R31, R3, R3 */
		/* 820C2340h case    0:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C2340h case    0:*/		return 0x820C2344;
		  /* 820C2344h */ case    1:  		/* bc 4, CR0_LT, -4624 */
		/* 820C2344h case    1:*/		if ( !regs.CR[0].lt ) { return 0x820C1134;  }
		/* 820C2344h case    1:*/		return 0x820C2348;
		  /* 820C2348h */ case    2:  		/* b 1932 */
		/* 820C2348h case    2:*/		return 0x820C2AD4;
		/* 820C2348h case    2:*/		return 0x820C234C;
		  /* 820C234Ch */ case    3:  		/* addi R5, R1, 144 */
		/* 820C234Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x90);
		/* 820C234Ch case    3:*/		return 0x820C2350;
		  /* 820C2350h */ case    4:  		/* lwz R4, <#[R15 + 32]> */
		/* 820C2350h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R15 + 0x00000020) );
		/* 820C2350h case    4:*/		return 0x820C2354;
		  /* 820C2354h */ case    5:  		/* mr R3, R17 */
		/* 820C2354h case    5:*/		regs.R3 = regs.R17;
		/* 820C2354h case    5:*/		return 0x820C2358;
		  /* 820C2358h */ case    6:  		/* bl -74424 */
		/* 820C2358h case    6:*/		regs.LR = 0x820C235C; return 0x820B00A0;
		/* 820C2358h case    6:*/		return 0x820C235C;
		  /* 820C235Ch */ case    7:  		/* or. R5, R3, R3 */
		/* 820C235Ch case    7:*/		cpu::op::or<1>(regs,&regs.R5,regs.R3,regs.R3);
		/* 820C235Ch case    7:*/		return 0x820C2360;
		  /* 820C2360h */ case    8:  		/* mr R3, R17 */
		/* 820C2360h case    8:*/		regs.R3 = regs.R17;
		/* 820C2360h case    8:*/		return 0x820C2364;
		  /* 820C2364h */ case    9:  		/* bc 4, CR0_EQ, 32 */
		/* 820C2364h case    9:*/		if ( !regs.CR[0].eq ) { return 0x820C2384;  }
		/* 820C2364h case    9:*/		return 0x820C2368;
		  /* 820C2368h */ case   10:  		/* lis R11, -32255 */
		/* 820C2368h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C2368h case   10:*/		return 0x820C236C;
		  /* 820C236Ch */ case   11:  		/* lwz R7, <#[R15 + 56]> */
		/* 820C236Ch case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R15 + 0x00000038) );
		/* 820C236Ch case   11:*/		return 0x820C2370;
		  /* 820C2370h */ case   12:  		/* li R5, 3510 */
		/* 820C2370h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0xDB6);
		/* 820C2370h case   12:*/		return 0x820C2374;
		  /* 820C2374h */ case   13:  		/* addi R6, R11, 9584 */
		/* 820C2374h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2570);
		/* 820C2374h case   13:*/		return 0x820C2378;
		  /* 820C2378h */ case   14:  		/* mr R4, R15 */
		/* 820C2378h case   14:*/		regs.R4 = regs.R15;
		/* 820C2378h case   14:*/		return 0x820C237C;
		  /* 820C237Ch */ case   15:  		/* bl -72076 */
		/* 820C237Ch case   15:*/		regs.LR = 0x820C2380; return 0x820B09F0;
		/* 820C237Ch case   15:*/		return 0x820C2380;
		  /* 820C2380h */ case   16:  		/* b 1868 */
		/* 820C2380h case   16:*/		return 0x820C2ACC;
		/* 820C2380h case   16:*/		return 0x820C2384;
	}
	return 0x820C2384;
} // Block from 820C2340h-820C2384h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C2384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2384);
		  /* 820C2384h */ case    0:  		/* lwz R11, <#[R17 + 56]> */
		/* 820C2384h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000038) );
		/* 820C2384h case    0:*/		return 0x820C2388;
		  /* 820C2388h */ case    1:  		/* li R9, 0 */
		/* 820C2388h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C2388h case    1:*/		return 0x820C238C;
		  /* 820C238Ch */ case    2:  		/* li R8, 0 */
		/* 820C238Ch case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C238Ch case    2:*/		return 0x820C2390;
		  /* 820C2390h */ case    3:  		/* lwz R4, <#[R1 + 144]> */
		/* 820C2390h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000090) );
		/* 820C2390h case    3:*/		return 0x820C2394;
		  /* 820C2394h */ case    4:  		/* addi R11, R11, 1 */
		/* 820C2394h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C2394h case    4:*/		return 0x820C2398;
		  /* 820C2398h */ case    5:  		/* mr R7, R14 */
		/* 820C2398h case    5:*/		regs.R7 = regs.R14;
		/* 820C2398h case    5:*/		return 0x820C239C;
		  /* 820C239Ch */ case    6:  		/* stw R11, <#[R17 + 56]> */
		/* 820C239Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R17 + 0x00000038) );
		/* 820C239Ch case    6:*/		return 0x820C23A0;
		  /* 820C23A0h */ case    7:  		/* lwz R6, <#[R15 + 36]> */
		/* 820C23A0h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R15 + 0x00000024) );
		/* 820C23A0h case    7:*/		return 0x820C23A4;
		  /* 820C23A4h */ case    8:  		/* bl -9116 */
		/* 820C23A4h case    8:*/		regs.LR = 0x820C23A8; return 0x820C0008;
		/* 820C23A4h case    8:*/		return 0x820C23A8;
		  /* 820C23A8h */ case    9:  		/* lwz R11, <#[R17 + 56]> */
		/* 820C23A8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000038) );
		/* 820C23A8h case    9:*/		return 0x820C23AC;
		  /* 820C23ACh */ case   10:  		/* addi R11, R11, -1 */
		/* 820C23ACh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820C23ACh case   10:*/		return 0x820C23B0;
		  /* 820C23B0h */ case   11:  		/* stw R11, <#[R17 + 56]> */
		/* 820C23B0h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R17 + 0x00000038) );
		/* 820C23B0h case   11:*/		return 0x820C23B4;
		  /* 820C23B4h */ case   12:  		/* b -116 */
		/* 820C23B4h case   12:*/		return 0x820C2340;
		/* 820C23B4h case   12:*/		return 0x820C23B8;
		  /* 820C23B8h */ case   13:  		/* mr R5, R14 */
		/* 820C23B8h case   13:*/		regs.R5 = regs.R14;
		/* 820C23B8h case   13:*/		return 0x820C23BC;
		  /* 820C23BCh */ case   14:  		/* mr R4, R15 */
		/* 820C23BCh case   14:*/		regs.R4 = regs.R15;
		/* 820C23BCh case   14:*/		return 0x820C23C0;
		  /* 820C23C0h */ case   15:  		/* mr R3, R17 */
		/* 820C23C0h case   15:*/		regs.R3 = regs.R17;
		/* 820C23C0h case   15:*/		return 0x820C23C4;
		  /* 820C23C4h */ case   16:  		/* bl -43276 */
		/* 820C23C4h case   16:*/		regs.LR = 0x820C23C8; return 0x820B7AB8;
		/* 820C23C4h case   16:*/		return 0x820C23C8;
		  /* 820C23C8h */ case   17:  		/* b -136 */
		/* 820C23C8h case   17:*/		return 0x820C2340;
		/* 820C23C8h case   17:*/		return 0x820C23CC;
		  /* 820C23CCh */ case   18:  		/* rlwinm R31, R31, 1, 0, 30 */
		/* 820C23CCh case   18:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R31,regs.R31);
		/* 820C23CCh case   18:*/		return 0x820C23D0;
	}
	return 0x820C23D0;
} // Block from 820C2384h-820C23D0h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820C23D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C23D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C23D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C23D0);
		  /* 820C23D0h */ case    0:  		/* cmplw CR6, R31, R21 */
		/* 820C23D0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R21);
		/* 820C23D0h case    0:*/		return 0x820C23D4;
		  /* 820C23D4h */ case    1:  		/* bc 12, CR6_LT, -8 */
		/* 820C23D4h case    1:*/		if ( regs.CR[6].lt ) { return 0x820C23CC;  }
		/* 820C23D4h case    1:*/		return 0x820C23D8;
		  /* 820C23D8h */ case    2:  		/* lis R4, 9345 */
		/* 820C23D8h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C23D8h case    2:*/		return 0x820C23DC;
		  /* 820C23DCh */ case    3:  		/* rlwinm R3, R31, 3, 0, 28 */
		/* 820C23DCh case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R3,regs.R31);
		/* 820C23DCh case    3:*/		return 0x820C23E0;
		  /* 820C23E0h */ case    4:  		/* bl -238048 */
		/* 820C23E0h case    4:*/		regs.LR = 0x820C23E4; return 0x82088200;
		/* 820C23E0h case    4:*/		return 0x820C23E4;
		  /* 820C23E4h */ case    5:  		/* or. R30, R3, R3 */
		/* 820C23E4h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 820C23E4h case    5:*/		return 0x820C23E8;
		  /* 820C23E8h */ case    6:  		/* bc 12, CR0_EQ, 636 */
		/* 820C23E8h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C23E8h case    6:*/		return 0x820C23EC;
		  /* 820C23ECh */ case    7:  		/* lis R4, 9345 */
		/* 820C23ECh case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C23ECh case    7:*/		return 0x820C23F0;
		  /* 820C23F0h */ case    8:  		/* lwz R3, <#[R17 + 160]> */
		/* 820C23F0h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0x000000A0) );
		/* 820C23F0h case    8:*/		return 0x820C23F4;
		  /* 820C23F4h */ case    9:  		/* bl -237756 */
		/* 820C23F4h case    9:*/		regs.LR = 0x820C23F8; return 0x82088338;
		/* 820C23F4h case    9:*/		return 0x820C23F8;
		  /* 820C23F8h */ case   10:  		/* stw R30, <#[R17 + 160]> */
		/* 820C23F8h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R17 + 0x000000A0) );
		/* 820C23F8h case   10:*/		return 0x820C23FC;
		  /* 820C23FCh */ case   11:  		/* stw R31, <#[R17 + 164]> */
		/* 820C23FCh case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R17 + 0x000000A4) );
		/* 820C23FCh case   11:*/		return 0x820C2400;
	}
	return 0x820C2400;
} // Block from 820C23D0h-820C2400h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C2400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2400);
		  /* 820C2400h */ case    0:  		/* lwz R25, <#[R17 + 160]> */
		/* 820C2400h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R17 + 0x000000A0) );
		/* 820C2400h case    0:*/		return 0x820C2404;
		  /* 820C2404h */ case    1:  		/* rlwinm R11, R21, 2, 0, 29 */
		/* 820C2404h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R21);
		/* 820C2404h case    1:*/		return 0x820C2408;
		  /* 820C2408h */ case    2:  		/* mr R3, R17 */
		/* 820C2408h case    2:*/		regs.R3 = regs.R17;
		/* 820C2408h case    2:*/		return 0x820C240C;
		  /* 820C240Ch */ case    3:  		/* lwz R4, <#[R15 + 16]> */
		/* 820C240Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R15 + 0x00000010) );
		/* 820C240Ch case    3:*/		return 0x820C2410;
		  /* 820C2410h */ case    4:  		/* add R16, R11, R25 */
		/* 820C2410h case    4:*/		cpu::op::add<0>(regs,&regs.R16,regs.R11,regs.R25);
		/* 820C2410h case    4:*/		return 0x820C2414;
		  /* 820C2414h */ case    5:  		/* mr R5, R16 */
		/* 820C2414h case    5:*/		regs.R5 = regs.R16;
		/* 820C2414h case    5:*/		return 0x820C2418;
		  /* 820C2418h */ case    6:  		/* bl -68984 */
		/* 820C2418h case    6:*/		regs.LR = 0x820C241C; return 0x820B16A0;
		/* 820C2418h case    6:*/		return 0x820C241C;
		  /* 820C241Ch */ case    7:  		/* li R27, 0 */
		/* 820C241Ch case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820C241Ch case    7:*/		return 0x820C2420;
		  /* 820C2420h */ case    8:  		/* li R24, 0 */
		/* 820C2420h case    8:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820C2420h case    8:*/		return 0x820C2424;
		  /* 820C2424h */ case    9:  		/* li R4, 0 */
		/* 820C2424h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C2424h case    9:*/		return 0x820C2428;
		  /* 820C2428h */ case   10:  		/* cmplwi CR6, R21, 0 */
		/* 820C2428h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C2428h case   10:*/		return 0x820C242C;
		  /* 820C242Ch */ case   11:  		/* bc 12, CR6_EQ, 1664 */
		/* 820C242Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C242Ch case   11:*/		return 0x820C2430;
		  /* 820C2430h */ case   12:  		/* mr R9, R25 */
		/* 820C2430h case   12:*/		regs.R9 = regs.R25;
		/* 820C2430h case   12:*/		return 0x820C2434;
		  /* 820C2434h */ case   13:  		/* subf R6, R16, R14 */
		/* 820C2434h case   13:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R16,regs.R14);
		/* 820C2434h case   13:*/		return 0x820C2438;
		  /* 820C2438h */ case   14:  		/* subf R5, R25, R16 */
		/* 820C2438h case   14:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R25,regs.R16);
		/* 820C2438h case   14:*/		return 0x820C243C;
		  /* 820C243Ch */ case   15:  		/* lwz R11, <#[R17 + 8]> */
		/* 820C243Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000008) );
		/* 820C243Ch case   15:*/		return 0x820C2440;
		  /* 820C2440h */ case   16:  		/* add R7, R5, R9 */
		/* 820C2440h case   16:*/		cpu::op::add<0>(regs,&regs.R7,regs.R5,regs.R9);
		/* 820C2440h case   16:*/		return 0x820C2444;
		  /* 820C2444h */ case   17:  		/* lwzx R10, <#[R7 + R6]> */
		/* 820C2444h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R6 + 0x00000000) );
		/* 820C2444h case   17:*/		return 0x820C2448;
		  /* 820C2448h */ case   18:  		/* lwz R8, <#[R11 + 8]> */
		/* 820C2448h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 820C2448h case   18:*/		return 0x820C244C;
		  /* 820C244Ch */ case   19:  		/* cmplw CR6, R10, R8 */
		/* 820C244Ch case   19:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820C244Ch case   19:*/		return 0x820C2450;
		  /* 820C2450h */ case   20:  		/* bc 4, CR6_LT, 20 */
		/* 820C2450h case   20:*/		if ( !regs.CR[6].lt ) { return 0x820C2464;  }
		/* 820C2450h case   20:*/		return 0x820C2454;
		  /* 820C2454h */ case   21:  		/* lwz R8, <#[R11 + 20]> */
		/* 820C2454h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 820C2454h case   21:*/		return 0x820C2458;
		  /* 820C2458h */ case   22:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C2458h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C2458h case   22:*/		return 0x820C245C;
		  /* 820C245Ch */ case   23:  		/* lwzx R8, <#[R10 + R8]> */
		/* 820C245Ch case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820C245Ch case   23:*/		return 0x820C2460;
		  /* 820C2460h */ case   24:  		/* b 8 */
		/* 820C2460h case   24:*/		return 0x820C2468;
		/* 820C2460h case   24:*/		return 0x820C2464;
	}
	return 0x820C2464;
} // Block from 820C2400h-820C2464h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820C2464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2464);
		  /* 820C2464h */ case    0:  		/* li R8, 0 */
		/* 820C2464h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C2464h case    0:*/		return 0x820C2468;
	}
	return 0x820C2468;
} // Block from 820C2464h-820C2468h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2468);
		  /* 820C2468h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820C2468h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C2468h case    0:*/		return 0x820C246C;
		  /* 820C246Ch */ case    1:  		/* bc 12, CR6_EQ, 328 */
		/* 820C246Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820C25B4;  }
		/* 820C246Ch case    1:*/		return 0x820C2470;
		  /* 820C2470h */ case    2:  		/* lwz R11, <#[R11 + 116]> */
		/* 820C2470h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000074) );
		/* 820C2470h case    2:*/		return 0x820C2474;
		  /* 820C2474h */ case    3:  		/* lwz R10, <#[R8 + 4]> */
		/* 820C2474h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 820C2474h case    3:*/		return 0x820C2478;
		  /* 820C2478h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820C2478h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C2478h case    4:*/		return 0x820C247C;
		  /* 820C247Ch */ case    5:  		/* bc 12, CR6_EQ, 84 */
		/* 820C247Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820C24D0;  }
		/* 820C247Ch case    5:*/		return 0x820C2480;
		  /* 820C2480h */ case    6:  		/* lwz R3, <#[R7]> */
		/* 820C2480h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R7 + 0x00000000) );
		/* 820C2480h case    6:*/		return 0x820C2484;
		  /* 820C2484h */ case    7:  		/* rlwinm. R3, R3, 0, 31, 31 */
		/* 820C2484h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R3,regs.R3);
		/* 820C2484h case    7:*/		return 0x820C2488;
		  /* 820C2488h */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 820C2488h case    8:*/		if ( regs.CR[0].eq ) { return 0x820C24A4;  }
		/* 820C2488h case    8:*/		return 0x820C248C;
		  /* 820C248Ch */ case    9:  		/* lwz R3, <#[R8]> */
		/* 820C248Ch case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + 0x00000000) );
		/* 820C248Ch case    9:*/		return 0x820C2490;
		  /* 820C2490h */ case   10:  		/* rlwinm. R3, R3, 0, 31, 31 */
		/* 820C2490h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R3,regs.R3);
		/* 820C2490h case   10:*/		return 0x820C2494;
		  /* 820C2494h */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 820C2494h case   11:*/		if ( !regs.CR[0].eq ) { return 0x820C24A4;  }
		/* 820C2494h case   11:*/		return 0x820C2498;
		  /* 820C2498h */ case   12:  		/* addi R27, R27, 1 */
		/* 820C2498h case   12:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820C2498h case   12:*/		return 0x820C249C;
		  /* 820C249Ch */ case   13:  		/* stw R20, <#[R9]> */
		/* 820C249Ch case   13:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R9 + 0x00000000) );
		/* 820C249Ch case   13:*/		return 0x820C24A0;
		  /* 820C24A0h */ case   14:  		/* b 56 */
		/* 820C24A0h case   14:*/		return 0x820C24D8;
		/* 820C24A0h case   14:*/		return 0x820C24A4;
	}
	return 0x820C24A4;
} // Block from 820C2468h-820C24A4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C24A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C24A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C24A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C24A4);
		  /* 820C24A4h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 820C24A4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C24A4h case    0:*/		return 0x820C24A8;
		  /* 820C24A8h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820C24A8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C24D0;  }
		/* 820C24A8h case    1:*/		return 0x820C24AC;
		  /* 820C24ACh */ case    2:  		/* lwz R11, <#[R7]> */
		/* 820C24ACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 820C24ACh case    2:*/		return 0x820C24B0;
		  /* 820C24B0h */ case    3:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820C24B0h case    3:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820C24B0h case    3:*/		return 0x820C24B4;
		  /* 820C24B4h */ case    4:  		/* bc 12, CR0_EQ, 28 */
		/* 820C24B4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C24D0;  }
		/* 820C24B4h case    4:*/		return 0x820C24B8;
		  /* 820C24B8h */ case    5:  		/* lwz R11, <#[R8]> */
		/* 820C24B8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820C24B8h case    5:*/		return 0x820C24BC;
		  /* 820C24BCh */ case    6:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 820C24BCh case    6:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 820C24BCh case    6:*/		return 0x820C24C0;
		  /* 820C24C0h */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 820C24C0h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820C24D0;  }
		/* 820C24C0h case    7:*/		return 0x820C24C4;
		  /* 820C24C4h */ case    8:  		/* li R11, 2 */
		/* 820C24C4h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 820C24C4h case    8:*/		return 0x820C24C8;
		  /* 820C24C8h */ case    9:  		/* addi R24, R24, 1 */
		/* 820C24C8h case    9:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 820C24C8h case    9:*/		return 0x820C24CC;
		  /* 820C24CCh */ case   10:  		/* b 8 */
		/* 820C24CCh case   10:*/		return 0x820C24D4;
		/* 820C24CCh case   10:*/		return 0x820C24D0;
	}
	return 0x820C24D0;
} // Block from 820C24A4h-820C24D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C24D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C24D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C24D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C24D0);
		  /* 820C24D0h */ case    0:  		/* li R11, 0 */
		/* 820C24D0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C24D0h case    0:*/		return 0x820C24D4;
	}
	return 0x820C24D4;
} // Block from 820C24D0h-820C24D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C24D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C24D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C24D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C24D4);
		  /* 820C24D4h */ case    0:  		/* stw R11, <#[R9]> */
		/* 820C24D4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820C24D4h case    0:*/		return 0x820C24D8;
	}
	return 0x820C24D8;
} // Block from 820C24D4h-820C24D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C24D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C24D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C24D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C24D8);
		  /* 820C24D8h */ case    0:  		/* addi R4, R4, 1 */
		/* 820C24D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820C24D8h case    0:*/		return 0x820C24DC;
		  /* 820C24DCh */ case    1:  		/* addi R9, R9, 4 */
		/* 820C24DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820C24DCh case    1:*/		return 0x820C24E0;
		  /* 820C24E0h */ case    2:  		/* cmplw CR6, R4, R21 */
		/* 820C24E0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R21);
		/* 820C24E0h case    2:*/		return 0x820C24E4;
		  /* 820C24E4h */ case    3:  		/* bc 12, CR6_LT, -168 */
		/* 820C24E4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C243C;  }
		/* 820C24E4h case    3:*/		return 0x820C24E8;
		  /* 820C24E8h */ case    4:  		/* cmplwi CR6, R27, 0 */
		/* 820C24E8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820C24E8h case    4:*/		return 0x820C24EC;
		  /* 820C24ECh */ case    5:  		/* bc 12, CR6_EQ, 348 */
		/* 820C24ECh case    5:*/		if ( regs.CR[6].eq ) { return 0x820C2648;  }
		/* 820C24ECh case    5:*/		return 0x820C24F0;
		  /* 820C24F0h */ case    6:  		/* rlwinm R31, R27, 2, 0, 29 */
		/* 820C24F0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R27);
		/* 820C24F0h case    6:*/		return 0x820C24F4;
		  /* 820C24F4h */ case    7:  		/* mr R3, R17 */
		/* 820C24F4h case    7:*/		regs.R3 = regs.R17;
		/* 820C24F4h case    7:*/		return 0x820C24F8;
		  /* 820C24F8h */ case    8:  		/* mr R4, R31 */
		/* 820C24F8h case    8:*/		regs.R4 = regs.R31;
		/* 820C24F8h case    8:*/		return 0x820C24FC;
		  /* 820C24FCh */ case    9:  		/* bl -73228 */
		/* 820C24FCh case    9:*/		regs.LR = 0x820C2500; return 0x820B06F0;
		/* 820C24FCh case    9:*/		return 0x820C2500;
		  /* 820C2500h */ case   10:  		/* or. R11, R3, R3 */
		/* 820C2500h case   10:*/		cpu::op::or<1>(regs,&regs.R11,regs.R3,regs.R3);
		/* 820C2500h case   10:*/		return 0x820C2504;
		  /* 820C2504h */ case   11:  		/* bc 12, CR0_EQ, 352 */
		/* 820C2504h case   11:*/		if ( regs.CR[0].eq ) { return 0x820C2664;  }
		/* 820C2504h case   11:*/		return 0x820C2508;
		  /* 820C2508h */ case   12:  		/* li R9, 4 */
		/* 820C2508h case   12:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820C2508h case   12:*/		return 0x820C250C;
		  /* 820C250Ch */ case   13:  		/* addi R10, R1, 140 */
		/* 820C250Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x8C);
		/* 820C250Ch case   13:*/		return 0x820C2510;
		  /* 820C2510h */ case   14:  		/* mtspr CTR, R9 */
		/* 820C2510h case   14:*/		regs.CTR = regs.R9;
		/* 820C2510h case   14:*/		return 0x820C2514;
		  /* 820C2514h */ case   15:  		/* stwu R11, <#[R10 + 4]> */
		/* 820C2514h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C2514h case   15:*/		return 0x820C2518;
		  /* 820C2518h */ case   16:  		/* add R11, R11, R31 */
		/* 820C2518h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820C2518h case   16:*/		return 0x820C251C;
		  /* 820C251Ch */ case   17:  		/* bc 16, CR0_LT, -8 */
		/* 820C251Ch case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2514;  }
		/* 820C251Ch case   17:*/		return 0x820C2520;
		  /* 820C2520h */ case   18:  		/* lwz R28, <#[R1 + 148]> */
		/* 820C2520h case   18:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000094) );
		/* 820C2520h case   18:*/		return 0x820C2524;
		  /* 820C2524h */ case   19:  		/* cmplwi CR6, R27, 0 */
		/* 820C2524h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820C2524h case   19:*/		return 0x820C2528;
		  /* 820C2528h */ case   20:  		/* bc 12, CR6_EQ, 32 */
		/* 820C2528h case   20:*/		if ( regs.CR[6].eq ) { return 0x820C2548;  }
		/* 820C2528h case   20:*/		return 0x820C252C;
		  /* 820C252Ch */ case   21:  		/* addi R11, R28, -4 */
		/* 820C252Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFFC);
		/* 820C252Ch case   21:*/		return 0x820C2530;
		  /* 820C2530h */ case   22:  		/* mr R10, R22 */
		/* 820C2530h case   22:*/		regs.R10 = regs.R22;
		/* 820C2530h case   22:*/		return 0x820C2534;
		  /* 820C2534h */ case   23:  		/* cmplwi CR0, R27, 0 */
		/* 820C2534h case   23:*/		cpu::op::cmplwi<0>(regs,regs.R27,0x00000000);
		/* 820C2534h case   23:*/		return 0x820C2538;
		  /* 820C2538h */ case   24:  		/* bc 12, CR0_EQ, 16 */
		/* 820C2538h case   24:*/		if ( regs.CR[0].eq ) { return 0x820C2548;  }
		/* 820C2538h case   24:*/		return 0x820C253C;
		  /* 820C253Ch */ case   25:  		/* mtspr CTR, R27 */
		/* 820C253Ch case   25:*/		regs.CTR = regs.R27;
		/* 820C253Ch case   25:*/		return 0x820C2540;
		  /* 820C2540h */ case   26:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C2540h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C2540h case   26:*/		return 0x820C2544;
		  /* 820C2544h */ case   27:  		/* bc 16, CR0_LT, -4 */
		/* 820C2544h case   27:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2540;  }
		/* 820C2544h case   27:*/		return 0x820C2548;
	}
	return 0x820C2548;
} // Block from 820C24D8h-820C2548h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820C2548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2548);
		  /* 820C2548h */ case    0:  		/* lwz R29, <#[R1 + 152]> */
		/* 820C2548h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000098) );
		/* 820C2548h case    0:*/		return 0x820C254C;
		  /* 820C254Ch */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 820C254Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820C254Ch case    1:*/		return 0x820C2550;
		  /* 820C2550h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820C2550h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C2570;  }
		/* 820C2550h case    2:*/		return 0x820C2554;
		  /* 820C2554h */ case    3:  		/* addi R11, R29, -4 */
		/* 820C2554h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFC);
		/* 820C2554h case    3:*/		return 0x820C2558;
		  /* 820C2558h */ case    4:  		/* mr R10, R22 */
		/* 820C2558h case    4:*/		regs.R10 = regs.R22;
		/* 820C2558h case    4:*/		return 0x820C255C;
		  /* 820C255Ch */ case    5:  		/* cmplwi CR0, R27, 0 */
		/* 820C255Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R27,0x00000000);
		/* 820C255Ch case    5:*/		return 0x820C2560;
		  /* 820C2560h */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 820C2560h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C2570;  }
		/* 820C2560h case    6:*/		return 0x820C2564;
		  /* 820C2564h */ case    7:  		/* mtspr CTR, R27 */
		/* 820C2564h case    7:*/		regs.CTR = regs.R27;
		/* 820C2564h case    7:*/		return 0x820C2568;
		  /* 820C2568h */ case    8:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C2568h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C2568h case    8:*/		return 0x820C256C;
		  /* 820C256Ch */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 820C256Ch case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2568;  }
		/* 820C256Ch case    9:*/		return 0x820C2570;
	}
	return 0x820C2570;
} // Block from 820C2548h-820C2570h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C2570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2570);
		  /* 820C2570h */ case    0:  		/* lwz R30, <#[R1 + 156]> */
		/* 820C2570h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000009C) );
		/* 820C2570h case    0:*/		return 0x820C2574;
		  /* 820C2574h */ case    1:  		/* mtspr CTR, R21 */
		/* 820C2574h case    1:*/		regs.CTR = regs.R21;
		/* 820C2574h case    1:*/		return 0x820C2578;
		  /* 820C2578h */ case    2:  		/* lwz R7, <#[R1 + 144]> */
		/* 820C2578h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000090) );
		/* 820C2578h case    2:*/		return 0x820C257C;
		  /* 820C257Ch */ case    3:  		/* mr R11, R14 */
		/* 820C257Ch case    3:*/		regs.R11 = regs.R14;
		/* 820C257Ch case    3:*/		return 0x820C2580;
		  /* 820C2580h */ case    4:  		/* mr R10, R30 */
		/* 820C2580h case    4:*/		regs.R10 = regs.R30;
		/* 820C2580h case    4:*/		return 0x820C2584;
		  /* 820C2584h */ case    5:  		/* subf R26, R14, R25 */
		/* 820C2584h case    5:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R14,regs.R25);
		/* 820C2584h case    5:*/		return 0x820C2588;
		  /* 820C2588h */ case    6:  		/* subf R8, R30, R7 */
		/* 820C2588h case    6:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R30,regs.R7);
		/* 820C2588h case    6:*/		return 0x820C258C;
		  /* 820C258Ch */ case    7:  		/* lwzx R9, <#[R26 + R11]> */
		/* 820C258Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + regs.R11 + 0x00000000) );
		/* 820C258Ch case    7:*/		return 0x820C2590;
		  /* 820C2590h */ case    8:  		/* cmplwi CR6, R9, 1 */
		/* 820C2590h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820C2590h case    8:*/		return 0x820C2594;
		  /* 820C2594h */ case    9:  		/* bc 4, CR6_EQ, 56 */
		/* 820C2594h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820C25CC;  }
		/* 820C2594h case    9:*/		return 0x820C2598;
		  /* 820C2598h */ case   10:  		/* lwz R9, <#[R11]> */
		/* 820C2598h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C2598h case   10:*/		return 0x820C259C;
		  /* 820C259Ch */ case   11:  		/* stwx R9, <#[R8 + R10]> */
		/* 820C259Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 820C259Ch case   11:*/		return 0x820C25A0;
		  /* 820C25A0h */ case   12:  		/* lwz R9, <#[R15 + 28]> */
		/* 820C25A0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R15 + 0x0000001C) );
		/* 820C25A0h case   12:*/		return 0x820C25A4;
		  /* 820C25A4h */ case   13:  		/* cmpwi CR6, R9, 0 */
		/* 820C25A4h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820C25A4h case   13:*/		return 0x820C25A8;
		  /* 820C25A8h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 820C25A8h case   14:*/		if ( regs.CR[6].eq ) { return 0x820C25C0;  }
		/* 820C25A8h case   14:*/		return 0x820C25AC;
		  /* 820C25ACh */ case   15:  		/* lwz R9, <#[R11]> */
		/* 820C25ACh case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C25ACh case   15:*/		return 0x820C25B0;
		  /* 820C25B0h */ case   16:  		/* b 20 */
		/* 820C25B0h case   16:*/		return 0x820C25C4;
		/* 820C25B0h case   16:*/		return 0x820C25B4;
	}
	return 0x820C25B4;
} // Block from 820C2570h-820C25B4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C25B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C25B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C25B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C25B4);
		  /* 820C25B4h */ case    0:  		/* lis R11, -32255 */
		/* 820C25B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C25B4h case    0:*/		return 0x820C25B8;
		  /* 820C25B8h */ case    1:  		/* addi R6, R11, 8112 */
		/* 820C25B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1FB0);
		/* 820C25B8h case    1:*/		return 0x820C25BC;
		  /* 820C25BCh */ case    2:  		/* b 1280 */
		/* 820C25BCh case    2:*/		return 0x820C2ABC;
		/* 820C25BCh case    2:*/		return 0x820C25C0;
	}
	return 0x820C25C0;
} // Block from 820C25B4h-820C25C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C25C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C25C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C25C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C25C0);
		  /* 820C25C0h */ case    0:  		/* mr R9, R22 */
		/* 820C25C0h case    0:*/		regs.R9 = regs.R22;
		/* 820C25C0h case    0:*/		return 0x820C25C4;
	}
	return 0x820C25C4;
} // Block from 820C25C0h-820C25C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C25C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C25C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C25C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C25C4);
		  /* 820C25C4h */ case    0:  		/* stw R9, <#[R10]> */
		/* 820C25C4h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820C25C4h case    0:*/		return 0x820C25C8;
		  /* 820C25C8h */ case    1:  		/* addi R10, R10, 4 */
		/* 820C25C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C25C8h case    1:*/		return 0x820C25CC;
	}
	return 0x820C25CC;
} // Block from 820C25C4h-820C25CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C25CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C25CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C25CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C25CC);
		  /* 820C25CCh */ case    0:  		/* addi R11, R11, 4 */
		/* 820C25CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820C25CCh case    0:*/		return 0x820C25D0;
		  /* 820C25D0h */ case    1:  		/* bc 16, CR0_LT, -68 */
		/* 820C25D0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C258C;  }
		/* 820C25D0h case    1:*/		return 0x820C25D4;
		  /* 820C25D4h */ case    2:  		/* mr R8, R27 */
		/* 820C25D4h case    2:*/		regs.R8 = regs.R27;
		/* 820C25D4h case    2:*/		return 0x820C25D8;
		  /* 820C25D8h */ case    3:  		/* mr R6, R29 */
		/* 820C25D8h case    3:*/		regs.R6 = regs.R29;
		/* 820C25D8h case    3:*/		return 0x820C25DC;
		  /* 820C25DCh */ case    4:  		/* mr R5, R28 */
		/* 820C25DCh case    4:*/		regs.R5 = regs.R28;
		/* 820C25DCh case    4:*/		return 0x820C25E0;
		  /* 820C25E0h */ case    5:  		/* mr R4, R15 */
		/* 820C25E0h case    5:*/		regs.R4 = regs.R15;
		/* 820C25E0h case    5:*/		return 0x820C25E4;
		  /* 820C25E4h */ case    6:  		/* mr R3, R17 */
		/* 820C25E4h case    6:*/		regs.R3 = regs.R17;
		/* 820C25E4h case    6:*/		return 0x820C25E8;
		  /* 820C25E8h */ case    7:  		/* bl -58424 */
		/* 820C25E8h case    7:*/		regs.LR = 0x820C25EC; return 0x820B41B0;
		/* 820C25E8h case    7:*/		return 0x820C25EC;
		  /* 820C25ECh */ case    8:  		/* or. R31, R3, R3 */
		/* 820C25ECh case    8:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C25ECh case    8:*/		return 0x820C25F0;
		  /* 820C25F0h */ case    9:  		/* bc 12, CR0_LT, 1252 */
		/* 820C25F0h case    9:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C25F0h case    9:*/		return 0x820C25F4;
		  /* 820C25F4h */ case   10:  		/* mr R5, R27 */
		/* 820C25F4h case   10:*/		regs.R5 = regs.R27;
		/* 820C25F4h case   10:*/		return 0x820C25F8;
		  /* 820C25F8h */ case   11:  		/* li R9, 23 */
		/* 820C25F8h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C25F8h case   11:*/		return 0x820C25FC;
		  /* 820C25FCh */ case   12:  		/* rlwimi R5, R19, 21, 0, 11 */
		/* 820C25FCh case   12:*/		cpu::op::rlwimi<0,21,0,11>(regs,&regs.R5,regs.R19);
		/* 820C25FCh case   12:*/		return 0x820C2600;
		  /* 820C2600h */ case   13:  		/* mr R8, R28 */
		/* 820C2600h case   13:*/		regs.R8 = regs.R28;
		/* 820C2600h case   13:*/		return 0x820C2604;
		  /* 820C2604h */ case   14:  		/* mr R7, R29 */
		/* 820C2604h case   14:*/		regs.R7 = regs.R29;
		/* 820C2604h case   14:*/		return 0x820C2608;
		  /* 820C2608h */ case   15:  		/* mr R6, R30 */
		/* 820C2608h case   15:*/		regs.R6 = regs.R30;
		/* 820C2608h case   15:*/		return 0x820C260C;
		  /* 820C260Ch */ case   16:  		/* mr R4, R15 */
		/* 820C260Ch case   16:*/		regs.R4 = regs.R15;
		/* 820C260Ch case   16:*/		return 0x820C2610;
		  /* 820C2610h */ case   17:  		/* mr R3, R17 */
		/* 820C2610h case   17:*/		regs.R3 = regs.R17;
		/* 820C2610h case   17:*/		return 0x820C2614;
		  /* 820C2614h */ case   18:  		/* bl -72460 */
		/* 820C2614h case   18:*/		regs.LR = 0x820C2618; return 0x820B0B08;
		/* 820C2614h case   18:*/		return 0x820C2618;
		  /* 820C2618h */ case   19:  		/* or. R31, R3, R3 */
		/* 820C2618h case   19:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C2618h case   19:*/		return 0x820C261C;
		  /* 820C261Ch */ case   20:  		/* bc 12, CR0_LT, 1208 */
		/* 820C261Ch case   20:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C261Ch case   20:*/		return 0x820C2620;
		  /* 820C2620h */ case   21:  		/* mr R11, R14 */
		/* 820C2620h case   21:*/		regs.R11 = regs.R14;
		/* 820C2620h case   21:*/		return 0x820C2624;
		  /* 820C2624h */ case   22:  		/* mtspr CTR, R21 */
		/* 820C2624h case   22:*/		regs.CTR = regs.R21;
		/* 820C2624h case   22:*/		return 0x820C2628;
		  /* 820C2628h */ case   23:  		/* addi R10, R30, -4 */
		/* 820C2628h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFFC);
		/* 820C2628h case   23:*/		return 0x820C262C;
		  /* 820C262Ch */ case   24:  		/* lwzx R9, <#[R11 + R26]> */
		/* 820C262Ch case   24:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 820C262Ch case   24:*/		return 0x820C2630;
		  /* 820C2630h */ case   25:  		/* cmplwi CR6, R9, 1 */
		/* 820C2630h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820C2630h case   25:*/		return 0x820C2634;
		  /* 820C2634h */ case   26:  		/* bc 4, CR6_EQ, 12 */
		/* 820C2634h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820C2640;  }
		/* 820C2634h case   26:*/		return 0x820C2638;
		  /* 820C2638h */ case   27:  		/* lwzu R9, <#[R10 + 4]> */
		/* 820C2638h case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C2638h case   27:*/		return 0x820C263C;
		  /* 820C263Ch */ case   28:  		/* stw R9, <#[R11]> */
		/* 820C263Ch case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C263Ch case   28:*/		return 0x820C2640;
	}
	return 0x820C2640;
} // Block from 820C25CCh-820C2640h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820C2640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2640);
		  /* 820C2640h */ case    0:  		/* addi R11, R11, 4 */
		/* 820C2640h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820C2640h case    0:*/		return 0x820C2644;
		  /* 820C2644h */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 820C2644h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C262C;  }
		/* 820C2644h case    1:*/		return 0x820C2648;
	}
	return 0x820C2648;
} // Block from 820C2640h-820C2648h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C2648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2648);
		  /* 820C2648h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 820C2648h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820C2648h case    0:*/		return 0x820C264C;
		  /* 820C264Ch */ case    1:  		/* bc 12, CR6_EQ, 980 */
		/* 820C264Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820C2A20;  }
		/* 820C264Ch case    1:*/		return 0x820C2650;
		  /* 820C2650h */ case    2:  		/* mulli R4, R24, 11 */
		/* 820C2650h case    2:*/		cpu::op::mulli<0>(regs,&regs.R4,regs.R24,0xB);
		/* 820C2650h case    2:*/		return 0x820C2654;
		  /* 820C2654h */ case    3:  		/* mr R3, R17 */
		/* 820C2654h case    3:*/		regs.R3 = regs.R17;
		/* 820C2654h case    3:*/		return 0x820C2658;
		  /* 820C2658h */ case    4:  		/* bl -73576 */
		/* 820C2658h case    4:*/		regs.LR = 0x820C265C; return 0x820B06F0;
		/* 820C2658h case    4:*/		return 0x820C265C;
		  /* 820C265Ch */ case    5:  		/* or. R11, R3, R3 */
		/* 820C265Ch case    5:*/		cpu::op::or<1>(regs,&regs.R11,regs.R3,regs.R3);
		/* 820C265Ch case    5:*/		return 0x820C2660;
		  /* 820C2660h */ case    6:  		/* bc 4, CR0_EQ, 40 */
		/* 820C2660h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820C2688;  }
		/* 820C2660h case    6:*/		return 0x820C2664;
	}
	return 0x820C2664;
} // Block from 820C2648h-820C2664h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C2664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2664);
		  /* 820C2664h */ case    0:  		/* lis R11, -32255 */
		/* 820C2664h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C2664h case    0:*/		return 0x820C2668;
		  /* 820C2668h */ case    1:  		/* li R5, 0 */
		/* 820C2668h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C2668h case    1:*/		return 0x820C266C;
		  /* 820C266Ch */ case    2:  		/* addi R6, R11, -10040 */
		/* 820C266Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFD8C8);
		/* 820C266Ch case    2:*/		return 0x820C2670;
		  /* 820C2670h */ case    3:  		/* mr R4, R15 */
		/* 820C2670h case    3:*/		regs.R4 = regs.R15;
		/* 820C2670h case    3:*/		return 0x820C2674;
		  /* 820C2674h */ case    4:  		/* mr R3, R17 */
		/* 820C2674h case    4:*/		regs.R3 = regs.R17;
		/* 820C2674h case    4:*/		return 0x820C2678;
		  /* 820C2678h */ case    5:  		/* bl -72840 */
		/* 820C2678h case    5:*/		regs.LR = 0x820C267C; return 0x820B09F0;
		/* 820C2678h case    5:*/		return 0x820C267C;
		  /* 820C267Ch */ case    6:  		/* lis R31, -32761 */
		/* 820C267Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820C267Ch case    6:*/		return 0x820C2680;
		  /* 820C2680h */ case    7:  		/* ori R31, R31, 14 */
		/* 820C2680h case    7:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820C2680h case    7:*/		return 0x820C2684;
		  /* 820C2684h */ case    8:  		/* b 1104 */
		/* 820C2684h case    8:*/		return 0x820C2AD4;
		/* 820C2684h case    8:*/		return 0x820C2688;
	}
	return 0x820C2688;
} // Block from 820C2664h-820C2688h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C2688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2688);
		  /* 820C2688h */ case    0:  		/* li R10, 11 */
		/* 820C2688h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0xB);
		/* 820C2688h case    0:*/		return 0x820C268C;
		  /* 820C268Ch */ case    1:  		/* addi R9, R1, 156 */
		/* 820C268Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x9C);
		/* 820C268Ch case    1:*/		return 0x820C2690;
		  /* 820C2690h */ case    2:  		/* rlwinm R8, R24, 2, 0, 29 */
		/* 820C2690h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R24);
		/* 820C2690h case    2:*/		return 0x820C2694;
		  /* 820C2694h */ case    3:  		/* mtspr CTR, R10 */
		/* 820C2694h case    3:*/		regs.CTR = regs.R10;
		/* 820C2694h case    3:*/		return 0x820C2698;
		  /* 820C2698h */ case    4:  		/* stwu R11, <#[R9 + 4]> */
		/* 820C2698h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C2698h case    4:*/		return 0x820C269C;
		  /* 820C269Ch */ case    5:  		/* add R11, R8, R11 */
		/* 820C269Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 820C269Ch case    5:*/		return 0x820C26A0;
		  /* 820C26A0h */ case    6:  		/* bc 16, CR0_LT, -8 */
		/* 820C26A0h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2698;  }
		/* 820C26A0h case    6:*/		return 0x820C26A4;
		  /* 820C26A4h */ case    7:  		/* lwz R20, <#[R1 + 200]> */
		/* 820C26A4h case    7:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x000000C8) );
		/* 820C26A4h case    7:*/		return 0x820C26A8;
		  /* 820C26A8h */ case    8:  		/* mtspr CTR, R21 */
		/* 820C26A8h case    8:*/		regs.CTR = regs.R21;
		/* 820C26A8h case    8:*/		return 0x820C26AC;
		  /* 820C26ACh */ case    9:  		/* lwz R27, <#[R1 + 160]> */
		/* 820C26ACh case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000A0) );
		/* 820C26ACh case    9:*/		return 0x820C26B0;
		  /* 820C26B0h */ case   10:  		/* mr R11, R14 */
		/* 820C26B0h case   10:*/		regs.R11 = regs.R14;
		/* 820C26B0h case   10:*/		return 0x820C26B4;
		  /* 820C26B4h */ case   11:  		/* mr R10, R20 */
		/* 820C26B4h case   11:*/		regs.R10 = regs.R20;
		/* 820C26B4h case   11:*/		return 0x820C26B8;
		  /* 820C26B8h */ case   12:  		/* subf R18, R14, R25 */
		/* 820C26B8h case   12:*/		cpu::op::subf<0>(regs,&regs.R18,regs.R14,regs.R25);
		/* 820C26B8h case   12:*/		return 0x820C26BC;
		  /* 820C26BCh */ case   13:  		/* subf R19, R20, R27 */
		/* 820C26BCh case   13:*/		cpu::op::subf<0>(regs,&regs.R19,regs.R20,regs.R27);
		/* 820C26BCh case   13:*/		return 0x820C26C0;
		  /* 820C26C0h */ case   14:  		/* lwzx R9, <#[R11 + R18]> */
		/* 820C26C0h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R18 + 0x00000000) );
		/* 820C26C0h case   14:*/		return 0x820C26C4;
		  /* 820C26C4h */ case   15:  		/* cmplwi CR6, R9, 2 */
		/* 820C26C4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000002);
		/* 820C26C4h case   15:*/		return 0x820C26C8;
		  /* 820C26C8h */ case   16:  		/* bc 4, CR6_EQ, 44 */
		/* 820C26C8h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820C26F4;  }
		/* 820C26C8h case   16:*/		return 0x820C26CC;
		  /* 820C26CCh */ case   17:  		/* lwz R9, <#[R11]> */
		/* 820C26CCh case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C26CCh case   17:*/		return 0x820C26D0;
		  /* 820C26D0h */ case   18:  		/* stwx R9, <#[R19 + R10]> */
		/* 820C26D0h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R19 + regs.R10 + 0x00000000) );
		/* 820C26D0h case   18:*/		return 0x820C26D4;
		  /* 820C26D4h */ case   19:  		/* lwz R9, <#[R15 + 28]> */
		/* 820C26D4h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R15 + 0x0000001C) );
		/* 820C26D4h case   19:*/		return 0x820C26D8;
		  /* 820C26D8h */ case   20:  		/* cmpwi CR6, R9, 0 */
		/* 820C26D8h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820C26D8h case   20:*/		return 0x820C26DC;
		  /* 820C26DCh */ case   21:  		/* bc 12, CR6_EQ, 12 */
		/* 820C26DCh case   21:*/		if ( regs.CR[6].eq ) { return 0x820C26E8;  }
		/* 820C26DCh case   21:*/		return 0x820C26E0;
		  /* 820C26E0h */ case   22:  		/* lwz R9, <#[R11]> */
		/* 820C26E0h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C26E0h case   22:*/		return 0x820C26E4;
		  /* 820C26E4h */ case   23:  		/* b 8 */
		/* 820C26E4h case   23:*/		return 0x820C26EC;
		/* 820C26E4h case   23:*/		return 0x820C26E8;
	}
	return 0x820C26E8;
} // Block from 820C2688h-820C26E8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820C26E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C26E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C26E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C26E8);
		  /* 820C26E8h */ case    0:  		/* mr R9, R22 */
		/* 820C26E8h case    0:*/		regs.R9 = regs.R22;
		/* 820C26E8h case    0:*/		return 0x820C26EC;
	}
	return 0x820C26EC;
} // Block from 820C26E8h-820C26ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C26ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C26EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C26EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C26EC);
		  /* 820C26ECh */ case    0:  		/* stw R9, <#[R10]> */
		/* 820C26ECh case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820C26ECh case    0:*/		return 0x820C26F0;
		  /* 820C26F0h */ case    1:  		/* addi R10, R10, 4 */
		/* 820C26F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C26F0h case    1:*/		return 0x820C26F4;
	}
	return 0x820C26F4;
} // Block from 820C26ECh-820C26F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C26F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C26F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C26F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C26F4);
		  /* 820C26F4h */ case    0:  		/* addi R11, R11, 4 */
		/* 820C26F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820C26F4h case    0:*/		return 0x820C26F8;
		  /* 820C26F8h */ case    1:  		/* bc 16, CR0_LT, -56 */
		/* 820C26F8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C26C0;  }
		/* 820C26F8h case    1:*/		return 0x820C26FC;
		  /* 820C26FCh */ case    2:  		/* addi R9, R1, 164 */
		/* 820C26FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xA4);
		/* 820C26FCh case    2:*/		return 0x820C2700;
		  /* 820C2700h */ case    3:  		/* li R8, 9 */
		/* 820C2700h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x9);
		/* 820C2700h case    3:*/		return 0x820C2704;
		  /* 820C2704h */ case    4:  		/* lwz R11, <#[R9]> */
		/* 820C2704h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 820C2704h case    4:*/		return 0x820C2708;
		  /* 820C2708h */ case    5:  		/* cmplwi CR6, R24, 0 */
		/* 820C2708h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820C2708h case    5:*/		return 0x820C270C;
		  /* 820C270Ch */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 820C270Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820C272C;  }
		/* 820C270Ch case    6:*/		return 0x820C2710;
		  /* 820C2710h */ case    7:  		/* addi R11, R11, -4 */
		/* 820C2710h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820C2710h case    7:*/		return 0x820C2714;
		  /* 820C2714h */ case    8:  		/* mr R10, R22 */
		/* 820C2714h case    8:*/		regs.R10 = regs.R22;
		/* 820C2714h case    8:*/		return 0x820C2718;
		  /* 820C2718h */ case    9:  		/* cmplwi CR0, R24, 0 */
		/* 820C2718h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R24,0x00000000);
		/* 820C2718h case    9:*/		return 0x820C271C;
		  /* 820C271Ch */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 820C271Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x820C272C;  }
		/* 820C271Ch case   10:*/		return 0x820C2720;
		  /* 820C2720h */ case   11:  		/* mtspr CTR, R24 */
		/* 820C2720h case   11:*/		regs.CTR = regs.R24;
		/* 820C2720h case   11:*/		return 0x820C2724;
		  /* 820C2724h */ case   12:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C2724h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C2724h case   12:*/		return 0x820C2728;
		  /* 820C2728h */ case   13:  		/* bc 16, CR0_LT, -4 */
		/* 820C2728h case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2724;  }
		/* 820C2728h case   13:*/		return 0x820C272C;
	}
	return 0x820C272C;
} // Block from 820C26F4h-820C272Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C272Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C272C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C272C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C272C);
		  /* 820C272Ch */ case    0:  		/* addic. R8, R8, -1 */
		/* 820C272Ch case    0:*/		cpu::op::addic<1>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820C272Ch case    0:*/		return 0x820C2730;
		  /* 820C2730h */ case    1:  		/* addi R9, R9, 4 */
		/* 820C2730h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820C2730h case    1:*/		return 0x820C2734;
		  /* 820C2734h */ case    2:  		/* bc 4, CR0_EQ, -48 */
		/* 820C2734h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820C2704;  }
		/* 820C2734h case    2:*/		return 0x820C2738;
		  /* 820C2738h */ case    3:  		/* lwz R28, <#[R1 + 164]> */
		/* 820C2738h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000A4) );
		/* 820C2738h case    3:*/		return 0x820C273C;
		  /* 820C273Ch */ case    4:  		/* rlwinm R30, R24, 0, 12, 31 */
		/* 820C273Ch case    4:*/		cpu::op::rlwinm<0,0,12,31>(regs,&regs.R30,regs.R24);
		/* 820C273Ch case    4:*/		return 0x820C2740;
		  /* 820C2740h */ case    5:  		/* li R9, 0 */
		/* 820C2740h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C2740h case    5:*/		return 0x820C2744;
		  /* 820C2744h */ case    6:  		/* li R8, 0 */
		/* 820C2744h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C2744h case    6:*/		return 0x820C2748;
		  /* 820C2748h */ case    7:  		/* mr R7, R27 */
		/* 820C2748h case    7:*/		regs.R7 = regs.R27;
		/* 820C2748h case    7:*/		return 0x820C274C;
		  /* 820C274Ch */ case    8:  		/* mr R6, R28 */
		/* 820C274Ch case    8:*/		regs.R6 = regs.R28;
		/* 820C274Ch case    8:*/		return 0x820C2750;
		  /* 820C2750h */ case    9:  		/* oris R5, R30, 4128 */
		/* 820C2750h case    9:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1020);
		/* 820C2750h case    9:*/		return 0x820C2754;
		  /* 820C2754h */ case   10:  		/* mr R4, R15 */
		/* 820C2754h case   10:*/		regs.R4 = regs.R15;
		/* 820C2754h case   10:*/		return 0x820C2758;
		  /* 820C2758h */ case   11:  		/* mr R3, R17 */
		/* 820C2758h case   11:*/		regs.R3 = regs.R17;
		/* 820C2758h case   11:*/		return 0x820C275C;
		  /* 820C275Ch */ case   12:  		/* bl -72788 */
		/* 820C275Ch case   12:*/		regs.LR = 0x820C2760; return 0x820B0B08;
		/* 820C275Ch case   12:*/		return 0x820C2760;
		  /* 820C2760h */ case   13:  		/* or. R31, R3, R3 */
		/* 820C2760h case   13:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C2760h case   13:*/		return 0x820C2764;
		  /* 820C2764h */ case   14:  		/* bc 12, CR0_LT, 880 */
		/* 820C2764h case   14:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C2764h case   14:*/		return 0x820C2768;
		  /* 820C2768h */ case   15:  		/* lwz R25, <#[R1 + 168]> */
		/* 820C2768h case   15:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000000A8) );
		/* 820C2768h case   15:*/		return 0x820C276C;
		  /* 820C276Ch */ case   16:  		/* li R9, 20 */
		/* 820C276Ch case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 820C276Ch case   16:*/		return 0x820C2770;
		  /* 820C2770h */ case   17:  		/* li R8, 0 */
		/* 820C2770h case   17:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C2770h case   17:*/		return 0x820C2774;
		  /* 820C2774h */ case   18:  		/* mr R7, R28 */
		/* 820C2774h case   18:*/		regs.R7 = regs.R28;
		/* 820C2774h case   18:*/		return 0x820C2778;
		  /* 820C2778h */ case   19:  		/* mr R6, R25 */
		/* 820C2778h case   19:*/		regs.R6 = regs.R25;
		/* 820C2778h case   19:*/		return 0x820C277C;
		  /* 820C277Ch */ case   20:  		/* oris R5, R30, 4160 */
		/* 820C277Ch case   20:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x1040);
		/* 820C277Ch case   20:*/		return 0x820C2780;
		  /* 820C2780h */ case   21:  		/* mr R4, R15 */
		/* 820C2780h case   21:*/		regs.R4 = regs.R15;
		/* 820C2780h case   21:*/		return 0x820C2784;
		  /* 820C2784h */ case   22:  		/* mr R3, R17 */
		/* 820C2784h case   22:*/		regs.R3 = regs.R17;
		/* 820C2784h case   22:*/		return 0x820C2788;
		  /* 820C2788h */ case   23:  		/* bl -72832 */
		/* 820C2788h case   23:*/		regs.LR = 0x820C278C; return 0x820B0B08;
		/* 820C2788h case   23:*/		return 0x820C278C;
		  /* 820C278Ch */ case   24:  		/* or. R31, R3, R3 */
		/* 820C278Ch case   24:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C278Ch case   24:*/		return 0x820C2790;
		  /* 820C2790h */ case   25:  		/* bc 12, CR0_LT, 836 */
		/* 820C2790h case   25:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C2790h case   25:*/		return 0x820C2794;
		  /* 820C2794h */ case   26:  		/* lwz R29, <#[R1 + 172]> */
		/* 820C2794h case   26:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000AC) );
		/* 820C2794h case   26:*/		return 0x820C2798;
		  /* 820C2798h */ case   27:  		/* oris R26, R30, 4112 */
		/* 820C2798h case   27:*/		cpu::op::oris<0>(regs,&regs.R26,regs.R30,0x1010);
		/* 820C2798h case   27:*/		return 0x820C279C;
		  /* 820C279Ch */ case   28:  		/* li R9, 24 */
		/* 820C279Ch case   28:*/		cpu::op::li<0>(regs,&regs.R9,0x18);
		/* 820C279Ch case   28:*/		return 0x820C27A0;
		  /* 820C27A0h */ case   29:  		/* li R8, 0 */
		/* 820C27A0h case   29:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C27A0h case   29:*/		return 0x820C27A4;
		  /* 820C27A4h */ case   30:  		/* mr R7, R25 */
		/* 820C27A4h case   30:*/		regs.R7 = regs.R25;
		/* 820C27A4h case   30:*/		return 0x820C27A8;
		  /* 820C27A8h */ case   31:  		/* mr R6, R29 */
		/* 820C27A8h case   31:*/		regs.R6 = regs.R29;
		/* 820C27A8h case   31:*/		return 0x820C27AC;
		  /* 820C27ACh */ case   32:  		/* mr R5, R26 */
		/* 820C27ACh case   32:*/		regs.R5 = regs.R26;
		/* 820C27ACh case   32:*/		return 0x820C27B0;
		  /* 820C27B0h */ case   33:  		/* mr R4, R15 */
		/* 820C27B0h case   33:*/		regs.R4 = regs.R15;
		/* 820C27B0h case   33:*/		return 0x820C27B4;
		  /* 820C27B4h */ case   34:  		/* mr R3, R17 */
		/* 820C27B4h case   34:*/		regs.R3 = regs.R17;
		/* 820C27B4h case   34:*/		return 0x820C27B8;
		  /* 820C27B8h */ case   35:  		/* bl -72880 */
		/* 820C27B8h case   35:*/		regs.LR = 0x820C27BC; return 0x820B0B08;
		/* 820C27B8h case   35:*/		return 0x820C27BC;
		  /* 820C27BCh */ case   36:  		/* or. R31, R3, R3 */
		/* 820C27BCh case   36:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C27BCh case   36:*/		return 0x820C27C0;
		  /* 820C27C0h */ case   37:  		/* bc 12, CR0_LT, 788 */
		/* 820C27C0h case   37:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C27C0h case   37:*/		return 0x820C27C4;
		  /* 820C27C4h */ case   38:  		/* lwz R22, <#[R1 + 176]> */
		/* 820C27C4h case   38:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x000000B0) );
		/* 820C27C4h case   38:*/		return 0x820C27C8;
		  /* 820C27C8h */ case   39:  		/* oris R23, R30, 8256 */
		/* 820C27C8h case   39:*/		cpu::op::oris<0>(regs,&regs.R23,regs.R30,0x2040);
		/* 820C27C8h case   39:*/		return 0x820C27CC;
		  /* 820C27CCh */ case   40:  		/* li R9, 2 */
		/* 820C27CCh case   40:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 820C27CCh case   40:*/		return 0x820C27D0;
		  /* 820C27D0h */ case   41:  		/* mr R8, R28 */
		/* 820C27D0h case   41:*/		regs.R8 = regs.R28;
		/* 820C27D0h case   41:*/		return 0x820C27D4;
		  /* 820C27D4h */ case   42:  		/* mr R7, R29 */
		/* 820C27D4h case   42:*/		regs.R7 = regs.R29;
		/* 820C27D4h case   42:*/		return 0x820C27D8;
		  /* 820C27D8h */ case   43:  		/* mr R6, R22 */
		/* 820C27D8h case   43:*/		regs.R6 = regs.R22;
		/* 820C27D8h case   43:*/		return 0x820C27DC;
		  /* 820C27DCh */ case   44:  		/* mr R5, R23 */
		/* 820C27DCh case   44:*/		regs.R5 = regs.R23;
		/* 820C27DCh case   44:*/		return 0x820C27E0;
		  /* 820C27E0h */ case   45:  		/* mr R4, R15 */
		/* 820C27E0h case   45:*/		regs.R4 = regs.R15;
		/* 820C27E0h case   45:*/		return 0x820C27E4;
		  /* 820C27E4h */ case   46:  		/* mr R3, R17 */
		/* 820C27E4h case   46:*/		regs.R3 = regs.R17;
		/* 820C27E4h case   46:*/		return 0x820C27E8;
		  /* 820C27E8h */ case   47:  		/* bl -72928 */
		/* 820C27E8h case   47:*/		regs.LR = 0x820C27EC; return 0x820B0B08;
		/* 820C27E8h case   47:*/		return 0x820C27EC;
		  /* 820C27ECh */ case   48:  		/* or. R31, R3, R3 */
		/* 820C27ECh case   48:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C27ECh case   48:*/		return 0x820C27F0;
		  /* 820C27F0h */ case   49:  		/* bc 12, CR0_LT, 740 */
		/* 820C27F0h case   49:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C27F0h case   49:*/		return 0x820C27F4;
		  /* 820C27F4h */ case   50:  		/* lwz R28, <#[R1 + 180]> */
		/* 820C27F4h case   50:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000B4) );
		/* 820C27F4h case   50:*/		return 0x820C27F8;
		  /* 820C27F8h */ case   51:  		/* li R9, 0 */
		/* 820C27F8h case   51:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C27F8h case   51:*/		return 0x820C27FC;
		  /* 820C27FCh */ case   52:  		/* li R8, 0 */
		/* 820C27FCh case   52:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C27FCh case   52:*/		return 0x820C2800;
		  /* 820C2800h */ case   53:  		/* mr R7, R27 */
		/* 820C2800h case   53:*/		regs.R7 = regs.R27;
		/* 820C2800h case   53:*/		return 0x820C2804;
		  /* 820C2804h */ case   54:  		/* mr R6, R28 */
		/* 820C2804h case   54:*/		regs.R6 = regs.R28;
		/* 820C2804h case   54:*/		return 0x820C2808;
		  /* 820C2808h */ case   55:  		/* mr R5, R26 */
		/* 820C2808h case   55:*/		regs.R5 = regs.R26;
		/* 820C2808h case   55:*/		return 0x820C280C;
		  /* 820C280Ch */ case   56:  		/* mr R4, R15 */
		/* 820C280Ch case   56:*/		regs.R4 = regs.R15;
		/* 820C280Ch case   56:*/		return 0x820C2810;
		  /* 820C2810h */ case   57:  		/* mr R3, R17 */
		/* 820C2810h case   57:*/		regs.R3 = regs.R17;
		/* 820C2810h case   57:*/		return 0x820C2814;
		  /* 820C2814h */ case   58:  		/* bl -72972 */
		/* 820C2814h case   58:*/		regs.LR = 0x820C2818; return 0x820B0B08;
		/* 820C2814h case   58:*/		return 0x820C2818;
		  /* 820C2818h */ case   59:  		/* or. R31, R3, R3 */
		/* 820C2818h case   59:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C2818h case   59:*/		return 0x820C281C;
		  /* 820C281Ch */ case   60:  		/* bc 12, CR0_LT, 696 */
		/* 820C281Ch case   60:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C281Ch case   60:*/		return 0x820C2820;
		  /* 820C2820h */ case   61:  		/* lwz R24, <#[R1 + 184]> */
		/* 820C2820h case   61:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x000000B8) );
		/* 820C2820h case   61:*/		return 0x820C2824;
		  /* 820C2824h */ case   62:  		/* oris R29, R30, 8224 */
		/* 820C2824h case   62:*/		cpu::op::oris<0>(regs,&regs.R29,regs.R30,0x2020);
		/* 820C2824h case   62:*/		return 0x820C2828;
		  /* 820C2828h */ case   63:  		/* li R9, 23 */
		/* 820C2828h case   63:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C2828h case   63:*/		return 0x820C282C;
		  /* 820C282Ch */ case   64:  		/* mr R8, R28 */
		/* 820C282Ch case   64:*/		regs.R8 = regs.R28;
		/* 820C282Ch case   64:*/		return 0x820C2830;
		  /* 820C2830h */ case   65:  		/* mr R7, R27 */
		/* 820C2830h case   65:*/		regs.R7 = regs.R27;
		/* 820C2830h case   65:*/		return 0x820C2834;
		  /* 820C2834h */ case   66:  		/* mr R6, R24 */
		/* 820C2834h case   66:*/		regs.R6 = regs.R24;
		/* 820C2834h case   66:*/		return 0x820C2838;
		  /* 820C2838h */ case   67:  		/* mr R5, R29 */
		/* 820C2838h case   67:*/		regs.R5 = regs.R29;
		/* 820C2838h case   67:*/		return 0x820C283C;
		  /* 820C283Ch */ case   68:  		/* mr R4, R15 */
		/* 820C283Ch case   68:*/		regs.R4 = regs.R15;
		/* 820C283Ch case   68:*/		return 0x820C2840;
		  /* 820C2840h */ case   69:  		/* mr R3, R17 */
		/* 820C2840h case   69:*/		regs.R3 = regs.R17;
		/* 820C2840h case   69:*/		return 0x820C2844;
		  /* 820C2844h */ case   70:  		/* bl -73020 */
		/* 820C2844h case   70:*/		regs.LR = 0x820C2848; return 0x820B0B08;
		/* 820C2844h case   70:*/		return 0x820C2848;
		  /* 820C2848h */ case   71:  		/* or. R31, R3, R3 */
		/* 820C2848h case   71:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C2848h case   71:*/		return 0x820C284C;
		  /* 820C284Ch */ case   72:  		/* bc 12, CR0_LT, 648 */
		/* 820C284Ch case   72:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C284Ch case   72:*/		return 0x820C2850;
		  /* 820C2850h */ case   73:  		/* lwz R27, <#[R1 + 188]> */
		/* 820C2850h case   73:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000BC) );
		/* 820C2850h case   73:*/		return 0x820C2854;
		  /* 820C2854h */ case   74:  		/* li R9, 0 */
		/* 820C2854h case   74:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C2854h case   74:*/		return 0x820C2858;
		  /* 820C2858h */ case   75:  		/* li R8, 0 */
		/* 820C2858h case   75:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C2858h case   75:*/		return 0x820C285C;
		  /* 820C285Ch */ case   76:  		/* mr R7, R25 */
		/* 820C285Ch case   76:*/		regs.R7 = regs.R25;
		/* 820C285Ch case   76:*/		return 0x820C2860;
		  /* 820C2860h */ case   77:  		/* mr R6, R27 */
		/* 820C2860h case   77:*/		regs.R6 = regs.R27;
		/* 820C2860h case   77:*/		return 0x820C2864;
		  /* 820C2864h */ case   78:  		/* mr R5, R26 */
		/* 820C2864h case   78:*/		regs.R5 = regs.R26;
		/* 820C2864h case   78:*/		return 0x820C2868;
		  /* 820C2868h */ case   79:  		/* mr R4, R15 */
		/* 820C2868h case   79:*/		regs.R4 = regs.R15;
		/* 820C2868h case   79:*/		return 0x820C286C;
		  /* 820C286Ch */ case   80:  		/* mr R3, R17 */
		/* 820C286Ch case   80:*/		regs.R3 = regs.R17;
		/* 820C286Ch case   80:*/		return 0x820C2870;
		  /* 820C2870h */ case   81:  		/* bl -73064 */
		/* 820C2870h case   81:*/		regs.LR = 0x820C2874; return 0x820B0B08;
		/* 820C2870h case   81:*/		return 0x820C2874;
		  /* 820C2874h */ case   82:  		/* or. R31, R3, R3 */
		/* 820C2874h case   82:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C2874h case   82:*/		return 0x820C2878;
		  /* 820C2878h */ case   83:  		/* bc 12, CR0_LT, 604 */
		/* 820C2878h case   83:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C2878h case   83:*/		return 0x820C287C;
		  /* 820C287Ch */ case   84:  		/* lwz R28, <#[R1 + 192]> */
		/* 820C287Ch case   84:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000C0) );
		/* 820C287Ch case   84:*/		return 0x820C2880;
		  /* 820C2880h */ case   85:  		/* li R9, 23 */
		/* 820C2880h case   85:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C2880h case   85:*/		return 0x820C2884;
		  /* 820C2884h */ case   86:  		/* mr R8, R25 */
		/* 820C2884h case   86:*/		regs.R8 = regs.R25;
		/* 820C2884h case   86:*/		return 0x820C2888;
		  /* 820C2888h */ case   87:  		/* mr R7, R27 */
		/* 820C2888h case   87:*/		regs.R7 = regs.R27;
		/* 820C2888h case   87:*/		return 0x820C288C;
		  /* 820C288Ch */ case   88:  		/* mr R6, R28 */
		/* 820C288Ch case   88:*/		regs.R6 = regs.R28;
		/* 820C288Ch case   88:*/		return 0x820C2890;
		  /* 820C2890h */ case   89:  		/* mr R5, R29 */
		/* 820C2890h case   89:*/		regs.R5 = regs.R29;
		/* 820C2890h case   89:*/		return 0x820C2894;
		  /* 820C2894h */ case   90:  		/* mr R4, R15 */
		/* 820C2894h case   90:*/		regs.R4 = regs.R15;
		/* 820C2894h case   90:*/		return 0x820C2898;
		  /* 820C2898h */ case   91:  		/* mr R3, R17 */
		/* 820C2898h case   91:*/		regs.R3 = regs.R17;
		/* 820C2898h case   91:*/		return 0x820C289C;
		  /* 820C289Ch */ case   92:  		/* bl -73108 */
		/* 820C289Ch case   92:*/		regs.LR = 0x820C28A0; return 0x820B0B08;
		/* 820C289Ch case   92:*/		return 0x820C28A0;
		  /* 820C28A0h */ case   93:  		/* or. R31, R3, R3 */
		/* 820C28A0h case   93:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C28A0h case   93:*/		return 0x820C28A4;
		  /* 820C28A4h */ case   94:  		/* bc 12, CR0_LT, 560 */
		/* 820C28A4h case   94:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C28A4h case   94:*/		return 0x820C28A8;
		  /* 820C28A8h */ case   95:  		/* lwz R29, <#[R1 + 196]> */
		/* 820C28A8h case   95:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000C4) );
		/* 820C28A8h case   95:*/		return 0x820C28AC;
		  /* 820C28ACh */ case   96:  		/* li R9, 23 */
		/* 820C28ACh case   96:*/		cpu::op::li<0>(regs,&regs.R9,0x17);
		/* 820C28ACh case   96:*/		return 0x820C28B0;
		  /* 820C28B0h */ case   97:  		/* mr R8, R28 */
		/* 820C28B0h case   97:*/		regs.R8 = regs.R28;
		/* 820C28B0h case   97:*/		return 0x820C28B4;
		  /* 820C28B4h */ case   98:  		/* mr R7, R24 */
		/* 820C28B4h case   98:*/		regs.R7 = regs.R24;
		/* 820C28B4h case   98:*/		return 0x820C28B8;
		  /* 820C28B8h */ case   99:  		/* mr R6, R29 */
		/* 820C28B8h case   99:*/		regs.R6 = regs.R29;
		/* 820C28B8h case   99:*/		return 0x820C28BC;
		  /* 820C28BCh */ case  100:  		/* oris R5, R30, 8272 */
		/* 820C28BCh case  100:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R30,0x2050);
		/* 820C28BCh case  100:*/		return 0x820C28C0;
		  /* 820C28C0h */ case  101:  		/* mr R4, R15 */
		/* 820C28C0h case  101:*/		regs.R4 = regs.R15;
		/* 820C28C0h case  101:*/		return 0x820C28C4;
		  /* 820C28C4h */ case  102:  		/* mr R3, R17 */
		/* 820C28C4h case  102:*/		regs.R3 = regs.R17;
		/* 820C28C4h case  102:*/		return 0x820C28C8;
		  /* 820C28C8h */ case  103:  		/* bl -73152 */
		/* 820C28C8h case  103:*/		regs.LR = 0x820C28CC; return 0x820B0B08;
		/* 820C28C8h case  103:*/		return 0x820C28CC;
		  /* 820C28CCh */ case  104:  		/* or. R31, R3, R3 */
		/* 820C28CCh case  104:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C28CCh case  104:*/		return 0x820C28D0;
		  /* 820C28D0h */ case  105:  		/* bc 12, CR0_LT, 516 */
		/* 820C28D0h case  105:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C28D0h case  105:*/		return 0x820C28D4;
		  /* 820C28D4h */ case  106:  		/* li R9, 2 */
		/* 820C28D4h case  106:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 820C28D4h case  106:*/		return 0x820C28D8;
		  /* 820C28D8h */ case  107:  		/* mr R8, R29 */
		/* 820C28D8h case  107:*/		regs.R8 = regs.R29;
		/* 820C28D8h case  107:*/		return 0x820C28DC;
		  /* 820C28DCh */ case  108:  		/* mr R7, R22 */
		/* 820C28DCh case  108:*/		regs.R7 = regs.R22;
		/* 820C28DCh case  108:*/		return 0x820C28E0;
		  /* 820C28E0h */ case  109:  		/* mr R6, R20 */
		/* 820C28E0h case  109:*/		regs.R6 = regs.R20;
		/* 820C28E0h case  109:*/		return 0x820C28E4;
		  /* 820C28E4h */ case  110:  		/* mr R5, R23 */
		/* 820C28E4h case  110:*/		regs.R5 = regs.R23;
		/* 820C28E4h case  110:*/		return 0x820C28E8;
		  /* 820C28E8h */ case  111:  		/* mr R4, R15 */
		/* 820C28E8h case  111:*/		regs.R4 = regs.R15;
		/* 820C28E8h case  111:*/		return 0x820C28EC;
		  /* 820C28ECh */ case  112:  		/* mr R3, R17 */
		/* 820C28ECh case  112:*/		regs.R3 = regs.R17;
		/* 820C28ECh case  112:*/		return 0x820C28F0;
		  /* 820C28F0h */ case  113:  		/* bl -73192 */
		/* 820C28F0h case  113:*/		regs.LR = 0x820C28F4; return 0x820B0B08;
		/* 820C28F0h case  113:*/		return 0x820C28F4;
		  /* 820C28F4h */ case  114:  		/* or. R31, R3, R3 */
		/* 820C28F4h case  114:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C28F4h case  114:*/		return 0x820C28F8;
		  /* 820C28F8h */ case  115:  		/* bc 12, CR0_LT, 476 */
		/* 820C28F8h case  115:*/		if ( regs.CR[0].lt ) { return 0x820C2AD4;  }
		/* 820C28F8h case  115:*/		return 0x820C28FC;
		  /* 820C28FCh */ case  116:  		/* mr R28, R14 */
		/* 820C28FCh case  116:*/		regs.R28 = regs.R14;
		/* 820C28FCh case  116:*/		return 0x820C2900;
		  /* 820C2900h */ case  117:  		/* mr R29, R20 */
		/* 820C2900h case  117:*/		regs.R29 = regs.R20;
		/* 820C2900h case  117:*/		return 0x820C2904;
		  /* 820C2904h */ case  118:  		/* mr R27, R21 */
		/* 820C2904h case  118:*/		regs.R27 = regs.R21;
		/* 820C2904h case  118:*/		return 0x820C2908;
		  /* 820C2908h */ case  119:  		/* lwzx R11, <#[R18 + R28]> */
		/* 820C2908h case  119:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R18 + regs.R28 + 0x00000000) );
		/* 820C2908h case  119:*/		return 0x820C290C;
		  /* 820C290Ch */ case  120:  		/* cmplwi CR6, R11, 2 */
		/* 820C290Ch case  120:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820C290Ch case  120:*/		return 0x820C2910;
		  /* 820C2910h */ case  121:  		/* bc 4, CR6_EQ, 260 */
		/* 820C2910h case  121:*/		if ( !regs.CR[6].eq ) { return 0x820C2A14;  }
		/* 820C2910h case  121:*/		return 0x820C2914;
		  /* 820C2914h */ case  122:  		/* lwz R11, <#[R17 + 8]> */
		/* 820C2914h case  122:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000008) );
		/* 820C2914h case  122:*/		return 0x820C2918;
		  /* 820C2918h */ case  123:  		/* lwzx R10, <#[R19 + R29]> */
		/* 820C2918h case  123:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + regs.R29 + 0x00000000) );
		/* 820C2918h case  123:*/		return 0x820C291C;
		  /* 820C291Ch */ case  124:  		/* lwz R9, <#[R29]> */
		/* 820C291Ch case  124:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 820C291Ch case  124:*/		return 0x820C2920;
		  /* 820C2920h */ case  125:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C2920h case  125:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C2920h case  125:*/		return 0x820C2924;
		  /* 820C2924h */ case  126:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C2924h case  126:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C2924h case  126:*/		return 0x820C2928;
		  /* 820C2928h */ case  127:  		/* lwz R11, <#[R11 + 20]> */
		/* 820C2928h case  127:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820C2928h case  127:*/		return 0x820C292C;
		  /* 820C292Ch */ case  128:  		/* lwzx R31, <#[R10 + R11]> */
		/* 820C292Ch case  128:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820C292Ch case  128:*/		return 0x820C2930;
		  /* 820C2930h */ case  129:  		/* lwzx R30, <#[R9 + R11]> */
		/* 820C2930h case  129:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820C2930h case  129:*/		return 0x820C2934;
		  /* 820C2934h */ case  130:  		/* lwz R11, <#[R31]> */
		/* 820C2934h case  130:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C2934h case  130:*/		return 0x820C2938;
		  /* 820C2938h */ case  131:  		/* rlwinm. R10, R11, 0, 24, 24 */
		/* 820C2938h case  131:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R10,regs.R11);
		/* 820C2938h case  131:*/		return 0x820C293C;
		  /* 820C293Ch */ case  132:  		/* bc 12, CR0_EQ, 20 */
		/* 820C293Ch case  132:*/		if ( regs.CR[0].eq ) { return 0x820C2950;  }
		/* 820C293Ch case  132:*/		return 0x820C2940;
		  /* 820C2940h */ case  133:  		/* ori R11, R11, 256 */
		/* 820C2940h case  133:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 820C2940h case  133:*/		return 0x820C2944;
		  /* 820C2944h */ case  134:  		/* lfd FR0, <#[R31 + 32]> */
		/* 820C2944h case  134:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000020) );
		/* 820C2944h case  134:*/		return 0x820C2948;
		  /* 820C2948h */ case  135:  		/* stfd FR0, <#[R31 + 40]> */
		/* 820C2948h case  135:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000028) );
		/* 820C2948h case  135:*/		return 0x820C294C;
		  /* 820C294Ch */ case  136:  		/* stw R11, <#[R31]> */
		/* 820C294Ch case  136:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C294Ch case  136:*/		return 0x820C2950;
	}
	return 0x820C2950;
} // Block from 820C272Ch-820C2950h (137 instructions)

//////////////////////////////////////////////////////
// Block at 820C2950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2950);
		  /* 820C2950h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820C2950h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C2950h case    0:*/		return 0x820C2954;
		  /* 820C2954h */ case    1:  		/* rlwinm. R11, R11, 0, 23, 23 */
		/* 820C2954h case    1:*/		cpu::op::rlwinm<1,0,23,23>(regs,&regs.R11,regs.R11);
		/* 820C2954h case    1:*/		return 0x820C2958;
		  /* 820C2958h */ case    2:  		/* bc 12, CR0_EQ, 176 */
		/* 820C2958h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C2A08;  }
		/* 820C2958h case    2:*/		return 0x820C295C;
		  /* 820C295Ch */ case    3:  		/* lfd FR1, <#[R31 + 32]> */
		/* 820C295Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R31 + 0x00000020) );
		/* 820C295Ch case    3:*/		return 0x820C2960;
		  /* 820C2960h */ case    4:  		/* bl -174480 */
		/* 820C2960h case    4:*/		regs.LR = 0x820C2964; return 0x82097FD0;
		/* 820C2960h case    4:*/		return 0x820C2964;
		  /* 820C2964h */ case    5:  		/* lfd FR0, <#[R31 + 32]> */
		/* 820C2964h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000020) );
		/* 820C2964h case    5:*/		return 0x820C2968;
		  /* 820C2968h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C2968h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C2968h case    6:*/		return 0x820C296C;
		  /* 820C296Ch */ case    7:  		/* bc 12, CR0_EQ, 44 */
		/* 820C296Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820C2998;  }
		/* 820C296Ch case    7:*/		return 0x820C2970;
		  /* 820C2970h */ case    8:  		/* lfd FR13, <#[R17 + 184]> */
		/* 820C2970h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R17 + 0x000000B8) );
		/* 820C2970h case    8:*/		return 0x820C2974;
		  /* 820C2974h */ case    9:  		/* fcmpu CR6, FR0, FR31 */
		/* 820C2974h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820C2974h case    9:*/		return 0x820C2978;
		  /* 820C2978h */ case   10:  		/* bc 12, CR6_LT, 20 */
		/* 820C2978h case   10:*/		if ( regs.CR[6].lt ) { return 0x820C298C;  }
		/* 820C2978h case   10:*/		return 0x820C297C;
		  /* 820C297Ch */ case   11:  		/* fadd FR1, FR13, FR0 */
		/* 820C297Ch case   11:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 820C297Ch case   11:*/		return 0x820C2980;
		  /* 820C2980h */ case   12:  		/* bl -199328 */
		/* 820C2980h case   12:*/		regs.LR = 0x820C2984; return 0x82091EE0;
		/* 820C2980h case   12:*/		return 0x820C2984;
		  /* 820C2984h */ case   13:  		/* stfd FR1, <#[R30 + 32]> */
		/* 820C2984h case   13:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R30 + 0x00000020) );
		/* 820C2984h case   13:*/		return 0x820C2988;
		  /* 820C2988h */ case   14:  		/* b 20 */
		/* 820C2988h case   14:*/		return 0x820C299C;
		/* 820C2988h case   14:*/		return 0x820C298C;
	}
	return 0x820C298C;
} // Block from 820C2950h-820C298Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C298Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C298C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C298C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C298C);
		  /* 820C298Ch */ case    0:  		/* fsub FR1, FR13, FR0 */
		/* 820C298Ch case    0:*/		cpu::op::fsub<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 820C298Ch case    0:*/		return 0x820C2990;
		  /* 820C2990h */ case    1:  		/* bl -199344 */
		/* 820C2990h case    1:*/		regs.LR = 0x820C2994; return 0x82091EE0;
		/* 820C2990h case    1:*/		return 0x820C2994;
		  /* 820C2994h */ case    2:  		/* fneg FR0, FR1 */
		/* 820C2994h case    2:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR1);
		/* 820C2994h case    2:*/		return 0x820C2998;
	}
	return 0x820C2998;
} // Block from 820C298Ch-820C2998h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C2998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2998);
		  /* 820C2998h */ case    0:  		/* stfd FR0, <#[R30 + 32]> */
		/* 820C2998h case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000020) );
		/* 820C2998h case    0:*/		return 0x820C299C;
	}
	return 0x820C299C;
} // Block from 820C2998h-820C299Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C299Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C299C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C299C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C299C);
		  /* 820C299Ch */ case    0:  		/* lfd FR1, <#[R31 + 40]> */
		/* 820C299Ch case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R31 + 0x00000028) );
		/* 820C299Ch case    0:*/		return 0x820C29A0;
		  /* 820C29A0h */ case    1:  		/* bl -174544 */
		/* 820C29A0h case    1:*/		regs.LR = 0x820C29A4; return 0x82097FD0;
		/* 820C29A0h case    1:*/		return 0x820C29A4;
		  /* 820C29A4h */ case    2:  		/* lfd FR0, <#[R31 + 40]> */
		/* 820C29A4h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000028) );
		/* 820C29A4h case    2:*/		return 0x820C29A8;
		  /* 820C29A8h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820C29A8h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C29A8h case    3:*/		return 0x820C29AC;
		  /* 820C29ACh */ case    4:  		/* bc 12, CR0_EQ, 44 */
		/* 820C29ACh case    4:*/		if ( regs.CR[0].eq ) { return 0x820C29D8;  }
		/* 820C29ACh case    4:*/		return 0x820C29B0;
		  /* 820C29B0h */ case    5:  		/* lfd FR13, <#[R17 + 184]> */
		/* 820C29B0h case    5:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R17 + 0x000000B8) );
		/* 820C29B0h case    5:*/		return 0x820C29B4;
		  /* 820C29B4h */ case    6:  		/* fcmpu CR6, FR0, FR31 */
		/* 820C29B4h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 820C29B4h case    6:*/		return 0x820C29B8;
		  /* 820C29B8h */ case    7:  		/* bc 12, CR6_LT, 20 */
		/* 820C29B8h case    7:*/		if ( regs.CR[6].lt ) { return 0x820C29CC;  }
		/* 820C29B8h case    7:*/		return 0x820C29BC;
		  /* 820C29BCh */ case    8:  		/* fadd FR1, FR13, FR0 */
		/* 820C29BCh case    8:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 820C29BCh case    8:*/		return 0x820C29C0;
		  /* 820C29C0h */ case    9:  		/* bl -199392 */
		/* 820C29C0h case    9:*/		regs.LR = 0x820C29C4; return 0x82091EE0;
		/* 820C29C0h case    9:*/		return 0x820C29C4;
		  /* 820C29C4h */ case   10:  		/* stfd FR1, <#[R30 + 40]> */
		/* 820C29C4h case   10:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R30 + 0x00000028) );
		/* 820C29C4h case   10:*/		return 0x820C29C8;
		  /* 820C29C8h */ case   11:  		/* b 20 */
		/* 820C29C8h case   11:*/		return 0x820C29DC;
		/* 820C29C8h case   11:*/		return 0x820C29CC;
	}
	return 0x820C29CC;
} // Block from 820C299Ch-820C29CCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C29CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C29CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C29CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C29CC);
		  /* 820C29CCh */ case    0:  		/* fsub FR1, FR13, FR0 */
		/* 820C29CCh case    0:*/		cpu::op::fsub<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 820C29CCh case    0:*/		return 0x820C29D0;
		  /* 820C29D0h */ case    1:  		/* bl -199408 */
		/* 820C29D0h case    1:*/		regs.LR = 0x820C29D4; return 0x82091EE0;
		/* 820C29D0h case    1:*/		return 0x820C29D4;
		  /* 820C29D4h */ case    2:  		/* fneg FR0, FR1 */
		/* 820C29D4h case    2:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR1);
		/* 820C29D4h case    2:*/		return 0x820C29D8;
	}
	return 0x820C29D8;
} // Block from 820C29CCh-820C29D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C29D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C29D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C29D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C29D8);
		  /* 820C29D8h */ case    0:  		/* stfd FR0, <#[R30 + 40]> */
		/* 820C29D8h case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000028) );
		/* 820C29D8h case    0:*/		return 0x820C29DC;
	}
	return 0x820C29DC;
} // Block from 820C29D8h-820C29DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C29DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C29DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C29DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C29DC);
		  /* 820C29DCh */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820C29DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C29DCh case    0:*/		return 0x820C29E0;
		  /* 820C29E0h */ case    1:  		/* lfd FR0, <#[R30 + 32]> */
		/* 820C29E0h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000020) );
		/* 820C29E0h case    1:*/		return 0x820C29E4;
		  /* 820C29E4h */ case    2:  		/* lfd FR13, <#[R30 + 40]> */
		/* 820C29E4h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R30 + 0x00000028) );
		/* 820C29E4h case    2:*/		return 0x820C29E8;
		  /* 820C29E8h */ case    3:  		/* ori R11, R11, 256 */
		/* 820C29E8h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 820C29E8h case    3:*/		return 0x820C29EC;
		  /* 820C29ECh */ case    4:  		/* fcmpu CR6, FR0, FR13 */
		/* 820C29ECh case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820C29ECh case    4:*/		return 0x820C29F0;
		  /* 820C29F0h */ case    5:  		/* stw R11, <#[R30]> */
		/* 820C29F0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C29F0h case    5:*/		return 0x820C29F4;
		  /* 820C29F4h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 820C29F4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820C2A00;  }
		/* 820C29F4h case    6:*/		return 0x820C29F8;
		  /* 820C29F8h */ case    7:  		/* ori R11, R11, 128 */
		/* 820C29F8h case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 820C29F8h case    7:*/		return 0x820C29FC;
		  /* 820C29FCh */ case    8:  		/* b 8 */
		/* 820C29FCh case    8:*/		return 0x820C2A04;
		/* 820C29FCh case    8:*/		return 0x820C2A00;
	}
	return 0x820C2A00;
} // Block from 820C29DCh-820C2A00h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C2A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2A00);
		  /* 820C2A00h */ case    0:  		/* rlwinm R11, R11, 0, 25, 23 */
		/* 820C2A00h case    0:*/		cpu::op::rlwinm<0,0,25,23>(regs,&regs.R11,regs.R11);
		/* 820C2A00h case    0:*/		return 0x820C2A04;
	}
	return 0x820C2A04;
} // Block from 820C2A00h-820C2A04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2A04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2A04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2A04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2A04);
		  /* 820C2A04h */ case    0:  		/* stw R11, <#[R30]> */
		/* 820C2A04h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C2A04h case    0:*/		return 0x820C2A08;
	}
	return 0x820C2A08;
} // Block from 820C2A04h-820C2A08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2A08);
		  /* 820C2A08h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 820C2A08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820C2A08h case    0:*/		return 0x820C2A0C;
		  /* 820C2A0Ch */ case    1:  		/* addi R29, R29, 4 */
		/* 820C2A0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820C2A0Ch case    1:*/		return 0x820C2A10;
		  /* 820C2A10h */ case    2:  		/* stw R11, <#[R28]> */
		/* 820C2A10h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820C2A10h case    2:*/		return 0x820C2A14;
	}
	return 0x820C2A14;
} // Block from 820C2A08h-820C2A14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C2A14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2A14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2A14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2A14);
		  /* 820C2A14h */ case    0:  		/* addic. R27, R27, -1 */
		/* 820C2A14h case    0:*/		cpu::op::addic<1>(regs,&regs.R27,regs.R27,0xFFFFFFFF);
		/* 820C2A14h case    0:*/		return 0x820C2A18;
		  /* 820C2A18h */ case    1:  		/* addi R28, R28, 4 */
		/* 820C2A18h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820C2A18h case    1:*/		return 0x820C2A1C;
		  /* 820C2A1Ch */ case    2:  		/* bc 4, CR0_EQ, -276 */
		/* 820C2A1Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820C2908;  }
		/* 820C2A1Ch case    2:*/		return 0x820C2A20;
	}
	return 0x820C2A20;
} // Block from 820C2A14h-820C2A20h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C2A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2A20);
		  /* 820C2A20h */ case    0:  		/* cmplwi CR6, R21, 0 */
		/* 820C2A20h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 820C2A20h case    0:*/		return 0x820C2A24;
		  /* 820C2A24h */ case    1:  		/* bc 12, CR6_EQ, 136 */
		/* 820C2A24h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C2AAC;  }
		/* 820C2A24h case    1:*/		return 0x820C2A28;
		  /* 820C2A28h */ case    2:  		/* mtspr CTR, R21 */
		/* 820C2A28h case    2:*/		regs.CTR = regs.R21;
		/* 820C2A28h case    2:*/		return 0x820C2A2C;
		  /* 820C2A2Ch */ case    3:  		/* mr R9, R16 */
		/* 820C2A2Ch case    3:*/		regs.R9 = regs.R16;
		/* 820C2A2Ch case    3:*/		return 0x820C2A30;
		  /* 820C2A30h */ case    4:  		/* subf R7, R16, R14 */
		/* 820C2A30h case    4:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R16,regs.R14);
		/* 820C2A30h case    4:*/		return 0x820C2A34;
		  /* 820C2A34h */ case    5:  		/* lwz R11, <#[R17 + 8]> */
		/* 820C2A34h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000008) );
		/* 820C2A34h case    5:*/		return 0x820C2A38;
		  /* 820C2A38h */ case    6:  		/* lwzx R10, <#[R7 + R9]> */
		/* 820C2A38h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + regs.R9 + 0x00000000) );
		/* 820C2A38h case    6:*/		return 0x820C2A3C;
		  /* 820C2A3Ch */ case    7:  		/* lwz R8, <#[R9]> */
		/* 820C2A3Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 820C2A3Ch case    7:*/		return 0x820C2A40;
		  /* 820C2A40h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C2A40h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C2A40h case    8:*/		return 0x820C2A44;
		  /* 820C2A44h */ case    9:  		/* rlwinm R6, R8, 0, 7, 3 */
		/* 820C2A44h case    9:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R6,regs.R8);
		/* 820C2A44h case    9:*/		return 0x820C2A48;
		  /* 820C2A48h */ case   10:  		/* lwz R11, <#[R11 + 20]> */
		/* 820C2A48h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820C2A48h case   10:*/		return 0x820C2A4C;
		  /* 820C2A4Ch */ case   11:  		/* lwzx R8, <#[R10 + R11]> */
		/* 820C2A4Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820C2A4Ch case   11:*/		return 0x820C2A50;
		  /* 820C2A50h */ case   12:  		/* lwz R11, <#[R8]> */
		/* 820C2A50h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820C2A50h case   12:*/		return 0x820C2A54;
		  /* 820C2A54h */ case   13:  		/* or R10, R6, R11 */
		/* 820C2A54h case   13:*/		cpu::op::or<0>(regs,&regs.R10,regs.R6,regs.R11);
		/* 820C2A54h case   13:*/		return 0x820C2A58;
		  /* 820C2A58h */ case   14:  		/* stw R10, <#[R8]> */
		/* 820C2A58h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820C2A58h case   14:*/		return 0x820C2A5C;
		  /* 820C2A5Ch */ case   15:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 820C2A5Ch case   15:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 820C2A5Ch case   15:*/		return 0x820C2A60;
		  /* 820C2A60h */ case   16:  		/* lwz R10, <#[R9]> */
		/* 820C2A60h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820C2A60h case   16:*/		return 0x820C2A64;
		  /* 820C2A64h */ case   17:  		/* rlwinm R10, R10, 0, 4, 6 */
		/* 820C2A64h case   17:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R10,regs.R10);
		/* 820C2A64h case   17:*/		return 0x820C2A68;
		  /* 820C2A68h */ case   18:  		/* bc 4, CR0_EQ, 8 */
		/* 820C2A68h case   18:*/		if ( !regs.CR[0].eq ) { return 0x820C2A70;  }
		/* 820C2A68h case   18:*/		return 0x820C2A6C;
		  /* 820C2A6Ch */ case   19:  		/* mr R11, R10 */
		/* 820C2A6Ch case   19:*/		regs.R11 = regs.R10;
		/* 820C2A6Ch case   19:*/		return 0x820C2A70;
	}
	return 0x820C2A70;
} // Block from 820C2A20h-820C2A70h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C2A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2A70);
		  /* 820C2A70h */ case    0:  		/* lwz R6, <#[R8 + 92]> */
		/* 820C2A70h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x0000005C) );
		/* 820C2A70h case    0:*/		return 0x820C2A74;
		  /* 820C2A74h */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 820C2A74h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820C2A74h case    1:*/		return 0x820C2A78;
		  /* 820C2A78h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C2A78h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C2A88;  }
		/* 820C2A78h case    2:*/		return 0x820C2A7C;
		  /* 820C2A7Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C2A7Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C2A7Ch case    3:*/		return 0x820C2A80;
		  /* 820C2A80h */ case    4:  		/* bc 12, CR6_LT, 20 */
		/* 820C2A80h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C2A94;  }
		/* 820C2A80h case    4:*/		return 0x820C2A84;
		  /* 820C2A84h */ case    5:  		/* b 12 */
		/* 820C2A84h case    5:*/		return 0x820C2A90;
		/* 820C2A84h case    5:*/		return 0x820C2A88;
	}
	return 0x820C2A88;
} // Block from 820C2A70h-820C2A88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C2A88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2A88);
		  /* 820C2A88h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 820C2A88h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C2A88h case    0:*/		return 0x820C2A8C;
		  /* 820C2A8Ch */ case    1:  		/* bc 12, CR6_GT, 8 */
		/* 820C2A8Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x820C2A94;  }
		/* 820C2A8Ch case    1:*/		return 0x820C2A90;
	}
	return 0x820C2A90;
} // Block from 820C2A88h-820C2A90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C2A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2A90);
		  /* 820C2A90h */ case    0:  		/* mr R11, R10 */
		/* 820C2A90h case    0:*/		regs.R11 = regs.R10;
		/* 820C2A90h case    0:*/		return 0x820C2A94;
	}
	return 0x820C2A94;
} // Block from 820C2A90h-820C2A94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2A94);
		  /* 820C2A94h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 820C2A94h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820C2A94h case    0:*/		return 0x820C2A98;
		  /* 820C2A98h */ case    1:  		/* addi R9, R9, 4 */
		/* 820C2A98h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820C2A98h case    1:*/		return 0x820C2A9C;
		  /* 820C2A9Ch */ case    2:  		/* rlwinm R10, R10, 0, 7, 3 */
		/* 820C2A9Ch case    2:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R10,regs.R10);
		/* 820C2A9Ch case    2:*/		return 0x820C2AA0;
		  /* 820C2AA0h */ case    3:  		/* or R11, R10, R11 */
		/* 820C2AA0h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C2AA0h case    3:*/		return 0x820C2AA4;
		  /* 820C2AA4h */ case    4:  		/* stw R11, <#[R8]> */
		/* 820C2AA4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820C2AA4h case    4:*/		return 0x820C2AA8;
		  /* 820C2AA8h */ case    5:  		/* bc 16, CR0_LT, -116 */
		/* 820C2AA8h case    5:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2A34;  }
		/* 820C2AA8h case    5:*/		return 0x820C2AAC;
	}
	return 0x820C2AAC;
} // Block from 820C2A94h-820C2AACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C2AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2AAC);
		  /* 820C2AACh */ case    0:  		/* li R31, 0 */
		/* 820C2AACh case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C2AACh case    0:*/		return 0x820C2AB0;
		  /* 820C2AB0h */ case    1:  		/* b 36 */
		/* 820C2AB0h case    1:*/		return 0x820C2AD4;
		/* 820C2AB0h case    1:*/		return 0x820C2AB4;
	}
	return 0x820C2AB4;
} // Block from 820C2AACh-820C2AB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C2AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2AB4);
		  /* 820C2AB4h */ case    0:  		/* lis R11, -32255 */
		/* 820C2AB4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C2AB4h case    0:*/		return 0x820C2AB8;
		  /* 820C2AB8h */ case    1:  		/* addi R6, R11, 9544 */
		/* 820C2AB8h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2548);
		/* 820C2AB8h case    1:*/		return 0x820C2ABC;
	}
	return 0x820C2ABC;
} // Block from 820C2AB4h-820C2ABCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C2ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2ABC);
		  /* 820C2ABCh */ case    0:  		/* li R4, 0 */
		/* 820C2ABCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C2ABCh case    0:*/		return 0x820C2AC0;
	}
	return 0x820C2AC0;
} // Block from 820C2ABCh-820C2AC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2AC0);
		  /* 820C2AC0h */ case    0:  		/* li R5, 0 */
		/* 820C2AC0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C2AC0h case    0:*/		return 0x820C2AC4;
		  /* 820C2AC4h */ case    1:  		/* mr R3, R17 */
		/* 820C2AC4h case    1:*/		regs.R3 = regs.R17;
		/* 820C2AC4h case    1:*/		return 0x820C2AC8;
		  /* 820C2AC8h */ case    2:  		/* bl -73944 */
		/* 820C2AC8h case    2:*/		regs.LR = 0x820C2ACC; return 0x820B09F0;
		/* 820C2AC8h case    2:*/		return 0x820C2ACC;
	}
	return 0x820C2ACC;
} // Block from 820C2AC0h-820C2ACCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C2ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2ACC);
		  /* 820C2ACCh */ case    0:  		/* lis R31, -32768 */
		/* 820C2ACCh case    0:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8000);
		/* 820C2ACCh case    0:*/		return 0x820C2AD0;
		  /* 820C2AD0h */ case    1:  		/* ori R31, R31, 16389 */
		/* 820C2AD0h case    1:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x4005);
		/* 820C2AD0h case    1:*/		return 0x820C2AD4;
	}
	return 0x820C2AD4;
} // Block from 820C2ACCh-820C2AD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C2AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2AD4);
		  /* 820C2AD4h */ case    0:  		/* lwz R11, <#[R1 + 132]> */
		/* 820C2AD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000084) );
		/* 820C2AD4h case    0:*/		return 0x820C2AD8;
		  /* 820C2AD8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C2AD8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C2AD8h case    1:*/		return 0x820C2ADC;
		  /* 820C2ADCh */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 820C2ADCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820C2B10;  }
		/* 820C2ADCh case    2:*/		return 0x820C2AE0;
		  /* 820C2AE0h */ case    3:  		/* lwz R10, <#[R11 - 8]> */
		/* 820C2AE0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 820C2AE0h case    3:*/		return 0x820C2AE4;
		  /* 820C2AE4h */ case    4:  		/* addi R3, R11, -8 */
		/* 820C2AE4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFF8);
		/* 820C2AE4h case    4:*/		return 0x820C2AE8;
		  /* 820C2AE8h */ case    5:  		/* stw R10, <#[R17 + 144]> */
		/* 820C2AE8h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R17 + 0x00000090) );
		/* 820C2AE8h case    5:*/		return 0x820C2AEC;
		  /* 820C2AECh */ case    6:  		/* lwz R11, <#[R11 - 4]> */
		/* 820C2AECh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 820C2AECh case    6:*/		return 0x820C2AF0;
		  /* 820C2AF0h */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820C2AF0h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C2AF0h case    7:*/		return 0x820C2AF4;
		  /* 820C2AF4h */ case    8:  		/* bc 4, CR6_GT, 12 */
		/* 820C2AF4h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820C2B00;  }
		/* 820C2AF4h case    8:*/		return 0x820C2AF8;
		  /* 820C2AF8h */ case    9:  		/* stw R11, <#[R17 + 148]> */
		/* 820C2AF8h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R17 + 0x00000094) );
		/* 820C2AF8h case    9:*/		return 0x820C2AFC;
		  /* 820C2AFCh */ case   10:  		/* b 20 */
		/* 820C2AFCh case   10:*/		return 0x820C2B10;
		/* 820C2AFCh case   10:*/		return 0x820C2B00;
	}
	return 0x820C2B00;
} // Block from 820C2AD4h-820C2B00h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C2B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2B00);
		  /* 820C2B00h */ case    0:  		/* neg R11, R11 */
		/* 820C2B00h case    0:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 820C2B00h case    0:*/		return 0x820C2B04;
		  /* 820C2B04h */ case    1:  		/* lis R4, 9345 */
		/* 820C2B04h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C2B04h case    1:*/		return 0x820C2B08;
		  /* 820C2B08h */ case    2:  		/* stw R11, <#[R17 + 148]> */
		/* 820C2B08h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R17 + 0x00000094) );
		/* 820C2B08h case    2:*/		return 0x820C2B0C;
		  /* 820C2B0Ch */ case    3:  		/* bl -239572 */
		/* 820C2B0Ch case    3:*/		regs.LR = 0x820C2B10; return 0x82088338;
		/* 820C2B0Ch case    3:*/		return 0x820C2B10;
	}
	return 0x820C2B10;
} // Block from 820C2B00h-820C2B10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C2B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2B10);
		  /* 820C2B10h */ case    0:  		/* lwz R11, <#[R1 + 128]> */
		/* 820C2B10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000080) );
		/* 820C2B10h case    0:*/		return 0x820C2B14;
		  /* 820C2B14h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C2B14h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C2B14h case    1:*/		return 0x820C2B18;
		  /* 820C2B18h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 820C2B18h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C2B4C;  }
		/* 820C2B18h case    2:*/		return 0x820C2B1C;
		  /* 820C2B1Ch */ case    3:  		/* lwz R10, <#[R11 - 8]> */
		/* 820C2B1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 820C2B1Ch case    3:*/		return 0x820C2B20;
		  /* 820C2B20h */ case    4:  		/* addi R3, R11, -8 */
		/* 820C2B20h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFF8);
		/* 820C2B20h case    4:*/		return 0x820C2B24;
		  /* 820C2B24h */ case    5:  		/* stw R10, <#[R17 + 144]> */
		/* 820C2B24h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R17 + 0x00000090) );
		/* 820C2B24h case    5:*/		return 0x820C2B28;
		  /* 820C2B28h */ case    6:  		/* lwz R11, <#[R11 - 4]> */
		/* 820C2B28h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 820C2B28h case    6:*/		return 0x820C2B2C;
		  /* 820C2B2Ch */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 820C2B2Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C2B2Ch case    7:*/		return 0x820C2B30;
		  /* 820C2B30h */ case    8:  		/* bc 4, CR6_GT, 12 */
		/* 820C2B30h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820C2B3C;  }
		/* 820C2B30h case    8:*/		return 0x820C2B34;
		  /* 820C2B34h */ case    9:  		/* stw R11, <#[R17 + 148]> */
		/* 820C2B34h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R17 + 0x00000094) );
		/* 820C2B34h case    9:*/		return 0x820C2B38;
		  /* 820C2B38h */ case   10:  		/* b 20 */
		/* 820C2B38h case   10:*/		return 0x820C2B4C;
		/* 820C2B38h case   10:*/		return 0x820C2B3C;
	}
	return 0x820C2B3C;
} // Block from 820C2B10h-820C2B3Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C2B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2B3C);
		  /* 820C2B3Ch */ case    0:  		/* neg R11, R11 */
		/* 820C2B3Ch case    0:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R11);
		/* 820C2B3Ch case    0:*/		return 0x820C2B40;
		  /* 820C2B40h */ case    1:  		/* lis R4, 9345 */
		/* 820C2B40h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C2B40h case    1:*/		return 0x820C2B44;
		  /* 820C2B44h */ case    2:  		/* stw R11, <#[R17 + 148]> */
		/* 820C2B44h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R17 + 0x00000094) );
		/* 820C2B44h case    2:*/		return 0x820C2B48;
		  /* 820C2B48h */ case    3:  		/* bl -239632 */
		/* 820C2B48h case    3:*/		regs.LR = 0x820C2B4C; return 0x82088338;
		/* 820C2B48h case    3:*/		return 0x820C2B4C;
	}
	return 0x820C2B4C;
} // Block from 820C2B3Ch-820C2B4Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C2B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2B4C);
		  /* 820C2B4Ch */ case    0:  		/* mr R3, R31 */
		/* 820C2B4Ch case    0:*/		regs.R3 = regs.R31;
		/* 820C2B4Ch case    0:*/		return 0x820C2B50;
		  /* 820C2B50h */ case    1:  		/* b 12 */
		/* 820C2B50h case    1:*/		return 0x820C2B5C;
		/* 820C2B50h case    1:*/		return 0x820C2B54;
	}
	return 0x820C2B54;
} // Block from 820C2B4Ch-820C2B54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C2B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2B54);
		  /* 820C2B54h */ case    0:  		/* lis R3, -32768 */
		/* 820C2B54h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C2B54h case    0:*/		return 0x820C2B58;
		  /* 820C2B58h */ case    1:  		/* ori R3, R3, 16389 */
		/* 820C2B58h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C2B58h case    1:*/		return 0x820C2B5C;
	}
	return 0x820C2B5C;
} // Block from 820C2B54h-820C2B5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C2B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2B5C);
		  /* 820C2B5Ch */ case    0:  		/* addi R1, R1, 368 */
		/* 820C2B5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x170);
		/* 820C2B5Ch case    0:*/		return 0x820C2B60;
		  /* 820C2B60h */ case    1:  		/* lfd FR31, <#[R1 - 160]> */
		/* 820C2B60h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 820C2B60h case    1:*/		return 0x820C2B64;
		  /* 820C2B64h */ case    2:  		/* b -202996 */
		/* 820C2B64h case    2:*/		return 0x82091270;
		/* 820C2B64h case    2:*/		return 0x820C2B68;
	}
	return 0x820C2B68;
} // Block from 820C2B5Ch-820C2B68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C2B68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2B68);
		  /* 820C2B68h */ case    0:  		/* mfspr R12, LR */
		/* 820C2B68h case    0:*/		regs.R12 = regs.LR;
		/* 820C2B68h case    0:*/		return 0x820C2B6C;
		  /* 820C2B6Ch */ case    1:  		/* bl -203028 */
		/* 820C2B6Ch case    1:*/		regs.LR = 0x820C2B70; return 0x82091258;
		/* 820C2B6Ch case    1:*/		return 0x820C2B70;
		  /* 820C2B70h */ case    2:  		/* stfd FR31, <#[R1 - 48]> */
		/* 820C2B70h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 820C2B70h case    2:*/		return 0x820C2B74;
		  /* 820C2B74h */ case    3:  		/* stwu R1, <#[R1 - 176]> */
		/* 820C2B74h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820C2B74h case    3:*/		return 0x820C2B78;
		  /* 820C2B78h */ case    4:  		/* mr R28, R3 */
		/* 820C2B78h case    4:*/		regs.R28 = regs.R3;
		/* 820C2B78h case    4:*/		return 0x820C2B7C;
		  /* 820C2B7Ch */ case    5:  		/* mr R29, R4 */
		/* 820C2B7Ch case    5:*/		regs.R29 = regs.R4;
		/* 820C2B7Ch case    5:*/		return 0x820C2B80;
		  /* 820C2B80h */ case    6:  		/* mr R31, R5 */
		/* 820C2B80h case    6:*/		regs.R31 = regs.R5;
		/* 820C2B80h case    6:*/		return 0x820C2B84;
		  /* 820C2B84h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820C2B84h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C2B84h case    7:*/		return 0x820C2B88;
		  /* 820C2B88h */ case    8:  		/* bc 4, CR6_EQ, 132 */
		/* 820C2B88h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C2C0C;  }
		/* 820C2B88h case    8:*/		return 0x820C2B8C;
		  /* 820C2B8Ch */ case    9:  		/* cmplwi CR6, R5, 0 */
		/* 820C2B8Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820C2B8Ch case    9:*/		return 0x820C2B90;
		  /* 820C2B90h */ case   10:  		/* bc 12, CR6_EQ, 116 */
		/* 820C2B90h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C2C04;  }
		/* 820C2B90h case   10:*/		return 0x820C2B94;
		  /* 820C2B94h */ case   11:  		/* cmplwi CR6, R6, 0 */
		/* 820C2B94h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820C2B94h case   11:*/		return 0x820C2B98;
		  /* 820C2B98h */ case   12:  		/* bc 12, CR6_EQ, 108 */
		/* 820C2B98h case   12:*/		if ( regs.CR[6].eq ) { return 0x820C2C04;  }
		/* 820C2B98h case   12:*/		return 0x820C2B9C;
		  /* 820C2B9Ch */ case   13:  		/* lis R11, -32256 */
		/* 820C2B9Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820C2B9Ch case   13:*/		return 0x820C2BA0;
		  /* 820C2BA0h */ case   14:  		/* mr R30, R6 */
		/* 820C2BA0h case   14:*/		regs.R30 = regs.R6;
		/* 820C2BA0h case   14:*/		return 0x820C2BA4;
		  /* 820C2BA4h */ case   15:  		/* li R29, -1 */
		/* 820C2BA4h case   15:*/		cpu::op::li<0>(regs,&regs.R29,0xFFFFFFFF);
		/* 820C2BA4h case   15:*/		return 0x820C2BA8;
		  /* 820C2BA8h */ case   16:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 820C2BA8h case   16:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 820C2BA8h case   16:*/		return 0x820C2BAC;
		  /* 820C2BACh */ case   17:  		/* lwz R3, <#[R28 + 8]> */
		/* 820C2BACh case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000008) );
		/* 820C2BACh case   17:*/		return 0x820C2BB0;
		  /* 820C2BB0h */ case   18:  		/* li R6, 0 */
		/* 820C2BB0h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C2BB0h case   18:*/		return 0x820C2BB4;
		  /* 820C2BB4h */ case   19:  		/* li R5, 0 */
		/* 820C2BB4h case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C2BB4h case   19:*/		return 0x820C2BB8;
		  /* 820C2BB8h */ case   20:  		/* fmr FR1, FR31 */
		/* 820C2BB8h case   20:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820C2BB8h case   20:*/		return 0x820C2BBC;
		  /* 820C2BBCh */ case   21:  		/* lwz R4, <#[R3 + 136]> */
		/* 820C2BBCh case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000088) );
		/* 820C2BBCh case   21:*/		return 0x820C2BC0;
		  /* 820C2BC0h */ case   22:  		/* bl 239208 */
		/* 820C2BC0h case   22:*/		regs.LR = 0x820C2BC4; return 0x820FD228;
		/* 820C2BC0h case   22:*/		return 0x820C2BC4;
		  /* 820C2BC4h */ case   23:  		/* stw R3, <#[R31]> */
		/* 820C2BC4h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820C2BC4h case   23:*/		return 0x820C2BC8;
		  /* 820C2BC8h */ case   24:  		/* lwz R11, <#[R28 + 8]> */
		/* 820C2BC8h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820C2BC8h case   24:*/		return 0x820C2BCC;
		  /* 820C2BCCh */ case   25:  		/* lwz R10, <#[R11 + 8]> */
		/* 820C2BCCh case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820C2BCCh case   25:*/		return 0x820C2BD0;
		  /* 820C2BD0h */ case   26:  		/* cmplw CR6, R3, R10 */
		/* 820C2BD0h case   26:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C2BD0h case   26:*/		return 0x820C2BD4;
		  /* 820C2BD4h */ case   27:  		/* bc 4, CR6_LT, 20 */
		/* 820C2BD4h case   27:*/		if ( !regs.CR[6].lt ) { return 0x820C2BE8;  }
		/* 820C2BD4h case   27:*/		return 0x820C2BD8;
		  /* 820C2BD8h */ case   28:  		/* lwz R11, <#[R11 + 20]> */
		/* 820C2BD8h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820C2BD8h case   28:*/		return 0x820C2BDC;
		  /* 820C2BDCh */ case   29:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820C2BDCh case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820C2BDCh case   29:*/		return 0x820C2BE0;
		  /* 820C2BE0h */ case   30:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820C2BE0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820C2BE0h case   30:*/		return 0x820C2BE4;
		  /* 820C2BE4h */ case   31:  		/* b 8 */
		/* 820C2BE4h case   31:*/		return 0x820C2BEC;
		/* 820C2BE4h case   31:*/		return 0x820C2BE8;
	}
	return 0x820C2BE8;
} // Block from 820C2B68h-820C2BE8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820C2BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2BE8);
		  /* 820C2BE8h */ case    0:  		/* li R11, 0 */
		/* 820C2BE8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C2BE8h case    0:*/		return 0x820C2BEC;
	}
	return 0x820C2BEC;
} // Block from 820C2BE8h-820C2BECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2BEC);
		  /* 820C2BECh */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C2BECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C2BECh case    0:*/		return 0x820C2BF0;
		  /* 820C2BF0h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820C2BF0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C2BF8;  }
		/* 820C2BF0h case    1:*/		return 0x820C2BF4;
		  /* 820C2BF4h */ case    2:  		/* stw R29, <#[R11 + 48]> */
		/* 820C2BF4h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000030) );
		/* 820C2BF4h case    2:*/		return 0x820C2BF8;
	}
	return 0x820C2BF8;
} // Block from 820C2BECh-820C2BF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C2BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2BF8);
		  /* 820C2BF8h */ case    0:  		/* addic. R30, R30, -1 */
		/* 820C2BF8h case    0:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 820C2BF8h case    0:*/		return 0x820C2BFC;
		  /* 820C2BFCh */ case    1:  		/* addi R31, R31, 4 */
		/* 820C2BFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820C2BFCh case    1:*/		return 0x820C2C00;
		  /* 820C2C00h */ case    2:  		/* bc 4, CR0_EQ, -84 */
		/* 820C2C00h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820C2BAC;  }
		/* 820C2C00h case    2:*/		return 0x820C2C04;
	}
	return 0x820C2C04;
} // Block from 820C2BF8h-820C2C04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C2C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2C04);
		  /* 820C2C04h */ case    0:  		/* li R3, 0 */
		/* 820C2C04h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C2C04h case    0:*/		return 0x820C2C08;
		  /* 820C2C08h */ case    1:  		/* b 568 */
		/* 820C2C08h case    1:*/		return 0x820C2E40;
		/* 820C2C08h case    1:*/		return 0x820C2C0C;
	}
	return 0x820C2C0C;
} // Block from 820C2C04h-820C2C0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C2C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2C0C);
		  /* 820C2C0Ch */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 820C2C0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820C2C0Ch case    0:*/		return 0x820C2C10;
		  /* 820C2C10h */ case    1:  		/* cmpwi CR6, R11, 15 */
		/* 820C2C10h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 820C2C10h case    1:*/		return 0x820C2C14;
		  /* 820C2C14h */ case    2:  		/* bc 4, CR6_EQ, 332 */
		/* 820C2C14h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C2D60;  }
		/* 820C2C14h case    2:*/		return 0x820C2C18;
		  /* 820C2C18h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 820C2C18h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C2C18h case    3:*/		return 0x820C2C1C;
		  /* 820C2C1Ch */ case    4:  		/* bc 12, CR6_EQ, -24 */
		/* 820C2C1Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820C2C04;  }
		/* 820C2C1Ch case    4:*/		return 0x820C2C20;
		  /* 820C2C20h */ case    5:  		/* lwz R11, <#[R29 + 16]> */
		/* 820C2C20h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 820C2C20h case    5:*/		return 0x820C2C24;
		  /* 820C2C24h */ case    6:  		/* cmpwi CR6, R11, 6 */
		/* 820C2C24h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820C2C24h case    6:*/		return 0x820C2C28;
		  /* 820C2C28h */ case    7:  		/* bc 4, CR6_EQ, 112 */
		/* 820C2C28h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820C2C98;  }
		/* 820C2C28h case    7:*/		return 0x820C2C2C;
		  /* 820C2C2Ch */ case    8:  		/* lwz R11, <#[R29 + 24]> */
		/* 820C2C2Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820C2C2Ch case    8:*/		return 0x820C2C30;
		  /* 820C2C30h */ case    9:  		/* cmpwi CR6, R11, -1 */
		/* 820C2C30h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820C2C30h case    9:*/		return 0x820C2C34;
		  /* 820C2C34h */ case   10:  		/* bc 4, CR6_EQ, 44 */
		/* 820C2C34h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820C2C60;  }
		/* 820C2C34h case   10:*/		return 0x820C2C38;
		  /* 820C2C38h */ case   11:  		/* cmplwi CR6, R6, 0 */
		/* 820C2C38h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820C2C38h case   11:*/		return 0x820C2C3C;
		  /* 820C2C3Ch */ case   12:  		/* bc 12, CR6_EQ, -56 */
		/* 820C2C3Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820C2C04;  }
		/* 820C2C3Ch case   12:*/		return 0x820C2C40;
		  /* 820C2C40h */ case   13:  		/* mtspr CTR, R6 */
		/* 820C2C40h case   13:*/		regs.CTR = regs.R6;
		/* 820C2C40h case   13:*/		return 0x820C2C44;
		  /* 820C2C44h */ case   14:  		/* li R11, 0 */
		/* 820C2C44h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C2C44h case   14:*/		return 0x820C2C48;
		  /* 820C2C48h */ case   15:  		/* lwz R10, <#[R28 + 28]> */
		/* 820C2C48h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x0000001C) );
		/* 820C2C48h case   15:*/		return 0x820C2C4C;
		  /* 820C2C4Ch */ case   16:  		/* lwzx R10, <#[R10 + R11]> */
		/* 820C2C4Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820C2C4Ch case   16:*/		return 0x820C2C50;
		  /* 820C2C50h */ case   17:  		/* stwx R10, <#[R11 + R31]> */
		/* 820C2C50h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 820C2C50h case   17:*/		return 0x820C2C54;
		  /* 820C2C54h */ case   18:  		/* addi R11, R11, 4 */
		/* 820C2C54h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820C2C54h case   18:*/		return 0x820C2C58;
		  /* 820C2C58h */ case   19:  		/* bc 16, CR0_LT, -16 */
		/* 820C2C58h case   19:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2C48;  }
		/* 820C2C58h case   19:*/		return 0x820C2C5C;
		  /* 820C2C5Ch */ case   20:  		/* b -88 */
		/* 820C2C5Ch case   20:*/		return 0x820C2C04;
		/* 820C2C5Ch case   20:*/		return 0x820C2C60;
	}
	return 0x820C2C60;
} // Block from 820C2C0Ch-820C2C60h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C2C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2C60);
		  /* 820C2C60h */ case    0:  		/* li R11, 0 */
		/* 820C2C60h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C2C60h case    0:*/		return 0x820C2C64;
		  /* 820C2C64h */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 820C2C64h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820C2C64h case    1:*/		return 0x820C2C68;
		  /* 820C2C68h */ case    2:  		/* bc 12, CR6_EQ, -100 */
		/* 820C2C68h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C2C04;  }
		/* 820C2C68h case    2:*/		return 0x820C2C6C;
		  /* 820C2C6Ch */ case    3:  		/* mtspr CTR, R6 */
		/* 820C2C6Ch case    3:*/		regs.CTR = regs.R6;
		/* 820C2C6Ch case    3:*/		return 0x820C2C70;
		  /* 820C2C70h */ case    4:  		/* addi R10, R31, -4 */
		/* 820C2C70h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFFC);
		/* 820C2C70h case    4:*/		return 0x820C2C74;
		  /* 820C2C74h */ case    5:  		/* lwz R9, <#[R29 + 24]> */
		/* 820C2C74h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000018) );
		/* 820C2C74h case    5:*/		return 0x820C2C78;
		  /* 820C2C78h */ case    6:  		/* lwz R8, <#[R28 + 24]> */
		/* 820C2C78h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000018) );
		/* 820C2C78h case    6:*/		return 0x820C2C7C;
		  /* 820C2C7Ch */ case    7:  		/* add R9, R9, R11 */
		/* 820C2C7Ch case    7:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 820C2C7Ch case    7:*/		return 0x820C2C80;
		  /* 820C2C80h */ case    8:  		/* addi R11, R11, 1 */
		/* 820C2C80h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C2C80h case    8:*/		return 0x820C2C84;
		  /* 820C2C84h */ case    9:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C2C84h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C2C84h case    9:*/		return 0x820C2C88;
		  /* 820C2C88h */ case   10:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820C2C88h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820C2C88h case   10:*/		return 0x820C2C8C;
		  /* 820C2C8Ch */ case   11:  		/* stwu R9, <#[R10 + 4]> */
		/* 820C2C8Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C2C8Ch case   11:*/		return 0x820C2C90;
		  /* 820C2C90h */ case   12:  		/* bc 16, CR0_LT, -28 */
		/* 820C2C90h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2C74;  }
		/* 820C2C90h case   12:*/		return 0x820C2C94;
		  /* 820C2C94h */ case   13:  		/* b -144 */
		/* 820C2C94h case   13:*/		return 0x820C2C04;
		/* 820C2C94h case   13:*/		return 0x820C2C98;
	}
	return 0x820C2C98;
} // Block from 820C2C60h-820C2C98h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C2C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2C98);
		  /* 820C2C98h */ case    0:  		/* lis R10, -32256 */
		/* 820C2C98h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820C2C98h case    0:*/		return 0x820C2C9C;
		  /* 820C2C9Ch */ case    1:  		/* li R30, 0 */
		/* 820C2C9Ch case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C2C9Ch case    1:*/		return 0x820C2CA0;
		  /* 820C2CA0h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 820C2CA0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C2CA0h case    2:*/		return 0x820C2CA4;
		  /* 820C2CA4h */ case    3:  		/* lfd FR1, <#[R10 + 1808]> */
		/* 820C2CA4h case    3:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R10 + 0x00000710) );
		/* 820C2CA4h case    3:*/		return 0x820C2CA8;
		  /* 820C2CA8h */ case    4:  		/* bc 12, CR6_LT, 68 */
		/* 820C2CA8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C2CEC;  }
		/* 820C2CA8h case    4:*/		return 0x820C2CAC;
		  /* 820C2CACh */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 820C2CACh case    5:*/		if ( regs.CR[6].eq ) { return 0x820C2CD4;  }
		/* 820C2CACh case    5:*/		return 0x820C2CB0;
		  /* 820C2CB0h */ case    6:  		/* cmplwi CR6, R11, 3 */
		/* 820C2CB0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C2CB0h case    6:*/		return 0x820C2CB4;
		  /* 820C2CB4h */ case    7:  		/* bc 12, CR6_LT, 16 */
		/* 820C2CB4h case    7:*/		if ( regs.CR[6].lt ) { return 0x820C2CC4;  }
		/* 820C2CB4h case    7:*/		return 0x820C2CB8;
		  /* 820C2CB8h */ case    8:  		/* bc 4, CR6_EQ, 76 */
		/* 820C2CB8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C2D04;  }
		/* 820C2CB8h case    8:*/		return 0x820C2CBC;
		  /* 820C2CBCh */ case    9:  		/* lfd FR1, <#[R29 + 24]> */
		/* 820C2CBCh case    9:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R29 + 0x00000018) );
		/* 820C2CBCh case    9:*/		return 0x820C2CC0;
		  /* 820C2CC0h */ case   10:  		/* b 68 */
		/* 820C2CC0h case   10:*/		return 0x820C2D04;
		/* 820C2CC0h case   10:*/		return 0x820C2CC4;
	}
	return 0x820C2CC4;
} // Block from 820C2C98h-820C2CC4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C2CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2CC4);
		  /* 820C2CC4h */ case    0:  		/* lwz R11, <#[R29 + 24]> */
		/* 820C2CC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820C2CC4h case    0:*/		return 0x820C2CC8;
		  /* 820C2CC8h */ case    1:  		/* std R11, <#[R1 + 112]> */
		/* 820C2CC8h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820C2CC8h case    1:*/		return 0x820C2CCC;
		  /* 820C2CCCh */ case    2:  		/* lfd FR0, <#[R1 + 112]> */
		/* 820C2CCCh case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 820C2CCCh case    2:*/		return 0x820C2CD0;
		  /* 820C2CD0h */ case    3:  		/* b 16 */
		/* 820C2CD0h case    3:*/		return 0x820C2CE0;
		/* 820C2CD0h case    3:*/		return 0x820C2CD4;
	}
	return 0x820C2CD4;
} // Block from 820C2CC4h-820C2CD4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C2CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2CD4);
		  /* 820C2CD4h */ case    0:  		/* lwa R11, <#[R29 + 24]> */
		/* 820C2CD4h case    0:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820C2CD4h case    0:*/		return 0x820C2CD8;
		  /* 820C2CD8h */ case    1:  		/* std R11, <#[R1 + 112]> */
		/* 820C2CD8h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820C2CD8h case    1:*/		return 0x820C2CDC;
		  /* 820C2CDCh */ case    2:  		/* lfd FR0, <#[R1 + 112]> */
		/* 820C2CDCh case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 820C2CDCh case    2:*/		return 0x820C2CE0;
	}
	return 0x820C2CE0;
} // Block from 820C2CD4h-820C2CE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C2CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2CE0);
		  /* 820C2CE0h */ case    0:  		/* li R30, 2 */
		/* 820C2CE0h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 820C2CE0h case    0:*/		return 0x820C2CE4;
		  /* 820C2CE4h */ case    1:  		/* fcfid FR1, FR0 */
		/* 820C2CE4h case    1:*/		cpu::op::fcfid<0>(regs,&regs.FR1,regs.FR0);
		/* 820C2CE4h case    1:*/		return 0x820C2CE8;
		  /* 820C2CE8h */ case    2:  		/* b 28 */
		/* 820C2CE8h case    2:*/		return 0x820C2D04;
		/* 820C2CE8h case    2:*/		return 0x820C2CEC;
	}
	return 0x820C2CEC;
} // Block from 820C2CE0h-820C2CECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C2CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2CEC);
		  /* 820C2CECh */ case    0:  		/* lwz R11, <#[R29 + 24]> */
		/* 820C2CECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820C2CECh case    0:*/		return 0x820C2CF0;
		  /* 820C2CF0h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 820C2CF0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C2CF0h case    1:*/		return 0x820C2CF4;
		  /* 820C2CF4h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 820C2CF4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C2D00;  }
		/* 820C2CF4h case    2:*/		return 0x820C2CF8;
		  /* 820C2CF8h */ case    3:  		/* lis R11, -32256 */
		/* 820C2CF8h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820C2CF8h case    3:*/		return 0x820C2CFC;
		  /* 820C2CFCh */ case    4:  		/* lfd FR1, <#[R11 + 1848]> */
		/* 820C2CFCh case    4:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000738) );
		/* 820C2CFCh case    4:*/		return 0x820C2D00;
	}
	return 0x820C2D00;
} // Block from 820C2CECh-820C2D00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C2D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2D00);
		  /* 820C2D00h */ case    0:  		/* li R30, 23 */
		/* 820C2D00h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x17);
		/* 820C2D00h case    0:*/		return 0x820C2D04;
	}
	return 0x820C2D04;
} // Block from 820C2D00h-820C2D04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2D04);
		  /* 820C2D04h */ case    0:  		/* lwz R3, <#[R28 + 8]> */
		/* 820C2D04h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000008) );
		/* 820C2D04h case    0:*/		return 0x820C2D08;
		  /* 820C2D08h */ case    1:  		/* li R6, 0 */
		/* 820C2D08h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C2D08h case    1:*/		return 0x820C2D0C;
		  /* 820C2D0Ch */ case    2:  		/* li R5, 0 */
		/* 820C2D0Ch case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C2D0Ch case    2:*/		return 0x820C2D10;
		  /* 820C2D10h */ case    3:  		/* lwz R4, <#[R3 + 120]> */
		/* 820C2D10h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000078) );
		/* 820C2D10h case    3:*/		return 0x820C2D14;
		  /* 820C2D14h */ case    4:  		/* bl 238868 */
		/* 820C2D14h case    4:*/		regs.LR = 0x820C2D18; return 0x820FD228;
		/* 820C2D14h case    4:*/		return 0x820C2D18;
		  /* 820C2D18h */ case    5:  		/* stw R3, <#[R31]> */
		/* 820C2D18h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820C2D18h case    5:*/		return 0x820C2D1C;
		  /* 820C2D1Ch */ case    6:  		/* lwz R11, <#[R28 + 8]> */
		/* 820C2D1Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820C2D1Ch case    6:*/		return 0x820C2D20;
		  /* 820C2D20h */ case    7:  		/* lwz R10, <#[R11 + 8]> */
		/* 820C2D20h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820C2D20h case    7:*/		return 0x820C2D24;
		  /* 820C2D24h */ case    8:  		/* cmplw CR6, R3, R10 */
		/* 820C2D24h case    8:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C2D24h case    8:*/		return 0x820C2D28;
		  /* 820C2D28h */ case    9:  		/* bc 4, CR6_LT, 20 */
		/* 820C2D28h case    9:*/		if ( !regs.CR[6].lt ) { return 0x820C2D3C;  }
		/* 820C2D28h case    9:*/		return 0x820C2D2C;
		  /* 820C2D2Ch */ case   10:  		/* lwz R11, <#[R11 + 20]> */
		/* 820C2D2Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 820C2D2Ch case   10:*/		return 0x820C2D30;
		  /* 820C2D30h */ case   11:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 820C2D30h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 820C2D30h case   11:*/		return 0x820C2D34;
		  /* 820C2D34h */ case   12:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820C2D34h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820C2D34h case   12:*/		return 0x820C2D38;
		  /* 820C2D38h */ case   13:  		/* b 8 */
		/* 820C2D38h case   13:*/		return 0x820C2D40;
		/* 820C2D38h case   13:*/		return 0x820C2D3C;
	}
	return 0x820C2D3C;
} // Block from 820C2D04h-820C2D3Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C2D3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2D3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2D3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2D3C);
		  /* 820C2D3Ch */ case    0:  		/* li R11, 0 */
		/* 820C2D3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C2D3Ch case    0:*/		return 0x820C2D40;
	}
	return 0x820C2D40;
} // Block from 820C2D3Ch-820C2D40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2D40);
		  /* 820C2D40h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C2D40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C2D40h case    0:*/		return 0x820C2D44;
		  /* 820C2D44h */ case    1:  		/* bc 12, CR6_EQ, -320 */
		/* 820C2D44h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C2C04;  }
		/* 820C2D44h case    1:*/		return 0x820C2D48;
		  /* 820C2D48h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 820C2D48h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C2D48h case    2:*/		return 0x820C2D4C;
		  /* 820C2D4Ch */ case    3:  		/* li R9, -1 */
		/* 820C2D4Ch case    3:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 820C2D4Ch case    3:*/		return 0x820C2D50;
		  /* 820C2D50h */ case    4:  		/* or R10, R10, R30 */
		/* 820C2D50h case    4:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 820C2D50h case    4:*/		return 0x820C2D54;
		  /* 820C2D54h */ case    5:  		/* stw R9, <#[R11 + 48]> */
		/* 820C2D54h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 820C2D54h case    5:*/		return 0x820C2D58;
		  /* 820C2D58h */ case    6:  		/* stw R10, <#[R11]> */
		/* 820C2D58h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C2D58h case    6:*/		return 0x820C2D5C;
		  /* 820C2D5Ch */ case    7:  		/* b -344 */
		/* 820C2D5Ch case    7:*/		return 0x820C2C04;
		/* 820C2D5Ch case    7:*/		return 0x820C2D60;
	}
	return 0x820C2D60;
} // Block from 820C2D40h-820C2D60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C2D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2D60);
		  /* 820C2D60h */ case    0:  		/* cmpwi CR6, R11, 14 */
		/* 820C2D60h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 820C2D60h case    0:*/		return 0x820C2D64;
		  /* 820C2D64h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820C2D64h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C2D80;  }
		/* 820C2D64h case    1:*/		return 0x820C2D68;
		  /* 820C2D68h */ case    2:  		/* li R6, 0 */
		/* 820C2D68h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C2D68h case    2:*/		return 0x820C2D6C;
		  /* 820C2D6Ch */ case    3:  		/* mr R5, R31 */
		/* 820C2D6Ch case    3:*/		regs.R5 = regs.R31;
		/* 820C2D6Ch case    3:*/		return 0x820C2D70;
		  /* 820C2D70h */ case    4:  		/* mr R4, R29 */
		/* 820C2D70h case    4:*/		regs.R4 = regs.R29;
		/* 820C2D70h case    4:*/		return 0x820C2D74;
		  /* 820C2D74h */ case    5:  		/* mr R3, R28 */
		/* 820C2D74h case    5:*/		regs.R3 = regs.R28;
		/* 820C2D74h case    5:*/		return 0x820C2D78;
		  /* 820C2D78h */ case    6:  		/* bl -7824 */
		/* 820C2D78h case    6:*/		regs.LR = 0x820C2D7C; return 0x820C0EE8;
		/* 820C2D78h case    6:*/		return 0x820C2D7C;
		  /* 820C2D7Ch */ case    7:  		/* b 196 */
		/* 820C2D7Ch case    7:*/		return 0x820C2E40;
		/* 820C2D7Ch case    7:*/		return 0x820C2D80;
	}
	return 0x820C2D80;
} // Block from 820C2D60h-820C2D80h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C2D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2D80);
		  /* 820C2D80h */ case    0:  		/* cmpwi CR6, R11, 1 */
		/* 820C2D80h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820C2D80h case    0:*/		return 0x820C2D84;
		  /* 820C2D84h */ case    1:  		/* bc 4, CR6_EQ, 156 */
		/* 820C2D84h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C2E20;  }
		/* 820C2D84h case    1:*/		return 0x820C2D88;
		  /* 820C2D88h */ case    2:  		/* lwz R4, <#[R29 + 8]> */
		/* 820C2D88h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000008) );
		/* 820C2D88h case    2:*/		return 0x820C2D8C;
		  /* 820C2D8Ch */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 820C2D8Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C2D8Ch case    3:*/		return 0x820C2D90;
		  /* 820C2D90h */ case    4:  		/* bc 12, CR6_EQ, 144 */
		/* 820C2D90h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C2E20;  }
		/* 820C2D90h case    4:*/		return 0x820C2D94;
		  /* 820C2D94h */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 820C2D94h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C2D94h case    5:*/		return 0x820C2D98;
		  /* 820C2D98h */ case    6:  		/* cmpwi CR6, R11, 15 */
		/* 820C2D98h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000F);
		/* 820C2D98h case    6:*/		return 0x820C2D9C;
		  /* 820C2D9Ch */ case    7:  		/* bc 4, CR6_EQ, 44 */
		/* 820C2D9Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820C2DC8;  }
		/* 820C2D9Ch case    7:*/		return 0x820C2DA0;
		  /* 820C2DA0h */ case    8:  		/* lwz R11, <#[R4 + 16]> */
		/* 820C2DA0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 820C2DA0h case    8:*/		return 0x820C2DA4;
		  /* 820C2DA4h */ case    9:  		/* li R30, 1 */
		/* 820C2DA4h case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820C2DA4h case    9:*/		return 0x820C2DA8;
		  /* 820C2DA8h */ case   10:  		/* cmpwi CR6, R11, 6 */
		/* 820C2DA8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 820C2DA8h case   10:*/		return 0x820C2DAC;
		  /* 820C2DACh */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 820C2DACh case   11:*/		if ( !regs.CR[6].eq ) { return 0x820C2DB4;  }
		/* 820C2DACh case   11:*/		return 0x820C2DB0;
		  /* 820C2DB0h */ case   12:  		/* lwz R30, <#[R4 + 28]> */
		/* 820C2DB0h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R4 + 0x0000001C) );
		/* 820C2DB0h case   12:*/		return 0x820C2DB4;
	}
	return 0x820C2DB4;
} // Block from 820C2D80h-820C2DB4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C2DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2DB4);
		  /* 820C2DB4h */ case    0:  		/* mr R6, R30 */
		/* 820C2DB4h case    0:*/		regs.R6 = regs.R30;
		/* 820C2DB4h case    0:*/		return 0x820C2DB8;
		  /* 820C2DB8h */ case    1:  		/* mr R5, R31 */
		/* 820C2DB8h case    1:*/		regs.R5 = regs.R31;
		/* 820C2DB8h case    1:*/		return 0x820C2DBC;
		  /* 820C2DBCh */ case    2:  		/* mr R3, R28 */
		/* 820C2DBCh case    2:*/		regs.R3 = regs.R28;
		/* 820C2DBCh case    2:*/		return 0x820C2DC0;
		  /* 820C2DC0h */ case    3:  		/* bl -600 */
		/* 820C2DC0h case    3:*/		regs.LR = 0x820C2DC4; return 0x820C2B68;
		/* 820C2DC0h case    3:*/		return 0x820C2DC4;
		  /* 820C2DC4h */ case    4:  		/* b 52 */
		/* 820C2DC4h case    4:*/		return 0x820C2DF8;
		/* 820C2DC4h case    4:*/		return 0x820C2DC8;
	}
	return 0x820C2DC8;
} // Block from 820C2DB4h-820C2DC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C2DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2DC8);
		  /* 820C2DC8h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820C2DC8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C2DC8h case    0:*/		return 0x820C2DCC;
		  /* 820C2DCCh */ case    1:  		/* bc 12, CR6_EQ, 84 */
		/* 820C2DCCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820C2E20;  }
		/* 820C2DCCh case    1:*/		return 0x820C2DD0;
		  /* 820C2DD0h */ case    2:  		/* lwz R11, <#[R4 + 4]> */
		/* 820C2DD0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C2DD0h case    2:*/		return 0x820C2DD4;
		  /* 820C2DD4h */ case    3:  		/* cmpwi CR6, R11, 14 */
		/* 820C2DD4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 820C2DD4h case    3:*/		return 0x820C2DD8;
		  /* 820C2DD8h */ case    4:  		/* bc 4, CR6_EQ, 72 */
		/* 820C2DD8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C2E20;  }
		/* 820C2DD8h case    4:*/		return 0x820C2DDC;
		  /* 820C2DDCh */ case    5:  		/* lwz R11, <#[R4 + 24]> */
		/* 820C2DDCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 820C2DDCh case    5:*/		return 0x820C2DE0;
		  /* 820C2DE0h */ case    6:  		/* li R6, 0 */
		/* 820C2DE0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C2DE0h case    6:*/		return 0x820C2DE4;
		  /* 820C2DE4h */ case    7:  		/* lwz R10, <#[R4 + 20]> */
		/* 820C2DE4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 820C2DE4h case    7:*/		return 0x820C2DE8;
		  /* 820C2DE8h */ case    8:  		/* mr R5, R31 */
		/* 820C2DE8h case    8:*/		regs.R5 = regs.R31;
		/* 820C2DE8h case    8:*/		return 0x820C2DEC;
		  /* 820C2DECh */ case    9:  		/* mr R3, R28 */
		/* 820C2DECh case    9:*/		regs.R3 = regs.R28;
		/* 820C2DECh case    9:*/		return 0x820C2DF0;
		  /* 820C2DF0h */ case   10:  		/* mullw R30, R11, R10 */
		/* 820C2DF0h case   10:*/		cpu::op::mullw<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 820C2DF0h case   10:*/		return 0x820C2DF4;
		  /* 820C2DF4h */ case   11:  		/* bl -7948 */
		/* 820C2DF4h case   11:*/		regs.LR = 0x820C2DF8; return 0x820C0EE8;
		/* 820C2DF4h case   11:*/		return 0x820C2DF8;
	}
	return 0x820C2DF8;
} // Block from 820C2DC8h-820C2DF8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C2DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2DF8);
		  /* 820C2DF8h */ case    0:  		/* cmpwi CR0, R3, 0 */
		/* 820C2DF8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C2DF8h case    0:*/		return 0x820C2DFC;
		  /* 820C2DFCh */ case    1:  		/* bc 12, CR0_LT, 68 */
		/* 820C2DFCh case    1:*/		if ( regs.CR[0].lt ) { return 0x820C2E40;  }
		/* 820C2DFCh case    1:*/		return 0x820C2E00;
		  /* 820C2E00h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 820C2E00h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C2E00h case    2:*/		return 0x820C2E04;
		  /* 820C2E04h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 820C2E04h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C2E10;  }
		/* 820C2E04h case    3:*/		return 0x820C2E08;
		  /* 820C2E08h */ case    4:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 820C2E08h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 820C2E08h case    4:*/		return 0x820C2E0C;
		  /* 820C2E0Ch */ case    5:  		/* add R31, R11, R31 */
		/* 820C2E0Ch case    5:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 820C2E0Ch case    5:*/		return 0x820C2E10;
	}
	return 0x820C2E10;
} // Block from 820C2DF8h-820C2E10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C2E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2E10);
		  /* 820C2E10h */ case    0:  		/* lwz R29, <#[R29 + 12]> */
		/* 820C2E10h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x0000000C) );
		/* 820C2E10h case    0:*/		return 0x820C2E14;
		  /* 820C2E14h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 820C2E14h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820C2E14h case    1:*/		return 0x820C2E18;
		  /* 820C2E18h */ case    2:  		/* bc 4, CR6_EQ, -144 */
		/* 820C2E18h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C2D88;  }
		/* 820C2E18h case    2:*/		return 0x820C2E1C;
		  /* 820C2E1Ch */ case    3:  		/* b -536 */
		/* 820C2E1Ch case    3:*/		return 0x820C2C04;
		/* 820C2E1Ch case    3:*/		return 0x820C2E20;
	}
	return 0x820C2E20;
} // Block from 820C2E10h-820C2E20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C2E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2E20);
		  /* 820C2E20h */ case    0:  		/* lis R11, -32255 */
		/* 820C2E20h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C2E20h case    0:*/		return 0x820C2E24;
		  /* 820C2E24h */ case    1:  		/* li R5, 0 */
		/* 820C2E24h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C2E24h case    1:*/		return 0x820C2E28;
		  /* 820C2E28h */ case    2:  		/* addi R6, R11, 9660 */
		/* 820C2E28h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x25BC);
		/* 820C2E28h case    2:*/		return 0x820C2E2C;
		  /* 820C2E2Ch */ case    3:  		/* li R4, 0 */
		/* 820C2E2Ch case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C2E2Ch case    3:*/		return 0x820C2E30;
		  /* 820C2E30h */ case    4:  		/* mr R3, R28 */
		/* 820C2E30h case    4:*/		regs.R3 = regs.R28;
		/* 820C2E30h case    4:*/		return 0x820C2E34;
		  /* 820C2E34h */ case    5:  		/* bl -74820 */
		/* 820C2E34h case    5:*/		regs.LR = 0x820C2E38; return 0x820B09F0;
		/* 820C2E34h case    5:*/		return 0x820C2E38;
		  /* 820C2E38h */ case    6:  		/* lis R3, -32768 */
		/* 820C2E38h case    6:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C2E38h case    6:*/		return 0x820C2E3C;
		  /* 820C2E3Ch */ case    7:  		/* ori R3, R3, 16389 */
		/* 820C2E3Ch case    7:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C2E3Ch case    7:*/		return 0x820C2E40;
	}
	return 0x820C2E40;
} // Block from 820C2E20h-820C2E40h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C2E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2E40);
		  /* 820C2E40h */ case    0:  		/* addi R1, R1, 176 */
		/* 820C2E40h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820C2E40h case    0:*/		return 0x820C2E44;
		  /* 820C2E44h */ case    1:  		/* lfd FR31, <#[R1 - 48]> */
		/* 820C2E44h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 820C2E44h case    1:*/		return 0x820C2E48;
		  /* 820C2E48h */ case    2:  		/* b -203680 */
		/* 820C2E48h case    2:*/		return 0x820912A8;
		/* 820C2E48h case    2:*/		return 0x820C2E4C;
		  /* 820C2E4Ch */ case    3:  		/* nop */
		/* 820C2E4Ch case    3:*/		cpu::op::nop();
		/* 820C2E4Ch case    3:*/		return 0x820C2E50;
	}
	return 0x820C2E50;
} // Block from 820C2E40h-820C2E50h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C2E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2E50);
		  /* 820C2E50h */ case    0:  		/* mfspr R12, LR */
		/* 820C2E50h case    0:*/		regs.R12 = regs.LR;
		/* 820C2E50h case    0:*/		return 0x820C2E54;
		  /* 820C2E54h */ case    1:  		/* bl -203776 */
		/* 820C2E54h case    1:*/		regs.LR = 0x820C2E58; return 0x82091254;
		/* 820C2E54h case    1:*/		return 0x820C2E58;
		  /* 820C2E58h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C2E58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C2E58h case    2:*/		return 0x820C2E5C;
		  /* 820C2E5Ch */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 820C2E5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C2E5Ch case    3:*/		return 0x820C2E60;
		  /* 820C2E60h */ case    4:  		/* mr R28, R3 */
		/* 820C2E60h case    4:*/		regs.R28 = regs.R3;
		/* 820C2E60h case    4:*/		return 0x820C2E64;
		  /* 820C2E64h */ case    5:  		/* mr R27, R4 */
		/* 820C2E64h case    5:*/		regs.R27 = regs.R4;
		/* 820C2E64h case    5:*/		return 0x820C2E68;
		  /* 820C2E68h */ case    6:  		/* cmpwi CR6, R11, 14 */
		/* 820C2E68h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000E);
		/* 820C2E68h case    6:*/		return 0x820C2E6C;
		  /* 820C2E6Ch */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820C2E6Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820C2E78;  }
		/* 820C2E6Ch case    7:*/		return 0x820C2E70;
		  /* 820C2E70h */ case    8:  		/* li R3, 0 */
		/* 820C2E70h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C2E70h case    8:*/		return 0x820C2E74;
		  /* 820C2E74h */ case    9:  		/* b 320 */
		/* 820C2E74h case    9:*/		return 0x820C2FB4;
		/* 820C2E74h case    9:*/		return 0x820C2E78;
	}
	return 0x820C2E78;
} // Block from 820C2E50h-820C2E78h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C2E78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2E78);
		  /* 820C2E78h */ case    0:  		/* lwz R11, <#[R27 + 24]> */
		/* 820C2E78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000018) );
		/* 820C2E78h case    0:*/		return 0x820C2E7C;
		  /* 820C2E7Ch */ case    1:  		/* lis R4, 9345 */
		/* 820C2E7Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C2E7Ch case    1:*/		return 0x820C2E80;
		  /* 820C2E80h */ case    2:  		/* lwz R10, <#[R27 + 20]> */
		/* 820C2E80h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000014) );
		/* 820C2E80h case    2:*/		return 0x820C2E84;
		  /* 820C2E84h */ case    3:  		/* mullw R30, R11, R10 */
		/* 820C2E84h case    3:*/		cpu::op::mullw<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 820C2E84h case    3:*/		return 0x820C2E88;
		  /* 820C2E88h */ case    4:  		/* rlwinm R3, R30, 2, 0, 29 */
		/* 820C2E88h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R30);
		/* 820C2E88h case    4:*/		return 0x820C2E8C;
		  /* 820C2E8Ch */ case    5:  		/* bl -240780 */
		/* 820C2E8Ch case    5:*/		regs.LR = 0x820C2E90; return 0x82088200;
		/* 820C2E8Ch case    5:*/		return 0x820C2E90;
		  /* 820C2E90h */ case    6:  		/* or. R29, R3, R3 */
		/* 820C2E90h case    6:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C2E90h case    6:*/		return 0x820C2E94;
		  /* 820C2E94h */ case    7:  		/* bc 4, CR0_EQ, 16 */
		/* 820C2E94h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820C2EA4;  }
		/* 820C2E94h case    7:*/		return 0x820C2E98;
		  /* 820C2E98h */ case    8:  		/* lis R31, -32761 */
		/* 820C2E98h case    8:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8007);
		/* 820C2E98h case    8:*/		return 0x820C2E9C;
		  /* 820C2E9Ch */ case    9:  		/* ori R31, R31, 14 */
		/* 820C2E9Ch case    9:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0xE);
		/* 820C2E9Ch case    9:*/		return 0x820C2EA0;
		  /* 820C2EA0h */ case   10:  		/* b 240 */
		/* 820C2EA0h case   10:*/		return 0x820C2F90;
		/* 820C2EA0h case   10:*/		return 0x820C2EA4;
	}
	return 0x820C2EA4;
} // Block from 820C2E78h-820C2EA4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C2EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2EA4);
		  /* 820C2EA4h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 820C2EA4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C2EA4h case    0:*/		return 0x820C2EA8;
		  /* 820C2EA8h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820C2EA8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C2EC8;  }
		/* 820C2EA8h case    1:*/		return 0x820C2EAC;
		  /* 820C2EACh */ case    2:  		/* addi R11, R29, -4 */
		/* 820C2EACh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFFFC);
		/* 820C2EACh case    2:*/		return 0x820C2EB0;
		  /* 820C2EB0h */ case    3:  		/* li R10, -1 */
		/* 820C2EB0h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C2EB0h case    3:*/		return 0x820C2EB4;
		  /* 820C2EB4h */ case    4:  		/* cmplwi CR0, R30, 0 */
		/* 820C2EB4h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 820C2EB4h case    4:*/		return 0x820C2EB8;
		  /* 820C2EB8h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 820C2EB8h case    5:*/		if ( regs.CR[0].eq ) { return 0x820C2EC8;  }
		/* 820C2EB8h case    5:*/		return 0x820C2EBC;
		  /* 820C2EBCh */ case    6:  		/* mtspr CTR, R30 */
		/* 820C2EBCh case    6:*/		regs.CTR = regs.R30;
		/* 820C2EBCh case    6:*/		return 0x820C2EC0;
		  /* 820C2EC0h */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 820C2EC0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820C2EC0h case    7:*/		return 0x820C2EC4;
		  /* 820C2EC4h */ case    8:  		/* bc 16, CR0_LT, -4 */
		/* 820C2EC4h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2EC0;  }
		/* 820C2EC4h case    8:*/		return 0x820C2EC8;
	}
	return 0x820C2EC8;
} // Block from 820C2EA4h-820C2EC8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C2EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2EC8);
		  /* 820C2EC8h */ case    0:  		/* li R6, 0 */
		/* 820C2EC8h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C2EC8h case    0:*/		return 0x820C2ECC;
		  /* 820C2ECCh */ case    1:  		/* mr R5, R29 */
		/* 820C2ECCh case    1:*/		regs.R5 = regs.R29;
		/* 820C2ECCh case    1:*/		return 0x820C2ED0;
		  /* 820C2ED0h */ case    2:  		/* mr R4, R27 */
		/* 820C2ED0h case    2:*/		regs.R4 = regs.R27;
		/* 820C2ED0h case    2:*/		return 0x820C2ED4;
		  /* 820C2ED4h */ case    3:  		/* mr R3, R28 */
		/* 820C2ED4h case    3:*/		regs.R3 = regs.R28;
		/* 820C2ED4h case    3:*/		return 0x820C2ED8;
		  /* 820C2ED8h */ case    4:  		/* bl -8176 */
		/* 820C2ED8h case    4:*/		regs.LR = 0x820C2EDC; return 0x820C0EE8;
		/* 820C2ED8h case    4:*/		return 0x820C2EDC;
		  /* 820C2EDCh */ case    5:  		/* or. R31, R3, R3 */
		/* 820C2EDCh case    5:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C2EDCh case    5:*/		return 0x820C2EE0;
		  /* 820C2EE0h */ case    6:  		/* bc 12, CR0_LT, 176 */
		/* 820C2EE0h case    6:*/		if ( regs.CR[0].lt ) { return 0x820C2F90;  }
		/* 820C2EE0h case    6:*/		return 0x820C2EE4;
		  /* 820C2EE4h */ case    7:  		/* li R11, 1 */
		/* 820C2EE4h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820C2EE4h case    7:*/		return 0x820C2EE8;
		  /* 820C2EE8h */ case    8:  		/* mr R5, R30 */
		/* 820C2EE8h case    8:*/		regs.R5 = regs.R30;
		/* 820C2EE8h case    8:*/		return 0x820C2EEC;
		  /* 820C2EECh */ case    9:  		/* li R9, 0 */
		/* 820C2EECh case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C2EECh case    9:*/		return 0x820C2EF0;
		  /* 820C2EF0h */ case   10:  		/* rlwimi R5, R11, 28, 0, 11 */
		/* 820C2EF0h case   10:*/		cpu::op::rlwimi<0,28,0,11>(regs,&regs.R5,regs.R11);
		/* 820C2EF0h case   10:*/		return 0x820C2EF4;
		  /* 820C2EF4h */ case   11:  		/* li R8, 0 */
		/* 820C2EF4h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C2EF4h case   11:*/		return 0x820C2EF8;
		  /* 820C2EF8h */ case   12:  		/* mr R7, R29 */
		/* 820C2EF8h case   12:*/		regs.R7 = regs.R29;
		/* 820C2EF8h case   12:*/		return 0x820C2EFC;
		  /* 820C2EFCh */ case   13:  		/* mr R6, R29 */
		/* 820C2EFCh case   13:*/		regs.R6 = regs.R29;
		/* 820C2EFCh case   13:*/		return 0x820C2F00;
		  /* 820C2F00h */ case   14:  		/* mr R4, R27 */
		/* 820C2F00h case   14:*/		regs.R4 = regs.R27;
		/* 820C2F00h case   14:*/		return 0x820C2F04;
		  /* 820C2F04h */ case   15:  		/* mr R3, R28 */
		/* 820C2F04h case   15:*/		regs.R3 = regs.R28;
		/* 820C2F04h case   15:*/		return 0x820C2F08;
		  /* 820C2F08h */ case   16:  		/* bl -74752 */
		/* 820C2F08h case   16:*/		regs.LR = 0x820C2F0C; return 0x820B0B08;
		/* 820C2F08h case   16:*/		return 0x820C2F0C;
		  /* 820C2F0Ch */ case   17:  		/* or. R31, R3, R3 */
		/* 820C2F0Ch case   17:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 820C2F0Ch case   17:*/		return 0x820C2F10;
		  /* 820C2F10h */ case   18:  		/* bc 12, CR0_LT, 128 */
		/* 820C2F10h case   18:*/		if ( regs.CR[0].lt ) { return 0x820C2F90;  }
		/* 820C2F10h case   18:*/		return 0x820C2F14;
		  /* 820C2F14h */ case   19:  		/* cmplwi CR6, R30, 0 */
		/* 820C2F14h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C2F14h case   19:*/		return 0x820C2F18;
		  /* 820C2F18h */ case   20:  		/* bc 12, CR6_EQ, 76 */
		/* 820C2F18h case   20:*/		if ( regs.CR[6].eq ) { return 0x820C2F64;  }
		/* 820C2F18h case   20:*/		return 0x820C2F1C;
		  /* 820C2F1Ch */ case   21:  		/* mtspr CTR, R30 */
		/* 820C2F1Ch case   21:*/		regs.CTR = regs.R30;
		/* 820C2F1Ch case   21:*/		return 0x820C2F20;
		  /* 820C2F20h */ case   22:  		/* mr R9, R29 */
		/* 820C2F20h case   22:*/		regs.R9 = regs.R29;
		/* 820C2F20h case   22:*/		return 0x820C2F24;
		  /* 820C2F24h */ case   23:  		/* lwz R11, <#[R28 + 8]> */
		/* 820C2F24h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820C2F24h case   23:*/		return 0x820C2F28;
		  /* 820C2F28h */ case   24:  		/* lwz R10, <#[R9]> */
		/* 820C2F28h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820C2F28h case   24:*/		return 0x820C2F2C;
		  /* 820C2F2Ch */ case   25:  		/* lwz R8, <#[R11 + 8]> */
		/* 820C2F2Ch case   25:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 820C2F2Ch case   25:*/		return 0x820C2F30;
		  /* 820C2F30h */ case   26:  		/* cmplw CR6, R10, R8 */
		/* 820C2F30h case   26:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 820C2F30h case   26:*/		return 0x820C2F34;
		  /* 820C2F34h */ case   27:  		/* bc 4, CR6_LT, 20 */
		/* 820C2F34h case   27:*/		if ( !regs.CR[6].lt ) { return 0x820C2F48;  }
		/* 820C2F34h case   27:*/		return 0x820C2F38;
		  /* 820C2F38h */ case   28:  		/* lwz R8, <#[R11 + 20]> */
		/* 820C2F38h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 820C2F38h case   28:*/		return 0x820C2F3C;
		  /* 820C2F3Ch */ case   29:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C2F3Ch case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C2F3Ch case   29:*/		return 0x820C2F40;
		  /* 820C2F40h */ case   30:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820C2F40h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820C2F40h case   30:*/		return 0x820C2F44;
		  /* 820C2F44h */ case   31:  		/* b 8 */
		/* 820C2F44h case   31:*/		return 0x820C2F4C;
		/* 820C2F44h case   31:*/		return 0x820C2F48;
	}
	return 0x820C2F48;
} // Block from 820C2EC8h-820C2F48h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820C2F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2F48);
		  /* 820C2F48h */ case    0:  		/* li R10, 0 */
		/* 820C2F48h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C2F48h case    0:*/		return 0x820C2F4C;
	}
	return 0x820C2F4C;
} // Block from 820C2F48h-820C2F4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2F4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2F4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2F4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2F4C);
		  /* 820C2F4Ch */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820C2F4Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C2F4Ch case    0:*/		return 0x820C2F50;
		  /* 820C2F50h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820C2F50h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C2F5C;  }
		/* 820C2F50h case    1:*/		return 0x820C2F54;
		  /* 820C2F54h */ case    2:  		/* lwz R11, <#[R11 + 132]> */
		/* 820C2F54h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000084) );
		/* 820C2F54h case    2:*/		return 0x820C2F58;
		  /* 820C2F58h */ case    3:  		/* stw R11, <#[R10 + 4]> */
		/* 820C2F58h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 820C2F58h case    3:*/		return 0x820C2F5C;
	}
	return 0x820C2F5C;
} // Block from 820C2F4Ch-820C2F5Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C2F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2F5C);
		  /* 820C2F5Ch */ case    0:  		/* addi R9, R9, 4 */
		/* 820C2F5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820C2F5Ch case    0:*/		return 0x820C2F60;
		  /* 820C2F60h */ case    1:  		/* bc 16, CR0_LT, -60 */
		/* 820C2F60h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C2F24;  }
		/* 820C2F60h case    1:*/		return 0x820C2F64;
	}
	return 0x820C2F64;
} // Block from 820C2F5Ch-820C2F64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C2F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2F64);
		  /* 820C2F64h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 820C2F64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820C2F64h case    0:*/		return 0x820C2F68;
		  /* 820C2F68h */ case    1:  		/* li R10, 0 */
		/* 820C2F68h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C2F68h case    1:*/		return 0x820C2F6C;
		  /* 820C2F6Ch */ case    2:  		/* li R9, 0 */
		/* 820C2F6Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C2F6Ch case    2:*/		return 0x820C2F70;
		  /* 820C2F70h */ case    3:  		/* lwz R4, <#[R27 + 16]> */
		/* 820C2F70h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000010) );
		/* 820C2F70h case    3:*/		return 0x820C2F74;
		  /* 820C2F74h */ case    4:  		/* li R8, 1 */
		/* 820C2F74h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820C2F74h case    4:*/		return 0x820C2F78;
		  /* 820C2F78h */ case    5:  		/* li R7, 1 */
		/* 820C2F78h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820C2F78h case    5:*/		return 0x820C2F7C;
		  /* 820C2F7Ch */ case    6:  		/* mr R5, R29 */
		/* 820C2F7Ch case    6:*/		regs.R5 = regs.R29;
		/* 820C2F7Ch case    6:*/		return 0x820C2F80;
		  /* 820C2F80h */ case    7:  		/* mr R3, R28 */
		/* 820C2F80h case    7:*/		regs.R3 = regs.R28;
		/* 820C2F80h case    7:*/		return 0x820C2F84;
		  /* 820C2F84h */ case    8:  		/* lwz R6, <#[R11 + 132]> */
		/* 820C2F84h case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000084) );
		/* 820C2F84h case    8:*/		return 0x820C2F88;
		  /* 820C2F88h */ case    9:  		/* bl -59128 */
		/* 820C2F88h case    9:*/		regs.LR = 0x820C2F8C; return 0x820B4890;
		/* 820C2F88h case    9:*/		return 0x820C2F8C;
		  /* 820C2F8Ch */ case   10:  		/* mr R31, R3 */
		/* 820C2F8Ch case   10:*/		regs.R31 = regs.R3;
		/* 820C2F8Ch case   10:*/		return 0x820C2F90;
	}
	return 0x820C2F90;
} // Block from 820C2F64h-820C2F90h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C2F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2F90);
		  /* 820C2F90h */ case    0:  		/* lis R4, 9345 */
		/* 820C2F90h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C2F90h case    0:*/		return 0x820C2F94;
		  /* 820C2F94h */ case    1:  		/* mr R3, R29 */
		/* 820C2F94h case    1:*/		regs.R3 = regs.R29;
		/* 820C2F94h case    1:*/		return 0x820C2F98;
		  /* 820C2F98h */ case    2:  		/* bl -240736 */
		/* 820C2F98h case    2:*/		regs.LR = 0x820C2F9C; return 0x82088338;
		/* 820C2F98h case    2:*/		return 0x820C2F9C;
		  /* 820C2F9Ch */ case    3:  		/* lwz R11, <#[R28 + 76]> */
		/* 820C2F9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000004C) );
		/* 820C2F9Ch case    3:*/		return 0x820C2FA0;
		  /* 820C2FA0h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 820C2FA0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C2FA0h case    4:*/		return 0x820C2FA4;
		  /* 820C2FA4h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 820C2FA4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C2FB0;  }
		/* 820C2FA4h case    5:*/		return 0x820C2FA8;
		  /* 820C2FA8h */ case    6:  		/* lis R31, -32768 */
		/* 820C2FA8h case    6:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8000);
		/* 820C2FA8h case    6:*/		return 0x820C2FAC;
		  /* 820C2FACh */ case    7:  		/* ori R31, R31, 16389 */
		/* 820C2FACh case    7:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R31,0x4005);
		/* 820C2FACh case    7:*/		return 0x820C2FB0;
	}
	return 0x820C2FB0;
} // Block from 820C2F90h-820C2FB0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C2FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2FB0);
		  /* 820C2FB0h */ case    0:  		/* mr R3, R31 */
		/* 820C2FB0h case    0:*/		regs.R3 = regs.R31;
		/* 820C2FB0h case    0:*/		return 0x820C2FB4;
	}
	return 0x820C2FB4;
} // Block from 820C2FB0h-820C2FB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C2FB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2FB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2FB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2FB4);
		  /* 820C2FB4h */ case    0:  		/* addi R1, R1, 128 */
		/* 820C2FB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C2FB4h case    0:*/		return 0x820C2FB8;
		  /* 820C2FB8h */ case    1:  		/* b -204052 */
		/* 820C2FB8h case    1:*/		return 0x820912A4;
		/* 820C2FB8h case    1:*/		return 0x820C2FBC;
		  /* 820C2FBCh */ case    2:  		/* nop */
		/* 820C2FBCh case    2:*/		cpu::op::nop();
		/* 820C2FBCh case    2:*/		return 0x820C2FC0;
		  /* 820C2FC0h */ case    3:  		/* lwz R17, <#[R6 - 11576]> */
		/* 820C2FC0h case    3:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R6 + 0xFFFFD2C8) );
		/* 820C2FC0h case    3:*/		return 0x820C2FC4;
		  /* 820C2FC4h */ case    4:  		/* lwz R16, <#[R4 - 15048]> */
		/* 820C2FC4h case    4:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R4 + 0xFFFFC538) );
		/* 820C2FC4h case    4:*/		return 0x820C2FC8;
	}
	return 0x820C2FC8;
} // Block from 820C2FB4h-820C2FC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C2FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C2FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C2FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C2FC8);
		  /* 820C2FC8h */ case    0:  		/* mfspr R12, LR */
		/* 820C2FC8h case    0:*/		regs.R12 = regs.LR;
		/* 820C2FC8h case    0:*/		return 0x820C2FCC;
		  /* 820C2FCCh */ case    1:  		/* bl -204204 */
		/* 820C2FCCh case    1:*/		regs.LR = 0x820C2FD0; return 0x82091220;
		/* 820C2FCCh case    1:*/		return 0x820C2FD0;
		  /* 820C2FD0h */ case    2:  		/* addi R31, R1, -656 */
		/* 820C2FD0h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0xFFFFFD70);
		/* 820C2FD0h case    2:*/		return 0x820C2FD4;
		  /* 820C2FD4h */ case    3:  		/* stwu R1, <#[R1 - 656]> */
		/* 820C2FD4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFD70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFD70);
		/* 820C2FD4h case    3:*/		return 0x820C2FD8;
		  /* 820C2FD8h */ case    4:  		/* mr R30, R3 */
		/* 820C2FD8h case    4:*/		regs.R30 = regs.R3;
		/* 820C2FD8h case    4:*/		return 0x820C2FDC;
		  /* 820C2FDCh */ case    5:  		/* stw R3, <#[R31 + 676]> */
		/* 820C2FDCh case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000002A4) );
		/* 820C2FDCh case    5:*/		return 0x820C2FE0;
		  /* 820C2FE0h */ case    6:  		/* mr R28, R4 */
		/* 820C2FE0h case    6:*/		regs.R28 = regs.R4;
		/* 820C2FE0h case    6:*/		return 0x820C2FE4;
		  /* 820C2FE4h */ case    7:  		/* mr R25, R5 */
		/* 820C2FE4h case    7:*/		regs.R25 = regs.R5;
		/* 820C2FE4h case    7:*/		return 0x820C2FE8;
		  /* 820C2FE8h */ case    8:  		/* mr R17, R6 */
		/* 820C2FE8h case    8:*/		regs.R17 = regs.R6;
		/* 820C2FE8h case    8:*/		return 0x820C2FEC;
		  /* 820C2FECh */ case    9:  		/* lis R5, 1 */
		/* 820C2FECh case    9:*/		cpu::op::lis<0>(regs,&regs.R5,0x1);
		/* 820C2FECh case    9:*/		return 0x820C2FF0;
		  /* 820C2FF0h */ case   10:  		/* lis R4, 16 */
		/* 820C2FF0h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x10);
		/* 820C2FF0h case   10:*/		return 0x820C2FF4;
		  /* 820C2FF4h */ case   11:  		/* stw R6, <#[R31 + 700]> */
		/* 820C2FF4h case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x000002BC) );
		/* 820C2FF4h case   11:*/		return 0x820C2FF8;
		  /* 820C2FF8h */ case   12:  		/* addi R3, R31, 256 */
		/* 820C2FF8h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x100);
		/* 820C2FF8h case   12:*/		return 0x820C2FFC;
		  /* 820C2FFCh */ case   13:  		/* mr R20, R7 */
		/* 820C2FFCh case   13:*/		regs.R20 = regs.R7;
		/* 820C2FFCh case   13:*/		return 0x820C3000;
		  /* 820C3000h */ case   14:  		/* mr R16, R8 */
		/* 820C3000h case   14:*/		regs.R16 = regs.R8;
		/* 820C3000h case   14:*/		return 0x820C3004;
		  /* 820C3004h */ case   15:  		/* mr R15, R9 */
		/* 820C3004h case   15:*/		regs.R15 = regs.R9;
		/* 820C3004h case   15:*/		return 0x820C3008;
		  /* 820C3008h */ case   16:  		/* mr R24, R10 */
		/* 820C3008h case   16:*/		regs.R24 = regs.R10;
		/* 820C3008h case   16:*/		return 0x820C300C;
		  /* 820C300Ch */ case   17:  		/* bl 24636 */
		/* 820C300Ch case   17:*/		regs.LR = 0x820C3010; return 0x820C9048;
		/* 820C300Ch case   17:*/		return 0x820C3010;
		  /* 820C3010h */ case   18:  		/* li R26, 0 */
		/* 820C3010h case   18:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820C3010h case   18:*/		return 0x820C3014;
		  /* 820C3014h */ case   19:  		/* li R4, 0 */
		/* 820C3014h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C3014h case   19:*/		return 0x820C3018;
		  /* 820C3018h */ case   20:  		/* stw R26, <#[R31 + 196]> */
		/* 820C3018h case   20:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C3018h case   20:*/		return 0x820C301C;
		  /* 820C301Ch */ case   21:  		/* mr R14, R26 */
		/* 820C301Ch case   21:*/		regs.R14 = regs.R26;
		/* 820C301Ch case   21:*/		return 0x820C3020;
		  /* 820C3020h */ case   22:  		/* stw R26, <#[R31 + 208]> */
		/* 820C3020h case   22:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000D0) );
		/* 820C3020h case   22:*/		return 0x820C3024;
		  /* 820C3024h */ case   23:  		/* li R3, 0 */
		/* 820C3024h case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C3024h case   23:*/		return 0x820C3028;
		  /* 820C3028h */ case   24:  		/* stw R26, <#[R31 + 212]> */
		/* 820C3028h case   24:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000D4) );
		/* 820C3028h case   24:*/		return 0x820C302C;
		  /* 820C302Ch */ case   25:  		/* mr R22, R26 */
		/* 820C302Ch case   25:*/		regs.R22 = regs.R26;
		/* 820C302Ch case   25:*/		return 0x820C3030;
		  /* 820C3030h */ case   26:  		/* stw R26, <#[R31 + 220]> */
		/* 820C3030h case   26:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000DC) );
		/* 820C3030h case   26:*/		return 0x820C3034;
		  /* 820C3034h */ case   27:  		/* mr R21, R26 */
		/* 820C3034h case   27:*/		regs.R21 = regs.R26;
		/* 820C3034h case   27:*/		return 0x820C3038;
		  /* 820C3038h */ case   28:  		/* bl -163496 */
		/* 820C3038h case   28:*/		regs.LR = 0x820C303C; return 0x8209B190;
		/* 820C3038h case   28:*/		return 0x820C303C;
		  /* 820C303Ch */ case   29:  		/* li R29, -1 */
		/* 820C303Ch case   29:*/		cpu::op::li<0>(regs,&regs.R29,0xFFFFFFFF);
		/* 820C303Ch case   29:*/		return 0x820C3040;
		  /* 820C3040h */ case   30:  		/* lis R4, 8 */
		/* 820C3040h case   30:*/		cpu::op::lis<0>(regs,&regs.R4,0x8);
		/* 820C3040h case   30:*/		return 0x820C3044;
		  /* 820C3044h */ case   31:  		/* stw R3, <#[R31 + 216]> */
		/* 820C3044h case   31:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000D8) );
		/* 820C3044h case   31:*/		return 0x820C3048;
		  /* 820C3048h */ case   32:  		/* mr R3, R29 */
		/* 820C3048h case   32:*/		regs.R3 = regs.R29;
		/* 820C3048h case   32:*/		return 0x820C304C;
		  /* 820C304Ch */ case   33:  		/* ori R4, R4, 31 */
		/* 820C304Ch case   33:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x1F);
		/* 820C304Ch case   33:*/		return 0x820C3050;
		  /* 820C3050h */ case   34:  		/* bl -163520 */
		/* 820C3050h case   34:*/		regs.LR = 0x820C3054; return 0x8209B190;
		/* 820C3050h case   34:*/		return 0x820C3054;
		  /* 820C3054h */ case   35:  		/* lis R4, 3 */
		/* 820C3054h case   35:*/		cpu::op::lis<0>(regs,&regs.R4,0x3);
		/* 820C3054h case   35:*/		return 0x820C3058;
		  /* 820C3058h */ case   36:  		/* li R3, 0 */
		/* 820C3058h case   36:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C3058h case   36:*/		return 0x820C305C;
		  /* 820C305Ch */ case   37:  		/* bl -163532 */
		/* 820C305Ch case   37:*/		regs.LR = 0x820C3060; return 0x8209B190;
		/* 820C305Ch case   37:*/		return 0x820C3060;
		  /* 820C3060h */ case   38:  		/* lwz R19, <#[R31 + 772]> */
		/* 820C3060h case   38:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R31 + 0x00000304) );
		/* 820C3060h case   38:*/		return 0x820C3064;
		  /* 820C3064h */ case   39:  		/* cmplwi CR6, R19, 0 */
		/* 820C3064h case   39:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000000);
		/* 820C3064h case   39:*/		return 0x820C3068;
		  /* 820C3068h */ case   40:  		/* bc 4, CR6_EQ, 44 */
		/* 820C3068h case   40:*/		if ( !regs.CR[6].eq ) { return 0x820C3094;  }
		/* 820C3068h case   40:*/		return 0x820C306C;
		  /* 820C306Ch */ case   41:  		/* li R10, 8 */
		/* 820C306Ch case   41:*/		cpu::op::li<0>(regs,&regs.R10,0x8);
		/* 820C306Ch case   41:*/		return 0x820C3070;
		  /* 820C3070h */ case   42:  		/* addi R11, R31, 280 */
		/* 820C3070h case   42:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x118);
		/* 820C3070h case   42:*/		return 0x820C3074;
		  /* 820C3074h */ case   43:  		/* mr R9, R26 */
		/* 820C3074h case   43:*/		regs.R9 = regs.R26;
		/* 820C3074h case   43:*/		return 0x820C3078;
		  /* 820C3078h */ case   44:  		/* mtspr CTR, R10 */
		/* 820C3078h case   44:*/		regs.CTR = regs.R10;
		/* 820C3078h case   44:*/		return 0x820C307C;
		  /* 820C307Ch */ case   45:  		/* stdu R9, <#[R11 + 8]> */
		/* 820C307Ch case   45:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		regs.R11 = (uint32)(regs.R11 + 0x00000008);
		/* 820C307Ch case   45:*/		return 0x820C3080;
		  /* 820C3080h */ case   46:  		/* bc 16, CR0_LT, -4 */
		/* 820C3080h case   46:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C307C;  }
		/* 820C3080h case   46:*/		return 0x820C3084;
		  /* 820C3084h */ case   47:  		/* addi R19, R31, 288 */
		/* 820C3084h case   47:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R31,0x120);
		/* 820C3084h case   47:*/		return 0x820C3088;
		  /* 820C3088h */ case   48:  		/* stw R9, <#[R11 + 8]> */
		/* 820C3088h case   48:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3088h case   48:*/		return 0x820C308C;
		  /* 820C308Ch */ case   49:  		/* stw R19, <#[R31 + 772]> */
		/* 820C308Ch case   49:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R31 + 0x00000304) );
		/* 820C308Ch case   49:*/		return 0x820C3090;
		  /* 820C3090h */ case   50:  		/* b 8 */
		/* 820C3090h case   50:*/		return 0x820C3098;
		/* 820C3090h case   50:*/		return 0x820C3094;
	}
	return 0x820C3094;
} // Block from 820C2FC8h-820C3094h (51 instructions)

//////////////////////////////////////////////////////
// Block at 820C3094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3094);
		  /* 820C3094h */ case    0:  		/* stw R26, <#[R19 + 28]> */
		/* 820C3094h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R19 + 0x0000001C) );
		/* 820C3094h case    0:*/		return 0x820C3098;
	}
	return 0x820C3098;
} // Block from 820C3094h-820C3098h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C3098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3098);
		  /* 820C3098h */ case    0:  		/* lwz R27, <#[R31 + 748]> */
		/* 820C3098h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x000002EC) );
		/* 820C3098h case    0:*/		return 0x820C309C;
		  /* 820C309Ch */ case    1:  		/* lis R12, -863 */
		/* 820C309Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFFCA1);
		/* 820C309Ch case    1:*/		return 0x820C30A0;
		  /* 820C30A0h */ case    2:  		/* ori R12, R12, 57344 */
		/* 820C30A0h case    2:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xE000);
		/* 820C30A0h case    2:*/		return 0x820C30A4;
		  /* 820C30A4h */ case    3:  		/* and. R11, R27, R12 */
		/* 820C30A4h case    3:*/		cpu::op::and<1>(regs,&regs.R11,regs.R27,regs.R12);
		/* 820C30A4h case    3:*/		return 0x820C30A8;
		  /* 820C30A8h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820C30A8h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C30B8;  }
		/* 820C30A8h case    4:*/		return 0x820C30AC;
		  /* 820C30ACh */ case    5:  		/* lis R29, -30602 */
		/* 820C30ACh case    5:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8876);
		/* 820C30ACh case    5:*/		return 0x820C30B0;
		  /* 820C30B0h */ case    6:  		/* ori R29, R29, 2156 */
		/* 820C30B0h case    6:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0x86C);
		/* 820C30B0h case    6:*/		return 0x820C30B4;
		  /* 820C30B4h */ case    7:  		/* b 2332 */
		/* 820C30B4h case    7:*/		return 0x820C39D0;
		/* 820C30B4h case    7:*/		return 0x820C30B8;
	}
	return 0x820C30B8;
} // Block from 820C3098h-820C30B8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C30B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C30B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C30B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C30B8);
		  /* 820C30B8h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 820C30B8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820C30B8h case    0:*/		return 0x820C30BC;
		  /* 820C30BCh */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820C30BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820C30C8;  }
		/* 820C30BCh case    1:*/		return 0x820C30C0;
		  /* 820C30C0h */ case    2:  		/* rlwinm. R11, R27, 0, 27, 28 */
		/* 820C30C0h case    2:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R27);
		/* 820C30C0h case    2:*/		return 0x820C30C4;
		  /* 820C30C4h */ case    3:  		/* bc 4, CR0_EQ, -24 */
		/* 820C30C4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820C30AC;  }
		/* 820C30C4h case    3:*/		return 0x820C30C8;
	}
	return 0x820C30C8;
} // Block from 820C30B8h-820C30C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C30C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C30C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C30C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C30C8);
		  /* 820C30C8h */ case    0:  		/* lwz R11, <#[R31 + 756]> */
		/* 820C30C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000002F4) );
		/* 820C30C8h case    0:*/		return 0x820C30CC;
		  /* 820C30CCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C30CCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C30CCh case    1:*/		return 0x820C30D0;
		  /* 820C30D0h */ case    2:  		/* bc 12, CR6_EQ, -36 */
		/* 820C30D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C30AC;  }
		/* 820C30D0h case    2:*/		return 0x820C30D4;
		  /* 820C30D4h */ case    3:  		/* lwz R3, <#[R30 + 8]> */
		/* 820C30D4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820C30D4h case    3:*/		return 0x820C30D8;
		  /* 820C30D8h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820C30D8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C30D8h case    4:*/		return 0x820C30DC;
		  /* 820C30DCh */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820C30DCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820C30F4;  }
		/* 820C30DCh case    5:*/		return 0x820C30E0;
		  /* 820C30E0h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820C30E0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C30E0h case    6:*/		return 0x820C30E4;
		  /* 820C30E4h */ case    7:  		/* li R4, 1 */
		/* 820C30E4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820C30E4h case    7:*/		return 0x820C30E8;
		  /* 820C30E8h */ case    8:  		/* lwz R11, <#[R11]> */
		/* 820C30E8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C30E8h case    8:*/		return 0x820C30EC;
		  /* 820C30ECh */ case    9:  		/* mtspr CTR, R11 */
		/* 820C30ECh case    9:*/		regs.CTR = regs.R11;
		/* 820C30ECh case    9:*/		return 0x820C30F0;
		  /* 820C30F0h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820C30F0h case   10:*/		if ( 1 ) { regs.LR = 0x820C30F4; return (uint32)regs.CTR; }
		/* 820C30F0h case   10:*/		return 0x820C30F4;
	}
	return 0x820C30F4;
} // Block from 820C30C8h-820C30F4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C30F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C30F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C30F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C30F4);
		  /* 820C30F4h */ case    0:  		/* lis R4, 9345 */
		/* 820C30F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C30F4h case    0:*/		return 0x820C30F8;
		  /* 820C30F8h */ case    1:  		/* lwz R3, <#[R30 + 24]> */
		/* 820C30F8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820C30F8h case    1:*/		return 0x820C30FC;
		  /* 820C30FCh */ case    2:  		/* bl -241092 */
		/* 820C30FCh case    2:*/		regs.LR = 0x820C3100; return 0x82088338;
		/* 820C30FCh case    2:*/		return 0x820C3100;
		  /* 820C3100h */ case    3:  		/* lwz R3, <#[R31 + 740]> */
		/* 820C3100h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000002E4) );
		/* 820C3100h case    3:*/		return 0x820C3104;
		  /* 820C3104h */ case    4:  		/* addi R23, R30, 4 */
		/* 820C3104h case    4:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R30,0x4);
		/* 820C3104h case    4:*/		return 0x820C3108;
		  /* 820C3108h */ case    5:  		/* stw R28, <#[R30]> */
		/* 820C3108h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 820C3108h case    5:*/		return 0x820C310C;
		  /* 820C310Ch */ case    6:  		/* stw R24, <#[R30 + 136]> */
		/* 820C310Ch case    6:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R30 + 0x00000088) );
		/* 820C310Ch case    6:*/		return 0x820C3110;
		  /* 820C3110h */ case    7:  		/* mr R18, R26 */
		/* 820C3110h case    7:*/		regs.R18 = regs.R26;
		/* 820C3110h case    7:*/		return 0x820C3114;
		  /* 820C3114h */ case    8:  		/* stw R26, <#[R30 + 4]> */
		/* 820C3114h case    8:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000004) );
		/* 820C3114h case    8:*/		return 0x820C3118;
		  /* 820C3118h */ case    9:  		/* cmplwi CR6, R16, 0 */
		/* 820C3118h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 820C3118h case    9:*/		return 0x820C311C;
		  /* 820C311Ch */ case   10:  		/* stw R26, <#[R30 + 8]> */
		/* 820C311Ch case   10:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000008) );
		/* 820C311Ch case   10:*/		return 0x820C3120;
		  /* 820C3120h */ case   11:  		/* stw R26, <#[R30 + 24]> */
		/* 820C3120h case   11:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000018) );
		/* 820C3120h case   11:*/		return 0x820C3124;
		  /* 820C3124h */ case   12:  		/* stw R26, <#[R30 + 28]> */
		/* 820C3124h case   12:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x0000001C) );
		/* 820C3124h case   12:*/		return 0x820C3128;
		  /* 820C3128h */ case   13:  		/* stw R26, <#[R30 + 76]> */
		/* 820C3128h case   13:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x0000004C) );
		/* 820C3128h case   13:*/		return 0x820C312C;
		  /* 820C312Ch */ case   14:  		/* stw R26, <#[R30 + 80]> */
		/* 820C312Ch case   14:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000050) );
		/* 820C312Ch case   14:*/		return 0x820C3130;
		  /* 820C3130h */ case   15:  		/* stw R26, <#[R30 + 84]> */
		/* 820C3130h case   15:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000054) );
		/* 820C3130h case   15:*/		return 0x820C3134;
		  /* 820C3134h */ case   16:  		/* stw R26, <#[R30 + 88]> */
		/* 820C3134h case   16:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000058) );
		/* 820C3134h case   16:*/		return 0x820C3138;
		  /* 820C3138h */ case   17:  		/* stw R26, <#[R30 + 92]> */
		/* 820C3138h case   17:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x0000005C) );
		/* 820C3138h case   17:*/		return 0x820C313C;
		  /* 820C313Ch */ case   18:  		/* stw R26, <#[R30 + 96]> */
		/* 820C313Ch case   18:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000060) );
		/* 820C313Ch case   18:*/		return 0x820C3140;
		  /* 820C3140h */ case   19:  		/* stw R26, <#[R30 + 100]> */
		/* 820C3140h case   19:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000064) );
		/* 820C3140h case   19:*/		return 0x820C3144;
		  /* 820C3144h */ case   20:  		/* stw R3, <#[R30 + 12]> */
		/* 820C3144h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 820C3144h case   20:*/		return 0x820C3148;
		  /* 820C3148h */ case   21:  		/* stw R27, <#[R30 + 20]> */
		/* 820C3148h case   21:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000014) );
		/* 820C3148h case   21:*/		return 0x820C314C;
		  /* 820C314Ch */ case   22:  		/* stw R26, <#[R30 + 56]> */
		/* 820C314Ch case   22:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000038) );
		/* 820C314Ch case   22:*/		return 0x820C3150;
		  /* 820C3150h */ case   23:  		/* stw R26, <#[R30 + 60]> */
		/* 820C3150h case   23:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x0000003C) );
		/* 820C3150h case   23:*/		return 0x820C3154;
		  /* 820C3154h */ case   24:  		/* stw R26, <#[R30 + 64]> */
		/* 820C3154h case   24:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000040) );
		/* 820C3154h case   24:*/		return 0x820C3158;
		  /* 820C3158h */ case   25:  		/* stw R26, <#[R30 + 68]> */
		/* 820C3158h case   25:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000044) );
		/* 820C3158h case   25:*/		return 0x820C315C;
		  /* 820C315Ch */ case   26:  		/* stw R26, <#[R30 + 108]> */
		/* 820C315Ch case   26:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x0000006C) );
		/* 820C315Ch case   26:*/		return 0x820C3160;
		  /* 820C3160h */ case   27:  		/* stw R26, <#[R30 + 112]> */
		/* 820C3160h case   27:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000070) );
		/* 820C3160h case   27:*/		return 0x820C3164;
		  /* 820C3164h */ case   28:  		/* stw R29, <#[R30 + 72]> */
		/* 820C3164h case   28:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000048) );
		/* 820C3164h case   28:*/		return 0x820C3168;
		  /* 820C3168h */ case   29:  		/* stw R26, <#[R30 + 116]> */
		/* 820C3168h case   29:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000074) );
		/* 820C3168h case   29:*/		return 0x820C316C;
		  /* 820C316Ch */ case   30:  		/* stw R26, <#[R30 + 120]> */
		/* 820C316Ch case   30:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000078) );
		/* 820C316Ch case   30:*/		return 0x820C3170;
		  /* 820C3170h */ case   31:  		/* stw R26, <#[R30 + 124]> */
		/* 820C3170h case   31:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x0000007C) );
		/* 820C3170h case   31:*/		return 0x820C3174;
		  /* 820C3174h */ case   32:  		/* stw R26, <#[R30 + 128]> */
		/* 820C3174h case   32:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000080) );
		/* 820C3174h case   32:*/		return 0x820C3178;
		  /* 820C3178h */ case   33:  		/* stw R26, <#[R30 + 132]> */
		/* 820C3178h case   33:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000084) );
		/* 820C3178h case   33:*/		return 0x820C317C;
		  /* 820C317Ch */ case   34:  		/* bc 12, CR6_EQ, 72 */
		/* 820C317Ch case   34:*/		if ( regs.CR[6].eq ) { return 0x820C31C4;  }
		/* 820C317Ch case   34:*/		return 0x820C3180;
		  /* 820C3180h */ case   35:  		/* lis R11, 18008 */
		/* 820C3180h case   35:*/		cpu::op::lis<0>(regs,&regs.R11,0x4658);
		/* 820C3180h case   35:*/		return 0x820C3184;
		  /* 820C3184h */ case   36:  		/* lis R4, 9345 */
		/* 820C3184h case   36:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C3184h case   36:*/		return 0x820C3188;
		  /* 820C3188h */ case   37:  		/* ori R11, R11, 512 */
		/* 820C3188h case   37:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x200);
		/* 820C3188h case   37:*/		return 0x820C318C;
		  /* 820C318Ch */ case   38:  		/* li R3, 512 */
		/* 820C318Ch case   38:*/		cpu::op::li<0>(regs,&regs.R3,0x200);
		/* 820C318Ch case   38:*/		return 0x820C3190;
		  /* 820C3190h */ case   39:  		/* stw R11, <#[R30 + 16]> */
		/* 820C3190h case   39:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C3190h case   39:*/		return 0x820C3194;
		  /* 820C3194h */ case   40:  		/* bl -241556 */
		/* 820C3194h case   40:*/		regs.LR = 0x820C3198; return 0x82088200;
		/* 820C3194h case   40:*/		return 0x820C3198;
		  /* 820C3198h */ case   41:  		/* cmplwi CR0, R3, 0 */
		/* 820C3198h case   41:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C3198h case   41:*/		return 0x820C319C;
		  /* 820C319Ch */ case   42:  		/* bc 12, CR0_EQ, 16 */
		/* 820C319Ch case   42:*/		if ( regs.CR[0].eq ) { return 0x820C31AC;  }
		/* 820C319Ch case   42:*/		return 0x820C31A0;
		  /* 820C31A0h */ case   43:  		/* lwz R4, <#[R30 + 140]> */
		/* 820C31A0h case   43:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000008C) );
		/* 820C31A0h case   43:*/		return 0x820C31A4;
		  /* 820C31A4h */ case   44:  		/* bl 522172 */
		/* 820C31A4h case   44:*/		regs.LR = 0x820C31A8; return 0x82142960;
		/* 820C31A4h case   44:*/		return 0x820C31A8;
		  /* 820C31A8h */ case   45:  		/* b 8 */
		/* 820C31A8h case   45:*/		return 0x820C31B0;
		/* 820C31A8h case   45:*/		return 0x820C31AC;
	}
	return 0x820C31AC;
} // Block from 820C30F4h-820C31ACh (46 instructions)

//////////////////////////////////////////////////////
// Block at 820C31ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C31AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C31AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C31AC);
		  /* 820C31ACh */ case    0:  		/* mr R3, R26 */
		/* 820C31ACh case    0:*/		regs.R3 = regs.R26;
		/* 820C31ACh case    0:*/		return 0x820C31B0;
	}
	return 0x820C31B0;
} // Block from 820C31ACh-820C31B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C31B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C31B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C31B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C31B0);
		  /* 820C31B0h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820C31B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C31B0h case    0:*/		return 0x820C31B4;
		  /* 820C31B4h */ case    1:  		/* li R18, 1 */
		/* 820C31B4h case    1:*/		cpu::op::li<0>(regs,&regs.R18,0x1);
		/* 820C31B4h case    1:*/		return 0x820C31B8;
		  /* 820C31B8h */ case    2:  		/* ori R11, R11, 256 */
		/* 820C31B8h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 820C31B8h case    2:*/		return 0x820C31BC;
		  /* 820C31BCh */ case    3:  		/* stw R11, <#[R30 + 20]> */
		/* 820C31BCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C31BCh case    3:*/		return 0x820C31C0;
		  /* 820C31C0h */ case    4:  		/* b 888 */
		/* 820C31C0h case    4:*/		return 0x820C3538;
		/* 820C31C0h case    4:*/		return 0x820C31C4;
	}
	return 0x820C31C4;
} // Block from 820C31B0h-820C31C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C31C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C31C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C31C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C31C4);
		  /* 820C31C4h */ case    0:  		/* rlwinm. R11, R27, 0, 24, 25 */
		/* 820C31C4h case    0:*/		cpu::op::rlwinm<1,0,24,25>(regs,&regs.R11,regs.R27);
		/* 820C31C4h case    0:*/		return 0x820C31C8;
		  /* 820C31C8h */ case    1:  		/* bc 12, CR0_EQ, 184 */
		/* 820C31C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C3280;  }
		/* 820C31C8h case    1:*/		return 0x820C31CC;
		  /* 820C31CCh */ case    2:  		/* addi R5, R31, 232 */
		/* 820C31CCh case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0xE8);
		/* 820C31CCh case    2:*/		return 0x820C31D0;
		  /* 820C31D0h */ case    3:  		/* li R4, 2 */
		/* 820C31D0h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 820C31D0h case    3:*/		return 0x820C31D4;
		  /* 820C31D4h */ case    4:  		/* bl -148548 */
		/* 820C31D4h case    4:*/		regs.LR = 0x820C31D8; return 0x8209ED90;
		/* 820C31D4h case    4:*/		return 0x820C31D8;
		  /* 820C31D8h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820C31D8h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C31D8h case    5:*/		return 0x820C31DC;
		  /* 820C31DCh */ case    6:  		/* bc 4, CR0_LT, 36 */
		/* 820C31DCh case    6:*/		if ( !regs.CR[0].lt ) { return 0x820C3200;  }
		/* 820C31DCh case    6:*/		return 0x820C31E0;
		  /* 820C31E0h */ case    7:  		/* lis R11, -32255 */
		/* 820C31E0h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C31E0h case    7:*/		return 0x820C31E4;
		  /* 820C31E4h */ case    8:  		/* lwz R7, <#[R30 + 12]> */
		/* 820C31E4h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x0000000C) );
		/* 820C31E4h case    8:*/		return 0x820C31E8;
		  /* 820C31E8h */ case    9:  		/* li R5, 3506 */
		/* 820C31E8h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0xDB2);
		/* 820C31E8h case    9:*/		return 0x820C31EC;
		  /* 820C31ECh */ case   10:  		/* addi R6, R11, 10308 */
		/* 820C31ECh case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2844);
		/* 820C31ECh case   10:*/		return 0x820C31F0;
		  /* 820C31F0h */ case   11:  		/* li R4, 0 */
		/* 820C31F0h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C31F0h case   11:*/		return 0x820C31F4;
		  /* 820C31F4h */ case   12:  		/* mr R3, R30 */
		/* 820C31F4h case   12:*/		regs.R3 = regs.R30;
		/* 820C31F4h case   12:*/		return 0x820C31F8;
		  /* 820C31F8h */ case   13:  		/* bl -75784 */
		/* 820C31F8h case   13:*/		regs.LR = 0x820C31FC; return 0x820B09F0;
		/* 820C31F8h case   13:*/		return 0x820C31FC;
		  /* 820C31FCh */ case   14:  		/* b -336 */
		/* 820C31FCh case   14:*/		return 0x820C30AC;
		/* 820C31FCh case   14:*/		return 0x820C3200;
	}
	return 0x820C3200;
} // Block from 820C31C4h-820C3200h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C3200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3200);
		  /* 820C3200h */ case    0:  		/* lwz R10, <#[R31 + 236]> */
		/* 820C3200h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000000EC) );
		/* 820C3200h case    0:*/		return 0x820C3204;
		  /* 820C3204h */ case    1:  		/* lis R9, -2 */
		/* 820C3204h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFFFE);
		/* 820C3204h case    1:*/		return 0x820C3208;
		  /* 820C3208h */ case    2:  		/* rlwinm R11, R10, 0, 0, 15 */
		/* 820C3208h case    2:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R10);
		/* 820C3208h case    2:*/		return 0x820C320C;
		  /* 820C320Ch */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 820C320Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820C320Ch case    3:*/		return 0x820C3210;
		  /* 820C3210h */ case    4:  		/* bc 12, CR6_EQ, 64 */
		/* 820C3210h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C3250;  }
		/* 820C3210h case    4:*/		return 0x820C3214;
		  /* 820C3214h */ case    5:  		/* lis R9, -1 */
		/* 820C3214h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 820C3214h case    5:*/		return 0x820C3218;
		  /* 820C3218h */ case    6:  		/* cmplw CR6, R11, R9 */
		/* 820C3218h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820C3218h case    6:*/		return 0x820C321C;
		  /* 820C321Ch */ case    7:  		/* bc 4, CR6_EQ, 100 */
		/* 820C321Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x820C3280;  }
		/* 820C321Ch case    7:*/		return 0x820C3220;
		  /* 820C3220h */ case    8:  		/* rlwinm. R11, R27, 0, 24, 24 */
		/* 820C3220h case    8:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R27);
		/* 820C3220h case    8:*/		return 0x820C3224;
		  /* 820C3224h */ case    9:  		/* bc 12, CR0_EQ, 92 */
		/* 820C3224h case    9:*/		if ( regs.CR[0].eq ) { return 0x820C3280;  }
		/* 820C3224h case    9:*/		return 0x820C3228;
		  /* 820C3228h */ case   10:  		/* rlwinm R11, R10, 0, 16, 23 */
		/* 820C3228h case   10:*/		cpu::op::rlwinm<0,0,16,23>(regs,&regs.R11,regs.R10);
		/* 820C3228h case   10:*/		return 0x820C322C;
		  /* 820C322Ch */ case   11:  		/* ori R27, R27, 5 */
		/* 820C322Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x5);
		/* 820C322Ch case   11:*/		return 0x820C3230;
		  /* 820C3230h */ case   12:  		/* cmplwi CR6, R11, 768 */
		/* 820C3230h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000300);
		/* 820C3230h case   12:*/		return 0x820C3234;
		  /* 820C3234h */ case   13:  		/* bc 4, CR6_EQ, 16 */
		/* 820C3234h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820C3244;  }
		/* 820C3234h case   13:*/		return 0x820C3238;
		  /* 820C3238h */ case   14:  		/* lis R11, -32255 */
		/* 820C3238h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C3238h case   14:*/		return 0x820C323C;
		  /* 820C323Ch */ case   15:  		/* addi R11, R11, -15576 */
		/* 820C323Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC328);
		/* 820C323Ch case   15:*/		return 0x820C3240;
		  /* 820C3240h */ case   16:  		/* b 60 */
		/* 820C3240h case   16:*/		return 0x820C327C;
		/* 820C3240h case   16:*/		return 0x820C3244;
	}
	return 0x820C3244;
} // Block from 820C3200h-820C3244h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C3244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3244);
		  /* 820C3244h */ case    0:  		/* lis R11, -32255 */
		/* 820C3244h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C3244h case    0:*/		return 0x820C3248;
		  /* 820C3248h */ case    1:  		/* addi R11, R11, -15552 */
		/* 820C3248h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC340);
		/* 820C3248h case    1:*/		return 0x820C324C;
		  /* 820C324Ch */ case    2:  		/* b 48 */
		/* 820C324Ch case    2:*/		return 0x820C327C;
		/* 820C324Ch case    2:*/		return 0x820C3250;
	}
	return 0x820C3250;
} // Block from 820C3244h-820C3250h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C3250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3250);
		  /* 820C3250h */ case    0:  		/* rlwinm. R11, R27, 0, 25, 25 */
		/* 820C3250h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R11,regs.R27);
		/* 820C3250h case    0:*/		return 0x820C3254;
		  /* 820C3254h */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 820C3254h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C3280;  }
		/* 820C3254h case    1:*/		return 0x820C3258;
		  /* 820C3258h */ case    2:  		/* rlwinm R11, R10, 0, 16, 23 */
		/* 820C3258h case    2:*/		cpu::op::rlwinm<0,0,16,23>(regs,&regs.R11,regs.R10);
		/* 820C3258h case    2:*/		return 0x820C325C;
		  /* 820C325Ch */ case    3:  		/* ori R27, R27, 5 */
		/* 820C325Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R27,regs.R27,0x5);
		/* 820C325Ch case    3:*/		return 0x820C3260;
		  /* 820C3260h */ case    4:  		/* cmplwi CR6, R11, 768 */
		/* 820C3260h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000300);
		/* 820C3260h case    4:*/		return 0x820C3264;
		  /* 820C3264h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 820C3264h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C3274;  }
		/* 820C3264h case    5:*/		return 0x820C3268;
		  /* 820C3268h */ case    6:  		/* lis R11, -32255 */
		/* 820C3268h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C3268h case    6:*/		return 0x820C326C;
		  /* 820C326Ch */ case    7:  		/* addi R11, R11, -15736 */
		/* 820C326Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC288);
		/* 820C326Ch case    7:*/		return 0x820C3270;
		  /* 820C3270h */ case    8:  		/* b 12 */
		/* 820C3270h case    8:*/		return 0x820C327C;
		/* 820C3270h case    8:*/		return 0x820C3274;
	}
	return 0x820C3274;
} // Block from 820C3250h-820C3274h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C3274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3274);
		  /* 820C3274h */ case    0:  		/* lis R11, -32255 */
		/* 820C3274h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C3274h case    0:*/		return 0x820C3278;
		  /* 820C3278h */ case    1:  		/* addi R11, R11, -15712 */
		/* 820C3278h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC2A0);
		/* 820C3278h case    1:*/		return 0x820C327C;
	}
	return 0x820C327C;
} // Block from 820C3274h-820C327Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C327Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C327C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C327C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C327C);
		  /* 820C327Ch */ case    0:  		/* stw R11, <#[R30 + 12]> */
		/* 820C327Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 820C327Ch case    0:*/		return 0x820C3280;
	}
	return 0x820C3280;
} // Block from 820C327Ch-820C3280h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C3280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3280);
		  /* 820C3280h */ case    0:  		/* addi R5, R31, 232 */
		/* 820C3280h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0xE8);
		/* 820C3280h case    0:*/		return 0x820C3284;
		  /* 820C3284h */ case    1:  		/* lwz R3, <#[R30 + 12]> */
		/* 820C3284h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 820C3284h case    1:*/		return 0x820C3288;
		  /* 820C3288h */ case    2:  		/* li R4, 2 */
		/* 820C3288h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 820C3288h case    2:*/		return 0x820C328C;
		  /* 820C328Ch */ case    3:  		/* bl -148732 */
		/* 820C328Ch case    3:*/		regs.LR = 0x820C3290; return 0x8209ED90;
		/* 820C328Ch case    3:*/		return 0x820C3290;
		  /* 820C3290h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820C3290h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C3290h case    4:*/		return 0x820C3294;
		  /* 820C3294h */ case    5:  		/* bc 12, CR0_LT, -180 */
		/* 820C3294h case    5:*/		if ( regs.CR[0].lt ) { return 0x820C31E0;  }
		/* 820C3294h case    5:*/		return 0x820C3298;
		  /* 820C3298h */ case    6:  		/* lwz R9, <#[R31 + 236]> */
		/* 820C3298h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000000EC) );
		/* 820C3298h case    6:*/		return 0x820C329C;
		  /* 820C329Ch */ case    7:  		/* lis R11, -2 */
		/* 820C329Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFFFFE);
		/* 820C329Ch case    7:*/		return 0x820C32A0;
		  /* 820C32A0h */ case    8:  		/* stw R27, <#[R30 + 20]> */
		/* 820C32A0h case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000014) );
		/* 820C32A0h case    8:*/		return 0x820C32A4;
		  /* 820C32A4h */ case    9:  		/* ori R11, R11, 256 */
		/* 820C32A4h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 820C32A4h case    9:*/		return 0x820C32A8;
		  /* 820C32A8h */ case   10:  		/* cmplw CR6, R9, R11 */
		/* 820C32A8h case   10:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820C32A8h case   10:*/		return 0x820C32AC;
		  /* 820C32ACh */ case   11:  		/* stw R9, <#[R30 + 16]> */
		/* 820C32ACh case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00000010) );
		/* 820C32ACh case   11:*/		return 0x820C32B0;
		  /* 820C32B0h */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 820C32B0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820C32C4;  }
		/* 820C32B0h case   12:*/		return 0x820C32B4;
		  /* 820C32B4h */ case   13:  		/* lis R11, -2 */
		/* 820C32B4h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFFFFE);
		/* 820C32B4h case   13:*/		return 0x820C32B8;
		  /* 820C32B8h */ case   14:  		/* li R22, 1 */
		/* 820C32B8h case   14:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 820C32B8h case   14:*/		return 0x820C32BC;
		  /* 820C32BCh */ case   15:  		/* ori R11, R11, 257 */
		/* 820C32BCh case   15:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x101);
		/* 820C32BCh case   15:*/		return 0x820C32C0;
		  /* 820C32C0h */ case   16:  		/* stw R11, <#[R30 + 16]> */
		/* 820C32C0h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C32C0h case   16:*/		return 0x820C32C4;
	}
	return 0x820C32C4;
} // Block from 820C3280h-820C32C4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C32C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C32C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C32C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C32C4);
		  /* 820C32C4h */ case    0:  		/* lis R11, -1 */
		/* 820C32C4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820C32C4h case    0:*/		return 0x820C32C8;
		  /* 820C32C8h */ case    1:  		/* lwz R10, <#[R30 + 16]> */
		/* 820C32C8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000010) );
		/* 820C32C8h case    1:*/		return 0x820C32CC;
		  /* 820C32CCh */ case    2:  		/* ori R11, R11, 256 */
		/* 820C32CCh case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 820C32CCh case    2:*/		return 0x820C32D0;
		  /* 820C32D0h */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 820C32D0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820C32D0h case    3:*/		return 0x820C32D4;
		  /* 820C32D4h */ case    4:  		/* bc 4, CR6_EQ, 20 */
		/* 820C32D4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C32E8;  }
		/* 820C32D4h case    4:*/		return 0x820C32D8;
		  /* 820C32D8h */ case    5:  		/* lis R11, -1 */
		/* 820C32D8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820C32D8h case    5:*/		return 0x820C32DC;
		  /* 820C32DCh */ case    6:  		/* li R21, 1 */
		/* 820C32DCh case    6:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 820C32DCh case    6:*/		return 0x820C32E0;
		  /* 820C32E0h */ case    7:  		/* ori R11, R11, 257 */
		/* 820C32E0h case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x101);
		/* 820C32E0h case    7:*/		return 0x820C32E4;
		  /* 820C32E4h */ case    8:  		/* stw R11, <#[R30 + 16]> */
		/* 820C32E4h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C32E4h case    8:*/		return 0x820C32E8;
	}
	return 0x820C32E8;
} // Block from 820C32C4h-820C32E8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C32E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C32E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C32E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C32E8);
		  /* 820C32E8h */ case    0:  		/* lis R10, -1 */
		/* 820C32E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C32E8h case    0:*/		return 0x820C32EC;
		  /* 820C32ECh */ case    1:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C32ECh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C32ECh case    1:*/		return 0x820C32F0;
		  /* 820C32F0h */ case    2:  		/* ori R10, R10, 612 */
		/* 820C32F0h case    2:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x264);
		/* 820C32F0h case    2:*/		return 0x820C32F4;
		  /* 820C32F4h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C32F4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C32F4h case    3:*/		return 0x820C32F8;
		  /* 820C32F8h */ case    4:  		/* bc 12, CR6_GT, 496 */
		/* 820C32F8h case    4:*/		if ( regs.CR[6].gt ) { return 0x820C34E8;  }
		/* 820C32F8h case    4:*/		return 0x820C32FC;
		  /* 820C32FCh */ case    5:  		/* bc 12, CR6_EQ, 456 */
		/* 820C32FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820C34C4;  }
		/* 820C32FCh case    5:*/		return 0x820C3300;
		  /* 820C3300h */ case    6:  		/* lis R10, -2 */
		/* 820C3300h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820C3300h case    6:*/		return 0x820C3304;
		  /* 820C3304h */ case    7:  		/* ori R10, R10, 768 */
		/* 820C3304h case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x300);
		/* 820C3304h case    7:*/		return 0x820C3308;
		  /* 820C3308h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 820C3308h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C3308h case    8:*/		return 0x820C330C;
		  /* 820C330Ch */ case    9:  		/* bc 12, CR6_GT, 140 */
		/* 820C330Ch case    9:*/		if ( regs.CR[6].gt ) { return 0x820C3398;  }
		/* 820C330Ch case    9:*/		return 0x820C3310;
		  /* 820C3310h */ case   10:  		/* bc 12, CR6_EQ, 512 */
		/* 820C3310h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C3510;  }
		/* 820C3310h case   10:*/		return 0x820C3314;
		  /* 820C3314h */ case   11:  		/* lis R10, 21592 */
		/* 820C3314h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0x5458);
		/* 820C3314h case   11:*/		return 0x820C3318;
		  /* 820C3318h */ case   12:  		/* ori R10, R10, 256 */
		/* 820C3318h case   12:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x100);
		/* 820C3318h case   12:*/		return 0x820C331C;
		  /* 820C331Ch */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820C331Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C331Ch case   13:*/		return 0x820C3320;
		  /* 820C3320h */ case   14:  		/* bc 12, CR6_EQ, 80 */
		/* 820C3320h case   14:*/		if ( regs.CR[6].eq ) { return 0x820C3370;  }
		/* 820C3320h case   14:*/		return 0x820C3324;
		  /* 820C3324h */ case   15:  		/* lis R10, -2 */
		/* 820C3324h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820C3324h case   15:*/		return 0x820C3328;
		  /* 820C3328h */ case   16:  		/* ori R10, R10, 257 */
		/* 820C3328h case   16:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x101);
		/* 820C3328h case   16:*/		return 0x820C332C;
		  /* 820C332Ch */ case   17:  		/* subf. R11, R10, R11 */
		/* 820C332Ch case   17:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C332Ch case   17:*/		return 0x820C3330;
		  /* 820C3330h */ case   18:  		/* bc 12, CR0_EQ, 28 */
		/* 820C3330h case   18:*/		if ( regs.CR[0].eq ) { return 0x820C334C;  }
		/* 820C3330h case   18:*/		return 0x820C3334;
		  /* 820C3334h */ case   19:  		/* cmplwi CR6, R11, 255 */
		/* 820C3334h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000FF);
		/* 820C3334h case   19:*/		return 0x820C3338;
		  /* 820C3338h */ case   20:  		/* bc 12, CR6_EQ, 20 */
		/* 820C3338h case   20:*/		if ( regs.CR[6].eq ) { return 0x820C334C;  }
		/* 820C3338h case   20:*/		return 0x820C333C;
		  /* 820C333Ch */ case   21:  		/* cmplwi CR6, R11, 257 */
		/* 820C333Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000101);
		/* 820C333Ch case   21:*/		return 0x820C3340;
		  /* 820C3340h */ case   22:  		/* bc 12, CR6_EQ, 12 */
		/* 820C3340h case   22:*/		if ( regs.CR[6].eq ) { return 0x820C334C;  }
		/* 820C3340h case   22:*/		return 0x820C3344;
		  /* 820C3344h */ case   23:  		/* cmplwi CR6, R11, 510 */
		/* 820C3344h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000001FE);
		/* 820C3344h case   23:*/		return 0x820C3348;
		  /* 820C3348h */ case   24:  		/* bc 4, CR6_EQ, 448 */
		/* 820C3348h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820C3508;  }
		/* 820C3348h case   24:*/		return 0x820C334C;
	}
	return 0x820C334C;
} // Block from 820C32E8h-820C334Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 820C334Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C334C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C334C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C334C);
		  /* 820C334Ch */ case    0:  		/* lis R4, 9345 */
		/* 820C334Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C334Ch case    0:*/		return 0x820C3350;
		  /* 820C3350h */ case    1:  		/* li R3, 508 */
		/* 820C3350h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1FC);
		/* 820C3350h case    1:*/		return 0x820C3354;
		  /* 820C3354h */ case    2:  		/* bl -242004 */
		/* 820C3354h case    2:*/		regs.LR = 0x820C3358; return 0x82088200;
		/* 820C3354h case    2:*/		return 0x820C3358;
		  /* 820C3358h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820C3358h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C3358h case    3:*/		return 0x820C335C;
		  /* 820C335Ch */ case    4:  		/* bc 12, CR0_EQ, 472 */
		/* 820C335Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x820C3534;  }
		/* 820C335Ch case    4:*/		return 0x820C3360;
		  /* 820C3360h */ case    5:  		/* mr R4, R24 */
		/* 820C3360h case    5:*/		regs.R4 = regs.R24;
		/* 820C3360h case    5:*/		return 0x820C3364;
		  /* 820C3364h */ case    6:  		/* lwz R5, <#[R30 + 140]> */
		/* 820C3364h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000008C) );
		/* 820C3364h case    6:*/		return 0x820C3368;
		  /* 820C3368h */ case    7:  		/* bl 507304 */
		/* 820C3368h case    7:*/		regs.LR = 0x820C336C; return 0x8213F110;
		/* 820C3368h case    7:*/		return 0x820C336C;
		  /* 820C336Ch */ case    8:  		/* b 460 */
		/* 820C336Ch case    8:*/		return 0x820C3538;
		/* 820C336Ch case    8:*/		return 0x820C3370;
	}
	return 0x820C3370;
} // Block from 820C334Ch-820C3370h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C3370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3370);
		  /* 820C3370h */ case    0:  		/* ori R11, R27, 256 */
		/* 820C3370h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R27,0x100);
		/* 820C3370h case    0:*/		return 0x820C3374;
		  /* 820C3374h */ case    1:  		/* lis R4, 9345 */
		/* 820C3374h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C3374h case    1:*/		return 0x820C3378;
		  /* 820C3378h */ case    2:  		/* stw R11, <#[R30 + 20]> */
		/* 820C3378h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C3378h case    2:*/		return 0x820C337C;
		  /* 820C337Ch */ case    3:  		/* li R3, 512 */
		/* 820C337Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x200);
		/* 820C337Ch case    3:*/		return 0x820C3380;
		  /* 820C3380h */ case    4:  		/* bl -242048 */
		/* 820C3380h case    4:*/		regs.LR = 0x820C3384; return 0x82088200;
		/* 820C3380h case    4:*/		return 0x820C3384;
		  /* 820C3384h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820C3384h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C3384h case    5:*/		return 0x820C3388;
		  /* 820C3388h */ case    6:  		/* bc 12, CR0_EQ, 428 */
		/* 820C3388h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C3534;  }
		/* 820C3388h case    6:*/		return 0x820C338C;
		  /* 820C338Ch */ case    7:  		/* lwz R4, <#[R30 + 140]> */
		/* 820C338Ch case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000008C) );
		/* 820C338Ch case    7:*/		return 0x820C3390;
		  /* 820C3390h */ case    8:  		/* bl 521680 */
		/* 820C3390h case    8:*/		regs.LR = 0x820C3394; return 0x82142960;
		/* 820C3390h case    8:*/		return 0x820C3394;
		  /* 820C3394h */ case    9:  		/* b 420 */
		/* 820C3394h case    9:*/		return 0x820C3538;
		/* 820C3394h case    9:*/		return 0x820C3398;
	}
	return 0x820C3398;
} // Block from 820C3370h-820C3398h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C3398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3398);
		  /* 820C3398h */ case    0:  		/* lis R10, -1 */
		/* 820C3398h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C3398h case    0:*/		return 0x820C339C;
		  /* 820C339Ch */ case    1:  		/* ori R10, R10, 260 */
		/* 820C339Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x104);
		/* 820C339Ch case    1:*/		return 0x820C33A0;
		  /* 820C33A0h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C33A0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C33A0h case    2:*/		return 0x820C33A4;
		  /* 820C33A4h */ case    3:  		/* lis R10, -1 */
		/* 820C33A4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C33A4h case    3:*/		return 0x820C33A8;
		  /* 820C33A8h */ case    4:  		/* bc 12, CR6_GT, 240 */
		/* 820C33A8h case    4:*/		if ( regs.CR[6].gt ) { return 0x820C3498;  }
		/* 820C33A8h case    4:*/		return 0x820C33AC;
		  /* 820C33ACh */ case    5:  		/* ori R10, R10, 257 */
		/* 820C33ACh case    5:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x101);
		/* 820C33ACh case    5:*/		return 0x820C33B0;
		  /* 820C33B0h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820C33B0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C33B0h case    6:*/		return 0x820C33B4;
		  /* 820C33B4h */ case    7:  		/* bc 4, CR6_LT, 188 */
		/* 820C33B4h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820C3470;  }
		/* 820C33B4h case    7:*/		return 0x820C33B8;
		  /* 820C33B8h */ case    8:  		/* lis R10, -2 */
		/* 820C33B8h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820C33B8h case    8:*/		return 0x820C33BC;
		  /* 820C33BCh */ case    9:  		/* ori R10, R10, 1021 */
		/* 820C33BCh case    9:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3FD);
		/* 820C33BCh case    9:*/		return 0x820C33C0;
		  /* 820C33C0h */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 820C33C0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C33C0h case   10:*/		return 0x820C33C4;
		  /* 820C33C4h */ case   11:  		/* bc 12, CR6_LT, 324 */
		/* 820C33C4h case   11:*/		if ( regs.CR[6].lt ) { return 0x820C3508;  }
		/* 820C33C4h case   11:*/		return 0x820C33C8;
		  /* 820C33C8h */ case   12:  		/* lis R8, -2 */
		/* 820C33C8h case   12:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFFFFE);
		/* 820C33C8h case   12:*/		return 0x820C33CC;
		  /* 820C33CCh */ case   13:  		/* ori R8, R8, 1022 */
		/* 820C33CCh case   13:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x3FE);
		/* 820C33CCh case   13:*/		return 0x820C33D0;
		  /* 820C33D0h */ case   14:  		/* cmplw CR6, R11, R8 */
		/* 820C33D0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 820C33D0h case   14:*/		return 0x820C33D4;
		  /* 820C33D4h */ case   15:  		/* bc 4, CR6_GT, 20 */
		/* 820C33D4h case   15:*/		if ( !regs.CR[6].gt ) { return 0x820C33E8;  }
		/* 820C33D4h case   15:*/		return 0x820C33D8;
		  /* 820C33D8h */ case   16:  		/* lis R10, -2 */
		/* 820C33D8h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820C33D8h case   16:*/		return 0x820C33DC;
		  /* 820C33DCh */ case   17:  		/* ori R10, R10, 1023 */
		/* 820C33DCh case   17:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3FF);
		/* 820C33DCh case   17:*/		return 0x820C33E0;
		  /* 820C33E0h */ case   18:  		/* cmplw CR6, R11, R10 */
		/* 820C33E0h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C33E0h case   18:*/		return 0x820C33E4;
		  /* 820C33E4h */ case   19:  		/* b 288 */
		/* 820C33E4h case   19:*/		return 0x820C3504;
		/* 820C33E4h case   19:*/		return 0x820C33E8;
	}
	return 0x820C33E8;
} // Block from 820C3398h-820C33E8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C33E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C33E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C33E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C33E8);
		  /* 820C33E8h */ case    0:  		/* rlwinm R11, R9, 0, 0, 15 */
		/* 820C33E8h case    0:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R9);
		/* 820C33E8h case    0:*/		return 0x820C33EC;
		  /* 820C33ECh */ case    1:  		/* subf R11, R11, R10 */
		/* 820C33ECh case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C33ECh case    1:*/		return 0x820C33F0;
		  /* 820C33F0h */ case    2:  		/* cntlzw R11, R11 */
		/* 820C33F0h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C33F0h case    2:*/		return 0x820C33F4;
		  /* 820C33F4h */ case    3:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 820C33F4h case    3:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820C33F4h case    3:*/		return 0x820C33F8;
		  /* 820C33F8h */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 820C33F8h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C3400;  }
		/* 820C33F8h case    4:*/		return 0x820C33FC;
		  /* 820C33FCh */ case    5:  		/* twi 31, R0, 22 */
		/* 820C33FCh case    5:*/		cpu::op::trap(regs, 0x820C33FC, regs.R0, 0x00000016);
		/* 820C33FCh case    5:*/		return 0x820C3400;
	}
	return 0x820C3400;
} // Block from 820C33E8h-820C3400h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C3400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3400);
		  /* 820C3400h */ case    0:  		/* lwz R29, <#[R19 + 24]> */
		/* 820C3400h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R19 + 0x00000018) );
		/* 820C3400h case    0:*/		return 0x820C3404;
		  /* 820C3404h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 820C3404h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820C3404h case    1:*/		return 0x820C3408;
		  /* 820C3408h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820C3408h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C3418;  }
		/* 820C3408h case    2:*/		return 0x820C340C;
		  /* 820C340Ch */ case    3:  		/* lbz R11, <#[R29]> */
		/* 820C340Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820C340Ch case    3:*/		return 0x820C3410;
		  /* 820C3410h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 820C3410h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C3410h case    4:*/		return 0x820C3414;
		  /* 820C3414h */ case    5:  		/* bc 4, CR0_EQ, 8 */
		/* 820C3414h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820C341C;  }
		/* 820C3414h case    5:*/		return 0x820C3418;
	}
	return 0x820C3418;
} // Block from 820C3400h-820C3418h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C3418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3418);
		  /* 820C3418h */ case    0:  		/* mr R29, R17 */
		/* 820C3418h case    0:*/		regs.R29 = regs.R17;
		/* 820C3418h case    0:*/		return 0x820C341C;
	}
	return 0x820C341C;
} // Block from 820C3418h-820C341Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C341Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C341C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C341C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C341C);
		  /* 820C341Ch */ case    0:  		/* lwz R11, <#[R19]> */
		/* 820C341Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 820C341Ch case    0:*/		return 0x820C3420;
		  /* 820C3420h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 820C3420h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 820C3420h case    1:*/		return 0x820C3424;
		  /* 820C3424h */ case    2:  		/* lis R4, 9345 */
		/* 820C3424h case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C3424h case    2:*/		return 0x820C3428;
		  /* 820C3428h */ case    3:  		/* li R3, 1824 */
		/* 820C3428h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x720);
		/* 820C3428h case    3:*/		return 0x820C342C;
		  /* 820C342Ch */ case    4:  		/* bc 4, CR0_EQ, 36 */
		/* 820C342Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x820C3450;  }
		/* 820C342Ch case    4:*/		return 0x820C3430;
		  /* 820C3430h */ case    5:  		/* bl -242224 */
		/* 820C3430h case    5:*/		regs.LR = 0x820C3434; return 0x82088200;
		/* 820C3430h case    5:*/		return 0x820C3434;
		  /* 820C3434h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820C3434h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C3434h case    6:*/		return 0x820C3438;
		  /* 820C3438h */ case    7:  		/* bc 12, CR0_EQ, 252 */
		/* 820C3438h case    7:*/		if ( regs.CR[0].eq ) { return 0x820C3534;  }
		/* 820C3438h case    7:*/		return 0x820C343C;
		  /* 820C343Ch */ case    8:  		/* mr R6, R29 */
		/* 820C343Ch case    8:*/		regs.R6 = regs.R29;
		/* 820C343Ch case    8:*/		return 0x820C3440;
		  /* 820C3440h */ case    9:  		/* lwz R5, <#[R30 + 140]> */
		/* 820C3440h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000008C) );
		/* 820C3440h case    9:*/		return 0x820C3444;
		  /* 820C3444h */ case   10:  		/* mr R4, R24 */
		/* 820C3444h case   10:*/		regs.R4 = regs.R24;
		/* 820C3444h case   10:*/		return 0x820C3448;
		  /* 820C3448h */ case   11:  		/* bl -85712 */
		/* 820C3448h case   11:*/		regs.LR = 0x820C344C; return 0x820AE578;
		/* 820C3448h case   11:*/		return 0x820C344C;
		  /* 820C344Ch */ case   12:  		/* b 236 */
		/* 820C344Ch case   12:*/		return 0x820C3538;
		/* 820C344Ch case   12:*/		return 0x820C3450;
	}
	return 0x820C3450;
} // Block from 820C341Ch-820C3450h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C3450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3450);
		  /* 820C3450h */ case    0:  		/* bl -242256 */
		/* 820C3450h case    0:*/		regs.LR = 0x820C3454; return 0x82088200;
		/* 820C3450h case    0:*/		return 0x820C3454;
		  /* 820C3454h */ case    1:  		/* cmplwi CR0, R3, 0 */
		/* 820C3454h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C3454h case    1:*/		return 0x820C3458;
		  /* 820C3458h */ case    2:  		/* bc 12, CR0_EQ, 220 */
		/* 820C3458h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C3534;  }
		/* 820C3458h case    2:*/		return 0x820C345C;
		  /* 820C345Ch */ case    3:  		/* mr R6, R29 */
		/* 820C345Ch case    3:*/		regs.R6 = regs.R29;
		/* 820C345Ch case    3:*/		return 0x820C3460;
		  /* 820C3460h */ case    4:  		/* lwz R5, <#[R30 + 140]> */
		/* 820C3460h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000008C) );
		/* 820C3460h case    4:*/		return 0x820C3464;
		  /* 820C3464h */ case    5:  		/* mr R4, R24 */
		/* 820C3464h case    5:*/		regs.R4 = regs.R24;
		/* 820C3464h case    5:*/		return 0x820C3468;
		  /* 820C3468h */ case    6:  		/* bl -85680 */
		/* 820C3468h case    6:*/		regs.LR = 0x820C346C; return 0x820AE5B8;
		/* 820C3468h case    6:*/		return 0x820C346C;
		  /* 820C346Ch */ case    7:  		/* b 204 */
		/* 820C346Ch case    7:*/		return 0x820C3538;
		/* 820C346Ch case    7:*/		return 0x820C3470;
	}
	return 0x820C3470;
} // Block from 820C3450h-820C3470h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C3470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3470);
		  /* 820C3470h */ case    0:  		/* rlwinm R11, R27, 0, 30, 28 */
		/* 820C3470h case    0:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R11,regs.R27);
		/* 820C3470h case    0:*/		return 0x820C3474;
		  /* 820C3474h */ case    1:  		/* lis R4, 9345 */
		/* 820C3474h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C3474h case    1:*/		return 0x820C3478;
		  /* 820C3478h */ case    2:  		/* stw R11, <#[R30 + 20]> */
		/* 820C3478h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C3478h case    2:*/		return 0x820C347C;
		  /* 820C347Ch */ case    3:  		/* li R3, 1160 */
		/* 820C347Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x488);
		/* 820C347Ch case    3:*/		return 0x820C3480;
		  /* 820C3480h */ case    4:  		/* bl -242304 */
		/* 820C3480h case    4:*/		regs.LR = 0x820C3484; return 0x82088200;
		/* 820C3480h case    4:*/		return 0x820C3484;
		  /* 820C3484h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820C3484h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C3484h case    5:*/		return 0x820C3488;
		  /* 820C3488h */ case    6:  		/* bc 12, CR0_EQ, 172 */
		/* 820C3488h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C3534;  }
		/* 820C3488h case    6:*/		return 0x820C348C;
		  /* 820C348Ch */ case    7:  		/* lwz R4, <#[R30 + 140]> */
		/* 820C348Ch case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000008C) );
		/* 820C348Ch case    7:*/		return 0x820C3490;
		  /* 820C3490h */ case    8:  		/* bl 443176 */
		/* 820C3490h case    8:*/		regs.LR = 0x820C3494; return 0x8212F7B8;
		/* 820C3490h case    8:*/		return 0x820C3494;
		  /* 820C3494h */ case    9:  		/* b 164 */
		/* 820C3494h case    9:*/		return 0x820C3538;
		/* 820C3494h case    9:*/		return 0x820C3498;
	}
	return 0x820C3498;
} // Block from 820C3470h-820C3498h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C3498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3498);
		  /* 820C3498h */ case    0:  		/* ori R10, R10, 512 */
		/* 820C3498h case    0:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x200);
		/* 820C3498h case    0:*/		return 0x820C349C;
		  /* 820C349Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820C349Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C349Ch case    1:*/		return 0x820C34A0;
		  /* 820C34A0h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820C34A0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C34C4;  }
		/* 820C34A0h case    2:*/		return 0x820C34A4;
		  /* 820C34A4h */ case    3:  		/* lis R10, -1 */
		/* 820C34A4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C34A4h case    3:*/		return 0x820C34A8;
		  /* 820C34A8h */ case    4:  		/* ori R10, R10, 513 */
		/* 820C34A8h case    4:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x201);
		/* 820C34A8h case    4:*/		return 0x820C34AC;
		  /* 820C34ACh */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820C34ACh case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C34ACh case    5:*/		return 0x820C34B0;
		  /* 820C34B0h */ case    6:  		/* bc 4, CR6_GT, 88 */
		/* 820C34B0h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820C3508;  }
		/* 820C34B0h case    6:*/		return 0x820C34B4;
		  /* 820C34B4h */ case    7:  		/* lis R10, -1 */
		/* 820C34B4h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C34B4h case    7:*/		return 0x820C34B8;
		  /* 820C34B8h */ case    8:  		/* ori R10, R10, 515 */
		/* 820C34B8h case    8:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x203);
		/* 820C34B8h case    8:*/		return 0x820C34BC;
		  /* 820C34BCh */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820C34BCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C34BCh case    9:*/		return 0x820C34C0;
		  /* 820C34C0h */ case   10:  		/* bc 12, CR6_GT, 72 */
		/* 820C34C0h case   10:*/		if ( regs.CR[6].gt ) { return 0x820C3508;  }
		/* 820C34C0h case   10:*/		return 0x820C34C4;
	}
	return 0x820C34C4;
} // Block from 820C3498h-820C34C4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C34C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C34C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C34C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C34C4);
		  /* 820C34C4h */ case    0:  		/* lis R4, 9345 */
		/* 820C34C4h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C34C4h case    0:*/		return 0x820C34C8;
		  /* 820C34C8h */ case    1:  		/* li R3, 560 */
		/* 820C34C8h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x230);
		/* 820C34C8h case    1:*/		return 0x820C34CC;
		  /* 820C34CCh */ case    2:  		/* bl -242380 */
		/* 820C34CCh case    2:*/		regs.LR = 0x820C34D0; return 0x82088200;
		/* 820C34CCh case    2:*/		return 0x820C34D0;
		  /* 820C34D0h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820C34D0h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C34D0h case    3:*/		return 0x820C34D4;
		  /* 820C34D4h */ case    4:  		/* bc 12, CR0_EQ, 96 */
		/* 820C34D4h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C3534;  }
		/* 820C34D4h case    4:*/		return 0x820C34D8;
		  /* 820C34D8h */ case    5:  		/* mr R4, R24 */
		/* 820C34D8h case    5:*/		regs.R4 = regs.R24;
		/* 820C34D8h case    5:*/		return 0x820C34DC;
		  /* 820C34DCh */ case    6:  		/* lwz R5, <#[R30 + 140]> */
		/* 820C34DCh case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000008C) );
		/* 820C34DCh case    6:*/		return 0x820C34E0;
		  /* 820C34E0h */ case    7:  		/* bl 426784 */
		/* 820C34E0h case    7:*/		regs.LR = 0x820C34E4; return 0x8212B800;
		/* 820C34E0h case    7:*/		return 0x820C34E4;
		  /* 820C34E4h */ case    8:  		/* b 84 */
		/* 820C34E4h case    8:*/		return 0x820C3538;
		/* 820C34E4h case    8:*/		return 0x820C34E8;
	}
	return 0x820C34E8;
} // Block from 820C34C4h-820C34E8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C34E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C34E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C34E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C34E8);
		  /* 820C34E8h */ case    0:  		/* lis R10, -1 */
		/* 820C34E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C34E8h case    0:*/		return 0x820C34EC;
		  /* 820C34ECh */ case    1:  		/* ori R10, R10, 767 */
		/* 820C34ECh case    1:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2FF);
		/* 820C34ECh case    1:*/		return 0x820C34F0;
		  /* 820C34F0h */ case    2:  		/* subf. R11, R10, R11 */
		/* 820C34F0h case    2:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C34F0h case    2:*/		return 0x820C34F4;
		  /* 820C34F4h */ case    3:  		/* bc 12, CR0_EQ, -48 */
		/* 820C34F4h case    3:*/		if ( regs.CR[0].eq ) { return 0x820C34C4;  }
		/* 820C34F4h case    3:*/		return 0x820C34F8;
		  /* 820C34F8h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 820C34F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C34F8h case    4:*/		return 0x820C34FC;
		  /* 820C34FCh */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 820C34FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x820C3510;  }
		/* 820C34FCh case    5:*/		return 0x820C3500;
		  /* 820C3500h */ case    6:  		/* cmplwi CR6, R11, 256 */
		/* 820C3500h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000100);
		/* 820C3500h case    6:*/		return 0x820C3504;
	}
	return 0x820C3504;
} // Block from 820C34E8h-820C3504h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C3504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3504);
		  /* 820C3504h */ case    0:  		/* bc 12, CR6_EQ, 12 */
		/* 820C3504h case    0:*/		if ( regs.CR[6].eq ) { return 0x820C3510;  }
		/* 820C3504h case    0:*/		return 0x820C3508;
	}
	return 0x820C3508;
} // Block from 820C3504h-820C3508h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C3508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3508);
		  /* 820C3508h */ case    0:  		/* stw R26, <#[R30 + 8]> */
		/* 820C3508h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000008) );
		/* 820C3508h case    0:*/		return 0x820C350C;
		  /* 820C350Ch */ case    1:  		/* b 48 */
		/* 820C350Ch case    1:*/		return 0x820C353C;
		/* 820C350Ch case    1:*/		return 0x820C3510;
	}
	return 0x820C3510;
} // Block from 820C3508h-820C3510h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C3510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3510);
		  /* 820C3510h */ case    0:  		/* lis R4, 9345 */
		/* 820C3510h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C3510h case    0:*/		return 0x820C3514;
		  /* 820C3514h */ case    1:  		/* li R3, 508 */
		/* 820C3514h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1FC);
		/* 820C3514h case    1:*/		return 0x820C3518;
		  /* 820C3518h */ case    2:  		/* bl -242456 */
		/* 820C3518h case    2:*/		regs.LR = 0x820C351C; return 0x82088200;
		/* 820C3518h case    2:*/		return 0x820C351C;
		  /* 820C351Ch */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820C351Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C351Ch case    3:*/		return 0x820C3520;
		  /* 820C3520h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 820C3520h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C3534;  }
		/* 820C3520h case    4:*/		return 0x820C3524;
		  /* 820C3524h */ case    5:  		/* mr R4, R24 */
		/* 820C3524h case    5:*/		regs.R4 = regs.R24;
		/* 820C3524h case    5:*/		return 0x820C3528;
		  /* 820C3528h */ case    6:  		/* lwz R5, <#[R30 + 140]> */
		/* 820C3528h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000008C) );
		/* 820C3528h case    6:*/		return 0x820C352C;
		  /* 820C352Ch */ case    7:  		/* bl 220924 */
		/* 820C352Ch case    7:*/		regs.LR = 0x820C3530; return 0x820F9428;
		/* 820C352Ch case    7:*/		return 0x820C3530;
		  /* 820C3530h */ case    8:  		/* b 8 */
		/* 820C3530h case    8:*/		return 0x820C3538;
		/* 820C3530h case    8:*/		return 0x820C3534;
	}
	return 0x820C3534;
} // Block from 820C3510h-820C3534h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C3534h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3534( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3534) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3534);
		  /* 820C3534h */ case    0:  		/* mr R3, R26 */
		/* 820C3534h case    0:*/		regs.R3 = regs.R26;
		/* 820C3534h case    0:*/		return 0x820C3538;
	}
	return 0x820C3538;
} // Block from 820C3534h-820C3538h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C3538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3538);
		  /* 820C3538h */ case    0:  		/* stw R3, <#[R30 + 8]> */
		/* 820C3538h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820C3538h case    0:*/		return 0x820C353C;
	}
	return 0x820C353C;
} // Block from 820C3538h-820C353Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C353Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C353C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C353C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C353C);
		  /* 820C353Ch */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 820C353Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 820C353Ch case    0:*/		return 0x820C3540;
		  /* 820C3540h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C3540h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C3540h case    1:*/		return 0x820C3544;
		  /* 820C3544h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C3544h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C3554;  }
		/* 820C3544h case    2:*/		return 0x820C3548;
		  /* 820C3548h */ case    3:  		/* lis R29, -32761 */
		/* 820C3548h case    3:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8007);
		/* 820C3548h case    3:*/		return 0x820C354C;
		  /* 820C354Ch */ case    4:  		/* ori R29, R29, 14 */
		/* 820C354Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0xE);
		/* 820C354Ch case    4:*/		return 0x820C3550;
		  /* 820C3550h */ case    5:  		/* b 1152 */
		/* 820C3550h case    5:*/		return 0x820C39D0;
		/* 820C3550h case    5:*/		return 0x820C3554;
	}
	return 0x820C3554;
} // Block from 820C353Ch-820C3554h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C3554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3554);
		  /* 820C3554h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 820C3554h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 820C3554h case    0:*/		return 0x820C3558;
		  /* 820C3558h */ case    1:  		/* bc 4, CR6_EQ, 68 */
		/* 820C3558h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C359C;  }
		/* 820C3558h case    1:*/		return 0x820C355C;
		  /* 820C355Ch */ case    2:  		/* addi R3, R31, 368 */
		/* 820C355Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x170);
		/* 820C355Ch case    2:*/		return 0x820C3560;
		  /* 820C3560h */ case    3:  		/* lwz R29, <#[R30 + 20]> */
		/* 820C3560h case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000014) );
		/* 820C3560h case    3:*/		return 0x820C3564;
		  /* 820C3564h */ case    4:  		/* lwz R28, <#[R30]> */
		/* 820C3564h case    4:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000000) );
		/* 820C3564h case    4:*/		return 0x820C3568;
		  /* 820C3568h */ case    5:  		/* bl 346424 */
		/* 820C3568h case    5:*/		regs.LR = 0x820C356C; return 0x82117EA0;
		/* 820C3568h case    5:*/		return 0x820C356C;
		  /* 820C356Ch */ case    6:  		/* mr R4, R28 */
		/* 820C356Ch case    6:*/		regs.R4 = regs.R28;
		/* 820C356Ch case    6:*/		return 0x820C3570;
		  /* 820C3570h */ case    7:  		/* oris R5, R29, 32768 */
		/* 820C3570h case    7:*/		cpu::op::oris<0>(regs,&regs.R5,regs.R29,0x8000);
		/* 820C3570h case    7:*/		return 0x820C3574;
		  /* 820C3574h */ case    8:  		/* mr R6, R23 */
		/* 820C3574h case    8:*/		regs.R6 = regs.R23;
		/* 820C3574h case    8:*/		return 0x820C3578;
		  /* 820C3578h */ case    9:  		/* mr R7, R19 */
		/* 820C3578h case    9:*/		regs.R7 = regs.R19;
		/* 820C3578h case    9:*/		return 0x820C357C;
		  /* 820C357Ch */ case   10:  		/* bl 426220 */
		/* 820C357Ch case   10:*/		regs.LR = 0x820C3580; return 0x8212B668;
		/* 820C357Ch case   10:*/		return 0x820C3580;
		  /* 820C3580h */ case   11:  		/* mr R29, R3 */
		/* 820C3580h case   11:*/		regs.R29 = regs.R3;
		/* 820C3580h case   11:*/		return 0x820C3584;
		  /* 820C3584h */ case   12:  		/* addi R3, R31, 368 */
		/* 820C3584h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x170);
		/* 820C3584h case   12:*/		return 0x820C3588;
		  /* 820C3588h */ case   13:  		/* rlwinm R28, R29, 1, 31, 31 */
		/* 820C3588h case   13:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R28,regs.R29);
		/* 820C3588h case   13:*/		return 0x820C358C;
		  /* 820C358Ch */ case   14:  		/* bl 1416756 */
		/* 820C358Ch case   14:*/		regs.LR = 0x820C3590; return 0x8221D3C0;
		/* 820C358Ch case   14:*/		return 0x820C3590;
		  /* 820C3590h */ case   15:  		/* cmplwi CR0, R28, 0 */
		/* 820C3590h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R28,0x00000000);
		/* 820C3590h case   15:*/		return 0x820C3594;
		  /* 820C3594h */ case   16:  		/* bc 4, CR0_EQ, 1084 */
		/* 820C3594h case   16:*/		if ( !regs.CR[0].eq ) { return 0x820C39D0;  }
		/* 820C3594h case   16:*/		return 0x820C3598;
		  /* 820C3598h */ case   17:  		/* b 8 */
		/* 820C3598h case   17:*/		return 0x820C35A0;
		/* 820C3598h case   17:*/		return 0x820C359C;
	}
	return 0x820C359C;
} // Block from 820C3554h-820C359Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 820C359Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C359C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C359C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C359C);
		  /* 820C359Ch */ case    0:  		/* stw R25, <#[R23]> */
		/* 820C359Ch case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R23 + 0x00000000) );
		/* 820C359Ch case    0:*/		return 0x820C35A0;
	}
	return 0x820C35A0;
} // Block from 820C359Ch-820C35A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C35A0h
// Function '?EmitArgs@CCompiler@D3DXShader@@IAAJPAVCNode@2@PAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C35A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C35A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C35A0);
		  /* 820C35A0h */ case    0:  		/* cmpwi CR6, R22, 0 */
		/* 820C35A0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 820C35A0h case    0:*/		return 0x820C35A4;
		  /* 820C35A4h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820C35A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C35C0;  }
		/* 820C35A4h case    1:*/		return 0x820C35A8;
		  /* 820C35A8h */ case    2:  		/* lis R11, -32255 */
		/* 820C35A8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C35A8h case    2:*/		return 0x820C35AC;
		  /* 820C35ACh */ case    3:  		/* li R5, 3505 */
		/* 820C35ACh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0xDB1);
		/* 820C35ACh case    3:*/		return 0x820C35B0;
		  /* 820C35B0h */ case    4:  		/* addi R6, R11, 6600 */
		/* 820C35B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x19C8);
		/* 820C35B0h case    4:*/		return 0x820C35B4;
		  /* 820C35B4h */ case    5:  		/* li R4, 0 */
		/* 820C35B4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C35B4h case    5:*/		return 0x820C35B8;
		  /* 820C35B8h */ case    6:  		/* mr R3, R30 */
		/* 820C35B8h case    6:*/		regs.R3 = regs.R30;
		/* 820C35B8h case    6:*/		return 0x820C35BC;
		  /* 820C35BCh */ case    7:  		/* bl -76604 */
		/* 820C35BCh case    7:*/		regs.LR = 0x820C35C0; return 0x820B0A80;
		/* 820C35BCh case    7:*/		return 0x820C35C0;
	}
	return 0x820C35C0;
} // Block from 820C35A0h-820C35C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C35C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C35C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C35C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C35C0);
		  /* 820C35C0h */ case    0:  		/* cmpwi CR6, R21, 0 */
		/* 820C35C0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 820C35C0h case    0:*/		return 0x820C35C4;
		  /* 820C35C4h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820C35C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C35E0;  }
		/* 820C35C4h case    1:*/		return 0x820C35C8;
		  /* 820C35C8h */ case    2:  		/* lis R11, -32255 */
		/* 820C35C8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C35C8h case    2:*/		return 0x820C35CC;
		  /* 820C35CCh */ case    3:  		/* li R5, 3505 */
		/* 820C35CCh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0xDB1);
		/* 820C35CCh case    3:*/		return 0x820C35D0;
		  /* 820C35D0h */ case    4:  		/* addi R6, R11, 6556 */
		/* 820C35D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x199C);
		/* 820C35D0h case    4:*/		return 0x820C35D4;
		  /* 820C35D4h */ case    5:  		/* li R4, 0 */
		/* 820C35D4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C35D4h case    5:*/		return 0x820C35D8;
		  /* 820C35D8h */ case    6:  		/* mr R3, R30 */
		/* 820C35D8h case    6:*/		regs.R3 = regs.R30;
		/* 820C35D8h case    6:*/		return 0x820C35DC;
		  /* 820C35DCh */ case    7:  		/* bl -76636 */
		/* 820C35DCh case    7:*/		regs.LR = 0x820C35E0; return 0x820B0A80;
		/* 820C35DCh case    7:*/		return 0x820C35E0;
	}
	return 0x820C35E0;
} // Block from 820C35C0h-820C35E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C35E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C35E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C35E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C35E0);
		  /* 820C35E0h */ case    0:  		/* cmplwi CR6, R16, 0 */
		/* 820C35E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 820C35E0h case    0:*/		return 0x820C35E4;
		  /* 820C35E4h */ case    1:  		/* bc 4, CR6_EQ, 96 */
		/* 820C35E4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C3644;  }
		/* 820C35E4h case    1:*/		return 0x820C35E8;
		  /* 820C35E8h */ case    2:  		/* cmplwi CR6, R17, 0 */
		/* 820C35E8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 820C35E8h case    2:*/		return 0x820C35EC;
		  /* 820C35ECh */ case    3:  		/* mr R3, R30 */
		/* 820C35ECh case    3:*/		regs.R3 = regs.R30;
		/* 820C35ECh case    3:*/		return 0x820C35F0;
		  /* 820C35F0h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 820C35F0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C3608;  }
		/* 820C35F0h case    4:*/		return 0x820C35F4;
		  /* 820C35F4h */ case    5:  		/* mr R4, R17 */
		/* 820C35F4h case    5:*/		regs.R4 = regs.R17;
		/* 820C35F4h case    5:*/		return 0x820C35F8;
		  /* 820C35F8h */ case    6:  		/* bl -79528 */
		/* 820C35F8h case    6:*/		regs.LR = 0x820C35FC; return 0x820AFF50;
		/* 820C35F8h case    6:*/		return 0x820C35FC;
		  /* 820C35FCh */ case    7:  		/* mr R28, R3 */
		/* 820C35FCh case    7:*/		regs.R28 = regs.R3;
		/* 820C35FCh case    7:*/		return 0x820C3600;
		  /* 820C3600h */ case    8:  		/* mr R25, R26 */
		/* 820C3600h case    8:*/		regs.R25 = regs.R26;
		/* 820C3600h case    8:*/		return 0x820C3604;
		  /* 820C3604h */ case    9:  		/* b 72 */
		/* 820C3604h case    9:*/		return 0x820C364C;
		/* 820C3604h case    9:*/		return 0x820C3608;
	}
	return 0x820C3608;
} // Block from 820C35E0h-820C3608h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C3608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3608);
		  /* 820C3608h */ case    0:  		/* addi R5, R31, 700 */
		/* 820C3608h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x2BC);
		/* 820C3608h case    0:*/		return 0x820C360C;
		  /* 820C360Ch */ case    1:  		/* mr R4, R20 */
		/* 820C360Ch case    1:*/		regs.R4 = regs.R20;
		/* 820C360Ch case    1:*/		return 0x820C3610;
		  /* 820C3610h */ case    2:  		/* bl -79216 */
		/* 820C3610h case    2:*/		regs.LR = 0x820C3614; return 0x820B00A0;
		/* 820C3610h case    2:*/		return 0x820C3614;
		  /* 820C3614h */ case    3:  		/* or. R28, R3, R3 */
		/* 820C3614h case    3:*/		cpu::op::or<1>(regs,&regs.R28,regs.R3,regs.R3);
		/* 820C3614h case    3:*/		return 0x820C3618;
		  /* 820C3618h */ case    4:  		/* bc 4, CR0_EQ, 32 */
		/* 820C3618h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820C3638;  }
		/* 820C3618h case    4:*/		return 0x820C361C;
		  /* 820C361Ch */ case    5:  		/* lis R11, -32255 */
		/* 820C361Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C361Ch case    5:*/		return 0x820C3620;
		  /* 820C3620h */ case    6:  		/* li R5, 3501 */
		/* 820C3620h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0xDAD);
		/* 820C3620h case    6:*/		return 0x820C3624;
		  /* 820C3624h */ case    7:  		/* addi R6, R11, 10276 */
		/* 820C3624h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2824);
		/* 820C3624h case    7:*/		return 0x820C3628;
		  /* 820C3628h */ case    8:  		/* li R4, 0 */
		/* 820C3628h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C3628h case    8:*/		return 0x820C362C;
		  /* 820C362Ch */ case    9:  		/* mr R3, R30 */
		/* 820C362Ch case    9:*/		regs.R3 = regs.R30;
		/* 820C362Ch case    9:*/		return 0x820C3630;
		  /* 820C3630h */ case   10:  		/* bl -76864 */
		/* 820C3630h case   10:*/		regs.LR = 0x820C3634; return 0x820B09F0;
		/* 820C3630h case   10:*/		return 0x820C3634;
		  /* 820C3634h */ case   11:  		/* b 1332 */
		/* 820C3634h case   11:*/		return 0x820C3B68;
		/* 820C3634h case   11:*/		return 0x820C3638;
	}
	return 0x820C3638;
} // Block from 820C3608h-820C3638h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C3638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3638);
		  /* 820C3638h */ case    0:  		/* lwz R17, <#[R31 + 700]> */
		/* 820C3638h case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R31 + 0x000002BC) );
		/* 820C3638h case    0:*/		return 0x820C363C;
		  /* 820C363Ch */ case    1:  		/* li R25, 1 */
		/* 820C363Ch case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 820C363Ch case    1:*/		return 0x820C3640;
		  /* 820C3640h */ case    2:  		/* b 12 */
		/* 820C3640h case    2:*/		return 0x820C364C;
		/* 820C3640h case    2:*/		return 0x820C3644;
	}
	return 0x820C3644;
} // Block from 820C3638h-820C3644h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C3644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3644);
		  /* 820C3644h */ case    0:  		/* lwz R28, <#[R31 + 216]> */
		/* 820C3644h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x000000D8) );
		/* 820C3644h case    0:*/		return 0x820C3648;
		  /* 820C3648h */ case    1:  		/* lwz R25, <#[R31 + 216]> */
		/* 820C3648h case    1:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R31 + 0x000000D8) );
		/* 820C3648h case    1:*/		return 0x820C364C;
	}
	return 0x820C364C;
} // Block from 820C3644h-820C364Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C364Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C364C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C364C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C364C);
		  /* 820C364Ch */ case    0:  		/* lwz R4, <#[R30 + 20]> */
		/* 820C364Ch case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000014) );
		/* 820C364Ch case    0:*/		return 0x820C3650;
		  /* 820C3650h */ case    1:  		/* rlwinm. R9, R4, 0, 6, 6 */
		/* 820C3650h case    1:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R9,regs.R4);
		/* 820C3650h case    1:*/		return 0x820C3654;
		  /* 820C3654h */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 820C3654h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820C3664;  }
		/* 820C3654h case    2:*/		return 0x820C3658;
		  /* 820C3658h */ case    3:  		/* rlwinm. R11, R4, 0, 9, 9 */
		/* 820C3658h case    3:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R4);
		/* 820C3658h case    3:*/		return 0x820C365C;
		  /* 820C365Ch */ case    4:  		/* mr R11, R26 */
		/* 820C365Ch case    4:*/		regs.R11 = regs.R26;
		/* 820C365Ch case    4:*/		return 0x820C3660;
		  /* 820C3660h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 820C3660h case    5:*/		if ( regs.CR[0].eq ) { return 0x820C3668;  }
		/* 820C3660h case    5:*/		return 0x820C3664;
	}
	return 0x820C3664;
} // Block from 820C364Ch-820C3664h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C3664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3664);
		  /* 820C3664h */ case    0:  		/* li R11, 1 */
		/* 820C3664h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820C3664h case    0:*/		return 0x820C3668;
	}
	return 0x820C3668;
} // Block from 820C3664h-820C3668h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C3668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3668);
		  /* 820C3668h */ case    0:  		/* lwz R10, <#[R19 + 16]> */
		/* 820C3668h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000010) );
		/* 820C3668h case    0:*/		return 0x820C366C;
		  /* 820C366Ch */ case    1:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 820C366Ch case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 820C366Ch case    1:*/		return 0x820C3670;
		  /* 820C3670h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 820C3670h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C3670h case    2:*/		return 0x820C3674;
		  /* 820C3674h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 820C3674h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C3688;  }
		/* 820C3674h case    3:*/		return 0x820C3678;
		  /* 820C3678h */ case    4:  		/* addi R10, R10, -32 */
		/* 820C3678h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFE0);
		/* 820C3678h case    4:*/		return 0x820C367C;
		  /* 820C367Ch */ case    5:  		/* addic R10, R10, -1 */
		/* 820C367Ch case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C367Ch case    5:*/		return 0x820C3680;
		  /* 820C3680h */ case    6:  		/* subfe R10, R10, R10 */
		/* 820C3680h case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820C3680h case    6:*/		return 0x820C3684;
		  /* 820C3684h */ case    7:  		/* and R11, R10, R11 */
		/* 820C3684h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C3684h case    7:*/		return 0x820C3688;
	}
	return 0x820C3688;
} // Block from 820C3668h-820C3688h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C3688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3688);
		  /* 820C3688h */ case    0:  		/* lwz R10, <#[R19 + 36]> */
		/* 820C3688h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000024) );
		/* 820C3688h case    0:*/		return 0x820C368C;
		  /* 820C368Ch */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C368Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C368Ch case    1:*/		return 0x820C3690;
		  /* 820C3690h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C3690h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C36A0;  }
		/* 820C3690h case    2:*/		return 0x820C3694;
		  /* 820C3694h */ case    3:  		/* lwz R10, <#[R19 + 44]> */
		/* 820C3694h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x0000002C) );
		/* 820C3694h case    3:*/		return 0x820C3698;
		  /* 820C3698h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 820C3698h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C3698h case    4:*/		return 0x820C369C;
		  /* 820C369Ch */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 820C369Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820C36A4;  }
		/* 820C369Ch case    5:*/		return 0x820C36A0;
	}
	return 0x820C36A0;
} // Block from 820C3688h-820C36A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C36A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C36A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C36A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C36A0);
		  /* 820C36A0h */ case    0:  		/* mr R11, R26 */
		/* 820C36A0h case    0:*/		regs.R11 = regs.R26;
		/* 820C36A0h case    0:*/		return 0x820C36A4;
	}
	return 0x820C36A4;
} // Block from 820C36A0h-820C36A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C36A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C36A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C36A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C36A4);
		  /* 820C36A4h */ case    0:  		/* lwz R10, <#[R19]> */
		/* 820C36A4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000000) );
		/* 820C36A4h case    0:*/		return 0x820C36A8;
		  /* 820C36A8h */ case    1:  		/* rlwinm R8, R4, 0, 11, 11 */
		/* 820C36A8h case    1:*/		cpu::op::rlwinm<0,0,11,11>(regs,&regs.R8,regs.R4);
		/* 820C36A8h case    1:*/		return 0x820C36AC;
		  /* 820C36ACh */ case    2:  		/* andi. R10, R10, 18 */
		/* 820C36ACh case    2:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x12);
		/* 820C36ACh case    2:*/		return 0x820C36B0;
		  /* 820C36B0h */ case    3:  		/* cmplwi CR0, R8, 0 */
		/* 820C36B0h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R8,0x00000000);
		/* 820C36B0h case    3:*/		return 0x820C36B4;
		  /* 820C36B4h */ case    4:  		/* addic R10, R10, -1 */
		/* 820C36B4h case    4:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C36B4h case    4:*/		return 0x820C36B8;
		  /* 820C36B8h */ case    5:  		/* subfe R10, R10, R10 */
		/* 820C36B8h case    5:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820C36B8h case    5:*/		return 0x820C36BC;
		  /* 820C36BCh */ case    6:  		/* and R29, R10, R11 */
		/* 820C36BCh case    6:*/		cpu::op::and<0>(regs,&regs.R29,regs.R10,regs.R11);
		/* 820C36BCh case    6:*/		return 0x820C36C0;
		  /* 820C36C0h */ case    7:  		/* bc 4, CR0_EQ, 320 */
		/* 820C36C0h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820C3800;  }
		/* 820C36C0h case    7:*/		return 0x820C36C4;
		  /* 820C36C4h */ case    8:  		/* cmpwi CR6, R24, 0 */
		/* 820C36C4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 820C36C4h case    8:*/		return 0x820C36C8;
		  /* 820C36C8h */ case    9:  		/* bc 4, CR6_EQ, 312 */
		/* 820C36C8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820C3800;  }
		/* 820C36C8h case    9:*/		return 0x820C36CC;
		  /* 820C36CCh */ case   10:  		/* cmplwi CR6, R16, 0 */
		/* 820C36CCh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 820C36CCh case   10:*/		return 0x820C36D0;
		  /* 820C36D0h */ case   11:  		/* bc 4, CR6_EQ, 360 */
		/* 820C36D0h case   11:*/		if ( !regs.CR[6].eq ) { return 0x820C3838;  }
		/* 820C36D0h case   11:*/		return 0x820C36D4;
		  /* 820C36D4h */ case   12:  		/* cmplwi CR6, R9, 0 */
		/* 820C36D4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820C36D4h case   12:*/		return 0x820C36D8;
		  /* 820C36D8h */ case   13:  		/* bc 12, CR6_EQ, 16 */
		/* 820C36D8h case   13:*/		if ( regs.CR[6].eq ) { return 0x820C36E8;  }
		/* 820C36D8h case   13:*/		return 0x820C36DC;
		  /* 820C36DCh */ case   14:  		/* li R14, 1 */
		/* 820C36DCh case   14:*/		cpu::op::li<0>(regs,&regs.R14,0x1);
		/* 820C36DCh case   14:*/		return 0x820C36E0;
		  /* 820C36E0h */ case   15:  		/* stw R14, <#[R31 + 220]> */
		/* 820C36E0h case   15:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R31 + 0x000000DC) );
		/* 820C36E0h case   15:*/		return 0x820C36E4;
		  /* 820C36E4h */ case   16:  		/* b 284 */
		/* 820C36E4h case   16:*/		return 0x820C3800;
		/* 820C36E4h case   16:*/		return 0x820C36E8;
	}
	return 0x820C36E8;
} // Block from 820C36A4h-820C36E8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C36E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C36E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C36E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C36E8);
		  /* 820C36E8h */ case    0:  		/* lis R11, -32245 */
		/* 820C36E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820B);
		/* 820C36E8h case    0:*/		return 0x820C36EC;
		  /* 820C36ECh */ case    1:  		/* lwz R6, <#[R23]> */
		/* 820C36ECh case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R23 + 0x00000000) );
		/* 820C36ECh case    1:*/		return 0x820C36F0;
		  /* 820C36F0h */ case    2:  		/* addi R7, R31, 208 */
		/* 820C36F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R31,0xD0);
		/* 820C36F0h case    2:*/		return 0x820C36F4;
		  /* 820C36F4h */ case    3:  		/* lwz R3, <#[R30 + 16]> */
		/* 820C36F4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000010) );
		/* 820C36F4h case    3:*/		return 0x820C36F8;
		  /* 820C36F8h */ case    4:  		/* addi R11, R11, 2536 */
		/* 820C36F8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x9E8);
		/* 820C36F8h case    4:*/		return 0x820C36FC;
		  /* 820C36FCh */ case    5:  		/* stw R19, <#[R1 + 108]> */
		/* 820C36FCh case    5:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x0000006C) );
		/* 820C36FCh case    5:*/		return 0x820C3700;
		  /* 820C3700h */ case    6:  		/* addi R10, R31, 196 */
		/* 820C3700h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xC4);
		/* 820C3700h case    6:*/		return 0x820C3704;
		  /* 820C3704h */ case    7:  		/* stw R30, <#[R1 + 92]> */
		/* 820C3704h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 820C3704h case    7:*/		return 0x820C3708;
		  /* 820C3708h */ case    8:  		/* mr R9, R15 */
		/* 820C3708h case    8:*/		regs.R9 = regs.R15;
		/* 820C3708h case    8:*/		return 0x820C370C;
		  /* 820C370Ch */ case    9:  		/* stw R11, <#[R1 + 100]> */
		/* 820C370Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820C370Ch case    9:*/		return 0x820C3710;
		  /* 820C3710h */ case   10:  		/* mr R8, R28 */
		/* 820C3710h case   10:*/		regs.R8 = regs.R28;
		/* 820C3710h case   10:*/		return 0x820C3714;
		  /* 820C3714h */ case   11:  		/* stw R7, <#[R1 + 84]> */
		/* 820C3714h case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000054) );
		/* 820C3714h case   11:*/		return 0x820C3718;
		  /* 820C3718h */ case   12:  		/* mr R7, R17 */
		/* 820C3718h case   12:*/		regs.R7 = regs.R17;
		/* 820C3718h case   12:*/		return 0x820C371C;
		  /* 820C371Ch */ case   13:  		/* mr R5, R25 */
		/* 820C371Ch case   13:*/		regs.R5 = regs.R25;
		/* 820C371Ch case   13:*/		return 0x820C3720;
		  /* 820C3720h */ case   14:  		/* bl 586664 */
		/* 820C3720h case   14:*/		regs.LR = 0x820C3724; return 0x82152AC8;
		/* 820C3720h case   14:*/		return 0x820C3724;
		  /* 820C3724h */ case   15:  		/* lwz R11, <#[R31 + 196]> */
		/* 820C3724h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C3724h case   15:*/		return 0x820C3728;
		  /* 820C3728h */ case   16:  		/* mr R14, R3 */
		/* 820C3728h case   16:*/		regs.R14 = regs.R3;
		/* 820C3728h case   16:*/		return 0x820C372C;
		  /* 820C372Ch */ case   17:  		/* stw R3, <#[R31 + 220]> */
		/* 820C372Ch case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000DC) );
		/* 820C372Ch case   17:*/		return 0x820C3730;
		  /* 820C3730h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 820C3730h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C3730h case   18:*/		return 0x820C3734;
		  /* 820C3734h */ case   19:  		/* bc 12, CR6_EQ, 56 */
		/* 820C3734h case   19:*/		if ( regs.CR[6].eq ) { return 0x820C376C;  }
		/* 820C3734h case   19:*/		return 0x820C3738;
		  /* 820C3738h */ case   20:  		/* lwz R10, <#[R11]> */
		/* 820C3738h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C3738h case   20:*/		return 0x820C373C;
		  /* 820C373Ch */ case   21:  		/* mr R3, R11 */
		/* 820C373Ch case   21:*/		regs.R3 = regs.R11;
		/* 820C373Ch case   21:*/		return 0x820C3740;
		  /* 820C3740h */ case   22:  		/* lwz R11, <#[R10 + 16]> */
		/* 820C3740h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820C3740h case   22:*/		return 0x820C3744;
		  /* 820C3744h */ case   23:  		/* mtspr CTR, R11 */
		/* 820C3744h case   23:*/		regs.CTR = regs.R11;
		/* 820C3744h case   23:*/		return 0x820C3748;
		  /* 820C3748h */ case   24:  		/* bcctrl 20, CR0_LT */
		/* 820C3748h case   24:*/		if ( 1 ) { regs.LR = 0x820C374C; return (uint32)regs.CTR; }
		/* 820C3748h case   24:*/		return 0x820C374C;
		  /* 820C374Ch */ case   25:  		/* cmplwi CR0, R3, 0 */
		/* 820C374Ch case   25:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C374Ch case   25:*/		return 0x820C3750;
		  /* 820C3750h */ case   26:  		/* bc 12, CR0_EQ, 28 */
		/* 820C3750h case   26:*/		if ( regs.CR[0].eq ) { return 0x820C376C;  }
		/* 820C3750h case   26:*/		return 0x820C3754;
		  /* 820C3754h */ case   27:  		/* lwz R11, <#[R19 + 28]> */
		/* 820C3754h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x0000001C) );
		/* 820C3754h case   27:*/		return 0x820C3758;
		  /* 820C3758h */ case   28:  		/* cmpwi CR6, R11, 0 */
		/* 820C3758h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C3758h case   28:*/		return 0x820C375C;
		  /* 820C375Ch */ case   29:  		/* bc 4, CR6_EQ, 16 */
		/* 820C375Ch case   29:*/		if ( !regs.CR[6].eq ) { return 0x820C376C;  }
		/* 820C375Ch case   29:*/		return 0x820C3760;
		  /* 820C3760h */ case   30:  		/* lwz R3, <#[R31 + 196]> */
		/* 820C3760h case   30:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C3760h case   30:*/		return 0x820C3764;
		  /* 820C3764h */ case   31:  		/* bl -78236 */
		/* 820C3764h case   31:*/		regs.LR = 0x820C3768; return 0x820B05C8;
		/* 820C3764h case   31:*/		return 0x820C3768;
		  /* 820C3768h */ case   32:  		/* stw R3, <#[R19 + 28]> */
		/* 820C3768h case   32:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R19 + 0x0000001C) );
		/* 820C3768h case   32:*/		return 0x820C376C;
	}
	return 0x820C376C;
} // Block from 820C36E8h-820C376Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 820C376Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C376C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C376C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C376C);
		  /* 820C376Ch */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 820C376Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 820C376Ch case    0:*/		return 0x820C3770;
		  /* 820C3770h */ case    1:  		/* bc 4, CR6_LT, 144 */
		/* 820C3770h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820C3800;  }
		/* 820C3770h case    1:*/		return 0x820C3774;
		  /* 820C3774h */ case    2:  		/* lwz R11, <#[R19 + 28]> */
		/* 820C3774h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x0000001C) );
		/* 820C3774h case    2:*/		return 0x820C3778;
		  /* 820C3778h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820C3778h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C3778h case    3:*/		return 0x820C377C;
		  /* 820C377Ch */ case    4:  		/* bc 4, CR6_EQ, 132 */
		/* 820C377Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C3800;  }
		/* 820C377Ch case    4:*/		return 0x820C3780;
		  /* 820C3780h */ case    5:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 820C3780h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 820C3780h case    5:*/		return 0x820C3784;
		  /* 820C3784h */ case    6:  		/* bc 12, CR0_EQ, 124 */
		/* 820C3784h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C3800;  }
		/* 820C3784h case    6:*/		return 0x820C3788;
		  /* 820C3788h */ case    7:  		/* lis R11, -32768 */
		/* 820C3788h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 820C3788h case    7:*/		return 0x820C378C;
		  /* 820C378Ch */ case    8:  		/* ori R11, R11, 16388 */
		/* 820C378Ch case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4004);
		/* 820C378Ch case    8:*/		return 0x820C3790;
		  /* 820C3790h */ case    9:  		/* cmpw CR6, R14, R11 */
		/* 820C3790h case    9:*/		cpu::op::cmpw<6>(regs,regs.R14,regs.R11);
		/* 820C3790h case    9:*/		return 0x820C3794;
		  /* 820C3794h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 820C3794h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820C37A0;  }
		/* 820C3794h case   10:*/		return 0x820C3798;
		  /* 820C3798h */ case   11:  		/* mr R29, R26 */
		/* 820C3798h case   11:*/		regs.R29 = regs.R26;
		/* 820C3798h case   11:*/		return 0x820C379C;
		  /* 820C379Ch */ case   12:  		/* b 100 */
		/* 820C379Ch case   12:*/		return 0x820C3800;
		/* 820C379Ch case   12:*/		return 0x820C37A0;
	}
	return 0x820C37A0;
} // Block from 820C376Ch-820C37A0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C37A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C37A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C37A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C37A0);
		  /* 820C37A0h */ case    0:  		/* lwz R3, <#[R31 + 196]> */
		/* 820C37A0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C37A0h case    0:*/		return 0x820C37A4;
		  /* 820C37A4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C37A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C37A4h case    1:*/		return 0x820C37A8;
		  /* 820C37A8h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820C37A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C37C0;  }
		/* 820C37A8h case    2:*/		return 0x820C37AC;
		  /* 820C37ACh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820C37ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C37ACh case    3:*/		return 0x820C37B0;
		  /* 820C37B0h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C37B0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C37B0h case    4:*/		return 0x820C37B4;
		  /* 820C37B4h */ case    5:  		/* mtspr CTR, R11 */
		/* 820C37B4h case    5:*/		regs.CTR = regs.R11;
		/* 820C37B4h case    5:*/		return 0x820C37B8;
		  /* 820C37B8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820C37B8h case    6:*/		if ( 1 ) { regs.LR = 0x820C37BC; return (uint32)regs.CTR; }
		/* 820C37B8h case    6:*/		return 0x820C37BC;
		  /* 820C37BCh */ case    7:  		/* stw R26, <#[R31 + 196]> */
		/* 820C37BCh case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C37BCh case    7:*/		return 0x820C37C0;
	}
	return 0x820C37C0;
} // Block from 820C37A0h-820C37C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C37C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C37C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C37C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C37C0);
		  /* 820C37C0h */ case    0:  		/* lwz R3, <#[R31 + 208]> */
		/* 820C37C0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000D0) );
		/* 820C37C0h case    0:*/		return 0x820C37C4;
		  /* 820C37C4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C37C4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C37C4h case    1:*/		return 0x820C37C8;
		  /* 820C37C8h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820C37C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C37E0;  }
		/* 820C37C8h case    2:*/		return 0x820C37CC;
		  /* 820C37CCh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820C37CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C37CCh case    3:*/		return 0x820C37D0;
		  /* 820C37D0h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C37D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C37D0h case    4:*/		return 0x820C37D4;
		  /* 820C37D4h */ case    5:  		/* mtspr CTR, R11 */
		/* 820C37D4h case    5:*/		regs.CTR = regs.R11;
		/* 820C37D4h case    5:*/		return 0x820C37D8;
		  /* 820C37D8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820C37D8h case    6:*/		if ( 1 ) { regs.LR = 0x820C37DC; return (uint32)regs.CTR; }
		/* 820C37D8h case    6:*/		return 0x820C37DC;
		  /* 820C37DCh */ case    7:  		/* stw R26, <#[R31 + 208]> */
		/* 820C37DCh case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000D0) );
		/* 820C37DCh case    7:*/		return 0x820C37E0;
	}
	return 0x820C37E0;
} // Block from 820C37C0h-820C37E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C37E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C37E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C37E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C37E0);
		  /* 820C37E0h */ case    0:  		/* stw R26, <#[R30 + 76]> */
		/* 820C37E0h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x0000004C) );
		/* 820C37E0h case    0:*/		return 0x820C37E4;
		  /* 820C37E4h */ case    1:  		/* addi R4, R31, 212 */
		/* 820C37E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xD4);
		/* 820C37E4h case    1:*/		return 0x820C37E8;
		  /* 820C37E8h */ case    2:  		/* lwz R11, <#[R30]> */
		/* 820C37E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C37E8h case    2:*/		return 0x820C37EC;
		  /* 820C37ECh */ case    3:  		/* addi R3, R11, 24 */
		/* 820C37ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x18);
		/* 820C37ECh case    3:*/		return 0x820C37F0;
		  /* 820C37F0h */ case    4:  		/* bl -121736 */
		/* 820C37F0h case    4:*/		regs.LR = 0x820C37F4; return 0x820A5C68;
		/* 820C37F0h case    4:*/		return 0x820C37F4;
		  /* 820C37F4h */ case    5:  		/* lwz R11, <#[R30]> */
		/* 820C37F4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C37F4h case    5:*/		return 0x820C37F8;
		  /* 820C37F8h */ case    6:  		/* addi R3, R11, 24 */
		/* 820C37F8h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x18);
		/* 820C37F8h case    6:*/		return 0x820C37FC;
		  /* 820C37FCh */ case    7:  		/* bl -118308 */
		/* 820C37FCh case    7:*/		regs.LR = 0x820C3800; return 0x820A69D8;
		/* 820C37FCh case    7:*/		return 0x820C3800;
	}
	return 0x820C3800;
} // Block from 820C37E0h-820C3800h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C3800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3800);
		  /* 820C3800h */ case    0:  		/* cmplwi CR6, R16, 0 */
		/* 820C3800h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 820C3800h case    0:*/		return 0x820C3804;
		  /* 820C3804h */ case    1:  		/* bc 4, CR6_EQ, 52 */
		/* 820C3804h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C3838;  }
		/* 820C3804h case    1:*/		return 0x820C3808;
		  /* 820C3808h */ case    2:  		/* cmplwi CR6, R28, 0 */
		/* 820C3808h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C3808h case    2:*/		return 0x820C380C;
		  /* 820C380Ch */ case    3:  		/* bc 4, CR6_EQ, 44 */
		/* 820C380Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C3838;  }
		/* 820C380Ch case    3:*/		return 0x820C3810;
		  /* 820C3810h */ case    4:  		/* cmpwi CR6, R14, 0 */
		/* 820C3810h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 820C3810h case    4:*/		return 0x820C3814;
		  /* 820C3814h */ case    5:  		/* bc 12, CR6_LT, 852 */
		/* 820C3814h case    5:*/		if ( regs.CR[6].lt ) { return 0x820C3B68;  }
		/* 820C3814h case    5:*/		return 0x820C3818;
		  /* 820C3818h */ case    6:  		/* lis R11, -32255 */
		/* 820C3818h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C3818h case    6:*/		return 0x820C381C;
		  /* 820C381Ch */ case    7:  		/* mr R7, R17 */
		/* 820C381Ch case    7:*/		regs.R7 = regs.R17;
		/* 820C381Ch case    7:*/		return 0x820C3820;
		  /* 820C3820h */ case    8:  		/* addi R6, R11, 10248 */
		/* 820C3820h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2808);
		/* 820C3820h case    8:*/		return 0x820C3824;
		  /* 820C3824h */ case    9:  		/* li R5, 3501 */
		/* 820C3824h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0xDAD);
		/* 820C3824h case    9:*/		return 0x820C3828;
		  /* 820C3828h */ case   10:  		/* li R4, 0 */
		/* 820C3828h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C3828h case   10:*/		return 0x820C382C;
		  /* 820C382Ch */ case   11:  		/* mr R3, R30 */
		/* 820C382Ch case   11:*/		regs.R3 = regs.R30;
		/* 820C382Ch case   11:*/		return 0x820C3830;
		  /* 820C3830h */ case   12:  		/* bl -77376 */
		/* 820C3830h case   12:*/		regs.LR = 0x820C3834; return 0x820B09F0;
		/* 820C3830h case   12:*/		return 0x820C3834;
		  /* 820C3834h */ case   13:  		/* b 820 */
		/* 820C3834h case   13:*/		return 0x820C3B68;
		/* 820C3834h case   13:*/		return 0x820C3838;
	}
	return 0x820C3838;
} // Block from 820C3800h-820C3838h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C3838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3838);
		  /* 820C3838h */ case    0:  		/* lwz R8, <#[R19 + 28]> */
		/* 820C3838h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R19 + 0x0000001C) );
		/* 820C3838h case    0:*/		return 0x820C383C;
		  /* 820C383Ch */ case    1:  		/* lwz R11, <#[R31 + 196]> */
		/* 820C383Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C383Ch case    1:*/		return 0x820C3840;
		  /* 820C3840h */ case    2:  		/* addic R10, R8, -1 */
		/* 820C3840h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R8,0xFFFFFFFF);
		/* 820C3840h case    2:*/		return 0x820C3844;
		  /* 820C3844h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820C3844h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C3844h case    3:*/		return 0x820C3848;
		  /* 820C3848h */ case    4:  		/* subfe R11, R10, R10 */
		/* 820C3848h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R10);
		/* 820C3848h case    4:*/		return 0x820C384C;
		  /* 820C384Ch */ case    5:  		/* and R9, R11, R29 */
		/* 820C384Ch case    5:*/		cpu::op::and<0>(regs,&regs.R9,regs.R11,regs.R29);
		/* 820C384Ch case    5:*/		return 0x820C3850;
		  /* 820C3850h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 820C3850h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820C3860;  }
		/* 820C3850h case    6:*/		return 0x820C3854;
		  /* 820C3854h */ case    7:  		/* lwz R10, <#[R30 + 20]> */
		/* 820C3854h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 820C3854h case    7:*/		return 0x820C3858;
		  /* 820C3858h */ case    8:  		/* rlwinm. R11, R10, 0, 6, 6 */
		/* 820C3858h case    8:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R10);
		/* 820C3858h case    8:*/		return 0x820C385C;
		  /* 820C385Ch */ case    9:  		/* bc 4, CR0_EQ, 20 */
		/* 820C385Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x820C3870;  }
		/* 820C385Ch case    9:*/		return 0x820C3860;
	}
	return 0x820C3860;
} // Block from 820C3838h-820C3860h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C3860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3860);
		  /* 820C3860h */ case    0:  		/* lwz R10, <#[R30 + 20]> */
		/* 820C3860h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 820C3860h case    0:*/		return 0x820C3864;
		  /* 820C3864h */ case    1:  		/* rlwinm. R11, R10, 0, 9, 9 */
		/* 820C3864h case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R10);
		/* 820C3864h case    1:*/		return 0x820C3868;
		  /* 820C3868h */ case    2:  		/* mr R11, R26 */
		/* 820C3868h case    2:*/		regs.R11 = regs.R26;
		/* 820C3868h case    2:*/		return 0x820C386C;
		  /* 820C386Ch */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 820C386Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820C3874;  }
		/* 820C386Ch case    3:*/		return 0x820C3870;
	}
	return 0x820C3870;
} // Block from 820C3860h-820C3870h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C3870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3870);
		  /* 820C3870h */ case    0:  		/* li R11, 1 */
		/* 820C3870h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820C3870h case    0:*/		return 0x820C3874;
	}
	return 0x820C3874;
} // Block from 820C3870h-820C3874h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C3874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3874);
		  /* 820C3874h */ case    0:  		/* rlwinm. R27, R11, 0, 24, 31 */
		/* 820C3874h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R27,regs.R11);
		/* 820C3874h case    0:*/		return 0x820C3878;
		  /* 820C3878h */ case    1:  		/* stb R27, <#[R31 + 200]> */
		/* 820C3878h case    1:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R31 + 0x000000C8) );
		/* 820C3878h case    1:*/		return 0x820C387C;
		  /* 820C387Ch */ case    2:  		/* bc 12, CR0_EQ, 184 */
		/* 820C387Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820C3934;  }
		/* 820C387Ch case    2:*/		return 0x820C3880;
		  /* 820C3880h */ case    3:  		/* rlwinm. R11, R9, 0, 24, 31 */
		/* 820C3880h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R9);
		/* 820C3880h case    3:*/		return 0x820C3884;
		  /* 820C3884h */ case    4:  		/* bc 4, CR0_EQ, 176 */
		/* 820C3884h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820C3934;  }
		/* 820C3884h case    4:*/		return 0x820C3888;
	}
	return 0x820C3888;
} // Block from 820C3874h-820C3888h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C3888h
// Function '?EmitEval@CCompiler@D3DXShader@@IAAJPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3888);
		  /* 820C3888h */ case    0:  		/* rlwinm. R11, R10, 0, 7, 7 */
		/* 820C3888h case    0:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R11,regs.R10);
		/* 820C3888h case    0:*/		return 0x820C388C;
		  /* 820C388Ch */ case    1:  		/* mr R27, R26 */
		/* 820C388Ch case    1:*/		regs.R27 = regs.R26;
		/* 820C388Ch case    1:*/		return 0x820C3890;
		  /* 820C3890h */ case    2:  		/* stb R26, <#[R31 + 200]> */
		/* 820C3890h case    2:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R31 + 0x000000C8) );
		/* 820C3890h case    2:*/		return 0x820C3894;
		  /* 820C3894h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 820C3894h case    3:*/		if ( regs.CR[0].eq ) { return 0x820C38A4;  }
		/* 820C3894h case    3:*/		return 0x820C3898;
		  /* 820C3898h */ case    4:  		/* lis R11, -32255 */
		/* 820C3898h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C3898h case    4:*/		return 0x820C389C;
		  /* 820C389Ch */ case    5:  		/* addi R6, R11, 10200 */
		/* 820C389Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x27D8);
		/* 820C389Ch case    5:*/		return 0x820C38A0;
		  /* 820C38A0h */ case    6:  		/* b 132 */
		/* 820C38A0h case    6:*/		return 0x820C3924;
		/* 820C38A0h case    6:*/		return 0x820C38A4;
	}
	return 0x820C38A4;
} // Block from 820C3888h-820C38A4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C38A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C38A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C38A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C38A4);
		  /* 820C38A4h */ case    0:  		/* lwz R11, <#[R19 + 16]> */
		/* 820C38A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000010) );
		/* 820C38A4h case    0:*/		return 0x820C38A8;
		  /* 820C38A8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C38A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C38A8h case    1:*/		return 0x820C38AC;
		  /* 820C38ACh */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820C38ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x820C38C4;  }
		/* 820C38ACh case    2:*/		return 0x820C38B0;
		  /* 820C38B0h */ case    3:  		/* cmplwi CR6, R11, 32 */
		/* 820C38B0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 820C38B0h case    3:*/		return 0x820C38B4;
		  /* 820C38B4h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 820C38B4h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C38C4;  }
		/* 820C38B4h case    4:*/		return 0x820C38B8;
		  /* 820C38B8h */ case    5:  		/* lis R11, -32255 */
		/* 820C38B8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C38B8h case    5:*/		return 0x820C38BC;
		  /* 820C38BCh */ case    6:  		/* addi R6, R11, 10148 */
		/* 820C38BCh case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x27A4);
		/* 820C38BCh case    6:*/		return 0x820C38C0;
		  /* 820C38C0h */ case    7:  		/* b 100 */
		/* 820C38C0h case    7:*/		return 0x820C3924;
		/* 820C38C0h case    7:*/		return 0x820C38C4;
	}
	return 0x820C38C4;
} // Block from 820C38A4h-820C38C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C38C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C38C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C38C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C38C4);
		  /* 820C38C4h */ case    0:  		/* lwz R11, <#[R19 + 36]> */
		/* 820C38C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000024) );
		/* 820C38C4h case    0:*/		return 0x820C38C8;
		  /* 820C38C8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C38C8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C38C8h case    1:*/		return 0x820C38CC;
		  /* 820C38CCh */ case    2:  		/* bc 4, CR6_EQ, 80 */
		/* 820C38CCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C391C;  }
		/* 820C38CCh case    2:*/		return 0x820C38D0;
		  /* 820C38D0h */ case    3:  		/* lwz R11, <#[R19 + 44]> */
		/* 820C38D0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x0000002C) );
		/* 820C38D0h case    3:*/		return 0x820C38D4;
		  /* 820C38D4h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820C38D4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C38D4h case    4:*/		return 0x820C38D8;
		  /* 820C38D8h */ case    5:  		/* bc 4, CR6_EQ, 68 */
		/* 820C38D8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C391C;  }
		/* 820C38D8h case    5:*/		return 0x820C38DC;
		  /* 820C38DCh */ case    6:  		/* cmpwi CR6, R8, 0 */
		/* 820C38DCh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 820C38DCh case    6:*/		return 0x820C38E0;
		  /* 820C38E0h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 820C38E0h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C38F0;  }
		/* 820C38E0h case    7:*/		return 0x820C38E4;
		  /* 820C38E4h */ case    8:  		/* lis R11, -32255 */
		/* 820C38E4h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C38E4h case    8:*/		return 0x820C38E8;
		  /* 820C38E8h */ case    9:  		/* addi R6, R11, 10092 */
		/* 820C38E8h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x276C);
		/* 820C38E8h case    9:*/		return 0x820C38EC;
		  /* 820C38ECh */ case   10:  		/* b 56 */
		/* 820C38ECh case   10:*/		return 0x820C3924;
		/* 820C38ECh case   10:*/		return 0x820C38F0;
	}
	return 0x820C38F0;
} // Block from 820C38C4h-820C38F0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C38F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C38F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C38F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C38F0);
		  /* 820C38F0h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 820C38F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 820C38F0h case    0:*/		return 0x820C38F4;
		  /* 820C38F4h */ case    1:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 820C38F4h case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 820C38F4h case    1:*/		return 0x820C38F8;
		  /* 820C38F8h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 820C38F8h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C3908;  }
		/* 820C38F8h case    2:*/		return 0x820C38FC;
		  /* 820C38FCh */ case    3:  		/* lis R11, -32255 */
		/* 820C38FCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C38FCh case    3:*/		return 0x820C3900;
		  /* 820C3900h */ case    4:  		/* addi R6, R11, 10048 */
		/* 820C3900h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2740);
		/* 820C3900h case    4:*/		return 0x820C3904;
		  /* 820C3904h */ case    5:  		/* b 32 */
		/* 820C3904h case    5:*/		return 0x820C3924;
		/* 820C3904h case    5:*/		return 0x820C3908;
	}
	return 0x820C3908;
} // Block from 820C38F0h-820C3908h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C3908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3908);
		  /* 820C3908h */ case    0:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 820C3908h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 820C3908h case    0:*/		return 0x820C390C;
		  /* 820C390Ch */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 820C390Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820C3934;  }
		/* 820C390Ch case    1:*/		return 0x820C3910;
		  /* 820C3910h */ case    2:  		/* lis R11, -32255 */
		/* 820C3910h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C3910h case    2:*/		return 0x820C3914;
		  /* 820C3914h */ case    3:  		/* addi R6, R11, 10004 */
		/* 820C3914h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2714);
		/* 820C3914h case    3:*/		return 0x820C3918;
		  /* 820C3918h */ case    4:  		/* b 12 */
		/* 820C3918h case    4:*/		return 0x820C3924;
		/* 820C3918h case    4:*/		return 0x820C391C;
	}
	return 0x820C391C;
} // Block from 820C3908h-820C391Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C391Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C391C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C391C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C391C);
		  /* 820C391Ch */ case    0:  		/* lis R11, -32255 */
		/* 820C391Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C391Ch case    0:*/		return 0x820C3920;
		  /* 820C3920h */ case    1:  		/* addi R6, R11, 9952 */
		/* 820C3920h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x26E0);
		/* 820C3920h case    1:*/		return 0x820C3924;
	}
	return 0x820C3924;
} // Block from 820C391Ch-820C3924h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C3924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3924);
		  /* 820C3924h */ case    0:  		/* li R5, 3042 */
		/* 820C3924h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0xBE2);
		/* 820C3924h case    0:*/		return 0x820C3928;
		  /* 820C3928h */ case    1:  		/* li R4, 0 */
		/* 820C3928h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C3928h case    1:*/		return 0x820C392C;
		  /* 820C392Ch */ case    2:  		/* mr R3, R30 */
		/* 820C392Ch case    2:*/		regs.R3 = regs.R30;
		/* 820C392Ch case    2:*/		return 0x820C3930;
		  /* 820C3930h */ case    3:  		/* bl -77488 */
		/* 820C3930h case    3:*/		regs.LR = 0x820C3934; return 0x820B0A80;
		/* 820C3930h case    3:*/		return 0x820C3934;
	}
	return 0x820C3934;
} // Block from 820C3924h-820C3934h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C3934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3934);
		  /* 820C3934h */ case    0:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 820C3934h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 820C3934h case    0:*/		return 0x820C3938;
		  /* 820C3938h */ case    1:  		/* bc 4, CR0_EQ, 360 */
		/* 820C3938h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820C3AA0;  }
		/* 820C3938h case    1:*/		return 0x820C393C;
		  /* 820C393Ch */ case    2:  		/* lwz R11, <#[R31 + 196]> */
		/* 820C393Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C393Ch case    2:*/		return 0x820C3940;
		  /* 820C3940h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820C3940h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C3940h case    3:*/		return 0x820C3944;
		  /* 820C3944h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 820C3944h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C3950;  }
		/* 820C3944h case    4:*/		return 0x820C3948;
		  /* 820C3948h */ case    5:  		/* cmpwi CR6, R14, 0 */
		/* 820C3948h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 820C3948h case    5:*/		return 0x820C394C;
		  /* 820C394Ch */ case    6:  		/* bc 4, CR6_LT, 340 */
		/* 820C394Ch case    6:*/		if ( !regs.CR[6].lt ) { return 0x820C3AA0;  }
		/* 820C394Ch case    6:*/		return 0x820C3950;
	}
	return 0x820C3950;
} // Block from 820C3934h-820C3950h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C3950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3950);
		  /* 820C3950h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 820C3950h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 820C3950h case    0:*/		return 0x820C3954;
		  /* 820C3954h */ case    1:  		/* bc 12, CR6_LT, 956 */
		/* 820C3954h case    1:*/		if ( regs.CR[6].lt ) { return 0x820C3D10;  }
		/* 820C3954h case    1:*/		return 0x820C3958;
		  /* 820C3958h */ case    2:  		/* lwz R28, <#[R31 + 764]> */
		/* 820C3958h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x000002FC) );
		/* 820C3958h case    2:*/		return 0x820C395C;
		  /* 820C395Ch */ case    3:  		/* lwz R27, <#[R31 + 756]> */
		/* 820C395Ch case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x000002F4) );
		/* 820C395Ch case    3:*/		return 0x820C3960;
		  /* 820C3960h */ case    4:  		/* lwz R11, <#[R31 + 196]> */
		/* 820C3960h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C3960h case    4:*/		return 0x820C3964;
		  /* 820C3964h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820C3964h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C3964h case    5:*/		return 0x820C3968;
		  /* 820C3968h */ case    6:  		/* bc 12, CR6_EQ, 100 */
		/* 820C3968h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C39CC;  }
		/* 820C3968h case    6:*/		return 0x820C396C;
		  /* 820C396Ch */ case    7:  		/* lwz R3, <#[R27]> */
		/* 820C396Ch case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000000) );
		/* 820C396Ch case    7:*/		return 0x820C3970;
		  /* 820C3970h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 820C3970h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3970h case    8:*/		return 0x820C3974;
		  /* 820C3974h */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 820C3974h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C398C;  }
		/* 820C3974h case    9:*/		return 0x820C3978;
		  /* 820C3978h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 820C3978h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3978h case   10:*/		return 0x820C397C;
		  /* 820C397Ch */ case   11:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C397Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C397Ch case   11:*/		return 0x820C3980;
		  /* 820C3980h */ case   12:  		/* mtspr CTR, R11 */
		/* 820C3980h case   12:*/		regs.CTR = regs.R11;
		/* 820C3980h case   12:*/		return 0x820C3984;
		  /* 820C3984h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 820C3984h case   13:*/		if ( 1 ) { regs.LR = 0x820C3988; return (uint32)regs.CTR; }
		/* 820C3984h case   13:*/		return 0x820C3988;
		  /* 820C3988h */ case   14:  		/* stw R26, <#[R27]> */
		/* 820C3988h case   14:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R27 + 0x00000000) );
		/* 820C3988h case   14:*/		return 0x820C398C;
	}
	return 0x820C398C;
} // Block from 820C3950h-820C398Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C398Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C398C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C398C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C398C);
		  /* 820C398Ch */ case    0:  		/* lwz R11, <#[R31 + 196]> */
		/* 820C398Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C398Ch case    0:*/		return 0x820C3990;
		  /* 820C3990h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 820C3990h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C3990h case    1:*/		return 0x820C3994;
		  /* 820C3994h */ case    2:  		/* stw R26, <#[R31 + 196]> */
		/* 820C3994h case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C3994h case    2:*/		return 0x820C3998;
		  /* 820C3998h */ case    3:  		/* stw R11, <#[R27]> */
		/* 820C3998h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820C3998h case    3:*/		return 0x820C399C;
		  /* 820C399Ch */ case    4:  		/* bc 12, CR6_EQ, 48 */
		/* 820C399Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820C39CC;  }
		/* 820C399Ch case    4:*/		return 0x820C39A0;
		  /* 820C39A0h */ case    5:  		/* lwz R3, <#[R28]> */
		/* 820C39A0h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000000) );
		/* 820C39A0h case    5:*/		return 0x820C39A4;
		  /* 820C39A4h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 820C39A4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C39A4h case    6:*/		return 0x820C39A8;
		  /* 820C39A8h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 820C39A8h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C39C0;  }
		/* 820C39A8h case    7:*/		return 0x820C39AC;
		  /* 820C39ACh */ case    8:  		/* lwz R11, <#[R3]> */
		/* 820C39ACh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C39ACh case    8:*/		return 0x820C39B0;
		  /* 820C39B0h */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C39B0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C39B0h case    9:*/		return 0x820C39B4;
		  /* 820C39B4h */ case   10:  		/* mtspr CTR, R11 */
		/* 820C39B4h case   10:*/		regs.CTR = regs.R11;
		/* 820C39B4h case   10:*/		return 0x820C39B8;
		  /* 820C39B8h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820C39B8h case   11:*/		if ( 1 ) { regs.LR = 0x820C39BC; return (uint32)regs.CTR; }
		/* 820C39B8h case   11:*/		return 0x820C39BC;
		  /* 820C39BCh */ case   12:  		/* stw R26, <#[R28]> */
		/* 820C39BCh case   12:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R28 + 0x00000000) );
		/* 820C39BCh case   12:*/		return 0x820C39C0;
	}
	return 0x820C39C0;
} // Block from 820C398Ch-820C39C0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C39C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C39C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C39C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C39C0);
		  /* 820C39C0h */ case    0:  		/* lwz R11, <#[R31 + 208]> */
		/* 820C39C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000D0) );
		/* 820C39C0h case    0:*/		return 0x820C39C4;
		  /* 820C39C4h */ case    1:  		/* stw R26, <#[R31 + 208]> */
		/* 820C39C4h case    1:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000D0) );
		/* 820C39C4h case    1:*/		return 0x820C39C8;
		  /* 820C39C8h */ case    2:  		/* stw R11, <#[R28]> */
		/* 820C39C8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820C39C8h case    2:*/		return 0x820C39CC;
	}
	return 0x820C39CC;
} // Block from 820C39C0h-820C39CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C39CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C39CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C39CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C39CC);
		  /* 820C39CCh */ case    0:  		/* mr R29, R26 */
		/* 820C39CCh case    0:*/		regs.R29 = regs.R26;
		/* 820C39CCh case    0:*/		return 0x820C39D0;
	}
	return 0x820C39D0;
} // Block from 820C39CCh-820C39D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C39D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C39D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C39D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C39D0);
		  /* 820C39D0h */ case    0:  		/* bl -165592 */
		/* 820C39D0h case    0:*/		regs.LR = 0x820C39D4; return 0x8209B2F8;
		/* 820C39D0h case    0:*/		return 0x820C39D4;
		  /* 820C39D4h */ case    1:  		/* lis R4, 11 */
		/* 820C39D4h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0xB);
		/* 820C39D4h case    1:*/		return 0x820C39D8;
		  /* 820C39D8h */ case    2:  		/* lwz R3, <#[R31 + 216]> */
		/* 820C39D8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000D8) );
		/* 820C39D8h case    2:*/		return 0x820C39DC;
		  /* 820C39DCh */ case    3:  		/* ori R4, R4, 31 */
		/* 820C39DCh case    3:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x1F);
		/* 820C39DCh case    3:*/		return 0x820C39E0;
		  /* 820C39E0h */ case    4:  		/* bl -165968 */
		/* 820C39E0h case    4:*/		regs.LR = 0x820C39E4; return 0x8209B190;
		/* 820C39E0h case    4:*/		return 0x820C39E4;
		  /* 820C39E4h */ case    5:  		/* lwz R3, <#[R30 + 8]> */
		/* 820C39E4h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820C39E4h case    5:*/		return 0x820C39E8;
		  /* 820C39E8h */ case    6:  		/* stw R26, <#[R30 + 4]> */
		/* 820C39E8h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000004) );
		/* 820C39E8h case    6:*/		return 0x820C39EC;
		  /* 820C39ECh */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 820C39ECh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C39ECh case    7:*/		return 0x820C39F0;
		  /* 820C39F0h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 820C39F0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C3A08;  }
		/* 820C39F0h case    8:*/		return 0x820C39F4;
		  /* 820C39F4h */ case    9:  		/* lwz R11, <#[R3]> */
		/* 820C39F4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C39F4h case    9:*/		return 0x820C39F8;
		  /* 820C39F8h */ case   10:  		/* li R4, 1 */
		/* 820C39F8h case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820C39F8h case   10:*/		return 0x820C39FC;
		  /* 820C39FCh */ case   11:  		/* lwz R11, <#[R11]> */
		/* 820C39FCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C39FCh case   11:*/		return 0x820C3A00;
	}
	return 0x820C3A00;
} // Block from 820C39D0h-820C3A00h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C3A00h
// Function '?CompileInternal@CCompiler@D3DXShader@@IAAJPAVCPreProcessor@2@PAVCNode@2@PBD111H2KPAPAUID3DXBuffer@@PAPAUID3DXConstantTable@@PAU_D3DXSHADER_COMPILE_PARAMETERSA@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3A00);
		  /* 820C3A00h */ case    0:  		/* mtspr CTR, R11 */
		/* 820C3A00h case    0:*/		regs.CTR = regs.R11;
		/* 820C3A00h case    0:*/		return 0x820C3A04;
		  /* 820C3A04h */ case    1:  		/* bcctrl 20, CR0_LT */
		/* 820C3A04h case    1:*/		if ( 1 ) { regs.LR = 0x820C3A08; return (uint32)regs.CTR; }
		/* 820C3A04h case    1:*/		return 0x820C3A08;
	}
	return 0x820C3A08;
} // Block from 820C3A00h-820C3A08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C3A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3A08);
		  /* 820C3A08h */ case    0:  		/* stw R26, <#[R30 + 8]> */
		/* 820C3A08h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000008) );
		/* 820C3A08h case    0:*/		return 0x820C3A0C;
		  /* 820C3A0Ch */ case    1:  		/* lis R4, 9345 */
		/* 820C3A0Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C3A0Ch case    1:*/		return 0x820C3A10;
		  /* 820C3A10h */ case    2:  		/* lwz R3, <#[R30 + 24]> */
		/* 820C3A10h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820C3A10h case    2:*/		return 0x820C3A14;
		  /* 820C3A14h */ case    3:  		/* bl -243420 */
		/* 820C3A14h case    3:*/		regs.LR = 0x820C3A18; return 0x82088338;
		/* 820C3A14h case    3:*/		return 0x820C3A18;
		  /* 820C3A18h */ case    4:  		/* stw R26, <#[R30 + 24]> */
		/* 820C3A18h case    4:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R30 + 0x00000018) );
		/* 820C3A18h case    4:*/		return 0x820C3A1C;
		  /* 820C3A1Ch */ case    5:  		/* li R3, 0 */
		/* 820C3A1Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C3A1Ch case    5:*/		return 0x820C3A20;
		  /* 820C3A20h */ case    6:  		/* bl 234192 */
		/* 820C3A20h case    6:*/		regs.LR = 0x820C3A24; return 0x820FCCF0;
		/* 820C3A20h case    6:*/		return 0x820C3A24;
		  /* 820C3A24h */ case    7:  		/* li R3, 0 */
		/* 820C3A24h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C3A24h case    7:*/		return 0x820C3A28;
		  /* 820C3A28h */ case    8:  		/* bl 232184 */
		/* 820C3A28h case    8:*/		regs.LR = 0x820C3A2C; return 0x820FC520;
		/* 820C3A28h case    8:*/		return 0x820C3A2C;
		  /* 820C3A2Ch */ case    9:  		/* lwz R3, <#[R31 + 196]> */
		/* 820C3A2Ch case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C3A2Ch case    9:*/		return 0x820C3A30;
		  /* 820C3A30h */ case   10:  		/* cmplwi CR6, R3, 0 */
		/* 820C3A30h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3A30h case   10:*/		return 0x820C3A34;
		  /* 820C3A34h */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 820C3A34h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C3A4C;  }
		/* 820C3A34h case   11:*/		return 0x820C3A38;
		  /* 820C3A38h */ case   12:  		/* lwz R11, <#[R3]> */
		/* 820C3A38h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3A38h case   12:*/		return 0x820C3A3C;
		  /* 820C3A3Ch */ case   13:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3A3Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3A3Ch case   13:*/		return 0x820C3A40;
		  /* 820C3A40h */ case   14:  		/* mtspr CTR, R11 */
		/* 820C3A40h case   14:*/		regs.CTR = regs.R11;
		/* 820C3A40h case   14:*/		return 0x820C3A44;
		  /* 820C3A44h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 820C3A44h case   15:*/		if ( 1 ) { regs.LR = 0x820C3A48; return (uint32)regs.CTR; }
		/* 820C3A44h case   15:*/		return 0x820C3A48;
		  /* 820C3A48h */ case   16:  		/* stw R26, <#[R31 + 196]> */
		/* 820C3A48h case   16:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C3A48h case   16:*/		return 0x820C3A4C;
	}
	return 0x820C3A4C;
} // Block from 820C3A08h-820C3A4Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C3A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3A4C);
		  /* 820C3A4Ch */ case    0:  		/* lwz R3, <#[R31 + 208]> */
		/* 820C3A4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000D0) );
		/* 820C3A4Ch case    0:*/		return 0x820C3A50;
		  /* 820C3A50h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C3A50h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3A50h case    1:*/		return 0x820C3A54;
		  /* 820C3A54h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820C3A54h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C3A6C;  }
		/* 820C3A54h case    2:*/		return 0x820C3A58;
		  /* 820C3A58h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820C3A58h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3A58h case    3:*/		return 0x820C3A5C;
		  /* 820C3A5Ch */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3A5Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3A5Ch case    4:*/		return 0x820C3A60;
		  /* 820C3A60h */ case    5:  		/* mtspr CTR, R11 */
		/* 820C3A60h case    5:*/		regs.CTR = regs.R11;
		/* 820C3A60h case    5:*/		return 0x820C3A64;
		  /* 820C3A64h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820C3A64h case    6:*/		if ( 1 ) { regs.LR = 0x820C3A68; return (uint32)regs.CTR; }
		/* 820C3A64h case    6:*/		return 0x820C3A68;
		  /* 820C3A68h */ case    7:  		/* stw R26, <#[R31 + 208]> */
		/* 820C3A68h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000D0) );
		/* 820C3A68h case    7:*/		return 0x820C3A6C;
	}
	return 0x820C3A6C;
} // Block from 820C3A4Ch-820C3A6Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C3A6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3A6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3A6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3A6C);
		  /* 820C3A6Ch */ case    0:  		/* lwz R3, <#[R31 + 212]> */
		/* 820C3A6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000D4) );
		/* 820C3A6Ch case    0:*/		return 0x820C3A70;
		  /* 820C3A70h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C3A70h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3A70h case    1:*/		return 0x820C3A74;
		  /* 820C3A74h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820C3A74h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C3A8C;  }
		/* 820C3A74h case    2:*/		return 0x820C3A78;
		  /* 820C3A78h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820C3A78h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3A78h case    3:*/		return 0x820C3A7C;
		  /* 820C3A7Ch */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3A7Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3A7Ch case    4:*/		return 0x820C3A80;
		  /* 820C3A80h */ case    5:  		/* mtspr CTR, R11 */
		/* 820C3A80h case    5:*/		regs.CTR = regs.R11;
		/* 820C3A80h case    5:*/		return 0x820C3A84;
		  /* 820C3A84h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820C3A84h case    6:*/		if ( 1 ) { regs.LR = 0x820C3A88; return (uint32)regs.CTR; }
		/* 820C3A84h case    6:*/		return 0x820C3A88;
		  /* 820C3A88h */ case    7:  		/* stw R26, <#[R31 + 212]> */
		/* 820C3A88h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000D4) );
		/* 820C3A88h case    7:*/		return 0x820C3A8C;
	}
	return 0x820C3A8C;
} // Block from 820C3A6Ch-820C3A8Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C3A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3A8C);
		  /* 820C3A8Ch */ case    0:  		/* addi R3, R31, 256 */
		/* 820C3A8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x100);
		/* 820C3A8Ch case    0:*/		return 0x820C3A90;
		  /* 820C3A90h */ case    1:  		/* bl 22016 */
		/* 820C3A90h case    1:*/		regs.LR = 0x820C3A94; return 0x820C9090;
		/* 820C3A90h case    1:*/		return 0x820C3A94;
		  /* 820C3A94h */ case    2:  		/* mr R3, R29 */
		/* 820C3A94h case    2:*/		regs.R3 = regs.R29;
		/* 820C3A94h case    2:*/		return 0x820C3A98;
		  /* 820C3A98h */ case    3:  		/* addi R1, R31, 656 */
		/* 820C3A98h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R31,0x290);
		/* 820C3A98h case    3:*/		return 0x820C3A9C;
		  /* 820C3A9Ch */ case    4:  		/* b -206892 */
		/* 820C3A9Ch case    4:*/		return 0x82091270;
		/* 820C3A9Ch case    4:*/		return 0x820C3AA0;
	}
	return 0x820C3AA0;
} // Block from 820C3A8Ch-820C3AA0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C3AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3AA0);
		  /* 820C3AA0h */ case    0:  		/* rlwinm. R11, R18, 0, 24, 31 */
		/* 820C3AA0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R18);
		/* 820C3AA0h case    0:*/		return 0x820C3AA4;
		  /* 820C3AA4h */ case    1:  		/* bc 4, CR0_EQ, 28 */
		/* 820C3AA4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820C3AC0;  }
		/* 820C3AA4h case    1:*/		return 0x820C3AA8;
		  /* 820C3AA8h */ case    2:  		/* lis R11, -32255 */
		/* 820C3AA8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C3AA8h case    2:*/		return 0x820C3AAC;
		  /* 820C3AACh */ case    3:  		/* li R5, 3505 */
		/* 820C3AACh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0xDB1);
		/* 820C3AACh case    3:*/		return 0x820C3AB0;
		  /* 820C3AB0h */ case    4:  		/* addi R6, R11, 9880 */
		/* 820C3AB0h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2698);
		/* 820C3AB0h case    4:*/		return 0x820C3AB4;
		  /* 820C3AB4h */ case    5:  		/* li R4, 0 */
		/* 820C3AB4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C3AB4h case    5:*/		return 0x820C3AB8;
		  /* 820C3AB8h */ case    6:  		/* mr R3, R30 */
		/* 820C3AB8h case    6:*/		regs.R3 = regs.R30;
		/* 820C3AB8h case    6:*/		return 0x820C3ABC;
		  /* 820C3ABCh */ case    7:  		/* bl -77884 */
		/* 820C3ABCh case    7:*/		regs.LR = 0x820C3AC0; return 0x820B0A80;
		/* 820C3ABCh case    7:*/		return 0x820C3AC0;
	}
	return 0x820C3AC0;
} // Block from 820C3AA0h-820C3AC0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C3AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3AC0);
		  /* 820C3AC0h */ case    0:  		/* lwz R11, <#[R30 + 144]> */
		/* 820C3AC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000090) );
		/* 820C3AC0h case    0:*/		return 0x820C3AC4;
		  /* 820C3AC4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C3AC4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C3AC4h case    1:*/		return 0x820C3AC8;
		  /* 820C3AC8h */ case    2:  		/* bc 4, CR6_EQ, 56 */
		/* 820C3AC8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C3B00;  }
		/* 820C3AC8h case    2:*/		return 0x820C3ACC;
		  /* 820C3ACCh */ case    3:  		/* li R11, 4096 */
		/* 820C3ACCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1000);
		/* 820C3ACCh case    3:*/		return 0x820C3AD0;
		  /* 820C3AD0h */ case    4:  		/* lis R4, 9345 */
		/* 820C3AD0h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C3AD0h case    4:*/		return 0x820C3AD4;
		  /* 820C3AD4h */ case    5:  		/* stw R11, <#[R30 + 148]> */
		/* 820C3AD4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000094) );
		/* 820C3AD4h case    5:*/		return 0x820C3AD8;
		  /* 820C3AD8h */ case    6:  		/* li R3, 16384 */
		/* 820C3AD8h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x4000);
		/* 820C3AD8h case    6:*/		return 0x820C3ADC;
		  /* 820C3ADCh */ case    7:  		/* bl -243932 */
		/* 820C3ADCh case    7:*/		regs.LR = 0x820C3AE0; return 0x82088200;
		/* 820C3ADCh case    7:*/		return 0x820C3AE0;
		  /* 820C3AE0h */ case    8:  		/* stw R3, <#[R30 + 144]> */
		/* 820C3AE0h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000090) );
		/* 820C3AE0h case    8:*/		return 0x820C3AE4;
		  /* 820C3AE4h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820C3AE4h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C3AE4h case    9:*/		return 0x820C3AE8;
		  /* 820C3AE8h */ case   10:  		/* bc 4, CR0_EQ, 24 */
		/* 820C3AE8h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820C3B00;  }
		/* 820C3AE8h case   10:*/		return 0x820C3AEC;
		  /* 820C3AECh */ case   11:  		/* addi R3, R31, 256 */
		/* 820C3AECh case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x100);
		/* 820C3AECh case   11:*/		return 0x820C3AF0;
		  /* 820C3AF0h */ case   12:  		/* bl 21920 */
		/* 820C3AF0h case   12:*/		regs.LR = 0x820C3AF4; return 0x820C9090;
		/* 820C3AF0h case   12:*/		return 0x820C3AF4;
		  /* 820C3AF4h */ case   13:  		/* lis R3, -32761 */
		/* 820C3AF4h case   13:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820C3AF4h case   13:*/		return 0x820C3AF8;
		  /* 820C3AF8h */ case   14:  		/* ori R3, R3, 14 */
		/* 820C3AF8h case   14:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820C3AF8h case   14:*/		return 0x820C3AFC;
		  /* 820C3AFCh */ case   15:  		/* b -100 */
		/* 820C3AFCh case   15:*/		return 0x820C3A98;
		/* 820C3AFCh case   15:*/		return 0x820C3B00;
	}
	return 0x820C3B00;
} // Block from 820C3AC0h-820C3B00h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C3B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3B00);
		  /* 820C3B00h */ case    0:  		/* addi R3, R31, 256 */
		/* 820C3B00h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x100);
		/* 820C3B00h case    0:*/		return 0x820C3B04;
		  /* 820C3B04h */ case    1:  		/* bl 233964 */
		/* 820C3B04h case    1:*/		regs.LR = 0x820C3B08; return 0x820FCCF0;
		/* 820C3B04h case    1:*/		return 0x820C3B08;
		  /* 820C3B08h */ case    2:  		/* addi R3, R31, 256 */
		/* 820C3B08h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x100);
		/* 820C3B08h case    2:*/		return 0x820C3B0C;
		  /* 820C3B0Ch */ case    3:  		/* bl 231956 */
		/* 820C3B0Ch case    3:*/		regs.LR = 0x820C3B10; return 0x820FC520;
		/* 820C3B0Ch case    3:*/		return 0x820C3B10;
		  /* 820C3B10h */ case    4:  		/* mr R3, R30 */
		/* 820C3B10h case    4:*/		regs.R3 = regs.R30;
		/* 820C3B10h case    4:*/		return 0x820C3B14;
		  /* 820C3B14h */ case    5:  		/* bl -11684 */
		/* 820C3B14h case    5:*/		regs.LR = 0x820C3B18; return 0x820C0D70;
		/* 820C3B14h case    5:*/		return 0x820C3B18;
		  /* 820C3B18h */ case    6:  		/* or. R29, R3, R3 */
		/* 820C3B18h case    6:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C3B18h case    6:*/		return 0x820C3B1C;
		  /* 820C3B1Ch */ case    7:  		/* bc 12, CR0_LT, -332 */
		/* 820C3B1Ch case    7:*/		if ( regs.CR[0].lt ) { return 0x820C39D0;  }
		/* 820C3B1Ch case    7:*/		return 0x820C3B20;
		  /* 820C3B20h */ case    8:  		/* cmplwi CR6, R16, 0 */
		/* 820C3B20h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 820C3B20h case    8:*/		return 0x820C3B24;
		  /* 820C3B24h */ case    9:  		/* mr R3, R30 */
		/* 820C3B24h case    9:*/		regs.R3 = regs.R30;
		/* 820C3B24h case    9:*/		return 0x820C3B28;
		  /* 820C3B28h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 820C3B28h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C3B38;  }
		/* 820C3B28h case   10:*/		return 0x820C3B2C;
		  /* 820C3B2Ch */ case   11:  		/* mr R4, R16 */
		/* 820C3B2Ch case   11:*/		regs.R4 = regs.R16;
		/* 820C3B2Ch case   11:*/		return 0x820C3B30;
		  /* 820C3B30h */ case   12:  		/* bl -3296 */
		/* 820C3B30h case   12:*/		regs.LR = 0x820C3B34; return 0x820C2E50;
		/* 820C3B30h case   12:*/		return 0x820C3B34;
		  /* 820C3B34h */ case   13:  		/* b 32 */
		/* 820C3B34h case   13:*/		return 0x820C3B54;
		/* 820C3B34h case   13:*/		return 0x820C3B38;
	}
	return 0x820C3B38;
} // Block from 820C3B00h-820C3B38h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C3B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3B38);
		  /* 820C3B38h */ case    0:  		/* mr R9, R25 */
		/* 820C3B38h case    0:*/		regs.R9 = regs.R25;
		/* 820C3B38h case    0:*/		return 0x820C3B3C;
		  /* 820C3B3Ch */ case    1:  		/* li R8, 1 */
		/* 820C3B3Ch case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820C3B3Ch case    1:*/		return 0x820C3B40;
		  /* 820C3B40h */ case    2:  		/* li R7, 0 */
		/* 820C3B40h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C3B40h case    2:*/		return 0x820C3B44;
		  /* 820C3B44h */ case    3:  		/* mr R6, R15 */
		/* 820C3B44h case    3:*/		regs.R6 = regs.R15;
		/* 820C3B44h case    3:*/		return 0x820C3B48;
		  /* 820C3B48h */ case    4:  		/* mr R5, R28 */
		/* 820C3B48h case    4:*/		regs.R5 = regs.R28;
		/* 820C3B48h case    4:*/		return 0x820C3B4C;
		  /* 820C3B4Ch */ case    5:  		/* mr R4, R17 */
		/* 820C3B4Ch case    5:*/		regs.R4 = regs.R17;
		/* 820C3B4Ch case    5:*/		return 0x820C3B50;
		  /* 820C3B50h */ case    6:  		/* bl -15176 */
		/* 820C3B50h case    6:*/		regs.LR = 0x820C3B54; return 0x820C0008;
		/* 820C3B50h case    6:*/		return 0x820C3B54;
	}
	return 0x820C3B54;
} // Block from 820C3B38h-820C3B54h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C3B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3B54);
		  /* 820C3B54h */ case    0:  		/* or. R29, R3, R3 */
		/* 820C3B54h case    0:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C3B54h case    0:*/		return 0x820C3B58;
		  /* 820C3B58h */ case    1:  		/* bc 12, CR0_LT, -392 */
		/* 820C3B58h case    1:*/		if ( regs.CR[0].lt ) { return 0x820C39D0;  }
		/* 820C3B58h case    1:*/		return 0x820C3B5C;
		  /* 820C3B5Ch */ case    2:  		/* lwz R11, <#[R30 + 76]> */
		/* 820C3B5Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 820C3B5Ch case    2:*/		return 0x820C3B60;
		  /* 820C3B60h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 820C3B60h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820C3B60h case    3:*/		return 0x820C3B64;
		  /* 820C3B64h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 820C3B64h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C3B74;  }
		/* 820C3B64h case    4:*/		return 0x820C3B68;
	}
	return 0x820C3B68;
} // Block from 820C3B54h-820C3B68h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C3B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3B68);
		  /* 820C3B68h */ case    0:  		/* lis R29, -32768 */
		/* 820C3B68h case    0:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8000);
		/* 820C3B68h case    0:*/		return 0x820C3B6C;
		  /* 820C3B6Ch */ case    1:  		/* ori R29, R29, 16389 */
		/* 820C3B6Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0x4005);
		/* 820C3B6Ch case    1:*/		return 0x820C3B70;
		  /* 820C3B70h */ case    2:  		/* b -416 */
		/* 820C3B70h case    2:*/		return 0x820C39D0;
		/* 820C3B70h case    2:*/		return 0x820C3B74;
	}
	return 0x820C3B74;
} // Block from 820C3B68h-820C3B74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C3B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3B74);
		  /* 820C3B74h */ case    0:  		/* mr R3, R30 */
		/* 820C3B74h case    0:*/		regs.R3 = regs.R30;
		/* 820C3B74h case    0:*/		return 0x820C3B78;
		  /* 820C3B78h */ case    1:  		/* bl -80256 */
		/* 820C3B78h case    1:*/		regs.LR = 0x820C3B7C; return 0x820B01F8;
		/* 820C3B78h case    1:*/		return 0x820C3B7C;
		  /* 820C3B7Ch */ case    2:  		/* or. R29, R3, R3 */
		/* 820C3B7Ch case    2:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C3B7Ch case    2:*/		return 0x820C3B80;
		  /* 820C3B80h */ case    3:  		/* bc 12, CR0_LT, -432 */
		/* 820C3B80h case    3:*/		if ( regs.CR[0].lt ) { return 0x820C39D0;  }
		/* 820C3B80h case    3:*/		return 0x820C3B84;
		  /* 820C3B84h */ case    4:  		/* stw R26, <#[R31 + 192]> */
		/* 820C3B84h case    4:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3B84h case    4:*/		return 0x820C3B88;
		  /* 820C3B88h */ case    5:  		/* stw R26, <#[R31 + 204]> */
		/* 820C3B88h case    5:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000CC) );
		/* 820C3B88h case    5:*/		return 0x820C3B8C;
		  /* 820C3B8Ch */ case    6:  		/* nop */
		/* 820C3B8Ch case    6:*/		cpu::op::nop();
		/* 820C3B8Ch case    6:*/		return 0x820C3B90;
		  /* 820C3B90h */ case    7:  		/* nop */
		/* 820C3B90h case    7:*/		cpu::op::nop();
		/* 820C3B90h case    7:*/		return 0x820C3B94;
	}
	return 0x820C3B94;
} // Block from 820C3B74h-820C3B94h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C3B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3B94);
		  /* 820C3B94h */ case    0:  		/* lwz R3, <#[R30 + 8]> */
		/* 820C3B94h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820C3B94h case    0:*/		return 0x820C3B98;
		  /* 820C3B98h */ case    1:  		/* addi R4, R31, 192 */
		/* 820C3B98h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xC0);
		/* 820C3B98h case    1:*/		return 0x820C3B9C;
		  /* 820C3B9Ch */ case    2:  		/* lwz R11, <#[R3]> */
		/* 820C3B9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3B9Ch case    2:*/		return 0x820C3BA0;
		  /* 820C3BA0h */ case    3:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3BA0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3BA0h case    3:*/		return 0x820C3BA4;
		  /* 820C3BA4h */ case    4:  		/* mtspr CTR, R11 */
		/* 820C3BA4h case    4:*/		regs.CTR = regs.R11;
		/* 820C3BA4h case    4:*/		return 0x820C3BA8;
		  /* 820C3BA8h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820C3BA8h case    5:*/		if ( 1 ) { regs.LR = 0x820C3BAC; return (uint32)regs.CTR; }
		/* 820C3BA8h case    5:*/		return 0x820C3BAC;
		  /* 820C3BACh */ case    6:  		/* mr R29, R3 */
		/* 820C3BACh case    6:*/		regs.R29 = regs.R3;
		/* 820C3BACh case    6:*/		return 0x820C3BB0;
		  /* 820C3BB0h */ case    7:  		/* stw R3, <#[R31 + 224]> */
		/* 820C3BB0h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x000000E0) );
		/* 820C3BB0h case    7:*/		return 0x820C3BB4;
	}
	return 0x820C3BB4;
} // Block from 820C3B94h-820C3BB4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C3BB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3BB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3BB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3BB4);
		  /* 820C3BB4h */ case    0:  		/* nop */
		/* 820C3BB4h case    0:*/		cpu::op::nop();
		/* 820C3BB4h case    0:*/		return 0x820C3BB8;
		  /* 820C3BB8h */ case    1:  		/* nop */
		/* 820C3BB8h case    1:*/		cpu::op::nop();
		/* 820C3BB8h case    1:*/		return 0x820C3BBC;
		  /* 820C3BBCh */ case    2:  		/* nop */
		/* 820C3BBCh case    2:*/		cpu::op::nop();
		/* 820C3BBCh case    2:*/		return 0x820C3BC0;
		  /* 820C3BC0h */ case    3:  		/* b 64 */
		/* 820C3BC0h case    3:*/		return 0x820C3C00;
		/* 820C3BC0h case    3:*/		return 0x820C3BC4;
	}
	return 0x820C3BC4;
} // Block from 820C3BB4h-820C3BC4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C3BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3BC4);
		  /* 820C3BC4h */ case    0:  		/* lwz R30, <#[R31 + 676]> */
		/* 820C3BC4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x000002A4) );
		/* 820C3BC4h case    0:*/		return 0x820C3BC8;
		  /* 820C3BC8h */ case    1:  		/* lis R11, -32255 */
		/* 820C3BC8h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C3BC8h case    1:*/		return 0x820C3BCC;
		  /* 820C3BCCh */ case    2:  		/* mr R7, R3 */
		/* 820C3BCCh case    2:*/		regs.R7 = regs.R3;
		/* 820C3BCCh case    2:*/		return 0x820C3BD0;
		  /* 820C3BD0h */ case    3:  		/* addi R6, R11, 9784 */
		/* 820C3BD0h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x2638);
		/* 820C3BD0h case    3:*/		return 0x820C3BD4;
		  /* 820C3BD4h */ case    4:  		/* li R5, 3042 */
		/* 820C3BD4h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0xBE2);
		/* 820C3BD4h case    4:*/		return 0x820C3BD8;
		  /* 820C3BD8h */ case    5:  		/* li R4, 0 */
		/* 820C3BD8h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C3BD8h case    5:*/		return 0x820C3BDC;
		  /* 820C3BDCh */ case    6:  		/* mr R3, R30 */
		/* 820C3BDCh case    6:*/		regs.R3 = regs.R30;
		/* 820C3BDCh case    6:*/		return 0x820C3BE0;
		  /* 820C3BE0h */ case    7:  		/* bl -78176 */
		/* 820C3BE0h case    7:*/		regs.LR = 0x820C3BE4; return 0x820B0A80;
		/* 820C3BE0h case    7:*/		return 0x820C3BE4;
		  /* 820C3BE4h */ case    8:  		/* lis R29, -32768 */
		/* 820C3BE4h case    8:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8000);
		/* 820C3BE4h case    8:*/		return 0x820C3BE8;
		  /* 820C3BE8h */ case    9:  		/* ori R29, R29, 16385 */
		/* 820C3BE8h case    9:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R29,0x4001);
		/* 820C3BE8h case    9:*/		return 0x820C3BEC;
		  /* 820C3BECh */ case   10:  		/* stw R29, <#[R31 + 224]> */
		/* 820C3BECh case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x000000E0) );
		/* 820C3BECh case   10:*/		return 0x820C3BF0;
		  /* 820C3BF0h */ case   11:  		/* li R26, 0 */
		/* 820C3BF0h case   11:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820C3BF0h case   11:*/		return 0x820C3BF4;
		  /* 820C3BF4h */ case   12:  		/* lwz R19, <#[R31 + 772]> */
		/* 820C3BF4h case   12:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R31 + 0x00000304) );
		/* 820C3BF4h case   12:*/		return 0x820C3BF8;
		  /* 820C3BF8h */ case   13:  		/* lwz R14, <#[R31 + 220]> */
		/* 820C3BF8h case   13:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R31 + 0x000000DC) );
		/* 820C3BF8h case   13:*/		return 0x820C3BFC;
		  /* 820C3BFCh */ case   14:  		/* lbz R27, <#[R31 + 200]> */
		/* 820C3BFCh case   14:*/		cpu::mem::load8z( regs, &regs.R27, (uint32)(regs.R31 + 0x000000C8) );
		/* 820C3BFCh case   14:*/		return 0x820C3C00;
	}
	return 0x820C3C00;
} // Block from 820C3BC4h-820C3C00h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C3C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3C00);
		  /* 820C3C00h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 820C3C00h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820C3C00h case    0:*/		return 0x820C3C04;
		  /* 820C3C04h */ case    1:  		/* bc 12, CR6_LT, -564 */
		/* 820C3C04h case    1:*/		if ( regs.CR[6].lt ) { return 0x820C39D0;  }
		/* 820C3C04h case    1:*/		return 0x820C3C08;
		  /* 820C3C08h */ case    2:  		/* lwz R28, <#[R31 + 764]> */
		/* 820C3C08h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R31 + 0x000002FC) );
		/* 820C3C08h case    2:*/		return 0x820C3C0C;
		  /* 820C3C0Ch */ case    3:  		/* cmplwi CR6, R28, 0 */
		/* 820C3C0Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C3C0Ch case    3:*/		return 0x820C3C10;
		  /* 820C3C10h */ case    4:  		/* bc 12, CR6_EQ, 76 */
		/* 820C3C10h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C3C5C;  }
		/* 820C3C10h case    4:*/		return 0x820C3C14;
		  /* 820C3C14h */ case    5:  		/* lwz R3, <#[R31 + 192]> */
		/* 820C3C14h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3C14h case    5:*/		return 0x820C3C18;
		  /* 820C3C18h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820C3C18h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3C18h case    6:*/		return 0x820C3C1C;
		  /* 820C3C1Ch */ case    7:  		/* lwz R11, <#[R11 + 12]> */
		/* 820C3C1Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C3C1Ch case    7:*/		return 0x820C3C20;
		  /* 820C3C20h */ case    8:  		/* mtspr CTR, R11 */
		/* 820C3C20h case    8:*/		regs.CTR = regs.R11;
		/* 820C3C20h case    8:*/		return 0x820C3C24;
		  /* 820C3C24h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820C3C24h case    9:*/		if ( 1 ) { regs.LR = 0x820C3C28; return (uint32)regs.CTR; }
		/* 820C3C24h case    9:*/		return 0x820C3C28;
		  /* 820C3C28h */ case   10:  		/* addi R4, R31, 204 */
		/* 820C3C28h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xCC);
		/* 820C3C28h case   10:*/		return 0x820C3C2C;
		  /* 820C3C2Ch */ case   11:  		/* bl -147844 */
		/* 820C3C2Ch case   11:*/		regs.LR = 0x820C3C30; return 0x8209FAA8;
		/* 820C3C2Ch case   11:*/		return 0x820C3C30;
		  /* 820C3C30h */ case   12:  		/* or. R29, R3, R3 */
		/* 820C3C30h case   12:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C3C30h case   12:*/		return 0x820C3C34;
		  /* 820C3C34h */ case   13:  		/* bc 4, CR0_LT, 40 */
		/* 820C3C34h case   13:*/		if ( !regs.CR[0].lt ) { return 0x820C3C5C;  }
		/* 820C3C34h case   13:*/		return 0x820C3C38;
		  /* 820C3C38h */ case   14:  		/* lwz R3, <#[R31 + 192]> */
		/* 820C3C38h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3C38h case   14:*/		return 0x820C3C3C;
		  /* 820C3C3Ch */ case   15:  		/* cmplwi CR6, R3, 0 */
		/* 820C3C3Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3C3Ch case   15:*/		return 0x820C3C40;
		  /* 820C3C40h */ case   16:  		/* bc 12, CR6_EQ, -624 */
		/* 820C3C40h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C39D0;  }
		/* 820C3C40h case   16:*/		return 0x820C3C44;
		  /* 820C3C44h */ case   17:  		/* lwz R11, <#[R3]> */
		/* 820C3C44h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3C44h case   17:*/		return 0x820C3C48;
		  /* 820C3C48h */ case   18:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3C48h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3C48h case   18:*/		return 0x820C3C4C;
		  /* 820C3C4Ch */ case   19:  		/* mtspr CTR, R11 */
		/* 820C3C4Ch case   19:*/		regs.CTR = regs.R11;
		/* 820C3C4Ch case   19:*/		return 0x820C3C50;
		  /* 820C3C50h */ case   20:  		/* bcctrl 20, CR0_LT */
		/* 820C3C50h case   20:*/		if ( 1 ) { regs.LR = 0x820C3C54; return (uint32)regs.CTR; }
		/* 820C3C50h case   20:*/		return 0x820C3C54;
		  /* 820C3C54h */ case   21:  		/* stw R26, <#[R31 + 192]> */
		/* 820C3C54h case   21:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3C54h case   21:*/		return 0x820C3C58;
		  /* 820C3C58h */ case   22:  		/* b -648 */
		/* 820C3C58h case   22:*/		return 0x820C39D0;
		/* 820C3C58h case   22:*/		return 0x820C3C5C;
	}
	return 0x820C3C5C;
} // Block from 820C3C00h-820C3C5Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 820C3C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3C5C);
		  /* 820C3C5Ch */ case    0:  		/* lwz R3, <#[R31 + 192]> */
		/* 820C3C5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3C5Ch case    0:*/		return 0x820C3C60;
		  /* 820C3C60h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 820C3C60h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3C60h case    1:*/		return 0x820C3C64;
		  /* 820C3C64h */ case    2:  		/* lwz R11, <#[R11 + 12]> */
		/* 820C3C64h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C3C64h case    2:*/		return 0x820C3C68;
		  /* 820C3C68h */ case    3:  		/* mtspr CTR, R11 */
		/* 820C3C68h case    3:*/		regs.CTR = regs.R11;
		/* 820C3C68h case    3:*/		return 0x820C3C6C;
		  /* 820C3C6Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820C3C6Ch case    4:*/		if ( 1 ) { regs.LR = 0x820C3C70; return (uint32)regs.CTR; }
		/* 820C3C6Ch case    4:*/		return 0x820C3C70;
		  /* 820C3C70h */ case    5:  		/* lwz R11, <#[R30 + 20]> */
		/* 820C3C70h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C3C70h case    5:*/		return 0x820C3C74;
		  /* 820C3C74h */ case    6:  		/* lwz R10, <#[R3]> */
		/* 820C3C74h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3C74h case    6:*/		return 0x820C3C78;
		  /* 820C3C78h */ case    7:  		/* rlwinm. R9, R11, 0, 11, 11 */
		/* 820C3C78h case    7:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R9,regs.R11);
		/* 820C3C78h case    7:*/		return 0x820C3C7C;
		  /* 820C3C7Ch */ case    8:  		/* rlwinm R11, R10, 0, 0, 15 */
		/* 820C3C7Ch case    8:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R10);
		/* 820C3C7Ch case    8:*/		return 0x820C3C80;
		  /* 820C3C80h */ case    9:  		/* bc 4, CR0_EQ, 344 */
		/* 820C3C80h case    9:*/		if ( !regs.CR[0].eq ) { return 0x820C3DD8;  }
		/* 820C3C80h case    9:*/		return 0x820C3C84;
		  /* 820C3C84h */ case   10:  		/* lis R10, 18008 */
		/* 820C3C84h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0x4658);
		/* 820C3C84h case   10:*/		return 0x820C3C88;
		  /* 820C3C88h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820C3C88h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C3C88h case   11:*/		return 0x820C3C8C;
		  /* 820C3C8Ch */ case   12:  		/* bc 12, CR6_EQ, 332 */
		/* 820C3C8Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820C3DD8;  }
		/* 820C3C8Ch case   12:*/		return 0x820C3C90;
		  /* 820C3C90h */ case   13:  		/* lis R10, 21592 */
		/* 820C3C90h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x5458);
		/* 820C3C90h case   13:*/		return 0x820C3C94;
		  /* 820C3C94h */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 820C3C94h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C3C94h case   14:*/		return 0x820C3C98;
		  /* 820C3C98h */ case   15:  		/* bc 12, CR6_EQ, 320 */
		/* 820C3C98h case   15:*/		if ( regs.CR[6].eq ) { return 0x820C3DD8;  }
		/* 820C3C98h case   15:*/		return 0x820C3C9C;
		  /* 820C3C9Ch */ case   16:  		/* lis R10, -2 */
		/* 820C3C9Ch case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820C3C9Ch case   16:*/		return 0x820C3CA0;
		  /* 820C3CA0h */ case   17:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C3CA0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C3CA0h case   17:*/		return 0x820C3CA4;
		  /* 820C3CA4h */ case   18:  		/* ori R10, R10, 1022 */
		/* 820C3CA4h case   18:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3FE);
		/* 820C3CA4h case   18:*/		return 0x820C3CA8;
		  /* 820C3CA8h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820C3CA8h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C3CA8h case   19:*/		return 0x820C3CAC;
		  /* 820C3CACh */ case   20:  		/* bc 12, CR6_EQ, 300 */
		/* 820C3CACh case   20:*/		if ( regs.CR[6].eq ) { return 0x820C3DD8;  }
		/* 820C3CACh case   20:*/		return 0x820C3CB0;
		  /* 820C3CB0h */ case   21:  		/* lis R10, -2 */
		/* 820C3CB0h case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820C3CB0h case   21:*/		return 0x820C3CB4;
		  /* 820C3CB4h */ case   22:  		/* ori R10, R10, 1021 */
		/* 820C3CB4h case   22:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3FD);
		/* 820C3CB4h case   22:*/		return 0x820C3CB8;
		  /* 820C3CB8h */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 820C3CB8h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C3CB8h case   23:*/		return 0x820C3CBC;
		  /* 820C3CBCh */ case   24:  		/* bc 12, CR6_EQ, 284 */
		/* 820C3CBCh case   24:*/		if ( regs.CR[6].eq ) { return 0x820C3DD8;  }
		/* 820C3CBCh case   24:*/		return 0x820C3CC0;
		  /* 820C3CC0h */ case   25:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 820C3CC0h case   25:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 820C3CC0h case   25:*/		return 0x820C3CC4;
		  /* 820C3CC4h */ case   26:  		/* bc 4, CR0_EQ, 84 */
		/* 820C3CC4h case   26:*/		if ( !regs.CR[0].eq ) { return 0x820C3D18;  }
		/* 820C3CC4h case   26:*/		return 0x820C3CC8;
		  /* 820C3CC8h */ case   27:  		/* lwz R3, <#[R31 + 192]> */
		/* 820C3CC8h case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3CC8h case   27:*/		return 0x820C3CCC;
		  /* 820C3CCCh */ case   28:  		/* cmplwi CR6, R3, 0 */
		/* 820C3CCCh case   28:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3CCCh case   28:*/		return 0x820C3CD0;
		  /* 820C3CD0h */ case   29:  		/* bc 12, CR6_EQ, 24 */
		/* 820C3CD0h case   29:*/		if ( regs.CR[6].eq ) { return 0x820C3CE8;  }
		/* 820C3CD0h case   29:*/		return 0x820C3CD4;
		  /* 820C3CD4h */ case   30:  		/* lwz R11, <#[R3]> */
		/* 820C3CD4h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3CD4h case   30:*/		return 0x820C3CD8;
		  /* 820C3CD8h */ case   31:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3CD8h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3CD8h case   31:*/		return 0x820C3CDC;
		  /* 820C3CDCh */ case   32:  		/* mtspr CTR, R11 */
		/* 820C3CDCh case   32:*/		regs.CTR = regs.R11;
		/* 820C3CDCh case   32:*/		return 0x820C3CE0;
		  /* 820C3CE0h */ case   33:  		/* bcctrl 20, CR0_LT */
		/* 820C3CE0h case   33:*/		if ( 1 ) { regs.LR = 0x820C3CE4; return (uint32)regs.CTR; }
		/* 820C3CE0h case   33:*/		return 0x820C3CE4;
		  /* 820C3CE4h */ case   34:  		/* stw R26, <#[R31 + 192]> */
		/* 820C3CE4h case   34:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3CE4h case   34:*/		return 0x820C3CE8;
	}
	return 0x820C3CE8;
} // Block from 820C3C5Ch-820C3CE8h (35 instructions)

//////////////////////////////////////////////////////
// Block at 820C3CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3CE8);
		  /* 820C3CE8h */ case    0:  		/* lwz R3, <#[R31 + 204]> */
		/* 820C3CE8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000CC) );
		/* 820C3CE8h case    0:*/		return 0x820C3CEC;
		  /* 820C3CECh */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C3CECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3CECh case    1:*/		return 0x820C3CF0;
		  /* 820C3CF0h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820C3CF0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C3D08;  }
		/* 820C3CF0h case    2:*/		return 0x820C3CF4;
		  /* 820C3CF4h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820C3CF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3CF4h case    3:*/		return 0x820C3CF8;
		  /* 820C3CF8h */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3CF8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3CF8h case    4:*/		return 0x820C3CFC;
		  /* 820C3CFCh */ case    5:  		/* mtspr CTR, R11 */
		/* 820C3CFCh case    5:*/		regs.CTR = regs.R11;
		/* 820C3CFCh case    5:*/		return 0x820C3D00;
		  /* 820C3D00h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 820C3D00h case    6:*/		if ( 1 ) { regs.LR = 0x820C3D04; return (uint32)regs.CTR; }
		/* 820C3D00h case    6:*/		return 0x820C3D04;
		  /* 820C3D04h */ case    7:  		/* stw R26, <#[R31 + 204]> */
		/* 820C3D04h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000CC) );
		/* 820C3D04h case    7:*/		return 0x820C3D08;
	}
	return 0x820C3D08;
} // Block from 820C3CE8h-820C3D08h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C3D08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3D08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3D08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3D08);
		  /* 820C3D08h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 820C3D08h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 820C3D08h case    0:*/		return 0x820C3D0C;
		  /* 820C3D0Ch */ case    1:  		/* bc 4, CR6_LT, -420 */
		/* 820C3D0Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x820C3B68;  }
		/* 820C3D0Ch case    1:*/		return 0x820C3D10;
	}
	return 0x820C3D10;
} // Block from 820C3D08h-820C3D10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C3D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3D10);
		  /* 820C3D10h */ case    0:  		/* mr R29, R14 */
		/* 820C3D10h case    0:*/		regs.R29 = regs.R14;
		/* 820C3D10h case    0:*/		return 0x820C3D14;
		  /* 820C3D14h */ case    1:  		/* b -836 */
		/* 820C3D14h case    1:*/		return 0x820C39D0;
		/* 820C3D14h case    1:*/		return 0x820C3D18;
	}
	return 0x820C3D18;
} // Block from 820C3D10h-820C3D18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C3D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3D18);
		  /* 820C3D18h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 820C3D18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C3D18h case    0:*/		return 0x820C3D1C;
		  /* 820C3D1Ch */ case    1:  		/* addi R3, R11, 24 */
		/* 820C3D1Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x18);
		/* 820C3D1Ch case    1:*/		return 0x820C3D20;
		  /* 820C3D20h */ case    2:  		/* bl -122880 */
		/* 820C3D20h case    2:*/		regs.LR = 0x820C3D24; return 0x820A5D20;
		/* 820C3D20h case    2:*/		return 0x820C3D24;
		  /* 820C3D24h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820C3D24h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C3D24h case    3:*/		return 0x820C3D28;
		  /* 820C3D28h */ case    4:  		/* bc 12, CR0_EQ, 40 */
		/* 820C3D28h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C3D50;  }
		/* 820C3D28h case    4:*/		return 0x820C3D2C;
		  /* 820C3D2Ch */ case    5:  		/* lwz R3, <#[R31 + 204]> */
		/* 820C3D2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000CC) );
		/* 820C3D2Ch case    5:*/		return 0x820C3D30;
		  /* 820C3D30h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 820C3D30h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3D30h case    6:*/		return 0x820C3D34;
		  /* 820C3D34h */ case    7:  		/* bc 12, CR6_EQ, -868 */
		/* 820C3D34h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C39D0;  }
		/* 820C3D34h case    7:*/		return 0x820C3D38;
		  /* 820C3D38h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 820C3D38h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3D38h case    8:*/		return 0x820C3D3C;
		  /* 820C3D3Ch */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3D3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3D3Ch case    9:*/		return 0x820C3D40;
		  /* 820C3D40h */ case   10:  		/* mtspr CTR, R11 */
		/* 820C3D40h case   10:*/		regs.CTR = regs.R11;
		/* 820C3D40h case   10:*/		return 0x820C3D44;
		  /* 820C3D44h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820C3D44h case   11:*/		if ( 1 ) { regs.LR = 0x820C3D48; return (uint32)regs.CTR; }
		/* 820C3D44h case   11:*/		return 0x820C3D48;
		  /* 820C3D48h */ case   12:  		/* stw R26, <#[R31 + 204]> */
		/* 820C3D48h case   12:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000CC) );
		/* 820C3D48h case   12:*/		return 0x820C3D4C;
		  /* 820C3D4Ch */ case   13:  		/* b -892 */
		/* 820C3D4Ch case   13:*/		return 0x820C39D0;
		/* 820C3D4Ch case   13:*/		return 0x820C3D50;
	}
	return 0x820C3D50;
} // Block from 820C3D18h-820C3D50h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C3D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3D50);
		  /* 820C3D50h */ case    0:  		/* lwz R3, <#[R31 + 192]> */
		/* 820C3D50h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3D50h case    0:*/		return 0x820C3D54;
		  /* 820C3D54h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 820C3D54h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3D54h case    1:*/		return 0x820C3D58;
		  /* 820C3D58h */ case    2:  		/* lwz R11, <#[R11 + 16]> */
		/* 820C3D58h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 820C3D58h case    2:*/		return 0x820C3D5C;
		  /* 820C3D5Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 820C3D5Ch case    3:*/		regs.CTR = regs.R11;
		/* 820C3D5Ch case    3:*/		return 0x820C3D60;
		  /* 820C3D60h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820C3D60h case    4:*/		if ( 1 ) { regs.LR = 0x820C3D64; return (uint32)regs.CTR; }
		/* 820C3D60h case    4:*/		return 0x820C3D64;
		  /* 820C3D64h */ case    5:  		/* lwz R11, <#[R31 + 192]> */
		/* 820C3D64h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3D64h case    5:*/		return 0x820C3D68;
		  /* 820C3D68h */ case    6:  		/* mr R29, R3 */
		/* 820C3D68h case    6:*/		regs.R29 = regs.R3;
		/* 820C3D68h case    6:*/		return 0x820C3D6C;
		  /* 820C3D6Ch */ case    7:  		/* lwz R10, <#[R11]> */
		/* 820C3D6Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C3D6Ch case    7:*/		return 0x820C3D70;
		  /* 820C3D70h */ case    8:  		/* mr R3, R11 */
		/* 820C3D70h case    8:*/		regs.R3 = regs.R11;
		/* 820C3D70h case    8:*/		return 0x820C3D74;
		  /* 820C3D74h */ case    9:  		/* lwz R11, <#[R10 + 12]> */
		/* 820C3D74h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820C3D74h case    9:*/		return 0x820C3D78;
		  /* 820C3D78h */ case   10:  		/* mtspr CTR, R11 */
		/* 820C3D78h case   10:*/		regs.CTR = regs.R11;
		/* 820C3D78h case   10:*/		return 0x820C3D7C;
		  /* 820C3D7Ch */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820C3D7Ch case   11:*/		if ( 1 ) { regs.LR = 0x820C3D80; return (uint32)regs.CTR; }
		/* 820C3D7Ch case   11:*/		return 0x820C3D80;
		  /* 820C3D80h */ case   12:  		/* lwz R11, <#[R30 + 20]> */
		/* 820C3D80h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C3D80h case   12:*/		return 0x820C3D84;
		  /* 820C3D84h */ case   13:  		/* lis R10, -32245 */
		/* 820C3D84h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF820B);
		/* 820C3D84h case   13:*/		return 0x820C3D88;
		  /* 820C3D88h */ case   14:  		/* lwz R27, <#[R31 + 756]> */
		/* 820C3D88h case   14:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x000002F4) );
		/* 820C3D88h case   14:*/		return 0x820C3D8C;
		  /* 820C3D8Ch */ case   15:  		/* mr R4, R3 */
		/* 820C3D8Ch case   15:*/		regs.R4 = regs.R3;
		/* 820C3D8Ch case   15:*/		return 0x820C3D90;
		  /* 820C3D90h */ case   16:  		/* rlwinm R3, R11, 0, 7, 5 */
		/* 820C3D90h case   16:*/		cpu::op::rlwinm<0,0,7,5>(regs,&regs.R3,regs.R11);
		/* 820C3D90h case   16:*/		return 0x820C3D94;
		  /* 820C3D94h */ case   17:  		/* mr R5, R29 */
		/* 820C3D94h case   17:*/		regs.R5 = regs.R29;
		/* 820C3D94h case   17:*/		return 0x820C3D98;
		  /* 820C3D98h */ case   18:  		/* mr R6, R27 */
		/* 820C3D98h case   18:*/		regs.R6 = regs.R27;
		/* 820C3D98h case   18:*/		return 0x820C3D9C;
		  /* 820C3D9Ch */ case   19:  		/* mr R7, R30 */
		/* 820C3D9Ch case   19:*/		regs.R7 = regs.R30;
		/* 820C3D9Ch case   19:*/		return 0x820C3DA0;
		  /* 820C3DA0h */ case   20:  		/* addi R8, R10, 2520 */
		/* 820C3DA0h case   20:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x9D8);
		/* 820C3DA0h case   20:*/		return 0x820C3DA4;
		  /* 820C3DA4h */ case   21:  		/* mr R9, R19 */
		/* 820C3DA4h case   21:*/		regs.R9 = regs.R19;
		/* 820C3DA4h case   21:*/		return 0x820C3DA8;
		  /* 820C3DA8h */ case   22:  		/* bl -109384 */
		/* 820C3DA8h case   22:*/		regs.LR = 0x820C3DAC; return 0x820A9260;
		/* 820C3DA8h case   22:*/		return 0x820C3DAC;
		  /* 820C3DACh */ case   23:  		/* or. R29, R3, R3 */
		/* 820C3DACh case   23:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820C3DACh case   23:*/		return 0x820C3DB0;
		  /* 820C3DB0h */ case   24:  		/* lwz R3, <#[R31 + 192]> */
		/* 820C3DB0h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3DB0h case   24:*/		return 0x820C3DB4;
		  /* 820C3DB4h */ case   25:  		/* bc 4, CR0_LT, 80 */
		/* 820C3DB4h case   25:*/		if ( !regs.CR[0].lt ) { return 0x820C3E04;  }
		/* 820C3DB4h case   25:*/		return 0x820C3DB8;
		  /* 820C3DB8h */ case   26:  		/* cmplwi CR6, R3, 0 */
		/* 820C3DB8h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3DB8h case   26:*/		return 0x820C3DBC;
		  /* 820C3DBCh */ case   27:  		/* bc 12, CR6_EQ, -144 */
		/* 820C3DBCh case   27:*/		if ( regs.CR[6].eq ) { return 0x820C3D2C;  }
		/* 820C3DBCh case   27:*/		return 0x820C3DC0;
		  /* 820C3DC0h */ case   28:  		/* lwz R11, <#[R3]> */
		/* 820C3DC0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3DC0h case   28:*/		return 0x820C3DC4;
		  /* 820C3DC4h */ case   29:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3DC4h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3DC4h case   29:*/		return 0x820C3DC8;
		  /* 820C3DC8h */ case   30:  		/* mtspr CTR, R11 */
		/* 820C3DC8h case   30:*/		regs.CTR = regs.R11;
		/* 820C3DC8h case   30:*/		return 0x820C3DCC;
		  /* 820C3DCCh */ case   31:  		/* bcctrl 20, CR0_LT */
		/* 820C3DCCh case   31:*/		if ( 1 ) { regs.LR = 0x820C3DD0; return (uint32)regs.CTR; }
		/* 820C3DCCh case   31:*/		return 0x820C3DD0;
		  /* 820C3DD0h */ case   32:  		/* stw R26, <#[R31 + 192]> */
		/* 820C3DD0h case   32:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3DD0h case   32:*/		return 0x820C3DD4;
		  /* 820C3DD4h */ case   33:  		/* b -168 */
		/* 820C3DD4h case   33:*/		return 0x820C3D2C;
		/* 820C3DD4h case   33:*/		return 0x820C3DD8;
	}
	return 0x820C3DD8;
} // Block from 820C3D50h-820C3DD8h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820C3DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3DD8);
		  /* 820C3DD8h */ case    0:  		/* lwz R27, <#[R31 + 756]> */
		/* 820C3DD8h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x000002F4) );
		/* 820C3DD8h case    0:*/		return 0x820C3DDC;
		  /* 820C3DDCh */ case    1:  		/* lwz R3, <#[R27]> */
		/* 820C3DDCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000000) );
		/* 820C3DDCh case    1:*/		return 0x820C3DE0;
		  /* 820C3DE0h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 820C3DE0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3DE0h case    2:*/		return 0x820C3DE4;
		  /* 820C3DE4h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820C3DE4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C3DFC;  }
		/* 820C3DE4h case    3:*/		return 0x820C3DE8;
		  /* 820C3DE8h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820C3DE8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3DE8h case    4:*/		return 0x820C3DEC;
		  /* 820C3DECh */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3DECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3DECh case    5:*/		return 0x820C3DF0;
		  /* 820C3DF0h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C3DF0h case    6:*/		regs.CTR = regs.R11;
		/* 820C3DF0h case    6:*/		return 0x820C3DF4;
		  /* 820C3DF4h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820C3DF4h case    7:*/		if ( 1 ) { regs.LR = 0x820C3DF8; return (uint32)regs.CTR; }
		/* 820C3DF4h case    7:*/		return 0x820C3DF8;
		  /* 820C3DF8h */ case    8:  		/* stw R26, <#[R27]> */
		/* 820C3DF8h case    8:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R27 + 0x00000000) );
		/* 820C3DF8h case    8:*/		return 0x820C3DFC;
	}
	return 0x820C3DFC;
} // Block from 820C3DD8h-820C3DFCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C3DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3DFC);
		  /* 820C3DFCh */ case    0:  		/* lwz R3, <#[R31 + 192]> */
		/* 820C3DFCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3DFCh case    0:*/		return 0x820C3E00;
		  /* 820C3E00h */ case    1:  		/* stw R3, <#[R27]> */
		/* 820C3E00h case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x00000000) );
		/* 820C3E00h case    1:*/		return 0x820C3E04;
	}
	return 0x820C3E04;
} // Block from 820C3DFCh-820C3E04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C3E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3E04);
		  /* 820C3E04h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820C3E04h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C3E04h case    0:*/		return 0x820C3E08;
		  /* 820C3E08h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 820C3E08h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C3E14;  }
		/* 820C3E08h case    1:*/		return 0x820C3E0C;
		  /* 820C3E0Ch */ case    2:  		/* lwz R11, <#[R31 + 204]> */
		/* 820C3E0Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 820C3E0Ch case    2:*/		return 0x820C3E10;
		  /* 820C3E10h */ case    3:  		/* stw R11, <#[R28]> */
		/* 820C3E10h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820C3E10h case    3:*/		return 0x820C3E14;
	}
	return 0x820C3E14;
} // Block from 820C3E04h-820C3E14h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C3E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3E14);
		  /* 820C3E14h */ case    0:  		/* lwz R11, <#[R31 + 196]> */
		/* 820C3E14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C3E14h case    0:*/		return 0x820C3E18;
		  /* 820C3E18h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C3E18h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C3E18h case    1:*/		return 0x820C3E1C;
		  /* 820C3E1Ch */ case    2:  		/* bc 12, CR6_EQ, 212 */
		/* 820C3E1Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C3EF0;  }
		/* 820C3E1Ch case    2:*/		return 0x820C3E20;
		  /* 820C3E20h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 820C3E20h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C3E20h case    3:*/		return 0x820C3E24;
		  /* 820C3E24h */ case    4:  		/* addi R3, R11, 24 */
		/* 820C3E24h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x18);
		/* 820C3E24h case    4:*/		return 0x820C3E28;
		  /* 820C3E28h */ case    5:  		/* bl -123144 */
		/* 820C3E28h case    5:*/		regs.LR = 0x820C3E2C; return 0x820A5D20;
		/* 820C3E28h case    5:*/		return 0x820C3E2C;
		  /* 820C3E2Ch */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820C3E2Ch case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C3E2Ch case    6:*/		return 0x820C3E30;
		  /* 820C3E30h */ case    7:  		/* bc 4, CR0_EQ, -1120 */
		/* 820C3E30h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820C39D0;  }
		/* 820C3E30h case    7:*/		return 0x820C3E34;
		  /* 820C3E34h */ case    8:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C3E34h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C3E34h case    8:*/		return 0x820C3E38;
		  /* 820C3E38h */ case    9:  		/* lis R10, -1 */
		/* 820C3E38h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C3E38h case    9:*/		return 0x820C3E3C;
		  /* 820C3E3Ch */ case   10:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 820C3E3Ch case   10:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 820C3E3Ch case   10:*/		return 0x820C3E40;
		  /* 820C3E40h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820C3E40h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C3E40h case   11:*/		return 0x820C3E44;
		  /* 820C3E44h */ case   12:  		/* li R8, 0 */
		/* 820C3E44h case   12:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C3E44h case   12:*/		return 0x820C3E48;
		  /* 820C3E48h */ case   13:  		/* lwz R4, <#[R31 + 196]> */
		/* 820C3E48h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000000C4) );
		/* 820C3E48h case   13:*/		return 0x820C3E4C;
		  /* 820C3E4Ch */ case   14:  		/* li R7, 0 */
		/* 820C3E4Ch case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C3E4Ch case   14:*/		return 0x820C3E50;
		  /* 820C3E50h */ case   15:  		/* lwz R3, <#[R31 + 192]> */
		/* 820C3E50h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3E50h case   15:*/		return 0x820C3E54;
		  /* 820C3E54h */ case   16:  		/* li R6, 0 */
		/* 820C3E54h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C3E54h case   16:*/		return 0x820C3E58;
		  /* 820C3E58h */ case   17:  		/* li R5, 0 */
		/* 820C3E58h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C3E58h case   17:*/		return 0x820C3E5C;
		  /* 820C3E5Ch */ case   18:  		/* bc 12, CR6_EQ, 12 */
		/* 820C3E5Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x820C3E68;  }
		/* 820C3E5Ch case   18:*/		return 0x820C3E60;
		  /* 820C3E60h */ case   19:  		/* bl 556696 */
		/* 820C3E60h case   19:*/		regs.LR = 0x820C3E64; return 0x8214BCF8;
		/* 820C3E60h case   19:*/		return 0x820C3E64;
		  /* 820C3E64h */ case   20:  		/* b 8 */
		/* 820C3E64h case   20:*/		return 0x820C3E6C;
		/* 820C3E64h case   20:*/		return 0x820C3E68;
	}
	return 0x820C3E68;
} // Block from 820C3E14h-820C3E68h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C3E68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3E68);
		  /* 820C3E68h */ case    0:  		/* bl 556688 */
		/* 820C3E68h case    0:*/		regs.LR = 0x820C3E6C; return 0x8214BCF8;
		/* 820C3E68h case    0:*/		return 0x820C3E6C;
	}
	return 0x820C3E6C;
} // Block from 820C3E68h-820C3E6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C3E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3E6C);
		  /* 820C3E6Ch */ case    0:  		/* mr R29, R3 */
		/* 820C3E6Ch case    0:*/		regs.R29 = regs.R3;
		/* 820C3E6Ch case    0:*/		return 0x820C3E70;
		  /* 820C3E70h */ case    1:  		/* lwz R3, <#[R31 + 192]> */
		/* 820C3E70h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3E70h case    1:*/		return 0x820C3E74;
		  /* 820C3E74h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 820C3E74h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3E74h case    2:*/		return 0x820C3E78;
		  /* 820C3E78h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 820C3E78h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C3E94;  }
		/* 820C3E78h case    3:*/		return 0x820C3E7C;
		  /* 820C3E7Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820C3E7Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3E7Ch case    4:*/		return 0x820C3E80;
		  /* 820C3E80h */ case    5:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3E80h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3E80h case    5:*/		return 0x820C3E84;
		  /* 820C3E84h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C3E84h case    6:*/		regs.CTR = regs.R11;
		/* 820C3E84h case    6:*/		return 0x820C3E88;
		  /* 820C3E88h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820C3E88h case    7:*/		if ( 1 ) { regs.LR = 0x820C3E8C; return (uint32)regs.CTR; }
		/* 820C3E88h case    7:*/		return 0x820C3E8C;
		  /* 820C3E8Ch */ case    8:  		/* mr R3, R26 */
		/* 820C3E8Ch case    8:*/		regs.R3 = regs.R26;
		/* 820C3E8Ch case    8:*/		return 0x820C3E90;
		  /* 820C3E90h */ case    9:  		/* stw R26, <#[R31 + 192]> */
		/* 820C3E90h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3E90h case    9:*/		return 0x820C3E94;
	}
	return 0x820C3E94;
} // Block from 820C3E6Ch-820C3E94h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C3E94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3E94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3E94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3E94);
		  /* 820C3E94h */ case    0:  		/* lwz R11, <#[R31 + 204]> */
		/* 820C3E94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000CC) );
		/* 820C3E94h case    0:*/		return 0x820C3E98;
		  /* 820C3E98h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C3E98h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C3E98h case    1:*/		return 0x820C3E9C;
		  /* 820C3E9Ch */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 820C3E9Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C3EBC;  }
		/* 820C3E9Ch case    2:*/		return 0x820C3EA0;
		  /* 820C3EA0h */ case    3:  		/* lwz R10, <#[R11]> */
		/* 820C3EA0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C3EA0h case    3:*/		return 0x820C3EA4;
		  /* 820C3EA4h */ case    4:  		/* mr R3, R11 */
		/* 820C3EA4h case    4:*/		regs.R3 = regs.R11;
		/* 820C3EA4h case    4:*/		return 0x820C3EA8;
		  /* 820C3EA8h */ case    5:  		/* lwz R11, <#[R10 + 8]> */
		/* 820C3EA8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820C3EA8h case    5:*/		return 0x820C3EAC;
		  /* 820C3EACh */ case    6:  		/* mtspr CTR, R11 */
		/* 820C3EACh case    6:*/		regs.CTR = regs.R11;
		/* 820C3EACh case    6:*/		return 0x820C3EB0;
		  /* 820C3EB0h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820C3EB0h case    7:*/		if ( 1 ) { regs.LR = 0x820C3EB4; return (uint32)regs.CTR; }
		/* 820C3EB0h case    7:*/		return 0x820C3EB4;
		  /* 820C3EB4h */ case    8:  		/* lwz R3, <#[R31 + 192]> */
		/* 820C3EB4h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3EB4h case    8:*/		return 0x820C3EB8;
		  /* 820C3EB8h */ case    9:  		/* stw R26, <#[R31 + 204]> */
		/* 820C3EB8h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000CC) );
		/* 820C3EB8h case    9:*/		return 0x820C3EBC;
	}
	return 0x820C3EBC;
} // Block from 820C3E94h-820C3EBCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C3EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3EBC);
		  /* 820C3EBCh */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 820C3EBCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C3EBCh case    0:*/		return 0x820C3EC0;
		  /* 820C3EC0h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820C3EC0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C3EC8;  }
		/* 820C3EC0h case    1:*/		return 0x820C3EC4;
		  /* 820C3EC4h */ case    2:  		/* stw R26, <#[R28]> */
		/* 820C3EC4h case    2:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R28 + 0x00000000) );
		/* 820C3EC4h case    2:*/		return 0x820C3EC8;
	}
	return 0x820C3EC8;
} // Block from 820C3EBCh-820C3EC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C3EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3EC8);
		  /* 820C3EC8h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 820C3EC8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820C3EC8h case    0:*/		return 0x820C3ECC;
		  /* 820C3ECCh */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 820C3ECCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C3EEC;  }
		/* 820C3ECCh case    1:*/		return 0x820C3ED0;
		  /* 820C3ED0h */ case    2:  		/* lis R11, -32255 */
		/* 820C3ED0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C3ED0h case    2:*/		return 0x820C3ED4;
		  /* 820C3ED4h */ case    3:  		/* li R5, 3042 */
		/* 820C3ED4h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0xBE2);
		/* 820C3ED4h case    3:*/		return 0x820C3ED8;
		  /* 820C3ED8h */ case    4:  		/* addi R6, R11, 9696 */
		/* 820C3ED8h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x25E0);
		/* 820C3ED8h case    4:*/		return 0x820C3EDC;
		  /* 820C3EDCh */ case    5:  		/* li R4, 0 */
		/* 820C3EDCh case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C3EDCh case    5:*/		return 0x820C3EE0;
		  /* 820C3EE0h */ case    6:  		/* mr R3, R30 */
		/* 820C3EE0h case    6:*/		regs.R3 = regs.R30;
		/* 820C3EE0h case    6:*/		return 0x820C3EE4;
		  /* 820C3EE4h */ case    7:  		/* bl -78948 */
		/* 820C3EE4h case    7:*/		regs.LR = 0x820C3EE8; return 0x820B0A80;
		/* 820C3EE4h case    7:*/		return 0x820C3EE8;
		  /* 820C3EE8h */ case    8:  		/* b -896 */
		/* 820C3EE8h case    8:*/		return 0x820C3B68;
		/* 820C3EE8h case    8:*/		return 0x820C3EEC;
	}
	return 0x820C3EEC;
} // Block from 820C3EC8h-820C3EECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C3EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3EEC);
		  /* 820C3EECh */ case    0:  		/* lwz R27, <#[R31 + 756]> */
		/* 820C3EECh case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x000002F4) );
		/* 820C3EECh case    0:*/		return 0x820C3EF0;
	}
	return 0x820C3EF0;
} // Block from 820C3EECh-820C3EF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C3EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3EF0);
		  /* 820C3EF0h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820C3EF0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C3EF0h case    0:*/		return 0x820C3EF4;
		  /* 820C3EF4h */ case    1:  		/* bc 12, CR6_EQ, -1428 */
		/* 820C3EF4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C3960;  }
		/* 820C3EF4h case    1:*/		return 0x820C3EF8;
		  /* 820C3EF8h */ case    2:  		/* lwz R11, <#[R27]> */
		/* 820C3EF8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820C3EF8h case    2:*/		return 0x820C3EFC;
		  /* 820C3EFCh */ case    3:  		/* cmplw CR6, R11, R3 */
		/* 820C3EFCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R3);
		/* 820C3EFCh case    3:*/		return 0x820C3F00;
		  /* 820C3F00h */ case    4:  		/* bc 12, CR6_EQ, -1440 */
		/* 820C3F00h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C3960;  }
		/* 820C3F00h case    4:*/		return 0x820C3F04;
		  /* 820C3F04h */ case    5:  		/* lwz R11, <#[R3]> */
		/* 820C3F04h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C3F04h case    5:*/		return 0x820C3F08;
		  /* 820C3F08h */ case    6:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C3F08h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C3F08h case    6:*/		return 0x820C3F0C;
		  /* 820C3F0Ch */ case    7:  		/* mtspr CTR, R11 */
		/* 820C3F0Ch case    7:*/		regs.CTR = regs.R11;
		/* 820C3F0Ch case    7:*/		return 0x820C3F10;
		  /* 820C3F10h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820C3F10h case    8:*/		if ( 1 ) { regs.LR = 0x820C3F14; return (uint32)regs.CTR; }
		/* 820C3F10h case    8:*/		return 0x820C3F14;
		  /* 820C3F14h */ case    9:  		/* stw R26, <#[R31 + 192]> */
		/* 820C3F14h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R31 + 0x000000C0) );
		/* 820C3F14h case    9:*/		return 0x820C3F18;
		  /* 820C3F18h */ case   10:  		/* b -1464 */
		/* 820C3F18h case   10:*/		return 0x820C3960;
		/* 820C3F18h case   10:*/		return 0x820C3F1C;
	}
	return 0x820C3F1C;
} // Block from 820C3EF0h-820C3F1Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C3F1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3F1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3F1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3F1C);
		  /* 820C3F1Ch */ case    0:  		/* li R3, 1 */
		/* 820C3F1Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820C3F1Ch case    0:*/		return 0x820C3F20;
		  /* 820C3F20h */ case    1:  		/* nop */
		/* 820C3F20h case    1:*/		cpu::op::nop();
		/* 820C3F20h case    1:*/		return 0x820C3F24;
		  /* 820C3F24h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820C3F24h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C3F24h case    2:*/		return 0x820C3F28;
	}
	return 0x820C3F28;
} // Block from 820C3F1Ch-820C3F28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C3F28h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3F28);
		  /* 820C3F28h */ case    0:  		/* mfspr R12, LR */
		/* 820C3F28h case    0:*/		regs.R12 = regs.LR;
		/* 820C3F28h case    0:*/		return 0x820C3F2C;
		  /* 820C3F2Ch */ case    1:  		/* bl -208080 */
		/* 820C3F2Ch case    1:*/		regs.LR = 0x820C3F30; return 0x8209125C;
		/* 820C3F2Ch case    1:*/		return 0x820C3F30;
		  /* 820C3F30h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820C3F30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820C3F30h case    2:*/		return 0x820C3F34;
		  /* 820C3F34h */ case    3:  		/* mr R11, R10 */
		/* 820C3F34h case    3:*/		regs.R11 = regs.R10;
		/* 820C3F34h case    3:*/		return 0x820C3F38;
		  /* 820C3F38h */ case    4:  		/* mr R31, R8 */
		/* 820C3F38h case    4:*/		regs.R31 = regs.R8;
		/* 820C3F38h case    4:*/		return 0x820C3F3C;
		  /* 820C3F3Ch */ case    5:  		/* mr R30, R9 */
		/* 820C3F3Ch case    5:*/		regs.R30 = regs.R9;
		/* 820C3F3Ch case    5:*/		return 0x820C3F40;
		  /* 820C3F40h */ case    6:  		/* li R10, 0 */
		/* 820C3F40h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C3F40h case    6:*/		return 0x820C3F44;
		  /* 820C3F44h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820C3F44h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C3F44h case    7:*/		return 0x820C3F48;
		  /* 820C3F48h */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 820C3F48h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C3F50;  }
		/* 820C3F48h case    8:*/		return 0x820C3F4C;
		  /* 820C3F4Ch */ case    9:  		/* stw R10, <#[R11]> */
		/* 820C3F4Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C3F4Ch case    9:*/		return 0x820C3F50;
	}
	return 0x820C3F50;
} // Block from 820C3F28h-820C3F50h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C3F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3F50);
		  /* 820C3F50h */ case    0:  		/* lwz R8, <#[R1 + 244]> */
		/* 820C3F50h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x000000F4) );
		/* 820C3F50h case    0:*/		return 0x820C3F54;
		  /* 820C3F54h */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 820C3F54h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C3F54h case    1:*/		return 0x820C3F58;
		  /* 820C3F58h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820C3F58h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C3F60;  }
		/* 820C3F58h case    2:*/		return 0x820C3F5C;
		  /* 820C3F5Ch */ case    3:  		/* stw R10, <#[R8]> */
		/* 820C3F5Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 820C3F5Ch case    3:*/		return 0x820C3F60;
	}
	return 0x820C3F60;
} // Block from 820C3F50h-820C3F60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C3F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3F60);
		  /* 820C3F60h */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 820C3F60h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820C3F60h case    0:*/		return 0x820C3F64;
		  /* 820C3F64h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820C3F64h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C3F74;  }
		/* 820C3F64h case    1:*/		return 0x820C3F68;
		  /* 820C3F68h */ case    2:  		/* lis R3, -30602 */
		/* 820C3F68h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820C3F68h case    2:*/		return 0x820C3F6C;
		  /* 820C3F6Ch */ case    3:  		/* ori R3, R3, 2156 */
		/* 820C3F6Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 820C3F6Ch case    3:*/		return 0x820C3F70;
		  /* 820C3F70h */ case    4:  		/* b 48 */
		/* 820C3F70h case    4:*/		return 0x820C3FA0;
		/* 820C3F70h case    4:*/		return 0x820C3F74;
	}
	return 0x820C3F74;
} // Block from 820C3F60h-820C3F74h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C3F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3F74);
		  /* 820C3F74h */ case    0:  		/* lwz R29, <#[R1 + 252]> */
		/* 820C3F74h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000FC) );
		/* 820C3F74h case    0:*/		return 0x820C3F78;
		  /* 820C3F78h */ case    1:  		/* mr R10, R7 */
		/* 820C3F78h case    1:*/		regs.R10 = regs.R7;
		/* 820C3F78h case    1:*/		return 0x820C3F7C;
		  /* 820C3F7Ch */ case    2:  		/* stw R8, <#[R1 + 108]> */
		/* 820C3F7Ch case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000006C) );
		/* 820C3F7Ch case    2:*/		return 0x820C3F80;
		  /* 820C3F80h */ case    3:  		/* li R9, 0 */
		/* 820C3F80h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C3F80h case    3:*/		return 0x820C3F84;
		  /* 820C3F84h */ case    4:  		/* li R8, 0 */
		/* 820C3F84h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C3F84h case    4:*/		return 0x820C3F88;
		  /* 820C3F88h */ case    5:  		/* stw R11, <#[R1 + 100]> */
		/* 820C3F88h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 820C3F88h case    5:*/		return 0x820C3F8C;
		  /* 820C3F8Ch */ case    6:  		/* li R7, 0 */
		/* 820C3F8Ch case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C3F8Ch case    6:*/		return 0x820C3F90;
		  /* 820C3F90h */ case    7:  		/* stw R30, <#[R1 + 92]> */
		/* 820C3F90h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 820C3F90h case    7:*/		return 0x820C3F94;
		  /* 820C3F94h */ case    8:  		/* stw R31, <#[R1 + 84]> */
		/* 820C3F94h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 820C3F94h case    8:*/		return 0x820C3F98;
		  /* 820C3F98h */ case    9:  		/* stw R29, <#[R1 + 116]> */
		/* 820C3F98h case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000074) );
		/* 820C3F98h case    9:*/		return 0x820C3F9C;
		  /* 820C3F9Ch */ case   10:  		/* bl -4052 */
		/* 820C3F9Ch case   10:*/		regs.LR = 0x820C3FA0; return 0x820C2FC8;
		/* 820C3F9Ch case   10:*/		return 0x820C3FA0;
	}
	return 0x820C3FA0;
} // Block from 820C3F74h-820C3FA0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C3FA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3FA0);
		  /* 820C3FA0h */ case    0:  		/* addi R1, R1, 160 */
		/* 820C3FA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820C3FA0h case    0:*/		return 0x820C3FA4;
		  /* 820C3FA4h */ case    1:  		/* b -208120 */
		/* 820C3FA4h case    1:*/		return 0x820912AC;
		/* 820C3FA4h case    1:*/		return 0x820C3FA8;
	}
	return 0x820C3FA8;
} // Block from 820C3FA0h-820C3FA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C3FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C3FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C3FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C3FA8);
		  /* 820C3FA8h */ case    0:  		/* mfspr R12, LR */
		/* 820C3FA8h case    0:*/		regs.R12 = regs.LR;
		/* 820C3FA8h case    0:*/		return 0x820C3FAC;
		  /* 820C3FACh */ case    1:  		/* bl -208228 */
		/* 820C3FACh case    1:*/		regs.LR = 0x820C3FB0; return 0x82091248;
		/* 820C3FACh case    1:*/		return 0x820C3FB0;
		  /* 820C3FB0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 820C3FB0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 820C3FB0h case    2:*/		return 0x820C3FB4;
		  /* 820C3FB4h */ case    3:  		/* lhz R11, <#[R5 + 10]> */
		/* 820C3FB4h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000000A) );
		/* 820C3FB4h case    3:*/		return 0x820C3FB8;
		  /* 820C3FB8h */ case    4:  		/* mr R29, R3 */
		/* 820C3FB8h case    4:*/		regs.R29 = regs.R3;
		/* 820C3FB8h case    4:*/		return 0x820C3FBC;
		  /* 820C3FBCh */ case    5:  		/* mr R25, R4 */
		/* 820C3FBCh case    5:*/		regs.R25 = regs.R4;
		/* 820C3FBCh case    5:*/		return 0x820C3FC0;
		  /* 820C3FC0h */ case    6:  		/* mr R31, R5 */
		/* 820C3FC0h case    6:*/		regs.R31 = regs.R5;
		/* 820C3FC0h case    6:*/		return 0x820C3FC4;
		  /* 820C3FC4h */ case    7:  		/* mr R28, R6 */
		/* 820C3FC4h case    7:*/		regs.R28 = regs.R6;
		/* 820C3FC4h case    7:*/		return 0x820C3FC8;
		  /* 820C3FC8h */ case    8:  		/* mr R30, R7 */
		/* 820C3FC8h case    8:*/		regs.R30 = regs.R7;
		/* 820C3FC8h case    8:*/		return 0x820C3FCC;
		  /* 820C3FCCh */ case    9:  		/* mr R24, R8 */
		/* 820C3FCCh case    9:*/		regs.R24 = regs.R8;
		/* 820C3FCCh case    9:*/		return 0x820C3FD0;
		  /* 820C3FD0h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 820C3FD0h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C3FD0h case   10:*/		return 0x820C3FD4;
		  /* 820C3FD4h */ case   11:  		/* bc 12, CR0_EQ, 104 */
		/* 820C3FD4h case   11:*/		if ( regs.CR[0].eq ) { return 0x820C403C;  }
		/* 820C3FD4h case   11:*/		return 0x820C3FD8;
		  /* 820C3FD8h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 820C3FD8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C3FD8h case   12:*/		return 0x820C3FDC;
		  /* 820C3FDCh */ case   13:  		/* lwz R10, <#[R5 + 12]> */
		/* 820C3FDCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x0000000C) );
		/* 820C3FDCh case   13:*/		return 0x820C3FE0;
		  /* 820C3FE0h */ case   14:  		/* lwz R11, <#[R3 + 8]> */
		/* 820C3FE0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C3FE0h case   14:*/		return 0x820C3FE4;
		  /* 820C3FE4h */ case   15:  		/* li R27, 0 */
		/* 820C3FE4h case   15:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820C3FE4h case   15:*/		return 0x820C3FE8;
		  /* 820C3FE8h */ case   16:  		/* add R11, R10, R11 */
		/* 820C3FE8h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C3FE8h case   16:*/		return 0x820C3FEC;
		  /* 820C3FECh */ case   17:  		/* bc 12, CR6_EQ, 192 */
		/* 820C3FECh case   17:*/		if ( regs.CR[6].eq ) { return 0x820C40AC;  }
		/* 820C3FECh case   17:*/		return 0x820C3FF0;
		  /* 820C3FF0h */ case   18:  		/* addi R26, R11, 4 */
		/* 820C3FF0h case   18:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x4);
		/* 820C3FF0h case   18:*/		return 0x820C3FF4;
		  /* 820C3FF4h */ case   19:  		/* lwz R10, <#[R26]> */
		/* 820C3FF4h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820C3FF4h case   19:*/		return 0x820C3FF8;
		  /* 820C3FF8h */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 820C3FF8h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C3FF8h case   20:*/		return 0x820C3FFC;
		  /* 820C3FFCh */ case   21:  		/* bc 12, CR6_EQ, 40 */
		/* 820C3FFCh case   21:*/		if ( regs.CR[6].eq ) { return 0x820C4024;  }
		/* 820C3FFCh case   21:*/		return 0x820C4000;
		  /* 820C4000h */ case   22:  		/* lwz R11, <#[R29 + 8]> */
		/* 820C4000h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820C4000h case   22:*/		return 0x820C4004;
		  /* 820C4004h */ case   23:  		/* mr R8, R24 */
		/* 820C4004h case   23:*/		regs.R8 = regs.R24;
		/* 820C4004h case   23:*/		return 0x820C4008;
		  /* 820C4008h */ case   24:  		/* mr R7, R30 */
		/* 820C4008h case   24:*/		regs.R7 = regs.R30;
		/* 820C4008h case   24:*/		return 0x820C400C;
		  /* 820C400Ch */ case   25:  		/* add R5, R10, R11 */
		/* 820C400Ch case   25:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 820C400Ch case   25:*/		return 0x820C4010;
		  /* 820C4010h */ case   26:  		/* mr R4, R25 */
		/* 820C4010h case   26:*/		regs.R4 = regs.R25;
		/* 820C4010h case   26:*/		return 0x820C4014;
		  /* 820C4014h */ case   27:  		/* mr R3, R29 */
		/* 820C4014h case   27:*/		regs.R3 = regs.R29;
		/* 820C4014h case   27:*/		return 0x820C4018;
		  /* 820C4018h */ case   28:  		/* lhz R11, <#[R5 + 8]> */
		/* 820C4018h case   28:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 820C4018h case   28:*/		return 0x820C401C;
		  /* 820C401Ch */ case   29:  		/* mullw R6, R11, R28 */
		/* 820C401Ch case   29:*/		cpu::op::mullw<0>(regs,&regs.R6,regs.R11,regs.R28);
		/* 820C401Ch case   29:*/		return 0x820C4020;
		  /* 820C4020h */ case   30:  		/* bl -120 */
		/* 820C4020h case   30:*/		regs.LR = 0x820C4024; return 0x820C3FA8;
		/* 820C4020h case   30:*/		return 0x820C4024;
	}
	return 0x820C4024;
} // Block from 820C3FA8h-820C4024h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820C4024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4024);
		  /* 820C4024h */ case    0:  		/* lhz R11, <#[R31 + 10]> */
		/* 820C4024h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000A) );
		/* 820C4024h case    0:*/		return 0x820C4028;
		  /* 820C4028h */ case    1:  		/* addi R27, R27, 1 */
		/* 820C4028h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820C4028h case    1:*/		return 0x820C402C;
		  /* 820C402Ch */ case    2:  		/* addi R26, R26, 8 */
		/* 820C402Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x8);
		/* 820C402Ch case    2:*/		return 0x820C4030;
		  /* 820C4030h */ case    3:  		/* cmplw CR6, R27, R11 */
		/* 820C4030h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820C4030h case    3:*/		return 0x820C4034;
		  /* 820C4034h */ case    4:  		/* bc 12, CR6_LT, -64 */
		/* 820C4034h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C3FF4;  }
		/* 820C4034h case    4:*/		return 0x820C4038;
		  /* 820C4038h */ case    5:  		/* b 116 */
		/* 820C4038h case    5:*/		return 0x820C40AC;
		/* 820C4038h case    5:*/		return 0x820C403C;
	}
	return 0x820C403C;
} // Block from 820C4024h-820C403Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C403Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C403C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C403C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C403C);
		  /* 820C403Ch */ case    0:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C403Ch case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C403Ch case    0:*/		return 0x820C4040;
		  /* 820C4040h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 820C4040h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C4040h case    1:*/		return 0x820C4044;
		  /* 820C4044h */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 820C4044h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820C4054;  }
		/* 820C4044h case    2:*/		return 0x820C4048;
		  /* 820C4048h */ case    3:  		/* lhz R11, <#[R31 + 6]> */
		/* 820C4048h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000006) );
		/* 820C4048h case    3:*/		return 0x820C404C;
		  /* 820C404Ch */ case    4:  		/* lhz R9, <#[R31 + 4]> */
		/* 820C404Ch case    4:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 820C404Ch case    4:*/		return 0x820C4050;
		  /* 820C4050h */ case    5:  		/* b 44 */
		/* 820C4050h case    5:*/		return 0x820C407C;
		/* 820C4050h case    5:*/		return 0x820C4054;
	}
	return 0x820C4054;
} // Block from 820C403Ch-820C4054h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C4054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4054);
		  /* 820C4054h */ case    0:  		/* lhz R11, <#[R31]> */
		/* 820C4054h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C4054h case    0:*/		return 0x820C4058;
		  /* 820C4058h */ case    1:  		/* cmplwi CR6, R11, 3 */
		/* 820C4058h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C4058h case    1:*/		return 0x820C405C;
		  /* 820C405Ch */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820C405Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C406C;  }
		/* 820C405Ch case    2:*/		return 0x820C4060;
		  /* 820C4060h */ case    3:  		/* lhz R11, <#[R31 + 6]> */
		/* 820C4060h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000006) );
		/* 820C4060h case    3:*/		return 0x820C4064;
		  /* 820C4064h */ case    4:  		/* lhz R9, <#[R31 + 4]> */
		/* 820C4064h case    4:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 820C4064h case    4:*/		return 0x820C4068;
		  /* 820C4068h */ case    5:  		/* b 12 */
		/* 820C4068h case    5:*/		return 0x820C4074;
		/* 820C4068h case    5:*/		return 0x820C406C;
	}
	return 0x820C406C;
} // Block from 820C4054h-820C406Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C406Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C406C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C406C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C406C);
		  /* 820C406Ch */ case    0:  		/* lhz R11, <#[R31 + 4]> */
		/* 820C406Ch case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820C406Ch case    0:*/		return 0x820C4070;
		  /* 820C4070h */ case    1:  		/* lhz R9, <#[R31 + 6]> */
		/* 820C4070h case    1:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000006) );
		/* 820C4070h case    1:*/		return 0x820C4074;
	}
	return 0x820C4074;
} // Block from 820C406Ch-820C4074h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C4074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4074);
		  /* 820C4074h */ case    0:  		/* addi R11, R11, 3 */
		/* 820C4074h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820C4074h case    0:*/		return 0x820C4078;
		  /* 820C4078h */ case    1:  		/* srawi R11, R11, 2 */
		/* 820C4078h case    1:*/		cpu::op::srawi<0,2>(regs,&regs.R11,regs.R11);
		/* 820C4078h case    1:*/		return 0x820C407C;
	}
	return 0x820C407C;
} // Block from 820C4074h-820C407Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C407Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C407C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C407C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C407C);
		  /* 820C407Ch */ case    0:  		/* mullw R11, R11, R9 */
		/* 820C407Ch case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820C407Ch case    0:*/		return 0x820C4080;
		  /* 820C4080h */ case    1:  		/* lwz R10, <#[R30]> */
		/* 820C4080h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820C4080h case    1:*/		return 0x820C4084;
		  /* 820C4084h */ case    2:  		/* mullw R11, R11, R28 */
		/* 820C4084h case    2:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 820C4084h case    2:*/		return 0x820C4088;
		  /* 820C4088h */ case    3:  		/* add R11, R11, R10 */
		/* 820C4088h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C4088h case    3:*/		return 0x820C408C;
		  /* 820C408Ch */ case    4:  		/* stw R11, <#[R30]> */
		/* 820C408Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C408Ch case    4:*/		return 0x820C4090;
		  /* 820C4090h */ case    5:  		/* lwz R10, <#[R24]> */
		/* 820C4090h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 820C4090h case    5:*/		return 0x820C4094;
		  /* 820C4094h */ case    6:  		/* lhz R11, <#[R31 + 6]> */
		/* 820C4094h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000006) );
		/* 820C4094h case    6:*/		return 0x820C4098;
		  /* 820C4098h */ case    7:  		/* lhz R9, <#[R31 + 4]> */
		/* 820C4098h case    7:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 820C4098h case    7:*/		return 0x820C409C;
		  /* 820C409Ch */ case    8:  		/* mullw R11, R11, R9 */
		/* 820C409Ch case    8:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820C409Ch case    8:*/		return 0x820C40A0;
		  /* 820C40A0h */ case    9:  		/* mullw R11, R11, R28 */
		/* 820C40A0h case    9:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 820C40A0h case    9:*/		return 0x820C40A4;
		  /* 820C40A4h */ case   10:  		/* add R11, R11, R10 */
		/* 820C40A4h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C40A4h case   10:*/		return 0x820C40A8;
		  /* 820C40A8h */ case   11:  		/* stw R11, <#[R24]> */
		/* 820C40A8h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 820C40A8h case   11:*/		return 0x820C40AC;
	}
	return 0x820C40AC;
} // Block from 820C407Ch-820C40ACh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C40ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C40AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C40AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C40AC);
		  /* 820C40ACh */ case    0:  		/* addi R1, R1, 160 */
		/* 820C40ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 820C40ACh case    0:*/		return 0x820C40B0;
		  /* 820C40B0h */ case    1:  		/* b -208408 */
		/* 820C40B0h case    1:*/		return 0x82091298;
		/* 820C40B0h case    1:*/		return 0x820C40B4;
		  /* 820C40B4h */ case    2:  		/* nop */
		/* 820C40B4h case    2:*/		cpu::op::nop();
		/* 820C40B4h case    2:*/		return 0x820C40B8;
	}
	return 0x820C40B8;
} // Block from 820C40ACh-820C40B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C40B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C40B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C40B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C40B8);
		  /* 820C40B8h */ case    0:  		/* mfspr R12, LR */
		/* 820C40B8h case    0:*/		regs.R12 = regs.LR;
		/* 820C40B8h case    0:*/		return 0x820C40BC;
		  /* 820C40BCh */ case    1:  		/* bl -208480 */
		/* 820C40BCh case    1:*/		regs.LR = 0x820C40C0; return 0x8209125C;
		/* 820C40BCh case    1:*/		return 0x820C40C0;
		  /* 820C40C0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C40C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C40C0h case    2:*/		return 0x820C40C4;
		  /* 820C40C4h */ case    3:  		/* mr R31, R3 */
		/* 820C40C4h case    3:*/		regs.R31 = regs.R3;
		/* 820C40C4h case    3:*/		return 0x820C40C8;
		  /* 820C40C8h */ case    4:  		/* li R11, 5 */
		/* 820C40C8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820C40C8h case    4:*/		return 0x820C40CC;
		  /* 820C40CCh */ case    5:  		/* mr R3, R4 */
		/* 820C40CCh case    5:*/		regs.R3 = regs.R4;
		/* 820C40CCh case    5:*/		return 0x820C40D0;
		  /* 820C40D0h */ case    6:  		/* mr R4, R5 */
		/* 820C40D0h case    6:*/		regs.R4 = regs.R5;
		/* 820C40D0h case    6:*/		return 0x820C40D4;
		  /* 820C40D4h */ case    7:  		/* mr R29, R6 */
		/* 820C40D4h case    7:*/		regs.R29 = regs.R6;
		/* 820C40D4h case    7:*/		return 0x820C40D8;
		  /* 820C40D8h */ case    8:  		/* stw R3, <#[R31]> */
		/* 820C40D8h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820C40D8h case    8:*/		return 0x820C40DC;
		  /* 820C40DCh */ case    9:  		/* mr R9, R31 */
		/* 820C40DCh case    9:*/		regs.R9 = regs.R31;
		/* 820C40DCh case    9:*/		return 0x820C40E0;
		  /* 820C40E0h */ case   10:  		/* addi R10, R5, -4 */
		/* 820C40E0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0xFFFFFFFC);
		/* 820C40E0h case   10:*/		return 0x820C40E4;
		  /* 820C40E4h */ case   11:  		/* mtspr CTR, R11 */
		/* 820C40E4h case   11:*/		regs.CTR = regs.R11;
		/* 820C40E4h case   11:*/		return 0x820C40E8;
		  /* 820C40E8h */ case   12:  		/* lwzu R11, <#[R10 + 4]> */
		/* 820C40E8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C40E8h case   12:*/		return 0x820C40EC;
		  /* 820C40ECh */ case   13:  		/* stwu R11, <#[R9 + 4]> */
		/* 820C40ECh case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C40ECh case   13:*/		return 0x820C40F0;
		  /* 820C40F0h */ case   14:  		/* bc 16, CR0_LT, -8 */
		/* 820C40F0h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C40E8;  }
		/* 820C40F0h case   14:*/		return 0x820C40F4;
		  /* 820C40F4h */ case   15:  		/* li R30, 0 */
		/* 820C40F4h case   15:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C40F4h case   15:*/		return 0x820C40F8;
		  /* 820C40F8h */ case   16:  		/* stw R7, <#[R31 + 28]> */
		/* 820C40F8h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x0000001C) );
		/* 820C40F8h case   16:*/		return 0x820C40FC;
		  /* 820C40FCh */ case   17:  		/* stw R8, <#[R31 + 32]> */
		/* 820C40FCh case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000020) );
		/* 820C40FCh case   17:*/		return 0x820C4100;
		  /* 820C4100h */ case   18:  		/* addi R7, R31, 44 */
		/* 820C4100h case   18:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R31,0x2C);
		/* 820C4100h case   18:*/		return 0x820C4104;
		  /* 820C4104h */ case   19:  		/* stw R29, <#[R31 + 24]> */
		/* 820C4104h case   19:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000018) );
		/* 820C4104h case   19:*/		return 0x820C4108;
		  /* 820C4108h */ case   20:  		/* addi R8, R31, 52 */
		/* 820C4108h case   20:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x34);
		/* 820C4108h case   20:*/		return 0x820C410C;
		  /* 820C410Ch */ case   21:  		/* stw R30, <#[R31 + 36]> */
		/* 820C410Ch case   21:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000024) );
		/* 820C410Ch case   21:*/		return 0x820C4110;
		  /* 820C4110h */ case   22:  		/* li R6, 1 */
		/* 820C4110h case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820C4110h case   22:*/		return 0x820C4114;
		  /* 820C4114h */ case   23:  		/* stw R30, <#[R31 + 44]> */
		/* 820C4114h case   23:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000002C) );
		/* 820C4114h case   23:*/		return 0x820C4118;
		  /* 820C4118h */ case   24:  		/* mr R5, R29 */
		/* 820C4118h case   24:*/		regs.R5 = regs.R29;
		/* 820C4118h case   24:*/		return 0x820C411C;
		  /* 820C411Ch */ case   25:  		/* stw R30, <#[R31 + 52]> */
		/* 820C411Ch case   25:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000034) );
		/* 820C411Ch case   25:*/		return 0x820C4120;
		  /* 820C4120h */ case   26:  		/* bl -376 */
		/* 820C4120h case   26:*/		regs.LR = 0x820C4124; return 0x820C3FA8;
		/* 820C4120h case   26:*/		return 0x820C4124;
		  /* 820C4124h */ case   27:  		/* lhz R11, <#[R29 + 8]> */
		/* 820C4124h case   27:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820C4124h case   27:*/		return 0x820C4128;
		  /* 820C4128h */ case   28:  		/* lwz R10, <#[R31 + 44]> */
		/* 820C4128h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000002C) );
		/* 820C4128h case   28:*/		return 0x820C412C;
		  /* 820C412Ch */ case   29:  		/* mr R3, R31 */
		/* 820C412Ch case   29:*/		regs.R3 = regs.R31;
		/* 820C412Ch case   29:*/		return 0x820C4130;
		  /* 820C4130h */ case   30:  		/* lwz R9, <#[R31 + 52]> */
		/* 820C4130h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000034) );
		/* 820C4130h case   30:*/		return 0x820C4134;
		  /* 820C4134h */ case   31:  		/* mullw R11, R11, R10 */
		/* 820C4134h case   31:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C4134h case   31:*/		return 0x820C4138;
		  /* 820C4138h */ case   32:  		/* stw R11, <#[R31 + 40]> */
		/* 820C4138h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820C4138h case   32:*/		return 0x820C413C;
		  /* 820C413Ch */ case   33:  		/* lhz R11, <#[R29 + 8]> */
		/* 820C413Ch case   33:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 820C413Ch case   33:*/		return 0x820C4140;
		  /* 820C4140h */ case   34:  		/* mullw R11, R11, R9 */
		/* 820C4140h case   34:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820C4140h case   34:*/		return 0x820C4144;
		  /* 820C4144h */ case   35:  		/* stw R30, <#[R31 + 56]> */
		/* 820C4144h case   35:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000038) );
		/* 820C4144h case   35:*/		return 0x820C4148;
		  /* 820C4148h */ case   36:  		/* stw R30, <#[R31 + 60]> */
		/* 820C4148h case   36:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C4148h case   36:*/		return 0x820C414C;
		  /* 820C414Ch */ case   37:  		/* stw R30, <#[R31 + 64]> */
		/* 820C414Ch case   37:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000040) );
		/* 820C414Ch case   37:*/		return 0x820C4150;
		  /* 820C4150h */ case   38:  		/* stw R11, <#[R31 + 48]> */
		/* 820C4150h case   38:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820C4150h case   38:*/		return 0x820C4154;
		  /* 820C4154h */ case   39:  		/* addi R1, R1, 112 */
		/* 820C4154h case   39:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C4154h case   39:*/		return 0x820C4158;
		  /* 820C4158h */ case   40:  		/* b -208556 */
		/* 820C4158h case   40:*/		return 0x820912AC;
		/* 820C4158h case   40:*/		return 0x820C415C;
		  /* 820C415Ch */ case   41:  		/* nop */
		/* 820C415Ch case   41:*/		cpu::op::nop();
		/* 820C415Ch case   41:*/		return 0x820C4160;
	}
	return 0x820C4160;
} // Block from 820C40B8h-820C4160h (42 instructions)

//////////////////////////////////////////////////////
// Block at 820C4160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4160);
		  /* 820C4160h */ case    0:  		/* mfspr R12, LR */
		/* 820C4160h case    0:*/		regs.R12 = regs.LR;
		/* 820C4160h case    0:*/		return 0x820C4164;
		  /* 820C4164h */ case    1:  		/* bl -208652 */
		/* 820C4164h case    1:*/		regs.LR = 0x820C4168; return 0x82091258;
		/* 820C4164h case    1:*/		return 0x820C4168;
		  /* 820C4168h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C4168h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C4168h case    2:*/		return 0x820C416C;
		  /* 820C416Ch */ case    3:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C416Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C416Ch case    3:*/		return 0x820C4170;
		  /* 820C4170h */ case    4:  		/* mr R30, R3 */
		/* 820C4170h case    4:*/		regs.R30 = regs.R3;
		/* 820C4170h case    4:*/		return 0x820C4174;
		  /* 820C4174h */ case    5:  		/* stw R4, <#[R3 + 32]> */
		/* 820C4174h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000020) );
		/* 820C4174h case    5:*/		return 0x820C4178;
		  /* 820C4178h */ case    6:  		/* mr R29, R4 */
		/* 820C4178h case    6:*/		regs.R29 = regs.R4;
		/* 820C4178h case    6:*/		return 0x820C417C;
		  /* 820C417Ch */ case    7:  		/* li R28, 0 */
		/* 820C417Ch case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820C417Ch case    7:*/		return 0x820C4180;
		  /* 820C4180h */ case    8:  		/* lhz R11, <#[R11 + 10]> */
		/* 820C4180h case    8:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000A) );
		/* 820C4180h case    8:*/		return 0x820C4184;
		  /* 820C4184h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 820C4184h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C4184h case    9:*/		return 0x820C4188;
		  /* 820C4188h */ case   10:  		/* bc 12, CR0_EQ, 108 */
		/* 820C4188h case   10:*/		if ( regs.CR[0].eq ) { return 0x820C41F4;  }
		/* 820C4188h case   10:*/		return 0x820C418C;
		  /* 820C418Ch */ case   11:  		/* lwz R11, <#[R3 + 56]> */
		/* 820C418Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820C418Ch case   11:*/		return 0x820C4190;
		  /* 820C4190h */ case   12:  		/* li R31, 0 */
		/* 820C4190h case   12:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C4190h case   12:*/		return 0x820C4194;
		  /* 820C4194h */ case   13:  		/* mr R4, R29 */
		/* 820C4194h case   13:*/		regs.R4 = regs.R29;
		/* 820C4194h case   13:*/		return 0x820C4198;
		  /* 820C4198h */ case   14:  		/* lwzx R3, <#[R31 + R11]> */
		/* 820C4198h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820C4198h case   14:*/		return 0x820C419C;
		  /* 820C419Ch */ case   15:  		/* bl -60 */
		/* 820C419Ch case   15:*/		regs.LR = 0x820C41A0; return 0x820C4160;
		/* 820C419Ch case   15:*/		return 0x820C41A0;
		  /* 820C41A0h */ case   16:  		/* lwz R11, <#[R30 + 56]> */
		/* 820C41A0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000038) );
		/* 820C41A0h case   16:*/		return 0x820C41A4;
		  /* 820C41A4h */ case   17:  		/* lwzx R10, <#[R31 + R11]> */
		/* 820C41A4h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820C41A4h case   17:*/		return 0x820C41A8;
		  /* 820C41A8h */ case   18:  		/* lhz R10, <#[R10 + 8]> */
		/* 820C41A8h case   18:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820C41A8h case   18:*/		return 0x820C41AC;
		  /* 820C41ACh */ case   19:  		/* cmplwi CR0, R10, 0 */
		/* 820C41ACh case   19:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820C41ACh case   19:*/		return 0x820C41B0;
		  /* 820C41B0h */ case   20:  		/* li R10, 1 */
		/* 820C41B0h case   20:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820C41B0h case   20:*/		return 0x820C41B4;
		  /* 820C41B4h */ case   21:  		/* bc 12, CR0_EQ, 8 */
		/* 820C41B4h case   21:*/		if ( regs.CR[0].eq ) { return 0x820C41BC;  }
		/* 820C41B4h case   21:*/		return 0x820C41B8;
		  /* 820C41B8h */ case   22:  		/* li R10, 4 */
		/* 820C41B8h case   22:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820C41B8h case   22:*/		return 0x820C41BC;
	}
	return 0x820C41BC;
} // Block from 820C4160h-820C41BCh (23 instructions)

//////////////////////////////////////////////////////
// Block at 820C41BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C41BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C41BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C41BC);
		  /* 820C41BCh */ case    0:  		/* lwzx R9, <#[R31 + R11]> */
		/* 820C41BCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + regs.R11 + 0x00000000) );
		/* 820C41BCh case    0:*/		return 0x820C41C0;
		  /* 820C41C0h */ case    1:  		/* addi R28, R28, 1 */
		/* 820C41C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820C41C0h case    1:*/		return 0x820C41C4;
		  /* 820C41C4h */ case    2:  		/* lwz R8, <#[R30 + 24]> */
		/* 820C41C4h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000018) );
		/* 820C41C4h case    2:*/		return 0x820C41C8;
		  /* 820C41C8h */ case    3:  		/* addi R31, R31, 4 */
		/* 820C41C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820C41C8h case    3:*/		return 0x820C41CC;
		  /* 820C41CCh */ case    4:  		/* lwz R7, <#[R9 + 24]> */
		/* 820C41CCh case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000018) );
		/* 820C41CCh case    4:*/		return 0x820C41D0;
		  /* 820C41D0h */ case    5:  		/* lhz R8, <#[R8 + 10]> */
		/* 820C41D0h case    5:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000A) );
		/* 820C41D0h case    5:*/		return 0x820C41D4;
		  /* 820C41D4h */ case    6:  		/* lwz R9, <#[R9 + 44]> */
		/* 820C41D4h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000002C) );
		/* 820C41D4h case    6:*/		return 0x820C41D8;
		  /* 820C41D8h */ case    7:  		/* cmplw CR6, R28, R8 */
		/* 820C41D8h case    7:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R8);
		/* 820C41D8h case    7:*/		return 0x820C41DC;
		  /* 820C41DCh */ case    8:  		/* lhz R8, <#[R7 + 8]> */
		/* 820C41DCh case    8:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000008) );
		/* 820C41DCh case    8:*/		return 0x820C41E0;
		  /* 820C41E0h */ case    9:  		/* mullw R9, R8, R9 */
		/* 820C41E0h case    9:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C41E0h case    9:*/		return 0x820C41E4;
		  /* 820C41E4h */ case   10:  		/* mullw R10, R9, R10 */
		/* 820C41E4h case   10:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820C41E4h case   10:*/		return 0x820C41E8;
		  /* 820C41E8h */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C41E8h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C41E8h case   11:*/		return 0x820C41EC;
		  /* 820C41ECh */ case   12:  		/* add R29, R10, R29 */
		/* 820C41ECh case   12:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R29);
		/* 820C41ECh case   12:*/		return 0x820C41F0;
		  /* 820C41F0h */ case   13:  		/* bc 12, CR6_LT, -92 */
		/* 820C41F0h case   13:*/		if ( regs.CR[6].lt ) { return 0x820C4194;  }
		/* 820C41F0h case   13:*/		return 0x820C41F4;
	}
	return 0x820C41F4;
} // Block from 820C41BCh-820C41F4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C41F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C41F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C41F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C41F4);
		  /* 820C41F4h */ case    0:  		/* li R3, 0 */
		/* 820C41F4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C41F4h case    0:*/		return 0x820C41F8;
		  /* 820C41F8h */ case    1:  		/* addi R1, R1, 128 */
		/* 820C41F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C41F8h case    1:*/		return 0x820C41FC;
		  /* 820C41FCh */ case    2:  		/* b -208724 */
		/* 820C41FCh case    2:*/		return 0x820912A8;
		/* 820C41FCh case    2:*/		return 0x820C4200;
		  /* 820C4200h */ case    3:  		/* li R9, 0 */
		/* 820C4200h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C4200h case    3:*/		return 0x820C4204;
		  /* 820C4204h */ case    4:  		/* stw R9, <#[R4]> */
		/* 820C4204h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x00000000) );
		/* 820C4204h case    4:*/		return 0x820C4208;
		  /* 820C4208h */ case    5:  		/* stw R9, <#[R4 + 4]> */
		/* 820C4208h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x00000004) );
		/* 820C4208h case    5:*/		return 0x820C420C;
		  /* 820C420Ch */ case    6:  		/* stw R9, <#[R4 + 8]> */
		/* 820C420Ch case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x00000008) );
		/* 820C420Ch case    6:*/		return 0x820C4210;
		  /* 820C4210h */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 820C4210h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820C4210h case    7:*/		return 0x820C4214;
		  /* 820C4214h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 820C4214h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C4214h case    8:*/		return 0x820C4218;
		  /* 820C4218h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 820C4218h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C422C;  }
		/* 820C4218h case    9:*/		return 0x820C421C;
		  /* 820C421Ch */ case   10:  		/* lwz R10, <#[R3]> */
		/* 820C421Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C421Ch case   10:*/		return 0x820C4220;
		  /* 820C4220h */ case   11:  		/* lwz R10, <#[R10 + 8]> */
		/* 820C4220h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820C4220h case   11:*/		return 0x820C4224;
		  /* 820C4224h */ case   12:  		/* add R11, R10, R11 */
		/* 820C4224h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C4224h case   12:*/		return 0x820C4228;
		  /* 820C4228h */ case   13:  		/* b 8 */
		/* 820C4228h case   13:*/		return 0x820C4230;
		/* 820C4228h case   13:*/		return 0x820C422C;
	}
	return 0x820C422C;
} // Block from 820C41F4h-820C422Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C422Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C422C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C422C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C422C);
		  /* 820C422Ch */ case    0:  		/* mr R11, R9 */
		/* 820C422Ch case    0:*/		regs.R11 = regs.R9;
		/* 820C422Ch case    0:*/		return 0x820C4230;
	}
	return 0x820C4230;
} // Block from 820C422Ch-820C4230h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C4230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4230);
		  /* 820C4230h */ case    0:  		/* stw R11, <#[R4]> */
		/* 820C4230h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820C4230h case    0:*/		return 0x820C4234;
		  /* 820C4234h */ case    1:  		/* lhz R11, <#[R3 + 8]> */
		/* 820C4234h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C4234h case    1:*/		return 0x820C4238;
		  /* 820C4238h */ case    2:  		/* stw R11, <#[R4 + 4]> */
		/* 820C4238h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C4238h case    2:*/		return 0x820C423C;
		  /* 820C423Ch */ case    3:  		/* lhz R11, <#[R3 + 10]> */
		/* 820C423Ch case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000A) );
		/* 820C423Ch case    3:*/		return 0x820C4240;
		  /* 820C4240h */ case    4:  		/* stw R11, <#[R4 + 8]> */
		/* 820C4240h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 820C4240h case    4:*/		return 0x820C4244;
		  /* 820C4244h */ case    5:  		/* lhz R11, <#[R3 + 12]> */
		/* 820C4244h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C4244h case    5:*/		return 0x820C4248;
		  /* 820C4248h */ case    6:  		/* stw R11, <#[R4 + 12]> */
		/* 820C4248h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 820C4248h case    6:*/		return 0x820C424C;
		  /* 820C424Ch */ case    7:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C424Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C424Ch case    7:*/		return 0x820C4250;
		  /* 820C4250h */ case    8:  		/* lhz R11, <#[R11]> */
		/* 820C4250h case    8:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C4250h case    8:*/		return 0x820C4254;
		  /* 820C4254h */ case    9:  		/* stw R11, <#[R4 + 16]> */
		/* 820C4254h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 820C4254h case    9:*/		return 0x820C4258;
		  /* 820C4258h */ case   10:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C4258h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C4258h case   10:*/		return 0x820C425C;
		  /* 820C425Ch */ case   11:  		/* lhz R11, <#[R11 + 2]> */
		/* 820C425Ch case   11:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000002) );
		/* 820C425Ch case   11:*/		return 0x820C4260;
		  /* 820C4260h */ case   12:  		/* stw R11, <#[R4 + 20]> */
		/* 820C4260h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 820C4260h case   12:*/		return 0x820C4264;
		  /* 820C4264h */ case   13:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C4264h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C4264h case   13:*/		return 0x820C4268;
		  /* 820C4268h */ case   14:  		/* lhz R11, <#[R11 + 4]> */
		/* 820C4268h case   14:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820C4268h case   14:*/		return 0x820C426C;
		  /* 820C426Ch */ case   15:  		/* stw R11, <#[R4 + 24]> */
		/* 820C426Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000018) );
		/* 820C426Ch case   15:*/		return 0x820C4270;
		  /* 820C4270h */ case   16:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C4270h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C4270h case   16:*/		return 0x820C4274;
		  /* 820C4274h */ case   17:  		/* lhz R11, <#[R11 + 6]> */
		/* 820C4274h case   17:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000006) );
		/* 820C4274h case   17:*/		return 0x820C4278;
		  /* 820C4278h */ case   18:  		/* stw R11, <#[R4 + 28]> */
		/* 820C4278h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 820C4278h case   18:*/		return 0x820C427C;
		  /* 820C427Ch */ case   19:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C427Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C427Ch case   19:*/		return 0x820C4280;
		  /* 820C4280h */ case   20:  		/* lhz R11, <#[R11 + 8]> */
		/* 820C4280h case   20:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C4280h case   20:*/		return 0x820C4284;
		  /* 820C4284h */ case   21:  		/* stw R11, <#[R4 + 32]> */
		/* 820C4284h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000020) );
		/* 820C4284h case   21:*/		return 0x820C4288;
		  /* 820C4288h */ case   22:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C4288h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C4288h case   22:*/		return 0x820C428C;
		  /* 820C428Ch */ case   23:  		/* lhz R11, <#[R11 + 10]> */
		/* 820C428Ch case   23:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000A) );
		/* 820C428Ch case   23:*/		return 0x820C4290;
		  /* 820C4290h */ case   24:  		/* stw R11, <#[R4 + 36]> */
		/* 820C4290h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000024) );
		/* 820C4290h case   24:*/		return 0x820C4294;
		  /* 820C4294h */ case   25:  		/* lwz R11, <#[R4 + 32]> */
		/* 820C4294h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000020) );
		/* 820C4294h case   25:*/		return 0x820C4298;
		  /* 820C4298h */ case   26:  		/* lwz R10, <#[R4 + 24]> */
		/* 820C4298h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 820C4298h case   26:*/		return 0x820C429C;
		  /* 820C429Ch */ case   27:  		/* lwz R8, <#[R4 + 28]> */
		/* 820C429Ch case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x0000001C) );
		/* 820C429Ch case   27:*/		return 0x820C42A0;
		  /* 820C42A0h */ case   28:  		/* mullw R11, R11, R10 */
		/* 820C42A0h case   28:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C42A0h case   28:*/		return 0x820C42A4;
		  /* 820C42A4h */ case   29:  		/* mullw R11, R11, R8 */
		/* 820C42A4h case   29:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820C42A4h case   29:*/		return 0x820C42A8;
		  /* 820C42A8h */ case   30:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C42A8h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C42A8h case   30:*/		return 0x820C42AC;
		  /* 820C42ACh */ case   31:  		/* stw R11, <#[R4 + 40]> */
		/* 820C42ACh case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000028) );
		/* 820C42ACh case   31:*/		return 0x820C42B0;
		  /* 820C42B0h */ case   32:  		/* lwz R11, <#[R3 + 20]> */
		/* 820C42B0h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820C42B0h case   32:*/		return 0x820C42B4;
		  /* 820C42B4h */ case   33:  		/* cmplwi CR6, R11, 0 */
		/* 820C42B4h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C42B4h case   33:*/		return 0x820C42B8;
		  /* 820C42B8h */ case   34:  		/* bc 12, CR6_EQ, 20 */
		/* 820C42B8h case   34:*/		if ( regs.CR[6].eq ) { return 0x820C42CC;  }
		/* 820C42B8h case   34:*/		return 0x820C42BC;
		  /* 820C42BCh */ case   35:  		/* lwz R10, <#[R3]> */
		/* 820C42BCh case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C42BCh case   35:*/		return 0x820C42C0;
		  /* 820C42C0h */ case   36:  		/* lwz R10, <#[R10 + 8]> */
		/* 820C42C0h case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820C42C0h case   36:*/		return 0x820C42C4;
		  /* 820C42C4h */ case   37:  		/* add R11, R10, R11 */
		/* 820C42C4h case   37:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C42C4h case   37:*/		return 0x820C42C8;
		  /* 820C42C8h */ case   38:  		/* b 8 */
		/* 820C42C8h case   38:*/		return 0x820C42D0;
		/* 820C42C8h case   38:*/		return 0x820C42CC;
	}
	return 0x820C42CC;
} // Block from 820C4230h-820C42CCh (39 instructions)

//////////////////////////////////////////////////////
// Block at 820C42CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C42CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C42CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C42CC);
		  /* 820C42CCh */ case    0:  		/* mr R11, R9 */
		/* 820C42CCh case    0:*/		regs.R11 = regs.R9;
		/* 820C42CCh case    0:*/		return 0x820C42D0;
	}
	return 0x820C42D0;
} // Block from 820C42CCh-820C42D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C42D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C42D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C42D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C42D0);
		  /* 820C42D0h */ case    0:  		/* stw R11, <#[R4 + 44]> */
		/* 820C42D0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x0000002C) );
		/* 820C42D0h case    0:*/		return 0x820C42D4;
		  /* 820C42D4h */ case    1:  		/* li R3, 0 */
		/* 820C42D4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C42D4h case    1:*/		return 0x820C42D8;
		  /* 820C42D8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820C42D8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C42D8h case    2:*/		return 0x820C42DC;
	}
	return 0x820C42DC;
} // Block from 820C42D0h-820C42DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C42DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C42DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C42DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C42DC);
		  /* 820C42DCh */ case    0:  		/* nop */
		/* 820C42DCh case    0:*/		cpu::op::nop();
		/* 820C42DCh case    0:*/		return 0x820C42E0;
	}
	return 0x820C42E0;
} // Block from 820C42DCh-820C42E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C42E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C42E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C42E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C42E0);
		  /* 820C42E0h */ case    0:  		/* mfspr R12, LR */
		/* 820C42E0h case    0:*/		regs.R12 = regs.LR;
		/* 820C42E0h case    0:*/		return 0x820C42E4;
		  /* 820C42E4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C42E4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C42E4h case    1:*/		return 0x820C42E8;
		  /* 820C42E8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820C42E8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C42E8h case    2:*/		return 0x820C42EC;
		  /* 820C42ECh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C42ECh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C42ECh case    3:*/		return 0x820C42F0;
		  /* 820C42F0h */ case    4:  		/* mr R11, R3 */
		/* 820C42F0h case    4:*/		regs.R11 = regs.R3;
		/* 820C42F0h case    4:*/		return 0x820C42F4;
		  /* 820C42F4h */ case    5:  		/* mr R3, R4 */
		/* 820C42F4h case    5:*/		regs.R3 = regs.R4;
		/* 820C42F4h case    5:*/		return 0x820C42F8;
		  /* 820C42F8h */ case    6:  		/* lwz R8, <#[R11 + 20]> */
		/* 820C42F8h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 820C42F8h case    6:*/		return 0x820C42FC;
		  /* 820C42FCh */ case    7:  		/* cmplwi CR6, R8, 0 */
		/* 820C42FCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C42FCh case    7:*/		return 0x820C4300;
		  /* 820C4300h */ case    8:  		/* bc 12, CR6_EQ, 104 */
		/* 820C4300h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C4368;  }
		/* 820C4300h case    8:*/		return 0x820C4304;
		  /* 820C4304h */ case    9:  		/* lhz R10, <#[R11 + 8]> */
		/* 820C4304h case    9:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820C4304h case    9:*/		return 0x820C4308;
		  /* 820C4308h */ case   10:  		/* li R9, 1 */
		/* 820C4308h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820C4308h case   10:*/		return 0x820C430C;
		  /* 820C430Ch */ case   11:  		/* cmplwi CR0, R10, 0 */
		/* 820C430Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820C430Ch case   11:*/		return 0x820C4310;
		  /* 820C4310h */ case   12:  		/* bc 12, CR0_EQ, 8 */
		/* 820C4310h case   12:*/		if ( regs.CR[0].eq ) { return 0x820C4318;  }
		/* 820C4310h case   12:*/		return 0x820C4314;
		  /* 820C4314h */ case   13:  		/* li R9, 4 */
		/* 820C4314h case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820C4314h case   13:*/		return 0x820C4318;
	}
	return 0x820C4318;
} // Block from 820C42E0h-820C4318h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C4318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4318);
		  /* 820C4318h */ case    0:  		/* lwz R10, <#[R11 + 28]> */
		/* 820C4318h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 820C4318h case    0:*/		return 0x820C431C;
		  /* 820C431Ch */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C431Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C431Ch case    1:*/		return 0x820C4320;
		  /* 820C4320h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C4320h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C4330;  }
		/* 820C4320h case    2:*/		return 0x820C4324;
		  /* 820C4324h */ case    3:  		/* lis R3, -32768 */
		/* 820C4324h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C4324h case    3:*/		return 0x820C4328;
		  /* 820C4328h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820C4328h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C4328h case    4:*/		return 0x820C432C;
		  /* 820C432Ch */ case    5:  		/* b 64 */
		/* 820C432Ch case    5:*/		return 0x820C436C;
		/* 820C432Ch case    5:*/		return 0x820C4330;
	}
	return 0x820C4330;
} // Block from 820C4318h-820C4330h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C4330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4330);
		  /* 820C4330h */ case    0:  		/* lwz R4, <#[R11]> */
		/* 820C4330h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820C4330h case    0:*/		return 0x820C4334;
		  /* 820C4334h */ case    1:  		/* mullw R31, R9, R5 */
		/* 820C4334h case    1:*/		cpu::op::mullw<0>(regs,&regs.R31,regs.R9,regs.R5);
		/* 820C4334h case    1:*/		return 0x820C4338;
		  /* 820C4338h */ case    2:  		/* lhz R9, <#[R11 + 10]> */
		/* 820C4338h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000A) );
		/* 820C4338h case    2:*/		return 0x820C433C;
		  /* 820C433Ch */ case    3:  		/* mtspr CTR, R10 */
		/* 820C433Ch case    3:*/		regs.CTR = regs.R10;
		/* 820C433Ch case    3:*/		return 0x820C4340;
		  /* 820C4340h */ case    4:  		/* lhz R7, <#[R11 + 12]> */
		/* 820C4340h case    4:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C4340h case    4:*/		return 0x820C4344;
		  /* 820C4344h */ case    5:  		/* lwz R6, <#[R11 + 32]> */
		/* 820C4344h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000020) );
		/* 820C4344h case    5:*/		return 0x820C4348;
		  /* 820C4348h */ case    6:  		/* lwz R10, <#[R4 + 8]> */
		/* 820C4348h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 820C4348h case    6:*/		return 0x820C434C;
		  /* 820C434Ch */ case    7:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 820C434Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 820C434Ch case    7:*/		return 0x820C4350;
		  /* 820C4350h */ case    8:  		/* add R4, R9, R5 */
		/* 820C4350h case    8:*/		cpu::op::add<0>(regs,&regs.R4,regs.R9,regs.R5);
		/* 820C4350h case    8:*/		return 0x820C4354;
		  /* 820C4354h */ case    9:  		/* add R11, R11, R10 */
		/* 820C4354h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C4354h case    9:*/		return 0x820C4358;
		  /* 820C4358h */ case   10:  		/* add R5, R11, R8 */
		/* 820C4358h case   10:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R8);
		/* 820C4358h case   10:*/		return 0x820C435C;
		  /* 820C435Ch */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820C435Ch case   11:*/		if ( 1 ) { regs.LR = 0x820C4360; return (uint32)regs.CTR; }
		/* 820C435Ch case   11:*/		return 0x820C4360;
		  /* 820C4360h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820C4360h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C4360h case   12:*/		return 0x820C4364;
		  /* 820C4364h */ case   13:  		/* bc 12, CR0_LT, 8 */
		/* 820C4364h case   13:*/		if ( regs.CR[0].lt ) { return 0x820C436C;  }
		/* 820C4364h case   13:*/		return 0x820C4368;
	}
	return 0x820C4368;
} // Block from 820C4330h-820C4368h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C4368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4368);
		  /* 820C4368h */ case    0:  		/* li R3, 0 */
		/* 820C4368h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4368h case    0:*/		return 0x820C436C;
	}
	return 0x820C436C;
} // Block from 820C4368h-820C436Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C436Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C436C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C436C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C436C);
		  /* 820C436Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 820C436Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C436Ch case    0:*/		return 0x820C4370;
		  /* 820C4370h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4370h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4370h case    1:*/		return 0x820C4374;
		  /* 820C4374h */ case    2:  		/* mtspr LR, R12 */
		/* 820C4374h case    2:*/		regs.LR = regs.R12;
		/* 820C4374h case    2:*/		return 0x820C4378;
		  /* 820C4378h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820C4378h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C4378h case    3:*/		return 0x820C437C;
		  /* 820C437Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 820C437Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C437Ch case    4:*/		return 0x820C4380;
	}
	return 0x820C4380;
} // Block from 820C436Ch-820C4380h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C4380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4380);
		  /* 820C4380h */ case    0:  		/* mfspr R12, LR */
		/* 820C4380h case    0:*/		regs.R12 = regs.LR;
		/* 820C4380h case    0:*/		return 0x820C4384;
		  /* 820C4384h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4384h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4384h case    1:*/		return 0x820C4388;
		  /* 820C4388h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4388h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4388h case    2:*/		return 0x820C438C;
		  /* 820C438Ch */ case    3:  		/* li R11, 0 */
		/* 820C438Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C438Ch case    3:*/		return 0x820C4390;
		  /* 820C4390h */ case    4:  		/* lis R10, -32255 */
		/* 820C4390h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C4390h case    4:*/		return 0x820C4394;
		  /* 820C4394h */ case    5:  		/* stw R11, <#[R5]> */
		/* 820C4394h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820C4394h case    5:*/		return 0x820C4398;
		  /* 820C4398h */ case    6:  		/* mr R11, R4 */
		/* 820C4398h case    6:*/		regs.R11 = regs.R4;
		/* 820C4398h case    6:*/		return 0x820C439C;
		  /* 820C439Ch */ case    7:  		/* addi R10, R10, 11180 */
		/* 820C439Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2BAC);
		/* 820C439Ch case    7:*/		return 0x820C43A0;
		  /* 820C43A0h */ case    8:  		/* addi R9, R4, 16 */
		/* 820C43A0h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x10);
		/* 820C43A0h case    8:*/		return 0x820C43A4;
		  /* 820C43A4h */ case    9:  		/* lbz R8, <#[R11]> */
		/* 820C43A4h case    9:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820C43A4h case    9:*/		return 0x820C43A8;
		  /* 820C43A8h */ case   10:  		/* lbz R7, <#[R10]> */
		/* 820C43A8h case   10:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820C43A8h case   10:*/		return 0x820C43AC;
		  /* 820C43ACh */ case   11:  		/* subf. R8, R7, R8 */
		/* 820C43ACh case   11:*/		cpu::op::subf<1>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820C43ACh case   11:*/		return 0x820C43B0;
		  /* 820C43B0h */ case   12:  		/* bc 4, CR0_EQ, 20 */
		/* 820C43B0h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820C43C4;  }
		/* 820C43B0h case   12:*/		return 0x820C43B4;
		  /* 820C43B4h */ case   13:  		/* addi R11, R11, 1 */
		/* 820C43B4h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C43B4h case   13:*/		return 0x820C43B8;
		  /* 820C43B8h */ case   14:  		/* addi R10, R10, 1 */
		/* 820C43B8h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C43B8h case   14:*/		return 0x820C43BC;
		  /* 820C43BCh */ case   15:  		/* cmpw CR6, R11, R9 */
		/* 820C43BCh case   15:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 820C43BCh case   15:*/		return 0x820C43C0;
		  /* 820C43C0h */ case   16:  		/* bc 4, CR6_EQ, -28 */
		/* 820C43C0h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820C43A4;  }
		/* 820C43C0h case   16:*/		return 0x820C43C4;
	}
	return 0x820C43C4;
} // Block from 820C4380h-820C43C4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C43C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C43C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C43C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C43C4);
		  /* 820C43C4h */ case    0:  		/* cmpwi CR0, R8, 0 */
		/* 820C43C4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R8,0x00000000);
		/* 820C43C4h case    0:*/		return 0x820C43C8;
		  /* 820C43C8h */ case    1:  		/* bc 12, CR0_EQ, 60 */
		/* 820C43C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C4404;  }
		/* 820C43C8h case    1:*/		return 0x820C43CC;
		  /* 820C43CCh */ case    2:  		/* lis R10, -32255 */
		/* 820C43CCh case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C43CCh case    2:*/		return 0x820C43D0;
		  /* 820C43D0h */ case    3:  		/* mr R11, R4 */
		/* 820C43D0h case    3:*/		regs.R11 = regs.R4;
		/* 820C43D0h case    3:*/		return 0x820C43D4;
		  /* 820C43D4h */ case    4:  		/* addi R10, R10, 11164 */
		/* 820C43D4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2B9C);
		/* 820C43D4h case    4:*/		return 0x820C43D8;
		  /* 820C43D8h */ case    5:  		/* addi R8, R4, 16 */
		/* 820C43D8h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R4,0x10);
		/* 820C43D8h case    5:*/		return 0x820C43DC;
		  /* 820C43DCh */ case    6:  		/* lbz R9, <#[R11]> */
		/* 820C43DCh case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C43DCh case    6:*/		return 0x820C43E0;
		  /* 820C43E0h */ case    7:  		/* lbz R7, <#[R10]> */
		/* 820C43E0h case    7:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820C43E0h case    7:*/		return 0x820C43E4;
		  /* 820C43E4h */ case    8:  		/* subf. R9, R7, R9 */
		/* 820C43E4h case    8:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820C43E4h case    8:*/		return 0x820C43E8;
		  /* 820C43E8h */ case    9:  		/* bc 4, CR0_EQ, 20 */
		/* 820C43E8h case    9:*/		if ( !regs.CR[0].eq ) { return 0x820C43FC;  }
		/* 820C43E8h case    9:*/		return 0x820C43EC;
		  /* 820C43ECh */ case   10:  		/* addi R11, R11, 1 */
		/* 820C43ECh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C43ECh case   10:*/		return 0x820C43F0;
		  /* 820C43F0h */ case   11:  		/* addi R10, R10, 1 */
		/* 820C43F0h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C43F0h case   11:*/		return 0x820C43F4;
		  /* 820C43F4h */ case   12:  		/* cmpw CR6, R11, R8 */
		/* 820C43F4h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820C43F4h case   12:*/		return 0x820C43F8;
		  /* 820C43F8h */ case   13:  		/* bc 4, CR6_EQ, -28 */
		/* 820C43F8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820C43DC;  }
		/* 820C43F8h case   13:*/		return 0x820C43FC;
	}
	return 0x820C43FC;
} // Block from 820C43C4h-820C43FCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C43FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C43FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C43FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C43FC);
		  /* 820C43FCh */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820C43FCh case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820C43FCh case    0:*/		return 0x820C4400;
		  /* 820C4400h */ case    1:  		/* bc 4, CR0_EQ, 32 */
		/* 820C4400h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820C4420;  }
		/* 820C4400h case    1:*/		return 0x820C4404;
	}
	return 0x820C4404;
} // Block from 820C43FCh-820C4404h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C4404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4404);
		  /* 820C4404h */ case    0:  		/* stw R3, <#[R5]> */
		/* 820C4404h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R5 + 0x00000000) );
		/* 820C4404h case    0:*/		return 0x820C4408;
		  /* 820C4408h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 820C4408h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C4408h case    1:*/		return 0x820C440C;
		  /* 820C440Ch */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 820C440Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820C440Ch case    2:*/		return 0x820C4410;
		  /* 820C4410h */ case    3:  		/* mtspr CTR, R11 */
		/* 820C4410h case    3:*/		regs.CTR = regs.R11;
		/* 820C4410h case    3:*/		return 0x820C4414;
		  /* 820C4414h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820C4414h case    4:*/		if ( 1 ) { regs.LR = 0x820C4418; return (uint32)regs.CTR; }
		/* 820C4414h case    4:*/		return 0x820C4418;
		  /* 820C4418h */ case    5:  		/* li R3, 0 */
		/* 820C4418h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4418h case    5:*/		return 0x820C441C;
		  /* 820C441Ch */ case    6:  		/* b 12 */
		/* 820C441Ch case    6:*/		return 0x820C4428;
		/* 820C441Ch case    6:*/		return 0x820C4420;
	}
	return 0x820C4420;
} // Block from 820C4404h-820C4420h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C4420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4420);
		  /* 820C4420h */ case    0:  		/* lis R3, -32768 */
		/* 820C4420h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C4420h case    0:*/		return 0x820C4424;
		  /* 820C4424h */ case    1:  		/* ori R3, R3, 16386 */
		/* 820C4424h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4002);
		/* 820C4424h case    1:*/		return 0x820C4428;
	}
	return 0x820C4428;
} // Block from 820C4420h-820C4428h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C4428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4428);
		  /* 820C4428h */ case    0:  		/* addi R1, R1, 96 */
		/* 820C4428h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4428h case    0:*/		return 0x820C442C;
		  /* 820C442Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C442Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C442Ch case    1:*/		return 0x820C4430;
		  /* 820C4430h */ case    2:  		/* mtspr LR, R12 */
		/* 820C4430h case    2:*/		regs.LR = regs.R12;
		/* 820C4430h case    2:*/		return 0x820C4434;
		  /* 820C4434h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820C4434h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4434h case    3:*/		return 0x820C4438;
	}
	return 0x820C4438;
} // Block from 820C4428h-820C4438h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C4438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4438);
		  /* 820C4438h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 820C4438h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820C4438h case    0:*/		return 0x820C443C;
		  /* 820C443Ch */ case    1:  		/* mr R10, R3 */
		/* 820C443Ch case    1:*/		regs.R10 = regs.R3;
		/* 820C443Ch case    1:*/		return 0x820C4440;
		  /* 820C4440h */ case    2:  		/* addi R3, R11, 1 */
		/* 820C4440h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 820C4440h case    2:*/		return 0x820C4444;
		  /* 820C4444h */ case    3:  		/* stw R3, <#[R10 + 4]> */
		/* 820C4444h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R10 + 0x00000004) );
		/* 820C4444h case    3:*/		return 0x820C4448;
		  /* 820C4448h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820C4448h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4448h case    4:*/		return 0x820C444C;
	}
	return 0x820C444C;
} // Block from 820C4438h-820C444Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C444Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C444C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C444C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C444C);
		  /* 820C444Ch */ case    0:  		/* nop */
		/* 820C444Ch case    0:*/		cpu::op::nop();
		/* 820C444Ch case    0:*/		return 0x820C4450;
	}
	return 0x820C4450;
} // Block from 820C444Ch-820C4450h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C4450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4450);
		  /* 820C4450h */ case    0:  		/* lwz R3, <#[R3 + 8]> */
		/* 820C4450h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 820C4450h case    0:*/		return 0x820C4454;
		  /* 820C4454h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820C4454h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4454h case    1:*/		return 0x820C4458;
	}
	return 0x820C4458;
} // Block from 820C4450h-820C4458h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C4458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4458);
		  /* 820C4458h */ case    0:  		/* lwz R3, <#[R3 + 12]> */
		/* 820C4458h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C4458h case    0:*/		return 0x820C445C;
		  /* 820C445Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820C445Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C445Ch case    1:*/		return 0x820C4460;
	}
	return 0x820C4460;
} // Block from 820C4458h-820C4460h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C4460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4460);
		  /* 820C4460h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820C4460h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C4460h case    0:*/		return 0x820C4464;
		  /* 820C4464h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820C4464h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C4474;  }
		/* 820C4464h case    1:*/		return 0x820C4468;
		  /* 820C4468h */ case    2:  		/* lis R3, -30602 */
		/* 820C4468h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820C4468h case    2:*/		return 0x820C446C;
		  /* 820C446Ch */ case    3:  		/* ori R3, R3, 2156 */
		/* 820C446Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 820C446Ch case    3:*/		return 0x820C4470;
		  /* 820C4470h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820C4470h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4470h case    4:*/		return 0x820C4474;
	}
	return 0x820C4474;
} // Block from 820C4460h-820C4474h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C4474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4474);
		  /* 820C4474h */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 820C4474h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C4474h case    0:*/		return 0x820C4478;
		  /* 820C4478h */ case    1:  		/* cmplwi CR6, R11, 28 */
		/* 820C4478h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001C);
		/* 820C4478h case    1:*/		return 0x820C447C;
		  /* 820C447Ch */ case    2:  		/* bc 12, CR6_LT, 32 */
		/* 820C447Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x820C449C;  }
		/* 820C447Ch case    2:*/		return 0x820C4480;
		  /* 820C4480h */ case    3:  		/* lwz R9, <#[R3 + 8]> */
		/* 820C4480h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 820C4480h case    3:*/		return 0x820C4484;
		  /* 820C4484h */ case    4:  		/* lwz R10, <#[R9]> */
		/* 820C4484h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 820C4484h case    4:*/		return 0x820C4488;
		  /* 820C4488h */ case    5:  		/* cmplwi CR6, R10, 28 */
		/* 820C4488h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001C);
		/* 820C4488h case    5:*/		return 0x820C448C;
		  /* 820C448Ch */ case    6:  		/* bc 12, CR6_LT, 16 */
		/* 820C448Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x820C449C;  }
		/* 820C448Ch case    6:*/		return 0x820C4490;
		  /* 820C4490h */ case    7:  		/* lwz R10, <#[R9 + 4]> */
		/* 820C4490h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 820C4490h case    7:*/		return 0x820C4494;
		  /* 820C4494h */ case    8:  		/* cmplw CR6, R10, R11 */
		/* 820C4494h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820C4494h case    8:*/		return 0x820C4498;
		  /* 820C4498h */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 820C4498h case    9:*/		if ( regs.CR[6].lt ) { return 0x820C44A8;  }
		/* 820C4498h case    9:*/		return 0x820C449C;
	}
	return 0x820C449C;
} // Block from 820C4474h-820C449Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C449Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C449C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C449C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C449C);
		  /* 820C449Ch */ case    0:  		/* lis R3, -30602 */
		/* 820C449Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820C449Ch case    0:*/		return 0x820C44A0;
		  /* 820C44A0h */ case    1:  		/* ori R3, R3, 2905 */
		/* 820C44A0h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xB59);
		/* 820C44A0h case    1:*/		return 0x820C44A4;
		  /* 820C44A4h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820C44A4h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C44A4h case    2:*/		return 0x820C44A8;
	}
	return 0x820C44A8;
} // Block from 820C449Ch-820C44A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C44A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C44A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C44A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C44A8);
		  /* 820C44A8h */ case    0:  		/* li R10, 0 */
		/* 820C44A8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C44A8h case    0:*/		return 0x820C44AC;
		  /* 820C44ACh */ case    1:  		/* stw R10, <#[R4]> */
		/* 820C44ACh case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 820C44ACh case    1:*/		return 0x820C44B0;
		  /* 820C44B0h */ case    2:  		/* stw R10, <#[R4 + 4]> */
		/* 820C44B0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 820C44B0h case    2:*/		return 0x820C44B4;
		  /* 820C44B4h */ case    3:  		/* stw R10, <#[R4 + 8]> */
		/* 820C44B4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 820C44B4h case    3:*/		return 0x820C44B8;
		  /* 820C44B8h */ case    4:  		/* lwz R11, <#[R9 + 4]> */
		/* 820C44B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 820C44B8h case    4:*/		return 0x820C44BC;
		  /* 820C44BCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820C44BCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C44BCh case    5:*/		return 0x820C44C0;
		  /* 820C44C0h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 820C44C0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C44CC;  }
		/* 820C44C0h case    6:*/		return 0x820C44C4;
		  /* 820C44C4h */ case    7:  		/* lwz R10, <#[R3 + 8]> */
		/* 820C44C4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820C44C4h case    7:*/		return 0x820C44C8;
		  /* 820C44C8h */ case    8:  		/* add R10, R10, R11 */
		/* 820C44C8h case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C44C8h case    8:*/		return 0x820C44CC;
	}
	return 0x820C44CC;
} // Block from 820C44A8h-820C44CCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C44CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C44CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C44CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C44CC);
		  /* 820C44CCh */ case    0:  		/* stw R10, <#[R4]> */
		/* 820C44CCh case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 820C44CCh case    0:*/		return 0x820C44D0;
		  /* 820C44D0h */ case    1:  		/* li R3, 0 */
		/* 820C44D0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C44D0h case    1:*/		return 0x820C44D4;
		  /* 820C44D4h */ case    2:  		/* lwz R11, <#[R9 + 8]> */
		/* 820C44D4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 820C44D4h case    2:*/		return 0x820C44D8;
		  /* 820C44D8h */ case    3:  		/* stw R11, <#[R4 + 4]> */
		/* 820C44D8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C44D8h case    3:*/		return 0x820C44DC;
		  /* 820C44DCh */ case    4:  		/* lwz R11, <#[R9 + 12]> */
		/* 820C44DCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 820C44DCh case    4:*/		return 0x820C44E0;
		  /* 820C44E0h */ case    5:  		/* stw R11, <#[R4 + 8]> */
		/* 820C44E0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 820C44E0h case    5:*/		return 0x820C44E4;
		  /* 820C44E4h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C44E4h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C44E4h case    6:*/		return 0x820C44E8;
	}
	return 0x820C44E8;
} // Block from 820C44CCh-820C44E8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C44E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C44E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C44E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C44E8);
		  /* 820C44E8h */ case    0:  		/* mfspr R12, LR */
		/* 820C44E8h case    0:*/		regs.R12 = regs.LR;
		/* 820C44E8h case    0:*/		return 0x820C44EC;
		  /* 820C44ECh */ case    1:  		/* bl -209556 */
		/* 820C44ECh case    1:*/		regs.LR = 0x820C44F0; return 0x82091258;
		/* 820C44ECh case    1:*/		return 0x820C44F0;
		  /* 820C44F0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C44F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C44F0h case    2:*/		return 0x820C44F4;
		  /* 820C44F4h */ case    3:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C44F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C44F4h case    3:*/		return 0x820C44F8;
		  /* 820C44F8h */ case    4:  		/* mr R31, R3 */
		/* 820C44F8h case    4:*/		regs.R31 = regs.R3;
		/* 820C44F8h case    4:*/		return 0x820C44FC;
		  /* 820C44FCh */ case    5:  		/* mr R28, R4 */
		/* 820C44FCh case    5:*/		regs.R28 = regs.R4;
		/* 820C44FCh case    5:*/		return 0x820C4500;
		  /* 820C4500h */ case    6:  		/* li R29, 0 */
		/* 820C4500h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C4500h case    6:*/		return 0x820C4504;
		  /* 820C4504h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820C4504h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C4504h case    7:*/		return 0x820C4508;
		  /* 820C4508h */ case    8:  		/* bc 4, CR6_GT, 56 */
		/* 820C4508h case    8:*/		if ( !regs.CR[6].gt ) { return 0x820C4540;  }
		/* 820C4508h case    8:*/		return 0x820C450C;
		  /* 820C450Ch */ case    9:  		/* li R30, 0 */
		/* 820C450Ch case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C450Ch case    9:*/		return 0x820C4510;
		  /* 820C4510h */ case   10:  		/* lwz R11, <#[R31 + 20]> */
		/* 820C4510h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820C4510h case   10:*/		return 0x820C4514;
		  /* 820C4514h */ case   11:  		/* li R5, 0 */
		/* 820C4514h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C4514h case   11:*/		return 0x820C4518;
		  /* 820C4518h */ case   12:  		/* mr R4, R28 */
		/* 820C4518h case   12:*/		regs.R4 = regs.R28;
		/* 820C4518h case   12:*/		return 0x820C451C;
		  /* 820C451Ch */ case   13:  		/* lwzx R3, <#[R11 + R30]> */
		/* 820C451Ch case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820C451Ch case   13:*/		return 0x820C4520;
		  /* 820C4520h */ case   14:  		/* bl -576 */
		/* 820C4520h case   14:*/		regs.LR = 0x820C4524; return 0x820C42E0;
		/* 820C4520h case   14:*/		return 0x820C4524;
		  /* 820C4524h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820C4524h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C4524h case   15:*/		return 0x820C4528;
		  /* 820C4528h */ case   16:  		/* bc 12, CR0_LT, 28 */
		/* 820C4528h case   16:*/		if ( regs.CR[0].lt ) { return 0x820C4544;  }
		/* 820C4528h case   16:*/		return 0x820C452C;
		  /* 820C452Ch */ case   17:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C452Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C452Ch case   17:*/		return 0x820C4530;
		  /* 820C4530h */ case   18:  		/* addi R29, R29, 1 */
		/* 820C4530h case   18:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820C4530h case   18:*/		return 0x820C4534;
		  /* 820C4534h */ case   19:  		/* addi R30, R30, 4 */
		/* 820C4534h case   19:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C4534h case   19:*/		return 0x820C4538;
		  /* 820C4538h */ case   20:  		/* cmplw CR6, R29, R11 */
		/* 820C4538h case   20:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820C4538h case   20:*/		return 0x820C453C;
		  /* 820C453Ch */ case   21:  		/* bc 12, CR6_LT, -44 */
		/* 820C453Ch case   21:*/		if ( regs.CR[6].lt ) { return 0x820C4510;  }
		/* 820C453Ch case   21:*/		return 0x820C4540;
	}
	return 0x820C4540;
} // Block from 820C44E8h-820C4540h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C4540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4540);
		  /* 820C4540h */ case    0:  		/* li R3, 0 */
		/* 820C4540h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4540h case    0:*/		return 0x820C4544;
	}
	return 0x820C4544;
} // Block from 820C4540h-820C4544h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C4544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4544);
		  /* 820C4544h */ case    0:  		/* addi R1, R1, 128 */
		/* 820C4544h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C4544h case    0:*/		return 0x820C4548;
		  /* 820C4548h */ case    1:  		/* b -209568 */
		/* 820C4548h case    1:*/		return 0x820912A8;
		/* 820C4548h case    1:*/		return 0x820C454C;
		  /* 820C454Ch */ case    2:  		/* nop */
		/* 820C454Ch case    2:*/		cpu::op::nop();
		/* 820C454Ch case    2:*/		return 0x820C4550;
	}
	return 0x820C4550;
} // Block from 820C4544h-820C4550h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C4550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4550);
		  /* 820C4550h */ case    0:  		/* mfspr R12, LR */
		/* 820C4550h case    0:*/		regs.R12 = regs.LR;
		/* 820C4550h case    0:*/		return 0x820C4554;
		  /* 820C4554h */ case    1:  		/* bl -209656 */
		/* 820C4554h case    1:*/		regs.LR = 0x820C4558; return 0x8209125C;
		/* 820C4554h case    1:*/		return 0x820C4558;
		  /* 820C4558h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C4558h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C4558h case    2:*/		return 0x820C455C;
		  /* 820C455Ch */ case    3:  		/* lwz R11, <#[R3 + 56]> */
		/* 820C455Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 820C455Ch case    3:*/		return 0x820C4560;
		  /* 820C4560h */ case    4:  		/* mr R31, R3 */
		/* 820C4560h case    4:*/		regs.R31 = regs.R3;
		/* 820C4560h case    4:*/		return 0x820C4564;
		  /* 820C4564h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820C4564h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C4564h case    5:*/		return 0x820C4568;
		  /* 820C4568h */ case    6:  		/* bc 12, CR6_EQ, 88 */
		/* 820C4568h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C45C0;  }
		/* 820C4568h case    6:*/		return 0x820C456C;
		  /* 820C456Ch */ case    7:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C456Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C456Ch case    7:*/		return 0x820C4570;
		  /* 820C4570h */ case    8:  		/* li R29, 0 */
		/* 820C4570h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C4570h case    8:*/		return 0x820C4574;
		  /* 820C4574h */ case    9:  		/* lhz R11, <#[R11 + 10]> */
		/* 820C4574h case    9:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000A) );
		/* 820C4574h case    9:*/		return 0x820C4578;
		  /* 820C4578h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 820C4578h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C4578h case   10:*/		return 0x820C457C;
		  /* 820C457Ch */ case   11:  		/* bc 12, CR0_EQ, 56 */
		/* 820C457Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x820C45B4;  }
		/* 820C457Ch case   11:*/		return 0x820C4580;
		  /* 820C4580h */ case   12:  		/* li R30, 0 */
		/* 820C4580h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C4580h case   12:*/		return 0x820C4584;
		  /* 820C4584h */ case   13:  		/* lwz R11, <#[R31 + 56]> */
		/* 820C4584h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820C4584h case   13:*/		return 0x820C4588;
		  /* 820C4588h */ case   14:  		/* lwzx R3, <#[R30 + R11]> */
		/* 820C4588h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820C4588h case   14:*/		return 0x820C458C;
		  /* 820C458Ch */ case   15:  		/* cmplwi CR6, R3, 0 */
		/* 820C458Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C458Ch case   15:*/		return 0x820C4590;
		  /* 820C4590h */ case   16:  		/* bc 12, CR6_EQ, 12 */
		/* 820C4590h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C459C;  }
		/* 820C4590h case   16:*/		return 0x820C4594;
		  /* 820C4594h */ case   17:  		/* li R4, 1 */
		/* 820C4594h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820C4594h case   17:*/		return 0x820C4598;
		  /* 820C4598h */ case   18:  		/* bl 12656 */
		/* 820C4598h case   18:*/		regs.LR = 0x820C459C; return 0x820C7708;
		/* 820C4598h case   18:*/		return 0x820C459C;
	}
	return 0x820C459C;
} // Block from 820C4550h-820C459Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 820C459Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C459C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C459C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C459C);
		  /* 820C459Ch */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C459Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C459Ch case    0:*/		return 0x820C45A0;
		  /* 820C45A0h */ case    1:  		/* addi R29, R29, 1 */
		/* 820C45A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820C45A0h case    1:*/		return 0x820C45A4;
		  /* 820C45A4h */ case    2:  		/* addi R30, R30, 4 */
		/* 820C45A4h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C45A4h case    2:*/		return 0x820C45A8;
		  /* 820C45A8h */ case    3:  		/* lhz R11, <#[R11 + 10]> */
		/* 820C45A8h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000A) );
		/* 820C45A8h case    3:*/		return 0x820C45AC;
		  /* 820C45ACh */ case    4:  		/* cmplw CR6, R29, R11 */
		/* 820C45ACh case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820C45ACh case    4:*/		return 0x820C45B0;
		  /* 820C45B0h */ case    5:  		/* bc 12, CR6_LT, -44 */
		/* 820C45B0h case    5:*/		if ( regs.CR[6].lt ) { return 0x820C4584;  }
		/* 820C45B0h case    5:*/		return 0x820C45B4;
	}
	return 0x820C45B4;
} // Block from 820C459Ch-820C45B4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C45B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C45B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C45B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C45B4);
		  /* 820C45B4h */ case    0:  		/* lis R4, 9345 */
		/* 820C45B4h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C45B4h case    0:*/		return 0x820C45B8;
		  /* 820C45B8h */ case    1:  		/* lwz R3, <#[R31 + 56]> */
		/* 820C45B8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 820C45B8h case    1:*/		return 0x820C45BC;
		  /* 820C45BCh */ case    2:  		/* bl -246404 */
		/* 820C45BCh case    2:*/		regs.LR = 0x820C45C0; return 0x82088338;
		/* 820C45BCh case    2:*/		return 0x820C45C0;
	}
	return 0x820C45C0;
} // Block from 820C45B4h-820C45C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C45C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C45C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C45C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C45C0);
		  /* 820C45C0h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 820C45C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C45C0h case    0:*/		return 0x820C45C4;
		  /* 820C45C4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C45C4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C45C4h case    1:*/		return 0x820C45C8;
		  /* 820C45C8h */ case    2:  		/* bc 12, CR6_EQ, 88 */
		/* 820C45C8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C4620;  }
		/* 820C45C8h case    2:*/		return 0x820C45CC;
		  /* 820C45CCh */ case    3:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C45CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C45CCh case    3:*/		return 0x820C45D0;
		  /* 820C45D0h */ case    4:  		/* li R29, 0 */
		/* 820C45D0h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C45D0h case    4:*/		return 0x820C45D4;
		  /* 820C45D4h */ case    5:  		/* lhz R11, <#[R11 + 8]> */
		/* 820C45D4h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C45D4h case    5:*/		return 0x820C45D8;
		  /* 820C45D8h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 820C45D8h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C45D8h case    6:*/		return 0x820C45DC;
		  /* 820C45DCh */ case    7:  		/* bc 12, CR0_EQ, 56 */
		/* 820C45DCh case    7:*/		if ( regs.CR[0].eq ) { return 0x820C4614;  }
		/* 820C45DCh case    7:*/		return 0x820C45E0;
		  /* 820C45E0h */ case    8:  		/* li R30, 0 */
		/* 820C45E0h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C45E0h case    8:*/		return 0x820C45E4;
		  /* 820C45E4h */ case    9:  		/* lwz R11, <#[R31 + 60]> */
		/* 820C45E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C45E4h case    9:*/		return 0x820C45E8;
		  /* 820C45E8h */ case   10:  		/* lwzx R3, <#[R11 + R30]> */
		/* 820C45E8h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820C45E8h case   10:*/		return 0x820C45EC;
		  /* 820C45ECh */ case   11:  		/* cmplwi CR6, R3, 0 */
		/* 820C45ECh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C45ECh case   11:*/		return 0x820C45F0;
		  /* 820C45F0h */ case   12:  		/* bc 12, CR6_EQ, 12 */
		/* 820C45F0h case   12:*/		if ( regs.CR[6].eq ) { return 0x820C45FC;  }
		/* 820C45F0h case   12:*/		return 0x820C45F4;
		  /* 820C45F4h */ case   13:  		/* li R4, 1 */
		/* 820C45F4h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 820C45F4h case   13:*/		return 0x820C45F8;
		  /* 820C45F8h */ case   14:  		/* bl 12560 */
		/* 820C45F8h case   14:*/		regs.LR = 0x820C45FC; return 0x820C7708;
		/* 820C45F8h case   14:*/		return 0x820C45FC;
	}
	return 0x820C45FC;
} // Block from 820C45C0h-820C45FCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C45FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C45FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C45FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C45FC);
		  /* 820C45FCh */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C45FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C45FCh case    0:*/		return 0x820C4600;
		  /* 820C4600h */ case    1:  		/* addi R29, R29, 1 */
		/* 820C4600h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820C4600h case    1:*/		return 0x820C4604;
		  /* 820C4604h */ case    2:  		/* addi R30, R30, 4 */
		/* 820C4604h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C4604h case    2:*/		return 0x820C4608;
		  /* 820C4608h */ case    3:  		/* lhz R11, <#[R11 + 8]> */
		/* 820C4608h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C4608h case    3:*/		return 0x820C460C;
		  /* 820C460Ch */ case    4:  		/* cmplw CR6, R29, R11 */
		/* 820C460Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 820C460Ch case    4:*/		return 0x820C4610;
		  /* 820C4610h */ case    5:  		/* bc 12, CR6_LT, -44 */
		/* 820C4610h case    5:*/		if ( regs.CR[6].lt ) { return 0x820C45E4;  }
		/* 820C4610h case    5:*/		return 0x820C4614;
	}
	return 0x820C4614;
} // Block from 820C45FCh-820C4614h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C4614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4614);
		  /* 820C4614h */ case    0:  		/* lis R4, 9345 */
		/* 820C4614h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C4614h case    0:*/		return 0x820C4618;
		  /* 820C4618h */ case    1:  		/* lwz R3, <#[R31 + 60]> */
		/* 820C4618h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C4618h case    1:*/		return 0x820C461C;
		  /* 820C461Ch */ case    2:  		/* bl -246500 */
		/* 820C461Ch case    2:*/		regs.LR = 0x820C4620; return 0x82088338;
		/* 820C461Ch case    2:*/		return 0x820C4620;
	}
	return 0x820C4620;
} // Block from 820C4614h-820C4620h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C4620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4620);
		  /* 820C4620h */ case    0:  		/* lis R4, 9345 */
		/* 820C4620h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C4620h case    0:*/		return 0x820C4624;
		  /* 820C4624h */ case    1:  		/* lwz R3, <#[R31 + 64]> */
		/* 820C4624h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000040) );
		/* 820C4624h case    1:*/		return 0x820C4628;
		  /* 820C4628h */ case    2:  		/* bl -246512 */
		/* 820C4628h case    2:*/		regs.LR = 0x820C462C; return 0x82088338;
		/* 820C4628h case    2:*/		return 0x820C462C;
		  /* 820C462Ch */ case    3:  		/* addi R1, R1, 112 */
		/* 820C462Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C462Ch case    3:*/		return 0x820C4630;
		  /* 820C4630h */ case    4:  		/* b -209796 */
		/* 820C4630h case    4:*/		return 0x820912AC;
		/* 820C4630h case    4:*/		return 0x820C4634;
		  /* 820C4634h */ case    5:  		/* nop */
		/* 820C4634h case    5:*/		cpu::op::nop();
		/* 820C4634h case    5:*/		return 0x820C4638;
	}
	return 0x820C4638;
} // Block from 820C4620h-820C4638h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C4638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4638);
		  /* 820C4638h */ case    0:  		/* mfspr R12, LR */
		/* 820C4638h case    0:*/		regs.R12 = regs.LR;
		/* 820C4638h case    0:*/		return 0x820C463C;
		  /* 820C463Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C463Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C463Ch case    1:*/		return 0x820C4640;
		  /* 820C4640h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820C4640h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C4640h case    2:*/		return 0x820C4644;
		  /* 820C4644h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4644h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4644h case    3:*/		return 0x820C4648;
		  /* 820C4648h */ case    4:  		/* mr R11, R4 */
		/* 820C4648h case    4:*/		regs.R11 = regs.R4;
		/* 820C4648h case    4:*/		return 0x820C464C;
		  /* 820C464Ch */ case    5:  		/* cmplwi CR6, R5, 0 */
		/* 820C464Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820C464Ch case    5:*/		return 0x820C4650;
		  /* 820C4650h */ case    6:  		/* bc 4, CR6_EQ, 24 */
		/* 820C4650h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820C4668;  }
		/* 820C4650h case    6:*/		return 0x820C4654;
		  /* 820C4654h */ case    7:  		/* cmplwi CR6, R6, 0 */
		/* 820C4654h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820C4654h case    7:*/		return 0x820C4658;
		  /* 820C4658h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 820C4658h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C4668;  }
		/* 820C4658h case    8:*/		return 0x820C465C;
		  /* 820C465Ch */ case    9:  		/* lis R3, -30602 */
		/* 820C465Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820C465Ch case    9:*/		return 0x820C4660;
		  /* 820C4660h */ case   10:  		/* ori R3, R3, 2156 */
		/* 820C4660h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 820C4660h case   10:*/		return 0x820C4664;
		  /* 820C4664h */ case   11:  		/* b 144 */
		/* 820C4664h case   11:*/		return 0x820C46F4;
		/* 820C4664h case   11:*/		return 0x820C4668;
	}
	return 0x820C4668;
} // Block from 820C4638h-820C4668h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C4668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4668);
		  /* 820C4668h */ case    0:  		/* nor. R7, R11, R11 */
		/* 820C4668h case    0:*/		cpu::op::nor<1>(regs,&regs.R7,regs.R11,regs.R11);
		/* 820C4668h case    0:*/		return 0x820C466C;
		  /* 820C466Ch */ case    1:  		/* li R10, 0 */
		/* 820C466Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C466Ch case    1:*/		return 0x820C4670;
		  /* 820C4670h */ case    2:  		/* li R31, 1 */
		/* 820C4670h case    2:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820C4670h case    2:*/		return 0x820C4674;
		  /* 820C4674h */ case    3:  		/* mr R11, R7 */
		/* 820C4674h case    3:*/		regs.R11 = regs.R7;
		/* 820C4674h case    3:*/		return 0x820C4678;
		  /* 820C4678h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 820C4678h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C468C;  }
		/* 820C4678h case    4:*/		return 0x820C467C;
		  /* 820C467Ch */ case    5:  		/* lwz R11, <#[R11 + 36]> */
		/* 820C467Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 820C467Ch case    5:*/		return 0x820C4680;
		  /* 820C4680h */ case    6:  		/* addi R10, R10, 1 */
		/* 820C4680h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C4680h case    6:*/		return 0x820C4684;
		  /* 820C4684h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820C4684h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C4684h case    7:*/		return 0x820C4688;
		  /* 820C4688h */ case    8:  		/* bc 4, CR6_EQ, -12 */
		/* 820C4688h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C467C;  }
		/* 820C4688h case    8:*/		return 0x820C468C;
	}
	return 0x820C468C;
} // Block from 820C4668h-820C468Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C468Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C468C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C468C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C468C);
		  /* 820C468Ch */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 820C468Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820C468Ch case    0:*/		return 0x820C4690;
		  /* 820C4690h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 820C4690h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C46B4;  }
		/* 820C4690h case    1:*/		return 0x820C4694;
		  /* 820C4694h */ case    2:  		/* lwz R31, <#[R6]> */
		/* 820C4694h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R6 + 0x00000000) );
		/* 820C4694h case    2:*/		return 0x820C4698;
		  /* 820C4698h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 820C4698h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C4698h case    3:*/		return 0x820C469C;
		  /* 820C469Ch */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 820C469Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C46A4;  }
		/* 820C469Ch case    4:*/		return 0x820C46A0;
		  /* 820C46A0h */ case    5:  		/* li R31, 1 */
		/* 820C46A0h case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 820C46A0h case    5:*/		return 0x820C46A4;
	}
	return 0x820C46A4;
} // Block from 820C468Ch-820C46A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C46A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C46A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C46A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C46A4);
		  /* 820C46A4h */ case    0:  		/* cmplw CR6, R31, R10 */
		/* 820C46A4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 820C46A4h case    0:*/		return 0x820C46A8;
		  /* 820C46A8h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 820C46A8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820C46B0;  }
		/* 820C46A8h case    1:*/		return 0x820C46AC;
		  /* 820C46ACh */ case    2:  		/* mr R31, R10 */
		/* 820C46ACh case    2:*/		regs.R31 = regs.R10;
		/* 820C46ACh case    2:*/		return 0x820C46B0;
	}
	return 0x820C46B0;
} // Block from 820C46A4h-820C46B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C46B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C46B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C46B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C46B0);
		  /* 820C46B0h */ case    0:  		/* stw R10, <#[R6]> */
		/* 820C46B0h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 820C46B0h case    0:*/		return 0x820C46B4;
	}
	return 0x820C46B4;
} // Block from 820C46B0h-820C46B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C46B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C46B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C46B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C46B4);
		  /* 820C46B4h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 820C46B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820C46B4h case    0:*/		return 0x820C46B8;
		  /* 820C46B8h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 820C46B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C46F0;  }
		/* 820C46B8h case    1:*/		return 0x820C46BC;
		  /* 820C46BCh */ case    2:  		/* b 44 */
		/* 820C46BCh case    2:*/		return 0x820C46E8;
		/* 820C46BCh case    2:*/		return 0x820C46C0;
		  /* 820C46C0h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 820C46C0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C46C0h case    3:*/		return 0x820C46C4;
		  /* 820C46C4h */ case    4:  		/* bc 12, CR6_EQ, 44 */
		/* 820C46C4h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C46F0;  }
		/* 820C46C4h case    4:*/		return 0x820C46C8;
		  /* 820C46C8h */ case    5:  		/* mr R4, R5 */
		/* 820C46C8h case    5:*/		regs.R4 = regs.R5;
		/* 820C46C8h case    5:*/		return 0x820C46CC;
		  /* 820C46CCh */ case    6:  		/* mr R3, R7 */
		/* 820C46CCh case    6:*/		regs.R3 = regs.R7;
		/* 820C46CCh case    6:*/		return 0x820C46D0;
		  /* 820C46D0h */ case    7:  		/* bl -1232 */
		/* 820C46D0h case    7:*/		regs.LR = 0x820C46D4; return 0x820C4200;
		/* 820C46D0h case    7:*/		return 0x820C46D4;
		  /* 820C46D4h */ case    8:  		/* cmpwi CR0, R3, 0 */
		/* 820C46D4h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C46D4h case    8:*/		return 0x820C46D8;
		  /* 820C46D8h */ case    9:  		/* bc 12, CR0_LT, 28 */
		/* 820C46D8h case    9:*/		if ( regs.CR[0].lt ) { return 0x820C46F4;  }
		/* 820C46D8h case    9:*/		return 0x820C46DC;
		  /* 820C46DCh */ case   10:  		/* lwz R7, <#[R7 + 36]> */
		/* 820C46DCh case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000024) );
		/* 820C46DCh case   10:*/		return 0x820C46E0;
		  /* 820C46E0h */ case   11:  		/* addi R5, R5, 48 */
		/* 820C46E0h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x30);
		/* 820C46E0h case   11:*/		return 0x820C46E4;
		  /* 820C46E4h */ case   12:  		/* addi R31, R31, -1 */
		/* 820C46E4h case   12:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 820C46E4h case   12:*/		return 0x820C46E8;
	}
	return 0x820C46E8;
} // Block from 820C46B4h-820C46E8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C46E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C46E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C46E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C46E8);
		  /* 820C46E8h */ case    0:  		/* cmplwi CR6, R7, 0 */
		/* 820C46E8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820C46E8h case    0:*/		return 0x820C46EC;
		  /* 820C46ECh */ case    1:  		/* bc 4, CR6_EQ, -44 */
		/* 820C46ECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C46C0;  }
		/* 820C46ECh case    1:*/		return 0x820C46F0;
	}
	return 0x820C46F0;
} // Block from 820C46E8h-820C46F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C46F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C46F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C46F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C46F0);
		  /* 820C46F0h */ case    0:  		/* li R3, 0 */
		/* 820C46F0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C46F0h case    0:*/		return 0x820C46F4;
	}
	return 0x820C46F4;
} // Block from 820C46F0h-820C46F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C46F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C46F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C46F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C46F4);
		  /* 820C46F4h */ case    0:  		/* addi R1, R1, 96 */
		/* 820C46F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C46F4h case    0:*/		return 0x820C46F8;
		  /* 820C46F8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C46F8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C46F8h case    1:*/		return 0x820C46FC;
		  /* 820C46FCh */ case    2:  		/* mtspr LR, R12 */
		/* 820C46FCh case    2:*/		regs.LR = regs.R12;
		/* 820C46FCh case    2:*/		return 0x820C4700;
		  /* 820C4700h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820C4700h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C4700h case    3:*/		return 0x820C4704;
		  /* 820C4704h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820C4704h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4704h case    4:*/		return 0x820C4708;
	}
	return 0x820C4708;
} // Block from 820C46F4h-820C4708h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C4708h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4708);
		  /* 820C4708h */ case    0:  		/* nor R11, R4, R4 */
		/* 820C4708h case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R4,regs.R4);
		/* 820C4708h case    0:*/		return 0x820C470C;
		  /* 820C470Ch */ case    1:  		/* li R3, -1 */
		/* 820C470Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 820C470Ch case    1:*/		return 0x820C4710;
		  /* 820C4710h */ case    2:  		/* lhz R10, <#[R11 + 8]> */
		/* 820C4710h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820C4710h case    2:*/		return 0x820C4714;
		  /* 820C4714h */ case    3:  		/* cmplwi CR6, R10, 3 */
		/* 820C4714h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C4714h case    3:*/		return 0x820C4718;
		  /* 820C4718h */ case    4:  		/* bclr 4, CR6_EQ */
		/* 820C4718h case    4:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820C4718h case    4:*/		return 0x820C471C;
	}
	return 0x820C471C;
} // Block from 820C4708h-820C471Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C471Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C471C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C471C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C471C);
		  /* 820C471Ch */ case    0:  		/* lhz R3, <#[R11 + 10]> */
		/* 820C471Ch case    0:*/		cpu::mem::load16z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000A) );
		/* 820C471Ch case    0:*/		return 0x820C4720;
		  /* 820C4720h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820C4720h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4720h case    1:*/		return 0x820C4724;
	}
	return 0x820C4724;
} // Block from 820C471Ch-820C4724h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C4724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4724);
		  /* 820C4724h */ case    0:  		/* nop */
		/* 820C4724h case    0:*/		cpu::op::nop();
		/* 820C4724h case    0:*/		return 0x820C4728;
	}
	return 0x820C4728;
} // Block from 820C4724h-820C4728h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C4728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4728);
		  /* 820C4728h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820C4728h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C4728h case    0:*/		return 0x820C472C;
		  /* 820C472Ch */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 820C472Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C4754;  }
		/* 820C472Ch case    1:*/		return 0x820C4730;
		  /* 820C4730h */ case    2:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C4730h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C4730h case    2:*/		return 0x820C4734;
		  /* 820C4734h */ case    3:  		/* cmplw CR6, R5, R11 */
		/* 820C4734h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 820C4734h case    3:*/		return 0x820C4738;
		  /* 820C4738h */ case    4:  		/* bc 12, CR6_LT, 12 */
		/* 820C4738h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C4744;  }
		/* 820C4738h case    4:*/		return 0x820C473C;
		  /* 820C473Ch */ case    5:  		/* li R3, 0 */
		/* 820C473Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C473Ch case    5:*/		return 0x820C4740;
		  /* 820C4740h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C4740h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4740h case    6:*/		return 0x820C4744;
	}
	return 0x820C4744;
} // Block from 820C4728h-820C4744h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C4744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4744);
		  /* 820C4744h */ case    0:  		/* lwz R11, <#[R3 + 20]> */
		/* 820C4744h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820C4744h case    0:*/		return 0x820C4748;
		  /* 820C4748h */ case    1:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 820C4748h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 820C4748h case    1:*/		return 0x820C474C;
		  /* 820C474Ch */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 820C474Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820C474Ch case    2:*/		return 0x820C4750;
		  /* 820C4750h */ case    3:  		/* b 56 */
		/* 820C4750h case    3:*/		return 0x820C4788;
		/* 820C4750h case    3:*/		return 0x820C4754;
	}
	return 0x820C4754;
} // Block from 820C4744h-820C4754h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C4754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4754);
		  /* 820C4754h */ case    0:  		/* nor R11, R4, R4 */
		/* 820C4754h case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R4,regs.R4);
		/* 820C4754h case    0:*/		return 0x820C4758;
		  /* 820C4758h */ case    1:  		/* lwz R10, <#[R11 + 24]> */
		/* 820C4758h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 820C4758h case    1:*/		return 0x820C475C;
		  /* 820C475Ch */ case    2:  		/* lhz R10, <#[R10 + 10]> */
		/* 820C475Ch case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000A) );
		/* 820C475Ch case    2:*/		return 0x820C4760;
		  /* 820C4760h */ case    3:  		/* cmplw CR6, R5, R10 */
		/* 820C4760h case    3:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R10);
		/* 820C4760h case    3:*/		return 0x820C4764;
		  /* 820C4764h */ case    4:  		/* bc 12, CR6_LT, 12 */
		/* 820C4764h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C4770;  }
		/* 820C4764h case    4:*/		return 0x820C4768;
		  /* 820C4768h */ case    5:  		/* li R11, 0 */
		/* 820C4768h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C4768h case    5:*/		return 0x820C476C;
		  /* 820C476Ch */ case    6:  		/* b 16 */
		/* 820C476Ch case    6:*/		return 0x820C477C;
		/* 820C476Ch case    6:*/		return 0x820C4770;
	}
	return 0x820C4770;
} // Block from 820C4754h-820C4770h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C4770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4770);
		  /* 820C4770h */ case    0:  		/* lwz R11, <#[R11 + 56]> */
		/* 820C4770h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000038) );
		/* 820C4770h case    0:*/		return 0x820C4774;
		  /* 820C4774h */ case    1:  		/* rlwinm R10, R5, 2, 0, 29 */
		/* 820C4774h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R5);
		/* 820C4774h case    1:*/		return 0x820C4778;
		  /* 820C4778h */ case    2:  		/* lwzx R11, <#[R11 + R10]> */
		/* 820C4778h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C4778h case    2:*/		return 0x820C477C;
	}
	return 0x820C477C;
} // Block from 820C4770h-820C477Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C477Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C477C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C477C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C477C);
		  /* 820C477Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C477Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C477Ch case    0:*/		return 0x820C4780;
		  /* 820C4780h */ case    1:  		/* li R3, 0 */
		/* 820C4780h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4780h case    1:*/		return 0x820C4784;
		  /* 820C4784h */ case    2:  		/* bclr 12, CR6_EQ */
		/* 820C4784h case    2:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820C4784h case    2:*/		return 0x820C4788;
	}
	return 0x820C4788;
} // Block from 820C477Ch-820C4788h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C4788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4788);
		  /* 820C4788h */ case    0:  		/* nor R3, R11, R11 */
		/* 820C4788h case    0:*/		cpu::op::nor<0>(regs,&regs.R3,regs.R11,regs.R11);
		/* 820C4788h case    0:*/		return 0x820C478C;
		  /* 820C478Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820C478Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C478Ch case    1:*/		return 0x820C4790;
	}
	return 0x820C4790;
} // Block from 820C4788h-820C4790h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C4790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4790);
		  /* 820C4790h */ case    0:  		/* mfspr R12, LR */
		/* 820C4790h case    0:*/		regs.R12 = regs.LR;
		/* 820C4790h case    0:*/		return 0x820C4794;
		  /* 820C4794h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4794h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4794h case    1:*/		return 0x820C4798;
		  /* 820C4798h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4798h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4798h case    2:*/		return 0x820C479C;
		  /* 820C479Ch */ case    3:  		/* mr R6, R7 */
		/* 820C479Ch case    3:*/		regs.R6 = regs.R7;
		/* 820C479Ch case    3:*/		return 0x820C47A0;
		  /* 820C47A0h */ case    4:  		/* bl -375736 */
		/* 820C47A0h case    4:*/		regs.LR = 0x820C47A4; return 0x82068BE8;
		/* 820C47A0h case    4:*/		return 0x820C47A4;
		  /* 820C47A4h */ case    5:  		/* li R3, 0 */
		/* 820C47A4h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C47A4h case    5:*/		return 0x820C47A8;
		  /* 820C47A8h */ case    6:  		/* addi R1, R1, 96 */
		/* 820C47A8h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C47A8h case    6:*/		return 0x820C47AC;
		  /* 820C47ACh */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C47ACh case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C47ACh case    7:*/		return 0x820C47B0;
		  /* 820C47B0h */ case    8:  		/* mtspr LR, R12 */
		/* 820C47B0h case    8:*/		regs.LR = regs.R12;
		/* 820C47B0h case    8:*/		return 0x820C47B4;
		  /* 820C47B4h */ case    9:  		/* bclr 20, CR0_LT */
		/* 820C47B4h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C47B4h case    9:*/		return 0x820C47B8;
	}
	return 0x820C47B8;
} // Block from 820C4790h-820C47B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C47B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C47B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C47B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C47B8);
		  /* 820C47B8h */ case    0:  		/* mfspr R12, LR */
		/* 820C47B8h case    0:*/		regs.R12 = regs.LR;
		/* 820C47B8h case    0:*/		return 0x820C47BC;
		  /* 820C47BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C47BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C47BCh case    1:*/		return 0x820C47C0;
		  /* 820C47C0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C47C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C47C0h case    2:*/		return 0x820C47C4;
		  /* 820C47C4h */ case    3:  		/* cmplwi CR6, R7, 0 */
		/* 820C47C4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820C47C4h case    3:*/		return 0x820C47C8;
		  /* 820C47C8h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 820C47C8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C47F0;  }
		/* 820C47C8h case    4:*/		return 0x820C47CC;
		  /* 820C47CCh */ case    5:  		/* mr R11, R6 */
		/* 820C47CCh case    5:*/		regs.R11 = regs.R6;
		/* 820C47CCh case    5:*/		return 0x820C47D0;
		  /* 820C47D0h */ case    6:  		/* mtspr CTR, R7 */
		/* 820C47D0h case    6:*/		regs.CTR = regs.R7;
		/* 820C47D0h case    6:*/		return 0x820C47D4;
		  /* 820C47D4h */ case    7:  		/* subf R10, R6, R5 */
		/* 820C47D4h case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R6,regs.R5);
		/* 820C47D4h case    7:*/		return 0x820C47D8;
		  /* 820C47D8h */ case    8:  		/* lwzx R9, <#[R10 + R11]> */
		/* 820C47D8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820C47D8h case    8:*/		return 0x820C47DC;
		  /* 820C47DCh */ case    9:  		/* addic R8, R9, -1 */
		/* 820C47DCh case    9:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 820C47DCh case    9:*/		return 0x820C47E0;
		  /* 820C47E0h */ case   10:  		/* subfe R9, R8, R9 */
		/* 820C47E0h case   10:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C47E0h case   10:*/		return 0x820C47E4;
		  /* 820C47E4h */ case   11:  		/* stw R9, <#[R11]> */
		/* 820C47E4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C47E4h case   11:*/		return 0x820C47E8;
		  /* 820C47E8h */ case   12:  		/* addi R11, R11, 4 */
		/* 820C47E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820C47E8h case   12:*/		return 0x820C47EC;
		  /* 820C47ECh */ case   13:  		/* bc 16, CR0_LT, -20 */
		/* 820C47ECh case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C47D8;  }
		/* 820C47ECh case   13:*/		return 0x820C47F0;
	}
	return 0x820C47F0;
} // Block from 820C47B8h-820C47F0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C47F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C47F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C47F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C47F0);
		  /* 820C47F0h */ case    0:  		/* mr R6, R7 */
		/* 820C47F0h case    0:*/		regs.R6 = regs.R7;
		/* 820C47F0h case    0:*/		return 0x820C47F4;
		  /* 820C47F4h */ case    1:  		/* bl -375820 */
		/* 820C47F4h case    1:*/		regs.LR = 0x820C47F8; return 0x82068BE8;
		/* 820C47F4h case    1:*/		return 0x820C47F8;
		  /* 820C47F8h */ case    2:  		/* li R3, 0 */
		/* 820C47F8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C47F8h case    2:*/		return 0x820C47FC;
		  /* 820C47FCh */ case    3:  		/* addi R1, R1, 96 */
		/* 820C47FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C47FCh case    3:*/		return 0x820C4800;
		  /* 820C4800h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4800h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4800h case    4:*/		return 0x820C4804;
		  /* 820C4804h */ case    5:  		/* mtspr LR, R12 */
		/* 820C4804h case    5:*/		regs.LR = regs.R12;
		/* 820C4804h case    5:*/		return 0x820C4808;
		  /* 820C4808h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C4808h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4808h case    6:*/		return 0x820C480C;
	}
	return 0x820C480C;
} // Block from 820C47F0h-820C480Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C480Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C480C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C480C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C480C);
		  /* 820C480Ch */ case    0:  		/* nop */
		/* 820C480Ch case    0:*/		cpu::op::nop();
		/* 820C480Ch case    0:*/		return 0x820C4810;
	}
	return 0x820C4810;
} // Block from 820C480Ch-820C4810h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C4810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4810);
		  /* 820C4810h */ case    0:  		/* mfspr R12, LR */
		/* 820C4810h case    0:*/		regs.R12 = regs.LR;
		/* 820C4810h case    0:*/		return 0x820C4814;
		  /* 820C4814h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4814h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4814h case    1:*/		return 0x820C4818;
		  /* 820C4818h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4818h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4818h case    2:*/		return 0x820C481C;
		  /* 820C481Ch */ case    3:  		/* mr R11, R6 */
		/* 820C481Ch case    3:*/		regs.R11 = regs.R6;
		/* 820C481Ch case    3:*/		return 0x820C4820;
		  /* 820C4820h */ case    4:  		/* cmplwi CR6, R7, 0 */
		/* 820C4820h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820C4820h case    4:*/		return 0x820C4824;
		  /* 820C4824h */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 820C4824h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C4858;  }
		/* 820C4824h case    5:*/		return 0x820C4828;
		  /* 820C4828h */ case    6:  		/* lis R10, -32256 */
		/* 820C4828h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820C4828h case    6:*/		return 0x820C482C;
		  /* 820C482Ch */ case    7:  		/* mtspr CTR, R7 */
		/* 820C482Ch case    7:*/		regs.CTR = regs.R7;
		/* 820C482Ch case    7:*/		return 0x820C4830;
		  /* 820C4830h */ case    8:  		/* subf R9, R6, R5 */
		/* 820C4830h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R5);
		/* 820C4830h case    8:*/		return 0x820C4834;
		  /* 820C4834h */ case    9:  		/* lfs FR0, <#[R10 + 1816]> */
		/* 820C4834h case    9:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000718) );
		/* 820C4834h case    9:*/		return 0x820C4838;
		  /* 820C4838h */ case   10:  		/* lfsx FR13, <#[R9 + R11]> */
		/* 820C4838h case   10:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820C4838h case   10:*/		return 0x820C483C;
		  /* 820C483Ch */ case   11:  		/* li R10, 1 */
		/* 820C483Ch case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820C483Ch case   11:*/		return 0x820C4840;
		  /* 820C4840h */ case   12:  		/* fcmpu CR6, FR13, FR0 */
		/* 820C4840h case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820C4840h case   12:*/		return 0x820C4844;
		  /* 820C4844h */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 820C4844h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820C484C;  }
		/* 820C4844h case   13:*/		return 0x820C4848;
		  /* 820C4848h */ case   14:  		/* li R10, 0 */
		/* 820C4848h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C4848h case   14:*/		return 0x820C484C;
	}
	return 0x820C484C;
} // Block from 820C4810h-820C484Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C484Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C484C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C484C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C484C);
		  /* 820C484Ch */ case    0:  		/* stw R10, <#[R11]> */
		/* 820C484Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C484Ch case    0:*/		return 0x820C4850;
		  /* 820C4850h */ case    1:  		/* addi R11, R11, 4 */
		/* 820C4850h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820C4850h case    1:*/		return 0x820C4854;
		  /* 820C4854h */ case    2:  		/* bc 16, CR0_LT, -28 */
		/* 820C4854h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C4838;  }
		/* 820C4854h case    2:*/		return 0x820C4858;
	}
	return 0x820C4858;
} // Block from 820C484Ch-820C4858h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C4858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4858);
		  /* 820C4858h */ case    0:  		/* mr R6, R7 */
		/* 820C4858h case    0:*/		regs.R6 = regs.R7;
		/* 820C4858h case    0:*/		return 0x820C485C;
		  /* 820C485Ch */ case    1:  		/* bl -375924 */
		/* 820C485Ch case    1:*/		regs.LR = 0x820C4860; return 0x82068BE8;
		/* 820C485Ch case    1:*/		return 0x820C4860;
		  /* 820C4860h */ case    2:  		/* li R3, 0 */
		/* 820C4860h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4860h case    2:*/		return 0x820C4864;
		  /* 820C4864h */ case    3:  		/* addi R1, R1, 96 */
		/* 820C4864h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4864h case    3:*/		return 0x820C4868;
		  /* 820C4868h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4868h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4868h case    4:*/		return 0x820C486C;
		  /* 820C486Ch */ case    5:  		/* mtspr LR, R12 */
		/* 820C486Ch case    5:*/		regs.LR = regs.R12;
		/* 820C486Ch case    5:*/		return 0x820C4870;
		  /* 820C4870h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C4870h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4870h case    6:*/		return 0x820C4874;
	}
	return 0x820C4874;
} // Block from 820C4858h-820C4874h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C4874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4874);
		  /* 820C4874h */ case    0:  		/* nop */
		/* 820C4874h case    0:*/		cpu::op::nop();
		/* 820C4874h case    0:*/		return 0x820C4878;
	}
	return 0x820C4878;
} // Block from 820C4874h-820C4878h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C4878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4878);
		  /* 820C4878h */ case    0:  		/* mfspr R12, LR */
		/* 820C4878h case    0:*/		regs.R12 = regs.LR;
		/* 820C4878h case    0:*/		return 0x820C487C;
		  /* 820C487Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C487Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C487Ch case    1:*/		return 0x820C4880;
		  /* 820C4880h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4880h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4880h case    2:*/		return 0x820C4884;
		  /* 820C4884h */ case    3:  		/* mr R6, R7 */
		/* 820C4884h case    3:*/		regs.R6 = regs.R7;
		/* 820C4884h case    3:*/		return 0x820C4888;
		  /* 820C4888h */ case    4:  		/* bl -375776 */
		/* 820C4888h case    4:*/		regs.LR = 0x820C488C; return 0x82068CA8;
		/* 820C4888h case    4:*/		return 0x820C488C;
		  /* 820C488Ch */ case    5:  		/* li R3, 0 */
		/* 820C488Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C488Ch case    5:*/		return 0x820C4890;
		  /* 820C4890h */ case    6:  		/* addi R1, R1, 96 */
		/* 820C4890h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4890h case    6:*/		return 0x820C4894;
		  /* 820C4894h */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4894h case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4894h case    7:*/		return 0x820C4898;
		  /* 820C4898h */ case    8:  		/* mtspr LR, R12 */
		/* 820C4898h case    8:*/		regs.LR = regs.R12;
		/* 820C4898h case    8:*/		return 0x820C489C;
		  /* 820C489Ch */ case    9:  		/* bclr 20, CR0_LT */
		/* 820C489Ch case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C489Ch case    9:*/		return 0x820C48A0;
	}
	return 0x820C48A0;
} // Block from 820C4878h-820C48A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C48A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C48A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C48A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C48A0);
		  /* 820C48A0h */ case    0:  		/* mfspr R12, LR */
		/* 820C48A0h case    0:*/		regs.R12 = regs.LR;
		/* 820C48A0h case    0:*/		return 0x820C48A4;
		  /* 820C48A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C48A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C48A4h case    1:*/		return 0x820C48A8;
		  /* 820C48A8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C48A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C48A8h case    2:*/		return 0x820C48AC;
		  /* 820C48ACh */ case    3:  		/* mr R10, R6 */
		/* 820C48ACh case    3:*/		regs.R10 = regs.R6;
		/* 820C48ACh case    3:*/		return 0x820C48B0;
		  /* 820C48B0h */ case    4:  		/* rlwinm. R11, R7, 2, 0, 29 */
		/* 820C48B0h case    4:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820C48B0h case    4:*/		return 0x820C48B4;
		  /* 820C48B4h */ case    5:  		/* bc 12, CR0_EQ, 36 */
		/* 820C48B4h case    5:*/		if ( regs.CR[0].eq ) { return 0x820C48D8;  }
		/* 820C48B4h case    5:*/		return 0x820C48B8;
		  /* 820C48B8h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C48B8h case    6:*/		regs.CTR = regs.R11;
		/* 820C48B8h case    6:*/		return 0x820C48BC;
		  /* 820C48BCh */ case    7:  		/* subf R11, R6, R5 */
		/* 820C48BCh case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 820C48BCh case    7:*/		return 0x820C48C0;
		  /* 820C48C0h */ case    8:  		/* lwzx R9, <#[R11 + R10]> */
		/* 820C48C0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C48C0h case    8:*/		return 0x820C48C4;
		  /* 820C48C4h */ case    9:  		/* addic R8, R9, -1 */
		/* 820C48C4h case    9:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 820C48C4h case    9:*/		return 0x820C48C8;
		  /* 820C48C8h */ case   10:  		/* subfe R9, R8, R9 */
		/* 820C48C8h case   10:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C48C8h case   10:*/		return 0x820C48CC;
		  /* 820C48CCh */ case   11:  		/* stw R9, <#[R10]> */
		/* 820C48CCh case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820C48CCh case   11:*/		return 0x820C48D0;
		  /* 820C48D0h */ case   12:  		/* addi R10, R10, 4 */
		/* 820C48D0h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C48D0h case   12:*/		return 0x820C48D4;
		  /* 820C48D4h */ case   13:  		/* bc 16, CR0_LT, -20 */
		/* 820C48D4h case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C48C0;  }
		/* 820C48D4h case   13:*/		return 0x820C48D8;
	}
	return 0x820C48D8;
} // Block from 820C48A0h-820C48D8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C48D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C48D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C48D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C48D8);
		  /* 820C48D8h */ case    0:  		/* mr R6, R7 */
		/* 820C48D8h case    0:*/		regs.R6 = regs.R7;
		/* 820C48D8h case    0:*/		return 0x820C48DC;
		  /* 820C48DCh */ case    1:  		/* bl -375860 */
		/* 820C48DCh case    1:*/		regs.LR = 0x820C48E0; return 0x82068CA8;
		/* 820C48DCh case    1:*/		return 0x820C48E0;
		  /* 820C48E0h */ case    2:  		/* li R3, 0 */
		/* 820C48E0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C48E0h case    2:*/		return 0x820C48E4;
		  /* 820C48E4h */ case    3:  		/* addi R1, R1, 96 */
		/* 820C48E4h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C48E4h case    3:*/		return 0x820C48E8;
		  /* 820C48E8h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C48E8h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C48E8h case    4:*/		return 0x820C48EC;
		  /* 820C48ECh */ case    5:  		/* mtspr LR, R12 */
		/* 820C48ECh case    5:*/		regs.LR = regs.R12;
		/* 820C48ECh case    5:*/		return 0x820C48F0;
		  /* 820C48F0h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C48F0h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C48F0h case    6:*/		return 0x820C48F4;
	}
	return 0x820C48F4;
} // Block from 820C48D8h-820C48F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C48F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C48F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C48F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C48F4);
		  /* 820C48F4h */ case    0:  		/* nop */
		/* 820C48F4h case    0:*/		cpu::op::nop();
		/* 820C48F4h case    0:*/		return 0x820C48F8;
	}
	return 0x820C48F8;
} // Block from 820C48F4h-820C48F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C48F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C48F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C48F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C48F8);
		  /* 820C48F8h */ case    0:  		/* mfspr R12, LR */
		/* 820C48F8h case    0:*/		regs.R12 = regs.LR;
		/* 820C48F8h case    0:*/		return 0x820C48FC;
		  /* 820C48FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C48FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C48FCh case    1:*/		return 0x820C4900;
		  /* 820C4900h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4900h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4900h case    2:*/		return 0x820C4904;
		  /* 820C4904h */ case    3:  		/* mr R10, R6 */
		/* 820C4904h case    3:*/		regs.R10 = regs.R6;
		/* 820C4904h case    3:*/		return 0x820C4908;
		  /* 820C4908h */ case    4:  		/* rlwinm. R11, R7, 2, 0, 29 */
		/* 820C4908h case    4:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820C4908h case    4:*/		return 0x820C490C;
		  /* 820C490Ch */ case    5:  		/* bc 12, CR0_EQ, 32 */
		/* 820C490Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820C492C;  }
		/* 820C490Ch case    5:*/		return 0x820C4910;
		  /* 820C4910h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C4910h case    6:*/		regs.CTR = regs.R11;
		/* 820C4910h case    6:*/		return 0x820C4914;
		  /* 820C4914h */ case    7:  		/* subf R11, R6, R5 */
		/* 820C4914h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 820C4914h case    7:*/		return 0x820C4918;
		  /* 820C4918h */ case    8:  		/* lfsx FR0, <#[R11 + R10]> */
		/* 820C4918h case    8:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C4918h case    8:*/		return 0x820C491C;
		  /* 820C491Ch */ case    9:  		/* fctiwz FR0, FR0 */
		/* 820C491Ch case    9:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 820C491Ch case    9:*/		return 0x820C4920;
		  /* 820C4920h */ case   10:  		/* stfiwx FR0, <#[R10]> */
		/* 820C4920h case   10:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C4920h case   10:*/		return 0x820C4924;
		  /* 820C4924h */ case   11:  		/* addi R10, R10, 4 */
		/* 820C4924h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C4924h case   11:*/		return 0x820C4928;
		  /* 820C4928h */ case   12:  		/* bc 16, CR0_LT, -16 */
		/* 820C4928h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C4918;  }
		/* 820C4928h case   12:*/		return 0x820C492C;
	}
	return 0x820C492C;
} // Block from 820C48F8h-820C492Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C492Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C492C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C492C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C492C);
		  /* 820C492Ch */ case    0:  		/* mr R6, R7 */
		/* 820C492Ch case    0:*/		regs.R6 = regs.R7;
		/* 820C492Ch case    0:*/		return 0x820C4930;
		  /* 820C4930h */ case    1:  		/* bl -375944 */
		/* 820C4930h case    1:*/		regs.LR = 0x820C4934; return 0x82068CA8;
		/* 820C4930h case    1:*/		return 0x820C4934;
		  /* 820C4934h */ case    2:  		/* li R3, 0 */
		/* 820C4934h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4934h case    2:*/		return 0x820C4938;
		  /* 820C4938h */ case    3:  		/* addi R1, R1, 96 */
		/* 820C4938h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4938h case    3:*/		return 0x820C493C;
		  /* 820C493Ch */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C493Ch case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C493Ch case    4:*/		return 0x820C4940;
		  /* 820C4940h */ case    5:  		/* mtspr LR, R12 */
		/* 820C4940h case    5:*/		regs.LR = regs.R12;
		/* 820C4940h case    5:*/		return 0x820C4944;
		  /* 820C4944h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C4944h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4944h case    6:*/		return 0x820C4948;
	}
	return 0x820C4948;
} // Block from 820C492Ch-820C4948h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C4948h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4948);
		  /* 820C4948h */ case    0:  		/* mfspr R12, LR */
		/* 820C4948h case    0:*/		regs.R12 = regs.LR;
		/* 820C4948h case    0:*/		return 0x820C494C;
		  /* 820C494Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C494Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C494Ch case    1:*/		return 0x820C4950;
		  /* 820C4950h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4950h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4950h case    2:*/		return 0x820C4954;
		  /* 820C4954h */ case    3:  		/* add R11, R4, R7 */
		/* 820C4954h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R7);
		/* 820C4954h case    3:*/		return 0x820C4958;
		  /* 820C4958h */ case    4:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 820C4958h case    4:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 820C4958h case    4:*/		return 0x820C495C;
		  /* 820C495Ch */ case    5:  		/* addi R11, R11, -1 */
		/* 820C495Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820C495Ch case    5:*/		return 0x820C4960;
	}
	return 0x820C4960;
} // Block from 820C4948h-820C4960h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C4960h
// Function '?Compile@CCompiler@D3DXShader@@QAAJPAVCPreProcessor@2@PAVCNode@2@PBDH2KPAPAUID3DXBuffer@@PAPAUID3DXConstantTable@@PAU_D3DXSHADER_COMPILE_PARAMETERSA@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4960);
		  /* 820C4960h */ case    0:  		/* li R9, 1 */
		/* 820C4960h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820C4960h case    0:*/		return 0x820C4964;
		  /* 820C4964h */ case    1:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 820C4964h case    1:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 820C4964h case    1:*/		return 0x820C4968;
		  /* 820C4968h */ case    2:  		/* rldicr R9, R9, 63, 63 */
		/* 820C4968h case    2:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 820C4968h case    2:*/		return 0x820C496C;
		  /* 820C496Ch */ case    3:  		/* subf R11, R10, R11 */
		/* 820C496Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C496Ch case    3:*/		return 0x820C4970;
		  /* 820C4970h */ case    4:  		/* mr R6, R7 */
		/* 820C4970h case    4:*/		regs.R6 = regs.R7;
		/* 820C4970h case    4:*/		return 0x820C4974;
		  /* 820C4974h */ case    5:  		/* rldicl R11, R11, 0, 32 */
		/* 820C4974h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 820C4974h case    5:*/		return 0x820C4978;
		  /* 820C4978h */ case    6:  		/* srad R11, R9, R11 */
		/* 820C4978h case    6:*/		cpu::op::srad<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820C4978h case    6:*/		return 0x820C497C;
		  /* 820C497Ch */ case    7:  		/* srd R7, R11, R10 */
		/* 820C497Ch case    7:*/		cpu::op::srd<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 820C497Ch case    7:*/		return 0x820C4980;
		  /* 820C4980h */ case    8:  		/* bl -376648 */
		/* 820C4980h case    8:*/		regs.LR = 0x820C4984; return 0x82068A38;
		/* 820C4980h case    8:*/		return 0x820C4984;
		  /* 820C4984h */ case    9:  		/* li R3, 0 */
		/* 820C4984h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4984h case    9:*/		return 0x820C4988;
		  /* 820C4988h */ case   10:  		/* addi R1, R1, 96 */
		/* 820C4988h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4988h case   10:*/		return 0x820C498C;
		  /* 820C498Ch */ case   11:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C498Ch case   11:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C498Ch case   11:*/		return 0x820C4990;
		  /* 820C4990h */ case   12:  		/* mtspr LR, R12 */
		/* 820C4990h case   12:*/		regs.LR = regs.R12;
		/* 820C4990h case   12:*/		return 0x820C4994;
		  /* 820C4994h */ case   13:  		/* bclr 20, CR0_LT */
		/* 820C4994h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4994h case   13:*/		return 0x820C4998;
	}
	return 0x820C4998;
} // Block from 820C4960h-820C4998h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C4998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4998);
		  /* 820C4998h */ case    0:  		/* mfspr R12, LR */
		/* 820C4998h case    0:*/		regs.R12 = regs.LR;
		/* 820C4998h case    0:*/		return 0x820C499C;
		  /* 820C499Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C499Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C499Ch case    1:*/		return 0x820C49A0;
		  /* 820C49A0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C49A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C49A0h case    2:*/		return 0x820C49A4;
		  /* 820C49A4h */ case    3:  		/* mr R10, R6 */
		/* 820C49A4h case    3:*/		regs.R10 = regs.R6;
		/* 820C49A4h case    3:*/		return 0x820C49A8;
		  /* 820C49A8h */ case    4:  		/* rlwinm. R11, R7, 2, 0, 29 */
		/* 820C49A8h case    4:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820C49A8h case    4:*/		return 0x820C49AC;
		  /* 820C49ACh */ case    5:  		/* bc 12, CR0_EQ, 56 */
		/* 820C49ACh case    5:*/		if ( regs.CR[0].eq ) { return 0x820C49E4;  }
		/* 820C49ACh case    5:*/		return 0x820C49B0;
		  /* 820C49B0h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C49B0h case    6:*/		regs.CTR = regs.R11;
		/* 820C49B0h case    6:*/		return 0x820C49B4;
		  /* 820C49B4h */ case    7:  		/* subf R11, R6, R5 */
		/* 820C49B4h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 820C49B4h case    7:*/		return 0x820C49B8;
		  /* 820C49B8h */ case    8:  		/* lwzx R9, <#[R11 + R10]> */
		/* 820C49B8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C49B8h case    8:*/		return 0x820C49BC;
		  /* 820C49BCh */ case    9:  		/* addic R8, R9, -1 */
		/* 820C49BCh case    9:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 820C49BCh case    9:*/		return 0x820C49C0;
		  /* 820C49C0h */ case   10:  		/* subfe R9, R8, R9 */
		/* 820C49C0h case   10:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C49C0h case   10:*/		return 0x820C49C4;
		  /* 820C49C4h */ case   11:  		/* extsw R9, R9 */
		/* 820C49C4h case   11:*/		cpu::op::extsw<0>(regs,&regs.R9,regs.R9);
		/* 820C49C4h case   11:*/		return 0x820C49C8;
		  /* 820C49C8h */ case   12:  		/* std R9, <#[R1 + 80]> */
		/* 820C49C8h case   12:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820C49C8h case   12:*/		return 0x820C49CC;
		  /* 820C49CCh */ case   13:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820C49CCh case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820C49CCh case   13:*/		return 0x820C49D0;
		  /* 820C49D0h */ case   14:  		/* fcfid FR0, FR0 */
		/* 820C49D0h case   14:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820C49D0h case   14:*/		return 0x820C49D4;
		  /* 820C49D4h */ case   15:  		/* frsp FR0, FR0 */
		/* 820C49D4h case   15:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820C49D4h case   15:*/		return 0x820C49D8;
		  /* 820C49D8h */ case   16:  		/* stfs FR0, <#[R10]> */
		/* 820C49D8h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C49D8h case   16:*/		return 0x820C49DC;
		  /* 820C49DCh */ case   17:  		/* addi R10, R10, 4 */
		/* 820C49DCh case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C49DCh case   17:*/		return 0x820C49E0;
	}
	return 0x820C49E0;
} // Block from 820C4998h-820C49E0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820C49E0h
// Function '?TypeSize@D3DXShader@@YAXPAVCConstantTable@1@PAU_D3DXSHADER_CONSTANTINFO@@PAU_D3DXSHADER_TYPEINFO@@IPAI3@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C49E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C49E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C49E0);
		  /* 820C49E0h */ case    0:  		/* bc 16, CR0_LT, -40 */
		/* 820C49E0h case    0:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C49B8;  }
		/* 820C49E0h case    0:*/		return 0x820C49E4;
	}
	return 0x820C49E4;
} // Block from 820C49E0h-820C49E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C49E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C49E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C49E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C49E4);
		  /* 820C49E4h */ case    0:  		/* add R11, R4, R7 */
		/* 820C49E4h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R7);
		/* 820C49E4h case    0:*/		return 0x820C49E8;
		  /* 820C49E8h */ case    1:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 820C49E8h case    1:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 820C49E8h case    1:*/		return 0x820C49EC;
		  /* 820C49ECh */ case    2:  		/* addi R11, R11, -1 */
		/* 820C49ECh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820C49ECh case    2:*/		return 0x820C49F0;
		  /* 820C49F0h */ case    3:  		/* li R9, 1 */
		/* 820C49F0h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820C49F0h case    3:*/		return 0x820C49F4;
		  /* 820C49F4h */ case    4:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 820C49F4h case    4:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 820C49F4h case    4:*/		return 0x820C49F8;
		  /* 820C49F8h */ case    5:  		/* rldicr R9, R9, 63, 63 */
		/* 820C49F8h case    5:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 820C49F8h case    5:*/		return 0x820C49FC;
		  /* 820C49FCh */ case    6:  		/* subf R11, R10, R11 */
		/* 820C49FCh case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C49FCh case    6:*/		return 0x820C4A00;
		  /* 820C4A00h */ case    7:  		/* mr R6, R7 */
		/* 820C4A00h case    7:*/		regs.R6 = regs.R7;
		/* 820C4A00h case    7:*/		return 0x820C4A04;
		  /* 820C4A04h */ case    8:  		/* rldicl R11, R11, 0, 32 */
		/* 820C4A04h case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 820C4A04h case    8:*/		return 0x820C4A08;
		  /* 820C4A08h */ case    9:  		/* srad R11, R9, R11 */
		/* 820C4A08h case    9:*/		cpu::op::srad<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820C4A08h case    9:*/		return 0x820C4A0C;
		  /* 820C4A0Ch */ case   10:  		/* srd R7, R11, R10 */
		/* 820C4A0Ch case   10:*/		cpu::op::srd<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 820C4A0Ch case   10:*/		return 0x820C4A10;
		  /* 820C4A10h */ case   11:  		/* bl -376792 */
		/* 820C4A10h case   11:*/		regs.LR = 0x820C4A14; return 0x82068A38;
		/* 820C4A10h case   11:*/		return 0x820C4A14;
		  /* 820C4A14h */ case   12:  		/* li R3, 0 */
		/* 820C4A14h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4A14h case   12:*/		return 0x820C4A18;
		  /* 820C4A18h */ case   13:  		/* addi R1, R1, 96 */
		/* 820C4A18h case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4A18h case   13:*/		return 0x820C4A1C;
		  /* 820C4A1Ch */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4A1Ch case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4A1Ch case   14:*/		return 0x820C4A20;
		  /* 820C4A20h */ case   15:  		/* mtspr LR, R12 */
		/* 820C4A20h case   15:*/		regs.LR = regs.R12;
		/* 820C4A20h case   15:*/		return 0x820C4A24;
		  /* 820C4A24h */ case   16:  		/* bclr 20, CR0_LT */
		/* 820C4A24h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4A24h case   16:*/		return 0x820C4A28;
	}
	return 0x820C4A28;
} // Block from 820C49E4h-820C4A28h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C4A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4A28);
		  /* 820C4A28h */ case    0:  		/* mfspr R12, LR */
		/* 820C4A28h case    0:*/		regs.R12 = regs.LR;
		/* 820C4A28h case    0:*/		return 0x820C4A2C;
		  /* 820C4A2Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4A2Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4A2Ch case    1:*/		return 0x820C4A30;
		  /* 820C4A30h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4A30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4A30h case    2:*/		return 0x820C4A34;
		  /* 820C4A34h */ case    3:  		/* mr R10, R6 */
		/* 820C4A34h case    3:*/		regs.R10 = regs.R6;
		/* 820C4A34h case    3:*/		return 0x820C4A38;
		  /* 820C4A38h */ case    4:  		/* rlwinm. R11, R7, 2, 0, 29 */
		/* 820C4A38h case    4:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820C4A38h case    4:*/		return 0x820C4A3C;
		  /* 820C4A3Ch */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 820C4A3Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820C4A68;  }
		/* 820C4A3Ch case    5:*/		return 0x820C4A40;
		  /* 820C4A40h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C4A40h case    6:*/		regs.CTR = regs.R11;
		/* 820C4A40h case    6:*/		return 0x820C4A44;
		  /* 820C4A44h */ case    7:  		/* subf R11, R6, R5 */
		/* 820C4A44h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 820C4A44h case    7:*/		return 0x820C4A48;
		  /* 820C4A48h */ case    8:  		/* lwax R9, <#[R11 + R10]> */
		/* 820C4A48h case    8:*/		cpu::mem::load32a( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C4A48h case    8:*/		return 0x820C4A4C;
		  /* 820C4A4Ch */ case    9:  		/* std R9, <#[R1 + 80]> */
		/* 820C4A4Ch case    9:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820C4A4Ch case    9:*/		return 0x820C4A50;
		  /* 820C4A50h */ case   10:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820C4A50h case   10:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820C4A50h case   10:*/		return 0x820C4A54;
		  /* 820C4A54h */ case   11:  		/* fcfid FR0, FR0 */
		/* 820C4A54h case   11:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820C4A54h case   11:*/		return 0x820C4A58;
		  /* 820C4A58h */ case   12:  		/* frsp FR0, FR0 */
		/* 820C4A58h case   12:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820C4A58h case   12:*/		return 0x820C4A5C;
		  /* 820C4A5Ch */ case   13:  		/* stfs FR0, <#[R10]> */
		/* 820C4A5Ch case   13:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C4A5Ch case   13:*/		return 0x820C4A60;
		  /* 820C4A60h */ case   14:  		/* addi R10, R10, 4 */
		/* 820C4A60h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C4A60h case   14:*/		return 0x820C4A64;
		  /* 820C4A64h */ case   15:  		/* bc 16, CR0_LT, -28 */
		/* 820C4A64h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C4A48;  }
		/* 820C4A64h case   15:*/		return 0x820C4A68;
	}
	return 0x820C4A68;
} // Block from 820C4A28h-820C4A68h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C4A68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4A68);
		  /* 820C4A68h */ case    0:  		/* add R11, R4, R7 */
		/* 820C4A68h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R7);
		/* 820C4A68h case    0:*/		return 0x820C4A6C;
		  /* 820C4A6Ch */ case    1:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 820C4A6Ch case    1:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 820C4A6Ch case    1:*/		return 0x820C4A70;
		  /* 820C4A70h */ case    2:  		/* addi R11, R11, -1 */
		/* 820C4A70h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820C4A70h case    2:*/		return 0x820C4A74;
		  /* 820C4A74h */ case    3:  		/* li R9, 1 */
		/* 820C4A74h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820C4A74h case    3:*/		return 0x820C4A78;
		  /* 820C4A78h */ case    4:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 820C4A78h case    4:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 820C4A78h case    4:*/		return 0x820C4A7C;
		  /* 820C4A7Ch */ case    5:  		/* rldicr R9, R9, 63, 63 */
		/* 820C4A7Ch case    5:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 820C4A7Ch case    5:*/		return 0x820C4A80;
		  /* 820C4A80h */ case    6:  		/* subf R11, R10, R11 */
		/* 820C4A80h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C4A80h case    6:*/		return 0x820C4A84;
		  /* 820C4A84h */ case    7:  		/* mr R6, R7 */
		/* 820C4A84h case    7:*/		regs.R6 = regs.R7;
		/* 820C4A84h case    7:*/		return 0x820C4A88;
		  /* 820C4A88h */ case    8:  		/* rldicl R11, R11, 0, 32 */
		/* 820C4A88h case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 820C4A88h case    8:*/		return 0x820C4A8C;
		  /* 820C4A8Ch */ case    9:  		/* srad R11, R9, R11 */
		/* 820C4A8Ch case    9:*/		cpu::op::srad<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820C4A8Ch case    9:*/		return 0x820C4A90;
		  /* 820C4A90h */ case   10:  		/* srd R7, R11, R10 */
		/* 820C4A90h case   10:*/		cpu::op::srd<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 820C4A90h case   10:*/		return 0x820C4A94;
		  /* 820C4A94h */ case   11:  		/* bl -376924 */
		/* 820C4A94h case   11:*/		regs.LR = 0x820C4A98; return 0x82068A38;
		/* 820C4A94h case   11:*/		return 0x820C4A98;
		  /* 820C4A98h */ case   12:  		/* li R3, 0 */
		/* 820C4A98h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4A98h case   12:*/		return 0x820C4A9C;
		  /* 820C4A9Ch */ case   13:  		/* addi R1, R1, 96 */
		/* 820C4A9Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4A9Ch case   13:*/		return 0x820C4AA0;
		  /* 820C4AA0h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4AA0h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4AA0h case   14:*/		return 0x820C4AA4;
		  /* 820C4AA4h */ case   15:  		/* mtspr LR, R12 */
		/* 820C4AA4h case   15:*/		regs.LR = regs.R12;
		/* 820C4AA4h case   15:*/		return 0x820C4AA8;
		  /* 820C4AA8h */ case   16:  		/* bclr 20, CR0_LT */
		/* 820C4AA8h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4AA8h case   16:*/		return 0x820C4AAC;
	}
	return 0x820C4AAC;
} // Block from 820C4A68h-820C4AACh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C4AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4AAC);
		  /* 820C4AACh */ case    0:  		/* nop */
		/* 820C4AACh case    0:*/		cpu::op::nop();
		/* 820C4AACh case    0:*/		return 0x820C4AB0;
	}
	return 0x820C4AB0;
} // Block from 820C4AACh-820C4AB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C4AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4AB0);
		  /* 820C4AB0h */ case    0:  		/* mfspr R12, LR */
		/* 820C4AB0h case    0:*/		regs.R12 = regs.LR;
		/* 820C4AB0h case    0:*/		return 0x820C4AB4;
		  /* 820C4AB4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4AB4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4AB4h case    1:*/		return 0x820C4AB8;
		  /* 820C4AB8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4AB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4AB8h case    2:*/		return 0x820C4ABC;
		  /* 820C4ABCh */ case    3:  		/* mr R6, R7 */
		/* 820C4ABCh case    3:*/		regs.R6 = regs.R7;
		/* 820C4ABCh case    3:*/		return 0x820C4AC0;
		  /* 820C4AC0h */ case    4:  		/* bl -376440 */
		/* 820C4AC0h case    4:*/		regs.LR = 0x820C4AC4; return 0x82068C48;
		/* 820C4AC0h case    4:*/		return 0x820C4AC4;
		  /* 820C4AC4h */ case    5:  		/* li R3, 0 */
		/* 820C4AC4h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4AC4h case    5:*/		return 0x820C4AC8;
		  /* 820C4AC8h */ case    6:  		/* addi R1, R1, 96 */
		/* 820C4AC8h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4AC8h case    6:*/		return 0x820C4ACC;
		  /* 820C4ACCh */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4ACCh case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4ACCh case    7:*/		return 0x820C4AD0;
		  /* 820C4AD0h */ case    8:  		/* mtspr LR, R12 */
		/* 820C4AD0h case    8:*/		regs.LR = regs.R12;
		/* 820C4AD0h case    8:*/		return 0x820C4AD4;
		  /* 820C4AD4h */ case    9:  		/* bclr 20, CR0_LT */
		/* 820C4AD4h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4AD4h case    9:*/		return 0x820C4AD8;
	}
	return 0x820C4AD8;
} // Block from 820C4AB0h-820C4AD8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C4AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4AD8);
		  /* 820C4AD8h */ case    0:  		/* mfspr R12, LR */
		/* 820C4AD8h case    0:*/		regs.R12 = regs.LR;
		/* 820C4AD8h case    0:*/		return 0x820C4ADC;
		  /* 820C4ADCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4ADCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4ADCh case    1:*/		return 0x820C4AE0;
		  /* 820C4AE0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4AE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4AE0h case    2:*/		return 0x820C4AE4;
		  /* 820C4AE4h */ case    3:  		/* cmplwi CR6, R7, 0 */
		/* 820C4AE4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820C4AE4h case    3:*/		return 0x820C4AE8;
		  /* 820C4AE8h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 820C4AE8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C4B10;  }
		/* 820C4AE8h case    4:*/		return 0x820C4AEC;
		  /* 820C4AECh */ case    5:  		/* mr R11, R6 */
		/* 820C4AECh case    5:*/		regs.R11 = regs.R6;
		/* 820C4AECh case    5:*/		return 0x820C4AF0;
	}
	return 0x820C4AF0;
} // Block from 820C4AD8h-820C4AF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C4AF0h
// Function '??0CConstant@D3DXShader@@QAA@PAVCConstantTable@1@PAU_D3DXSHADER_CONSTANTINFO@@PAU_D3DXSHADER_TYPEINFO@@P6AJPBXI3PAKI@Z4@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4AF0);
		  /* 820C4AF0h */ case    0:  		/* mtspr CTR, R7 */
		/* 820C4AF0h case    0:*/		regs.CTR = regs.R7;
		/* 820C4AF0h case    0:*/		return 0x820C4AF4;
		  /* 820C4AF4h */ case    1:  		/* subf R10, R6, R5 */
		/* 820C4AF4h case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R6,regs.R5);
		/* 820C4AF4h case    1:*/		return 0x820C4AF8;
		  /* 820C4AF8h */ case    2:  		/* lwzx R9, <#[R10 + R11]> */
		/* 820C4AF8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820C4AF8h case    2:*/		return 0x820C4AFC;
		  /* 820C4AFCh */ case    3:  		/* addic R8, R9, -1 */
		/* 820C4AFCh case    3:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 820C4AFCh case    3:*/		return 0x820C4B00;
		  /* 820C4B00h */ case    4:  		/* subfe R9, R8, R9 */
		/* 820C4B00h case    4:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C4B00h case    4:*/		return 0x820C4B04;
		  /* 820C4B04h */ case    5:  		/* stw R9, <#[R11]> */
		/* 820C4B04h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C4B04h case    5:*/		return 0x820C4B08;
		  /* 820C4B08h */ case    6:  		/* addi R11, R11, 4 */
		/* 820C4B08h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820C4B08h case    6:*/		return 0x820C4B0C;
		  /* 820C4B0Ch */ case    7:  		/* bc 16, CR0_LT, -20 */
		/* 820C4B0Ch case    7:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C4AF8;  }
		/* 820C4B0Ch case    7:*/		return 0x820C4B10;
	}
	return 0x820C4B10;
} // Block from 820C4AF0h-820C4B10h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C4B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4B10);
		  /* 820C4B10h */ case    0:  		/* mr R6, R7 */
		/* 820C4B10h case    0:*/		regs.R6 = regs.R7;
		/* 820C4B10h case    0:*/		return 0x820C4B14;
		  /* 820C4B14h */ case    1:  		/* bl -376524 */
		/* 820C4B14h case    1:*/		regs.LR = 0x820C4B18; return 0x82068C48;
		/* 820C4B14h case    1:*/		return 0x820C4B18;
		  /* 820C4B18h */ case    2:  		/* li R3, 0 */
		/* 820C4B18h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4B18h case    2:*/		return 0x820C4B1C;
		  /* 820C4B1Ch */ case    3:  		/* addi R1, R1, 96 */
		/* 820C4B1Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4B1Ch case    3:*/		return 0x820C4B20;
		  /* 820C4B20h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4B20h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4B20h case    4:*/		return 0x820C4B24;
		  /* 820C4B24h */ case    5:  		/* mtspr LR, R12 */
		/* 820C4B24h case    5:*/		regs.LR = regs.R12;
		/* 820C4B24h case    5:*/		return 0x820C4B28;
		  /* 820C4B28h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C4B28h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4B28h case    6:*/		return 0x820C4B2C;
	}
	return 0x820C4B2C;
} // Block from 820C4B10h-820C4B2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C4B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4B2C);
		  /* 820C4B2Ch */ case    0:  		/* nop */
		/* 820C4B2Ch case    0:*/		cpu::op::nop();
		/* 820C4B2Ch case    0:*/		return 0x820C4B30;
	}
	return 0x820C4B30;
} // Block from 820C4B2Ch-820C4B30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C4B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4B30);
		  /* 820C4B30h */ case    0:  		/* mfspr R12, LR */
		/* 820C4B30h case    0:*/		regs.R12 = regs.LR;
		/* 820C4B30h case    0:*/		return 0x820C4B34;
		  /* 820C4B34h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4B34h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4B34h case    1:*/		return 0x820C4B38;
		  /* 820C4B38h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4B38h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4B38h case    2:*/		return 0x820C4B3C;
		  /* 820C4B3Ch */ case    3:  		/* mr R11, R6 */
		/* 820C4B3Ch case    3:*/		regs.R11 = regs.R6;
		/* 820C4B3Ch case    3:*/		return 0x820C4B40;
		  /* 820C4B40h */ case    4:  		/* cmplwi CR6, R7, 0 */
		/* 820C4B40h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 820C4B40h case    4:*/		return 0x820C4B44;
		  /* 820C4B44h */ case    5:  		/* bc 12, CR6_EQ, 52 */
		/* 820C4B44h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C4B78;  }
		/* 820C4B44h case    5:*/		return 0x820C4B48;
		  /* 820C4B48h */ case    6:  		/* lis R10, -32256 */
		/* 820C4B48h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820C4B48h case    6:*/		return 0x820C4B4C;
		  /* 820C4B4Ch */ case    7:  		/* mtspr CTR, R7 */
		/* 820C4B4Ch case    7:*/		regs.CTR = regs.R7;
		/* 820C4B4Ch case    7:*/		return 0x820C4B50;
		  /* 820C4B50h */ case    8:  		/* subf R9, R6, R5 */
		/* 820C4B50h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R5);
		/* 820C4B50h case    8:*/		return 0x820C4B54;
		  /* 820C4B54h */ case    9:  		/* lfs FR0, <#[R10 + 1816]> */
		/* 820C4B54h case    9:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000718) );
		/* 820C4B54h case    9:*/		return 0x820C4B58;
		  /* 820C4B58h */ case   10:  		/* lfsx FR13, <#[R9 + R11]> */
		/* 820C4B58h case   10:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820C4B58h case   10:*/		return 0x820C4B5C;
		  /* 820C4B5Ch */ case   11:  		/* li R10, 1 */
		/* 820C4B5Ch case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820C4B5Ch case   11:*/		return 0x820C4B60;
		  /* 820C4B60h */ case   12:  		/* fcmpu CR6, FR13, FR0 */
		/* 820C4B60h case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820C4B60h case   12:*/		return 0x820C4B64;
		  /* 820C4B64h */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 820C4B64h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820C4B6C;  }
		/* 820C4B64h case   13:*/		return 0x820C4B68;
		  /* 820C4B68h */ case   14:  		/* li R10, 0 */
		/* 820C4B68h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C4B68h case   14:*/		return 0x820C4B6C;
	}
	return 0x820C4B6C;
} // Block from 820C4B30h-820C4B6Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C4B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4B6C);
		  /* 820C4B6Ch */ case    0:  		/* stw R10, <#[R11]> */
		/* 820C4B6Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C4B6Ch case    0:*/		return 0x820C4B70;
		  /* 820C4B70h */ case    1:  		/* addi R11, R11, 4 */
		/* 820C4B70h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820C4B70h case    1:*/		return 0x820C4B74;
		  /* 820C4B74h */ case    2:  		/* bc 16, CR0_LT, -28 */
		/* 820C4B74h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C4B58;  }
		/* 820C4B74h case    2:*/		return 0x820C4B78;
	}
	return 0x820C4B78;
} // Block from 820C4B6Ch-820C4B78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C4B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4B78);
		  /* 820C4B78h */ case    0:  		/* mr R6, R7 */
		/* 820C4B78h case    0:*/		regs.R6 = regs.R7;
		/* 820C4B78h case    0:*/		return 0x820C4B7C;
		  /* 820C4B7Ch */ case    1:  		/* bl -376628 */
		/* 820C4B7Ch case    1:*/		regs.LR = 0x820C4B80; return 0x82068C48;
		/* 820C4B7Ch case    1:*/		return 0x820C4B80;
		  /* 820C4B80h */ case    2:  		/* li R3, 0 */
		/* 820C4B80h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4B80h case    2:*/		return 0x820C4B84;
		  /* 820C4B84h */ case    3:  		/* addi R1, R1, 96 */
		/* 820C4B84h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4B84h case    3:*/		return 0x820C4B88;
		  /* 820C4B88h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4B88h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4B88h case    4:*/		return 0x820C4B8C;
		  /* 820C4B8Ch */ case    5:  		/* mtspr LR, R12 */
		/* 820C4B8Ch case    5:*/		regs.LR = regs.R12;
		/* 820C4B8Ch case    5:*/		return 0x820C4B90;
		  /* 820C4B90h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C4B90h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4B90h case    6:*/		return 0x820C4B94;
	}
	return 0x820C4B94;
} // Block from 820C4B78h-820C4B94h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C4B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4B94);
		  /* 820C4B94h */ case    0:  		/* nop */
		/* 820C4B94h case    0:*/		cpu::op::nop();
		/* 820C4B94h case    0:*/		return 0x820C4B98;
	}
	return 0x820C4B98;
} // Block from 820C4B94h-820C4B98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C4B98h
// Function '?SetScratch@CConstant@D3DXShader@@QAAJPAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4B98);
		  /* 820C4B98h */ case    0:  		/* mfspr R12, LR */
		/* 820C4B98h case    0:*/		regs.R12 = regs.LR;
		/* 820C4B98h case    0:*/		return 0x820C4B9C;
		  /* 820C4B9Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4B9Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4B9Ch case    1:*/		return 0x820C4BA0;
		  /* 820C4BA0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4BA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4BA0h case    2:*/		return 0x820C4BA4;
		  /* 820C4BA4h */ case    3:  		/* mr R10, R6 */
		/* 820C4BA4h case    3:*/		regs.R10 = regs.R6;
		/* 820C4BA4h case    3:*/		return 0x820C4BA8;
		  /* 820C4BA8h */ case    4:  		/* rlwinm. R11, R7, 2, 0, 29 */
		/* 820C4BA8h case    4:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820C4BA8h case    4:*/		return 0x820C4BAC;
		  /* 820C4BACh */ case    5:  		/* bc 12, CR0_EQ, 36 */
		/* 820C4BACh case    5:*/		if ( regs.CR[0].eq ) { return 0x820C4BD0;  }
		/* 820C4BACh case    5:*/		return 0x820C4BB0;
		  /* 820C4BB0h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C4BB0h case    6:*/		regs.CTR = regs.R11;
		/* 820C4BB0h case    6:*/		return 0x820C4BB4;
		  /* 820C4BB4h */ case    7:  		/* subf R11, R6, R5 */
		/* 820C4BB4h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 820C4BB4h case    7:*/		return 0x820C4BB8;
		  /* 820C4BB8h */ case    8:  		/* lwzx R9, <#[R11 + R10]> */
		/* 820C4BB8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C4BB8h case    8:*/		return 0x820C4BBC;
		  /* 820C4BBCh */ case    9:  		/* addic R8, R9, -1 */
		/* 820C4BBCh case    9:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 820C4BBCh case    9:*/		return 0x820C4BC0;
		  /* 820C4BC0h */ case   10:  		/* subfe R9, R8, R9 */
		/* 820C4BC0h case   10:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C4BC0h case   10:*/		return 0x820C4BC4;
		  /* 820C4BC4h */ case   11:  		/* stw R9, <#[R10]> */
		/* 820C4BC4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820C4BC4h case   11:*/		return 0x820C4BC8;
		  /* 820C4BC8h */ case   12:  		/* addi R10, R10, 4 */
		/* 820C4BC8h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C4BC8h case   12:*/		return 0x820C4BCC;
		  /* 820C4BCCh */ case   13:  		/* bc 16, CR0_LT, -20 */
		/* 820C4BCCh case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C4BB8;  }
		/* 820C4BCCh case   13:*/		return 0x820C4BD0;
	}
	return 0x820C4BD0;
} // Block from 820C4B98h-820C4BD0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C4BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4BD0);
		  /* 820C4BD0h */ case    0:  		/* mr R6, R7 */
		/* 820C4BD0h case    0:*/		regs.R6 = regs.R7;
		/* 820C4BD0h case    0:*/		return 0x820C4BD4;
		  /* 820C4BD4h */ case    1:  		/* bl -376532 */
		/* 820C4BD4h case    1:*/		regs.LR = 0x820C4BD8; return 0x82068D00;
		/* 820C4BD4h case    1:*/		return 0x820C4BD8;
		  /* 820C4BD8h */ case    2:  		/* li R3, 0 */
		/* 820C4BD8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4BD8h case    2:*/		return 0x820C4BDC;
		  /* 820C4BDCh */ case    3:  		/* addi R1, R1, 96 */
		/* 820C4BDCh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4BDCh case    3:*/		return 0x820C4BE0;
		  /* 820C4BE0h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4BE0h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4BE0h case    4:*/		return 0x820C4BE4;
		  /* 820C4BE4h */ case    5:  		/* mtspr LR, R12 */
		/* 820C4BE4h case    5:*/		regs.LR = regs.R12;
		/* 820C4BE4h case    5:*/		return 0x820C4BE8;
		  /* 820C4BE8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C4BE8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4BE8h case    6:*/		return 0x820C4BEC;
	}
	return 0x820C4BEC;
} // Block from 820C4BD0h-820C4BECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C4BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4BEC);
		  /* 820C4BECh */ case    0:  		/* nop */
		/* 820C4BECh case    0:*/		cpu::op::nop();
		/* 820C4BECh case    0:*/		return 0x820C4BF0;
	}
	return 0x820C4BF0;
} // Block from 820C4BECh-820C4BF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C4BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4BF0);
		  /* 820C4BF0h */ case    0:  		/* mfspr R12, LR */
		/* 820C4BF0h case    0:*/		regs.R12 = regs.LR;
		/* 820C4BF0h case    0:*/		return 0x820C4BF4;
		  /* 820C4BF4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4BF4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4BF4h case    1:*/		return 0x820C4BF8;
		  /* 820C4BF8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4BF8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4BF8h case    2:*/		return 0x820C4BFC;
		  /* 820C4BFCh */ case    3:  		/* mr R6, R7 */
		/* 820C4BFCh case    3:*/		regs.R6 = regs.R7;
		/* 820C4BFCh case    3:*/		return 0x820C4C00;
		  /* 820C4C00h */ case    4:  		/* bl -376576 */
		/* 820C4C00h case    4:*/		regs.LR = 0x820C4C04; return 0x82068D00;
		/* 820C4C00h case    4:*/		return 0x820C4C04;
		  /* 820C4C04h */ case    5:  		/* li R3, 0 */
		/* 820C4C04h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4C04h case    5:*/		return 0x820C4C08;
		  /* 820C4C08h */ case    6:  		/* addi R1, R1, 96 */
		/* 820C4C08h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4C08h case    6:*/		return 0x820C4C0C;
		  /* 820C4C0Ch */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4C0Ch case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4C0Ch case    7:*/		return 0x820C4C10;
		  /* 820C4C10h */ case    8:  		/* mtspr LR, R12 */
		/* 820C4C10h case    8:*/		regs.LR = regs.R12;
		/* 820C4C10h case    8:*/		return 0x820C4C14;
		  /* 820C4C14h */ case    9:  		/* bclr 20, CR0_LT */
		/* 820C4C14h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4C14h case    9:*/		return 0x820C4C18;
	}
	return 0x820C4C18;
} // Block from 820C4BF0h-820C4C18h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C4C18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4C18);
		  /* 820C4C18h */ case    0:  		/* mfspr R12, LR */
		/* 820C4C18h case    0:*/		regs.R12 = regs.LR;
		/* 820C4C18h case    0:*/		return 0x820C4C1C;
		  /* 820C4C1Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4C1Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4C1Ch case    1:*/		return 0x820C4C20;
		  /* 820C4C20h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4C20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4C20h case    2:*/		return 0x820C4C24;
		  /* 820C4C24h */ case    3:  		/* mr R10, R6 */
		/* 820C4C24h case    3:*/		regs.R10 = regs.R6;
		/* 820C4C24h case    3:*/		return 0x820C4C28;
		  /* 820C4C28h */ case    4:  		/* rlwinm. R11, R7, 2, 0, 29 */
		/* 820C4C28h case    4:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820C4C28h case    4:*/		return 0x820C4C2C;
		  /* 820C4C2Ch */ case    5:  		/* bc 12, CR0_EQ, 32 */
		/* 820C4C2Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820C4C4C;  }
		/* 820C4C2Ch case    5:*/		return 0x820C4C30;
		  /* 820C4C30h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C4C30h case    6:*/		regs.CTR = regs.R11;
		/* 820C4C30h case    6:*/		return 0x820C4C34;
		  /* 820C4C34h */ case    7:  		/* subf R11, R6, R5 */
		/* 820C4C34h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 820C4C34h case    7:*/		return 0x820C4C38;
	}
	return 0x820C4C38;
} // Block from 820C4C18h-820C4C38h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C4C38h
// Function '?GetDesc@CConstant@D3DXShader@@QAAJPAU_D3DXCONSTANT_DESC@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4C38);
		  /* 820C4C38h */ case    0:  		/* lfsx FR0, <#[R11 + R10]> */
		/* 820C4C38h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C4C38h case    0:*/		return 0x820C4C3C;
		  /* 820C4C3Ch */ case    1:  		/* fctiwz FR0, FR0 */
		/* 820C4C3Ch case    1:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 820C4C3Ch case    1:*/		return 0x820C4C40;
		  /* 820C4C40h */ case    2:  		/* stfiwx FR0, <#[R10]> */
		/* 820C4C40h case    2:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C4C40h case    2:*/		return 0x820C4C44;
		  /* 820C4C44h */ case    3:  		/* addi R10, R10, 4 */
		/* 820C4C44h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C4C44h case    3:*/		return 0x820C4C48;
		  /* 820C4C48h */ case    4:  		/* bc 16, CR0_LT, -16 */
		/* 820C4C48h case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C4C38;  }
		/* 820C4C48h case    4:*/		return 0x820C4C4C;
	}
	return 0x820C4C4C;
} // Block from 820C4C38h-820C4C4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C4C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4C4C);
		  /* 820C4C4Ch */ case    0:  		/* mr R6, R7 */
		/* 820C4C4Ch case    0:*/		regs.R6 = regs.R7;
		/* 820C4C4Ch case    0:*/		return 0x820C4C50;
		  /* 820C4C50h */ case    1:  		/* bl -376656 */
		/* 820C4C50h case    1:*/		regs.LR = 0x820C4C54; return 0x82068D00;
		/* 820C4C50h case    1:*/		return 0x820C4C54;
		  /* 820C4C54h */ case    2:  		/* li R3, 0 */
		/* 820C4C54h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4C54h case    2:*/		return 0x820C4C58;
		  /* 820C4C58h */ case    3:  		/* addi R1, R1, 96 */
		/* 820C4C58h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4C58h case    3:*/		return 0x820C4C5C;
		  /* 820C4C5Ch */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4C5Ch case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4C5Ch case    4:*/		return 0x820C4C60;
		  /* 820C4C60h */ case    5:  		/* mtspr LR, R12 */
		/* 820C4C60h case    5:*/		regs.LR = regs.R12;
		/* 820C4C60h case    5:*/		return 0x820C4C64;
		  /* 820C4C64h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C4C64h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4C64h case    6:*/		return 0x820C4C68;
	}
	return 0x820C4C68;
} // Block from 820C4C4Ch-820C4C68h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C4C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4C68);
		  /* 820C4C68h */ case    0:  		/* mfspr R12, LR */
		/* 820C4C68h case    0:*/		regs.R12 = regs.LR;
		/* 820C4C68h case    0:*/		return 0x820C4C6C;
		  /* 820C4C6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4C6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4C6Ch case    1:*/		return 0x820C4C70;
		  /* 820C4C70h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4C70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4C70h case    2:*/		return 0x820C4C74;
		  /* 820C4C74h */ case    3:  		/* add R11, R4, R7 */
		/* 820C4C74h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R7);
		/* 820C4C74h case    3:*/		return 0x820C4C78;
		  /* 820C4C78h */ case    4:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 820C4C78h case    4:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 820C4C78h case    4:*/		return 0x820C4C7C;
		  /* 820C4C7Ch */ case    5:  		/* addi R11, R11, -1 */
		/* 820C4C7Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820C4C7Ch case    5:*/		return 0x820C4C80;
		  /* 820C4C80h */ case    6:  		/* li R9, 1 */
		/* 820C4C80h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820C4C80h case    6:*/		return 0x820C4C84;
		  /* 820C4C84h */ case    7:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 820C4C84h case    7:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 820C4C84h case    7:*/		return 0x820C4C88;
		  /* 820C4C88h */ case    8:  		/* rldicr R9, R9, 63, 63 */
		/* 820C4C88h case    8:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 820C4C88h case    8:*/		return 0x820C4C8C;
		  /* 820C4C8Ch */ case    9:  		/* subf R11, R10, R11 */
		/* 820C4C8Ch case    9:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C4C8Ch case    9:*/		return 0x820C4C90;
		  /* 820C4C90h */ case   10:  		/* mr R6, R7 */
		/* 820C4C90h case   10:*/		regs.R6 = regs.R7;
		/* 820C4C90h case   10:*/		return 0x820C4C94;
		  /* 820C4C94h */ case   11:  		/* rldicl R11, R11, 0, 32 */
		/* 820C4C94h case   11:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 820C4C94h case   11:*/		return 0x820C4C98;
		  /* 820C4C98h */ case   12:  		/* srad R11, R9, R11 */
		/* 820C4C98h case   12:*/		cpu::op::srad<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820C4C98h case   12:*/		return 0x820C4C9C;
		  /* 820C4C9Ch */ case   13:  		/* srd R7, R11, R10 */
		/* 820C4C9Ch case   13:*/		cpu::op::srd<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 820C4C9Ch case   13:*/		return 0x820C4CA0;
		  /* 820C4CA0h */ case   14:  		/* bl -377232 */
		/* 820C4CA0h case   14:*/		regs.LR = 0x820C4CA4; return 0x82068B10;
		/* 820C4CA0h case   14:*/		return 0x820C4CA4;
		  /* 820C4CA4h */ case   15:  		/* li R3, 0 */
		/* 820C4CA4h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4CA4h case   15:*/		return 0x820C4CA8;
		  /* 820C4CA8h */ case   16:  		/* addi R1, R1, 96 */
		/* 820C4CA8h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4CA8h case   16:*/		return 0x820C4CAC;
		  /* 820C4CACh */ case   17:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4CACh case   17:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4CACh case   17:*/		return 0x820C4CB0;
		  /* 820C4CB0h */ case   18:  		/* mtspr LR, R12 */
		/* 820C4CB0h case   18:*/		regs.LR = regs.R12;
		/* 820C4CB0h case   18:*/		return 0x820C4CB4;
		  /* 820C4CB4h */ case   19:  		/* bclr 20, CR0_LT */
		/* 820C4CB4h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4CB4h case   19:*/		return 0x820C4CB8;
	}
	return 0x820C4CB8;
} // Block from 820C4C68h-820C4CB8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C4CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4CB8);
		  /* 820C4CB8h */ case    0:  		/* mfspr R12, LR */
		/* 820C4CB8h case    0:*/		regs.R12 = regs.LR;
		/* 820C4CB8h case    0:*/		return 0x820C4CBC;
		  /* 820C4CBCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4CBCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4CBCh case    1:*/		return 0x820C4CC0;
		  /* 820C4CC0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4CC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4CC0h case    2:*/		return 0x820C4CC4;
		  /* 820C4CC4h */ case    3:  		/* mr R10, R6 */
		/* 820C4CC4h case    3:*/		regs.R10 = regs.R6;
		/* 820C4CC4h case    3:*/		return 0x820C4CC8;
		  /* 820C4CC8h */ case    4:  		/* rlwinm. R11, R7, 2, 0, 29 */
		/* 820C4CC8h case    4:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820C4CC8h case    4:*/		return 0x820C4CCC;
		  /* 820C4CCCh */ case    5:  		/* bc 12, CR0_EQ, 56 */
		/* 820C4CCCh case    5:*/		if ( regs.CR[0].eq ) { return 0x820C4D04;  }
		/* 820C4CCCh case    5:*/		return 0x820C4CD0;
		  /* 820C4CD0h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C4CD0h case    6:*/		regs.CTR = regs.R11;
		/* 820C4CD0h case    6:*/		return 0x820C4CD4;
		  /* 820C4CD4h */ case    7:  		/* subf R11, R6, R5 */
		/* 820C4CD4h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 820C4CD4h case    7:*/		return 0x820C4CD8;
		  /* 820C4CD8h */ case    8:  		/* lwzx R9, <#[R11 + R10]> */
		/* 820C4CD8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C4CD8h case    8:*/		return 0x820C4CDC;
		  /* 820C4CDCh */ case    9:  		/* addic R8, R9, -1 */
		/* 820C4CDCh case    9:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 820C4CDCh case    9:*/		return 0x820C4CE0;
		  /* 820C4CE0h */ case   10:  		/* subfe R9, R8, R9 */
		/* 820C4CE0h case   10:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C4CE0h case   10:*/		return 0x820C4CE4;
		  /* 820C4CE4h */ case   11:  		/* extsw R9, R9 */
		/* 820C4CE4h case   11:*/		cpu::op::extsw<0>(regs,&regs.R9,regs.R9);
		/* 820C4CE4h case   11:*/		return 0x820C4CE8;
		  /* 820C4CE8h */ case   12:  		/* std R9, <#[R1 + 80]> */
		/* 820C4CE8h case   12:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820C4CE8h case   12:*/		return 0x820C4CEC;
		  /* 820C4CECh */ case   13:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820C4CECh case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820C4CECh case   13:*/		return 0x820C4CF0;
		  /* 820C4CF0h */ case   14:  		/* fcfid FR0, FR0 */
		/* 820C4CF0h case   14:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820C4CF0h case   14:*/		return 0x820C4CF4;
		  /* 820C4CF4h */ case   15:  		/* frsp FR0, FR0 */
		/* 820C4CF4h case   15:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820C4CF4h case   15:*/		return 0x820C4CF8;
		  /* 820C4CF8h */ case   16:  		/* stfs FR0, <#[R10]> */
		/* 820C4CF8h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C4CF8h case   16:*/		return 0x820C4CFC;
		  /* 820C4CFCh */ case   17:  		/* addi R10, R10, 4 */
		/* 820C4CFCh case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C4CFCh case   17:*/		return 0x820C4D00;
		  /* 820C4D00h */ case   18:  		/* bc 16, CR0_LT, -40 */
		/* 820C4D00h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C4CD8;  }
		/* 820C4D00h case   18:*/		return 0x820C4D04;
	}
	return 0x820C4D04;
} // Block from 820C4CB8h-820C4D04h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820C4D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4D04);
		  /* 820C4D04h */ case    0:  		/* add R11, R4, R7 */
		/* 820C4D04h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R7);
		/* 820C4D04h case    0:*/		return 0x820C4D08;
		  /* 820C4D08h */ case    1:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 820C4D08h case    1:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 820C4D08h case    1:*/		return 0x820C4D0C;
		  /* 820C4D0Ch */ case    2:  		/* addi R11, R11, -1 */
		/* 820C4D0Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820C4D0Ch case    2:*/		return 0x820C4D10;
		  /* 820C4D10h */ case    3:  		/* li R9, 1 */
		/* 820C4D10h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820C4D10h case    3:*/		return 0x820C4D14;
		  /* 820C4D14h */ case    4:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 820C4D14h case    4:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 820C4D14h case    4:*/		return 0x820C4D18;
	}
	return 0x820C4D18;
} // Block from 820C4D04h-820C4D18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C4D18h
// Function '?SetDefaults@CConstant@D3DXShader@@QAAJPBXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4D18);
		  /* 820C4D18h */ case    0:  		/* rldicr R9, R9, 63, 63 */
		/* 820C4D18h case    0:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 820C4D18h case    0:*/		return 0x820C4D1C;
		  /* 820C4D1Ch */ case    1:  		/* subf R11, R10, R11 */
		/* 820C4D1Ch case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C4D1Ch case    1:*/		return 0x820C4D20;
		  /* 820C4D20h */ case    2:  		/* mr R6, R7 */
		/* 820C4D20h case    2:*/		regs.R6 = regs.R7;
		/* 820C4D20h case    2:*/		return 0x820C4D24;
		  /* 820C4D24h */ case    3:  		/* rldicl R11, R11, 0, 32 */
		/* 820C4D24h case    3:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 820C4D24h case    3:*/		return 0x820C4D28;
		  /* 820C4D28h */ case    4:  		/* srad R11, R9, R11 */
		/* 820C4D28h case    4:*/		cpu::op::srad<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820C4D28h case    4:*/		return 0x820C4D2C;
		  /* 820C4D2Ch */ case    5:  		/* srd R7, R11, R10 */
		/* 820C4D2Ch case    5:*/		cpu::op::srd<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 820C4D2Ch case    5:*/		return 0x820C4D30;
		  /* 820C4D30h */ case    6:  		/* bl -377376 */
		/* 820C4D30h case    6:*/		regs.LR = 0x820C4D34; return 0x82068B10;
		/* 820C4D30h case    6:*/		return 0x820C4D34;
		  /* 820C4D34h */ case    7:  		/* li R3, 0 */
		/* 820C4D34h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4D34h case    7:*/		return 0x820C4D38;
		  /* 820C4D38h */ case    8:  		/* addi R1, R1, 96 */
		/* 820C4D38h case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4D38h case    8:*/		return 0x820C4D3C;
		  /* 820C4D3Ch */ case    9:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4D3Ch case    9:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4D3Ch case    9:*/		return 0x820C4D40;
		  /* 820C4D40h */ case   10:  		/* mtspr LR, R12 */
		/* 820C4D40h case   10:*/		regs.LR = regs.R12;
		/* 820C4D40h case   10:*/		return 0x820C4D44;
		  /* 820C4D44h */ case   11:  		/* bclr 20, CR0_LT */
		/* 820C4D44h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4D44h case   11:*/		return 0x820C4D48;
	}
	return 0x820C4D48;
} // Block from 820C4D18h-820C4D48h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C4D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4D48);
		  /* 820C4D48h */ case    0:  		/* mfspr R12, LR */
		/* 820C4D48h case    0:*/		regs.R12 = regs.LR;
		/* 820C4D48h case    0:*/		return 0x820C4D4C;
		  /* 820C4D4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C4D4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4D4Ch case    1:*/		return 0x820C4D50;
		  /* 820C4D50h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C4D50h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C4D50h case    2:*/		return 0x820C4D54;
		  /* 820C4D54h */ case    3:  		/* mr R10, R6 */
		/* 820C4D54h case    3:*/		regs.R10 = regs.R6;
		/* 820C4D54h case    3:*/		return 0x820C4D58;
		  /* 820C4D58h */ case    4:  		/* rlwinm. R11, R7, 2, 0, 29 */
		/* 820C4D58h case    4:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820C4D58h case    4:*/		return 0x820C4D5C;
		  /* 820C4D5Ch */ case    5:  		/* bc 12, CR0_EQ, 44 */
		/* 820C4D5Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820C4D88;  }
		/* 820C4D5Ch case    5:*/		return 0x820C4D60;
		  /* 820C4D60h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C4D60h case    6:*/		regs.CTR = regs.R11;
		/* 820C4D60h case    6:*/		return 0x820C4D64;
		  /* 820C4D64h */ case    7:  		/* subf R11, R6, R5 */
		/* 820C4D64h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 820C4D64h case    7:*/		return 0x820C4D68;
		  /* 820C4D68h */ case    8:  		/* lwax R9, <#[R11 + R10]> */
		/* 820C4D68h case    8:*/		cpu::mem::load32a( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C4D68h case    8:*/		return 0x820C4D6C;
		  /* 820C4D6Ch */ case    9:  		/* std R9, <#[R1 + 80]> */
		/* 820C4D6Ch case    9:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820C4D6Ch case    9:*/		return 0x820C4D70;
		  /* 820C4D70h */ case   10:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820C4D70h case   10:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820C4D70h case   10:*/		return 0x820C4D74;
		  /* 820C4D74h */ case   11:  		/* fcfid FR0, FR0 */
		/* 820C4D74h case   11:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820C4D74h case   11:*/		return 0x820C4D78;
		  /* 820C4D78h */ case   12:  		/* frsp FR0, FR0 */
		/* 820C4D78h case   12:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820C4D78h case   12:*/		return 0x820C4D7C;
		  /* 820C4D7Ch */ case   13:  		/* stfs FR0, <#[R10]> */
		/* 820C4D7Ch case   13:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C4D7Ch case   13:*/		return 0x820C4D80;
		  /* 820C4D80h */ case   14:  		/* addi R10, R10, 4 */
		/* 820C4D80h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C4D80h case   14:*/		return 0x820C4D84;
		  /* 820C4D84h */ case   15:  		/* bc 16, CR0_LT, -28 */
		/* 820C4D84h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C4D68;  }
		/* 820C4D84h case   15:*/		return 0x820C4D88;
	}
	return 0x820C4D88;
} // Block from 820C4D48h-820C4D88h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C4D88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4D88);
		  /* 820C4D88h */ case    0:  		/* add R11, R4, R7 */
		/* 820C4D88h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R4,regs.R7);
		/* 820C4D88h case    0:*/		return 0x820C4D8C;
		  /* 820C4D8Ch */ case    1:  		/* rlwinm R10, R4, 30, 2, 31 */
		/* 820C4D8Ch case    1:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R4);
		/* 820C4D8Ch case    1:*/		return 0x820C4D90;
		  /* 820C4D90h */ case    2:  		/* addi R11, R11, -1 */
		/* 820C4D90h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820C4D90h case    2:*/		return 0x820C4D94;
		  /* 820C4D94h */ case    3:  		/* li R9, 1 */
		/* 820C4D94h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820C4D94h case    3:*/		return 0x820C4D98;
		  /* 820C4D98h */ case    4:  		/* rlwinm R11, R11, 30, 2, 31 */
		/* 820C4D98h case    4:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R11,regs.R11);
		/* 820C4D98h case    4:*/		return 0x820C4D9C;
		  /* 820C4D9Ch */ case    5:  		/* rldicr R9, R9, 63, 63 */
		/* 820C4D9Ch case    5:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 820C4D9Ch case    5:*/		return 0x820C4DA0;
		  /* 820C4DA0h */ case    6:  		/* subf R11, R10, R11 */
		/* 820C4DA0h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C4DA0h case    6:*/		return 0x820C4DA4;
		  /* 820C4DA4h */ case    7:  		/* mr R6, R7 */
		/* 820C4DA4h case    7:*/		regs.R6 = regs.R7;
		/* 820C4DA4h case    7:*/		return 0x820C4DA8;
		  /* 820C4DA8h */ case    8:  		/* rldicl R11, R11, 0, 32 */
		/* 820C4DA8h case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 820C4DA8h case    8:*/		return 0x820C4DAC;
		  /* 820C4DACh */ case    9:  		/* srad R11, R9, R11 */
		/* 820C4DACh case    9:*/		cpu::op::srad<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820C4DACh case    9:*/		return 0x820C4DB0;
		  /* 820C4DB0h */ case   10:  		/* srd R7, R11, R10 */
		/* 820C4DB0h case   10:*/		cpu::op::srd<0>(regs,&regs.R7,regs.R11,regs.R10);
		/* 820C4DB0h case   10:*/		return 0x820C4DB4;
		  /* 820C4DB4h */ case   11:  		/* bl -377508 */
		/* 820C4DB4h case   11:*/		regs.LR = 0x820C4DB8; return 0x82068B10;
		/* 820C4DB4h case   11:*/		return 0x820C4DB8;
	}
	return 0x820C4DB8;
} // Block from 820C4D88h-820C4DB8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C4DB8h
// Function '?QueryInterface@CConstantTable@D3DXShader@@UAAJABU_GUID@@PAPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4DB8);
		  /* 820C4DB8h */ case    0:  		/* li R3, 0 */
		/* 820C4DB8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4DB8h case    0:*/		return 0x820C4DBC;
		  /* 820C4DBCh */ case    1:  		/* addi R1, R1, 96 */
		/* 820C4DBCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C4DBCh case    1:*/		return 0x820C4DC0;
		  /* 820C4DC0h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C4DC0h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C4DC0h case    2:*/		return 0x820C4DC4;
		  /* 820C4DC4h */ case    3:  		/* mtspr LR, R12 */
		/* 820C4DC4h case    3:*/		regs.LR = regs.R12;
		/* 820C4DC4h case    3:*/		return 0x820C4DC8;
		  /* 820C4DC8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820C4DC8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C4DC8h case    4:*/		return 0x820C4DCC;
	}
	return 0x820C4DCC;
} // Block from 820C4DB8h-820C4DCCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C4DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4DCC);
		  /* 820C4DCCh */ case    0:  		/* nop */
		/* 820C4DCCh case    0:*/		cpu::op::nop();
		/* 820C4DCCh case    0:*/		return 0x820C4DD0;
	}
	return 0x820C4DD0;
} // Block from 820C4DCCh-820C4DD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C4DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4DD0);
		  /* 820C4DD0h */ case    0:  		/* mfspr R12, LR */
		/* 820C4DD0h case    0:*/		regs.R12 = regs.LR;
		/* 820C4DD0h case    0:*/		return 0x820C4DD4;
		  /* 820C4DD4h */ case    1:  		/* bl -211832 */
		/* 820C4DD4h case    1:*/		regs.LR = 0x820C4DD8; return 0x8209125C;
		/* 820C4DD4h case    1:*/		return 0x820C4DD8;
		  /* 820C4DD8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C4DD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C4DD8h case    2:*/		return 0x820C4DDC;
		  /* 820C4DDCh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820C4DDCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C4DDCh case    3:*/		return 0x820C4DE0;
		  /* 820C4DE0h */ case    4:  		/* mr R31, R4 */
		/* 820C4DE0h case    4:*/		regs.R31 = regs.R4;
		/* 820C4DE0h case    4:*/		return 0x820C4DE4;
		  /* 820C4DE4h */ case    5:  		/* mr R30, R5 */
		/* 820C4DE4h case    5:*/		regs.R30 = regs.R5;
		/* 820C4DE4h case    5:*/		return 0x820C4DE8;
		  /* 820C4DE8h */ case    6:  		/* mr R29, R7 */
		/* 820C4DE8h case    6:*/		regs.R29 = regs.R7;
		/* 820C4DE8h case    6:*/		return 0x820C4DEC;
		  /* 820C4DECh */ case    7:  		/* lwz R11, <#[R11 + 12]> */
		/* 820C4DECh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C4DECh case    7:*/		return 0x820C4DF0;
		  /* 820C4DF0h */ case    8:  		/* mtspr CTR, R11 */
		/* 820C4DF0h case    8:*/		regs.CTR = regs.R11;
		/* 820C4DF0h case    8:*/		return 0x820C4DF4;
		  /* 820C4DF4h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820C4DF4h case    9:*/		if ( 1 ) { regs.LR = 0x820C4DF8; return (uint32)regs.CTR; }
		/* 820C4DF4h case    9:*/		return 0x820C4DF8;
		  /* 820C4DF8h */ case   10:  		/* rlwinm R11, R31, 4, 0, 27 */
		/* 820C4DF8h case   10:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R31);
		/* 820C4DF8h case   10:*/		return 0x820C4DFC;
		  /* 820C4DFCh */ case   11:  		/* mr R4, R30 */
		/* 820C4DFCh case   11:*/		regs.R4 = regs.R30;
		/* 820C4DFCh case   11:*/		return 0x820C4E00;
		  /* 820C4E00h */ case   12:  		/* add R3, R3, R11 */
		/* 820C4E00h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 820C4E00h case   12:*/		return 0x820C4E04;
		  /* 820C4E04h */ case   13:  		/* rlwinm R5, R29, 4, 0, 27 */
		/* 820C4E04h case   13:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R5,regs.R29);
		/* 820C4E04h case   13:*/		return 0x820C4E08;
		  /* 820C4E08h */ case   14:  		/* bl -210008 */
		/* 820C4E08h case   14:*/		regs.LR = 0x820C4E0C; return 0x820919B0;
		/* 820C4E08h case   14:*/		return 0x820C4E0C;
		  /* 820C4E0Ch */ case   15:  		/* li R3, 0 */
		/* 820C4E0Ch case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4E0Ch case   15:*/		return 0x820C4E10;
		  /* 820C4E10h */ case   16:  		/* addi R1, R1, 112 */
		/* 820C4E10h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C4E10h case   16:*/		return 0x820C4E14;
		  /* 820C4E14h */ case   17:  		/* b -211816 */
		/* 820C4E14h case   17:*/		return 0x820912AC;
		/* 820C4E14h case   17:*/		return 0x820C4E18;
	}
	return 0x820C4E18;
} // Block from 820C4DD0h-820C4E18h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820C4E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4E18);
		  /* 820C4E18h */ case    0:  		/* mfspr R12, LR */
		/* 820C4E18h case    0:*/		regs.R12 = regs.LR;
		/* 820C4E18h case    0:*/		return 0x820C4E1C;
		  /* 820C4E1Ch */ case    1:  		/* bl -211904 */
		/* 820C4E1Ch case    1:*/		regs.LR = 0x820C4E20; return 0x8209125C;
		/* 820C4E1Ch case    1:*/		return 0x820C4E20;
		  /* 820C4E20h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C4E20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C4E20h case    2:*/		return 0x820C4E24;
		  /* 820C4E24h */ case    3:  		/* mr R29, R4 */
		/* 820C4E24h case    3:*/		regs.R29 = regs.R4;
		/* 820C4E24h case    3:*/		return 0x820C4E28;
		  /* 820C4E28h */ case    4:  		/* mr R31, R5 */
		/* 820C4E28h case    4:*/		regs.R31 = regs.R5;
		/* 820C4E28h case    4:*/		return 0x820C4E2C;
		  /* 820C4E2Ch */ case    5:  		/* mr R30, R7 */
		/* 820C4E2Ch case    5:*/		regs.R30 = regs.R7;
		/* 820C4E2Ch case    5:*/		return 0x820C4E30;
		  /* 820C4E30h */ case    6:  		/* rlwinm. R11, R7, 2, 0, 29 */
		/* 820C4E30h case    6:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820C4E30h case    6:*/		return 0x820C4E34;
		  /* 820C4E34h */ case    7:  		/* bc 12, CR0_EQ, 60 */
		/* 820C4E34h case    7:*/		if ( regs.CR[0].eq ) { return 0x820C4E70;  }
		/* 820C4E34h case    7:*/		return 0x820C4E38;
		  /* 820C4E38h */ case    8:  		/* mtspr CTR, R11 */
		/* 820C4E38h case    8:*/		regs.CTR = regs.R11;
		/* 820C4E38h case    8:*/		return 0x820C4E3C;
		  /* 820C4E3Ch */ case    9:  		/* mr R10, R6 */
		/* 820C4E3Ch case    9:*/		regs.R10 = regs.R6;
		/* 820C4E3Ch case    9:*/		return 0x820C4E40;
		  /* 820C4E40h */ case   10:  		/* subf R11, R6, R5 */
		/* 820C4E40h case   10:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 820C4E40h case   10:*/		return 0x820C4E44;
		  /* 820C4E44h */ case   11:  		/* lwzx R9, <#[R11 + R10]> */
		/* 820C4E44h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C4E44h case   11:*/		return 0x820C4E48;
		  /* 820C4E48h */ case   12:  		/* addic R8, R9, -1 */
		/* 820C4E48h case   12:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 820C4E48h case   12:*/		return 0x820C4E4C;
		  /* 820C4E4Ch */ case   13:  		/* subfe R9, R8, R9 */
		/* 820C4E4Ch case   13:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C4E4Ch case   13:*/		return 0x820C4E50;
		  /* 820C4E50h */ case   14:  		/* extsw R9, R9 */
		/* 820C4E50h case   14:*/		cpu::op::extsw<0>(regs,&regs.R9,regs.R9);
		/* 820C4E50h case   14:*/		return 0x820C4E54;
		  /* 820C4E54h */ case   15:  		/* std R9, <#[R1 + 80]> */
		/* 820C4E54h case   15:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820C4E54h case   15:*/		return 0x820C4E58;
		  /* 820C4E58h */ case   16:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820C4E58h case   16:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820C4E58h case   16:*/		return 0x820C4E5C;
		  /* 820C4E5Ch */ case   17:  		/* fcfid FR0, FR0 */
		/* 820C4E5Ch case   17:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820C4E5Ch case   17:*/		return 0x820C4E60;
		  /* 820C4E60h */ case   18:  		/* frsp FR0, FR0 */
		/* 820C4E60h case   18:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820C4E60h case   18:*/		return 0x820C4E64;
		  /* 820C4E64h */ case   19:  		/* stfs FR0, <#[R10]> */
		/* 820C4E64h case   19:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C4E64h case   19:*/		return 0x820C4E68;
		  /* 820C4E68h */ case   20:  		/* addi R10, R10, 4 */
		/* 820C4E68h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C4E68h case   20:*/		return 0x820C4E6C;
		  /* 820C4E6Ch */ case   21:  		/* bc 16, CR0_LT, -40 */
		/* 820C4E6Ch case   21:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C4E44;  }
		/* 820C4E6Ch case   21:*/		return 0x820C4E70;
	}
	return 0x820C4E70;
} // Block from 820C4E18h-820C4E70h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C4E70h
// Function '?AddRef@CConstantTable@D3DXShader@@UAAKXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4E70);
		  /* 820C4E70h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820C4E70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C4E70h case    0:*/		return 0x820C4E74;
		  /* 820C4E74h */ case    1:  		/* lwz R11, <#[R11 + 12]> */
		/* 820C4E74h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C4E74h case    1:*/		return 0x820C4E78;
		  /* 820C4E78h */ case    2:  		/* mtspr CTR, R11 */
		/* 820C4E78h case    2:*/		regs.CTR = regs.R11;
		/* 820C4E78h case    2:*/		return 0x820C4E7C;
		  /* 820C4E7Ch */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 820C4E7Ch case    3:*/		if ( 1 ) { regs.LR = 0x820C4E80; return (uint32)regs.CTR; }
		/* 820C4E7Ch case    3:*/		return 0x820C4E80;
		  /* 820C4E80h */ case    4:  		/* rlwinm R11, R29, 4, 0, 27 */
		/* 820C4E80h case    4:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R29);
		/* 820C4E80h case    4:*/		return 0x820C4E84;
		  /* 820C4E84h */ case    5:  		/* mr R4, R31 */
		/* 820C4E84h case    5:*/		regs.R4 = regs.R31;
		/* 820C4E84h case    5:*/		return 0x820C4E88;
	}
	return 0x820C4E88;
} // Block from 820C4E70h-820C4E88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C4E88h
// Function '?GetDesc@CConstantTable@D3DXShader@@UAAJPAU_D3DXCONSTANTTABLE_DESC@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4E88);
		  /* 820C4E88h */ case    0:  		/* add R3, R3, R11 */
		/* 820C4E88h case    0:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 820C4E88h case    0:*/		return 0x820C4E8C;
		  /* 820C4E8Ch */ case    1:  		/* rlwinm R5, R30, 4, 0, 27 */
		/* 820C4E8Ch case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R5,regs.R30);
		/* 820C4E8Ch case    1:*/		return 0x820C4E90;
		  /* 820C4E90h */ case    2:  		/* bl -210144 */
		/* 820C4E90h case    2:*/		regs.LR = 0x820C4E94; return 0x820919B0;
		/* 820C4E90h case    2:*/		return 0x820C4E94;
		  /* 820C4E94h */ case    3:  		/* li R3, 0 */
		/* 820C4E94h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4E94h case    3:*/		return 0x820C4E98;
		  /* 820C4E98h */ case    4:  		/* addi R1, R1, 128 */
		/* 820C4E98h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C4E98h case    4:*/		return 0x820C4E9C;
		  /* 820C4E9Ch */ case    5:  		/* b -211952 */
		/* 820C4E9Ch case    5:*/		return 0x820912AC;
		/* 820C4E9Ch case    5:*/		return 0x820C4EA0;
	}
	return 0x820C4EA0;
} // Block from 820C4E88h-820C4EA0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C4EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4EA0);
		  /* 820C4EA0h */ case    0:  		/* mfspr R12, LR */
		/* 820C4EA0h case    0:*/		regs.R12 = regs.LR;
		/* 820C4EA0h case    0:*/		return 0x820C4EA4;
		  /* 820C4EA4h */ case    1:  		/* bl -212040 */
		/* 820C4EA4h case    1:*/		regs.LR = 0x820C4EA8; return 0x8209125C;
		/* 820C4EA4h case    1:*/		return 0x820C4EA8;
		  /* 820C4EA8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C4EA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C4EA8h case    2:*/		return 0x820C4EAC;
		  /* 820C4EACh */ case    3:  		/* mr R29, R4 */
		/* 820C4EACh case    3:*/		regs.R29 = regs.R4;
		/* 820C4EACh case    3:*/		return 0x820C4EB0;
		  /* 820C4EB0h */ case    4:  		/* mr R31, R5 */
		/* 820C4EB0h case    4:*/		regs.R31 = regs.R5;
		/* 820C4EB0h case    4:*/		return 0x820C4EB4;
		  /* 820C4EB4h */ case    5:  		/* mr R30, R7 */
		/* 820C4EB4h case    5:*/		regs.R30 = regs.R7;
		/* 820C4EB4h case    5:*/		return 0x820C4EB8;
		  /* 820C4EB8h */ case    6:  		/* rlwinm. R11, R7, 2, 0, 29 */
		/* 820C4EB8h case    6:*/		cpu::op::rlwinm<1,2,0,29>(regs,&regs.R11,regs.R7);
		/* 820C4EB8h case    6:*/		return 0x820C4EBC;
		  /* 820C4EBCh */ case    7:  		/* bc 12, CR0_EQ, 48 */
		/* 820C4EBCh case    7:*/		if ( regs.CR[0].eq ) { return 0x820C4EEC;  }
		/* 820C4EBCh case    7:*/		return 0x820C4EC0;
		  /* 820C4EC0h */ case    8:  		/* mtspr CTR, R11 */
		/* 820C4EC0h case    8:*/		regs.CTR = regs.R11;
		/* 820C4EC0h case    8:*/		return 0x820C4EC4;
		  /* 820C4EC4h */ case    9:  		/* mr R10, R6 */
		/* 820C4EC4h case    9:*/		regs.R10 = regs.R6;
		/* 820C4EC4h case    9:*/		return 0x820C4EC8;
		  /* 820C4EC8h */ case   10:  		/* subf R11, R6, R5 */
		/* 820C4EC8h case   10:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 820C4EC8h case   10:*/		return 0x820C4ECC;
		  /* 820C4ECCh */ case   11:  		/* lwax R9, <#[R11 + R10]> */
		/* 820C4ECCh case   11:*/		cpu::mem::load32a( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C4ECCh case   11:*/		return 0x820C4ED0;
		  /* 820C4ED0h */ case   12:  		/* std R9, <#[R1 + 80]> */
		/* 820C4ED0h case   12:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820C4ED0h case   12:*/		return 0x820C4ED4;
		  /* 820C4ED4h */ case   13:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820C4ED4h case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820C4ED4h case   13:*/		return 0x820C4ED8;
		  /* 820C4ED8h */ case   14:  		/* fcfid FR0, FR0 */
		/* 820C4ED8h case   14:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820C4ED8h case   14:*/		return 0x820C4EDC;
		  /* 820C4EDCh */ case   15:  		/* frsp FR0, FR0 */
		/* 820C4EDCh case   15:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820C4EDCh case   15:*/		return 0x820C4EE0;
		  /* 820C4EE0h */ case   16:  		/* stfs FR0, <#[R10]> */
		/* 820C4EE0h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C4EE0h case   16:*/		return 0x820C4EE4;
		  /* 820C4EE4h */ case   17:  		/* addi R10, R10, 4 */
		/* 820C4EE4h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C4EE4h case   17:*/		return 0x820C4EE8;
		  /* 820C4EE8h */ case   18:  		/* bc 16, CR0_LT, -28 */
		/* 820C4EE8h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C4ECC;  }
		/* 820C4EE8h case   18:*/		return 0x820C4EEC;
	}
	return 0x820C4EEC;
} // Block from 820C4EA0h-820C4EECh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820C4EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4EEC);
		  /* 820C4EECh */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820C4EECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C4EECh case    0:*/		return 0x820C4EF0;
		  /* 820C4EF0h */ case    1:  		/* lwz R11, <#[R11 + 12]> */
		/* 820C4EF0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C4EF0h case    1:*/		return 0x820C4EF4;
		  /* 820C4EF4h */ case    2:  		/* mtspr CTR, R11 */
		/* 820C4EF4h case    2:*/		regs.CTR = regs.R11;
		/* 820C4EF4h case    2:*/		return 0x820C4EF8;
		  /* 820C4EF8h */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 820C4EF8h case    3:*/		if ( 1 ) { regs.LR = 0x820C4EFC; return (uint32)regs.CTR; }
		/* 820C4EF8h case    3:*/		return 0x820C4EFC;
		  /* 820C4EFCh */ case    4:  		/* rlwinm R11, R29, 4, 0, 27 */
		/* 820C4EFCh case    4:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R29);
		/* 820C4EFCh case    4:*/		return 0x820C4F00;
		  /* 820C4F00h */ case    5:  		/* mr R4, R31 */
		/* 820C4F00h case    5:*/		regs.R4 = regs.R31;
		/* 820C4F00h case    5:*/		return 0x820C4F04;
		  /* 820C4F04h */ case    6:  		/* add R3, R3, R11 */
		/* 820C4F04h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 820C4F04h case    6:*/		return 0x820C4F08;
		  /* 820C4F08h */ case    7:  		/* rlwinm R5, R30, 4, 0, 27 */
		/* 820C4F08h case    7:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R5,regs.R30);
		/* 820C4F08h case    7:*/		return 0x820C4F0C;
		  /* 820C4F0Ch */ case    8:  		/* bl -210268 */
		/* 820C4F0Ch case    8:*/		regs.LR = 0x820C4F10; return 0x820919B0;
		/* 820C4F0Ch case    8:*/		return 0x820C4F10;
	}
	return 0x820C4F10;
} // Block from 820C4EECh-820C4F10h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C4F10h
// Function '?SetDefaults@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4F10);
		  /* 820C4F10h */ case    0:  		/* li R3, 0 */
		/* 820C4F10h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C4F10h case    0:*/		return 0x820C4F14;
		  /* 820C4F14h */ case    1:  		/* addi R1, R1, 128 */
		/* 820C4F14h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C4F14h case    1:*/		return 0x820C4F18;
		  /* 820C4F18h */ case    2:  		/* b -212076 */
		/* 820C4F18h case    2:*/		return 0x820912AC;
		/* 820C4F18h case    2:*/		return 0x820C4F1C;
		  /* 820C4F1Ch */ case    3:  		/* nop */
		/* 820C4F1Ch case    3:*/		cpu::op::nop();
		/* 820C4F1Ch case    3:*/		return 0x820C4F20;
	}
	return 0x820C4F20;
} // Block from 820C4F10h-820C4F20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C4F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4F20);
		  /* 820C4F20h */ case    0:  		/* mfspr R12, LR */
		/* 820C4F20h case    0:*/		regs.R12 = regs.LR;
		/* 820C4F20h case    0:*/		return 0x820C4F24;
		  /* 820C4F24h */ case    1:  		/* bl -212196 */
		/* 820C4F24h case    1:*/		regs.LR = 0x820C4F28; return 0x82091240;
		/* 820C4F24h case    1:*/		return 0x820C4F28;
		  /* 820C4F28h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820C4F28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820C4F28h case    2:*/		return 0x820C4F2C;
		  /* 820C4F2Ch */ case    3:  		/* lwz R31, <#[R3 + 24]> */
		/* 820C4F2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000018) );
		/* 820C4F2Ch case    3:*/		return 0x820C4F30;
		  /* 820C4F30h */ case    4:  		/* mr R11, R6 */
		/* 820C4F30h case    4:*/		regs.R11 = regs.R6;
		/* 820C4F30h case    4:*/		return 0x820C4F34;
		  /* 820C4F34h */ case    5:  		/* lwz R6, <#[R3 + 32]> */
		/* 820C4F34h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000020) );
		/* 820C4F34h case    5:*/		return 0x820C4F38;
		  /* 820C4F38h */ case    6:  		/* mr R24, R3 */
		/* 820C4F38h case    6:*/		regs.R24 = regs.R3;
		/* 820C4F38h case    6:*/		return 0x820C4F3C;
		  /* 820C4F3Ch */ case    7:  		/* mr R23, R4 */
		/* 820C4F3Ch case    7:*/		regs.R23 = regs.R4;
		/* 820C4F3Ch case    7:*/		return 0x820C4F40;
		  /* 820C4F40h */ case    8:  		/* mr R22, R7 */
		/* 820C4F40h case    8:*/		regs.R22 = regs.R7;
		/* 820C4F40h case    8:*/		return 0x820C4F44;
		  /* 820C4F44h */ case    9:  		/* mr R25, R5 */
		/* 820C4F44h case    9:*/		regs.R25 = regs.R5;
		/* 820C4F44h case    9:*/		return 0x820C4F48;
		  /* 820C4F48h */ case   10:  		/* lhz R10, <#[R31]> */
		/* 820C4F48h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820C4F48h case   10:*/		return 0x820C4F4C;
		  /* 820C4F4Ch */ case   11:  		/* cmplwi CR6, R10, 1 */
		/* 820C4F4Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C4F4Ch case   11:*/		return 0x820C4F50;
		  /* 820C4F50h */ case   12:  		/* bc 12, CR6_LT, 392 */
		/* 820C4F50h case   12:*/		if ( regs.CR[6].lt ) { return 0x820C50D8;  }
		/* 820C4F50h case   12:*/		return 0x820C4F54;
		  /* 820C4F54h */ case   13:  		/* bc 12, CR6_EQ, 380 */
		/* 820C4F54h case   13:*/		if ( regs.CR[6].eq ) { return 0x820C50D0;  }
		/* 820C4F54h case   13:*/		return 0x820C4F58;
		  /* 820C4F58h */ case   14:  		/* cmplwi CR6, R10, 3 */
		/* 820C4F58h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C4F58h case   14:*/		return 0x820C4F5C;
		  /* 820C4F5Ch */ case   15:  		/* bc 12, CR6_LT, 340 */
		/* 820C4F5Ch case   15:*/		if ( regs.CR[6].lt ) { return 0x820C50B0;  }
		/* 820C4F5Ch case   15:*/		return 0x820C4F60;
		  /* 820C4F60h */ case   16:  		/* bc 12, CR6_EQ, 176 */
		/* 820C4F60h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C5010;  }
		/* 820C4F60h case   16:*/		return 0x820C4F64;
		  /* 820C4F64h */ case   17:  		/* cmplwi CR6, R10, 5 */
		/* 820C4F64h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000005);
		/* 820C4F64h case   17:*/		return 0x820C4F68;
		  /* 820C4F68h */ case   18:  		/* bc 12, CR6_EQ, 16 */
		/* 820C4F68h case   18:*/		if ( regs.CR[6].eq ) { return 0x820C4F78;  }
		/* 820C4F68h case   18:*/		return 0x820C4F6C;
		  /* 820C4F6Ch */ case   19:  		/* lis R3, -32768 */
		/* 820C4F6Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C4F6Ch case   19:*/		return 0x820C4F70;
		  /* 820C4F70h */ case   20:  		/* ori R3, R3, 16385 */
		/* 820C4F70h case   20:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 820C4F70h case   20:*/		return 0x820C4F74;
		  /* 820C4F74h */ case   21:  		/* b 680 */
		/* 820C4F74h case   21:*/		return 0x820C521C;
		/* 820C4F74h case   21:*/		return 0x820C4F78;
	}
	return 0x820C4F78;
} // Block from 820C4F20h-820C4F78h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C4F78h
// Function '??1CConstant@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4F78);
		  /* 820C4F78h */ case    0:  		/* lwz R9, <#[R24 + 52]> */
		/* 820C4F78h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000034) );
		/* 820C4F78h case    0:*/		return 0x820C4F7C;
		  /* 820C4F7Ch */ case    1:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C4F7Ch case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C4F7Ch case    1:*/		return 0x820C4F80;
		  /* 820C4F80h */ case    2:  		/* divwu R27, R11, R9 */
		/* 820C4F80h case    2:*/		cpu::op::divwu<0>(regs,&regs.R27,regs.R11,regs.R9);
		/* 820C4F80h case    2:*/		return 0x820C4F84;
		  /* 820C4F84h */ case    3:  		/* twi 6, R9, 0 */
		/* 820C4F84h case    3:*/		cpu::op::tw<6>(regs, 0x820C4F84, regs.R9, 0x00000000);
		/* 820C4F84h case    3:*/		return 0x820C4F88;
		  /* 820C4F88h */ case    4:  		/* cmplw CR6, R27, R10 */
		/* 820C4F88h case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R10);
		/* 820C4F88h case    4:*/		return 0x820C4F8C;
		  /* 820C4F8Ch */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 820C4F8Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x820C4F94;  }
		/* 820C4F8Ch case    5:*/		return 0x820C4F90;
		  /* 820C4F90h */ case    6:  		/* mr R27, R10 */
		/* 820C4F90h case    6:*/		regs.R27 = regs.R10;
		/* 820C4F90h case    6:*/		return 0x820C4F94;
	}
	return 0x820C4F94;
} // Block from 820C4F78h-820C4F94h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C4F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4F94);
		  /* 820C4F94h */ case    0:  		/* li R26, 0 */
		/* 820C4F94h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820C4F94h case    0:*/		return 0x820C4F98;
		  /* 820C4F98h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 820C4F98h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820C4F98h case    1:*/		return 0x820C4F9C;
		  /* 820C4F9Ch */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 820C4F9Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5008;  }
		/* 820C4F9Ch case    2:*/		return 0x820C4FA0;
		  /* 820C4FA0h */ case    3:  		/* lhz R11, <#[R31 + 10]> */
		/* 820C4FA0h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000A) );
		/* 820C4FA0h case    3:*/		return 0x820C4FA4;
		  /* 820C4FA4h */ case    4:  		/* li R28, 0 */
		/* 820C4FA4h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820C4FA4h case    4:*/		return 0x820C4FA8;
		  /* 820C4FA8h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 820C4FA8h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C4FA8h case    5:*/		return 0x820C4FAC;
		  /* 820C4FACh */ case    6:  		/* bc 12, CR0_EQ, 80 */
		/* 820C4FACh case    6:*/		if ( regs.CR[0].eq ) { return 0x820C4FFC;  }
		/* 820C4FACh case    6:*/		return 0x820C4FB0;
		  /* 820C4FB0h */ case    7:  		/* li R29, 0 */
		/* 820C4FB0h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C4FB0h case    7:*/		return 0x820C4FB4;
		  /* 820C4FB4h */ case    8:  		/* lwz R11, <#[R24 + 56]> */
		/* 820C4FB4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 820C4FB4h case    8:*/		return 0x820C4FB8;
		  /* 820C4FB8h */ case    9:  		/* mr R7, R22 */
		/* 820C4FB8h case    9:*/		regs.R7 = regs.R22;
		/* 820C4FB8h case    9:*/		return 0x820C4FBC;
		  /* 820C4FBCh */ case   10:  		/* mr R5, R25 */
		/* 820C4FBCh case   10:*/		regs.R5 = regs.R25;
		/* 820C4FBCh case   10:*/		return 0x820C4FC0;
		  /* 820C4FC0h */ case   11:  		/* mr R4, R23 */
		/* 820C4FC0h case   11:*/		regs.R4 = regs.R23;
		/* 820C4FC0h case   11:*/		return 0x820C4FC4;
		  /* 820C4FC4h */ case   12:  		/* lwzx R30, <#[R29 + R11]> */
		/* 820C4FC4h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820C4FC4h case   12:*/		return 0x820C4FC8;
		  /* 820C4FC8h */ case   13:  		/* mr R3, R30 */
		/* 820C4FC8h case   13:*/		regs.R3 = regs.R30;
		/* 820C4FC8h case   13:*/		return 0x820C4FCC;
		  /* 820C4FCCh */ case   14:  		/* lwz R6, <#[R30 + 48]> */
		/* 820C4FCCh case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000030) );
		/* 820C4FCCh case   14:*/		return 0x820C4FD0;
		  /* 820C4FD0h */ case   15:  		/* bl -176 */
		/* 820C4FD0h case   15:*/		regs.LR = 0x820C4FD4; return 0x820C4F20;
		/* 820C4FD0h case   15:*/		return 0x820C4FD4;
		  /* 820C4FD4h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820C4FD4h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C4FD4h case   16:*/		return 0x820C4FD8;
		  /* 820C4FD8h */ case   17:  		/* bc 12, CR0_LT, 580 */
		/* 820C4FD8h case   17:*/		if ( regs.CR[0].lt ) { return 0x820C521C;  }
		/* 820C4FD8h case   17:*/		return 0x820C4FDC;
		  /* 820C4FDCh */ case   18:  		/* lwz R11, <#[R30 + 48]> */
		/* 820C4FDCh case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 820C4FDCh case   18:*/		return 0x820C4FE0;
		  /* 820C4FE0h */ case   19:  		/* addi R28, R28, 1 */
		/* 820C4FE0h case   19:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820C4FE0h case   19:*/		return 0x820C4FE4;
		  /* 820C4FE4h */ case   20:  		/* lhz R10, <#[R31 + 10]> */
		/* 820C4FE4h case   20:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000A) );
		/* 820C4FE4h case   20:*/		return 0x820C4FE8;
		  /* 820C4FE8h */ case   21:  		/* addi R29, R29, 4 */
		/* 820C4FE8h case   21:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820C4FE8h case   21:*/		return 0x820C4FEC;
		  /* 820C4FECh */ case   22:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C4FECh case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C4FECh case   22:*/		return 0x820C4FF0;
		  /* 820C4FF0h */ case   23:  		/* cmplw CR6, R28, R10 */
		/* 820C4FF0h case   23:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 820C4FF0h case   23:*/		return 0x820C4FF4;
		  /* 820C4FF4h */ case   24:  		/* add R25, R11, R25 */
		/* 820C4FF4h case   24:*/		cpu::op::add<0>(regs,&regs.R25,regs.R11,regs.R25);
		/* 820C4FF4h case   24:*/		return 0x820C4FF8;
		  /* 820C4FF8h */ case   25:  		/* bc 12, CR6_LT, -68 */
		/* 820C4FF8h case   25:*/		if ( regs.CR[6].lt ) { return 0x820C4FB4;  }
		/* 820C4FF8h case   25:*/		return 0x820C4FFC;
	}
	return 0x820C4FFC;
} // Block from 820C4F94h-820C4FFCh (26 instructions)

//////////////////////////////////////////////////////
// Block at 820C4FFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C4FFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C4FFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C4FFC);
		  /* 820C4FFCh */ case    0:  		/* addi R26, R26, 1 */
		/* 820C4FFCh case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820C4FFCh case    0:*/		return 0x820C5000;
		  /* 820C5000h */ case    1:  		/* cmplw CR6, R26, R27 */
		/* 820C5000h case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R27);
		/* 820C5000h case    1:*/		return 0x820C5004;
		  /* 820C5004h */ case    2:  		/* bc 12, CR6_LT, -100 */
		/* 820C5004h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C4FA0;  }
		/* 820C5004h case    2:*/		return 0x820C5008;
	}
	return 0x820C5008;
} // Block from 820C4FFCh-820C5008h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5008);
		  /* 820C5008h */ case    0:  		/* li R3, 0 */
		/* 820C5008h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C5008h case    0:*/		return 0x820C500C;
		  /* 820C500Ch */ case    1:  		/* b 528 */
		/* 820C500Ch case    1:*/		return 0x820C521C;
		/* 820C500Ch case    1:*/		return 0x820C5010;
	}
	return 0x820C5010;
} // Block from 820C5008h-820C5010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5010);
		  /* 820C5010h */ case    0:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C5010h case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5010h case    0:*/		return 0x820C5014;
		  /* 820C5014h */ case    1:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C5014h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5014h case    1:*/		return 0x820C5018;
		  /* 820C5018h */ case    2:  		/* lhz R9, <#[R31 + 8]> */
		/* 820C5018h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820C5018h case    2:*/		return 0x820C501C;
		  /* 820C501Ch */ case    3:  		/* mullw R7, R10, R8 */
		/* 820C501Ch case    3:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R8);
		/* 820C501Ch case    3:*/		return 0x820C5020;
		  /* 820C5020h */ case    4:  		/* divwu R3, R11, R7 */
		/* 820C5020h case    4:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R11,regs.R7);
		/* 820C5020h case    4:*/		return 0x820C5024;
		  /* 820C5024h */ case    5:  		/* twi 6, R7, 0 */
		/* 820C5024h case    5:*/		cpu::op::tw<6>(regs, 0x820C5024, regs.R7, 0x00000000);
		/* 820C5024h case    5:*/		return 0x820C5028;
		  /* 820C5028h */ case    6:  		/* cmplw CR6, R3, R9 */
		/* 820C5028h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 820C5028h case    6:*/		return 0x820C502C;
		  /* 820C502Ch */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 820C502Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x820C5034;  }
		/* 820C502Ch case    7:*/		return 0x820C5030;
		  /* 820C5030h */ case    8:  		/* mr R3, R9 */
		/* 820C5030h case    8:*/		regs.R3 = regs.R9;
		/* 820C5030h case    8:*/		return 0x820C5034;
	}
	return 0x820C5034;
} // Block from 820C5010h-820C5034h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C5034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5034);
		  /* 820C5034h */ case    0:  		/* li R4, 0 */
		/* 820C5034h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C5034h case    0:*/		return 0x820C5038;
		  /* 820C5038h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C5038h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C5038h case    1:*/		return 0x820C503C;
		  /* 820C503Ch */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 820C503Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C50A8;  }
		/* 820C503Ch case    2:*/		return 0x820C5040;
		  /* 820C5040h */ case    3:  		/* addi R7, R6, -4 */
		/* 820C5040h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820C5040h case    3:*/		return 0x820C5044;
		  /* 820C5044h */ case    4:  		/* li R9, 0 */
		/* 820C5044h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C5044h case    4:*/		return 0x820C5048;
		  /* 820C5048h */ case    5:  		/* cmplwi CR6, R8, 0 */
		/* 820C5048h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C5048h case    5:*/		return 0x820C504C;
		  /* 820C504Ch */ case    6:  		/* bc 12, CR6_EQ, 80 */
		/* 820C504Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820C509C;  }
		/* 820C504Ch case    6:*/		return 0x820C5050;
		  /* 820C5050h */ case    7:  		/* li R11, 0 */
		/* 820C5050h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C5050h case    7:*/		return 0x820C5054;
		  /* 820C5054h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 820C5054h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C5054h case    8:*/		return 0x820C5058;
		  /* 820C5058h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 820C5058h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C508C;  }
		/* 820C5058h case    9:*/		return 0x820C505C;
		  /* 820C505Ch */ case   10:  		/* mullw R10, R10, R4 */
		/* 820C505Ch case   10:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 820C505Ch case   10:*/		return 0x820C5060;
	}
	return 0x820C5060;
} // Block from 820C5034h-820C5060h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C5060h
// Function '?GetConstantDesc@CConstantTable@D3DXShader@@UAAJIPAU_D3DXCONSTANT_DESC@@PAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5060);
		  /* 820C5060h */ case    0:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C5060h case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5060h case    0:*/		return 0x820C5064;
		  /* 820C5064h */ case    1:  		/* add R10, R10, R11 */
		/* 820C5064h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C5064h case    1:*/		return 0x820C5068;
		  /* 820C5068h */ case    2:  		/* addi R11, R11, 1 */
		/* 820C5068h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C5068h case    2:*/		return 0x820C506C;
		  /* 820C506Ch */ case    3:  		/* mullw R10, R10, R8 */
		/* 820C506Ch case    3:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820C506Ch case    3:*/		return 0x820C5070;
		  /* 820C5070h */ case    4:  		/* add R10, R10, R9 */
		/* 820C5070h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820C5070h case    4:*/		return 0x820C5074;
		  /* 820C5074h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C5074h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C5074h case    5:*/		return 0x820C5078;
		  /* 820C5078h */ case    6:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C5078h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C5078h case    6:*/		return 0x820C507C;
		  /* 820C507Ch */ case    7:  		/* stwu R10, <#[R7 + 4]> */
		/* 820C507Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820C507Ch case    7:*/		return 0x820C5080;
		  /* 820C5080h */ case    8:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C5080h case    8:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5080h case    8:*/		return 0x820C5084;
		  /* 820C5084h */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820C5084h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C5084h case    9:*/		return 0x820C5088;
		  /* 820C5088h */ case   10:  		/* bc 12, CR6_LT, -44 */
		/* 820C5088h case   10:*/		if ( regs.CR[6].lt ) { return 0x820C505C;  }
		/* 820C5088h case   10:*/		return 0x820C508C;
	}
	return 0x820C508C;
} // Block from 820C5060h-820C508Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C508Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C508C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C508C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C508C);
		  /* 820C508Ch */ case    0:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C508Ch case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C508Ch case    0:*/		return 0x820C5090;
		  /* 820C5090h */ case    1:  		/* addi R9, R9, 1 */
		/* 820C5090h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C5090h case    1:*/		return 0x820C5094;
		  /* 820C5094h */ case    2:  		/* cmplw CR6, R9, R8 */
		/* 820C5094h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820C5094h case    2:*/		return 0x820C5098;
		  /* 820C5098h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 820C5098h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C5050;  }
		/* 820C5098h case    3:*/		return 0x820C509C;
	}
	return 0x820C509C;
} // Block from 820C508Ch-820C509Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C509Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C509C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C509C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C509C);
		  /* 820C509Ch */ case    0:  		/* addi R4, R4, 1 */
		/* 820C509Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820C509Ch case    0:*/		return 0x820C50A0;
		  /* 820C50A0h */ case    1:  		/* cmplw CR6, R4, R3 */
		/* 820C50A0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 820C50A0h case    1:*/		return 0x820C50A4;
		  /* 820C50A4h */ case    2:  		/* bc 12, CR6_LT, -96 */
		/* 820C50A4h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C5044;  }
		/* 820C50A4h case    2:*/		return 0x820C50A8;
	}
	return 0x820C50A8;
} // Block from 820C509Ch-820C50A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C50A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C50A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C50A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C50A8);
		  /* 820C50A8h */ case    0:  		/* mr R25, R6 */
		/* 820C50A8h case    0:*/		regs.R25 = regs.R6;
		/* 820C50A8h case    0:*/		return 0x820C50AC;
		  /* 820C50ACh */ case    1:  		/* b 64 */
		/* 820C50ACh case    1:*/		return 0x820C50EC;
		/* 820C50ACh case    1:*/		return 0x820C50B0;
	}
	return 0x820C50B0;
} // Block from 820C50A8h-820C50B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C50B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C50B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C50B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C50B0);
		  /* 820C50B0h */ case    0:  		/* lhz R9, <#[R31 + 6]> */
		/* 820C50B0h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000006) );
		/* 820C50B0h case    0:*/		return 0x820C50B4;
		  /* 820C50B4h */ case    1:  		/* lhz R8, <#[R31 + 4]> */
		/* 820C50B4h case    1:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 820C50B4h case    1:*/		return 0x820C50B8;
		  /* 820C50B8h */ case    2:  		/* mullw R9, R9, R8 */
		/* 820C50B8h case    2:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820C50B8h case    2:*/		return 0x820C50BC;
		  /* 820C50BCh */ case    3:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C50BCh case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C50BCh case    3:*/		return 0x820C50C0;
		  /* 820C50C0h */ case    4:  		/* divwu R3, R11, R9 */
		/* 820C50C0h case    4:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R11,regs.R9);
		/* 820C50C0h case    4:*/		return 0x820C50C4;
		  /* 820C50C4h */ case    5:  		/* twi 6, R9, 0 */
		/* 820C50C4h case    5:*/		cpu::op::tw<6>(regs, 0x820C50C4, regs.R9, 0x00000000);
		/* 820C50C4h case    5:*/		return 0x820C50C8;
		  /* 820C50C8h */ case    6:  		/* cmplw CR6, R3, R10 */
		/* 820C50C8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C50C8h case    6:*/		return 0x820C50CC;
		  /* 820C50CCh */ case    7:  		/* b 24 */
		/* 820C50CCh case    7:*/		return 0x820C50E4;
		/* 820C50CCh case    7:*/		return 0x820C50D0;
	}
	return 0x820C50D0;
} // Block from 820C50B0h-820C50D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C50D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C50D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C50D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C50D0);
		  /* 820C50D0h */ case    0:  		/* lhz R9, <#[R31 + 6]> */
		/* 820C50D0h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000006) );
		/* 820C50D0h case    0:*/		return 0x820C50D4;
		  /* 820C50D4h */ case    1:  		/* b -24 */
		/* 820C50D4h case    1:*/		return 0x820C50BC;
		/* 820C50D4h case    1:*/		return 0x820C50D8;
	}
	return 0x820C50D8;
} // Block from 820C50D0h-820C50D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C50D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C50D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C50D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C50D8);
		  /* 820C50D8h */ case    0:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C50D8h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C50D8h case    0:*/		return 0x820C50DC;
		  /* 820C50DCh */ case    1:  		/* mr R3, R11 */
		/* 820C50DCh case    1:*/		regs.R3 = regs.R11;
		/* 820C50DCh case    1:*/		return 0x820C50E0;
		  /* 820C50E0h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C50E0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C50E0h case    2:*/		return 0x820C50E4;
	}
	return 0x820C50E4;
} // Block from 820C50D8h-820C50E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C50E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C50E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C50E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C50E4);
		  /* 820C50E4h */ case    0:  		/* bc 4, CR6_GT, 8 */
		/* 820C50E4h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820C50EC;  }
		/* 820C50E4h case    0:*/		return 0x820C50E8;
		  /* 820C50E8h */ case    1:  		/* mr R3, R10 */
		/* 820C50E8h case    1:*/		regs.R3 = regs.R10;
		/* 820C50E8h case    1:*/		return 0x820C50EC;
	}
	return 0x820C50EC;
} // Block from 820C50E4h-820C50ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C50ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C50EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C50EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C50EC);
		  /* 820C50ECh */ case    0:  		/* lhz R9, <#[R24 + 8]> */
		/* 820C50ECh case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 820C50ECh case    0:*/		return 0x820C50F0;
		  /* 820C50F0h */ case    1:  		/* cmplwi CR0, R9, 0 */
		/* 820C50F0h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820C50F0h case    1:*/		return 0x820C50F4;
		  /* 820C50F4h */ case    2:  		/* bc 12, CR0_EQ, 216 */
		/* 820C50F4h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C51CC;  }
		/* 820C50F4h case    2:*/		return 0x820C50F8;
		  /* 820C50F8h */ case    3:  		/* lhz R11, <#[R31]> */
		/* 820C50F8h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C50F8h case    3:*/		return 0x820C50FC;
		  /* 820C50FCh */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C50FCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C50FCh case    4:*/		return 0x820C5100;
		  /* 820C5100h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820C5100h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C5110;  }
		/* 820C5100h case    5:*/		return 0x820C5104;
		  /* 820C5104h */ case    6:  		/* lhz R11, <#[R31 + 6]> */
		/* 820C5104h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5104h case    6:*/		return 0x820C5108;
		  /* 820C5108h */ case    7:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C5108h case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5108h case    7:*/		return 0x820C510C;
		  /* 820C510Ch */ case    8:  		/* b 12 */
		/* 820C510Ch case    8:*/		return 0x820C5118;
		/* 820C510Ch case    8:*/		return 0x820C5110;
	}
	return 0x820C5110;
} // Block from 820C50ECh-820C5110h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C5110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5110);
		  /* 820C5110h */ case    0:  		/* lhz R11, <#[R31 + 4]> */
		/* 820C5110h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5110h case    0:*/		return 0x820C5114;
		  /* 820C5114h */ case    1:  		/* lhz R10, <#[R31 + 6]> */
		/* 820C5114h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5114h case    1:*/		return 0x820C5118;
	}
	return 0x820C5118;
} // Block from 820C5110h-820C5118h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5118);
		  /* 820C5118h */ case    0:  		/* rlwinm. R8, R11, 0, 30, 31 */
		/* 820C5118h case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R8,regs.R11);
		/* 820C5118h case    0:*/		return 0x820C511C;
		  /* 820C511Ch */ case    1:  		/* bc 12, CR0_EQ, 176 */
		/* 820C511Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820C51CC;  }
		/* 820C511Ch case    1:*/		return 0x820C5120;
		  /* 820C5120h */ case    2:  		/* cmplwi CR6, R9, 1 */
		/* 820C5120h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820C5120h case    2:*/		return 0x820C5124;
		  /* 820C5124h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820C5124h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C5134;  }
		/* 820C5124h case    3:*/		return 0x820C5128;
		  /* 820C5128h */ case    4:  		/* lis R9, -32255 */
		/* 820C5128h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C5128h case    4:*/		return 0x820C512C;
		  /* 820C512Ch */ case    5:  		/* addi R4, R9, 10344 */
		/* 820C512Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2868);
		/* 820C512Ch case    5:*/		return 0x820C5130;
	}
	return 0x820C5130;
} // Block from 820C5118h-820C5130h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C5130h
// Function '?GetSamplerIndex@CConstantTable@D3DXShader@@UAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5130);
		  /* 820C5130h */ case    0:  		/* b 12 */
		/* 820C5130h case    0:*/		return 0x820C513C;
		/* 820C5130h case    0:*/		return 0x820C5134;
	}
	return 0x820C5134;
} // Block from 820C5130h-820C5134h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C5134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5134);
		  /* 820C5134h */ case    0:  		/* lis R9, -32255 */
		/* 820C5134h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C5134h case    0:*/		return 0x820C5138;
		  /* 820C5138h */ case    1:  		/* addi R4, R9, 10360 */
		/* 820C5138h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2878);
		/* 820C5138h case    1:*/		return 0x820C513C;
	}
	return 0x820C513C;
} // Block from 820C5134h-820C513Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C513Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C513C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C513C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C513C);
		  /* 820C513Ch */ case    0:  		/* addi R9, R11, 3 */
		/* 820C513Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 820C513Ch case    0:*/		return 0x820C5140;
		  /* 820C5140h */ case    1:  		/* mullw. R8, R10, R3 */
		/* 820C5140h case    1:*/		cpu::op::mullw<1>(regs,&regs.R8,regs.R10,regs.R3);
		/* 820C5140h case    1:*/		return 0x820C5144;
		  /* 820C5144h */ case    2:  		/* rlwinm R7, R9, 0, 0, 29 */
		/* 820C5144h case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R7,regs.R9);
		/* 820C5144h case    2:*/		return 0x820C5148;
		  /* 820C5148h */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 820C5148h case    3:*/		if ( regs.CR[0].eq ) { return 0x820C51C8;  }
		/* 820C5148h case    3:*/		return 0x820C514C;
		  /* 820C514Ch */ case    4:  		/* mullw R9, R8, R7 */
		/* 820C514Ch case    4:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R7);
		/* 820C514Ch case    4:*/		return 0x820C5150;
	}
	return 0x820C5150;
} // Block from 820C513Ch-820C5150h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C5150h
// Function '?GetConstant@CConstantTable@D3DXShader@@UAAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5150);
		  /* 820C5150h */ case    0:  		/* mullw R5, R8, R11 */
		/* 820C5150h case    0:*/		cpu::op::mullw<0>(regs,&regs.R5,regs.R8,regs.R11);
		/* 820C5150h case    0:*/		return 0x820C5154;
		  /* 820C5154h */ case    1:  		/* addi R8, R8, -1 */
		/* 820C5154h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820C5154h case    1:*/		return 0x820C5158;
		  /* 820C5158h */ case    2:  		/* subf R5, R11, R5 */
		/* 820C5158h case    2:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 820C5158h case    2:*/		return 0x820C515C;
		  /* 820C515Ch */ case    3:  		/* subf R9, R7, R9 */
		/* 820C515Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820C515Ch case    3:*/		return 0x820C5160;
		  /* 820C5160h */ case    4:  		/* mr R10, R7 */
		/* 820C5160h case    4:*/		regs.R10 = regs.R7;
		/* 820C5160h case    4:*/		return 0x820C5164;
		  /* 820C5164h */ case    5:  		/* cmplw CR6, R7, R11 */
		/* 820C5164h case    5:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C5164h case    5:*/		return 0x820C5168;
		  /* 820C5168h */ case    6:  		/* bc 4, CR6_GT, 40 */
		/* 820C5168h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820C5190;  }
		/* 820C5168h case    6:*/		return 0x820C516C;
		  /* 820C516Ch */ case    7:  		/* subf R31, R11, R7 */
		/* 820C516Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R7);
		/* 820C516Ch case    7:*/		return 0x820C5170;
		  /* 820C5170h */ case    8:  		/* mtspr CTR, R31 */
		/* 820C5170h case    8:*/		regs.CTR = regs.R31;
		/* 820C5170h case    8:*/		return 0x820C5174;
		  /* 820C5174h */ case    9:  		/* addi R10, R10, -1 */
		/* 820C5174h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C5174h case    9:*/		return 0x820C5178;
		  /* 820C5178h */ case   10:  		/* rlwinm R31, R10, 2, 28, 29 */
		/* 820C5178h case   10:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R31,regs.R10);
		/* 820C5178h case   10:*/		return 0x820C517C;
		  /* 820C517Ch */ case   11:  		/* add R30, R9, R10 */
		/* 820C517Ch case   11:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R10);
		/* 820C517Ch case   11:*/		return 0x820C5180;
		  /* 820C5180h */ case   12:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C5180h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C5180h case   12:*/		return 0x820C5184;
		  /* 820C5184h */ case   13:  		/* lwzx R31, <#[R31 + R4]> */
		/* 820C5184h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R4 + 0x00000000) );
		/* 820C5184h case   13:*/		return 0x820C5188;
		  /* 820C5188h */ case   14:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C5188h case   14:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C5188h case   14:*/		return 0x820C518C;
		  /* 820C518Ch */ case   15:  		/* bc 16, CR0_LT, -24 */
		/* 820C518Ch case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C5174;  }
		/* 820C518Ch case   15:*/		return 0x820C5190;
	}
	return 0x820C5190;
} // Block from 820C5150h-820C5190h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C5190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5190);
		  /* 820C5190h */ case    0:  		/* mr R10, R11 */
		/* 820C5190h case    0:*/		regs.R10 = regs.R11;
		/* 820C5190h case    0:*/		return 0x820C5194;
		  /* 820C5194h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C5194h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C5194h case    1:*/		return 0x820C5198;
		  /* 820C5198h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820C5198h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C51C0;  }
		/* 820C5198h case    2:*/		return 0x820C519C;
		  /* 820C519Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 820C519Ch case    3:*/		regs.CTR = regs.R11;
		/* 820C519Ch case    3:*/		return 0x820C51A0;
		  /* 820C51A0h */ case    4:  		/* addi R10, R10, -1 */
		/* 820C51A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C51A0h case    4:*/		return 0x820C51A4;
		  /* 820C51A4h */ case    5:  		/* add R31, R5, R10 */
		/* 820C51A4h case    5:*/		cpu::op::add<0>(regs,&regs.R31,regs.R5,regs.R10);
		/* 820C51A4h case    5:*/		return 0x820C51A8;
		  /* 820C51A8h */ case    6:  		/* add R30, R9, R10 */
		/* 820C51A8h case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R10);
		/* 820C51A8h case    6:*/		return 0x820C51AC;
		  /* 820C51ACh */ case    7:  		/* rlwinm R31, R31, 2, 0, 29 */
		/* 820C51ACh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R31);
		/* 820C51ACh case    7:*/		return 0x820C51B0;
		  /* 820C51B0h */ case    8:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C51B0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C51B0h case    8:*/		return 0x820C51B4;
		  /* 820C51B4h */ case    9:  		/* lwzx R31, <#[R31 + R25]> */
		/* 820C51B4h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R25 + 0x00000000) );
		/* 820C51B4h case    9:*/		return 0x820C51B8;
	}
	return 0x820C51B8;
} // Block from 820C5190h-820C51B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C51B8h
// Function '?Set@?$SetShaderConstant@$0A@$0A@$00@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C51B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C51B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C51B8);
		  /* 820C51B8h */ case    0:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C51B8h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C51B8h case    0:*/		return 0x820C51BC;
		  /* 820C51BCh */ case    1:  		/* bc 16, CR0_LT, -28 */
		/* 820C51BCh case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C51A0;  }
		/* 820C51BCh case    1:*/		return 0x820C51C0;
	}
	return 0x820C51C0;
} // Block from 820C51B8h-820C51C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C51C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C51C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C51C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C51C0);
		  /* 820C51C0h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820C51C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C51C0h case    0:*/		return 0x820C51C4;
		  /* 820C51C4h */ case    1:  		/* bc 4, CR6_EQ, -112 */
		/* 820C51C4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C5154;  }
		/* 820C51C4h case    1:*/		return 0x820C51C8;
	}
	return 0x820C51C8;
} // Block from 820C51C0h-820C51C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C51C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C51C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C51C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C51C8);
		  /* 820C51C8h */ case    0:  		/* mr R25, R6 */
		/* 820C51C8h case    0:*/		regs.R25 = regs.R6;
		/* 820C51C8h case    0:*/		return 0x820C51CC;
	}
	return 0x820C51CC;
} // Block from 820C51C8h-820C51CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C51CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C51CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C51CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C51CC);
		  /* 820C51CCh */ case    0:  		/* lwz R10, <#[R24 + 44]> */
		/* 820C51CCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000002C) );
		/* 820C51CCh case    0:*/		return 0x820C51D0;
		  /* 820C51D0h */ case    1:  		/* lhz R11, <#[R24 + 12]> */
		/* 820C51D0h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820C51D0h case    1:*/		return 0x820C51D4;
		  /* 820C51D4h */ case    2:  		/* mullw R7, R10, R3 */
		/* 820C51D4h case    2:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R3);
		/* 820C51D4h case    2:*/		return 0x820C51D8;
		  /* 820C51D8h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820C51D8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C51D8h case    3:*/		return 0x820C51DC;
		  /* 820C51DCh */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 820C51DCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x820C51E4;  }
		/* 820C51DCh case    4:*/		return 0x820C51E0;
	}
	return 0x820C51E0;
} // Block from 820C51CCh-820C51E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C51E0h
// Function '?Set@?$SetShaderConstant@$0A@$0A@$01@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C51E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C51E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C51E0);
		  /* 820C51E0h */ case    0:  		/* mr R7, R11 */
		/* 820C51E0h case    0:*/		regs.R7 = regs.R11;
		/* 820C51E0h case    0:*/		return 0x820C51E4;
	}
	return 0x820C51E4;
} // Block from 820C51E0h-820C51E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C51E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C51E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C51E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C51E4);
		  /* 820C51E4h */ case    0:  		/* lwz R10, <#[R24 + 28]> */
		/* 820C51E4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 820C51E4h case    0:*/		return 0x820C51E8;
		  /* 820C51E8h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C51E8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C51E8h case    1:*/		return 0x820C51EC;
		  /* 820C51ECh */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C51ECh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C51FC;  }
		/* 820C51ECh case    2:*/		return 0x820C51F0;
		  /* 820C51F0h */ case    3:  		/* lis R3, -32768 */
		/* 820C51F0h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C51F0h case    3:*/		return 0x820C51F4;
		  /* 820C51F4h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820C51F4h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C51F4h case    4:*/		return 0x820C51F8;
		  /* 820C51F8h */ case    5:  		/* b 36 */
		/* 820C51F8h case    5:*/		return 0x820C521C;
		/* 820C51F8h case    5:*/		return 0x820C51FC;
	}
	return 0x820C51FC;
} // Block from 820C51E4h-820C51FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C51FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C51FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C51FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C51FC);
		  /* 820C51FCh */ case    0:  		/* lhz R11, <#[R24 + 10]> */
		/* 820C51FCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000A) );
		/* 820C51FCh case    0:*/		return 0x820C5200;
		  /* 820C5200h */ case    1:  		/* mr R5, R25 */
		/* 820C5200h case    1:*/		regs.R5 = regs.R25;
		/* 820C5200h case    1:*/		return 0x820C5204;
		  /* 820C5204h */ case    2:  		/* mr R3, R23 */
		/* 820C5204h case    2:*/		regs.R3 = regs.R23;
		/* 820C5204h case    2:*/		return 0x820C5208;
		  /* 820C5208h */ case    3:  		/* mtspr CTR, R10 */
		/* 820C5208h case    3:*/		regs.CTR = regs.R10;
		/* 820C5208h case    3:*/		return 0x820C520C;
		  /* 820C520Ch */ case    4:  		/* add R4, R11, R22 */
		/* 820C520Ch case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R22);
		/* 820C520Ch case    4:*/		return 0x820C5210;
		  /* 820C5210h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820C5210h case    5:*/		if ( 1 ) { regs.LR = 0x820C5214; return (uint32)regs.CTR; }
		/* 820C5210h case    5:*/		return 0x820C5214;
		  /* 820C5214h */ case    6:  		/* srawi R11, R3, 31 */
		/* 820C5214h case    6:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820C5214h case    6:*/		return 0x820C5218;
		  /* 820C5218h */ case    7:  		/* and R3, R11, R3 */
		/* 820C5218h case    7:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C5218h case    7:*/		return 0x820C521C;
	}
	return 0x820C521C;
} // Block from 820C51FCh-820C521Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C521Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C521C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C521C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C521C);
		  /* 820C521Ch */ case    0:  		/* addi R1, R1, 176 */
		/* 820C521Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820C521Ch case    0:*/		return 0x820C5220;
		  /* 820C5220h */ case    1:  		/* b -212880 */
		/* 820C5220h case    1:*/		return 0x82091290;
		/* 820C5220h case    1:*/		return 0x820C5224;
		  /* 820C5224h */ case    2:  		/* nop */
		/* 820C5224h case    2:*/		cpu::op::nop();
		/* 820C5224h case    2:*/		return 0x820C5228;
	}
	return 0x820C5228;
} // Block from 820C521Ch-820C5228h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5228);
		  /* 820C5228h */ case    0:  		/* mfspr R12, LR */
		/* 820C5228h case    0:*/		regs.R12 = regs.LR;
		/* 820C5228h case    0:*/		return 0x820C522C;
		  /* 820C522Ch */ case    1:  		/* bl -212972 */
		/* 820C522Ch case    1:*/		regs.LR = 0x820C5230; return 0x82091240;
		/* 820C522Ch case    1:*/		return 0x820C5230;
		  /* 820C5230h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820C5230h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820C5230h case    2:*/		return 0x820C5234;
		  /* 820C5234h */ case    3:  		/* lwz R31, <#[R3 + 24]> */
		/* 820C5234h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000018) );
		/* 820C5234h case    3:*/		return 0x820C5238;
	}
	return 0x820C5238;
} // Block from 820C5228h-820C5238h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5238h
// Function '?Set@?$SetShaderConstant@$0A@$0A@$02@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5238);
		  /* 820C5238h */ case    0:  		/* mr R11, R6 */
		/* 820C5238h case    0:*/		regs.R11 = regs.R6;
		/* 820C5238h case    0:*/		return 0x820C523C;
		  /* 820C523Ch */ case    1:  		/* lwz R6, <#[R3 + 32]> */
		/* 820C523Ch case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000020) );
		/* 820C523Ch case    1:*/		return 0x820C5240;
		  /* 820C5240h */ case    2:  		/* mr R24, R3 */
		/* 820C5240h case    2:*/		regs.R24 = regs.R3;
		/* 820C5240h case    2:*/		return 0x820C5244;
		  /* 820C5244h */ case    3:  		/* mr R23, R4 */
		/* 820C5244h case    3:*/		regs.R23 = regs.R4;
		/* 820C5244h case    3:*/		return 0x820C5248;
		  /* 820C5248h */ case    4:  		/* mr R22, R7 */
		/* 820C5248h case    4:*/		regs.R22 = regs.R7;
		/* 820C5248h case    4:*/		return 0x820C524C;
		  /* 820C524Ch */ case    5:  		/* mr R25, R5 */
		/* 820C524Ch case    5:*/		regs.R25 = regs.R5;
		/* 820C524Ch case    5:*/		return 0x820C5250;
		  /* 820C5250h */ case    6:  		/* lhz R10, <#[R31]> */
		/* 820C5250h case    6:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820C5250h case    6:*/		return 0x820C5254;
		  /* 820C5254h */ case    7:  		/* cmplwi CR6, R10, 1 */
		/* 820C5254h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C5254h case    7:*/		return 0x820C5258;
		  /* 820C5258h */ case    8:  		/* bc 12, CR6_LT, 392 */
		/* 820C5258h case    8:*/		if ( regs.CR[6].lt ) { return 0x820C53E0;  }
		/* 820C5258h case    8:*/		return 0x820C525C;
		  /* 820C525Ch */ case    9:  		/* bc 12, CR6_EQ, 380 */
		/* 820C525Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820C53D8;  }
		/* 820C525Ch case    9:*/		return 0x820C5260;
		  /* 820C5260h */ case   10:  		/* cmplwi CR6, R10, 3 */
		/* 820C5260h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C5260h case   10:*/		return 0x820C5264;
		  /* 820C5264h */ case   11:  		/* bc 12, CR6_LT, 340 */
		/* 820C5264h case   11:*/		if ( regs.CR[6].lt ) { return 0x820C53B8;  }
		/* 820C5264h case   11:*/		return 0x820C5268;
		  /* 820C5268h */ case   12:  		/* bc 12, CR6_EQ, 176 */
		/* 820C5268h case   12:*/		if ( regs.CR[6].eq ) { return 0x820C5318;  }
		/* 820C5268h case   12:*/		return 0x820C526C;
		  /* 820C526Ch */ case   13:  		/* cmplwi CR6, R10, 5 */
		/* 820C526Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000005);
		/* 820C526Ch case   13:*/		return 0x820C5270;
		  /* 820C5270h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 820C5270h case   14:*/		if ( regs.CR[6].eq ) { return 0x820C5280;  }
		/* 820C5270h case   14:*/		return 0x820C5274;
		  /* 820C5274h */ case   15:  		/* lis R3, -32768 */
		/* 820C5274h case   15:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C5274h case   15:*/		return 0x820C5278;
		  /* 820C5278h */ case   16:  		/* ori R3, R3, 16385 */
		/* 820C5278h case   16:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 820C5278h case   16:*/		return 0x820C527C;
		  /* 820C527Ch */ case   17:  		/* b 840 */
		/* 820C527Ch case   17:*/		return 0x820C55C4;
		/* 820C527Ch case   17:*/		return 0x820C5280;
	}
	return 0x820C5280;
} // Block from 820C5238h-820C5280h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820C5280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5280);
		  /* 820C5280h */ case    0:  		/* lwz R9, <#[R24 + 52]> */
		/* 820C5280h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000034) );
		/* 820C5280h case    0:*/		return 0x820C5284;
		  /* 820C5284h */ case    1:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C5284h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C5284h case    1:*/		return 0x820C5288;
		  /* 820C5288h */ case    2:  		/* divwu R27, R11, R9 */
		/* 820C5288h case    2:*/		cpu::op::divwu<0>(regs,&regs.R27,regs.R11,regs.R9);
		/* 820C5288h case    2:*/		return 0x820C528C;
		  /* 820C528Ch */ case    3:  		/* twi 6, R9, 0 */
		/* 820C528Ch case    3:*/		cpu::op::tw<6>(regs, 0x820C528C, regs.R9, 0x00000000);
		/* 820C528Ch case    3:*/		return 0x820C5290;
		  /* 820C5290h */ case    4:  		/* cmplw CR6, R27, R10 */
		/* 820C5290h case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R10);
		/* 820C5290h case    4:*/		return 0x820C5294;
		  /* 820C5294h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 820C5294h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820C529C;  }
		/* 820C5294h case    5:*/		return 0x820C5298;
		  /* 820C5298h */ case    6:  		/* mr R27, R10 */
		/* 820C5298h case    6:*/		regs.R27 = regs.R10;
		/* 820C5298h case    6:*/		return 0x820C529C;
	}
	return 0x820C529C;
} // Block from 820C5280h-820C529Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C529Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C529C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C529C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C529C);
		  /* 820C529Ch */ case    0:  		/* li R26, 0 */
		/* 820C529Ch case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820C529Ch case    0:*/		return 0x820C52A0;
	}
	return 0x820C52A0;
} // Block from 820C529Ch-820C52A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C52A0h
// Function '?Set@?$SetShaderConstant@$0A@$00$00@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C52A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C52A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C52A0);
		  /* 820C52A0h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820C52A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820C52A0h case    0:*/		return 0x820C52A4;
		  /* 820C52A4h */ case    1:  		/* bc 12, CR6_EQ, 108 */
		/* 820C52A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C5310;  }
		/* 820C52A4h case    1:*/		return 0x820C52A8;
		  /* 820C52A8h */ case    2:  		/* lhz R11, <#[R31 + 10]> */
		/* 820C52A8h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000A) );
		/* 820C52A8h case    2:*/		return 0x820C52AC;
		  /* 820C52ACh */ case    3:  		/* li R28, 0 */
		/* 820C52ACh case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820C52ACh case    3:*/		return 0x820C52B0;
		  /* 820C52B0h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 820C52B0h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C52B0h case    4:*/		return 0x820C52B4;
		  /* 820C52B4h */ case    5:  		/* bc 12, CR0_EQ, 80 */
		/* 820C52B4h case    5:*/		if ( regs.CR[0].eq ) { return 0x820C5304;  }
		/* 820C52B4h case    5:*/		return 0x820C52B8;
		  /* 820C52B8h */ case    6:  		/* li R29, 0 */
		/* 820C52B8h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C52B8h case    6:*/		return 0x820C52BC;
		  /* 820C52BCh */ case    7:  		/* lwz R11, <#[R24 + 56]> */
		/* 820C52BCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 820C52BCh case    7:*/		return 0x820C52C0;
		  /* 820C52C0h */ case    8:  		/* mr R7, R22 */
		/* 820C52C0h case    8:*/		regs.R7 = regs.R22;
		/* 820C52C0h case    8:*/		return 0x820C52C4;
		  /* 820C52C4h */ case    9:  		/* mr R5, R25 */
		/* 820C52C4h case    9:*/		regs.R5 = regs.R25;
		/* 820C52C4h case    9:*/		return 0x820C52C8;
		  /* 820C52C8h */ case   10:  		/* mr R4, R23 */
		/* 820C52C8h case   10:*/		regs.R4 = regs.R23;
		/* 820C52C8h case   10:*/		return 0x820C52CC;
		  /* 820C52CCh */ case   11:  		/* lwzx R30, <#[R29 + R11]> */
		/* 820C52CCh case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820C52CCh case   11:*/		return 0x820C52D0;
		  /* 820C52D0h */ case   12:  		/* mr R3, R30 */
		/* 820C52D0h case   12:*/		regs.R3 = regs.R30;
		/* 820C52D0h case   12:*/		return 0x820C52D4;
		  /* 820C52D4h */ case   13:  		/* lwz R6, <#[R30 + 48]> */
		/* 820C52D4h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000030) );
		/* 820C52D4h case   13:*/		return 0x820C52D8;
		  /* 820C52D8h */ case   14:  		/* bl -176 */
		/* 820C52D8h case   14:*/		regs.LR = 0x820C52DC; return 0x820C5228;
		/* 820C52D8h case   14:*/		return 0x820C52DC;
		  /* 820C52DCh */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 820C52DCh case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C52DCh case   15:*/		return 0x820C52E0;
		  /* 820C52E0h */ case   16:  		/* bc 12, CR0_LT, 740 */
		/* 820C52E0h case   16:*/		if ( regs.CR[0].lt ) { return 0x820C55C4;  }
		/* 820C52E0h case   16:*/		return 0x820C52E4;
		  /* 820C52E4h */ case   17:  		/* lwz R11, <#[R30 + 48]> */
		/* 820C52E4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 820C52E4h case   17:*/		return 0x820C52E8;
		  /* 820C52E8h */ case   18:  		/* addi R28, R28, 1 */
		/* 820C52E8h case   18:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820C52E8h case   18:*/		return 0x820C52EC;
		  /* 820C52ECh */ case   19:  		/* lhz R10, <#[R31 + 10]> */
		/* 820C52ECh case   19:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000A) );
		/* 820C52ECh case   19:*/		return 0x820C52F0;
		  /* 820C52F0h */ case   20:  		/* addi R29, R29, 4 */
		/* 820C52F0h case   20:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820C52F0h case   20:*/		return 0x820C52F4;
		  /* 820C52F4h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C52F4h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C52F4h case   21:*/		return 0x820C52F8;
	}
	return 0x820C52F8;
} // Block from 820C52A0h-820C52F8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C52F8h
// Function '?Set@?$SetShaderConstant@$0A@$00$01@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C52F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C52F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C52F8);
		  /* 820C52F8h */ case    0:  		/* cmplw CR6, R28, R10 */
		/* 820C52F8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 820C52F8h case    0:*/		return 0x820C52FC;
		  /* 820C52FCh */ case    1:  		/* add R25, R11, R25 */
		/* 820C52FCh case    1:*/		cpu::op::add<0>(regs,&regs.R25,regs.R11,regs.R25);
		/* 820C52FCh case    1:*/		return 0x820C5300;
		  /* 820C5300h */ case    2:  		/* bc 12, CR6_LT, -68 */
		/* 820C5300h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C52BC;  }
		/* 820C5300h case    2:*/		return 0x820C5304;
	}
	return 0x820C5304;
} // Block from 820C52F8h-820C5304h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5304);
		  /* 820C5304h */ case    0:  		/* addi R26, R26, 1 */
		/* 820C5304h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820C5304h case    0:*/		return 0x820C5308;
		  /* 820C5308h */ case    1:  		/* cmplw CR6, R26, R27 */
		/* 820C5308h case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R27);
		/* 820C5308h case    1:*/		return 0x820C530C;
		  /* 820C530Ch */ case    2:  		/* bc 12, CR6_LT, -100 */
		/* 820C530Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x820C52A8;  }
		/* 820C530Ch case    2:*/		return 0x820C5310;
	}
	return 0x820C5310;
} // Block from 820C5304h-820C5310h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5310);
		  /* 820C5310h */ case    0:  		/* li R3, 0 */
		/* 820C5310h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C5310h case    0:*/		return 0x820C5314;
		  /* 820C5314h */ case    1:  		/* b 688 */
		/* 820C5314h case    1:*/		return 0x820C55C4;
		/* 820C5314h case    1:*/		return 0x820C5318;
	}
	return 0x820C5318;
} // Block from 820C5310h-820C5318h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5318);
		  /* 820C5318h */ case    0:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C5318h case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5318h case    0:*/		return 0x820C531C;
		  /* 820C531Ch */ case    1:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C531Ch case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C531Ch case    1:*/		return 0x820C5320;
	}
	return 0x820C5320;
} // Block from 820C5318h-820C5320h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5320h
// Function '?Set@?$SetShaderConstant@$0A@$00$02@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5320);
		  /* 820C5320h */ case    0:  		/* lhz R9, <#[R31 + 8]> */
		/* 820C5320h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820C5320h case    0:*/		return 0x820C5324;
		  /* 820C5324h */ case    1:  		/* mullw R7, R10, R8 */
		/* 820C5324h case    1:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R8);
		/* 820C5324h case    1:*/		return 0x820C5328;
		  /* 820C5328h */ case    2:  		/* divwu R3, R11, R7 */
		/* 820C5328h case    2:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R11,regs.R7);
		/* 820C5328h case    2:*/		return 0x820C532C;
		  /* 820C532Ch */ case    3:  		/* twi 6, R7, 0 */
		/* 820C532Ch case    3:*/		cpu::op::tw<6>(regs, 0x820C532C, regs.R7, 0x00000000);
		/* 820C532Ch case    3:*/		return 0x820C5330;
		  /* 820C5330h */ case    4:  		/* cmplw CR6, R3, R9 */
		/* 820C5330h case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 820C5330h case    4:*/		return 0x820C5334;
		  /* 820C5334h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 820C5334h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820C533C;  }
		/* 820C5334h case    5:*/		return 0x820C5338;
		  /* 820C5338h */ case    6:  		/* mr R3, R9 */
		/* 820C5338h case    6:*/		regs.R3 = regs.R9;
		/* 820C5338h case    6:*/		return 0x820C533C;
	}
	return 0x820C533C;
} // Block from 820C5320h-820C533Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C533Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C533C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C533C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C533C);
		  /* 820C533Ch */ case    0:  		/* li R4, 0 */
		/* 820C533Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C533Ch case    0:*/		return 0x820C5340;
		  /* 820C5340h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C5340h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C5340h case    1:*/		return 0x820C5344;
		  /* 820C5344h */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 820C5344h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C53B0;  }
		/* 820C5344h case    2:*/		return 0x820C5348;
		  /* 820C5348h */ case    3:  		/* addi R7, R6, -4 */
		/* 820C5348h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820C5348h case    3:*/		return 0x820C534C;
		  /* 820C534Ch */ case    4:  		/* li R9, 0 */
		/* 820C534Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C534Ch case    4:*/		return 0x820C5350;
		  /* 820C5350h */ case    5:  		/* cmplwi CR6, R8, 0 */
		/* 820C5350h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C5350h case    5:*/		return 0x820C5354;
		  /* 820C5354h */ case    6:  		/* bc 12, CR6_EQ, 80 */
		/* 820C5354h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C53A4;  }
		/* 820C5354h case    6:*/		return 0x820C5358;
		  /* 820C5358h */ case    7:  		/* li R11, 0 */
		/* 820C5358h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C5358h case    7:*/		return 0x820C535C;
		  /* 820C535Ch */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 820C535Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C535Ch case    8:*/		return 0x820C5360;
		  /* 820C5360h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 820C5360h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C5394;  }
		/* 820C5360h case    9:*/		return 0x820C5364;
		  /* 820C5364h */ case   10:  		/* mullw R10, R10, R4 */
		/* 820C5364h case   10:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 820C5364h case   10:*/		return 0x820C5368;
		  /* 820C5368h */ case   11:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C5368h case   11:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5368h case   11:*/		return 0x820C536C;
		  /* 820C536Ch */ case   12:  		/* add R10, R10, R11 */
		/* 820C536Ch case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C536Ch case   12:*/		return 0x820C5370;
	}
	return 0x820C5370;
} // Block from 820C533Ch-820C5370h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C5370h
// Function '?Set@?$SetShaderConstant@$0A@$01$00@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5370);
		  /* 820C5370h */ case    0:  		/* addi R11, R11, 1 */
		/* 820C5370h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C5370h case    0:*/		return 0x820C5374;
		  /* 820C5374h */ case    1:  		/* mullw R10, R10, R8 */
		/* 820C5374h case    1:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820C5374h case    1:*/		return 0x820C5378;
		  /* 820C5378h */ case    2:  		/* add R10, R10, R9 */
		/* 820C5378h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820C5378h case    2:*/		return 0x820C537C;
		  /* 820C537Ch */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C537Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C537Ch case    3:*/		return 0x820C5380;
		  /* 820C5380h */ case    4:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C5380h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C5380h case    4:*/		return 0x820C5384;
		  /* 820C5384h */ case    5:  		/* stwu R10, <#[R7 + 4]> */
		/* 820C5384h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820C5384h case    5:*/		return 0x820C5388;
		  /* 820C5388h */ case    6:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C5388h case    6:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5388h case    6:*/		return 0x820C538C;
		  /* 820C538Ch */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820C538Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C538Ch case    7:*/		return 0x820C5390;
		  /* 820C5390h */ case    8:  		/* bc 12, CR6_LT, -44 */
		/* 820C5390h case    8:*/		if ( regs.CR[6].lt ) { return 0x820C5364;  }
		/* 820C5390h case    8:*/		return 0x820C5394;
	}
	return 0x820C5394;
} // Block from 820C5370h-820C5394h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C5394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5394);
		  /* 820C5394h */ case    0:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C5394h case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5394h case    0:*/		return 0x820C5398;
		  /* 820C5398h */ case    1:  		/* addi R9, R9, 1 */
		/* 820C5398h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C5398h case    1:*/		return 0x820C539C;
		  /* 820C539Ch */ case    2:  		/* cmplw CR6, R9, R8 */
		/* 820C539Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820C539Ch case    2:*/		return 0x820C53A0;
		  /* 820C53A0h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 820C53A0h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C5358;  }
		/* 820C53A0h case    3:*/		return 0x820C53A4;
	}
	return 0x820C53A4;
} // Block from 820C5394h-820C53A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C53A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C53A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C53A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C53A4);
		  /* 820C53A4h */ case    0:  		/* addi R4, R4, 1 */
		/* 820C53A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820C53A4h case    0:*/		return 0x820C53A8;
		  /* 820C53A8h */ case    1:  		/* cmplw CR6, R4, R3 */
		/* 820C53A8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 820C53A8h case    1:*/		return 0x820C53AC;
		  /* 820C53ACh */ case    2:  		/* bc 12, CR6_LT, -96 */
		/* 820C53ACh case    2:*/		if ( regs.CR[6].lt ) { return 0x820C534C;  }
		/* 820C53ACh case    2:*/		return 0x820C53B0;
	}
	return 0x820C53B0;
} // Block from 820C53A4h-820C53B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C53B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C53B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C53B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C53B0);
		  /* 820C53B0h */ case    0:  		/* mr R25, R6 */
		/* 820C53B0h case    0:*/		regs.R25 = regs.R6;
		/* 820C53B0h case    0:*/		return 0x820C53B4;
		  /* 820C53B4h */ case    1:  		/* b 64 */
		/* 820C53B4h case    1:*/		return 0x820C53F4;
		/* 820C53B4h case    1:*/		return 0x820C53B8;
	}
	return 0x820C53B8;
} // Block from 820C53B0h-820C53B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C53B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C53B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C53B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C53B8);
		  /* 820C53B8h */ case    0:  		/* lhz R9, <#[R31 + 6]> */
		/* 820C53B8h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000006) );
		/* 820C53B8h case    0:*/		return 0x820C53BC;
		  /* 820C53BCh */ case    1:  		/* lhz R8, <#[R31 + 4]> */
		/* 820C53BCh case    1:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 820C53BCh case    1:*/		return 0x820C53C0;
		  /* 820C53C0h */ case    2:  		/* mullw R9, R9, R8 */
		/* 820C53C0h case    2:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820C53C0h case    2:*/		return 0x820C53C4;
		  /* 820C53C4h */ case    3:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C53C4h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C53C4h case    3:*/		return 0x820C53C8;
		  /* 820C53C8h */ case    4:  		/* divwu R3, R11, R9 */
		/* 820C53C8h case    4:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R11,regs.R9);
		/* 820C53C8h case    4:*/		return 0x820C53CC;
		  /* 820C53CCh */ case    5:  		/* twi 6, R9, 0 */
		/* 820C53CCh case    5:*/		cpu::op::tw<6>(regs, 0x820C53CC, regs.R9, 0x00000000);
		/* 820C53CCh case    5:*/		return 0x820C53D0;
		  /* 820C53D0h */ case    6:  		/* cmplw CR6, R3, R10 */
		/* 820C53D0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C53D0h case    6:*/		return 0x820C53D4;
		  /* 820C53D4h */ case    7:  		/* b 24 */
		/* 820C53D4h case    7:*/		return 0x820C53EC;
		/* 820C53D4h case    7:*/		return 0x820C53D8;
	}
	return 0x820C53D8;
} // Block from 820C53B8h-820C53D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C53D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C53D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C53D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C53D8);
		  /* 820C53D8h */ case    0:  		/* lhz R9, <#[R31 + 6]> */
		/* 820C53D8h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000006) );
		/* 820C53D8h case    0:*/		return 0x820C53DC;
		  /* 820C53DCh */ case    1:  		/* b -24 */
		/* 820C53DCh case    1:*/		return 0x820C53C4;
		/* 820C53DCh case    1:*/		return 0x820C53E0;
	}
	return 0x820C53E0;
} // Block from 820C53D8h-820C53E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C53E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C53E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C53E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C53E0);
		  /* 820C53E0h */ case    0:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C53E0h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C53E0h case    0:*/		return 0x820C53E4;
		  /* 820C53E4h */ case    1:  		/* mr R3, R11 */
		/* 820C53E4h case    1:*/		regs.R3 = regs.R11;
		/* 820C53E4h case    1:*/		return 0x820C53E8;
		  /* 820C53E8h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C53E8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C53E8h case    2:*/		return 0x820C53EC;
	}
	return 0x820C53EC;
} // Block from 820C53E0h-820C53ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C53ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C53EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C53EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C53EC);
		  /* 820C53ECh */ case    0:  		/* bc 4, CR6_GT, 8 */
		/* 820C53ECh case    0:*/		if ( !regs.CR[6].gt ) { return 0x820C53F4;  }
		/* 820C53ECh case    0:*/		return 0x820C53F0;
		  /* 820C53F0h */ case    1:  		/* mr R3, R10 */
		/* 820C53F0h case    1:*/		regs.R3 = regs.R10;
		/* 820C53F0h case    1:*/		return 0x820C53F4;
	}
	return 0x820C53F4;
} // Block from 820C53ECh-820C53F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C53F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C53F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C53F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C53F4);
		  /* 820C53F4h */ case    0:  		/* lhz R10, <#[R31 + 2]> */
		/* 820C53F4h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000002) );
		/* 820C53F4h case    0:*/		return 0x820C53F8;
		  /* 820C53F8h */ case    1:  		/* cmplwi CR6, R10, 1 */
		/* 820C53F8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C53F8h case    1:*/		return 0x820C53FC;
		  /* 820C53FCh */ case    2:  		/* bc 12, CR6_EQ, 152 */
		/* 820C53FCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5494;  }
		/* 820C53FCh case    2:*/		return 0x820C5400;
	}
	return 0x820C5400;
} // Block from 820C53F4h-820C5400h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5400h
// Function '?Set@?$SetShaderConstant@$0A@$01$01@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5400);
		  /* 820C5400h */ case    0:  		/* lwz R11, <#[R24 + 52]> */
		/* 820C5400h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000034) );
		/* 820C5400h case    0:*/		return 0x820C5404;
		  /* 820C5404h */ case    1:  		/* cmplwi CR6, R10, 2 */
		/* 820C5404h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820C5404h case    1:*/		return 0x820C5408;
		  /* 820C5408h */ case    2:  		/* mullw R11, R11, R3 */
		/* 820C5408h case    2:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820C5408h case    2:*/		return 0x820C540C;
		  /* 820C540Ch */ case    3:  		/* bc 12, CR6_EQ, 88 */
		/* 820C540Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820C5464;  }
		/* 820C540Ch case    3:*/		return 0x820C5410;
		  /* 820C5410h */ case    4:  		/* cmplwi CR6, R10, 3 */
		/* 820C5410h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C5410h case    4:*/		return 0x820C5414;
		  /* 820C5414h */ case    5:  		/* bc 4, CR6_EQ, 124 */
		/* 820C5414h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C5490;  }
		/* 820C5414h case    5:*/		return 0x820C5418;
		  /* 820C5418h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820C5418h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C5418h case    6:*/		return 0x820C541C;
		  /* 820C541Ch */ case    7:  		/* bc 12, CR6_EQ, 116 */
		/* 820C541Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820C5490;  }
		/* 820C541Ch case    7:*/		return 0x820C5420;
		  /* 820C5420h */ case    8:  		/* lis R9, -32256 */
		/* 820C5420h case    8:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 820C5420h case    8:*/		return 0x820C5424;
		  /* 820C5424h */ case    9:  		/* mtspr CTR, R11 */
		/* 820C5424h case    9:*/		regs.CTR = regs.R11;
		/* 820C5424h case    9:*/		return 0x820C5428;
		  /* 820C5428h */ case   10:  		/* lis R8, -32256 */
		/* 820C5428h case   10:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 820C5428h case   10:*/		return 0x820C542C;
		  /* 820C542Ch */ case   11:  		/* mr R10, R6 */
		/* 820C542Ch case   11:*/		regs.R10 = regs.R6;
		/* 820C542Ch case   11:*/		return 0x820C5430;
		  /* 820C5430h */ case   12:  		/* subf R11, R6, R25 */
		/* 820C5430h case   12:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R25);
		/* 820C5430h case   12:*/		return 0x820C5434;
		  /* 820C5434h */ case   13:  		/* lfs FR12, <#[R9 + 1816]> */
		/* 820C5434h case   13:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R9 + 0x00000718) );
		/* 820C5434h case   13:*/		return 0x820C5438;
		  /* 820C5438h */ case   14:  		/* lfs FR13, <#[R8 + 1792]> */
		/* 820C5438h case   14:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R8 + 0x00000700) );
		/* 820C5438h case   14:*/		return 0x820C543C;
		  /* 820C543Ch */ case   15:  		/* lwzx R9, <#[R11 + R10]> */
		/* 820C543Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C543Ch case   15:*/		return 0x820C5440;
		  /* 820C5440h */ case   16:  		/* cmpwi CR6, R9, 0 */
		/* 820C5440h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820C5440h case   16:*/		return 0x820C5444;
		  /* 820C5444h */ case   17:  		/* bc 12, CR6_EQ, 12 */
		/* 820C5444h case   17:*/		if ( regs.CR[6].eq ) { return 0x820C5450;  }
		/* 820C5444h case   17:*/		return 0x820C5448;
		  /* 820C5448h */ case   18:  		/* fmr FR0, FR13 */
		/* 820C5448h case   18:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR13);
		/* 820C5448h case   18:*/		return 0x820C544C;
		  /* 820C544Ch */ case   19:  		/* b 8 */
		/* 820C544Ch case   19:*/		return 0x820C5454;
		/* 820C544Ch case   19:*/		return 0x820C5450;
	}
	return 0x820C5450;
} // Block from 820C5400h-820C5450h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C5450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5450);
		  /* 820C5450h */ case    0:  		/* fmr FR0, FR12 */
		/* 820C5450h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR12);
		/* 820C5450h case    0:*/		return 0x820C5454;
	}
	return 0x820C5454;
} // Block from 820C5450h-820C5454h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C5454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5454);
		  /* 820C5454h */ case    0:  		/* stfs FR0, <#[R10]> */
		/* 820C5454h case    0:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C5454h case    0:*/		return 0x820C5458;
		  /* 820C5458h */ case    1:  		/* addi R10, R10, 4 */
		/* 820C5458h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C5458h case    1:*/		return 0x820C545C;
		  /* 820C545Ch */ case    2:  		/* bc 16, CR0_LT, -32 */
		/* 820C545Ch case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C543C;  }
		/* 820C545Ch case    2:*/		return 0x820C5460;
		  /* 820C5460h */ case    3:  		/* b 48 */
		/* 820C5460h case    3:*/		return 0x820C5490;
		/* 820C5460h case    3:*/		return 0x820C5464;
	}
	return 0x820C5464;
} // Block from 820C5454h-820C5464h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5464);
		  /* 820C5464h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C5464h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C5464h case    0:*/		return 0x820C5468;
		  /* 820C5468h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820C5468h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C5490;  }
		/* 820C5468h case    1:*/		return 0x820C546C;
		  /* 820C546Ch */ case    2:  		/* mtspr CTR, R11 */
		/* 820C546Ch case    2:*/		regs.CTR = regs.R11;
		/* 820C546Ch case    2:*/		return 0x820C5470;
		  /* 820C5470h */ case    3:  		/* mr R10, R6 */
		/* 820C5470h case    3:*/		regs.R10 = regs.R6;
		/* 820C5470h case    3:*/		return 0x820C5474;
		  /* 820C5474h */ case    4:  		/* subf R11, R6, R25 */
		/* 820C5474h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R25);
		/* 820C5474h case    4:*/		return 0x820C5478;
		  /* 820C5478h */ case    5:  		/* lwzx R9, <#[R10 + R11]> */
		/* 820C5478h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820C5478h case    5:*/		return 0x820C547C;
		  /* 820C547Ch */ case    6:  		/* addic R8, R9, -1 */
		/* 820C547Ch case    6:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 820C547Ch case    6:*/		return 0x820C5480;
		  /* 820C5480h */ case    7:  		/* subfe R9, R8, R9 */
		/* 820C5480h case    7:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C5480h case    7:*/		return 0x820C5484;
		  /* 820C5484h */ case    8:  		/* stw R9, <#[R10]> */
		/* 820C5484h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820C5484h case    8:*/		return 0x820C5488;
	}
	return 0x820C5488;
} // Block from 820C5464h-820C5488h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C5488h
// Function '?Set@?$SetShaderConstant@$0A@$01$0A@@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5488);
		  /* 820C5488h */ case    0:  		/* addi R10, R10, 4 */
		/* 820C5488h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C5488h case    0:*/		return 0x820C548C;
		  /* 820C548Ch */ case    1:  		/* bc 16, CR0_LT, -20 */
		/* 820C548Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C5478;  }
		/* 820C548Ch case    1:*/		return 0x820C5490;
	}
	return 0x820C5490;
} // Block from 820C5488h-820C5490h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5490);
		  /* 820C5490h */ case    0:  		/* mr R25, R6 */
		/* 820C5490h case    0:*/		regs.R25 = regs.R6;
		/* 820C5490h case    0:*/		return 0x820C5494;
	}
	return 0x820C5494;
} // Block from 820C5490h-820C5494h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C5494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5494);
		  /* 820C5494h */ case    0:  		/* lhz R9, <#[R24 + 8]> */
		/* 820C5494h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 820C5494h case    0:*/		return 0x820C5498;
		  /* 820C5498h */ case    1:  		/* cmplwi CR0, R9, 0 */
		/* 820C5498h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820C5498h case    1:*/		return 0x820C549C;
		  /* 820C549Ch */ case    2:  		/* bc 12, CR0_EQ, 216 */
		/* 820C549Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820C5574;  }
		/* 820C549Ch case    2:*/		return 0x820C54A0;
		  /* 820C54A0h */ case    3:  		/* lhz R11, <#[R31]> */
		/* 820C54A0h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C54A0h case    3:*/		return 0x820C54A4;
		  /* 820C54A4h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C54A4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C54A4h case    4:*/		return 0x820C54A8;
		  /* 820C54A8h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820C54A8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C54B8;  }
		/* 820C54A8h case    5:*/		return 0x820C54AC;
		  /* 820C54ACh */ case    6:  		/* lhz R11, <#[R31 + 6]> */
		/* 820C54ACh case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000006) );
		/* 820C54ACh case    6:*/		return 0x820C54B0;
		  /* 820C54B0h */ case    7:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C54B0h case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C54B0h case    7:*/		return 0x820C54B4;
		  /* 820C54B4h */ case    8:  		/* b 12 */
		/* 820C54B4h case    8:*/		return 0x820C54C0;
		/* 820C54B4h case    8:*/		return 0x820C54B8;
	}
	return 0x820C54B8;
} // Block from 820C5494h-820C54B8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C54B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C54B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C54B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C54B8);
		  /* 820C54B8h */ case    0:  		/* lhz R11, <#[R31 + 4]> */
		/* 820C54B8h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820C54B8h case    0:*/		return 0x820C54BC;
		  /* 820C54BCh */ case    1:  		/* lhz R10, <#[R31 + 6]> */
		/* 820C54BCh case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000006) );
		/* 820C54BCh case    1:*/		return 0x820C54C0;
	}
	return 0x820C54C0;
} // Block from 820C54B8h-820C54C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C54C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C54C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C54C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C54C0);
		  /* 820C54C0h */ case    0:  		/* rlwinm. R8, R11, 0, 30, 31 */
		/* 820C54C0h case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R8,regs.R11);
		/* 820C54C0h case    0:*/		return 0x820C54C4;
		  /* 820C54C4h */ case    1:  		/* bc 12, CR0_EQ, 176 */
		/* 820C54C4h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C5574;  }
		/* 820C54C4h case    1:*/		return 0x820C54C8;
		  /* 820C54C8h */ case    2:  		/* cmplwi CR6, R9, 1 */
		/* 820C54C8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820C54C8h case    2:*/		return 0x820C54CC;
		  /* 820C54CCh */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820C54CCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C54DC;  }
		/* 820C54CCh case    3:*/		return 0x820C54D0;
		  /* 820C54D0h */ case    4:  		/* lis R9, -32255 */
		/* 820C54D0h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C54D0h case    4:*/		return 0x820C54D4;
		  /* 820C54D4h */ case    5:  		/* addi R4, R9, 10344 */
		/* 820C54D4h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2868);
		/* 820C54D4h case    5:*/		return 0x820C54D8;
	}
	return 0x820C54D8;
} // Block from 820C54C0h-820C54D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C54D8h
// Function '?Set@?$SetShaderConstant@$00$0A@$00@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C54D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C54D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C54D8);
		  /* 820C54D8h */ case    0:  		/* b 12 */
		/* 820C54D8h case    0:*/		return 0x820C54E4;
		/* 820C54D8h case    0:*/		return 0x820C54DC;
	}
	return 0x820C54DC;
} // Block from 820C54D8h-820C54DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C54DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C54DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C54DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C54DC);
		  /* 820C54DCh */ case    0:  		/* lis R9, -32255 */
		/* 820C54DCh case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C54DCh case    0:*/		return 0x820C54E0;
		  /* 820C54E0h */ case    1:  		/* addi R4, R9, 10360 */
		/* 820C54E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2878);
		/* 820C54E0h case    1:*/		return 0x820C54E4;
	}
	return 0x820C54E4;
} // Block from 820C54DCh-820C54E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C54E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C54E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C54E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C54E4);
		  /* 820C54E4h */ case    0:  		/* addi R9, R11, 3 */
		/* 820C54E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 820C54E4h case    0:*/		return 0x820C54E8;
		  /* 820C54E8h */ case    1:  		/* mullw. R8, R10, R3 */
		/* 820C54E8h case    1:*/		cpu::op::mullw<1>(regs,&regs.R8,regs.R10,regs.R3);
		/* 820C54E8h case    1:*/		return 0x820C54EC;
		  /* 820C54ECh */ case    2:  		/* rlwinm R7, R9, 0, 0, 29 */
		/* 820C54ECh case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R7,regs.R9);
		/* 820C54ECh case    2:*/		return 0x820C54F0;
		  /* 820C54F0h */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 820C54F0h case    3:*/		if ( regs.CR[0].eq ) { return 0x820C5570;  }
		/* 820C54F0h case    3:*/		return 0x820C54F4;
		  /* 820C54F4h */ case    4:  		/* mullw R9, R8, R7 */
		/* 820C54F4h case    4:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R7);
		/* 820C54F4h case    4:*/		return 0x820C54F8;
		  /* 820C54F8h */ case    5:  		/* mullw R5, R8, R11 */
		/* 820C54F8h case    5:*/		cpu::op::mullw<0>(regs,&regs.R5,regs.R8,regs.R11);
		/* 820C54F8h case    5:*/		return 0x820C54FC;
		  /* 820C54FCh */ case    6:  		/* addi R8, R8, -1 */
		/* 820C54FCh case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820C54FCh case    6:*/		return 0x820C5500;
	}
	return 0x820C5500;
} // Block from 820C54E4h-820C5500h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C5500h
// Function '?Set@?$SetShaderConstant@$00$0A@$01@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5500);
		  /* 820C5500h */ case    0:  		/* subf R5, R11, R5 */
		/* 820C5500h case    0:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 820C5500h case    0:*/		return 0x820C5504;
		  /* 820C5504h */ case    1:  		/* subf R9, R7, R9 */
		/* 820C5504h case    1:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820C5504h case    1:*/		return 0x820C5508;
		  /* 820C5508h */ case    2:  		/* mr R10, R7 */
		/* 820C5508h case    2:*/		regs.R10 = regs.R7;
		/* 820C5508h case    2:*/		return 0x820C550C;
		  /* 820C550Ch */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820C550Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C550Ch case    3:*/		return 0x820C5510;
		  /* 820C5510h */ case    4:  		/* bc 4, CR6_GT, 40 */
		/* 820C5510h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820C5538;  }
		/* 820C5510h case    4:*/		return 0x820C5514;
		  /* 820C5514h */ case    5:  		/* subf R31, R11, R7 */
		/* 820C5514h case    5:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R7);
		/* 820C5514h case    5:*/		return 0x820C5518;
		  /* 820C5518h */ case    6:  		/* mtspr CTR, R31 */
		/* 820C5518h case    6:*/		regs.CTR = regs.R31;
		/* 820C5518h case    6:*/		return 0x820C551C;
		  /* 820C551Ch */ case    7:  		/* addi R10, R10, -1 */
		/* 820C551Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C551Ch case    7:*/		return 0x820C5520;
		  /* 820C5520h */ case    8:  		/* rlwinm R31, R10, 2, 28, 29 */
		/* 820C5520h case    8:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R31,regs.R10);
		/* 820C5520h case    8:*/		return 0x820C5524;
		  /* 820C5524h */ case    9:  		/* add R30, R9, R10 */
		/* 820C5524h case    9:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R10);
		/* 820C5524h case    9:*/		return 0x820C5528;
		  /* 820C5528h */ case   10:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C5528h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C5528h case   10:*/		return 0x820C552C;
		  /* 820C552Ch */ case   11:  		/* lwzx R31, <#[R31 + R4]> */
		/* 820C552Ch case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R4 + 0x00000000) );
		/* 820C552Ch case   11:*/		return 0x820C5530;
		  /* 820C5530h */ case   12:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C5530h case   12:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C5530h case   12:*/		return 0x820C5534;
		  /* 820C5534h */ case   13:  		/* bc 16, CR0_LT, -24 */
		/* 820C5534h case   13:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C551C;  }
		/* 820C5534h case   13:*/		return 0x820C5538;
	}
	return 0x820C5538;
} // Block from 820C5500h-820C5538h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C5538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5538);
		  /* 820C5538h */ case    0:  		/* mr R10, R11 */
		/* 820C5538h case    0:*/		regs.R10 = regs.R11;
		/* 820C5538h case    0:*/		return 0x820C553C;
		  /* 820C553Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C553Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C553Ch case    1:*/		return 0x820C5540;
		  /* 820C5540h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820C5540h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5568;  }
		/* 820C5540h case    2:*/		return 0x820C5544;
		  /* 820C5544h */ case    3:  		/* mtspr CTR, R11 */
		/* 820C5544h case    3:*/		regs.CTR = regs.R11;
		/* 820C5544h case    3:*/		return 0x820C5548;
		  /* 820C5548h */ case    4:  		/* addi R10, R10, -1 */
		/* 820C5548h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C5548h case    4:*/		return 0x820C554C;
		  /* 820C554Ch */ case    5:  		/* add R31, R5, R10 */
		/* 820C554Ch case    5:*/		cpu::op::add<0>(regs,&regs.R31,regs.R5,regs.R10);
		/* 820C554Ch case    5:*/		return 0x820C5550;
		  /* 820C5550h */ case    6:  		/* add R30, R9, R10 */
		/* 820C5550h case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R10);
		/* 820C5550h case    6:*/		return 0x820C5554;
		  /* 820C5554h */ case    7:  		/* rlwinm R31, R31, 2, 0, 29 */
		/* 820C5554h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R31);
		/* 820C5554h case    7:*/		return 0x820C5558;
	}
	return 0x820C5558;
} // Block from 820C5538h-820C5558h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C5558h
// Function '?Set@?$SetShaderConstant@$00$0A@$02@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5558);
		  /* 820C5558h */ case    0:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C5558h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C5558h case    0:*/		return 0x820C555C;
		  /* 820C555Ch */ case    1:  		/* lwzx R31, <#[R31 + R25]> */
		/* 820C555Ch case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R25 + 0x00000000) );
		/* 820C555Ch case    1:*/		return 0x820C5560;
		  /* 820C5560h */ case    2:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C5560h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C5560h case    2:*/		return 0x820C5564;
		  /* 820C5564h */ case    3:  		/* bc 16, CR0_LT, -28 */
		/* 820C5564h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C5548;  }
		/* 820C5564h case    3:*/		return 0x820C5568;
	}
	return 0x820C5568;
} // Block from 820C5558h-820C5568h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5568);
		  /* 820C5568h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820C5568h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C5568h case    0:*/		return 0x820C556C;
		  /* 820C556Ch */ case    1:  		/* bc 4, CR6_EQ, -112 */
		/* 820C556Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C54FC;  }
		/* 820C556Ch case    1:*/		return 0x820C5570;
	}
	return 0x820C5570;
} // Block from 820C5568h-820C5570h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5570);
		  /* 820C5570h */ case    0:  		/* mr R25, R6 */
		/* 820C5570h case    0:*/		regs.R25 = regs.R6;
		/* 820C5570h case    0:*/		return 0x820C5574;
	}
	return 0x820C5574;
} // Block from 820C5570h-820C5574h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C5574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5574);
		  /* 820C5574h */ case    0:  		/* lwz R10, <#[R24 + 44]> */
		/* 820C5574h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000002C) );
		/* 820C5574h case    0:*/		return 0x820C5578;
		  /* 820C5578h */ case    1:  		/* lhz R11, <#[R24 + 12]> */
		/* 820C5578h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820C5578h case    1:*/		return 0x820C557C;
		  /* 820C557Ch */ case    2:  		/* mullw R7, R10, R3 */
		/* 820C557Ch case    2:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R3);
		/* 820C557Ch case    2:*/		return 0x820C5580;
		  /* 820C5580h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820C5580h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C5580h case    3:*/		return 0x820C5584;
		  /* 820C5584h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 820C5584h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820C558C;  }
		/* 820C5584h case    4:*/		return 0x820C5588;
		  /* 820C5588h */ case    5:  		/* mr R7, R11 */
		/* 820C5588h case    5:*/		regs.R7 = regs.R11;
		/* 820C5588h case    5:*/		return 0x820C558C;
	}
	return 0x820C558C;
} // Block from 820C5574h-820C558Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C558Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C558C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C558C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C558C);
		  /* 820C558Ch */ case    0:  		/* lwz R10, <#[R24 + 28]> */
		/* 820C558Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 820C558Ch case    0:*/		return 0x820C5590;
		  /* 820C5590h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C5590h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C5590h case    1:*/		return 0x820C5594;
		  /* 820C5594h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C5594h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C55A4;  }
		/* 820C5594h case    2:*/		return 0x820C5598;
		  /* 820C5598h */ case    3:  		/* lis R3, -32768 */
		/* 820C5598h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C5598h case    3:*/		return 0x820C559C;
		  /* 820C559Ch */ case    4:  		/* ori R3, R3, 16389 */
		/* 820C559Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C559Ch case    4:*/		return 0x820C55A0;
		  /* 820C55A0h */ case    5:  		/* b 36 */
		/* 820C55A0h case    5:*/		return 0x820C55C4;
		/* 820C55A0h case    5:*/		return 0x820C55A4;
	}
	return 0x820C55A4;
} // Block from 820C558Ch-820C55A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C55A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C55A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C55A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C55A4);
		  /* 820C55A4h */ case    0:  		/* lhz R11, <#[R24 + 10]> */
		/* 820C55A4h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000A) );
		/* 820C55A4h case    0:*/		return 0x820C55A8;
		  /* 820C55A8h */ case    1:  		/* mr R5, R25 */
		/* 820C55A8h case    1:*/		regs.R5 = regs.R25;
		/* 820C55A8h case    1:*/		return 0x820C55AC;
		  /* 820C55ACh */ case    2:  		/* mr R3, R23 */
		/* 820C55ACh case    2:*/		regs.R3 = regs.R23;
		/* 820C55ACh case    2:*/		return 0x820C55B0;
		  /* 820C55B0h */ case    3:  		/* mtspr CTR, R10 */
		/* 820C55B0h case    3:*/		regs.CTR = regs.R10;
		/* 820C55B0h case    3:*/		return 0x820C55B4;
		  /* 820C55B4h */ case    4:  		/* add R4, R11, R22 */
		/* 820C55B4h case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R22);
		/* 820C55B4h case    4:*/		return 0x820C55B8;
		  /* 820C55B8h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820C55B8h case    5:*/		if ( 1 ) { regs.LR = 0x820C55BC; return (uint32)regs.CTR; }
		/* 820C55B8h case    5:*/		return 0x820C55BC;
		  /* 820C55BCh */ case    6:  		/* srawi R11, R3, 31 */
		/* 820C55BCh case    6:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820C55BCh case    6:*/		return 0x820C55C0;
	}
	return 0x820C55C0;
} // Block from 820C55A4h-820C55C0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C55C0h
// Function '?Set@?$SetShaderConstant@$00$00$00@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C55C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C55C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C55C0);
		  /* 820C55C0h */ case    0:  		/* and R3, R11, R3 */
		/* 820C55C0h case    0:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C55C0h case    0:*/		return 0x820C55C4;
	}
	return 0x820C55C4;
} // Block from 820C55C0h-820C55C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C55C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C55C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C55C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C55C4);
		  /* 820C55C4h */ case    0:  		/* addi R1, R1, 176 */
		/* 820C55C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820C55C4h case    0:*/		return 0x820C55C8;
		  /* 820C55C8h */ case    1:  		/* b -213816 */
		/* 820C55C8h case    1:*/		return 0x82091290;
		/* 820C55C8h case    1:*/		return 0x820C55CC;
		  /* 820C55CCh */ case    2:  		/* nop */
		/* 820C55CCh case    2:*/		cpu::op::nop();
		/* 820C55CCh case    2:*/		return 0x820C55D0;
	}
	return 0x820C55D0;
} // Block from 820C55C4h-820C55D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C55D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C55D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C55D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C55D0);
		  /* 820C55D0h */ case    0:  		/* mfspr R12, LR */
		/* 820C55D0h case    0:*/		regs.R12 = regs.LR;
		/* 820C55D0h case    0:*/		return 0x820C55D4;
		  /* 820C55D4h */ case    1:  		/* bl -213908 */
		/* 820C55D4h case    1:*/		regs.LR = 0x820C55D8; return 0x82091240;
		/* 820C55D4h case    1:*/		return 0x820C55D8;
		  /* 820C55D8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820C55D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820C55D8h case    2:*/		return 0x820C55DC;
		  /* 820C55DCh */ case    3:  		/* lwz R31, <#[R3 + 24]> */
		/* 820C55DCh case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000018) );
		/* 820C55DCh case    3:*/		return 0x820C55E0;
		  /* 820C55E0h */ case    4:  		/* mr R11, R6 */
		/* 820C55E0h case    4:*/		regs.R11 = regs.R6;
		/* 820C55E0h case    4:*/		return 0x820C55E4;
		  /* 820C55E4h */ case    5:  		/* lwz R6, <#[R3 + 32]> */
		/* 820C55E4h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000020) );
		/* 820C55E4h case    5:*/		return 0x820C55E8;
		  /* 820C55E8h */ case    6:  		/* mr R24, R3 */
		/* 820C55E8h case    6:*/		regs.R24 = regs.R3;
		/* 820C55E8h case    6:*/		return 0x820C55EC;
		  /* 820C55ECh */ case    7:  		/* mr R23, R4 */
		/* 820C55ECh case    7:*/		regs.R23 = regs.R4;
		/* 820C55ECh case    7:*/		return 0x820C55F0;
		  /* 820C55F0h */ case    8:  		/* mr R22, R7 */
		/* 820C55F0h case    8:*/		regs.R22 = regs.R7;
		/* 820C55F0h case    8:*/		return 0x820C55F4;
		  /* 820C55F4h */ case    9:  		/* mr R25, R5 */
		/* 820C55F4h case    9:*/		regs.R25 = regs.R5;
		/* 820C55F4h case    9:*/		return 0x820C55F8;
		  /* 820C55F8h */ case   10:  		/* lhz R10, <#[R31]> */
		/* 820C55F8h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820C55F8h case   10:*/		return 0x820C55FC;
		  /* 820C55FCh */ case   11:  		/* cmplwi CR6, R10, 1 */
		/* 820C55FCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C55FCh case   11:*/		return 0x820C5600;
		  /* 820C5600h */ case   12:  		/* bc 12, CR6_LT, 392 */
		/* 820C5600h case   12:*/		if ( regs.CR[6].lt ) { return 0x820C5788;  }
		/* 820C5600h case   12:*/		return 0x820C5604;
		  /* 820C5604h */ case   13:  		/* bc 12, CR6_EQ, 380 */
		/* 820C5604h case   13:*/		if ( regs.CR[6].eq ) { return 0x820C5780;  }
		/* 820C5604h case   13:*/		return 0x820C5608;
		  /* 820C5608h */ case   14:  		/* cmplwi CR6, R10, 3 */
		/* 820C5608h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C5608h case   14:*/		return 0x820C560C;
		  /* 820C560Ch */ case   15:  		/* bc 12, CR6_LT, 340 */
		/* 820C560Ch case   15:*/		if ( regs.CR[6].lt ) { return 0x820C5760;  }
		/* 820C560Ch case   15:*/		return 0x820C5610;
		  /* 820C5610h */ case   16:  		/* bc 12, CR6_EQ, 176 */
		/* 820C5610h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C56C0;  }
		/* 820C5610h case   16:*/		return 0x820C5614;
		  /* 820C5614h */ case   17:  		/* cmplwi CR6, R10, 5 */
		/* 820C5614h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000005);
		/* 820C5614h case   17:*/		return 0x820C5618;
	}
	return 0x820C5618;
} // Block from 820C55D0h-820C5618h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820C5618h
// Function '?Set@?$SetShaderConstant@$00$00$0A@@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5618);
		  /* 820C5618h */ case    0:  		/* bc 12, CR6_EQ, 16 */
		/* 820C5618h case    0:*/		if ( regs.CR[6].eq ) { return 0x820C5628;  }
		/* 820C5618h case    0:*/		return 0x820C561C;
		  /* 820C561Ch */ case    1:  		/* lis R3, -32768 */
		/* 820C561Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C561Ch case    1:*/		return 0x820C5620;
		  /* 820C5620h */ case    2:  		/* ori R3, R3, 16385 */
		/* 820C5620h case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 820C5620h case    2:*/		return 0x820C5624;
		  /* 820C5624h */ case    3:  		/* b 820 */
		/* 820C5624h case    3:*/		return 0x820C5958;
		/* 820C5624h case    3:*/		return 0x820C5628;
	}
	return 0x820C5628;
} // Block from 820C5618h-820C5628h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5628);
		  /* 820C5628h */ case    0:  		/* lwz R9, <#[R24 + 52]> */
		/* 820C5628h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000034) );
		/* 820C5628h case    0:*/		return 0x820C562C;
		  /* 820C562Ch */ case    1:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C562Ch case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C562Ch case    1:*/		return 0x820C5630;
		  /* 820C5630h */ case    2:  		/* divwu R27, R11, R9 */
		/* 820C5630h case    2:*/		cpu::op::divwu<0>(regs,&regs.R27,regs.R11,regs.R9);
		/* 820C5630h case    2:*/		return 0x820C5634;
		  /* 820C5634h */ case    3:  		/* twi 6, R9, 0 */
		/* 820C5634h case    3:*/		cpu::op::tw<6>(regs, 0x820C5634, regs.R9, 0x00000000);
		/* 820C5634h case    3:*/		return 0x820C5638;
		  /* 820C5638h */ case    4:  		/* cmplw CR6, R27, R10 */
		/* 820C5638h case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R10);
		/* 820C5638h case    4:*/		return 0x820C563C;
		  /* 820C563Ch */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 820C563Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x820C5644;  }
		/* 820C563Ch case    5:*/		return 0x820C5640;
	}
	return 0x820C5640;
} // Block from 820C5628h-820C5640h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C5640h
// Function '?Set@?$SetShaderConstant@$00$00$02@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5640);
		  /* 820C5640h */ case    0:  		/* mr R27, R10 */
		/* 820C5640h case    0:*/		regs.R27 = regs.R10;
		/* 820C5640h case    0:*/		return 0x820C5644;
	}
	return 0x820C5644;
} // Block from 820C5640h-820C5644h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C5644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5644);
		  /* 820C5644h */ case    0:  		/* li R26, 0 */
		/* 820C5644h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820C5644h case    0:*/		return 0x820C5648;
		  /* 820C5648h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 820C5648h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820C5648h case    1:*/		return 0x820C564C;
		  /* 820C564Ch */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 820C564Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C56B8;  }
		/* 820C564Ch case    2:*/		return 0x820C5650;
		  /* 820C5650h */ case    3:  		/* lhz R11, <#[R31 + 10]> */
		/* 820C5650h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000A) );
		/* 820C5650h case    3:*/		return 0x820C5654;
		  /* 820C5654h */ case    4:  		/* li R28, 0 */
		/* 820C5654h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820C5654h case    4:*/		return 0x820C5658;
		  /* 820C5658h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 820C5658h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C5658h case    5:*/		return 0x820C565C;
		  /* 820C565Ch */ case    6:  		/* bc 12, CR0_EQ, 80 */
		/* 820C565Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820C56AC;  }
		/* 820C565Ch case    6:*/		return 0x820C5660;
		  /* 820C5660h */ case    7:  		/* li R29, 0 */
		/* 820C5660h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C5660h case    7:*/		return 0x820C5664;
		  /* 820C5664h */ case    8:  		/* lwz R11, <#[R24 + 56]> */
		/* 820C5664h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 820C5664h case    8:*/		return 0x820C5668;
		  /* 820C5668h */ case    9:  		/* mr R7, R22 */
		/* 820C5668h case    9:*/		regs.R7 = regs.R22;
		/* 820C5668h case    9:*/		return 0x820C566C;
		  /* 820C566Ch */ case   10:  		/* mr R5, R25 */
		/* 820C566Ch case   10:*/		regs.R5 = regs.R25;
		/* 820C566Ch case   10:*/		return 0x820C5670;
		  /* 820C5670h */ case   11:  		/* mr R4, R23 */
		/* 820C5670h case   11:*/		regs.R4 = regs.R23;
		/* 820C5670h case   11:*/		return 0x820C5674;
		  /* 820C5674h */ case   12:  		/* lwzx R30, <#[R29 + R11]> */
		/* 820C5674h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820C5674h case   12:*/		return 0x820C5678;
		  /* 820C5678h */ case   13:  		/* mr R3, R30 */
		/* 820C5678h case   13:*/		regs.R3 = regs.R30;
		/* 820C5678h case   13:*/		return 0x820C567C;
		  /* 820C567Ch */ case   14:  		/* lwz R6, <#[R30 + 48]> */
		/* 820C567Ch case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000030) );
		/* 820C567Ch case   14:*/		return 0x820C5680;
		  /* 820C5680h */ case   15:  		/* bl -176 */
		/* 820C5680h case   15:*/		regs.LR = 0x820C5684; return 0x820C55D0;
		/* 820C5680h case   15:*/		return 0x820C5684;
		  /* 820C5684h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820C5684h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C5684h case   16:*/		return 0x820C5688;
		  /* 820C5688h */ case   17:  		/* bc 12, CR0_LT, 720 */
		/* 820C5688h case   17:*/		if ( regs.CR[0].lt ) { return 0x820C5958;  }
		/* 820C5688h case   17:*/		return 0x820C568C;
		  /* 820C568Ch */ case   18:  		/* lwz R11, <#[R30 + 48]> */
		/* 820C568Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 820C568Ch case   18:*/		return 0x820C5690;
	}
	return 0x820C5690;
} // Block from 820C5644h-820C5690h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820C5690h
// Function '?Set@?$SetShaderConstant@$00$01$00@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5690);
		  /* 820C5690h */ case    0:  		/* addi R28, R28, 1 */
		/* 820C5690h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820C5690h case    0:*/		return 0x820C5694;
		  /* 820C5694h */ case    1:  		/* lhz R10, <#[R31 + 10]> */
		/* 820C5694h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000A) );
		/* 820C5694h case    1:*/		return 0x820C5698;
		  /* 820C5698h */ case    2:  		/* addi R29, R29, 4 */
		/* 820C5698h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820C5698h case    2:*/		return 0x820C569C;
		  /* 820C569Ch */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C569Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C569Ch case    3:*/		return 0x820C56A0;
		  /* 820C56A0h */ case    4:  		/* cmplw CR6, R28, R10 */
		/* 820C56A0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 820C56A0h case    4:*/		return 0x820C56A4;
		  /* 820C56A4h */ case    5:  		/* add R25, R11, R25 */
		/* 820C56A4h case    5:*/		cpu::op::add<0>(regs,&regs.R25,regs.R11,regs.R25);
		/* 820C56A4h case    5:*/		return 0x820C56A8;
		  /* 820C56A8h */ case    6:  		/* bc 12, CR6_LT, -68 */
		/* 820C56A8h case    6:*/		if ( regs.CR[6].lt ) { return 0x820C5664;  }
		/* 820C56A8h case    6:*/		return 0x820C56AC;
	}
	return 0x820C56AC;
} // Block from 820C5690h-820C56ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C56ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C56AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C56AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C56AC);
		  /* 820C56ACh */ case    0:  		/* addi R26, R26, 1 */
		/* 820C56ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820C56ACh case    0:*/		return 0x820C56B0;
		  /* 820C56B0h */ case    1:  		/* cmplw CR6, R26, R27 */
		/* 820C56B0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R27);
		/* 820C56B0h case    1:*/		return 0x820C56B4;
		  /* 820C56B4h */ case    2:  		/* bc 12, CR6_LT, -100 */
		/* 820C56B4h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C5650;  }
		/* 820C56B4h case    2:*/		return 0x820C56B8;
	}
	return 0x820C56B8;
} // Block from 820C56ACh-820C56B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C56B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C56B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C56B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C56B8);
		  /* 820C56B8h */ case    0:  		/* li R3, 0 */
		/* 820C56B8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C56B8h case    0:*/		return 0x820C56BC;
		  /* 820C56BCh */ case    1:  		/* b 668 */
		/* 820C56BCh case    1:*/		return 0x820C5958;
		/* 820C56BCh case    1:*/		return 0x820C56C0;
	}
	return 0x820C56C0;
} // Block from 820C56B8h-820C56C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C56C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C56C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C56C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C56C0);
		  /* 820C56C0h */ case    0:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C56C0h case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C56C0h case    0:*/		return 0x820C56C4;
		  /* 820C56C4h */ case    1:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C56C4h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C56C4h case    1:*/		return 0x820C56C8;
		  /* 820C56C8h */ case    2:  		/* lhz R9, <#[R31 + 8]> */
		/* 820C56C8h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820C56C8h case    2:*/		return 0x820C56CC;
		  /* 820C56CCh */ case    3:  		/* mullw R7, R10, R8 */
		/* 820C56CCh case    3:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R8);
		/* 820C56CCh case    3:*/		return 0x820C56D0;
		  /* 820C56D0h */ case    4:  		/* divwu R3, R11, R7 */
		/* 820C56D0h case    4:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R11,regs.R7);
		/* 820C56D0h case    4:*/		return 0x820C56D4;
		  /* 820C56D4h */ case    5:  		/* twi 6, R7, 0 */
		/* 820C56D4h case    5:*/		cpu::op::tw<6>(regs, 0x820C56D4, regs.R7, 0x00000000);
		/* 820C56D4h case    5:*/		return 0x820C56D8;
		  /* 820C56D8h */ case    6:  		/* cmplw CR6, R3, R9 */
		/* 820C56D8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 820C56D8h case    6:*/		return 0x820C56DC;
		  /* 820C56DCh */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 820C56DCh case    7:*/		if ( !regs.CR[6].gt ) { return 0x820C56E4;  }
		/* 820C56DCh case    7:*/		return 0x820C56E0;
		  /* 820C56E0h */ case    8:  		/* mr R3, R9 */
		/* 820C56E0h case    8:*/		regs.R3 = regs.R9;
		/* 820C56E0h case    8:*/		return 0x820C56E4;
	}
	return 0x820C56E4;
} // Block from 820C56C0h-820C56E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C56E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C56E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C56E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C56E4);
		  /* 820C56E4h */ case    0:  		/* li R4, 0 */
		/* 820C56E4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C56E4h case    0:*/		return 0x820C56E8;
		  /* 820C56E8h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C56E8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C56E8h case    1:*/		return 0x820C56EC;
		  /* 820C56ECh */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 820C56ECh case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5758;  }
		/* 820C56ECh case    2:*/		return 0x820C56F0;
		  /* 820C56F0h */ case    3:  		/* addi R7, R6, -4 */
		/* 820C56F0h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820C56F0h case    3:*/		return 0x820C56F4;
		  /* 820C56F4h */ case    4:  		/* li R9, 0 */
		/* 820C56F4h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C56F4h case    4:*/		return 0x820C56F8;
		  /* 820C56F8h */ case    5:  		/* cmplwi CR6, R8, 0 */
		/* 820C56F8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C56F8h case    5:*/		return 0x820C56FC;
		  /* 820C56FCh */ case    6:  		/* bc 12, CR6_EQ, 80 */
		/* 820C56FCh case    6:*/		if ( regs.CR[6].eq ) { return 0x820C574C;  }
		/* 820C56FCh case    6:*/		return 0x820C5700;
		  /* 820C5700h */ case    7:  		/* li R11, 0 */
		/* 820C5700h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C5700h case    7:*/		return 0x820C5704;
		  /* 820C5704h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 820C5704h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C5704h case    8:*/		return 0x820C5708;
		  /* 820C5708h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 820C5708h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C573C;  }
		/* 820C5708h case    9:*/		return 0x820C570C;
		  /* 820C570Ch */ case   10:  		/* mullw R10, R10, R4 */
		/* 820C570Ch case   10:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 820C570Ch case   10:*/		return 0x820C5710;
		  /* 820C5710h */ case   11:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C5710h case   11:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5710h case   11:*/		return 0x820C5714;
		  /* 820C5714h */ case   12:  		/* add R10, R10, R11 */
		/* 820C5714h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C5714h case   12:*/		return 0x820C5718;
		  /* 820C5718h */ case   13:  		/* addi R11, R11, 1 */
		/* 820C5718h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C5718h case   13:*/		return 0x820C571C;
		  /* 820C571Ch */ case   14:  		/* mullw R10, R10, R8 */
		/* 820C571Ch case   14:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820C571Ch case   14:*/		return 0x820C5720;
	}
	return 0x820C5720;
} // Block from 820C56E4h-820C5720h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C5720h
// Function '?Set@?$SetShaderConstant@$00$01$01@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5720);
		  /* 820C5720h */ case    0:  		/* add R10, R10, R9 */
		/* 820C5720h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820C5720h case    0:*/		return 0x820C5724;
		  /* 820C5724h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C5724h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C5724h case    1:*/		return 0x820C5728;
		  /* 820C5728h */ case    2:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C5728h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C5728h case    2:*/		return 0x820C572C;
		  /* 820C572Ch */ case    3:  		/* stwu R10, <#[R7 + 4]> */
		/* 820C572Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820C572Ch case    3:*/		return 0x820C5730;
		  /* 820C5730h */ case    4:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C5730h case    4:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5730h case    4:*/		return 0x820C5734;
		  /* 820C5734h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 820C5734h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C5734h case    5:*/		return 0x820C5738;
		  /* 820C5738h */ case    6:  		/* bc 12, CR6_LT, -44 */
		/* 820C5738h case    6:*/		if ( regs.CR[6].lt ) { return 0x820C570C;  }
		/* 820C5738h case    6:*/		return 0x820C573C;
	}
	return 0x820C573C;
} // Block from 820C5720h-820C573Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C573Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C573C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C573C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C573C);
		  /* 820C573Ch */ case    0:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C573Ch case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C573Ch case    0:*/		return 0x820C5740;
		  /* 820C5740h */ case    1:  		/* addi R9, R9, 1 */
		/* 820C5740h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C5740h case    1:*/		return 0x820C5744;
		  /* 820C5744h */ case    2:  		/* cmplw CR6, R9, R8 */
		/* 820C5744h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820C5744h case    2:*/		return 0x820C5748;
		  /* 820C5748h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 820C5748h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C5700;  }
		/* 820C5748h case    3:*/		return 0x820C574C;
	}
	return 0x820C574C;
} // Block from 820C573Ch-820C574Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C574Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C574C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C574C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C574C);
		  /* 820C574Ch */ case    0:  		/* addi R4, R4, 1 */
		/* 820C574Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820C574Ch case    0:*/		return 0x820C5750;
		  /* 820C5750h */ case    1:  		/* cmplw CR6, R4, R3 */
		/* 820C5750h case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 820C5750h case    1:*/		return 0x820C5754;
		  /* 820C5754h */ case    2:  		/* bc 12, CR6_LT, -96 */
		/* 820C5754h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C56F4;  }
		/* 820C5754h case    2:*/		return 0x820C5758;
	}
	return 0x820C5758;
} // Block from 820C574Ch-820C5758h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5758);
		  /* 820C5758h */ case    0:  		/* mr R25, R6 */
		/* 820C5758h case    0:*/		regs.R25 = regs.R6;
		/* 820C5758h case    0:*/		return 0x820C575C;
		  /* 820C575Ch */ case    1:  		/* b 64 */
		/* 820C575Ch case    1:*/		return 0x820C579C;
		/* 820C575Ch case    1:*/		return 0x820C5760;
	}
	return 0x820C5760;
} // Block from 820C5758h-820C5760h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5760);
		  /* 820C5760h */ case    0:  		/* lhz R9, <#[R31 + 6]> */
		/* 820C5760h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5760h case    0:*/		return 0x820C5764;
		  /* 820C5764h */ case    1:  		/* lhz R8, <#[R31 + 4]> */
		/* 820C5764h case    1:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5764h case    1:*/		return 0x820C5768;
		  /* 820C5768h */ case    2:  		/* mullw R9, R9, R8 */
		/* 820C5768h case    2:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820C5768h case    2:*/		return 0x820C576C;
		  /* 820C576Ch */ case    3:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C576Ch case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C576Ch case    3:*/		return 0x820C5770;
		  /* 820C5770h */ case    4:  		/* divwu R3, R11, R9 */
		/* 820C5770h case    4:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R11,regs.R9);
		/* 820C5770h case    4:*/		return 0x820C5774;
		  /* 820C5774h */ case    5:  		/* twi 6, R9, 0 */
		/* 820C5774h case    5:*/		cpu::op::tw<6>(regs, 0x820C5774, regs.R9, 0x00000000);
		/* 820C5774h case    5:*/		return 0x820C5778;
		  /* 820C5778h */ case    6:  		/* cmplw CR6, R3, R10 */
		/* 820C5778h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C5778h case    6:*/		return 0x820C577C;
		  /* 820C577Ch */ case    7:  		/* b 24 */
		/* 820C577Ch case    7:*/		return 0x820C5794;
		/* 820C577Ch case    7:*/		return 0x820C5780;
	}
	return 0x820C5780;
} // Block from 820C5760h-820C5780h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C5780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5780);
		  /* 820C5780h */ case    0:  		/* lhz R9, <#[R31 + 6]> */
		/* 820C5780h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5780h case    0:*/		return 0x820C5784;
		  /* 820C5784h */ case    1:  		/* b -24 */
		/* 820C5784h case    1:*/		return 0x820C576C;
		/* 820C5784h case    1:*/		return 0x820C5788;
	}
	return 0x820C5788;
} // Block from 820C5780h-820C5788h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5788);
		  /* 820C5788h */ case    0:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C5788h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C5788h case    0:*/		return 0x820C578C;
		  /* 820C578Ch */ case    1:  		/* mr R3, R11 */
		/* 820C578Ch case    1:*/		regs.R3 = regs.R11;
		/* 820C578Ch case    1:*/		return 0x820C5790;
		  /* 820C5790h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C5790h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C5790h case    2:*/		return 0x820C5794;
	}
	return 0x820C5794;
} // Block from 820C5788h-820C5794h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5794);
		  /* 820C5794h */ case    0:  		/* bc 4, CR6_GT, 8 */
		/* 820C5794h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820C579C;  }
		/* 820C5794h case    0:*/		return 0x820C5798;
		  /* 820C5798h */ case    1:  		/* mr R3, R10 */
		/* 820C5798h case    1:*/		regs.R3 = regs.R10;
		/* 820C5798h case    1:*/		return 0x820C579C;
	}
	return 0x820C579C;
} // Block from 820C5794h-820C579Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C579Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C579C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C579C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C579C);
		  /* 820C579Ch */ case    0:  		/* lhz R10, <#[R31 + 2]> */
		/* 820C579Ch case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000002) );
		/* 820C579Ch case    0:*/		return 0x820C57A0;
		  /* 820C57A0h */ case    1:  		/* cmplwi CR6, R10, 2 */
		/* 820C57A0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820C57A0h case    1:*/		return 0x820C57A4;
		  /* 820C57A4h */ case    2:  		/* bc 12, CR6_EQ, 132 */
		/* 820C57A4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5828;  }
		/* 820C57A4h case    2:*/		return 0x820C57A8;
	}
	return 0x820C57A8;
} // Block from 820C579Ch-820C57A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C57A8h
// Function '?Set@?$SetShaderConstant@$00$01$02@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C57A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C57A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C57A8);
		  /* 820C57A8h */ case    0:  		/* lwz R11, <#[R24 + 52]> */
		/* 820C57A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000034) );
		/* 820C57A8h case    0:*/		return 0x820C57AC;
		  /* 820C57ACh */ case    1:  		/* cmplwi CR6, R10, 1 */
		/* 820C57ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C57ACh case    1:*/		return 0x820C57B0;
		  /* 820C57B0h */ case    2:  		/* mullw R11, R11, R3 */
		/* 820C57B0h case    2:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820C57B0h case    2:*/		return 0x820C57B4;
		  /* 820C57B4h */ case    3:  		/* bc 12, CR6_EQ, 68 */
		/* 820C57B4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C57F8;  }
		/* 820C57B4h case    3:*/		return 0x820C57B8;
		  /* 820C57B8h */ case    4:  		/* cmplwi CR6, R10, 3 */
		/* 820C57B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C57B8h case    4:*/		return 0x820C57BC;
		  /* 820C57BCh */ case    5:  		/* bc 4, CR6_EQ, 104 */
		/* 820C57BCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C5824;  }
		/* 820C57BCh case    5:*/		return 0x820C57C0;
		  /* 820C57C0h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820C57C0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C57C0h case    6:*/		return 0x820C57C4;
		  /* 820C57C4h */ case    7:  		/* bc 12, CR6_EQ, 96 */
		/* 820C57C4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C5824;  }
		/* 820C57C4h case    7:*/		return 0x820C57C8;
		  /* 820C57C8h */ case    8:  		/* mtspr CTR, R11 */
		/* 820C57C8h case    8:*/		regs.CTR = regs.R11;
		/* 820C57C8h case    8:*/		return 0x820C57CC;
		  /* 820C57CCh */ case    9:  		/* mr R10, R6 */
		/* 820C57CCh case    9:*/		regs.R10 = regs.R6;
		/* 820C57CCh case    9:*/		return 0x820C57D0;
		  /* 820C57D0h */ case   10:  		/* subf R11, R6, R25 */
		/* 820C57D0h case   10:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R25);
		/* 820C57D0h case   10:*/		return 0x820C57D4;
		  /* 820C57D4h */ case   11:  		/* lwax R9, <#[R11 + R10]> */
		/* 820C57D4h case   11:*/		cpu::mem::load32a( regs, &regs.R9, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C57D4h case   11:*/		return 0x820C57D8;
		  /* 820C57D8h */ case   12:  		/* std R9, <#[R1 + 80]> */
		/* 820C57D8h case   12:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820C57D8h case   12:*/		return 0x820C57DC;
		  /* 820C57DCh */ case   13:  		/* lfd FR0, <#[R1 + 80]> */
		/* 820C57DCh case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820C57DCh case   13:*/		return 0x820C57E0;
		  /* 820C57E0h */ case   14:  		/* fcfid FR0, FR0 */
		/* 820C57E0h case   14:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820C57E0h case   14:*/		return 0x820C57E4;
		  /* 820C57E4h */ case   15:  		/* frsp FR0, FR0 */
		/* 820C57E4h case   15:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 820C57E4h case   15:*/		return 0x820C57E8;
		  /* 820C57E8h */ case   16:  		/* stfs FR0, <#[R10]> */
		/* 820C57E8h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C57E8h case   16:*/		return 0x820C57EC;
		  /* 820C57ECh */ case   17:  		/* addi R10, R10, 4 */
		/* 820C57ECh case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C57ECh case   17:*/		return 0x820C57F0;
		  /* 820C57F0h */ case   18:  		/* bc 16, CR0_LT, -28 */
		/* 820C57F0h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C57D4;  }
		/* 820C57F0h case   18:*/		return 0x820C57F4;
		  /* 820C57F4h */ case   19:  		/* b 48 */
		/* 820C57F4h case   19:*/		return 0x820C5824;
		/* 820C57F4h case   19:*/		return 0x820C57F8;
	}
	return 0x820C57F8;
} // Block from 820C57A8h-820C57F8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C57F8h
// Function '?Set@?$SetShaderConstant@$01$01$00@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C57F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C57F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C57F8);
		  /* 820C57F8h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C57F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C57F8h case    0:*/		return 0x820C57FC;
		  /* 820C57FCh */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820C57FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820C5824;  }
		/* 820C57FCh case    1:*/		return 0x820C5800;
		  /* 820C5800h */ case    2:  		/* mtspr CTR, R11 */
		/* 820C5800h case    2:*/		regs.CTR = regs.R11;
		/* 820C5800h case    2:*/		return 0x820C5804;
		  /* 820C5804h */ case    3:  		/* mr R10, R6 */
		/* 820C5804h case    3:*/		regs.R10 = regs.R6;
		/* 820C5804h case    3:*/		return 0x820C5808;
		  /* 820C5808h */ case    4:  		/* subf R11, R6, R25 */
		/* 820C5808h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R25);
		/* 820C5808h case    4:*/		return 0x820C580C;
		  /* 820C580Ch */ case    5:  		/* lwzx R9, <#[R10 + R11]> */
		/* 820C580Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820C580Ch case    5:*/		return 0x820C5810;
		  /* 820C5810h */ case    6:  		/* addic R8, R9, -1 */
		/* 820C5810h case    6:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 820C5810h case    6:*/		return 0x820C5814;
		  /* 820C5814h */ case    7:  		/* subfe R9, R8, R9 */
		/* 820C5814h case    7:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C5814h case    7:*/		return 0x820C5818;
		  /* 820C5818h */ case    8:  		/* stw R9, <#[R10]> */
		/* 820C5818h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820C5818h case    8:*/		return 0x820C581C;
		  /* 820C581Ch */ case    9:  		/* addi R10, R10, 4 */
		/* 820C581Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C581Ch case    9:*/		return 0x820C5820;
		  /* 820C5820h */ case   10:  		/* bc 16, CR0_LT, -20 */
		/* 820C5820h case   10:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C580C;  }
		/* 820C5820h case   10:*/		return 0x820C5824;
	}
	return 0x820C5824;
} // Block from 820C57F8h-820C5824h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C5824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5824);
		  /* 820C5824h */ case    0:  		/* mr R25, R6 */
		/* 820C5824h case    0:*/		regs.R25 = regs.R6;
		/* 820C5824h case    0:*/		return 0x820C5828;
	}
	return 0x820C5828;
} // Block from 820C5824h-820C5828h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C5828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5828);
		  /* 820C5828h */ case    0:  		/* lhz R9, <#[R24 + 8]> */
		/* 820C5828h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 820C5828h case    0:*/		return 0x820C582C;
		  /* 820C582Ch */ case    1:  		/* cmplwi CR0, R9, 0 */
		/* 820C582Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820C582Ch case    1:*/		return 0x820C5830;
		  /* 820C5830h */ case    2:  		/* bc 12, CR0_EQ, 216 */
		/* 820C5830h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C5908;  }
		/* 820C5830h case    2:*/		return 0x820C5834;
		  /* 820C5834h */ case    3:  		/* lhz R11, <#[R31]> */
		/* 820C5834h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C5834h case    3:*/		return 0x820C5838;
		  /* 820C5838h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C5838h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C5838h case    4:*/		return 0x820C583C;
		  /* 820C583Ch */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820C583Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x820C584C;  }
		/* 820C583Ch case    5:*/		return 0x820C5840;
		  /* 820C5840h */ case    6:  		/* lhz R11, <#[R31 + 6]> */
		/* 820C5840h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5840h case    6:*/		return 0x820C5844;
		  /* 820C5844h */ case    7:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C5844h case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5844h case    7:*/		return 0x820C5848;
		  /* 820C5848h */ case    8:  		/* b 12 */
		/* 820C5848h case    8:*/		return 0x820C5854;
		/* 820C5848h case    8:*/		return 0x820C584C;
	}
	return 0x820C584C;
} // Block from 820C5828h-820C584Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C584Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C584C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C584C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C584C);
		  /* 820C584Ch */ case    0:  		/* lhz R11, <#[R31 + 4]> */
		/* 820C584Ch case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820C584Ch case    0:*/		return 0x820C5850;
		  /* 820C5850h */ case    1:  		/* lhz R10, <#[R31 + 6]> */
		/* 820C5850h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5850h case    1:*/		return 0x820C5854;
	}
	return 0x820C5854;
} // Block from 820C584Ch-820C5854h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5854);
		  /* 820C5854h */ case    0:  		/* rlwinm. R8, R11, 0, 30, 31 */
		/* 820C5854h case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R8,regs.R11);
		/* 820C5854h case    0:*/		return 0x820C5858;
		  /* 820C5858h */ case    1:  		/* bc 12, CR0_EQ, 176 */
		/* 820C5858h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C5908;  }
		/* 820C5858h case    1:*/		return 0x820C585C;
		  /* 820C585Ch */ case    2:  		/* cmplwi CR6, R9, 1 */
		/* 820C585Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820C585Ch case    2:*/		return 0x820C5860;
		  /* 820C5860h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820C5860h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C5870;  }
		/* 820C5860h case    3:*/		return 0x820C5864;
		  /* 820C5864h */ case    4:  		/* lis R9, -32255 */
		/* 820C5864h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C5864h case    4:*/		return 0x820C5868;
		  /* 820C5868h */ case    5:  		/* addi R4, R9, 10344 */
		/* 820C5868h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2868);
		/* 820C5868h case    5:*/		return 0x820C586C;
		  /* 820C586Ch */ case    6:  		/* b 12 */
		/* 820C586Ch case    6:*/		return 0x820C5878;
		/* 820C586Ch case    6:*/		return 0x820C5870;
	}
	return 0x820C5870;
} // Block from 820C5854h-820C5870h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C5870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5870);
		  /* 820C5870h */ case    0:  		/* lis R9, -32255 */
		/* 820C5870h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C5870h case    0:*/		return 0x820C5874;
		  /* 820C5874h */ case    1:  		/* addi R4, R9, 10360 */
		/* 820C5874h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2878);
		/* 820C5874h case    1:*/		return 0x820C5878;
	}
	return 0x820C5878;
} // Block from 820C5870h-820C5878h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5878);
		  /* 820C5878h */ case    0:  		/* addi R9, R11, 3 */
		/* 820C5878h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 820C5878h case    0:*/		return 0x820C587C;
		  /* 820C587Ch */ case    1:  		/* mullw. R8, R10, R3 */
		/* 820C587Ch case    1:*/		cpu::op::mullw<1>(regs,&regs.R8,regs.R10,regs.R3);
		/* 820C587Ch case    1:*/		return 0x820C5880;
	}
	return 0x820C5880;
} // Block from 820C5878h-820C5880h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5880h
// Function '?Set@?$SetShaderConstant@$01$01$01@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5880);
		  /* 820C5880h */ case    0:  		/* rlwinm R7, R9, 0, 0, 29 */
		/* 820C5880h case    0:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R7,regs.R9);
		/* 820C5880h case    0:*/		return 0x820C5884;
		  /* 820C5884h */ case    1:  		/* bc 12, CR0_EQ, 128 */
		/* 820C5884h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C5904;  }
		/* 820C5884h case    1:*/		return 0x820C5888;
		  /* 820C5888h */ case    2:  		/* mullw R9, R8, R7 */
		/* 820C5888h case    2:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R7);
		/* 820C5888h case    2:*/		return 0x820C588C;
		  /* 820C588Ch */ case    3:  		/* mullw R5, R8, R11 */
		/* 820C588Ch case    3:*/		cpu::op::mullw<0>(regs,&regs.R5,regs.R8,regs.R11);
		/* 820C588Ch case    3:*/		return 0x820C5890;
		  /* 820C5890h */ case    4:  		/* addi R8, R8, -1 */
		/* 820C5890h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820C5890h case    4:*/		return 0x820C5894;
		  /* 820C5894h */ case    5:  		/* subf R5, R11, R5 */
		/* 820C5894h case    5:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 820C5894h case    5:*/		return 0x820C5898;
		  /* 820C5898h */ case    6:  		/* subf R9, R7, R9 */
		/* 820C5898h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820C5898h case    6:*/		return 0x820C589C;
		  /* 820C589Ch */ case    7:  		/* mr R10, R7 */
		/* 820C589Ch case    7:*/		regs.R10 = regs.R7;
		/* 820C589Ch case    7:*/		return 0x820C58A0;
		  /* 820C58A0h */ case    8:  		/* cmplw CR6, R7, R11 */
		/* 820C58A0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C58A0h case    8:*/		return 0x820C58A4;
		  /* 820C58A4h */ case    9:  		/* bc 4, CR6_GT, 40 */
		/* 820C58A4h case    9:*/		if ( !regs.CR[6].gt ) { return 0x820C58CC;  }
		/* 820C58A4h case    9:*/		return 0x820C58A8;
		  /* 820C58A8h */ case   10:  		/* subf R31, R11, R7 */
		/* 820C58A8h case   10:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R7);
		/* 820C58A8h case   10:*/		return 0x820C58AC;
		  /* 820C58ACh */ case   11:  		/* mtspr CTR, R31 */
		/* 820C58ACh case   11:*/		regs.CTR = regs.R31;
		/* 820C58ACh case   11:*/		return 0x820C58B0;
		  /* 820C58B0h */ case   12:  		/* addi R10, R10, -1 */
		/* 820C58B0h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C58B0h case   12:*/		return 0x820C58B4;
		  /* 820C58B4h */ case   13:  		/* rlwinm R31, R10, 2, 28, 29 */
		/* 820C58B4h case   13:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R31,regs.R10);
		/* 820C58B4h case   13:*/		return 0x820C58B8;
		  /* 820C58B8h */ case   14:  		/* add R30, R9, R10 */
		/* 820C58B8h case   14:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R10);
		/* 820C58B8h case   14:*/		return 0x820C58BC;
		  /* 820C58BCh */ case   15:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C58BCh case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C58BCh case   15:*/		return 0x820C58C0;
		  /* 820C58C0h */ case   16:  		/* lwzx R31, <#[R31 + R4]> */
		/* 820C58C0h case   16:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R4 + 0x00000000) );
		/* 820C58C0h case   16:*/		return 0x820C58C4;
		  /* 820C58C4h */ case   17:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C58C4h case   17:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C58C4h case   17:*/		return 0x820C58C8;
		  /* 820C58C8h */ case   18:  		/* bc 16, CR0_LT, -24 */
		/* 820C58C8h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C58B0;  }
		/* 820C58C8h case   18:*/		return 0x820C58CC;
	}
	return 0x820C58CC;
} // Block from 820C5880h-820C58CCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820C58CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C58CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C58CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C58CC);
		  /* 820C58CCh */ case    0:  		/* mr R10, R11 */
		/* 820C58CCh case    0:*/		regs.R10 = regs.R11;
		/* 820C58CCh case    0:*/		return 0x820C58D0;
		  /* 820C58D0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C58D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C58D0h case    1:*/		return 0x820C58D4;
		  /* 820C58D4h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820C58D4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C58FC;  }
		/* 820C58D4h case    2:*/		return 0x820C58D8;
		  /* 820C58D8h */ case    3:  		/* mtspr CTR, R11 */
		/* 820C58D8h case    3:*/		regs.CTR = regs.R11;
		/* 820C58D8h case    3:*/		return 0x820C58DC;
		  /* 820C58DCh */ case    4:  		/* addi R10, R10, -1 */
		/* 820C58DCh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C58DCh case    4:*/		return 0x820C58E0;
		  /* 820C58E0h */ case    5:  		/* add R31, R5, R10 */
		/* 820C58E0h case    5:*/		cpu::op::add<0>(regs,&regs.R31,regs.R5,regs.R10);
		/* 820C58E0h case    5:*/		return 0x820C58E4;
		  /* 820C58E4h */ case    6:  		/* add R30, R9, R10 */
		/* 820C58E4h case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R10);
		/* 820C58E4h case    6:*/		return 0x820C58E8;
		  /* 820C58E8h */ case    7:  		/* rlwinm R31, R31, 2, 0, 29 */
		/* 820C58E8h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R31);
		/* 820C58E8h case    7:*/		return 0x820C58EC;
		  /* 820C58ECh */ case    8:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C58ECh case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C58ECh case    8:*/		return 0x820C58F0;
		  /* 820C58F0h */ case    9:  		/* lwzx R31, <#[R31 + R25]> */
		/* 820C58F0h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R25 + 0x00000000) );
		/* 820C58F0h case    9:*/		return 0x820C58F4;
		  /* 820C58F4h */ case   10:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C58F4h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C58F4h case   10:*/		return 0x820C58F8;
		  /* 820C58F8h */ case   11:  		/* bc 16, CR0_LT, -28 */
		/* 820C58F8h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C58DC;  }
		/* 820C58F8h case   11:*/		return 0x820C58FC;
	}
	return 0x820C58FC;
} // Block from 820C58CCh-820C58FCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C58FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C58FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C58FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C58FC);
		  /* 820C58FCh */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820C58FCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C58FCh case    0:*/		return 0x820C5900;
	}
	return 0x820C5900;
} // Block from 820C58FCh-820C5900h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C5900h
// Function '?Set@?$SetShaderConstant@$01$01$0A@@D3DXShader@@SAJPBXI0PAKI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5900);
		  /* 820C5900h */ case    0:  		/* bc 4, CR6_EQ, -112 */
		/* 820C5900h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820C5890;  }
		/* 820C5900h case    0:*/		return 0x820C5904;
	}
	return 0x820C5904;
} // Block from 820C5900h-820C5904h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C5904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5904);
		  /* 820C5904h */ case    0:  		/* mr R25, R6 */
		/* 820C5904h case    0:*/		regs.R25 = regs.R6;
		/* 820C5904h case    0:*/		return 0x820C5908;
	}
	return 0x820C5908;
} // Block from 820C5904h-820C5908h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C5908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5908);
		  /* 820C5908h */ case    0:  		/* lwz R10, <#[R24 + 44]> */
		/* 820C5908h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000002C) );
		/* 820C5908h case    0:*/		return 0x820C590C;
		  /* 820C590Ch */ case    1:  		/* lhz R11, <#[R24 + 12]> */
		/* 820C590Ch case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820C590Ch case    1:*/		return 0x820C5910;
		  /* 820C5910h */ case    2:  		/* mullw R7, R10, R3 */
		/* 820C5910h case    2:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R3);
		/* 820C5910h case    2:*/		return 0x820C5914;
		  /* 820C5914h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820C5914h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C5914h case    3:*/		return 0x820C5918;
		  /* 820C5918h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 820C5918h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820C5920;  }
		/* 820C5918h case    4:*/		return 0x820C591C;
		  /* 820C591Ch */ case    5:  		/* mr R7, R11 */
		/* 820C591Ch case    5:*/		regs.R7 = regs.R11;
		/* 820C591Ch case    5:*/		return 0x820C5920;
	}
	return 0x820C5920;
} // Block from 820C5908h-820C5920h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C5920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5920);
		  /* 820C5920h */ case    0:  		/* lwz R10, <#[R24 + 28]> */
		/* 820C5920h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 820C5920h case    0:*/		return 0x820C5924;
		  /* 820C5924h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C5924h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C5924h case    1:*/		return 0x820C5928;
		  /* 820C5928h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C5928h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C5938;  }
		/* 820C5928h case    2:*/		return 0x820C592C;
		  /* 820C592Ch */ case    3:  		/* lis R3, -32768 */
		/* 820C592Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C592Ch case    3:*/		return 0x820C5930;
		  /* 820C5930h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820C5930h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C5930h case    4:*/		return 0x820C5934;
		  /* 820C5934h */ case    5:  		/* b 36 */
		/* 820C5934h case    5:*/		return 0x820C5958;
		/* 820C5934h case    5:*/		return 0x820C5938;
	}
	return 0x820C5938;
} // Block from 820C5920h-820C5938h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C5938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5938);
		  /* 820C5938h */ case    0:  		/* lhz R11, <#[R24 + 10]> */
		/* 820C5938h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000A) );
		/* 820C5938h case    0:*/		return 0x820C593C;
		  /* 820C593Ch */ case    1:  		/* mr R5, R25 */
		/* 820C593Ch case    1:*/		regs.R5 = regs.R25;
		/* 820C593Ch case    1:*/		return 0x820C5940;
		  /* 820C5940h */ case    2:  		/* mr R3, R23 */
		/* 820C5940h case    2:*/		regs.R3 = regs.R23;
		/* 820C5940h case    2:*/		return 0x820C5944;
		  /* 820C5944h */ case    3:  		/* mtspr CTR, R10 */
		/* 820C5944h case    3:*/		regs.CTR = regs.R10;
		/* 820C5944h case    3:*/		return 0x820C5948;
	}
	return 0x820C5948;
} // Block from 820C5938h-820C5948h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5948h
// Function '?Set@?$SetTyped@$0A@$0A@$00$00$0A@@D3DXShader@@SAJPAVCConstant@2@PBX1II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5948);
		  /* 820C5948h */ case    0:  		/* add R4, R11, R22 */
		/* 820C5948h case    0:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R22);
		/* 820C5948h case    0:*/		return 0x820C594C;
		  /* 820C594Ch */ case    1:  		/* bcctrl 20, CR0_LT */
		/* 820C594Ch case    1:*/		if ( 1 ) { regs.LR = 0x820C5950; return (uint32)regs.CTR; }
		/* 820C594Ch case    1:*/		return 0x820C5950;
		  /* 820C5950h */ case    2:  		/* srawi R11, R3, 31 */
		/* 820C5950h case    2:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820C5950h case    2:*/		return 0x820C5954;
		  /* 820C5954h */ case    3:  		/* and R3, R11, R3 */
		/* 820C5954h case    3:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C5954h case    3:*/		return 0x820C5958;
	}
	return 0x820C5958;
} // Block from 820C5948h-820C5958h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5958);
		  /* 820C5958h */ case    0:  		/* addi R1, R1, 176 */
		/* 820C5958h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820C5958h case    0:*/		return 0x820C595C;
		  /* 820C595Ch */ case    1:  		/* b -214732 */
		/* 820C595Ch case    1:*/		return 0x82091290;
		/* 820C595Ch case    1:*/		return 0x820C5960;
	}
	return 0x820C5960;
} // Block from 820C5958h-820C5960h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5960);
		  /* 820C5960h */ case    0:  		/* mfspr R12, LR */
		/* 820C5960h case    0:*/		regs.R12 = regs.LR;
		/* 820C5960h case    0:*/		return 0x820C5964;
		  /* 820C5964h */ case    1:  		/* bl -214820 */
		/* 820C5964h case    1:*/		regs.LR = 0x820C5968; return 0x82091240;
		/* 820C5964h case    1:*/		return 0x820C5968;
		  /* 820C5968h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820C5968h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820C5968h case    2:*/		return 0x820C596C;
		  /* 820C596Ch */ case    3:  		/* lwz R31, <#[R3 + 24]> */
		/* 820C596Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000018) );
		/* 820C596Ch case    3:*/		return 0x820C5970;
		  /* 820C5970h */ case    4:  		/* mr R11, R6 */
		/* 820C5970h case    4:*/		regs.R11 = regs.R6;
		/* 820C5970h case    4:*/		return 0x820C5974;
		  /* 820C5974h */ case    5:  		/* lwz R6, <#[R3 + 32]> */
		/* 820C5974h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000020) );
		/* 820C5974h case    5:*/		return 0x820C5978;
		  /* 820C5978h */ case    6:  		/* mr R24, R3 */
		/* 820C5978h case    6:*/		regs.R24 = regs.R3;
		/* 820C5978h case    6:*/		return 0x820C597C;
		  /* 820C597Ch */ case    7:  		/* mr R23, R4 */
		/* 820C597Ch case    7:*/		regs.R23 = regs.R4;
		/* 820C597Ch case    7:*/		return 0x820C5980;
		  /* 820C5980h */ case    8:  		/* mr R22, R7 */
		/* 820C5980h case    8:*/		regs.R22 = regs.R7;
		/* 820C5980h case    8:*/		return 0x820C5984;
		  /* 820C5984h */ case    9:  		/* mr R25, R5 */
		/* 820C5984h case    9:*/		regs.R25 = regs.R5;
		/* 820C5984h case    9:*/		return 0x820C5988;
		  /* 820C5988h */ case   10:  		/* lhz R10, <#[R31]> */
		/* 820C5988h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 820C5988h case   10:*/		return 0x820C598C;
		  /* 820C598Ch */ case   11:  		/* cmplwi CR6, R10, 1 */
		/* 820C598Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C598Ch case   11:*/		return 0x820C5990;
		  /* 820C5990h */ case   12:  		/* bc 12, CR6_LT, 392 */
		/* 820C5990h case   12:*/		if ( regs.CR[6].lt ) { return 0x820C5B18;  }
		/* 820C5990h case   12:*/		return 0x820C5994;
		  /* 820C5994h */ case   13:  		/* bc 12, CR6_EQ, 380 */
		/* 820C5994h case   13:*/		if ( regs.CR[6].eq ) { return 0x820C5B10;  }
		/* 820C5994h case   13:*/		return 0x820C5998;
		  /* 820C5998h */ case   14:  		/* cmplwi CR6, R10, 3 */
		/* 820C5998h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C5998h case   14:*/		return 0x820C599C;
		  /* 820C599Ch */ case   15:  		/* bc 12, CR6_LT, 340 */
		/* 820C599Ch case   15:*/		if ( regs.CR[6].lt ) { return 0x820C5AF0;  }
		/* 820C599Ch case   15:*/		return 0x820C59A0;
		  /* 820C59A0h */ case   16:  		/* bc 12, CR6_EQ, 176 */
		/* 820C59A0h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C5A50;  }
		/* 820C59A0h case   16:*/		return 0x820C59A4;
		  /* 820C59A4h */ case   17:  		/* cmplwi CR6, R10, 5 */
		/* 820C59A4h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000005);
		/* 820C59A4h case   17:*/		return 0x820C59A8;
		  /* 820C59A8h */ case   18:  		/* bc 12, CR6_EQ, 16 */
		/* 820C59A8h case   18:*/		if ( regs.CR[6].eq ) { return 0x820C59B8;  }
		/* 820C59A8h case   18:*/		return 0x820C59AC;
		  /* 820C59ACh */ case   19:  		/* lis R3, -32768 */
		/* 820C59ACh case   19:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C59ACh case   19:*/		return 0x820C59B0;
		  /* 820C59B0h */ case   20:  		/* ori R3, R3, 16385 */
		/* 820C59B0h case   20:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 820C59B0h case   20:*/		return 0x820C59B4;
		  /* 820C59B4h */ case   21:  		/* b 824 */
		/* 820C59B4h case   21:*/		return 0x820C5CEC;
		/* 820C59B4h case   21:*/		return 0x820C59B8;
	}
	return 0x820C59B8;
} // Block from 820C5960h-820C59B8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C59B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C59B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C59B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C59B8);
		  /* 820C59B8h */ case    0:  		/* lwz R9, <#[R24 + 52]> */
		/* 820C59B8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000034) );
		/* 820C59B8h case    0:*/		return 0x820C59BC;
		  /* 820C59BCh */ case    1:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C59BCh case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C59BCh case    1:*/		return 0x820C59C0;
		  /* 820C59C0h */ case    2:  		/* divwu R27, R11, R9 */
		/* 820C59C0h case    2:*/		cpu::op::divwu<0>(regs,&regs.R27,regs.R11,regs.R9);
		/* 820C59C0h case    2:*/		return 0x820C59C4;
		  /* 820C59C4h */ case    3:  		/* twi 6, R9, 0 */
		/* 820C59C4h case    3:*/		cpu::op::tw<6>(regs, 0x820C59C4, regs.R9, 0x00000000);
		/* 820C59C4h case    3:*/		return 0x820C59C8;
		  /* 820C59C8h */ case    4:  		/* cmplw CR6, R27, R10 */
		/* 820C59C8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R10);
		/* 820C59C8h case    4:*/		return 0x820C59CC;
		  /* 820C59CCh */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 820C59CCh case    5:*/		if ( !regs.CR[6].gt ) { return 0x820C59D4;  }
		/* 820C59CCh case    5:*/		return 0x820C59D0;
		  /* 820C59D0h */ case    6:  		/* mr R27, R10 */
		/* 820C59D0h case    6:*/		regs.R27 = regs.R10;
		/* 820C59D0h case    6:*/		return 0x820C59D4;
	}
	return 0x820C59D4;
} // Block from 820C59B8h-820C59D4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C59D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C59D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C59D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C59D4);
		  /* 820C59D4h */ case    0:  		/* li R26, 0 */
		/* 820C59D4h case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820C59D4h case    0:*/		return 0x820C59D8;
		  /* 820C59D8h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 820C59D8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820C59D8h case    1:*/		return 0x820C59DC;
		  /* 820C59DCh */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 820C59DCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5A48;  }
		/* 820C59DCh case    2:*/		return 0x820C59E0;
		  /* 820C59E0h */ case    3:  		/* lhz R11, <#[R31 + 10]> */
		/* 820C59E0h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000A) );
		/* 820C59E0h case    3:*/		return 0x820C59E4;
		  /* 820C59E4h */ case    4:  		/* li R28, 0 */
		/* 820C59E4h case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820C59E4h case    4:*/		return 0x820C59E8;
		  /* 820C59E8h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 820C59E8h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C59E8h case    5:*/		return 0x820C59EC;
		  /* 820C59ECh */ case    6:  		/* bc 12, CR0_EQ, 80 */
		/* 820C59ECh case    6:*/		if ( regs.CR[0].eq ) { return 0x820C5A3C;  }
		/* 820C59ECh case    6:*/		return 0x820C59F0;
		  /* 820C59F0h */ case    7:  		/* li R29, 0 */
		/* 820C59F0h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C59F0h case    7:*/		return 0x820C59F4;
		  /* 820C59F4h */ case    8:  		/* lwz R11, <#[R24 + 56]> */
		/* 820C59F4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 820C59F4h case    8:*/		return 0x820C59F8;
		  /* 820C59F8h */ case    9:  		/* mr R7, R22 */
		/* 820C59F8h case    9:*/		regs.R7 = regs.R22;
		/* 820C59F8h case    9:*/		return 0x820C59FC;
		  /* 820C59FCh */ case   10:  		/* mr R5, R25 */
		/* 820C59FCh case   10:*/		regs.R5 = regs.R25;
		/* 820C59FCh case   10:*/		return 0x820C5A00;
		  /* 820C5A00h */ case   11:  		/* mr R4, R23 */
		/* 820C5A00h case   11:*/		regs.R4 = regs.R23;
		/* 820C5A00h case   11:*/		return 0x820C5A04;
		  /* 820C5A04h */ case   12:  		/* lwzx R30, <#[R29 + R11]> */
		/* 820C5A04h case   12:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820C5A04h case   12:*/		return 0x820C5A08;
		  /* 820C5A08h */ case   13:  		/* mr R3, R30 */
		/* 820C5A08h case   13:*/		regs.R3 = regs.R30;
		/* 820C5A08h case   13:*/		return 0x820C5A0C;
		  /* 820C5A0Ch */ case   14:  		/* lwz R6, <#[R30 + 48]> */
		/* 820C5A0Ch case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + 0x00000030) );
		/* 820C5A0Ch case   14:*/		return 0x820C5A10;
		  /* 820C5A10h */ case   15:  		/* bl -176 */
		/* 820C5A10h case   15:*/		regs.LR = 0x820C5A14; return 0x820C5960;
		/* 820C5A10h case   15:*/		return 0x820C5A14;
		  /* 820C5A14h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820C5A14h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C5A14h case   16:*/		return 0x820C5A18;
		  /* 820C5A18h */ case   17:  		/* bc 12, CR0_LT, 724 */
		/* 820C5A18h case   17:*/		if ( regs.CR[0].lt ) { return 0x820C5CEC;  }
		/* 820C5A18h case   17:*/		return 0x820C5A1C;
		  /* 820C5A1Ch */ case   18:  		/* lwz R11, <#[R30 + 48]> */
		/* 820C5A1Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 820C5A1Ch case   18:*/		return 0x820C5A20;
		  /* 820C5A20h */ case   19:  		/* addi R28, R28, 1 */
		/* 820C5A20h case   19:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820C5A20h case   19:*/		return 0x820C5A24;
		  /* 820C5A24h */ case   20:  		/* lhz R10, <#[R31 + 10]> */
		/* 820C5A24h case   20:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000A) );
		/* 820C5A24h case   20:*/		return 0x820C5A28;
		  /* 820C5A28h */ case   21:  		/* addi R29, R29, 4 */
		/* 820C5A28h case   21:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 820C5A28h case   21:*/		return 0x820C5A2C;
		  /* 820C5A2Ch */ case   22:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C5A2Ch case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C5A2Ch case   22:*/		return 0x820C5A30;
		  /* 820C5A30h */ case   23:  		/* cmplw CR6, R28, R10 */
		/* 820C5A30h case   23:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 820C5A30h case   23:*/		return 0x820C5A34;
		  /* 820C5A34h */ case   24:  		/* add R25, R11, R25 */
		/* 820C5A34h case   24:*/		cpu::op::add<0>(regs,&regs.R25,regs.R11,regs.R25);
		/* 820C5A34h case   24:*/		return 0x820C5A38;
		  /* 820C5A38h */ case   25:  		/* bc 12, CR6_LT, -68 */
		/* 820C5A38h case   25:*/		if ( regs.CR[6].lt ) { return 0x820C59F4;  }
		/* 820C5A38h case   25:*/		return 0x820C5A3C;
	}
	return 0x820C5A3C;
} // Block from 820C59D4h-820C5A3Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 820C5A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5A3C);
		  /* 820C5A3Ch */ case    0:  		/* addi R26, R26, 1 */
		/* 820C5A3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820C5A3Ch case    0:*/		return 0x820C5A40;
		  /* 820C5A40h */ case    1:  		/* cmplw CR6, R26, R27 */
		/* 820C5A40h case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R27);
		/* 820C5A40h case    1:*/		return 0x820C5A44;
		  /* 820C5A44h */ case    2:  		/* bc 12, CR6_LT, -100 */
		/* 820C5A44h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C59E0;  }
		/* 820C5A44h case    2:*/		return 0x820C5A48;
	}
	return 0x820C5A48;
} // Block from 820C5A3Ch-820C5A48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5A48);
		  /* 820C5A48h */ case    0:  		/* li R3, 0 */
		/* 820C5A48h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C5A48h case    0:*/		return 0x820C5A4C;
		  /* 820C5A4Ch */ case    1:  		/* b 672 */
		/* 820C5A4Ch case    1:*/		return 0x820C5CEC;
		/* 820C5A4Ch case    1:*/		return 0x820C5A50;
	}
	return 0x820C5A50;
} // Block from 820C5A48h-820C5A50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5A50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5A50);
		  /* 820C5A50h */ case    0:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C5A50h case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5A50h case    0:*/		return 0x820C5A54;
		  /* 820C5A54h */ case    1:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C5A54h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5A54h case    1:*/		return 0x820C5A58;
		  /* 820C5A58h */ case    2:  		/* lhz R9, <#[R31 + 8]> */
		/* 820C5A58h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 820C5A58h case    2:*/		return 0x820C5A5C;
		  /* 820C5A5Ch */ case    3:  		/* mullw R7, R10, R8 */
		/* 820C5A5Ch case    3:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R8);
		/* 820C5A5Ch case    3:*/		return 0x820C5A60;
		  /* 820C5A60h */ case    4:  		/* divwu R3, R11, R7 */
		/* 820C5A60h case    4:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R11,regs.R7);
		/* 820C5A60h case    4:*/		return 0x820C5A64;
		  /* 820C5A64h */ case    5:  		/* twi 6, R7, 0 */
		/* 820C5A64h case    5:*/		cpu::op::tw<6>(regs, 0x820C5A64, regs.R7, 0x00000000);
		/* 820C5A64h case    5:*/		return 0x820C5A68;
		  /* 820C5A68h */ case    6:  		/* cmplw CR6, R3, R9 */
		/* 820C5A68h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 820C5A68h case    6:*/		return 0x820C5A6C;
		  /* 820C5A6Ch */ case    7:  		/* bc 4, CR6_GT, 8 */
		/* 820C5A6Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x820C5A74;  }
		/* 820C5A6Ch case    7:*/		return 0x820C5A70;
		  /* 820C5A70h */ case    8:  		/* mr R3, R9 */
		/* 820C5A70h case    8:*/		regs.R3 = regs.R9;
		/* 820C5A70h case    8:*/		return 0x820C5A74;
	}
	return 0x820C5A74;
} // Block from 820C5A50h-820C5A74h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C5A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5A74);
		  /* 820C5A74h */ case    0:  		/* li R4, 0 */
		/* 820C5A74h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C5A74h case    0:*/		return 0x820C5A78;
		  /* 820C5A78h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C5A78h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C5A78h case    1:*/		return 0x820C5A7C;
		  /* 820C5A7Ch */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 820C5A7Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5AE8;  }
		/* 820C5A7Ch case    2:*/		return 0x820C5A80;
		  /* 820C5A80h */ case    3:  		/* addi R7, R6, -4 */
		/* 820C5A80h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820C5A80h case    3:*/		return 0x820C5A84;
		  /* 820C5A84h */ case    4:  		/* li R9, 0 */
		/* 820C5A84h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C5A84h case    4:*/		return 0x820C5A88;
		  /* 820C5A88h */ case    5:  		/* cmplwi CR6, R8, 0 */
		/* 820C5A88h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C5A88h case    5:*/		return 0x820C5A8C;
		  /* 820C5A8Ch */ case    6:  		/* bc 12, CR6_EQ, 80 */
		/* 820C5A8Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x820C5ADC;  }
		/* 820C5A8Ch case    6:*/		return 0x820C5A90;
		  /* 820C5A90h */ case    7:  		/* li R11, 0 */
		/* 820C5A90h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C5A90h case    7:*/		return 0x820C5A94;
		  /* 820C5A94h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 820C5A94h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C5A94h case    8:*/		return 0x820C5A98;
		  /* 820C5A98h */ case    9:  		/* bc 12, CR6_EQ, 52 */
		/* 820C5A98h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C5ACC;  }
		/* 820C5A98h case    9:*/		return 0x820C5A9C;
		  /* 820C5A9Ch */ case   10:  		/* mullw R10, R10, R4 */
		/* 820C5A9Ch case   10:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 820C5A9Ch case   10:*/		return 0x820C5AA0;
		  /* 820C5AA0h */ case   11:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C5AA0h case   11:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5AA0h case   11:*/		return 0x820C5AA4;
		  /* 820C5AA4h */ case   12:  		/* add R10, R10, R11 */
		/* 820C5AA4h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C5AA4h case   12:*/		return 0x820C5AA8;
		  /* 820C5AA8h */ case   13:  		/* addi R11, R11, 1 */
		/* 820C5AA8h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C5AA8h case   13:*/		return 0x820C5AAC;
		  /* 820C5AACh */ case   14:  		/* mullw R10, R10, R8 */
		/* 820C5AACh case   14:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820C5AACh case   14:*/		return 0x820C5AB0;
		  /* 820C5AB0h */ case   15:  		/* add R10, R10, R9 */
		/* 820C5AB0h case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820C5AB0h case   15:*/		return 0x820C5AB4;
		  /* 820C5AB4h */ case   16:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C5AB4h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C5AB4h case   16:*/		return 0x820C5AB8;
		  /* 820C5AB8h */ case   17:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C5AB8h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C5AB8h case   17:*/		return 0x820C5ABC;
		  /* 820C5ABCh */ case   18:  		/* stwu R10, <#[R7 + 4]> */
		/* 820C5ABCh case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820C5ABCh case   18:*/		return 0x820C5AC0;
		  /* 820C5AC0h */ case   19:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C5AC0h case   19:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5AC0h case   19:*/		return 0x820C5AC4;
		  /* 820C5AC4h */ case   20:  		/* cmplw CR6, R11, R10 */
		/* 820C5AC4h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C5AC4h case   20:*/		return 0x820C5AC8;
		  /* 820C5AC8h */ case   21:  		/* bc 12, CR6_LT, -44 */
		/* 820C5AC8h case   21:*/		if ( regs.CR[6].lt ) { return 0x820C5A9C;  }
		/* 820C5AC8h case   21:*/		return 0x820C5ACC;
	}
	return 0x820C5ACC;
} // Block from 820C5A74h-820C5ACCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C5ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5ACC);
		  /* 820C5ACCh */ case    0:  		/* lhz R8, <#[R31 + 6]> */
		/* 820C5ACCh case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5ACCh case    0:*/		return 0x820C5AD0;
		  /* 820C5AD0h */ case    1:  		/* addi R9, R9, 1 */
		/* 820C5AD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C5AD0h case    1:*/		return 0x820C5AD4;
		  /* 820C5AD4h */ case    2:  		/* cmplw CR6, R9, R8 */
		/* 820C5AD4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820C5AD4h case    2:*/		return 0x820C5AD8;
		  /* 820C5AD8h */ case    3:  		/* bc 12, CR6_LT, -72 */
		/* 820C5AD8h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C5A90;  }
		/* 820C5AD8h case    3:*/		return 0x820C5ADC;
	}
	return 0x820C5ADC;
} // Block from 820C5ACCh-820C5ADCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5ADC);
		  /* 820C5ADCh */ case    0:  		/* addi R4, R4, 1 */
		/* 820C5ADCh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 820C5ADCh case    0:*/		return 0x820C5AE0;
		  /* 820C5AE0h */ case    1:  		/* cmplw CR6, R4, R3 */
		/* 820C5AE0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R3);
		/* 820C5AE0h case    1:*/		return 0x820C5AE4;
		  /* 820C5AE4h */ case    2:  		/* bc 12, CR6_LT, -96 */
		/* 820C5AE4h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C5A84;  }
		/* 820C5AE4h case    2:*/		return 0x820C5AE8;
	}
	return 0x820C5AE8;
} // Block from 820C5ADCh-820C5AE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5AE8);
		  /* 820C5AE8h */ case    0:  		/* mr R25, R6 */
		/* 820C5AE8h case    0:*/		regs.R25 = regs.R6;
		/* 820C5AE8h case    0:*/		return 0x820C5AEC;
		  /* 820C5AECh */ case    1:  		/* b 64 */
		/* 820C5AECh case    1:*/		return 0x820C5B2C;
		/* 820C5AECh case    1:*/		return 0x820C5AF0;
	}
	return 0x820C5AF0;
} // Block from 820C5AE8h-820C5AF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5AF0);
		  /* 820C5AF0h */ case    0:  		/* lhz R9, <#[R31 + 6]> */
		/* 820C5AF0h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5AF0h case    0:*/		return 0x820C5AF4;
		  /* 820C5AF4h */ case    1:  		/* lhz R8, <#[R31 + 4]> */
		/* 820C5AF4h case    1:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5AF4h case    1:*/		return 0x820C5AF8;
		  /* 820C5AF8h */ case    2:  		/* mullw R9, R9, R8 */
		/* 820C5AF8h case    2:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820C5AF8h case    2:*/		return 0x820C5AFC;
		  /* 820C5AFCh */ case    3:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C5AFCh case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C5AFCh case    3:*/		return 0x820C5B00;
		  /* 820C5B00h */ case    4:  		/* divwu R3, R11, R9 */
		/* 820C5B00h case    4:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R11,regs.R9);
		/* 820C5B00h case    4:*/		return 0x820C5B04;
		  /* 820C5B04h */ case    5:  		/* twi 6, R9, 0 */
		/* 820C5B04h case    5:*/		cpu::op::tw<6>(regs, 0x820C5B04, regs.R9, 0x00000000);
		/* 820C5B04h case    5:*/		return 0x820C5B08;
		  /* 820C5B08h */ case    6:  		/* cmplw CR6, R3, R10 */
		/* 820C5B08h case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C5B08h case    6:*/		return 0x820C5B0C;
		  /* 820C5B0Ch */ case    7:  		/* b 24 */
		/* 820C5B0Ch case    7:*/		return 0x820C5B24;
		/* 820C5B0Ch case    7:*/		return 0x820C5B10;
	}
	return 0x820C5B10;
} // Block from 820C5AF0h-820C5B10h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C5B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5B10);
		  /* 820C5B10h */ case    0:  		/* lhz R9, <#[R31 + 6]> */
		/* 820C5B10h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5B10h case    0:*/		return 0x820C5B14;
		  /* 820C5B14h */ case    1:  		/* b -24 */
		/* 820C5B14h case    1:*/		return 0x820C5AFC;
		/* 820C5B14h case    1:*/		return 0x820C5B18;
	}
	return 0x820C5B18;
} // Block from 820C5B10h-820C5B18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5B18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5B18);
		  /* 820C5B18h */ case    0:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C5B18h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C5B18h case    0:*/		return 0x820C5B1C;
		  /* 820C5B1Ch */ case    1:  		/* mr R3, R11 */
		/* 820C5B1Ch case    1:*/		regs.R3 = regs.R11;
		/* 820C5B1Ch case    1:*/		return 0x820C5B20;
		  /* 820C5B20h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C5B20h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C5B20h case    2:*/		return 0x820C5B24;
	}
	return 0x820C5B24;
} // Block from 820C5B18h-820C5B24h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5B24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5B24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5B24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5B24);
		  /* 820C5B24h */ case    0:  		/* bc 4, CR6_GT, 8 */
		/* 820C5B24h case    0:*/		if ( !regs.CR[6].gt ) { return 0x820C5B2C;  }
		/* 820C5B24h case    0:*/		return 0x820C5B28;
		  /* 820C5B28h */ case    1:  		/* mr R3, R10 */
		/* 820C5B28h case    1:*/		regs.R3 = regs.R10;
		/* 820C5B28h case    1:*/		return 0x820C5B2C;
	}
	return 0x820C5B2C;
} // Block from 820C5B24h-820C5B2Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5B2C);
		  /* 820C5B2Ch */ case    0:  		/* lhz R10, <#[R31 + 2]> */
		/* 820C5B2Ch case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000002) );
		/* 820C5B2Ch case    0:*/		return 0x820C5B30;
		  /* 820C5B30h */ case    1:  		/* cmplwi CR6, R10, 3 */
		/* 820C5B30h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C5B30h case    1:*/		return 0x820C5B34;
		  /* 820C5B34h */ case    2:  		/* bc 12, CR6_EQ, 136 */
		/* 820C5B34h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5BBC;  }
		/* 820C5B34h case    2:*/		return 0x820C5B38;
		  /* 820C5B38h */ case    3:  		/* lwz R11, <#[R24 + 52]> */
		/* 820C5B38h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000034) );
		/* 820C5B38h case    3:*/		return 0x820C5B3C;
		  /* 820C5B3Ch */ case    4:  		/* cmplwi CR6, R10, 1 */
		/* 820C5B3Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C5B3Ch case    4:*/		return 0x820C5B40;
		  /* 820C5B40h */ case    5:  		/* mullw R11, R11, R3 */
		/* 820C5B40h case    5:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820C5B40h case    5:*/		return 0x820C5B44;
		  /* 820C5B44h */ case    6:  		/* bc 12, CR6_EQ, 56 */
		/* 820C5B44h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C5B7C;  }
		/* 820C5B44h case    6:*/		return 0x820C5B48;
		  /* 820C5B48h */ case    7:  		/* cmplwi CR6, R10, 2 */
		/* 820C5B48h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820C5B48h case    7:*/		return 0x820C5B4C;
		  /* 820C5B4Ch */ case    8:  		/* bc 4, CR6_EQ, 108 */
		/* 820C5B4Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C5BB8;  }
		/* 820C5B4Ch case    8:*/		return 0x820C5B50;
		  /* 820C5B50h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820C5B50h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C5B50h case    9:*/		return 0x820C5B54;
		  /* 820C5B54h */ case   10:  		/* bc 12, CR6_EQ, 100 */
		/* 820C5B54h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C5BB8;  }
		/* 820C5B54h case   10:*/		return 0x820C5B58;
		  /* 820C5B58h */ case   11:  		/* mtspr CTR, R11 */
		/* 820C5B58h case   11:*/		regs.CTR = regs.R11;
		/* 820C5B58h case   11:*/		return 0x820C5B5C;
		  /* 820C5B5Ch */ case   12:  		/* mr R10, R6 */
		/* 820C5B5Ch case   12:*/		regs.R10 = regs.R6;
		/* 820C5B5Ch case   12:*/		return 0x820C5B60;
		  /* 820C5B60h */ case   13:  		/* subf R11, R6, R25 */
		/* 820C5B60h case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R25);
		/* 820C5B60h case   13:*/		return 0x820C5B64;
		  /* 820C5B64h */ case   14:  		/* lfsx FR0, <#[R11 + R10]> */
		/* 820C5B64h case   14:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C5B64h case   14:*/		return 0x820C5B68;
		  /* 820C5B68h */ case   15:  		/* fctiwz FR0, FR0 */
		/* 820C5B68h case   15:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 820C5B68h case   15:*/		return 0x820C5B6C;
		  /* 820C5B6Ch */ case   16:  		/* stfiwx FR0, <#[R10]> */
		/* 820C5B6Ch case   16:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C5B6Ch case   16:*/		return 0x820C5B70;
		  /* 820C5B70h */ case   17:  		/* addi R10, R10, 4 */
		/* 820C5B70h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C5B70h case   17:*/		return 0x820C5B74;
		  /* 820C5B74h */ case   18:  		/* bc 16, CR0_LT, -16 */
		/* 820C5B74h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C5B64;  }
		/* 820C5B74h case   18:*/		return 0x820C5B78;
		  /* 820C5B78h */ case   19:  		/* b 64 */
		/* 820C5B78h case   19:*/		return 0x820C5BB8;
		/* 820C5B78h case   19:*/		return 0x820C5B7C;
	}
	return 0x820C5B7C;
} // Block from 820C5B2Ch-820C5B7Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C5B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5B7C);
		  /* 820C5B7Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C5B7Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C5B7Ch case    0:*/		return 0x820C5B80;
		  /* 820C5B80h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 820C5B80h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C5BB8;  }
		/* 820C5B80h case    1:*/		return 0x820C5B84;
		  /* 820C5B84h */ case    2:  		/* mtspr CTR, R11 */
		/* 820C5B84h case    2:*/		regs.CTR = regs.R11;
		/* 820C5B84h case    2:*/		return 0x820C5B88;
		  /* 820C5B88h */ case    3:  		/* lis R11, -32256 */
		/* 820C5B88h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820C5B88h case    3:*/		return 0x820C5B8C;
		  /* 820C5B8Ch */ case    4:  		/* mr R10, R6 */
		/* 820C5B8Ch case    4:*/		regs.R10 = regs.R6;
		/* 820C5B8Ch case    4:*/		return 0x820C5B90;
		  /* 820C5B90h */ case    5:  		/* subf R9, R6, R25 */
		/* 820C5B90h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R25);
		/* 820C5B90h case    5:*/		return 0x820C5B94;
		  /* 820C5B94h */ case    6:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 820C5B94h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 820C5B94h case    6:*/		return 0x820C5B98;
		  /* 820C5B98h */ case    7:  		/* lfsx FR13, <#[R10 + R9]> */
		/* 820C5B98h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820C5B98h case    7:*/		return 0x820C5B9C;
		  /* 820C5B9Ch */ case    8:  		/* li R11, 1 */
		/* 820C5B9Ch case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820C5B9Ch case    8:*/		return 0x820C5BA0;
		  /* 820C5BA0h */ case    9:  		/* fcmpu CR6, FR13, FR0 */
		/* 820C5BA0h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820C5BA0h case    9:*/		return 0x820C5BA4;
		  /* 820C5BA4h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 820C5BA4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820C5BAC;  }
		/* 820C5BA4h case   10:*/		return 0x820C5BA8;
		  /* 820C5BA8h */ case   11:  		/* li R11, 0 */
		/* 820C5BA8h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C5BA8h case   11:*/		return 0x820C5BAC;
	}
	return 0x820C5BAC;
} // Block from 820C5B7Ch-820C5BACh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C5BACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5BAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5BAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5BAC);
		  /* 820C5BACh */ case    0:  		/* stw R11, <#[R10]> */
		/* 820C5BACh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820C5BACh case    0:*/		return 0x820C5BB0;
		  /* 820C5BB0h */ case    1:  		/* addi R10, R10, 4 */
		/* 820C5BB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C5BB0h case    1:*/		return 0x820C5BB4;
		  /* 820C5BB4h */ case    2:  		/* bc 16, CR0_LT, -28 */
		/* 820C5BB4h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C5B98;  }
		/* 820C5BB4h case    2:*/		return 0x820C5BB8;
	}
	return 0x820C5BB8;
} // Block from 820C5BACh-820C5BB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5BB8);
		  /* 820C5BB8h */ case    0:  		/* mr R25, R6 */
		/* 820C5BB8h case    0:*/		regs.R25 = regs.R6;
		/* 820C5BB8h case    0:*/		return 0x820C5BBC;
	}
	return 0x820C5BBC;
} // Block from 820C5BB8h-820C5BBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C5BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5BBC);
		  /* 820C5BBCh */ case    0:  		/* lhz R9, <#[R24 + 8]> */
		/* 820C5BBCh case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 820C5BBCh case    0:*/		return 0x820C5BC0;
		  /* 820C5BC0h */ case    1:  		/* cmplwi CR0, R9, 0 */
		/* 820C5BC0h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820C5BC0h case    1:*/		return 0x820C5BC4;
		  /* 820C5BC4h */ case    2:  		/* bc 12, CR0_EQ, 216 */
		/* 820C5BC4h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C5C9C;  }
		/* 820C5BC4h case    2:*/		return 0x820C5BC8;
		  /* 820C5BC8h */ case    3:  		/* lhz R11, <#[R31]> */
		/* 820C5BC8h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C5BC8h case    3:*/		return 0x820C5BCC;
		  /* 820C5BCCh */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C5BCCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C5BCCh case    4:*/		return 0x820C5BD0;
		  /* 820C5BD0h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820C5BD0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C5BE0;  }
		/* 820C5BD0h case    5:*/		return 0x820C5BD4;
		  /* 820C5BD4h */ case    6:  		/* lhz R11, <#[R31 + 6]> */
		/* 820C5BD4h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5BD4h case    6:*/		return 0x820C5BD8;
		  /* 820C5BD8h */ case    7:  		/* lhz R10, <#[R31 + 4]> */
		/* 820C5BD8h case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5BD8h case    7:*/		return 0x820C5BDC;
		  /* 820C5BDCh */ case    8:  		/* b 12 */
		/* 820C5BDCh case    8:*/		return 0x820C5BE8;
		/* 820C5BDCh case    8:*/		return 0x820C5BE0;
	}
	return 0x820C5BE0;
} // Block from 820C5BBCh-820C5BE0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C5BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5BE0);
		  /* 820C5BE0h */ case    0:  		/* lhz R11, <#[R31 + 4]> */
		/* 820C5BE0h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820C5BE0h case    0:*/		return 0x820C5BE4;
		  /* 820C5BE4h */ case    1:  		/* lhz R10, <#[R31 + 6]> */
		/* 820C5BE4h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000006) );
		/* 820C5BE4h case    1:*/		return 0x820C5BE8;
	}
	return 0x820C5BE8;
} // Block from 820C5BE0h-820C5BE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5BE8);
		  /* 820C5BE8h */ case    0:  		/* rlwinm. R8, R11, 0, 30, 31 */
		/* 820C5BE8h case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R8,regs.R11);
		/* 820C5BE8h case    0:*/		return 0x820C5BEC;
		  /* 820C5BECh */ case    1:  		/* bc 12, CR0_EQ, 176 */
		/* 820C5BECh case    1:*/		if ( regs.CR[0].eq ) { return 0x820C5C9C;  }
		/* 820C5BECh case    1:*/		return 0x820C5BF0;
		  /* 820C5BF0h */ case    2:  		/* cmplwi CR6, R9, 1 */
		/* 820C5BF0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820C5BF0h case    2:*/		return 0x820C5BF4;
		  /* 820C5BF4h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820C5BF4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C5C04;  }
		/* 820C5BF4h case    3:*/		return 0x820C5BF8;
		  /* 820C5BF8h */ case    4:  		/* lis R9, -32255 */
		/* 820C5BF8h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C5BF8h case    4:*/		return 0x820C5BFC;
		  /* 820C5BFCh */ case    5:  		/* addi R4, R9, 10344 */
		/* 820C5BFCh case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2868);
		/* 820C5BFCh case    5:*/		return 0x820C5C00;
		  /* 820C5C00h */ case    6:  		/* b 12 */
		/* 820C5C00h case    6:*/		return 0x820C5C0C;
		/* 820C5C00h case    6:*/		return 0x820C5C04;
	}
	return 0x820C5C04;
} // Block from 820C5BE8h-820C5C04h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C5C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5C04);
		  /* 820C5C04h */ case    0:  		/* lis R9, -32255 */
		/* 820C5C04h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C5C04h case    0:*/		return 0x820C5C08;
		  /* 820C5C08h */ case    1:  		/* addi R4, R9, 10360 */
		/* 820C5C08h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2878);
		/* 820C5C08h case    1:*/		return 0x820C5C0C;
	}
	return 0x820C5C0C;
} // Block from 820C5C04h-820C5C0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5C0C);
		  /* 820C5C0Ch */ case    0:  		/* addi R9, R11, 3 */
		/* 820C5C0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 820C5C0Ch case    0:*/		return 0x820C5C10;
		  /* 820C5C10h */ case    1:  		/* mullw. R8, R10, R3 */
		/* 820C5C10h case    1:*/		cpu::op::mullw<1>(regs,&regs.R8,regs.R10,regs.R3);
		/* 820C5C10h case    1:*/		return 0x820C5C14;
		  /* 820C5C14h */ case    2:  		/* rlwinm R7, R9, 0, 0, 29 */
		/* 820C5C14h case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R7,regs.R9);
		/* 820C5C14h case    2:*/		return 0x820C5C18;
		  /* 820C5C18h */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 820C5C18h case    3:*/		if ( regs.CR[0].eq ) { return 0x820C5C98;  }
		/* 820C5C18h case    3:*/		return 0x820C5C1C;
		  /* 820C5C1Ch */ case    4:  		/* mullw R9, R8, R7 */
		/* 820C5C1Ch case    4:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R7);
		/* 820C5C1Ch case    4:*/		return 0x820C5C20;
		  /* 820C5C20h */ case    5:  		/* mullw R5, R8, R11 */
		/* 820C5C20h case    5:*/		cpu::op::mullw<0>(regs,&regs.R5,regs.R8,regs.R11);
		/* 820C5C20h case    5:*/		return 0x820C5C24;
		  /* 820C5C24h */ case    6:  		/* addi R8, R8, -1 */
		/* 820C5C24h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820C5C24h case    6:*/		return 0x820C5C28;
		  /* 820C5C28h */ case    7:  		/* subf R5, R11, R5 */
		/* 820C5C28h case    7:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 820C5C28h case    7:*/		return 0x820C5C2C;
		  /* 820C5C2Ch */ case    8:  		/* subf R9, R7, R9 */
		/* 820C5C2Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820C5C2Ch case    8:*/		return 0x820C5C30;
		  /* 820C5C30h */ case    9:  		/* mr R10, R7 */
		/* 820C5C30h case    9:*/		regs.R10 = regs.R7;
		/* 820C5C30h case    9:*/		return 0x820C5C34;
		  /* 820C5C34h */ case   10:  		/* cmplw CR6, R7, R11 */
		/* 820C5C34h case   10:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C5C34h case   10:*/		return 0x820C5C38;
		  /* 820C5C38h */ case   11:  		/* bc 4, CR6_GT, 40 */
		/* 820C5C38h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820C5C60;  }
		/* 820C5C38h case   11:*/		return 0x820C5C3C;
		  /* 820C5C3Ch */ case   12:  		/* subf R31, R11, R7 */
		/* 820C5C3Ch case   12:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R7);
		/* 820C5C3Ch case   12:*/		return 0x820C5C40;
		  /* 820C5C40h */ case   13:  		/* mtspr CTR, R31 */
		/* 820C5C40h case   13:*/		regs.CTR = regs.R31;
		/* 820C5C40h case   13:*/		return 0x820C5C44;
		  /* 820C5C44h */ case   14:  		/* addi R10, R10, -1 */
		/* 820C5C44h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C5C44h case   14:*/		return 0x820C5C48;
		  /* 820C5C48h */ case   15:  		/* rlwinm R31, R10, 2, 28, 29 */
		/* 820C5C48h case   15:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R31,regs.R10);
		/* 820C5C48h case   15:*/		return 0x820C5C4C;
		  /* 820C5C4Ch */ case   16:  		/* add R30, R9, R10 */
		/* 820C5C4Ch case   16:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R10);
		/* 820C5C4Ch case   16:*/		return 0x820C5C50;
	}
	return 0x820C5C50;
} // Block from 820C5C0Ch-820C5C50h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C5C50h
// Function '?Set@?$SetTyped@$0A@$00$00$00$0A@@D3DXShader@@SAJPAVCConstant@2@PBX1II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5C50);
		  /* 820C5C50h */ case    0:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C5C50h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C5C50h case    0:*/		return 0x820C5C54;
		  /* 820C5C54h */ case    1:  		/* lwzx R31, <#[R31 + R4]> */
		/* 820C5C54h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R4 + 0x00000000) );
		/* 820C5C54h case    1:*/		return 0x820C5C58;
		  /* 820C5C58h */ case    2:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C5C58h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C5C58h case    2:*/		return 0x820C5C5C;
		  /* 820C5C5Ch */ case    3:  		/* bc 16, CR0_LT, -24 */
		/* 820C5C5Ch case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C5C44;  }
		/* 820C5C5Ch case    3:*/		return 0x820C5C60;
	}
	return 0x820C5C60;
} // Block from 820C5C50h-820C5C60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5C60);
		  /* 820C5C60h */ case    0:  		/* mr R10, R11 */
		/* 820C5C60h case    0:*/		regs.R10 = regs.R11;
		/* 820C5C60h case    0:*/		return 0x820C5C64;
		  /* 820C5C64h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C5C64h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C5C64h case    1:*/		return 0x820C5C68;
		  /* 820C5C68h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820C5C68h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5C90;  }
		/* 820C5C68h case    2:*/		return 0x820C5C6C;
		  /* 820C5C6Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 820C5C6Ch case    3:*/		regs.CTR = regs.R11;
		/* 820C5C6Ch case    3:*/		return 0x820C5C70;
		  /* 820C5C70h */ case    4:  		/* addi R10, R10, -1 */
		/* 820C5C70h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C5C70h case    4:*/		return 0x820C5C74;
		  /* 820C5C74h */ case    5:  		/* add R31, R5, R10 */
		/* 820C5C74h case    5:*/		cpu::op::add<0>(regs,&regs.R31,regs.R5,regs.R10);
		/* 820C5C74h case    5:*/		return 0x820C5C78;
		  /* 820C5C78h */ case    6:  		/* add R30, R9, R10 */
		/* 820C5C78h case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R10);
		/* 820C5C78h case    6:*/		return 0x820C5C7C;
		  /* 820C5C7Ch */ case    7:  		/* rlwinm R31, R31, 2, 0, 29 */
		/* 820C5C7Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R31);
		/* 820C5C7Ch case    7:*/		return 0x820C5C80;
		  /* 820C5C80h */ case    8:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C5C80h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C5C80h case    8:*/		return 0x820C5C84;
		  /* 820C5C84h */ case    9:  		/* lwzx R31, <#[R31 + R25]> */
		/* 820C5C84h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R25 + 0x00000000) );
		/* 820C5C84h case    9:*/		return 0x820C5C88;
		  /* 820C5C88h */ case   10:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C5C88h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C5C88h case   10:*/		return 0x820C5C8C;
		  /* 820C5C8Ch */ case   11:  		/* bc 16, CR0_LT, -28 */
		/* 820C5C8Ch case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C5C70;  }
		/* 820C5C8Ch case   11:*/		return 0x820C5C90;
	}
	return 0x820C5C90;
} // Block from 820C5C60h-820C5C90h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C5C90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5C90);
		  /* 820C5C90h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820C5C90h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C5C90h case    0:*/		return 0x820C5C94;
		  /* 820C5C94h */ case    1:  		/* bc 4, CR6_EQ, -112 */
		/* 820C5C94h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C5C24;  }
		/* 820C5C94h case    1:*/		return 0x820C5C98;
	}
	return 0x820C5C98;
} // Block from 820C5C90h-820C5C98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5C98);
		  /* 820C5C98h */ case    0:  		/* mr R25, R6 */
		/* 820C5C98h case    0:*/		regs.R25 = regs.R6;
		/* 820C5C98h case    0:*/		return 0x820C5C9C;
	}
	return 0x820C5C9C;
} // Block from 820C5C98h-820C5C9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C5C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5C9C);
		  /* 820C5C9Ch */ case    0:  		/* lwz R10, <#[R24 + 44]> */
		/* 820C5C9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000002C) );
		/* 820C5C9Ch case    0:*/		return 0x820C5CA0;
		  /* 820C5CA0h */ case    1:  		/* lhz R11, <#[R24 + 12]> */
		/* 820C5CA0h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820C5CA0h case    1:*/		return 0x820C5CA4;
		  /* 820C5CA4h */ case    2:  		/* mullw R7, R10, R3 */
		/* 820C5CA4h case    2:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R3);
		/* 820C5CA4h case    2:*/		return 0x820C5CA8;
		  /* 820C5CA8h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820C5CA8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C5CA8h case    3:*/		return 0x820C5CAC;
		  /* 820C5CACh */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 820C5CACh case    4:*/		if ( !regs.CR[6].gt ) { return 0x820C5CB4;  }
		/* 820C5CACh case    4:*/		return 0x820C5CB0;
		  /* 820C5CB0h */ case    5:  		/* mr R7, R11 */
		/* 820C5CB0h case    5:*/		regs.R7 = regs.R11;
		/* 820C5CB0h case    5:*/		return 0x820C5CB4;
	}
	return 0x820C5CB4;
} // Block from 820C5C9Ch-820C5CB4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C5CB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5CB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5CB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5CB4);
		  /* 820C5CB4h */ case    0:  		/* lwz R10, <#[R24 + 28]> */
		/* 820C5CB4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 820C5CB4h case    0:*/		return 0x820C5CB8;
		  /* 820C5CB8h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C5CB8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C5CB8h case    1:*/		return 0x820C5CBC;
		  /* 820C5CBCh */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C5CBCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C5CCC;  }
		/* 820C5CBCh case    2:*/		return 0x820C5CC0;
		  /* 820C5CC0h */ case    3:  		/* lis R3, -32768 */
		/* 820C5CC0h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C5CC0h case    3:*/		return 0x820C5CC4;
		  /* 820C5CC4h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820C5CC4h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C5CC4h case    4:*/		return 0x820C5CC8;
		  /* 820C5CC8h */ case    5:  		/* b 36 */
		/* 820C5CC8h case    5:*/		return 0x820C5CEC;
		/* 820C5CC8h case    5:*/		return 0x820C5CCC;
	}
	return 0x820C5CCC;
} // Block from 820C5CB4h-820C5CCCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C5CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5CCC);
		  /* 820C5CCCh */ case    0:  		/* lhz R11, <#[R24 + 10]> */
		/* 820C5CCCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000A) );
		/* 820C5CCCh case    0:*/		return 0x820C5CD0;
		  /* 820C5CD0h */ case    1:  		/* mr R5, R25 */
		/* 820C5CD0h case    1:*/		regs.R5 = regs.R25;
		/* 820C5CD0h case    1:*/		return 0x820C5CD4;
		  /* 820C5CD4h */ case    2:  		/* mr R3, R23 */
		/* 820C5CD4h case    2:*/		regs.R3 = regs.R23;
		/* 820C5CD4h case    2:*/		return 0x820C5CD8;
		  /* 820C5CD8h */ case    3:  		/* mtspr CTR, R10 */
		/* 820C5CD8h case    3:*/		regs.CTR = regs.R10;
		/* 820C5CD8h case    3:*/		return 0x820C5CDC;
		  /* 820C5CDCh */ case    4:  		/* add R4, R11, R22 */
		/* 820C5CDCh case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R22);
		/* 820C5CDCh case    4:*/		return 0x820C5CE0;
		  /* 820C5CE0h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820C5CE0h case    5:*/		if ( 1 ) { regs.LR = 0x820C5CE4; return (uint32)regs.CTR; }
		/* 820C5CE0h case    5:*/		return 0x820C5CE4;
		  /* 820C5CE4h */ case    6:  		/* srawi R11, R3, 31 */
		/* 820C5CE4h case    6:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820C5CE4h case    6:*/		return 0x820C5CE8;
		  /* 820C5CE8h */ case    7:  		/* and R3, R11, R3 */
		/* 820C5CE8h case    7:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C5CE8h case    7:*/		return 0x820C5CEC;
	}
	return 0x820C5CEC;
} // Block from 820C5CCCh-820C5CECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C5CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5CEC);
		  /* 820C5CECh */ case    0:  		/* addi R1, R1, 176 */
		/* 820C5CECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820C5CECh case    0:*/		return 0x820C5CF0;
		  /* 820C5CF0h */ case    1:  		/* b -215648 */
		/* 820C5CF0h case    1:*/		return 0x82091290;
		/* 820C5CF0h case    1:*/		return 0x820C5CF4;
		  /* 820C5CF4h */ case    2:  		/* nop */
		/* 820C5CF4h case    2:*/		cpu::op::nop();
		/* 820C5CF4h case    2:*/		return 0x820C5CF8;
	}
	return 0x820C5CF8;
} // Block from 820C5CECh-820C5CF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5CF8);
		  /* 820C5CF8h */ case    0:  		/* mfspr R12, LR */
		/* 820C5CF8h case    0:*/		regs.R12 = regs.LR;
		/* 820C5CF8h case    0:*/		return 0x820C5CFC;
		  /* 820C5CFCh */ case    1:  		/* bl -215740 */
		/* 820C5CFCh case    1:*/		regs.LR = 0x820C5D00; return 0x82091240;
		/* 820C5CFCh case    1:*/		return 0x820C5D00;
		  /* 820C5D00h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820C5D00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820C5D00h case    2:*/		return 0x820C5D04;
		  /* 820C5D04h */ case    3:  		/* lwz R26, <#[R3 + 24]> */
		/* 820C5D04h case    3:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R3 + 0x00000018) );
		/* 820C5D04h case    3:*/		return 0x820C5D08;
		  /* 820C5D08h */ case    4:  		/* mr R11, R6 */
		/* 820C5D08h case    4:*/		regs.R11 = regs.R6;
		/* 820C5D08h case    4:*/		return 0x820C5D0C;
		  /* 820C5D0Ch */ case    5:  		/* lwz R6, <#[R3 + 32]> */
		/* 820C5D0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000020) );
		/* 820C5D0Ch case    5:*/		return 0x820C5D10;
		  /* 820C5D10h */ case    6:  		/* mr R24, R3 */
		/* 820C5D10h case    6:*/		regs.R24 = regs.R3;
		/* 820C5D10h case    6:*/		return 0x820C5D14;
		  /* 820C5D14h */ case    7:  		/* mr R23, R4 */
		/* 820C5D14h case    7:*/		regs.R23 = regs.R4;
		/* 820C5D14h case    7:*/		return 0x820C5D18;
		  /* 820C5D18h */ case    8:  		/* mr R22, R7 */
		/* 820C5D18h case    8:*/		regs.R22 = regs.R7;
		/* 820C5D18h case    8:*/		return 0x820C5D1C;
		  /* 820C5D1Ch */ case    9:  		/* mr R25, R5 */
		/* 820C5D1Ch case    9:*/		regs.R25 = regs.R5;
		/* 820C5D1Ch case    9:*/		return 0x820C5D20;
		  /* 820C5D20h */ case   10:  		/* lhz R10, <#[R26]> */
		/* 820C5D20h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 820C5D20h case   10:*/		return 0x820C5D24;
		  /* 820C5D24h */ case   11:  		/* cmplwi CR6, R10, 1 */
		/* 820C5D24h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C5D24h case   11:*/		return 0x820C5D28;
		  /* 820C5D28h */ case   12:  		/* bc 12, CR6_LT, 664 */
		/* 820C5D28h case   12:*/		if ( regs.CR[6].lt ) { return 0x820C5FC0;  }
		/* 820C5D28h case   12:*/		return 0x820C5D2C;
		  /* 820C5D2Ch */ case   13:  		/* bc 12, CR6_EQ, 532 */
		/* 820C5D2Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x820C5F40;  }
		/* 820C5D2Ch case   13:*/		return 0x820C5D30;
		  /* 820C5D30h */ case   14:  		/* cmplwi CR6, R10, 3 */
		/* 820C5D30h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C5D30h case   14:*/		return 0x820C5D34;
		  /* 820C5D34h */ case   15:  		/* bc 12, CR6_LT, 348 */
		/* 820C5D34h case   15:*/		if ( regs.CR[6].lt ) { return 0x820C5E90;  }
		/* 820C5D34h case   15:*/		return 0x820C5D38;
		  /* 820C5D38h */ case   16:  		/* bc 12, CR6_EQ, 180 */
		/* 820C5D38h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C5DEC;  }
		/* 820C5D38h case   16:*/		return 0x820C5D3C;
		  /* 820C5D3Ch */ case   17:  		/* cmplwi CR6, R10, 5 */
		/* 820C5D3Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000005);
		/* 820C5D3Ch case   17:*/		return 0x820C5D40;
		  /* 820C5D40h */ case   18:  		/* bc 12, CR6_EQ, 16 */
		/* 820C5D40h case   18:*/		if ( regs.CR[6].eq ) { return 0x820C5D50;  }
		/* 820C5D40h case   18:*/		return 0x820C5D44;
		  /* 820C5D44h */ case   19:  		/* lis R3, -32768 */
		/* 820C5D44h case   19:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C5D44h case   19:*/		return 0x820C5D48;
		  /* 820C5D48h */ case   20:  		/* ori R3, R3, 16385 */
		/* 820C5D48h case   20:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 820C5D48h case   20:*/		return 0x820C5D4C;
		  /* 820C5D4Ch */ case   21:  		/* b 1096 */
		/* 820C5D4Ch case   21:*/		return 0x820C6194;
		/* 820C5D4Ch case   21:*/		return 0x820C5D50;
	}
	return 0x820C5D50;
} // Block from 820C5CF8h-820C5D50h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C5D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5D50);
		  /* 820C5D50h */ case    0:  		/* lwz R10, <#[R24 + 52]> */
		/* 820C5D50h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000034) );
		/* 820C5D50h case    0:*/		return 0x820C5D54;
		  /* 820C5D54h */ case    1:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 820C5D54h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 820C5D54h case    1:*/		return 0x820C5D58;
		  /* 820C5D58h */ case    2:  		/* lhz R11, <#[R26 + 8]> */
		/* 820C5D58h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 820C5D58h case    2:*/		return 0x820C5D5C;
		  /* 820C5D5Ch */ case    3:  		/* divwu R28, R9, R10 */
		/* 820C5D5Ch case    3:*/		cpu::op::divwu<0>(regs,&regs.R28,regs.R9,regs.R10);
		/* 820C5D5Ch case    3:*/		return 0x820C5D60;
		  /* 820C5D60h */ case    4:  		/* twi 6, R10, 0 */
		/* 820C5D60h case    4:*/		cpu::op::tw<6>(regs, 0x820C5D60, regs.R10, 0x00000000);
		/* 820C5D60h case    4:*/		return 0x820C5D64;
		  /* 820C5D64h */ case    5:  		/* cmplw CR6, R28, R11 */
		/* 820C5D64h case    5:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820C5D64h case    5:*/		return 0x820C5D68;
		  /* 820C5D68h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 820C5D68h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820C5D70;  }
		/* 820C5D68h case    6:*/		return 0x820C5D6C;
		  /* 820C5D6Ch */ case    7:  		/* mr R28, R11 */
		/* 820C5D6Ch case    7:*/		regs.R28 = regs.R11;
		/* 820C5D6Ch case    7:*/		return 0x820C5D70;
	}
	return 0x820C5D70;
} // Block from 820C5D50h-820C5D70h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C5D70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5D70);
		  /* 820C5D70h */ case    0:  		/* li R27, 0 */
		/* 820C5D70h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820C5D70h case    0:*/		return 0x820C5D74;
		  /* 820C5D74h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 820C5D74h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C5D74h case    1:*/		return 0x820C5D78;
		  /* 820C5D78h */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 820C5D78h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5DE4;  }
		/* 820C5D78h case    2:*/		return 0x820C5D7C;
		  /* 820C5D7Ch */ case    3:  		/* lhz R11, <#[R26 + 10]> */
		/* 820C5D7Ch case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000000A) );
		/* 820C5D7Ch case    3:*/		return 0x820C5D80;
		  /* 820C5D80h */ case    4:  		/* li R29, 0 */
		/* 820C5D80h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C5D80h case    4:*/		return 0x820C5D84;
		  /* 820C5D84h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 820C5D84h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C5D84h case    5:*/		return 0x820C5D88;
		  /* 820C5D88h */ case    6:  		/* bc 12, CR0_EQ, 80 */
		/* 820C5D88h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C5DD8;  }
		/* 820C5D88h case    6:*/		return 0x820C5D8C;
		  /* 820C5D8Ch */ case    7:  		/* li R30, 0 */
		/* 820C5D8Ch case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C5D8Ch case    7:*/		return 0x820C5D90;
		  /* 820C5D90h */ case    8:  		/* lwz R11, <#[R24 + 56]> */
		/* 820C5D90h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 820C5D90h case    8:*/		return 0x820C5D94;
		  /* 820C5D94h */ case    9:  		/* mr R7, R22 */
		/* 820C5D94h case    9:*/		regs.R7 = regs.R22;
		/* 820C5D94h case    9:*/		return 0x820C5D98;
		  /* 820C5D98h */ case   10:  		/* mr R5, R25 */
		/* 820C5D98h case   10:*/		regs.R5 = regs.R25;
		/* 820C5D98h case   10:*/		return 0x820C5D9C;
		  /* 820C5D9Ch */ case   11:  		/* mr R4, R23 */
		/* 820C5D9Ch case   11:*/		regs.R4 = regs.R23;
		/* 820C5D9Ch case   11:*/		return 0x820C5DA0;
		  /* 820C5DA0h */ case   12:  		/* lwzx R31, <#[R30 + R11]> */
		/* 820C5DA0h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820C5DA0h case   12:*/		return 0x820C5DA4;
		  /* 820C5DA4h */ case   13:  		/* mr R3, R31 */
		/* 820C5DA4h case   13:*/		regs.R3 = regs.R31;
		/* 820C5DA4h case   13:*/		return 0x820C5DA8;
		  /* 820C5DA8h */ case   14:  		/* lwz R6, <#[R31 + 48]> */
		/* 820C5DA8h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000030) );
		/* 820C5DA8h case   14:*/		return 0x820C5DAC;
		  /* 820C5DACh */ case   15:  		/* bl -1100 */
		/* 820C5DACh case   15:*/		regs.LR = 0x820C5DB0; return 0x820C5960;
		/* 820C5DACh case   15:*/		return 0x820C5DB0;
		  /* 820C5DB0h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820C5DB0h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C5DB0h case   16:*/		return 0x820C5DB4;
		  /* 820C5DB4h */ case   17:  		/* bc 12, CR0_LT, 992 */
		/* 820C5DB4h case   17:*/		if ( regs.CR[0].lt ) { return 0x820C6194;  }
		/* 820C5DB4h case   17:*/		return 0x820C5DB8;
		  /* 820C5DB8h */ case   18:  		/* lwz R11, <#[R31 + 48]> */
		/* 820C5DB8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820C5DB8h case   18:*/		return 0x820C5DBC;
		  /* 820C5DBCh */ case   19:  		/* addi R29, R29, 1 */
		/* 820C5DBCh case   19:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820C5DBCh case   19:*/		return 0x820C5DC0;
		  /* 820C5DC0h */ case   20:  		/* lhz R10, <#[R26 + 10]> */
		/* 820C5DC0h case   20:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x0000000A) );
		/* 820C5DC0h case   20:*/		return 0x820C5DC4;
		  /* 820C5DC4h */ case   21:  		/* addi R30, R30, 4 */
		/* 820C5DC4h case   21:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C5DC4h case   21:*/		return 0x820C5DC8;
		  /* 820C5DC8h */ case   22:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C5DC8h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C5DC8h case   22:*/		return 0x820C5DCC;
		  /* 820C5DCCh */ case   23:  		/* cmplw CR6, R29, R10 */
		/* 820C5DCCh case   23:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 820C5DCCh case   23:*/		return 0x820C5DD0;
		  /* 820C5DD0h */ case   24:  		/* add R25, R11, R25 */
		/* 820C5DD0h case   24:*/		cpu::op::add<0>(regs,&regs.R25,regs.R11,regs.R25);
		/* 820C5DD0h case   24:*/		return 0x820C5DD4;
		  /* 820C5DD4h */ case   25:  		/* bc 12, CR6_LT, -68 */
		/* 820C5DD4h case   25:*/		if ( regs.CR[6].lt ) { return 0x820C5D90;  }
		/* 820C5DD4h case   25:*/		return 0x820C5DD8;
	}
	return 0x820C5DD8;
} // Block from 820C5D70h-820C5DD8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820C5DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5DD8);
		  /* 820C5DD8h */ case    0:  		/* addi R27, R27, 1 */
		/* 820C5DD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820C5DD8h case    0:*/		return 0x820C5DDC;
		  /* 820C5DDCh */ case    1:  		/* cmplw CR6, R27, R28 */
		/* 820C5DDCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R28);
		/* 820C5DDCh case    1:*/		return 0x820C5DE0;
		  /* 820C5DE0h */ case    2:  		/* bc 12, CR6_LT, -100 */
		/* 820C5DE0h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C5D7C;  }
		/* 820C5DE0h case    2:*/		return 0x820C5DE4;
	}
	return 0x820C5DE4;
} // Block from 820C5DD8h-820C5DE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5DE4);
		  /* 820C5DE4h */ case    0:  		/* li R3, 0 */
		/* 820C5DE4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C5DE4h case    0:*/		return 0x820C5DE8;
		  /* 820C5DE8h */ case    1:  		/* b 940 */
		/* 820C5DE8h case    1:*/		return 0x820C6194;
		/* 820C5DE8h case    1:*/		return 0x820C5DEC;
	}
	return 0x820C5DEC;
} // Block from 820C5DE4h-820C5DECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5DEC);
		  /* 820C5DECh */ case    0:  		/* lhz R9, <#[R26 + 6]> */
		/* 820C5DECh case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000006) );
		/* 820C5DECh case    0:*/		return 0x820C5DF0;
		  /* 820C5DF0h */ case    1:  		/* lhz R10, <#[R26 + 8]> */
		/* 820C5DF0h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 820C5DF0h case    1:*/		return 0x820C5DF4;
		  /* 820C5DF4h */ case    2:  		/* divwu R3, R11, R9 */
		/* 820C5DF4h case    2:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R11,regs.R9);
		/* 820C5DF4h case    2:*/		return 0x820C5DF8;
		  /* 820C5DF8h */ case    3:  		/* twi 6, R9, 0 */
		/* 820C5DF8h case    3:*/		cpu::op::tw<6>(regs, 0x820C5DF8, regs.R9, 0x00000000);
		/* 820C5DF8h case    3:*/		return 0x820C5DFC;
		  /* 820C5DFCh */ case    4:  		/* cmplw CR6, R3, R10 */
		/* 820C5DFCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C5DFCh case    4:*/		return 0x820C5E00;
		  /* 820C5E00h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 820C5E00h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820C5E08;  }
		/* 820C5E00h case    5:*/		return 0x820C5E04;
		  /* 820C5E04h */ case    6:  		/* mr R3, R10 */
		/* 820C5E04h case    6:*/		regs.R3 = regs.R10;
		/* 820C5E04h case    6:*/		return 0x820C5E08;
	}
	return 0x820C5E08;
} // Block from 820C5DECh-820C5E08h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C5E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5E08);
		  /* 820C5E08h */ case    0:  		/* li R7, 0 */
		/* 820C5E08h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C5E08h case    0:*/		return 0x820C5E0C;
		  /* 820C5E0Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C5E0Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C5E0Ch case    1:*/		return 0x820C5E10;
		  /* 820C5E10h */ case    2:  		/* bc 12, CR6_EQ, 424 */
		/* 820C5E10h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5FB8;  }
		/* 820C5E10h case    2:*/		return 0x820C5E14;
		  /* 820C5E14h */ case    3:  		/* addi R4, R6, -4 */
		/* 820C5E14h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R6,0xFFFFFFFC);
		/* 820C5E14h case    3:*/		return 0x820C5E18;
		  /* 820C5E18h */ case    4:  		/* li R8, 0 */
		/* 820C5E18h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C5E18h case    4:*/		return 0x820C5E1C;
		  /* 820C5E1Ch */ case    5:  		/* cmplwi CR6, R9, 0 */
		/* 820C5E1Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820C5E1Ch case    5:*/		return 0x820C5E20;
		  /* 820C5E20h */ case    6:  		/* bc 12, CR6_EQ, 96 */
		/* 820C5E20h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C5E80;  }
		/* 820C5E20h case    6:*/		return 0x820C5E24;
		  /* 820C5E24h */ case    7:  		/* lhz R10, <#[R26 + 4]> */
		/* 820C5E24h case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 820C5E24h case    7:*/		return 0x820C5E28;
		  /* 820C5E28h */ case    8:  		/* li R11, 0 */
		/* 820C5E28h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C5E28h case    8:*/		return 0x820C5E2C;
		  /* 820C5E2Ch */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 820C5E2Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C5E2Ch case    9:*/		return 0x820C5E30;
		  /* 820C5E30h */ case   10:  		/* bc 12, CR6_EQ, 64 */
		/* 820C5E30h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C5E70;  }
		/* 820C5E30h case   10:*/		return 0x820C5E34;
		  /* 820C5E34h */ case   11:  		/* cmplwi CR6, R8, 4 */
		/* 820C5E34h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000004);
		/* 820C5E34h case   11:*/		return 0x820C5E38;
		  /* 820C5E38h */ case   12:  		/* bc 4, CR6_GT, 12 */
		/* 820C5E38h case   12:*/		if ( !regs.CR[6].gt ) { return 0x820C5E44;  }
		/* 820C5E38h case   12:*/		return 0x820C5E3C;
		  /* 820C5E3Ch */ case   13:  		/* li R10, 0 */
		/* 820C5E3Ch case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C5E3Ch case   13:*/		return 0x820C5E40;
		  /* 820C5E40h */ case   14:  		/* b 28 */
		/* 820C5E40h case   14:*/		return 0x820C5E5C;
		/* 820C5E40h case   14:*/		return 0x820C5E44;
	}
	return 0x820C5E44;
} // Block from 820C5E08h-820C5E44h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C5E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5E44);
		  /* 820C5E44h */ case    0:  		/* mullw R10, R10, R7 */
		/* 820C5E44h case    0:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 820C5E44h case    0:*/		return 0x820C5E48;
		  /* 820C5E48h */ case    1:  		/* add R10, R10, R11 */
		/* 820C5E48h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C5E48h case    1:*/		return 0x820C5E4C;
		  /* 820C5E4Ch */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C5E4Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C5E4Ch case    2:*/		return 0x820C5E50;
		  /* 820C5E50h */ case    3:  		/* add R10, R10, R8 */
		/* 820C5E50h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820C5E50h case    3:*/		return 0x820C5E54;
		  /* 820C5E54h */ case    4:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C5E54h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C5E54h case    4:*/		return 0x820C5E58;
		  /* 820C5E58h */ case    5:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C5E58h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C5E58h case    5:*/		return 0x820C5E5C;
	}
	return 0x820C5E5C;
} // Block from 820C5E44h-820C5E5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C5E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5E5C);
		  /* 820C5E5Ch */ case    0:  		/* addi R11, R11, 1 */
		/* 820C5E5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C5E5Ch case    0:*/		return 0x820C5E60;
		  /* 820C5E60h */ case    1:  		/* stwu R10, <#[R4 + 4]> */
		/* 820C5E60h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 820C5E60h case    1:*/		return 0x820C5E64;
		  /* 820C5E64h */ case    2:  		/* lhz R10, <#[R26 + 4]> */
		/* 820C5E64h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 820C5E64h case    2:*/		return 0x820C5E68;
		  /* 820C5E68h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C5E68h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C5E68h case    3:*/		return 0x820C5E6C;
		  /* 820C5E6Ch */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 820C5E6Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820C5E34;  }
		/* 820C5E6Ch case    4:*/		return 0x820C5E70;
	}
	return 0x820C5E70;
} // Block from 820C5E5Ch-820C5E70h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C5E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5E70);
		  /* 820C5E70h */ case    0:  		/* lhz R9, <#[R26 + 6]> */
		/* 820C5E70h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000006) );
		/* 820C5E70h case    0:*/		return 0x820C5E74;
		  /* 820C5E74h */ case    1:  		/* addi R8, R8, 1 */
		/* 820C5E74h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820C5E74h case    1:*/		return 0x820C5E78;
		  /* 820C5E78h */ case    2:  		/* cmplw CR6, R8, R9 */
		/* 820C5E78h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 820C5E78h case    2:*/		return 0x820C5E7C;
		  /* 820C5E7Ch */ case    3:  		/* bc 12, CR6_LT, -84 */
		/* 820C5E7Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820C5E28;  }
		/* 820C5E7Ch case    3:*/		return 0x820C5E80;
	}
	return 0x820C5E80;
} // Block from 820C5E70h-820C5E80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5E80);
		  /* 820C5E80h */ case    0:  		/* addi R7, R7, 1 */
		/* 820C5E80h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820C5E80h case    0:*/		return 0x820C5E84;
		  /* 820C5E84h */ case    1:  		/* cmplw CR6, R7, R3 */
		/* 820C5E84h case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R3);
		/* 820C5E84h case    1:*/		return 0x820C5E88;
		  /* 820C5E88h */ case    2:  		/* bc 12, CR6_LT, -112 */
		/* 820C5E88h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C5E18;  }
		/* 820C5E88h case    2:*/		return 0x820C5E8C;
		  /* 820C5E8Ch */ case    3:  		/* b 300 */
		/* 820C5E8Ch case    3:*/		return 0x820C5FB8;
		/* 820C5E8Ch case    3:*/		return 0x820C5E90;
	}
	return 0x820C5E90;
} // Block from 820C5E80h-820C5E90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5E90);
		  /* 820C5E90h */ case    0:  		/* lhz R8, <#[R26 + 4]> */
		/* 820C5E90h case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000004) );
		/* 820C5E90h case    0:*/		return 0x820C5E94;
		  /* 820C5E94h */ case    1:  		/* lhz R10, <#[R26 + 8]> */
		/* 820C5E94h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 820C5E94h case    1:*/		return 0x820C5E98;
		  /* 820C5E98h */ case    2:  		/* divwu R3, R11, R8 */
		/* 820C5E98h case    2:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R11,regs.R8);
		/* 820C5E98h case    2:*/		return 0x820C5E9C;
		  /* 820C5E9Ch */ case    3:  		/* twi 6, R8, 0 */
		/* 820C5E9Ch case    3:*/		cpu::op::tw<6>(regs, 0x820C5E9C, regs.R8, 0x00000000);
		/* 820C5E9Ch case    3:*/		return 0x820C5EA0;
		  /* 820C5EA0h */ case    4:  		/* cmplw CR6, R3, R10 */
		/* 820C5EA0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C5EA0h case    4:*/		return 0x820C5EA4;
		  /* 820C5EA4h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 820C5EA4h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820C5EAC;  }
		/* 820C5EA4h case    5:*/		return 0x820C5EA8;
		  /* 820C5EA8h */ case    6:  		/* mr R3, R10 */
		/* 820C5EA8h case    6:*/		regs.R3 = regs.R10;
		/* 820C5EA8h case    6:*/		return 0x820C5EAC;
	}
	return 0x820C5EAC;
} // Block from 820C5E90h-820C5EACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C5EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5EAC);
		  /* 820C5EACh */ case    0:  		/* lhz R10, <#[R26 + 6]> */
		/* 820C5EACh case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000006) );
		/* 820C5EACh case    0:*/		return 0x820C5EB0;
		  /* 820C5EB0h */ case    1:  		/* cmplwi CR6, R10, 4 */
		/* 820C5EB0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820C5EB0h case    1:*/		return 0x820C5EB4;
		  /* 820C5EB4h */ case    2:  		/* bc 12, CR6_EQ, 288 */
		/* 820C5EB4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5FD4;  }
		/* 820C5EB4h case    2:*/		return 0x820C5EB8;
		  /* 820C5EB8h */ case    3:  		/* li R7, 0 */
		/* 820C5EB8h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C5EB8h case    3:*/		return 0x820C5EBC;
		  /* 820C5EBCh */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820C5EBCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C5EBCh case    4:*/		return 0x820C5EC0;
		  /* 820C5EC0h */ case    5:  		/* bc 12, CR6_EQ, 248 */
		/* 820C5EC0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C5FB8;  }
		/* 820C5EC0h case    5:*/		return 0x820C5EC4;
		  /* 820C5EC4h */ case    6:  		/* addi R4, R6, -4 */
		/* 820C5EC4h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R6,0xFFFFFFFC);
		/* 820C5EC4h case    6:*/		return 0x820C5EC8;
		  /* 820C5EC8h */ case    7:  		/* li R9, 0 */
		/* 820C5EC8h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C5EC8h case    7:*/		return 0x820C5ECC;
		  /* 820C5ECCh */ case    8:  		/* cmplwi CR6, R8, 0 */
		/* 820C5ECCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C5ECCh case    8:*/		return 0x820C5ED0;
		  /* 820C5ED0h */ case    9:  		/* bc 12, CR6_EQ, 96 */
		/* 820C5ED0h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C5F30;  }
		/* 820C5ED0h case    9:*/		return 0x820C5ED4;
		  /* 820C5ED4h */ case   10:  		/* li R11, 0 */
		/* 820C5ED4h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C5ED4h case   10:*/		return 0x820C5ED8;
		  /* 820C5ED8h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 820C5ED8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C5ED8h case   11:*/		return 0x820C5EDC;
		  /* 820C5EDCh */ case   12:  		/* bc 12, CR6_EQ, 68 */
		/* 820C5EDCh case   12:*/		if ( regs.CR[6].eq ) { return 0x820C5F20;  }
		/* 820C5EDCh case   12:*/		return 0x820C5EE0;
		  /* 820C5EE0h */ case   13:  		/* cmplwi CR6, R11, 4 */
		/* 820C5EE0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C5EE0h case   13:*/		return 0x820C5EE4;
		  /* 820C5EE4h */ case   14:  		/* bc 4, CR6_GT, 12 */
		/* 820C5EE4h case   14:*/		if ( !regs.CR[6].gt ) { return 0x820C5EF0;  }
		/* 820C5EE4h case   14:*/		return 0x820C5EE8;
		  /* 820C5EE8h */ case   15:  		/* li R10, 0 */
		/* 820C5EE8h case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C5EE8h case   15:*/		return 0x820C5EEC;
		  /* 820C5EECh */ case   16:  		/* b 32 */
		/* 820C5EECh case   16:*/		return 0x820C5F0C;
		/* 820C5EECh case   16:*/		return 0x820C5EF0;
	}
	return 0x820C5EF0;
} // Block from 820C5EACh-820C5EF0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C5EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5EF0);
		  /* 820C5EF0h */ case    0:  		/* lhz R10, <#[R26 + 4]> */
		/* 820C5EF0h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 820C5EF0h case    0:*/		return 0x820C5EF4;
		  /* 820C5EF4h */ case    1:  		/* mullw R10, R10, R7 */
		/* 820C5EF4h case    1:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 820C5EF4h case    1:*/		return 0x820C5EF8;
		  /* 820C5EF8h */ case    2:  		/* add R10, R10, R9 */
		/* 820C5EF8h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820C5EF8h case    2:*/		return 0x820C5EFC;
		  /* 820C5EFCh */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C5EFCh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C5EFCh case    3:*/		return 0x820C5F00;
		  /* 820C5F00h */ case    4:  		/* add R10, R10, R11 */
		/* 820C5F00h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C5F00h case    4:*/		return 0x820C5F04;
		  /* 820C5F04h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C5F04h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C5F04h case    5:*/		return 0x820C5F08;
		  /* 820C5F08h */ case    6:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C5F08h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C5F08h case    6:*/		return 0x820C5F0C;
	}
	return 0x820C5F0C;
} // Block from 820C5EF0h-820C5F0Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C5F0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5F0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5F0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5F0C);
		  /* 820C5F0Ch */ case    0:  		/* stwu R10, <#[R4 + 4]> */
		/* 820C5F0Ch case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000004) );
		regs.R4 = (uint32)(regs.R4 + 0x00000004);
		/* 820C5F0Ch case    0:*/		return 0x820C5F10;
		  /* 820C5F10h */ case    1:  		/* addi R11, R11, 1 */
		/* 820C5F10h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C5F10h case    1:*/		return 0x820C5F14;
		  /* 820C5F14h */ case    2:  		/* lhz R10, <#[R26 + 6]> */
		/* 820C5F14h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000006) );
		/* 820C5F14h case    2:*/		return 0x820C5F18;
		  /* 820C5F18h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C5F18h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C5F18h case    3:*/		return 0x820C5F1C;
		  /* 820C5F1Ch */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 820C5F1Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820C5EE0;  }
		/* 820C5F1Ch case    4:*/		return 0x820C5F20;
	}
	return 0x820C5F20;
} // Block from 820C5F0Ch-820C5F20h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C5F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5F20);
		  /* 820C5F20h */ case    0:  		/* lhz R8, <#[R26 + 4]> */
		/* 820C5F20h case    0:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000004) );
		/* 820C5F20h case    0:*/		return 0x820C5F24;
		  /* 820C5F24h */ case    1:  		/* addi R9, R9, 1 */
		/* 820C5F24h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C5F24h case    1:*/		return 0x820C5F28;
		  /* 820C5F28h */ case    2:  		/* cmplw CR6, R9, R8 */
		/* 820C5F28h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 820C5F28h case    2:*/		return 0x820C5F2C;
		  /* 820C5F2Ch */ case    3:  		/* bc 12, CR6_LT, -88 */
		/* 820C5F2Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x820C5ED4;  }
		/* 820C5F2Ch case    3:*/		return 0x820C5F30;
	}
	return 0x820C5F30;
} // Block from 820C5F20h-820C5F30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5F30);
		  /* 820C5F30h */ case    0:  		/* addi R7, R7, 1 */
		/* 820C5F30h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820C5F30h case    0:*/		return 0x820C5F34;
		  /* 820C5F34h */ case    1:  		/* cmplw CR6, R7, R3 */
		/* 820C5F34h case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R3);
		/* 820C5F34h case    1:*/		return 0x820C5F38;
		  /* 820C5F38h */ case    2:  		/* bc 12, CR6_LT, -112 */
		/* 820C5F38h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C5EC8;  }
		/* 820C5F38h case    2:*/		return 0x820C5F3C;
		  /* 820C5F3Ch */ case    3:  		/* b 124 */
		/* 820C5F3Ch case    3:*/		return 0x820C5FB8;
		/* 820C5F3Ch case    3:*/		return 0x820C5F40;
	}
	return 0x820C5F40;
} // Block from 820C5F30h-820C5F40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C5F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5F40);
		  /* 820C5F40h */ case    0:  		/* lhz R10, <#[R26 + 8]> */
		/* 820C5F40h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 820C5F40h case    0:*/		return 0x820C5F44;
		  /* 820C5F44h */ case    1:  		/* mr R3, R11 */
		/* 820C5F44h case    1:*/		regs.R3 = regs.R11;
		/* 820C5F44h case    1:*/		return 0x820C5F48;
		  /* 820C5F48h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C5F48h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C5F48h case    2:*/		return 0x820C5F4C;
		  /* 820C5F4Ch */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C5F4Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C5F54;  }
		/* 820C5F4Ch case    3:*/		return 0x820C5F50;
		  /* 820C5F50h */ case    4:  		/* mr R3, R10 */
		/* 820C5F50h case    4:*/		regs.R3 = regs.R10;
		/* 820C5F50h case    4:*/		return 0x820C5F54;
	}
	return 0x820C5F54;
} // Block from 820C5F40h-820C5F54h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C5F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5F54);
		  /* 820C5F54h */ case    0:  		/* lhz R10, <#[R26 + 6]> */
		/* 820C5F54h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000006) );
		/* 820C5F54h case    0:*/		return 0x820C5F58;
		  /* 820C5F58h */ case    1:  		/* cmplwi CR6, R10, 4 */
		/* 820C5F58h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820C5F58h case    1:*/		return 0x820C5F5C;
		  /* 820C5F5Ch */ case    2:  		/* bc 12, CR6_EQ, 120 */
		/* 820C5F5Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C5FD4;  }
		/* 820C5F5Ch case    2:*/		return 0x820C5F60;
		  /* 820C5F60h */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 820C5F60h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C5F60h case    3:*/		return 0x820C5F64;
		  /* 820C5F64h */ case    4:  		/* bc 12, CR6_EQ, 84 */
		/* 820C5F64h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C5FB8;  }
		/* 820C5F64h case    4:*/		return 0x820C5F68;
		  /* 820C5F68h */ case    5:  		/* li R8, 0 */
		/* 820C5F68h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C5F68h case    5:*/		return 0x820C5F6C;
		  /* 820C5F6Ch */ case    6:  		/* mtspr CTR, R3 */
		/* 820C5F6Ch case    6:*/		regs.CTR = regs.R3;
		/* 820C5F6Ch case    6:*/		return 0x820C5F70;
		  /* 820C5F70h */ case    7:  		/* addi R9, R6, -4 */
		/* 820C5F70h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0xFFFFFFFC);
		/* 820C5F70h case    7:*/		return 0x820C5F74;
		  /* 820C5F74h */ case    8:  		/* li R11, 0 */
		/* 820C5F74h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C5F74h case    8:*/		return 0x820C5F78;
		  /* 820C5F78h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 820C5F78h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C5F78h case    9:*/		return 0x820C5F7C;
		  /* 820C5F7Ch */ case   10:  		/* bc 12, CR6_EQ, 52 */
		/* 820C5F7Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x820C5FB0;  }
		/* 820C5F7Ch case   10:*/		return 0x820C5F80;
		  /* 820C5F80h */ case   11:  		/* cmplwi CR6, R11, 4 */
		/* 820C5F80h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C5F80h case   11:*/		return 0x820C5F84;
		  /* 820C5F84h */ case   12:  		/* bc 4, CR6_GT, 12 */
		/* 820C5F84h case   12:*/		if ( !regs.CR[6].gt ) { return 0x820C5F90;  }
		/* 820C5F84h case   12:*/		return 0x820C5F88;
		  /* 820C5F88h */ case   13:  		/* li R10, 0 */
		/* 820C5F88h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C5F88h case   13:*/		return 0x820C5F8C;
		  /* 820C5F8Ch */ case   14:  		/* b 16 */
		/* 820C5F8Ch case   14:*/		return 0x820C5F9C;
		/* 820C5F8Ch case   14:*/		return 0x820C5F90;
	}
	return 0x820C5F90;
} // Block from 820C5F54h-820C5F90h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C5F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5F90);
		  /* 820C5F90h */ case    0:  		/* add R10, R8, R11 */
		/* 820C5F90h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R11);
		/* 820C5F90h case    0:*/		return 0x820C5F94;
		  /* 820C5F94h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C5F94h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C5F94h case    1:*/		return 0x820C5F98;
		  /* 820C5F98h */ case    2:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C5F98h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C5F98h case    2:*/		return 0x820C5F9C;
	}
	return 0x820C5F9C;
} // Block from 820C5F90h-820C5F9Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C5F9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5F9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5F9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5F9C);
		  /* 820C5F9Ch */ case    0:  		/* addi R11, R11, 1 */
		/* 820C5F9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C5F9Ch case    0:*/		return 0x820C5FA0;
		  /* 820C5FA0h */ case    1:  		/* stwu R10, <#[R9 + 4]> */
		/* 820C5FA0h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C5FA0h case    1:*/		return 0x820C5FA4;
		  /* 820C5FA4h */ case    2:  		/* lhz R10, <#[R26 + 6]> */
		/* 820C5FA4h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000006) );
		/* 820C5FA4h case    2:*/		return 0x820C5FA8;
		  /* 820C5FA8h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C5FA8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C5FA8h case    3:*/		return 0x820C5FAC;
		  /* 820C5FACh */ case    4:  		/* bc 12, CR6_LT, -44 */
		/* 820C5FACh case    4:*/		if ( regs.CR[6].lt ) { return 0x820C5F80;  }
		/* 820C5FACh case    4:*/		return 0x820C5FB0;
	}
	return 0x820C5FB0;
} // Block from 820C5F9Ch-820C5FB0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C5FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5FB0);
		  /* 820C5FB0h */ case    0:  		/* addi R8, R8, 4 */
		/* 820C5FB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820C5FB0h case    0:*/		return 0x820C5FB4;
		  /* 820C5FB4h */ case    1:  		/* bc 16, CR0_LT, -64 */
		/* 820C5FB4h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C5F74;  }
		/* 820C5FB4h case    1:*/		return 0x820C5FB8;
	}
	return 0x820C5FB8;
} // Block from 820C5FB0h-820C5FB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5FB8);
		  /* 820C5FB8h */ case    0:  		/* mr R25, R6 */
		/* 820C5FB8h case    0:*/		regs.R25 = regs.R6;
		/* 820C5FB8h case    0:*/		return 0x820C5FBC;
		  /* 820C5FBCh */ case    1:  		/* b 24 */
		/* 820C5FBCh case    1:*/		return 0x820C5FD4;
		/* 820C5FBCh case    1:*/		return 0x820C5FC0;
	}
	return 0x820C5FC0;
} // Block from 820C5FB8h-820C5FC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C5FC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5FC0);
		  /* 820C5FC0h */ case    0:  		/* lhz R10, <#[R26 + 8]> */
		/* 820C5FC0h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 820C5FC0h case    0:*/		return 0x820C5FC4;
		  /* 820C5FC4h */ case    1:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820C5FC4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820C5FC4h case    1:*/		return 0x820C5FC8;
		  /* 820C5FC8h */ case    2:  		/* cmplw CR6, R3, R10 */
		/* 820C5FC8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C5FC8h case    2:*/		return 0x820C5FCC;
		  /* 820C5FCCh */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C5FCCh case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C5FD4;  }
		/* 820C5FCCh case    3:*/		return 0x820C5FD0;
		  /* 820C5FD0h */ case    4:  		/* mr R3, R10 */
		/* 820C5FD0h case    4:*/		regs.R3 = regs.R10;
		/* 820C5FD0h case    4:*/		return 0x820C5FD4;
	}
	return 0x820C5FD4;
} // Block from 820C5FC0h-820C5FD4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C5FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5FD4);
		  /* 820C5FD4h */ case    0:  		/* lhz R10, <#[R26 + 2]> */
		/* 820C5FD4h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000002) );
		/* 820C5FD4h case    0:*/		return 0x820C5FD8;
		  /* 820C5FD8h */ case    1:  		/* cmplwi CR6, R10, 3 */
		/* 820C5FD8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C5FD8h case    1:*/		return 0x820C5FDC;
		  /* 820C5FDCh */ case    2:  		/* bc 12, CR6_EQ, 136 */
		/* 820C5FDCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820C6064;  }
		/* 820C5FDCh case    2:*/		return 0x820C5FE0;
		  /* 820C5FE0h */ case    3:  		/* lwz R11, <#[R24 + 52]> */
		/* 820C5FE0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000034) );
		/* 820C5FE0h case    3:*/		return 0x820C5FE4;
		  /* 820C5FE4h */ case    4:  		/* cmplwi CR6, R10, 1 */
		/* 820C5FE4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C5FE4h case    4:*/		return 0x820C5FE8;
		  /* 820C5FE8h */ case    5:  		/* mullw R11, R11, R3 */
		/* 820C5FE8h case    5:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820C5FE8h case    5:*/		return 0x820C5FEC;
		  /* 820C5FECh */ case    6:  		/* bc 12, CR6_EQ, 56 */
		/* 820C5FECh case    6:*/		if ( regs.CR[6].eq ) { return 0x820C6024;  }
		/* 820C5FECh case    6:*/		return 0x820C5FF0;
		  /* 820C5FF0h */ case    7:  		/* cmplwi CR6, R10, 2 */
		/* 820C5FF0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820C5FF0h case    7:*/		return 0x820C5FF4;
		  /* 820C5FF4h */ case    8:  		/* bc 4, CR6_EQ, 108 */
		/* 820C5FF4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C6060;  }
		/* 820C5FF4h case    8:*/		return 0x820C5FF8;
	}
	return 0x820C5FF8;
} // Block from 820C5FD4h-820C5FF8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C5FF8h
// Function '?Set@?$SetTyped@$0A@$01$00$00$0A@@D3DXShader@@SAJPAVCConstant@2@PBX1II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C5FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C5FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C5FF8);
		  /* 820C5FF8h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C5FF8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C5FF8h case    0:*/		return 0x820C5FFC;
		  /* 820C5FFCh */ case    1:  		/* bc 12, CR6_EQ, 100 */
		/* 820C5FFCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820C6060;  }
		/* 820C5FFCh case    1:*/		return 0x820C6000;
		  /* 820C6000h */ case    2:  		/* mtspr CTR, R11 */
		/* 820C6000h case    2:*/		regs.CTR = regs.R11;
		/* 820C6000h case    2:*/		return 0x820C6004;
		  /* 820C6004h */ case    3:  		/* mr R10, R6 */
		/* 820C6004h case    3:*/		regs.R10 = regs.R6;
		/* 820C6004h case    3:*/		return 0x820C6008;
		  /* 820C6008h */ case    4:  		/* subf R11, R6, R25 */
		/* 820C6008h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R25);
		/* 820C6008h case    4:*/		return 0x820C600C;
		  /* 820C600Ch */ case    5:  		/* lfsx FR0, <#[R11 + R10]> */
		/* 820C600Ch case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C600Ch case    5:*/		return 0x820C6010;
		  /* 820C6010h */ case    6:  		/* fctiwz FR0, FR0 */
		/* 820C6010h case    6:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 820C6010h case    6:*/		return 0x820C6014;
		  /* 820C6014h */ case    7:  		/* stfiwx FR0, <#[R10]> */
		/* 820C6014h case    7:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C6014h case    7:*/		return 0x820C6018;
		  /* 820C6018h */ case    8:  		/* addi R10, R10, 4 */
		/* 820C6018h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C6018h case    8:*/		return 0x820C601C;
		  /* 820C601Ch */ case    9:  		/* bc 16, CR0_LT, -16 */
		/* 820C601Ch case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C600C;  }
		/* 820C601Ch case    9:*/		return 0x820C6020;
		  /* 820C6020h */ case   10:  		/* b 64 */
		/* 820C6020h case   10:*/		return 0x820C6060;
		/* 820C6020h case   10:*/		return 0x820C6024;
	}
	return 0x820C6024;
} // Block from 820C5FF8h-820C6024h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C6024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6024);
		  /* 820C6024h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C6024h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C6024h case    0:*/		return 0x820C6028;
		  /* 820C6028h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 820C6028h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C6060;  }
		/* 820C6028h case    1:*/		return 0x820C602C;
		  /* 820C602Ch */ case    2:  		/* mtspr CTR, R11 */
		/* 820C602Ch case    2:*/		regs.CTR = regs.R11;
		/* 820C602Ch case    2:*/		return 0x820C6030;
		  /* 820C6030h */ case    3:  		/* lis R11, -32256 */
		/* 820C6030h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820C6030h case    3:*/		return 0x820C6034;
		  /* 820C6034h */ case    4:  		/* mr R10, R6 */
		/* 820C6034h case    4:*/		regs.R10 = regs.R6;
		/* 820C6034h case    4:*/		return 0x820C6038;
		  /* 820C6038h */ case    5:  		/* subf R9, R6, R25 */
		/* 820C6038h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R25);
		/* 820C6038h case    5:*/		return 0x820C603C;
		  /* 820C603Ch */ case    6:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 820C603Ch case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 820C603Ch case    6:*/		return 0x820C6040;
		  /* 820C6040h */ case    7:  		/* lfsx FR13, <#[R10 + R9]> */
		/* 820C6040h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820C6040h case    7:*/		return 0x820C6044;
		  /* 820C6044h */ case    8:  		/* li R11, 1 */
		/* 820C6044h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820C6044h case    8:*/		return 0x820C6048;
		  /* 820C6048h */ case    9:  		/* fcmpu CR6, FR13, FR0 */
		/* 820C6048h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820C6048h case    9:*/		return 0x820C604C;
		  /* 820C604Ch */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 820C604Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x820C6054;  }
		/* 820C604Ch case   10:*/		return 0x820C6050;
		  /* 820C6050h */ case   11:  		/* li R11, 0 */
		/* 820C6050h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6050h case   11:*/		return 0x820C6054;
	}
	return 0x820C6054;
} // Block from 820C6024h-820C6054h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C6054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6054);
		  /* 820C6054h */ case    0:  		/* stw R11, <#[R10]> */
		/* 820C6054h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820C6054h case    0:*/		return 0x820C6058;
		  /* 820C6058h */ case    1:  		/* addi R10, R10, 4 */
		/* 820C6058h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C6058h case    1:*/		return 0x820C605C;
		  /* 820C605Ch */ case    2:  		/* bc 16, CR0_LT, -28 */
		/* 820C605Ch case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6040;  }
		/* 820C605Ch case    2:*/		return 0x820C6060;
	}
	return 0x820C6060;
} // Block from 820C6054h-820C6060h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C6060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6060);
		  /* 820C6060h */ case    0:  		/* mr R25, R6 */
		/* 820C6060h case    0:*/		regs.R25 = regs.R6;
		/* 820C6060h case    0:*/		return 0x820C6064;
	}
	return 0x820C6064;
} // Block from 820C6060h-820C6064h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C6064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6064);
		  /* 820C6064h */ case    0:  		/* lhz R9, <#[R24 + 8]> */
		/* 820C6064h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 820C6064h case    0:*/		return 0x820C6068;
		  /* 820C6068h */ case    1:  		/* cmplwi CR0, R9, 0 */
		/* 820C6068h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820C6068h case    1:*/		return 0x820C606C;
		  /* 820C606Ch */ case    2:  		/* bc 12, CR0_EQ, 216 */
		/* 820C606Ch case    2:*/		if ( regs.CR[0].eq ) { return 0x820C6144;  }
		/* 820C606Ch case    2:*/		return 0x820C6070;
		  /* 820C6070h */ case    3:  		/* lhz R11, <#[R26]> */
		/* 820C6070h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820C6070h case    3:*/		return 0x820C6074;
		  /* 820C6074h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C6074h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C6074h case    4:*/		return 0x820C6078;
		  /* 820C6078h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820C6078h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C6088;  }
		/* 820C6078h case    5:*/		return 0x820C607C;
		  /* 820C607Ch */ case    6:  		/* lhz R11, <#[R26 + 6]> */
		/* 820C607Ch case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000006) );
		/* 820C607Ch case    6:*/		return 0x820C6080;
		  /* 820C6080h */ case    7:  		/* lhz R10, <#[R26 + 4]> */
		/* 820C6080h case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 820C6080h case    7:*/		return 0x820C6084;
		  /* 820C6084h */ case    8:  		/* b 12 */
		/* 820C6084h case    8:*/		return 0x820C6090;
		/* 820C6084h case    8:*/		return 0x820C6088;
	}
	return 0x820C6088;
} // Block from 820C6064h-820C6088h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C6088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6088);
		  /* 820C6088h */ case    0:  		/* lhz R11, <#[R26 + 4]> */
		/* 820C6088h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 820C6088h case    0:*/		return 0x820C608C;
		  /* 820C608Ch */ case    1:  		/* lhz R10, <#[R26 + 6]> */
		/* 820C608Ch case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000006) );
		/* 820C608Ch case    1:*/		return 0x820C6090;
	}
	return 0x820C6090;
} // Block from 820C6088h-820C6090h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C6090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6090);
		  /* 820C6090h */ case    0:  		/* rlwinm. R8, R11, 0, 30, 31 */
		/* 820C6090h case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R8,regs.R11);
		/* 820C6090h case    0:*/		return 0x820C6094;
		  /* 820C6094h */ case    1:  		/* bc 12, CR0_EQ, 176 */
		/* 820C6094h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C6144;  }
		/* 820C6094h case    1:*/		return 0x820C6098;
		  /* 820C6098h */ case    2:  		/* cmplwi CR6, R9, 1 */
		/* 820C6098h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820C6098h case    2:*/		return 0x820C609C;
		  /* 820C609Ch */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820C609Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C60AC;  }
		/* 820C609Ch case    3:*/		return 0x820C60A0;
		  /* 820C60A0h */ case    4:  		/* lis R9, -32255 */
		/* 820C60A0h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C60A0h case    4:*/		return 0x820C60A4;
		  /* 820C60A4h */ case    5:  		/* addi R4, R9, 10344 */
		/* 820C60A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2868);
		/* 820C60A4h case    5:*/		return 0x820C60A8;
		  /* 820C60A8h */ case    6:  		/* b 12 */
		/* 820C60A8h case    6:*/		return 0x820C60B4;
		/* 820C60A8h case    6:*/		return 0x820C60AC;
	}
	return 0x820C60AC;
} // Block from 820C6090h-820C60ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C60ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C60AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C60AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C60AC);
		  /* 820C60ACh */ case    0:  		/* lis R9, -32255 */
		/* 820C60ACh case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C60ACh case    0:*/		return 0x820C60B0;
		  /* 820C60B0h */ case    1:  		/* addi R4, R9, 10360 */
		/* 820C60B0h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2878);
		/* 820C60B0h case    1:*/		return 0x820C60B4;
	}
	return 0x820C60B4;
} // Block from 820C60ACh-820C60B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C60B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C60B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C60B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C60B4);
		  /* 820C60B4h */ case    0:  		/* addi R9, R11, 3 */
		/* 820C60B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 820C60B4h case    0:*/		return 0x820C60B8;
		  /* 820C60B8h */ case    1:  		/* mullw. R8, R10, R3 */
		/* 820C60B8h case    1:*/		cpu::op::mullw<1>(regs,&regs.R8,regs.R10,regs.R3);
		/* 820C60B8h case    1:*/		return 0x820C60BC;
		  /* 820C60BCh */ case    2:  		/* rlwinm R7, R9, 0, 0, 29 */
		/* 820C60BCh case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R7,regs.R9);
		/* 820C60BCh case    2:*/		return 0x820C60C0;
		  /* 820C60C0h */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 820C60C0h case    3:*/		if ( regs.CR[0].eq ) { return 0x820C6140;  }
		/* 820C60C0h case    3:*/		return 0x820C60C4;
		  /* 820C60C4h */ case    4:  		/* mullw R9, R8, R7 */
		/* 820C60C4h case    4:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R7);
		/* 820C60C4h case    4:*/		return 0x820C60C8;
		  /* 820C60C8h */ case    5:  		/* mullw R5, R8, R11 */
		/* 820C60C8h case    5:*/		cpu::op::mullw<0>(regs,&regs.R5,regs.R8,regs.R11);
		/* 820C60C8h case    5:*/		return 0x820C60CC;
		  /* 820C60CCh */ case    6:  		/* addi R8, R8, -1 */
		/* 820C60CCh case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820C60CCh case    6:*/		return 0x820C60D0;
		  /* 820C60D0h */ case    7:  		/* subf R5, R11, R5 */
		/* 820C60D0h case    7:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 820C60D0h case    7:*/		return 0x820C60D4;
		  /* 820C60D4h */ case    8:  		/* subf R9, R7, R9 */
		/* 820C60D4h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820C60D4h case    8:*/		return 0x820C60D8;
		  /* 820C60D8h */ case    9:  		/* mr R10, R7 */
		/* 820C60D8h case    9:*/		regs.R10 = regs.R7;
		/* 820C60D8h case    9:*/		return 0x820C60DC;
		  /* 820C60DCh */ case   10:  		/* cmplw CR6, R7, R11 */
		/* 820C60DCh case   10:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C60DCh case   10:*/		return 0x820C60E0;
		  /* 820C60E0h */ case   11:  		/* bc 4, CR6_GT, 40 */
		/* 820C60E0h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820C6108;  }
		/* 820C60E0h case   11:*/		return 0x820C60E4;
		  /* 820C60E4h */ case   12:  		/* subf R31, R11, R7 */
		/* 820C60E4h case   12:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R7);
		/* 820C60E4h case   12:*/		return 0x820C60E8;
		  /* 820C60E8h */ case   13:  		/* mtspr CTR, R31 */
		/* 820C60E8h case   13:*/		regs.CTR = regs.R31;
		/* 820C60E8h case   13:*/		return 0x820C60EC;
		  /* 820C60ECh */ case   14:  		/* addi R10, R10, -1 */
		/* 820C60ECh case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C60ECh case   14:*/		return 0x820C60F0;
		  /* 820C60F0h */ case   15:  		/* rlwinm R31, R10, 2, 28, 29 */
		/* 820C60F0h case   15:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R31,regs.R10);
		/* 820C60F0h case   15:*/		return 0x820C60F4;
		  /* 820C60F4h */ case   16:  		/* add R30, R9, R10 */
		/* 820C60F4h case   16:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R10);
		/* 820C60F4h case   16:*/		return 0x820C60F8;
		  /* 820C60F8h */ case   17:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C60F8h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C60F8h case   17:*/		return 0x820C60FC;
		  /* 820C60FCh */ case   18:  		/* lwzx R31, <#[R31 + R4]> */
		/* 820C60FCh case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R4 + 0x00000000) );
		/* 820C60FCh case   18:*/		return 0x820C6100;
		  /* 820C6100h */ case   19:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C6100h case   19:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C6100h case   19:*/		return 0x820C6104;
		  /* 820C6104h */ case   20:  		/* bc 16, CR0_LT, -24 */
		/* 820C6104h case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C60EC;  }
		/* 820C6104h case   20:*/		return 0x820C6108;
	}
	return 0x820C6108;
} // Block from 820C60B4h-820C6108h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C6108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6108);
		  /* 820C6108h */ case    0:  		/* mr R10, R11 */
		/* 820C6108h case    0:*/		regs.R10 = regs.R11;
		/* 820C6108h case    0:*/		return 0x820C610C;
		  /* 820C610Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C610Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C610Ch case    1:*/		return 0x820C6110;
		  /* 820C6110h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820C6110h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C6138;  }
		/* 820C6110h case    2:*/		return 0x820C6114;
		  /* 820C6114h */ case    3:  		/* mtspr CTR, R11 */
		/* 820C6114h case    3:*/		regs.CTR = regs.R11;
		/* 820C6114h case    3:*/		return 0x820C6118;
		  /* 820C6118h */ case    4:  		/* addi R10, R10, -1 */
		/* 820C6118h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C6118h case    4:*/		return 0x820C611C;
		  /* 820C611Ch */ case    5:  		/* add R31, R5, R10 */
		/* 820C611Ch case    5:*/		cpu::op::add<0>(regs,&regs.R31,regs.R5,regs.R10);
		/* 820C611Ch case    5:*/		return 0x820C6120;
		  /* 820C6120h */ case    6:  		/* add R30, R9, R10 */
		/* 820C6120h case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R10);
		/* 820C6120h case    6:*/		return 0x820C6124;
		  /* 820C6124h */ case    7:  		/* rlwinm R31, R31, 2, 0, 29 */
		/* 820C6124h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R31);
		/* 820C6124h case    7:*/		return 0x820C6128;
		  /* 820C6128h */ case    8:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C6128h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C6128h case    8:*/		return 0x820C612C;
		  /* 820C612Ch */ case    9:  		/* lwzx R31, <#[R31 + R25]> */
		/* 820C612Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R25 + 0x00000000) );
		/* 820C612Ch case    9:*/		return 0x820C6130;
		  /* 820C6130h */ case   10:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C6130h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C6130h case   10:*/		return 0x820C6134;
		  /* 820C6134h */ case   11:  		/* bc 16, CR0_LT, -28 */
		/* 820C6134h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6118;  }
		/* 820C6134h case   11:*/		return 0x820C6138;
	}
	return 0x820C6138;
} // Block from 820C6108h-820C6138h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C6138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6138);
		  /* 820C6138h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820C6138h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C6138h case    0:*/		return 0x820C613C;
		  /* 820C613Ch */ case    1:  		/* bc 4, CR6_EQ, -112 */
		/* 820C613Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C60CC;  }
		/* 820C613Ch case    1:*/		return 0x820C6140;
	}
	return 0x820C6140;
} // Block from 820C6138h-820C6140h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C6140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6140);
		  /* 820C6140h */ case    0:  		/* mr R25, R6 */
		/* 820C6140h case    0:*/		regs.R25 = regs.R6;
		/* 820C6140h case    0:*/		return 0x820C6144;
	}
	return 0x820C6144;
} // Block from 820C6140h-820C6144h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C6144h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6144( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6144) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6144);
		  /* 820C6144h */ case    0:  		/* lwz R10, <#[R24 + 44]> */
		/* 820C6144h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000002C) );
		/* 820C6144h case    0:*/		return 0x820C6148;
		  /* 820C6148h */ case    1:  		/* lhz R11, <#[R24 + 12]> */
		/* 820C6148h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820C6148h case    1:*/		return 0x820C614C;
		  /* 820C614Ch */ case    2:  		/* mullw R7, R10, R3 */
		/* 820C614Ch case    2:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R3);
		/* 820C614Ch case    2:*/		return 0x820C6150;
		  /* 820C6150h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820C6150h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C6150h case    3:*/		return 0x820C6154;
		  /* 820C6154h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 820C6154h case    4:*/		if ( !regs.CR[6].gt ) { return 0x820C615C;  }
		/* 820C6154h case    4:*/		return 0x820C6158;
		  /* 820C6158h */ case    5:  		/* mr R7, R11 */
		/* 820C6158h case    5:*/		regs.R7 = regs.R11;
		/* 820C6158h case    5:*/		return 0x820C615C;
	}
	return 0x820C615C;
} // Block from 820C6144h-820C615Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C615Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C615C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C615C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C615C);
		  /* 820C615Ch */ case    0:  		/* lwz R10, <#[R24 + 28]> */
		/* 820C615Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 820C615Ch case    0:*/		return 0x820C6160;
		  /* 820C6160h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C6160h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C6160h case    1:*/		return 0x820C6164;
		  /* 820C6164h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C6164h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C6174;  }
		/* 820C6164h case    2:*/		return 0x820C6168;
		  /* 820C6168h */ case    3:  		/* lis R3, -32768 */
		/* 820C6168h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C6168h case    3:*/		return 0x820C616C;
		  /* 820C616Ch */ case    4:  		/* ori R3, R3, 16389 */
		/* 820C616Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C616Ch case    4:*/		return 0x820C6170;
		  /* 820C6170h */ case    5:  		/* b 36 */
		/* 820C6170h case    5:*/		return 0x820C6194;
		/* 820C6170h case    5:*/		return 0x820C6174;
	}
	return 0x820C6174;
} // Block from 820C615Ch-820C6174h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C6174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6174);
		  /* 820C6174h */ case    0:  		/* lhz R11, <#[R24 + 10]> */
		/* 820C6174h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000A) );
		/* 820C6174h case    0:*/		return 0x820C6178;
		  /* 820C6178h */ case    1:  		/* mr R5, R25 */
		/* 820C6178h case    1:*/		regs.R5 = regs.R25;
		/* 820C6178h case    1:*/		return 0x820C617C;
		  /* 820C617Ch */ case    2:  		/* mr R3, R23 */
		/* 820C617Ch case    2:*/		regs.R3 = regs.R23;
		/* 820C617Ch case    2:*/		return 0x820C6180;
		  /* 820C6180h */ case    3:  		/* mtspr CTR, R10 */
		/* 820C6180h case    3:*/		regs.CTR = regs.R10;
		/* 820C6180h case    3:*/		return 0x820C6184;
		  /* 820C6184h */ case    4:  		/* add R4, R11, R22 */
		/* 820C6184h case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R22);
		/* 820C6184h case    4:*/		return 0x820C6188;
		  /* 820C6188h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820C6188h case    5:*/		if ( 1 ) { regs.LR = 0x820C618C; return (uint32)regs.CTR; }
		/* 820C6188h case    5:*/		return 0x820C618C;
		  /* 820C618Ch */ case    6:  		/* srawi R11, R3, 31 */
		/* 820C618Ch case    6:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820C618Ch case    6:*/		return 0x820C6190;
		  /* 820C6190h */ case    7:  		/* and R3, R11, R3 */
		/* 820C6190h case    7:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C6190h case    7:*/		return 0x820C6194;
	}
	return 0x820C6194;
} // Block from 820C6174h-820C6194h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C6194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6194);
		  /* 820C6194h */ case    0:  		/* addi R1, R1, 176 */
		/* 820C6194h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820C6194h case    0:*/		return 0x820C6198;
		  /* 820C6198h */ case    1:  		/* b -216840 */
		/* 820C6198h case    1:*/		return 0x82091290;
		/* 820C6198h case    1:*/		return 0x820C619C;
		  /* 820C619Ch */ case    2:  		/* nop */
		/* 820C619Ch case    2:*/		cpu::op::nop();
		/* 820C619Ch case    2:*/		return 0x820C61A0;
	}
	return 0x820C61A0;
} // Block from 820C6194h-820C61A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C61A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C61A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C61A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C61A0);
		  /* 820C61A0h */ case    0:  		/* mfspr R12, LR */
		/* 820C61A0h case    0:*/		regs.R12 = regs.LR;
		/* 820C61A0h case    0:*/		return 0x820C61A4;
		  /* 820C61A4h */ case    1:  		/* bl -216932 */
		/* 820C61A4h case    1:*/		regs.LR = 0x820C61A8; return 0x82091240;
		/* 820C61A4h case    1:*/		return 0x820C61A8;
		  /* 820C61A8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820C61A8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820C61A8h case    2:*/		return 0x820C61AC;
		  /* 820C61ACh */ case    3:  		/* lwz R25, <#[R3 + 24]> */
		/* 820C61ACh case    3:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R3 + 0x00000018) );
		/* 820C61ACh case    3:*/		return 0x820C61B0;
		  /* 820C61B0h */ case    4:  		/* mr R11, R6 */
		/* 820C61B0h case    4:*/		regs.R11 = regs.R6;
		/* 820C61B0h case    4:*/		return 0x820C61B4;
		  /* 820C61B4h */ case    5:  		/* lwz R6, <#[R3 + 32]> */
		/* 820C61B4h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000020) );
		/* 820C61B4h case    5:*/		return 0x820C61B8;
		  /* 820C61B8h */ case    6:  		/* mr R24, R3 */
		/* 820C61B8h case    6:*/		regs.R24 = regs.R3;
		/* 820C61B8h case    6:*/		return 0x820C61BC;
		  /* 820C61BCh */ case    7:  		/* mr R23, R4 */
		/* 820C61BCh case    7:*/		regs.R23 = regs.R4;
		/* 820C61BCh case    7:*/		return 0x820C61C0;
		  /* 820C61C0h */ case    8:  		/* mr R22, R7 */
		/* 820C61C0h case    8:*/		regs.R22 = regs.R7;
		/* 820C61C0h case    8:*/		return 0x820C61C4;
		  /* 820C61C4h */ case    9:  		/* mr R26, R5 */
		/* 820C61C4h case    9:*/		regs.R26 = regs.R5;
		/* 820C61C4h case    9:*/		return 0x820C61C8;
		  /* 820C61C8h */ case   10:  		/* lhz R10, <#[R25]> */
		/* 820C61C8h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 820C61C8h case   10:*/		return 0x820C61CC;
		  /* 820C61CCh */ case   11:  		/* cmplwi CR6, R10, 1 */
		/* 820C61CCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C61CCh case   11:*/		return 0x820C61D0;
		  /* 820C61D0h */ case   12:  		/* bc 12, CR6_LT, 872 */
		/* 820C61D0h case   12:*/		if ( regs.CR[6].lt ) { return 0x820C6538;  }
		/* 820C61D0h case   12:*/		return 0x820C61D4;
		  /* 820C61D4h */ case   13:  		/* bc 12, CR6_EQ, 724 */
		/* 820C61D4h case   13:*/		if ( regs.CR[6].eq ) { return 0x820C64A8;  }
		/* 820C61D4h case   13:*/		return 0x820C61D8;
		  /* 820C61D8h */ case   14:  		/* cmplwi CR6, R10, 3 */
		/* 820C61D8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C61D8h case   14:*/		return 0x820C61DC;
		  /* 820C61DCh */ case   15:  		/* bc 12, CR6_LT, 532 */
		/* 820C61DCh case   15:*/		if ( regs.CR[6].lt ) { return 0x820C63F0;  }
		/* 820C61DCh case   15:*/		return 0x820C61E0;
		  /* 820C61E0h */ case   16:  		/* bc 12, CR6_EQ, 180 */
		/* 820C61E0h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C6294;  }
		/* 820C61E0h case   16:*/		return 0x820C61E4;
		  /* 820C61E4h */ case   17:  		/* cmplwi CR6, R10, 5 */
		/* 820C61E4h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000005);
		/* 820C61E4h case   17:*/		return 0x820C61E8;
		  /* 820C61E8h */ case   18:  		/* bc 12, CR6_EQ, 16 */
		/* 820C61E8h case   18:*/		if ( regs.CR[6].eq ) { return 0x820C61F8;  }
		/* 820C61E8h case   18:*/		return 0x820C61EC;
		  /* 820C61ECh */ case   19:  		/* lis R3, -32768 */
		/* 820C61ECh case   19:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C61ECh case   19:*/		return 0x820C61F0;
		  /* 820C61F0h */ case   20:  		/* ori R3, R3, 16385 */
		/* 820C61F0h case   20:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 820C61F0h case   20:*/		return 0x820C61F4;
		  /* 820C61F4h */ case   21:  		/* b 1304 */
		/* 820C61F4h case   21:*/		return 0x820C670C;
		/* 820C61F4h case   21:*/		return 0x820C61F8;
	}
	return 0x820C61F8;
} // Block from 820C61A0h-820C61F8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C61F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C61F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C61F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C61F8);
		  /* 820C61F8h */ case    0:  		/* lwz R10, <#[R24 + 52]> */
		/* 820C61F8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000034) );
		/* 820C61F8h case    0:*/		return 0x820C61FC;
		  /* 820C61FCh */ case    1:  		/* rlwinm R9, R11, 4, 0, 27 */
		/* 820C61FCh case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R9,regs.R11);
		/* 820C61FCh case    1:*/		return 0x820C6200;
		  /* 820C6200h */ case    2:  		/* lhz R11, <#[R25 + 8]> */
		/* 820C6200h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820C6200h case    2:*/		return 0x820C6204;
		  /* 820C6204h */ case    3:  		/* divwu R28, R9, R10 */
		/* 820C6204h case    3:*/		cpu::op::divwu<0>(regs,&regs.R28,regs.R9,regs.R10);
		/* 820C6204h case    3:*/		return 0x820C6208;
		  /* 820C6208h */ case    4:  		/* twi 6, R10, 0 */
		/* 820C6208h case    4:*/		cpu::op::tw<6>(regs, 0x820C6208, regs.R10, 0x00000000);
		/* 820C6208h case    4:*/		return 0x820C620C;
		  /* 820C620Ch */ case    5:  		/* cmplw CR6, R28, R11 */
		/* 820C620Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820C620Ch case    5:*/		return 0x820C6210;
		  /* 820C6210h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 820C6210h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820C6218;  }
		/* 820C6210h case    6:*/		return 0x820C6214;
		  /* 820C6214h */ case    7:  		/* mr R28, R11 */
		/* 820C6214h case    7:*/		regs.R28 = regs.R11;
		/* 820C6214h case    7:*/		return 0x820C6218;
	}
	return 0x820C6218;
} // Block from 820C61F8h-820C6218h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C6218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6218);
		  /* 820C6218h */ case    0:  		/* li R27, 0 */
		/* 820C6218h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820C6218h case    0:*/		return 0x820C621C;
		  /* 820C621Ch */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 820C621Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C621Ch case    1:*/		return 0x820C6220;
		  /* 820C6220h */ case    2:  		/* bc 12, CR6_EQ, 108 */
		/* 820C6220h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C628C;  }
		/* 820C6220h case    2:*/		return 0x820C6224;
		  /* 820C6224h */ case    3:  		/* lhz R11, <#[R25 + 10]> */
		/* 820C6224h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000A) );
		/* 820C6224h case    3:*/		return 0x820C6228;
		  /* 820C6228h */ case    4:  		/* li R29, 0 */
		/* 820C6228h case    4:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C6228h case    4:*/		return 0x820C622C;
		  /* 820C622Ch */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 820C622Ch case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C622Ch case    5:*/		return 0x820C6230;
		  /* 820C6230h */ case    6:  		/* bc 12, CR0_EQ, 80 */
		/* 820C6230h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C6280;  }
		/* 820C6230h case    6:*/		return 0x820C6234;
		  /* 820C6234h */ case    7:  		/* li R30, 0 */
		/* 820C6234h case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C6234h case    7:*/		return 0x820C6238;
		  /* 820C6238h */ case    8:  		/* lwz R11, <#[R24 + 56]> */
		/* 820C6238h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 820C6238h case    8:*/		return 0x820C623C;
		  /* 820C623Ch */ case    9:  		/* mr R7, R22 */
		/* 820C623Ch case    9:*/		regs.R7 = regs.R22;
		/* 820C623Ch case    9:*/		return 0x820C6240;
		  /* 820C6240h */ case   10:  		/* mr R5, R26 */
		/* 820C6240h case   10:*/		regs.R5 = regs.R26;
		/* 820C6240h case   10:*/		return 0x820C6244;
		  /* 820C6244h */ case   11:  		/* mr R4, R23 */
		/* 820C6244h case   11:*/		regs.R4 = regs.R23;
		/* 820C6244h case   11:*/		return 0x820C6248;
		  /* 820C6248h */ case   12:  		/* lwzx R31, <#[R11 + R30]> */
		/* 820C6248h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820C6248h case   12:*/		return 0x820C624C;
		  /* 820C624Ch */ case   13:  		/* mr R3, R31 */
		/* 820C624Ch case   13:*/		regs.R3 = regs.R31;
		/* 820C624Ch case   13:*/		return 0x820C6250;
		  /* 820C6250h */ case   14:  		/* lwz R6, <#[R31 + 48]> */
		/* 820C6250h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000030) );
		/* 820C6250h case   14:*/		return 0x820C6254;
		  /* 820C6254h */ case   15:  		/* bl -2292 */
		/* 820C6254h case   15:*/		regs.LR = 0x820C6258; return 0x820C5960;
		/* 820C6254h case   15:*/		return 0x820C6258;
		  /* 820C6258h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 820C6258h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C6258h case   16:*/		return 0x820C625C;
		  /* 820C625Ch */ case   17:  		/* bc 12, CR0_LT, 1200 */
		/* 820C625Ch case   17:*/		if ( regs.CR[0].lt ) { return 0x820C670C;  }
		/* 820C625Ch case   17:*/		return 0x820C6260;
		  /* 820C6260h */ case   18:  		/* lwz R11, <#[R31 + 48]> */
		/* 820C6260h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820C6260h case   18:*/		return 0x820C6264;
		  /* 820C6264h */ case   19:  		/* addi R29, R29, 1 */
		/* 820C6264h case   19:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 820C6264h case   19:*/		return 0x820C6268;
		  /* 820C6268h */ case   20:  		/* lhz R10, <#[R25 + 10]> */
		/* 820C6268h case   20:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x0000000A) );
		/* 820C6268h case   20:*/		return 0x820C626C;
		  /* 820C626Ch */ case   21:  		/* addi R30, R30, 4 */
		/* 820C626Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C626Ch case   21:*/		return 0x820C6270;
		  /* 820C6270h */ case   22:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C6270h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C6270h case   22:*/		return 0x820C6274;
		  /* 820C6274h */ case   23:  		/* cmplw CR6, R29, R10 */
		/* 820C6274h case   23:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 820C6274h case   23:*/		return 0x820C6278;
		  /* 820C6278h */ case   24:  		/* add R26, R11, R26 */
		/* 820C6278h case   24:*/		cpu::op::add<0>(regs,&regs.R26,regs.R11,regs.R26);
		/* 820C6278h case   24:*/		return 0x820C627C;
		  /* 820C627Ch */ case   25:  		/* bc 12, CR6_LT, -68 */
		/* 820C627Ch case   25:*/		if ( regs.CR[6].lt ) { return 0x820C6238;  }
		/* 820C627Ch case   25:*/		return 0x820C6280;
	}
	return 0x820C6280;
} // Block from 820C6218h-820C6280h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820C6280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6280);
		  /* 820C6280h */ case    0:  		/* addi R27, R27, 1 */
		/* 820C6280h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820C6280h case    0:*/		return 0x820C6284;
		  /* 820C6284h */ case    1:  		/* cmplw CR6, R27, R28 */
		/* 820C6284h case    1:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R28);
		/* 820C6284h case    1:*/		return 0x820C6288;
		  /* 820C6288h */ case    2:  		/* bc 12, CR6_LT, -100 */
		/* 820C6288h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C6224;  }
		/* 820C6288h case    2:*/		return 0x820C628C;
	}
	return 0x820C628C;
} // Block from 820C6280h-820C628Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C628Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C628C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C628C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C628C);
		  /* 820C628Ch */ case    0:  		/* li R3, 0 */
		/* 820C628Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C628Ch case    0:*/		return 0x820C6290;
		  /* 820C6290h */ case    1:  		/* b 1148 */
		/* 820C6290h case    1:*/		return 0x820C670C;
		/* 820C6290h case    1:*/		return 0x820C6294;
	}
	return 0x820C6294;
} // Block from 820C628Ch-820C6294h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C6294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6294);
		  /* 820C6294h */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C6294h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C6294h case    0:*/		return 0x820C6298;
		  /* 820C6298h */ case    1:  		/* mr R3, R11 */
		/* 820C6298h case    1:*/		regs.R3 = regs.R11;
		/* 820C6298h case    1:*/		return 0x820C629C;
		  /* 820C629Ch */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C629Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C629Ch case    2:*/		return 0x820C62A0;
		  /* 820C62A0h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C62A0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C62A8;  }
		/* 820C62A0h case    3:*/		return 0x820C62A4;
		  /* 820C62A4h */ case    4:  		/* mr R3, R10 */
		/* 820C62A4h case    4:*/		regs.R3 = regs.R10;
		/* 820C62A4h case    4:*/		return 0x820C62A8;
	}
	return 0x820C62A8;
} // Block from 820C6294h-820C62A8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C62A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C62A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C62A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C62A8);
		  /* 820C62A8h */ case    0:  		/* lhz R10, <#[R25 + 4]> */
		/* 820C62A8h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820C62A8h case    0:*/		return 0x820C62AC;
		  /* 820C62ACh */ case    1:  		/* cmplwi CR6, R10, 4 */
		/* 820C62ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820C62ACh case    1:*/		return 0x820C62B0;
		  /* 820C62B0h */ case    2:  		/* bc 4, CR6_EQ, 180 */
		/* 820C62B0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C6364;  }
		/* 820C62B0h case    2:*/		return 0x820C62B4;
		  /* 820C62B4h */ case    3:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C62B4h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C62B4h case    3:*/		return 0x820C62B8;
		  /* 820C62B8h */ case    4:  		/* cmplwi CR6, R11, 4 */
		/* 820C62B8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C62B8h case    4:*/		return 0x820C62BC;
		  /* 820C62BCh */ case    5:  		/* bc 4, CR6_EQ, 168 */
		/* 820C62BCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C6364;  }
		/* 820C62BCh case    5:*/		return 0x820C62C0;
		  /* 820C62C0h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 820C62C0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C62C0h case    6:*/		return 0x820C62C4;
		  /* 820C62C4h */ case    7:  		/* bc 12, CR6_EQ, 620 */
		/* 820C62C4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C6530;  }
		/* 820C62C4h case    7:*/		return 0x820C62C8;
		  /* 820C62C8h */ case    8:  		/* addi R10, R6, -4 */
		/* 820C62C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C62C8h case    8:*/		return 0x820C62CC;
		  /* 820C62CCh */ case    9:  		/* mtspr CTR, R3 */
		/* 820C62CCh case    9:*/		regs.CTR = regs.R3;
		/* 820C62CCh case    9:*/		return 0x820C62D0;
		  /* 820C62D0h */ case   10:  		/* addi R11, R5, 32 */
		/* 820C62D0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x20);
		/* 820C62D0h case   10:*/		return 0x820C62D4;
		  /* 820C62D4h */ case   11:  		/* subf R9, R5, R6 */
		/* 820C62D4h case   11:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R5,regs.R6);
		/* 820C62D4h case   11:*/		return 0x820C62D8;
		  /* 820C62D8h */ case   12:  		/* lfs FR0, <#[R11 - 32]> */
		/* 820C62D8h case   12:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFE0) );
		/* 820C62D8h case   12:*/		return 0x820C62DC;
		  /* 820C62DCh */ case   13:  		/* stfs FR0, <#[R10 + 4]> */
		/* 820C62DCh case   13:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000004) );
		/* 820C62DCh case   13:*/		return 0x820C62E0;
		  /* 820C62E0h */ case   14:  		/* lfs FR0, <#[R11 - 16]> */
		/* 820C62E0h case   14:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFF0) );
		/* 820C62E0h case   14:*/		return 0x820C62E4;
		  /* 820C62E4h */ case   15:  		/* stfs FR0, <#[R10 + 8]> */
		/* 820C62E4h case   15:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000008) );
		/* 820C62E4h case   15:*/		return 0x820C62E8;
		  /* 820C62E8h */ case   16:  		/* lfs FR0, <#[R11]> */
		/* 820C62E8h case   16:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 820C62E8h case   16:*/		return 0x820C62EC;
		  /* 820C62ECh */ case   17:  		/* stfs FR0, <#[R10 + 12]> */
		/* 820C62ECh case   17:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x0000000C) );
		/* 820C62ECh case   17:*/		return 0x820C62F0;
		  /* 820C62F0h */ case   18:  		/* lfs FR0, <#[R11 + 16]> */
		/* 820C62F0h case   18:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000010) );
		/* 820C62F0h case   18:*/		return 0x820C62F4;
		  /* 820C62F4h */ case   19:  		/* stfs FR0, <#[R10 + 16]> */
		/* 820C62F4h case   19:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000010) );
		/* 820C62F4h case   19:*/		return 0x820C62F8;
		  /* 820C62F8h */ case   20:  		/* lfs FR0, <#[R11 - 28]> */
		/* 820C62F8h case   20:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFE4) );
		/* 820C62F8h case   20:*/		return 0x820C62FC;
		  /* 820C62FCh */ case   21:  		/* stfs FR0, <#[R10 + 20]> */
		/* 820C62FCh case   21:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000014) );
		/* 820C62FCh case   21:*/		return 0x820C6300;
		  /* 820C6300h */ case   22:  		/* lfs FR0, <#[R11 - 12]> */
		/* 820C6300h case   22:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFF4) );
		/* 820C6300h case   22:*/		return 0x820C6304;
		  /* 820C6304h */ case   23:  		/* stfs FR0, <#[R10 + 24]> */
		/* 820C6304h case   23:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000018) );
		/* 820C6304h case   23:*/		return 0x820C6308;
		  /* 820C6308h */ case   24:  		/* lfs FR0, <#[R11 + 4]> */
		/* 820C6308h case   24:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000004) );
		/* 820C6308h case   24:*/		return 0x820C630C;
		  /* 820C630Ch */ case   25:  		/* stfs FR0, <#[R10 + 28]> */
		/* 820C630Ch case   25:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x0000001C) );
		/* 820C630Ch case   25:*/		return 0x820C6310;
		  /* 820C6310h */ case   26:  		/* lfs FR0, <#[R11 + 20]> */
		/* 820C6310h case   26:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000014) );
		/* 820C6310h case   26:*/		return 0x820C6314;
		  /* 820C6314h */ case   27:  		/* stfs FR0, <#[R10 + 32]> */
		/* 820C6314h case   27:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820C6314h case   27:*/		return 0x820C6318;
		  /* 820C6318h */ case   28:  		/* lfs FR0, <#[R11 - 24]> */
		/* 820C6318h case   28:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFE8) );
		/* 820C6318h case   28:*/		return 0x820C631C;
		  /* 820C631Ch */ case   29:  		/* stfsx FR0, <#[R9 + R11]> */
		/* 820C631Ch case   29:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820C631Ch case   29:*/		return 0x820C6320;
		  /* 820C6320h */ case   30:  		/* lfs FR0, <#[R11 - 8]> */
		/* 820C6320h case   30:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 820C6320h case   30:*/		return 0x820C6324;
		  /* 820C6324h */ case   31:  		/* stfs FR0, <#[R10 + 40]> */
		/* 820C6324h case   31:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000028) );
		/* 820C6324h case   31:*/		return 0x820C6328;
		  /* 820C6328h */ case   32:  		/* lfs FR0, <#[R11 + 8]> */
		/* 820C6328h case   32:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000008) );
		/* 820C6328h case   32:*/		return 0x820C632C;
		  /* 820C632Ch */ case   33:  		/* stfs FR0, <#[R10 + 44]> */
		/* 820C632Ch case   33:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x0000002C) );
		/* 820C632Ch case   33:*/		return 0x820C6330;
		  /* 820C6330h */ case   34:  		/* lfs FR0, <#[R11 + 24]> */
		/* 820C6330h case   34:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000018) );
		/* 820C6330h case   34:*/		return 0x820C6334;
		  /* 820C6334h */ case   35:  		/* stfs FR0, <#[R10 + 48]> */
		/* 820C6334h case   35:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000030) );
		/* 820C6334h case   35:*/		return 0x820C6338;
		  /* 820C6338h */ case   36:  		/* lfs FR0, <#[R11 - 20]> */
		/* 820C6338h case   36:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFEC) );
		/* 820C6338h case   36:*/		return 0x820C633C;
		  /* 820C633Ch */ case   37:  		/* stfs FR0, <#[R10 + 52]> */
		/* 820C633Ch case   37:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000034) );
		/* 820C633Ch case   37:*/		return 0x820C6340;
		  /* 820C6340h */ case   38:  		/* lfs FR0, <#[R11 - 4]> */
		/* 820C6340h case   38:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 820C6340h case   38:*/		return 0x820C6344;
		  /* 820C6344h */ case   39:  		/* stfs FR0, <#[R10 + 56]> */
		/* 820C6344h case   39:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000038) );
		/* 820C6344h case   39:*/		return 0x820C6348;
		  /* 820C6348h */ case   40:  		/* lfs FR0, <#[R11 + 12]> */
		/* 820C6348h case   40:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C6348h case   40:*/		return 0x820C634C;
		  /* 820C634Ch */ case   41:  		/* stfs FR0, <#[R10 + 60]> */
		/* 820C634Ch case   41:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x0000003C) );
		/* 820C634Ch case   41:*/		return 0x820C6350;
		  /* 820C6350h */ case   42:  		/* lfs FR0, <#[R11 + 28]> */
		/* 820C6350h case   42:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x0000001C) );
		/* 820C6350h case   42:*/		return 0x820C6354;
		  /* 820C6354h */ case   43:  		/* addi R11, R11, 64 */
		/* 820C6354h case   43:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x40);
		/* 820C6354h case   43:*/		return 0x820C6358;
		  /* 820C6358h */ case   44:  		/* stfsu FR0, <#[R10 + 64]> */
		/* 820C6358h case   44:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000040) );
		regs.R10 = (uint32)(regs.R10 + 0x00000040);
		/* 820C6358h case   44:*/		return 0x820C635C;
		  /* 820C635Ch */ case   45:  		/* bc 16, CR0_LT, -132 */
		/* 820C635Ch case   45:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C62D8;  }
		/* 820C635Ch case   45:*/		return 0x820C6360;
		  /* 820C6360h */ case   46:  		/* b 464 */
		/* 820C6360h case   46:*/		return 0x820C6530;
		/* 820C6360h case   46:*/		return 0x820C6364;
	}
	return 0x820C6364;
} // Block from 820C62A8h-820C6364h (47 instructions)

//////////////////////////////////////////////////////
// Block at 820C6364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6364);
		  /* 820C6364h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820C6364h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C6364h case    0:*/		return 0x820C6368;
		  /* 820C6368h */ case    1:  		/* bc 12, CR6_EQ, 456 */
		/* 820C6368h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C6530;  }
		/* 820C6368h case    1:*/		return 0x820C636C;
		  /* 820C636Ch */ case    2:  		/* mtspr CTR, R3 */
		/* 820C636Ch case    2:*/		regs.CTR = regs.R3;
		/* 820C636Ch case    2:*/		return 0x820C6370;
		  /* 820C6370h */ case    3:  		/* li R8, 0 */
		/* 820C6370h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C6370h case    3:*/		return 0x820C6374;
		  /* 820C6374h */ case    4:  		/* addi R7, R6, -4 */
		/* 820C6374h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820C6374h case    4:*/		return 0x820C6378;
		  /* 820C6378h */ case    5:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C6378h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6378h case    5:*/		return 0x820C637C;
		  /* 820C637Ch */ case    6:  		/* li R9, 0 */
		/* 820C637Ch case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C637Ch case    6:*/		return 0x820C6380;
		  /* 820C6380h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 820C6380h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C6380h case    7:*/		return 0x820C6384;
		  /* 820C6384h */ case    8:  		/* bc 12, CR0_EQ, 96 */
		/* 820C6384h case    8:*/		if ( regs.CR[0].eq ) { return 0x820C63E4;  }
		/* 820C6384h case    8:*/		return 0x820C6388;
	}
	return 0x820C6388;
} // Block from 820C6364h-820C6388h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C6388h
// Function '?Set@?$SetTyped@$0A@$02$00$00$0A@@D3DXShader@@SAJPAVCConstant@2@PBX1II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6388);
		  /* 820C6388h */ case    0:  		/* li R11, 0 */
		/* 820C6388h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6388h case    0:*/		return 0x820C638C;
		  /* 820C638Ch */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C638Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C638Ch case    1:*/		return 0x820C6390;
		  /* 820C6390h */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 820C6390h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C63D4;  }
		/* 820C6390h case    2:*/		return 0x820C6394;
		  /* 820C6394h */ case    3:  		/* cmplwi CR6, R11, 4 */
		/* 820C6394h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C6394h case    3:*/		return 0x820C6398;
		  /* 820C6398h */ case    4:  		/* bc 12, CR6_GT, 36 */
		/* 820C6398h case    4:*/		if ( regs.CR[6].gt ) { return 0x820C63BC;  }
		/* 820C6398h case    4:*/		return 0x820C639C;
		  /* 820C639Ch */ case    5:  		/* cmplwi CR6, R9, 4 */
		/* 820C639Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000004);
		/* 820C639Ch case    5:*/		return 0x820C63A0;
		  /* 820C63A0h */ case    6:  		/* bc 12, CR6_GT, 28 */
		/* 820C63A0h case    6:*/		if ( regs.CR[6].gt ) { return 0x820C63BC;  }
		/* 820C63A0h case    6:*/		return 0x820C63A4;
		  /* 820C63A4h */ case    7:  		/* add R10, R8, R11 */
		/* 820C63A4h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R11);
		/* 820C63A4h case    7:*/		return 0x820C63A8;
		  /* 820C63A8h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C63A8h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C63A8h case    8:*/		return 0x820C63AC;
		  /* 820C63ACh */ case    9:  		/* add R10, R10, R9 */
		/* 820C63ACh case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820C63ACh case    9:*/		return 0x820C63B0;
		  /* 820C63B0h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C63B0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C63B0h case   10:*/		return 0x820C63B4;
		  /* 820C63B4h */ case   11:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C63B4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C63B4h case   11:*/		return 0x820C63B8;
		  /* 820C63B8h */ case   12:  		/* b 8 */
		/* 820C63B8h case   12:*/		return 0x820C63C0;
		/* 820C63B8h case   12:*/		return 0x820C63BC;
	}
	return 0x820C63BC;
} // Block from 820C6388h-820C63BCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C63BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C63BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C63BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C63BC);
		  /* 820C63BCh */ case    0:  		/* li R10, 0 */
		/* 820C63BCh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C63BCh case    0:*/		return 0x820C63C0;
	}
	return 0x820C63C0;
} // Block from 820C63BCh-820C63C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C63C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C63C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C63C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C63C0);
		  /* 820C63C0h */ case    0:  		/* addi R11, R11, 1 */
		/* 820C63C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C63C0h case    0:*/		return 0x820C63C4;
		  /* 820C63C4h */ case    1:  		/* stwu R10, <#[R7 + 4]> */
		/* 820C63C4h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820C63C4h case    1:*/		return 0x820C63C8;
		  /* 820C63C8h */ case    2:  		/* lhz R10, <#[R25 + 4]> */
		/* 820C63C8h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820C63C8h case    2:*/		return 0x820C63CC;
		  /* 820C63CCh */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C63CCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C63CCh case    3:*/		return 0x820C63D0;
		  /* 820C63D0h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 820C63D0h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C6394;  }
		/* 820C63D0h case    4:*/		return 0x820C63D4;
	}
	return 0x820C63D4;
} // Block from 820C63C0h-820C63D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C63D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C63D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C63D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C63D4);
		  /* 820C63D4h */ case    0:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C63D4h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C63D4h case    0:*/		return 0x820C63D8;
		  /* 820C63D8h */ case    1:  		/* addi R9, R9, 1 */
		/* 820C63D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C63D8h case    1:*/		return 0x820C63DC;
		  /* 820C63DCh */ case    2:  		/* cmplw CR6, R9, R11 */
		/* 820C63DCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820C63DCh case    2:*/		return 0x820C63E0;
		  /* 820C63E0h */ case    3:  		/* bc 12, CR6_LT, -88 */
		/* 820C63E0h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C6388;  }
		/* 820C63E0h case    3:*/		return 0x820C63E4;
	}
	return 0x820C63E4;
} // Block from 820C63D4h-820C63E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C63E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C63E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C63E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C63E4);
		  /* 820C63E4h */ case    0:  		/* addi R8, R8, 4 */
		/* 820C63E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820C63E4h case    0:*/		return 0x820C63E8;
		  /* 820C63E8h */ case    1:  		/* bc 16, CR0_LT, -112 */
		/* 820C63E8h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6378;  }
		/* 820C63E8h case    1:*/		return 0x820C63EC;
		  /* 820C63ECh */ case    2:  		/* b 324 */
		/* 820C63ECh case    2:*/		return 0x820C6530;
		/* 820C63ECh case    2:*/		return 0x820C63F0;
	}
	return 0x820C63F0;
} // Block from 820C63E4h-820C63F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C63F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C63F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C63F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C63F0);
		  /* 820C63F0h */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C63F0h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C63F0h case    0:*/		return 0x820C63F4;
		  /* 820C63F4h */ case    1:  		/* mr R3, R11 */
		/* 820C63F4h case    1:*/		regs.R3 = regs.R11;
		/* 820C63F4h case    1:*/		return 0x820C63F8;
		  /* 820C63F8h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C63F8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C63F8h case    2:*/		return 0x820C63FC;
		  /* 820C63FCh */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C63FCh case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C6404;  }
		/* 820C63FCh case    3:*/		return 0x820C6400;
		  /* 820C6400h */ case    4:  		/* mr R3, R10 */
		/* 820C6400h case    4:*/		regs.R3 = regs.R10;
		/* 820C6400h case    4:*/		return 0x820C6404;
	}
	return 0x820C6404;
} // Block from 820C63F0h-820C6404h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6404);
		  /* 820C6404h */ case    0:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C6404h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C6404h case    0:*/		return 0x820C6408;
		  /* 820C6408h */ case    1:  		/* cmplwi CR6, R11, 4 */
		/* 820C6408h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C6408h case    1:*/		return 0x820C640C;
		  /* 820C640Ch */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C640Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C641C;  }
		/* 820C640Ch case    2:*/		return 0x820C6410;
		  /* 820C6410h */ case    3:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C6410h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6410h case    3:*/		return 0x820C6414;
		  /* 820C6414h */ case    4:  		/* cmplwi CR6, R10, 4 */
		/* 820C6414h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820C6414h case    4:*/		return 0x820C6418;
		  /* 820C6418h */ case    5:  		/* bc 12, CR6_EQ, 308 */
		/* 820C6418h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C654C;  }
		/* 820C6418h case    5:*/		return 0x820C641C;
	}
	return 0x820C641C;
} // Block from 820C6404h-820C641Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C641Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C641C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C641C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C641C);
		  /* 820C641Ch */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820C641Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C641Ch case    0:*/		return 0x820C6420;
		  /* 820C6420h */ case    1:  		/* bc 12, CR6_EQ, 272 */
		/* 820C6420h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C6530;  }
		/* 820C6420h case    1:*/		return 0x820C6424;
		  /* 820C6424h */ case    2:  		/* li R8, 0 */
		/* 820C6424h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C6424h case    2:*/		return 0x820C6428;
		  /* 820C6428h */ case    3:  		/* mtspr CTR, R3 */
		/* 820C6428h case    3:*/		regs.CTR = regs.R3;
		/* 820C6428h case    3:*/		return 0x820C642C;
		  /* 820C642Ch */ case    4:  		/* addi R7, R6, -4 */
		/* 820C642Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820C642Ch case    4:*/		return 0x820C6430;
		  /* 820C6430h */ case    5:  		/* li R9, 0 */
		/* 820C6430h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C6430h case    5:*/		return 0x820C6434;
		  /* 820C6434h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820C6434h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C6434h case    6:*/		return 0x820C6438;
		  /* 820C6438h */ case    7:  		/* bc 12, CR6_EQ, 100 */
		/* 820C6438h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C649C;  }
		/* 820C6438h case    7:*/		return 0x820C643C;
		  /* 820C643Ch */ case    8:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C643Ch case    8:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C643Ch case    8:*/		return 0x820C6440;
		  /* 820C6440h */ case    9:  		/* li R11, 0 */
		/* 820C6440h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6440h case    9:*/		return 0x820C6444;
		  /* 820C6444h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 820C6444h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C6444h case   10:*/		return 0x820C6448;
		  /* 820C6448h */ case   11:  		/* bc 12, CR6_EQ, 68 */
		/* 820C6448h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C648C;  }
		/* 820C6448h case   11:*/		return 0x820C644C;
		  /* 820C644Ch */ case   12:  		/* cmplwi CR6, R9, 4 */
		/* 820C644Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000004);
		/* 820C644Ch case   12:*/		return 0x820C6450;
		  /* 820C6450h */ case   13:  		/* bc 12, CR6_GT, 36 */
		/* 820C6450h case   13:*/		if ( regs.CR[6].gt ) { return 0x820C6474;  }
		/* 820C6450h case   13:*/		return 0x820C6454;
		  /* 820C6454h */ case   14:  		/* cmplwi CR6, R11, 4 */
		/* 820C6454h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C6454h case   14:*/		return 0x820C6458;
		  /* 820C6458h */ case   15:  		/* bc 12, CR6_GT, 28 */
		/* 820C6458h case   15:*/		if ( regs.CR[6].gt ) { return 0x820C6474;  }
		/* 820C6458h case   15:*/		return 0x820C645C;
		  /* 820C645Ch */ case   16:  		/* add R10, R8, R9 */
		/* 820C645Ch case   16:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R9);
		/* 820C645Ch case   16:*/		return 0x820C6460;
		  /* 820C6460h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C6460h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C6460h case   17:*/		return 0x820C6464;
		  /* 820C6464h */ case   18:  		/* add R10, R10, R11 */
		/* 820C6464h case   18:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C6464h case   18:*/		return 0x820C6468;
		  /* 820C6468h */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C6468h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C6468h case   19:*/		return 0x820C646C;
		  /* 820C646Ch */ case   20:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C646Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C646Ch case   20:*/		return 0x820C6470;
		  /* 820C6470h */ case   21:  		/* b 8 */
		/* 820C6470h case   21:*/		return 0x820C6478;
		/* 820C6470h case   21:*/		return 0x820C6474;
	}
	return 0x820C6474;
} // Block from 820C641Ch-820C6474h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C6474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6474);
		  /* 820C6474h */ case    0:  		/* li R10, 0 */
		/* 820C6474h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C6474h case    0:*/		return 0x820C6478;
	}
	return 0x820C6478;
} // Block from 820C6474h-820C6478h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C6478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6478);
		  /* 820C6478h */ case    0:  		/* addi R11, R11, 1 */
		/* 820C6478h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C6478h case    0:*/		return 0x820C647C;
		  /* 820C647Ch */ case    1:  		/* stwu R10, <#[R7 + 4]> */
		/* 820C647Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820C647Ch case    1:*/		return 0x820C6480;
		  /* 820C6480h */ case    2:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C6480h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6480h case    2:*/		return 0x820C6484;
		  /* 820C6484h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C6484h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C6484h case    3:*/		return 0x820C6488;
		  /* 820C6488h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 820C6488h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C644C;  }
		/* 820C6488h case    4:*/		return 0x820C648C;
	}
	return 0x820C648C;
} // Block from 820C6478h-820C648Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C648Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C648C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C648C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C648C);
		  /* 820C648Ch */ case    0:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C648Ch case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C648Ch case    0:*/		return 0x820C6490;
		  /* 820C6490h */ case    1:  		/* addi R9, R9, 1 */
		/* 820C6490h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C6490h case    1:*/		return 0x820C6494;
		  /* 820C6494h */ case    2:  		/* cmplw CR6, R9, R11 */
		/* 820C6494h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820C6494h case    2:*/		return 0x820C6498;
		  /* 820C6498h */ case    3:  		/* bc 12, CR6_LT, -88 */
		/* 820C6498h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C6440;  }
		/* 820C6498h case    3:*/		return 0x820C649C;
	}
	return 0x820C649C;
} // Block from 820C648Ch-820C649Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C649Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C649C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C649C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C649C);
		  /* 820C649Ch */ case    0:  		/* addi R8, R8, 4 */
		/* 820C649Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820C649Ch case    0:*/		return 0x820C64A0;
		  /* 820C64A0h */ case    1:  		/* bc 16, CR0_LT, -112 */
		/* 820C64A0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6430;  }
		/* 820C64A0h case    1:*/		return 0x820C64A4;
		  /* 820C64A4h */ case    2:  		/* b 140 */
		/* 820C64A4h case    2:*/		return 0x820C6530;
		/* 820C64A4h case    2:*/		return 0x820C64A8;
	}
	return 0x820C64A8;
} // Block from 820C649Ch-820C64A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C64A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C64A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C64A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C64A8);
		  /* 820C64A8h */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C64A8h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C64A8h case    0:*/		return 0x820C64AC;
		  /* 820C64ACh */ case    1:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820C64ACh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820C64ACh case    1:*/		return 0x820C64B0;
		  /* 820C64B0h */ case    2:  		/* cmplw CR6, R3, R10 */
		/* 820C64B0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C64B0h case    2:*/		return 0x820C64B4;
		  /* 820C64B4h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C64B4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C64BC;  }
		/* 820C64B4h case    3:*/		return 0x820C64B8;
		  /* 820C64B8h */ case    4:  		/* mr R3, R10 */
		/* 820C64B8h case    4:*/		regs.R3 = regs.R10;
		/* 820C64B8h case    4:*/		return 0x820C64BC;
	}
	return 0x820C64BC;
} // Block from 820C64A8h-820C64BCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C64BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C64BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C64BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C64BC);
		  /* 820C64BCh */ case    0:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C64BCh case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C64BCh case    0:*/		return 0x820C64C0;
		  /* 820C64C0h */ case    1:  		/* cmplwi CR6, R10, 4 */
		/* 820C64C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820C64C0h case    1:*/		return 0x820C64C4;
		  /* 820C64C4h */ case    2:  		/* bc 12, CR6_EQ, 136 */
		/* 820C64C4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C654C;  }
		/* 820C64C4h case    2:*/		return 0x820C64C8;
		  /* 820C64C8h */ case    3:  		/* li R8, 0 */
		/* 820C64C8h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C64C8h case    3:*/		return 0x820C64CC;
		  /* 820C64CCh */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820C64CCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C64CCh case    4:*/		return 0x820C64D0;
		  /* 820C64D0h */ case    5:  		/* bc 12, CR6_EQ, 96 */
		/* 820C64D0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C6530;  }
		/* 820C64D0h case    5:*/		return 0x820C64D4;
		  /* 820C64D4h */ case    6:  		/* addi R7, R6, -4 */
		/* 820C64D4h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820C64D4h case    6:*/		return 0x820C64D8;
		  /* 820C64D8h */ case    7:  		/* li R11, 0 */
		/* 820C64D8h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C64D8h case    7:*/		return 0x820C64DC;
		  /* 820C64DCh */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 820C64DCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C64DCh case    8:*/		return 0x820C64E0;
		  /* 820C64E0h */ case    9:  		/* bc 12, CR6_EQ, 68 */
		/* 820C64E0h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C6524;  }
		/* 820C64E0h case    9:*/		return 0x820C64E4;
		  /* 820C64E4h */ case   10:  		/* cmplwi CR6, R11, 4 */
		/* 820C64E4h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C64E4h case   10:*/		return 0x820C64E8;
		  /* 820C64E8h */ case   11:  		/* bc 4, CR6_GT, 12 */
		/* 820C64E8h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820C64F4;  }
		/* 820C64E8h case   11:*/		return 0x820C64EC;
		  /* 820C64ECh */ case   12:  		/* li R10, 0 */
		/* 820C64ECh case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C64ECh case   12:*/		return 0x820C64F0;
		  /* 820C64F0h */ case   13:  		/* b 32 */
		/* 820C64F0h case   13:*/		return 0x820C6510;
		/* 820C64F0h case   13:*/		return 0x820C64F4;
	}
	return 0x820C64F4;
} // Block from 820C64BCh-820C64F4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C64F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C64F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C64F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C64F4);
		  /* 820C64F4h */ case    0:  		/* rlwinm R10, R8, 0, 30, 31 */
		/* 820C64F4h case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R8);
		/* 820C64F4h case    0:*/		return 0x820C64F8;
		  /* 820C64F8h */ case    1:  		/* rlwinm R9, R8, 0, 0, 29 */
		/* 820C64F8h case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R9,regs.R8);
		/* 820C64F8h case    1:*/		return 0x820C64FC;
		  /* 820C64FCh */ case    2:  		/* add R10, R9, R10 */
		/* 820C64FCh case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820C64FCh case    2:*/		return 0x820C6500;
		  /* 820C6500h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C6500h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C6500h case    3:*/		return 0x820C6504;
		  /* 820C6504h */ case    4:  		/* add R10, R10, R11 */
		/* 820C6504h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C6504h case    4:*/		return 0x820C6508;
		  /* 820C6508h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C6508h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C6508h case    5:*/		return 0x820C650C;
		  /* 820C650Ch */ case    6:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C650Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C650Ch case    6:*/		return 0x820C6510;
	}
	return 0x820C6510;
} // Block from 820C64F4h-820C6510h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C6510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6510);
		  /* 820C6510h */ case    0:  		/* stwu R10, <#[R7 + 4]> */
		/* 820C6510h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820C6510h case    0:*/		return 0x820C6514;
		  /* 820C6514h */ case    1:  		/* addi R11, R11, 1 */
		/* 820C6514h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C6514h case    1:*/		return 0x820C6518;
		  /* 820C6518h */ case    2:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C6518h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6518h case    2:*/		return 0x820C651C;
		  /* 820C651Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C651Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C651Ch case    3:*/		return 0x820C6520;
		  /* 820C6520h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 820C6520h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C64E4;  }
		/* 820C6520h case    4:*/		return 0x820C6524;
	}
	return 0x820C6524;
} // Block from 820C6510h-820C6524h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6524);
		  /* 820C6524h */ case    0:  		/* addi R8, R8, 1 */
		/* 820C6524h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820C6524h case    0:*/		return 0x820C6528;
		  /* 820C6528h */ case    1:  		/* cmplw CR6, R8, R3 */
		/* 820C6528h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R3);
		/* 820C6528h case    1:*/		return 0x820C652C;
		  /* 820C652Ch */ case    2:  		/* bc 12, CR6_LT, -84 */
		/* 820C652Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x820C64D8;  }
		/* 820C652Ch case    2:*/		return 0x820C6530;
	}
	return 0x820C6530;
} // Block from 820C6524h-820C6530h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C6530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6530);
		  /* 820C6530h */ case    0:  		/* mr R26, R6 */
		/* 820C6530h case    0:*/		regs.R26 = regs.R6;
		/* 820C6530h case    0:*/		return 0x820C6534;
		  /* 820C6534h */ case    1:  		/* b 24 */
		/* 820C6534h case    1:*/		return 0x820C654C;
		/* 820C6534h case    1:*/		return 0x820C6538;
	}
	return 0x820C6538;
} // Block from 820C6530h-820C6538h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C6538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6538);
		  /* 820C6538h */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C6538h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C6538h case    0:*/		return 0x820C653C;
		  /* 820C653Ch */ case    1:  		/* rlwinm R3, R11, 4, 0, 27 */
		/* 820C653Ch case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R3,regs.R11);
		/* 820C653Ch case    1:*/		return 0x820C6540;
		  /* 820C6540h */ case    2:  		/* cmplw CR6, R3, R10 */
		/* 820C6540h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 820C6540h case    2:*/		return 0x820C6544;
		  /* 820C6544h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C6544h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C654C;  }
		/* 820C6544h case    3:*/		return 0x820C6548;
		  /* 820C6548h */ case    4:  		/* mr R3, R10 */
		/* 820C6548h case    4:*/		regs.R3 = regs.R10;
		/* 820C6548h case    4:*/		return 0x820C654C;
	}
	return 0x820C654C;
} // Block from 820C6538h-820C654Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C654Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C654C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C654C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C654C);
		  /* 820C654Ch */ case    0:  		/* lhz R10, <#[R25 + 2]> */
		/* 820C654Ch case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000002) );
		/* 820C654Ch case    0:*/		return 0x820C6550;
		  /* 820C6550h */ case    1:  		/* cmplwi CR6, R10, 3 */
		/* 820C6550h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C6550h case    1:*/		return 0x820C6554;
		  /* 820C6554h */ case    2:  		/* bc 12, CR6_EQ, 136 */
		/* 820C6554h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C65DC;  }
		/* 820C6554h case    2:*/		return 0x820C6558;
		  /* 820C6558h */ case    3:  		/* lwz R11, <#[R24 + 52]> */
		/* 820C6558h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000034) );
		/* 820C6558h case    3:*/		return 0x820C655C;
		  /* 820C655Ch */ case    4:  		/* cmplwi CR6, R10, 1 */
		/* 820C655Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C655Ch case    4:*/		return 0x820C6560;
		  /* 820C6560h */ case    5:  		/* mullw R11, R11, R3 */
		/* 820C6560h case    5:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820C6560h case    5:*/		return 0x820C6564;
		  /* 820C6564h */ case    6:  		/* bc 12, CR6_EQ, 56 */
		/* 820C6564h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C659C;  }
		/* 820C6564h case    6:*/		return 0x820C6568;
		  /* 820C6568h */ case    7:  		/* cmplwi CR6, R10, 2 */
		/* 820C6568h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820C6568h case    7:*/		return 0x820C656C;
		  /* 820C656Ch */ case    8:  		/* bc 4, CR6_EQ, 108 */
		/* 820C656Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C65D8;  }
		/* 820C656Ch case    8:*/		return 0x820C6570;
		  /* 820C6570h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820C6570h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C6570h case    9:*/		return 0x820C6574;
		  /* 820C6574h */ case   10:  		/* bc 12, CR6_EQ, 100 */
		/* 820C6574h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C65D8;  }
		/* 820C6574h case   10:*/		return 0x820C6578;
		  /* 820C6578h */ case   11:  		/* mtspr CTR, R11 */
		/* 820C6578h case   11:*/		regs.CTR = regs.R11;
		/* 820C6578h case   11:*/		return 0x820C657C;
		  /* 820C657Ch */ case   12:  		/* mr R10, R6 */
		/* 820C657Ch case   12:*/		regs.R10 = regs.R6;
		/* 820C657Ch case   12:*/		return 0x820C6580;
		  /* 820C6580h */ case   13:  		/* subf R11, R6, R26 */
		/* 820C6580h case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R26);
		/* 820C6580h case   13:*/		return 0x820C6584;
		  /* 820C6584h */ case   14:  		/* lfsx FR0, <#[R11 + R10]> */
		/* 820C6584h case   14:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C6584h case   14:*/		return 0x820C6588;
		  /* 820C6588h */ case   15:  		/* fctiwz FR0, FR0 */
		/* 820C6588h case   15:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 820C6588h case   15:*/		return 0x820C658C;
		  /* 820C658Ch */ case   16:  		/* stfiwx FR0, <#[R10]> */
		/* 820C658Ch case   16:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C658Ch case   16:*/		return 0x820C6590;
		  /* 820C6590h */ case   17:  		/* addi R10, R10, 4 */
		/* 820C6590h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C6590h case   17:*/		return 0x820C6594;
		  /* 820C6594h */ case   18:  		/* bc 16, CR0_LT, -16 */
		/* 820C6594h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6584;  }
		/* 820C6594h case   18:*/		return 0x820C6598;
		  /* 820C6598h */ case   19:  		/* b 64 */
		/* 820C6598h case   19:*/		return 0x820C65D8;
		/* 820C6598h case   19:*/		return 0x820C659C;
	}
	return 0x820C659C;
} // Block from 820C654Ch-820C659Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C659Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C659C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C659C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C659C);
		  /* 820C659Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C659Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C659Ch case    0:*/		return 0x820C65A0;
		  /* 820C65A0h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 820C65A0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C65D8;  }
		/* 820C65A0h case    1:*/		return 0x820C65A4;
		  /* 820C65A4h */ case    2:  		/* mtspr CTR, R11 */
		/* 820C65A4h case    2:*/		regs.CTR = regs.R11;
		/* 820C65A4h case    2:*/		return 0x820C65A8;
		  /* 820C65A8h */ case    3:  		/* lis R11, -32256 */
		/* 820C65A8h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820C65A8h case    3:*/		return 0x820C65AC;
		  /* 820C65ACh */ case    4:  		/* mr R10, R6 */
		/* 820C65ACh case    4:*/		regs.R10 = regs.R6;
		/* 820C65ACh case    4:*/		return 0x820C65B0;
		  /* 820C65B0h */ case    5:  		/* subf R9, R6, R26 */
		/* 820C65B0h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R26);
		/* 820C65B0h case    5:*/		return 0x820C65B4;
		  /* 820C65B4h */ case    6:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 820C65B4h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 820C65B4h case    6:*/		return 0x820C65B8;
		  /* 820C65B8h */ case    7:  		/* lfsx FR13, <#[R9 + R10]> */
		/* 820C65B8h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 820C65B8h case    7:*/		return 0x820C65BC;
		  /* 820C65BCh */ case    8:  		/* li R11, 1 */
		/* 820C65BCh case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820C65BCh case    8:*/		return 0x820C65C0;
		  /* 820C65C0h */ case    9:  		/* fcmpu CR6, FR13, FR0 */
		/* 820C65C0h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820C65C0h case    9:*/		return 0x820C65C4;
		  /* 820C65C4h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 820C65C4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820C65CC;  }
		/* 820C65C4h case   10:*/		return 0x820C65C8;
		  /* 820C65C8h */ case   11:  		/* li R11, 0 */
		/* 820C65C8h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C65C8h case   11:*/		return 0x820C65CC;
	}
	return 0x820C65CC;
} // Block from 820C659Ch-820C65CCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C65CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C65CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C65CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C65CC);
		  /* 820C65CCh */ case    0:  		/* stw R11, <#[R10]> */
		/* 820C65CCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820C65CCh case    0:*/		return 0x820C65D0;
		  /* 820C65D0h */ case    1:  		/* addi R10, R10, 4 */
		/* 820C65D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C65D0h case    1:*/		return 0x820C65D4;
		  /* 820C65D4h */ case    2:  		/* bc 16, CR0_LT, -28 */
		/* 820C65D4h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C65B8;  }
		/* 820C65D4h case    2:*/		return 0x820C65D8;
	}
	return 0x820C65D8;
} // Block from 820C65CCh-820C65D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C65D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C65D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C65D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C65D8);
		  /* 820C65D8h */ case    0:  		/* mr R26, R6 */
		/* 820C65D8h case    0:*/		regs.R26 = regs.R6;
		/* 820C65D8h case    0:*/		return 0x820C65DC;
	}
	return 0x820C65DC;
} // Block from 820C65D8h-820C65DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C65DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C65DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C65DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C65DC);
		  /* 820C65DCh */ case    0:  		/* lhz R9, <#[R24 + 8]> */
		/* 820C65DCh case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 820C65DCh case    0:*/		return 0x820C65E0;
		  /* 820C65E0h */ case    1:  		/* cmplwi CR0, R9, 0 */
		/* 820C65E0h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820C65E0h case    1:*/		return 0x820C65E4;
		  /* 820C65E4h */ case    2:  		/* bc 12, CR0_EQ, 216 */
		/* 820C65E4h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C66BC;  }
		/* 820C65E4h case    2:*/		return 0x820C65E8;
		  /* 820C65E8h */ case    3:  		/* lhz R11, <#[R25]> */
		/* 820C65E8h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820C65E8h case    3:*/		return 0x820C65EC;
		  /* 820C65ECh */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C65ECh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C65ECh case    4:*/		return 0x820C65F0;
		  /* 820C65F0h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820C65F0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C6600;  }
		/* 820C65F0h case    5:*/		return 0x820C65F4;
		  /* 820C65F4h */ case    6:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C65F4h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C65F4h case    6:*/		return 0x820C65F8;
		  /* 820C65F8h */ case    7:  		/* lhz R10, <#[R25 + 4]> */
		/* 820C65F8h case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820C65F8h case    7:*/		return 0x820C65FC;
		  /* 820C65FCh */ case    8:  		/* b 12 */
		/* 820C65FCh case    8:*/		return 0x820C6608;
		/* 820C65FCh case    8:*/		return 0x820C6600;
	}
	return 0x820C6600;
} // Block from 820C65DCh-820C6600h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C6600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6600);
		  /* 820C6600h */ case    0:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C6600h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C6600h case    0:*/		return 0x820C6604;
		  /* 820C6604h */ case    1:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C6604h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6604h case    1:*/		return 0x820C6608;
	}
	return 0x820C6608;
} // Block from 820C6600h-820C6608h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C6608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6608);
		  /* 820C6608h */ case    0:  		/* rlwinm. R8, R11, 0, 30, 31 */
		/* 820C6608h case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R8,regs.R11);
		/* 820C6608h case    0:*/		return 0x820C660C;
		  /* 820C660Ch */ case    1:  		/* bc 12, CR0_EQ, 176 */
		/* 820C660Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x820C66BC;  }
		/* 820C660Ch case    1:*/		return 0x820C6610;
		  /* 820C6610h */ case    2:  		/* cmplwi CR6, R9, 1 */
		/* 820C6610h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820C6610h case    2:*/		return 0x820C6614;
		  /* 820C6614h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820C6614h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C6624;  }
		/* 820C6614h case    3:*/		return 0x820C6618;
		  /* 820C6618h */ case    4:  		/* lis R9, -32255 */
		/* 820C6618h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C6618h case    4:*/		return 0x820C661C;
		  /* 820C661Ch */ case    5:  		/* addi R4, R9, 10344 */
		/* 820C661Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2868);
		/* 820C661Ch case    5:*/		return 0x820C6620;
		  /* 820C6620h */ case    6:  		/* b 12 */
		/* 820C6620h case    6:*/		return 0x820C662C;
		/* 820C6620h case    6:*/		return 0x820C6624;
	}
	return 0x820C6624;
} // Block from 820C6608h-820C6624h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C6624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6624);
		  /* 820C6624h */ case    0:  		/* lis R9, -32255 */
		/* 820C6624h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C6624h case    0:*/		return 0x820C6628;
		  /* 820C6628h */ case    1:  		/* addi R4, R9, 10360 */
		/* 820C6628h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x2878);
		/* 820C6628h case    1:*/		return 0x820C662C;
	}
	return 0x820C662C;
} // Block from 820C6624h-820C662Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C662Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C662C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C662C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C662C);
		  /* 820C662Ch */ case    0:  		/* addi R9, R11, 3 */
		/* 820C662Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 820C662Ch case    0:*/		return 0x820C6630;
		  /* 820C6630h */ case    1:  		/* mullw. R8, R10, R3 */
		/* 820C6630h case    1:*/		cpu::op::mullw<1>(regs,&regs.R8,regs.R10,regs.R3);
		/* 820C6630h case    1:*/		return 0x820C6634;
		  /* 820C6634h */ case    2:  		/* rlwinm R7, R9, 0, 0, 29 */
		/* 820C6634h case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R7,regs.R9);
		/* 820C6634h case    2:*/		return 0x820C6638;
		  /* 820C6638h */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 820C6638h case    3:*/		if ( regs.CR[0].eq ) { return 0x820C66B8;  }
		/* 820C6638h case    3:*/		return 0x820C663C;
		  /* 820C663Ch */ case    4:  		/* mullw R9, R8, R7 */
		/* 820C663Ch case    4:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R7);
		/* 820C663Ch case    4:*/		return 0x820C6640;
		  /* 820C6640h */ case    5:  		/* mullw R5, R8, R11 */
		/* 820C6640h case    5:*/		cpu::op::mullw<0>(regs,&regs.R5,regs.R8,regs.R11);
		/* 820C6640h case    5:*/		return 0x820C6644;
		  /* 820C6644h */ case    6:  		/* addi R8, R8, -1 */
		/* 820C6644h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820C6644h case    6:*/		return 0x820C6648;
		  /* 820C6648h */ case    7:  		/* subf R5, R11, R5 */
		/* 820C6648h case    7:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 820C6648h case    7:*/		return 0x820C664C;
		  /* 820C664Ch */ case    8:  		/* subf R9, R7, R9 */
		/* 820C664Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820C664Ch case    8:*/		return 0x820C6650;
		  /* 820C6650h */ case    9:  		/* mr R10, R7 */
		/* 820C6650h case    9:*/		regs.R10 = regs.R7;
		/* 820C6650h case    9:*/		return 0x820C6654;
		  /* 820C6654h */ case   10:  		/* cmplw CR6, R7, R11 */
		/* 820C6654h case   10:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C6654h case   10:*/		return 0x820C6658;
		  /* 820C6658h */ case   11:  		/* bc 4, CR6_GT, 40 */
		/* 820C6658h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820C6680;  }
		/* 820C6658h case   11:*/		return 0x820C665C;
		  /* 820C665Ch */ case   12:  		/* subf R31, R11, R7 */
		/* 820C665Ch case   12:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R7);
		/* 820C665Ch case   12:*/		return 0x820C6660;
		  /* 820C6660h */ case   13:  		/* mtspr CTR, R31 */
		/* 820C6660h case   13:*/		regs.CTR = regs.R31;
		/* 820C6660h case   13:*/		return 0x820C6664;
		  /* 820C6664h */ case   14:  		/* addi R10, R10, -1 */
		/* 820C6664h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C6664h case   14:*/		return 0x820C6668;
		  /* 820C6668h */ case   15:  		/* rlwinm R31, R10, 2, 28, 29 */
		/* 820C6668h case   15:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R31,regs.R10);
		/* 820C6668h case   15:*/		return 0x820C666C;
		  /* 820C666Ch */ case   16:  		/* add R30, R10, R9 */
		/* 820C666Ch case   16:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R9);
		/* 820C666Ch case   16:*/		return 0x820C6670;
		  /* 820C6670h */ case   17:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C6670h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C6670h case   17:*/		return 0x820C6674;
		  /* 820C6674h */ case   18:  		/* lwzx R31, <#[R31 + R4]> */
		/* 820C6674h case   18:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R4 + 0x00000000) );
		/* 820C6674h case   18:*/		return 0x820C6678;
		  /* 820C6678h */ case   19:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C6678h case   19:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C6678h case   19:*/		return 0x820C667C;
		  /* 820C667Ch */ case   20:  		/* bc 16, CR0_LT, -24 */
		/* 820C667Ch case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6664;  }
		/* 820C667Ch case   20:*/		return 0x820C6680;
	}
	return 0x820C6680;
} // Block from 820C662Ch-820C6680h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C6680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6680);
		  /* 820C6680h */ case    0:  		/* mr R10, R11 */
		/* 820C6680h case    0:*/		regs.R10 = regs.R11;
		/* 820C6680h case    0:*/		return 0x820C6684;
		  /* 820C6684h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C6684h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C6684h case    1:*/		return 0x820C6688;
		  /* 820C6688h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820C6688h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C66B0;  }
		/* 820C6688h case    2:*/		return 0x820C668C;
		  /* 820C668Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 820C668Ch case    3:*/		regs.CTR = regs.R11;
		/* 820C668Ch case    3:*/		return 0x820C6690;
		  /* 820C6690h */ case    4:  		/* addi R10, R10, -1 */
		/* 820C6690h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C6690h case    4:*/		return 0x820C6694;
		  /* 820C6694h */ case    5:  		/* add R31, R10, R5 */
		/* 820C6694h case    5:*/		cpu::op::add<0>(regs,&regs.R31,regs.R10,regs.R5);
		/* 820C6694h case    5:*/		return 0x820C6698;
		  /* 820C6698h */ case    6:  		/* add R30, R10, R9 */
		/* 820C6698h case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R9);
		/* 820C6698h case    6:*/		return 0x820C669C;
		  /* 820C669Ch */ case    7:  		/* rlwinm R31, R31, 2, 0, 29 */
		/* 820C669Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R31);
		/* 820C669Ch case    7:*/		return 0x820C66A0;
		  /* 820C66A0h */ case    8:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C66A0h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C66A0h case    8:*/		return 0x820C66A4;
		  /* 820C66A4h */ case    9:  		/* lwzx R31, <#[R31 + R26]> */
		/* 820C66A4h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + regs.R26 + 0x00000000) );
		/* 820C66A4h case    9:*/		return 0x820C66A8;
		  /* 820C66A8h */ case   10:  		/* stwx R31, <#[R30 + R6]> */
		/* 820C66A8h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C66A8h case   10:*/		return 0x820C66AC;
		  /* 820C66ACh */ case   11:  		/* bc 16, CR0_LT, -28 */
		/* 820C66ACh case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6690;  }
		/* 820C66ACh case   11:*/		return 0x820C66B0;
	}
	return 0x820C66B0;
} // Block from 820C6680h-820C66B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C66B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C66B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C66B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C66B0);
		  /* 820C66B0h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820C66B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C66B0h case    0:*/		return 0x820C66B4;
		  /* 820C66B4h */ case    1:  		/* bc 4, CR6_EQ, -112 */
		/* 820C66B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C6644;  }
		/* 820C66B4h case    1:*/		return 0x820C66B8;
	}
	return 0x820C66B8;
} // Block from 820C66B0h-820C66B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C66B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C66B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C66B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C66B8);
		  /* 820C66B8h */ case    0:  		/* mr R26, R6 */
		/* 820C66B8h case    0:*/		regs.R26 = regs.R6;
		/* 820C66B8h case    0:*/		return 0x820C66BC;
	}
	return 0x820C66BC;
} // Block from 820C66B8h-820C66BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C66BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C66BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C66BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C66BC);
		  /* 820C66BCh */ case    0:  		/* lwz R10, <#[R24 + 44]> */
		/* 820C66BCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000002C) );
		/* 820C66BCh case    0:*/		return 0x820C66C0;
		  /* 820C66C0h */ case    1:  		/* lhz R11, <#[R24 + 12]> */
		/* 820C66C0h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820C66C0h case    1:*/		return 0x820C66C4;
		  /* 820C66C4h */ case    2:  		/* mullw R7, R10, R3 */
		/* 820C66C4h case    2:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R3);
		/* 820C66C4h case    2:*/		return 0x820C66C8;
		  /* 820C66C8h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820C66C8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C66C8h case    3:*/		return 0x820C66CC;
		  /* 820C66CCh */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 820C66CCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x820C66D4;  }
		/* 820C66CCh case    4:*/		return 0x820C66D0;
		  /* 820C66D0h */ case    5:  		/* mr R7, R11 */
		/* 820C66D0h case    5:*/		regs.R7 = regs.R11;
		/* 820C66D0h case    5:*/		return 0x820C66D4;
	}
	return 0x820C66D4;
} // Block from 820C66BCh-820C66D4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C66D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C66D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C66D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C66D4);
		  /* 820C66D4h */ case    0:  		/* lwz R10, <#[R24 + 28]> */
		/* 820C66D4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 820C66D4h case    0:*/		return 0x820C66D8;
		  /* 820C66D8h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C66D8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C66D8h case    1:*/		return 0x820C66DC;
		  /* 820C66DCh */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C66DCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C66EC;  }
		/* 820C66DCh case    2:*/		return 0x820C66E0;
		  /* 820C66E0h */ case    3:  		/* lis R3, -32768 */
		/* 820C66E0h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C66E0h case    3:*/		return 0x820C66E4;
		  /* 820C66E4h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820C66E4h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C66E4h case    4:*/		return 0x820C66E8;
		  /* 820C66E8h */ case    5:  		/* b 36 */
		/* 820C66E8h case    5:*/		return 0x820C670C;
		/* 820C66E8h case    5:*/		return 0x820C66EC;
	}
	return 0x820C66EC;
} // Block from 820C66D4h-820C66ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C66ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C66EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C66EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C66EC);
		  /* 820C66ECh */ case    0:  		/* lhz R11, <#[R24 + 10]> */
		/* 820C66ECh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000A) );
		/* 820C66ECh case    0:*/		return 0x820C66F0;
		  /* 820C66F0h */ case    1:  		/* mr R5, R26 */
		/* 820C66F0h case    1:*/		regs.R5 = regs.R26;
		/* 820C66F0h case    1:*/		return 0x820C66F4;
		  /* 820C66F4h */ case    2:  		/* mr R3, R23 */
		/* 820C66F4h case    2:*/		regs.R3 = regs.R23;
		/* 820C66F4h case    2:*/		return 0x820C66F8;
		  /* 820C66F8h */ case    3:  		/* mtspr CTR, R10 */
		/* 820C66F8h case    3:*/		regs.CTR = regs.R10;
		/* 820C66F8h case    3:*/		return 0x820C66FC;
		  /* 820C66FCh */ case    4:  		/* add R4, R11, R22 */
		/* 820C66FCh case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R22);
		/* 820C66FCh case    4:*/		return 0x820C6700;
		  /* 820C6700h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820C6700h case    5:*/		if ( 1 ) { regs.LR = 0x820C6704; return (uint32)regs.CTR; }
		/* 820C6700h case    5:*/		return 0x820C6704;
		  /* 820C6704h */ case    6:  		/* srawi R11, R3, 31 */
		/* 820C6704h case    6:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820C6704h case    6:*/		return 0x820C6708;
		  /* 820C6708h */ case    7:  		/* and R3, R11, R3 */
		/* 820C6708h case    7:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C6708h case    7:*/		return 0x820C670C;
	}
	return 0x820C670C;
} // Block from 820C66ECh-820C670Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C670Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C670C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C670C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C670C);
		  /* 820C670Ch */ case    0:  		/* addi R1, R1, 176 */
		/* 820C670Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820C670Ch case    0:*/		return 0x820C6710;
		  /* 820C6710h */ case    1:  		/* b -218240 */
		/* 820C6710h case    1:*/		return 0x82091290;
		/* 820C6710h case    1:*/		return 0x820C6714;
		  /* 820C6714h */ case    2:  		/* nop */
		/* 820C6714h case    2:*/		cpu::op::nop();
		/* 820C6714h case    2:*/		return 0x820C6718;
	}
	return 0x820C6718;
} // Block from 820C670Ch-820C6718h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C6718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6718);
		  /* 820C6718h */ case    0:  		/* mfspr R12, LR */
		/* 820C6718h case    0:*/		regs.R12 = regs.LR;
		/* 820C6718h case    0:*/		return 0x820C671C;
		  /* 820C671Ch */ case    1:  		/* bl -218332 */
		/* 820C671Ch case    1:*/		regs.LR = 0x820C6720; return 0x82091240;
		/* 820C671Ch case    1:*/		return 0x820C6720;
	}
	return 0x820C6720;
} // Block from 820C6718h-820C6720h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C6720h
// Function '?Set@?$SetTyped@$00$02$00$03$0A@@D3DXShader@@SAJPAVCConstant@2@PBX1II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6720);
		  /* 820C6720h */ case    0:  		/* stwu R1, <#[R1 - 176]> */
		/* 820C6720h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820C6720h case    0:*/		return 0x820C6724;
		  /* 820C6724h */ case    1:  		/* lwz R25, <#[R3 + 24]> */
		/* 820C6724h case    1:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R3 + 0x00000018) );
		/* 820C6724h case    1:*/		return 0x820C6728;
		  /* 820C6728h */ case    2:  		/* mr R23, R4 */
		/* 820C6728h case    2:*/		regs.R23 = regs.R4;
		/* 820C6728h case    2:*/		return 0x820C672C;
		  /* 820C672Ch */ case    3:  		/* mr R11, R6 */
		/* 820C672Ch case    3:*/		regs.R11 = regs.R6;
		/* 820C672Ch case    3:*/		return 0x820C6730;
		  /* 820C6730h */ case    4:  		/* lwz R6, <#[R3 + 32]> */
		/* 820C6730h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000020) );
		/* 820C6730h case    4:*/		return 0x820C6734;
		  /* 820C6734h */ case    5:  		/* mr R24, R3 */
		/* 820C6734h case    5:*/		regs.R24 = regs.R3;
		/* 820C6734h case    5:*/		return 0x820C6738;
		  /* 820C6738h */ case    6:  		/* mr R4, R5 */
		/* 820C6738h case    6:*/		regs.R4 = regs.R5;
		/* 820C6738h case    6:*/		return 0x820C673C;
		  /* 820C673Ch */ case    7:  		/* mr R22, R7 */
		/* 820C673Ch case    7:*/		regs.R22 = regs.R7;
		/* 820C673Ch case    7:*/		return 0x820C6740;
		  /* 820C6740h */ case    8:  		/* lhz R10, <#[R25]> */
		/* 820C6740h case    8:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 820C6740h case    8:*/		return 0x820C6744;
		  /* 820C6744h */ case    9:  		/* cmplwi CR6, R10, 1 */
		/* 820C6744h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C6744h case    9:*/		return 0x820C6748;
		  /* 820C6748h */ case   10:  		/* bc 12, CR6_LT, 708 */
		/* 820C6748h case   10:*/		if ( regs.CR[6].lt ) { return 0x820C6A0C;  }
		/* 820C6748h case   10:*/		return 0x820C674C;
		  /* 820C674Ch */ case   11:  		/* bc 12, CR6_EQ, 576 */
		/* 820C674Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820C698C;  }
		/* 820C674Ch case   11:*/		return 0x820C6750;
		  /* 820C6750h */ case   12:  		/* cmplwi CR6, R10, 3 */
		/* 820C6750h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C6750h case   12:*/		return 0x820C6754;
		  /* 820C6754h */ case   13:  		/* bc 12, CR6_LT, 404 */
		/* 820C6754h case   13:*/		if ( regs.CR[6].lt ) { return 0x820C68E8;  }
		/* 820C6754h case   13:*/		return 0x820C6758;
		  /* 820C6758h */ case   14:  		/* bc 12, CR6_EQ, 244 */
		/* 820C6758h case   14:*/		if ( regs.CR[6].eq ) { return 0x820C684C;  }
		/* 820C6758h case   14:*/		return 0x820C675C;
		  /* 820C675Ch */ case   15:  		/* cmplwi CR6, R10, 5 */
		/* 820C675Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000005);
		/* 820C675Ch case   15:*/		return 0x820C6760;
		  /* 820C6760h */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 820C6760h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C6770;  }
		/* 820C6760h case   16:*/		return 0x820C6764;
		  /* 820C6764h */ case   17:  		/* lis R3, -32768 */
		/* 820C6764h case   17:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C6764h case   17:*/		return 0x820C6768;
		  /* 820C6768h */ case   18:  		/* ori R3, R3, 16385 */
		/* 820C6768h case   18:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 820C6768h case   18:*/		return 0x820C676C;
		  /* 820C676Ch */ case   19:  		/* b 1184 */
		/* 820C676Ch case   19:*/		return 0x820C6C0C;
		/* 820C676Ch case   19:*/		return 0x820C6770;
	}
	return 0x820C6770;
} // Block from 820C6720h-820C6770h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C6770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6770);
		  /* 820C6770h */ case    0:  		/* lwz R10, <#[R24 + 52]> */
		/* 820C6770h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000034) );
		/* 820C6770h case    0:*/		return 0x820C6774;
		  /* 820C6774h */ case    1:  		/* rlwinm R9, R11, 4, 0, 27 */
		/* 820C6774h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R9,regs.R11);
		/* 820C6774h case    1:*/		return 0x820C6778;
		  /* 820C6778h */ case    2:  		/* lhz R11, <#[R25 + 8]> */
		/* 820C6778h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820C6778h case    2:*/		return 0x820C677C;
		  /* 820C677Ch */ case    3:  		/* divwu R27, R9, R10 */
		/* 820C677Ch case    3:*/		cpu::op::divwu<0>(regs,&regs.R27,regs.R9,regs.R10);
		/* 820C677Ch case    3:*/		return 0x820C6780;
		  /* 820C6780h */ case    4:  		/* twi 6, R10, 0 */
		/* 820C6780h case    4:*/		cpu::op::tw<6>(regs, 0x820C6780, regs.R10, 0x00000000);
		/* 820C6780h case    4:*/		return 0x820C6784;
		  /* 820C6784h */ case    5:  		/* cmplw CR6, R27, R11 */
		/* 820C6784h case    5:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820C6784h case    5:*/		return 0x820C6788;
		  /* 820C6788h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 820C6788h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820C6790;  }
		/* 820C6788h case    6:*/		return 0x820C678C;
		  /* 820C678Ch */ case    7:  		/* mr R27, R11 */
		/* 820C678Ch case    7:*/		regs.R27 = regs.R11;
		/* 820C678Ch case    7:*/		return 0x820C6790;
	}
	return 0x820C6790;
} // Block from 820C6770h-820C6790h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C6790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6790);
		  /* 820C6790h */ case    0:  		/* mullw. R10, R10, R27 */
		/* 820C6790h case    0:*/		cpu::op::mullw<1>(regs,&regs.R10,regs.R10,regs.R27);
		/* 820C6790h case    0:*/		return 0x820C6794;
		  /* 820C6794h */ case    1:  		/* li R11, 0 */
		/* 820C6794h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6794h case    1:*/		return 0x820C6798;
		  /* 820C6798h */ case    2:  		/* bc 12, CR0_EQ, 52 */
		/* 820C6798h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C67CC;  }
		/* 820C6798h case    2:*/		return 0x820C679C;
		  /* 820C679Ch */ case    3:  		/* mtspr CTR, R10 */
		/* 820C679Ch case    3:*/		regs.CTR = regs.R10;
		/* 820C679Ch case    3:*/		return 0x820C67A0;
		  /* 820C67A0h */ case    4:  		/* addi R10, R6, -4 */
		/* 820C67A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C67A0h case    4:*/		return 0x820C67A4;
		  /* 820C67A4h */ case    5:  		/* rlwinm R8, R11, 0, 28, 29 */
		/* 820C67A4h case    5:*/		cpu::op::rlwinm<0,0,28,29>(regs,&regs.R8,regs.R11);
		/* 820C67A4h case    5:*/		return 0x820C67A8;
		  /* 820C67A8h */ case    6:  		/* rlwinm R9, R11, 0, 30, 31 */
		/* 820C67A8h case    6:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R11);
		/* 820C67A8h case    6:*/		return 0x820C67AC;
		  /* 820C67ACh */ case    7:  		/* rlwinm R7, R11, 30, 2, 29 */
		/* 820C67ACh case    7:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R7,regs.R11);
		/* 820C67ACh case    7:*/		return 0x820C67B0;
		  /* 820C67B0h */ case    8:  		/* add R9, R8, R9 */
		/* 820C67B0h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C67B0h case    8:*/		return 0x820C67B4;
		  /* 820C67B4h */ case    9:  		/* addi R11, R11, 1 */
		/* 820C67B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C67B4h case    9:*/		return 0x820C67B8;
		  /* 820C67B8h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C67B8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C67B8h case   10:*/		return 0x820C67BC;
		  /* 820C67BCh */ case   11:  		/* lwzx R8, <#[R7 + R4]> */
		/* 820C67BCh case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R4 + 0x00000000) );
		/* 820C67BCh case   11:*/		return 0x820C67C0;
		  /* 820C67C0h */ case   12:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820C67C0h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820C67C0h case   12:*/		return 0x820C67C4;
		  /* 820C67C4h */ case   13:  		/* stwu R9, <#[R10 + 4]> */
		/* 820C67C4h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C67C4h case   13:*/		return 0x820C67C8;
		  /* 820C67C8h */ case   14:  		/* bc 16, CR0_LT, -36 */
		/* 820C67C8h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C67A4;  }
		/* 820C67C8h case   14:*/		return 0x820C67CC;
	}
	return 0x820C67CC;
} // Block from 820C6790h-820C67CCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C67CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C67CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C67CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C67CC);
		  /* 820C67CCh */ case    0:  		/* mr R29, R6 */
		/* 820C67CCh case    0:*/		regs.R29 = regs.R6;
		/* 820C67CCh case    0:*/		return 0x820C67D0;
		  /* 820C67D0h */ case    1:  		/* li R26, 0 */
		/* 820C67D0h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820C67D0h case    1:*/		return 0x820C67D4;
		  /* 820C67D4h */ case    2:  		/* cmplwi CR6, R27, 0 */
		/* 820C67D4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820C67D4h case    2:*/		return 0x820C67D8;
		  /* 820C67D8h */ case    3:  		/* bc 12, CR6_EQ, 108 */
		/* 820C67D8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C6844;  }
		/* 820C67D8h case    3:*/		return 0x820C67DC;
		  /* 820C67DCh */ case    4:  		/* lhz R11, <#[R25 + 10]> */
		/* 820C67DCh case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000A) );
		/* 820C67DCh case    4:*/		return 0x820C67E0;
		  /* 820C67E0h */ case    5:  		/* li R28, 0 */
		/* 820C67E0h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820C67E0h case    5:*/		return 0x820C67E4;
		  /* 820C67E4h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 820C67E4h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C67E4h case    6:*/		return 0x820C67E8;
		  /* 820C67E8h */ case    7:  		/* bc 12, CR0_EQ, 80 */
		/* 820C67E8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820C6838;  }
		/* 820C67E8h case    7:*/		return 0x820C67EC;
		  /* 820C67ECh */ case    8:  		/* li R30, 0 */
		/* 820C67ECh case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C67ECh case    8:*/		return 0x820C67F0;
		  /* 820C67F0h */ case    9:  		/* lwz R11, <#[R24 + 56]> */
		/* 820C67F0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 820C67F0h case    9:*/		return 0x820C67F4;
		  /* 820C67F4h */ case   10:  		/* mr R7, R22 */
		/* 820C67F4h case   10:*/		regs.R7 = regs.R22;
		/* 820C67F4h case   10:*/		return 0x820C67F8;
		  /* 820C67F8h */ case   11:  		/* mr R5, R29 */
		/* 820C67F8h case   11:*/		regs.R5 = regs.R29;
		/* 820C67F8h case   11:*/		return 0x820C67FC;
		  /* 820C67FCh */ case   12:  		/* mr R4, R23 */
		/* 820C67FCh case   12:*/		regs.R4 = regs.R23;
		/* 820C67FCh case   12:*/		return 0x820C6800;
		  /* 820C6800h */ case   13:  		/* lwzx R31, <#[R11 + R30]> */
		/* 820C6800h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820C6800h case   13:*/		return 0x820C6804;
		  /* 820C6804h */ case   14:  		/* mr R3, R31 */
		/* 820C6804h case   14:*/		regs.R3 = regs.R31;
		/* 820C6804h case   14:*/		return 0x820C6808;
		  /* 820C6808h */ case   15:  		/* lwz R6, <#[R31 + 48]> */
		/* 820C6808h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000030) );
		/* 820C6808h case   15:*/		return 0x820C680C;
		  /* 820C680Ch */ case   16:  		/* bl -3756 */
		/* 820C680Ch case   16:*/		regs.LR = 0x820C6810; return 0x820C5960;
		/* 820C680Ch case   16:*/		return 0x820C6810;
		  /* 820C6810h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820C6810h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C6810h case   17:*/		return 0x820C6814;
		  /* 820C6814h */ case   18:  		/* bc 12, CR0_LT, 1016 */
		/* 820C6814h case   18:*/		if ( regs.CR[0].lt ) { return 0x820C6C0C;  }
		/* 820C6814h case   18:*/		return 0x820C6818;
		  /* 820C6818h */ case   19:  		/* lwz R11, <#[R31 + 48]> */
		/* 820C6818h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820C6818h case   19:*/		return 0x820C681C;
		  /* 820C681Ch */ case   20:  		/* addi R28, R28, 1 */
		/* 820C681Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820C681Ch case   20:*/		return 0x820C6820;
		  /* 820C6820h */ case   21:  		/* lhz R10, <#[R25 + 10]> */
		/* 820C6820h case   21:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x0000000A) );
		/* 820C6820h case   21:*/		return 0x820C6824;
		  /* 820C6824h */ case   22:  		/* addi R30, R30, 4 */
		/* 820C6824h case   22:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C6824h case   22:*/		return 0x820C6828;
		  /* 820C6828h */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C6828h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C6828h case   23:*/		return 0x820C682C;
		  /* 820C682Ch */ case   24:  		/* cmplw CR6, R28, R10 */
		/* 820C682Ch case   24:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 820C682Ch case   24:*/		return 0x820C6830;
		  /* 820C6830h */ case   25:  		/* add R29, R11, R29 */
		/* 820C6830h case   25:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 820C6830h case   25:*/		return 0x820C6834;
		  /* 820C6834h */ case   26:  		/* bc 12, CR6_LT, -68 */
		/* 820C6834h case   26:*/		if ( regs.CR[6].lt ) { return 0x820C67F0;  }
		/* 820C6834h case   26:*/		return 0x820C6838;
	}
	return 0x820C6838;
} // Block from 820C67CCh-820C6838h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820C6838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6838);
		  /* 820C6838h */ case    0:  		/* addi R26, R26, 1 */
		/* 820C6838h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820C6838h case    0:*/		return 0x820C683C;
		  /* 820C683Ch */ case    1:  		/* cmplw CR6, R26, R27 */
		/* 820C683Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R27);
		/* 820C683Ch case    1:*/		return 0x820C6840;
		  /* 820C6840h */ case    2:  		/* bc 12, CR6_LT, -100 */
		/* 820C6840h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C67DC;  }
		/* 820C6840h case    2:*/		return 0x820C6844;
	}
	return 0x820C6844;
} // Block from 820C6838h-820C6844h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C6844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6844);
		  /* 820C6844h */ case    0:  		/* li R3, 0 */
		/* 820C6844h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C6844h case    0:*/		return 0x820C6848;
		  /* 820C6848h */ case    1:  		/* b 964 */
		/* 820C6848h case    1:*/		return 0x820C6C0C;
		/* 820C6848h case    1:*/		return 0x820C684C;
	}
	return 0x820C684C;
} // Block from 820C6844h-820C684Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C684Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C684C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C684C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C684C);
		  /* 820C684Ch */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C684Ch case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C684Ch case    0:*/		return 0x820C6850;
		  /* 820C6850h */ case    1:  		/* mr R31, R11 */
		/* 820C6850h case    1:*/		regs.R31 = regs.R11;
		/* 820C6850h case    1:*/		return 0x820C6854;
		  /* 820C6854h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C6854h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C6854h case    2:*/		return 0x820C6858;
		  /* 820C6858h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C6858h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C6860;  }
		/* 820C6858h case    3:*/		return 0x820C685C;
		  /* 820C685Ch */ case    4:  		/* mr R31, R10 */
		/* 820C685Ch case    4:*/		regs.R31 = regs.R10;
		/* 820C685Ch case    4:*/		return 0x820C6860;
	}
	return 0x820C6860;
} // Block from 820C684Ch-820C6860h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6860);
		  /* 820C6860h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820C6860h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C6860h case    0:*/		return 0x820C6864;
		  /* 820C6864h */ case    1:  		/* bc 12, CR6_EQ, 504 */
		/* 820C6864h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C6A5C;  }
		/* 820C6864h case    1:*/		return 0x820C6868;
		  /* 820C6868h */ case    2:  		/* mtspr CTR, R31 */
		/* 820C6868h case    2:*/		regs.CTR = regs.R31;
		/* 820C6868h case    2:*/		return 0x820C686C;
		  /* 820C686Ch */ case    3:  		/* addi R8, R6, -4 */
		/* 820C686Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R6,0xFFFFFFFC);
		/* 820C686Ch case    3:*/		return 0x820C6870;
		  /* 820C6870h */ case    4:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C6870h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6870h case    4:*/		return 0x820C6874;
		  /* 820C6874h */ case    5:  		/* li R7, 0 */
		/* 820C6874h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C6874h case    5:*/		return 0x820C6878;
		  /* 820C6878h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 820C6878h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C6878h case    6:*/		return 0x820C687C;
		  /* 820C687Ch */ case    7:  		/* bc 12, CR0_EQ, 96 */
		/* 820C687Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820C68DC;  }
		/* 820C687Ch case    7:*/		return 0x820C6880;
		  /* 820C6880h */ case    8:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C6880h case    8:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C6880h case    8:*/		return 0x820C6884;
		  /* 820C6884h */ case    9:  		/* li R10, 0 */
		/* 820C6884h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C6884h case    9:*/		return 0x820C6888;
		  /* 820C6888h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 820C6888h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C6888h case   10:*/		return 0x820C688C;
		  /* 820C688Ch */ case   11:  		/* bc 12, CR6_EQ, 64 */
		/* 820C688Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x820C68CC;  }
		/* 820C688Ch case   11:*/		return 0x820C6890;
		  /* 820C6890h */ case   12:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 820C6890h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 820C6890h case   12:*/		return 0x820C6894;
		  /* 820C6894h */ case   13:  		/* cmplwi CR6, R10, 4 */
		/* 820C6894h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820C6894h case   13:*/		return 0x820C6898;
		  /* 820C6898h */ case   14:  		/* bc 12, CR6_GT, 24 */
		/* 820C6898h case   14:*/		if ( regs.CR[6].gt ) { return 0x820C68B0;  }
		/* 820C6898h case   14:*/		return 0x820C689C;
		  /* 820C689Ch */ case   15:  		/* cmplwi CR6, R7, 4 */
		/* 820C689Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000004);
		/* 820C689Ch case   15:*/		return 0x820C68A0;
		  /* 820C68A0h */ case   16:  		/* bc 12, CR6_GT, 16 */
		/* 820C68A0h case   16:*/		if ( regs.CR[6].gt ) { return 0x820C68B0;  }
		/* 820C68A0h case   16:*/		return 0x820C68A4;
		  /* 820C68A4h */ case   17:  		/* lwz R11, <#[R4]> */
		/* 820C68A4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820C68A4h case   17:*/		return 0x820C68A8;
		  /* 820C68A8h */ case   18:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820C68A8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820C68A8h case   18:*/		return 0x820C68AC;
		  /* 820C68ACh */ case   19:  		/* b 8 */
		/* 820C68ACh case   19:*/		return 0x820C68B4;
		/* 820C68ACh case   19:*/		return 0x820C68B0;
	}
	return 0x820C68B0;
} // Block from 820C6860h-820C68B0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C68B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C68B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C68B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C68B0);
		  /* 820C68B0h */ case    0:  		/* li R11, 0 */
		/* 820C68B0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C68B0h case    0:*/		return 0x820C68B4;
	}
	return 0x820C68B4;
} // Block from 820C68B0h-820C68B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C68B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C68B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C68B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C68B4);
		  /* 820C68B4h */ case    0:  		/* addi R10, R10, 1 */
		/* 820C68B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C68B4h case    0:*/		return 0x820C68B8;
		  /* 820C68B8h */ case    1:  		/* stwu R11, <#[R8 + 4]> */
		/* 820C68B8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 820C68B8h case    1:*/		return 0x820C68BC;
		  /* 820C68BCh */ case    2:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C68BCh case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C68BCh case    2:*/		return 0x820C68C0;
		  /* 820C68C0h */ case    3:  		/* addi R9, R9, 16 */
		/* 820C68C0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x10);
		/* 820C68C0h case    3:*/		return 0x820C68C4;
		  /* 820C68C4h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 820C68C4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820C68C4h case    4:*/		return 0x820C68C8;
		  /* 820C68C8h */ case    5:  		/* bc 12, CR6_LT, -52 */
		/* 820C68C8h case    5:*/		if ( regs.CR[6].lt ) { return 0x820C6894;  }
		/* 820C68C8h case    5:*/		return 0x820C68CC;
	}
	return 0x820C68CC;
} // Block from 820C68B4h-820C68CCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C68CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C68CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C68CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C68CC);
		  /* 820C68CCh */ case    0:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C68CCh case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C68CCh case    0:*/		return 0x820C68D0;
		  /* 820C68D0h */ case    1:  		/* addi R7, R7, 1 */
		/* 820C68D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820C68D0h case    1:*/		return 0x820C68D4;
		  /* 820C68D4h */ case    2:  		/* cmplw CR6, R7, R10 */
		/* 820C68D4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 820C68D4h case    2:*/		return 0x820C68D8;
		  /* 820C68D8h */ case    3:  		/* bc 12, CR6_LT, -84 */
		/* 820C68D8h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C6884;  }
		/* 820C68D8h case    3:*/		return 0x820C68DC;
	}
	return 0x820C68DC;
} // Block from 820C68CCh-820C68DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C68DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C68DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C68DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C68DC);
		  /* 820C68DCh */ case    0:  		/* addi R4, R4, 4 */
		/* 820C68DCh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 820C68DCh case    0:*/		return 0x820C68E0;
		  /* 820C68E0h */ case    1:  		/* bc 16, CR0_LT, -112 */
		/* 820C68E0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6870;  }
		/* 820C68E0h case    1:*/		return 0x820C68E4;
		  /* 820C68E4h */ case    2:  		/* b 376 */
		/* 820C68E4h case    2:*/		return 0x820C6A5C;
		/* 820C68E4h case    2:*/		return 0x820C68E8;
	}
	return 0x820C68E8;
} // Block from 820C68DCh-820C68E8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C68E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C68E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C68E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C68E8);
		  /* 820C68E8h */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C68E8h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C68E8h case    0:*/		return 0x820C68EC;
		  /* 820C68ECh */ case    1:  		/* mr R31, R11 */
		/* 820C68ECh case    1:*/		regs.R31 = regs.R11;
		/* 820C68ECh case    1:*/		return 0x820C68F0;
		  /* 820C68F0h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C68F0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C68F0h case    2:*/		return 0x820C68F4;
		  /* 820C68F4h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C68F4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C68FC;  }
		/* 820C68F4h case    3:*/		return 0x820C68F8;
		  /* 820C68F8h */ case    4:  		/* mr R31, R10 */
		/* 820C68F8h case    4:*/		regs.R31 = regs.R10;
		/* 820C68F8h case    4:*/		return 0x820C68FC;
	}
	return 0x820C68FC;
} // Block from 820C68E8h-820C68FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C68FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C68FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C68FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C68FC);
		  /* 820C68FCh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820C68FCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C68FCh case    0:*/		return 0x820C6900;
		  /* 820C6900h */ case    1:  		/* bc 12, CR6_EQ, 348 */
		/* 820C6900h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C6A5C;  }
		/* 820C6900h case    1:*/		return 0x820C6904;
		  /* 820C6904h */ case    2:  		/* mtspr CTR, R31 */
		/* 820C6904h case    2:*/		regs.CTR = regs.R31;
		/* 820C6904h case    2:*/		return 0x820C6908;
		  /* 820C6908h */ case    3:  		/* addi R8, R6, -4 */
		/* 820C6908h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R6,0xFFFFFFFC);
		/* 820C6908h case    3:*/		return 0x820C690C;
		  /* 820C690Ch */ case    4:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C690Ch case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C690Ch case    4:*/		return 0x820C6910;
		  /* 820C6910h */ case    5:  		/* li R7, 0 */
		/* 820C6910h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C6910h case    5:*/		return 0x820C6914;
		  /* 820C6914h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 820C6914h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C6914h case    6:*/		return 0x820C6918;
		  /* 820C6918h */ case    7:  		/* bc 12, CR0_EQ, 104 */
		/* 820C6918h case    7:*/		if ( regs.CR[0].eq ) { return 0x820C6980;  }
		/* 820C6918h case    7:*/		return 0x820C691C;
		  /* 820C691Ch */ case    8:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C691Ch case    8:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C691Ch case    8:*/		return 0x820C6920;
		  /* 820C6920h */ case    9:  		/* li R9, 0 */
		/* 820C6920h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C6920h case    9:*/		return 0x820C6924;
		  /* 820C6924h */ case   10:  		/* li R11, 0 */
		/* 820C6924h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6924h case   10:*/		return 0x820C6928;
		  /* 820C6928h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 820C6928h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C6928h case   11:*/		return 0x820C692C;
		  /* 820C692Ch */ case   12:  		/* bc 12, CR6_EQ, 64 */
		/* 820C692Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820C696C;  }
		/* 820C692Ch case   12:*/		return 0x820C6930;
		  /* 820C6930h */ case   13:  		/* cmplwi CR6, R9, 16 */
		/* 820C6930h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000010);
		/* 820C6930h case   13:*/		return 0x820C6934;
		  /* 820C6934h */ case   14:  		/* bc 12, CR6_GT, 32 */
		/* 820C6934h case   14:*/		if ( regs.CR[6].gt ) { return 0x820C6954;  }
		/* 820C6934h case   14:*/		return 0x820C6938;
		  /* 820C6938h */ case   15:  		/* cmplwi CR6, R11, 4 */
		/* 820C6938h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C6938h case   15:*/		return 0x820C693C;
		  /* 820C693Ch */ case   16:  		/* bc 12, CR6_GT, 24 */
		/* 820C693Ch case   16:*/		if ( regs.CR[6].gt ) { return 0x820C6954;  }
		/* 820C693Ch case   16:*/		return 0x820C6940;
		  /* 820C6940h */ case   17:  		/* add R10, R9, R11 */
		/* 820C6940h case   17:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R11);
		/* 820C6940h case   17:*/		return 0x820C6944;
		  /* 820C6944h */ case   18:  		/* lwz R5, <#[R4]> */
		/* 820C6944h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x00000000) );
		/* 820C6944h case   18:*/		return 0x820C6948;
		  /* 820C6948h */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C6948h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C6948h case   19:*/		return 0x820C694C;
		  /* 820C694Ch */ case   20:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C694Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C694Ch case   20:*/		return 0x820C6950;
		  /* 820C6950h */ case   21:  		/* b 8 */
		/* 820C6950h case   21:*/		return 0x820C6958;
		/* 820C6950h case   21:*/		return 0x820C6954;
	}
	return 0x820C6954;
} // Block from 820C68FCh-820C6954h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C6954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6954);
		  /* 820C6954h */ case    0:  		/* li R10, 0 */
		/* 820C6954h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C6954h case    0:*/		return 0x820C6958;
	}
	return 0x820C6958;
} // Block from 820C6954h-820C6958h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C6958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6958);
		  /* 820C6958h */ case    0:  		/* addi R11, R11, 1 */
		/* 820C6958h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C6958h case    0:*/		return 0x820C695C;
		  /* 820C695Ch */ case    1:  		/* stwu R10, <#[R8 + 4]> */
		/* 820C695Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 820C695Ch case    1:*/		return 0x820C6960;
		  /* 820C6960h */ case    2:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C6960h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6960h case    2:*/		return 0x820C6964;
		  /* 820C6964h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C6964h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C6964h case    3:*/		return 0x820C6968;
		  /* 820C6968h */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 820C6968h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C6930;  }
		/* 820C6968h case    4:*/		return 0x820C696C;
	}
	return 0x820C696C;
} // Block from 820C6958h-820C696Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C696Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C696C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C696C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C696C);
		  /* 820C696Ch */ case    0:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C696Ch case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C696Ch case    0:*/		return 0x820C6970;
		  /* 820C6970h */ case    1:  		/* addi R7, R7, 1 */
		/* 820C6970h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820C6970h case    1:*/		return 0x820C6974;
		  /* 820C6974h */ case    2:  		/* addi R9, R9, 4 */
		/* 820C6974h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820C6974h case    2:*/		return 0x820C6978;
		  /* 820C6978h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820C6978h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C6978h case    3:*/		return 0x820C697C;
		  /* 820C697Ch */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 820C697Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x820C6924;  }
		/* 820C697Ch case    4:*/		return 0x820C6980;
	}
	return 0x820C6980;
} // Block from 820C696Ch-820C6980h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6980);
		  /* 820C6980h */ case    0:  		/* addi R4, R4, 4 */
		/* 820C6980h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 820C6980h case    0:*/		return 0x820C6984;
		  /* 820C6984h */ case    1:  		/* bc 16, CR0_LT, -120 */
		/* 820C6984h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C690C;  }
		/* 820C6984h case    1:*/		return 0x820C6988;
		  /* 820C6988h */ case    2:  		/* b 212 */
		/* 820C6988h case    2:*/		return 0x820C6A5C;
		/* 820C6988h case    2:*/		return 0x820C698C;
	}
	return 0x820C698C;
} // Block from 820C6980h-820C698Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C698Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C698C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C698C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C698C);
		  /* 820C698Ch */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C698Ch case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C698Ch case    0:*/		return 0x820C6990;
		  /* 820C6990h */ case    1:  		/* rlwinm R31, R11, 2, 0, 29 */
		/* 820C6990h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R11);
		/* 820C6990h case    1:*/		return 0x820C6994;
		  /* 820C6994h */ case    2:  		/* cmplw CR6, R31, R10 */
		/* 820C6994h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 820C6994h case    2:*/		return 0x820C6998;
		  /* 820C6998h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C6998h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C69A0;  }
		/* 820C6998h case    3:*/		return 0x820C699C;
		  /* 820C699Ch */ case    4:  		/* mr R31, R10 */
		/* 820C699Ch case    4:*/		regs.R31 = regs.R10;
		/* 820C699Ch case    4:*/		return 0x820C69A0;
	}
	return 0x820C69A0;
} // Block from 820C698Ch-820C69A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C69A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C69A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C69A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C69A0);
		  /* 820C69A0h */ case    0:  		/* li R9, 0 */
		/* 820C69A0h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C69A0h case    0:*/		return 0x820C69A4;
		  /* 820C69A4h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820C69A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C69A4h case    1:*/		return 0x820C69A8;
		  /* 820C69A8h */ case    2:  		/* bc 12, CR6_EQ, 180 */
		/* 820C69A8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C6A5C;  }
		/* 820C69A8h case    2:*/		return 0x820C69AC;
		  /* 820C69ACh */ case    3:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C69ACh case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C69ACh case    3:*/		return 0x820C69B0;
		  /* 820C69B0h */ case    4:  		/* addi R8, R6, -4 */
		/* 820C69B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R6,0xFFFFFFFC);
		/* 820C69B0h case    4:*/		return 0x820C69B4;
		  /* 820C69B4h */ case    5:  		/* li R11, 0 */
		/* 820C69B4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C69B4h case    5:*/		return 0x820C69B8;
		  /* 820C69B8h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 820C69B8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C69B8h case    6:*/		return 0x820C69BC;
		  /* 820C69BCh */ case    7:  		/* bc 12, CR6_EQ, 64 */
		/* 820C69BCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820C69FC;  }
		/* 820C69BCh case    7:*/		return 0x820C69C0;
		  /* 820C69C0h */ case    8:  		/* cmplwi CR6, R11, 4 */
		/* 820C69C0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C69C0h case    8:*/		return 0x820C69C4;
		  /* 820C69C4h */ case    9:  		/* bc 4, CR6_GT, 12 */
		/* 820C69C4h case    9:*/		if ( !regs.CR[6].gt ) { return 0x820C69D0;  }
		/* 820C69C4h case    9:*/		return 0x820C69C8;
		  /* 820C69C8h */ case   10:  		/* li R10, 0 */
		/* 820C69C8h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C69C8h case   10:*/		return 0x820C69CC;
		  /* 820C69CCh */ case   11:  		/* b 28 */
		/* 820C69CCh case   11:*/		return 0x820C69E8;
		/* 820C69CCh case   11:*/		return 0x820C69D0;
	}
	return 0x820C69D0;
} // Block from 820C69A0h-820C69D0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C69D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C69D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C69D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C69D0);
		  /* 820C69D0h */ case    0:  		/* rlwinm R10, R9, 2, 28, 29 */
		/* 820C69D0h case    0:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R10,regs.R9);
		/* 820C69D0h case    0:*/		return 0x820C69D4;
		  /* 820C69D4h */ case    1:  		/* rlwinm R7, R9, 0, 0, 29 */
		/* 820C69D4h case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R7,regs.R9);
		/* 820C69D4h case    1:*/		return 0x820C69D8;
		  /* 820C69D8h */ case    2:  		/* add R10, R10, R11 */
		/* 820C69D8h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C69D8h case    2:*/		return 0x820C69DC;
		  /* 820C69DCh */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C69DCh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C69DCh case    3:*/		return 0x820C69E0;
		  /* 820C69E0h */ case    4:  		/* lwzx R7, <#[R7 + R4]> */
		/* 820C69E0h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R4 + 0x00000000) );
		/* 820C69E0h case    4:*/		return 0x820C69E4;
		  /* 820C69E4h */ case    5:  		/* lwzx R10, <#[R10 + R7]> */
		/* 820C69E4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 820C69E4h case    5:*/		return 0x820C69E8;
	}
	return 0x820C69E8;
} // Block from 820C69D0h-820C69E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C69E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C69E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C69E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C69E8);
		  /* 820C69E8h */ case    0:  		/* stwu R10, <#[R8 + 4]> */
		/* 820C69E8h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 820C69E8h case    0:*/		return 0x820C69EC;
		  /* 820C69ECh */ case    1:  		/* addi R11, R11, 1 */
		/* 820C69ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C69ECh case    1:*/		return 0x820C69F0;
		  /* 820C69F0h */ case    2:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C69F0h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C69F0h case    2:*/		return 0x820C69F4;
		  /* 820C69F4h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C69F4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C69F4h case    3:*/		return 0x820C69F8;
		  /* 820C69F8h */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 820C69F8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C69C0;  }
		/* 820C69F8h case    4:*/		return 0x820C69FC;
	}
	return 0x820C69FC;
} // Block from 820C69E8h-820C69FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C69FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C69FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C69FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C69FC);
		  /* 820C69FCh */ case    0:  		/* addi R9, R9, 1 */
		/* 820C69FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C69FCh case    0:*/		return 0x820C6A00;
		  /* 820C6A00h */ case    1:  		/* cmplw CR6, R9, R31 */
		/* 820C6A00h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 820C6A00h case    1:*/		return 0x820C6A04;
		  /* 820C6A04h */ case    2:  		/* bc 12, CR6_LT, -80 */
		/* 820C6A04h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C69B4;  }
		/* 820C6A04h case    2:*/		return 0x820C6A08;
		  /* 820C6A08h */ case    3:  		/* b 84 */
		/* 820C6A08h case    3:*/		return 0x820C6A5C;
		/* 820C6A08h case    3:*/		return 0x820C6A0C;
	}
	return 0x820C6A0C;
} // Block from 820C69FCh-820C6A0Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C6A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6A0C);
		  /* 820C6A0Ch */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C6A0Ch case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C6A0Ch case    0:*/		return 0x820C6A10;
		  /* 820C6A10h */ case    1:  		/* rlwinm R31, R11, 4, 0, 27 */
		/* 820C6A10h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R31,regs.R11);
		/* 820C6A10h case    1:*/		return 0x820C6A14;
		  /* 820C6A14h */ case    2:  		/* cmplw CR6, R31, R10 */
		/* 820C6A14h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 820C6A14h case    2:*/		return 0x820C6A18;
		  /* 820C6A18h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C6A18h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C6A20;  }
		/* 820C6A18h case    3:*/		return 0x820C6A1C;
		  /* 820C6A1Ch */ case    4:  		/* mr R31, R10 */
		/* 820C6A1Ch case    4:*/		regs.R31 = regs.R10;
		/* 820C6A1Ch case    4:*/		return 0x820C6A20;
	}
	return 0x820C6A20;
} // Block from 820C6A0Ch-820C6A20h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6A20);
		  /* 820C6A20h */ case    0:  		/* li R11, 0 */
		/* 820C6A20h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6A20h case    0:*/		return 0x820C6A24;
		  /* 820C6A24h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820C6A24h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C6A24h case    1:*/		return 0x820C6A28;
		  /* 820C6A28h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 820C6A28h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C6A5C;  }
		/* 820C6A28h case    2:*/		return 0x820C6A2C;
		  /* 820C6A2Ch */ case    3:  		/* mtspr CTR, R31 */
		/* 820C6A2Ch case    3:*/		regs.CTR = regs.R31;
		/* 820C6A2Ch case    3:*/		return 0x820C6A30;
		  /* 820C6A30h */ case    4:  		/* addi R10, R6, -4 */
		/* 820C6A30h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C6A30h case    4:*/		return 0x820C6A34;
		  /* 820C6A34h */ case    5:  		/* rlwinm R8, R11, 0, 28, 29 */
		/* 820C6A34h case    5:*/		cpu::op::rlwinm<0,0,28,29>(regs,&regs.R8,regs.R11);
		/* 820C6A34h case    5:*/		return 0x820C6A38;
		  /* 820C6A38h */ case    6:  		/* rlwinm R9, R11, 0, 30, 31 */
		/* 820C6A38h case    6:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R11);
		/* 820C6A38h case    6:*/		return 0x820C6A3C;
		  /* 820C6A3Ch */ case    7:  		/* rlwinm R7, R11, 30, 2, 29 */
		/* 820C6A3Ch case    7:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R7,regs.R11);
		/* 820C6A3Ch case    7:*/		return 0x820C6A40;
		  /* 820C6A40h */ case    8:  		/* add R9, R8, R9 */
		/* 820C6A40h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C6A40h case    8:*/		return 0x820C6A44;
		  /* 820C6A44h */ case    9:  		/* addi R11, R11, 1 */
		/* 820C6A44h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C6A44h case    9:*/		return 0x820C6A48;
		  /* 820C6A48h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C6A48h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C6A48h case   10:*/		return 0x820C6A4C;
		  /* 820C6A4Ch */ case   11:  		/* lwzx R8, <#[R7 + R4]> */
		/* 820C6A4Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R4 + 0x00000000) );
		/* 820C6A4Ch case   11:*/		return 0x820C6A50;
		  /* 820C6A50h */ case   12:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820C6A50h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820C6A50h case   12:*/		return 0x820C6A54;
		  /* 820C6A54h */ case   13:  		/* stwu R9, <#[R10 + 4]> */
		/* 820C6A54h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C6A54h case   13:*/		return 0x820C6A58;
		  /* 820C6A58h */ case   14:  		/* bc 16, CR0_LT, -36 */
		/* 820C6A58h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6A34;  }
		/* 820C6A58h case   14:*/		return 0x820C6A5C;
	}
	return 0x820C6A5C;
} // Block from 820C6A20h-820C6A5Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C6A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6A5C);
		  /* 820C6A5Ch */ case    0:  		/* lhz R10, <#[R25 + 2]> */
		/* 820C6A5Ch case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000002) );
		/* 820C6A5Ch case    0:*/		return 0x820C6A60;
		  /* 820C6A60h */ case    1:  		/* cmplwi CR6, R10, 3 */
		/* 820C6A60h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C6A60h case    1:*/		return 0x820C6A64;
		  /* 820C6A64h */ case    2:  		/* bc 12, CR6_EQ, 124 */
		/* 820C6A64h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C6AE0;  }
		/* 820C6A64h case    2:*/		return 0x820C6A68;
		  /* 820C6A68h */ case    3:  		/* lwz R11, <#[R24 + 52]> */
		/* 820C6A68h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000034) );
		/* 820C6A68h case    3:*/		return 0x820C6A6C;
		  /* 820C6A6Ch */ case    4:  		/* cmplwi CR6, R10, 1 */
		/* 820C6A6Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C6A6Ch case    4:*/		return 0x820C6A70;
		  /* 820C6A70h */ case    5:  		/* mullw R11, R11, R31 */
		/* 820C6A70h case    5:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820C6A70h case    5:*/		return 0x820C6A74;
		  /* 820C6A74h */ case    6:  		/* bc 12, CR6_EQ, 56 */
		/* 820C6A74h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C6AAC;  }
		/* 820C6A74h case    6:*/		return 0x820C6A78;
		  /* 820C6A78h */ case    7:  		/* cmplwi CR6, R10, 2 */
		/* 820C6A78h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820C6A78h case    7:*/		return 0x820C6A7C;
		  /* 820C6A7Ch */ case    8:  		/* bc 4, CR6_EQ, 100 */
		/* 820C6A7Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C6AE0;  }
		/* 820C6A7Ch case    8:*/		return 0x820C6A80;
		  /* 820C6A80h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820C6A80h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C6A80h case    9:*/		return 0x820C6A84;
		  /* 820C6A84h */ case   10:  		/* bc 12, CR6_EQ, 92 */
		/* 820C6A84h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C6AE0;  }
		/* 820C6A84h case   10:*/		return 0x820C6A88;
		  /* 820C6A88h */ case   11:  		/* addi R10, R6, -4 */
		/* 820C6A88h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C6A88h case   11:*/		return 0x820C6A8C;
		  /* 820C6A8Ch */ case   12:  		/* mtspr CTR, R11 */
		/* 820C6A8Ch case   12:*/		regs.CTR = regs.R11;
		/* 820C6A8Ch case   12:*/		return 0x820C6A90;
		  /* 820C6A90h */ case   13:  		/* lfs FR0, <#[R10 + 4]> */
		/* 820C6A90h case   13:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000004) );
		/* 820C6A90h case   13:*/		return 0x820C6A94;
		  /* 820C6A94h */ case   14:  		/* fctiwz FR0, FR0 */
		/* 820C6A94h case   14:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 820C6A94h case   14:*/		return 0x820C6A98;
		  /* 820C6A98h */ case   15:  		/* stfd FR0, <#[R1 + 80]> */
		/* 820C6A98h case   15:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820C6A98h case   15:*/		return 0x820C6A9C;
		  /* 820C6A9Ch */ case   16:  		/* lwz R11, <#[R1 + 84]> */
		/* 820C6A9Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820C6A9Ch case   16:*/		return 0x820C6AA0;
		  /* 820C6AA0h */ case   17:  		/* stwu R11, <#[R10 + 4]> */
		/* 820C6AA0h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C6AA0h case   17:*/		return 0x820C6AA4;
		  /* 820C6AA4h */ case   18:  		/* bc 16, CR0_LT, -20 */
		/* 820C6AA4h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6A90;  }
		/* 820C6AA4h case   18:*/		return 0x820C6AA8;
		  /* 820C6AA8h */ case   19:  		/* b 56 */
		/* 820C6AA8h case   19:*/		return 0x820C6AE0;
		/* 820C6AA8h case   19:*/		return 0x820C6AAC;
	}
	return 0x820C6AAC;
} // Block from 820C6A5Ch-820C6AACh (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C6AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6AAC);
		  /* 820C6AACh */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C6AACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C6AACh case    0:*/		return 0x820C6AB0;
		  /* 820C6AB0h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 820C6AB0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C6AE0;  }
		/* 820C6AB0h case    1:*/		return 0x820C6AB4;
		  /* 820C6AB4h */ case    2:  		/* mtspr CTR, R11 */
		/* 820C6AB4h case    2:*/		regs.CTR = regs.R11;
		/* 820C6AB4h case    2:*/		return 0x820C6AB8;
		  /* 820C6AB8h */ case    3:  		/* lis R11, -32256 */
		/* 820C6AB8h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820C6AB8h case    3:*/		return 0x820C6ABC;
		  /* 820C6ABCh */ case    4:  		/* addi R10, R6, -4 */
		/* 820C6ABCh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C6ABCh case    4:*/		return 0x820C6AC0;
		  /* 820C6AC0h */ case    5:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 820C6AC0h case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 820C6AC0h case    5:*/		return 0x820C6AC4;
		  /* 820C6AC4h */ case    6:  		/* lfs FR13, <#[R10 + 4]> */
		/* 820C6AC4h case    6:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000004) );
		/* 820C6AC4h case    6:*/		return 0x820C6AC8;
		  /* 820C6AC8h */ case    7:  		/* li R11, 1 */
		/* 820C6AC8h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820C6AC8h case    7:*/		return 0x820C6ACC;
		  /* 820C6ACCh */ case    8:  		/* fcmpu CR6, FR13, FR0 */
		/* 820C6ACCh case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820C6ACCh case    8:*/		return 0x820C6AD0;
		  /* 820C6AD0h */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 820C6AD0h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820C6AD8;  }
		/* 820C6AD0h case    9:*/		return 0x820C6AD4;
		  /* 820C6AD4h */ case   10:  		/* li R11, 0 */
		/* 820C6AD4h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6AD4h case   10:*/		return 0x820C6AD8;
	}
	return 0x820C6AD8;
} // Block from 820C6AACh-820C6AD8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C6AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6AD8);
		  /* 820C6AD8h */ case    0:  		/* stwu R11, <#[R10 + 4]> */
		/* 820C6AD8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C6AD8h case    0:*/		return 0x820C6ADC;
		  /* 820C6ADCh */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 820C6ADCh case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6AC4;  }
		/* 820C6ADCh case    1:*/		return 0x820C6AE0;
	}
	return 0x820C6AE0;
} // Block from 820C6AD8h-820C6AE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C6AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6AE0);
		  /* 820C6AE0h */ case    0:  		/* lhz R9, <#[R24 + 8]> */
		/* 820C6AE0h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 820C6AE0h case    0:*/		return 0x820C6AE4;
		  /* 820C6AE4h */ case    1:  		/* cmplwi CR0, R9, 0 */
		/* 820C6AE4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820C6AE4h case    1:*/		return 0x820C6AE8;
		  /* 820C6AE8h */ case    2:  		/* bc 12, CR0_EQ, 212 */
		/* 820C6AE8h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C6BBC;  }
		/* 820C6AE8h case    2:*/		return 0x820C6AEC;
		  /* 820C6AECh */ case    3:  		/* lhz R11, <#[R25]> */
		/* 820C6AECh case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820C6AECh case    3:*/		return 0x820C6AF0;
		  /* 820C6AF0h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C6AF0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C6AF0h case    4:*/		return 0x820C6AF4;
		  /* 820C6AF4h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820C6AF4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C6B04;  }
		/* 820C6AF4h case    5:*/		return 0x820C6AF8;
		  /* 820C6AF8h */ case    6:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C6AF8h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6AF8h case    6:*/		return 0x820C6AFC;
		  /* 820C6AFCh */ case    7:  		/* lhz R10, <#[R25 + 4]> */
		/* 820C6AFCh case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820C6AFCh case    7:*/		return 0x820C6B00;
		  /* 820C6B00h */ case    8:  		/* b 12 */
		/* 820C6B00h case    8:*/		return 0x820C6B0C;
		/* 820C6B00h case    8:*/		return 0x820C6B04;
	}
	return 0x820C6B04;
} // Block from 820C6AE0h-820C6B04h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C6B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6B04);
		  /* 820C6B04h */ case    0:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C6B04h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C6B04h case    0:*/		return 0x820C6B08;
		  /* 820C6B08h */ case    1:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C6B08h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6B08h case    1:*/		return 0x820C6B0C;
	}
	return 0x820C6B0C;
} // Block from 820C6B04h-820C6B0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C6B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6B0C);
		  /* 820C6B0Ch */ case    0:  		/* rlwinm. R8, R11, 0, 30, 31 */
		/* 820C6B0Ch case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R8,regs.R11);
		/* 820C6B0Ch case    0:*/		return 0x820C6B10;
		  /* 820C6B10h */ case    1:  		/* bc 12, CR0_EQ, 172 */
		/* 820C6B10h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C6BBC;  }
		/* 820C6B10h case    1:*/		return 0x820C6B14;
		  /* 820C6B14h */ case    2:  		/* cmplwi CR6, R9, 1 */
		/* 820C6B14h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820C6B14h case    2:*/		return 0x820C6B18;
		  /* 820C6B18h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820C6B18h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C6B28;  }
		/* 820C6B18h case    3:*/		return 0x820C6B1C;
		  /* 820C6B1Ch */ case    4:  		/* lis R9, -32255 */
		/* 820C6B1Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C6B1Ch case    4:*/		return 0x820C6B20;
		  /* 820C6B20h */ case    5:  		/* addi R3, R9, 10344 */
		/* 820C6B20h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R9,0x2868);
		/* 820C6B20h case    5:*/		return 0x820C6B24;
		  /* 820C6B24h */ case    6:  		/* b 12 */
		/* 820C6B24h case    6:*/		return 0x820C6B30;
		/* 820C6B24h case    6:*/		return 0x820C6B28;
	}
	return 0x820C6B28;
} // Block from 820C6B0Ch-820C6B28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C6B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6B28);
		  /* 820C6B28h */ case    0:  		/* lis R9, -32255 */
		/* 820C6B28h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C6B28h case    0:*/		return 0x820C6B2C;
		  /* 820C6B2Ch */ case    1:  		/* addi R3, R9, 10360 */
		/* 820C6B2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R9,0x2878);
		/* 820C6B2Ch case    1:*/		return 0x820C6B30;
	}
	return 0x820C6B30;
} // Block from 820C6B28h-820C6B30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C6B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6B30);
		  /* 820C6B30h */ case    0:  		/* addi R8, R11, 3 */
		/* 820C6B30h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x3);
		/* 820C6B30h case    0:*/		return 0x820C6B34;
		  /* 820C6B34h */ case    1:  		/* mullw. R9, R10, R31 */
		/* 820C6B34h case    1:*/		cpu::op::mullw<1>(regs,&regs.R9,regs.R10,regs.R31);
		/* 820C6B34h case    1:*/		return 0x820C6B38;
		  /* 820C6B38h */ case    2:  		/* rlwinm R7, R8, 0, 0, 29 */
		/* 820C6B38h case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R7,regs.R8);
		/* 820C6B38h case    2:*/		return 0x820C6B3C;
		  /* 820C6B3Ch */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 820C6B3Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820C6BBC;  }
		/* 820C6B3Ch case    3:*/		return 0x820C6B40;
		  /* 820C6B40h */ case    4:  		/* mullw R8, R9, R7 */
		/* 820C6B40h case    4:*/		cpu::op::mullw<0>(regs,&regs.R8,regs.R9,regs.R7);
		/* 820C6B40h case    4:*/		return 0x820C6B44;
		  /* 820C6B44h */ case    5:  		/* mullw R4, R9, R11 */
		/* 820C6B44h case    5:*/		cpu::op::mullw<0>(regs,&regs.R4,regs.R9,regs.R11);
		/* 820C6B44h case    5:*/		return 0x820C6B48;
		  /* 820C6B48h */ case    6:  		/* addi R9, R9, -1 */
		/* 820C6B48h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 820C6B48h case    6:*/		return 0x820C6B4C;
		  /* 820C6B4Ch */ case    7:  		/* subf R4, R11, R4 */
		/* 820C6B4Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R11,regs.R4);
		/* 820C6B4Ch case    7:*/		return 0x820C6B50;
		  /* 820C6B50h */ case    8:  		/* subf R8, R7, R8 */
		/* 820C6B50h case    8:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820C6B50h case    8:*/		return 0x820C6B54;
		  /* 820C6B54h */ case    9:  		/* mr R10, R7 */
		/* 820C6B54h case    9:*/		regs.R10 = regs.R7;
		/* 820C6B54h case    9:*/		return 0x820C6B58;
		  /* 820C6B58h */ case   10:  		/* cmplw CR6, R7, R11 */
		/* 820C6B58h case   10:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C6B58h case   10:*/		return 0x820C6B5C;
		  /* 820C6B5Ch */ case   11:  		/* bc 4, CR6_GT, 40 */
		/* 820C6B5Ch case   11:*/		if ( !regs.CR[6].gt ) { return 0x820C6B84;  }
		/* 820C6B5Ch case   11:*/		return 0x820C6B60;
		  /* 820C6B60h */ case   12:  		/* subf R5, R11, R7 */
		/* 820C6B60h case   12:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R11,regs.R7);
		/* 820C6B60h case   12:*/		return 0x820C6B64;
		  /* 820C6B64h */ case   13:  		/* mtspr CTR, R5 */
		/* 820C6B64h case   13:*/		regs.CTR = regs.R5;
		/* 820C6B64h case   13:*/		return 0x820C6B68;
		  /* 820C6B68h */ case   14:  		/* addi R10, R10, -1 */
		/* 820C6B68h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C6B68h case   14:*/		return 0x820C6B6C;
		  /* 820C6B6Ch */ case   15:  		/* rlwinm R5, R10, 2, 28, 29 */
		/* 820C6B6Ch case   15:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R5,regs.R10);
		/* 820C6B6Ch case   15:*/		return 0x820C6B70;
		  /* 820C6B70h */ case   16:  		/* add R30, R10, R8 */
		/* 820C6B70h case   16:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R8);
		/* 820C6B70h case   16:*/		return 0x820C6B74;
		  /* 820C6B74h */ case   17:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C6B74h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C6B74h case   17:*/		return 0x820C6B78;
		  /* 820C6B78h */ case   18:  		/* lwzx R5, <#[R5 + R3]> */
		/* 820C6B78h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 820C6B78h case   18:*/		return 0x820C6B7C;
		  /* 820C6B7Ch */ case   19:  		/* stwx R5, <#[R30 + R6]> */
		/* 820C6B7Ch case   19:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C6B7Ch case   19:*/		return 0x820C6B80;
		  /* 820C6B80h */ case   20:  		/* bc 16, CR0_LT, -24 */
		/* 820C6B80h case   20:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6B68;  }
		/* 820C6B80h case   20:*/		return 0x820C6B84;
	}
	return 0x820C6B84;
} // Block from 820C6B30h-820C6B84h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C6B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6B84);
		  /* 820C6B84h */ case    0:  		/* mr R10, R11 */
		/* 820C6B84h case    0:*/		regs.R10 = regs.R11;
		/* 820C6B84h case    0:*/		return 0x820C6B88;
		  /* 820C6B88h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C6B88h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C6B88h case    1:*/		return 0x820C6B8C;
		  /* 820C6B8Ch */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820C6B8Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C6BB4;  }
		/* 820C6B8Ch case    2:*/		return 0x820C6B90;
		  /* 820C6B90h */ case    3:  		/* mtspr CTR, R11 */
		/* 820C6B90h case    3:*/		regs.CTR = regs.R11;
		/* 820C6B90h case    3:*/		return 0x820C6B94;
		  /* 820C6B94h */ case    4:  		/* addi R10, R10, -1 */
		/* 820C6B94h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C6B94h case    4:*/		return 0x820C6B98;
		  /* 820C6B98h */ case    5:  		/* add R5, R10, R4 */
		/* 820C6B98h case    5:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R4);
		/* 820C6B98h case    5:*/		return 0x820C6B9C;
		  /* 820C6B9Ch */ case    6:  		/* add R30, R10, R8 */
		/* 820C6B9Ch case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R8);
		/* 820C6B9Ch case    6:*/		return 0x820C6BA0;
		  /* 820C6BA0h */ case    7:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 820C6BA0h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 820C6BA0h case    7:*/		return 0x820C6BA4;
		  /* 820C6BA4h */ case    8:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C6BA4h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C6BA4h case    8:*/		return 0x820C6BA8;
		  /* 820C6BA8h */ case    9:  		/* lwzx R5, <#[R5 + R6]> */
		/* 820C6BA8h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 820C6BA8h case    9:*/		return 0x820C6BAC;
		  /* 820C6BACh */ case   10:  		/* stwx R5, <#[R30 + R6]> */
		/* 820C6BACh case   10:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C6BACh case   10:*/		return 0x820C6BB0;
		  /* 820C6BB0h */ case   11:  		/* bc 16, CR0_LT, -28 */
		/* 820C6BB0h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6B94;  }
		/* 820C6BB0h case   11:*/		return 0x820C6BB4;
	}
	return 0x820C6BB4;
} // Block from 820C6B84h-820C6BB4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C6BB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6BB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6BB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6BB4);
		  /* 820C6BB4h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 820C6BB4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820C6BB4h case    0:*/		return 0x820C6BB8;
		  /* 820C6BB8h */ case    1:  		/* bc 4, CR6_EQ, -112 */
		/* 820C6BB8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C6B48;  }
		/* 820C6BB8h case    1:*/		return 0x820C6BBC;
	}
	return 0x820C6BBC;
} // Block from 820C6BB4h-820C6BBCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C6BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6BBC);
		  /* 820C6BBCh */ case    0:  		/* lwz R10, <#[R24 + 44]> */
		/* 820C6BBCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000002C) );
		/* 820C6BBCh case    0:*/		return 0x820C6BC0;
		  /* 820C6BC0h */ case    1:  		/* lhz R11, <#[R24 + 12]> */
		/* 820C6BC0h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820C6BC0h case    1:*/		return 0x820C6BC4;
		  /* 820C6BC4h */ case    2:  		/* mullw R7, R10, R31 */
		/* 820C6BC4h case    2:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R31);
		/* 820C6BC4h case    2:*/		return 0x820C6BC8;
	}
	return 0x820C6BC8;
} // Block from 820C6BBCh-820C6BC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C6BC8h
// Function '?Set@?$SetTyped@$01$02$03$03$0A@@D3DXShader@@SAJPAVCConstant@2@PBX1II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6BC8);
		  /* 820C6BC8h */ case    0:  		/* cmplw CR6, R7, R11 */
		/* 820C6BC8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C6BC8h case    0:*/		return 0x820C6BCC;
		  /* 820C6BCCh */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 820C6BCCh case    1:*/		if ( !regs.CR[6].gt ) { return 0x820C6BD4;  }
		/* 820C6BCCh case    1:*/		return 0x820C6BD0;
		  /* 820C6BD0h */ case    2:  		/* mr R7, R11 */
		/* 820C6BD0h case    2:*/		regs.R7 = regs.R11;
		/* 820C6BD0h case    2:*/		return 0x820C6BD4;
	}
	return 0x820C6BD4;
} // Block from 820C6BC8h-820C6BD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C6BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6BD4);
		  /* 820C6BD4h */ case    0:  		/* lwz R10, <#[R24 + 28]> */
		/* 820C6BD4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 820C6BD4h case    0:*/		return 0x820C6BD8;
		  /* 820C6BD8h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C6BD8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C6BD8h case    1:*/		return 0x820C6BDC;
		  /* 820C6BDCh */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C6BDCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C6BEC;  }
		/* 820C6BDCh case    2:*/		return 0x820C6BE0;
		  /* 820C6BE0h */ case    3:  		/* lis R3, -32768 */
		/* 820C6BE0h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C6BE0h case    3:*/		return 0x820C6BE4;
		  /* 820C6BE4h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820C6BE4h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C6BE4h case    4:*/		return 0x820C6BE8;
		  /* 820C6BE8h */ case    5:  		/* b 36 */
		/* 820C6BE8h case    5:*/		return 0x820C6C0C;
		/* 820C6BE8h case    5:*/		return 0x820C6BEC;
	}
	return 0x820C6BEC;
} // Block from 820C6BD4h-820C6BECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C6BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6BEC);
		  /* 820C6BECh */ case    0:  		/* lhz R11, <#[R24 + 10]> */
		/* 820C6BECh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000A) );
		/* 820C6BECh case    0:*/		return 0x820C6BF0;
		  /* 820C6BF0h */ case    1:  		/* mr R5, R6 */
		/* 820C6BF0h case    1:*/		regs.R5 = regs.R6;
		/* 820C6BF0h case    1:*/		return 0x820C6BF4;
		  /* 820C6BF4h */ case    2:  		/* mr R3, R23 */
		/* 820C6BF4h case    2:*/		regs.R3 = regs.R23;
		/* 820C6BF4h case    2:*/		return 0x820C6BF8;
		  /* 820C6BF8h */ case    3:  		/* mtspr CTR, R10 */
		/* 820C6BF8h case    3:*/		regs.CTR = regs.R10;
		/* 820C6BF8h case    3:*/		return 0x820C6BFC;
		  /* 820C6BFCh */ case    4:  		/* add R4, R11, R22 */
		/* 820C6BFCh case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R22);
		/* 820C6BFCh case    4:*/		return 0x820C6C00;
		  /* 820C6C00h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820C6C00h case    5:*/		if ( 1 ) { regs.LR = 0x820C6C04; return (uint32)regs.CTR; }
		/* 820C6C00h case    5:*/		return 0x820C6C04;
		  /* 820C6C04h */ case    6:  		/* srawi R11, R3, 31 */
		/* 820C6C04h case    6:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820C6C04h case    6:*/		return 0x820C6C08;
		  /* 820C6C08h */ case    7:  		/* and R3, R11, R3 */
		/* 820C6C08h case    7:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C6C08h case    7:*/		return 0x820C6C0C;
	}
	return 0x820C6C0C;
} // Block from 820C6BECh-820C6C0Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C6C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6C0C);
		  /* 820C6C0Ch */ case    0:  		/* addi R1, R1, 176 */
		/* 820C6C0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820C6C0Ch case    0:*/		return 0x820C6C10;
		  /* 820C6C10h */ case    1:  		/* b -219520 */
		/* 820C6C10h case    1:*/		return 0x82091290;
		/* 820C6C10h case    1:*/		return 0x820C6C14;
		  /* 820C6C14h */ case    2:  		/* nop */
		/* 820C6C14h case    2:*/		cpu::op::nop();
		/* 820C6C14h case    2:*/		return 0x820C6C18;
	}
	return 0x820C6C18;
} // Block from 820C6C0Ch-820C6C18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C6C18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6C18);
		  /* 820C6C18h */ case    0:  		/* mfspr R12, LR */
		/* 820C6C18h case    0:*/		regs.R12 = regs.LR;
		/* 820C6C18h case    0:*/		return 0x820C6C1C;
		  /* 820C6C1Ch */ case    1:  		/* bl -219612 */
		/* 820C6C1Ch case    1:*/		regs.LR = 0x820C6C20; return 0x82091240;
		/* 820C6C1Ch case    1:*/		return 0x820C6C20;
		  /* 820C6C20h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820C6C20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820C6C20h case    2:*/		return 0x820C6C24;
		  /* 820C6C24h */ case    3:  		/* lwz R25, <#[R3 + 24]> */
		/* 820C6C24h case    3:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R3 + 0x00000018) );
		/* 820C6C24h case    3:*/		return 0x820C6C28;
		  /* 820C6C28h */ case    4:  		/* mr R11, R6 */
		/* 820C6C28h case    4:*/		regs.R11 = regs.R6;
		/* 820C6C28h case    4:*/		return 0x820C6C2C;
		  /* 820C6C2Ch */ case    5:  		/* lwz R6, <#[R3 + 32]> */
		/* 820C6C2Ch case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000020) );
		/* 820C6C2Ch case    5:*/		return 0x820C6C30;
		  /* 820C6C30h */ case    6:  		/* mr R24, R3 */
		/* 820C6C30h case    6:*/		regs.R24 = regs.R3;
		/* 820C6C30h case    6:*/		return 0x820C6C34;
		  /* 820C6C34h */ case    7:  		/* mr R23, R4 */
		/* 820C6C34h case    7:*/		regs.R23 = regs.R4;
		/* 820C6C34h case    7:*/		return 0x820C6C38;
		  /* 820C6C38h */ case    8:  		/* mr R22, R7 */
		/* 820C6C38h case    8:*/		regs.R22 = regs.R7;
		/* 820C6C38h case    8:*/		return 0x820C6C3C;
		  /* 820C6C3Ch */ case    9:  		/* lhz R10, <#[R25]> */
		/* 820C6C3Ch case    9:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 820C6C3Ch case    9:*/		return 0x820C6C40;
		  /* 820C6C40h */ case   10:  		/* cmplwi CR6, R10, 1 */
		/* 820C6C40h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C6C40h case   10:*/		return 0x820C6C44;
		  /* 820C6C44h */ case   11:  		/* bc 12, CR6_LT, 928 */
		/* 820C6C44h case   11:*/		if ( regs.CR[6].lt ) { return 0x820C6FE4;  }
		/* 820C6C44h case   11:*/		return 0x820C6C48;
		  /* 820C6C48h */ case   12:  		/* bc 12, CR6_EQ, 792 */
		/* 820C6C48h case   12:*/		if ( regs.CR[6].eq ) { return 0x820C6F60;  }
		/* 820C6C48h case   12:*/		return 0x820C6C4C;
		  /* 820C6C4Ch */ case   13:  		/* cmplwi CR6, R10, 3 */
		/* 820C6C4Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C6C4Ch case   13:*/		return 0x820C6C50;
		  /* 820C6C50h */ case   14:  		/* bc 12, CR6_LT, 436 */
		/* 820C6C50h case   14:*/		if ( regs.CR[6].lt ) { return 0x820C6E04;  }
		/* 820C6C50h case   14:*/		return 0x820C6C54;
		  /* 820C6C54h */ case   15:  		/* bc 12, CR6_EQ, 248 */
		/* 820C6C54h case   15:*/		if ( regs.CR[6].eq ) { return 0x820C6D4C;  }
		/* 820C6C54h case   15:*/		return 0x820C6C58;
		  /* 820C6C58h */ case   16:  		/* cmplwi CR6, R10, 5 */
		/* 820C6C58h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000005);
		/* 820C6C58h case   16:*/		return 0x820C6C5C;
		  /* 820C6C5Ch */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 820C6C5Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x820C6C6C;  }
		/* 820C6C5Ch case   17:*/		return 0x820C6C60;
		  /* 820C6C60h */ case   18:  		/* lis R3, -32768 */
		/* 820C6C60h case   18:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C6C60h case   18:*/		return 0x820C6C64;
		  /* 820C6C64h */ case   19:  		/* ori R3, R3, 16385 */
		/* 820C6C64h case   19:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 820C6C64h case   19:*/		return 0x820C6C68;
		  /* 820C6C68h */ case   20:  		/* b 1424 */
		/* 820C6C68h case   20:*/		return 0x820C71F8;
		/* 820C6C68h case   20:*/		return 0x820C6C6C;
	}
	return 0x820C6C6C;
} // Block from 820C6C18h-820C6C6Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C6C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6C6C);
		  /* 820C6C6Ch */ case    0:  		/* lwz R10, <#[R24 + 52]> */
		/* 820C6C6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000034) );
		/* 820C6C6Ch case    0:*/		return 0x820C6C70;
		  /* 820C6C70h */ case    1:  		/* rlwinm R9, R11, 4, 0, 27 */
		/* 820C6C70h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R9,regs.R11);
		/* 820C6C70h case    1:*/		return 0x820C6C74;
		  /* 820C6C74h */ case    2:  		/* lhz R11, <#[R25 + 8]> */
		/* 820C6C74h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820C6C74h case    2:*/		return 0x820C6C78;
		  /* 820C6C78h */ case    3:  		/* divwu R27, R9, R10 */
		/* 820C6C78h case    3:*/		cpu::op::divwu<0>(regs,&regs.R27,regs.R9,regs.R10);
		/* 820C6C78h case    3:*/		return 0x820C6C7C;
		  /* 820C6C7Ch */ case    4:  		/* twi 6, R10, 0 */
		/* 820C6C7Ch case    4:*/		cpu::op::tw<6>(regs, 0x820C6C7C, regs.R10, 0x00000000);
		/* 820C6C7Ch case    4:*/		return 0x820C6C80;
		  /* 820C6C80h */ case    5:  		/* cmplw CR6, R27, R11 */
		/* 820C6C80h case    5:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820C6C80h case    5:*/		return 0x820C6C84;
		  /* 820C6C84h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 820C6C84h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820C6C8C;  }
		/* 820C6C84h case    6:*/		return 0x820C6C88;
		  /* 820C6C88h */ case    7:  		/* mr R27, R11 */
		/* 820C6C88h case    7:*/		regs.R27 = regs.R11;
		/* 820C6C88h case    7:*/		return 0x820C6C8C;
	}
	return 0x820C6C8C;
} // Block from 820C6C6Ch-820C6C8Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C6C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6C8C);
		  /* 820C6C8Ch */ case    0:  		/* mullw. R10, R10, R27 */
		/* 820C6C8Ch case    0:*/		cpu::op::mullw<1>(regs,&regs.R10,regs.R10,regs.R27);
		/* 820C6C8Ch case    0:*/		return 0x820C6C90;
		  /* 820C6C90h */ case    1:  		/* li R11, 0 */
		/* 820C6C90h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6C90h case    1:*/		return 0x820C6C94;
		  /* 820C6C94h */ case    2:  		/* bc 12, CR0_EQ, 56 */
		/* 820C6C94h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C6CCC;  }
		/* 820C6C94h case    2:*/		return 0x820C6C98;
		  /* 820C6C98h */ case    3:  		/* mtspr CTR, R10 */
		/* 820C6C98h case    3:*/		regs.CTR = regs.R10;
		/* 820C6C98h case    3:*/		return 0x820C6C9C;
		  /* 820C6C9Ch */ case    4:  		/* addi R10, R6, -4 */
		/* 820C6C9Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C6C9Ch case    4:*/		return 0x820C6CA0;
		  /* 820C6CA0h */ case    5:  		/* rlwinm R9, R11, 0, 30, 31 */
		/* 820C6CA0h case    5:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R11);
		/* 820C6CA0h case    5:*/		return 0x820C6CA4;
		  /* 820C6CA4h */ case    6:  		/* rlwinm R8, R11, 30, 2, 29 */
		/* 820C6CA4h case    6:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R8,regs.R11);
		/* 820C6CA4h case    6:*/		return 0x820C6CA8;
		  /* 820C6CA8h */ case    7:  		/* rlwinm R7, R11, 30, 30, 31 */
		/* 820C6CA8h case    7:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R7,regs.R11);
		/* 820C6CA8h case    7:*/		return 0x820C6CAC;
		  /* 820C6CACh */ case    8:  		/* add R9, R8, R9 */
		/* 820C6CACh case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C6CACh case    8:*/		return 0x820C6CB0;
		  /* 820C6CB0h */ case    9:  		/* addi R11, R11, 1 */
		/* 820C6CB0h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C6CB0h case    9:*/		return 0x820C6CB4;
		  /* 820C6CB4h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C6CB4h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C6CB4h case   10:*/		return 0x820C6CB8;
		  /* 820C6CB8h */ case   11:  		/* add R9, R9, R7 */
		/* 820C6CB8h case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 820C6CB8h case   11:*/		return 0x820C6CBC;
		  /* 820C6CBCh */ case   12:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C6CBCh case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C6CBCh case   12:*/		return 0x820C6CC0;
		  /* 820C6CC0h */ case   13:  		/* lwzx R9, <#[R9 + R5]> */
		/* 820C6CC0h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 820C6CC0h case   13:*/		return 0x820C6CC4;
		  /* 820C6CC4h */ case   14:  		/* stwu R9, <#[R10 + 4]> */
		/* 820C6CC4h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C6CC4h case   14:*/		return 0x820C6CC8;
		  /* 820C6CC8h */ case   15:  		/* bc 16, CR0_LT, -40 */
		/* 820C6CC8h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6CA0;  }
		/* 820C6CC8h case   15:*/		return 0x820C6CCC;
	}
	return 0x820C6CCC;
} // Block from 820C6C8Ch-820C6CCCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C6CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6CCC);
		  /* 820C6CCCh */ case    0:  		/* mr R29, R6 */
		/* 820C6CCCh case    0:*/		regs.R29 = regs.R6;
		/* 820C6CCCh case    0:*/		return 0x820C6CD0;
		  /* 820C6CD0h */ case    1:  		/* li R26, 0 */
		/* 820C6CD0h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820C6CD0h case    1:*/		return 0x820C6CD4;
		  /* 820C6CD4h */ case    2:  		/* cmplwi CR6, R27, 0 */
		/* 820C6CD4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820C6CD4h case    2:*/		return 0x820C6CD8;
		  /* 820C6CD8h */ case    3:  		/* bc 12, CR6_EQ, 108 */
		/* 820C6CD8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C6D44;  }
		/* 820C6CD8h case    3:*/		return 0x820C6CDC;
		  /* 820C6CDCh */ case    4:  		/* lhz R11, <#[R25 + 10]> */
		/* 820C6CDCh case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000A) );
		/* 820C6CDCh case    4:*/		return 0x820C6CE0;
		  /* 820C6CE0h */ case    5:  		/* li R28, 0 */
		/* 820C6CE0h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820C6CE0h case    5:*/		return 0x820C6CE4;
		  /* 820C6CE4h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 820C6CE4h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C6CE4h case    6:*/		return 0x820C6CE8;
		  /* 820C6CE8h */ case    7:  		/* bc 12, CR0_EQ, 80 */
		/* 820C6CE8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820C6D38;  }
		/* 820C6CE8h case    7:*/		return 0x820C6CEC;
		  /* 820C6CECh */ case    8:  		/* li R30, 0 */
		/* 820C6CECh case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C6CECh case    8:*/		return 0x820C6CF0;
		  /* 820C6CF0h */ case    9:  		/* lwz R11, <#[R24 + 56]> */
		/* 820C6CF0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 820C6CF0h case    9:*/		return 0x820C6CF4;
		  /* 820C6CF4h */ case   10:  		/* mr R7, R22 */
		/* 820C6CF4h case   10:*/		regs.R7 = regs.R22;
		/* 820C6CF4h case   10:*/		return 0x820C6CF8;
		  /* 820C6CF8h */ case   11:  		/* mr R5, R29 */
		/* 820C6CF8h case   11:*/		regs.R5 = regs.R29;
		/* 820C6CF8h case   11:*/		return 0x820C6CFC;
		  /* 820C6CFCh */ case   12:  		/* mr R4, R23 */
		/* 820C6CFCh case   12:*/		regs.R4 = regs.R23;
		/* 820C6CFCh case   12:*/		return 0x820C6D00;
		  /* 820C6D00h */ case   13:  		/* lwzx R31, <#[R30 + R11]> */
		/* 820C6D00h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820C6D00h case   13:*/		return 0x820C6D04;
		  /* 820C6D04h */ case   14:  		/* mr R3, R31 */
		/* 820C6D04h case   14:*/		regs.R3 = regs.R31;
		/* 820C6D04h case   14:*/		return 0x820C6D08;
		  /* 820C6D08h */ case   15:  		/* lwz R6, <#[R31 + 48]> */
		/* 820C6D08h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000030) );
		/* 820C6D08h case   15:*/		return 0x820C6D0C;
		  /* 820C6D0Ch */ case   16:  		/* bl -5036 */
		/* 820C6D0Ch case   16:*/		regs.LR = 0x820C6D10; return 0x820C5960;
		/* 820C6D0Ch case   16:*/		return 0x820C6D10;
		  /* 820C6D10h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820C6D10h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C6D10h case   17:*/		return 0x820C6D14;
		  /* 820C6D14h */ case   18:  		/* bc 12, CR0_LT, 1252 */
		/* 820C6D14h case   18:*/		if ( regs.CR[0].lt ) { return 0x820C71F8;  }
		/* 820C6D14h case   18:*/		return 0x820C6D18;
		  /* 820C6D18h */ case   19:  		/* lwz R11, <#[R31 + 48]> */
		/* 820C6D18h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820C6D18h case   19:*/		return 0x820C6D1C;
		  /* 820C6D1Ch */ case   20:  		/* addi R28, R28, 1 */
		/* 820C6D1Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820C6D1Ch case   20:*/		return 0x820C6D20;
		  /* 820C6D20h */ case   21:  		/* lhz R10, <#[R25 + 10]> */
		/* 820C6D20h case   21:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x0000000A) );
		/* 820C6D20h case   21:*/		return 0x820C6D24;
		  /* 820C6D24h */ case   22:  		/* addi R30, R30, 4 */
		/* 820C6D24h case   22:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C6D24h case   22:*/		return 0x820C6D28;
		  /* 820C6D28h */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C6D28h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C6D28h case   23:*/		return 0x820C6D2C;
		  /* 820C6D2Ch */ case   24:  		/* cmplw CR6, R28, R10 */
		/* 820C6D2Ch case   24:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 820C6D2Ch case   24:*/		return 0x820C6D30;
		  /* 820C6D30h */ case   25:  		/* add R29, R11, R29 */
		/* 820C6D30h case   25:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 820C6D30h case   25:*/		return 0x820C6D34;
		  /* 820C6D34h */ case   26:  		/* bc 12, CR6_LT, -68 */
		/* 820C6D34h case   26:*/		if ( regs.CR[6].lt ) { return 0x820C6CF0;  }
		/* 820C6D34h case   26:*/		return 0x820C6D38;
	}
	return 0x820C6D38;
} // Block from 820C6CCCh-820C6D38h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820C6D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6D38);
		  /* 820C6D38h */ case    0:  		/* addi R26, R26, 1 */
		/* 820C6D38h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820C6D38h case    0:*/		return 0x820C6D3C;
		  /* 820C6D3Ch */ case    1:  		/* cmplw CR6, R26, R27 */
		/* 820C6D3Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R27);
		/* 820C6D3Ch case    1:*/		return 0x820C6D40;
		  /* 820C6D40h */ case    2:  		/* bc 12, CR6_LT, -100 */
		/* 820C6D40h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C6CDC;  }
		/* 820C6D40h case    2:*/		return 0x820C6D44;
	}
	return 0x820C6D44;
} // Block from 820C6D38h-820C6D44h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C6D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6D44);
		  /* 820C6D44h */ case    0:  		/* li R3, 0 */
		/* 820C6D44h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C6D44h case    0:*/		return 0x820C6D48;
		  /* 820C6D48h */ case    1:  		/* b 1200 */
		/* 820C6D48h case    1:*/		return 0x820C71F8;
		/* 820C6D48h case    1:*/		return 0x820C6D4C;
	}
	return 0x820C6D4C;
} // Block from 820C6D44h-820C6D4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C6D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6D4C);
		  /* 820C6D4Ch */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C6D4Ch case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C6D4Ch case    0:*/		return 0x820C6D50;
		  /* 820C6D50h */ case    1:  		/* mr R31, R11 */
		/* 820C6D50h case    1:*/		regs.R31 = regs.R11;
		/* 820C6D50h case    1:*/		return 0x820C6D54;
		  /* 820C6D54h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C6D54h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C6D54h case    2:*/		return 0x820C6D58;
		  /* 820C6D58h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C6D58h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C6D60;  }
		/* 820C6D58h case    3:*/		return 0x820C6D5C;
		  /* 820C6D5Ch */ case    4:  		/* mr R31, R10 */
		/* 820C6D5Ch case    4:*/		regs.R31 = regs.R10;
		/* 820C6D5Ch case    4:*/		return 0x820C6D60;
	}
	return 0x820C6D60;
} // Block from 820C6D4Ch-820C6D60h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6D60);
		  /* 820C6D60h */ case    0:  		/* lhz R10, <#[R25 + 4]> */
		/* 820C6D60h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820C6D60h case    0:*/		return 0x820C6D64;
		  /* 820C6D64h */ case    1:  		/* cmplwi CR6, R10, 4 */
		/* 820C6D64h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820C6D64h case    1:*/		return 0x820C6D68;
		  /* 820C6D68h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C6D68h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C6D78;  }
		/* 820C6D68h case    2:*/		return 0x820C6D6C;
		  /* 820C6D6Ch */ case    3:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C6D6Ch case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6D6Ch case    3:*/		return 0x820C6D70;
		  /* 820C6D70h */ case    4:  		/* cmplwi CR6, R11, 4 */
		/* 820C6D70h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C6D70h case    4:*/		return 0x820C6D74;
		  /* 820C6D74h */ case    5:  		/* bc 12, CR6_EQ, 712 */
		/* 820C6D74h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C703C;  }
		/* 820C6D74h case    5:*/		return 0x820C6D78;
	}
	return 0x820C6D78;
} // Block from 820C6D60h-820C6D78h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C6D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6D78);
		  /* 820C6D78h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820C6D78h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C6D78h case    0:*/		return 0x820C6D7C;
		  /* 820C6D7Ch */ case    1:  		/* bc 12, CR6_EQ, 700 */
		/* 820C6D7Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820C7038;  }
		/* 820C6D7Ch case    1:*/		return 0x820C6D80;
		  /* 820C6D80h */ case    2:  		/* mtspr CTR, R31 */
		/* 820C6D80h case    2:*/		regs.CTR = regs.R31;
		/* 820C6D80h case    2:*/		return 0x820C6D84;
		  /* 820C6D84h */ case    3:  		/* li R8, 0 */
		/* 820C6D84h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C6D84h case    3:*/		return 0x820C6D88;
		  /* 820C6D88h */ case    4:  		/* addi R7, R6, -4 */
		/* 820C6D88h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820C6D88h case    4:*/		return 0x820C6D8C;
		  /* 820C6D8Ch */ case    5:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C6D8Ch case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6D8Ch case    5:*/		return 0x820C6D90;
		  /* 820C6D90h */ case    6:  		/* li R9, 0 */
		/* 820C6D90h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C6D90h case    6:*/		return 0x820C6D94;
		  /* 820C6D94h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 820C6D94h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C6D94h case    7:*/		return 0x820C6D98;
		  /* 820C6D98h */ case    8:  		/* bc 12, CR0_EQ, 96 */
		/* 820C6D98h case    8:*/		if ( regs.CR[0].eq ) { return 0x820C6DF8;  }
		/* 820C6D98h case    8:*/		return 0x820C6D9C;
		  /* 820C6D9Ch */ case    9:  		/* li R11, 0 */
		/* 820C6D9Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6D9Ch case    9:*/		return 0x820C6DA0;
		  /* 820C6DA0h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 820C6DA0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C6DA0h case   10:*/		return 0x820C6DA4;
		  /* 820C6DA4h */ case   11:  		/* bc 12, CR6_EQ, 68 */
		/* 820C6DA4h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C6DE8;  }
		/* 820C6DA4h case   11:*/		return 0x820C6DA8;
		  /* 820C6DA8h */ case   12:  		/* cmplwi CR6, R11, 4 */
		/* 820C6DA8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C6DA8h case   12:*/		return 0x820C6DAC;
		  /* 820C6DACh */ case   13:  		/* bc 12, CR6_GT, 36 */
		/* 820C6DACh case   13:*/		if ( regs.CR[6].gt ) { return 0x820C6DD0;  }
		/* 820C6DACh case   13:*/		return 0x820C6DB0;
		  /* 820C6DB0h */ case   14:  		/* cmplwi CR6, R9, 4 */
		/* 820C6DB0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000004);
		/* 820C6DB0h case   14:*/		return 0x820C6DB4;
		  /* 820C6DB4h */ case   15:  		/* bc 12, CR6_GT, 28 */
		/* 820C6DB4h case   15:*/		if ( regs.CR[6].gt ) { return 0x820C6DD0;  }
		/* 820C6DB4h case   15:*/		return 0x820C6DB8;
		  /* 820C6DB8h */ case   16:  		/* add R10, R8, R9 */
		/* 820C6DB8h case   16:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R9);
		/* 820C6DB8h case   16:*/		return 0x820C6DBC;
		  /* 820C6DBCh */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C6DBCh case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C6DBCh case   17:*/		return 0x820C6DC0;
		  /* 820C6DC0h */ case   18:  		/* add R10, R10, R11 */
		/* 820C6DC0h case   18:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C6DC0h case   18:*/		return 0x820C6DC4;
		  /* 820C6DC4h */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C6DC4h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C6DC4h case   19:*/		return 0x820C6DC8;
		  /* 820C6DC8h */ case   20:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C6DC8h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C6DC8h case   20:*/		return 0x820C6DCC;
		  /* 820C6DCCh */ case   21:  		/* b 8 */
		/* 820C6DCCh case   21:*/		return 0x820C6DD4;
		/* 820C6DCCh case   21:*/		return 0x820C6DD0;
	}
	return 0x820C6DD0;
} // Block from 820C6D78h-820C6DD0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C6DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6DD0);
		  /* 820C6DD0h */ case    0:  		/* li R10, 0 */
		/* 820C6DD0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C6DD0h case    0:*/		return 0x820C6DD4;
	}
	return 0x820C6DD4;
} // Block from 820C6DD0h-820C6DD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C6DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6DD4);
		  /* 820C6DD4h */ case    0:  		/* addi R11, R11, 1 */
		/* 820C6DD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C6DD4h case    0:*/		return 0x820C6DD8;
		  /* 820C6DD8h */ case    1:  		/* stwu R10, <#[R7 + 4]> */
		/* 820C6DD8h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820C6DD8h case    1:*/		return 0x820C6DDC;
		  /* 820C6DDCh */ case    2:  		/* lhz R10, <#[R25 + 4]> */
		/* 820C6DDCh case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820C6DDCh case    2:*/		return 0x820C6DE0;
		  /* 820C6DE0h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C6DE0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C6DE0h case    3:*/		return 0x820C6DE4;
		  /* 820C6DE4h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 820C6DE4h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C6DA8;  }
		/* 820C6DE4h case    4:*/		return 0x820C6DE8;
	}
	return 0x820C6DE8;
} // Block from 820C6DD4h-820C6DE8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6DE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6DE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6DE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6DE8);
		  /* 820C6DE8h */ case    0:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C6DE8h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6DE8h case    0:*/		return 0x820C6DEC;
		  /* 820C6DECh */ case    1:  		/* addi R9, R9, 1 */
		/* 820C6DECh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C6DECh case    1:*/		return 0x820C6DF0;
		  /* 820C6DF0h */ case    2:  		/* cmplw CR6, R9, R11 */
		/* 820C6DF0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820C6DF0h case    2:*/		return 0x820C6DF4;
		  /* 820C6DF4h */ case    3:  		/* bc 12, CR6_LT, -88 */
		/* 820C6DF4h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C6D9C;  }
		/* 820C6DF4h case    3:*/		return 0x820C6DF8;
	}
	return 0x820C6DF8;
} // Block from 820C6DE8h-820C6DF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C6DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6DF8);
		  /* 820C6DF8h */ case    0:  		/* addi R8, R8, 4 */
		/* 820C6DF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820C6DF8h case    0:*/		return 0x820C6DFC;
		  /* 820C6DFCh */ case    1:  		/* bc 16, CR0_LT, -112 */
		/* 820C6DFCh case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6D8C;  }
		/* 820C6DFCh case    1:*/		return 0x820C6E00;
		  /* 820C6E00h */ case    2:  		/* b 568 */
		/* 820C6E00h case    2:*/		return 0x820C7038;
		/* 820C6E00h case    2:*/		return 0x820C6E04;
	}
	return 0x820C6E04;
} // Block from 820C6DF8h-820C6E04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C6E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6E04);
		  /* 820C6E04h */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C6E04h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C6E04h case    0:*/		return 0x820C6E08;
		  /* 820C6E08h */ case    1:  		/* mr R31, R11 */
		/* 820C6E08h case    1:*/		regs.R31 = regs.R11;
		/* 820C6E08h case    1:*/		return 0x820C6E0C;
		  /* 820C6E0Ch */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C6E0Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C6E0Ch case    2:*/		return 0x820C6E10;
		  /* 820C6E10h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C6E10h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C6E18;  }
		/* 820C6E10h case    3:*/		return 0x820C6E14;
		  /* 820C6E14h */ case    4:  		/* mr R31, R10 */
		/* 820C6E14h case    4:*/		regs.R31 = regs.R10;
		/* 820C6E14h case    4:*/		return 0x820C6E18;
	}
	return 0x820C6E18;
} // Block from 820C6E04h-820C6E18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6E18);
		  /* 820C6E18h */ case    0:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C6E18h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C6E18h case    0:*/		return 0x820C6E1C;
		  /* 820C6E1Ch */ case    1:  		/* cmplwi CR6, R11, 4 */
		/* 820C6E1Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C6E1Ch case    1:*/		return 0x820C6E20;
		  /* 820C6E20h */ case    2:  		/* bc 4, CR6_EQ, 180 */
		/* 820C6E20h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C6ED4;  }
		/* 820C6E20h case    2:*/		return 0x820C6E24;
		  /* 820C6E24h */ case    3:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C6E24h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6E24h case    3:*/		return 0x820C6E28;
		  /* 820C6E28h */ case    4:  		/* cmplwi CR6, R10, 4 */
		/* 820C6E28h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820C6E28h case    4:*/		return 0x820C6E2C;
		  /* 820C6E2Ch */ case    5:  		/* bc 4, CR6_EQ, 168 */
		/* 820C6E2Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C6ED4;  }
		/* 820C6E2Ch case    5:*/		return 0x820C6E30;
		  /* 820C6E30h */ case    6:  		/* cmplwi CR6, R31, 0 */
		/* 820C6E30h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C6E30h case    6:*/		return 0x820C6E34;
		  /* 820C6E34h */ case    7:  		/* bc 12, CR6_EQ, 516 */
		/* 820C6E34h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C7038;  }
		/* 820C6E34h case    7:*/		return 0x820C6E38;
		  /* 820C6E38h */ case    8:  		/* addi R10, R6, -4 */
		/* 820C6E38h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C6E38h case    8:*/		return 0x820C6E3C;
		  /* 820C6E3Ch */ case    9:  		/* mtspr CTR, R31 */
		/* 820C6E3Ch case    9:*/		regs.CTR = regs.R31;
		/* 820C6E3Ch case    9:*/		return 0x820C6E40;
		  /* 820C6E40h */ case   10:  		/* addi R11, R5, 32 */
		/* 820C6E40h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x20);
		/* 820C6E40h case   10:*/		return 0x820C6E44;
		  /* 820C6E44h */ case   11:  		/* subf R9, R5, R6 */
		/* 820C6E44h case   11:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R5,regs.R6);
		/* 820C6E44h case   11:*/		return 0x820C6E48;
		  /* 820C6E48h */ case   12:  		/* lfs FR0, <#[R11 - 32]> */
		/* 820C6E48h case   12:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFE0) );
		/* 820C6E48h case   12:*/		return 0x820C6E4C;
		  /* 820C6E4Ch */ case   13:  		/* stfs FR0, <#[R10 + 4]> */
		/* 820C6E4Ch case   13:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000004) );
		/* 820C6E4Ch case   13:*/		return 0x820C6E50;
		  /* 820C6E50h */ case   14:  		/* lfs FR0, <#[R11 - 16]> */
		/* 820C6E50h case   14:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFF0) );
		/* 820C6E50h case   14:*/		return 0x820C6E54;
		  /* 820C6E54h */ case   15:  		/* stfs FR0, <#[R10 + 8]> */
		/* 820C6E54h case   15:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000008) );
		/* 820C6E54h case   15:*/		return 0x820C6E58;
		  /* 820C6E58h */ case   16:  		/* lfs FR0, <#[R11]> */
		/* 820C6E58h case   16:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 820C6E58h case   16:*/		return 0x820C6E5C;
		  /* 820C6E5Ch */ case   17:  		/* stfs FR0, <#[R10 + 12]> */
		/* 820C6E5Ch case   17:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x0000000C) );
		/* 820C6E5Ch case   17:*/		return 0x820C6E60;
		  /* 820C6E60h */ case   18:  		/* lfs FR0, <#[R11 + 16]> */
		/* 820C6E60h case   18:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000010) );
		/* 820C6E60h case   18:*/		return 0x820C6E64;
		  /* 820C6E64h */ case   19:  		/* stfs FR0, <#[R10 + 16]> */
		/* 820C6E64h case   19:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000010) );
		/* 820C6E64h case   19:*/		return 0x820C6E68;
		  /* 820C6E68h */ case   20:  		/* lfs FR0, <#[R11 - 28]> */
		/* 820C6E68h case   20:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFE4) );
		/* 820C6E68h case   20:*/		return 0x820C6E6C;
		  /* 820C6E6Ch */ case   21:  		/* stfs FR0, <#[R10 + 20]> */
		/* 820C6E6Ch case   21:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000014) );
		/* 820C6E6Ch case   21:*/		return 0x820C6E70;
		  /* 820C6E70h */ case   22:  		/* lfs FR0, <#[R11 - 12]> */
		/* 820C6E70h case   22:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFF4) );
		/* 820C6E70h case   22:*/		return 0x820C6E74;
		  /* 820C6E74h */ case   23:  		/* stfs FR0, <#[R10 + 24]> */
		/* 820C6E74h case   23:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000018) );
		/* 820C6E74h case   23:*/		return 0x820C6E78;
		  /* 820C6E78h */ case   24:  		/* lfs FR0, <#[R11 + 4]> */
		/* 820C6E78h case   24:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000004) );
		/* 820C6E78h case   24:*/		return 0x820C6E7C;
		  /* 820C6E7Ch */ case   25:  		/* stfs FR0, <#[R10 + 28]> */
		/* 820C6E7Ch case   25:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x0000001C) );
		/* 820C6E7Ch case   25:*/		return 0x820C6E80;
		  /* 820C6E80h */ case   26:  		/* lfs FR0, <#[R11 + 20]> */
		/* 820C6E80h case   26:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000014) );
		/* 820C6E80h case   26:*/		return 0x820C6E84;
		  /* 820C6E84h */ case   27:  		/* stfs FR0, <#[R10 + 32]> */
		/* 820C6E84h case   27:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000020) );
		/* 820C6E84h case   27:*/		return 0x820C6E88;
		  /* 820C6E88h */ case   28:  		/* lfs FR0, <#[R11 - 24]> */
		/* 820C6E88h case   28:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFE8) );
		/* 820C6E88h case   28:*/		return 0x820C6E8C;
		  /* 820C6E8Ch */ case   29:  		/* stfsx FR0, <#[R9 + R11]> */
		/* 820C6E8Ch case   29:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 820C6E8Ch case   29:*/		return 0x820C6E90;
		  /* 820C6E90h */ case   30:  		/* lfs FR0, <#[R11 - 8]> */
		/* 820C6E90h case   30:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 820C6E90h case   30:*/		return 0x820C6E94;
		  /* 820C6E94h */ case   31:  		/* stfs FR0, <#[R10 + 40]> */
		/* 820C6E94h case   31:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000028) );
		/* 820C6E94h case   31:*/		return 0x820C6E98;
		  /* 820C6E98h */ case   32:  		/* lfs FR0, <#[R11 + 8]> */
		/* 820C6E98h case   32:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000008) );
		/* 820C6E98h case   32:*/		return 0x820C6E9C;
		  /* 820C6E9Ch */ case   33:  		/* stfs FR0, <#[R10 + 44]> */
		/* 820C6E9Ch case   33:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x0000002C) );
		/* 820C6E9Ch case   33:*/		return 0x820C6EA0;
		  /* 820C6EA0h */ case   34:  		/* lfs FR0, <#[R11 + 24]> */
		/* 820C6EA0h case   34:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000018) );
		/* 820C6EA0h case   34:*/		return 0x820C6EA4;
		  /* 820C6EA4h */ case   35:  		/* stfs FR0, <#[R10 + 48]> */
		/* 820C6EA4h case   35:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000030) );
		/* 820C6EA4h case   35:*/		return 0x820C6EA8;
		  /* 820C6EA8h */ case   36:  		/* lfs FR0, <#[R11 - 20]> */
		/* 820C6EA8h case   36:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFEC) );
		/* 820C6EA8h case   36:*/		return 0x820C6EAC;
		  /* 820C6EACh */ case   37:  		/* stfs FR0, <#[R10 + 52]> */
		/* 820C6EACh case   37:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000034) );
		/* 820C6EACh case   37:*/		return 0x820C6EB0;
		  /* 820C6EB0h */ case   38:  		/* lfs FR0, <#[R11 - 4]> */
		/* 820C6EB0h case   38:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 820C6EB0h case   38:*/		return 0x820C6EB4;
		  /* 820C6EB4h */ case   39:  		/* stfs FR0, <#[R10 + 56]> */
		/* 820C6EB4h case   39:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000038) );
		/* 820C6EB4h case   39:*/		return 0x820C6EB8;
		  /* 820C6EB8h */ case   40:  		/* lfs FR0, <#[R11 + 12]> */
		/* 820C6EB8h case   40:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C6EB8h case   40:*/		return 0x820C6EBC;
		  /* 820C6EBCh */ case   41:  		/* stfs FR0, <#[R10 + 60]> */
		/* 820C6EBCh case   41:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x0000003C) );
		/* 820C6EBCh case   41:*/		return 0x820C6EC0;
		  /* 820C6EC0h */ case   42:  		/* lfs FR0, <#[R11 + 28]> */
		/* 820C6EC0h case   42:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x0000001C) );
		/* 820C6EC0h case   42:*/		return 0x820C6EC4;
		  /* 820C6EC4h */ case   43:  		/* addi R11, R11, 64 */
		/* 820C6EC4h case   43:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x40);
		/* 820C6EC4h case   43:*/		return 0x820C6EC8;
		  /* 820C6EC8h */ case   44:  		/* stfsu FR0, <#[R10 + 64]> */
		/* 820C6EC8h case   44:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R10 + 0x00000040) );
		regs.R10 = (uint32)(regs.R10 + 0x00000040);
		/* 820C6EC8h case   44:*/		return 0x820C6ECC;
		  /* 820C6ECCh */ case   45:  		/* bc 16, CR0_LT, -132 */
		/* 820C6ECCh case   45:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6E48;  }
		/* 820C6ECCh case   45:*/		return 0x820C6ED0;
		  /* 820C6ED0h */ case   46:  		/* b 360 */
		/* 820C6ED0h case   46:*/		return 0x820C7038;
		/* 820C6ED0h case   46:*/		return 0x820C6ED4;
	}
	return 0x820C6ED4;
} // Block from 820C6E18h-820C6ED4h (47 instructions)

//////////////////////////////////////////////////////
// Block at 820C6ED4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6ED4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6ED4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6ED4);
		  /* 820C6ED4h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820C6ED4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C6ED4h case    0:*/		return 0x820C6ED8;
		  /* 820C6ED8h */ case    1:  		/* bc 12, CR6_EQ, 352 */
		/* 820C6ED8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C7038;  }
		/* 820C6ED8h case    1:*/		return 0x820C6EDC;
		  /* 820C6EDCh */ case    2:  		/* li R8, 0 */
		/* 820C6EDCh case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C6EDCh case    2:*/		return 0x820C6EE0;
		  /* 820C6EE0h */ case    3:  		/* mtspr CTR, R31 */
		/* 820C6EE0h case    3:*/		regs.CTR = regs.R31;
		/* 820C6EE0h case    3:*/		return 0x820C6EE4;
		  /* 820C6EE4h */ case    4:  		/* addi R7, R6, -4 */
		/* 820C6EE4h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820C6EE4h case    4:*/		return 0x820C6EE8;
		  /* 820C6EE8h */ case    5:  		/* li R9, 0 */
		/* 820C6EE8h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C6EE8h case    5:*/		return 0x820C6EEC;
		  /* 820C6EECh */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820C6EECh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C6EECh case    6:*/		return 0x820C6EF0;
		  /* 820C6EF0h */ case    7:  		/* bc 12, CR6_EQ, 100 */
		/* 820C6EF0h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C6F54;  }
		/* 820C6EF0h case    7:*/		return 0x820C6EF4;
		  /* 820C6EF4h */ case    8:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C6EF4h case    8:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6EF4h case    8:*/		return 0x820C6EF8;
		  /* 820C6EF8h */ case    9:  		/* li R11, 0 */
		/* 820C6EF8h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6EF8h case    9:*/		return 0x820C6EFC;
		  /* 820C6EFCh */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 820C6EFCh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C6EFCh case   10:*/		return 0x820C6F00;
		  /* 820C6F00h */ case   11:  		/* bc 12, CR6_EQ, 68 */
		/* 820C6F00h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C6F44;  }
		/* 820C6F00h case   11:*/		return 0x820C6F04;
		  /* 820C6F04h */ case   12:  		/* cmplwi CR6, R9, 4 */
		/* 820C6F04h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000004);
		/* 820C6F04h case   12:*/		return 0x820C6F08;
		  /* 820C6F08h */ case   13:  		/* bc 12, CR6_GT, 36 */
		/* 820C6F08h case   13:*/		if ( regs.CR[6].gt ) { return 0x820C6F2C;  }
		/* 820C6F08h case   13:*/		return 0x820C6F0C;
		  /* 820C6F0Ch */ case   14:  		/* cmplwi CR6, R11, 4 */
		/* 820C6F0Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C6F0Ch case   14:*/		return 0x820C6F10;
		  /* 820C6F10h */ case   15:  		/* bc 12, CR6_GT, 28 */
		/* 820C6F10h case   15:*/		if ( regs.CR[6].gt ) { return 0x820C6F2C;  }
		/* 820C6F10h case   15:*/		return 0x820C6F14;
		  /* 820C6F14h */ case   16:  		/* add R10, R8, R11 */
		/* 820C6F14h case   16:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R11);
		/* 820C6F14h case   16:*/		return 0x820C6F18;
		  /* 820C6F18h */ case   17:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C6F18h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C6F18h case   17:*/		return 0x820C6F1C;
		  /* 820C6F1Ch */ case   18:  		/* add R10, R10, R9 */
		/* 820C6F1Ch case   18:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820C6F1Ch case   18:*/		return 0x820C6F20;
		  /* 820C6F20h */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C6F20h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C6F20h case   19:*/		return 0x820C6F24;
		  /* 820C6F24h */ case   20:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C6F24h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C6F24h case   20:*/		return 0x820C6F28;
		  /* 820C6F28h */ case   21:  		/* b 8 */
		/* 820C6F28h case   21:*/		return 0x820C6F30;
		/* 820C6F28h case   21:*/		return 0x820C6F2C;
	}
	return 0x820C6F2C;
} // Block from 820C6ED4h-820C6F2Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C6F2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6F2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6F2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6F2C);
		  /* 820C6F2Ch */ case    0:  		/* li R10, 0 */
		/* 820C6F2Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C6F2Ch case    0:*/		return 0x820C6F30;
	}
	return 0x820C6F30;
} // Block from 820C6F2Ch-820C6F30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C6F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6F30);
		  /* 820C6F30h */ case    0:  		/* addi R11, R11, 1 */
		/* 820C6F30h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C6F30h case    0:*/		return 0x820C6F34;
		  /* 820C6F34h */ case    1:  		/* stwu R10, <#[R7 + 4]> */
		/* 820C6F34h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820C6F34h case    1:*/		return 0x820C6F38;
		  /* 820C6F38h */ case    2:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C6F38h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6F38h case    2:*/		return 0x820C6F3C;
		  /* 820C6F3Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C6F3Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C6F3Ch case    3:*/		return 0x820C6F40;
		  /* 820C6F40h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 820C6F40h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C6F04;  }
		/* 820C6F40h case    4:*/		return 0x820C6F44;
	}
	return 0x820C6F44;
} // Block from 820C6F30h-820C6F44h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6F44);
		  /* 820C6F44h */ case    0:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C6F44h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C6F44h case    0:*/		return 0x820C6F48;
		  /* 820C6F48h */ case    1:  		/* addi R9, R9, 1 */
		/* 820C6F48h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C6F48h case    1:*/		return 0x820C6F4C;
		  /* 820C6F4Ch */ case    2:  		/* cmplw CR6, R9, R11 */
		/* 820C6F4Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820C6F4Ch case    2:*/		return 0x820C6F50;
		  /* 820C6F50h */ case    3:  		/* bc 12, CR6_LT, -88 */
		/* 820C6F50h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C6EF8;  }
		/* 820C6F50h case    3:*/		return 0x820C6F54;
	}
	return 0x820C6F54;
} // Block from 820C6F44h-820C6F54h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C6F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6F54);
		  /* 820C6F54h */ case    0:  		/* addi R8, R8, 4 */
		/* 820C6F54h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x4);
		/* 820C6F54h case    0:*/		return 0x820C6F58;
		  /* 820C6F58h */ case    1:  		/* bc 16, CR0_LT, -112 */
		/* 820C6F58h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C6EE8;  }
		/* 820C6F58h case    1:*/		return 0x820C6F5C;
		  /* 820C6F5Ch */ case    2:  		/* b 220 */
		/* 820C6F5Ch case    2:*/		return 0x820C7038;
		/* 820C6F5Ch case    2:*/		return 0x820C6F60;
	}
	return 0x820C6F60;
} // Block from 820C6F54h-820C6F60h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C6F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6F60);
		  /* 820C6F60h */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C6F60h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C6F60h case    0:*/		return 0x820C6F64;
		  /* 820C6F64h */ case    1:  		/* rlwinm R31, R11, 2, 0, 29 */
		/* 820C6F64h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R11);
		/* 820C6F64h case    1:*/		return 0x820C6F68;
		  /* 820C6F68h */ case    2:  		/* cmplw CR6, R31, R10 */
		/* 820C6F68h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 820C6F68h case    2:*/		return 0x820C6F6C;
		  /* 820C6F6Ch */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C6F6Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C6F74;  }
		/* 820C6F6Ch case    3:*/		return 0x820C6F70;
		  /* 820C6F70h */ case    4:  		/* mr R31, R10 */
		/* 820C6F70h case    4:*/		regs.R31 = regs.R10;
		/* 820C6F70h case    4:*/		return 0x820C6F74;
	}
	return 0x820C6F74;
} // Block from 820C6F60h-820C6F74h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6F74);
		  /* 820C6F74h */ case    0:  		/* li R8, 0 */
		/* 820C6F74h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C6F74h case    0:*/		return 0x820C6F78;
		  /* 820C6F78h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820C6F78h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C6F78h case    1:*/		return 0x820C6F7C;
		  /* 820C6F7Ch */ case    2:  		/* bc 12, CR6_EQ, 188 */
		/* 820C6F7Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C7038;  }
		/* 820C6F7Ch case    2:*/		return 0x820C6F80;
		  /* 820C6F80h */ case    3:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C6F80h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6F80h case    3:*/		return 0x820C6F84;
		  /* 820C6F84h */ case    4:  		/* addi R7, R6, -4 */
		/* 820C6F84h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820C6F84h case    4:*/		return 0x820C6F88;
		  /* 820C6F88h */ case    5:  		/* li R11, 0 */
		/* 820C6F88h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6F88h case    5:*/		return 0x820C6F8C;
		  /* 820C6F8Ch */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 820C6F8Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C6F8Ch case    6:*/		return 0x820C6F90;
		  /* 820C6F90h */ case    7:  		/* bc 12, CR6_EQ, 68 */
		/* 820C6F90h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C6FD4;  }
		/* 820C6F90h case    7:*/		return 0x820C6F94;
		  /* 820C6F94h */ case    8:  		/* cmplwi CR6, R11, 4 */
		/* 820C6F94h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C6F94h case    8:*/		return 0x820C6F98;
		  /* 820C6F98h */ case    9:  		/* bc 4, CR6_GT, 12 */
		/* 820C6F98h case    9:*/		if ( !regs.CR[6].gt ) { return 0x820C6FA4;  }
		/* 820C6F98h case    9:*/		return 0x820C6F9C;
		  /* 820C6F9Ch */ case   10:  		/* li R10, 0 */
		/* 820C6F9Ch case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C6F9Ch case   10:*/		return 0x820C6FA0;
		  /* 820C6FA0h */ case   11:  		/* b 32 */
		/* 820C6FA0h case   11:*/		return 0x820C6FC0;
		/* 820C6FA0h case   11:*/		return 0x820C6FA4;
	}
	return 0x820C6FA4;
} // Block from 820C6F74h-820C6FA4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C6FA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6FA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6FA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6FA4);
		  /* 820C6FA4h */ case    0:  		/* rlwinm R10, R8, 0, 0, 29 */
		/* 820C6FA4h case    0:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R8);
		/* 820C6FA4h case    0:*/		return 0x820C6FA8;
		  /* 820C6FA8h */ case    1:  		/* rlwinm R9, R8, 0, 30, 31 */
		/* 820C6FA8h case    1:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R9,regs.R8);
		/* 820C6FA8h case    1:*/		return 0x820C6FAC;
		  /* 820C6FACh */ case    2:  		/* add R10, R10, R11 */
		/* 820C6FACh case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C6FACh case    2:*/		return 0x820C6FB0;
		  /* 820C6FB0h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C6FB0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C6FB0h case    3:*/		return 0x820C6FB4;
		  /* 820C6FB4h */ case    4:  		/* add R10, R10, R9 */
		/* 820C6FB4h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820C6FB4h case    4:*/		return 0x820C6FB8;
		  /* 820C6FB8h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C6FB8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C6FB8h case    5:*/		return 0x820C6FBC;
		  /* 820C6FBCh */ case    6:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C6FBCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C6FBCh case    6:*/		return 0x820C6FC0;
	}
	return 0x820C6FC0;
} // Block from 820C6FA4h-820C6FC0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C6FC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6FC0);
		  /* 820C6FC0h */ case    0:  		/* addi R11, R11, 1 */
		/* 820C6FC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C6FC0h case    0:*/		return 0x820C6FC4;
		  /* 820C6FC4h */ case    1:  		/* stwu R10, <#[R7 + 4]> */
		/* 820C6FC4h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820C6FC4h case    1:*/		return 0x820C6FC8;
		  /* 820C6FC8h */ case    2:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C6FC8h case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C6FC8h case    2:*/		return 0x820C6FCC;
		  /* 820C6FCCh */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C6FCCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C6FCCh case    3:*/		return 0x820C6FD0;
		  /* 820C6FD0h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 820C6FD0h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C6F94;  }
		/* 820C6FD0h case    4:*/		return 0x820C6FD4;
	}
	return 0x820C6FD4;
} // Block from 820C6FC0h-820C6FD4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6FD4);
		  /* 820C6FD4h */ case    0:  		/* addi R8, R8, 1 */
		/* 820C6FD4h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820C6FD4h case    0:*/		return 0x820C6FD8;
		  /* 820C6FD8h */ case    1:  		/* cmplw CR6, R8, R31 */
		/* 820C6FD8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R31);
		/* 820C6FD8h case    1:*/		return 0x820C6FDC;
		  /* 820C6FDCh */ case    2:  		/* bc 12, CR6_LT, -84 */
		/* 820C6FDCh case    2:*/		if ( regs.CR[6].lt ) { return 0x820C6F88;  }
		/* 820C6FDCh case    2:*/		return 0x820C6FE0;
		  /* 820C6FE0h */ case    3:  		/* b 88 */
		/* 820C6FE0h case    3:*/		return 0x820C7038;
		/* 820C6FE0h case    3:*/		return 0x820C6FE4;
	}
	return 0x820C6FE4;
} // Block from 820C6FD4h-820C6FE4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C6FE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6FE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6FE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6FE4);
		  /* 820C6FE4h */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C6FE4h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C6FE4h case    0:*/		return 0x820C6FE8;
		  /* 820C6FE8h */ case    1:  		/* rlwinm R31, R11, 4, 0, 27 */
		/* 820C6FE8h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R31,regs.R11);
		/* 820C6FE8h case    1:*/		return 0x820C6FEC;
		  /* 820C6FECh */ case    2:  		/* cmplw CR6, R31, R10 */
		/* 820C6FECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 820C6FECh case    2:*/		return 0x820C6FF0;
		  /* 820C6FF0h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C6FF0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C6FF8;  }
		/* 820C6FF0h case    3:*/		return 0x820C6FF4;
		  /* 820C6FF4h */ case    4:  		/* mr R31, R10 */
		/* 820C6FF4h case    4:*/		regs.R31 = regs.R10;
		/* 820C6FF4h case    4:*/		return 0x820C6FF8;
	}
	return 0x820C6FF8;
} // Block from 820C6FE4h-820C6FF8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C6FF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C6FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C6FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C6FF8);
		  /* 820C6FF8h */ case    0:  		/* li R11, 0 */
		/* 820C6FF8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C6FF8h case    0:*/		return 0x820C6FFC;
		  /* 820C6FFCh */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820C6FFCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C6FFCh case    1:*/		return 0x820C7000;
		  /* 820C7000h */ case    2:  		/* bc 12, CR6_EQ, 56 */
		/* 820C7000h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C7038;  }
		/* 820C7000h case    2:*/		return 0x820C7004;
		  /* 820C7004h */ case    3:  		/* mtspr CTR, R31 */
		/* 820C7004h case    3:*/		regs.CTR = regs.R31;
		/* 820C7004h case    3:*/		return 0x820C7008;
		  /* 820C7008h */ case    4:  		/* addi R10, R6, -4 */
		/* 820C7008h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C7008h case    4:*/		return 0x820C700C;
		  /* 820C700Ch */ case    5:  		/* rlwinm R9, R11, 30, 2, 29 */
		/* 820C700Ch case    5:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R9,regs.R11);
		/* 820C700Ch case    5:*/		return 0x820C7010;
		  /* 820C7010h */ case    6:  		/* rlwinm R7, R11, 0, 30, 31 */
		/* 820C7010h case    6:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R7,regs.R11);
		/* 820C7010h case    6:*/		return 0x820C7014;
		  /* 820C7014h */ case    7:  		/* rlwinm R8, R11, 30, 30, 31 */
		/* 820C7014h case    7:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R8,regs.R11);
		/* 820C7014h case    7:*/		return 0x820C7018;
		  /* 820C7018h */ case    8:  		/* add R9, R9, R7 */
		/* 820C7018h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 820C7018h case    8:*/		return 0x820C701C;
		  /* 820C701Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 820C701Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C701Ch case    9:*/		return 0x820C7020;
		  /* 820C7020h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C7020h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C7020h case   10:*/		return 0x820C7024;
		  /* 820C7024h */ case   11:  		/* add R9, R9, R8 */
		/* 820C7024h case   11:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820C7024h case   11:*/		return 0x820C7028;
		  /* 820C7028h */ case   12:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C7028h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C7028h case   12:*/		return 0x820C702C;
		  /* 820C702Ch */ case   13:  		/* lwzx R9, <#[R9 + R5]> */
		/* 820C702Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 820C702Ch case   13:*/		return 0x820C7030;
		  /* 820C7030h */ case   14:  		/* stwu R9, <#[R10 + 4]> */
		/* 820C7030h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C7030h case   14:*/		return 0x820C7034;
		  /* 820C7034h */ case   15:  		/* bc 16, CR0_LT, -40 */
		/* 820C7034h case   15:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C700C;  }
		/* 820C7034h case   15:*/		return 0x820C7038;
	}
	return 0x820C7038;
} // Block from 820C6FF8h-820C7038h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C7038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7038);
		  /* 820C7038h */ case    0:  		/* mr R5, R6 */
		/* 820C7038h case    0:*/		regs.R5 = regs.R6;
		/* 820C7038h case    0:*/		return 0x820C703C;
	}
	return 0x820C703C;
} // Block from 820C7038h-820C703Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C703Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C703C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C703C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C703C);
		  /* 820C703Ch */ case    0:  		/* lhz R10, <#[R25 + 2]> */
		/* 820C703Ch case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000002) );
		/* 820C703Ch case    0:*/		return 0x820C7040;
		  /* 820C7040h */ case    1:  		/* cmplwi CR6, R10, 3 */
		/* 820C7040h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C7040h case    1:*/		return 0x820C7044;
		  /* 820C7044h */ case    2:  		/* bc 12, CR6_EQ, 136 */
		/* 820C7044h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C70CC;  }
		/* 820C7044h case    2:*/		return 0x820C7048;
		  /* 820C7048h */ case    3:  		/* lwz R11, <#[R24 + 52]> */
		/* 820C7048h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000034) );
		/* 820C7048h case    3:*/		return 0x820C704C;
		  /* 820C704Ch */ case    4:  		/* cmplwi CR6, R10, 1 */
		/* 820C704Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C704Ch case    4:*/		return 0x820C7050;
		  /* 820C7050h */ case    5:  		/* mullw R11, R11, R31 */
		/* 820C7050h case    5:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820C7050h case    5:*/		return 0x820C7054;
		  /* 820C7054h */ case    6:  		/* bc 12, CR6_EQ, 56 */
		/* 820C7054h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C708C;  }
		/* 820C7054h case    6:*/		return 0x820C7058;
		  /* 820C7058h */ case    7:  		/* cmplwi CR6, R10, 2 */
		/* 820C7058h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820C7058h case    7:*/		return 0x820C705C;
		  /* 820C705Ch */ case    8:  		/* bc 4, CR6_EQ, 108 */
		/* 820C705Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C70C8;  }
		/* 820C705Ch case    8:*/		return 0x820C7060;
		  /* 820C7060h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820C7060h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C7060h case    9:*/		return 0x820C7064;
		  /* 820C7064h */ case   10:  		/* bc 12, CR6_EQ, 100 */
		/* 820C7064h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C70C8;  }
		/* 820C7064h case   10:*/		return 0x820C7068;
		  /* 820C7068h */ case   11:  		/* mtspr CTR, R11 */
		/* 820C7068h case   11:*/		regs.CTR = regs.R11;
		/* 820C7068h case   11:*/		return 0x820C706C;
		  /* 820C706Ch */ case   12:  		/* mr R10, R6 */
		/* 820C706Ch case   12:*/		regs.R10 = regs.R6;
		/* 820C706Ch case   12:*/		return 0x820C7070;
		  /* 820C7070h */ case   13:  		/* subf R11, R6, R5 */
		/* 820C7070h case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R5);
		/* 820C7070h case   13:*/		return 0x820C7074;
		  /* 820C7074h */ case   14:  		/* lfsx FR0, <#[R11 + R10]> */
		/* 820C7074h case   14:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 820C7074h case   14:*/		return 0x820C7078;
		  /* 820C7078h */ case   15:  		/* fctiwz FR0, FR0 */
		/* 820C7078h case   15:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 820C7078h case   15:*/		return 0x820C707C;
		  /* 820C707Ch */ case   16:  		/* stfiwx FR0, <#[R10]> */
		/* 820C707Ch case   16:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R10 + 0x00000000) );
		/* 820C707Ch case   16:*/		return 0x820C7080;
		  /* 820C7080h */ case   17:  		/* addi R10, R10, 4 */
		/* 820C7080h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C7080h case   17:*/		return 0x820C7084;
		  /* 820C7084h */ case   18:  		/* bc 16, CR0_LT, -16 */
		/* 820C7084h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C7074;  }
		/* 820C7084h case   18:*/		return 0x820C7088;
		  /* 820C7088h */ case   19:  		/* b 64 */
		/* 820C7088h case   19:*/		return 0x820C70C8;
		/* 820C7088h case   19:*/		return 0x820C708C;
	}
	return 0x820C708C;
} // Block from 820C703Ch-820C708Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C708Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C708C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C708C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C708C);
		  /* 820C708Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C708Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C708Ch case    0:*/		return 0x820C7090;
		  /* 820C7090h */ case    1:  		/* bc 12, CR6_EQ, 56 */
		/* 820C7090h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C70C8;  }
		/* 820C7090h case    1:*/		return 0x820C7094;
		  /* 820C7094h */ case    2:  		/* mtspr CTR, R11 */
		/* 820C7094h case    2:*/		regs.CTR = regs.R11;
		/* 820C7094h case    2:*/		return 0x820C7098;
		  /* 820C7098h */ case    3:  		/* lis R11, -32256 */
		/* 820C7098h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820C7098h case    3:*/		return 0x820C709C;
		  /* 820C709Ch */ case    4:  		/* mr R10, R6 */
		/* 820C709Ch case    4:*/		regs.R10 = regs.R6;
		/* 820C709Ch case    4:*/		return 0x820C70A0;
		  /* 820C70A0h */ case    5:  		/* subf R9, R6, R5 */
		/* 820C70A0h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R5);
		/* 820C70A0h case    5:*/		return 0x820C70A4;
		  /* 820C70A4h */ case    6:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 820C70A4h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 820C70A4h case    6:*/		return 0x820C70A8;
		  /* 820C70A8h */ case    7:  		/* lfsx FR13, <#[R10 + R9]> */
		/* 820C70A8h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 820C70A8h case    7:*/		return 0x820C70AC;
		  /* 820C70ACh */ case    8:  		/* li R11, 1 */
		/* 820C70ACh case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820C70ACh case    8:*/		return 0x820C70B0;
		  /* 820C70B0h */ case    9:  		/* fcmpu CR6, FR13, FR0 */
		/* 820C70B0h case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820C70B0h case    9:*/		return 0x820C70B4;
		  /* 820C70B4h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 820C70B4h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820C70BC;  }
		/* 820C70B4h case   10:*/		return 0x820C70B8;
		  /* 820C70B8h */ case   11:  		/* li R11, 0 */
		/* 820C70B8h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C70B8h case   11:*/		return 0x820C70BC;
	}
	return 0x820C70BC;
} // Block from 820C708Ch-820C70BCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C70BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C70BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C70BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C70BC);
		  /* 820C70BCh */ case    0:  		/* stw R11, <#[R10]> */
		/* 820C70BCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820C70BCh case    0:*/		return 0x820C70C0;
		  /* 820C70C0h */ case    1:  		/* addi R10, R10, 4 */
		/* 820C70C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C70C0h case    1:*/		return 0x820C70C4;
		  /* 820C70C4h */ case    2:  		/* bc 16, CR0_LT, -28 */
		/* 820C70C4h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C70A8;  }
		/* 820C70C4h case    2:*/		return 0x820C70C8;
	}
	return 0x820C70C8;
} // Block from 820C70BCh-820C70C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C70C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C70C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C70C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C70C8);
		  /* 820C70C8h */ case    0:  		/* mr R5, R6 */
		/* 820C70C8h case    0:*/		regs.R5 = regs.R6;
		/* 820C70C8h case    0:*/		return 0x820C70CC;
	}
	return 0x820C70CC;
} // Block from 820C70C8h-820C70CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C70CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C70CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C70CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C70CC);
		  /* 820C70CCh */ case    0:  		/* lhz R9, <#[R24 + 8]> */
		/* 820C70CCh case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 820C70CCh case    0:*/		return 0x820C70D0;
		  /* 820C70D0h */ case    1:  		/* cmplwi CR0, R9, 0 */
		/* 820C70D0h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820C70D0h case    1:*/		return 0x820C70D4;
		  /* 820C70D4h */ case    2:  		/* bc 12, CR0_EQ, 216 */
		/* 820C70D4h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C71AC;  }
		/* 820C70D4h case    2:*/		return 0x820C70D8;
		  /* 820C70D8h */ case    3:  		/* lhz R11, <#[R25]> */
		/* 820C70D8h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820C70D8h case    3:*/		return 0x820C70DC;
		  /* 820C70DCh */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C70DCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C70DCh case    4:*/		return 0x820C70E0;
		  /* 820C70E0h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820C70E0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C70F0;  }
		/* 820C70E0h case    5:*/		return 0x820C70E4;
		  /* 820C70E4h */ case    6:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C70E4h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C70E4h case    6:*/		return 0x820C70E8;
		  /* 820C70E8h */ case    7:  		/* lhz R10, <#[R25 + 4]> */
		/* 820C70E8h case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820C70E8h case    7:*/		return 0x820C70EC;
		  /* 820C70ECh */ case    8:  		/* b 12 */
		/* 820C70ECh case    8:*/		return 0x820C70F8;
		/* 820C70ECh case    8:*/		return 0x820C70F0;
	}
	return 0x820C70F0;
} // Block from 820C70CCh-820C70F0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C70F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C70F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C70F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C70F0);
		  /* 820C70F0h */ case    0:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C70F0h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C70F0h case    0:*/		return 0x820C70F4;
		  /* 820C70F4h */ case    1:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C70F4h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C70F4h case    1:*/		return 0x820C70F8;
	}
	return 0x820C70F8;
} // Block from 820C70F0h-820C70F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C70F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C70F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C70F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C70F8);
		  /* 820C70F8h */ case    0:  		/* rlwinm. R8, R11, 0, 30, 31 */
		/* 820C70F8h case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R8,regs.R11);
		/* 820C70F8h case    0:*/		return 0x820C70FC;
		  /* 820C70FCh */ case    1:  		/* bc 12, CR0_EQ, 176 */
		/* 820C70FCh case    1:*/		if ( regs.CR[0].eq ) { return 0x820C71AC;  }
		/* 820C70FCh case    1:*/		return 0x820C7100;
		  /* 820C7100h */ case    2:  		/* cmplwi CR6, R9, 1 */
		/* 820C7100h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820C7100h case    2:*/		return 0x820C7104;
		  /* 820C7104h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820C7104h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C7114;  }
		/* 820C7104h case    3:*/		return 0x820C7108;
		  /* 820C7108h */ case    4:  		/* lis R9, -32255 */
		/* 820C7108h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C7108h case    4:*/		return 0x820C710C;
		  /* 820C710Ch */ case    5:  		/* addi R3, R9, 10344 */
		/* 820C710Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R9,0x2868);
		/* 820C710Ch case    5:*/		return 0x820C7110;
		  /* 820C7110h */ case    6:  		/* b 12 */
		/* 820C7110h case    6:*/		return 0x820C711C;
		/* 820C7110h case    6:*/		return 0x820C7114;
	}
	return 0x820C7114;
} // Block from 820C70F8h-820C7114h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C7114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7114);
		  /* 820C7114h */ case    0:  		/* lis R9, -32255 */
		/* 820C7114h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C7114h case    0:*/		return 0x820C7118;
		  /* 820C7118h */ case    1:  		/* addi R3, R9, 10360 */
		/* 820C7118h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R9,0x2878);
		/* 820C7118h case    1:*/		return 0x820C711C;
	}
	return 0x820C711C;
} // Block from 820C7114h-820C711Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C711Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C711C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C711C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C711C);
		  /* 820C711Ch */ case    0:  		/* addi R9, R11, 3 */
		/* 820C711Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 820C711Ch case    0:*/		return 0x820C7120;
		  /* 820C7120h */ case    1:  		/* mullw. R8, R10, R31 */
		/* 820C7120h case    1:*/		cpu::op::mullw<1>(regs,&regs.R8,regs.R10,regs.R31);
		/* 820C7120h case    1:*/		return 0x820C7124;
		  /* 820C7124h */ case    2:  		/* rlwinm R7, R9, 0, 0, 29 */
		/* 820C7124h case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R7,regs.R9);
		/* 820C7124h case    2:*/		return 0x820C7128;
		  /* 820C7128h */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 820C7128h case    3:*/		if ( regs.CR[0].eq ) { return 0x820C71A8;  }
		/* 820C7128h case    3:*/		return 0x820C712C;
		  /* 820C712Ch */ case    4:  		/* mullw R9, R8, R7 */
		/* 820C712Ch case    4:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R7);
		/* 820C712Ch case    4:*/		return 0x820C7130;
		  /* 820C7130h */ case    5:  		/* mullw R4, R8, R11 */
		/* 820C7130h case    5:*/		cpu::op::mullw<0>(regs,&regs.R4,regs.R8,regs.R11);
		/* 820C7130h case    5:*/		return 0x820C7134;
		  /* 820C7134h */ case    6:  		/* addi R8, R8, -1 */
		/* 820C7134h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 820C7134h case    6:*/		return 0x820C7138;
		  /* 820C7138h */ case    7:  		/* subf R4, R11, R4 */
		/* 820C7138h case    7:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R11,regs.R4);
		/* 820C7138h case    7:*/		return 0x820C713C;
		  /* 820C713Ch */ case    8:  		/* subf R9, R7, R9 */
		/* 820C713Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820C713Ch case    8:*/		return 0x820C7140;
	}
	return 0x820C7140;
} // Block from 820C711Ch-820C7140h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7140h
// Function '?Set@?$SetTyped@$01$02$03$03$00@D3DXShader@@SAJPAVCConstant@2@PBX1II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7140);
		  /* 820C7140h */ case    0:  		/* mr R10, R7 */
		/* 820C7140h case    0:*/		regs.R10 = regs.R7;
		/* 820C7140h case    0:*/		return 0x820C7144;
		  /* 820C7144h */ case    1:  		/* cmplw CR6, R7, R11 */
		/* 820C7144h case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C7144h case    1:*/		return 0x820C7148;
		  /* 820C7148h */ case    2:  		/* bc 4, CR6_GT, 40 */
		/* 820C7148h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820C7170;  }
		/* 820C7148h case    2:*/		return 0x820C714C;
		  /* 820C714Ch */ case    3:  		/* subf R30, R11, R7 */
		/* 820C714Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R11,regs.R7);
		/* 820C714Ch case    3:*/		return 0x820C7150;
		  /* 820C7150h */ case    4:  		/* mtspr CTR, R30 */
		/* 820C7150h case    4:*/		regs.CTR = regs.R30;
		/* 820C7150h case    4:*/		return 0x820C7154;
		  /* 820C7154h */ case    5:  		/* addi R10, R10, -1 */
		/* 820C7154h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C7154h case    5:*/		return 0x820C7158;
		  /* 820C7158h */ case    6:  		/* rlwinm R30, R10, 2, 28, 29 */
		/* 820C7158h case    6:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R30,regs.R10);
		/* 820C7158h case    6:*/		return 0x820C715C;
		  /* 820C715Ch */ case    7:  		/* add R29, R10, R9 */
		/* 820C715Ch case    7:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R9);
		/* 820C715Ch case    7:*/		return 0x820C7160;
		  /* 820C7160h */ case    8:  		/* rlwinm R29, R29, 2, 0, 29 */
		/* 820C7160h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R29);
		/* 820C7160h case    8:*/		return 0x820C7164;
		  /* 820C7164h */ case    9:  		/* lwzx R30, <#[R30 + R3]> */
		/* 820C7164h case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + regs.R3 + 0x00000000) );
		/* 820C7164h case    9:*/		return 0x820C7168;
		  /* 820C7168h */ case   10:  		/* stwx R30, <#[R29 + R6]> */
		/* 820C7168h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R29 + regs.R6 + 0x00000000) );
		/* 820C7168h case   10:*/		return 0x820C716C;
		  /* 820C716Ch */ case   11:  		/* bc 16, CR0_LT, -24 */
		/* 820C716Ch case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C7154;  }
		/* 820C716Ch case   11:*/		return 0x820C7170;
	}
	return 0x820C7170;
} // Block from 820C7140h-820C7170h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C7170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7170);
		  /* 820C7170h */ case    0:  		/* mr R10, R11 */
		/* 820C7170h case    0:*/		regs.R10 = regs.R11;
		/* 820C7170h case    0:*/		return 0x820C7174;
		  /* 820C7174h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C7174h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C7174h case    1:*/		return 0x820C7178;
		  /* 820C7178h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7178h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C71A0;  }
		/* 820C7178h case    2:*/		return 0x820C717C;
		  /* 820C717Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 820C717Ch case    3:*/		regs.CTR = regs.R11;
		/* 820C717Ch case    3:*/		return 0x820C7180;
		  /* 820C7180h */ case    4:  		/* addi R10, R10, -1 */
		/* 820C7180h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C7180h case    4:*/		return 0x820C7184;
		  /* 820C7184h */ case    5:  		/* add R30, R10, R4 */
		/* 820C7184h case    5:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R4);
		/* 820C7184h case    5:*/		return 0x820C7188;
		  /* 820C7188h */ case    6:  		/* add R29, R10, R9 */
		/* 820C7188h case    6:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R9);
		/* 820C7188h case    6:*/		return 0x820C718C;
		  /* 820C718Ch */ case    7:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C718Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C718Ch case    7:*/		return 0x820C7190;
		  /* 820C7190h */ case    8:  		/* rlwinm R29, R29, 2, 0, 29 */
		/* 820C7190h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R29);
		/* 820C7190h case    8:*/		return 0x820C7194;
		  /* 820C7194h */ case    9:  		/* lwzx R30, <#[R30 + R5]> */
		/* 820C7194h case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + regs.R5 + 0x00000000) );
		/* 820C7194h case    9:*/		return 0x820C7198;
		  /* 820C7198h */ case   10:  		/* stwx R30, <#[R29 + R6]> */
		/* 820C7198h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R29 + regs.R6 + 0x00000000) );
		/* 820C7198h case   10:*/		return 0x820C719C;
		  /* 820C719Ch */ case   11:  		/* bc 16, CR0_LT, -28 */
		/* 820C719Ch case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C7180;  }
		/* 820C719Ch case   11:*/		return 0x820C71A0;
	}
	return 0x820C71A0;
} // Block from 820C7170h-820C71A0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C71A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C71A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C71A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C71A0);
		  /* 820C71A0h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 820C71A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C71A0h case    0:*/		return 0x820C71A4;
		  /* 820C71A4h */ case    1:  		/* bc 4, CR6_EQ, -112 */
		/* 820C71A4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C7134;  }
		/* 820C71A4h case    1:*/		return 0x820C71A8;
	}
	return 0x820C71A8;
} // Block from 820C71A0h-820C71A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C71A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C71A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C71A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C71A8);
		  /* 820C71A8h */ case    0:  		/* mr R5, R6 */
		/* 820C71A8h case    0:*/		regs.R5 = regs.R6;
		/* 820C71A8h case    0:*/		return 0x820C71AC;
	}
	return 0x820C71AC;
} // Block from 820C71A8h-820C71ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C71ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C71AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C71AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C71AC);
		  /* 820C71ACh */ case    0:  		/* lwz R10, <#[R24 + 44]> */
		/* 820C71ACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000002C) );
		/* 820C71ACh case    0:*/		return 0x820C71B0;
		  /* 820C71B0h */ case    1:  		/* lhz R11, <#[R24 + 12]> */
		/* 820C71B0h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820C71B0h case    1:*/		return 0x820C71B4;
		  /* 820C71B4h */ case    2:  		/* mullw R7, R10, R31 */
		/* 820C71B4h case    2:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R31);
		/* 820C71B4h case    2:*/		return 0x820C71B8;
		  /* 820C71B8h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820C71B8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C71B8h case    3:*/		return 0x820C71BC;
		  /* 820C71BCh */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 820C71BCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x820C71C4;  }
		/* 820C71BCh case    4:*/		return 0x820C71C0;
		  /* 820C71C0h */ case    5:  		/* mr R7, R11 */
		/* 820C71C0h case    5:*/		regs.R7 = regs.R11;
		/* 820C71C0h case    5:*/		return 0x820C71C4;
	}
	return 0x820C71C4;
} // Block from 820C71ACh-820C71C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C71C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C71C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C71C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C71C4);
		  /* 820C71C4h */ case    0:  		/* lwz R10, <#[R24 + 28]> */
		/* 820C71C4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 820C71C4h case    0:*/		return 0x820C71C8;
		  /* 820C71C8h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C71C8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C71C8h case    1:*/		return 0x820C71CC;
		  /* 820C71CCh */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C71CCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C71DC;  }
		/* 820C71CCh case    2:*/		return 0x820C71D0;
		  /* 820C71D0h */ case    3:  		/* lis R3, -32768 */
		/* 820C71D0h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C71D0h case    3:*/		return 0x820C71D4;
		  /* 820C71D4h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820C71D4h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C71D4h case    4:*/		return 0x820C71D8;
		  /* 820C71D8h */ case    5:  		/* b 32 */
		/* 820C71D8h case    5:*/		return 0x820C71F8;
		/* 820C71D8h case    5:*/		return 0x820C71DC;
	}
	return 0x820C71DC;
} // Block from 820C71C4h-820C71DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C71DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C71DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C71DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C71DC);
		  /* 820C71DCh */ case    0:  		/* lhz R11, <#[R24 + 10]> */
		/* 820C71DCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000A) );
		/* 820C71DCh case    0:*/		return 0x820C71E0;
		  /* 820C71E0h */ case    1:  		/* mr R3, R23 */
		/* 820C71E0h case    1:*/		regs.R3 = regs.R23;
		/* 820C71E0h case    1:*/		return 0x820C71E4;
		  /* 820C71E4h */ case    2:  		/* mtspr CTR, R10 */
		/* 820C71E4h case    2:*/		regs.CTR = regs.R10;
		/* 820C71E4h case    2:*/		return 0x820C71E8;
		  /* 820C71E8h */ case    3:  		/* add R4, R11, R22 */
		/* 820C71E8h case    3:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R22);
		/* 820C71E8h case    3:*/		return 0x820C71EC;
		  /* 820C71ECh */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820C71ECh case    4:*/		if ( 1 ) { regs.LR = 0x820C71F0; return (uint32)regs.CTR; }
		/* 820C71ECh case    4:*/		return 0x820C71F0;
		  /* 820C71F0h */ case    5:  		/* srawi R11, R3, 31 */
		/* 820C71F0h case    5:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820C71F0h case    5:*/		return 0x820C71F4;
		  /* 820C71F4h */ case    6:  		/* and R3, R11, R3 */
		/* 820C71F4h case    6:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C71F4h case    6:*/		return 0x820C71F8;
	}
	return 0x820C71F8;
} // Block from 820C71DCh-820C71F8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C71F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C71F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C71F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C71F8);
		  /* 820C71F8h */ case    0:  		/* addi R1, R1, 176 */
		/* 820C71F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820C71F8h case    0:*/		return 0x820C71FC;
		  /* 820C71FCh */ case    1:  		/* b -221036 */
		/* 820C71FCh case    1:*/		return 0x82091290;
		/* 820C71FCh case    1:*/		return 0x820C7200;
	}
	return 0x820C7200;
} // Block from 820C71F8h-820C7200h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C7200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7200);
		  /* 820C7200h */ case    0:  		/* mfspr R12, LR */
		/* 820C7200h case    0:*/		regs.R12 = regs.LR;
		/* 820C7200h case    0:*/		return 0x820C7204;
		  /* 820C7204h */ case    1:  		/* bl -221124 */
		/* 820C7204h case    1:*/		regs.LR = 0x820C7208; return 0x82091240;
		/* 820C7204h case    1:*/		return 0x820C7208;
		  /* 820C7208h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820C7208h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820C7208h case    2:*/		return 0x820C720C;
		  /* 820C720Ch */ case    3:  		/* lwz R25, <#[R3 + 24]> */
		/* 820C720Ch case    3:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R3 + 0x00000018) );
		/* 820C720Ch case    3:*/		return 0x820C7210;
		  /* 820C7210h */ case    4:  		/* mr R23, R4 */
		/* 820C7210h case    4:*/		regs.R23 = regs.R4;
		/* 820C7210h case    4:*/		return 0x820C7214;
		  /* 820C7214h */ case    5:  		/* mr R11, R6 */
		/* 820C7214h case    5:*/		regs.R11 = regs.R6;
		/* 820C7214h case    5:*/		return 0x820C7218;
		  /* 820C7218h */ case    6:  		/* lwz R6, <#[R3 + 32]> */
		/* 820C7218h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000020) );
		/* 820C7218h case    6:*/		return 0x820C721C;
		  /* 820C721Ch */ case    7:  		/* mr R24, R3 */
		/* 820C721Ch case    7:*/		regs.R24 = regs.R3;
		/* 820C721Ch case    7:*/		return 0x820C7220;
		  /* 820C7220h */ case    8:  		/* mr R4, R5 */
		/* 820C7220h case    8:*/		regs.R4 = regs.R5;
		/* 820C7220h case    8:*/		return 0x820C7224;
		  /* 820C7224h */ case    9:  		/* mr R22, R7 */
		/* 820C7224h case    9:*/		regs.R22 = regs.R7;
		/* 820C7224h case    9:*/		return 0x820C7228;
		  /* 820C7228h */ case   10:  		/* lhz R10, <#[R25]> */
		/* 820C7228h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 820C7228h case   10:*/		return 0x820C722C;
		  /* 820C722Ch */ case   11:  		/* cmplwi CR6, R10, 1 */
		/* 820C722Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C722Ch case   11:*/		return 0x820C7230;
		  /* 820C7230h */ case   12:  		/* bc 12, CR6_LT, 716 */
		/* 820C7230h case   12:*/		if ( regs.CR[6].lt ) { return 0x820C74FC;  }
		/* 820C7230h case   12:*/		return 0x820C7234;
		  /* 820C7234h */ case   13:  		/* bc 12, CR6_EQ, 576 */
		/* 820C7234h case   13:*/		if ( regs.CR[6].eq ) { return 0x820C7474;  }
		/* 820C7234h case   13:*/		return 0x820C7238;
		  /* 820C7238h */ case   14:  		/* cmplwi CR6, R10, 3 */
		/* 820C7238h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C7238h case   14:*/		return 0x820C723C;
		  /* 820C723Ch */ case   15:  		/* bc 12, CR6_LT, 412 */
		/* 820C723Ch case   15:*/		if ( regs.CR[6].lt ) { return 0x820C73D8;  }
		/* 820C723Ch case   15:*/		return 0x820C7240;
		  /* 820C7240h */ case   16:  		/* bc 12, CR6_EQ, 244 */
		/* 820C7240h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C7334;  }
		/* 820C7240h case   16:*/		return 0x820C7244;
		  /* 820C7244h */ case   17:  		/* cmplwi CR6, R10, 5 */
		/* 820C7244h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000005);
		/* 820C7244h case   17:*/		return 0x820C7248;
		  /* 820C7248h */ case   18:  		/* bc 12, CR6_EQ, 16 */
		/* 820C7248h case   18:*/		if ( regs.CR[6].eq ) { return 0x820C7258;  }
		/* 820C7248h case   18:*/		return 0x820C724C;
		  /* 820C724Ch */ case   19:  		/* lis R3, -32768 */
		/* 820C724Ch case   19:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C724Ch case   19:*/		return 0x820C7250;
		  /* 820C7250h */ case   20:  		/* ori R3, R3, 16385 */
		/* 820C7250h case   20:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4001);
		/* 820C7250h case   20:*/		return 0x820C7254;
		  /* 820C7254h */ case   21:  		/* b 1192 */
		/* 820C7254h case   21:*/		return 0x820C76FC;
		/* 820C7254h case   21:*/		return 0x820C7258;
	}
	return 0x820C7258;
} // Block from 820C7200h-820C7258h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C7258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7258);
		  /* 820C7258h */ case    0:  		/* lwz R10, <#[R24 + 52]> */
		/* 820C7258h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000034) );
		/* 820C7258h case    0:*/		return 0x820C725C;
		  /* 820C725Ch */ case    1:  		/* rlwinm R9, R11, 4, 0, 27 */
		/* 820C725Ch case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R9,regs.R11);
		/* 820C725Ch case    1:*/		return 0x820C7260;
		  /* 820C7260h */ case    2:  		/* lhz R11, <#[R25 + 8]> */
		/* 820C7260h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820C7260h case    2:*/		return 0x820C7264;
		  /* 820C7264h */ case    3:  		/* divwu R27, R9, R10 */
		/* 820C7264h case    3:*/		cpu::op::divwu<0>(regs,&regs.R27,regs.R9,regs.R10);
		/* 820C7264h case    3:*/		return 0x820C7268;
		  /* 820C7268h */ case    4:  		/* twi 6, R10, 0 */
		/* 820C7268h case    4:*/		cpu::op::tw<6>(regs, 0x820C7268, regs.R10, 0x00000000);
		/* 820C7268h case    4:*/		return 0x820C726C;
		  /* 820C726Ch */ case    5:  		/* cmplw CR6, R27, R11 */
		/* 820C726Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 820C726Ch case    5:*/		return 0x820C7270;
		  /* 820C7270h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 820C7270h case    6:*/		if ( !regs.CR[6].gt ) { return 0x820C7278;  }
		/* 820C7270h case    6:*/		return 0x820C7274;
		  /* 820C7274h */ case    7:  		/* mr R27, R11 */
		/* 820C7274h case    7:*/		regs.R27 = regs.R11;
		/* 820C7274h case    7:*/		return 0x820C7278;
	}
	return 0x820C7278;
} // Block from 820C7258h-820C7278h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C7278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7278);
		  /* 820C7278h */ case    0:  		/* mullw. R10, R10, R27 */
		/* 820C7278h case    0:*/		cpu::op::mullw<1>(regs,&regs.R10,regs.R10,regs.R27);
		/* 820C7278h case    0:*/		return 0x820C727C;
		  /* 820C727Ch */ case    1:  		/* li R11, 0 */
		/* 820C727Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C727Ch case    1:*/		return 0x820C7280;
		  /* 820C7280h */ case    2:  		/* bc 12, CR0_EQ, 52 */
		/* 820C7280h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C72B4;  }
		/* 820C7280h case    2:*/		return 0x820C7284;
		  /* 820C7284h */ case    3:  		/* mtspr CTR, R10 */
		/* 820C7284h case    3:*/		regs.CTR = regs.R10;
		/* 820C7284h case    3:*/		return 0x820C7288;
		  /* 820C7288h */ case    4:  		/* addi R10, R6, -4 */
		/* 820C7288h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C7288h case    4:*/		return 0x820C728C;
		  /* 820C728Ch */ case    5:  		/* rlwinm R8, R11, 2, 28, 29 */
		/* 820C728Ch case    5:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R8,regs.R11);
		/* 820C728Ch case    5:*/		return 0x820C7290;
		  /* 820C7290h */ case    6:  		/* rlwinm R9, R11, 30, 30, 31 */
		/* 820C7290h case    6:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R9,regs.R11);
		/* 820C7290h case    6:*/		return 0x820C7294;
		  /* 820C7294h */ case    7:  		/* rlwinm R7, R11, 30, 2, 29 */
		/* 820C7294h case    7:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R7,regs.R11);
		/* 820C7294h case    7:*/		return 0x820C7298;
		  /* 820C7298h */ case    8:  		/* add R9, R8, R9 */
		/* 820C7298h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C7298h case    8:*/		return 0x820C729C;
		  /* 820C729Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 820C729Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C729Ch case    9:*/		return 0x820C72A0;
		  /* 820C72A0h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C72A0h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C72A0h case   10:*/		return 0x820C72A4;
		  /* 820C72A4h */ case   11:  		/* lwzx R8, <#[R7 + R4]> */
		/* 820C72A4h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R4 + 0x00000000) );
		/* 820C72A4h case   11:*/		return 0x820C72A8;
		  /* 820C72A8h */ case   12:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820C72A8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820C72A8h case   12:*/		return 0x820C72AC;
		  /* 820C72ACh */ case   13:  		/* stwu R9, <#[R10 + 4]> */
		/* 820C72ACh case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C72ACh case   13:*/		return 0x820C72B0;
		  /* 820C72B0h */ case   14:  		/* bc 16, CR0_LT, -36 */
		/* 820C72B0h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C728C;  }
		/* 820C72B0h case   14:*/		return 0x820C72B4;
	}
	return 0x820C72B4;
} // Block from 820C7278h-820C72B4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C72B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C72B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C72B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C72B4);
		  /* 820C72B4h */ case    0:  		/* mr R29, R6 */
		/* 820C72B4h case    0:*/		regs.R29 = regs.R6;
		/* 820C72B4h case    0:*/		return 0x820C72B8;
		  /* 820C72B8h */ case    1:  		/* li R26, 0 */
		/* 820C72B8h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820C72B8h case    1:*/		return 0x820C72BC;
		  /* 820C72BCh */ case    2:  		/* cmplwi CR6, R27, 0 */
		/* 820C72BCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820C72BCh case    2:*/		return 0x820C72C0;
		  /* 820C72C0h */ case    3:  		/* bc 12, CR6_EQ, 108 */
		/* 820C72C0h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C732C;  }
		/* 820C72C0h case    3:*/		return 0x820C72C4;
		  /* 820C72C4h */ case    4:  		/* lhz R11, <#[R25 + 10]> */
		/* 820C72C4h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000A) );
		/* 820C72C4h case    4:*/		return 0x820C72C8;
		  /* 820C72C8h */ case    5:  		/* li R28, 0 */
		/* 820C72C8h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820C72C8h case    5:*/		return 0x820C72CC;
		  /* 820C72CCh */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 820C72CCh case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C72CCh case    6:*/		return 0x820C72D0;
		  /* 820C72D0h */ case    7:  		/* bc 12, CR0_EQ, 80 */
		/* 820C72D0h case    7:*/		if ( regs.CR[0].eq ) { return 0x820C7320;  }
		/* 820C72D0h case    7:*/		return 0x820C72D4;
		  /* 820C72D4h */ case    8:  		/* li R30, 0 */
		/* 820C72D4h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C72D4h case    8:*/		return 0x820C72D8;
		  /* 820C72D8h */ case    9:  		/* lwz R11, <#[R24 + 56]> */
		/* 820C72D8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000038) );
		/* 820C72D8h case    9:*/		return 0x820C72DC;
		  /* 820C72DCh */ case   10:  		/* mr R7, R22 */
		/* 820C72DCh case   10:*/		regs.R7 = regs.R22;
		/* 820C72DCh case   10:*/		return 0x820C72E0;
		  /* 820C72E0h */ case   11:  		/* mr R5, R29 */
		/* 820C72E0h case   11:*/		regs.R5 = regs.R29;
		/* 820C72E0h case   11:*/		return 0x820C72E4;
		  /* 820C72E4h */ case   12:  		/* mr R4, R23 */
		/* 820C72E4h case   12:*/		regs.R4 = regs.R23;
		/* 820C72E4h case   12:*/		return 0x820C72E8;
		  /* 820C72E8h */ case   13:  		/* lwzx R31, <#[R11 + R30]> */
		/* 820C72E8h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820C72E8h case   13:*/		return 0x820C72EC;
		  /* 820C72ECh */ case   14:  		/* mr R3, R31 */
		/* 820C72ECh case   14:*/		regs.R3 = regs.R31;
		/* 820C72ECh case   14:*/		return 0x820C72F0;
		  /* 820C72F0h */ case   15:  		/* lwz R6, <#[R31 + 48]> */
		/* 820C72F0h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000030) );
		/* 820C72F0h case   15:*/		return 0x820C72F4;
		  /* 820C72F4h */ case   16:  		/* bl -6548 */
		/* 820C72F4h case   16:*/		regs.LR = 0x820C72F8; return 0x820C5960;
		/* 820C72F4h case   16:*/		return 0x820C72F8;
		  /* 820C72F8h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820C72F8h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C72F8h case   17:*/		return 0x820C72FC;
		  /* 820C72FCh */ case   18:  		/* bc 12, CR0_LT, 1024 */
		/* 820C72FCh case   18:*/		if ( regs.CR[0].lt ) { return 0x820C76FC;  }
		/* 820C72FCh case   18:*/		return 0x820C7300;
		  /* 820C7300h */ case   19:  		/* lwz R11, <#[R31 + 48]> */
		/* 820C7300h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820C7300h case   19:*/		return 0x820C7304;
		  /* 820C7304h */ case   20:  		/* addi R28, R28, 1 */
		/* 820C7304h case   20:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820C7304h case   20:*/		return 0x820C7308;
		  /* 820C7308h */ case   21:  		/* lhz R10, <#[R25 + 10]> */
		/* 820C7308h case   21:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x0000000A) );
		/* 820C7308h case   21:*/		return 0x820C730C;
		  /* 820C730Ch */ case   22:  		/* addi R30, R30, 4 */
		/* 820C730Ch case   22:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C730Ch case   22:*/		return 0x820C7310;
		  /* 820C7310h */ case   23:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C7310h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C7310h case   23:*/		return 0x820C7314;
		  /* 820C7314h */ case   24:  		/* cmplw CR6, R28, R10 */
		/* 820C7314h case   24:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 820C7314h case   24:*/		return 0x820C7318;
		  /* 820C7318h */ case   25:  		/* add R29, R11, R29 */
		/* 820C7318h case   25:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 820C7318h case   25:*/		return 0x820C731C;
		  /* 820C731Ch */ case   26:  		/* bc 12, CR6_LT, -68 */
		/* 820C731Ch case   26:*/		if ( regs.CR[6].lt ) { return 0x820C72D8;  }
		/* 820C731Ch case   26:*/		return 0x820C7320;
	}
	return 0x820C7320;
} // Block from 820C72B4h-820C7320h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820C7320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7320);
		  /* 820C7320h */ case    0:  		/* addi R26, R26, 1 */
		/* 820C7320h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 820C7320h case    0:*/		return 0x820C7324;
		  /* 820C7324h */ case    1:  		/* cmplw CR6, R26, R27 */
		/* 820C7324h case    1:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R27);
		/* 820C7324h case    1:*/		return 0x820C7328;
		  /* 820C7328h */ case    2:  		/* bc 12, CR6_LT, -100 */
		/* 820C7328h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C72C4;  }
		/* 820C7328h case    2:*/		return 0x820C732C;
	}
	return 0x820C732C;
} // Block from 820C7320h-820C732Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C732Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C732C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C732C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C732C);
		  /* 820C732Ch */ case    0:  		/* li R3, 0 */
		/* 820C732Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C732Ch case    0:*/		return 0x820C7330;
		  /* 820C7330h */ case    1:  		/* b 972 */
		/* 820C7330h case    1:*/		return 0x820C76FC;
		/* 820C7330h case    1:*/		return 0x820C7334;
	}
	return 0x820C7334;
} // Block from 820C732Ch-820C7334h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C7334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7334);
		  /* 820C7334h */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C7334h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C7334h case    0:*/		return 0x820C7338;
		  /* 820C7338h */ case    1:  		/* mr R31, R11 */
		/* 820C7338h case    1:*/		regs.R31 = regs.R11;
		/* 820C7338h case    1:*/		return 0x820C733C;
		  /* 820C733Ch */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C733Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C733Ch case    2:*/		return 0x820C7340;
		  /* 820C7340h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C7340h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C7348;  }
		/* 820C7340h case    3:*/		return 0x820C7344;
		  /* 820C7344h */ case    4:  		/* mr R31, R10 */
		/* 820C7344h case    4:*/		regs.R31 = regs.R10;
		/* 820C7344h case    4:*/		return 0x820C7348;
	}
	return 0x820C7348;
} // Block from 820C7334h-820C7348h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C7348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7348);
		  /* 820C7348h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820C7348h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7348h case    0:*/		return 0x820C734C;
		  /* 820C734Ch */ case    1:  		/* bc 12, CR6_EQ, 512 */
		/* 820C734Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820C754C;  }
		/* 820C734Ch case    1:*/		return 0x820C7350;
		  /* 820C7350h */ case    2:  		/* mtspr CTR, R31 */
		/* 820C7350h case    2:*/		regs.CTR = regs.R31;
		/* 820C7350h case    2:*/		return 0x820C7354;
		  /* 820C7354h */ case    3:  		/* addi R8, R6, -4 */
		/* 820C7354h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R6,0xFFFFFFFC);
		/* 820C7354h case    3:*/		return 0x820C7358;
		  /* 820C7358h */ case    4:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C7358h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C7358h case    4:*/		return 0x820C735C;
		  /* 820C735Ch */ case    5:  		/* li R7, 0 */
		/* 820C735Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C735Ch case    5:*/		return 0x820C7360;
		  /* 820C7360h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 820C7360h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C7360h case    6:*/		return 0x820C7364;
		  /* 820C7364h */ case    7:  		/* bc 12, CR0_EQ, 104 */
		/* 820C7364h case    7:*/		if ( regs.CR[0].eq ) { return 0x820C73CC;  }
		/* 820C7364h case    7:*/		return 0x820C7368;
		  /* 820C7368h */ case    8:  		/* lhz R10, <#[R25 + 4]> */
		/* 820C7368h case    8:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820C7368h case    8:*/		return 0x820C736C;
		  /* 820C736Ch */ case    9:  		/* li R9, 0 */
		/* 820C736Ch case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C736Ch case    9:*/		return 0x820C7370;
		  /* 820C7370h */ case   10:  		/* li R11, 0 */
		/* 820C7370h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C7370h case   10:*/		return 0x820C7374;
		  /* 820C7374h */ case   11:  		/* cmplwi CR6, R10, 0 */
		/* 820C7374h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C7374h case   11:*/		return 0x820C7378;
		  /* 820C7378h */ case   12:  		/* bc 12, CR6_EQ, 64 */
		/* 820C7378h case   12:*/		if ( regs.CR[6].eq ) { return 0x820C73B8;  }
		/* 820C7378h case   12:*/		return 0x820C737C;
		  /* 820C737Ch */ case   13:  		/* cmplwi CR6, R11, 4 */
		/* 820C737Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 820C737Ch case   13:*/		return 0x820C7380;
		  /* 820C7380h */ case   14:  		/* bc 12, CR6_GT, 32 */
		/* 820C7380h case   14:*/		if ( regs.CR[6].gt ) { return 0x820C73A0;  }
		/* 820C7380h case   14:*/		return 0x820C7384;
		  /* 820C7384h */ case   15:  		/* cmplwi CR6, R9, 16 */
		/* 820C7384h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000010);
		/* 820C7384h case   15:*/		return 0x820C7388;
		  /* 820C7388h */ case   16:  		/* bc 12, CR6_GT, 24 */
		/* 820C7388h case   16:*/		if ( regs.CR[6].gt ) { return 0x820C73A0;  }
		/* 820C7388h case   16:*/		return 0x820C738C;
		  /* 820C738Ch */ case   17:  		/* add R10, R11, R9 */
		/* 820C738Ch case   17:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 820C738Ch case   17:*/		return 0x820C7390;
		  /* 820C7390h */ case   18:  		/* lwz R5, <#[R4]> */
		/* 820C7390h case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x00000000) );
		/* 820C7390h case   18:*/		return 0x820C7394;
		  /* 820C7394h */ case   19:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C7394h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C7394h case   19:*/		return 0x820C7398;
		  /* 820C7398h */ case   20:  		/* lwzx R10, <#[R10 + R5]> */
		/* 820C7398h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 820C7398h case   20:*/		return 0x820C739C;
		  /* 820C739Ch */ case   21:  		/* b 8 */
		/* 820C739Ch case   21:*/		return 0x820C73A4;
		/* 820C739Ch case   21:*/		return 0x820C73A0;
	}
	return 0x820C73A0;
} // Block from 820C7348h-820C73A0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820C73A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C73A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C73A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C73A0);
		  /* 820C73A0h */ case    0:  		/* li R10, 0 */
		/* 820C73A0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C73A0h case    0:*/		return 0x820C73A4;
	}
	return 0x820C73A4;
} // Block from 820C73A0h-820C73A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C73A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C73A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C73A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C73A4);
		  /* 820C73A4h */ case    0:  		/* addi R11, R11, 1 */
		/* 820C73A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C73A4h case    0:*/		return 0x820C73A8;
		  /* 820C73A8h */ case    1:  		/* stwu R10, <#[R8 + 4]> */
		/* 820C73A8h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 820C73A8h case    1:*/		return 0x820C73AC;
		  /* 820C73ACh */ case    2:  		/* lhz R10, <#[R25 + 4]> */
		/* 820C73ACh case    2:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820C73ACh case    2:*/		return 0x820C73B0;
		  /* 820C73B0h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C73B0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C73B0h case    3:*/		return 0x820C73B4;
		  /* 820C73B4h */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 820C73B4h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C737C;  }
		/* 820C73B4h case    4:*/		return 0x820C73B8;
	}
	return 0x820C73B8;
} // Block from 820C73A4h-820C73B8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C73B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C73B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C73B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C73B8);
		  /* 820C73B8h */ case    0:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C73B8h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C73B8h case    0:*/		return 0x820C73BC;
		  /* 820C73BCh */ case    1:  		/* addi R7, R7, 1 */
		/* 820C73BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820C73BCh case    1:*/		return 0x820C73C0;
		  /* 820C73C0h */ case    2:  		/* addi R9, R9, 4 */
		/* 820C73C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 820C73C0h case    2:*/		return 0x820C73C4;
		  /* 820C73C4h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820C73C4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C73C4h case    3:*/		return 0x820C73C8;
		  /* 820C73C8h */ case    4:  		/* bc 12, CR6_LT, -88 */
		/* 820C73C8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C7370;  }
		/* 820C73C8h case    4:*/		return 0x820C73CC;
	}
	return 0x820C73CC;
} // Block from 820C73B8h-820C73CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C73CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C73CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C73CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C73CC);
		  /* 820C73CCh */ case    0:  		/* addi R4, R4, 4 */
		/* 820C73CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 820C73CCh case    0:*/		return 0x820C73D0;
		  /* 820C73D0h */ case    1:  		/* bc 16, CR0_LT, -120 */
		/* 820C73D0h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C7358;  }
		/* 820C73D0h case    1:*/		return 0x820C73D4;
		  /* 820C73D4h */ case    2:  		/* b 376 */
		/* 820C73D4h case    2:*/		return 0x820C754C;
		/* 820C73D4h case    2:*/		return 0x820C73D8;
	}
	return 0x820C73D8;
} // Block from 820C73CCh-820C73D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C73D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C73D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C73D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C73D8);
		  /* 820C73D8h */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C73D8h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C73D8h case    0:*/		return 0x820C73DC;
		  /* 820C73DCh */ case    1:  		/* mr R31, R11 */
		/* 820C73DCh case    1:*/		regs.R31 = regs.R11;
		/* 820C73DCh case    1:*/		return 0x820C73E0;
		  /* 820C73E0h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C73E0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C73E0h case    2:*/		return 0x820C73E4;
		  /* 820C73E4h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C73E4h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C73EC;  }
		/* 820C73E4h case    3:*/		return 0x820C73E8;
		  /* 820C73E8h */ case    4:  		/* mr R31, R10 */
		/* 820C73E8h case    4:*/		regs.R31 = regs.R10;
		/* 820C73E8h case    4:*/		return 0x820C73EC;
	}
	return 0x820C73EC;
} // Block from 820C73D8h-820C73ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C73ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C73EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C73EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C73EC);
		  /* 820C73ECh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820C73ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C73ECh case    0:*/		return 0x820C73F0;
		  /* 820C73F0h */ case    1:  		/* bc 12, CR6_EQ, 348 */
		/* 820C73F0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C754C;  }
		/* 820C73F0h case    1:*/		return 0x820C73F4;
		  /* 820C73F4h */ case    2:  		/* mtspr CTR, R31 */
		/* 820C73F4h case    2:*/		regs.CTR = regs.R31;
		/* 820C73F4h case    2:*/		return 0x820C73F8;
		  /* 820C73F8h */ case    3:  		/* addi R8, R6, -4 */
		/* 820C73F8h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R6,0xFFFFFFFC);
		/* 820C73F8h case    3:*/		return 0x820C73FC;
		  /* 820C73FCh */ case    4:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C73FCh case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C73FCh case    4:*/		return 0x820C7400;
		  /* 820C7400h */ case    5:  		/* li R7, 0 */
		/* 820C7400h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7400h case    5:*/		return 0x820C7404;
		  /* 820C7404h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 820C7404h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C7404h case    6:*/		return 0x820C7408;
		  /* 820C7408h */ case    7:  		/* bc 12, CR0_EQ, 96 */
		/* 820C7408h case    7:*/		if ( regs.CR[0].eq ) { return 0x820C7468;  }
		/* 820C7408h case    7:*/		return 0x820C740C;
		  /* 820C740Ch */ case    8:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C740Ch case    8:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C740Ch case    8:*/		return 0x820C7410;
		  /* 820C7410h */ case    9:  		/* li R10, 0 */
		/* 820C7410h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C7410h case    9:*/		return 0x820C7414;
		  /* 820C7414h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 820C7414h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C7414h case   10:*/		return 0x820C7418;
		  /* 820C7418h */ case   11:  		/* bc 12, CR6_EQ, 64 */
		/* 820C7418h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C7458;  }
		/* 820C7418h case   11:*/		return 0x820C741C;
		  /* 820C741Ch */ case   12:  		/* rlwinm R9, R7, 2, 0, 29 */
		/* 820C741Ch case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 820C741Ch case   12:*/		return 0x820C7420;
		  /* 820C7420h */ case   13:  		/* cmplwi CR6, R7, 4 */
		/* 820C7420h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000004);
		/* 820C7420h case   13:*/		return 0x820C7424;
		  /* 820C7424h */ case   14:  		/* bc 12, CR6_GT, 24 */
		/* 820C7424h case   14:*/		if ( regs.CR[6].gt ) { return 0x820C743C;  }
		/* 820C7424h case   14:*/		return 0x820C7428;
		  /* 820C7428h */ case   15:  		/* cmplwi CR6, R10, 4 */
		/* 820C7428h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 820C7428h case   15:*/		return 0x820C742C;
		  /* 820C742Ch */ case   16:  		/* bc 12, CR6_GT, 16 */
		/* 820C742Ch case   16:*/		if ( regs.CR[6].gt ) { return 0x820C743C;  }
		/* 820C742Ch case   16:*/		return 0x820C7430;
		  /* 820C7430h */ case   17:  		/* lwz R11, <#[R4]> */
		/* 820C7430h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820C7430h case   17:*/		return 0x820C7434;
		  /* 820C7434h */ case   18:  		/* lwzx R11, <#[R11 + R9]> */
		/* 820C7434h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 820C7434h case   18:*/		return 0x820C7438;
		  /* 820C7438h */ case   19:  		/* b 8 */
		/* 820C7438h case   19:*/		return 0x820C7440;
		/* 820C7438h case   19:*/		return 0x820C743C;
	}
	return 0x820C743C;
} // Block from 820C73ECh-820C743Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C743Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C743C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C743C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C743C);
		  /* 820C743Ch */ case    0:  		/* li R11, 0 */
		/* 820C743Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C743Ch case    0:*/		return 0x820C7440;
	}
	return 0x820C7440;
} // Block from 820C743Ch-820C7440h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7440);
		  /* 820C7440h */ case    0:  		/* addi R10, R10, 1 */
		/* 820C7440h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C7440h case    0:*/		return 0x820C7444;
		  /* 820C7444h */ case    1:  		/* stwu R11, <#[R8 + 4]> */
		/* 820C7444h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000004) );
		regs.R8 = (uint32)(regs.R8 + 0x00000004);
		/* 820C7444h case    1:*/		return 0x820C7448;
		  /* 820C7448h */ case    2:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C7448h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C7448h case    2:*/		return 0x820C744C;
		  /* 820C744Ch */ case    3:  		/* addi R9, R9, 16 */
		/* 820C744Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x10);
		/* 820C744Ch case    3:*/		return 0x820C7450;
		  /* 820C7450h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 820C7450h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820C7450h case    4:*/		return 0x820C7454;
		  /* 820C7454h */ case    5:  		/* bc 12, CR6_LT, -52 */
		/* 820C7454h case    5:*/		if ( regs.CR[6].lt ) { return 0x820C7420;  }
		/* 820C7454h case    5:*/		return 0x820C7458;
	}
	return 0x820C7458;
} // Block from 820C7440h-820C7458h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C7458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7458);
		  /* 820C7458h */ case    0:  		/* lhz R10, <#[R25 + 4]> */
		/* 820C7458h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820C7458h case    0:*/		return 0x820C745C;
		  /* 820C745Ch */ case    1:  		/* addi R7, R7, 1 */
		/* 820C745Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820C745Ch case    1:*/		return 0x820C7460;
		  /* 820C7460h */ case    2:  		/* cmplw CR6, R7, R10 */
		/* 820C7460h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R10);
		/* 820C7460h case    2:*/		return 0x820C7464;
		  /* 820C7464h */ case    3:  		/* bc 12, CR6_LT, -84 */
		/* 820C7464h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C7410;  }
		/* 820C7464h case    3:*/		return 0x820C7468;
	}
	return 0x820C7468;
} // Block from 820C7458h-820C7468h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C7468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7468);
		  /* 820C7468h */ case    0:  		/* addi R4, R4, 4 */
		/* 820C7468h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 820C7468h case    0:*/		return 0x820C746C;
		  /* 820C746Ch */ case    1:  		/* bc 16, CR0_LT, -112 */
		/* 820C746Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C73FC;  }
		/* 820C746Ch case    1:*/		return 0x820C7470;
		  /* 820C7470h */ case    2:  		/* b 220 */
		/* 820C7470h case    2:*/		return 0x820C754C;
		/* 820C7470h case    2:*/		return 0x820C7474;
	}
	return 0x820C7474;
} // Block from 820C7468h-820C7474h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7474);
		  /* 820C7474h */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C7474h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C7474h case    0:*/		return 0x820C7478;
		  /* 820C7478h */ case    1:  		/* rlwinm R31, R11, 2, 0, 29 */
		/* 820C7478h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R11);
		/* 820C7478h case    1:*/		return 0x820C747C;
		  /* 820C747Ch */ case    2:  		/* cmplw CR6, R31, R10 */
		/* 820C747Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 820C747Ch case    2:*/		return 0x820C7480;
		  /* 820C7480h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C7480h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C7488;  }
		/* 820C7480h case    3:*/		return 0x820C7484;
		  /* 820C7484h */ case    4:  		/* mr R31, R10 */
		/* 820C7484h case    4:*/		regs.R31 = regs.R10;
		/* 820C7484h case    4:*/		return 0x820C7488;
	}
	return 0x820C7488;
} // Block from 820C7474h-820C7488h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C7488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7488);
		  /* 820C7488h */ case    0:  		/* li R8, 0 */
		/* 820C7488h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C7488h case    0:*/		return 0x820C748C;
		  /* 820C748Ch */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820C748Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C748Ch case    1:*/		return 0x820C7490;
		  /* 820C7490h */ case    2:  		/* bc 12, CR6_EQ, 188 */
		/* 820C7490h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C754C;  }
		/* 820C7490h case    2:*/		return 0x820C7494;
		  /* 820C7494h */ case    3:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C7494h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C7494h case    3:*/		return 0x820C7498;
		  /* 820C7498h */ case    4:  		/* addi R7, R6, -4 */
		/* 820C7498h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R6,0xFFFFFFFC);
		/* 820C7498h case    4:*/		return 0x820C749C;
		  /* 820C749Ch */ case    5:  		/* li R9, 0 */
		/* 820C749Ch case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C749Ch case    5:*/		return 0x820C74A0;
		  /* 820C74A0h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820C74A0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C74A0h case    6:*/		return 0x820C74A4;
		  /* 820C74A4h */ case    7:  		/* bc 12, CR6_EQ, 72 */
		/* 820C74A4h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C74EC;  }
		/* 820C74A4h case    7:*/		return 0x820C74A8;
		  /* 820C74A8h */ case    8:  		/* li R10, 0 */
		/* 820C74A8h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C74A8h case    8:*/		return 0x820C74AC;
		  /* 820C74ACh */ case    9:  		/* cmplwi CR6, R9, 4 */
		/* 820C74ACh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000004);
		/* 820C74ACh case    9:*/		return 0x820C74B0;
		  /* 820C74B0h */ case   10:  		/* bc 4, CR6_GT, 12 */
		/* 820C74B0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x820C74BC;  }
		/* 820C74B0h case   10:*/		return 0x820C74B4;
		  /* 820C74B4h */ case   11:  		/* li R11, 0 */
		/* 820C74B4h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C74B4h case   11:*/		return 0x820C74B8;
		  /* 820C74B8h */ case   12:  		/* b 28 */
		/* 820C74B8h case   12:*/		return 0x820C74D4;
		/* 820C74B8h case   12:*/		return 0x820C74BC;
	}
	return 0x820C74BC;
} // Block from 820C7488h-820C74BCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C74BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C74BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C74BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C74BC);
		  /* 820C74BCh */ case    0:  		/* rlwinm R11, R8, 0, 30, 31 */
		/* 820C74BCh case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R8);
		/* 820C74BCh case    0:*/		return 0x820C74C0;
		  /* 820C74C0h */ case    1:  		/* rlwinm R5, R8, 0, 0, 29 */
		/* 820C74C0h case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R5,regs.R8);
		/* 820C74C0h case    1:*/		return 0x820C74C4;
		  /* 820C74C4h */ case    2:  		/* add R11, R11, R10 */
		/* 820C74C4h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C74C4h case    2:*/		return 0x820C74C8;
		  /* 820C74C8h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C74C8h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C74C8h case    3:*/		return 0x820C74CC;
		  /* 820C74CCh */ case    4:  		/* lwzx R5, <#[R5 + R4]> */
		/* 820C74CCh case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R4 + 0x00000000) );
		/* 820C74CCh case    4:*/		return 0x820C74D0;
		  /* 820C74D0h */ case    5:  		/* lwzx R11, <#[R5 + R11]> */
		/* 820C74D0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 820C74D0h case    5:*/		return 0x820C74D4;
	}
	return 0x820C74D4;
} // Block from 820C74BCh-820C74D4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C74D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C74D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C74D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C74D4);
		  /* 820C74D4h */ case    0:  		/* stwu R11, <#[R7 + 4]> */
		/* 820C74D4h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820C74D4h case    0:*/		return 0x820C74D8;
		  /* 820C74D8h */ case    1:  		/* addi R9, R9, 1 */
		/* 820C74D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C74D8h case    1:*/		return 0x820C74DC;
		  /* 820C74DCh */ case    2:  		/* addi R10, R10, 4 */
		/* 820C74DCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C74DCh case    2:*/		return 0x820C74E0;
		  /* 820C74E0h */ case    3:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C74E0h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C74E0h case    3:*/		return 0x820C74E4;
		  /* 820C74E4h */ case    4:  		/* cmplw CR6, R9, R11 */
		/* 820C74E4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 820C74E4h case    4:*/		return 0x820C74E8;
		  /* 820C74E8h */ case    5:  		/* bc 12, CR6_LT, -60 */
		/* 820C74E8h case    5:*/		if ( regs.CR[6].lt ) { return 0x820C74AC;  }
		/* 820C74E8h case    5:*/		return 0x820C74EC;
	}
	return 0x820C74EC;
} // Block from 820C74D4h-820C74ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C74ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C74EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C74EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C74EC);
		  /* 820C74ECh */ case    0:  		/* addi R8, R8, 1 */
		/* 820C74ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820C74ECh case    0:*/		return 0x820C74F0;
		  /* 820C74F0h */ case    1:  		/* cmplw CR6, R8, R31 */
		/* 820C74F0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R31);
		/* 820C74F0h case    1:*/		return 0x820C74F4;
		  /* 820C74F4h */ case    2:  		/* bc 12, CR6_LT, -88 */
		/* 820C74F4h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C749C;  }
		/* 820C74F4h case    2:*/		return 0x820C74F8;
		  /* 820C74F8h */ case    3:  		/* b 84 */
		/* 820C74F8h case    3:*/		return 0x820C754C;
		/* 820C74F8h case    3:*/		return 0x820C74FC;
	}
	return 0x820C74FC;
} // Block from 820C74ECh-820C74FCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C74FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C74FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C74FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C74FC);
		  /* 820C74FCh */ case    0:  		/* lhz R10, <#[R25 + 8]> */
		/* 820C74FCh case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820C74FCh case    0:*/		return 0x820C7500;
		  /* 820C7500h */ case    1:  		/* rlwinm R31, R11, 4, 0, 27 */
		/* 820C7500h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R31,regs.R11);
		/* 820C7500h case    1:*/		return 0x820C7504;
		  /* 820C7504h */ case    2:  		/* cmplw CR6, R31, R10 */
		/* 820C7504h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 820C7504h case    2:*/		return 0x820C7508;
		  /* 820C7508h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 820C7508h case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C7510;  }
		/* 820C7508h case    3:*/		return 0x820C750C;
		  /* 820C750Ch */ case    4:  		/* mr R31, R10 */
		/* 820C750Ch case    4:*/		regs.R31 = regs.R10;
		/* 820C750Ch case    4:*/		return 0x820C7510;
	}
	return 0x820C7510;
} // Block from 820C74FCh-820C7510h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C7510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7510);
		  /* 820C7510h */ case    0:  		/* li R11, 0 */
		/* 820C7510h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C7510h case    0:*/		return 0x820C7514;
		  /* 820C7514h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 820C7514h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7514h case    1:*/		return 0x820C7518;
		  /* 820C7518h */ case    2:  		/* bc 12, CR6_EQ, 52 */
		/* 820C7518h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C754C;  }
		/* 820C7518h case    2:*/		return 0x820C751C;
		  /* 820C751Ch */ case    3:  		/* mtspr CTR, R31 */
		/* 820C751Ch case    3:*/		regs.CTR = regs.R31;
		/* 820C751Ch case    3:*/		return 0x820C7520;
		  /* 820C7520h */ case    4:  		/* addi R10, R6, -4 */
		/* 820C7520h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C7520h case    4:*/		return 0x820C7524;
		  /* 820C7524h */ case    5:  		/* rlwinm R8, R11, 2, 28, 29 */
		/* 820C7524h case    5:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R8,regs.R11);
		/* 820C7524h case    5:*/		return 0x820C7528;
		  /* 820C7528h */ case    6:  		/* rlwinm R9, R11, 30, 30, 31 */
		/* 820C7528h case    6:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R9,regs.R11);
		/* 820C7528h case    6:*/		return 0x820C752C;
		  /* 820C752Ch */ case    7:  		/* rlwinm R7, R11, 30, 2, 29 */
		/* 820C752Ch case    7:*/		cpu::op::rlwinm<0,30,2,29>(regs,&regs.R7,regs.R11);
		/* 820C752Ch case    7:*/		return 0x820C7530;
		  /* 820C7530h */ case    8:  		/* add R9, R8, R9 */
		/* 820C7530h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C7530h case    8:*/		return 0x820C7534;
		  /* 820C7534h */ case    9:  		/* addi R11, R11, 1 */
		/* 820C7534h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C7534h case    9:*/		return 0x820C7538;
		  /* 820C7538h */ case   10:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C7538h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C7538h case   10:*/		return 0x820C753C;
		  /* 820C753Ch */ case   11:  		/* lwzx R8, <#[R7 + R4]> */
		/* 820C753Ch case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + regs.R4 + 0x00000000) );
		/* 820C753Ch case   11:*/		return 0x820C7540;
		  /* 820C7540h */ case   12:  		/* lwzx R9, <#[R9 + R8]> */
		/* 820C7540h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 820C7540h case   12:*/		return 0x820C7544;
		  /* 820C7544h */ case   13:  		/* stwu R9, <#[R10 + 4]> */
		/* 820C7544h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C7544h case   13:*/		return 0x820C7548;
		  /* 820C7548h */ case   14:  		/* bc 16, CR0_LT, -36 */
		/* 820C7548h case   14:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C7524;  }
		/* 820C7548h case   14:*/		return 0x820C754C;
	}
	return 0x820C754C;
} // Block from 820C7510h-820C754Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C754Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C754C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C754C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C754C);
		  /* 820C754Ch */ case    0:  		/* lhz R10, <#[R25 + 2]> */
		/* 820C754Ch case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000002) );
		/* 820C754Ch case    0:*/		return 0x820C7550;
		  /* 820C7550h */ case    1:  		/* cmplwi CR6, R10, 3 */
		/* 820C7550h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 820C7550h case    1:*/		return 0x820C7554;
		  /* 820C7554h */ case    2:  		/* bc 12, CR6_EQ, 124 */
		/* 820C7554h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C75D0;  }
		/* 820C7554h case    2:*/		return 0x820C7558;
		  /* 820C7558h */ case    3:  		/* lwz R11, <#[R24 + 52]> */
		/* 820C7558h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000034) );
		/* 820C7558h case    3:*/		return 0x820C755C;
		  /* 820C755Ch */ case    4:  		/* cmplwi CR6, R10, 1 */
		/* 820C755Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820C755Ch case    4:*/		return 0x820C7560;
		  /* 820C7560h */ case    5:  		/* mullw R11, R11, R31 */
		/* 820C7560h case    5:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820C7560h case    5:*/		return 0x820C7564;
		  /* 820C7564h */ case    6:  		/* bc 12, CR6_EQ, 56 */
		/* 820C7564h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C759C;  }
		/* 820C7564h case    6:*/		return 0x820C7568;
		  /* 820C7568h */ case    7:  		/* cmplwi CR6, R10, 2 */
		/* 820C7568h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820C7568h case    7:*/		return 0x820C756C;
		  /* 820C756Ch */ case    8:  		/* bc 4, CR6_EQ, 100 */
		/* 820C756Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C75D0;  }
		/* 820C756Ch case    8:*/		return 0x820C7570;
		  /* 820C7570h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820C7570h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C7570h case    9:*/		return 0x820C7574;
		  /* 820C7574h */ case   10:  		/* bc 12, CR6_EQ, 92 */
		/* 820C7574h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C75D0;  }
		/* 820C7574h case   10:*/		return 0x820C7578;
		  /* 820C7578h */ case   11:  		/* addi R10, R6, -4 */
		/* 820C7578h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C7578h case   11:*/		return 0x820C757C;
		  /* 820C757Ch */ case   12:  		/* mtspr CTR, R11 */
		/* 820C757Ch case   12:*/		regs.CTR = regs.R11;
		/* 820C757Ch case   12:*/		return 0x820C7580;
		  /* 820C7580h */ case   13:  		/* lfs FR0, <#[R10 + 4]> */
		/* 820C7580h case   13:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000004) );
		/* 820C7580h case   13:*/		return 0x820C7584;
		  /* 820C7584h */ case   14:  		/* fctiwz FR0, FR0 */
		/* 820C7584h case   14:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 820C7584h case   14:*/		return 0x820C7588;
		  /* 820C7588h */ case   15:  		/* stfd FR0, <#[R1 + 80]> */
		/* 820C7588h case   15:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820C7588h case   15:*/		return 0x820C758C;
		  /* 820C758Ch */ case   16:  		/* lwz R11, <#[R1 + 84]> */
		/* 820C758Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820C758Ch case   16:*/		return 0x820C7590;
		  /* 820C7590h */ case   17:  		/* stwu R11, <#[R10 + 4]> */
		/* 820C7590h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C7590h case   17:*/		return 0x820C7594;
		  /* 820C7594h */ case   18:  		/* bc 16, CR0_LT, -20 */
		/* 820C7594h case   18:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C7580;  }
		/* 820C7594h case   18:*/		return 0x820C7598;
		  /* 820C7598h */ case   19:  		/* b 56 */
		/* 820C7598h case   19:*/		return 0x820C75D0;
		/* 820C7598h case   19:*/		return 0x820C759C;
	}
	return 0x820C759C;
} // Block from 820C754Ch-820C759Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C759Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C759C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C759C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C759C);
		  /* 820C759Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 820C759Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C759Ch case    0:*/		return 0x820C75A0;
		  /* 820C75A0h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 820C75A0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C75D0;  }
		/* 820C75A0h case    1:*/		return 0x820C75A4;
		  /* 820C75A4h */ case    2:  		/* mtspr CTR, R11 */
		/* 820C75A4h case    2:*/		regs.CTR = regs.R11;
		/* 820C75A4h case    2:*/		return 0x820C75A8;
		  /* 820C75A8h */ case    3:  		/* lis R11, -32256 */
		/* 820C75A8h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820C75A8h case    3:*/		return 0x820C75AC;
		  /* 820C75ACh */ case    4:  		/* addi R10, R6, -4 */
		/* 820C75ACh case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xFFFFFFFC);
		/* 820C75ACh case    4:*/		return 0x820C75B0;
		  /* 820C75B0h */ case    5:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 820C75B0h case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 820C75B0h case    5:*/		return 0x820C75B4;
		  /* 820C75B4h */ case    6:  		/* lfs FR13, <#[R10 + 4]> */
		/* 820C75B4h case    6:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000004) );
		/* 820C75B4h case    6:*/		return 0x820C75B8;
		  /* 820C75B8h */ case    7:  		/* li R11, 1 */
		/* 820C75B8h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820C75B8h case    7:*/		return 0x820C75BC;
		  /* 820C75BCh */ case    8:  		/* fcmpu CR6, FR13, FR0 */
		/* 820C75BCh case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 820C75BCh case    8:*/		return 0x820C75C0;
		  /* 820C75C0h */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 820C75C0h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820C75C8;  }
		/* 820C75C0h case    9:*/		return 0x820C75C4;
		  /* 820C75C4h */ case   10:  		/* li R11, 0 */
		/* 820C75C4h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C75C4h case   10:*/		return 0x820C75C8;
	}
	return 0x820C75C8;
} // Block from 820C759Ch-820C75C8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C75C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C75C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C75C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C75C8);
		  /* 820C75C8h */ case    0:  		/* stwu R11, <#[R10 + 4]> */
		/* 820C75C8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C75C8h case    0:*/		return 0x820C75CC;
		  /* 820C75CCh */ case    1:  		/* bc 16, CR0_LT, -24 */
		/* 820C75CCh case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C75B4;  }
		/* 820C75CCh case    1:*/		return 0x820C75D0;
	}
	return 0x820C75D0;
} // Block from 820C75C8h-820C75D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C75D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C75D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C75D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C75D0);
		  /* 820C75D0h */ case    0:  		/* lhz R9, <#[R24 + 8]> */
		/* 820C75D0h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000008) );
		/* 820C75D0h case    0:*/		return 0x820C75D4;
		  /* 820C75D4h */ case    1:  		/* cmplwi CR0, R9, 0 */
		/* 820C75D4h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820C75D4h case    1:*/		return 0x820C75D8;
		  /* 820C75D8h */ case    2:  		/* bc 12, CR0_EQ, 212 */
		/* 820C75D8h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C76AC;  }
		/* 820C75D8h case    2:*/		return 0x820C75DC;
		  /* 820C75DCh */ case    3:  		/* lhz R11, <#[R25]> */
		/* 820C75DCh case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 820C75DCh case    3:*/		return 0x820C75E0;
		  /* 820C75E0h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C75E0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C75E0h case    4:*/		return 0x820C75E4;
		  /* 820C75E4h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 820C75E4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C75F4;  }
		/* 820C75E4h case    5:*/		return 0x820C75E8;
		  /* 820C75E8h */ case    6:  		/* lhz R11, <#[R25 + 6]> */
		/* 820C75E8h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000006) );
		/* 820C75E8h case    6:*/		return 0x820C75EC;
		  /* 820C75ECh */ case    7:  		/* lhz R10, <#[R25 + 4]> */
		/* 820C75ECh case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820C75ECh case    7:*/		return 0x820C75F0;
		  /* 820C75F0h */ case    8:  		/* b 12 */
		/* 820C75F0h case    8:*/		return 0x820C75FC;
		/* 820C75F0h case    8:*/		return 0x820C75F4;
	}
	return 0x820C75F4;
} // Block from 820C75D0h-820C75F4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C75F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C75F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C75F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C75F4);
		  /* 820C75F4h */ case    0:  		/* lhz R11, <#[R25 + 4]> */
		/* 820C75F4h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820C75F4h case    0:*/		return 0x820C75F8;
		  /* 820C75F8h */ case    1:  		/* lhz R10, <#[R25 + 6]> */
		/* 820C75F8h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000006) );
		/* 820C75F8h case    1:*/		return 0x820C75FC;
	}
	return 0x820C75FC;
} // Block from 820C75F4h-820C75FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C75FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C75FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C75FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C75FC);
		  /* 820C75FCh */ case    0:  		/* rlwinm. R8, R11, 0, 30, 31 */
		/* 820C75FCh case    0:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R8,regs.R11);
		/* 820C75FCh case    0:*/		return 0x820C7600;
		  /* 820C7600h */ case    1:  		/* bc 12, CR0_EQ, 172 */
		/* 820C7600h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C76AC;  }
		/* 820C7600h case    1:*/		return 0x820C7604;
		  /* 820C7604h */ case    2:  		/* cmplwi CR6, R9, 1 */
		/* 820C7604h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 820C7604h case    2:*/		return 0x820C7608;
		  /* 820C7608h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 820C7608h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C7618;  }
		/* 820C7608h case    3:*/		return 0x820C760C;
		  /* 820C760Ch */ case    4:  		/* lis R9, -32255 */
		/* 820C760Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C760Ch case    4:*/		return 0x820C7610;
		  /* 820C7610h */ case    5:  		/* addi R3, R9, 10344 */
		/* 820C7610h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R9,0x2868);
		/* 820C7610h case    5:*/		return 0x820C7614;
		  /* 820C7614h */ case    6:  		/* b 12 */
		/* 820C7614h case    6:*/		return 0x820C7620;
		/* 820C7614h case    6:*/		return 0x820C7618;
	}
	return 0x820C7618;
} // Block from 820C75FCh-820C7618h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C7618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7618);
		  /* 820C7618h */ case    0:  		/* lis R9, -32255 */
		/* 820C7618h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C7618h case    0:*/		return 0x820C761C;
		  /* 820C761Ch */ case    1:  		/* addi R3, R9, 10360 */
		/* 820C761Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R9,0x2878);
		/* 820C761Ch case    1:*/		return 0x820C7620;
	}
	return 0x820C7620;
} // Block from 820C7618h-820C7620h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C7620h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7620( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7620) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7620);
		  /* 820C7620h */ case    0:  		/* addi R8, R11, 3 */
		/* 820C7620h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x3);
		/* 820C7620h case    0:*/		return 0x820C7624;
		  /* 820C7624h */ case    1:  		/* mullw. R9, R10, R31 */
		/* 820C7624h case    1:*/		cpu::op::mullw<1>(regs,&regs.R9,regs.R10,regs.R31);
		/* 820C7624h case    1:*/		return 0x820C7628;
		  /* 820C7628h */ case    2:  		/* rlwinm R7, R8, 0, 0, 29 */
		/* 820C7628h case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R7,regs.R8);
		/* 820C7628h case    2:*/		return 0x820C762C;
		  /* 820C762Ch */ case    3:  		/* bc 12, CR0_EQ, 128 */
		/* 820C762Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820C76AC;  }
		/* 820C762Ch case    3:*/		return 0x820C7630;
		  /* 820C7630h */ case    4:  		/* mullw R8, R9, R7 */
		/* 820C7630h case    4:*/		cpu::op::mullw<0>(regs,&regs.R8,regs.R9,regs.R7);
		/* 820C7630h case    4:*/		return 0x820C7634;
		  /* 820C7634h */ case    5:  		/* mullw R4, R9, R11 */
		/* 820C7634h case    5:*/		cpu::op::mullw<0>(regs,&regs.R4,regs.R9,regs.R11);
		/* 820C7634h case    5:*/		return 0x820C7638;
		  /* 820C7638h */ case    6:  		/* addi R9, R9, -1 */
		/* 820C7638h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 820C7638h case    6:*/		return 0x820C763C;
		  /* 820C763Ch */ case    7:  		/* subf R4, R11, R4 */
		/* 820C763Ch case    7:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R11,regs.R4);
		/* 820C763Ch case    7:*/		return 0x820C7640;
	}
	return 0x820C7640;
} // Block from 820C7620h-820C7640h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C7640h
// Function '?Set@?$SetTyped@$02$02$03$03$0A@@D3DXShader@@SAJPAVCConstant@2@PBX1II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7640);
		  /* 820C7640h */ case    0:  		/* subf R8, R7, R8 */
		/* 820C7640h case    0:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820C7640h case    0:*/		return 0x820C7644;
		  /* 820C7644h */ case    1:  		/* mr R10, R7 */
		/* 820C7644h case    1:*/		regs.R10 = regs.R7;
		/* 820C7644h case    1:*/		return 0x820C7648;
		  /* 820C7648h */ case    2:  		/* cmplw CR6, R7, R11 */
		/* 820C7648h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C7648h case    2:*/		return 0x820C764C;
		  /* 820C764Ch */ case    3:  		/* bc 4, CR6_GT, 40 */
		/* 820C764Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x820C7674;  }
		/* 820C764Ch case    3:*/		return 0x820C7650;
		  /* 820C7650h */ case    4:  		/* subf R5, R11, R7 */
		/* 820C7650h case    4:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R11,regs.R7);
		/* 820C7650h case    4:*/		return 0x820C7654;
		  /* 820C7654h */ case    5:  		/* mtspr CTR, R5 */
		/* 820C7654h case    5:*/		regs.CTR = regs.R5;
		/* 820C7654h case    5:*/		return 0x820C7658;
		  /* 820C7658h */ case    6:  		/* addi R10, R10, -1 */
		/* 820C7658h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C7658h case    6:*/		return 0x820C765C;
		  /* 820C765Ch */ case    7:  		/* rlwinm R5, R10, 2, 28, 29 */
		/* 820C765Ch case    7:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R5,regs.R10);
		/* 820C765Ch case    7:*/		return 0x820C7660;
		  /* 820C7660h */ case    8:  		/* add R30, R10, R8 */
		/* 820C7660h case    8:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R8);
		/* 820C7660h case    8:*/		return 0x820C7664;
		  /* 820C7664h */ case    9:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C7664h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C7664h case    9:*/		return 0x820C7668;
		  /* 820C7668h */ case   10:  		/* lwzx R5, <#[R5 + R3]> */
		/* 820C7668h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 820C7668h case   10:*/		return 0x820C766C;
		  /* 820C766Ch */ case   11:  		/* stwx R5, <#[R30 + R6]> */
		/* 820C766Ch case   11:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C766Ch case   11:*/		return 0x820C7670;
		  /* 820C7670h */ case   12:  		/* bc 16, CR0_LT, -24 */
		/* 820C7670h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C7658;  }
		/* 820C7670h case   12:*/		return 0x820C7674;
	}
	return 0x820C7674;
} // Block from 820C7640h-820C7674h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C7674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7674);
		  /* 820C7674h */ case    0:  		/* mr R10, R11 */
		/* 820C7674h case    0:*/		regs.R10 = regs.R11;
		/* 820C7674h case    0:*/		return 0x820C7678;
		  /* 820C7678h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C7678h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C7678h case    1:*/		return 0x820C767C;
		  /* 820C767Ch */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820C767Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820C76A4;  }
		/* 820C767Ch case    2:*/		return 0x820C7680;
		  /* 820C7680h */ case    3:  		/* mtspr CTR, R11 */
		/* 820C7680h case    3:*/		regs.CTR = regs.R11;
		/* 820C7680h case    3:*/		return 0x820C7684;
		  /* 820C7684h */ case    4:  		/* addi R10, R10, -1 */
		/* 820C7684h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C7684h case    4:*/		return 0x820C7688;
		  /* 820C7688h */ case    5:  		/* add R5, R10, R4 */
		/* 820C7688h case    5:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R4);
		/* 820C7688h case    5:*/		return 0x820C768C;
		  /* 820C768Ch */ case    6:  		/* add R30, R10, R8 */
		/* 820C768Ch case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R8);
		/* 820C768Ch case    6:*/		return 0x820C7690;
		  /* 820C7690h */ case    7:  		/* rlwinm R5, R5, 2, 0, 29 */
		/* 820C7690h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R5);
		/* 820C7690h case    7:*/		return 0x820C7694;
		  /* 820C7694h */ case    8:  		/* rlwinm R30, R30, 2, 0, 29 */
		/* 820C7694h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 820C7694h case    8:*/		return 0x820C7698;
		  /* 820C7698h */ case    9:  		/* lwzx R5, <#[R5 + R6]> */
		/* 820C7698h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R6 + 0x00000000) );
		/* 820C7698h case    9:*/		return 0x820C769C;
		  /* 820C769Ch */ case   10:  		/* stwx R5, <#[R30 + R6]> */
		/* 820C769Ch case   10:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R30 + regs.R6 + 0x00000000) );
		/* 820C769Ch case   10:*/		return 0x820C76A0;
		  /* 820C76A0h */ case   11:  		/* bc 16, CR0_LT, -28 */
		/* 820C76A0h case   11:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C7684;  }
		/* 820C76A0h case   11:*/		return 0x820C76A4;
	}
	return 0x820C76A4;
} // Block from 820C7674h-820C76A4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C76A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C76A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C76A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C76A4);
		  /* 820C76A4h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 820C76A4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820C76A4h case    0:*/		return 0x820C76A8;
		  /* 820C76A8h */ case    1:  		/* bc 4, CR6_EQ, -112 */
		/* 820C76A8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C7638;  }
		/* 820C76A8h case    1:*/		return 0x820C76AC;
	}
	return 0x820C76AC;
} // Block from 820C76A4h-820C76ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C76ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C76AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C76AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C76AC);
		  /* 820C76ACh */ case    0:  		/* lwz R10, <#[R24 + 44]> */
		/* 820C76ACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000002C) );
		/* 820C76ACh case    0:*/		return 0x820C76B0;
		  /* 820C76B0h */ case    1:  		/* lhz R11, <#[R24 + 12]> */
		/* 820C76B0h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 820C76B0h case    1:*/		return 0x820C76B4;
		  /* 820C76B4h */ case    2:  		/* mullw R7, R10, R31 */
		/* 820C76B4h case    2:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R31);
		/* 820C76B4h case    2:*/		return 0x820C76B8;
		  /* 820C76B8h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 820C76B8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820C76B8h case    3:*/		return 0x820C76BC;
		  /* 820C76BCh */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 820C76BCh case    4:*/		if ( !regs.CR[6].gt ) { return 0x820C76C4;  }
		/* 820C76BCh case    4:*/		return 0x820C76C0;
		  /* 820C76C0h */ case    5:  		/* mr R7, R11 */
		/* 820C76C0h case    5:*/		regs.R7 = regs.R11;
		/* 820C76C0h case    5:*/		return 0x820C76C4;
	}
	return 0x820C76C4;
} // Block from 820C76ACh-820C76C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C76C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C76C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C76C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C76C4);
		  /* 820C76C4h */ case    0:  		/* lwz R10, <#[R24 + 28]> */
		/* 820C76C4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x0000001C) );
		/* 820C76C4h case    0:*/		return 0x820C76C8;
		  /* 820C76C8h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C76C8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C76C8h case    1:*/		return 0x820C76CC;
		  /* 820C76CCh */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 820C76CCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C76DC;  }
		/* 820C76CCh case    2:*/		return 0x820C76D0;
		  /* 820C76D0h */ case    3:  		/* lis R3, -32768 */
		/* 820C76D0h case    3:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C76D0h case    3:*/		return 0x820C76D4;
		  /* 820C76D4h */ case    4:  		/* ori R3, R3, 16389 */
		/* 820C76D4h case    4:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C76D4h case    4:*/		return 0x820C76D8;
		  /* 820C76D8h */ case    5:  		/* b 36 */
		/* 820C76D8h case    5:*/		return 0x820C76FC;
		/* 820C76D8h case    5:*/		return 0x820C76DC;
	}
	return 0x820C76DC;
} // Block from 820C76C4h-820C76DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C76DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C76DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C76DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C76DC);
		  /* 820C76DCh */ case    0:  		/* lhz R11, <#[R24 + 10]> */
		/* 820C76DCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000A) );
		/* 820C76DCh case    0:*/		return 0x820C76E0;
		  /* 820C76E0h */ case    1:  		/* mr R5, R6 */
		/* 820C76E0h case    1:*/		regs.R5 = regs.R6;
		/* 820C76E0h case    1:*/		return 0x820C76E4;
		  /* 820C76E4h */ case    2:  		/* mr R3, R23 */
		/* 820C76E4h case    2:*/		regs.R3 = regs.R23;
		/* 820C76E4h case    2:*/		return 0x820C76E8;
		  /* 820C76E8h */ case    3:  		/* mtspr CTR, R10 */
		/* 820C76E8h case    3:*/		regs.CTR = regs.R10;
		/* 820C76E8h case    3:*/		return 0x820C76EC;
		  /* 820C76ECh */ case    4:  		/* add R4, R11, R22 */
		/* 820C76ECh case    4:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R22);
		/* 820C76ECh case    4:*/		return 0x820C76F0;
		  /* 820C76F0h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820C76F0h case    5:*/		if ( 1 ) { regs.LR = 0x820C76F4; return (uint32)regs.CTR; }
		/* 820C76F0h case    5:*/		return 0x820C76F4;
		  /* 820C76F4h */ case    6:  		/* srawi R11, R3, 31 */
		/* 820C76F4h case    6:*/		cpu::op::srawi<0,31>(regs,&regs.R11,regs.R3);
		/* 820C76F4h case    6:*/		return 0x820C76F8;
		  /* 820C76F8h */ case    7:  		/* and R3, R11, R3 */
		/* 820C76F8h case    7:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C76F8h case    7:*/		return 0x820C76FC;
	}
	return 0x820C76FC;
} // Block from 820C76DCh-820C76FCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C76FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C76FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C76FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C76FC);
		  /* 820C76FCh */ case    0:  		/* addi R1, R1, 176 */
		/* 820C76FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 820C76FCh case    0:*/		return 0x820C7700;
		  /* 820C7700h */ case    1:  		/* b -222320 */
		/* 820C7700h case    1:*/		return 0x82091290;
		/* 820C7700h case    1:*/		return 0x820C7704;
		  /* 820C7704h */ case    2:  		/* nop */
		/* 820C7704h case    2:*/		cpu::op::nop();
		/* 820C7704h case    2:*/		return 0x820C7708;
	}
	return 0x820C7708;
} // Block from 820C76FCh-820C7708h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7708h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7708);
		  /* 820C7708h */ case    0:  		/* mfspr R12, LR */
		/* 820C7708h case    0:*/		regs.R12 = regs.LR;
		/* 820C7708h case    0:*/		return 0x820C770C;
		  /* 820C770Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C770Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C770Ch case    1:*/		return 0x820C7710;
		  /* 820C7710h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C7710h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C7710h case    2:*/		return 0x820C7714;
		  /* 820C7714h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C7714h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C7714h case    3:*/		return 0x820C7718;
		  /* 820C7718h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C7718h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C7718h case    4:*/		return 0x820C771C;
		  /* 820C771Ch */ case    5:  		/* mr R31, R3 */
		/* 820C771Ch case    5:*/		regs.R31 = regs.R3;
		/* 820C771Ch case    5:*/		return 0x820C7720;
		  /* 820C7720h */ case    6:  		/* mr R30, R4 */
		/* 820C7720h case    6:*/		regs.R30 = regs.R4;
		/* 820C7720h case    6:*/		return 0x820C7724;
		  /* 820C7724h */ case    7:  		/* bl -12756 */
		/* 820C7724h case    7:*/		regs.LR = 0x820C7728; return 0x820C4550;
		/* 820C7724h case    7:*/		return 0x820C7728;
		  /* 820C7728h */ case    8:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 820C7728h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 820C7728h case    8:*/		return 0x820C772C;
		  /* 820C772Ch */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 820C772Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x820C773C;  }
		/* 820C772Ch case    9:*/		return 0x820C7730;
		  /* 820C7730h */ case   10:  		/* lis R4, 9345 */
		/* 820C7730h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C7730h case   10:*/		return 0x820C7734;
		  /* 820C7734h */ case   11:  		/* mr R3, R31 */
		/* 820C7734h case   11:*/		regs.R3 = regs.R31;
		/* 820C7734h case   11:*/		return 0x820C7738;
		  /* 820C7738h */ case   12:  		/* bl -259072 */
		/* 820C7738h case   12:*/		regs.LR = 0x820C773C; return 0x82088338;
		/* 820C7738h case   12:*/		return 0x820C773C;
	}
	return 0x820C773C;
} // Block from 820C7708h-820C773Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C773Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C773C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C773C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C773C);
		  /* 820C773Ch */ case    0:  		/* mr R3, R31 */
		/* 820C773Ch case    0:*/		regs.R3 = regs.R31;
		/* 820C773Ch case    0:*/		return 0x820C7740;
		  /* 820C7740h */ case    1:  		/* addi R1, R1, 112 */
		/* 820C7740h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C7740h case    1:*/		return 0x820C7744;
		  /* 820C7744h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C7744h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C7744h case    2:*/		return 0x820C7748;
		  /* 820C7748h */ case    3:  		/* mtspr LR, R12 */
		/* 820C7748h case    3:*/		regs.LR = regs.R12;
		/* 820C7748h case    3:*/		return 0x820C774C;
		  /* 820C774Ch */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820C774Ch case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C774Ch case    4:*/		return 0x820C7750;
		  /* 820C7750h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820C7750h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C7750h case    5:*/		return 0x820C7754;
		  /* 820C7754h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C7754h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C7754h case    6:*/		return 0x820C7758;
	}
	return 0x820C7758;
} // Block from 820C773Ch-820C7758h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C7758h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7758);
		  /* 820C7758h */ case    0:  		/* mfspr R12, LR */
		/* 820C7758h case    0:*/		regs.R12 = regs.LR;
		/* 820C7758h case    0:*/		return 0x820C775C;
		  /* 820C775Ch */ case    1:  		/* bl -222468 */
		/* 820C775Ch case    1:*/		regs.LR = 0x820C7760; return 0x82091258;
		/* 820C775Ch case    1:*/		return 0x820C7760;
		  /* 820C7760h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C7760h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C7760h case    2:*/		return 0x820C7764;
		  /* 820C7764h */ case    3:  		/* lis R11, -32255 */
		/* 820C7764h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C7764h case    3:*/		return 0x820C7768;
		  /* 820C7768h */ case    4:  		/* lwz R10, <#[R3 + 20]> */
		/* 820C7768h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 820C7768h case    4:*/		return 0x820C776C;
		  /* 820C776Ch */ case    5:  		/* mr R31, R3 */
		/* 820C776Ch case    5:*/		regs.R31 = regs.R3;
		/* 820C776Ch case    5:*/		return 0x820C7770;
		  /* 820C7770h */ case    6:  		/* addi R11, R11, 10376 */
		/* 820C7770h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2888);
		/* 820C7770h case    6:*/		return 0x820C7774;
		  /* 820C7774h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 820C7774h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C7774h case    7:*/		return 0x820C7778;
		  /* 820C7778h */ case    8:  		/* stw R11, <#[R3]> */
		/* 820C7778h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C7778h case    8:*/		return 0x820C777C;
		  /* 820C777Ch */ case    9:  		/* bc 12, CR6_EQ, 92 */
		/* 820C777Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x820C77D8;  }
		/* 820C777Ch case    9:*/		return 0x820C7780;
		  /* 820C7780h */ case   10:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C7780h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C7780h case   10:*/		return 0x820C7784;
		  /* 820C7784h */ case   11:  		/* li R28, 0 */
		/* 820C7784h case   11:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820C7784h case   11:*/		return 0x820C7788;
		  /* 820C7788h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 820C7788h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C7788h case   12:*/		return 0x820C778C;
		  /* 820C778Ch */ case   13:  		/* bc 4, CR6_GT, 64 */
		/* 820C778Ch case   13:*/		if ( !regs.CR[6].gt ) { return 0x820C77CC;  }
		/* 820C778Ch case   13:*/		return 0x820C7790;
		  /* 820C7790h */ case   14:  		/* li R30, 0 */
		/* 820C7790h case   14:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C7790h case   14:*/		return 0x820C7794;
		  /* 820C7794h */ case   15:  		/* lwz R11, <#[R31 + 20]> */
		/* 820C7794h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820C7794h case   15:*/		return 0x820C7798;
		  /* 820C7798h */ case   16:  		/* lwzx R29, <#[R11 + R30]> */
		/* 820C7798h case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820C7798h case   16:*/		return 0x820C779C;
		  /* 820C779Ch */ case   17:  		/* cmplwi CR6, R29, 0 */
		/* 820C779Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820C779Ch case   17:*/		return 0x820C77A0;
		  /* 820C77A0h */ case   18:  		/* bc 12, CR6_EQ, 24 */
		/* 820C77A0h case   18:*/		if ( regs.CR[6].eq ) { return 0x820C77B8;  }
		/* 820C77A0h case   18:*/		return 0x820C77A4;
		  /* 820C77A4h */ case   19:  		/* mr R3, R29 */
		/* 820C77A4h case   19:*/		regs.R3 = regs.R29;
		/* 820C77A4h case   19:*/		return 0x820C77A8;
		  /* 820C77A8h */ case   20:  		/* bl -12888 */
		/* 820C77A8h case   20:*/		regs.LR = 0x820C77AC; return 0x820C4550;
		/* 820C77A8h case   20:*/		return 0x820C77AC;
		  /* 820C77ACh */ case   21:  		/* lis R4, 9345 */
		/* 820C77ACh case   21:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C77ACh case   21:*/		return 0x820C77B0;
		  /* 820C77B0h */ case   22:  		/* mr R3, R29 */
		/* 820C77B0h case   22:*/		regs.R3 = regs.R29;
		/* 820C77B0h case   22:*/		return 0x820C77B4;
		  /* 820C77B4h */ case   23:  		/* bl -259196 */
		/* 820C77B4h case   23:*/		regs.LR = 0x820C77B8; return 0x82088338;
		/* 820C77B4h case   23:*/		return 0x820C77B8;
	}
	return 0x820C77B8;
} // Block from 820C7758h-820C77B8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820C77B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C77B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C77B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C77B8);
		  /* 820C77B8h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C77B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C77B8h case    0:*/		return 0x820C77BC;
		  /* 820C77BCh */ case    1:  		/* addi R28, R28, 1 */
		/* 820C77BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820C77BCh case    1:*/		return 0x820C77C0;
		  /* 820C77C0h */ case    2:  		/* addi R30, R30, 4 */
		/* 820C77C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C77C0h case    2:*/		return 0x820C77C4;
		  /* 820C77C4h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 820C77C4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820C77C4h case    3:*/		return 0x820C77C8;
		  /* 820C77C8h */ case    4:  		/* bc 12, CR6_LT, -52 */
		/* 820C77C8h case    4:*/		if ( regs.CR[6].lt ) { return 0x820C7794;  }
		/* 820C77C8h case    4:*/		return 0x820C77CC;
	}
	return 0x820C77CC;
} // Block from 820C77B8h-820C77CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C77CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C77CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C77CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C77CC);
		  /* 820C77CCh */ case    0:  		/* lis R4, 9345 */
		/* 820C77CCh case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C77CCh case    0:*/		return 0x820C77D0;
		  /* 820C77D0h */ case    1:  		/* lwz R3, <#[R31 + 20]> */
		/* 820C77D0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820C77D0h case    1:*/		return 0x820C77D4;
		  /* 820C77D4h */ case    2:  		/* bl -259228 */
		/* 820C77D4h case    2:*/		regs.LR = 0x820C77D8; return 0x82088338;
		/* 820C77D4h case    2:*/		return 0x820C77D8;
	}
	return 0x820C77D8;
} // Block from 820C77CCh-820C77D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C77D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C77D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C77D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C77D8);
		  /* 820C77D8h */ case    0:  		/* lis R4, 9345 */
		/* 820C77D8h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C77D8h case    0:*/		return 0x820C77DC;
		  /* 820C77DCh */ case    1:  		/* lwz R3, <#[R31 + 8]> */
		/* 820C77DCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820C77DCh case    1:*/		return 0x820C77E0;
		  /* 820C77E0h */ case    2:  		/* bl -259240 */
		/* 820C77E0h case    2:*/		regs.LR = 0x820C77E4; return 0x82088338;
		/* 820C77E0h case    2:*/		return 0x820C77E4;
		  /* 820C77E4h */ case    3:  		/* lis R4, 9345 */
		/* 820C77E4h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C77E4h case    3:*/		return 0x820C77E8;
		  /* 820C77E8h */ case    4:  		/* lwz R3, <#[R31 + 28]> */
		/* 820C77E8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 820C77E8h case    4:*/		return 0x820C77EC;
		  /* 820C77ECh */ case    5:  		/* bl -259252 */
		/* 820C77ECh case    5:*/		regs.LR = 0x820C77F0; return 0x82088338;
		/* 820C77ECh case    5:*/		return 0x820C77F0;
		  /* 820C77F0h */ case    6:  		/* addi R1, R1, 128 */
		/* 820C77F0h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C77F0h case    6:*/		return 0x820C77F4;
		  /* 820C77F4h */ case    7:  		/* b -222540 */
		/* 820C77F4h case    7:*/		return 0x820912A8;
		/* 820C77F4h case    7:*/		return 0x820C77F8;
	}
	return 0x820C77F8;
} // Block from 820C77D8h-820C77F8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C77F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C77F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C77F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C77F8);
		  /* 820C77F8h */ case    0:  		/* mfspr R12, LR */
		/* 820C77F8h case    0:*/		regs.R12 = regs.LR;
		/* 820C77F8h case    0:*/		return 0x820C77FC;
		  /* 820C77FCh */ case    1:  		/* bl -222628 */
		/* 820C77FCh case    1:*/		regs.LR = 0x820C7800; return 0x82091258;
		/* 820C77FCh case    1:*/		return 0x820C7800;
		  /* 820C7800h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C7800h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C7800h case    2:*/		return 0x820C7804;
		  /* 820C7804h */ case    3:  		/* mr R30, R4 */
		/* 820C7804h case    3:*/		regs.R30 = regs.R4;
		/* 820C7804h case    3:*/		return 0x820C7808;
		  /* 820C7808h */ case    4:  		/* mr R29, R6 */
		/* 820C7808h case    4:*/		regs.R29 = regs.R6;
		/* 820C7808h case    4:*/		return 0x820C780C;
		  /* 820C780Ch */ case    5:  		/* nor R31, R5, R5 */
		/* 820C780Ch case    5:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C780Ch case    5:*/		return 0x820C7810;
		  /* 820C7810h */ case    6:  		/* rlwinm R28, R7, 30, 2, 31 */
		/* 820C7810h case    6:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R28,regs.R7);
		/* 820C7810h case    6:*/		return 0x820C7814;
		  /* 820C7814h */ case    7:  		/* b 16 */
		/* 820C7814h case    7:*/		return 0x820C7824;
		/* 820C7814h case    7:*/		return 0x820C7818;
		  /* 820C7818h */ case    8:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C7818h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C7818h case    8:*/		return 0x820C781C;
		  /* 820C781Ch */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 820C781Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C781Ch case    9:*/		return 0x820C7820;
		  /* 820C7820h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7820h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C7848;  }
		/* 820C7820h case   10:*/		return 0x820C7824;
	}
	return 0x820C7824;
} // Block from 820C77F8h-820C7824h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C7824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7824);
		  /* 820C7824h */ case    0:  		/* li R7, 0 */
		/* 820C7824h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7824h case    0:*/		return 0x820C7828;
		  /* 820C7828h */ case    1:  		/* mr R6, R28 */
		/* 820C7828h case    1:*/		regs.R6 = regs.R28;
		/* 820C7828h case    1:*/		return 0x820C782C;
		  /* 820C782Ch */ case    2:  		/* mr R5, R29 */
		/* 820C782Ch case    2:*/		regs.R5 = regs.R29;
		/* 820C782Ch case    2:*/		return 0x820C7830;
		  /* 820C7830h */ case    3:  		/* mr R4, R30 */
		/* 820C7830h case    3:*/		regs.R4 = regs.R30;
		/* 820C7830h case    3:*/		return 0x820C7834;
		  /* 820C7834h */ case    4:  		/* mr R3, R31 */
		/* 820C7834h case    4:*/		regs.R3 = regs.R31;
		/* 820C7834h case    4:*/		return 0x820C7838;
		  /* 820C7838h */ case    5:  		/* bl -10520 */
		/* 820C7838h case    5:*/		regs.LR = 0x820C783C; return 0x820C4F20;
		/* 820C7838h case    5:*/		return 0x820C783C;
		  /* 820C783Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C783Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C783Ch case    6:*/		return 0x820C7840;
		  /* 820C7840h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7840h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C7818;  }
		/* 820C7840h case    7:*/		return 0x820C7844;
		  /* 820C7844h */ case    8:  		/* b 8 */
		/* 820C7844h case    8:*/		return 0x820C784C;
		/* 820C7844h case    8:*/		return 0x820C7848;
	}
	return 0x820C7848;
} // Block from 820C7824h-820C7848h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7848);
		  /* 820C7848h */ case    0:  		/* li R3, 0 */
		/* 820C7848h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7848h case    0:*/		return 0x820C784C;
	}
	return 0x820C784C;
} // Block from 820C7848h-820C784Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C784Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C784C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C784C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C784C);
		  /* 820C784Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 820C784Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C784Ch case    0:*/		return 0x820C7850;
		  /* 820C7850h */ case    1:  		/* b -222632 */
		/* 820C7850h case    1:*/		return 0x820912A8;
		/* 820C7850h case    1:*/		return 0x820C7854;
		  /* 820C7854h */ case    2:  		/* nop */
		/* 820C7854h case    2:*/		cpu::op::nop();
		/* 820C7854h case    2:*/		return 0x820C7858;
	}
	return 0x820C7858;
} // Block from 820C784Ch-820C7858h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7858);
		  /* 820C7858h */ case    0:  		/* mfspr R12, LR */
		/* 820C7858h case    0:*/		regs.R12 = regs.LR;
		/* 820C7858h case    0:*/		return 0x820C785C;
		  /* 820C785Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C785Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C785Ch case    1:*/		return 0x820C7860;
		  /* 820C7860h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C7860h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C7860h case    2:*/		return 0x820C7864;
		  /* 820C7864h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C7864h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C7864h case    3:*/		return 0x820C7868;
		  /* 820C7868h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C7868h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C7868h case    4:*/		return 0x820C786C;
		  /* 820C786Ch */ case    5:  		/* mr R30, R4 */
		/* 820C786Ch case    5:*/		regs.R30 = regs.R4;
		/* 820C786Ch case    5:*/		return 0x820C7870;
		  /* 820C7870h */ case    6:  		/* stw R6, <#[R1 + 156]> */
		/* 820C7870h case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000009C) );
		/* 820C7870h case    6:*/		return 0x820C7874;
		  /* 820C7874h */ case    7:  		/* nor R31, R5, R5 */
		/* 820C7874h case    7:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7874h case    7:*/		return 0x820C7878;
		  /* 820C7878h */ case    8:  		/* b 16 */
		/* 820C7878h case    8:*/		return 0x820C7888;
		/* 820C7878h case    8:*/		return 0x820C787C;
		  /* 820C787Ch */ case    9:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C787Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C787Ch case    9:*/		return 0x820C7880;
		  /* 820C7880h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 820C7880h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7880h case   10:*/		return 0x820C7884;
		  /* 820C7884h */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7884h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C78AC;  }
		/* 820C7884h case   11:*/		return 0x820C7888;
	}
	return 0x820C7888;
} // Block from 820C7858h-820C7888h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C7888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7888);
		  /* 820C7888h */ case    0:  		/* li R7, 0 */
		/* 820C7888h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7888h case    0:*/		return 0x820C788C;
		  /* 820C788Ch */ case    1:  		/* li R6, 1 */
		/* 820C788Ch case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820C788Ch case    1:*/		return 0x820C7890;
		  /* 820C7890h */ case    2:  		/* addi R5, R1, 156 */
		/* 820C7890h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x9C);
		/* 820C7890h case    2:*/		return 0x820C7894;
		  /* 820C7894h */ case    3:  		/* mr R4, R30 */
		/* 820C7894h case    3:*/		regs.R4 = regs.R30;
		/* 820C7894h case    3:*/		return 0x820C7898;
		  /* 820C7898h */ case    4:  		/* mr R3, R31 */
		/* 820C7898h case    4:*/		regs.R3 = regs.R31;
		/* 820C7898h case    4:*/		return 0x820C789C;
		  /* 820C789Ch */ case    5:  		/* bl -9844 */
		/* 820C789Ch case    5:*/		regs.LR = 0x820C78A0; return 0x820C5228;
		/* 820C789Ch case    5:*/		return 0x820C78A0;
		  /* 820C78A0h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C78A0h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C78A0h case    6:*/		return 0x820C78A4;
		  /* 820C78A4h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C78A4h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C787C;  }
		/* 820C78A4h case    7:*/		return 0x820C78A8;
		  /* 820C78A8h */ case    8:  		/* b 8 */
		/* 820C78A8h case    8:*/		return 0x820C78B0;
		/* 820C78A8h case    8:*/		return 0x820C78AC;
	}
	return 0x820C78AC;
} // Block from 820C7888h-820C78ACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C78ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C78AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C78AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C78AC);
		  /* 820C78ACh */ case    0:  		/* li R3, 0 */
		/* 820C78ACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C78ACh case    0:*/		return 0x820C78B0;
	}
	return 0x820C78B0;
} // Block from 820C78ACh-820C78B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C78B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C78B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C78B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C78B0);
		  /* 820C78B0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820C78B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C78B0h case    0:*/		return 0x820C78B4;
		  /* 820C78B4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C78B4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C78B4h case    1:*/		return 0x820C78B8;
		  /* 820C78B8h */ case    2:  		/* mtspr LR, R12 */
		/* 820C78B8h case    2:*/		regs.LR = regs.R12;
		/* 820C78B8h case    2:*/		return 0x820C78BC;
		  /* 820C78BCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820C78BCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C78BCh case    3:*/		return 0x820C78C0;
		  /* 820C78C0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820C78C0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C78C0h case    4:*/		return 0x820C78C4;
		  /* 820C78C4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C78C4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C78C4h case    5:*/		return 0x820C78C8;
	}
	return 0x820C78C8;
} // Block from 820C78B0h-820C78C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C78C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C78C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C78C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C78C8);
		  /* 820C78C8h */ case    0:  		/* mfspr R12, LR */
		/* 820C78C8h case    0:*/		regs.R12 = regs.LR;
		/* 820C78C8h case    0:*/		return 0x820C78CC;
		  /* 820C78CCh */ case    1:  		/* bl -222836 */
		/* 820C78CCh case    1:*/		regs.LR = 0x820C78D0; return 0x82091258;
		/* 820C78CCh case    1:*/		return 0x820C78D0;
		  /* 820C78D0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C78D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C78D0h case    2:*/		return 0x820C78D4;
		  /* 820C78D4h */ case    3:  		/* mr R30, R4 */
		/* 820C78D4h case    3:*/		regs.R30 = regs.R4;
		/* 820C78D4h case    3:*/		return 0x820C78D8;
		  /* 820C78D8h */ case    4:  		/* mr R29, R6 */
		/* 820C78D8h case    4:*/		regs.R29 = regs.R6;
		/* 820C78D8h case    4:*/		return 0x820C78DC;
		  /* 820C78DCh */ case    5:  		/* mr R28, R7 */
		/* 820C78DCh case    5:*/		regs.R28 = regs.R7;
		/* 820C78DCh case    5:*/		return 0x820C78E0;
		  /* 820C78E0h */ case    6:  		/* nor R31, R5, R5 */
		/* 820C78E0h case    6:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C78E0h case    6:*/		return 0x820C78E4;
		  /* 820C78E4h */ case    7:  		/* b 16 */
		/* 820C78E4h case    7:*/		return 0x820C78F4;
		/* 820C78E4h case    7:*/		return 0x820C78E8;
		  /* 820C78E8h */ case    8:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C78E8h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C78E8h case    8:*/		return 0x820C78EC;
		  /* 820C78ECh */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 820C78ECh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C78ECh case    9:*/		return 0x820C78F0;
		  /* 820C78F0h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820C78F0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C7918;  }
		/* 820C78F0h case   10:*/		return 0x820C78F4;
	}
	return 0x820C78F4;
} // Block from 820C78C8h-820C78F4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C78F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C78F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C78F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C78F4);
		  /* 820C78F4h */ case    0:  		/* li R7, 0 */
		/* 820C78F4h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C78F4h case    0:*/		return 0x820C78F8;
		  /* 820C78F8h */ case    1:  		/* mr R6, R28 */
		/* 820C78F8h case    1:*/		regs.R6 = regs.R28;
		/* 820C78F8h case    1:*/		return 0x820C78FC;
		  /* 820C78FCh */ case    2:  		/* mr R5, R29 */
		/* 820C78FCh case    2:*/		regs.R5 = regs.R29;
		/* 820C78FCh case    2:*/		return 0x820C7900;
		  /* 820C7900h */ case    3:  		/* mr R4, R30 */
		/* 820C7900h case    3:*/		regs.R4 = regs.R30;
		/* 820C7900h case    3:*/		return 0x820C7904;
		  /* 820C7904h */ case    4:  		/* mr R3, R31 */
		/* 820C7904h case    4:*/		regs.R3 = regs.R31;
		/* 820C7904h case    4:*/		return 0x820C7908;
		  /* 820C7908h */ case    5:  		/* bl -9952 */
		/* 820C7908h case    5:*/		regs.LR = 0x820C790C; return 0x820C5228;
		/* 820C7908h case    5:*/		return 0x820C790C;
		  /* 820C790Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C790Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C790Ch case    6:*/		return 0x820C7910;
		  /* 820C7910h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7910h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C78E8;  }
		/* 820C7910h case    7:*/		return 0x820C7914;
		  /* 820C7914h */ case    8:  		/* b 8 */
		/* 820C7914h case    8:*/		return 0x820C791C;
		/* 820C7914h case    8:*/		return 0x820C7918;
	}
	return 0x820C7918;
} // Block from 820C78F4h-820C7918h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7918);
		  /* 820C7918h */ case    0:  		/* li R3, 0 */
		/* 820C7918h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7918h case    0:*/		return 0x820C791C;
	}
	return 0x820C791C;
} // Block from 820C7918h-820C791Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C791Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C791C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C791C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C791C);
		  /* 820C791Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 820C791Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C791Ch case    0:*/		return 0x820C7920;
		  /* 820C7920h */ case    1:  		/* b -222840 */
		/* 820C7920h case    1:*/		return 0x820912A8;
		/* 820C7920h case    1:*/		return 0x820C7924;
		  /* 820C7924h */ case    2:  		/* nop */
		/* 820C7924h case    2:*/		cpu::op::nop();
		/* 820C7924h case    2:*/		return 0x820C7928;
	}
	return 0x820C7928;
} // Block from 820C791Ch-820C7928h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7928);
		  /* 820C7928h */ case    0:  		/* mfspr R12, LR */
		/* 820C7928h case    0:*/		regs.R12 = regs.LR;
		/* 820C7928h case    0:*/		return 0x820C792C;
		  /* 820C792Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C792Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C792Ch case    1:*/		return 0x820C7930;
		  /* 820C7930h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C7930h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C7930h case    2:*/		return 0x820C7934;
		  /* 820C7934h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C7934h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C7934h case    3:*/		return 0x820C7938;
		  /* 820C7938h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C7938h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C7938h case    4:*/		return 0x820C793C;
		  /* 820C793Ch */ case    5:  		/* mr R30, R4 */
		/* 820C793Ch case    5:*/		regs.R30 = regs.R4;
		/* 820C793Ch case    5:*/		return 0x820C7940;
		  /* 820C7940h */ case    6:  		/* stw R6, <#[R1 + 156]> */
		/* 820C7940h case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000009C) );
		/* 820C7940h case    6:*/		return 0x820C7944;
		  /* 820C7944h */ case    7:  		/* nor R31, R5, R5 */
		/* 820C7944h case    7:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7944h case    7:*/		return 0x820C7948;
		  /* 820C7948h */ case    8:  		/* b 16 */
		/* 820C7948h case    8:*/		return 0x820C7958;
		/* 820C7948h case    8:*/		return 0x820C794C;
		  /* 820C794Ch */ case    9:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C794Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C794Ch case    9:*/		return 0x820C7950;
		  /* 820C7950h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 820C7950h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7950h case   10:*/		return 0x820C7954;
		  /* 820C7954h */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7954h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C797C;  }
		/* 820C7954h case   11:*/		return 0x820C7958;
	}
	return 0x820C7958;
} // Block from 820C7928h-820C7958h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C7958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7958);
		  /* 820C7958h */ case    0:  		/* li R7, 0 */
		/* 820C7958h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7958h case    0:*/		return 0x820C795C;
		  /* 820C795Ch */ case    1:  		/* li R6, 1 */
		/* 820C795Ch case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820C795Ch case    1:*/		return 0x820C7960;
		  /* 820C7960h */ case    2:  		/* addi R5, R1, 156 */
		/* 820C7960h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x9C);
		/* 820C7960h case    2:*/		return 0x820C7964;
		  /* 820C7964h */ case    3:  		/* mr R4, R30 */
		/* 820C7964h case    3:*/		regs.R4 = regs.R30;
		/* 820C7964h case    3:*/		return 0x820C7968;
		  /* 820C7968h */ case    4:  		/* mr R3, R31 */
		/* 820C7968h case    4:*/		regs.R3 = regs.R31;
		/* 820C7968h case    4:*/		return 0x820C796C;
		  /* 820C796Ch */ case    5:  		/* bl -9116 */
		/* 820C796Ch case    5:*/		regs.LR = 0x820C7970; return 0x820C55D0;
		/* 820C796Ch case    5:*/		return 0x820C7970;
		  /* 820C7970h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C7970h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C7970h case    6:*/		return 0x820C7974;
		  /* 820C7974h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7974h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C794C;  }
		/* 820C7974h case    7:*/		return 0x820C7978;
		  /* 820C7978h */ case    8:  		/* b 8 */
		/* 820C7978h case    8:*/		return 0x820C7980;
		/* 820C7978h case    8:*/		return 0x820C797C;
	}
	return 0x820C797C;
} // Block from 820C7958h-820C797Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C797Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C797C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C797C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C797C);
		  /* 820C797Ch */ case    0:  		/* li R3, 0 */
		/* 820C797Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C797Ch case    0:*/		return 0x820C7980;
	}
	return 0x820C7980;
} // Block from 820C797Ch-820C7980h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7980);
		  /* 820C7980h */ case    0:  		/* addi R1, R1, 112 */
		/* 820C7980h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C7980h case    0:*/		return 0x820C7984;
		  /* 820C7984h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C7984h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C7984h case    1:*/		return 0x820C7988;
		  /* 820C7988h */ case    2:  		/* mtspr LR, R12 */
		/* 820C7988h case    2:*/		regs.LR = regs.R12;
		/* 820C7988h case    2:*/		return 0x820C798C;
		  /* 820C798Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820C798Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C798Ch case    3:*/		return 0x820C7990;
		  /* 820C7990h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820C7990h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C7990h case    4:*/		return 0x820C7994;
		  /* 820C7994h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C7994h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C7994h case    5:*/		return 0x820C7998;
	}
	return 0x820C7998;
} // Block from 820C7980h-820C7998h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C7998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7998);
		  /* 820C7998h */ case    0:  		/* mfspr R12, LR */
		/* 820C7998h case    0:*/		regs.R12 = regs.LR;
		/* 820C7998h case    0:*/		return 0x820C799C;
		  /* 820C799Ch */ case    1:  		/* bl -223044 */
		/* 820C799Ch case    1:*/		regs.LR = 0x820C79A0; return 0x82091258;
		/* 820C799Ch case    1:*/		return 0x820C79A0;
		  /* 820C79A0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C79A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C79A0h case    2:*/		return 0x820C79A4;
		  /* 820C79A4h */ case    3:  		/* mr R30, R4 */
		/* 820C79A4h case    3:*/		regs.R30 = regs.R4;
		/* 820C79A4h case    3:*/		return 0x820C79A8;
		  /* 820C79A8h */ case    4:  		/* mr R29, R6 */
		/* 820C79A8h case    4:*/		regs.R29 = regs.R6;
		/* 820C79A8h case    4:*/		return 0x820C79AC;
		  /* 820C79ACh */ case    5:  		/* mr R28, R7 */
		/* 820C79ACh case    5:*/		regs.R28 = regs.R7;
		/* 820C79ACh case    5:*/		return 0x820C79B0;
		  /* 820C79B0h */ case    6:  		/* nor R31, R5, R5 */
		/* 820C79B0h case    6:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C79B0h case    6:*/		return 0x820C79B4;
		  /* 820C79B4h */ case    7:  		/* b 16 */
		/* 820C79B4h case    7:*/		return 0x820C79C4;
		/* 820C79B4h case    7:*/		return 0x820C79B8;
		  /* 820C79B8h */ case    8:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C79B8h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C79B8h case    8:*/		return 0x820C79BC;
		  /* 820C79BCh */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 820C79BCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C79BCh case    9:*/		return 0x820C79C0;
		  /* 820C79C0h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820C79C0h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C79E8;  }
		/* 820C79C0h case   10:*/		return 0x820C79C4;
	}
	return 0x820C79C4;
} // Block from 820C7998h-820C79C4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C79C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C79C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C79C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C79C4);
		  /* 820C79C4h */ case    0:  		/* li R7, 0 */
		/* 820C79C4h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C79C4h case    0:*/		return 0x820C79C8;
		  /* 820C79C8h */ case    1:  		/* mr R6, R28 */
		/* 820C79C8h case    1:*/		regs.R6 = regs.R28;
		/* 820C79C8h case    1:*/		return 0x820C79CC;
		  /* 820C79CCh */ case    2:  		/* mr R5, R29 */
		/* 820C79CCh case    2:*/		regs.R5 = regs.R29;
		/* 820C79CCh case    2:*/		return 0x820C79D0;
		  /* 820C79D0h */ case    3:  		/* mr R4, R30 */
		/* 820C79D0h case    3:*/		regs.R4 = regs.R30;
		/* 820C79D0h case    3:*/		return 0x820C79D4;
		  /* 820C79D4h */ case    4:  		/* mr R3, R31 */
		/* 820C79D4h case    4:*/		regs.R3 = regs.R31;
		/* 820C79D4h case    4:*/		return 0x820C79D8;
		  /* 820C79D8h */ case    5:  		/* bl -9224 */
		/* 820C79D8h case    5:*/		regs.LR = 0x820C79DC; return 0x820C55D0;
		/* 820C79D8h case    5:*/		return 0x820C79DC;
		  /* 820C79DCh */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C79DCh case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C79DCh case    6:*/		return 0x820C79E0;
		  /* 820C79E0h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C79E0h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C79B8;  }
		/* 820C79E0h case    7:*/		return 0x820C79E4;
		  /* 820C79E4h */ case    8:  		/* b 8 */
		/* 820C79E4h case    8:*/		return 0x820C79EC;
		/* 820C79E4h case    8:*/		return 0x820C79E8;
	}
	return 0x820C79E8;
} // Block from 820C79C4h-820C79E8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C79E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C79E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C79E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C79E8);
		  /* 820C79E8h */ case    0:  		/* li R3, 0 */
		/* 820C79E8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C79E8h case    0:*/		return 0x820C79EC;
	}
	return 0x820C79EC;
} // Block from 820C79E8h-820C79ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C79ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C79EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C79EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C79EC);
		  /* 820C79ECh */ case    0:  		/* addi R1, R1, 128 */
		/* 820C79ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C79ECh case    0:*/		return 0x820C79F0;
		  /* 820C79F0h */ case    1:  		/* b -223048 */
		/* 820C79F0h case    1:*/		return 0x820912A8;
		/* 820C79F0h case    1:*/		return 0x820C79F4;
		  /* 820C79F4h */ case    2:  		/* nop */
		/* 820C79F4h case    2:*/		cpu::op::nop();
		/* 820C79F4h case    2:*/		return 0x820C79F8;
	}
	return 0x820C79F8;
} // Block from 820C79ECh-820C79F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C79F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C79F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C79F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C79F8);
		  /* 820C79F8h */ case    0:  		/* mfspr R12, LR */
		/* 820C79F8h case    0:*/		regs.R12 = regs.LR;
		/* 820C79F8h case    0:*/		return 0x820C79FC;
		  /* 820C79FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C79FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C79FCh case    1:*/		return 0x820C7A00;
		  /* 820C7A00h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C7A00h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C7A00h case    2:*/		return 0x820C7A04;
		  /* 820C7A04h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C7A04h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C7A04h case    3:*/		return 0x820C7A08;
		  /* 820C7A08h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C7A08h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C7A08h case    4:*/		return 0x820C7A0C;
		  /* 820C7A0Ch */ case    5:  		/* stfs FR1, <#[R1 + 156]> */
		/* 820C7A0Ch case    5:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R1 + 0x0000009C) );
		/* 820C7A0Ch case    5:*/		return 0x820C7A10;
		  /* 820C7A10h */ case    6:  		/* mr R30, R4 */
		/* 820C7A10h case    6:*/		regs.R30 = regs.R4;
		/* 820C7A10h case    6:*/		return 0x820C7A14;
		  /* 820C7A14h */ case    7:  		/* nor R31, R5, R5 */
		/* 820C7A14h case    7:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7A14h case    7:*/		return 0x820C7A18;
		  /* 820C7A18h */ case    8:  		/* b 16 */
		/* 820C7A18h case    8:*/		return 0x820C7A28;
		/* 820C7A18h case    8:*/		return 0x820C7A1C;
		  /* 820C7A1Ch */ case    9:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C7A1Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C7A1Ch case    9:*/		return 0x820C7A20;
		  /* 820C7A20h */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 820C7A20h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7A20h case   10:*/		return 0x820C7A24;
		  /* 820C7A24h */ case   11:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7A24h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C7A4C;  }
		/* 820C7A24h case   11:*/		return 0x820C7A28;
	}
	return 0x820C7A28;
} // Block from 820C79F8h-820C7A28h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C7A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7A28);
		  /* 820C7A28h */ case    0:  		/* li R7, 0 */
		/* 820C7A28h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7A28h case    0:*/		return 0x820C7A2C;
		  /* 820C7A2Ch */ case    1:  		/* li R6, 1 */
		/* 820C7A2Ch case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820C7A2Ch case    1:*/		return 0x820C7A30;
		  /* 820C7A30h */ case    2:  		/* addi R5, R1, 156 */
		/* 820C7A30h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x9C);
		/* 820C7A30h case    2:*/		return 0x820C7A34;
		  /* 820C7A34h */ case    3:  		/* mr R4, R30 */
		/* 820C7A34h case    3:*/		regs.R4 = regs.R30;
		/* 820C7A34h case    3:*/		return 0x820C7A38;
		  /* 820C7A38h */ case    4:  		/* mr R3, R31 */
		/* 820C7A38h case    4:*/		regs.R3 = regs.R31;
		/* 820C7A38h case    4:*/		return 0x820C7A3C;
		  /* 820C7A3Ch */ case    5:  		/* bl -8412 */
		/* 820C7A3Ch case    5:*/		regs.LR = 0x820C7A40; return 0x820C5960;
		/* 820C7A3Ch case    5:*/		return 0x820C7A40;
		  /* 820C7A40h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C7A40h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C7A40h case    6:*/		return 0x820C7A44;
		  /* 820C7A44h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7A44h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C7A1C;  }
		/* 820C7A44h case    7:*/		return 0x820C7A48;
		  /* 820C7A48h */ case    8:  		/* b 8 */
		/* 820C7A48h case    8:*/		return 0x820C7A50;
		/* 820C7A48h case    8:*/		return 0x820C7A4C;
	}
	return 0x820C7A4C;
} // Block from 820C7A28h-820C7A4Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7A4C);
		  /* 820C7A4Ch */ case    0:  		/* li R3, 0 */
		/* 820C7A4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7A4Ch case    0:*/		return 0x820C7A50;
	}
	return 0x820C7A50;
} // Block from 820C7A4Ch-820C7A50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7A50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7A50);
		  /* 820C7A50h */ case    0:  		/* addi R1, R1, 112 */
		/* 820C7A50h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C7A50h case    0:*/		return 0x820C7A54;
		  /* 820C7A54h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C7A54h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C7A54h case    1:*/		return 0x820C7A58;
		  /* 820C7A58h */ case    2:  		/* mtspr LR, R12 */
		/* 820C7A58h case    2:*/		regs.LR = regs.R12;
		/* 820C7A58h case    2:*/		return 0x820C7A5C;
		  /* 820C7A5Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820C7A5Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C7A5Ch case    3:*/		return 0x820C7A60;
		  /* 820C7A60h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820C7A60h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C7A60h case    4:*/		return 0x820C7A64;
		  /* 820C7A64h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C7A64h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C7A64h case    5:*/		return 0x820C7A68;
	}
	return 0x820C7A68;
} // Block from 820C7A50h-820C7A68h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C7A68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7A68);
		  /* 820C7A68h */ case    0:  		/* mfspr R12, LR */
		/* 820C7A68h case    0:*/		regs.R12 = regs.LR;
		/* 820C7A68h case    0:*/		return 0x820C7A6C;
		  /* 820C7A6Ch */ case    1:  		/* bl -223252 */
		/* 820C7A6Ch case    1:*/		regs.LR = 0x820C7A70; return 0x82091258;
		/* 820C7A6Ch case    1:*/		return 0x820C7A70;
		  /* 820C7A70h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C7A70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C7A70h case    2:*/		return 0x820C7A74;
		  /* 820C7A74h */ case    3:  		/* mr R30, R4 */
		/* 820C7A74h case    3:*/		regs.R30 = regs.R4;
		/* 820C7A74h case    3:*/		return 0x820C7A78;
		  /* 820C7A78h */ case    4:  		/* mr R29, R6 */
		/* 820C7A78h case    4:*/		regs.R29 = regs.R6;
		/* 820C7A78h case    4:*/		return 0x820C7A7C;
		  /* 820C7A7Ch */ case    5:  		/* mr R28, R7 */
		/* 820C7A7Ch case    5:*/		regs.R28 = regs.R7;
		/* 820C7A7Ch case    5:*/		return 0x820C7A80;
		  /* 820C7A80h */ case    6:  		/* nor R31, R5, R5 */
		/* 820C7A80h case    6:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7A80h case    6:*/		return 0x820C7A84;
		  /* 820C7A84h */ case    7:  		/* b 16 */
		/* 820C7A84h case    7:*/		return 0x820C7A94;
		/* 820C7A84h case    7:*/		return 0x820C7A88;
		  /* 820C7A88h */ case    8:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C7A88h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C7A88h case    8:*/		return 0x820C7A8C;
		  /* 820C7A8Ch */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 820C7A8Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7A8Ch case    9:*/		return 0x820C7A90;
		  /* 820C7A90h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7A90h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C7AB8;  }
		/* 820C7A90h case   10:*/		return 0x820C7A94;
	}
	return 0x820C7A94;
} // Block from 820C7A68h-820C7A94h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C7A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7A94);
		  /* 820C7A94h */ case    0:  		/* li R7, 0 */
		/* 820C7A94h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7A94h case    0:*/		return 0x820C7A98;
		  /* 820C7A98h */ case    1:  		/* mr R6, R28 */
		/* 820C7A98h case    1:*/		regs.R6 = regs.R28;
		/* 820C7A98h case    1:*/		return 0x820C7A9C;
		  /* 820C7A9Ch */ case    2:  		/* mr R5, R29 */
		/* 820C7A9Ch case    2:*/		regs.R5 = regs.R29;
		/* 820C7A9Ch case    2:*/		return 0x820C7AA0;
		  /* 820C7AA0h */ case    3:  		/* mr R4, R30 */
		/* 820C7AA0h case    3:*/		regs.R4 = regs.R30;
		/* 820C7AA0h case    3:*/		return 0x820C7AA4;
		  /* 820C7AA4h */ case    4:  		/* mr R3, R31 */
		/* 820C7AA4h case    4:*/		regs.R3 = regs.R31;
		/* 820C7AA4h case    4:*/		return 0x820C7AA8;
		  /* 820C7AA8h */ case    5:  		/* bl -8520 */
		/* 820C7AA8h case    5:*/		regs.LR = 0x820C7AAC; return 0x820C5960;
		/* 820C7AA8h case    5:*/		return 0x820C7AAC;
		  /* 820C7AACh */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C7AACh case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C7AACh case    6:*/		return 0x820C7AB0;
		  /* 820C7AB0h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7AB0h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C7A88;  }
		/* 820C7AB0h case    7:*/		return 0x820C7AB4;
		  /* 820C7AB4h */ case    8:  		/* b 8 */
		/* 820C7AB4h case    8:*/		return 0x820C7ABC;
		/* 820C7AB4h case    8:*/		return 0x820C7AB8;
	}
	return 0x820C7AB8;
} // Block from 820C7A94h-820C7AB8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7AB8);
		  /* 820C7AB8h */ case    0:  		/* li R3, 0 */
		/* 820C7AB8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7AB8h case    0:*/		return 0x820C7ABC;
	}
	return 0x820C7ABC;
} // Block from 820C7AB8h-820C7ABCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7ABC);
		  /* 820C7ABCh */ case    0:  		/* addi R1, R1, 128 */
		/* 820C7ABCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C7ABCh case    0:*/		return 0x820C7AC0;
		  /* 820C7AC0h */ case    1:  		/* b -223256 */
		/* 820C7AC0h case    1:*/		return 0x820912A8;
		/* 820C7AC0h case    1:*/		return 0x820C7AC4;
		  /* 820C7AC4h */ case    2:  		/* nop */
		/* 820C7AC4h case    2:*/		cpu::op::nop();
		/* 820C7AC4h case    2:*/		return 0x820C7AC8;
	}
	return 0x820C7AC8;
} // Block from 820C7ABCh-820C7AC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7AC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7AC8);
		  /* 820C7AC8h */ case    0:  		/* mfspr R12, LR */
		/* 820C7AC8h case    0:*/		regs.R12 = regs.LR;
		/* 820C7AC8h case    0:*/		return 0x820C7ACC;
		  /* 820C7ACCh */ case    1:  		/* bl -223344 */
		/* 820C7ACCh case    1:*/		regs.LR = 0x820C7AD0; return 0x8209125C;
		/* 820C7ACCh case    1:*/		return 0x820C7AD0;
		  /* 820C7AD0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C7AD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C7AD0h case    2:*/		return 0x820C7AD4;
		  /* 820C7AD4h */ case    3:  		/* mr R30, R4 */
		/* 820C7AD4h case    3:*/		regs.R30 = regs.R4;
		/* 820C7AD4h case    3:*/		return 0x820C7AD8;
		  /* 820C7AD8h */ case    4:  		/* mr R29, R6 */
		/* 820C7AD8h case    4:*/		regs.R29 = regs.R6;
		/* 820C7AD8h case    4:*/		return 0x820C7ADC;
		  /* 820C7ADCh */ case    5:  		/* nor R31, R5, R5 */
		/* 820C7ADCh case    5:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7ADCh case    5:*/		return 0x820C7AE0;
		  /* 820C7AE0h */ case    6:  		/* b 16 */
		/* 820C7AE0h case    6:*/		return 0x820C7AF0;
		/* 820C7AE0h case    6:*/		return 0x820C7AE4;
		  /* 820C7AE4h */ case    7:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C7AE4h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C7AE4h case    7:*/		return 0x820C7AE8;
		  /* 820C7AE8h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 820C7AE8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7AE8h case    8:*/		return 0x820C7AEC;
		  /* 820C7AECh */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7AECh case    9:*/		if ( regs.CR[6].eq ) { return 0x820C7B14;  }
		/* 820C7AECh case    9:*/		return 0x820C7AF0;
	}
	return 0x820C7AF0;
} // Block from 820C7AC8h-820C7AF0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C7AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7AF0);
		  /* 820C7AF0h */ case    0:  		/* li R7, 0 */
		/* 820C7AF0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7AF0h case    0:*/		return 0x820C7AF4;
		  /* 820C7AF4h */ case    1:  		/* li R6, 1 */
		/* 820C7AF4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820C7AF4h case    1:*/		return 0x820C7AF8;
		  /* 820C7AF8h */ case    2:  		/* mr R5, R29 */
		/* 820C7AF8h case    2:*/		regs.R5 = regs.R29;
		/* 820C7AF8h case    2:*/		return 0x820C7AFC;
		  /* 820C7AFCh */ case    3:  		/* mr R4, R30 */
		/* 820C7AFCh case    3:*/		regs.R4 = regs.R30;
		/* 820C7AFCh case    3:*/		return 0x820C7B00;
		  /* 820C7B00h */ case    4:  		/* mr R3, R31 */
		/* 820C7B00h case    4:*/		regs.R3 = regs.R31;
		/* 820C7B00h case    4:*/		return 0x820C7B04;
		  /* 820C7B04h */ case    5:  		/* bl -7692 */
		/* 820C7B04h case    5:*/		regs.LR = 0x820C7B08; return 0x820C5CF8;
		/* 820C7B04h case    5:*/		return 0x820C7B08;
		  /* 820C7B08h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C7B08h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C7B08h case    6:*/		return 0x820C7B0C;
		  /* 820C7B0Ch */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7B0Ch case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C7AE4;  }
		/* 820C7B0Ch case    7:*/		return 0x820C7B10;
		  /* 820C7B10h */ case    8:  		/* b 8 */
		/* 820C7B10h case    8:*/		return 0x820C7B18;
		/* 820C7B10h case    8:*/		return 0x820C7B14;
	}
	return 0x820C7B14;
} // Block from 820C7AF0h-820C7B14h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7B14);
		  /* 820C7B14h */ case    0:  		/* li R3, 0 */
		/* 820C7B14h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7B14h case    0:*/		return 0x820C7B18;
	}
	return 0x820C7B18;
} // Block from 820C7B14h-820C7B18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7B18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7B18);
		  /* 820C7B18h */ case    0:  		/* addi R1, R1, 112 */
		/* 820C7B18h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C7B18h case    0:*/		return 0x820C7B1C;
		  /* 820C7B1Ch */ case    1:  		/* b -223344 */
		/* 820C7B1Ch case    1:*/		return 0x820912AC;
		/* 820C7B1Ch case    1:*/		return 0x820C7B20;
	}
	return 0x820C7B20;
} // Block from 820C7B18h-820C7B20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C7B20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7B20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7B20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7B20);
		  /* 820C7B20h */ case    0:  		/* mfspr R12, LR */
		/* 820C7B20h case    0:*/		regs.R12 = regs.LR;
		/* 820C7B20h case    0:*/		return 0x820C7B24;
		  /* 820C7B24h */ case    1:  		/* bl -223436 */
		/* 820C7B24h case    1:*/		regs.LR = 0x820C7B28; return 0x82091258;
		/* 820C7B24h case    1:*/		return 0x820C7B28;
		  /* 820C7B28h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C7B28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C7B28h case    2:*/		return 0x820C7B2C;
		  /* 820C7B2Ch */ case    3:  		/* mr R30, R4 */
		/* 820C7B2Ch case    3:*/		regs.R30 = regs.R4;
		/* 820C7B2Ch case    3:*/		return 0x820C7B30;
		  /* 820C7B30h */ case    4:  		/* mr R29, R6 */
		/* 820C7B30h case    4:*/		regs.R29 = regs.R6;
		/* 820C7B30h case    4:*/		return 0x820C7B34;
		  /* 820C7B34h */ case    5:  		/* mr R28, R7 */
		/* 820C7B34h case    5:*/		regs.R28 = regs.R7;
		/* 820C7B34h case    5:*/		return 0x820C7B38;
		  /* 820C7B38h */ case    6:  		/* nor R31, R5, R5 */
		/* 820C7B38h case    6:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7B38h case    6:*/		return 0x820C7B3C;
		  /* 820C7B3Ch */ case    7:  		/* b 16 */
		/* 820C7B3Ch case    7:*/		return 0x820C7B4C;
		/* 820C7B3Ch case    7:*/		return 0x820C7B40;
		  /* 820C7B40h */ case    8:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C7B40h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C7B40h case    8:*/		return 0x820C7B44;
		  /* 820C7B44h */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 820C7B44h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7B44h case    9:*/		return 0x820C7B48;
		  /* 820C7B48h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7B48h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C7B70;  }
		/* 820C7B48h case   10:*/		return 0x820C7B4C;
	}
	return 0x820C7B4C;
} // Block from 820C7B20h-820C7B4Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C7B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7B4C);
		  /* 820C7B4Ch */ case    0:  		/* li R7, 0 */
		/* 820C7B4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7B4Ch case    0:*/		return 0x820C7B50;
		  /* 820C7B50h */ case    1:  		/* mr R6, R28 */
		/* 820C7B50h case    1:*/		regs.R6 = regs.R28;
		/* 820C7B50h case    1:*/		return 0x820C7B54;
		  /* 820C7B54h */ case    2:  		/* mr R5, R29 */
		/* 820C7B54h case    2:*/		regs.R5 = regs.R29;
		/* 820C7B54h case    2:*/		return 0x820C7B58;
		  /* 820C7B58h */ case    3:  		/* mr R4, R30 */
		/* 820C7B58h case    3:*/		regs.R4 = regs.R30;
		/* 820C7B58h case    3:*/		return 0x820C7B5C;
		  /* 820C7B5Ch */ case    4:  		/* mr R3, R31 */
		/* 820C7B5Ch case    4:*/		regs.R3 = regs.R31;
		/* 820C7B5Ch case    4:*/		return 0x820C7B60;
		  /* 820C7B60h */ case    5:  		/* bl -7784 */
		/* 820C7B60h case    5:*/		regs.LR = 0x820C7B64; return 0x820C5CF8;
		/* 820C7B60h case    5:*/		return 0x820C7B64;
		  /* 820C7B64h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C7B64h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C7B64h case    6:*/		return 0x820C7B68;
		  /* 820C7B68h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7B68h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C7B40;  }
		/* 820C7B68h case    7:*/		return 0x820C7B6C;
		  /* 820C7B6Ch */ case    8:  		/* b 8 */
		/* 820C7B6Ch case    8:*/		return 0x820C7B74;
		/* 820C7B6Ch case    8:*/		return 0x820C7B70;
	}
	return 0x820C7B70;
} // Block from 820C7B4Ch-820C7B70h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7B70);
		  /* 820C7B70h */ case    0:  		/* li R3, 0 */
		/* 820C7B70h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7B70h case    0:*/		return 0x820C7B74;
	}
	return 0x820C7B74;
} // Block from 820C7B70h-820C7B74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7B74);
		  /* 820C7B74h */ case    0:  		/* addi R1, R1, 128 */
		/* 820C7B74h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C7B74h case    0:*/		return 0x820C7B78;
		  /* 820C7B78h */ case    1:  		/* b -223440 */
		/* 820C7B78h case    1:*/		return 0x820912A8;
		/* 820C7B78h case    1:*/		return 0x820C7B7C;
		  /* 820C7B7Ch */ case    2:  		/* nop */
		/* 820C7B7Ch case    2:*/		cpu::op::nop();
		/* 820C7B7Ch case    2:*/		return 0x820C7B80;
	}
	return 0x820C7B80;
} // Block from 820C7B74h-820C7B80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7B80);
		  /* 820C7B80h */ case    0:  		/* mfspr R12, LR */
		/* 820C7B80h case    0:*/		regs.R12 = regs.LR;
		/* 820C7B80h case    0:*/		return 0x820C7B84;
		  /* 820C7B84h */ case    1:  		/* bl -223528 */
		/* 820C7B84h case    1:*/		regs.LR = 0x820C7B88; return 0x8209125C;
		/* 820C7B84h case    1:*/		return 0x820C7B88;
		  /* 820C7B88h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C7B88h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C7B88h case    2:*/		return 0x820C7B8C;
		  /* 820C7B8Ch */ case    3:  		/* mr R30, R4 */
		/* 820C7B8Ch case    3:*/		regs.R30 = regs.R4;
		/* 820C7B8Ch case    3:*/		return 0x820C7B90;
		  /* 820C7B90h */ case    4:  		/* mr R29, R6 */
		/* 820C7B90h case    4:*/		regs.R29 = regs.R6;
		/* 820C7B90h case    4:*/		return 0x820C7B94;
		  /* 820C7B94h */ case    5:  		/* nor R31, R5, R5 */
		/* 820C7B94h case    5:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7B94h case    5:*/		return 0x820C7B98;
		  /* 820C7B98h */ case    6:  		/* b 16 */
		/* 820C7B98h case    6:*/		return 0x820C7BA8;
		/* 820C7B98h case    6:*/		return 0x820C7B9C;
		  /* 820C7B9Ch */ case    7:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C7B9Ch case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C7B9Ch case    7:*/		return 0x820C7BA0;
		  /* 820C7BA0h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 820C7BA0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7BA0h case    8:*/		return 0x820C7BA4;
		  /* 820C7BA4h */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7BA4h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C7BCC;  }
		/* 820C7BA4h case    9:*/		return 0x820C7BA8;
	}
	return 0x820C7BA8;
} // Block from 820C7B80h-820C7BA8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C7BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7BA8);
		  /* 820C7BA8h */ case    0:  		/* li R7, 0 */
		/* 820C7BA8h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7BA8h case    0:*/		return 0x820C7BAC;
		  /* 820C7BACh */ case    1:  		/* li R6, 1 */
		/* 820C7BACh case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820C7BACh case    1:*/		return 0x820C7BB0;
		  /* 820C7BB0h */ case    2:  		/* mr R5, R29 */
		/* 820C7BB0h case    2:*/		regs.R5 = regs.R29;
		/* 820C7BB0h case    2:*/		return 0x820C7BB4;
		  /* 820C7BB4h */ case    3:  		/* mr R4, R30 */
		/* 820C7BB4h case    3:*/		regs.R4 = regs.R30;
		/* 820C7BB4h case    3:*/		return 0x820C7BB8;
		  /* 820C7BB8h */ case    4:  		/* mr R3, R31 */
		/* 820C7BB8h case    4:*/		regs.R3 = regs.R31;
		/* 820C7BB8h case    4:*/		return 0x820C7BBC;
		  /* 820C7BBCh */ case    5:  		/* bl -6684 */
		/* 820C7BBCh case    5:*/		regs.LR = 0x820C7BC0; return 0x820C61A0;
		/* 820C7BBCh case    5:*/		return 0x820C7BC0;
		  /* 820C7BC0h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C7BC0h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C7BC0h case    6:*/		return 0x820C7BC4;
		  /* 820C7BC4h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7BC4h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C7B9C;  }
		/* 820C7BC4h case    7:*/		return 0x820C7BC8;
		  /* 820C7BC8h */ case    8:  		/* b 8 */
		/* 820C7BC8h case    8:*/		return 0x820C7BD0;
		/* 820C7BC8h case    8:*/		return 0x820C7BCC;
	}
	return 0x820C7BCC;
} // Block from 820C7BA8h-820C7BCCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7BCC);
		  /* 820C7BCCh */ case    0:  		/* li R3, 0 */
		/* 820C7BCCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7BCCh case    0:*/		return 0x820C7BD0;
	}
	return 0x820C7BD0;
} // Block from 820C7BCCh-820C7BD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7BD0);
		  /* 820C7BD0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820C7BD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C7BD0h case    0:*/		return 0x820C7BD4;
		  /* 820C7BD4h */ case    1:  		/* b -223528 */
		/* 820C7BD4h case    1:*/		return 0x820912AC;
		/* 820C7BD4h case    1:*/		return 0x820C7BD8;
	}
	return 0x820C7BD8;
} // Block from 820C7BD0h-820C7BD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C7BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7BD8);
		  /* 820C7BD8h */ case    0:  		/* mfspr R12, LR */
		/* 820C7BD8h case    0:*/		regs.R12 = regs.LR;
		/* 820C7BD8h case    0:*/		return 0x820C7BDC;
		  /* 820C7BDCh */ case    1:  		/* bl -223620 */
		/* 820C7BDCh case    1:*/		regs.LR = 0x820C7BE0; return 0x82091258;
		/* 820C7BDCh case    1:*/		return 0x820C7BE0;
		  /* 820C7BE0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C7BE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C7BE0h case    2:*/		return 0x820C7BE4;
		  /* 820C7BE4h */ case    3:  		/* mr R30, R4 */
		/* 820C7BE4h case    3:*/		regs.R30 = regs.R4;
		/* 820C7BE4h case    3:*/		return 0x820C7BE8;
		  /* 820C7BE8h */ case    4:  		/* mr R29, R6 */
		/* 820C7BE8h case    4:*/		regs.R29 = regs.R6;
		/* 820C7BE8h case    4:*/		return 0x820C7BEC;
		  /* 820C7BECh */ case    5:  		/* mr R28, R7 */
		/* 820C7BECh case    5:*/		regs.R28 = regs.R7;
		/* 820C7BECh case    5:*/		return 0x820C7BF0;
		  /* 820C7BF0h */ case    6:  		/* nor R31, R5, R5 */
		/* 820C7BF0h case    6:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7BF0h case    6:*/		return 0x820C7BF4;
		  /* 820C7BF4h */ case    7:  		/* b 16 */
		/* 820C7BF4h case    7:*/		return 0x820C7C04;
		/* 820C7BF4h case    7:*/		return 0x820C7BF8;
		  /* 820C7BF8h */ case    8:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C7BF8h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C7BF8h case    8:*/		return 0x820C7BFC;
		  /* 820C7BFCh */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 820C7BFCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7BFCh case    9:*/		return 0x820C7C00;
		  /* 820C7C00h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7C00h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C7C28;  }
		/* 820C7C00h case   10:*/		return 0x820C7C04;
	}
	return 0x820C7C04;
} // Block from 820C7BD8h-820C7C04h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C7C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7C04);
		  /* 820C7C04h */ case    0:  		/* li R7, 0 */
		/* 820C7C04h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7C04h case    0:*/		return 0x820C7C08;
		  /* 820C7C08h */ case    1:  		/* mr R6, R28 */
		/* 820C7C08h case    1:*/		regs.R6 = regs.R28;
		/* 820C7C08h case    1:*/		return 0x820C7C0C;
		  /* 820C7C0Ch */ case    2:  		/* mr R5, R29 */
		/* 820C7C0Ch case    2:*/		regs.R5 = regs.R29;
		/* 820C7C0Ch case    2:*/		return 0x820C7C10;
		  /* 820C7C10h */ case    3:  		/* mr R4, R30 */
		/* 820C7C10h case    3:*/		regs.R4 = regs.R30;
		/* 820C7C10h case    3:*/		return 0x820C7C14;
		  /* 820C7C14h */ case    4:  		/* mr R3, R31 */
		/* 820C7C14h case    4:*/		regs.R3 = regs.R31;
		/* 820C7C14h case    4:*/		return 0x820C7C18;
		  /* 820C7C18h */ case    5:  		/* bl -6776 */
		/* 820C7C18h case    5:*/		regs.LR = 0x820C7C1C; return 0x820C61A0;
		/* 820C7C18h case    5:*/		return 0x820C7C1C;
		  /* 820C7C1Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C7C1Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C7C1Ch case    6:*/		return 0x820C7C20;
		  /* 820C7C20h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7C20h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C7BF8;  }
		/* 820C7C20h case    7:*/		return 0x820C7C24;
		  /* 820C7C24h */ case    8:  		/* b 8 */
		/* 820C7C24h case    8:*/		return 0x820C7C2C;
		/* 820C7C24h case    8:*/		return 0x820C7C28;
	}
	return 0x820C7C28;
} // Block from 820C7C04h-820C7C28h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7C28h
// Function '?Set@?$SetTyped@$02$02$03$03$00@D3DXShader@@SAJPAVCConstant@2@PBX1II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7C28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7C28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7C28);
		  /* 820C7C28h */ case    0:  		/* li R3, 0 */
		/* 820C7C28h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7C28h case    0:*/		return 0x820C7C2C;
	}
	return 0x820C7C2C;
} // Block from 820C7C28h-820C7C2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7C2C);
		  /* 820C7C2Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 820C7C2Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C7C2Ch case    0:*/		return 0x820C7C30;
		  /* 820C7C30h */ case    1:  		/* b -223624 */
		/* 820C7C30h case    1:*/		return 0x820912A8;
		/* 820C7C30h case    1:*/		return 0x820C7C34;
		  /* 820C7C34h */ case    2:  		/* nop */
		/* 820C7C34h case    2:*/		cpu::op::nop();
		/* 820C7C34h case    2:*/		return 0x820C7C38;
	}
	return 0x820C7C38;
} // Block from 820C7C2Ch-820C7C38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7C38);
		  /* 820C7C38h */ case    0:  		/* mfspr R12, LR */
		/* 820C7C38h case    0:*/		regs.R12 = regs.LR;
		/* 820C7C38h case    0:*/		return 0x820C7C3C;
		  /* 820C7C3Ch */ case    1:  		/* bl -223716 */
		/* 820C7C3Ch case    1:*/		regs.LR = 0x820C7C40; return 0x82091258;
		/* 820C7C3Ch case    1:*/		return 0x820C7C40;
		  /* 820C7C40h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C7C40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C7C40h case    2:*/		return 0x820C7C44;
		  /* 820C7C44h */ case    3:  		/* mr R30, R4 */
		/* 820C7C44h case    3:*/		regs.R30 = regs.R4;
		/* 820C7C44h case    3:*/		return 0x820C7C48;
		  /* 820C7C48h */ case    4:  		/* mr R29, R6 */
		/* 820C7C48h case    4:*/		regs.R29 = regs.R6;
		/* 820C7C48h case    4:*/		return 0x820C7C4C;
		  /* 820C7C4Ch */ case    5:  		/* mr R28, R7 */
		/* 820C7C4Ch case    5:*/		regs.R28 = regs.R7;
		/* 820C7C4Ch case    5:*/		return 0x820C7C50;
		  /* 820C7C50h */ case    6:  		/* nor R31, R5, R5 */
		/* 820C7C50h case    6:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7C50h case    6:*/		return 0x820C7C54;
		  /* 820C7C54h */ case    7:  		/* b 16 */
		/* 820C7C54h case    7:*/		return 0x820C7C64;
		/* 820C7C54h case    7:*/		return 0x820C7C58;
		  /* 820C7C58h */ case    8:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C7C58h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C7C58h case    8:*/		return 0x820C7C5C;
		  /* 820C7C5Ch */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 820C7C5Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7C5Ch case    9:*/		return 0x820C7C60;
		  /* 820C7C60h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7C60h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C7C88;  }
		/* 820C7C60h case   10:*/		return 0x820C7C64;
	}
	return 0x820C7C64;
} // Block from 820C7C38h-820C7C64h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C7C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7C64);
		  /* 820C7C64h */ case    0:  		/* li R7, 0 */
		/* 820C7C64h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7C64h case    0:*/		return 0x820C7C68;
		  /* 820C7C68h */ case    1:  		/* mr R6, R28 */
		/* 820C7C68h case    1:*/		regs.R6 = regs.R28;
		/* 820C7C68h case    1:*/		return 0x820C7C6C;
		  /* 820C7C6Ch */ case    2:  		/* mr R5, R29 */
		/* 820C7C6Ch case    2:*/		regs.R5 = regs.R29;
		/* 820C7C6Ch case    2:*/		return 0x820C7C70;
		  /* 820C7C70h */ case    3:  		/* mr R4, R30 */
		/* 820C7C70h case    3:*/		regs.R4 = regs.R30;
		/* 820C7C70h case    3:*/		return 0x820C7C74;
		  /* 820C7C74h */ case    4:  		/* mr R3, R31 */
		/* 820C7C74h case    4:*/		regs.R3 = regs.R31;
		/* 820C7C74h case    4:*/		return 0x820C7C78;
		  /* 820C7C78h */ case    5:  		/* bl -5472 */
		/* 820C7C78h case    5:*/		regs.LR = 0x820C7C7C; return 0x820C6718;
		/* 820C7C78h case    5:*/		return 0x820C7C7C;
		  /* 820C7C7Ch */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C7C7Ch case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C7C7Ch case    6:*/		return 0x820C7C80;
		  /* 820C7C80h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7C80h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C7C58;  }
		/* 820C7C80h case    7:*/		return 0x820C7C84;
		  /* 820C7C84h */ case    8:  		/* b 8 */
		/* 820C7C84h case    8:*/		return 0x820C7C8C;
		/* 820C7C84h case    8:*/		return 0x820C7C88;
	}
	return 0x820C7C88;
} // Block from 820C7C64h-820C7C88h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7C88);
		  /* 820C7C88h */ case    0:  		/* li R3, 0 */
		/* 820C7C88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7C88h case    0:*/		return 0x820C7C8C;
	}
	return 0x820C7C8C;
} // Block from 820C7C88h-820C7C8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7C8C);
		  /* 820C7C8Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 820C7C8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C7C8Ch case    0:*/		return 0x820C7C90;
		  /* 820C7C90h */ case    1:  		/* b -223720 */
		/* 820C7C90h case    1:*/		return 0x820912A8;
		/* 820C7C90h case    1:*/		return 0x820C7C94;
		  /* 820C7C94h */ case    2:  		/* nop */
		/* 820C7C94h case    2:*/		cpu::op::nop();
		/* 820C7C94h case    2:*/		return 0x820C7C98;
	}
	return 0x820C7C98;
} // Block from 820C7C8Ch-820C7C98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7C98);
		  /* 820C7C98h */ case    0:  		/* mfspr R12, LR */
		/* 820C7C98h case    0:*/		regs.R12 = regs.LR;
		/* 820C7C98h case    0:*/		return 0x820C7C9C;
		  /* 820C7C9Ch */ case    1:  		/* bl -223808 */
		/* 820C7C9Ch case    1:*/		regs.LR = 0x820C7CA0; return 0x8209125C;
		/* 820C7C9Ch case    1:*/		return 0x820C7CA0;
		  /* 820C7CA0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C7CA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C7CA0h case    2:*/		return 0x820C7CA4;
		  /* 820C7CA4h */ case    3:  		/* mr R30, R4 */
		/* 820C7CA4h case    3:*/		regs.R30 = regs.R4;
		/* 820C7CA4h case    3:*/		return 0x820C7CA8;
		  /* 820C7CA8h */ case    4:  		/* mr R29, R6 */
		/* 820C7CA8h case    4:*/		regs.R29 = regs.R6;
		/* 820C7CA8h case    4:*/		return 0x820C7CAC;
		  /* 820C7CACh */ case    5:  		/* nor R31, R5, R5 */
		/* 820C7CACh case    5:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7CACh case    5:*/		return 0x820C7CB0;
		  /* 820C7CB0h */ case    6:  		/* b 16 */
		/* 820C7CB0h case    6:*/		return 0x820C7CC0;
		/* 820C7CB0h case    6:*/		return 0x820C7CB4;
		  /* 820C7CB4h */ case    7:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C7CB4h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C7CB4h case    7:*/		return 0x820C7CB8;
		  /* 820C7CB8h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 820C7CB8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7CB8h case    8:*/		return 0x820C7CBC;
		  /* 820C7CBCh */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7CBCh case    9:*/		if ( regs.CR[6].eq ) { return 0x820C7CE4;  }
		/* 820C7CBCh case    9:*/		return 0x820C7CC0;
	}
	return 0x820C7CC0;
} // Block from 820C7C98h-820C7CC0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C7CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7CC0);
		  /* 820C7CC0h */ case    0:  		/* li R7, 0 */
		/* 820C7CC0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7CC0h case    0:*/		return 0x820C7CC4;
		  /* 820C7CC4h */ case    1:  		/* li R6, 1 */
		/* 820C7CC4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820C7CC4h case    1:*/		return 0x820C7CC8;
		  /* 820C7CC8h */ case    2:  		/* mr R5, R29 */
		/* 820C7CC8h case    2:*/		regs.R5 = regs.R29;
		/* 820C7CC8h case    2:*/		return 0x820C7CCC;
		  /* 820C7CCCh */ case    3:  		/* mr R4, R30 */
		/* 820C7CCCh case    3:*/		regs.R4 = regs.R30;
		/* 820C7CCCh case    3:*/		return 0x820C7CD0;
		  /* 820C7CD0h */ case    4:  		/* mr R3, R31 */
		/* 820C7CD0h case    4:*/		regs.R3 = regs.R31;
		/* 820C7CD0h case    4:*/		return 0x820C7CD4;
		  /* 820C7CD4h */ case    5:  		/* bl -4284 */
		/* 820C7CD4h case    5:*/		regs.LR = 0x820C7CD8; return 0x820C6C18;
		/* 820C7CD4h case    5:*/		return 0x820C7CD8;
		  /* 820C7CD8h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C7CD8h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C7CD8h case    6:*/		return 0x820C7CDC;
		  /* 820C7CDCh */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7CDCh case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C7CB4;  }
		/* 820C7CDCh case    7:*/		return 0x820C7CE0;
		  /* 820C7CE0h */ case    8:  		/* b 8 */
		/* 820C7CE0h case    8:*/		return 0x820C7CE8;
		/* 820C7CE0h case    8:*/		return 0x820C7CE4;
	}
	return 0x820C7CE4;
} // Block from 820C7CC0h-820C7CE4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7CE4);
		  /* 820C7CE4h */ case    0:  		/* li R3, 0 */
		/* 820C7CE4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7CE4h case    0:*/		return 0x820C7CE8;
	}
	return 0x820C7CE8;
} // Block from 820C7CE4h-820C7CE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7CE8);
		  /* 820C7CE8h */ case    0:  		/* addi R1, R1, 112 */
		/* 820C7CE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C7CE8h case    0:*/		return 0x820C7CEC;
		  /* 820C7CECh */ case    1:  		/* b -223808 */
		/* 820C7CECh case    1:*/		return 0x820912AC;
		/* 820C7CECh case    1:*/		return 0x820C7CF0;
	}
	return 0x820C7CF0;
} // Block from 820C7CE8h-820C7CF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C7CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7CF0);
		  /* 820C7CF0h */ case    0:  		/* mfspr R12, LR */
		/* 820C7CF0h case    0:*/		regs.R12 = regs.LR;
		/* 820C7CF0h case    0:*/		return 0x820C7CF4;
		  /* 820C7CF4h */ case    1:  		/* bl -223900 */
		/* 820C7CF4h case    1:*/		regs.LR = 0x820C7CF8; return 0x82091258;
		/* 820C7CF4h case    1:*/		return 0x820C7CF8;
		  /* 820C7CF8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C7CF8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C7CF8h case    2:*/		return 0x820C7CFC;
		  /* 820C7CFCh */ case    3:  		/* mr R30, R4 */
		/* 820C7CFCh case    3:*/		regs.R30 = regs.R4;
		/* 820C7CFCh case    3:*/		return 0x820C7D00;
		  /* 820C7D00h */ case    4:  		/* mr R29, R6 */
		/* 820C7D00h case    4:*/		regs.R29 = regs.R6;
		/* 820C7D00h case    4:*/		return 0x820C7D04;
		  /* 820C7D04h */ case    5:  		/* mr R28, R7 */
		/* 820C7D04h case    5:*/		regs.R28 = regs.R7;
		/* 820C7D04h case    5:*/		return 0x820C7D08;
		  /* 820C7D08h */ case    6:  		/* nor R31, R5, R5 */
		/* 820C7D08h case    6:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7D08h case    6:*/		return 0x820C7D0C;
		  /* 820C7D0Ch */ case    7:  		/* b 16 */
		/* 820C7D0Ch case    7:*/		return 0x820C7D1C;
		/* 820C7D0Ch case    7:*/		return 0x820C7D10;
		  /* 820C7D10h */ case    8:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C7D10h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C7D10h case    8:*/		return 0x820C7D14;
		  /* 820C7D14h */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 820C7D14h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7D14h case    9:*/		return 0x820C7D18;
		  /* 820C7D18h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7D18h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C7D40;  }
		/* 820C7D18h case   10:*/		return 0x820C7D1C;
	}
	return 0x820C7D1C;
} // Block from 820C7CF0h-820C7D1Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C7D1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7D1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7D1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7D1C);
		  /* 820C7D1Ch */ case    0:  		/* li R7, 0 */
		/* 820C7D1Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7D1Ch case    0:*/		return 0x820C7D20;
		  /* 820C7D20h */ case    1:  		/* mr R6, R28 */
		/* 820C7D20h case    1:*/		regs.R6 = regs.R28;
		/* 820C7D20h case    1:*/		return 0x820C7D24;
		  /* 820C7D24h */ case    2:  		/* mr R5, R29 */
		/* 820C7D24h case    2:*/		regs.R5 = regs.R29;
		/* 820C7D24h case    2:*/		return 0x820C7D28;
		  /* 820C7D28h */ case    3:  		/* mr R4, R30 */
		/* 820C7D28h case    3:*/		regs.R4 = regs.R30;
		/* 820C7D28h case    3:*/		return 0x820C7D2C;
		  /* 820C7D2Ch */ case    4:  		/* mr R3, R31 */
		/* 820C7D2Ch case    4:*/		regs.R3 = regs.R31;
		/* 820C7D2Ch case    4:*/		return 0x820C7D30;
		  /* 820C7D30h */ case    5:  		/* bl -4376 */
		/* 820C7D30h case    5:*/		regs.LR = 0x820C7D34; return 0x820C6C18;
		/* 820C7D30h case    5:*/		return 0x820C7D34;
		  /* 820C7D34h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C7D34h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C7D34h case    6:*/		return 0x820C7D38;
		  /* 820C7D38h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7D38h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C7D10;  }
		/* 820C7D38h case    7:*/		return 0x820C7D3C;
		  /* 820C7D3Ch */ case    8:  		/* b 8 */
		/* 820C7D3Ch case    8:*/		return 0x820C7D44;
		/* 820C7D3Ch case    8:*/		return 0x820C7D40;
	}
	return 0x820C7D40;
} // Block from 820C7D1Ch-820C7D40h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7D40);
		  /* 820C7D40h */ case    0:  		/* li R3, 0 */
		/* 820C7D40h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7D40h case    0:*/		return 0x820C7D44;
	}
	return 0x820C7D44;
} // Block from 820C7D40h-820C7D44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7D44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7D44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7D44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7D44);
		  /* 820C7D44h */ case    0:  		/* addi R1, R1, 128 */
		/* 820C7D44h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C7D44h case    0:*/		return 0x820C7D48;
		  /* 820C7D48h */ case    1:  		/* b -223904 */
		/* 820C7D48h case    1:*/		return 0x820912A8;
		/* 820C7D48h case    1:*/		return 0x820C7D4C;
		  /* 820C7D4Ch */ case    2:  		/* nop */
		/* 820C7D4Ch case    2:*/		cpu::op::nop();
		/* 820C7D4Ch case    2:*/		return 0x820C7D50;
	}
	return 0x820C7D50;
} // Block from 820C7D44h-820C7D50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7D50);
		  /* 820C7D50h */ case    0:  		/* mfspr R12, LR */
		/* 820C7D50h case    0:*/		regs.R12 = regs.LR;
		/* 820C7D50h case    0:*/		return 0x820C7D54;
		  /* 820C7D54h */ case    1:  		/* bl -223996 */
		/* 820C7D54h case    1:*/		regs.LR = 0x820C7D58; return 0x82091258;
		/* 820C7D54h case    1:*/		return 0x820C7D58;
		  /* 820C7D58h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C7D58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C7D58h case    2:*/		return 0x820C7D5C;
		  /* 820C7D5Ch */ case    3:  		/* mr R30, R4 */
		/* 820C7D5Ch case    3:*/		regs.R30 = regs.R4;
		/* 820C7D5Ch case    3:*/		return 0x820C7D60;
		  /* 820C7D60h */ case    4:  		/* mr R29, R6 */
		/* 820C7D60h case    4:*/		regs.R29 = regs.R6;
		/* 820C7D60h case    4:*/		return 0x820C7D64;
		  /* 820C7D64h */ case    5:  		/* mr R28, R7 */
		/* 820C7D64h case    5:*/		regs.R28 = regs.R7;
		/* 820C7D64h case    5:*/		return 0x820C7D68;
		  /* 820C7D68h */ case    6:  		/* nor R31, R5, R5 */
		/* 820C7D68h case    6:*/		cpu::op::nor<0>(regs,&regs.R31,regs.R5,regs.R5);
		/* 820C7D68h case    6:*/		return 0x820C7D6C;
		  /* 820C7D6Ch */ case    7:  		/* b 16 */
		/* 820C7D6Ch case    7:*/		return 0x820C7D7C;
		/* 820C7D6Ch case    7:*/		return 0x820C7D70;
		  /* 820C7D70h */ case    8:  		/* lwz R31, <#[R31 + 36]> */
		/* 820C7D70h case    8:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000024) );
		/* 820C7D70h case    8:*/		return 0x820C7D74;
		  /* 820C7D74h */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 820C7D74h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C7D74h case    9:*/		return 0x820C7D78;
		  /* 820C7D78h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7D78h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C7DA0;  }
		/* 820C7D78h case   10:*/		return 0x820C7D7C;
	}
	return 0x820C7D7C;
} // Block from 820C7D50h-820C7D7Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C7D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7D7C);
		  /* 820C7D7Ch */ case    0:  		/* li R7, 0 */
		/* 820C7D7Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C7D7Ch case    0:*/		return 0x820C7D80;
		  /* 820C7D80h */ case    1:  		/* mr R6, R28 */
		/* 820C7D80h case    1:*/		regs.R6 = regs.R28;
		/* 820C7D80h case    1:*/		return 0x820C7D84;
		  /* 820C7D84h */ case    2:  		/* mr R5, R29 */
		/* 820C7D84h case    2:*/		regs.R5 = regs.R29;
		/* 820C7D84h case    2:*/		return 0x820C7D88;
		  /* 820C7D88h */ case    3:  		/* mr R4, R30 */
		/* 820C7D88h case    3:*/		regs.R4 = regs.R30;
		/* 820C7D88h case    3:*/		return 0x820C7D8C;
		  /* 820C7D8Ch */ case    4:  		/* mr R3, R31 */
		/* 820C7D8Ch case    4:*/		regs.R3 = regs.R31;
		/* 820C7D8Ch case    4:*/		return 0x820C7D90;
		  /* 820C7D90h */ case    5:  		/* bl -2960 */
		/* 820C7D90h case    5:*/		regs.LR = 0x820C7D94; return 0x820C7200;
		/* 820C7D90h case    5:*/		return 0x820C7D94;
		  /* 820C7D94h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C7D94h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C7D94h case    6:*/		return 0x820C7D98;
		  /* 820C7D98h */ case    7:  		/* bc 4, CR0_LT, -40 */
		/* 820C7D98h case    7:*/		if ( !regs.CR[0].lt ) { return 0x820C7D70;  }
		/* 820C7D98h case    7:*/		return 0x820C7D9C;
		  /* 820C7D9Ch */ case    8:  		/* b 8 */
		/* 820C7D9Ch case    8:*/		return 0x820C7DA4;
		/* 820C7D9Ch case    8:*/		return 0x820C7DA0;
	}
	return 0x820C7DA0;
} // Block from 820C7D7Ch-820C7DA0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C7DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7DA0);
		  /* 820C7DA0h */ case    0:  		/* li R3, 0 */
		/* 820C7DA0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C7DA0h case    0:*/		return 0x820C7DA4;
	}
	return 0x820C7DA4;
} // Block from 820C7DA0h-820C7DA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C7DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7DA4);
		  /* 820C7DA4h */ case    0:  		/* addi R1, R1, 128 */
		/* 820C7DA4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C7DA4h case    0:*/		return 0x820C7DA8;
		  /* 820C7DA8h */ case    1:  		/* b -224000 */
		/* 820C7DA8h case    1:*/		return 0x820912A8;
		/* 820C7DA8h case    1:*/		return 0x820C7DAC;
		  /* 820C7DACh */ case    2:  		/* nop */
		/* 820C7DACh case    2:*/		cpu::op::nop();
		/* 820C7DACh case    2:*/		return 0x820C7DB0;
	}
	return 0x820C7DB0;
} // Block from 820C7DA4h-820C7DB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7DB0);
		  /* 820C7DB0h */ case    0:  		/* mfspr R12, LR */
		/* 820C7DB0h case    0:*/		regs.R12 = regs.LR;
		/* 820C7DB0h case    0:*/		return 0x820C7DB4;
		  /* 820C7DB4h */ case    1:  		/* bl -224096 */
		/* 820C7DB4h case    1:*/		regs.LR = 0x820C7DB8; return 0x82091254;
		/* 820C7DB4h case    1:*/		return 0x820C7DB8;
		  /* 820C7DB8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C7DB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C7DB8h case    2:*/		return 0x820C7DBC;
		  /* 820C7DBCh */ case    3:  		/* lhz R11, <#[R5 + 10]> */
		/* 820C7DBCh case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000000A) );
		/* 820C7DBCh case    3:*/		return 0x820C7DC0;
		  /* 820C7DC0h */ case    4:  		/* mr R28, R3 */
		/* 820C7DC0h case    4:*/		regs.R28 = regs.R3;
		/* 820C7DC0h case    4:*/		return 0x820C7DC4;
		  /* 820C7DC4h */ case    5:  		/* mr R29, R4 */
		/* 820C7DC4h case    5:*/		regs.R29 = regs.R4;
		/* 820C7DC4h case    5:*/		return 0x820C7DC8;
		  /* 820C7DC8h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 820C7DC8h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C7DC8h case    6:*/		return 0x820C7DCC;
		  /* 820C7DCCh */ case    7:  		/* lwz R11, <#[R3 + 16]> */
		/* 820C7DCCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820C7DCCh case    7:*/		return 0x820C7DD0;
		  /* 820C7DD0h */ case    8:  		/* mr R30, R5 */
		/* 820C7DD0h case    8:*/		regs.R30 = regs.R5;
		/* 820C7DD0h case    8:*/		return 0x820C7DD4;
		  /* 820C7DD4h */ case    9:  		/* mr R27, R6 */
		/* 820C7DD4h case    9:*/		regs.R27 = regs.R6;
		/* 820C7DD4h case    9:*/		return 0x820C7DD8;
		  /* 820C7DD8h */ case   10:  		/* li R31, 0 */
		/* 820C7DD8h case   10:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C7DD8h case   10:*/		return 0x820C7DDC;
		  /* 820C7DDCh */ case   11:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C7DDCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C7DDCh case   11:*/		return 0x820C7DE0;
		  /* 820C7DE0h */ case   12:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 820C7DE0h case   12:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 820C7DE0h case   12:*/		return 0x820C7DE4;
		  /* 820C7DE4h */ case   13:  		/* bc 4, CR0_EQ, 588 */
		/* 820C7DE4h case   13:*/		if ( !regs.CR[0].eq ) { return 0x820C8030;  }
		/* 820C7DE4h case   13:*/		return 0x820C7DE8;
		  /* 820C7DE8h */ case   14:  		/* lis R10, 21592 */
		/* 820C7DE8h case   14:*/		cpu::op::lis<0>(regs,&regs.R10,0x5458);
		/* 820C7DE8h case   14:*/		return 0x820C7DEC;
		  /* 820C7DECh */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820C7DECh case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C7DECh case   15:*/		return 0x820C7DF0;
		  /* 820C7DF0h */ case   16:  		/* bc 12, CR6_EQ, 488 */
		/* 820C7DF0h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C7FD8;  }
		/* 820C7DF0h case   16:*/		return 0x820C7DF4;
		  /* 820C7DF4h */ case   17:  		/* lis R10, -2 */
		/* 820C7DF4h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820C7DF4h case   17:*/		return 0x820C7DF8;
		  /* 820C7DF8h */ case   18:  		/* cmplw CR6, R11, R10 */
		/* 820C7DF8h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C7DF8h case   18:*/		return 0x820C7DFC;
		  /* 820C7DFCh */ case   19:  		/* bc 12, CR6_EQ, 256 */
		/* 820C7DFCh case   19:*/		if ( regs.CR[6].eq ) { return 0x820C7EFC;  }
		/* 820C7DFCh case   19:*/		return 0x820C7E00;
		  /* 820C7E00h */ case   20:  		/* lis R10, -1 */
		/* 820C7E00h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C7E00h case   20:*/		return 0x820C7E04;
		  /* 820C7E04h */ case   21:  		/* cmplw CR6, R11, R10 */
		/* 820C7E04h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C7E04h case   21:*/		return 0x820C7E08;
		  /* 820C7E08h */ case   22:  		/* bc 4, CR6_EQ, 672 */
		/* 820C7E08h case   22:*/		if ( !regs.CR[6].eq ) { return 0x820C80A8;  }
		/* 820C7E08h case   22:*/		return 0x820C7E0C;
		  /* 820C7E0Ch */ case   23:  		/* lhz R11, <#[R4 + 4]> */
		/* 820C7E0Ch case   23:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C7E0Ch case   23:*/		return 0x820C7E10;
		  /* 820C7E10h */ case   24:  		/* cmplwi CR6, R11, 1 */
		/* 820C7E10h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C7E10h case   24:*/		return 0x820C7E14;
		  /* 820C7E14h */ case   25:  		/* bc 12, CR6_LT, 168 */
		/* 820C7E14h case   25:*/		if ( regs.CR[6].lt ) { return 0x820C7EBC;  }
		/* 820C7E14h case   25:*/		return 0x820C7E18;
		  /* 820C7E18h */ case   26:  		/* bc 12, CR6_EQ, 88 */
		/* 820C7E18h case   26:*/		if ( regs.CR[6].eq ) { return 0x820C7E70;  }
		/* 820C7E18h case   26:*/		return 0x820C7E1C;
		  /* 820C7E1Ch */ case   27:  		/* cmplwi CR6, R11, 3 */
		/* 820C7E1Ch case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C7E1Ch case   27:*/		return 0x820C7E20;
		  /* 820C7E20h */ case   28:  		/* bc 4, CR6_LT, 648 */
		/* 820C7E20h case   28:*/		if ( !regs.CR[6].lt ) { return 0x820C80A8;  }
		/* 820C7E20h case   28:*/		return 0x820C7E24;
		  /* 820C7E24h */ case   29:  		/* lhz R11, <#[R5 + 2]> */
		/* 820C7E24h case   29:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000002) );
		/* 820C7E24h case   29:*/		return 0x820C7E28;
		  /* 820C7E28h */ case   30:  		/* cmplwi CR6, R11, 1 */
		/* 820C7E28h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C7E28h case   30:*/		return 0x820C7E2C;
		  /* 820C7E2Ch */ case   31:  		/* bc 12, CR6_LT, 56 */
		/* 820C7E2Ch case   31:*/		if ( regs.CR[6].lt ) { return 0x820C7E64;  }
		/* 820C7E2Ch case   31:*/		return 0x820C7E30;
		  /* 820C7E30h */ case   32:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7E30h case   32:*/		if ( regs.CR[6].eq ) { return 0x820C7E58;  }
		/* 820C7E30h case   32:*/		return 0x820C7E34;
		  /* 820C7E34h */ case   33:  		/* cmplwi CR6, R11, 3 */
		/* 820C7E34h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C7E34h case   33:*/		return 0x820C7E38;
		  /* 820C7E38h */ case   34:  		/* bc 12, CR6_LT, 20 */
		/* 820C7E38h case   34:*/		if ( regs.CR[6].lt ) { return 0x820C7E4C;  }
		/* 820C7E38h case   34:*/		return 0x820C7E3C;
		  /* 820C7E3Ch */ case   35:  		/* bc 4, CR6_EQ, 620 */
		/* 820C7E3Ch case   35:*/		if ( !regs.CR[6].eq ) { return 0x820C80A8;  }
		/* 820C7E3Ch case   35:*/		return 0x820C7E40;
		  /* 820C7E40h */ case   36:  		/* lis R11, -32244 */
		/* 820C7E40h case   36:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7E40h case   36:*/		return 0x820C7E44;
		  /* 820C7E44h */ case   37:  		/* addi R31, R11, 19560 */
		/* 820C7E44h case   37:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4C68);
		/* 820C7E44h case   37:*/		return 0x820C7E48;
		  /* 820C7E48h */ case   38:  		/* b 608 */
		/* 820C7E48h case   38:*/		return 0x820C80A8;
		/* 820C7E48h case   38:*/		return 0x820C7E4C;
	}
	return 0x820C7E4C;
} // Block from 820C7DB0h-820C7E4Ch (39 instructions)

//////////////////////////////////////////////////////
// Block at 820C7E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7E4C);
		  /* 820C7E4Ch */ case    0:  		/* lis R11, -32244 */
		/* 820C7E4Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7E4Ch case    0:*/		return 0x820C7E50;
		  /* 820C7E50h */ case    1:  		/* addi R31, R11, 19784 */
		/* 820C7E50h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4D48);
		/* 820C7E50h case    1:*/		return 0x820C7E54;
		  /* 820C7E54h */ case    2:  		/* b 596 */
		/* 820C7E54h case    2:*/		return 0x820C80A8;
		/* 820C7E54h case    2:*/		return 0x820C7E58;
	}
	return 0x820C7E58;
} // Block from 820C7E4Ch-820C7E58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7E58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7E58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7E58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7E58);
		  /* 820C7E58h */ case    0:  		/* lis R11, -32244 */
		/* 820C7E58h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7E58h case    0:*/		return 0x820C7E5C;
		  /* 820C7E5Ch */ case    1:  		/* addi R31, R11, 19640 */
		/* 820C7E5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4CB8);
		/* 820C7E5Ch case    1:*/		return 0x820C7E60;
		  /* 820C7E60h */ case    2:  		/* b 584 */
		/* 820C7E60h case    2:*/		return 0x820C80A8;
		/* 820C7E60h case    2:*/		return 0x820C7E64;
	}
	return 0x820C7E64;
} // Block from 820C7E58h-820C7E64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7E64);
		  /* 820C7E64h */ case    0:  		/* lis R11, -32244 */
		/* 820C7E64h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7E64h case    0:*/		return 0x820C7E68;
		  /* 820C7E68h */ case    1:  		/* addi R31, R11, 19560 */
		/* 820C7E68h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4C68);
		/* 820C7E68h case    1:*/		return 0x820C7E6C;
		  /* 820C7E6Ch */ case    2:  		/* b 572 */
		/* 820C7E6Ch case    2:*/		return 0x820C80A8;
		/* 820C7E6Ch case    2:*/		return 0x820C7E70;
	}
	return 0x820C7E70;
} // Block from 820C7E64h-820C7E70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7E70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7E70);
		  /* 820C7E70h */ case    0:  		/* lhz R11, <#[R30 + 2]> */
		/* 820C7E70h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000002) );
		/* 820C7E70h case    0:*/		return 0x820C7E74;
		  /* 820C7E74h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 820C7E74h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C7E74h case    1:*/		return 0x820C7E78;
		  /* 820C7E78h */ case    2:  		/* bc 12, CR6_LT, 56 */
		/* 820C7E78h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C7EB0;  }
		/* 820C7E78h case    2:*/		return 0x820C7E7C;
		  /* 820C7E7Ch */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7E7Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820C7EA4;  }
		/* 820C7E7Ch case    3:*/		return 0x820C7E80;
		  /* 820C7E80h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C7E80h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C7E80h case    4:*/		return 0x820C7E84;
		  /* 820C7E84h */ case    5:  		/* bc 12, CR6_LT, 20 */
		/* 820C7E84h case    5:*/		if ( regs.CR[6].lt ) { return 0x820C7E98;  }
		/* 820C7E84h case    5:*/		return 0x820C7E88;
		  /* 820C7E88h */ case    6:  		/* bc 4, CR6_EQ, 544 */
		/* 820C7E88h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820C80A8;  }
		/* 820C7E88h case    6:*/		return 0x820C7E8C;
		  /* 820C7E8Ch */ case    7:  		/* lis R11, -32244 */
		/* 820C7E8Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7E8Ch case    7:*/		return 0x820C7E90;
		  /* 820C7E90h */ case    8:  		/* addi R31, R11, 19480 */
		/* 820C7E90h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4C18);
		/* 820C7E90h case    8:*/		return 0x820C7E94;
		  /* 820C7E94h */ case    9:  		/* b 532 */
		/* 820C7E94h case    9:*/		return 0x820C80A8;
		/* 820C7E94h case    9:*/		return 0x820C7E98;
	}
	return 0x820C7E98;
} // Block from 820C7E70h-820C7E98h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C7E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7E98);
		  /* 820C7E98h */ case    0:  		/* lis R11, -32244 */
		/* 820C7E98h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7E98h case    0:*/		return 0x820C7E9C;
		  /* 820C7E9Ch */ case    1:  		/* addi R31, R11, 19440 */
		/* 820C7E9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4BF0);
		/* 820C7E9Ch case    1:*/		return 0x820C7EA0;
		  /* 820C7EA0h */ case    2:  		/* b 520 */
		/* 820C7EA0h case    2:*/		return 0x820C80A8;
		/* 820C7EA0h case    2:*/		return 0x820C7EA4;
	}
	return 0x820C7EA4;
} // Block from 820C7E98h-820C7EA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7EA4);
		  /* 820C7EA4h */ case    0:  		/* lis R11, -32244 */
		/* 820C7EA4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7EA4h case    0:*/		return 0x820C7EA8;
		  /* 820C7EA8h */ case    1:  		/* addi R31, R11, 19352 */
		/* 820C7EA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4B98);
		/* 820C7EA8h case    1:*/		return 0x820C7EAC;
		  /* 820C7EACh */ case    2:  		/* b 508 */
		/* 820C7EACh case    2:*/		return 0x820C80A8;
		/* 820C7EACh case    2:*/		return 0x820C7EB0;
	}
	return 0x820C7EB0;
} // Block from 820C7EA4h-820C7EB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7EB0);
		  /* 820C7EB0h */ case    0:  		/* lis R11, -32244 */
		/* 820C7EB0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7EB0h case    0:*/		return 0x820C7EB4;
		  /* 820C7EB4h */ case    1:  		/* addi R31, R11, 19440 */
		/* 820C7EB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4BF0);
		/* 820C7EB4h case    1:*/		return 0x820C7EB8;
		  /* 820C7EB8h */ case    2:  		/* b 496 */
		/* 820C7EB8h case    2:*/		return 0x820C80A8;
		/* 820C7EB8h case    2:*/		return 0x820C7EBC;
	}
	return 0x820C7EBC;
} // Block from 820C7EB0h-820C7EBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7EBC);
		  /* 820C7EBCh */ case    0:  		/* lhz R11, <#[R30 + 2]> */
		/* 820C7EBCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000002) );
		/* 820C7EBCh case    0:*/		return 0x820C7EC0;
		  /* 820C7EC0h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 820C7EC0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C7EC0h case    1:*/		return 0x820C7EC4;
		  /* 820C7EC4h */ case    2:  		/* bc 12, CR6_LT, 44 */
		/* 820C7EC4h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C7EF0;  }
		/* 820C7EC4h case    2:*/		return 0x820C7EC8;
		  /* 820C7EC8h */ case    3:  		/* bc 12, CR6_EQ, 412 */
		/* 820C7EC8h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C8064;  }
		/* 820C7EC8h case    3:*/		return 0x820C7ECC;
		  /* 820C7ECCh */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C7ECCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C7ECCh case    4:*/		return 0x820C7ED0;
		  /* 820C7ED0h */ case    5:  		/* bc 12, CR6_LT, 20 */
		/* 820C7ED0h case    5:*/		if ( regs.CR[6].lt ) { return 0x820C7EE4;  }
		/* 820C7ED0h case    5:*/		return 0x820C7ED4;
		  /* 820C7ED4h */ case    6:  		/* bc 4, CR6_EQ, 468 */
		/* 820C7ED4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820C80A8;  }
		/* 820C7ED4h case    6:*/		return 0x820C7ED8;
		  /* 820C7ED8h */ case    7:  		/* lis R11, -32244 */
		/* 820C7ED8h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7ED8h case    7:*/		return 0x820C7EDC;
		  /* 820C7EDCh */ case    8:  		/* addi R31, R11, 19248 */
		/* 820C7EDCh case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4B30);
		/* 820C7EDCh case    8:*/		return 0x820C7EE0;
		  /* 820C7EE0h */ case    9:  		/* b 456 */
		/* 820C7EE0h case    9:*/		return 0x820C80A8;
		/* 820C7EE0h case    9:*/		return 0x820C7EE4;
	}
	return 0x820C7EE4;
} // Block from 820C7EBCh-820C7EE4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C7EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7EE4);
		  /* 820C7EE4h */ case    0:  		/* lis R11, -32244 */
		/* 820C7EE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7EE4h case    0:*/		return 0x820C7EE8;
		  /* 820C7EE8h */ case    1:  		/* addi R31, R11, 19160 */
		/* 820C7EE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4AD8);
		/* 820C7EE8h case    1:*/		return 0x820C7EEC;
		  /* 820C7EECh */ case    2:  		/* b 444 */
		/* 820C7EECh case    2:*/		return 0x820C80A8;
		/* 820C7EECh case    2:*/		return 0x820C7EF0;
	}
	return 0x820C7EF0;
} // Block from 820C7EE4h-820C7EF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7EF0);
		  /* 820C7EF0h */ case    0:  		/* lis R11, -32244 */
		/* 820C7EF0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7EF0h case    0:*/		return 0x820C7EF4;
		  /* 820C7EF4h */ case    1:  		/* addi R31, R11, 19120 */
		/* 820C7EF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4AB0);
		/* 820C7EF4h case    1:*/		return 0x820C7EF8;
		  /* 820C7EF8h */ case    2:  		/* b 432 */
		/* 820C7EF8h case    2:*/		return 0x820C80A8;
		/* 820C7EF8h case    2:*/		return 0x820C7EFC;
	}
	return 0x820C7EFC;
} // Block from 820C7EF0h-820C7EFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7EFC);
		  /* 820C7EFCh */ case    0:  		/* lhz R11, <#[R29 + 4]> */
		/* 820C7EFCh case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820C7EFCh case    0:*/		return 0x820C7F00;
		  /* 820C7F00h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 820C7F00h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C7F00h case    1:*/		return 0x820C7F04;
		  /* 820C7F04h */ case    2:  		/* bc 12, CR6_LT, 148 */
		/* 820C7F04h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C7F98;  }
		/* 820C7F04h case    2:*/		return 0x820C7F08;
		  /* 820C7F08h */ case    3:  		/* bc 12, CR6_EQ, 80 */
		/* 820C7F08h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C7F58;  }
		/* 820C7F08h case    3:*/		return 0x820C7F0C;
		  /* 820C7F0Ch */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C7F0Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C7F0Ch case    4:*/		return 0x820C7F10;
		  /* 820C7F10h */ case    5:  		/* bc 4, CR6_LT, 408 */
		/* 820C7F10h case    5:*/		if ( !regs.CR[6].lt ) { return 0x820C80A8;  }
		/* 820C7F10h case    5:*/		return 0x820C7F14;
		  /* 820C7F14h */ case    6:  		/* lhz R11, <#[R30 + 2]> */
		/* 820C7F14h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000002) );
		/* 820C7F14h case    6:*/		return 0x820C7F18;
		  /* 820C7F18h */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 820C7F18h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C7F18h case    7:*/		return 0x820C7F1C;
		  /* 820C7F1Ch */ case    8:  		/* bc 12, CR6_LT, 48 */
		/* 820C7F1Ch case    8:*/		if ( regs.CR[6].lt ) { return 0x820C7F4C;  }
		/* 820C7F1Ch case    8:*/		return 0x820C7F20;
		  /* 820C7F20h */ case    9:  		/* bc 12, CR6_EQ, 32 */
		/* 820C7F20h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C7F40;  }
		/* 820C7F20h case    9:*/		return 0x820C7F24;
		  /* 820C7F24h */ case   10:  		/* cmplwi CR6, R11, 3 */
		/* 820C7F24h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C7F24h case   10:*/		return 0x820C7F28;
		  /* 820C7F28h */ case   11:  		/* bc 12, CR6_LT, 12 */
		/* 820C7F28h case   11:*/		if ( regs.CR[6].lt ) { return 0x820C7F34;  }
		/* 820C7F28h case   11:*/		return 0x820C7F2C;
		  /* 820C7F2Ch */ case   12:  		/* bc 4, CR6_EQ, 380 */
		/* 820C7F2Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x820C80A8;  }
		/* 820C7F2Ch case   12:*/		return 0x820C7F30;
		  /* 820C7F30h */ case   13:  		/* b 344 */
		/* 820C7F30h case   13:*/		return 0x820C8088;
		/* 820C7F30h case   13:*/		return 0x820C7F34;
	}
	return 0x820C7F34;
} // Block from 820C7EFCh-820C7F34h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C7F34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7F34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7F34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7F34);
		  /* 820C7F34h */ case    0:  		/* lis R11, -32244 */
		/* 820C7F34h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7F34h case    0:*/		return 0x820C7F38;
		  /* 820C7F38h */ case    1:  		/* addi R31, R11, 18984 */
		/* 820C7F38h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4A28);
		/* 820C7F38h case    1:*/		return 0x820C7F3C;
		  /* 820C7F3Ch */ case    2:  		/* b 364 */
		/* 820C7F3Ch case    2:*/		return 0x820C80A8;
		/* 820C7F3Ch case    2:*/		return 0x820C7F40;
	}
	return 0x820C7F40;
} // Block from 820C7F34h-820C7F40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7F40);
		  /* 820C7F40h */ case    0:  		/* lis R11, -32244 */
		/* 820C7F40h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7F40h case    0:*/		return 0x820C7F44;
		  /* 820C7F44h */ case    1:  		/* addi R31, R11, 18840 */
		/* 820C7F44h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4998);
		/* 820C7F44h case    1:*/		return 0x820C7F48;
		  /* 820C7F48h */ case    2:  		/* b 352 */
		/* 820C7F48h case    2:*/		return 0x820C80A8;
		/* 820C7F48h case    2:*/		return 0x820C7F4C;
	}
	return 0x820C7F4C;
} // Block from 820C7F40h-820C7F4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7F4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7F4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7F4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7F4C);
		  /* 820C7F4Ch */ case    0:  		/* lis R11, -32244 */
		/* 820C7F4Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7F4Ch case    0:*/		return 0x820C7F50;
		  /* 820C7F50h */ case    1:  		/* addi R31, R11, 18760 */
		/* 820C7F50h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4948);
		/* 820C7F50h case    1:*/		return 0x820C7F54;
		  /* 820C7F54h */ case    2:  		/* b 340 */
		/* 820C7F54h case    2:*/		return 0x820C80A8;
		/* 820C7F54h case    2:*/		return 0x820C7F58;
	}
	return 0x820C7F58;
} // Block from 820C7F4Ch-820C7F58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7F58);
		  /* 820C7F58h */ case    0:  		/* lhz R11, <#[R30 + 2]> */
		/* 820C7F58h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000002) );
		/* 820C7F58h case    0:*/		return 0x820C7F5C;
		  /* 820C7F5Ch */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 820C7F5Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C7F5Ch case    1:*/		return 0x820C7F60;
		  /* 820C7F60h */ case    2:  		/* bc 12, CR6_LT, 44 */
		/* 820C7F60h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C7F8C;  }
		/* 820C7F60h case    2:*/		return 0x820C7F64;
		  /* 820C7F64h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 820C7F64h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C7F80;  }
		/* 820C7F64h case    3:*/		return 0x820C7F68;
		  /* 820C7F68h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C7F68h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C7F68h case    4:*/		return 0x820C7F6C;
		  /* 820C7F6Ch */ case    5:  		/* bc 12, CR6_LT, 296 */
		/* 820C7F6Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x820C8094;  }
		/* 820C7F6Ch case    5:*/		return 0x820C7F70;
		  /* 820C7F70h */ case    6:  		/* bc 4, CR6_EQ, 312 */
		/* 820C7F70h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820C80A8;  }
		/* 820C7F70h case    6:*/		return 0x820C7F74;
		  /* 820C7F74h */ case    7:  		/* lis R11, -32244 */
		/* 820C7F74h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7F74h case    7:*/		return 0x820C7F78;
		  /* 820C7F78h */ case    8:  		/* addi R31, R11, 18680 */
		/* 820C7F78h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x48F8);
		/* 820C7F78h case    8:*/		return 0x820C7F7C;
		  /* 820C7F7Ch */ case    9:  		/* b 300 */
		/* 820C7F7Ch case    9:*/		return 0x820C80A8;
		/* 820C7F7Ch case    9:*/		return 0x820C7F80;
	}
	return 0x820C7F80;
} // Block from 820C7F58h-820C7F80h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C7F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7F80);
		  /* 820C7F80h */ case    0:  		/* lis R11, -32244 */
		/* 820C7F80h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7F80h case    0:*/		return 0x820C7F84;
		  /* 820C7F84h */ case    1:  		/* addi R31, R11, 18592 */
		/* 820C7F84h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x48A0);
		/* 820C7F84h case    1:*/		return 0x820C7F88;
		  /* 820C7F88h */ case    2:  		/* b 288 */
		/* 820C7F88h case    2:*/		return 0x820C80A8;
		/* 820C7F88h case    2:*/		return 0x820C7F8C;
	}
	return 0x820C7F8C;
} // Block from 820C7F80h-820C7F8Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7F8C);
		  /* 820C7F8Ch */ case    0:  		/* lis R11, -32244 */
		/* 820C7F8Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7F8Ch case    0:*/		return 0x820C7F90;
		  /* 820C7F90h */ case    1:  		/* addi R31, R11, 18552 */
		/* 820C7F90h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4878);
		/* 820C7F90h case    1:*/		return 0x820C7F94;
		  /* 820C7F94h */ case    2:  		/* b 276 */
		/* 820C7F94h case    2:*/		return 0x820C80A8;
		/* 820C7F94h case    2:*/		return 0x820C7F98;
	}
	return 0x820C7F98;
} // Block from 820C7F8Ch-820C7F98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7F98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7F98);
		  /* 820C7F98h */ case    0:  		/* lhz R11, <#[R30 + 2]> */
		/* 820C7F98h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000002) );
		/* 820C7F98h case    0:*/		return 0x820C7F9C;
		  /* 820C7F9Ch */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 820C7F9Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C7F9Ch case    1:*/		return 0x820C7FA0;
		  /* 820C7FA0h */ case    2:  		/* bc 12, CR6_LT, 44 */
		/* 820C7FA0h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C7FCC;  }
		/* 820C7FA0h case    2:*/		return 0x820C7FA4;
		  /* 820C7FA4h */ case    3:  		/* bc 12, CR6_EQ, 252 */
		/* 820C7FA4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C80A0;  }
		/* 820C7FA4h case    3:*/		return 0x820C7FA8;
		  /* 820C7FA8h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C7FA8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C7FA8h case    4:*/		return 0x820C7FAC;
		  /* 820C7FACh */ case    5:  		/* bc 12, CR6_LT, 20 */
		/* 820C7FACh case    5:*/		if ( regs.CR[6].lt ) { return 0x820C7FC0;  }
		/* 820C7FACh case    5:*/		return 0x820C7FB0;
		  /* 820C7FB0h */ case    6:  		/* bc 4, CR6_EQ, 248 */
		/* 820C7FB0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820C80A8;  }
		/* 820C7FB0h case    6:*/		return 0x820C7FB4;
		  /* 820C7FB4h */ case    7:  		/* lis R11, -32244 */
		/* 820C7FB4h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7FB4h case    7:*/		return 0x820C7FB8;
		  /* 820C7FB8h */ case    8:  		/* addi R31, R11, 18448 */
		/* 820C7FB8h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4810);
		/* 820C7FB8h case    8:*/		return 0x820C7FBC;
		  /* 820C7FBCh */ case    9:  		/* b 236 */
		/* 820C7FBCh case    9:*/		return 0x820C80A8;
		/* 820C7FBCh case    9:*/		return 0x820C7FC0;
	}
	return 0x820C7FC0;
} // Block from 820C7F98h-820C7FC0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C7FC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7FC0);
		  /* 820C7FC0h */ case    0:  		/* lis R11, -32244 */
		/* 820C7FC0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7FC0h case    0:*/		return 0x820C7FC4;
		  /* 820C7FC4h */ case    1:  		/* addi R31, R11, 18360 */
		/* 820C7FC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x47B8);
		/* 820C7FC4h case    1:*/		return 0x820C7FC8;
		  /* 820C7FC8h */ case    2:  		/* b 224 */
		/* 820C7FC8h case    2:*/		return 0x820C80A8;
		/* 820C7FC8h case    2:*/		return 0x820C7FCC;
	}
	return 0x820C7FCC;
} // Block from 820C7FC0h-820C7FCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7FCC);
		  /* 820C7FCCh */ case    0:  		/* lis R11, -32244 */
		/* 820C7FCCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C7FCCh case    0:*/		return 0x820C7FD0;
		  /* 820C7FD0h */ case    1:  		/* addi R31, R11, 18320 */
		/* 820C7FD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4790);
		/* 820C7FD0h case    1:*/		return 0x820C7FD4;
		  /* 820C7FD4h */ case    2:  		/* b 212 */
		/* 820C7FD4h case    2:*/		return 0x820C80A8;
		/* 820C7FD4h case    2:*/		return 0x820C7FD8;
	}
	return 0x820C7FD8;
} // Block from 820C7FCCh-820C7FD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C7FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C7FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C7FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C7FD8);
		  /* 820C7FD8h */ case    0:  		/* lhz R11, <#[R29 + 4]> */
		/* 820C7FD8h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820C7FD8h case    0:*/		return 0x820C7FDC;
		  /* 820C7FDCh */ case    1:  		/* cmplwi CR6, R11, 2 */
		/* 820C7FDCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820C7FDCh case    1:*/		return 0x820C7FE0;
		  /* 820C7FE0h */ case    2:  		/* bc 4, CR6_EQ, 200 */
		/* 820C7FE0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C80A8;  }
		/* 820C7FE0h case    2:*/		return 0x820C7FE4;
		  /* 820C7FE4h */ case    3:  		/* lhz R11, <#[R30 + 2]> */
		/* 820C7FE4h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000002) );
		/* 820C7FE4h case    3:*/		return 0x820C7FE8;
		  /* 820C7FE8h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 820C7FE8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C7FE8h case    4:*/		return 0x820C7FEC;
		  /* 820C7FECh */ case    5:  		/* bc 12, CR6_LT, 56 */
		/* 820C7FECh case    5:*/		if ( regs.CR[6].lt ) { return 0x820C8024;  }
		/* 820C7FECh case    5:*/		return 0x820C7FF0;
		  /* 820C7FF0h */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 820C7FF0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C8018;  }
		/* 820C7FF0h case    6:*/		return 0x820C7FF4;
		  /* 820C7FF4h */ case    7:  		/* cmplwi CR6, R11, 3 */
		/* 820C7FF4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C7FF4h case    7:*/		return 0x820C7FF8;
		  /* 820C7FF8h */ case    8:  		/* bc 12, CR6_LT, 20 */
		/* 820C7FF8h case    8:*/		if ( regs.CR[6].lt ) { return 0x820C800C;  }
		/* 820C7FF8h case    8:*/		return 0x820C7FFC;
		  /* 820C7FFCh */ case    9:  		/* bc 4, CR6_EQ, 172 */
		/* 820C7FFCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x820C80A8;  }
		/* 820C7FFCh case    9:*/		return 0x820C8000;
		  /* 820C8000h */ case   10:  		/* lis R11, -32244 */
		/* 820C8000h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C8000h case   10:*/		return 0x820C8004;
		  /* 820C8004h */ case   11:  		/* addi R31, R11, 19920 */
		/* 820C8004h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4DD0);
		/* 820C8004h case   11:*/		return 0x820C8008;
		  /* 820C8008h */ case   12:  		/* b 160 */
		/* 820C8008h case   12:*/		return 0x820C80A8;
		/* 820C8008h case   12:*/		return 0x820C800C;
	}
	return 0x820C800C;
} // Block from 820C7FD8h-820C800Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C800Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C800C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C800C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C800C);
		  /* 820C800Ch */ case    0:  		/* lis R11, -32244 */
		/* 820C800Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C800Ch case    0:*/		return 0x820C8010;
		  /* 820C8010h */ case    1:  		/* addi R31, R11, 20128 */
		/* 820C8010h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4EA0);
		/* 820C8010h case    1:*/		return 0x820C8014;
		  /* 820C8014h */ case    2:  		/* b 148 */
		/* 820C8014h case    2:*/		return 0x820C80A8;
		/* 820C8014h case    2:*/		return 0x820C8018;
	}
	return 0x820C8018;
} // Block from 820C800Ch-820C8018h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8018);
		  /* 820C8018h */ case    0:  		/* lis R11, -32244 */
		/* 820C8018h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C8018h case    0:*/		return 0x820C801C;
		  /* 820C801Ch */ case    1:  		/* addi R31, R11, 19992 */
		/* 820C801Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4E18);
		/* 820C801Ch case    1:*/		return 0x820C8020;
		  /* 820C8020h */ case    2:  		/* b 136 */
		/* 820C8020h case    2:*/		return 0x820C80A8;
		/* 820C8020h case    2:*/		return 0x820C8024;
	}
	return 0x820C8024;
} // Block from 820C8018h-820C8024h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8024);
		  /* 820C8024h */ case    0:  		/* lis R11, -32244 */
		/* 820C8024h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C8024h case    0:*/		return 0x820C8028;
		  /* 820C8028h */ case    1:  		/* addi R31, R11, 19920 */
		/* 820C8028h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4DD0);
		/* 820C8028h case    1:*/		return 0x820C802C;
		  /* 820C802Ch */ case    2:  		/* b 124 */
		/* 820C802Ch case    2:*/		return 0x820C80A8;
		/* 820C802Ch case    2:*/		return 0x820C8030;
	}
	return 0x820C8030;
} // Block from 820C8024h-820C8030h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8030);
		  /* 820C8030h */ case    0:  		/* lis R10, -2 */
		/* 820C8030h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 820C8030h case    0:*/		return 0x820C8034;
		  /* 820C8034h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820C8034h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C8034h case    1:*/		return 0x820C8038;
		  /* 820C8038h */ case    2:  		/* bc 12, CR6_EQ, 56 */
		/* 820C8038h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C8070;  }
		/* 820C8038h case    2:*/		return 0x820C803C;
		  /* 820C803Ch */ case    3:  		/* lis R10, -1 */
		/* 820C803Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C803Ch case    3:*/		return 0x820C8040;
		  /* 820C8040h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 820C8040h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C8040h case    4:*/		return 0x820C8044;
		  /* 820C8044h */ case    5:  		/* bc 4, CR6_EQ, 100 */
		/* 820C8044h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C80A8;  }
		/* 820C8044h case    5:*/		return 0x820C8048;
		  /* 820C8048h */ case    6:  		/* lhz R11, <#[R29 + 4]> */
		/* 820C8048h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820C8048h case    6:*/		return 0x820C804C;
		  /* 820C804Ch */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 820C804Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C804Ch case    7:*/		return 0x820C8050;
		  /* 820C8050h */ case    8:  		/* bc 12, CR6_LT, 20 */
		/* 820C8050h case    8:*/		if ( regs.CR[6].lt ) { return 0x820C8064;  }
		/* 820C8050h case    8:*/		return 0x820C8054;
		  /* 820C8054h */ case    9:  		/* bc 12, CR6_EQ, -444 */
		/* 820C8054h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C7E98;  }
		/* 820C8054h case    9:*/		return 0x820C8058;
		  /* 820C8058h */ case   10:  		/* cmplwi CR6, R11, 3 */
		/* 820C8058h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C8058h case   10:*/		return 0x820C805C;
		  /* 820C805Ch */ case   11:  		/* bc 4, CR6_LT, 76 */
		/* 820C805Ch case   11:*/		if ( !regs.CR[6].lt ) { return 0x820C80A8;  }
		/* 820C805Ch case   11:*/		return 0x820C8060;
		  /* 820C8060h */ case   12:  		/* b -544 */
		/* 820C8060h case   12:*/		return 0x820C7E40;
		/* 820C8060h case   12:*/		return 0x820C8064;
	}
	return 0x820C8064;
} // Block from 820C8030h-820C8064h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C8064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8064);
		  /* 820C8064h */ case    0:  		/* lis R11, -32244 */
		/* 820C8064h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C8064h case    0:*/		return 0x820C8068;
		  /* 820C8068h */ case    1:  		/* addi R31, R11, 19120 */
		/* 820C8068h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4AB0);
		/* 820C8068h case    1:*/		return 0x820C806C;
		  /* 820C806Ch */ case    2:  		/* b 60 */
		/* 820C806Ch case    2:*/		return 0x820C80A8;
		/* 820C806Ch case    2:*/		return 0x820C8070;
	}
	return 0x820C8070;
} // Block from 820C8064h-820C8070h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8070);
		  /* 820C8070h */ case    0:  		/* lhz R11, <#[R29 + 4]> */
		/* 820C8070h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 820C8070h case    0:*/		return 0x820C8074;
		  /* 820C8074h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 820C8074h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C8074h case    1:*/		return 0x820C8078;
		  /* 820C8078h */ case    2:  		/* bc 12, CR6_LT, 40 */
		/* 820C8078h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C80A0;  }
		/* 820C8078h case    2:*/		return 0x820C807C;
		  /* 820C807Ch */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820C807Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820C8094;  }
		/* 820C807Ch case    3:*/		return 0x820C8080;
		  /* 820C8080h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 820C8080h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820C8080h case    4:*/		return 0x820C8084;
		  /* 820C8084h */ case    5:  		/* bc 4, CR6_LT, 36 */
		/* 820C8084h case    5:*/		if ( !regs.CR[6].lt ) { return 0x820C80A8;  }
		/* 820C8084h case    5:*/		return 0x820C8088;
	}
	return 0x820C8088;
} // Block from 820C8070h-820C8088h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C8088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8088);
		  /* 820C8088h */ case    0:  		/* lis R11, -32244 */
		/* 820C8088h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C8088h case    0:*/		return 0x820C808C;
		  /* 820C808Ch */ case    1:  		/* addi R31, R11, 18760 */
		/* 820C808Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4948);
		/* 820C808Ch case    1:*/		return 0x820C8090;
		  /* 820C8090h */ case    2:  		/* b 24 */
		/* 820C8090h case    2:*/		return 0x820C80A8;
		/* 820C8090h case    2:*/		return 0x820C8094;
	}
	return 0x820C8094;
} // Block from 820C8088h-820C8094h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8094);
		  /* 820C8094h */ case    0:  		/* lis R11, -32244 */
		/* 820C8094h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C8094h case    0:*/		return 0x820C8098;
		  /* 820C8098h */ case    1:  		/* addi R31, R11, 18552 */
		/* 820C8098h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4878);
		/* 820C8098h case    1:*/		return 0x820C809C;
		  /* 820C809Ch */ case    2:  		/* b 12 */
		/* 820C809Ch case    2:*/		return 0x820C80A8;
		/* 820C809Ch case    2:*/		return 0x820C80A0;
	}
	return 0x820C80A0;
} // Block from 820C8094h-820C80A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C80A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C80A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C80A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C80A0);
		  /* 820C80A0h */ case    0:  		/* lis R11, -32244 */
		/* 820C80A0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF820C);
		/* 820C80A0h case    0:*/		return 0x820C80A4;
		  /* 820C80A4h */ case    1:  		/* addi R31, R11, 18320 */
		/* 820C80A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x4790);
		/* 820C80A4h case    1:*/		return 0x820C80A8;
	}
	return 0x820C80A8;
} // Block from 820C80A0h-820C80A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C80A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C80A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C80A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C80A8);
		  /* 820C80A8h */ case    0:  		/* lis R4, 9345 */
		/* 820C80A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C80A8h case    0:*/		return 0x820C80AC;
		  /* 820C80ACh */ case    1:  		/* li R3, 68 */
		/* 820C80ACh case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x44);
		/* 820C80ACh case    1:*/		return 0x820C80B0;
		  /* 820C80B0h */ case    2:  		/* bl -261808 */
		/* 820C80B0h case    2:*/		regs.LR = 0x820C80B4; return 0x82088200;
		/* 820C80B0h case    2:*/		return 0x820C80B4;
		  /* 820C80B4h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820C80B4h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C80B4h case    3:*/		return 0x820C80B8;
		  /* 820C80B8h */ case    4:  		/* bc 12, CR0_EQ, 36 */
		/* 820C80B8h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C80DC;  }
		/* 820C80B8h case    4:*/		return 0x820C80BC;
		  /* 820C80BCh */ case    5:  		/* mr R8, R27 */
		/* 820C80BCh case    5:*/		regs.R8 = regs.R27;
		/* 820C80BCh case    5:*/		return 0x820C80C0;
		  /* 820C80C0h */ case    6:  		/* mr R7, R31 */
		/* 820C80C0h case    6:*/		regs.R7 = regs.R31;
		/* 820C80C0h case    6:*/		return 0x820C80C4;
		  /* 820C80C4h */ case    7:  		/* mr R6, R30 */
		/* 820C80C4h case    7:*/		regs.R6 = regs.R30;
		/* 820C80C4h case    7:*/		return 0x820C80C8;
		  /* 820C80C8h */ case    8:  		/* mr R5, R29 */
		/* 820C80C8h case    8:*/		regs.R5 = regs.R29;
		/* 820C80C8h case    8:*/		return 0x820C80CC;
		  /* 820C80CCh */ case    9:  		/* mr R4, R28 */
		/* 820C80CCh case    9:*/		regs.R4 = regs.R28;
		/* 820C80CCh case    9:*/		return 0x820C80D0;
		  /* 820C80D0h */ case   10:  		/* bl -16408 */
		/* 820C80D0h case   10:*/		regs.LR = 0x820C80D4; return 0x820C40B8;
		/* 820C80D0h case   10:*/		return 0x820C80D4;
		  /* 820C80D4h */ case   11:  		/* mr R31, R3 */
		/* 820C80D4h case   11:*/		regs.R31 = regs.R3;
		/* 820C80D4h case   11:*/		return 0x820C80D8;
		  /* 820C80D8h */ case   12:  		/* b 8 */
		/* 820C80D8h case   12:*/		return 0x820C80E0;
		/* 820C80D8h case   12:*/		return 0x820C80DC;
	}
	return 0x820C80DC;
} // Block from 820C80A8h-820C80DCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C80DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C80DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C80DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C80DC);
		  /* 820C80DCh */ case    0:  		/* li R31, 0 */
		/* 820C80DCh case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C80DCh case    0:*/		return 0x820C80E0;
	}
	return 0x820C80E0;
} // Block from 820C80DCh-820C80E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C80E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C80E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C80E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C80E0);
		  /* 820C80E0h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820C80E0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C80E0h case    0:*/		return 0x820C80E4;
		  /* 820C80E4h */ case    1:  		/* bc 12, CR6_EQ, 40 */
		/* 820C80E4h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C810C;  }
		/* 820C80E4h case    1:*/		return 0x820C80E8;
		  /* 820C80E8h */ case    2:  		/* mr R3, R31 */
		/* 820C80E8h case    2:*/		regs.R3 = regs.R31;
		/* 820C80E8h case    2:*/		return 0x820C80EC;
		  /* 820C80ECh */ case    3:  		/* bl 44 */
		/* 820C80ECh case    3:*/		regs.LR = 0x820C80F0; return 0x820C8118;
		/* 820C80ECh case    3:*/		return 0x820C80F0;
		  /* 820C80F0h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 820C80F0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C80F0h case    4:*/		return 0x820C80F4;
		  /* 820C80F4h */ case    5:  		/* mr R3, R31 */
		/* 820C80F4h case    5:*/		regs.R3 = regs.R31;
		/* 820C80F4h case    5:*/		return 0x820C80F8;
		  /* 820C80F8h */ case    6:  		/* bc 4, CR0_LT, 24 */
		/* 820C80F8h case    6:*/		if ( !regs.CR[0].lt ) { return 0x820C8110;  }
		/* 820C80F8h case    6:*/		return 0x820C80FC;
		  /* 820C80FCh */ case    7:  		/* bl -15276 */
		/* 820C80FCh case    7:*/		regs.LR = 0x820C8100; return 0x820C4550;
		/* 820C80FCh case    7:*/		return 0x820C8100;
		  /* 820C8100h */ case    8:  		/* lis R4, 9345 */
		/* 820C8100h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C8100h case    8:*/		return 0x820C8104;
		  /* 820C8104h */ case    9:  		/* mr R3, R31 */
		/* 820C8104h case    9:*/		regs.R3 = regs.R31;
		/* 820C8104h case    9:*/		return 0x820C8108;
		  /* 820C8108h */ case   10:  		/* bl -261584 */
		/* 820C8108h case   10:*/		regs.LR = 0x820C810C; return 0x82088338;
		/* 820C8108h case   10:*/		return 0x820C810C;
	}
	return 0x820C810C;
} // Block from 820C80E0h-820C810Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C810Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C810C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C810C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C810C);
		  /* 820C810Ch */ case    0:  		/* li R3, 0 */
		/* 820C810Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C810Ch case    0:*/		return 0x820C8110;
	}
	return 0x820C8110;
} // Block from 820C810Ch-820C8110h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8110);
		  /* 820C8110h */ case    0:  		/* addi R1, R1, 128 */
		/* 820C8110h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C8110h case    0:*/		return 0x820C8114;
		  /* 820C8114h */ case    1:  		/* b -224880 */
		/* 820C8114h case    1:*/		return 0x820912A4;
		/* 820C8114h case    1:*/		return 0x820C8118;
	}
	return 0x820C8118;
} // Block from 820C8110h-820C8118h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8118h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8118);
		  /* 820C8118h */ case    0:  		/* mfspr R12, LR */
		/* 820C8118h case    0:*/		regs.R12 = regs.LR;
		/* 820C8118h case    0:*/		return 0x820C811C;
		  /* 820C811Ch */ case    1:  		/* bl -224976 */
		/* 820C811Ch case    1:*/		regs.LR = 0x820C8120; return 0x8209124C;
		/* 820C811Ch case    1:*/		return 0x820C8120;
		  /* 820C8120h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 820C8120h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 820C8120h case    2:*/		return 0x820C8124;
		  /* 820C8124h */ case    3:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C8124h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C8124h case    3:*/		return 0x820C8128;
		  /* 820C8128h */ case    4:  		/* mr R31, R3 */
		/* 820C8128h case    4:*/		regs.R31 = regs.R3;
		/* 820C8128h case    4:*/		return 0x820C812C;
		  /* 820C812Ch */ case    5:  		/* lhz R10, <#[R11 + 10]> */
		/* 820C812Ch case    5:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000A) );
		/* 820C812Ch case    5:*/		return 0x820C8130;
	}
	return 0x820C8130;
} // Block from 820C8118h-820C8130h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C8130h
// Function '??_GCConstant@D3DXShader@@QAAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8130);
		  /* 820C8130h */ case    0:  		/* cmplwi CR0, R10, 0 */
		/* 820C8130h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820C8130h case    0:*/		return 0x820C8134;
		  /* 820C8134h */ case    1:  		/* bc 12, CR0_EQ, 516 */
		/* 820C8134h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C8338;  }
		/* 820C8134h case    1:*/		return 0x820C8138;
		  /* 820C8138h */ case    2:  		/* rlwinm R11, R10, 0, 16, 31 */
		/* 820C8138h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R10);
		/* 820C8138h case    2:*/		return 0x820C813C;
		  /* 820C813Ch */ case    3:  		/* lis R4, 9345 */
		/* 820C813Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C813Ch case    3:*/		return 0x820C8140;
		  /* 820C8140h */ case    4:  		/* rlwinm R3, R11, 2, 0, 31 */
		/* 820C8140h case    4:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R3,regs.R11);
		/* 820C8140h case    4:*/		return 0x820C8144;
		  /* 820C8144h */ case    5:  		/* bl -261956 */
		/* 820C8144h case    5:*/		regs.LR = 0x820C8148; return 0x82088200;
		/* 820C8144h case    5:*/		return 0x820C8148;
		  /* 820C8148h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820C8148h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C8148h case    6:*/		return 0x820C814C;
		  /* 820C814Ch */ case    7:  		/* stw R3, <#[R31 + 56]> */
		/* 820C814Ch case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000038) );
		/* 820C814Ch case    7:*/		return 0x820C8150;
		  /* 820C8150h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 820C8150h case    8:*/		if ( !regs.CR[0].eq ) { return 0x820C8160;  }
		/* 820C8150h case    8:*/		return 0x820C8154;
		  /* 820C8154h */ case    9:  		/* lis R3, -32761 */
		/* 820C8154h case    9:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820C8154h case    9:*/		return 0x820C8158;
		  /* 820C8158h */ case   10:  		/* ori R3, R3, 14 */
		/* 820C8158h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820C8158h case   10:*/		return 0x820C815C;
		  /* 820C815Ch */ case   11:  		/* b 480 */
		/* 820C815Ch case   11:*/		return 0x820C833C;
		/* 820C815Ch case   11:*/		return 0x820C8160;
	}
	return 0x820C8160;
} // Block from 820C8130h-820C8160h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C8160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8160);
		  /* 820C8160h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C8160h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C8160h case    0:*/		return 0x820C8164;
		  /* 820C8164h */ case    1:  		/* li R4, 0 */
		/* 820C8164h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C8164h case    1:*/		return 0x820C8168;
		  /* 820C8168h */ case    2:  		/* lhz R11, <#[R11 + 10]> */
		/* 820C8168h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000A) );
		/* 820C8168h case    2:*/		return 0x820C816C;
		  /* 820C816Ch */ case    3:  		/* rlwinm R5, R11, 2, 0, 31 */
		/* 820C816Ch case    3:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R5,regs.R11);
		/* 820C816Ch case    3:*/		return 0x820C8170;
		  /* 820C8170h */ case    4:  		/* bl -224816 */
		/* 820C8170h case    4:*/		regs.LR = 0x820C8174; return 0x82091340;
		/* 820C8170h case    4:*/		return 0x820C8174;
		  /* 820C8174h */ case    5:  		/* li R11, 5 */
		/* 820C8174h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820C8174h case    5:*/		return 0x820C8178;
		  /* 820C8178h */ case    6:  		/* addi R10, R1, 92 */
		/* 820C8178h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x5C);
		/* 820C8178h case    6:*/		return 0x820C817C;
		  /* 820C817Ch */ case    7:  		/* mr R9, R31 */
		/* 820C817Ch case    7:*/		regs.R9 = regs.R31;
		/* 820C817Ch case    7:*/		return 0x820C8180;
	}
	return 0x820C8180;
} // Block from 820C8160h-820C8180h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C8180h
// Function '??1CConstantTable@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8180);
		  /* 820C8180h */ case    0:  		/* mtspr CTR, R11 */
		/* 820C8180h case    0:*/		regs.CTR = regs.R11;
		/* 820C8180h case    0:*/		return 0x820C8184;
		  /* 820C8184h */ case    1:  		/* lwz R25, <#[R31 + 32]> */
		/* 820C8184h case    1:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R31 + 0x00000020) );
		/* 820C8184h case    1:*/		return 0x820C8188;
		  /* 820C8188h */ case    2:  		/* lwzu R11, <#[R9 + 4]> */
		/* 820C8188h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C8188h case    2:*/		return 0x820C818C;
		  /* 820C818Ch */ case    3:  		/* stwu R11, <#[R10 + 4]> */
		/* 820C818Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C818Ch case    3:*/		return 0x820C8190;
		  /* 820C8190h */ case    4:  		/* bc 16, CR0_LT, -8 */
		/* 820C8190h case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C8188;  }
		/* 820C8190h case    4:*/		return 0x820C8194;
		  /* 820C8194h */ case    5:  		/* lwz R9, <#[R31 + 24]> */
		/* 820C8194h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 820C8194h case    5:*/		return 0x820C8198;
		  /* 820C8198h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 820C8198h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C8198h case    6:*/		return 0x820C819C;
		  /* 820C819Ch */ case    7:  		/* lhz R10, <#[R9 + 10]> */
		/* 820C819Ch case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000000A) );
		/* 820C819Ch case    7:*/		return 0x820C81A0;
		  /* 820C81A0h */ case    8:  		/* lwz R9, <#[R9 + 12]> */
		/* 820C81A0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000000C) );
		/* 820C81A0h case    8:*/		return 0x820C81A4;
		  /* 820C81A4h */ case    9:  		/* rlwinm R8, R10, 3, 0, 31 */
		/* 820C81A4h case    9:*/		cpu::op::rlwinm<0,3,0,31>(regs,&regs.R8,regs.R10);
		/* 820C81A4h case    9:*/		return 0x820C81A8;
		  /* 820C81A8h */ case   10:  		/* lwz R7, <#[R11 + 12]> */
		/* 820C81A8h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C81A8h case   10:*/		return 0x820C81AC;
		  /* 820C81ACh */ case   11:  		/* add R8, R8, R9 */
		/* 820C81ACh case   11:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 820C81ACh case   11:*/		return 0x820C81B0;
		  /* 820C81B0h */ case   12:  		/* cmplw CR6, R8, R7 */
		/* 820C81B0h case   12:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 820C81B0h case   12:*/		return 0x820C81B4;
		  /* 820C81B4h */ case   13:  		/* bc 4, CR6_GT, 16 */
		/* 820C81B4h case   13:*/		if ( !regs.CR[6].gt ) { return 0x820C81C4;  }
		/* 820C81B4h case   13:*/		return 0x820C81B8;
		  /* 820C81B8h */ case   14:  		/* lis R3, -32768 */
		/* 820C81B8h case   14:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C81B8h case   14:*/		return 0x820C81BC;
		  /* 820C81BCh */ case   15:  		/* ori R3, R3, 16389 */
		/* 820C81BCh case   15:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C81BCh case   15:*/		return 0x820C81C0;
		  /* 820C81C0h */ case   16:  		/* b 380 */
		/* 820C81C0h case   16:*/		return 0x820C833C;
		/* 820C81C0h case   16:*/		return 0x820C81C4;
	}
	return 0x820C81C4;
} // Block from 820C8180h-820C81C4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C81C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C81C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C81C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C81C4);
		  /* 820C81C4h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 820C81C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C81C4h case    0:*/		return 0x820C81C8;
		  /* 820C81C8h */ case    1:  		/* li R26, 0 */
		/* 820C81C8h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820C81C8h case    1:*/		return 0x820C81CC;
		  /* 820C81CCh */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 820C81CCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C81CCh case    2:*/		return 0x820C81D0;
		  /* 820C81D0h */ case    3:  		/* mr R27, R26 */
		/* 820C81D0h case    3:*/		regs.R27 = regs.R26;
		/* 820C81D0h case    3:*/		return 0x820C81D4;
		  /* 820C81D4h */ case    4:  		/* add R29, R11, R9 */
		/* 820C81D4h case    4:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R9);
		/* 820C81D4h case    4:*/		return 0x820C81D8;
		  /* 820C81D8h */ case    5:  		/* bc 12, CR6_EQ, 352 */
		/* 820C81D8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C8338;  }
		/* 820C81D8h case    5:*/		return 0x820C81DC;
		  /* 820C81DCh */ case    6:  		/* mr R28, R26 */
		/* 820C81DCh case    6:*/		regs.R28 = regs.R26;
		/* 820C81DCh case    6:*/		return 0x820C81E0;
		  /* 820C81E0h */ case    7:  		/* lwz R3, <#[R31]> */
		/* 820C81E0h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820C81E0h case    7:*/		return 0x820C81E4;
		  /* 820C81E4h */ case    8:  		/* lwz R10, <#[R29 + 4]> */
		/* 820C81E4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 820C81E4h case    8:*/		return 0x820C81E8;
		  /* 820C81E8h */ case    9:  		/* addi R11, R10, 16 */
		/* 820C81E8h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x10);
		/* 820C81E8h case    9:*/		return 0x820C81EC;
		  /* 820C81ECh */ case   10:  		/* lwz R9, <#[R3 + 12]> */
		/* 820C81ECh case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C81ECh case   10:*/		return 0x820C81F0;
		  /* 820C81F0h */ case   11:  		/* cmplw CR6, R11, R9 */
		/* 820C81F0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820C81F0h case   11:*/		return 0x820C81F4;
		  /* 820C81F4h */ case   12:  		/* bc 12, CR6_GT, -60 */
		/* 820C81F4h case   12:*/		if ( regs.CR[6].gt ) { return 0x820C81B8;  }
		/* 820C81F4h case   12:*/		return 0x820C81F8;
		  /* 820C81F8h */ case   13:  		/* lwz R11, <#[R3 + 8]> */
		/* 820C81F8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C81F8h case   13:*/		return 0x820C81FC;
		  /* 820C81FCh */ case   14:  		/* addi R8, R1, 84 */
		/* 820C81FCh case   14:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x54);
		/* 820C81FCh case   14:*/		return 0x820C8200;
		  /* 820C8200h */ case   15:  		/* stw R26, <#[R1 + 80]> */
		/* 820C8200h case   15:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 820C8200h case   15:*/		return 0x820C8204;
		  /* 820C8204h */ case   16:  		/* addi R7, R1, 80 */
		/* 820C8204h case   16:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 820C8204h case   16:*/		return 0x820C8208;
		  /* 820C8208h */ case   17:  		/* stw R26, <#[R1 + 84]> */
		/* 820C8208h case   17:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000054) );
		/* 820C8208h case   17:*/		return 0x820C820C;
		  /* 820C820Ch */ case   18:  		/* add R30, R11, R10 */
		/* 820C820Ch case   18:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 820C820Ch case   18:*/		return 0x820C8210;
		  /* 820C8210h */ case   19:  		/* li R6, 1 */
		/* 820C8210h case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 820C8210h case   19:*/		return 0x820C8214;
		  /* 820C8214h */ case   20:  		/* mr R5, R30 */
		/* 820C8214h case   20:*/		regs.R5 = regs.R30;
		/* 820C8214h case   20:*/		return 0x820C8218;
		  /* 820C8218h */ case   21:  		/* addi R4, R1, 96 */
		/* 820C8218h case   21:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820C8218h case   21:*/		return 0x820C821C;
		  /* 820C821Ch */ case   22:  		/* bl -17012 */
		/* 820C821Ch case   22:*/		regs.LR = 0x820C8220; return 0x820C3FA8;
		/* 820C821Ch case   22:*/		return 0x820C8220;
	}
	return 0x820C8220;
} // Block from 820C81C4h-820C8220h (23 instructions)

//////////////////////////////////////////////////////
// Block at 820C8220h
// Function '?SetValue@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPBXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8220);
		  /* 820C8220h */ case    0:  		/* lhz R9, <#[R31 + 12]> */
		/* 820C8220h case    0:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 820C8220h case    0:*/		return 0x820C8224;
		  /* 820C8224h */ case    1:  		/* lhz R10, <#[R31 + 10]> */
		/* 820C8224h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000A) );
		/* 820C8224h case    1:*/		return 0x820C8228;
		  /* 820C8228h */ case    2:  		/* lwz R8, <#[R1 + 80]> */
		/* 820C8228h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 820C8228h case    2:*/		return 0x820C822C;
		  /* 820C822Ch */ case    3:  		/* add R10, R9, R10 */
		/* 820C822Ch case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820C822Ch case    3:*/		return 0x820C8230;
		  /* 820C8230h */ case    4:  		/* lhz R11, <#[R1 + 102]> */
		/* 820C8230h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000066) );
		/* 820C8230h case    4:*/		return 0x820C8234;
		  /* 820C8234h */ case    5:  		/* lwz R9, <#[R29]> */
		/* 820C8234h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 820C8234h case    5:*/		return 0x820C8238;
		  /* 820C8238h */ case    6:  		/* stw R9, <#[R1 + 96]> */
		/* 820C8238h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 820C8238h case    6:*/		return 0x820C823C;
		  /* 820C823Ch */ case    7:  		/* lwz R9, <#[R29 + 4]> */
		/* 820C823Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000004) );
		/* 820C823Ch case    7:*/		return 0x820C8240;
		  /* 820C8240h */ case    8:  		/* stw R9, <#[R1 + 108]> */
		/* 820C8240h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000006C) );
		/* 820C8240h case    8:*/		return 0x820C8244;
		  /* 820C8244h */ case    9:  		/* lhz R9, <#[R30 + 8]> */
		/* 820C8244h case    9:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 820C8244h case    9:*/		return 0x820C8248;
		  /* 820C8248h */ case   10:  		/* mullw R9, R9, R8 */
		/* 820C8248h case   10:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820C8248h case   10:*/		return 0x820C824C;
		  /* 820C824Ch */ case   11:  		/* rlwinm R9, R9, 0, 16, 31 */
		/* 820C824Ch case   11:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R9);
		/* 820C824Ch case   11:*/		return 0x820C8250;
		  /* 820C8250h */ case   12:  		/* add R8, R9, R11 */
		/* 820C8250h case   12:*/		cpu::op::add<0>(regs,&regs.R8,regs.R9,regs.R11);
		/* 820C8250h case   12:*/		return 0x820C8254;
		  /* 820C8254h */ case   13:  		/* sth R9, <#[R1 + 104]> */
		/* 820C8254h case   13:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x00000068) );
		/* 820C8254h case   13:*/		return 0x820C8258;
		  /* 820C8258h */ case   14:  		/* cmpw CR6, R8, R10 */
		/* 820C8258h case   14:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R10);
		/* 820C8258h case   14:*/		return 0x820C825C;
		  /* 820C825Ch */ case   15:  		/* bc 4, CR6_GT, 36 */
		/* 820C825Ch case   15:*/		if ( !regs.CR[6].gt ) { return 0x820C8280;  }
		/* 820C825Ch case   15:*/		return 0x820C8260;
		  /* 820C8260h */ case   16:  		/* subf R10, R11, R10 */
		/* 820C8260h case   16:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 820C8260h case   16:*/		return 0x820C8264;
		  /* 820C8264h */ case   17:  		/* mr R11, R26 */
		/* 820C8264h case   17:*/		regs.R11 = regs.R26;
		/* 820C8264h case   17:*/		return 0x820C8268;
		  /* 820C8268h */ case   18:  		/* xoris R9, R26, 32768 */
		/* 820C8268h case   18:*/		cpu::op::xoris<0>(regs,&regs.R9,regs.R26,0x8000);
		/* 820C8268h case   18:*/		return 0x820C826C;
		  /* 820C826Ch */ case   19:  		/* subf R11, R11, R10 */
		/* 820C826Ch case   19:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C826Ch case   19:*/		return 0x820C8270;
		  /* 820C8270h */ case   20:  		/* addc R11, R11, R9 */
		/* 820C8270h case   20:*/		cpu::op::addc<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820C8270h case   20:*/		return 0x820C8274;
		  /* 820C8274h */ case   21:  		/* subfe R11, R11, R11 */
		/* 820C8274h case   21:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820C8274h case   21:*/		return 0x820C8278;
		  /* 820C8278h */ case   22:  		/* and R11, R11, R10 */
		/* 820C8278h case   22:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C8278h case   22:*/		return 0x820C827C;
		  /* 820C827Ch */ case   23:  		/* sth R11, <#[R1 + 104]> */
		/* 820C827Ch case   23:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820C827Ch case   23:*/		return 0x820C8280;
	}
	return 0x820C8280;
} // Block from 820C8220h-820C8280h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820C8280h
// Function '?SetBool@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8280);
		  /* 820C8280h */ case    0:  		/* mr R6, R25 */
		/* 820C8280h case    0:*/		regs.R6 = regs.R25;
		/* 820C8280h case    0:*/		return 0x820C8284;
		  /* 820C8284h */ case    1:  		/* lwz R3, <#[R31]> */
		/* 820C8284h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820C8284h case    1:*/		return 0x820C8288;
		  /* 820C8288h */ case    2:  		/* mr R5, R30 */
		/* 820C8288h case    2:*/		regs.R5 = regs.R30;
		/* 820C8288h case    2:*/		return 0x820C828C;
		  /* 820C828Ch */ case    3:  		/* addi R4, R1, 96 */
		/* 820C828Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820C828Ch case    3:*/		return 0x820C8290;
		  /* 820C8290h */ case    4:  		/* bl -1248 */
		/* 820C8290h case    4:*/		regs.LR = 0x820C8294; return 0x820C7DB0;
		/* 820C8290h case    4:*/		return 0x820C8294;
		  /* 820C8294h */ case    5:  		/* lwz R11, <#[R31 + 56]> */
		/* 820C8294h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820C8294h case    5:*/		return 0x820C8298;
		  /* 820C8298h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820C8298h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C8298h case    6:*/		return 0x820C829C;
		  /* 820C829Ch */ case    7:  		/* stwx R3, <#[R28 + R11]> */
		/* 820C829Ch case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820C829Ch case    7:*/		return 0x820C82A0;
		  /* 820C82A0h */ case    8:  		/* bc 12, CR0_EQ, -332 */
		/* 820C82A0h case    8:*/		if ( regs.CR[0].eq ) { return 0x820C8154;  }
		/* 820C82A0h case    8:*/		return 0x820C82A4;
		  /* 820C82A4h */ case    9:  		/* lhz R11, <#[R1 + 102]> */
		/* 820C82A4h case    9:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000066) );
		/* 820C82A4h case    9:*/		return 0x820C82A8;
		  /* 820C82A8h */ case   10:  		/* lhz R10, <#[R1 + 104]> */
		/* 820C82A8h case   10:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 820C82A8h case   10:*/		return 0x820C82AC;
		  /* 820C82ACh */ case   11:  		/* lhz R9, <#[R1 + 100]> */
		/* 820C82ACh case   11:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000064) );
		/* 820C82ACh case   11:*/		return 0x820C82B0;
		  /* 820C82B0h */ case   12:  		/* add R11, R11, R10 */
		/* 820C82B0h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C82B0h case   12:*/		return 0x820C82B4;
		  /* 820C82B4h */ case   13:  		/* cmplwi CR0, R9, 0 */
		/* 820C82B4h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 820C82B4h case   13:*/		return 0x820C82B8;
		  /* 820C82B8h */ case   14:  		/* sth R11, <#[R1 + 102]> */
		/* 820C82B8h case   14:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000066) );
		/* 820C82B8h case   14:*/		return 0x820C82BC;
		  /* 820C82BCh */ case   15:  		/* li R10, 1 */
		/* 820C82BCh case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820C82BCh case   15:*/		return 0x820C82C0;
		  /* 820C82C0h */ case   16:  		/* bc 12, CR0_EQ, 8 */
		/* 820C82C0h case   16:*/		if ( regs.CR[0].eq ) { return 0x820C82C8;  }
		/* 820C82C0h case   16:*/		return 0x820C82C4;
		  /* 820C82C4h */ case   17:  		/* li R10, 4 */
		/* 820C82C4h case   17:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820C82C4h case   17:*/		return 0x820C82C8;
	}
	return 0x820C82C8;
} // Block from 820C8280h-820C82C8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820C82C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C82C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C82C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C82C8);
		  /* 820C82C8h */ case    0:  		/* lwz R11, <#[R31 + 56]> */
		/* 820C82C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 820C82C8h case    0:*/		return 0x820C82CC;
		  /* 820C82CCh */ case    1:  		/* cmplwi CR6, R9, 0 */
		/* 820C82CCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820C82CCh case    1:*/		return 0x820C82D0;
		  /* 820C82D0h */ case    2:  		/* lhz R9, <#[R30 + 8]> */
		/* 820C82D0h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 820C82D0h case    2:*/		return 0x820C82D4;
		  /* 820C82D4h */ case    3:  		/* lwz R8, <#[R1 + 112]> */
		/* 820C82D4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000070) );
		/* 820C82D4h case    3:*/		return 0x820C82D8;
		  /* 820C82D8h */ case    4:  		/* lwzx R7, <#[R28 + R11]> */
		/* 820C82D8h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820C82D8h case    4:*/		return 0x820C82DC;
		  /* 820C82DCh */ case    5:  		/* lwz R7, <#[R7 + 44]> */
		/* 820C82DCh case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x0000002C) );
		/* 820C82DCh case    5:*/		return 0x820C82E0;
		  /* 820C82E0h */ case    6:  		/* mullw R9, R7, R9 */
		/* 820C82E0h case    6:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820C82E0h case    6:*/		return 0x820C82E4;
		  /* 820C82E4h */ case    7:  		/* mullw R10, R9, R10 */
		/* 820C82E4h case    7:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820C82E4h case    7:*/		return 0x820C82E8;
		  /* 820C82E8h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 820C82E8h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 820C82E8h case    8:*/		return 0x820C82EC;
		  /* 820C82ECh */ case    9:  		/* add R10, R10, R8 */
		/* 820C82ECh case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820C82ECh case    9:*/		return 0x820C82F0;
	}
	return 0x820C82F0;
} // Block from 820C82C8h-820C82F0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C82F0h
// Function '?SetBoolArray@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPBHI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C82F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C82F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C82F0);
		  /* 820C82F0h */ case    0:  		/* stw R10, <#[R1 + 112]> */
		/* 820C82F0h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 820C82F0h case    0:*/		return 0x820C82F4;
		  /* 820C82F4h */ case    1:  		/* li R10, 1 */
		/* 820C82F4h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820C82F4h case    1:*/		return 0x820C82F8;
		  /* 820C82F8h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 820C82F8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C8300;  }
		/* 820C82F8h case    2:*/		return 0x820C82FC;
		  /* 820C82FCh */ case    3:  		/* li R10, 4 */
		/* 820C82FCh case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820C82FCh case    3:*/		return 0x820C8300;
	}
	return 0x820C8300;
} // Block from 820C82F0h-820C8300h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C8300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8300);
		  /* 820C8300h */ case    0:  		/* lwzx R11, <#[R28 + R11]> */
		/* 820C8300h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 820C8300h case    0:*/		return 0x820C8304;
		  /* 820C8304h */ case    1:  		/* addi R27, R27, 1 */
		/* 820C8304h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820C8304h case    1:*/		return 0x820C8308;
		  /* 820C8308h */ case    2:  		/* lhz R9, <#[R30 + 8]> */
		/* 820C8308h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 820C8308h case    2:*/		return 0x820C830C;
		  /* 820C830Ch */ case    3:  		/* addi R29, R29, 8 */
		/* 820C830Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x8);
		/* 820C830Ch case    3:*/		return 0x820C8310;
		  /* 820C8310h */ case    4:  		/* lwz R8, <#[R31 + 24]> */
		/* 820C8310h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 820C8310h case    4:*/		return 0x820C8314;
		  /* 820C8314h */ case    5:  		/* addi R28, R28, 4 */
		/* 820C8314h case    5:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 820C8314h case    5:*/		return 0x820C8318;
		  /* 820C8318h */ case    6:  		/* lwz R11, <#[R11 + 44]> */
		/* 820C8318h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 820C8318h case    6:*/		return 0x820C831C;
		  /* 820C831Ch */ case    7:  		/* mullw R11, R11, R9 */
		/* 820C831Ch case    7:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820C831Ch case    7:*/		return 0x820C8320;
		  /* 820C8320h */ case    8:  		/* lhz R9, <#[R8 + 10]> */
		/* 820C8320h case    8:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R8 + 0x0000000A) );
		/* 820C8320h case    8:*/		return 0x820C8324;
		  /* 820C8324h */ case    9:  		/* mullw R11, R11, R10 */
		/* 820C8324h case    9:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C8324h case    9:*/		return 0x820C8328;
		  /* 820C8328h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C8328h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C8328h case   10:*/		return 0x820C832C;
		  /* 820C832Ch */ case   11:  		/* cmplw CR6, R27, R9 */
		/* 820C832Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R9);
		/* 820C832Ch case   11:*/		return 0x820C8330;
		  /* 820C8330h */ case   12:  		/* add R25, R11, R25 */
		/* 820C8330h case   12:*/		cpu::op::add<0>(regs,&regs.R25,regs.R11,regs.R25);
		/* 820C8330h case   12:*/		return 0x820C8334;
		  /* 820C8334h */ case   13:  		/* bc 12, CR6_LT, -340 */
		/* 820C8334h case   13:*/		if ( regs.CR[6].lt ) { return 0x820C81E0;  }
		/* 820C8334h case   13:*/		return 0x820C8338;
	}
	return 0x820C8338;
} // Block from 820C8300h-820C8338h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C8338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8338);
		  /* 820C8338h */ case    0:  		/* li R3, 0 */
		/* 820C8338h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C8338h case    0:*/		return 0x820C833C;
	}
	return 0x820C833C;
} // Block from 820C8338h-820C833Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C833Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C833C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C833C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C833C);
		  /* 820C833Ch */ case    0:  		/* addi R1, R1, 192 */
		/* 820C833Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820C833Ch case    0:*/		return 0x820C8340;
		  /* 820C8340h */ case    1:  		/* b -225444 */
		/* 820C8340h case    1:*/		return 0x8209129C;
		/* 820C8340h case    1:*/		return 0x820C8344;
		  /* 820C8344h */ case    2:  		/* nop */
		/* 820C8344h case    2:*/		cpu::op::nop();
		/* 820C8344h case    2:*/		return 0x820C8348;
	}
	return 0x820C8348;
} // Block from 820C833Ch-820C8348h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8348);
		  /* 820C8348h */ case    0:  		/* mfspr R12, LR */
		/* 820C8348h case    0:*/		regs.R12 = regs.LR;
		/* 820C8348h case    0:*/		return 0x820C834C;
		  /* 820C834Ch */ case    1:  		/* bl -225520 */
		/* 820C834Ch case    1:*/		regs.LR = 0x820C8350; return 0x8209125C;
		/* 820C834Ch case    1:*/		return 0x820C8350;
	}
	return 0x820C8350;
} // Block from 820C8348h-820C8350h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8350h
// Function '?SetInt@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8350);
		  /* 820C8350h */ case    0:  		/* stwu R1, <#[R1 - 144]> */
		/* 820C8350h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820C8350h case    0:*/		return 0x820C8354;
		  /* 820C8354h */ case    1:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C8354h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C8354h case    1:*/		return 0x820C8358;
		  /* 820C8358h */ case    2:  		/* mr R31, R3 */
		/* 820C8358h case    2:*/		regs.R31 = regs.R3;
		/* 820C8358h case    2:*/		return 0x820C835C;
		  /* 820C835Ch */ case    3:  		/* mr R30, R4 */
		/* 820C835Ch case    3:*/		regs.R30 = regs.R4;
		/* 820C835Ch case    3:*/		return 0x820C8360;
		  /* 820C8360h */ case    4:  		/* lhz R11, <#[R11 + 8]> */
		/* 820C8360h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C8360h case    4:*/		return 0x820C8364;
		  /* 820C8364h */ case    5:  		/* cmplw CR6, R4, R11 */
		/* 820C8364h case    5:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 820C8364h case    5:*/		return 0x820C8368;
		  /* 820C8368h */ case    6:  		/* bc 12, CR6_LT, 12 */
		/* 820C8368h case    6:*/		if ( regs.CR[6].lt ) { return 0x820C8374;  }
		/* 820C8368h case    6:*/		return 0x820C836C;
		  /* 820C836Ch */ case    7:  		/* li R3, 0 */
		/* 820C836Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C836Ch case    7:*/		return 0x820C8370;
		  /* 820C8370h */ case    8:  		/* b 512 */
		/* 820C8370h case    8:*/		return 0x820C8570;
		/* 820C8370h case    8:*/		return 0x820C8374;
	}
	return 0x820C8374;
} // Block from 820C8350h-820C8374h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C8374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8374);
		  /* 820C8374h */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 820C8374h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C8374h case    0:*/		return 0x820C8378;
		  /* 820C8378h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820C8378h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C8384;  }
		/* 820C8378h case    1:*/		return 0x820C837C;
		  /* 820C837Ch */ case    2:  		/* mr R3, R31 */
		/* 820C837Ch case    2:*/		regs.R3 = regs.R31;
		/* 820C837Ch case    2:*/		return 0x820C8380;
		  /* 820C8380h */ case    3:  		/* b 496 */
		/* 820C8380h case    3:*/		return 0x820C8570;
		/* 820C8380h case    3:*/		return 0x820C8384;
	}
	return 0x820C8384;
} // Block from 820C8374h-820C8384h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C8384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8384);
		  /* 820C8384h */ case    0:  		/* lwz R10, <#[R31 + 60]> */
		/* 820C8384h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C8384h case    0:*/		return 0x820C8388;
		  /* 820C8388h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 820C8388h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C8388h case    1:*/		return 0x820C838C;
		  /* 820C838Ch */ case    2:  		/* bc 4, CR6_EQ, 48 */
		/* 820C838Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C83BC;  }
		/* 820C838Ch case    2:*/		return 0x820C8390;
		  /* 820C8390h */ case    3:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820C8390h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820C8390h case    3:*/		return 0x820C8394;
		  /* 820C8394h */ case    4:  		/* lis R4, 9345 */
		/* 820C8394h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C8394h case    4:*/		return 0x820C8398;
		  /* 820C8398h */ case    5:  		/* bl -262552 */
		/* 820C8398h case    5:*/		regs.LR = 0x820C839C; return 0x82088200;
		/* 820C8398h case    5:*/		return 0x820C839C;
		  /* 820C839Ch */ case    6:  		/* stw R3, <#[R31 + 60]> */
		/* 820C839Ch case    6:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C839Ch case    6:*/		return 0x820C83A0;
		  /* 820C83A0h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 820C83A0h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C83A0h case    7:*/		return 0x820C83A4;
		  /* 820C83A4h */ case    8:  		/* bc 12, CR0_EQ, -56 */
		/* 820C83A4h case    8:*/		if ( regs.CR[0].eq ) { return 0x820C836C;  }
		/* 820C83A4h case    8:*/		return 0x820C83A8;
		  /* 820C83A8h */ case    9:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C83A8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C83A8h case    9:*/		return 0x820C83AC;
		  /* 820C83ACh */ case   10:  		/* li R4, 0 */
		/* 820C83ACh case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C83ACh case   10:*/		return 0x820C83B0;
		  /* 820C83B0h */ case   11:  		/* lhz R11, <#[R11 + 8]> */
		/* 820C83B0h case   11:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C83B0h case   11:*/		return 0x820C83B4;
		  /* 820C83B4h */ case   12:  		/* rlwinm R5, R11, 2, 0, 31 */
		/* 820C83B4h case   12:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R5,regs.R11);
		/* 820C83B4h case   12:*/		return 0x820C83B8;
		  /* 820C83B8h */ case   13:  		/* bl -225400 */
		/* 820C83B8h case   13:*/		regs.LR = 0x820C83BC; return 0x82091340;
		/* 820C83B8h case   13:*/		return 0x820C83BC;
	}
	return 0x820C83BC;
} // Block from 820C8384h-820C83BCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C83BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C83BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C83BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C83BC);
		  /* 820C83BCh */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 820C83BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C83BCh case    0:*/		return 0x820C83C0;
	}
	return 0x820C83C0;
} // Block from 820C83BCh-820C83C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C83C0h
// Function '?SetIntArray@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPBHI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C83C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C83C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C83C0);
		  /* 820C83C0h */ case    0:  		/* rlwinm R29, R30, 2, 0, 29 */
		/* 820C83C0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R30);
		/* 820C83C0h case    0:*/		return 0x820C83C4;
		  /* 820C83C4h */ case    1:  		/* lwzx R11, <#[R29 + R11]> */
		/* 820C83C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820C83C4h case    1:*/		return 0x820C83C8;
		  /* 820C83C8h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820C83C8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C83C8h case    2:*/		return 0x820C83CC;
		  /* 820C83CCh */ case    3:  		/* bc 4, CR6_EQ, 412 */
		/* 820C83CCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C8568;  }
		/* 820C83CCh case    3:*/		return 0x820C83D0;
		  /* 820C83D0h */ case    4:  		/* lwz R11, <#[R31 + 64]> */
		/* 820C83D0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820C83D0h case    4:*/		return 0x820C83D4;
		  /* 820C83D4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820C83D4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C83D4h case    5:*/		return 0x820C83D8;
		  /* 820C83D8h */ case    6:  		/* bc 4, CR6_EQ, 76 */
		/* 820C83D8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820C8424;  }
		/* 820C83D8h case    6:*/		return 0x820C83DC;
		  /* 820C83DCh */ case    7:  		/* lis R4, 9345 */
		/* 820C83DCh case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C83DCh case    7:*/		return 0x820C83E0;
		  /* 820C83E0h */ case    8:  		/* li R3, 16 */
		/* 820C83E0h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x10);
		/* 820C83E0h case    8:*/		return 0x820C83E4;
		  /* 820C83E4h */ case    9:  		/* bl -262628 */
		/* 820C83E4h case    9:*/		regs.LR = 0x820C83E8; return 0x82088200;
		/* 820C83E4h case    9:*/		return 0x820C83E8;
		  /* 820C83E8h */ case   10:  		/* stw R3, <#[R31 + 64]> */
		/* 820C83E8h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000040) );
		/* 820C83E8h case   10:*/		return 0x820C83EC;
		  /* 820C83ECh */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820C83ECh case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C83ECh case   11:*/		return 0x820C83F0;
		  /* 820C83F0h */ case   12:  		/* bc 12, CR0_EQ, -132 */
		/* 820C83F0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820C836C;  }
		/* 820C83F0h case   12:*/		return 0x820C83F4;
		  /* 820C83F4h */ case   13:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C83F4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C83F4h case   13:*/		return 0x820C83F8;
		  /* 820C83F8h */ case   14:  		/* li R10, 1 */
		/* 820C83F8h case   14:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820C83F8h case   14:*/		return 0x820C83FC;
		  /* 820C83FCh */ case   15:  		/* lwz R9, <#[R11]> */
		/* 820C83FCh case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C83FCh case   15:*/		return 0x820C8400;
		  /* 820C8400h */ case   16:  		/* stw R9, <#[R3]> */
		/* 820C8400h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 820C8400h case   16:*/		return 0x820C8404;
		  /* 820C8404h */ case   17:  		/* lwz R9, <#[R11 + 4]> */
		/* 820C8404h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820C8404h case   17:*/		return 0x820C8408;
		  /* 820C8408h */ case   18:  		/* stw R9, <#[R3 + 4]> */
		/* 820C8408h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C8408h case   18:*/		return 0x820C840C;
		  /* 820C840Ch */ case   19:  		/* lwz R9, <#[R11 + 8]> */
		/* 820C840Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820C840Ch case   19:*/		return 0x820C8410;
		  /* 820C8410h */ case   20:  		/* stw R9, <#[R3 + 8]> */
		/* 820C8410h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 820C8410h case   20:*/		return 0x820C8414;
		  /* 820C8414h */ case   21:  		/* lwz R11, <#[R11 + 12]> */
		/* 820C8414h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C8414h case   21:*/		return 0x820C8418;
		  /* 820C8418h */ case   22:  		/* stw R11, <#[R3 + 12]> */
		/* 820C8418h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C8418h case   22:*/		return 0x820C841C;
		  /* 820C841Ch */ case   23:  		/* lwz R11, <#[R31 + 64]> */
		/* 820C841Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000040) );
		/* 820C841Ch case   23:*/		return 0x820C8420;
	}
	return 0x820C8420;
} // Block from 820C83C0h-820C8420h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820C8420h
// Function '?SetFloat@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IM@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8420);
		  /* 820C8420h */ case    0:  		/* sth R10, <#[R11 + 8]> */
		/* 820C8420h case    0:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820C8420h case    0:*/		return 0x820C8424;
	}
	return 0x820C8424;
} // Block from 820C8420h-820C8424h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8424);
		  /* 820C8424h */ case    0:  		/* li R11, 5 */
		/* 820C8424h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820C8424h case    0:*/		return 0x820C8428;
		  /* 820C8428h */ case    1:  		/* addi R10, R1, 76 */
		/* 820C8428h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x4C);
		/* 820C8428h case    1:*/		return 0x820C842C;
		  /* 820C842Ch */ case    2:  		/* mr R9, R31 */
		/* 820C842Ch case    2:*/		regs.R9 = regs.R31;
		/* 820C842Ch case    2:*/		return 0x820C8430;
		  /* 820C8430h */ case    3:  		/* mtspr CTR, R11 */
		/* 820C8430h case    3:*/		regs.CTR = regs.R11;
		/* 820C8430h case    3:*/		return 0x820C8434;
		  /* 820C8434h */ case    4:  		/* lwzu R11, <#[R9 + 4]> */
		/* 820C8434h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 820C8434h case    4:*/		return 0x820C8438;
		  /* 820C8438h */ case    5:  		/* stwu R11, <#[R10 + 4]> */
		/* 820C8438h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 820C8438h case    5:*/		return 0x820C843C;
		  /* 820C843Ch */ case    6:  		/* bc 16, CR0_LT, -8 */
		/* 820C843Ch case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C8434;  }
		/* 820C843Ch case    6:*/		return 0x820C8440;
		  /* 820C8440h */ case    7:  		/* lwz R11, <#[R31 + 44]> */
		/* 820C8440h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820C8440h case    7:*/		return 0x820C8444;
		  /* 820C8444h */ case    8:  		/* lhz R10, <#[R31 + 10]> */
		/* 820C8444h case    8:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000A) );
		/* 820C8444h case    8:*/		return 0x820C8448;
		  /* 820C8448h */ case    9:  		/* mullw R8, R11, R30 */
		/* 820C8448h case    9:*/		cpu::op::mullw<0>(regs,&regs.R8,regs.R11,regs.R30);
		/* 820C8448h case    9:*/		return 0x820C844C;
		  /* 820C844Ch */ case   10:  		/* lhz R7, <#[R31 + 12]> */
		/* 820C844Ch case   10:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000000C) );
		/* 820C844Ch case   10:*/		return 0x820C8450;
		  /* 820C8450h */ case   11:  		/* add R8, R8, R10 */
		/* 820C8450h case   11:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 820C8450h case   11:*/		return 0x820C8454;
		  /* 820C8454h */ case   12:  		/* rlwinm R9, R11, 0, 16, 31 */
		/* 820C8454h case   12:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R11);
		/* 820C8454h case   12:*/		return 0x820C8458;
		  /* 820C8458h */ case   13:  		/* rlwinm R8, R8, 0, 16, 31 */
		/* 820C8458h case   13:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R8,regs.R8);
		/* 820C8458h case   13:*/		return 0x820C845C;
		  /* 820C845Ch */ case   14:  		/* sth R9, <#[R1 + 88]> */
		/* 820C845Ch case   14:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 820C845Ch case   14:*/		return 0x820C8460;
		  /* 820C8460h */ case   15:  		/* sth R8, <#[R1 + 86]> */
		/* 820C8460h case   15:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R1 + 0x00000056) );
		/* 820C8460h case   15:*/		return 0x820C8464;
		  /* 820C8464h */ case   16:  		/* subf R8, R8, R7 */
		/* 820C8464h case   16:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 820C8464h case   16:*/		return 0x820C8468;
		  /* 820C8468h */ case   17:  		/* add R10, R8, R10 */
		/* 820C8468h case   17:*/		cpu::op::add<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 820C8468h case   17:*/		return 0x820C846C;
		  /* 820C846Ch */ case   18:  		/* cmpw CR6, R9, R10 */
		/* 820C846Ch case   18:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R10);
		/* 820C846Ch case   18:*/		return 0x820C8470;
		  /* 820C8470h */ case   19:  		/* bc 4, CR6_GT, 32 */
		/* 820C8470h case   19:*/		if ( !regs.CR[6].gt ) { return 0x820C8490;  }
		/* 820C8470h case   19:*/		return 0x820C8474;
		  /* 820C8474h */ case   20:  		/* li R9, 0 */
		/* 820C8474h case   20:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C8474h case   20:*/		return 0x820C8478;
		  /* 820C8478h */ case   21:  		/* xoris R8, R9, 32768 */
		/* 820C8478h case   21:*/		cpu::op::xoris<0>(regs,&regs.R8,regs.R9,0x8000);
		/* 820C8478h case   21:*/		return 0x820C847C;
		  /* 820C847Ch */ case   22:  		/* subf R9, R9, R10 */
		/* 820C847Ch case   22:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 820C847Ch case   22:*/		return 0x820C8480;
		  /* 820C8480h */ case   23:  		/* addc R9, R9, R8 */
		/* 820C8480h case   23:*/		cpu::op::addc<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820C8480h case   23:*/		return 0x820C8484;
		  /* 820C8484h */ case   24:  		/* subfe R9, R9, R9 */
		/* 820C8484h case   24:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 820C8484h case   24:*/		return 0x820C8488;
		  /* 820C8488h */ case   25:  		/* and R10, R9, R10 */
		/* 820C8488h case   25:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820C8488h case   25:*/		return 0x820C848C;
		  /* 820C848Ch */ case   26:  		/* sth R10, <#[R1 + 88]> */
		/* 820C848Ch case   26:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 820C848Ch case   26:*/		return 0x820C8490;
	}
	return 0x820C8490;
} // Block from 820C8424h-820C8490h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820C8490h
// Function '?SetFloatArray@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPBMI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8490);
		  /* 820C8490h */ case    0:  		/* lhz R10, <#[R31 + 8]> */
		/* 820C8490h case    0:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C8490h case    0:*/		return 0x820C8494;
		  /* 820C8494h */ case    1:  		/* cmplwi CR0, R10, 0 */
		/* 820C8494h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820C8494h case    1:*/		return 0x820C8498;
		  /* 820C8498h */ case    2:  		/* li R10, 1 */
		/* 820C8498h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820C8498h case    2:*/		return 0x820C849C;
		  /* 820C849Ch */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 820C849Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x820C84A4;  }
		/* 820C849Ch case    3:*/		return 0x820C84A0;
		  /* 820C84A0h */ case    4:  		/* li R10, 4 */
		/* 820C84A0h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820C84A0h case    4:*/		return 0x820C84A4;
	}
	return 0x820C84A4;
} // Block from 820C8490h-820C84A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C84A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C84A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C84A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C84A4);
		  /* 820C84A4h */ case    0:  		/* lwz R8, <#[R31 + 20]> */
		/* 820C84A4h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000014) );
		/* 820C84A4h case    0:*/		return 0x820C84A8;
		  /* 820C84A8h */ case    1:  		/* cmplwi CR6, R8, 0 */
		/* 820C84A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 820C84A8h case    1:*/		return 0x820C84AC;
		  /* 820C84ACh */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 820C84ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x820C84C4;  }
		/* 820C84ACh case    2:*/		return 0x820C84B0;
		  /* 820C84B0h */ case    3:  		/* mullw R9, R11, R10 */
		/* 820C84B0h case    3:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 820C84B0h case    3:*/		return 0x820C84B4;
		  /* 820C84B4h */ case    4:  		/* mullw R9, R9, R30 */
		/* 820C84B4h case    4:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R30);
		/* 820C84B4h case    4:*/		return 0x820C84B8;
		  /* 820C84B8h */ case    5:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 820C84B8h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 820C84B8h case    5:*/		return 0x820C84BC;
		  /* 820C84BCh */ case    6:  		/* add R9, R9, R8 */
		/* 820C84BCh case    6:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820C84BCh case    6:*/		return 0x820C84C0;
		  /* 820C84C0h */ case    7:  		/* stw R9, <#[R1 + 96]> */
		/* 820C84C0h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 820C84C0h case    7:*/		return 0x820C84C4;
	}
	return 0x820C84C4;
} // Block from 820C84A4h-820C84C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C84C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C84C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C84C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C84C4);
		  /* 820C84C4h */ case    0:  		/* mullw R11, R11, R10 */
		/* 820C84C4h case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C84C4h case    0:*/		return 0x820C84C8;
		  /* 820C84C8h */ case    1:  		/* lwz R10, <#[R31 + 32]> */
		/* 820C84C8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 820C84C8h case    1:*/		return 0x820C84CC;
		  /* 820C84CCh */ case    2:  		/* mullw R11, R11, R30 */
		/* 820C84CCh case    2:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 820C84CCh case    2:*/		return 0x820C84D0;
		  /* 820C84D0h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820C84D0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820C84D0h case    3:*/		return 0x820C84D4;
		  /* 820C84D4h */ case    4:  		/* lis R4, 9345 */
		/* 820C84D4h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C84D4h case    4:*/		return 0x820C84D8;
		  /* 820C84D8h */ case    5:  		/* li R3, 68 */
		/* 820C84D8h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x44);
		/* 820C84D8h case    5:*/		return 0x820C84DC;
		  /* 820C84DCh */ case    6:  		/* add R30, R11, R10 */
		/* 820C84DCh case    6:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R10);
		/* 820C84DCh case    6:*/		return 0x820C84E0;
		  /* 820C84E0h */ case    7:  		/* bl -262880 */
		/* 820C84E0h case    7:*/		regs.LR = 0x820C84E4; return 0x82088200;
		/* 820C84E0h case    7:*/		return 0x820C84E4;
		  /* 820C84E4h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 820C84E4h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C84E4h case    8:*/		return 0x820C84E8;
		  /* 820C84E8h */ case    9:  		/* bc 12, CR0_EQ, 32 */
		/* 820C84E8h case    9:*/		if ( regs.CR[0].eq ) { return 0x820C8508;  }
		/* 820C84E8h case    9:*/		return 0x820C84EC;
		  /* 820C84ECh */ case   10:  		/* mr R8, R30 */
		/* 820C84ECh case   10:*/		regs.R8 = regs.R30;
		/* 820C84ECh case   10:*/		return 0x820C84F0;
	}
	return 0x820C84F0;
} // Block from 820C84C4h-820C84F0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C84F0h
// Function '?SetVector@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPBUD3DXVECTOR4@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C84F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C84F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C84F0);
		  /* 820C84F0h */ case    0:  		/* lwz R7, <#[R31 + 28]> */
		/* 820C84F0h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000001C) );
		/* 820C84F0h case    0:*/		return 0x820C84F4;
		  /* 820C84F4h */ case    1:  		/* addi R5, R1, 80 */
		/* 820C84F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820C84F4h case    1:*/		return 0x820C84F8;
		  /* 820C84F8h */ case    2:  		/* lwz R6, <#[R31 + 64]> */
		/* 820C84F8h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000040) );
		/* 820C84F8h case    2:*/		return 0x820C84FC;
		  /* 820C84FCh */ case    3:  		/* lwz R4, <#[R31]> */
		/* 820C84FCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 820C84FCh case    3:*/		return 0x820C8500;
		  /* 820C8500h */ case    4:  		/* bl -17480 */
		/* 820C8500h case    4:*/		regs.LR = 0x820C8504; return 0x820C40B8;
		/* 820C8500h case    4:*/		return 0x820C8504;
		  /* 820C8504h */ case    5:  		/* b 8 */
		/* 820C8504h case    5:*/		return 0x820C850C;
		/* 820C8504h case    5:*/		return 0x820C8508;
	}
	return 0x820C8508;
} // Block from 820C84F0h-820C8508h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C8508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8508);
		  /* 820C8508h */ case    0:  		/* li R3, 0 */
		/* 820C8508h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C8508h case    0:*/		return 0x820C850C;
	}
	return 0x820C850C;
} // Block from 820C8508h-820C850Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C850Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C850C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C850C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C850C);
		  /* 820C850Ch */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 820C850Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C850Ch case    0:*/		return 0x820C8510;
		  /* 820C8510h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C8510h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C8510h case    1:*/		return 0x820C8514;
		  /* 820C8514h */ case    2:  		/* stwx R3, <#[R29 + R11]> */
		/* 820C8514h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820C8514h case    2:*/		return 0x820C8518;
		  /* 820C8518h */ case    3:  		/* bc 12, CR6_EQ, -428 */
		/* 820C8518h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C836C;  }
		/* 820C8518h case    3:*/		return 0x820C851C;
		  /* 820C851Ch */ case    4:  		/* lwz R11, <#[R31 + 60]> */
		/* 820C851Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C851Ch case    4:*/		return 0x820C8520;
		  /* 820C8520h */ case    5:  		/* lwzx R3, <#[R29 + R11]> */
		/* 820C8520h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820C8520h case    5:*/		return 0x820C8524;
		  /* 820C8524h */ case    6:  		/* bl -1036 */
		/* 820C8524h case    6:*/		regs.LR = 0x820C8528; return 0x820C8118;
		/* 820C8524h case    6:*/		return 0x820C8528;
		  /* 820C8528h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820C8528h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8528h case    7:*/		return 0x820C852C;
		  /* 820C852Ch */ case    8:  		/* bc 4, CR0_LT, 60 */
		/* 820C852Ch case    8:*/		if ( !regs.CR[0].lt ) { return 0x820C8568;  }
		/* 820C852Ch case    8:*/		return 0x820C8530;
		  /* 820C8530h */ case    9:  		/* lwz R11, <#[R31 + 60]> */
		/* 820C8530h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C8530h case    9:*/		return 0x820C8534;
		  /* 820C8534h */ case   10:  		/* lwzx R30, <#[R29 + R11]> */
		/* 820C8534h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820C8534h case   10:*/		return 0x820C8538;
		  /* 820C8538h */ case   11:  		/* cmplwi CR6, R30, 0 */
		/* 820C8538h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C8538h case   11:*/		return 0x820C853C;
		  /* 820C853Ch */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 820C853Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820C8554;  }
		/* 820C853Ch case   12:*/		return 0x820C8540;
		  /* 820C8540h */ case   13:  		/* mr R3, R30 */
		/* 820C8540h case   13:*/		regs.R3 = regs.R30;
		/* 820C8540h case   13:*/		return 0x820C8544;
		  /* 820C8544h */ case   14:  		/* bl -16372 */
		/* 820C8544h case   14:*/		regs.LR = 0x820C8548; return 0x820C4550;
		/* 820C8544h case   14:*/		return 0x820C8548;
	}
	return 0x820C8548;
} // Block from 820C850Ch-820C8548h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C8548h
// Function '?SetVectorArray@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPBUD3DXVECTOR4@@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8548);
		  /* 820C8548h */ case    0:  		/* lis R4, 9345 */
		/* 820C8548h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C8548h case    0:*/		return 0x820C854C;
		  /* 820C854Ch */ case    1:  		/* mr R3, R30 */
		/* 820C854Ch case    1:*/		regs.R3 = regs.R30;
		/* 820C854Ch case    1:*/		return 0x820C8550;
		  /* 820C8550h */ case    2:  		/* bl -262680 */
		/* 820C8550h case    2:*/		regs.LR = 0x820C8554; return 0x82088338;
		/* 820C8550h case    2:*/		return 0x820C8554;
	}
	return 0x820C8554;
} // Block from 820C8548h-820C8554h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8554);
		  /* 820C8554h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 820C8554h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C8554h case    0:*/		return 0x820C8558;
		  /* 820C8558h */ case    1:  		/* li R10, 0 */
		/* 820C8558h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C8558h case    1:*/		return 0x820C855C;
		  /* 820C855Ch */ case    2:  		/* li R3, 0 */
		/* 820C855Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C855Ch case    2:*/		return 0x820C8560;
		  /* 820C8560h */ case    3:  		/* stwx R10, <#[R29 + R11]> */
		/* 820C8560h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820C8560h case    3:*/		return 0x820C8564;
		  /* 820C8564h */ case    4:  		/* b 12 */
		/* 820C8564h case    4:*/		return 0x820C8570;
		/* 820C8564h case    4:*/		return 0x820C8568;
	}
	return 0x820C8568;
} // Block from 820C8554h-820C8568h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C8568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8568);
		  /* 820C8568h */ case    0:  		/* lwz R11, <#[R31 + 60]> */
		/* 820C8568h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000003C) );
		/* 820C8568h case    0:*/		return 0x820C856C;
		  /* 820C856Ch */ case    1:  		/* lwzx R3, <#[R29 + R11]> */
		/* 820C856Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 820C856Ch case    1:*/		return 0x820C8570;
	}
	return 0x820C8570;
} // Block from 820C8568h-820C8570h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8570);
		  /* 820C8570h */ case    0:  		/* addi R1, R1, 144 */
		/* 820C8570h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820C8570h case    0:*/		return 0x820C8574;
		  /* 820C8574h */ case    1:  		/* b -225992 */
		/* 820C8574h case    1:*/		return 0x820912AC;
		/* 820C8574h case    1:*/		return 0x820C8578;
	}
	return 0x820C8578;
} // Block from 820C8570h-820C8578h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8578h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8578);
		  /* 820C8578h */ case    0:  		/* lis R10, -32255 */
		/* 820C8578h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C8578h case    0:*/		return 0x820C857C;
		  /* 820C857Ch */ case    1:  		/* li R11, 0 */
		/* 820C857Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C857Ch case    1:*/		return 0x820C8580;
		  /* 820C8580h */ case    2:  		/* li R9, 1 */
		/* 820C8580h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820C8580h case    2:*/		return 0x820C8584;
		  /* 820C8584h */ case    3:  		/* addi R10, R10, 10376 */
		/* 820C8584h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2888);
		/* 820C8584h case    3:*/		return 0x820C8588;
		  /* 820C8588h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 820C8588h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C8588h case    4:*/		return 0x820C858C;
		  /* 820C858Ch */ case    5:  		/* stw R9, <#[R3 + 4]> */
		/* 820C858Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C858Ch case    5:*/		return 0x820C8590;
		  /* 820C8590h */ case    6:  		/* stw R10, <#[R3]> */
		/* 820C8590h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C8590h case    6:*/		return 0x820C8594;
		  /* 820C8594h */ case    7:  		/* stw R11, <#[R3 + 12]> */
		/* 820C8594h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C8594h case    7:*/		return 0x820C8598;
		  /* 820C8598h */ case    8:  		/* stw R11, <#[R3 + 20]> */
		/* 820C8598h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820C8598h case    8:*/		return 0x820C859C;
		  /* 820C859Ch */ case    9:  		/* stw R11, <#[R3 + 24]> */
		/* 820C859Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C859Ch case    9:*/		return 0x820C85A0;
		  /* 820C85A0h */ case   10:  		/* stw R11, <#[R3 + 28]> */
		/* 820C85A0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820C85A0h case   10:*/		return 0x820C85A4;
		  /* 820C85A4h */ case   11:  		/* bclr 20, CR0_LT */
		/* 820C85A4h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C85A4h case   11:*/		return 0x820C85A8;
	}
	return 0x820C85A8;
} // Block from 820C8578h-820C85A8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C85A8h
// Function '?SetMatrix@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPBUD3DXMATRIX@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C85A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C85A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C85A8);
		  /* 820C85A8h */ case    0:  		/* mfspr R12, LR */
		/* 820C85A8h case    0:*/		regs.R12 = regs.LR;
		/* 820C85A8h case    0:*/		return 0x820C85AC;
		  /* 820C85ACh */ case    1:  		/* bl -226136 */
		/* 820C85ACh case    1:*/		regs.LR = 0x820C85B0; return 0x82091254;
		/* 820C85ACh case    1:*/		return 0x820C85B0;
		  /* 820C85B0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C85B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C85B0h case    2:*/		return 0x820C85B4;
		  /* 820C85B4h */ case    3:  		/* stw R5, <#[R3 + 12]> */
		/* 820C85B4h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C85B4h case    3:*/		return 0x820C85B8;
		  /* 820C85B8h */ case    4:  		/* mr R31, R3 */
		/* 820C85B8h case    4:*/		regs.R31 = regs.R3;
		/* 820C85B8h case    4:*/		return 0x820C85BC;
		  /* 820C85BCh */ case    5:  		/* mr R30, R4 */
		/* 820C85BCh case    5:*/		regs.R30 = regs.R4;
		/* 820C85BCh case    5:*/		return 0x820C85C0;
		  /* 820C85C0h */ case    6:  		/* lis R4, 9345 */
		/* 820C85C0h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C85C0h case    6:*/		return 0x820C85C4;
		  /* 820C85C4h */ case    7:  		/* mr R3, R5 */
		/* 820C85C4h case    7:*/		regs.R3 = regs.R5;
		/* 820C85C4h case    7:*/		return 0x820C85C8;
		  /* 820C85C8h */ case    8:  		/* mr R29, R6 */
		/* 820C85C8h case    8:*/		regs.R29 = regs.R6;
		/* 820C85C8h case    8:*/		return 0x820C85CC;
		  /* 820C85CCh */ case    9:  		/* bl -263116 */
		/* 820C85CCh case    9:*/		regs.LR = 0x820C85D0; return 0x82088200;
		/* 820C85CCh case    9:*/		return 0x820C85D0;
		  /* 820C85D0h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 820C85D0h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C85D0h case   10:*/		return 0x820C85D4;
		  /* 820C85D4h */ case   11:  		/* stw R3, <#[R31 + 8]> */
		/* 820C85D4h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820C85D4h case   11:*/		return 0x820C85D8;
		  /* 820C85D8h */ case   12:  		/* bc 4, CR0_EQ, 16 */
		/* 820C85D8h case   12:*/		if ( !regs.CR[0].eq ) { return 0x820C85E8;  }
		/* 820C85D8h case   12:*/		return 0x820C85DC;
		  /* 820C85DCh */ case   13:  		/* lis R3, -32761 */
		/* 820C85DCh case   13:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8007);
		/* 820C85DCh case   13:*/		return 0x820C85E0;
		  /* 820C85E0h */ case   14:  		/* ori R3, R3, 14 */
		/* 820C85E0h case   14:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xE);
		/* 820C85E0h case   14:*/		return 0x820C85E4;
		  /* 820C85E4h */ case   15:  		/* b 488 */
		/* 820C85E4h case   15:*/		return 0x820C87CC;
		/* 820C85E4h case   15:*/		return 0x820C85E8;
	}
	return 0x820C85E8;
} // Block from 820C85A8h-820C85E8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C85E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C85E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C85E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C85E8);
		  /* 820C85E8h */ case    0:  		/* lwz R5, <#[R31 + 12]> */
		/* 820C85E8h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 820C85E8h case    0:*/		return 0x820C85EC;
		  /* 820C85ECh */ case    1:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 820C85ECh case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 820C85ECh case    1:*/		return 0x820C85F0;
		  /* 820C85F0h */ case    2:  		/* bc 12, CR0_EQ, 20 */
		/* 820C85F0h case    2:*/		if ( regs.CR[0].eq ) { return 0x820C8604;  }
		/* 820C85F0h case    2:*/		return 0x820C85F4;
		  /* 820C85F4h */ case    3:  		/* mr R4, R3 */
		/* 820C85F4h case    3:*/		regs.R4 = regs.R3;
		/* 820C85F4h case    3:*/		return 0x820C85F8;
		  /* 820C85F8h */ case    4:  		/* mr R3, R30 */
		/* 820C85F8h case    4:*/		regs.R3 = regs.R30;
		/* 820C85F8h case    4:*/		return 0x820C85FC;
		  /* 820C85FCh */ case    5:  		/* bl -385708 */
		/* 820C85FCh case    5:*/		regs.LR = 0x820C8600; return 0x8206A350;
		/* 820C85FCh case    5:*/		return 0x820C8600;
	}
	return 0x820C8600;
} // Block from 820C85E8h-820C8600h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C8600h
// Function '?SetMatrixArray@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPBUD3DXMATRIX@@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8600);
		  /* 820C8600h */ case    0:  		/* b 12 */
		/* 820C8600h case    0:*/		return 0x820C860C;
		/* 820C8600h case    0:*/		return 0x820C8604;
	}
	return 0x820C8604;
} // Block from 820C8600h-820C8604h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8604);
		  /* 820C8604h */ case    0:  		/* mr R4, R30 */
		/* 820C8604h case    0:*/		regs.R4 = regs.R30;
		/* 820C8604h case    0:*/		return 0x820C8608;
		  /* 820C8608h */ case    1:  		/* bl -224344 */
		/* 820C8608h case    1:*/		regs.LR = 0x820C860C; return 0x820919B0;
		/* 820C8608h case    1:*/		return 0x820C860C;
	}
	return 0x820C860C;
} // Block from 820C8604h-820C860Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C860Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C860C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C860C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C860C);
		  /* 820C860Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 820C860Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820C860Ch case    0:*/		return 0x820C8610;
		  /* 820C8610h */ case    1:  		/* stw R11, <#[R31 + 16]> */
		/* 820C8610h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820C8610h case    1:*/		return 0x820C8614;
		  /* 820C8614h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 820C8614h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C8614h case    2:*/		return 0x820C8618;
		  /* 820C8618h */ case    3:  		/* cmplwi CR6, R10, 28 */
		/* 820C8618h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001C);
		/* 820C8618h case    3:*/		return 0x820C861C;
		  /* 820C861Ch */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 820C861Ch case    4:*/		if ( !regs.CR[6].lt ) { return 0x820C862C;  }
		/* 820C861Ch case    4:*/		return 0x820C8620;
		  /* 820C8620h */ case    5:  		/* lis R3, -30602 */
		/* 820C8620h case    5:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820C8620h case    5:*/		return 0x820C8624;
		  /* 820C8624h */ case    6:  		/* ori R3, R3, 2905 */
		/* 820C8624h case    6:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xB59);
		/* 820C8624h case    6:*/		return 0x820C8628;
		  /* 820C8628h */ case    7:  		/* b 420 */
		/* 820C8628h case    7:*/		return 0x820C87CC;
		/* 820C8628h case    7:*/		return 0x820C862C;
	}
	return 0x820C862C;
} // Block from 820C860Ch-820C862Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C862Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C862C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C862C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C862C);
		  /* 820C862Ch */ case    0:  		/* lwz R11, <#[R11 + 12]> */
		/* 820C862Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C862Ch case    0:*/		return 0x820C8630;
		  /* 820C8630h */ case    1:  		/* lis R4, 9345 */
		/* 820C8630h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C8630h case    1:*/		return 0x820C8634;
		  /* 820C8634h */ case    2:  		/* rlwinm R3, R11, 2, 0, 29 */
		/* 820C8634h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R11);
		/* 820C8634h case    2:*/		return 0x820C8638;
		  /* 820C8638h */ case    3:  		/* bl -263224 */
		/* 820C8638h case    3:*/		regs.LR = 0x820C863C; return 0x82088200;
		/* 820C8638h case    3:*/		return 0x820C863C;
		  /* 820C863Ch */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820C863Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C863Ch case    4:*/		return 0x820C8640;
		  /* 820C8640h */ case    5:  		/* stw R3, <#[R31 + 20]> */
		/* 820C8640h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820C8640h case    5:*/		return 0x820C8644;
		  /* 820C8644h */ case    6:  		/* bc 12, CR0_EQ, -104 */
		/* 820C8644h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C85DC;  }
		/* 820C8644h case    6:*/		return 0x820C8648;
		  /* 820C8648h */ case    7:  		/* lwz R11, <#[R31 + 16]> */
		/* 820C8648h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820C8648h case    7:*/		return 0x820C864C;
		  /* 820C864Ch */ case    8:  		/* li R4, 0 */
		/* 820C864Ch case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C864Ch case    8:*/		return 0x820C8650;
		  /* 820C8650h */ case    9:  		/* lwz R11, <#[R11 + 12]> */
		/* 820C8650h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C8650h case    9:*/		return 0x820C8654;
		  /* 820C8654h */ case   10:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 820C8654h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 820C8654h case   10:*/		return 0x820C8658;
		  /* 820C8658h */ case   11:  		/* bl -226072 */
		/* 820C8658h case   11:*/		regs.LR = 0x820C865C; return 0x82091340;
		/* 820C8658h case   11:*/		return 0x820C865C;
		  /* 820C865Ch */ case   12:  		/* lwz R11, <#[R31 + 16]> */
		/* 820C865Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820C865Ch case   12:*/		return 0x820C8660;
	}
	return 0x820C8660;
} // Block from 820C862Ch-820C8660h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C8660h
// Function '?SetMatrixPointerArray@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPAPBUD3DXMATRIX@@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8660);
		  /* 820C8660h */ case    0:  		/* lwz R9, <#[R31 + 12]> */
		/* 820C8660h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000000C) );
		/* 820C8660h case    0:*/		return 0x820C8664;
		  /* 820C8664h */ case    1:  		/* lwz R10, <#[R11 + 12]> */
		/* 820C8664h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C8664h case    1:*/		return 0x820C8668;
		  /* 820C8668h */ case    2:  		/* stw R10, <#[R31 + 24]> */
		/* 820C8668h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 820C8668h case    2:*/		return 0x820C866C;
		  /* 820C866Ch */ case    3:  		/* lwz R10, <#[R11 + 16]> */
		/* 820C866Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820C866Ch case    3:*/		return 0x820C8670;
		  /* 820C8670h */ case    4:  		/* lwz R11, <#[R11 + 12]> */
		/* 820C8670h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C8670h case    4:*/		return 0x820C8674;
		  /* 820C8674h */ case    5:  		/* mulli R11, R11, 20 */
		/* 820C8674h case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x14);
		/* 820C8674h case    5:*/		return 0x820C8678;
		  /* 820C8678h */ case    6:  		/* add R11, R11, R10 */
		/* 820C8678h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C8678h case    6:*/		return 0x820C867C;
		  /* 820C867Ch */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 820C867Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820C867Ch case    7:*/		return 0x820C8680;
		  /* 820C8680h */ case    8:  		/* bc 12, CR6_GT, -96 */
		/* 820C8680h case    8:*/		if ( regs.CR[6].gt ) { return 0x820C8620;  }
		/* 820C8680h case    8:*/		return 0x820C8684;
		  /* 820C8684h */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 820C8684h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820C8684h case    9:*/		return 0x820C8688;
		  /* 820C8688h */ case   10:  		/* li R27, 0 */
		/* 820C8688h case   10:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820C8688h case   10:*/		return 0x820C868C;
		  /* 820C868Ch */ case   11:  		/* lwz R9, <#[R31 + 24]> */
		/* 820C868Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 820C868Ch case   11:*/		return 0x820C8690;
		  /* 820C8690h */ case   12:  		/* li R28, 0 */
		/* 820C8690h case   12:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 820C8690h case   12:*/		return 0x820C8694;
		  /* 820C8694h */ case   13:  		/* add R11, R11, R10 */
		/* 820C8694h case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C8694h case   13:*/		return 0x820C8698;
		  /* 820C8698h */ case   14:  		/* cmplwi CR6, R9, 0 */
		/* 820C8698h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820C8698h case   14:*/		return 0x820C869C;
		  /* 820C869Ch */ case   15:  		/* bc 4, CR6_GT, 152 */
		/* 820C869Ch case   15:*/		if ( !regs.CR[6].gt ) { return 0x820C8734;  }
		/* 820C869Ch case   15:*/		return 0x820C86A0;
		  /* 820C86A0h */ case   16:  		/* li R30, 0 */
		/* 820C86A0h case   16:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C86A0h case   16:*/		return 0x820C86A4;
		  /* 820C86A4h */ case   17:  		/* addi R29, R11, 12 */
		/* 820C86A4h case   17:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xC);
		/* 820C86A4h case   17:*/		return 0x820C86A8;
		  /* 820C86A8h */ case   18:  		/* lwz R11, <#[R29]> */
		/* 820C86A8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820C86A8h case   18:*/		return 0x820C86AC;
		  /* 820C86ACh */ case   19:  		/* lwz R10, <#[R31 + 12]> */
		/* 820C86ACh case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 820C86ACh case   19:*/		return 0x820C86B0;
		  /* 820C86B0h */ case   20:  		/* addi R9, R11, 16 */
		/* 820C86B0h case   20:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x10);
		/* 820C86B0h case   20:*/		return 0x820C86B4;
		  /* 820C86B4h */ case   21:  		/* cmplw CR6, R9, R10 */
		/* 820C86B4h case   21:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 820C86B4h case   21:*/		return 0x820C86B8;
		  /* 820C86B8h */ case   22:  		/* bc 12, CR6_GT, -152 */
		/* 820C86B8h case   22:*/		if ( regs.CR[6].gt ) { return 0x820C8620;  }
		/* 820C86B8h case   22:*/		return 0x820C86BC;
		  /* 820C86BCh */ case   23:  		/* lwz R10, <#[R31 + 8]> */
		/* 820C86BCh case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 820C86BCh case   23:*/		return 0x820C86C0;
	}
	return 0x820C86C0;
} // Block from 820C8660h-820C86C0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820C86C0h
// Function '?SetMatrixTranspose@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPBUD3DXMATRIX@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C86C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C86C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C86C0);
		  /* 820C86C0h */ case    0:  		/* li R6, 0 */
		/* 820C86C0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C86C0h case    0:*/		return 0x820C86C4;
		  /* 820C86C4h */ case    1:  		/* addi R4, R29, -12 */
		/* 820C86C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0xFFFFFFF4);
		/* 820C86C4h case    1:*/		return 0x820C86C8;
		  /* 820C86C8h */ case    2:  		/* add R5, R10, R11 */
		/* 820C86C8h case    2:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R11);
		/* 820C86C8h case    2:*/		return 0x820C86CC;
		  /* 820C86CCh */ case    3:  		/* mr R3, R31 */
		/* 820C86CCh case    3:*/		regs.R3 = regs.R31;
		/* 820C86CCh case    3:*/		return 0x820C86D0;
		  /* 820C86D0h */ case    4:  		/* bl -2336 */
		/* 820C86D0h case    4:*/		regs.LR = 0x820C86D4; return 0x820C7DB0;
		/* 820C86D0h case    4:*/		return 0x820C86D4;
		  /* 820C86D4h */ case    5:  		/* lwz R11, <#[R31 + 20]> */
		/* 820C86D4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820C86D4h case    5:*/		return 0x820C86D8;
		  /* 820C86D8h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820C86D8h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C86D8h case    6:*/		return 0x820C86DC;
		  /* 820C86DCh */ case    7:  		/* stwx R3, <#[R11 + R30]> */
		/* 820C86DCh case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 820C86DCh case    7:*/		return 0x820C86E0;
		  /* 820C86E0h */ case    8:  		/* bc 12, CR0_EQ, -260 */
		/* 820C86E0h case    8:*/		if ( regs.CR[0].eq ) { return 0x820C85DC;  }
		/* 820C86E0h case    8:*/		return 0x820C86E4;
		  /* 820C86E4h */ case    9:  		/* lwz R10, <#[R31 + 20]> */
		/* 820C86E4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820C86E4h case    9:*/		return 0x820C86E8;
		  /* 820C86E8h */ case   10:  		/* lwzx R11, <#[R10 + R30]> */
		/* 820C86E8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 820C86E8h case   10:*/		return 0x820C86EC;
		  /* 820C86ECh */ case   11:  		/* lhz R11, <#[R11 + 8]> */
		/* 820C86ECh case   11:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 820C86ECh case   11:*/		return 0x820C86F0;
		  /* 820C86F0h */ case   12:  		/* cmplwi CR0, R11, 0 */
		/* 820C86F0h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C86F0h case   12:*/		return 0x820C86F4;
		  /* 820C86F4h */ case   13:  		/* li R11, 1 */
		/* 820C86F4h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820C86F4h case   13:*/		return 0x820C86F8;
		  /* 820C86F8h */ case   14:  		/* bc 12, CR0_EQ, 8 */
		/* 820C86F8h case   14:*/		if ( regs.CR[0].eq ) { return 0x820C8700;  }
		/* 820C86F8h case   14:*/		return 0x820C86FC;
		  /* 820C86FCh */ case   15:  		/* li R11, 4 */
		/* 820C86FCh case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 820C86FCh case   15:*/		return 0x820C8700;
	}
	return 0x820C8700;
} // Block from 820C86C0h-820C8700h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C8700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8700);
		  /* 820C8700h */ case    0:  		/* lwzx R10, <#[R10 + R30]> */
		/* 820C8700h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 820C8700h case    0:*/		return 0x820C8704;
		  /* 820C8704h */ case    1:  		/* addi R28, R28, 1 */
		/* 820C8704h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 820C8704h case    1:*/		return 0x820C8708;
		  /* 820C8708h */ case    2:  		/* lwz R9, <#[R31 + 24]> */
		/* 820C8708h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 820C8708h case    2:*/		return 0x820C870C;
		  /* 820C870Ch */ case    3:  		/* addi R29, R29, 20 */
		/* 820C870Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x14);
		/* 820C870Ch case    3:*/		return 0x820C8710;
		  /* 820C8710h */ case    4:  		/* addi R30, R30, 4 */
		/* 820C8710h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C8710h case    4:*/		return 0x820C8714;
		  /* 820C8714h */ case    5:  		/* cmplw CR6, R28, R9 */
		/* 820C8714h case    5:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R9);
		/* 820C8714h case    5:*/		return 0x820C8718;
	}
	return 0x820C8718;
} // Block from 820C8700h-820C8718h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C8718h
// Function '?SetMatrixTransposeArray@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPBUD3DXMATRIX@@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8718);
		  /* 820C8718h */ case    0:  		/* lwz R9, <#[R10 + 24]> */
		/* 820C8718h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000018) );
		/* 820C8718h case    0:*/		return 0x820C871C;
		  /* 820C871Ch */ case    1:  		/* lwz R10, <#[R10 + 44]> */
		/* 820C871Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000002C) );
		/* 820C871Ch case    1:*/		return 0x820C8720;
		  /* 820C8720h */ case    2:  		/* lhz R9, <#[R9 + 8]> */
		/* 820C8720h case    2:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 820C8720h case    2:*/		return 0x820C8724;
		  /* 820C8724h */ case    3:  		/* mullw R10, R9, R10 */
		/* 820C8724h case    3:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820C8724h case    3:*/		return 0x820C8728;
		  /* 820C8728h */ case    4:  		/* mullw R11, R10, R11 */
		/* 820C8728h case    4:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C8728h case    4:*/		return 0x820C872C;
		  /* 820C872Ch */ case    5:  		/* add R27, R11, R27 */
		/* 820C872Ch case    5:*/		cpu::op::add<0>(regs,&regs.R27,regs.R11,regs.R27);
		/* 820C872Ch case    5:*/		return 0x820C8730;
		  /* 820C8730h */ case    6:  		/* bc 12, CR6_LT, -136 */
		/* 820C8730h case    6:*/		if ( regs.CR[6].lt ) { return 0x820C86A8;  }
		/* 820C8730h case    6:*/		return 0x820C8734;
	}
	return 0x820C8734;
} // Block from 820C8718h-820C8734h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C8734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8734);
		  /* 820C8734h */ case    0:  		/* lis R4, 9345 */
		/* 820C8734h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C8734h case    0:*/		return 0x820C8738;
		  /* 820C8738h */ case    1:  		/* rlwinm R3, R27, 2, 0, 29 */
		/* 820C8738h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R27);
		/* 820C8738h case    1:*/		return 0x820C873C;
		  /* 820C873Ch */ case    2:  		/* bl -263484 */
		/* 820C873Ch case    2:*/		regs.LR = 0x820C8740; return 0x82088200;
		/* 820C873Ch case    2:*/		return 0x820C8740;
		  /* 820C8740h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820C8740h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C8740h case    3:*/		return 0x820C8744;
		  /* 820C8744h */ case    4:  		/* stw R3, <#[R31 + 28]> */
		/* 820C8744h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 820C8744h case    4:*/		return 0x820C8748;
		  /* 820C8748h */ case    5:  		/* bc 12, CR0_EQ, -364 */
		/* 820C8748h case    5:*/		if ( regs.CR[0].eq ) { return 0x820C85DC;  }
		/* 820C8748h case    5:*/		return 0x820C874C;
		  /* 820C874Ch */ case    6:  		/* lwz R11, <#[R31 + 24]> */
		/* 820C874Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C874Ch case    6:*/		return 0x820C8750;
		  /* 820C8750h */ case    7:  		/* li R5, 0 */
		/* 820C8750h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C8750h case    7:*/		return 0x820C8754;
		  /* 820C8754h */ case    8:  		/* li R30, 0 */
		/* 820C8754h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C8754h case    8:*/		return 0x820C8758;
		  /* 820C8758h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 820C8758h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C8758h case    9:*/		return 0x820C875C;
		  /* 820C875Ch */ case   10:  		/* bc 4, CR6_GT, 108 */
		/* 820C875Ch case   10:*/		if ( !regs.CR[6].gt ) { return 0x820C87C8;  }
		/* 820C875Ch case   10:*/		return 0x820C8760;
		  /* 820C8760h */ case   11:  		/* lwz R11, <#[R31 + 20]> */
		/* 820C8760h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820C8760h case   11:*/		return 0x820C8764;
		  /* 820C8764h */ case   12:  		/* li R6, 0 */
		/* 820C8764h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C8764h case   12:*/		return 0x820C8768;
		  /* 820C8768h */ case   13:  		/* lwz R10, <#[R31 + 28]> */
		/* 820C8768h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 820C8768h case   13:*/		return 0x820C876C;
		  /* 820C876Ch */ case   14:  		/* rlwinm R9, R5, 2, 0, 29 */
		/* 820C876Ch case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R5);
		/* 820C876Ch case   14:*/		return 0x820C8770;
		  /* 820C8770h */ case   15:  		/* lwzx R3, <#[R6 + R11]> */
		/* 820C8770h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820C8770h case   15:*/		return 0x820C8774;
		  /* 820C8774h */ case   16:  		/* add R4, R9, R10 */
		/* 820C8774h case   16:*/		cpu::op::add<0>(regs,&regs.R4,regs.R9,regs.R10);
		/* 820C8774h case   16:*/		return 0x820C8778;
	}
	return 0x820C8778;
} // Block from 820C8734h-820C8778h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C8778h
// Function '?SetMatrixTransposePointerArray@CConstantTable@D3DXShader@@UAAJPAUD3DDevice@@IPAPBUD3DXMATRIX@@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8778);
		  /* 820C8778h */ case    0:  		/* bl -17944 */
		/* 820C8778h case    0:*/		regs.LR = 0x820C877C; return 0x820C4160;
		/* 820C8778h case    0:*/		return 0x820C877C;
		  /* 820C877Ch */ case    1:  		/* lwz R11, <#[R31 + 20]> */
		/* 820C877Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820C877Ch case    1:*/		return 0x820C8780;
		  /* 820C8780h */ case    2:  		/* lwzx R10, <#[R6 + R11]> */
		/* 820C8780h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820C8780h case    2:*/		return 0x820C8784;
		  /* 820C8784h */ case    3:  		/* lhz R10, <#[R10 + 8]> */
		/* 820C8784h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820C8784h case    3:*/		return 0x820C8788;
		  /* 820C8788h */ case    4:  		/* cmplwi CR0, R10, 0 */
		/* 820C8788h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820C8788h case    4:*/		return 0x820C878C;
		  /* 820C878Ch */ case    5:  		/* li R10, 1 */
		/* 820C878Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820C878Ch case    5:*/		return 0x820C8790;
		  /* 820C8790h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 820C8790h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C8798;  }
		/* 820C8790h case    6:*/		return 0x820C8794;
		  /* 820C8794h */ case    7:  		/* li R10, 4 */
		/* 820C8794h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 820C8794h case    7:*/		return 0x820C8798;
	}
	return 0x820C8798;
} // Block from 820C8778h-820C8798h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C8798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8798);
		  /* 820C8798h */ case    0:  		/* lwzx R9, <#[R6 + R11]> */
		/* 820C8798h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 820C8798h case    0:*/		return 0x820C879C;
		  /* 820C879Ch */ case    1:  		/* addi R30, R30, 1 */
		/* 820C879Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820C879Ch case    1:*/		return 0x820C87A0;
		  /* 820C87A0h */ case    2:  		/* lwz R8, <#[R31 + 24]> */
		/* 820C87A0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 820C87A0h case    2:*/		return 0x820C87A4;
		  /* 820C87A4h */ case    3:  		/* addi R6, R6, 4 */
		/* 820C87A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 820C87A4h case    3:*/		return 0x820C87A8;
		  /* 820C87A8h */ case    4:  		/* cmplw CR6, R30, R8 */
		/* 820C87A8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R8);
		/* 820C87A8h case    4:*/		return 0x820C87AC;
		  /* 820C87ACh */ case    5:  		/* lwz R8, <#[R9 + 24]> */
		/* 820C87ACh case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000018) );
		/* 820C87ACh case    5:*/		return 0x820C87B0;
		  /* 820C87B0h */ case    6:  		/* lwz R9, <#[R9 + 44]> */
		/* 820C87B0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000002C) );
		/* 820C87B0h case    6:*/		return 0x820C87B4;
		  /* 820C87B4h */ case    7:  		/* lhz R8, <#[R8 + 8]> */
		/* 820C87B4h case    7:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 820C87B4h case    7:*/		return 0x820C87B8;
		  /* 820C87B8h */ case    8:  		/* mullw R9, R8, R9 */
		/* 820C87B8h case    8:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C87B8h case    8:*/		return 0x820C87BC;
		  /* 820C87BCh */ case    9:  		/* mullw R10, R9, R10 */
		/* 820C87BCh case    9:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820C87BCh case    9:*/		return 0x820C87C0;
		  /* 820C87C0h */ case   10:  		/* add R5, R10, R5 */
		/* 820C87C0h case   10:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R5);
		/* 820C87C0h case   10:*/		return 0x820C87C4;
		  /* 820C87C4h */ case   11:  		/* bc 12, CR6_LT, -92 */
		/* 820C87C4h case   11:*/		if ( regs.CR[6].lt ) { return 0x820C8768;  }
		/* 820C87C4h case   11:*/		return 0x820C87C8;
	}
	return 0x820C87C8;
} // Block from 820C8798h-820C87C8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C87C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C87C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C87C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C87C8);
		  /* 820C87C8h */ case    0:  		/* li R3, 0 */
		/* 820C87C8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C87C8h case    0:*/		return 0x820C87CC;
	}
	return 0x820C87CC;
} // Block from 820C87C8h-820C87CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C87CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C87CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C87CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C87CC);
		  /* 820C87CCh */ case    0:  		/* addi R1, R1, 128 */
		/* 820C87CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C87CCh case    0:*/		return 0x820C87D0;
		  /* 820C87D0h */ case    1:  		/* b -226604 */
		/* 820C87D0h case    1:*/		return 0x820912A4;
		/* 820C87D0h case    1:*/		return 0x820C87D4;
		  /* 820C87D4h */ case    2:  		/* nop */
		/* 820C87D4h case    2:*/		cpu::op::nop();
		/* 820C87D4h case    2:*/		return 0x820C87D8;
	}
	return 0x820C87D8;
} // Block from 820C87CCh-820C87D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C87D8h
// Function '?Create@CConstant@D3DXShader@@SAPAV12@PAVCConstantTable@2@PAU_D3DXSHADER_CONSTANTINFO@@PAU_D3DXSHADER_TYPEINFO@@PAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C87D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C87D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C87D8);
		  /* 820C87D8h */ case    0:  		/* mfspr R12, LR */
		/* 820C87D8h case    0:*/		regs.R12 = regs.LR;
		/* 820C87D8h case    0:*/		return 0x820C87DC;
		  /* 820C87DCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C87DCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C87DCh case    1:*/		return 0x820C87E0;
		  /* 820C87E0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C87E0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C87E0h case    2:*/		return 0x820C87E4;
		  /* 820C87E4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C87E4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C87E4h case    3:*/		return 0x820C87E8;
		  /* 820C87E8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C87E8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C87E8h case    4:*/		return 0x820C87EC;
		  /* 820C87ECh */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 820C87ECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820C87ECh case    5:*/		return 0x820C87F0;
		  /* 820C87F0h */ case    6:  		/* mr R31, R3 */
		/* 820C87F0h case    6:*/		regs.R31 = regs.R3;
		/* 820C87F0h case    6:*/		return 0x820C87F4;
		  /* 820C87F4h */ case    7:  		/* addi R30, R11, -1 */
		/* 820C87F4h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFFFFF);
		/* 820C87F4h case    7:*/		return 0x820C87F8;
		  /* 820C87F8h */ case    8:  		/* cmplwi CR6, R11, 1 */
		/* 820C87F8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C87F8h case    8:*/		return 0x820C87FC;
		  /* 820C87FCh */ case    9:  		/* stw R30, <#[R3 + 4]> */
		/* 820C87FCh case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 820C87FCh case    9:*/		return 0x820C8800;
		  /* 820C8800h */ case   10:  		/* bc 4, CR6_EQ, 20 */
		/* 820C8800h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820C8814;  }
		/* 820C8800h case   10:*/		return 0x820C8804;
		  /* 820C8804h */ case   11:  		/* bl -4268 */
		/* 820C8804h case   11:*/		regs.LR = 0x820C8808; return 0x820C7758;
		/* 820C8804h case   11:*/		return 0x820C8808;
		  /* 820C8808h */ case   12:  		/* lis R4, 9345 */
		/* 820C8808h case   12:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C8808h case   12:*/		return 0x820C880C;
		  /* 820C880Ch */ case   13:  		/* mr R3, R31 */
		/* 820C880Ch case   13:*/		regs.R3 = regs.R31;
		/* 820C880Ch case   13:*/		return 0x820C8810;
		  /* 820C8810h */ case   14:  		/* bl -263384 */
		/* 820C8810h case   14:*/		regs.LR = 0x820C8814; return 0x82088338;
		/* 820C8810h case   14:*/		return 0x820C8814;
	}
	return 0x820C8814;
} // Block from 820C87D8h-820C8814h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C8814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8814);
		  /* 820C8814h */ case    0:  		/* mr R3, R30 */
		/* 820C8814h case    0:*/		regs.R3 = regs.R30;
		/* 820C8814h case    0:*/		return 0x820C8818;
		  /* 820C8818h */ case    1:  		/* addi R1, R1, 112 */
		/* 820C8818h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C8818h case    1:*/		return 0x820C881C;
		  /* 820C881Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C881Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C881Ch case    2:*/		return 0x820C8820;
		  /* 820C8820h */ case    3:  		/* mtspr LR, R12 */
		/* 820C8820h case    3:*/		regs.LR = regs.R12;
		/* 820C8820h case    3:*/		return 0x820C8824;
		  /* 820C8824h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820C8824h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C8824h case    4:*/		return 0x820C8828;
		  /* 820C8828h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820C8828h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C8828h case    5:*/		return 0x820C882C;
		  /* 820C882Ch */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C882Ch case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C882Ch case    6:*/		return 0x820C8830;
	}
	return 0x820C8830;
} // Block from 820C8814h-820C8830h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C8830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8830);
		  /* 820C8830h */ case    0:  		/* mfspr R12, LR */
		/* 820C8830h case    0:*/		regs.R12 = regs.LR;
		/* 820C8830h case    0:*/		return 0x820C8834;
		  /* 820C8834h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C8834h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C8834h case    1:*/		return 0x820C8838;
		  /* 820C8838h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C8838h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C8838h case    2:*/		return 0x820C883C;
		  /* 820C883Ch */ case    3:  		/* mr R11, R4 */
		/* 820C883Ch case    3:*/		regs.R11 = regs.R4;
		/* 820C883Ch case    3:*/		return 0x820C8840;
		  /* 820C8840h */ case    4:  		/* mr R4, R5 */
		/* 820C8840h case    4:*/		regs.R4 = regs.R5;
		/* 820C8840h case    4:*/		return 0x820C8844;
		  /* 820C8844h */ case    5:  		/* nor R3, R11, R11 */
		/* 820C8844h case    5:*/		cpu::op::nor<0>(regs,&regs.R3,regs.R11,regs.R11);
		/* 820C8844h case    5:*/		return 0x820C8848;
		  /* 820C8848h */ case    6:  		/* bl -1280 */
		/* 820C8848h case    6:*/		regs.LR = 0x820C884C; return 0x820C8348;
		/* 820C8848h case    6:*/		return 0x820C884C;
		  /* 820C884Ch */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 820C884Ch case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C884Ch case    7:*/		return 0x820C8850;
		  /* 820C8850h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 820C8850h case    8:*/		if ( regs.CR[0].eq ) { return 0x820C8858;  }
		/* 820C8850h case    8:*/		return 0x820C8854;
		  /* 820C8854h */ case    9:  		/* nor R3, R3, R3 */
		/* 820C8854h case    9:*/		cpu::op::nor<0>(regs,&regs.R3,regs.R3,regs.R3);
		/* 820C8854h case    9:*/		return 0x820C8858;
	}
	return 0x820C8858;
} // Block from 820C8830h-820C8858h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C8858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8858);
		  /* 820C8858h */ case    0:  		/* addi R1, R1, 96 */
		/* 820C8858h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C8858h case    0:*/		return 0x820C885C;
		  /* 820C885Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C885Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C885Ch case    1:*/		return 0x820C8860;
		  /* 820C8860h */ case    2:  		/* mtspr LR, R12 */
		/* 820C8860h case    2:*/		regs.LR = regs.R12;
		/* 820C8860h case    2:*/		return 0x820C8864;
		  /* 820C8864h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820C8864h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C8864h case    3:*/		return 0x820C8868;
	}
	return 0x820C8868;
} // Block from 820C8858h-820C8868h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C8868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8868);
		  /* 820C8868h */ case    0:  		/* mfspr R12, LR */
		/* 820C8868h case    0:*/		regs.R12 = regs.LR;
		/* 820C8868h case    0:*/		return 0x820C886C;
		  /* 820C886Ch */ case    1:  		/* bl -226840 */
		/* 820C886Ch case    1:*/		regs.LR = 0x820C8870; return 0x82091254;
		/* 820C886Ch case    1:*/		return 0x820C8870;
		  /* 820C8870h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C8870h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C8870h case    2:*/		return 0x820C8874;
		  /* 820C8874h */ case    3:  		/* mr R29, R3 */
		/* 820C8874h case    3:*/		regs.R29 = regs.R3;
		/* 820C8874h case    3:*/		return 0x820C8878;
		  /* 820C8878h */ case    4:  		/* mr R31, R5 */
		/* 820C8878h case    4:*/		regs.R31 = regs.R5;
		/* 820C8878h case    4:*/		return 0x820C887C;
		  /* 820C887Ch */ case    5:  		/* lbz R11, <#[R4]> */
		/* 820C887Ch case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820C887Ch case    5:*/		return 0x820C8880;
		  /* 820C8880h */ case    6:  		/* mr R30, R4 */
		/* 820C8880h case    6:*/		regs.R30 = regs.R4;
		/* 820C8880h case    6:*/		return 0x820C8884;
		  /* 820C8884h */ case    7:  		/* b 8 */
		/* 820C8884h case    7:*/		return 0x820C888C;
		/* 820C8884h case    7:*/		return 0x820C8888;
		  /* 820C8888h */ case    8:  		/* lbzu R11, <#[R30 + 1]> */
		/* 820C8888h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820C8888h case    8:*/		return 0x820C888C;
	}
	return 0x820C888C;
} // Block from 820C8868h-820C888Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C888Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C888C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C888C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C888C);
		  /* 820C888Ch */ case    0:  		/* extsb R3, R11 */
		/* 820C888Ch case    0:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820C888Ch case    0:*/		return 0x820C8890;
		  /* 820C8890h */ case    1:  		/* bl -192832 */
		/* 820C8890h case    1:*/		regs.LR = 0x820C8894; return 0x82099750;
		/* 820C8890h case    1:*/		return 0x820C8894;
		  /* 820C8894h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820C8894h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8894h case    2:*/		return 0x820C8898;
		  /* 820C8898h */ case    3:  		/* bc 4, CR0_EQ, -16 */
		/* 820C8898h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820C8888;  }
		/* 820C8898h case    3:*/		return 0x820C889C;
		  /* 820C889Ch */ case    4:  		/* lbz R11, <#[R30]> */
		/* 820C889Ch case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C889Ch case    4:*/		return 0x820C88A0;
		  /* 820C88A0h */ case    5:  		/* extsb. R11, R11 */
		/* 820C88A0h case    5:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R11);
		/* 820C88A0h case    5:*/		return 0x820C88A4;
		  /* 820C88A4h */ case    6:  		/* bc 12, CR0_EQ, 476 */
		/* 820C88A4h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C8A80;  }
		/* 820C88A4h case    6:*/		return 0x820C88A8;
		  /* 820C88A8h */ case    7:  		/* cmpwi CR6, R11, 91 */
		/* 820C88A8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005B);
		/* 820C88A8h case    7:*/		return 0x820C88AC;
		  /* 820C88ACh */ case    8:  		/* bc 4, CR6_EQ, 176 */
		/* 820C88ACh case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C895C;  }
		/* 820C88ACh case    8:*/		return 0x820C88B0;
		  /* 820C88B0h */ case    9:  		/* lbzu R11, <#[R30 + 1]> */
		/* 820C88B0h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820C88B0h case    9:*/		return 0x820C88B4;
		  /* 820C88B4h */ case   10:  		/* extsb R3, R11 */
		/* 820C88B4h case   10:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820C88B4h case   10:*/		return 0x820C88B8;
		  /* 820C88B8h */ case   11:  		/* bl -192872 */
		/* 820C88B8h case   11:*/		regs.LR = 0x820C88BC; return 0x82099750;
		/* 820C88B8h case   11:*/		return 0x820C88BC;
		  /* 820C88BCh */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 820C88BCh case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C88BCh case   12:*/		return 0x820C88C0;
		  /* 820C88C0h */ case   13:  		/* bc 4, CR0_EQ, -16 */
		/* 820C88C0h case   13:*/		if ( !regs.CR[0].eq ) { return 0x820C88B0;  }
		/* 820C88C0h case   13:*/		return 0x820C88C4;
		  /* 820C88C4h */ case   14:  		/* lbz R11, <#[R30]> */
		/* 820C88C4h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C88C4h case   14:*/		return 0x820C88C8;
		  /* 820C88C8h */ case   15:  		/* extsb R3, R11 */
		/* 820C88C8h case   15:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820C88C8h case   15:*/		return 0x820C88CC;
		  /* 820C88CCh */ case   16:  		/* bl -192956 */
		/* 820C88CCh case   16:*/		regs.LR = 0x820C88D0; return 0x82099710;
		/* 820C88CCh case   16:*/		return 0x820C88D0;
		  /* 820C88D0h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 820C88D0h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C88D0h case   17:*/		return 0x820C88D4;
		  /* 820C88D4h */ case   18:  		/* bc 12, CR0_EQ, 436 */
		/* 820C88D4h case   18:*/		if ( regs.CR[0].eq ) { return 0x820C8A88;  }
		/* 820C88D4h case   18:*/		return 0x820C88D8;
		  /* 820C88D8h */ case   19:  		/* lbz R11, <#[R30]> */
		/* 820C88D8h case   19:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C88D8h case   19:*/		return 0x820C88DC;
		  /* 820C88DCh */ case   20:  		/* li R31, 0 */
		/* 820C88DCh case   20:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C88DCh case   20:*/		return 0x820C88E0;
		  /* 820C88E0h */ case   21:  		/* extsb R3, R11 */
		/* 820C88E0h case   21:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820C88E0h case   21:*/		return 0x820C88E4;
		  /* 820C88E4h */ case   22:  		/* b 32 */
		/* 820C88E4h case   22:*/		return 0x820C8904;
		/* 820C88E4h case   22:*/		return 0x820C88E8;
		  /* 820C88E8h */ case   23:  		/* lbz R10, <#[R30]> */
		/* 820C88E8h case   23:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820C88E8h case   23:*/		return 0x820C88EC;
		  /* 820C88ECh */ case   24:  		/* mulli R11, R31, 10 */
		/* 820C88ECh case   24:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R31,0xA);
		/* 820C88ECh case   24:*/		return 0x820C88F0;
		  /* 820C88F0h */ case   25:  		/* lbzu R9, <#[R30 + 1]> */
		/* 820C88F0h case   25:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820C88F0h case   25:*/		return 0x820C88F4;
		  /* 820C88F4h */ case   26:  		/* extsb R10, R10 */
		/* 820C88F4h case   26:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820C88F4h case   26:*/		return 0x820C88F8;
		  /* 820C88F8h */ case   27:  		/* extsb R3, R9 */
		/* 820C88F8h case   27:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R9);
		/* 820C88F8h case   27:*/		return 0x820C88FC;
		  /* 820C88FCh */ case   28:  		/* add R11, R11, R10 */
		/* 820C88FCh case   28:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C88FCh case   28:*/		return 0x820C8900;
		  /* 820C8900h */ case   29:  		/* addi R31, R11, -48 */
		/* 820C8900h case   29:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFD0);
		/* 820C8900h case   29:*/		return 0x820C8904;
	}
	return 0x820C8904;
} // Block from 820C888Ch-820C8904h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820C8904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8904);
		  /* 820C8904h */ case    0:  		/* bl -193012 */
		/* 820C8904h case    0:*/		regs.LR = 0x820C8908; return 0x82099710;
		/* 820C8904h case    0:*/		return 0x820C8908;
		  /* 820C8908h */ case    1:  		/* cmpwi CR0, R3, 0 */
		/* 820C8908h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8908h case    1:*/		return 0x820C890C;
		  /* 820C890Ch */ case    2:  		/* bc 4, CR0_EQ, -36 */
		/* 820C890Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820C88E8;  }
		/* 820C890Ch case    2:*/		return 0x820C8910;
		  /* 820C8910h */ case    3:  		/* lbz R11, <#[R30]> */
		/* 820C8910h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C8910h case    3:*/		return 0x820C8914;
		  /* 820C8914h */ case    4:  		/* b 8 */
		/* 820C8914h case    4:*/		return 0x820C891C;
		/* 820C8914h case    4:*/		return 0x820C8918;
		  /* 820C8918h */ case    5:  		/* lbzu R11, <#[R30 + 1]> */
		/* 820C8918h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820C8918h case    5:*/		return 0x820C891C;
	}
	return 0x820C891C;
} // Block from 820C8904h-820C891Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C891Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C891C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C891C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C891C);
		  /* 820C891Ch */ case    0:  		/* extsb R3, R11 */
		/* 820C891Ch case    0:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820C891Ch case    0:*/		return 0x820C8920;
		  /* 820C8920h */ case    1:  		/* bl -192976 */
		/* 820C8920h case    1:*/		regs.LR = 0x820C8924; return 0x82099750;
		/* 820C8920h case    1:*/		return 0x820C8924;
		  /* 820C8924h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820C8924h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8924h case    2:*/		return 0x820C8928;
		  /* 820C8928h */ case    3:  		/* bc 4, CR0_EQ, -16 */
		/* 820C8928h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820C8918;  }
		/* 820C8928h case    3:*/		return 0x820C892C;
		  /* 820C892Ch */ case    4:  		/* lbz R11, <#[R30]> */
		/* 820C892Ch case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C892Ch case    4:*/		return 0x820C8930;
		  /* 820C8930h */ case    5:  		/* cmplwi CR6, R11, 93 */
		/* 820C8930h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005D);
		/* 820C8930h case    5:*/		return 0x820C8934;
		  /* 820C8934h */ case    6:  		/* bc 4, CR6_EQ, 340 */
		/* 820C8934h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820C8A88;  }
		/* 820C8934h case    6:*/		return 0x820C8938;
		  /* 820C8938h */ case    7:  		/* mr R4, R31 */
		/* 820C8938h case    7:*/		regs.R4 = regs.R31;
		/* 820C8938h case    7:*/		return 0x820C893C;
		  /* 820C893Ch */ case    8:  		/* mr R3, R29 */
		/* 820C893Ch case    8:*/		regs.R3 = regs.R29;
		/* 820C893Ch case    8:*/		return 0x820C8940;
		  /* 820C8940h */ case    9:  		/* bl -1528 */
		/* 820C8940h case    9:*/		regs.LR = 0x820C8944; return 0x820C8348;
		/* 820C8940h case    9:*/		return 0x820C8944;
		  /* 820C8944h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 820C8944h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C8944h case   10:*/		return 0x820C8948;
		  /* 820C8948h */ case   11:  		/* bc 12, CR0_EQ, 320 */
		/* 820C8948h case   11:*/		if ( regs.CR[0].eq ) { return 0x820C8A88;  }
		/* 820C8948h case   11:*/		return 0x820C894C;
		  /* 820C894Ch */ case   12:  		/* addi R4, R30, 1 */
		/* 820C894Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R30,0x1);
		/* 820C894Ch case   12:*/		return 0x820C8950;
		  /* 820C8950h */ case   13:  		/* mr R29, R3 */
		/* 820C8950h case   13:*/		regs.R29 = regs.R3;
		/* 820C8950h case   13:*/		return 0x820C8954;
		  /* 820C8954h */ case   14:  		/* li R31, 0 */
		/* 820C8954h case   14:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C8954h case   14:*/		return 0x820C8958;
		  /* 820C8958h */ case   15:  		/* b -220 */
		/* 820C8958h case   15:*/		return 0x820C887C;
		/* 820C8958h case   15:*/		return 0x820C895C;
	}
	return 0x820C895C;
} // Block from 820C891Ch-820C895Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C895Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C895C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C895C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C895C);
		  /* 820C895Ch */ case    0:  		/* cmpwi CR6, R11, 46 */
		/* 820C895Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002E);
		/* 820C895Ch case    0:*/		return 0x820C8960;
		  /* 820C8960h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820C8960h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C8974;  }
		/* 820C8960h case    1:*/		return 0x820C8964;
		  /* 820C8964h */ case    2:  		/* cmpwi CR6, R31, 0 */
		/* 820C8964h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 820C8964h case    2:*/		return 0x820C8968;
		  /* 820C8968h */ case    3:  		/* bc 12, CR6_EQ, 288 */
		/* 820C8968h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C8A88;  }
		/* 820C8968h case    3:*/		return 0x820C896C;
		  /* 820C896Ch */ case    4:  		/* cmpwi CR6, R11, 46 */
		/* 820C896Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002E);
		/* 820C896Ch case    4:*/		return 0x820C8970;
		  /* 820C8970h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 820C8970h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C8978;  }
		/* 820C8970h case    5:*/		return 0x820C8974;
	}
	return 0x820C8974;
} // Block from 820C895Ch-820C8974h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C8974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8974);
		  /* 820C8974h */ case    0:  		/* addi R30, R30, 1 */
		/* 820C8974h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820C8974h case    0:*/		return 0x820C8978;
	}
	return 0x820C8978;
} // Block from 820C8974h-820C8978h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8978);
		  /* 820C8978h */ case    0:  		/* lbz R11, <#[R30]> */
		/* 820C8978h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C8978h case    0:*/		return 0x820C897C;
		  /* 820C897Ch */ case    1:  		/* b 8 */
		/* 820C897Ch case    1:*/		return 0x820C8984;
		/* 820C897Ch case    1:*/		return 0x820C8980;
		  /* 820C8980h */ case    2:  		/* lbzu R11, <#[R30 + 1]> */
		/* 820C8980h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000001) );
		regs.R30 = (uint32)(regs.R30 + 0x00000001);
		/* 820C8980h case    2:*/		return 0x820C8984;
	}
	return 0x820C8984;
} // Block from 820C8978h-820C8984h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8984);
		  /* 820C8984h */ case    0:  		/* extsb R3, R11 */
		/* 820C8984h case    0:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820C8984h case    0:*/		return 0x820C8988;
		  /* 820C8988h */ case    1:  		/* bl -193080 */
		/* 820C8988h case    1:*/		regs.LR = 0x820C898C; return 0x82099750;
		/* 820C8988h case    1:*/		return 0x820C898C;
		  /* 820C898Ch */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820C898Ch case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C898Ch case    2:*/		return 0x820C8990;
		  /* 820C8990h */ case    3:  		/* bc 4, CR0_EQ, -16 */
		/* 820C8990h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820C8980;  }
		/* 820C8990h case    3:*/		return 0x820C8994;
		  /* 820C8994h */ case    4:  		/* li R31, 0 */
		/* 820C8994h case    4:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C8994h case    4:*/		return 0x820C8998;
		  /* 820C8998h */ case    5:  		/* lbzx R11, <#[R31 + R30]> */
		/* 820C8998h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + regs.R30 + 0x00000000) );
		/* 820C8998h case    5:*/		return 0x820C899C;
		  /* 820C899Ch */ case    6:  		/* add R27, R31, R30 */
		/* 820C899Ch case    6:*/		cpu::op::add<0>(regs,&regs.R27,regs.R31,regs.R30);
		/* 820C899Ch case    6:*/		return 0x820C89A0;
		  /* 820C89A0h */ case    7:  		/* extsb R3, R11 */
		/* 820C89A0h case    7:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820C89A0h case    7:*/		return 0x820C89A4;
		  /* 820C89A4h */ case    8:  		/* bl -193076 */
		/* 820C89A4h case    8:*/		regs.LR = 0x820C89A8; return 0x82099770;
		/* 820C89A4h case    8:*/		return 0x820C89A8;
		  /* 820C89A8h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820C89A8h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C89A8h case    9:*/		return 0x820C89AC;
		  /* 820C89ACh */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 820C89ACh case   10:*/		if ( !regs.CR[0].eq ) { return 0x820C89BC;  }
		/* 820C89ACh case   10:*/		return 0x820C89B0;
		  /* 820C89B0h */ case   11:  		/* lbz R11, <#[R27]> */
		/* 820C89B0h case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 820C89B0h case   11:*/		return 0x820C89B4;
		  /* 820C89B4h */ case   12:  		/* cmplwi CR6, R11, 95 */
		/* 820C89B4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820C89B4h case   12:*/		return 0x820C89B8;
		  /* 820C89B8h */ case   13:  		/* bc 4, CR6_EQ, 12 */
		/* 820C89B8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820C89C4;  }
		/* 820C89B8h case   13:*/		return 0x820C89BC;
	}
	return 0x820C89BC;
} // Block from 820C8984h-820C89BCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C89BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C89BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C89BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C89BC);
		  /* 820C89BCh */ case    0:  		/* addi R31, R31, 1 */
		/* 820C89BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820C89BCh case    0:*/		return 0x820C89C0;
		  /* 820C89C0h */ case    1:  		/* b -40 */
		/* 820C89C0h case    1:*/		return 0x820C8998;
		/* 820C89C0h case    1:*/		return 0x820C89C4;
	}
	return 0x820C89C4;
} // Block from 820C89BCh-820C89C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C89C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C89C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C89C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C89C4);
		  /* 820C89C4h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820C89C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C89C4h case    0:*/		return 0x820C89C8;
		  /* 820C89C8h */ case    1:  		/* bc 12, CR6_EQ, 192 */
		/* 820C89C8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C8A88;  }
		/* 820C89C8h case    1:*/		return 0x820C89CC;
		  /* 820C89CCh */ case    2:  		/* lwz R11, <#[R29 + 24]> */
		/* 820C89CCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 820C89CCh case    2:*/		return 0x820C89D0;
		  /* 820C89D0h */ case    3:  		/* li R3, 0 */
		/* 820C89D0h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C89D0h case    3:*/		return 0x820C89D4;
		  /* 820C89D4h */ case    4:  		/* li R5, 0 */
		/* 820C89D4h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C89D4h case    4:*/		return 0x820C89D8;
		  /* 820C89D8h */ case    5:  		/* lhz R28, <#[R11 + 10]> */
		/* 820C89D8h case    5:*/		cpu::mem::load16z( regs, &regs.R28, (uint32)(regs.R11 + 0x0000000A) );
		/* 820C89D8h case    5:*/		return 0x820C89DC;
		  /* 820C89DCh */ case    6:  		/* cmplw CR6, R3, R28 */
		/* 820C89DCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R28);
		/* 820C89DCh case    6:*/		return 0x820C89E0;
		  /* 820C89E0h */ case    7:  		/* bc 4, CR6_LT, 168 */
		/* 820C89E0h case    7:*/		if ( !regs.CR[6].lt ) { return 0x820C8A88;  }
		/* 820C89E0h case    7:*/		return 0x820C89E4;
		  /* 820C89E4h */ case    8:  		/* lwz R4, <#[R29 + 56]> */
		/* 820C89E4h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x00000038) );
		/* 820C89E4h case    8:*/		return 0x820C89E8;
		  /* 820C89E8h */ case    9:  		/* lwzx R11, <#[R5 + R4]> */
		/* 820C89E8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + regs.R4 + 0x00000000) );
		/* 820C89E8h case    9:*/		return 0x820C89EC;
		  /* 820C89ECh */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 820C89ECh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820C89ECh case   10:*/		return 0x820C89F0;
		  /* 820C89F0h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 820C89F0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C89F0h case   11:*/		return 0x820C89F4;
		  /* 820C89F4h */ case   12:  		/* bc 12, CR6_EQ, 100 */
		/* 820C89F4h case   12:*/		if ( regs.CR[6].eq ) { return 0x820C8A58;  }
		/* 820C89F4h case   12:*/		return 0x820C89F8;
		  /* 820C89F8h */ case   13:  		/* lwz R10, <#[R29]> */
		/* 820C89F8h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 820C89F8h case   13:*/		return 0x820C89FC;
		  /* 820C89FCh */ case   14:  		/* li R9, 0 */
		/* 820C89FCh case   14:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C89FCh case   14:*/		return 0x820C8A00;
		  /* 820C8A00h */ case   15:  		/* cmplwi CR6, R31, 0 */
		/* 820C8A00h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C8A00h case   15:*/		return 0x820C8A04;
		  /* 820C8A04h */ case   16:  		/* lwz R10, <#[R10 + 8]> */
		/* 820C8A04h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 820C8A04h case   16:*/		return 0x820C8A08;
		  /* 820C8A08h */ case   17:  		/* add R6, R10, R11 */
		/* 820C8A08h case   17:*/		cpu::op::add<0>(regs,&regs.R6,regs.R10,regs.R11);
		/* 820C8A08h case   17:*/		return 0x820C8A0C;
		  /* 820C8A0Ch */ case   18:  		/* bc 12, CR6_EQ, 56 */
		/* 820C8A0Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x820C8A44;  }
		/* 820C8A0Ch case   18:*/		return 0x820C8A10;
		  /* 820C8A10h */ case   19:  		/* mr R11, R30 */
		/* 820C8A10h case   19:*/		regs.R11 = regs.R30;
		/* 820C8A10h case   19:*/		return 0x820C8A14;
		  /* 820C8A14h */ case   20:  		/* subf R7, R30, R6 */
		/* 820C8A14h case   20:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R30,regs.R6);
		/* 820C8A14h case   20:*/		return 0x820C8A18;
		  /* 820C8A18h */ case   21:  		/* lbzx R10, <#[R7 + R11]> */
		/* 820C8A18h case   21:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R7 + regs.R11 + 0x00000000) );
		/* 820C8A18h case   21:*/		return 0x820C8A1C;
		  /* 820C8A1Ch */ case   22:  		/* lbz R8, <#[R11]> */
		/* 820C8A1Ch case   22:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820C8A1Ch case   22:*/		return 0x820C8A20;
		  /* 820C8A20h */ case   23:  		/* extsb R10, R10 */
		/* 820C8A20h case   23:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 820C8A20h case   23:*/		return 0x820C8A24;
		  /* 820C8A24h */ case   24:  		/* extsb R8, R8 */
		/* 820C8A24h case   24:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R8);
		/* 820C8A24h case   24:*/		return 0x820C8A28;
		  /* 820C8A28h */ case   25:  		/* cmpw CR6, R10, R8 */
		/* 820C8A28h case   25:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R8);
		/* 820C8A28h case   25:*/		return 0x820C8A2C;
		  /* 820C8A2Ch */ case   26:  		/* bc 12, CR6_LT, 44 */
		/* 820C8A2Ch case   26:*/		if ( regs.CR[6].lt ) { return 0x820C8A58;  }
		/* 820C8A2Ch case   26:*/		return 0x820C8A30;
		  /* 820C8A30h */ case   27:  		/* bc 12, CR6_GT, 40 */
		/* 820C8A30h case   27:*/		if ( regs.CR[6].gt ) { return 0x820C8A58;  }
		/* 820C8A30h case   27:*/		return 0x820C8A34;
		  /* 820C8A34h */ case   28:  		/* addi R9, R9, 1 */
		/* 820C8A34h case   28:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C8A34h case   28:*/		return 0x820C8A38;
		  /* 820C8A38h */ case   29:  		/* addi R11, R11, 1 */
		/* 820C8A38h case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C8A38h case   29:*/		return 0x820C8A3C;
		  /* 820C8A3Ch */ case   30:  		/* cmplw CR6, R9, R31 */
		/* 820C8A3Ch case   30:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 820C8A3Ch case   30:*/		return 0x820C8A40;
		  /* 820C8A40h */ case   31:  		/* bc 12, CR6_LT, -40 */
		/* 820C8A40h case   31:*/		if ( regs.CR[6].lt ) { return 0x820C8A18;  }
		/* 820C8A40h case   31:*/		return 0x820C8A44;
	}
	return 0x820C8A44;
} // Block from 820C89C4h-820C8A44h (32 instructions)

//////////////////////////////////////////////////////
// Block at 820C8A44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8A44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8A44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8A44);
		  /* 820C8A44h */ case    0:  		/* cmplw CR6, R9, R31 */
		/* 820C8A44h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 820C8A44h case    0:*/		return 0x820C8A48;
		  /* 820C8A48h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820C8A48h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C8A64;  }
		/* 820C8A48h case    1:*/		return 0x820C8A4C;
		  /* 820C8A4Ch */ case    2:  		/* lbzx R11, <#[R9 + R6]> */
		/* 820C8A4Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + regs.R6 + 0x00000000) );
		/* 820C8A4Ch case    2:*/		return 0x820C8A50;
		  /* 820C8A50h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 820C8A50h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C8A50h case    3:*/		return 0x820C8A54;
		  /* 820C8A54h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820C8A54h case    4:*/		if ( regs.CR[0].eq ) { return 0x820C8A64;  }
		/* 820C8A54h case    4:*/		return 0x820C8A58;
	}
	return 0x820C8A58;
} // Block from 820C8A44h-820C8A58h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C8A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8A58);
		  /* 820C8A58h */ case    0:  		/* addi R3, R3, 1 */
		/* 820C8A58h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 820C8A58h case    0:*/		return 0x820C8A5C;
		  /* 820C8A5Ch */ case    1:  		/* addi R5, R5, 4 */
		/* 820C8A5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 820C8A5Ch case    1:*/		return 0x820C8A60;
		  /* 820C8A60h */ case    2:  		/* b -132 */
		/* 820C8A60h case    2:*/		return 0x820C89DC;
		/* 820C8A60h case    2:*/		return 0x820C8A64;
	}
	return 0x820C8A64;
} // Block from 820C8A58h-820C8A64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8A64);
		  /* 820C8A64h */ case    0:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 820C8A64h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 820C8A64h case    0:*/		return 0x820C8A68;
		  /* 820C8A68h */ case    1:  		/* lwzx R11, <#[R11 + R4]> */
		/* 820C8A68h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 820C8A68h case    1:*/		return 0x820C8A6C;
		  /* 820C8A6Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820C8A6Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C8A6Ch case    2:*/		return 0x820C8A70;
		  /* 820C8A70h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820C8A70h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C8A88;  }
		/* 820C8A70h case    3:*/		return 0x820C8A74;
		  /* 820C8A74h */ case    4:  		/* mr R4, R27 */
		/* 820C8A74h case    4:*/		regs.R4 = regs.R27;
		/* 820C8A74h case    4:*/		return 0x820C8A78;
		  /* 820C8A78h */ case    5:  		/* mr R29, R11 */
		/* 820C8A78h case    5:*/		regs.R29 = regs.R11;
		/* 820C8A78h case    5:*/		return 0x820C8A7C;
		  /* 820C8A7Ch */ case    6:  		/* b -296 */
		/* 820C8A7Ch case    6:*/		return 0x820C8954;
		/* 820C8A7Ch case    6:*/		return 0x820C8A80;
	}
	return 0x820C8A80;
} // Block from 820C8A64h-820C8A80h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C8A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8A80);
		  /* 820C8A80h */ case    0:  		/* mr R3, R29 */
		/* 820C8A80h case    0:*/		regs.R3 = regs.R29;
		/* 820C8A80h case    0:*/		return 0x820C8A84;
		  /* 820C8A84h */ case    1:  		/* b 8 */
		/* 820C8A84h case    1:*/		return 0x820C8A8C;
		/* 820C8A84h case    1:*/		return 0x820C8A88;
	}
	return 0x820C8A88;
} // Block from 820C8A80h-820C8A88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8A88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8A88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8A88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8A88);
		  /* 820C8A88h */ case    0:  		/* li R3, 0 */
		/* 820C8A88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C8A88h case    0:*/		return 0x820C8A8C;
	}
	return 0x820C8A8C;
} // Block from 820C8A88h-820C8A8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8A8C);
		  /* 820C8A8Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 820C8A8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C8A8Ch case    0:*/		return 0x820C8A90;
		  /* 820C8A90h */ case    1:  		/* b -227308 */
		/* 820C8A90h case    1:*/		return 0x820912A4;
		/* 820C8A90h case    1:*/		return 0x820C8A94;
		  /* 820C8A94h */ case    2:  		/* nop */
		/* 820C8A94h case    2:*/		cpu::op::nop();
		/* 820C8A94h case    2:*/		return 0x820C8A98;
	}
	return 0x820C8A98;
} // Block from 820C8A8Ch-820C8A98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8A98h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8A98);
		  /* 820C8A98h */ case    0:  		/* mfspr R12, LR */
		/* 820C8A98h case    0:*/		regs.R12 = regs.LR;
		/* 820C8A98h case    0:*/		return 0x820C8A9C;
		  /* 820C8A9Ch */ case    1:  		/* bl -227396 */
		/* 820C8A9Ch case    1:*/		regs.LR = 0x820C8AA0; return 0x82091258;
		/* 820C8A9Ch case    1:*/		return 0x820C8AA0;
		  /* 820C8AA0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C8AA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C8AA0h case    2:*/		return 0x820C8AA4;
		  /* 820C8AA4h */ case    3:  		/* mr R31, R3 */
		/* 820C8AA4h case    3:*/		regs.R31 = regs.R3;
		/* 820C8AA4h case    3:*/		return 0x820C8AA8;
		  /* 820C8AA8h */ case    4:  		/* mr R3, R4 */
		/* 820C8AA8h case    4:*/		regs.R3 = regs.R4;
		/* 820C8AA8h case    4:*/		return 0x820C8AAC;
		  /* 820C8AACh */ case    5:  		/* mr R28, R5 */
		/* 820C8AACh case    5:*/		regs.R28 = regs.R5;
		/* 820C8AACh case    5:*/		return 0x820C8AB0;
		  /* 820C8AB0h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 820C8AB0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C8AB0h case    6:*/		return 0x820C8AB4;
		  /* 820C8AB4h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 820C8AB4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820C8AC4;  }
		/* 820C8AB4h case    7:*/		return 0x820C8AB8;
		  /* 820C8AB8h */ case    8:  		/* lis R3, -30602 */
		/* 820C8AB8h case    8:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820C8AB8h case    8:*/		return 0x820C8ABC;
		  /* 820C8ABCh */ case    9:  		/* ori R3, R3, 2156 */
		/* 820C8ABCh case    9:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 820C8ABCh case    9:*/		return 0x820C8AC0;
		  /* 820C8AC0h */ case   10:  		/* b 236 */
		/* 820C8AC0h case   10:*/		return 0x820C8BAC;
		/* 820C8AC0h case   10:*/		return 0x820C8AC4;
	}
	return 0x820C8AC4;
} // Block from 820C8A98h-820C8AC4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C8AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8AC4);
		  /* 820C8AC4h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820C8AC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C8AC4h case    0:*/		return 0x820C8AC8;
		  /* 820C8AC8h */ case    1:  		/* lis R10, 4138 */
		/* 820C8AC8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x102A);
		/* 820C8AC8h case    1:*/		return 0x820C8ACC;
		  /* 820C8ACCh */ case    2:  		/* li R9, 0 */
		/* 820C8ACCh case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C8ACCh case    2:*/		return 0x820C8AD0;
		  /* 820C8AD0h */ case    3:  		/* ori R10, R10, 4352 */
		/* 820C8AD0h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1100);
		/* 820C8AD0h case    3:*/		return 0x820C8AD4;
		  /* 820C8AD4h */ case    4:  		/* rlwinm R11, R11, 0, 0, 23 */
		/* 820C8AD4h case    4:*/		cpu::op::rlwinm<0,0,0,23>(regs,&regs.R11,regs.R11);
		/* 820C8AD4h case    4:*/		return 0x820C8AD8;
		  /* 820C8AD8h */ case    5:  		/* stw R9, <#[R1 + 80]> */
		/* 820C8AD8h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 820C8AD8h case    5:*/		return 0x820C8ADC;
		  /* 820C8ADCh */ case    6:  		/* li R29, 0 */
		/* 820C8ADCh case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C8ADCh case    6:*/		return 0x820C8AE0;
		  /* 820C8AE0h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 820C8AE0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C8AE0h case    7:*/		return 0x820C8AE4;
		  /* 820C8AE4h */ case    8:  		/* bc 4, CR6_EQ, 208 */
		/* 820C8AE4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C8BB4;  }
		/* 820C8AE4h case    8:*/		return 0x820C8AE8;
		  /* 820C8AE8h */ case    9:  		/* lwz R11, <#[R3 + 16]> */
		/* 820C8AE8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820C8AE8h case    9:*/		return 0x820C8AEC;
		  /* 820C8AECh */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 820C8AECh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C8AECh case   10:*/		return 0x820C8AF0;
		  /* 820C8AF0h */ case   11:  		/* bc 12, CR6_EQ, 236 */
		/* 820C8AF0h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C8BDC;  }
		/* 820C8AF0h case   11:*/		return 0x820C8AF4;
		  /* 820C8AF4h */ case   12:  		/* add R10, R11, R3 */
		/* 820C8AF4h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R3);
		/* 820C8AF4h case   12:*/		return 0x820C8AF8;
		  /* 820C8AF8h */ case   13:  		/* addi R30, R31, 12 */
		/* 820C8AF8h case   13:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0xC);
		/* 820C8AF8h case   13:*/		return 0x820C8AFC;
		  /* 820C8AFCh */ case   14:  		/* addi R10, R10, 4 */
		/* 820C8AFCh case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 820C8AFCh case   14:*/		return 0x820C8B00;
		  /* 820C8B00h */ case   15:  		/* li R29, 1 */
		/* 820C8B00h case   15:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 820C8B00h case   15:*/		return 0x820C8B04;
		  /* 820C8B04h */ case   16:  		/* stw R10, <#[R1 + 80]> */
		/* 820C8B04h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 820C8B04h case   16:*/		return 0x820C8B08;
		  /* 820C8B08h */ case   17:  		/* lwzx R11, <#[R11 + R3]> */
		/* 820C8B08h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 820C8B08h case   17:*/		return 0x820C8B0C;
		  /* 820C8B0Ch */ case   18:  		/* stw R11, <#[R31 + 12]> */
		/* 820C8B0Ch case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820C8B0Ch case   18:*/		return 0x820C8B10;
		  /* 820C8B10h */ case   19:  		/* mr R6, R29 */
		/* 820C8B10h case   19:*/		regs.R6 = regs.R29;
		/* 820C8B10h case   19:*/		return 0x820C8B14;
		  /* 820C8B14h */ case   20:  		/* lwz R5, <#[R30]> */
		/* 820C8B14h case   20:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000000) );
		/* 820C8B14h case   20:*/		return 0x820C8B18;
		  /* 820C8B18h */ case   21:  		/* mr R3, R31 */
		/* 820C8B18h case   21:*/		regs.R3 = regs.R31;
		/* 820C8B18h case   21:*/		return 0x820C8B1C;
		  /* 820C8B1Ch */ case   22:  		/* lwz R4, <#[R1 + 80]> */
		/* 820C8B1Ch case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 820C8B1Ch case   22:*/		return 0x820C8B20;
		  /* 820C8B20h */ case   23:  		/* bl -1400 */
		/* 820C8B20h case   23:*/		regs.LR = 0x820C8B24; return 0x820C85A8;
		/* 820C8B20h case   23:*/		return 0x820C8B24;
		  /* 820C8B24h */ case   24:  		/* cmpwi CR0, R3, 0 */
		/* 820C8B24h case   24:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8B24h case   24:*/		return 0x820C8B28;
		  /* 820C8B28h */ case   25:  		/* bc 12, CR0_LT, 132 */
		/* 820C8B28h case   25:*/		if ( regs.CR[0].lt ) { return 0x820C8BAC;  }
		/* 820C8B28h case   25:*/		return 0x820C8B2C;
		  /* 820C8B2Ch */ case   26:  		/* cmplwi CR6, R28, 0 */
		/* 820C8B2Ch case   26:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820C8B2Ch case   26:*/		return 0x820C8B30;
		  /* 820C8B30h */ case   27:  		/* bc 12, CR6_EQ, 120 */
		/* 820C8B30h case   27:*/		if ( regs.CR[6].eq ) { return 0x820C8BA8;  }
		/* 820C8B30h case   27:*/		return 0x820C8B34;
		  /* 820C8B34h */ case   28:  		/* lwz R10, <#[R31 + 16]> */
		/* 820C8B34h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820C8B34h case   28:*/		return 0x820C8B38;
		  /* 820C8B38h */ case   29:  		/* li R8, 0 */
		/* 820C8B38h case   29:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820C8B38h case   29:*/		return 0x820C8B3C;
		  /* 820C8B3Ch */ case   30:  		/* lwz R11, <#[R31 + 8]> */
		/* 820C8B3Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820C8B3Ch case   30:*/		return 0x820C8B40;
	}
	return 0x820C8B40;
} // Block from 820C8AC4h-820C8B40h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820C8B40h
// Function '?Initialize@CConstant@D3DXShader@@QAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8B40);
		  /* 820C8B40h */ case    0:  		/* li R7, 0 */
		/* 820C8B40h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C8B40h case    0:*/		return 0x820C8B44;
		  /* 820C8B44h */ case    1:  		/* lwz R9, <#[R31 + 24]> */
		/* 820C8B44h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 820C8B44h case    1:*/		return 0x820C8B48;
		  /* 820C8B48h */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 820C8B48h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 820C8B48h case    2:*/		return 0x820C8B4C;
		  /* 820C8B4Ch */ case    3:  		/* lwz R10, <#[R10 + 16]> */
		/* 820C8B4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000010) );
		/* 820C8B4Ch case    3:*/		return 0x820C8B50;
		  /* 820C8B50h */ case    4:  		/* add R11, R10, R11 */
		/* 820C8B50h case    4:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C8B50h case    4:*/		return 0x820C8B54;
		  /* 820C8B54h */ case    5:  		/* bc 4, CR6_GT, 64 */
		/* 820C8B54h case    5:*/		if ( !regs.CR[6].gt ) { return 0x820C8B94;  }
		/* 820C8B54h case    5:*/		return 0x820C8B58;
		  /* 820C8B58h */ case    6:  		/* rlwinm R6, R9, 0, 0, 31 */
		/* 820C8B58h case    6:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R6,regs.R9);
		/* 820C8B58h case    6:*/		return 0x820C8B5C;
		  /* 820C8B5Ch */ case    7:  		/* addi R11, R11, 8 */
		/* 820C8B5Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 820C8B5Ch case    7:*/		return 0x820C8B60;
		  /* 820C8B60h */ case    8:  		/* lhz R10, <#[R11 - 4]> */
		/* 820C8B60h case    8:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 820C8B60h case    8:*/		return 0x820C8B64;
		  /* 820C8B64h */ case    9:  		/* cmplwi CR6, R10, 2 */
		/* 820C8B64h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820C8B64h case    9:*/		return 0x820C8B68;
		  /* 820C8B68h */ case   10:  		/* bc 4, CR6_EQ, 28 */
		/* 820C8B68h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820C8B84;  }
		/* 820C8B68h case   10:*/		return 0x820C8B6C;
		  /* 820C8B6Ch */ case   11:  		/* lhz R10, <#[R11]> */
		/* 820C8B6Ch case   11:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C8B6Ch case   11:*/		return 0x820C8B70;
		  /* 820C8B70h */ case   12:  		/* lhz R9, <#[R11 - 2]> */
		/* 820C8B70h case   12:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R11 + 0xFFFFFFFE) );
		/* 820C8B70h case   12:*/		return 0x820C8B74;
		  /* 820C8B74h */ case   13:  		/* add R10, R10, R9 */
		/* 820C8B74h case   13:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820C8B74h case   13:*/		return 0x820C8B78;
		  /* 820C8B78h */ case   14:  		/* cmplw CR6, R8, R10 */
		/* 820C8B78h case   14:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R10);
		/* 820C8B78h case   14:*/		return 0x820C8B7C;
		  /* 820C8B7Ch */ case   15:  		/* bc 4, CR6_LT, 8 */
		/* 820C8B7Ch case   15:*/		if ( !regs.CR[6].lt ) { return 0x820C8B84;  }
		/* 820C8B7Ch case   15:*/		return 0x820C8B80;
		  /* 820C8B80h */ case   16:  		/* mr R8, R10 */
		/* 820C8B80h case   16:*/		regs.R8 = regs.R10;
		/* 820C8B80h case   16:*/		return 0x820C8B84;
	}
	return 0x820C8B84;
} // Block from 820C8B40h-820C8B84h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C8B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8B84);
		  /* 820C8B84h */ case    0:  		/* addi R7, R7, 1 */
		/* 820C8B84h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 820C8B84h case    0:*/		return 0x820C8B88;
		  /* 820C8B88h */ case    1:  		/* addi R11, R11, 20 */
		/* 820C8B88h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x14);
		/* 820C8B88h case    1:*/		return 0x820C8B8C;
		  /* 820C8B8Ch */ case    2:  		/* cmplw CR6, R7, R6 */
		/* 820C8B8Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R6);
		/* 820C8B8Ch case    2:*/		return 0x820C8B90;
		  /* 820C8B90h */ case    3:  		/* bc 12, CR6_LT, -48 */
		/* 820C8B90h case    3:*/		if ( regs.CR[6].lt ) { return 0x820C8B60;  }
		/* 820C8B90h case    3:*/		return 0x820C8B94;
	}
	return 0x820C8B94;
} // Block from 820C8B84h-820C8B94h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C8B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8B94);
		  /* 820C8B94h */ case    0:  		/* mr R4, R28 */
		/* 820C8B94h case    0:*/		regs.R4 = regs.R28;
		/* 820C8B94h case    0:*/		return 0x820C8B98;
		  /* 820C8B98h */ case    1:  		/* rlwinm R3, R8, 4, 0, 27 */
		/* 820C8B98h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R3,regs.R8);
		/* 820C8B98h case    1:*/		return 0x820C8B9C;
		  /* 820C8B9Ch */ case    2:  		/* bl -143548 */
		/* 820C8B9Ch case    2:*/		regs.LR = 0x820C8BA0; return 0x820A5AE0;
		/* 820C8B9Ch case    2:*/		return 0x820C8BA0;
		  /* 820C8BA0h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 820C8BA0h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8BA0h case    3:*/		return 0x820C8BA4;
		  /* 820C8BA4h */ case    4:  		/* bc 12, CR0_LT, 8 */
		/* 820C8BA4h case    4:*/		if ( regs.CR[0].lt ) { return 0x820C8BAC;  }
		/* 820C8BA4h case    4:*/		return 0x820C8BA8;
	}
	return 0x820C8BA8;
} // Block from 820C8B94h-820C8BA8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C8BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8BA8);
		  /* 820C8BA8h */ case    0:  		/* li R3, 0 */
		/* 820C8BA8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C8BA8h case    0:*/		return 0x820C8BAC;
	}
	return 0x820C8BAC;
} // Block from 820C8BA8h-820C8BACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8BACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8BAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8BAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8BAC);
		  /* 820C8BACh */ case    0:  		/* addi R1, R1, 128 */
		/* 820C8BACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C8BACh case    0:*/		return 0x820C8BB0;
		  /* 820C8BB0h */ case    1:  		/* b -227592 */
		/* 820C8BB0h case    1:*/		return 0x820912A8;
		/* 820C8BB0h case    1:*/		return 0x820C8BB4;
	}
	return 0x820C8BB4;
} // Block from 820C8BACh-820C8BB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8BB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8BB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8BB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8BB4);
		  /* 820C8BB4h */ case    0:  		/* addi R30, R31, 12 */
		/* 820C8BB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0xC);
		/* 820C8BB4h case    0:*/		return 0x820C8BB8;
		  /* 820C8BB8h */ case    1:  		/* lis R4, 16961 */
		/* 820C8BB8h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x4241);
		/* 820C8BB8h case    1:*/		return 0x820C8BBC;
		  /* 820C8BBCh */ case    2:  		/* addi R5, R1, 80 */
		/* 820C8BBCh case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820C8BBCh case    2:*/		return 0x820C8BC0;
		  /* 820C8BC0h */ case    3:  		/* mr R6, R30 */
		/* 820C8BC0h case    3:*/		regs.R6 = regs.R30;
		/* 820C8BC0h case    3:*/		return 0x820C8BC4;
		  /* 820C8BC4h */ case    4:  		/* ori R4, R4, 21571 */
		/* 820C8BC4h case    4:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x5443);
		/* 820C8BC4h case    4:*/		return 0x820C8BC8;
		  /* 820C8BC8h */ case    5:  		/* bl -143584 */
		/* 820C8BC8h case    5:*/		regs.LR = 0x820C8BCC; return 0x820A5AE8;
		/* 820C8BC8h case    5:*/		return 0x820C8BCC;
		  /* 820C8BCCh */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C8BCCh case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8BCCh case    6:*/		return 0x820C8BD0;
		  /* 820C8BD0h */ case    7:  		/* bc 12, CR0_LT, -36 */
		/* 820C8BD0h case    7:*/		if ( regs.CR[0].lt ) { return 0x820C8BAC;  }
		/* 820C8BD0h case    7:*/		return 0x820C8BD4;
		  /* 820C8BD4h */ case    8:  		/* cmpwi CR6, R3, 1 */
		/* 820C8BD4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 820C8BD4h case    8:*/		return 0x820C8BD8;
		  /* 820C8BD8h */ case    9:  		/* bc 4, CR6_EQ, -200 */
		/* 820C8BD8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820C8B10;  }
		/* 820C8BD8h case    9:*/		return 0x820C8BDC;
	}
	return 0x820C8BDC;
} // Block from 820C8BB4h-820C8BDCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C8BDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8BDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8BDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8BDC);
		  /* 820C8BDCh */ case    0:  		/* lis R3, -30602 */
		/* 820C8BDCh case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820C8BDCh case    0:*/		return 0x820C8BE0;
		  /* 820C8BE0h */ case    1:  		/* ori R3, R3, 2905 */
		/* 820C8BE0h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xB59);
		/* 820C8BE0h case    1:*/		return 0x820C8BE4;
		  /* 820C8BE4h */ case    2:  		/* b -56 */
		/* 820C8BE4h case    2:*/		return 0x820C8BAC;
		/* 820C8BE4h case    2:*/		return 0x820C8BE8;
	}
	return 0x820C8BE8;
} // Block from 820C8BDCh-820C8BE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8BE8);
		  /* 820C8BE8h */ case    0:  		/* mfspr R12, LR */
		/* 820C8BE8h case    0:*/		regs.R12 = regs.LR;
		/* 820C8BE8h case    0:*/		return 0x820C8BEC;
		  /* 820C8BECh */ case    1:  		/* bl -227744 */
		/* 820C8BECh case    1:*/		regs.LR = 0x820C8BF0; return 0x8209124C;
		/* 820C8BECh case    1:*/		return 0x820C8BF0;
		  /* 820C8BF0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820C8BF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820C8BF0h case    2:*/		return 0x820C8BF4;
		  /* 820C8BF4h */ case    3:  		/* lbz R11, <#[R4]> */
		/* 820C8BF4h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820C8BF4h case    3:*/		return 0x820C8BF8;
		  /* 820C8BF8h */ case    4:  		/* mr R27, R3 */
		/* 820C8BF8h case    4:*/		regs.R27 = regs.R3;
		/* 820C8BF8h case    4:*/		return 0x820C8BFC;
		  /* 820C8BFCh */ case    5:  		/* mr R25, R5 */
		/* 820C8BFCh case    5:*/		regs.R25 = regs.R5;
		/* 820C8BFCh case    5:*/		return 0x820C8C00;
		  /* 820C8C00h */ case    6:  		/* mr R28, R4 */
		/* 820C8C00h case    6:*/		regs.R28 = regs.R4;
		/* 820C8C00h case    6:*/		return 0x820C8C04;
		  /* 820C8C04h */ case    7:  		/* b 8 */
		/* 820C8C04h case    7:*/		return 0x820C8C0C;
		/* 820C8C04h case    7:*/		return 0x820C8C08;
		  /* 820C8C08h */ case    8:  		/* lbzu R11, <#[R28 + 1]> */
		/* 820C8C08h case    8:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000001) );
		regs.R28 = (uint32)(regs.R28 + 0x00000001);
		/* 820C8C08h case    8:*/		return 0x820C8C0C;
	}
	return 0x820C8C0C;
} // Block from 820C8BE8h-820C8C0Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C8C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8C0C);
		  /* 820C8C0Ch */ case    0:  		/* extsb R3, R11 */
		/* 820C8C0Ch case    0:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820C8C0Ch case    0:*/		return 0x820C8C10;
		  /* 820C8C10h */ case    1:  		/* bl -193728 */
		/* 820C8C10h case    1:*/		regs.LR = 0x820C8C14; return 0x82099750;
		/* 820C8C10h case    1:*/		return 0x820C8C14;
		  /* 820C8C14h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 820C8C14h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8C14h case    2:*/		return 0x820C8C18;
		  /* 820C8C18h */ case    3:  		/* bc 4, CR0_EQ, -16 */
		/* 820C8C18h case    3:*/		if ( !regs.CR[0].eq ) { return 0x820C8C08;  }
		/* 820C8C18h case    3:*/		return 0x820C8C1C;
		  /* 820C8C1Ch */ case    4:  		/* lbz R11, <#[R28]> */
		/* 820C8C1Ch case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820C8C1Ch case    4:*/		return 0x820C8C20;
		  /* 820C8C20h */ case    5:  		/* extsb R3, R11 */
		/* 820C8C20h case    5:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820C8C20h case    5:*/		return 0x820C8C24;
		  /* 820C8C24h */ case    6:  		/* bl -193716 */
		/* 820C8C24h case    6:*/		regs.LR = 0x820C8C28; return 0x82099770;
		/* 820C8C24h case    6:*/		return 0x820C8C28;
		  /* 820C8C28h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820C8C28h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8C28h case    7:*/		return 0x820C8C2C;
		  /* 820C8C2Ch */ case    8:  		/* bc 4, CR0_EQ, 40 */
		/* 820C8C2Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x820C8C54;  }
		/* 820C8C2Ch case    8:*/		return 0x820C8C30;
		  /* 820C8C30h */ case    9:  		/* lbz R11, <#[R28]> */
		/* 820C8C30h case    9:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 820C8C30h case    9:*/		return 0x820C8C34;
		  /* 820C8C34h */ case   10:  		/* extsb R11, R11 */
		/* 820C8C34h case   10:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 820C8C34h case   10:*/		return 0x820C8C38;
		  /* 820C8C38h */ case   11:  		/* cmpwi CR6, R11, 95 */
		/* 820C8C38h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005F);
		/* 820C8C38h case   11:*/		return 0x820C8C3C;
		  /* 820C8C3Ch */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 820C8C3Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820C8C54;  }
		/* 820C8C3Ch case   12:*/		return 0x820C8C40;
		  /* 820C8C40h */ case   13:  		/* cmpwi CR6, R11, 36 */
		/* 820C8C40h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000024);
		/* 820C8C40h case   13:*/		return 0x820C8C44;
		  /* 820C8C44h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 820C8C44h case   14:*/		if ( regs.CR[6].eq ) { return 0x820C8C54;  }
		/* 820C8C44h case   14:*/		return 0x820C8C48;
		  /* 820C8C48h */ case   15:  		/* lis R3, -30602 */
		/* 820C8C48h case   15:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820C8C48h case   15:*/		return 0x820C8C4C;
		  /* 820C8C4Ch */ case   16:  		/* ori R3, R3, 2156 */
		/* 820C8C4Ch case   16:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 820C8C4Ch case   16:*/		return 0x820C8C50;
		  /* 820C8C50h */ case   17:  		/* b 504 */
		/* 820C8C50h case   17:*/		return 0x820C8E48;
		/* 820C8C50h case   17:*/		return 0x820C8C54;
	}
	return 0x820C8C54;
} // Block from 820C8C0Ch-820C8C54h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820C8C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8C54);
		  /* 820C8C54h */ case    0:  		/* li R30, 1 */
		/* 820C8C54h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 820C8C54h case    0:*/		return 0x820C8C58;
		  /* 820C8C58h */ case    1:  		/* lbzx R11, <#[R30 + R28]> */
		/* 820C8C58h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + regs.R28 + 0x00000000) );
		/* 820C8C58h case    1:*/		return 0x820C8C5C;
		  /* 820C8C5Ch */ case    2:  		/* add R26, R30, R28 */
		/* 820C8C5Ch case    2:*/		cpu::op::add<0>(regs,&regs.R26,regs.R30,regs.R28);
		/* 820C8C5Ch case    2:*/		return 0x820C8C60;
		  /* 820C8C60h */ case    3:  		/* extsb R3, R11 */
		/* 820C8C60h case    3:*/		cpu::op::extsb<0>(regs,&regs.R3,regs.R11);
		/* 820C8C60h case    3:*/		return 0x820C8C64;
		  /* 820C8C64h */ case    4:  		/* bl -193780 */
		/* 820C8C64h case    4:*/		regs.LR = 0x820C8C68; return 0x82099770;
		/* 820C8C64h case    4:*/		return 0x820C8C68;
		  /* 820C8C68h */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 820C8C68h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8C68h case    5:*/		return 0x820C8C6C;
		  /* 820C8C6Ch */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 820C8C6Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x820C8C7C;  }
		/* 820C8C6Ch case    6:*/		return 0x820C8C70;
		  /* 820C8C70h */ case    7:  		/* lbz R11, <#[R26]> */
		/* 820C8C70h case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 820C8C70h case    7:*/		return 0x820C8C74;
		  /* 820C8C74h */ case    8:  		/* cmplwi CR6, R11, 95 */
		/* 820C8C74h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 820C8C74h case    8:*/		return 0x820C8C78;
		  /* 820C8C78h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 820C8C78h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820C8C84;  }
		/* 820C8C78h case    9:*/		return 0x820C8C7C;
	}
	return 0x820C8C7C;
} // Block from 820C8C54h-820C8C7Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C8C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8C7C);
		  /* 820C8C7Ch */ case    0:  		/* addi R30, R30, 1 */
		/* 820C8C7Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820C8C7Ch case    0:*/		return 0x820C8C80;
		  /* 820C8C80h */ case    1:  		/* b -40 */
		/* 820C8C80h case    1:*/		return 0x820C8C58;
		/* 820C8C80h case    1:*/		return 0x820C8C84;
	}
	return 0x820C8C84;
} // Block from 820C8C7Ch-820C8C84h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8C84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8C84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8C84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8C84);
		  /* 820C8C84h */ case    0:  		/* lwz R10, <#[R27 + 16]> */
		/* 820C8C84h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000010) );
		/* 820C8C84h case    0:*/		return 0x820C8C88;
		  /* 820C8C88h */ case    1:  		/* li R31, 0 */
		/* 820C8C88h case    1:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C8C88h case    1:*/		return 0x820C8C8C;
		  /* 820C8C8Ch */ case    2:  		/* lwz R3, <#[R27 + 8]> */
		/* 820C8C8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0x00000008) );
		/* 820C8C8Ch case    2:*/		return 0x820C8C90;
		  /* 820C8C90h */ case    3:  		/* li R6, 0 */
		/* 820C8C90h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C8C90h case    3:*/		return 0x820C8C94;
		  /* 820C8C94h */ case    4:  		/* lwz R11, <#[R10 + 16]> */
		/* 820C8C94h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 820C8C94h case    4:*/		return 0x820C8C98;
		  /* 820C8C98h */ case    5:  		/* lwz R10, <#[R10 + 12]> */
		/* 820C8C98h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 820C8C98h case    5:*/		return 0x820C8C9C;
		  /* 820C8C9Ch */ case    6:  		/* add R29, R11, R3 */
		/* 820C8C9Ch case    6:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R3);
		/* 820C8C9Ch case    6:*/		return 0x820C8CA0;
		  /* 820C8CA0h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 820C8CA0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C8CA0h case    7:*/		return 0x820C8CA4;
		  /* 820C8CA4h */ case    8:  		/* bc 12, CR6_EQ, 120 */
		/* 820C8CA4h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C8D1C;  }
		/* 820C8CA4h case    8:*/		return 0x820C8CA8;
		  /* 820C8CA8h */ case    9:  		/* add R11, R10, R6 */
		/* 820C8CA8h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R6);
		/* 820C8CA8h case    9:*/		return 0x820C8CAC;
		  /* 820C8CACh */ case   10:  		/* li R9, 0 */
		/* 820C8CACh case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C8CACh case   10:*/		return 0x820C8CB0;
		  /* 820C8CB0h */ case   11:  		/* rlwinm R31, R11, 31, 1, 31 */
		/* 820C8CB0h case   11:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R31,regs.R11);
		/* 820C8CB0h case   11:*/		return 0x820C8CB4;
		  /* 820C8CB4h */ case   12:  		/* cmplwi CR6, R30, 0 */
		/* 820C8CB4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C8CB4h case   12:*/		return 0x820C8CB8;
		  /* 820C8CB8h */ case   13:  		/* mulli R11, R31, 20 */
		/* 820C8CB8h case   13:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R31,0x14);
		/* 820C8CB8h case   13:*/		return 0x820C8CBC;
		  /* 820C8CBCh */ case   14:  		/* lwzx R11, <#[R11 + R29]> */
		/* 820C8CBCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820C8CBCh case   14:*/		return 0x820C8CC0;
		  /* 820C8CC0h */ case   15:  		/* add R5, R11, R3 */
		/* 820C8CC0h case   15:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R3);
		/* 820C8CC0h case   15:*/		return 0x820C8CC4;
		  /* 820C8CC4h */ case   16:  		/* bc 12, CR6_EQ, 56 */
		/* 820C8CC4h case   16:*/		if ( regs.CR[6].eq ) { return 0x820C8CFC;  }
		/* 820C8CC4h case   16:*/		return 0x820C8CC8;
		  /* 820C8CC8h */ case   17:  		/* mr R11, R28 */
		/* 820C8CC8h case   17:*/		regs.R11 = regs.R28;
		/* 820C8CC8h case   17:*/		return 0x820C8CCC;
		  /* 820C8CCCh */ case   18:  		/* subf R4, R28, R5 */
		/* 820C8CCCh case   18:*/		cpu::op::subf<0>(regs,&regs.R4,regs.R28,regs.R5);
		/* 820C8CCCh case   18:*/		return 0x820C8CD0;
		  /* 820C8CD0h */ case   19:  		/* lbzx R8, <#[R4 + R11]> */
		/* 820C8CD0h case   19:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 820C8CD0h case   19:*/		return 0x820C8CD4;
		  /* 820C8CD4h */ case   20:  		/* lbz R7, <#[R11]> */
		/* 820C8CD4h case   20:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820C8CD4h case   20:*/		return 0x820C8CD8;
		  /* 820C8CD8h */ case   21:  		/* extsb R8, R8 */
		/* 820C8CD8h case   21:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R8);
		/* 820C8CD8h case   21:*/		return 0x820C8CDC;
		  /* 820C8CDCh */ case   22:  		/* extsb R7, R7 */
		/* 820C8CDCh case   22:*/		cpu::op::extsb<0>(regs,&regs.R7,regs.R7);
		/* 820C8CDCh case   22:*/		return 0x820C8CE0;
		  /* 820C8CE0h */ case   23:  		/* cmpw CR6, R8, R7 */
		/* 820C8CE0h case   23:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R7);
		/* 820C8CE0h case   23:*/		return 0x820C8CE4;
		  /* 820C8CE4h */ case   24:  		/* bc 12, CR6_LT, 344 */
		/* 820C8CE4h case   24:*/		if ( regs.CR[6].lt ) { return 0x820C8E3C;  }
		/* 820C8CE4h case   24:*/		return 0x820C8CE8;
		  /* 820C8CE8h */ case   25:  		/* bc 12, CR6_GT, 40 */
		/* 820C8CE8h case   25:*/		if ( regs.CR[6].gt ) { return 0x820C8D10;  }
		/* 820C8CE8h case   25:*/		return 0x820C8CEC;
		  /* 820C8CECh */ case   26:  		/* addi R9, R9, 1 */
		/* 820C8CECh case   26:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 820C8CECh case   26:*/		return 0x820C8CF0;
		  /* 820C8CF0h */ case   27:  		/* addi R11, R11, 1 */
		/* 820C8CF0h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C8CF0h case   27:*/		return 0x820C8CF4;
		  /* 820C8CF4h */ case   28:  		/* cmplw CR6, R9, R30 */
		/* 820C8CF4h case   28:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R30);
		/* 820C8CF4h case   28:*/		return 0x820C8CF8;
		  /* 820C8CF8h */ case   29:  		/* bc 12, CR6_LT, -40 */
		/* 820C8CF8h case   29:*/		if ( regs.CR[6].lt ) { return 0x820C8CD0;  }
		/* 820C8CF8h case   29:*/		return 0x820C8CFC;
	}
	return 0x820C8CFC;
} // Block from 820C8C84h-820C8CFCh (30 instructions)

//////////////////////////////////////////////////////
// Block at 820C8CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8CFC);
		  /* 820C8CFCh */ case    0:  		/* cmplw CR6, R9, R30 */
		/* 820C8CFCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R30);
		/* 820C8CFCh case    0:*/		return 0x820C8D00;
		  /* 820C8D00h */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 820C8D00h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C8D1C;  }
		/* 820C8D00h case    1:*/		return 0x820C8D04;
		  /* 820C8D04h */ case    2:  		/* lbzx R11, <#[R9 + R5]> */
		/* 820C8D04h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + regs.R5 + 0x00000000) );
		/* 820C8D04h case    2:*/		return 0x820C8D08;
		  /* 820C8D08h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 820C8D08h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 820C8D08h case    3:*/		return 0x820C8D0C;
		  /* 820C8D0Ch */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 820C8D0Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x820C8D1C;  }
		/* 820C8D0Ch case    4:*/		return 0x820C8D10;
	}
	return 0x820C8D10;
} // Block from 820C8CFCh-820C8D10h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C8D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8D10);
		  /* 820C8D10h */ case    0:  		/* mr R10, R31 */
		/* 820C8D10h case    0:*/		regs.R10 = regs.R31;
		/* 820C8D10h case    0:*/		return 0x820C8D14;
		  /* 820C8D14h */ case    1:  		/* cmplw CR6, R6, R10 */
		/* 820C8D14h case    1:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 820C8D14h case    1:*/		return 0x820C8D18;
		  /* 820C8D18h */ case    2:  		/* bc 12, CR6_LT, -112 */
		/* 820C8D18h case    2:*/		if ( regs.CR[6].lt ) { return 0x820C8CA8;  }
		/* 820C8D18h case    2:*/		return 0x820C8D1C;
	}
	return 0x820C8D1C;
} // Block from 820C8D10h-820C8D1Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8D1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8D1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8D1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8D1C);
		  /* 820C8D1Ch */ case    0:  		/* cmplw CR6, R6, R10 */
		/* 820C8D1Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R10);
		/* 820C8D1Ch case    0:*/		return 0x820C8D20;
		  /* 820C8D20h */ case    1:  		/* bc 12, CR6_EQ, -216 */
		/* 820C8D20h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C8C48;  }
		/* 820C8D20h case    1:*/		return 0x820C8D24;
		  /* 820C8D24h */ case    2:  		/* mulli R11, R31, 20 */
		/* 820C8D24h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R31,0x14);
		/* 820C8D24h case    2:*/		return 0x820C8D28;
		  /* 820C8D28h */ case    3:  		/* add R11, R11, R29 */
		/* 820C8D28h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 820C8D28h case    3:*/		return 0x820C8D2C;
		  /* 820C8D2Ch */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 820C8D2Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C8D2Ch case    4:*/		return 0x820C8D30;
		  /* 820C8D30h */ case    5:  		/* lwz R10, <#[R11]> */
		/* 820C8D30h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C8D30h case    5:*/		return 0x820C8D34;
		  /* 820C8D34h */ case    6:  		/* add R28, R10, R3 */
		/* 820C8D34h case    6:*/		cpu::op::add<0>(regs,&regs.R28,regs.R10,regs.R3);
		/* 820C8D34h case    6:*/		return 0x820C8D38;
		  /* 820C8D38h */ case    7:  		/* bc 12, CR6_EQ, 84 */
		/* 820C8D38h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C8D8C;  }
		/* 820C8D38h case    7:*/		return 0x820C8D3C;
		  /* 820C8D3Ch */ case    8:  		/* addi R8, R11, -20 */
		/* 820C8D3Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFEC);
		/* 820C8D3Ch case    8:*/		return 0x820C8D40;
		  /* 820C8D40h */ case    9:  		/* lwz R11, <#[R8]> */
		/* 820C8D40h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 820C8D40h case    9:*/		return 0x820C8D44;
		  /* 820C8D44h */ case   10:  		/* add R11, R11, R3 */
		/* 820C8D44h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820C8D44h case   10:*/		return 0x820C8D48;
		  /* 820C8D48h */ case   11:  		/* cmplw CR6, R28, R11 */
		/* 820C8D48h case   11:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820C8D48h case   11:*/		return 0x820C8D4C;
		  /* 820C8D4Ch */ case   12:  		/* bc 12, CR6_EQ, 52 */
		/* 820C8D4Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x820C8D80;  }
		/* 820C8D4Ch case   12:*/		return 0x820C8D50;
		  /* 820C8D50h */ case   13:  		/* mr R10, R28 */
		/* 820C8D50h case   13:*/		regs.R10 = regs.R28;
		/* 820C8D50h case   13:*/		return 0x820C8D54;
		  /* 820C8D54h */ case   14:  		/* lbz R9, <#[R10]> */
		/* 820C8D54h case   14:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820C8D54h case   14:*/		return 0x820C8D58;
		  /* 820C8D58h */ case   15:  		/* lbz R7, <#[R11]> */
		/* 820C8D58h case   15:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 820C8D58h case   15:*/		return 0x820C8D5C;
		  /* 820C8D5Ch */ case   16:  		/* cmpwi CR0, R9, 0 */
		/* 820C8D5Ch case   16:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820C8D5Ch case   16:*/		return 0x820C8D60;
		  /* 820C8D60h */ case   17:  		/* subf R9, R7, R9 */
		/* 820C8D60h case   17:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820C8D60h case   17:*/		return 0x820C8D64;
		  /* 820C8D64h */ case   18:  		/* bc 12, CR0_EQ, 20 */
		/* 820C8D64h case   18:*/		if ( regs.CR[0].eq ) { return 0x820C8D78;  }
		/* 820C8D64h case   18:*/		return 0x820C8D68;
		  /* 820C8D68h */ case   19:  		/* addi R10, R10, 1 */
		/* 820C8D68h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C8D68h case   19:*/		return 0x820C8D6C;
		  /* 820C8D6Ch */ case   20:  		/* addi R11, R11, 1 */
		/* 820C8D6Ch case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C8D6Ch case   20:*/		return 0x820C8D70;
	}
	return 0x820C8D70;
} // Block from 820C8D1Ch-820C8D70h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C8D70h
// Function '?GetConstantElement@CConstant@D3DXShader@@QAAPAV12@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8D70);
		  /* 820C8D70h */ case    0:  		/* cmpwi CR6, R9, 0 */
		/* 820C8D70h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820C8D70h case    0:*/		return 0x820C8D74;
		  /* 820C8D74h */ case    1:  		/* bc 12, CR6_EQ, -32 */
		/* 820C8D74h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C8D54;  }
		/* 820C8D74h case    1:*/		return 0x820C8D78;
	}
	return 0x820C8D78;
} // Block from 820C8D70h-820C8D78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8D78);
		  /* 820C8D78h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820C8D78h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820C8D78h case    0:*/		return 0x820C8D7C;
		  /* 820C8D7Ch */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 820C8D7Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x820C8D8C;  }
		/* 820C8D7Ch case    1:*/		return 0x820C8D80;
	}
	return 0x820C8D80;
} // Block from 820C8D78h-820C8D80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8D80);
		  /* 820C8D80h */ case    0:  		/* addic. R31, R31, -1 */
		/* 820C8D80h case    0:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 820C8D80h case    0:*/		return 0x820C8D84;
		  /* 820C8D84h */ case    1:  		/* addi R8, R8, -20 */
		/* 820C8D84h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFEC);
		/* 820C8D84h case    1:*/		return 0x820C8D88;
		  /* 820C8D88h */ case    2:  		/* bc 4, CR0_EQ, -72 */
		/* 820C8D88h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820C8D40;  }
		/* 820C8D88h case    2:*/		return 0x820C8D8C;
	}
	return 0x820C8D8C;
} // Block from 820C8D80h-820C8D8Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8D8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8D8C);
		  /* 820C8D8Ch */ case    0:  		/* lwz R11, <#[R27 + 20]> */
		/* 820C8D8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 820C8D8Ch case    0:*/		return 0x820C8D90;
		  /* 820C8D90h */ case    1:  		/* rlwinm R30, R31, 2, 0, 29 */
		/* 820C8D90h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R31);
		/* 820C8D90h case    1:*/		return 0x820C8D94;
		  /* 820C8D94h */ case    2:  		/* li R5, 0 */
		/* 820C8D94h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C8D94h case    2:*/		return 0x820C8D98;
		  /* 820C8D98h */ case    3:  		/* mr R4, R26 */
		/* 820C8D98h case    3:*/		regs.R4 = regs.R26;
		/* 820C8D98h case    3:*/		return 0x820C8D9C;
		  /* 820C8D9Ch */ case    4:  		/* lwzx R3, <#[R30 + R11]> */
		/* 820C8D9Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820C8D9Ch case    4:*/		return 0x820C8DA0;
		  /* 820C8DA0h */ case    5:  		/* bl -1336 */
		/* 820C8DA0h case    5:*/		regs.LR = 0x820C8DA4; return 0x820C8868;
		/* 820C8DA0h case    5:*/		return 0x820C8DA4;
		  /* 820C8DA4h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 820C8DA4h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C8DA4h case    6:*/		return 0x820C8DA8;
		  /* 820C8DA8h */ case    7:  		/* bc 12, CR0_EQ, -352 */
		/* 820C8DA8h case    7:*/		if ( regs.CR[0].eq ) { return 0x820C8C48;  }
		/* 820C8DA8h case    7:*/		return 0x820C8DAC;
		  /* 820C8DACh */ case    8:  		/* mulli R11, R31, 20 */
		/* 820C8DACh case    8:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R31,0x14);
		/* 820C8DACh case    8:*/		return 0x820C8DB0;
		  /* 820C8DB0h */ case    9:  		/* add R29, R11, R29 */
		/* 820C8DB0h case    9:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R29);
		/* 820C8DB0h case    9:*/		return 0x820C8DB4;
		  /* 820C8DB4h */ case   10:  		/* stw R3, <#[R25]> */
		/* 820C8DB4h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R25 + 0x00000000) );
		/* 820C8DB4h case   10:*/		return 0x820C8DB8;
		  /* 820C8DB8h */ case   11:  		/* addi R31, R31, 1 */
		/* 820C8DB8h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820C8DB8h case   11:*/		return 0x820C8DBC;
		  /* 820C8DBCh */ case   12:  		/* lwz R11, <#[R27 + 16]> */
		/* 820C8DBCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 820C8DBCh case   12:*/		return 0x820C8DC0;
		  /* 820C8DC0h */ case   13:  		/* addi R25, R3, 36 */
		/* 820C8DC0h case   13:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R3,0x24);
		/* 820C8DC0h case   13:*/		return 0x820C8DC4;
		  /* 820C8DC4h */ case   14:  		/* addi R29, R29, 20 */
		/* 820C8DC4h case   14:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x14);
		/* 820C8DC4h case   14:*/		return 0x820C8DC8;
		  /* 820C8DC8h */ case   15:  		/* addi R30, R30, 4 */
		/* 820C8DC8h case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 820C8DC8h case   15:*/		return 0x820C8DCC;
		  /* 820C8DCCh */ case   16:  		/* lwz R11, <#[R11 + 12]> */
		/* 820C8DCCh case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820C8DCCh case   16:*/		return 0x820C8DD0;
		  /* 820C8DD0h */ case   17:  		/* cmplw CR6, R31, R11 */
		/* 820C8DD0h case   17:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 820C8DD0h case   17:*/		return 0x820C8DD4;
		  /* 820C8DD4h */ case   18:  		/* bc 4, CR6_LT, 112 */
		/* 820C8DD4h case   18:*/		if ( !regs.CR[6].lt ) { return 0x820C8E44;  }
		/* 820C8DD4h case   18:*/		return 0x820C8DD8;
		  /* 820C8DD8h */ case   19:  		/* lwz R10, <#[R29]> */
		/* 820C8DD8h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 820C8DD8h case   19:*/		return 0x820C8DDC;
		  /* 820C8DDCh */ case   20:  		/* lwz R11, <#[R27 + 8]> */
		/* 820C8DDCh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 820C8DDCh case   20:*/		return 0x820C8DE0;
		  /* 820C8DE0h */ case   21:  		/* add R11, R11, R10 */
		/* 820C8DE0h case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C8DE0h case   21:*/		return 0x820C8DE4;
		  /* 820C8DE4h */ case   22:  		/* cmplw CR6, R28, R11 */
		/* 820C8DE4h case   22:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 820C8DE4h case   22:*/		return 0x820C8DE8;
		  /* 820C8DE8h */ case   23:  		/* bc 12, CR6_EQ, 52 */
		/* 820C8DE8h case   23:*/		if ( regs.CR[6].eq ) { return 0x820C8E1C;  }
		/* 820C8DE8h case   23:*/		return 0x820C8DEC;
		  /* 820C8DECh */ case   24:  		/* mr R10, R28 */
		/* 820C8DECh case   24:*/		regs.R10 = regs.R28;
		/* 820C8DECh case   24:*/		return 0x820C8DF0;
		  /* 820C8DF0h */ case   25:  		/* lbz R9, <#[R10]> */
		/* 820C8DF0h case   25:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820C8DF0h case   25:*/		return 0x820C8DF4;
		  /* 820C8DF4h */ case   26:  		/* lbz R8, <#[R11]> */
		/* 820C8DF4h case   26:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 820C8DF4h case   26:*/		return 0x820C8DF8;
		  /* 820C8DF8h */ case   27:  		/* cmpwi CR0, R9, 0 */
		/* 820C8DF8h case   27:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820C8DF8h case   27:*/		return 0x820C8DFC;
		  /* 820C8DFCh */ case   28:  		/* subf R9, R8, R9 */
		/* 820C8DFCh case   28:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C8DFCh case   28:*/		return 0x820C8E00;
		  /* 820C8E00h */ case   29:  		/* bc 12, CR0_EQ, 20 */
		/* 820C8E00h case   29:*/		if ( regs.CR[0].eq ) { return 0x820C8E14;  }
		/* 820C8E00h case   29:*/		return 0x820C8E04;
		  /* 820C8E04h */ case   30:  		/* addi R10, R10, 1 */
		/* 820C8E04h case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C8E04h case   30:*/		return 0x820C8E08;
		  /* 820C8E08h */ case   31:  		/* addi R11, R11, 1 */
		/* 820C8E08h case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C8E08h case   31:*/		return 0x820C8E0C;
		  /* 820C8E0Ch */ case   32:  		/* cmpwi CR6, R9, 0 */
		/* 820C8E0Ch case   32:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820C8E0Ch case   32:*/		return 0x820C8E10;
		  /* 820C8E10h */ case   33:  		/* bc 12, CR6_EQ, -32 */
		/* 820C8E10h case   33:*/		if ( regs.CR[6].eq ) { return 0x820C8DF0;  }
		/* 820C8E10h case   33:*/		return 0x820C8E14;
	}
	return 0x820C8E14;
} // Block from 820C8D8Ch-820C8E14h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820C8E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8E14);
		  /* 820C8E14h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820C8E14h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820C8E14h case    0:*/		return 0x820C8E18;
		  /* 820C8E18h */ case    1:  		/* bc 4, CR0_EQ, 44 */
		/* 820C8E18h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820C8E44;  }
		/* 820C8E18h case    1:*/		return 0x820C8E1C;
	}
	return 0x820C8E1C;
} // Block from 820C8E14h-820C8E1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8E1C);
		  /* 820C8E1Ch */ case    0:  		/* lwz R11, <#[R27 + 20]> */
		/* 820C8E1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 820C8E1Ch case    0:*/		return 0x820C8E20;
		  /* 820C8E20h */ case    1:  		/* li R5, 0 */
		/* 820C8E20h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820C8E20h case    1:*/		return 0x820C8E24;
		  /* 820C8E24h */ case    2:  		/* mr R4, R26 */
		/* 820C8E24h case    2:*/		regs.R4 = regs.R26;
		/* 820C8E24h case    2:*/		return 0x820C8E28;
		  /* 820C8E28h */ case    3:  		/* lwzx R3, <#[R30 + R11]> */
		/* 820C8E28h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 820C8E28h case    3:*/		return 0x820C8E2C;
		  /* 820C8E2Ch */ case    4:  		/* bl -1476 */
		/* 820C8E2Ch case    4:*/		regs.LR = 0x820C8E30; return 0x820C8868;
		/* 820C8E2Ch case    4:*/		return 0x820C8E30;
		  /* 820C8E30h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820C8E30h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C8E30h case    5:*/		return 0x820C8E34;
		  /* 820C8E34h */ case    6:  		/* bc 4, CR0_EQ, -128 */
		/* 820C8E34h case    6:*/		if ( !regs.CR[0].eq ) { return 0x820C8DB4;  }
		/* 820C8E34h case    6:*/		return 0x820C8E38;
		  /* 820C8E38h */ case    7:  		/* b -496 */
		/* 820C8E38h case    7:*/		return 0x820C8C48;
		/* 820C8E38h case    7:*/		return 0x820C8E3C;
	}
	return 0x820C8E3C;
} // Block from 820C8E1Ch-820C8E3Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C8E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8E3C);
		  /* 820C8E3Ch */ case    0:  		/* addi R6, R31, 1 */
		/* 820C8E3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x1);
		/* 820C8E3Ch case    0:*/		return 0x820C8E40;
		  /* 820C8E40h */ case    1:  		/* b -300 */
		/* 820C8E40h case    1:*/		return 0x820C8D14;
		/* 820C8E40h case    1:*/		return 0x820C8E44;
	}
	return 0x820C8E44;
} // Block from 820C8E3Ch-820C8E44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8E44);
		  /* 820C8E44h */ case    0:  		/* li R3, 0 */
		/* 820C8E44h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C8E44h case    0:*/		return 0x820C8E48;
	}
	return 0x820C8E48;
} // Block from 820C8E44h-820C8E48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8E48);
		  /* 820C8E48h */ case    0:  		/* addi R1, R1, 144 */
		/* 820C8E48h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820C8E48h case    0:*/		return 0x820C8E4C;
		  /* 820C8E4Ch */ case    1:  		/* b -228272 */
		/* 820C8E4Ch case    1:*/		return 0x8209129C;
		/* 820C8E4Ch case    1:*/		return 0x820C8E50;
	}
	return 0x820C8E50;
} // Block from 820C8E48h-820C8E50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8E50);
		  /* 820C8E50h */ case    0:  		/* mfspr R12, LR */
		/* 820C8E50h case    0:*/		regs.R12 = regs.LR;
		/* 820C8E50h case    0:*/		return 0x820C8E54;
		  /* 820C8E54h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C8E54h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C8E54h case    1:*/		return 0x820C8E58;
		  /* 820C8E58h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C8E58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C8E58h case    2:*/		return 0x820C8E5C;
		  /* 820C8E5Ch */ case    3:  		/* mr R11, R4 */
		/* 820C8E5Ch case    3:*/		regs.R11 = regs.R4;
		/* 820C8E5Ch case    3:*/		return 0x820C8E60;
		  /* 820C8E60h */ case    4:  		/* mr R4, R5 */
		/* 820C8E60h case    4:*/		regs.R4 = regs.R5;
		/* 820C8E60h case    4:*/		return 0x820C8E64;
		  /* 820C8E64h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820C8E64h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C8E64h case    5:*/		return 0x820C8E68;
		  /* 820C8E68h */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 820C8E68h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820C8E84;  }
		/* 820C8E68h case    6:*/		return 0x820C8E6C;
		  /* 820C8E6Ch */ case    7:  		/* addi R5, R1, 80 */
		/* 820C8E6Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820C8E6Ch case    7:*/		return 0x820C8E70;
		  /* 820C8E70h */ case    8:  		/* bl -648 */
		/* 820C8E70h case    8:*/		regs.LR = 0x820C8E74; return 0x820C8BE8;
		/* 820C8E70h case    8:*/		return 0x820C8E74;
		  /* 820C8E74h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 820C8E74h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8E74h case    9:*/		return 0x820C8E78;
		  /* 820C8E78h */ case   10:  		/* bc 4, CR0_LT, 36 */
		/* 820C8E78h case   10:*/		if ( !regs.CR[0].lt ) { return 0x820C8E9C;  }
		/* 820C8E78h case   10:*/		return 0x820C8E7C;
		  /* 820C8E7Ch */ case   11:  		/* li R3, 0 */
		/* 820C8E7Ch case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C8E7Ch case   11:*/		return 0x820C8E80;
		  /* 820C8E80h */ case   12:  		/* b 36 */
		/* 820C8E80h case   12:*/		return 0x820C8EA4;
		/* 820C8E80h case   12:*/		return 0x820C8E84;
	}
	return 0x820C8E84;
} // Block from 820C8E50h-820C8E84h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C8E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8E84);
		  /* 820C8E84h */ case    0:  		/* li R5, 1 */
		/* 820C8E84h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820C8E84h case    0:*/		return 0x820C8E88;
		  /* 820C8E88h */ case    1:  		/* nor R3, R11, R11 */
		/* 820C8E88h case    1:*/		cpu::op::nor<0>(regs,&regs.R3,regs.R11,regs.R11);
		/* 820C8E88h case    1:*/		return 0x820C8E8C;
		  /* 820C8E8Ch */ case    2:  		/* bl -1572 */
		/* 820C8E8Ch case    2:*/		regs.LR = 0x820C8E90; return 0x820C8868;
		/* 820C8E8Ch case    2:*/		return 0x820C8E90;
		  /* 820C8E90h */ case    3:  		/* cmplwi CR0, R3, 0 */
		/* 820C8E90h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C8E90h case    3:*/		return 0x820C8E94;
		  /* 820C8E94h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 820C8E94h case    4:*/		if ( !regs.CR[0].eq ) { return 0x820C8EA0;  }
		/* 820C8E94h case    4:*/		return 0x820C8E98;
		  /* 820C8E98h */ case    5:  		/* b -28 */
		/* 820C8E98h case    5:*/		return 0x820C8E7C;
		/* 820C8E98h case    5:*/		return 0x820C8E9C;
	}
	return 0x820C8E9C;
} // Block from 820C8E84h-820C8E9Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C8E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8E9C);
		  /* 820C8E9Ch */ case    0:  		/* lwz R3, <#[R1 + 80]> */
		/* 820C8E9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820C8E9Ch case    0:*/		return 0x820C8EA0;
	}
	return 0x820C8EA0;
} // Block from 820C8E9Ch-820C8EA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8EA0);
		  /* 820C8EA0h */ case    0:  		/* nor R3, R3, R3 */
		/* 820C8EA0h case    0:*/		cpu::op::nor<0>(regs,&regs.R3,regs.R3,regs.R3);
		/* 820C8EA0h case    0:*/		return 0x820C8EA4;
	}
	return 0x820C8EA4;
} // Block from 820C8EA0h-820C8EA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8EA4);
		  /* 820C8EA4h */ case    0:  		/* addi R1, R1, 96 */
		/* 820C8EA4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C8EA4h case    0:*/		return 0x820C8EA8;
		  /* 820C8EA8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C8EA8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C8EA8h case    1:*/		return 0x820C8EAC;
		  /* 820C8EACh */ case    2:  		/* mtspr LR, R12 */
		/* 820C8EACh case    2:*/		regs.LR = regs.R12;
		/* 820C8EACh case    2:*/		return 0x820C8EB0;
		  /* 820C8EB0h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820C8EB0h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C8EB0h case    3:*/		return 0x820C8EB4;
	}
	return 0x820C8EB4;
} // Block from 820C8EA4h-820C8EB4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C8EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8EB4);
		  /* 820C8EB4h */ case    0:  		/* nop */
		/* 820C8EB4h case    0:*/		cpu::op::nop();
		/* 820C8EB4h case    0:*/		return 0x820C8EB8;
	}
	return 0x820C8EB8;
} // Block from 820C8EB4h-820C8EB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8EB8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8EB8);
		  /* 820C8EB8h */ case    0:  		/* li R11, 0 */
		/* 820C8EB8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C8EB8h case    0:*/		return 0x820C8EBC;
		  /* 820C8EBCh */ case    1:  		/* li R10, -1 */
		/* 820C8EBCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820C8EBCh case    1:*/		return 0x820C8EC0;
		  /* 820C8EC0h */ case    2:  		/* stw R11, <#[R3 + 4]> */
		/* 820C8EC0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820C8EC0h case    2:*/		return 0x820C8EC4;
		  /* 820C8EC4h */ case    3:  		/* stw R10, <#[R3]> */
		/* 820C8EC4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C8EC4h case    3:*/		return 0x820C8EC8;
		  /* 820C8EC8h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 820C8EC8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C8EC8h case    4:*/		return 0x820C8ECC;
		  /* 820C8ECCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C8ECCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C8ECCh case    5:*/		return 0x820C8ED0;
	}
	return 0x820C8ED0;
} // Block from 820C8EB8h-820C8ED0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C8ED0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8ED0);
		  /* 820C8ED0h */ case    0:  		/* mfspr R12, LR */
		/* 820C8ED0h case    0:*/		regs.R12 = regs.LR;
		/* 820C8ED0h case    0:*/		return 0x820C8ED4;
		  /* 820C8ED4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C8ED4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C8ED4h case    1:*/		return 0x820C8ED8;
		  /* 820C8ED8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C8ED8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C8ED8h case    2:*/		return 0x820C8EDC;
		  /* 820C8EDCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C8EDCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C8EDCh case    3:*/		return 0x820C8EE0;
		  /* 820C8EE0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C8EE0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C8EE0h case    4:*/		return 0x820C8EE4;
		  /* 820C8EE4h */ case    5:  		/* mr R31, R3 */
		/* 820C8EE4h case    5:*/		regs.R31 = regs.R3;
		/* 820C8EE4h case    5:*/		return 0x820C8EE8;
		  /* 820C8EE8h */ case    6:  		/* mr R3, R4 */
		/* 820C8EE8h case    6:*/		regs.R3 = regs.R4;
		/* 820C8EE8h case    6:*/		return 0x820C8EEC;
		  /* 820C8EECh */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820C8EECh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C8EECh case    7:*/		return 0x820C8EF0;
		  /* 820C8EF0h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 820C8EF0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C8F00;  }
		/* 820C8EF0h case    8:*/		return 0x820C8EF4;
		  /* 820C8EF4h */ case    9:  		/* lis R3, -30602 */
		/* 820C8EF4h case    9:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820C8EF4h case    9:*/		return 0x820C8EF8;
		  /* 820C8EF8h */ case   10:  		/* ori R3, R3, 2156 */
		/* 820C8EF8h case   10:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x86C);
		/* 820C8EF8h case   10:*/		return 0x820C8EFC;
		  /* 820C8EFCh */ case   11:  		/* b 180 */
		/* 820C8EFCh case   11:*/		return 0x820C8FB0;
		/* 820C8EFCh case   11:*/		return 0x820C8F00;
	}
	return 0x820C8F00;
} // Block from 820C8ED0h-820C8F00h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C8F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8F00);
		  /* 820C8F00h */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 820C8F00h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 820C8F00h case    0:*/		return 0x820C8F04;
		  /* 820C8F04h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820C8F04h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C8F14;  }
		/* 820C8F04h case    1:*/		return 0x820C8F08;
		  /* 820C8F08h */ case    2:  		/* lis R3, -32768 */
		/* 820C8F08h case    2:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 820C8F08h case    2:*/		return 0x820C8F0C;
		  /* 820C8F0Ch */ case    3:  		/* ori R3, R3, 16389 */
		/* 820C8F0Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 820C8F0Ch case    3:*/		return 0x820C8F10;
		  /* 820C8F10h */ case    4:  		/* b 160 */
		/* 820C8F10h case    4:*/		return 0x820C8FB0;
		/* 820C8F10h case    4:*/		return 0x820C8F14;
	}
	return 0x820C8F14;
} // Block from 820C8F00h-820C8F14h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C8F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8F14);
		  /* 820C8F14h */ case    0:  		/* li R9, 0 */
		/* 820C8F14h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820C8F14h case    0:*/		return 0x820C8F18;
		  /* 820C8F18h */ case    1:  		/* lis R8, 2048 */
		/* 820C8F18h case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0x800);
		/* 820C8F18h case    1:*/		return 0x820C8F1C;
		  /* 820C8F1Ch */ case    2:  		/* li R7, 3 */
		/* 820C8F1Ch case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 820C8F1Ch case    2:*/		return 0x820C8F20;
		  /* 820C8F20h */ case    3:  		/* li R6, 0 */
		/* 820C8F20h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 820C8F20h case    3:*/		return 0x820C8F24;
		  /* 820C8F24h */ case    4:  		/* li R5, 1 */
		/* 820C8F24h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 820C8F24h case    4:*/		return 0x820C8F28;
		  /* 820C8F28h */ case    5:  		/* lis R4, -32768 */
		/* 820C8F28h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8000);
		/* 820C8F28h case    5:*/		return 0x820C8F2C;
		  /* 820C8F2Ch */ case    6:  		/* bl -262716 */
		/* 820C8F2Ch case    6:*/		regs.LR = 0x820C8F30; return 0x82088CF0;
		/* 820C8F2Ch case    6:*/		return 0x820C8F30;
		  /* 820C8F30h */ case    7:  		/* stw R3, <#[R31]> */
		/* 820C8F30h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820C8F30h case    7:*/		return 0x820C8F34;
		  /* 820C8F34h */ case    8:  		/* cmpwi CR6, R3, -1 */
		/* 820C8F34h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820C8F34h case    8:*/		return 0x820C8F38;
		  /* 820C8F38h */ case    9:  		/* bc 12, CR6_EQ, 100 */
		/* 820C8F38h case    9:*/		if ( regs.CR[6].eq ) { return 0x820C8F9C;  }
		/* 820C8F38h case    9:*/		return 0x820C8F3C;
		  /* 820C8F3Ch */ case   10:  		/* li R4, 0 */
		/* 820C8F3Ch case   10:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820C8F3Ch case   10:*/		return 0x820C8F40;
		  /* 820C8F40h */ case   11:  		/* bl 1696552 */
		/* 820C8F40h case   11:*/		regs.LR = 0x820C8F44; return 0x82267268;
		/* 820C8F40h case   11:*/		return 0x820C8F44;
		  /* 820C8F44h */ case   12:  		/* cmpwi CR6, R3, -1 */
		/* 820C8F44h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820C8F44h case   12:*/		return 0x820C8F48;
		  /* 820C8F48h */ case   13:  		/* stw R3, <#[R31 + 8]> */
		/* 820C8F48h case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820C8F48h case   13:*/		return 0x820C8F4C;
		  /* 820C8F4Ch */ case   14:  		/* bc 12, CR6_EQ, 80 */
		/* 820C8F4Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x820C8F9C;  }
		/* 820C8F4Ch case   14:*/		return 0x820C8F50;
		  /* 820C8F50h */ case   15:  		/* li R30, 0 */
		/* 820C8F50h case   15:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820C8F50h case   15:*/		return 0x820C8F54;
		  /* 820C8F54h */ case   16:  		/* cmplwi CR6, R3, 0 */
		/* 820C8F54h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C8F54h case   16:*/		return 0x820C8F58;
		  /* 820C8F58h */ case   17:  		/* bc 12, CR6_EQ, 28 */
		/* 820C8F58h case   17:*/		if ( regs.CR[6].eq ) { return 0x820C8F74;  }
		/* 820C8F58h case   17:*/		return 0x820C8F5C;
		  /* 820C8F5Ch */ case   18:  		/* lis R4, 9345 */
		/* 820C8F5Ch case   18:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C8F5Ch case   18:*/		return 0x820C8F60;
		  /* 820C8F60h */ case   19:  		/* bl -265568 */
		/* 820C8F60h case   19:*/		regs.LR = 0x820C8F64; return 0x82088200;
		/* 820C8F60h case   19:*/		return 0x820C8F64;
		  /* 820C8F64h */ case   20:  		/* cmplwi CR0, R3, 0 */
		/* 820C8F64h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C8F64h case   20:*/		return 0x820C8F68;
		  /* 820C8F68h */ case   21:  		/* stw R3, <#[R31 + 4]> */
		/* 820C8F68h case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 820C8F68h case   21:*/		return 0x820C8F6C;
		  /* 820C8F6Ch */ case   22:  		/* bc 12, CR0_EQ, 48 */
		/* 820C8F6Ch case   22:*/		if ( regs.CR[0].eq ) { return 0x820C8F9C;  }
		/* 820C8F6Ch case   22:*/		return 0x820C8F70;
		  /* 820C8F70h */ case   23:  		/* b 8 */
		/* 820C8F70h case   23:*/		return 0x820C8F78;
		/* 820C8F70h case   23:*/		return 0x820C8F74;
	}
	return 0x820C8F74;
} // Block from 820C8F14h-820C8F74h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820C8F74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8F74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8F74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8F74);
		  /* 820C8F74h */ case    0:  		/* stw R30, <#[R31 + 4]> */
		/* 820C8F74h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 820C8F74h case    0:*/		return 0x820C8F78;
	}
	return 0x820C8F78;
} // Block from 820C8F74h-820C8F78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8F78);
		  /* 820C8F78h */ case    0:  		/* stw R30, <#[R1 + 80]> */
		/* 820C8F78h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 820C8F78h case    0:*/		return 0x820C8F7C;
		  /* 820C8F7Ch */ case    1:  		/* li R7, 0 */
		/* 820C8F7Ch case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820C8F7Ch case    1:*/		return 0x820C8F80;
		  /* 820C8F80h */ case    2:  		/* addi R6, R1, 80 */
		/* 820C8F80h case    2:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 820C8F80h case    2:*/		return 0x820C8F84;
		  /* 820C8F84h */ case    3:  		/* lwz R5, <#[R31 + 8]> */
		/* 820C8F84h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000008) );
		/* 820C8F84h case    3:*/		return 0x820C8F88;
		  /* 820C8F88h */ case    4:  		/* lwz R4, <#[R31 + 4]> */
		/* 820C8F88h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 820C8F88h case    4:*/		return 0x820C8F8C;
		  /* 820C8F8Ch */ case    5:  		/* lwz R3, <#[R31]> */
		/* 820C8F8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820C8F8Ch case    5:*/		return 0x820C8F90;
		  /* 820C8F90h */ case    6:  		/* bl 1696080 */
		/* 820C8F90h case    6:*/		regs.LR = 0x820C8F94; return 0x822670E0;
		/* 820C8F90h case    6:*/		return 0x820C8F94;
		  /* 820C8F94h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 820C8F94h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C8F94h case    7:*/		return 0x820C8F98;
		  /* 820C8F98h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 820C8F98h case    8:*/		if ( !regs.CR[0].eq ) { return 0x820C8FAC;  }
		/* 820C8F98h case    8:*/		return 0x820C8F9C;
	}
	return 0x820C8F9C;
} // Block from 820C8F78h-820C8F9Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C8F9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8F9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8F9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8F9C);
		  /* 820C8F9Ch */ case    0:  		/* bl -256156 */
		/* 820C8F9Ch case    0:*/		regs.LR = 0x820C8FA0; return 0x8208A700;
		/* 820C8F9Ch case    0:*/		return 0x820C8FA0;
	}
	return 0x820C8FA0;
} // Block from 820C8F9Ch-820C8FA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8FA0h
// Function '??0CConstantTable@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8FA0);
		  /* 820C8FA0h */ case    0:  		/* lis R3, -30602 */
		/* 820C8FA0h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8876);
		/* 820C8FA0h case    0:*/		return 0x820C8FA4;
		  /* 820C8FA4h */ case    1:  		/* ori R3, R3, 2905 */
		/* 820C8FA4h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xB59);
		/* 820C8FA4h case    1:*/		return 0x820C8FA8;
		  /* 820C8FA8h */ case    2:  		/* b 8 */
		/* 820C8FA8h case    2:*/		return 0x820C8FB0;
		/* 820C8FA8h case    2:*/		return 0x820C8FAC;
	}
	return 0x820C8FAC;
} // Block from 820C8FA0h-820C8FACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C8FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8FAC);
		  /* 820C8FACh */ case    0:  		/* li R3, 0 */
		/* 820C8FACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C8FACh case    0:*/		return 0x820C8FB0;
	}
	return 0x820C8FB0;
} // Block from 820C8FACh-820C8FB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C8FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8FB0);
		  /* 820C8FB0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820C8FB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C8FB0h case    0:*/		return 0x820C8FB4;
		  /* 820C8FB4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C8FB4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C8FB4h case    1:*/		return 0x820C8FB8;
		  /* 820C8FB8h */ case    2:  		/* mtspr LR, R12 */
		/* 820C8FB8h case    2:*/		regs.LR = regs.R12;
		/* 820C8FB8h case    2:*/		return 0x820C8FBC;
		  /* 820C8FBCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820C8FBCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C8FBCh case    3:*/		return 0x820C8FC0;
		  /* 820C8FC0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820C8FC0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C8FC0h case    4:*/		return 0x820C8FC4;
		  /* 820C8FC4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C8FC4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C8FC4h case    5:*/		return 0x820C8FC8;
	}
	return 0x820C8FC8;
} // Block from 820C8FB0h-820C8FC8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C8FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8FC8);
		  /* 820C8FC8h */ case    0:  		/* mfspr R12, LR */
		/* 820C8FC8h case    0:*/		regs.R12 = regs.LR;
		/* 820C8FC8h case    0:*/		return 0x820C8FCC;
		  /* 820C8FCCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C8FCCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C8FCCh case    1:*/		return 0x820C8FD0;
	}
	return 0x820C8FD0;
} // Block from 820C8FC8h-820C8FD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C8FD0h
// Function '?Initialize@CConstantTable@D3DXShader@@QAAJPBU_D3DXSHADER_CONSTANTTABLE@@I_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8FD0);
		  /* 820C8FD0h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 820C8FD0h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C8FD0h case    0:*/		return 0x820C8FD4;
		  /* 820C8FD4h */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C8FD4h case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C8FD4h case    1:*/		return 0x820C8FD8;
		  /* 820C8FD8h */ case    2:  		/* mr R31, R3 */
		/* 820C8FD8h case    2:*/		regs.R31 = regs.R3;
		/* 820C8FD8h case    2:*/		return 0x820C8FDC;
		  /* 820C8FDCh */ case    3:  		/* lwz R3, <#[R3 + 4]> */
		/* 820C8FDCh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 820C8FDCh case    3:*/		return 0x820C8FE0;
		  /* 820C8FE0h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820C8FE0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C8FE0h case    4:*/		return 0x820C8FE4;
		  /* 820C8FE4h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820C8FE4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C8FFC;  }
		/* 820C8FE4h case    5:*/		return 0x820C8FE8;
		  /* 820C8FE8h */ case    6:  		/* lis R4, 9345 */
		/* 820C8FE8h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C8FE8h case    6:*/		return 0x820C8FEC;
		  /* 820C8FECh */ case    7:  		/* bl -265396 */
		/* 820C8FECh case    7:*/		regs.LR = 0x820C8FF0; return 0x82088338;
		/* 820C8FECh case    7:*/		return 0x820C8FF0;
		  /* 820C8FF0h */ case    8:  		/* li R11, 0 */
		/* 820C8FF0h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C8FF0h case    8:*/		return 0x820C8FF4;
		  /* 820C8FF4h */ case    9:  		/* stw R11, <#[R31 + 4]> */
		/* 820C8FF4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820C8FF4h case    9:*/		return 0x820C8FF8;
		  /* 820C8FF8h */ case   10:  		/* stw R11, <#[R31 + 8]> */
		/* 820C8FF8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820C8FF8h case   10:*/		return 0x820C8FFC;
	}
	return 0x820C8FFC;
} // Block from 820C8FD0h-820C8FFCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C8FFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C8FFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C8FFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C8FFC);
		  /* 820C8FFCh */ case    0:  		/* lwz R3, <#[R31]> */
		/* 820C8FFCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820C8FFCh case    0:*/		return 0x820C9000;
		  /* 820C9000h */ case    1:  		/* cmpwi CR6, R3, -1 */
		/* 820C9000h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 820C9000h case    1:*/		return 0x820C9004;
		  /* 820C9004h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 820C9004h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C9014;  }
		/* 820C9004h case    2:*/		return 0x820C9008;
		  /* 820C9008h */ case    3:  		/* bl -264192 */
		/* 820C9008h case    3:*/		regs.LR = 0x820C900C; return 0x82088808;
		/* 820C9008h case    3:*/		return 0x820C900C;
		  /* 820C900Ch */ case    4:  		/* li R11, -1 */
		/* 820C900Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 820C900Ch case    4:*/		return 0x820C9010;
		  /* 820C9010h */ case    5:  		/* stw R11, <#[R31]> */
		/* 820C9010h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C9010h case    5:*/		return 0x820C9014;
	}
	return 0x820C9014;
} // Block from 820C8FFCh-820C9014h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C9014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9014);
		  /* 820C9014h */ case    0:  		/* li R3, 0 */
		/* 820C9014h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C9014h case    0:*/		return 0x820C9018;
		  /* 820C9018h */ case    1:  		/* addi R1, R1, 96 */
		/* 820C9018h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C9018h case    1:*/		return 0x820C901C;
		  /* 820C901Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C901Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C901Ch case    2:*/		return 0x820C9020;
		  /* 820C9020h */ case    3:  		/* mtspr LR, R12 */
		/* 820C9020h case    3:*/		regs.LR = regs.R12;
		/* 820C9020h case    3:*/		return 0x820C9024;
		  /* 820C9024h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820C9024h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9024h case    4:*/		return 0x820C9028;
		  /* 820C9028h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C9028h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9028h case    5:*/		return 0x820C902C;
	}
	return 0x820C902C;
} // Block from 820C9014h-820C902Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C902Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C902C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C902C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C902C);
		  /* 820C902Ch */ case    0:  		/* nop */
		/* 820C902Ch case    0:*/		cpu::op::nop();
		/* 820C902Ch case    0:*/		return 0x820C9030;
	}
	return 0x820C9030;
} // Block from 820C902Ch-820C9030h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9030h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9030);
		  /* 820C9030h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820C9030h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9030h case    0:*/		return 0x820C9034;
		  /* 820C9034h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 820C9034h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 820C9034h case    1:*/		return 0x820C9038;
		  /* 820C9038h */ case    2:  		/* bclr 12, CR6_EQ */
		/* 820C9038h case    2:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820C9038h case    2:*/		return 0x820C903C;
	}
	return 0x820C903C;
} // Block from 820C9030h-820C903Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C903Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C903C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C903C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C903C);
		  /* 820C903Ch */ case    0:  		/* b -116 */
		/* 820C903Ch case    0:*/		return 0x820C8FC8;
		/* 820C903Ch case    0:*/		return 0x820C9040;
		  /* 820C9040h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820C9040h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9040h case    1:*/		return 0x820C9044;
	}
	return 0x820C9044;
} // Block from 820C903Ch-820C9044h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C9044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9044);
		  /* 820C9044h */ case    0:  		/* nop */
		/* 820C9044h case    0:*/		cpu::op::nop();
		/* 820C9044h case    0:*/		return 0x820C9048;
	}
	return 0x820C9048;
} // Block from 820C9044h-820C9048h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9048h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9048);
		  /* 820C9048h */ case    0:  		/* addi R10, R5, 4095 */
		/* 820C9048h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0xFFF);
		/* 820C9048h case    0:*/		return 0x820C904C;
		  /* 820C904Ch */ case    1:  		/* li R11, 0 */
		/* 820C904Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C904Ch case    1:*/		return 0x820C9050;
		  /* 820C9050h */ case    2:  		/* rlwinm R10, R10, 0, 0, 19 */
		/* 820C9050h case    2:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R10,regs.R10);
		/* 820C9050h case    2:*/		return 0x820C9054;
		  /* 820C9054h */ case    3:  		/* stw R11, <#[R3]> */
		/* 820C9054h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9054h case    3:*/		return 0x820C9058;
		  /* 820C9058h */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 820C9058h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C9058h case    4:*/		return 0x820C905C;
		  /* 820C905Ch */ case    5:  		/* stw R10, <#[R3 + 4]> */
		/* 820C905Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820C905Ch case    5:*/		return 0x820C9060;
		  /* 820C9060h */ case    6:  		/* stw R11, <#[R3 + 8]> */
		/* 820C9060h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9060h case    6:*/		return 0x820C9064;
		  /* 820C9064h */ case    7:  		/* stw R11, <#[R3 + 12]> */
		/* 820C9064h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C9064h case    7:*/		return 0x820C9068;
		  /* 820C9068h */ case    8:  		/* stw R11, <#[R3 + 16]> */
		/* 820C9068h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9068h case    8:*/		return 0x820C906C;
		  /* 820C906Ch */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 820C906Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x820C9074;  }
		/* 820C906Ch case    9:*/		return 0x820C9070;
		  /* 820C9070h */ case   10:  		/* lis R4, 16 */
		/* 820C9070h case   10:*/		cpu::op::lis<0>(regs,&regs.R4,0x10);
		/* 820C9070h case   10:*/		return 0x820C9074;
	}
	return 0x820C9074;
} // Block from 820C9048h-820C9074h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C9074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9074);
		  /* 820C9074h */ case    0:  		/* add R11, R10, R4 */
		/* 820C9074h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R4);
		/* 820C9074h case    0:*/		return 0x820C9078;
		  /* 820C9078h */ case    1:  		/* addi R10, R10, -1 */
		/* 820C9078h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C9078h case    1:*/		return 0x820C907C;
		  /* 820C907Ch */ case    2:  		/* addi R11, R11, -1 */
		/* 820C907Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820C907Ch case    2:*/		return 0x820C9080;
		  /* 820C9080h */ case    3:  		/* andc R11, R11, R10 */
		/* 820C9080h case    3:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820C9080h case    3:*/		return 0x820C9084;
		  /* 820C9084h */ case    4:  		/* stw R11, <#[R3 + 20]> */
		/* 820C9084h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9084h case    4:*/		return 0x820C9088;
		  /* 820C9088h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C9088h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9088h case    5:*/		return 0x820C908C;
	}
	return 0x820C908C;
} // Block from 820C9074h-820C908Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C908Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C908C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C908C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C908C);
		  /* 820C908Ch */ case    0:  		/* nop */
		/* 820C908Ch case    0:*/		cpu::op::nop();
		/* 820C908Ch case    0:*/		return 0x820C9090;
	}
	return 0x820C9090;
} // Block from 820C908Ch-820C9090h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9090h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9090);
		  /* 820C9090h */ case    0:  		/* mfspr R12, LR */
		/* 820C9090h case    0:*/		regs.R12 = regs.LR;
		/* 820C9090h case    0:*/		return 0x820C9094;
		  /* 820C9094h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C9094h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9094h case    1:*/		return 0x820C9098;
		  /* 820C9098h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820C9098h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9098h case    2:*/		return 0x820C909C;
		  /* 820C909Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C909Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C909Ch case    3:*/		return 0x820C90A0;
		  /* 820C90A0h */ case    4:  		/* mr R31, R3 */
		/* 820C90A0h case    4:*/		regs.R31 = regs.R3;
		/* 820C90A0h case    4:*/		return 0x820C90A4;
		  /* 820C90A4h */ case    5:  		/* b 24 */
		/* 820C90A4h case    5:*/		return 0x820C90BC;
		/* 820C90A4h case    5:*/		return 0x820C90A8;
		  /* 820C90A8h */ case    6:  		/* lwz R3, <#[R31]> */
		/* 820C90A8h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820C90A8h case    6:*/		return 0x820C90AC;
		  /* 820C90ACh */ case    7:  		/* lis R4, 9345 */
		/* 820C90ACh case    7:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C90ACh case    7:*/		return 0x820C90B0;
		  /* 820C90B0h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 820C90B0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C90B0h case    8:*/		return 0x820C90B4;
		  /* 820C90B4h */ case    9:  		/* stw R11, <#[R31]> */
		/* 820C90B4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C90B4h case    9:*/		return 0x820C90B8;
		  /* 820C90B8h */ case   10:  		/* bl -265600 */
		/* 820C90B8h case   10:*/		regs.LR = 0x820C90BC; return 0x82088338;
		/* 820C90B8h case   10:*/		return 0x820C90BC;
	}
	return 0x820C90BC;
} // Block from 820C9090h-820C90BCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C90BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C90BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C90BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C90BC);
		  /* 820C90BCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820C90BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C90BCh case    0:*/		return 0x820C90C0;
		  /* 820C90C0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C90C0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C90C0h case    1:*/		return 0x820C90C4;
		  /* 820C90C4h */ case    2:  		/* bc 4, CR6_EQ, -28 */
		/* 820C90C4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C90A8;  }
		/* 820C90C4h case    2:*/		return 0x820C90C8;
		  /* 820C90C8h */ case    3:  		/* addi R1, R1, 96 */
		/* 820C90C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C90C8h case    3:*/		return 0x820C90CC;
		  /* 820C90CCh */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C90CCh case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C90CCh case    4:*/		return 0x820C90D0;
		  /* 820C90D0h */ case    5:  		/* mtspr LR, R12 */
		/* 820C90D0h case    5:*/		regs.LR = regs.R12;
		/* 820C90D0h case    5:*/		return 0x820C90D4;
		  /* 820C90D4h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 820C90D4h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C90D4h case    6:*/		return 0x820C90D8;
		  /* 820C90D8h */ case    7:  		/* bclr 20, CR0_LT */
		/* 820C90D8h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C90D8h case    7:*/		return 0x820C90DC;
	}
	return 0x820C90DC;
} // Block from 820C90BCh-820C90DCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C90DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C90DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C90DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C90DC);
		  /* 820C90DCh */ case    0:  		/* nop */
		/* 820C90DCh case    0:*/		cpu::op::nop();
		/* 820C90DCh case    0:*/		return 0x820C90E0;
	}
	return 0x820C90E0;
} // Block from 820C90DCh-820C90E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C90E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C90E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C90E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C90E0);
		  /* 820C90E0h */ case    0:  		/* mfspr R12, LR */
		/* 820C90E0h case    0:*/		regs.R12 = regs.LR;
		/* 820C90E0h case    0:*/		return 0x820C90E4;
		  /* 820C90E4h */ case    1:  		/* bl -229004 */
		/* 820C90E4h case    1:*/		regs.LR = 0x820C90E8; return 0x82091258;
		/* 820C90E4h case    1:*/		return 0x820C90E8;
		  /* 820C90E8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C90E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C90E8h case    2:*/		return 0x820C90EC;
		  /* 820C90ECh */ case    3:  		/* lwz R10, <#[R3 + 8]> */
		/* 820C90ECh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820C90ECh case    3:*/		return 0x820C90F0;
		  /* 820C90F0h */ case    4:  		/* addi R11, R5, -1 */
		/* 820C90F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xFFFFFFFF);
		/* 820C90F0h case    4:*/		return 0x820C90F4;
		  /* 820C90F4h */ case    5:  		/* lwz R9, <#[R3 + 16]> */
		/* 820C90F4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 820C90F4h case    5:*/		return 0x820C90F8;
		  /* 820C90F8h */ case    6:  		/* mr R31, R3 */
		/* 820C90F8h case    6:*/		regs.R31 = regs.R3;
		/* 820C90F8h case    6:*/		return 0x820C90FC;
		  /* 820C90FCh */ case    7:  		/* add R10, R5, R10 */
		/* 820C90FCh case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 820C90FCh case    7:*/		return 0x820C9100;
		  /* 820C9100h */ case    8:  		/* nor R11, R11, R11 */
		/* 820C9100h case    8:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820C9100h case    8:*/		return 0x820C9104;
		  /* 820C9104h */ case    9:  		/* addi R10, R10, -1 */
		/* 820C9104h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C9104h case    9:*/		return 0x820C9108;
		  /* 820C9108h */ case   10:  		/* mr R28, R4 */
		/* 820C9108h case   10:*/		regs.R28 = regs.R4;
		/* 820C9108h case   10:*/		return 0x820C910C;
		  /* 820C910Ch */ case   11:  		/* and R10, R10, R11 */
		/* 820C910Ch case   11:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820C910Ch case   11:*/		return 0x820C9110;
		  /* 820C9110h */ case   12:  		/* add R30, R10, R4 */
		/* 820C9110h case   12:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R4);
		/* 820C9110h case   12:*/		return 0x820C9114;
		  /* 820C9114h */ case   13:  		/* cmplw CR6, R30, R9 */
		/* 820C9114h case   13:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R9);
		/* 820C9114h case   13:*/		return 0x820C9118;
		  /* 820C9118h */ case   14:  		/* bc 4, CR6_GT, 80 */
		/* 820C9118h case   14:*/		if ( !regs.CR[6].gt ) { return 0x820C9168;  }
		/* 820C9118h case   14:*/		return 0x820C911C;
		  /* 820C911Ch */ case   15:  		/* addi R10, R5, 3 */
		/* 820C911Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x3);
		/* 820C911Ch case   15:*/		return 0x820C9120;
		  /* 820C9120h */ case   16:  		/* lwz R29, <#[R3 + 20]> */
		/* 820C9120h case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9120h case   16:*/		return 0x820C9124;
		  /* 820C9124h */ case   17:  		/* and R11, R10, R11 */
		/* 820C9124h case   17:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C9124h case   17:*/		return 0x820C9128;
		  /* 820C9128h */ case   18:  		/* add R30, R11, R4 */
		/* 820C9128h case   18:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R4);
		/* 820C9128h case   18:*/		return 0x820C912C;
		  /* 820C912Ch */ case   19:  		/* b 8 */
		/* 820C912Ch case   19:*/		return 0x820C9134;
		/* 820C912Ch case   19:*/		return 0x820C9130;
		  /* 820C9130h */ case   20:  		/* rlwinm R29, R29, 1, 0, 30 */
		/* 820C9130h case   20:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R29,regs.R29);
		/* 820C9130h case   20:*/		return 0x820C9134;
	}
	return 0x820C9134;
} // Block from 820C90E0h-820C9134h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C9134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9134);
		  /* 820C9134h */ case    0:  		/* cmplw CR6, R30, R29 */
		/* 820C9134h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R29);
		/* 820C9134h case    0:*/		return 0x820C9138;
		  /* 820C9138h */ case    1:  		/* bc 12, CR6_GT, -8 */
		/* 820C9138h case    1:*/		if ( regs.CR[6].gt ) { return 0x820C9130;  }
		/* 820C9138h case    1:*/		return 0x820C913C;
		  /* 820C913Ch */ case    2:  		/* lis R4, 9345 */
		/* 820C913Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R4,0x2481);
		/* 820C913Ch case    2:*/		return 0x820C9140;
		  /* 820C9140h */ case    3:  		/* mr R3, R29 */
		/* 820C9140h case    3:*/		regs.R3 = regs.R29;
		/* 820C9140h case    3:*/		return 0x820C9144;
		  /* 820C9144h */ case    4:  		/* bl -266052 */
		/* 820C9144h case    4:*/		regs.LR = 0x820C9148; return 0x82088200;
		/* 820C9144h case    4:*/		return 0x820C9148;
		  /* 820C9148h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 820C9148h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C9148h case    5:*/		return 0x820C914C;
		  /* 820C914Ch */ case    6:  		/* bc 12, CR0_EQ, 80 */
		/* 820C914Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820C919C;  }
		/* 820C914Ch case    6:*/		return 0x820C9150;
		  /* 820C9150h */ case    7:  		/* lwz R9, <#[R31]> */
		/* 820C9150h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820C9150h case    7:*/		return 0x820C9154;
		  /* 820C9154h */ case    8:  		/* lwz R11, <#[R31 + 4]> */
		/* 820C9154h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820C9154h case    8:*/		return 0x820C9158;
		  /* 820C9158h */ case    9:  		/* stw R29, <#[R31 + 16]> */
		/* 820C9158h case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000010) );
		/* 820C9158h case    9:*/		return 0x820C915C;
		  /* 820C915Ch */ case   10:  		/* stw R9, <#[R3]> */
		/* 820C915Ch case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 820C915Ch case   10:*/		return 0x820C9160;
		  /* 820C9160h */ case   11:  		/* stw R3, <#[R31]> */
		/* 820C9160h case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 820C9160h case   11:*/		return 0x820C9164;
		  /* 820C9164h */ case   12:  		/* b 20 */
		/* 820C9164h case   12:*/		return 0x820C9178;
		/* 820C9164h case   12:*/		return 0x820C9168;
	}
	return 0x820C9168;
} // Block from 820C9134h-820C9168h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C9168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9168);
		  /* 820C9168h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820C9168h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820C9168h case    0:*/		return 0x820C916C;
		  /* 820C916Ch */ case    1:  		/* cmplw CR6, R30, R11 */
		/* 820C916Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820C916Ch case    1:*/		return 0x820C9170;
		  /* 820C9170h */ case    2:  		/* bc 4, CR6_GT, 28 */
		/* 820C9170h case    2:*/		if ( !regs.CR[6].gt ) { return 0x820C918C;  }
		/* 820C9170h case    2:*/		return 0x820C9174;
		  /* 820C9174h */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 820C9174h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820C9174h case    3:*/		return 0x820C9178;
	}
	return 0x820C9178;
} // Block from 820C9168h-820C9178h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C9178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9178);
		  /* 820C9178h */ case    0:  		/* add R10, R11, R30 */
		/* 820C9178h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R30);
		/* 820C9178h case    0:*/		return 0x820C917C;
		  /* 820C917Ch */ case    1:  		/* addi R11, R11, -1 */
		/* 820C917Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820C917Ch case    1:*/		return 0x820C9180;
		  /* 820C9180h */ case    2:  		/* addi R10, R10, -1 */
		/* 820C9180h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820C9180h case    2:*/		return 0x820C9184;
		  /* 820C9184h */ case    3:  		/* andc R11, R10, R11 */
		/* 820C9184h case    3:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C9184h case    3:*/		return 0x820C9188;
		  /* 820C9188h */ case    4:  		/* stw R11, <#[R31 + 12]> */
		/* 820C9188h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820C9188h case    4:*/		return 0x820C918C;
	}
	return 0x820C918C;
} // Block from 820C9178h-820C918Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C918Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C918C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C918C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C918C);
		  /* 820C918Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820C918Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C918Ch case    0:*/		return 0x820C9190;
		  /* 820C9190h */ case    1:  		/* stw R30, <#[R31 + 8]> */
		/* 820C9190h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 820C9190h case    1:*/		return 0x820C9194;
		  /* 820C9194h */ case    2:  		/* subf R11, R28, R11 */
		/* 820C9194h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 820C9194h case    2:*/		return 0x820C9198;
		  /* 820C9198h */ case    3:  		/* add R3, R11, R30 */
		/* 820C9198h case    3:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 820C9198h case    3:*/		return 0x820C919C;
	}
	return 0x820C919C;
} // Block from 820C918Ch-820C919Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C919Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C919C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C919C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C919C);
		  /* 820C919Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 820C919Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C919Ch case    0:*/		return 0x820C91A0;
		  /* 820C91A0h */ case    1:  		/* b -229112 */
		/* 820C91A0h case    1:*/		return 0x820912A8;
		/* 820C91A0h case    1:*/		return 0x820C91A4;
		  /* 820C91A4h */ case    2:  		/* nop */
		/* 820C91A4h case    2:*/		cpu::op::nop();
		/* 820C91A4h case    2:*/		return 0x820C91A8;
	}
	return 0x820C91A8;
} // Block from 820C919Ch-820C91A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C91A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C91A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C91A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C91A8);
		  /* 820C91A8h */ case    0:  		/* mfspr R12, LR */
		/* 820C91A8h case    0:*/		regs.R12 = regs.LR;
		/* 820C91A8h case    0:*/		return 0x820C91AC;
		  /* 820C91ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C91ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C91ACh case    1:*/		return 0x820C91B0;
		  /* 820C91B0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820C91B0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C91B0h case    2:*/		return 0x820C91B4;
		  /* 820C91B4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C91B4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C91B4h case    3:*/		return 0x820C91B8;
		  /* 820C91B8h */ case    4:  		/* mr R31, R3 */
		/* 820C91B8h case    4:*/		regs.R31 = regs.R3;
		/* 820C91B8h case    4:*/		return 0x820C91BC;
		  /* 820C91BCh */ case    5:  		/* bl 15988 */
		/* 820C91BCh case    5:*/		regs.LR = 0x820C91C0; return 0x820CD030;
		/* 820C91BCh case    5:*/		return 0x820C91C0;
		  /* 820C91C0h */ case    6:  		/* mr R11, R3 */
		/* 820C91C0h case    6:*/		regs.R11 = regs.R3;
		/* 820C91C0h case    6:*/		return 0x820C91C4;
		  /* 820C91C4h */ case    7:  		/* lwz R3, <#[R3]> */
		/* 820C91C4h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820C91C4h case    7:*/		return 0x820C91C8;
		  /* 820C91C8h */ case    8:  		/* stw R31, <#[R11]> */
		/* 820C91C8h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 820C91C8h case    8:*/		return 0x820C91CC;
		  /* 820C91CCh */ case    9:  		/* addi R1, R1, 96 */
		/* 820C91CCh case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C91CCh case    9:*/		return 0x820C91D0;
		  /* 820C91D0h */ case   10:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C91D0h case   10:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C91D0h case   10:*/		return 0x820C91D4;
		  /* 820C91D4h */ case   11:  		/* mtspr LR, R12 */
		/* 820C91D4h case   11:*/		regs.LR = regs.R12;
		/* 820C91D4h case   11:*/		return 0x820C91D8;
		  /* 820C91D8h */ case   12:  		/* ld R31, <#[R1 - 16]> */
		/* 820C91D8h case   12:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C91D8h case   12:*/		return 0x820C91DC;
		  /* 820C91DCh */ case   13:  		/* bclr 20, CR0_LT */
		/* 820C91DCh case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C91DCh case   13:*/		return 0x820C91E0;
	}
	return 0x820C91E0;
} // Block from 820C91A8h-820C91E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C91E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C91E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C91E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C91E0);
		  /* 820C91E0h */ case    0:  		/* mfspr R12, LR */
		/* 820C91E0h case    0:*/		regs.R12 = regs.LR;
		/* 820C91E0h case    0:*/		return 0x820C91E4;
		  /* 820C91E4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C91E4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C91E4h case    1:*/		return 0x820C91E8;
		  /* 820C91E8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C91E8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C91E8h case    2:*/		return 0x820C91EC;
		  /* 820C91ECh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C91ECh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C91ECh case    3:*/		return 0x820C91F0;
		  /* 820C91F0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C91F0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C91F0h case    4:*/		return 0x820C91F4;
		  /* 820C91F4h */ case    5:  		/* mr R31, R3 */
		/* 820C91F4h case    5:*/		regs.R31 = regs.R3;
		/* 820C91F4h case    5:*/		return 0x820C91F8;
		  /* 820C91F8h */ case    6:  		/* mr R30, R4 */
		/* 820C91F8h case    6:*/		regs.R30 = regs.R4;
		/* 820C91F8h case    6:*/		return 0x820C91FC;
		  /* 820C91FCh */ case    7:  		/* bl 15924 */
		/* 820C91FCh case    7:*/		regs.LR = 0x820C9200; return 0x820CD030;
		/* 820C91FCh case    7:*/		return 0x820C9200;
	}
	return 0x820C9200;
} // Block from 820C91E0h-820C9200h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C9200h
// Function '?Release@CConstantTable@D3DXShader@@UAAKXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9200);
		  /* 820C9200h */ case    0:  		/* mr R5, R30 */
		/* 820C9200h case    0:*/		regs.R5 = regs.R30;
		/* 820C9200h case    0:*/		return 0x820C9204;
		  /* 820C9204h */ case    1:  		/* lwz R3, <#[R3]> */
		/* 820C9204h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9204h case    1:*/		return 0x820C9208;
		  /* 820C9208h */ case    2:  		/* mr R4, R31 */
		/* 820C9208h case    2:*/		regs.R4 = regs.R31;
		/* 820C9208h case    2:*/		return 0x820C920C;
		  /* 820C920Ch */ case    3:  		/* bl -300 */
		/* 820C920Ch case    3:*/		regs.LR = 0x820C9210; return 0x820C90E0;
		/* 820C920Ch case    3:*/		return 0x820C9210;
		  /* 820C9210h */ case    4:  		/* addi R1, R1, 112 */
		/* 820C9210h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C9210h case    4:*/		return 0x820C9214;
		  /* 820C9214h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C9214h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9214h case    5:*/		return 0x820C9218;
		  /* 820C9218h */ case    6:  		/* mtspr LR, R12 */
		/* 820C9218h case    6:*/		regs.LR = regs.R12;
		/* 820C9218h case    6:*/		return 0x820C921C;
		  /* 820C921Ch */ case    7:  		/* ld R30, <#[R1 - 24]> */
		/* 820C921Ch case    7:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C921Ch case    7:*/		return 0x820C9220;
		  /* 820C9220h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 820C9220h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9220h case    8:*/		return 0x820C9224;
		  /* 820C9224h */ case    9:  		/* bclr 20, CR0_LT */
		/* 820C9224h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9224h case    9:*/		return 0x820C9228;
	}
	return 0x820C9228;
} // Block from 820C9200h-820C9228h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C9228h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9228);
		  /* 820C9228h */ case    0:  		/* mfspr R12, LR */
		/* 820C9228h case    0:*/		regs.R12 = regs.LR;
		/* 820C9228h case    0:*/		return 0x820C922C;
		  /* 820C922Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C922Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C922Ch case    1:*/		return 0x820C9230;
		  /* 820C9230h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820C9230h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9230h case    2:*/		return 0x820C9234;
		  /* 820C9234h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C9234h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C9234h case    3:*/		return 0x820C9238;
		  /* 820C9238h */ case    4:  		/* mr R31, R3 */
		/* 820C9238h case    4:*/		regs.R31 = regs.R3;
		/* 820C9238h case    4:*/		return 0x820C923C;
		  /* 820C923Ch */ case    5:  		/* bl 15860 */
		/* 820C923Ch case    5:*/		regs.LR = 0x820C9240; return 0x820CD030;
		/* 820C923Ch case    5:*/		return 0x820C9240;
		  /* 820C9240h */ case    6:  		/* li R5, 16 */
		/* 820C9240h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820C9240h case    6:*/		return 0x820C9244;
		  /* 820C9244h */ case    7:  		/* lwz R3, <#[R3]> */
		/* 820C9244h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9244h case    7:*/		return 0x820C9248;
		  /* 820C9248h */ case    8:  		/* mr R4, R31 */
		/* 820C9248h case    8:*/		regs.R4 = regs.R31;
		/* 820C9248h case    8:*/		return 0x820C924C;
		  /* 820C924Ch */ case    9:  		/* bl -364 */
		/* 820C924Ch case    9:*/		regs.LR = 0x820C9250; return 0x820C90E0;
		/* 820C924Ch case    9:*/		return 0x820C9250;
		  /* 820C9250h */ case   10:  		/* addi R1, R1, 96 */
		/* 820C9250h case   10:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C9250h case   10:*/		return 0x820C9254;
		  /* 820C9254h */ case   11:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C9254h case   11:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9254h case   11:*/		return 0x820C9258;
	}
	return 0x820C9258;
} // Block from 820C9228h-820C9258h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C9258h
// Function '?GetConstantElement@CConstantTable@D3DXShader@@UAAIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9258);
		  /* 820C9258h */ case    0:  		/* mtspr LR, R12 */
		/* 820C9258h case    0:*/		regs.LR = regs.R12;
		/* 820C9258h case    0:*/		return 0x820C925C;
		  /* 820C925Ch */ case    1:  		/* ld R31, <#[R1 - 16]> */
		/* 820C925Ch case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C925Ch case    1:*/		return 0x820C9260;
		  /* 820C9260h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820C9260h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9260h case    2:*/		return 0x820C9264;
	}
	return 0x820C9264;
} // Block from 820C9258h-820C9264h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9264);
		  /* 820C9264h */ case    0:  		/* nop */
		/* 820C9264h case    0:*/		cpu::op::nop();
		/* 820C9264h case    0:*/		return 0x820C9268;
		  /* 820C9268h */ case    1:  		/* lis R10, -32255 */
		/* 820C9268h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C9268h case    1:*/		return 0x820C926C;
		  /* 820C926Ch */ case    2:  		/* li R11, 0 */
		/* 820C926Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C926Ch case    2:*/		return 0x820C9270;
		  /* 820C9270h */ case    3:  		/* addi R10, R10, 10484 */
		/* 820C9270h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x28F4);
		/* 820C9270h case    3:*/		return 0x820C9274;
		  /* 820C9274h */ case    4:  		/* stw R11, <#[R3 + 4]> */
		/* 820C9274h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9274h case    4:*/		return 0x820C9278;
		  /* 820C9278h */ case    5:  		/* stw R10, <#[R3]> */
		/* 820C9278h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9278h case    5:*/		return 0x820C927C;
		  /* 820C927Ch */ case    6:  		/* stw R11, <#[R3 + 8]> */
		/* 820C927Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C927Ch case    6:*/		return 0x820C9280;
		  /* 820C9280h */ case    7:  		/* stw R11, <#[R3 + 12]> */
		/* 820C9280h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C9280h case    7:*/		return 0x820C9284;
		  /* 820C9284h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820C9284h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9284h case    8:*/		return 0x820C9288;
	}
	return 0x820C9288;
} // Block from 820C9264h-820C9288h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C9288h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9288);
		  /* 820C9288h */ case    0:  		/* lis R10, -32255 */
		/* 820C9288h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C9288h case    0:*/		return 0x820C928C;
		  /* 820C928Ch */ case    1:  		/* stw R4, <#[R3 + 4]> */
		/* 820C928Ch case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 820C928Ch case    1:*/		return 0x820C9290;
	}
	return 0x820C9290;
} // Block from 820C9288h-820C9290h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C9290h
// Function '?GetConstantByName@CConstant@D3DXShader@@QAAPAV12@PBDH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9290);
		  /* 820C9290h */ case    0:  		/* li R11, 0 */
		/* 820C9290h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C9290h case    0:*/		return 0x820C9294;
		  /* 820C9294h */ case    1:  		/* addi R10, R10, 10484 */
		/* 820C9294h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x28F4);
		/* 820C9294h case    1:*/		return 0x820C9298;
		  /* 820C9298h */ case    2:  		/* stw R11, <#[R3 + 8]> */
		/* 820C9298h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9298h case    2:*/		return 0x820C929C;
		  /* 820C929Ch */ case    3:  		/* stw R10, <#[R3]> */
		/* 820C929Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C929Ch case    3:*/		return 0x820C92A0;
		  /* 820C92A0h */ case    4:  		/* stw R11, <#[R3 + 12]> */
		/* 820C92A0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C92A0h case    4:*/		return 0x820C92A4;
		  /* 820C92A4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C92A4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C92A4h case    5:*/		return 0x820C92A8;
	}
	return 0x820C92A8;
} // Block from 820C9290h-820C92A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C92A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C92A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C92A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C92A8);
		  /* 820C92A8h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820C92A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C92A8h case    0:*/		return 0x820C92AC;
		  /* 820C92ACh */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820C92ACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C92B8;  }
		/* 820C92ACh case    1:*/		return 0x820C92B0;
		  /* 820C92B0h */ case    2:  		/* li R3, 0 */
		/* 820C92B0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C92B0h case    2:*/		return 0x820C92B4;
		  /* 820C92B4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820C92B4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C92B4h case    3:*/		return 0x820C92B8;
	}
	return 0x820C92B8;
} // Block from 820C92A8h-820C92B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C92B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C92B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C92B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C92B8);
		  /* 820C92B8h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 820C92B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820C92B8h case    0:*/		return 0x820C92BC;
		  /* 820C92BCh */ case    1:  		/* lwz R10, <#[R4 + 4]> */
		/* 820C92BCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 820C92BCh case    1:*/		return 0x820C92C0;
		  /* 820C92C0h */ case    2:  		/* subf R11, R10, R11 */
		/* 820C92C0h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820C92C0h case    2:*/		return 0x820C92C4;
		  /* 820C92C4h */ case    3:  		/* cntlzw R11, R11 */
		/* 820C92C4h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C92C4h case    3:*/		return 0x820C92C8;
		  /* 820C92C8h */ case    4:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820C92C8h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820C92C8h case    4:*/		return 0x820C92CC;
		  /* 820C92CCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C92CCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C92CCh case    5:*/		return 0x820C92D0;
	}
	return 0x820C92D0;
} // Block from 820C92B8h-820C92D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C92D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C92D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C92D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C92D0);
		  /* 820C92D0h */ case    0:  		/* mfspr R12, LR */
		/* 820C92D0h case    0:*/		regs.R12 = regs.LR;
		/* 820C92D0h case    0:*/		return 0x820C92D4;
		  /* 820C92D4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C92D4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C92D4h case    1:*/		return 0x820C92D8;
		  /* 820C92D8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820C92D8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C92D8h case    2:*/		return 0x820C92DC;
		  /* 820C92DCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C92DCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C92DCh case    3:*/		return 0x820C92E0;
		  /* 820C92E0h */ case    4:  		/* mr R31, R3 */
		/* 820C92E0h case    4:*/		regs.R31 = regs.R3;
		/* 820C92E0h case    4:*/		return 0x820C92E4;
		  /* 820C92E4h */ case    5:  		/* bl 15692 */
		/* 820C92E4h case    5:*/		regs.LR = 0x820C92E8; return 0x820CD030;
		/* 820C92E4h case    5:*/		return 0x820C92E8;
		  /* 820C92E8h */ case    6:  		/* li R5, 16 */
		/* 820C92E8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820C92E8h case    6:*/		return 0x820C92EC;
		  /* 820C92ECh */ case    7:  		/* lwz R3, <#[R3]> */
		/* 820C92ECh case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820C92ECh case    7:*/		return 0x820C92F0;
		  /* 820C92F0h */ case    8:  		/* li R4, 16 */
		/* 820C92F0h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 820C92F0h case    8:*/		return 0x820C92F4;
		  /* 820C92F4h */ case    9:  		/* bl -532 */
		/* 820C92F4h case    9:*/		regs.LR = 0x820C92F8; return 0x820C90E0;
		/* 820C92F4h case    9:*/		return 0x820C92F8;
		  /* 820C92F8h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 820C92F8h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C92F8h case   10:*/		return 0x820C92FC;
		  /* 820C92FCh */ case   11:  		/* bc 12, CR0_EQ, 40 */
		/* 820C92FCh case   11:*/		if ( regs.CR[0].eq ) { return 0x820C9324;  }
		/* 820C92FCh case   11:*/		return 0x820C9300;
		  /* 820C9300h */ case   12:  		/* lwz R9, <#[R31 + 4]> */
		/* 820C9300h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 820C9300h case   12:*/		return 0x820C9304;
		  /* 820C9304h */ case   13:  		/* lis R10, -32255 */
		/* 820C9304h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C9304h case   13:*/		return 0x820C9308;
		  /* 820C9308h */ case   14:  		/* li R11, 0 */
		/* 820C9308h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C9308h case   14:*/		return 0x820C930C;
		  /* 820C930Ch */ case   15:  		/* addi R10, R10, 10484 */
		/* 820C930Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x28F4);
		/* 820C930Ch case   15:*/		return 0x820C9310;
		  /* 820C9310h */ case   16:  		/* stw R11, <#[R3 + 8]> */
		/* 820C9310h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9310h case   16:*/		return 0x820C9314;
		  /* 820C9314h */ case   17:  		/* stw R10, <#[R3]> */
		/* 820C9314h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9314h case   17:*/		return 0x820C9318;
		  /* 820C9318h */ case   18:  		/* stw R9, <#[R3 + 4]> */
		/* 820C9318h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9318h case   18:*/		return 0x820C931C;
		  /* 820C931Ch */ case   19:  		/* stw R11, <#[R3 + 12]> */
		/* 820C931Ch case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C931Ch case   19:*/		return 0x820C9320;
		  /* 820C9320h */ case   20:  		/* b 8 */
		/* 820C9320h case   20:*/		return 0x820C9328;
		/* 820C9320h case   20:*/		return 0x820C9324;
	}
	return 0x820C9324;
} // Block from 820C92D0h-820C9324h (21 instructions)

//////////////////////////////////////////////////////
// Block at 820C9324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9324);
		  /* 820C9324h */ case    0:  		/* li R3, 0 */
		/* 820C9324h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C9324h case    0:*/		return 0x820C9328;
	}
	return 0x820C9328;
} // Block from 820C9324h-820C9328h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9328);
		  /* 820C9328h */ case    0:  		/* addi R1, R1, 96 */
		/* 820C9328h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C9328h case    0:*/		return 0x820C932C;
		  /* 820C932Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C932Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C932Ch case    1:*/		return 0x820C9330;
		  /* 820C9330h */ case    2:  		/* mtspr LR, R12 */
		/* 820C9330h case    2:*/		regs.LR = regs.R12;
		/* 820C9330h case    2:*/		return 0x820C9334;
		  /* 820C9334h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820C9334h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9334h case    3:*/		return 0x820C9338;
		  /* 820C9338h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820C9338h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9338h case    4:*/		return 0x820C933C;
	}
	return 0x820C933C;
} // Block from 820C9328h-820C933Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C933Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C933C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C933C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C933C);
		  /* 820C933Ch */ case    0:  		/* nop */
		/* 820C933Ch case    0:*/		cpu::op::nop();
		/* 820C933Ch case    0:*/		return 0x820C9340;
		  /* 820C9340h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 820C9340h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C9340h case    1:*/		return 0x820C9344;
		  /* 820C9344h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 820C9344h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C9358;  }
		/* 820C9344h case    2:*/		return 0x820C9348;
		  /* 820C9348h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 820C9348h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9348h case    3:*/		return 0x820C934C;
		  /* 820C934Ch */ case    4:  		/* lwz R11, <#[R11]> */
		/* 820C934Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C934Ch case    4:*/		return 0x820C9350;
		  /* 820C9350h */ case    5:  		/* mtspr CTR, R11 */
		/* 820C9350h case    5:*/		regs.CTR = regs.R11;
		/* 820C9350h case    5:*/		return 0x820C9354;
		  /* 820C9354h */ case    6:  		/* bcctr 20, CR0_LT */
		/* 820C9354h case    6:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820C9354h case    6:*/		return 0x820C9358;
	}
	return 0x820C9358;
} // Block from 820C933Ch-820C9358h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C9358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9358);
		  /* 820C9358h */ case    0:  		/* addi R11, R4, 0 */
		/* 820C9358h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820C9358h case    0:*/		return 0x820C935C;
		  /* 820C935Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820C935Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C935Ch case    1:*/		return 0x820C9360;
		  /* 820C9360h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820C9360h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820C9360h case    2:*/		return 0x820C9364;
		  /* 820C9364h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820C9364h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9364h case    3:*/		return 0x820C9368;
	}
	return 0x820C9368;
} // Block from 820C9358h-820C9368h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C9368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9368);
		  /* 820C9368h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820C9368h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C9368h case    0:*/		return 0x820C936C;
		  /* 820C936Ch */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 820C936Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C9374;  }
		/* 820C936Ch case    1:*/		return 0x820C9370;
		  /* 820C9370h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820C9370h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9370h case    2:*/		return 0x820C9374;
	}
	return 0x820C9374;
} // Block from 820C9368h-820C9374h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9374);
		  /* 820C9374h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 820C9374h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9374h case    0:*/		return 0x820C9378;
		  /* 820C9378h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 820C9378h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820C9378h case    1:*/		return 0x820C937C;
		  /* 820C937Ch */ case    2:  		/* mtspr CTR, R11 */
		/* 820C937Ch case    2:*/		regs.CTR = regs.R11;
		/* 820C937Ch case    2:*/		return 0x820C9380;
		  /* 820C9380h */ case    3:  		/* bcctr 20, CR0_LT */
		/* 820C9380h case    3:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 820C9380h case    3:*/		return 0x820C9384;
		  /* 820C9384h */ case    4:  		/* nop */
		/* 820C9384h case    4:*/		cpu::op::nop();
		/* 820C9384h case    4:*/		return 0x820C9388;
	}
	return 0x820C9388;
} // Block from 820C9374h-820C9388h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C9388h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9388);
		  /* 820C9388h */ case    0:  		/* mr R11, R3 */
		/* 820C9388h case    0:*/		regs.R11 = regs.R3;
		/* 820C9388h case    0:*/		return 0x820C938C;
		  /* 820C938Ch */ case    1:  		/* stw R3, <#[R1 + 20]> */
		/* 820C938Ch case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000014) );
		/* 820C938Ch case    1:*/		return 0x820C9390;
		  /* 820C9390h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 820C9390h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C9390h case    2:*/		return 0x820C9394;
		  /* 820C9394h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 820C9394h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C93A0;  }
		/* 820C9394h case    3:*/		return 0x820C9398;
		  /* 820C9398h */ case    4:  		/* mr R3, R4 */
		/* 820C9398h case    4:*/		regs.R3 = regs.R4;
		/* 820C9398h case    4:*/		return 0x820C939C;
		  /* 820C939Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C939Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C939Ch case    5:*/		return 0x820C93A0;
	}
	return 0x820C93A0;
} // Block from 820C9388h-820C93A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C93A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C93A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C93A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C93A0);
		  /* 820C93A0h */ case    0:  		/* addi R11, R1, 20 */
		/* 820C93A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x14);
		/* 820C93A0h case    0:*/		return 0x820C93A4;
		  /* 820C93A4h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 820C93A4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C93A4h case    1:*/		return 0x820C93A8;
		  /* 820C93A8h */ case    2:  		/* addi R11, R11, 12 */
		/* 820C93A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 820C93A8h case    2:*/		return 0x820C93AC;
		  /* 820C93ACh */ case    3:  		/* lwz R10, <#[R11]> */
		/* 820C93ACh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820C93ACh case    3:*/		return 0x820C93B0;
		  /* 820C93B0h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 820C93B0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820C93B0h case    4:*/		return 0x820C93B4;
		  /* 820C93B4h */ case    5:  		/* bc 4, CR6_EQ, -16 */
		/* 820C93B4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C93A4;  }
		/* 820C93B4h case    5:*/		return 0x820C93B8;
		  /* 820C93B8h */ case    6:  		/* stw R4, <#[R11]> */
		/* 820C93B8h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 820C93B8h case    6:*/		return 0x820C93BC;
		  /* 820C93BCh */ case    7:  		/* lwz R3, <#[R1 + 20]> */
		/* 820C93BCh case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000014) );
		/* 820C93BCh case    7:*/		return 0x820C93C0;
		  /* 820C93C0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820C93C0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C93C0h case    8:*/		return 0x820C93C4;
	}
	return 0x820C93C4;
} // Block from 820C93A0h-820C93C4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C93C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C93C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C93C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C93C4);
		  /* 820C93C4h */ case    0:  		/* nop */
		/* 820C93C4h case    0:*/		cpu::op::nop();
		/* 820C93C4h case    0:*/		return 0x820C93C8;
		  /* 820C93C8h */ case    1:  		/* lis R10, -32255 */
		/* 820C93C8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C93C8h case    1:*/		return 0x820C93CC;
		  /* 820C93CCh */ case    2:  		/* li R11, 0 */
		/* 820C93CCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C93CCh case    2:*/		return 0x820C93D0;
		  /* 820C93D0h */ case    3:  		/* li R9, 1 */
		/* 820C93D0h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820C93D0h case    3:*/		return 0x820C93D4;
		  /* 820C93D4h */ case    4:  		/* addi R10, R10, 10496 */
		/* 820C93D4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2900);
		/* 820C93D4h case    4:*/		return 0x820C93D8;
		  /* 820C93D8h */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 820C93D8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C93D8h case    5:*/		return 0x820C93DC;
		  /* 820C93DCh */ case    6:  		/* stw R9, <#[R3 + 4]> */
		/* 820C93DCh case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C93DCh case    6:*/		return 0x820C93E0;
		  /* 820C93E0h */ case    7:  		/* stw R10, <#[R3]> */
		/* 820C93E0h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C93E0h case    7:*/		return 0x820C93E4;
		  /* 820C93E4h */ case    8:  		/* stw R11, <#[R3 + 12]> */
		/* 820C93E4h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C93E4h case    8:*/		return 0x820C93E8;
		  /* 820C93E8h */ case    9:  		/* stw R11, <#[R3 + 16]> */
		/* 820C93E8h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820C93E8h case    9:*/		return 0x820C93EC;
		  /* 820C93ECh */ case   10:  		/* bclr 20, CR0_LT */
		/* 820C93ECh case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C93ECh case   10:*/		return 0x820C93F0;
	}
	return 0x820C93F0;
} // Block from 820C93C4h-820C93F0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C93F0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C93F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C93F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C93F0);
		  /* 820C93F0h */ case    0:  		/* lis R11, -32255 */
		/* 820C93F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C93F0h case    0:*/		return 0x820C93F4;
		  /* 820C93F4h */ case    1:  		/* stw R4, <#[R3 + 8]> */
		/* 820C93F4h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000008) );
		/* 820C93F4h case    1:*/		return 0x820C93F8;
		  /* 820C93F8h */ case    2:  		/* li R10, 1 */
		/* 820C93F8h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820C93F8h case    2:*/		return 0x820C93FC;
		  /* 820C93FCh */ case    3:  		/* stw R5, <#[R3 + 12]> */
		/* 820C93FCh case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C93FCh case    3:*/		return 0x820C9400;
		  /* 820C9400h */ case    4:  		/* addi R11, R11, 10496 */
		/* 820C9400h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2900);
		/* 820C9400h case    4:*/		return 0x820C9404;
		  /* 820C9404h */ case    5:  		/* stw R6, <#[R3 + 16]> */
		/* 820C9404h case    5:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9404h case    5:*/		return 0x820C9408;
		  /* 820C9408h */ case    6:  		/* stw R10, <#[R3 + 4]> */
		/* 820C9408h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9408h case    6:*/		return 0x820C940C;
		  /* 820C940Ch */ case    7:  		/* stw R11, <#[R3]> */
		/* 820C940Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C940Ch case    7:*/		return 0x820C9410;
		  /* 820C9410h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820C9410h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9410h case    8:*/		return 0x820C9414;
	}
	return 0x820C9414;
} // Block from 820C93F0h-820C9414h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C9414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9414);
		  /* 820C9414h */ case    0:  		/* nop */
		/* 820C9414h case    0:*/		cpu::op::nop();
		/* 820C9414h case    0:*/		return 0x820C9418;
	}
	return 0x820C9418;
} // Block from 820C9414h-820C9418h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9418);
		  /* 820C9418h */ case    0:  		/* mfspr R12, LR */
		/* 820C9418h case    0:*/		regs.R12 = regs.LR;
		/* 820C9418h case    0:*/		return 0x820C941C;
		  /* 820C941Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C941Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C941Ch case    1:*/		return 0x820C9420;
		  /* 820C9420h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C9420h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C9420h case    2:*/		return 0x820C9424;
		  /* 820C9424h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C9424h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9424h case    3:*/		return 0x820C9428;
		  /* 820C9428h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C9428h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C9428h case    4:*/		return 0x820C942C;
		  /* 820C942Ch */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 820C942Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C942Ch case    5:*/		return 0x820C9430;
		  /* 820C9430h */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 820C9430h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C9444;  }
		/* 820C9430h case    6:*/		return 0x820C9434;
		  /* 820C9434h */ case    7:  		/* lwz R11, <#[R4 + 4]> */
		/* 820C9434h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C9434h case    7:*/		return 0x820C9438;
		  /* 820C9438h */ case    8:  		/* lwz R10, <#[R3 + 4]> */
		/* 820C9438h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9438h case    8:*/		return 0x820C943C;
		  /* 820C943Ch */ case    9:  		/* cmpw CR6, R11, R10 */
		/* 820C943Ch case    9:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820C943Ch case    9:*/		return 0x820C9440;
		  /* 820C9440h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 820C9440h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C944C;  }
		/* 820C9440h case   10:*/		return 0x820C9444;
	}
	return 0x820C9444;
} // Block from 820C9418h-820C9444h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C9444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9444);
		  /* 820C9444h */ case    0:  		/* li R3, 0 */
		/* 820C9444h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C9444h case    0:*/		return 0x820C9448;
		  /* 820C9448h */ case    1:  		/* b 160 */
		/* 820C9448h case    1:*/		return 0x820C94E8;
		/* 820C9448h case    1:*/		return 0x820C944C;
	}
	return 0x820C944C;
} // Block from 820C9444h-820C944Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C944Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C944C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C944C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C944C);
		  /* 820C944Ch */ case    0:  		/* mr R31, R3 */
		/* 820C944Ch case    0:*/		regs.R31 = regs.R3;
		/* 820C944Ch case    0:*/		return 0x820C9450;
		  /* 820C9450h */ case    1:  		/* mr R30, R4 */
		/* 820C9450h case    1:*/		regs.R30 = regs.R4;
		/* 820C9450h case    1:*/		return 0x820C9454;
		  /* 820C9454h */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 820C9454h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820C9454h case    2:*/		return 0x820C9458;
		  /* 820C9458h */ case    3:  		/* cmpwi CR6, R11, 1 */
		/* 820C9458h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820C9458h case    3:*/		return 0x820C945C;
		  /* 820C945Ch */ case    4:  		/* bc 4, CR6_EQ, 100 */
		/* 820C945Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C94C0;  }
		/* 820C945Ch case    4:*/		return 0x820C9460;
		  /* 820C9460h */ case    5:  		/* cmplwi CR6, R30, 0 */
		/* 820C9460h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820C9460h case    5:*/		return 0x820C9464;
		  /* 820C9464h */ case    6:  		/* bc 12, CR6_EQ, -32 */
		/* 820C9464h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C9444;  }
		/* 820C9464h case    6:*/		return 0x820C9468;
		  /* 820C9468h */ case    7:  		/* lwz R11, <#[R30 + 4]> */
		/* 820C9468h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 820C9468h case    7:*/		return 0x820C946C;
		  /* 820C946Ch */ case    8:  		/* cmpwi CR6, R11, 1 */
		/* 820C946Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820C946Ch case    8:*/		return 0x820C9470;
		  /* 820C9470h */ case    9:  		/* bc 4, CR6_EQ, -44 */
		/* 820C9470h case    9:*/		if ( !regs.CR[6].eq ) { return 0x820C9444;  }
		/* 820C9470h case    9:*/		return 0x820C9474;
		  /* 820C9474h */ case   10:  		/* lwz R3, <#[R31 + 8]> */
		/* 820C9474h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 820C9474h case   10:*/		return 0x820C9478;
		  /* 820C9478h */ case   11:  		/* lwz R4, <#[R30 + 8]> */
		/* 820C9478h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000008) );
		/* 820C9478h case   11:*/		return 0x820C947C;
		  /* 820C947Ch */ case   12:  		/* cmplwi CR6, R3, 0 */
		/* 820C947Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C947Ch case   12:*/		return 0x820C9480;
		  /* 820C9480h */ case   13:  		/* bc 12, CR6_EQ, 24 */
		/* 820C9480h case   13:*/		if ( regs.CR[6].eq ) { return 0x820C9498;  }
		/* 820C9480h case   13:*/		return 0x820C9484;
		  /* 820C9484h */ case   14:  		/* lwz R11, <#[R3]> */
		/* 820C9484h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9484h case   14:*/		return 0x820C9488;
		  /* 820C9488h */ case   15:  		/* lwz R11, <#[R11]> */
		/* 820C9488h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C9488h case   15:*/		return 0x820C948C;
		  /* 820C948Ch */ case   16:  		/* mtspr CTR, R11 */
		/* 820C948Ch case   16:*/		regs.CTR = regs.R11;
		/* 820C948Ch case   16:*/		return 0x820C9490;
		  /* 820C9490h */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 820C9490h case   17:*/		if ( 1 ) { regs.LR = 0x820C9494; return (uint32)regs.CTR; }
		/* 820C9490h case   17:*/		return 0x820C9494;
		  /* 820C9494h */ case   18:  		/* b 16 */
		/* 820C9494h case   18:*/		return 0x820C94A4;
		/* 820C9494h case   18:*/		return 0x820C9498;
	}
	return 0x820C9498;
} // Block from 820C944Ch-820C9498h (19 instructions)

//////////////////////////////////////////////////////
// Block at 820C9498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9498);
		  /* 820C9498h */ case    0:  		/* addi R11, R4, 0 */
		/* 820C9498h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820C9498h case    0:*/		return 0x820C949C;
		  /* 820C949Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820C949Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C949Ch case    1:*/		return 0x820C94A0;
		  /* 820C94A0h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820C94A0h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820C94A0h case    2:*/		return 0x820C94A4;
	}
	return 0x820C94A4;
} // Block from 820C9498h-820C94A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C94A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C94A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C94A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C94A4);
		  /* 820C94A4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820C94A4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820C94A4h case    0:*/		return 0x820C94A8;
		  /* 820C94A8h */ case    1:  		/* bc 12, CR6_EQ, -100 */
		/* 820C94A8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C9444;  }
		/* 820C94A8h case    1:*/		return 0x820C94AC;
		  /* 820C94ACh */ case    2:  		/* lwz R31, <#[R31 + 12]> */
		/* 820C94ACh case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000000C) );
		/* 820C94ACh case    2:*/		return 0x820C94B0;
		  /* 820C94B0h */ case    3:  		/* lwz R30, <#[R30 + 12]> */
		/* 820C94B0h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x0000000C) );
		/* 820C94B0h case    3:*/		return 0x820C94B4;
		  /* 820C94B4h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 820C94B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C94B4h case    4:*/		return 0x820C94B8;
		  /* 820C94B8h */ case    5:  		/* bc 4, CR6_EQ, -100 */
		/* 820C94B8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820C9454;  }
		/* 820C94B8h case    5:*/		return 0x820C94BC;
		  /* 820C94BCh */ case    6:  		/* b 40 */
		/* 820C94BCh case    6:*/		return 0x820C94E4;
		/* 820C94BCh case    6:*/		return 0x820C94C0;
	}
	return 0x820C94C0;
} // Block from 820C94A4h-820C94C0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C94C0h
// Function '?Initialize@CConstantTable@D3DXShader@@QAAJPBKPAPAUID3DXBuffer@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C94C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C94C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C94C0);
		  /* 820C94C0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820C94C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C94C0h case    0:*/		return 0x820C94C4;
		  /* 820C94C4h */ case    1:  		/* mr R4, R30 */
		/* 820C94C4h case    1:*/		regs.R4 = regs.R30;
		/* 820C94C4h case    1:*/		return 0x820C94C8;
		  /* 820C94C8h */ case    2:  		/* mr R3, R31 */
		/* 820C94C8h case    2:*/		regs.R3 = regs.R31;
		/* 820C94C8h case    2:*/		return 0x820C94CC;
		  /* 820C94CCh */ case    3:  		/* lwz R11, <#[R11]> */
		/* 820C94CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C94CCh case    3:*/		return 0x820C94D0;
		  /* 820C94D0h */ case    4:  		/* mtspr CTR, R11 */
		/* 820C94D0h case    4:*/		regs.CTR = regs.R11;
		/* 820C94D0h case    4:*/		return 0x820C94D4;
		  /* 820C94D4h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 820C94D4h case    5:*/		if ( 1 ) { regs.LR = 0x820C94D8; return (uint32)regs.CTR; }
		/* 820C94D4h case    5:*/		return 0x820C94D8;
		  /* 820C94D8h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 820C94D8h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820C94D8h case    6:*/		return 0x820C94DC;
		  /* 820C94DCh */ case    7:  		/* li R3, 0 */
		/* 820C94DCh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C94DCh case    7:*/		return 0x820C94E0;
		  /* 820C94E0h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 820C94E0h case    8:*/		if ( regs.CR[0].eq ) { return 0x820C94E8;  }
		/* 820C94E0h case    8:*/		return 0x820C94E4;
	}
	return 0x820C94E4;
} // Block from 820C94C0h-820C94E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C94E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C94E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C94E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C94E4);
		  /* 820C94E4h */ case    0:  		/* li R3, 1 */
		/* 820C94E4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820C94E4h case    0:*/		return 0x820C94E8;
	}
	return 0x820C94E8;
} // Block from 820C94E4h-820C94E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C94E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C94E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C94E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C94E8);
		  /* 820C94E8h */ case    0:  		/* addi R1, R1, 112 */
		/* 820C94E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C94E8h case    0:*/		return 0x820C94EC;
		  /* 820C94ECh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C94ECh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C94ECh case    1:*/		return 0x820C94F0;
		  /* 820C94F0h */ case    2:  		/* mtspr LR, R12 */
		/* 820C94F0h case    2:*/		regs.LR = regs.R12;
		/* 820C94F0h case    2:*/		return 0x820C94F4;
		  /* 820C94F4h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820C94F4h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C94F4h case    3:*/		return 0x820C94F8;
		  /* 820C94F8h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820C94F8h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C94F8h case    4:*/		return 0x820C94FC;
		  /* 820C94FCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C94FCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C94FCh case    5:*/		return 0x820C9500;
	}
	return 0x820C9500;
} // Block from 820C94E8h-820C9500h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C9500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9500);
		  /* 820C9500h */ case    0:  		/* mfspr R12, LR */
		/* 820C9500h case    0:*/		regs.R12 = regs.LR;
		/* 820C9500h case    0:*/		return 0x820C9504;
		  /* 820C9504h */ case    1:  		/* bl -230060 */
		/* 820C9504h case    1:*/		regs.LR = 0x820C9508; return 0x82091258;
		/* 820C9504h case    1:*/		return 0x820C9508;
		  /* 820C9508h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 820C9508h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820C9508h case    2:*/		return 0x820C950C;
		  /* 820C950Ch */ case    3:  		/* li R29, 0 */
		/* 820C950Ch case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820C950Ch case    3:*/		return 0x820C9510;
		  /* 820C9510h */ case    4:  		/* mr R31, R3 */
		/* 820C9510h case    4:*/		regs.R31 = regs.R3;
		/* 820C9510h case    4:*/		return 0x820C9514;
		  /* 820C9514h */ case    5:  		/* stw R29, <#[R1 + 80]> */
		/* 820C9514h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 820C9514h case    5:*/		return 0x820C9518;
		  /* 820C9518h */ case    6:  		/* addi R30, R1, 80 */
		/* 820C9518h case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x50);
		/* 820C9518h case    6:*/		return 0x820C951C;
		  /* 820C951Ch */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 820C951Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C951Ch case    7:*/		return 0x820C9520;
		  /* 820C9520h */ case    8:  		/* bc 12, CR6_EQ, 212 */
		/* 820C9520h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C95F4;  }
		/* 820C9520h case    8:*/		return 0x820C9524;
		  /* 820C9524h */ case    9:  		/* lis R11, -32255 */
		/* 820C9524h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C9524h case    9:*/		return 0x820C9528;
		  /* 820C9528h */ case   10:  		/* addi R28, R11, 10496 */
		/* 820C9528h case   10:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x2900);
		/* 820C9528h case   10:*/		return 0x820C952C;
		  /* 820C952Ch */ case   11:  		/* lwz R11, <#[R31 + 4]> */
		/* 820C952Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820C952Ch case   11:*/		return 0x820C9530;
		  /* 820C9530h */ case   12:  		/* cmpwi CR6, R11, 1 */
		/* 820C9530h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 820C9530h case   12:*/		return 0x820C9534;
		  /* 820C9534h */ case   13:  		/* bc 4, CR6_EQ, 168 */
		/* 820C9534h case   13:*/		if ( !regs.CR[6].eq ) { return 0x820C95DC;  }
		/* 820C9534h case   13:*/		return 0x820C9538;
		  /* 820C9538h */ case   14:  		/* bl 15096 */
		/* 820C9538h case   14:*/		regs.LR = 0x820C953C; return 0x820CD030;
		/* 820C9538h case   14:*/		return 0x820C953C;
		  /* 820C953Ch */ case   15:  		/* li R5, 16 */
		/* 820C953Ch case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820C953Ch case   15:*/		return 0x820C9540;
		  /* 820C9540h */ case   16:  		/* li R4, 20 */
		/* 820C9540h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 820C9540h case   16:*/		return 0x820C9544;
		  /* 820C9544h */ case   17:  		/* lwz R3, <#[R3]> */
		/* 820C9544h case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9544h case   17:*/		return 0x820C9548;
		  /* 820C9548h */ case   18:  		/* bl -1128 */
		/* 820C9548h case   18:*/		regs.LR = 0x820C954C; return 0x820C90E0;
		/* 820C9548h case   18:*/		return 0x820C954C;
		  /* 820C954Ch */ case   19:  		/* cmplwi CR0, R3, 0 */
		/* 820C954Ch case   19:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C954Ch case   19:*/		return 0x820C9550;
		  /* 820C9550h */ case   20:  		/* bc 12, CR0_EQ, 36 */
		/* 820C9550h case   20:*/		if ( regs.CR[0].eq ) { return 0x820C9574;  }
		/* 820C9550h case   20:*/		return 0x820C9554;
		  /* 820C9554h */ case   21:  		/* li R10, 1 */
		/* 820C9554h case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820C9554h case   21:*/		return 0x820C9558;
		  /* 820C9558h */ case   22:  		/* stw R28, <#[R3]> */
		/* 820C9558h case   22:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9558h case   22:*/		return 0x820C955C;
		  /* 820C955Ch */ case   23:  		/* stw R29, <#[R3 + 8]> */
		/* 820C955Ch case   23:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000008) );
		/* 820C955Ch case   23:*/		return 0x820C9560;
		  /* 820C9560h */ case   24:  		/* mr R11, R3 */
		/* 820C9560h case   24:*/		regs.R11 = regs.R3;
		/* 820C9560h case   24:*/		return 0x820C9564;
		  /* 820C9564h */ case   25:  		/* stw R10, <#[R3 + 4]> */
		/* 820C9564h case   25:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9564h case   25:*/		return 0x820C9568;
		  /* 820C9568h */ case   26:  		/* stw R29, <#[R3 + 12]> */
		/* 820C9568h case   26:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C9568h case   26:*/		return 0x820C956C;
		  /* 820C956Ch */ case   27:  		/* stw R29, <#[R3 + 16]> */
		/* 820C956Ch case   27:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000010) );
		/* 820C956Ch case   27:*/		return 0x820C9570;
		  /* 820C9570h */ case   28:  		/* b 8 */
		/* 820C9570h case   28:*/		return 0x820C9578;
		/* 820C9570h case   28:*/		return 0x820C9574;
	}
	return 0x820C9574;
} // Block from 820C9500h-820C9574h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820C9574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9574);
		  /* 820C9574h */ case    0:  		/* mr R11, R29 */
		/* 820C9574h case    0:*/		regs.R11 = regs.R29;
		/* 820C9574h case    0:*/		return 0x820C9578;
	}
	return 0x820C9578;
} // Block from 820C9574h-820C9578h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9578);
		  /* 820C9578h */ case    0:  		/* stw R11, <#[R30]> */
		/* 820C9578h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C9578h case    0:*/		return 0x820C957C;
		  /* 820C957Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C957Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C957Ch case    1:*/		return 0x820C9580;
		  /* 820C9580h */ case    2:  		/* bc 12, CR6_EQ, 116 */
		/* 820C9580h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C95F4;  }
		/* 820C9580h case    2:*/		return 0x820C9584;
		  /* 820C9584h */ case    3:  		/* lwz R10, <#[R31 + 16]> */
		/* 820C9584h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820C9584h case    3:*/		return 0x820C9588;
		  /* 820C9588h */ case    4:  		/* stw R10, <#[R11 + 16]> */
		/* 820C9588h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820C9588h case    4:*/		return 0x820C958C;
		  /* 820C958Ch */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 820C958Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 820C958Ch case    5:*/		return 0x820C9590;
		  /* 820C9590h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820C9590h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C9590h case    6:*/		return 0x820C9594;
		  /* 820C9594h */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 820C9594h case    7:*/		if ( regs.CR[6].eq ) { return 0x820C95BC;  }
		/* 820C9594h case    7:*/		return 0x820C9598;
		  /* 820C9598h */ case    8:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820C9598h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820C9598h case    8:*/		return 0x820C959C;
		  /* 820C959Ch */ case    9:  		/* lwz R11, <#[R3]> */
		/* 820C959Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C959Ch case    9:*/		return 0x820C95A0;
		  /* 820C95A0h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 820C95A0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820C95A0h case   10:*/		return 0x820C95A4;
		  /* 820C95A4h */ case   11:  		/* mtspr CTR, R11 */
		/* 820C95A4h case   11:*/		regs.CTR = regs.R11;
		/* 820C95A4h case   11:*/		return 0x820C95A8;
		  /* 820C95A8h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 820C95A8h case   12:*/		if ( 1 ) { regs.LR = 0x820C95AC; return (uint32)regs.CTR; }
		/* 820C95A8h case   12:*/		return 0x820C95AC;
		  /* 820C95ACh */ case   13:  		/* lwz R11, <#[R30]> */
		/* 820C95ACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C95ACh case   13:*/		return 0x820C95B0;
		  /* 820C95B0h */ case   14:  		/* cmplwi CR0, R3, 0 */
		/* 820C95B0h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C95B0h case   14:*/		return 0x820C95B4;
		  /* 820C95B4h */ case   15:  		/* stw R3, <#[R11 + 8]> */
		/* 820C95B4h case   15:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000008) );
		/* 820C95B4h case   15:*/		return 0x820C95B8;
		  /* 820C95B8h */ case   16:  		/* bc 12, CR0_EQ, 28 */
		/* 820C95B8h case   16:*/		if ( regs.CR[0].eq ) { return 0x820C95D4;  }
		/* 820C95B8h case   16:*/		return 0x820C95BC;
	}
	return 0x820C95BC;
} // Block from 820C9578h-820C95BCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C95BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C95BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C95BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C95BC);
		  /* 820C95BCh */ case    0:  		/* lwz R31, <#[R31 + 12]> */
		/* 820C95BCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000000C) );
		/* 820C95BCh case    0:*/		return 0x820C95C0;
		  /* 820C95C0h */ case    1:  		/* lwz R11, <#[R30]> */
		/* 820C95C0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820C95C0h case    1:*/		return 0x820C95C4;
		  /* 820C95C4h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 820C95C4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C95C4h case    2:*/		return 0x820C95C8;
		  /* 820C95C8h */ case    3:  		/* addi R30, R11, 12 */
		/* 820C95C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xC);
		/* 820C95C8h case    3:*/		return 0x820C95CC;
		  /* 820C95CCh */ case    4:  		/* bc 4, CR6_EQ, -160 */
		/* 820C95CCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C952C;  }
		/* 820C95CCh case    4:*/		return 0x820C95D0;
		  /* 820C95D0h */ case    5:  		/* b 36 */
		/* 820C95D0h case    5:*/		return 0x820C95F4;
		/* 820C95D0h case    5:*/		return 0x820C95D4;
	}
	return 0x820C95D4;
} // Block from 820C95BCh-820C95D4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C95D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C95D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C95D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C95D4);
		  /* 820C95D4h */ case    0:  		/* stw R29, <#[R30]> */
		/* 820C95D4h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00000000) );
		/* 820C95D4h case    0:*/		return 0x820C95D8;
		  /* 820C95D8h */ case    1:  		/* b 28 */
		/* 820C95D8h case    1:*/		return 0x820C95F4;
		/* 820C95D8h case    1:*/		return 0x820C95DC;
	}
	return 0x820C95DC;
} // Block from 820C95D4h-820C95DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C95DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C95DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C95DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C95DC);
		  /* 820C95DCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820C95DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820C95DCh case    0:*/		return 0x820C95E0;
		  /* 820C95E0h */ case    1:  		/* mr R3, R31 */
		/* 820C95E0h case    1:*/		regs.R3 = regs.R31;
		/* 820C95E0h case    1:*/		return 0x820C95E4;
		  /* 820C95E4h */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 820C95E4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820C95E4h case    2:*/		return 0x820C95E8;
		  /* 820C95E8h */ case    3:  		/* mtspr CTR, R11 */
		/* 820C95E8h case    3:*/		regs.CTR = regs.R11;
		/* 820C95E8h case    3:*/		return 0x820C95EC;
		  /* 820C95ECh */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820C95ECh case    4:*/		if ( 1 ) { regs.LR = 0x820C95F0; return (uint32)regs.CTR; }
		/* 820C95ECh case    4:*/		return 0x820C95F0;
		  /* 820C95F0h */ case    5:  		/* stw R3, <#[R30]> */
		/* 820C95F0h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 820C95F0h case    5:*/		return 0x820C95F4;
	}
	return 0x820C95F4;
} // Block from 820C95DCh-820C95F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C95F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C95F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C95F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C95F4);
		  /* 820C95F4h */ case    0:  		/* lwz R3, <#[R1 + 80]> */
		/* 820C95F4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 820C95F4h case    0:*/		return 0x820C95F8;
		  /* 820C95F8h */ case    1:  		/* addi R1, R1, 128 */
		/* 820C95F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820C95F8h case    1:*/		return 0x820C95FC;
		  /* 820C95FCh */ case    2:  		/* b -230228 */
		/* 820C95FCh case    2:*/		return 0x820912A8;
		/* 820C95FCh case    2:*/		return 0x820C9600;
		  /* 820C9600h */ case    3:  		/* lis R11, -32255 */
		/* 820C9600h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 820C9600h case    3:*/		return 0x820C9604;
		  /* 820C9604h */ case    4:  		/* stw R4, <#[R3 + 16]> */
		/* 820C9604h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9604h case    4:*/		return 0x820C9608;
		  /* 820C9608h */ case    5:  		/* li R10, 2 */
		/* 820C9608h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 820C9608h case    5:*/		return 0x820C960C;
		  /* 820C960Ch */ case    6:  		/* stw R5, <#[R3 + 8]> */
		/* 820C960Ch case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000008) );
		/* 820C960Ch case    6:*/		return 0x820C9610;
	}
	return 0x820C9610;
} // Block from 820C95F4h-820C9610h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C9610h
// Function '?FindConstantByName@CConstantTable@D3DXShader@@QAAJPBDPAPAVCConstant@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9610);
		  /* 820C9610h */ case    0:  		/* addi R11, R11, 10508 */
		/* 820C9610h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x290C);
		/* 820C9610h case    0:*/		return 0x820C9614;
		  /* 820C9614h */ case    1:  		/* stw R6, <#[R3 + 12]> */
		/* 820C9614h case    1:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C9614h case    1:*/		return 0x820C9618;
		  /* 820C9618h */ case    2:  		/* stw R10, <#[R3 + 4]> */
		/* 820C9618h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9618h case    2:*/		return 0x820C961C;
		  /* 820C961Ch */ case    3:  		/* stw R11, <#[R3]> */
		/* 820C961Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C961Ch case    3:*/		return 0x820C9620;
		  /* 820C9620h */ case    4:  		/* stw R7, <#[R3 + 20]> */
		/* 820C9620h case    4:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9620h case    4:*/		return 0x820C9624;
		  /* 820C9624h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C9624h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9624h case    5:*/		return 0x820C9628;
	}
	return 0x820C9628;
} // Block from 820C9610h-820C9628h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C9628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9628);
		  /* 820C9628h */ case    0:  		/* mfspr R12, LR */
		/* 820C9628h case    0:*/		regs.R12 = regs.LR;
		/* 820C9628h case    0:*/		return 0x820C962C;
		  /* 820C962Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C962Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C962Ch case    1:*/		return 0x820C9630;
		  /* 820C9630h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C9630h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C9630h case    2:*/		return 0x820C9634;
		  /* 820C9634h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C9634h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9634h case    3:*/		return 0x820C9638;
		  /* 820C9638h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C9638h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C9638h case    4:*/		return 0x820C963C;
		  /* 820C963Ch */ case    5:  		/* mr R30, R3 */
		/* 820C963Ch case    5:*/		regs.R30 = regs.R3;
		/* 820C963Ch case    5:*/		return 0x820C9640;
		  /* 820C9640h */ case    6:  		/* mr R31, R4 */
		/* 820C9640h case    6:*/		regs.R31 = regs.R4;
		/* 820C9640h case    6:*/		return 0x820C9644;
		  /* 820C9644h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820C9644h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C9644h case    7:*/		return 0x820C9648;
		  /* 820C9648h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 820C9648h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C965C;  }
		/* 820C9648h case    8:*/		return 0x820C964C;
		  /* 820C964Ch */ case    9:  		/* lwz R11, <#[R4 + 4]> */
		/* 820C964Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C964Ch case    9:*/		return 0x820C9650;
		  /* 820C9650h */ case   10:  		/* lwz R10, <#[R3 + 4]> */
		/* 820C9650h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9650h case   10:*/		return 0x820C9654;
		  /* 820C9654h */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820C9654h case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820C9654h case   11:*/		return 0x820C9658;
		  /* 820C9658h */ case   12:  		/* bc 12, CR6_EQ, 12 */
		/* 820C9658h case   12:*/		if ( regs.CR[6].eq ) { return 0x820C9664;  }
		/* 820C9658h case   12:*/		return 0x820C965C;
	}
	return 0x820C965C;
} // Block from 820C9628h-820C965Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820C965Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C965C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C965C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C965C);
		  /* 820C965Ch */ case    0:  		/* li R3, 0 */
		/* 820C965Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C965Ch case    0:*/		return 0x820C9660;
		  /* 820C9660h */ case    1:  		/* b 148 */
		/* 820C9660h case    1:*/		return 0x820C96F4;
		/* 820C9660h case    1:*/		return 0x820C9664;
	}
	return 0x820C9664;
} // Block from 820C965Ch-820C9664h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C9664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9664);
		  /* 820C9664h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C9664h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C9664h case    0:*/		return 0x820C9668;
		  /* 820C9668h */ case    1:  		/* lwz R10, <#[R31 + 16]> */
		/* 820C9668h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 820C9668h case    1:*/		return 0x820C966C;
		  /* 820C966Ch */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C966Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C966Ch case    2:*/		return 0x820C9670;
		  /* 820C9670h */ case    3:  		/* bc 4, CR6_EQ, -20 */
		/* 820C9670h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C965C;  }
		/* 820C9670h case    3:*/		return 0x820C9674;
		  /* 820C9674h */ case    4:  		/* lwz R11, <#[R30 + 20]> */
		/* 820C9674h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C9674h case    4:*/		return 0x820C9678;
		  /* 820C9678h */ case    5:  		/* lwz R10, <#[R31 + 20]> */
		/* 820C9678h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 820C9678h case    5:*/		return 0x820C967C;
		  /* 820C967Ch */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 820C967Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C967Ch case    6:*/		return 0x820C9680;
		  /* 820C9680h */ case    7:  		/* bc 4, CR6_EQ, -36 */
		/* 820C9680h case    7:*/		if ( !regs.CR[6].eq ) { return 0x820C965C;  }
		/* 820C9680h case    7:*/		return 0x820C9684;
		  /* 820C9684h */ case    8:  		/* lwz R3, <#[R30 + 8]> */
		/* 820C9684h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000008) );
		/* 820C9684h case    8:*/		return 0x820C9688;
		  /* 820C9688h */ case    9:  		/* lwz R4, <#[R31 + 8]> */
		/* 820C9688h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 820C9688h case    9:*/		return 0x820C968C;
		  /* 820C968Ch */ case   10:  		/* cmplwi CR6, R3, 0 */
		/* 820C968Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C968Ch case   10:*/		return 0x820C9690;
		  /* 820C9690h */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 820C9690h case   11:*/		if ( regs.CR[6].eq ) { return 0x820C96A8;  }
		/* 820C9690h case   11:*/		return 0x820C9694;
		  /* 820C9694h */ case   12:  		/* lwz R11, <#[R3]> */
		/* 820C9694h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9694h case   12:*/		return 0x820C9698;
		  /* 820C9698h */ case   13:  		/* lwz R11, <#[R11]> */
		/* 820C9698h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C9698h case   13:*/		return 0x820C969C;
		  /* 820C969Ch */ case   14:  		/* mtspr CTR, R11 */
		/* 820C969Ch case   14:*/		regs.CTR = regs.R11;
		/* 820C969Ch case   14:*/		return 0x820C96A0;
		  /* 820C96A0h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 820C96A0h case   15:*/		if ( 1 ) { regs.LR = 0x820C96A4; return (uint32)regs.CTR; }
		/* 820C96A0h case   15:*/		return 0x820C96A4;
		  /* 820C96A4h */ case   16:  		/* b 16 */
		/* 820C96A4h case   16:*/		return 0x820C96B4;
		/* 820C96A4h case   16:*/		return 0x820C96A8;
	}
	return 0x820C96A8;
} // Block from 820C9664h-820C96A8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820C96A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C96A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C96A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C96A8);
		  /* 820C96A8h */ case    0:  		/* addi R11, R4, 0 */
		/* 820C96A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820C96A8h case    0:*/		return 0x820C96AC;
		  /* 820C96ACh */ case    1:  		/* cntlzw R11, R11 */
		/* 820C96ACh case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C96ACh case    1:*/		return 0x820C96B0;
		  /* 820C96B0h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820C96B0h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820C96B0h case    2:*/		return 0x820C96B4;
	}
	return 0x820C96B4;
} // Block from 820C96A8h-820C96B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C96B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C96B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C96B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C96B4);
		  /* 820C96B4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820C96B4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820C96B4h case    0:*/		return 0x820C96B8;
		  /* 820C96B8h */ case    1:  		/* bc 12, CR6_EQ, -92 */
		/* 820C96B8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C965C;  }
		/* 820C96B8h case    1:*/		return 0x820C96BC;
		  /* 820C96BCh */ case    2:  		/* lwz R3, <#[R30 + 12]> */
		/* 820C96BCh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000000C) );
		/* 820C96BCh case    2:*/		return 0x820C96C0;
		  /* 820C96C0h */ case    3:  		/* lwz R4, <#[R31 + 12]> */
		/* 820C96C0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 820C96C0h case    3:*/		return 0x820C96C4;
		  /* 820C96C4h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820C96C4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C96C4h case    4:*/		return 0x820C96C8;
		  /* 820C96C8h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820C96C8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C96E0;  }
		/* 820C96C8h case    5:*/		return 0x820C96CC;
		  /* 820C96CCh */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820C96CCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C96CCh case    6:*/		return 0x820C96D0;
		  /* 820C96D0h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820C96D0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C96D0h case    7:*/		return 0x820C96D4;
		  /* 820C96D4h */ case    8:  		/* mtspr CTR, R11 */
		/* 820C96D4h case    8:*/		regs.CTR = regs.R11;
		/* 820C96D4h case    8:*/		return 0x820C96D8;
		  /* 820C96D8h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820C96D8h case    9:*/		if ( 1 ) { regs.LR = 0x820C96DC; return (uint32)regs.CTR; }
		/* 820C96D8h case    9:*/		return 0x820C96DC;
		  /* 820C96DCh */ case   10:  		/* b 16 */
		/* 820C96DCh case   10:*/		return 0x820C96EC;
		/* 820C96DCh case   10:*/		return 0x820C96E0;
	}
	return 0x820C96E0;
} // Block from 820C96B4h-820C96E0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C96E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C96E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C96E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C96E0);
		  /* 820C96E0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820C96E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820C96E0h case    0:*/		return 0x820C96E4;
		  /* 820C96E4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820C96E4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C96E4h case    1:*/		return 0x820C96E8;
		  /* 820C96E8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820C96E8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820C96E8h case    2:*/		return 0x820C96EC;
	}
	return 0x820C96EC;
} // Block from 820C96E0h-820C96ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C96ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C96EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C96EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C96EC);
		  /* 820C96ECh */ case    0:  		/* addic R11, R3, -1 */
		/* 820C96ECh case    0:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 820C96ECh case    0:*/		return 0x820C96F0;
		  /* 820C96F0h */ case    1:  		/* subfe R3, R11, R3 */
		/* 820C96F0h case    1:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C96F0h case    1:*/		return 0x820C96F4;
	}
	return 0x820C96F4;
} // Block from 820C96ECh-820C96F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C96F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C96F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C96F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C96F4);
		  /* 820C96F4h */ case    0:  		/* addi R1, R1, 112 */
		/* 820C96F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C96F4h case    0:*/		return 0x820C96F8;
		  /* 820C96F8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C96F8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C96F8h case    1:*/		return 0x820C96FC;
		  /* 820C96FCh */ case    2:  		/* mtspr LR, R12 */
		/* 820C96FCh case    2:*/		regs.LR = regs.R12;
		/* 820C96FCh case    2:*/		return 0x820C9700;
		  /* 820C9700h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820C9700h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C9700h case    3:*/		return 0x820C9704;
		  /* 820C9704h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820C9704h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9704h case    4:*/		return 0x820C9708;
		  /* 820C9708h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C9708h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9708h case    5:*/		return 0x820C970C;
	}
	return 0x820C970C;
} // Block from 820C96F4h-820C970Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C970Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C970C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C970C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C970C);
		  /* 820C970Ch */ case    0:  		/* nop */
		/* 820C970Ch case    0:*/		cpu::op::nop();
		/* 820C970Ch case    0:*/		return 0x820C9710;
		  /* 820C9710h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 820C9710h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9710h case    1:*/		return 0x820C9714;
		  /* 820C9714h */ case    2:  		/* lwz R10, <#[R4]> */
		/* 820C9714h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 820C9714h case    2:*/		return 0x820C9718;
		  /* 820C9718h */ case    3:  		/* cmpw CR6, R11, R10 */
		/* 820C9718h case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820C9718h case    3:*/		return 0x820C971C;
		  /* 820C971Ch */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 820C971Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x820C9728;  }
		/* 820C971Ch case    4:*/		return 0x820C9720;
		  /* 820C9720h */ case    5:  		/* li R3, 0 */
		/* 820C9720h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C9720h case    5:*/		return 0x820C9724;
		  /* 820C9724h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820C9724h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9724h case    6:*/		return 0x820C9728;
	}
	return 0x820C9728;
} // Block from 820C970Ch-820C9728h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C9728h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9728);
		  /* 820C9728h */ case    0:  		/* cmpwi CR6, R11, 10 */
		/* 820C9728h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000A);
		/* 820C9728h case    0:*/		return 0x820C972C;
		  /* 820C972Ch */ case    1:  		/* bc 12, CR6_GT, 124 */
		/* 820C972Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x820C97A8;  }
		/* 820C972Ch case    1:*/		return 0x820C9730;
		  /* 820C9730h */ case    2:  		/* cmpwi CR6, R11, 7 */
		/* 820C9730h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000007);
		/* 820C9730h case    2:*/		return 0x820C9734;
		  /* 820C9734h */ case    3:  		/* bc 4, CR6_LT, 100 */
		/* 820C9734h case    3:*/		if ( !regs.CR[6].lt ) { return 0x820C9798;  }
		/* 820C9734h case    3:*/		return 0x820C9738;
		  /* 820C9738h */ case    4:  		/* cmplwi CR6, R11, 1 */
		/* 820C9738h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820C9738h case    4:*/		return 0x820C973C;
		  /* 820C973Ch */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 820C973Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x820C974C;  }
		/* 820C973Ch case    5:*/		return 0x820C9740;
		  /* 820C9740h */ case    6:  		/* bc 12, CR6_EQ, 32 */
		/* 820C9740h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C9760;  }
		/* 820C9740h case    6:*/		return 0x820C9744;
		  /* 820C9744h */ case    7:  		/* cmplwi CR6, R11, 5 */
		/* 820C9744h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 820C9744h case    7:*/		return 0x820C9748;
		  /* 820C9748h */ case    8:  		/* bc 4, CR6_LT, 216 */
		/* 820C9748h case    8:*/		if ( !regs.CR[6].lt ) { return 0x820C9820;  }
		/* 820C9748h case    8:*/		return 0x820C974C;
	}
	return 0x820C974C;
} // Block from 820C9728h-820C974Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C974Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C974C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C974C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C974C);
		  /* 820C974Ch */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 820C974Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C974Ch case    0:*/		return 0x820C9750;
		  /* 820C9750h */ case    1:  		/* lwz R10, <#[R4 + 8]> */
		/* 820C9750h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 820C9750h case    1:*/		return 0x820C9754;
		  /* 820C9754h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820C9754h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C9754h case    2:*/		return 0x820C9758;
		  /* 820C9758h */ case    3:  		/* bc 12, CR6_EQ, 200 */
		/* 820C9758h case    3:*/		if ( regs.CR[6].eq ) { return 0x820C9820;  }
		/* 820C9758h case    3:*/		return 0x820C975C;
		  /* 820C975Ch */ case    4:  		/* b -60 */
		/* 820C975Ch case    4:*/		return 0x820C9720;
		/* 820C975Ch case    4:*/		return 0x820C9760;
	}
	return 0x820C9760;
} // Block from 820C974Ch-820C9760h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C9760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9760);
		  /* 820C9760h */ case    0:  		/* addi R10, R4, 8 */
		/* 820C9760h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x8);
		/* 820C9760h case    0:*/		return 0x820C9764;
		  /* 820C9764h */ case    1:  		/* addi R11, R3, 8 */
		/* 820C9764h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x8);
		/* 820C9764h case    1:*/		return 0x820C9768;
		  /* 820C9768h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820C9768h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C9768h case    2:*/		return 0x820C976C;
		  /* 820C976Ch */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820C976Ch case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820C976Ch case    3:*/		return 0x820C9770;
		  /* 820C9770h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820C9770h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820C9770h case    4:*/		return 0x820C9774;
		  /* 820C9774h */ case    5:  		/* subf R9, R8, R9 */
		/* 820C9774h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C9774h case    5:*/		return 0x820C9778;
		  /* 820C9778h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820C9778h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C978C;  }
		/* 820C9778h case    6:*/		return 0x820C977C;
		  /* 820C977Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 820C977Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C977Ch case    7:*/		return 0x820C9780;
		  /* 820C9780h */ case    8:  		/* addi R10, R10, 1 */
		/* 820C9780h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C9780h case    8:*/		return 0x820C9784;
		  /* 820C9784h */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820C9784h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820C9784h case    9:*/		return 0x820C9788;
		  /* 820C9788h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820C9788h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C9768;  }
		/* 820C9788h case   10:*/		return 0x820C978C;
	}
	return 0x820C978C;
} // Block from 820C9760h-820C978Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C978Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C978C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C978C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C978C);
		  /* 820C978Ch */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820C978Ch case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820C978Ch case    0:*/		return 0x820C9790;
		  /* 820C9790h */ case    1:  		/* bc 12, CR0_EQ, 144 */
		/* 820C9790h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C9820;  }
		/* 820C9790h case    1:*/		return 0x820C9794;
		  /* 820C9794h */ case    2:  		/* b -116 */
		/* 820C9794h case    2:*/		return 0x820C9720;
		/* 820C9794h case    2:*/		return 0x820C9798;
	}
	return 0x820C9798;
} // Block from 820C978Ch-820C9798h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9798);
		  /* 820C9798h */ case    0:  		/* lfd FR0, <#[R3 + 8]> */
		/* 820C9798h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9798h case    0:*/		return 0x820C979C;
		  /* 820C979Ch */ case    1:  		/* lfd FR13, <#[R4 + 8]> */
		/* 820C979Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R4 + 0x00000008) );
		/* 820C979Ch case    1:*/		return 0x820C97A0;
		  /* 820C97A0h */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 820C97A0h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 820C97A0h case    2:*/		return 0x820C97A4;
		  /* 820C97A4h */ case    3:  		/* b -76 */
		/* 820C97A4h case    3:*/		return 0x820C9758;
		/* 820C97A4h case    3:*/		return 0x820C97A8;
	}
	return 0x820C97A8;
} // Block from 820C9798h-820C97A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C97A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C97A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C97A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C97A8);
		  /* 820C97A8h */ case    0:  		/* cmpwi CR6, R11, 11 */
		/* 820C97A8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000B);
		/* 820C97A8h case    0:*/		return 0x820C97AC;
		  /* 820C97ACh */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 820C97ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x820C97E8;  }
		/* 820C97ACh case    1:*/		return 0x820C97B0;
		  /* 820C97B0h */ case    2:  		/* cmpwi CR6, R11, 12 */
		/* 820C97B0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000000C);
		/* 820C97B0h case    2:*/		return 0x820C97B4;
		  /* 820C97B4h */ case    3:  		/* bc 4, CR6_EQ, 108 */
		/* 820C97B4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820C9820;  }
		/* 820C97B4h case    3:*/		return 0x820C97B8;
		  /* 820C97B8h */ case    4:  		/* lwz R10, <#[R4 + 8]> */
		/* 820C97B8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 820C97B8h case    4:*/		return 0x820C97BC;
		  /* 820C97BCh */ case    5:  		/* lwz R11, <#[R3 + 8]> */
		/* 820C97BCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C97BCh case    5:*/		return 0x820C97C0;
		  /* 820C97C0h */ case    6:  		/* lbz R9, <#[R11]> */
		/* 820C97C0h case    6:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C97C0h case    6:*/		return 0x820C97C4;
		  /* 820C97C4h */ case    7:  		/* lbz R8, <#[R10]> */
		/* 820C97C4h case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820C97C4h case    7:*/		return 0x820C97C8;
		  /* 820C97C8h */ case    8:  		/* cmpwi CR0, R9, 0 */
		/* 820C97C8h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820C97C8h case    8:*/		return 0x820C97CC;
		  /* 820C97CCh */ case    9:  		/* subf R9, R8, R9 */
		/* 820C97CCh case    9:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C97CCh case    9:*/		return 0x820C97D0;
		  /* 820C97D0h */ case   10:  		/* bc 12, CR0_EQ, -68 */
		/* 820C97D0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820C978C;  }
		/* 820C97D0h case   10:*/		return 0x820C97D4;
		  /* 820C97D4h */ case   11:  		/* addi R11, R11, 1 */
		/* 820C97D4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C97D4h case   11:*/		return 0x820C97D8;
		  /* 820C97D8h */ case   12:  		/* addi R10, R10, 1 */
		/* 820C97D8h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C97D8h case   12:*/		return 0x820C97DC;
		  /* 820C97DCh */ case   13:  		/* cmpwi CR6, R9, 0 */
		/* 820C97DCh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820C97DCh case   13:*/		return 0x820C97E0;
		  /* 820C97E0h */ case   14:  		/* bc 12, CR6_EQ, -32 */
		/* 820C97E0h case   14:*/		if ( regs.CR[6].eq ) { return 0x820C97C0;  }
		/* 820C97E0h case   14:*/		return 0x820C97E4;
		  /* 820C97E4h */ case   15:  		/* b -88 */
		/* 820C97E4h case   15:*/		return 0x820C978C;
		/* 820C97E4h case   15:*/		return 0x820C97E8;
	}
	return 0x820C97E8;
} // Block from 820C97A8h-820C97E8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C97E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C97E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C97E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C97E8);
		  /* 820C97E8h */ case    0:  		/* lwz R10, <#[R4 + 8]> */
		/* 820C97E8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 820C97E8h case    0:*/		return 0x820C97EC;
		  /* 820C97ECh */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 820C97ECh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C97ECh case    1:*/		return 0x820C97F0;
		  /* 820C97F0h */ case    2:  		/* lbz R9, <#[R11]> */
		/* 820C97F0h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820C97F0h case    2:*/		return 0x820C97F4;
		  /* 820C97F4h */ case    3:  		/* lbz R8, <#[R10]> */
		/* 820C97F4h case    3:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 820C97F4h case    3:*/		return 0x820C97F8;
		  /* 820C97F8h */ case    4:  		/* cmpwi CR0, R9, 0 */
		/* 820C97F8h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820C97F8h case    4:*/		return 0x820C97FC;
		  /* 820C97FCh */ case    5:  		/* subf R9, R8, R9 */
		/* 820C97FCh case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820C97FCh case    5:*/		return 0x820C9800;
		  /* 820C9800h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 820C9800h case    6:*/		if ( regs.CR[0].eq ) { return 0x820C9814;  }
		/* 820C9800h case    6:*/		return 0x820C9804;
		  /* 820C9804h */ case    7:  		/* addi R11, R11, 1 */
		/* 820C9804h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820C9804h case    7:*/		return 0x820C9808;
		  /* 820C9808h */ case    8:  		/* addi R10, R10, 1 */
		/* 820C9808h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820C9808h case    8:*/		return 0x820C980C;
		  /* 820C980Ch */ case    9:  		/* cmpwi CR6, R9, 0 */
		/* 820C980Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 820C980Ch case    9:*/		return 0x820C9810;
		  /* 820C9810h */ case   10:  		/* bc 12, CR6_EQ, -32 */
		/* 820C9810h case   10:*/		if ( regs.CR[6].eq ) { return 0x820C97F0;  }
		/* 820C9810h case   10:*/		return 0x820C9814;
	}
	return 0x820C9814;
} // Block from 820C97E8h-820C9814h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C9814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9814);
		  /* 820C9814h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820C9814h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820C9814h case    0:*/		return 0x820C9818;
		  /* 820C9818h */ case    1:  		/* li R3, 0 */
		/* 820C9818h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C9818h case    1:*/		return 0x820C981C;
		  /* 820C981Ch */ case    2:  		/* bclr 4, CR0_EQ */
		/* 820C981Ch case    2:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 820C981Ch case    2:*/		return 0x820C9820;
	}
	return 0x820C9820;
} // Block from 820C9814h-820C9820h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9820);
		  /* 820C9820h */ case    0:  		/* li R3, 1 */
		/* 820C9820h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820C9820h case    0:*/		return 0x820C9824;
		  /* 820C9824h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820C9824h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9824h case    1:*/		return 0x820C9828;
	}
	return 0x820C9828;
} // Block from 820C9820h-820C9828h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C9828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9828);
		  /* 820C9828h */ case    0:  		/* lis R10, -32255 */
		/* 820C9828h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C9828h case    0:*/		return 0x820C982C;
		  /* 820C982Ch */ case    1:  		/* li R11, 0 */
		/* 820C982Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C982Ch case    1:*/		return 0x820C9830;
		  /* 820C9830h */ case    2:  		/* li R9, 3 */
		/* 820C9830h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 820C9830h case    2:*/		return 0x820C9834;
		  /* 820C9834h */ case    3:  		/* addi R10, R10, 10520 */
		/* 820C9834h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2918);
		/* 820C9834h case    3:*/		return 0x820C9838;
		  /* 820C9838h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 820C9838h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9838h case    4:*/		return 0x820C983C;
		  /* 820C983Ch */ case    5:  		/* stw R9, <#[R3 + 4]> */
		/* 820C983Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C983Ch case    5:*/		return 0x820C9840;
		  /* 820C9840h */ case    6:  		/* stw R10, <#[R3]> */
		/* 820C9840h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9840h case    6:*/		return 0x820C9844;
		  /* 820C9844h */ case    7:  		/* stw R11, <#[R3 + 12]> */
		/* 820C9844h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C9844h case    7:*/		return 0x820C9848;
		  /* 820C9848h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820C9848h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9848h case    8:*/		return 0x820C984C;
	}
	return 0x820C984C;
} // Block from 820C9828h-820C984Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C984Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C984C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C984C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C984C);
		  /* 820C984Ch */ case    0:  		/* nop */
		/* 820C984Ch case    0:*/		cpu::op::nop();
		/* 820C984Ch case    0:*/		return 0x820C9850;
	}
	return 0x820C9850;
} // Block from 820C984Ch-820C9850h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9850h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9850);
		  /* 820C9850h */ case    0:  		/* lis R9, -32255 */
		/* 820C9850h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 820C9850h case    0:*/		return 0x820C9854;
		  /* 820C9854h */ case    1:  		/* li R11, 5 */
		/* 820C9854h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820C9854h case    1:*/		return 0x820C9858;
		  /* 820C9858h */ case    2:  		/* li R10, 0 */
		/* 820C9858h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820C9858h case    2:*/		return 0x820C985C;
		  /* 820C985Ch */ case    3:  		/* addi R8, R9, 10520 */
		/* 820C985Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x2918);
		/* 820C985Ch case    3:*/		return 0x820C9860;
		  /* 820C9860h */ case    4:  		/* li R7, 3 */
		/* 820C9860h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 820C9860h case    4:*/		return 0x820C9864;
		  /* 820C9864h */ case    5:  		/* stw R10, <#[R3 + 8]> */
		/* 820C9864h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9864h case    5:*/		return 0x820C9868;
		  /* 820C9868h */ case    6:  		/* stw R10, <#[R3 + 12]> */
		/* 820C9868h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C9868h case    6:*/		return 0x820C986C;
		  /* 820C986Ch */ case    7:  		/* addi R9, R3, 8 */
		/* 820C986Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 820C986Ch case    7:*/		return 0x820C9870;
		  /* 820C9870h */ case    8:  		/* stw R8, <#[R3]> */
		/* 820C9870h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9870h case    8:*/		return 0x820C9874;
		  /* 820C9874h */ case    9:  		/* addi R10, R4, -8 */
		/* 820C9874h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xFFFFFFF8);
		/* 820C9874h case    9:*/		return 0x820C9878;
	}
	return 0x820C9878;
} // Block from 820C9850h-820C9878h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C9878h
// Function '?GetConstantByName@CConstantTable@D3DXShader@@UAAIIPBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9878);
		  /* 820C9878h */ case    0:  		/* stw R7, <#[R3 + 4]> */
		/* 820C9878h case    0:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9878h case    0:*/		return 0x820C987C;
		  /* 820C987Ch */ case    1:  		/* mtspr CTR, R11 */
		/* 820C987Ch case    1:*/		regs.CTR = regs.R11;
		/* 820C987Ch case    1:*/		return 0x820C9880;
		  /* 820C9880h */ case    2:  		/* ldu R11, <#[R10 + 8]> */
		/* 820C9880h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820C9880h case    2:*/		return 0x820C9884;
		  /* 820C9884h */ case    3:  		/* stdu R11, <#[R9 + 8]> */
		/* 820C9884h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820C9884h case    3:*/		return 0x820C9888;
		  /* 820C9888h */ case    4:  		/* bc 16, CR0_LT, -8 */
		/* 820C9888h case    4:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C9880;  }
		/* 820C9888h case    4:*/		return 0x820C988C;
		  /* 820C988Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C988Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C988Ch case    5:*/		return 0x820C9890;
	}
	return 0x820C9890;
} // Block from 820C9878h-820C9890h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C9890h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9890);
		  /* 820C9890h */ case    0:  		/* mfspr R12, LR */
		/* 820C9890h case    0:*/		regs.R12 = regs.LR;
		/* 820C9890h case    0:*/		return 0x820C9894;
		  /* 820C9894h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C9894h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9894h case    1:*/		return 0x820C9898;
		  /* 820C9898h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C9898h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C9898h case    2:*/		return 0x820C989C;
		  /* 820C989Ch */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 820C989Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C989Ch case    3:*/		return 0x820C98A0;
		  /* 820C98A0h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 820C98A0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C98B4;  }
		/* 820C98A0h case    4:*/		return 0x820C98A4;
		  /* 820C98A4h */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 820C98A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C98A4h case    5:*/		return 0x820C98A8;
		  /* 820C98A8h */ case    6:  		/* lwz R10, <#[R3 + 4]> */
		/* 820C98A8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820C98A8h case    6:*/		return 0x820C98AC;
		  /* 820C98ACh */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 820C98ACh case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820C98ACh case    7:*/		return 0x820C98B0;
		  /* 820C98B0h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 820C98B0h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C98BC;  }
		/* 820C98B0h case    8:*/		return 0x820C98B4;
	}
	return 0x820C98B4;
} // Block from 820C9890h-820C98B4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C98B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C98B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C98B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C98B4);
		  /* 820C98B4h */ case    0:  		/* li R3, 0 */
		/* 820C98B4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C98B4h case    0:*/		return 0x820C98B8;
		  /* 820C98B8h */ case    1:  		/* b 24 */
		/* 820C98B8h case    1:*/		return 0x820C98D0;
		/* 820C98B8h case    1:*/		return 0x820C98BC;
	}
	return 0x820C98BC;
} // Block from 820C98B4h-820C98BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C98BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C98BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C98BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C98BC);
		  /* 820C98BCh */ case    0:  		/* addi R4, R4, 16 */
		/* 820C98BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x10);
		/* 820C98BCh case    0:*/		return 0x820C98C0;
		  /* 820C98C0h */ case    1:  		/* addi R3, R3, 16 */
		/* 820C98C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x10);
		/* 820C98C0h case    1:*/		return 0x820C98C4;
		  /* 820C98C4h */ case    2:  		/* bl -436 */
		/* 820C98C4h case    2:*/		regs.LR = 0x820C98C8; return 0x820C9710;
		/* 820C98C4h case    2:*/		return 0x820C98C8;
		  /* 820C98C8h */ case    3:  		/* addic R11, R3, -1 */
		/* 820C98C8h case    3:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 820C98C8h case    3:*/		return 0x820C98CC;
		  /* 820C98CCh */ case    4:  		/* subfe R3, R11, R3 */
		/* 820C98CCh case    4:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C98CCh case    4:*/		return 0x820C98D0;
	}
	return 0x820C98D0;
} // Block from 820C98BCh-820C98D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C98D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C98D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C98D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C98D0);
		  /* 820C98D0h */ case    0:  		/* addi R1, R1, 96 */
		/* 820C98D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C98D0h case    0:*/		return 0x820C98D4;
		  /* 820C98D4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C98D4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C98D4h case    1:*/		return 0x820C98D8;
		  /* 820C98D8h */ case    2:  		/* mtspr LR, R12 */
		/* 820C98D8h case    2:*/		regs.LR = regs.R12;
		/* 820C98D8h case    2:*/		return 0x820C98DC;
		  /* 820C98DCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 820C98DCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C98DCh case    3:*/		return 0x820C98E0;
	}
	return 0x820C98E0;
} // Block from 820C98D0h-820C98E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C98E0h
// Function '??0CFile@D3DXCore@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C98E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C98E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C98E0);
		  /* 820C98E0h */ case    0:  		/* mfspr R12, LR */
		/* 820C98E0h case    0:*/		regs.R12 = regs.LR;
		/* 820C98E0h case    0:*/		return 0x820C98E4;
		  /* 820C98E4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C98E4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C98E4h case    1:*/		return 0x820C98E8;
		  /* 820C98E8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820C98E8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C98E8h case    2:*/		return 0x820C98EC;
		  /* 820C98ECh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C98ECh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C98ECh case    3:*/		return 0x820C98F0;
		  /* 820C98F0h */ case    4:  		/* mr R31, R3 */
		/* 820C98F0h case    4:*/		regs.R31 = regs.R3;
		/* 820C98F0h case    4:*/		return 0x820C98F4;
		  /* 820C98F4h */ case    5:  		/* bl 14140 */
		/* 820C98F4h case    5:*/		regs.LR = 0x820C98F8; return 0x820CD030;
		/* 820C98F4h case    5:*/		return 0x820C98F8;
	}
	return 0x820C98F8;
} // Block from 820C98E0h-820C98F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C98F8h
// Function '?Open@CFile@D3DXCore@@QAAJPBXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C98F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C98F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C98F8);
		  /* 820C98F8h */ case    0:  		/* li R5, 16 */
		/* 820C98F8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820C98F8h case    0:*/		return 0x820C98FC;
		  /* 820C98FCh */ case    1:  		/* lwz R3, <#[R3]> */
		/* 820C98FCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820C98FCh case    1:*/		return 0x820C9900;
		  /* 820C9900h */ case    2:  		/* li R4, 56 */
		/* 820C9900h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 820C9900h case    2:*/		return 0x820C9904;
		  /* 820C9904h */ case    3:  		/* bl -2084 */
		/* 820C9904h case    3:*/		regs.LR = 0x820C9908; return 0x820C90E0;
		/* 820C9904h case    3:*/		return 0x820C9908;
		  /* 820C9908h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 820C9908h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C9908h case    4:*/		return 0x820C990C;
		  /* 820C990Ch */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 820C990Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x820C9934;  }
		/* 820C990Ch case    5:*/		return 0x820C9910;
		  /* 820C9910h */ case    6:  		/* lis R10, -32255 */
		/* 820C9910h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C9910h case    6:*/		return 0x820C9914;
		  /* 820C9914h */ case    7:  		/* li R11, 0 */
		/* 820C9914h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C9914h case    7:*/		return 0x820C9918;
		  /* 820C9918h */ case    8:  		/* li R9, 3 */
		/* 820C9918h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 820C9918h case    8:*/		return 0x820C991C;
		  /* 820C991Ch */ case    9:  		/* addi R10, R10, 10520 */
		/* 820C991Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2918);
		/* 820C991Ch case    9:*/		return 0x820C9920;
		  /* 820C9920h */ case   10:  		/* stw R11, <#[R3 + 8]> */
		/* 820C9920h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9920h case   10:*/		return 0x820C9924;
		  /* 820C9924h */ case   11:  		/* stw R9, <#[R3 + 4]> */
		/* 820C9924h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9924h case   11:*/		return 0x820C9928;
		  /* 820C9928h */ case   12:  		/* stw R10, <#[R3]> */
		/* 820C9928h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9928h case   12:*/		return 0x820C992C;
		  /* 820C992Ch */ case   13:  		/* stw R11, <#[R3 + 12]> */
		/* 820C992Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C992Ch case   13:*/		return 0x820C9930;
		  /* 820C9930h */ case   14:  		/* b 8 */
		/* 820C9930h case   14:*/		return 0x820C9938;
		/* 820C9930h case   14:*/		return 0x820C9934;
	}
	return 0x820C9934;
} // Block from 820C98F8h-820C9934h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C9934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9934);
		  /* 820C9934h */ case    0:  		/* li R3, 0 */
		/* 820C9934h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C9934h case    0:*/		return 0x820C9938;
	}
	return 0x820C9938;
} // Block from 820C9934h-820C9938h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9938);
		  /* 820C9938h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820C9938h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C9938h case    0:*/		return 0x820C993C;
		  /* 820C993Ch */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 820C993Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x820C995C;  }
		/* 820C993Ch case    1:*/		return 0x820C9940;
		  /* 820C9940h */ case    2:  		/* li R11, 5 */
		/* 820C9940h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5);
		/* 820C9940h case    2:*/		return 0x820C9944;
		  /* 820C9944h */ case    3:  		/* addi R10, R31, 8 */
		/* 820C9944h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x8);
		/* 820C9944h case    3:*/		return 0x820C9948;
		  /* 820C9948h */ case    4:  		/* addi R9, R3, 8 */
		/* 820C9948h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 820C9948h case    4:*/		return 0x820C994C;
		  /* 820C994Ch */ case    5:  		/* mtspr CTR, R11 */
		/* 820C994Ch case    5:*/		regs.CTR = regs.R11;
		/* 820C994Ch case    5:*/		return 0x820C9950;
		  /* 820C9950h */ case    6:  		/* ldu R11, <#[R10 + 8]> */
		/* 820C9950h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 820C9950h case    6:*/		return 0x820C9954;
		  /* 820C9954h */ case    7:  		/* stdu R11, <#[R9 + 8]> */
		/* 820C9954h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		regs.R9 = (uint32)(regs.R9 + 0x00000008);
		/* 820C9954h case    7:*/		return 0x820C9958;
		  /* 820C9958h */ case    8:  		/* bc 16, CR0_LT, -8 */
		/* 820C9958h case    8:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820C9950;  }
		/* 820C9958h case    8:*/		return 0x820C995C;
	}
	return 0x820C995C;
} // Block from 820C9938h-820C995Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C995Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C995C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C995C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C995C);
		  /* 820C995Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 820C995Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C995Ch case    0:*/		return 0x820C9960;
		  /* 820C9960h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C9960h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9960h case    1:*/		return 0x820C9964;
		  /* 820C9964h */ case    2:  		/* mtspr LR, R12 */
		/* 820C9964h case    2:*/		regs.LR = regs.R12;
		/* 820C9964h case    2:*/		return 0x820C9968;
		  /* 820C9968h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 820C9968h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9968h case    3:*/		return 0x820C996C;
		  /* 820C996Ch */ case    4:  		/* bclr 20, CR0_LT */
		/* 820C996Ch case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C996Ch case    4:*/		return 0x820C9970;
	}
	return 0x820C9970;
} // Block from 820C995Ch-820C9970h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820C9970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9970);
		  /* 820C9970h */ case    0:  		/* lis R10, -32255 */
		/* 820C9970h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C9970h case    0:*/		return 0x820C9974;
		  /* 820C9974h */ case    1:  		/* li R11, 0 */
		/* 820C9974h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C9974h case    1:*/		return 0x820C9978;
		  /* 820C9978h */ case    2:  		/* li R9, 4 */
		/* 820C9978h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820C9978h case    2:*/		return 0x820C997C;
		  /* 820C997Ch */ case    3:  		/* addi R10, R10, 10532 */
		/* 820C997Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2924);
		/* 820C997Ch case    3:*/		return 0x820C9980;
		  /* 820C9980h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 820C9980h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9980h case    4:*/		return 0x820C9984;
		  /* 820C9984h */ case    5:  		/* stw R9, <#[R3 + 4]> */
		/* 820C9984h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9984h case    5:*/		return 0x820C9988;
		  /* 820C9988h */ case    6:  		/* stw R10, <#[R3]> */
		/* 820C9988h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9988h case    6:*/		return 0x820C998C;
		  /* 820C998Ch */ case    7:  		/* stw R11, <#[R3 + 12]> */
		/* 820C998Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C998Ch case    7:*/		return 0x820C9990;
		  /* 820C9990h */ case    8:  		/* stw R11, <#[R3 + 16]> */
		/* 820C9990h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9990h case    8:*/		return 0x820C9994;
		  /* 820C9994h */ case    9:  		/* stw R11, <#[R3 + 20]> */
		/* 820C9994h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9994h case    9:*/		return 0x820C9998;
		  /* 820C9998h */ case   10:  		/* stw R11, <#[R3 + 24]> */
		/* 820C9998h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C9998h case   10:*/		return 0x820C999C;
		  /* 820C999Ch */ case   11:  		/* stw R11, <#[R3 + 28]> */
		/* 820C999Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820C999Ch case   11:*/		return 0x820C99A0;
		  /* 820C99A0h */ case   12:  		/* stw R11, <#[R3 + 36]> */
		/* 820C99A0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820C99A0h case   12:*/		return 0x820C99A4;
		  /* 820C99A4h */ case   13:  		/* stw R11, <#[R3 + 32]> */
		/* 820C99A4h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820C99A4h case   13:*/		return 0x820C99A8;
		  /* 820C99A8h */ case   14:  		/* stw R11, <#[R3 + 40]> */
		/* 820C99A8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820C99A8h case   14:*/		return 0x820C99AC;
		  /* 820C99ACh */ case   15:  		/* bclr 20, CR0_LT */
		/* 820C99ACh case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C99ACh case   15:*/		return 0x820C99B0;
	}
	return 0x820C99B0;
} // Block from 820C9970h-820C99B0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C99B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C99B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C99B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C99B0);
		  /* 820C99B0h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 820C99B0h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C99B0h case    0:*/		return 0x820C99B4;
		  /* 820C99B4h */ case    1:  		/* lis R31, -32255 */
		/* 820C99B4h case    1:*/		cpu::op::lis<0>(regs,&regs.R31,0xFFFF8201);
		/* 820C99B4h case    1:*/		return 0x820C99B8;
		  /* 820C99B8h */ case    2:  		/* stw R5, <#[R3 + 20]> */
		/* 820C99B8h case    2:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820C99B8h case    2:*/		return 0x820C99BC;
		  /* 820C99BCh */ case    3:  		/* stw R6, <#[R3 + 24]> */
		/* 820C99BCh case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000018) );
		/* 820C99BCh case    3:*/		return 0x820C99C0;
		  /* 820C99C0h */ case    4:  		/* li R11, 0 */
		/* 820C99C0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C99C0h case    4:*/		return 0x820C99C4;
		  /* 820C99C4h */ case    5:  		/* li R5, 4 */
		/* 820C99C4h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 820C99C4h case    5:*/		return 0x820C99C8;
		  /* 820C99C8h */ case    6:  		/* stw R4, <#[R3 + 16]> */
		/* 820C99C8h case    6:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820C99C8h case    6:*/		return 0x820C99CC;
		  /* 820C99CCh */ case    7:  		/* addi R6, R31, 10532 */
		/* 820C99CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R31,0x2924);
		/* 820C99CCh case    7:*/		return 0x820C99D0;
		  /* 820C99D0h */ case    8:  		/* stw R11, <#[R3 + 8]> */
		/* 820C99D0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C99D0h case    8:*/		return 0x820C99D4;
		  /* 820C99D4h */ case    9:  		/* stw R5, <#[R3 + 4]> */
		/* 820C99D4h case    9:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		/* 820C99D4h case    9:*/		return 0x820C99D8;
		  /* 820C99D8h */ case   10:  		/* stw R6, <#[R3]> */
		/* 820C99D8h case   10:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000000) );
		/* 820C99D8h case   10:*/		return 0x820C99DC;
		  /* 820C99DCh */ case   11:  		/* stw R11, <#[R3 + 12]> */
		/* 820C99DCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C99DCh case   11:*/		return 0x820C99E0;
		  /* 820C99E0h */ case   12:  		/* stw R7, <#[R3 + 28]> */
		/* 820C99E0h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x0000001C) );
		/* 820C99E0h case   12:*/		return 0x820C99E4;
		  /* 820C99E4h */ case   13:  		/* stw R8, <#[R3 + 36]> */
		/* 820C99E4h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000024) );
		/* 820C99E4h case   13:*/		return 0x820C99E8;
		  /* 820C99E8h */ case   14:  		/* stw R9, <#[R3 + 32]> */
		/* 820C99E8h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000020) );
		/* 820C99E8h case   14:*/		return 0x820C99EC;
		  /* 820C99ECh */ case   15:  		/* stw R10, <#[R3 + 40]> */
		/* 820C99ECh case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000028) );
		/* 820C99ECh case   15:*/		return 0x820C99F0;
	}
	return 0x820C99F0;
} // Block from 820C99B0h-820C99F0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C99F0h
// Function '?Close@CFile@D3DXCore@@QAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C99F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C99F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C99F0);
		  /* 820C99F0h */ case    0:  		/* ld R31, <#[R1 - 8]> */
		/* 820C99F0h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C99F0h case    0:*/		return 0x820C99F4;
		  /* 820C99F4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820C99F4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C99F4h case    1:*/		return 0x820C99F8;
	}
	return 0x820C99F8;
} // Block from 820C99F0h-820C99F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C99F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C99F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C99F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C99F8);
		  /* 820C99F8h */ case    0:  		/* mfspr R12, LR */
		/* 820C99F8h case    0:*/		regs.R12 = regs.LR;
		/* 820C99F8h case    0:*/		return 0x820C99FC;
		  /* 820C99FCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C99FCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C99FCh case    1:*/		return 0x820C9A00;
		  /* 820C9A00h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820C9A00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820C9A00h case    2:*/		return 0x820C9A04;
		  /* 820C9A04h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 820C9A04h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C9A04h case    3:*/		return 0x820C9A08;
		  /* 820C9A08h */ case    4:  		/* bc 12, CR6_EQ, 176 */
		/* 820C9A08h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C9AB8;  }
		/* 820C9A08h case    4:*/		return 0x820C9A0C;
		  /* 820C9A0Ch */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 820C9A0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C9A0Ch case    5:*/		return 0x820C9A10;
		  /* 820C9A10h */ case    6:  		/* lwz R10, <#[R3 + 4]> */
		/* 820C9A10h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9A10h case    6:*/		return 0x820C9A14;
		  /* 820C9A14h */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 820C9A14h case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820C9A14h case    7:*/		return 0x820C9A18;
		  /* 820C9A18h */ case    8:  		/* bc 4, CR6_EQ, 160 */
		/* 820C9A18h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820C9AB8;  }
		/* 820C9A18h case    8:*/		return 0x820C9A1C;
		  /* 820C9A1Ch */ case    9:  		/* lwz R11, <#[R3 + 16]> */
		/* 820C9A1Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9A1Ch case    9:*/		return 0x820C9A20;
		  /* 820C9A20h */ case   10:  		/* lwz R10, <#[R4 + 16]> */
		/* 820C9A20h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 820C9A20h case   10:*/		return 0x820C9A24;
		  /* 820C9A24h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820C9A24h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C9A24h case   11:*/		return 0x820C9A28;
		  /* 820C9A28h */ case   12:  		/* bc 4, CR6_EQ, 144 */
		/* 820C9A28h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820C9AB8;  }
		/* 820C9A28h case   12:*/		return 0x820C9A2C;
		  /* 820C9A2Ch */ case   13:  		/* lwz R11, <#[R3 + 20]> */
		/* 820C9A2Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9A2Ch case   13:*/		return 0x820C9A30;
		  /* 820C9A30h */ case   14:  		/* lwz R10, <#[R4 + 20]> */
		/* 820C9A30h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 820C9A30h case   14:*/		return 0x820C9A34;
		  /* 820C9A34h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820C9A34h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C9A34h case   15:*/		return 0x820C9A38;
		  /* 820C9A38h */ case   16:  		/* bc 4, CR6_EQ, 128 */
		/* 820C9A38h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820C9AB8;  }
		/* 820C9A38h case   16:*/		return 0x820C9A3C;
		  /* 820C9A3Ch */ case   17:  		/* lwz R11, <#[R3 + 24]> */
		/* 820C9A3Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C9A3Ch case   17:*/		return 0x820C9A40;
		  /* 820C9A40h */ case   18:  		/* lwz R10, <#[R4 + 24]> */
		/* 820C9A40h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 820C9A40h case   18:*/		return 0x820C9A44;
		  /* 820C9A44h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 820C9A44h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C9A44h case   19:*/		return 0x820C9A48;
		  /* 820C9A48h */ case   20:  		/* bc 4, CR6_EQ, 112 */
		/* 820C9A48h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820C9AB8;  }
		/* 820C9A48h case   20:*/		return 0x820C9A4C;
		  /* 820C9A4Ch */ case   21:  		/* lwz R11, <#[R3 + 28]> */
		/* 820C9A4Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820C9A4Ch case   21:*/		return 0x820C9A50;
		  /* 820C9A50h */ case   22:  		/* lwz R10, <#[R4 + 28]> */
		/* 820C9A50h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001C) );
		/* 820C9A50h case   22:*/		return 0x820C9A54;
		  /* 820C9A54h */ case   23:  		/* cmplw CR6, R11, R10 */
		/* 820C9A54h case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C9A54h case   23:*/		return 0x820C9A58;
	}
	return 0x820C9A58;
} // Block from 820C99F8h-820C9A58h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820C9A58h
// Function '??1CFile@D3DXCore@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9A58);
		  /* 820C9A58h */ case    0:  		/* bc 4, CR6_EQ, 96 */
		/* 820C9A58h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820C9AB8;  }
		/* 820C9A58h case    0:*/		return 0x820C9A5C;
		  /* 820C9A5Ch */ case    1:  		/* lwz R11, <#[R3 + 36]> */
		/* 820C9A5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820C9A5Ch case    1:*/		return 0x820C9A60;
		  /* 820C9A60h */ case    2:  		/* lwz R10, <#[R4 + 36]> */
		/* 820C9A60h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000024) );
		/* 820C9A60h case    2:*/		return 0x820C9A64;
		  /* 820C9A64h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C9A64h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C9A64h case    3:*/		return 0x820C9A68;
		  /* 820C9A68h */ case    4:  		/* bc 4, CR6_EQ, 80 */
		/* 820C9A68h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C9AB8;  }
		/* 820C9A68h case    4:*/		return 0x820C9A6C;
		  /* 820C9A6Ch */ case    5:  		/* lwz R11, <#[R3 + 32]> */
		/* 820C9A6Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820C9A6Ch case    5:*/		return 0x820C9A70;
	}
	return 0x820C9A70;
} // Block from 820C9A58h-820C9A70h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C9A70h
// Function '??0CAlloc@D3DXCore@@QAA@II@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9A70);
		  /* 820C9A70h */ case    0:  		/* lwz R10, <#[R4 + 32]> */
		/* 820C9A70h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000020) );
		/* 820C9A70h case    0:*/		return 0x820C9A74;
		  /* 820C9A74h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820C9A74h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C9A74h case    1:*/		return 0x820C9A78;
		  /* 820C9A78h */ case    2:  		/* bc 4, CR6_EQ, 64 */
		/* 820C9A78h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C9AB8;  }
		/* 820C9A78h case    2:*/		return 0x820C9A7C;
		  /* 820C9A7Ch */ case    3:  		/* lwz R3, <#[R3 + 40]> */
		/* 820C9A7Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000028) );
		/* 820C9A7Ch case    3:*/		return 0x820C9A80;
		  /* 820C9A80h */ case    4:  		/* lwz R4, <#[R4 + 40]> */
		/* 820C9A80h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000028) );
		/* 820C9A80h case    4:*/		return 0x820C9A84;
		  /* 820C9A84h */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 820C9A84h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C9A84h case    5:*/		return 0x820C9A88;
		  /* 820C9A88h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 820C9A88h case    6:*/		if ( regs.CR[6].eq ) { return 0x820C9AA0;  }
		/* 820C9A88h case    6:*/		return 0x820C9A8C;
		  /* 820C9A8Ch */ case    7:  		/* lwz R11, <#[R3]> */
		/* 820C9A8Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9A8Ch case    7:*/		return 0x820C9A90;
		  /* 820C9A90h */ case    8:  		/* lwz R11, <#[R11]> */
		/* 820C9A90h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C9A90h case    8:*/		return 0x820C9A94;
		  /* 820C9A94h */ case    9:  		/* mtspr CTR, R11 */
		/* 820C9A94h case    9:*/		regs.CTR = regs.R11;
		/* 820C9A94h case    9:*/		return 0x820C9A98;
		  /* 820C9A98h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820C9A98h case   10:*/		if ( 1 ) { regs.LR = 0x820C9A9C; return (uint32)regs.CTR; }
		/* 820C9A98h case   10:*/		return 0x820C9A9C;
		  /* 820C9A9Ch */ case   11:  		/* b 16 */
		/* 820C9A9Ch case   11:*/		return 0x820C9AAC;
		/* 820C9A9Ch case   11:*/		return 0x820C9AA0;
	}
	return 0x820C9AA0;
} // Block from 820C9A70h-820C9AA0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C9AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9AA0);
		  /* 820C9AA0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820C9AA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820C9AA0h case    0:*/		return 0x820C9AA4;
		  /* 820C9AA4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820C9AA4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C9AA4h case    1:*/		return 0x820C9AA8;
		  /* 820C9AA8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820C9AA8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820C9AA8h case    2:*/		return 0x820C9AAC;
	}
	return 0x820C9AAC;
} // Block from 820C9AA0h-820C9AACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9AAC);
		  /* 820C9AACh */ case    0:  		/* addic R11, R3, -1 */
		/* 820C9AACh case    0:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 820C9AACh case    0:*/		return 0x820C9AB0;
		  /* 820C9AB0h */ case    1:  		/* subfe R3, R11, R3 */
		/* 820C9AB0h case    1:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820C9AB0h case    1:*/		return 0x820C9AB4;
		  /* 820C9AB4h */ case    2:  		/* b 8 */
		/* 820C9AB4h case    2:*/		return 0x820C9ABC;
		/* 820C9AB4h case    2:*/		return 0x820C9AB8;
	}
	return 0x820C9AB8;
} // Block from 820C9AACh-820C9AB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9AB8h
// Function '??1CAlloc@D3DXCore@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9AB8);
		  /* 820C9AB8h */ case    0:  		/* li R3, 0 */
		/* 820C9AB8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C9AB8h case    0:*/		return 0x820C9ABC;
	}
	return 0x820C9ABC;
} // Block from 820C9AB8h-820C9ABCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9ABC);
		  /* 820C9ABCh */ case    0:  		/* addi R1, R1, 96 */
		/* 820C9ABCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820C9ABCh case    0:*/		return 0x820C9AC0;
		  /* 820C9AC0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C9AC0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9AC0h case    1:*/		return 0x820C9AC4;
		  /* 820C9AC4h */ case    2:  		/* mtspr LR, R12 */
		/* 820C9AC4h case    2:*/		regs.LR = regs.R12;
		/* 820C9AC4h case    2:*/		return 0x820C9AC8;
		  /* 820C9AC8h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820C9AC8h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9AC8h case    3:*/		return 0x820C9ACC;
	}
	return 0x820C9ACC;
} // Block from 820C9ABCh-820C9ACCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C9ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9ACC);
		  /* 820C9ACCh */ case    0:  		/* nop */
		/* 820C9ACCh case    0:*/		cpu::op::nop();
		/* 820C9ACCh case    0:*/		return 0x820C9AD0;
	}
	return 0x820C9AD0;
} // Block from 820C9ACCh-820C9AD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9AD0);
		  /* 820C9AD0h */ case    0:  		/* mfspr R12, LR */
		/* 820C9AD0h case    0:*/		regs.R12 = regs.LR;
		/* 820C9AD0h case    0:*/		return 0x820C9AD4;
		  /* 820C9AD4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C9AD4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9AD4h case    1:*/		return 0x820C9AD8;
		  /* 820C9AD8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C9AD8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C9AD8h case    2:*/		return 0x820C9ADC;
		  /* 820C9ADCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C9ADCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9ADCh case    3:*/		return 0x820C9AE0;
		  /* 820C9AE0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C9AE0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C9AE0h case    4:*/		return 0x820C9AE4;
		  /* 820C9AE4h */ case    5:  		/* mr R30, R3 */
		/* 820C9AE4h case    5:*/		regs.R30 = regs.R3;
		/* 820C9AE4h case    5:*/		return 0x820C9AE8;
		  /* 820C9AE8h */ case    6:  		/* bl 13640 */
		/* 820C9AE8h case    6:*/		regs.LR = 0x820C9AEC; return 0x820CD030;
		/* 820C9AE8h case    6:*/		return 0x820C9AEC;
		  /* 820C9AECh */ case    7:  		/* li R5, 16 */
		/* 820C9AECh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820C9AECh case    7:*/		return 0x820C9AF0;
		  /* 820C9AF0h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820C9AF0h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9AF0h case    8:*/		return 0x820C9AF4;
		  /* 820C9AF4h */ case    9:  		/* li R4, 44 */
		/* 820C9AF4h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x2C);
		/* 820C9AF4h case    9:*/		return 0x820C9AF8;
		  /* 820C9AF8h */ case   10:  		/* bl -2584 */
		/* 820C9AF8h case   10:*/		regs.LR = 0x820C9AFC; return 0x820C90E0;
		/* 820C9AF8h case   10:*/		return 0x820C9AFC;
		  /* 820C9AFCh */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820C9AFCh case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C9AFCh case   11:*/		return 0x820C9B00;
		  /* 820C9B00h */ case   12:  		/* bc 12, CR0_EQ, 72 */
		/* 820C9B00h case   12:*/		if ( regs.CR[0].eq ) { return 0x820C9B48;  }
		/* 820C9B00h case   12:*/		return 0x820C9B04;
		  /* 820C9B04h */ case   13:  		/* lis R10, -32255 */
		/* 820C9B04h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C9B04h case   13:*/		return 0x820C9B08;
	}
	return 0x820C9B08;
} // Block from 820C9AD0h-820C9B08h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C9B08h
// Function '?Alloc@CAlloc@D3DXCore@@QAAPAEKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9B08);
		  /* 820C9B08h */ case    0:  		/* li R11, 0 */
		/* 820C9B08h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C9B08h case    0:*/		return 0x820C9B0C;
		  /* 820C9B0Ch */ case    1:  		/* li R9, 4 */
		/* 820C9B0Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820C9B0Ch case    1:*/		return 0x820C9B10;
		  /* 820C9B10h */ case    2:  		/* addi R10, R10, 10532 */
		/* 820C9B10h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2924);
		/* 820C9B10h case    2:*/		return 0x820C9B14;
		  /* 820C9B14h */ case    3:  		/* stw R11, <#[R3 + 8]> */
		/* 820C9B14h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9B14h case    3:*/		return 0x820C9B18;
		  /* 820C9B18h */ case    4:  		/* stw R9, <#[R3 + 4]> */
		/* 820C9B18h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9B18h case    4:*/		return 0x820C9B1C;
		  /* 820C9B1Ch */ case    5:  		/* mr R31, R3 */
		/* 820C9B1Ch case    5:*/		regs.R31 = regs.R3;
		/* 820C9B1Ch case    5:*/		return 0x820C9B20;
		  /* 820C9B20h */ case    6:  		/* stw R10, <#[R3]> */
		/* 820C9B20h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9B20h case    6:*/		return 0x820C9B24;
		  /* 820C9B24h */ case    7:  		/* stw R11, <#[R3 + 12]> */
		/* 820C9B24h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C9B24h case    7:*/		return 0x820C9B28;
		  /* 820C9B28h */ case    8:  		/* stw R11, <#[R3 + 16]> */
		/* 820C9B28h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9B28h case    8:*/		return 0x820C9B2C;
		  /* 820C9B2Ch */ case    9:  		/* stw R11, <#[R3 + 20]> */
		/* 820C9B2Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9B2Ch case    9:*/		return 0x820C9B30;
		  /* 820C9B30h */ case   10:  		/* stw R11, <#[R3 + 24]> */
		/* 820C9B30h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C9B30h case   10:*/		return 0x820C9B34;
		  /* 820C9B34h */ case   11:  		/* stw R11, <#[R3 + 28]> */
		/* 820C9B34h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820C9B34h case   11:*/		return 0x820C9B38;
		  /* 820C9B38h */ case   12:  		/* stw R11, <#[R3 + 36]> */
		/* 820C9B38h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820C9B38h case   12:*/		return 0x820C9B3C;
		  /* 820C9B3Ch */ case   13:  		/* stw R11, <#[R3 + 32]> */
		/* 820C9B3Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820C9B3Ch case   13:*/		return 0x820C9B40;
		  /* 820C9B40h */ case   14:  		/* stw R11, <#[R3 + 40]> */
		/* 820C9B40h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820C9B40h case   14:*/		return 0x820C9B44;
		  /* 820C9B44h */ case   15:  		/* b 8 */
		/* 820C9B44h case   15:*/		return 0x820C9B4C;
		/* 820C9B44h case   15:*/		return 0x820C9B48;
	}
	return 0x820C9B48;
} // Block from 820C9B08h-820C9B48h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C9B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9B48);
		  /* 820C9B48h */ case    0:  		/* li R31, 0 */
		/* 820C9B48h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C9B48h case    0:*/		return 0x820C9B4C;
	}
	return 0x820C9B4C;
} // Block from 820C9B48h-820C9B4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9B4C);
		  /* 820C9B4Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820C9B4Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C9B4Ch case    0:*/		return 0x820C9B50;
		  /* 820C9B50h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820C9B50h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C9B5C;  }
		/* 820C9B50h case    1:*/		return 0x820C9B54;
		  /* 820C9B54h */ case    2:  		/* li R3, 0 */
		/* 820C9B54h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C9B54h case    2:*/		return 0x820C9B58;
		  /* 820C9B58h */ case    3:  		/* b 104 */
		/* 820C9B58h case    3:*/		return 0x820C9BC0;
		/* 820C9B58h case    3:*/		return 0x820C9B5C;
	}
	return 0x820C9B5C;
} // Block from 820C9B4Ch-820C9B5Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C9B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9B5C);
		  /* 820C9B5Ch */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C9B5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C9B5Ch case    0:*/		return 0x820C9B60;
		  /* 820C9B60h */ case    1:  		/* stw R11, <#[R31 + 16]> */
		/* 820C9B60h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820C9B60h case    1:*/		return 0x820C9B64;
		  /* 820C9B64h */ case    2:  		/* lwz R11, <#[R30 + 20]> */
		/* 820C9B64h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C9B64h case    2:*/		return 0x820C9B68;
		  /* 820C9B68h */ case    3:  		/* stw R11, <#[R31 + 20]> */
		/* 820C9B68h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820C9B68h case    3:*/		return 0x820C9B6C;
		  /* 820C9B6Ch */ case    4:  		/* lwz R11, <#[R30 + 24]> */
		/* 820C9B6Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820C9B6Ch case    4:*/		return 0x820C9B70;
		  /* 820C9B70h */ case    5:  		/* stw R11, <#[R31 + 24]> */
		/* 820C9B70h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820C9B70h case    5:*/		return 0x820C9B74;
		  /* 820C9B74h */ case    6:  		/* lwz R11, <#[R30 + 28]> */
		/* 820C9B74h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820C9B74h case    6:*/		return 0x820C9B78;
		  /* 820C9B78h */ case    7:  		/* stw R11, <#[R31 + 28]> */
		/* 820C9B78h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820C9B78h case    7:*/		return 0x820C9B7C;
		  /* 820C9B7Ch */ case    8:  		/* lwz R11, <#[R30 + 36]> */
		/* 820C9B7Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820C9B7Ch case    8:*/		return 0x820C9B80;
		  /* 820C9B80h */ case    9:  		/* stw R11, <#[R31 + 36]> */
		/* 820C9B80h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820C9B80h case    9:*/		return 0x820C9B84;
		  /* 820C9B84h */ case   10:  		/* lwz R11, <#[R30 + 32]> */
		/* 820C9B84h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 820C9B84h case   10:*/		return 0x820C9B88;
		  /* 820C9B88h */ case   11:  		/* stw R11, <#[R31 + 32]> */
		/* 820C9B88h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820C9B88h case   11:*/		return 0x820C9B8C;
		  /* 820C9B8Ch */ case   12:  		/* lwz R11, <#[R30 + 40]> */
		/* 820C9B8Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 820C9B8Ch case   12:*/		return 0x820C9B90;
		  /* 820C9B90h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 820C9B90h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C9B90h case   13:*/		return 0x820C9B94;
		  /* 820C9B94h */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 820C9B94h case   14:*/		if ( regs.CR[6].eq ) { return 0x820C9BBC;  }
		/* 820C9B94h case   14:*/		return 0x820C9B98;
		  /* 820C9B98h */ case   15:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820C9B98h case   15:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820C9B98h case   15:*/		return 0x820C9B9C;
		  /* 820C9B9Ch */ case   16:  		/* lwz R11, <#[R3]> */
		/* 820C9B9Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9B9Ch case   16:*/		return 0x820C9BA0;
		  /* 820C9BA0h */ case   17:  		/* lwz R11, <#[R11 + 4]> */
		/* 820C9BA0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820C9BA0h case   17:*/		return 0x820C9BA4;
		  /* 820C9BA4h */ case   18:  		/* mtspr CTR, R11 */
		/* 820C9BA4h case   18:*/		regs.CTR = regs.R11;
		/* 820C9BA4h case   18:*/		return 0x820C9BA8;
		  /* 820C9BA8h */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 820C9BA8h case   19:*/		if ( 1 ) { regs.LR = 0x820C9BAC; return (uint32)regs.CTR; }
		/* 820C9BA8h case   19:*/		return 0x820C9BAC;
		  /* 820C9BACh */ case   20:  		/* stw R3, <#[R31 + 40]> */
		/* 820C9BACh case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000028) );
		/* 820C9BACh case   20:*/		return 0x820C9BB0;
		  /* 820C9BB0h */ case   21:  		/* cmplwi CR0, R3, 0 */
		/* 820C9BB0h case   21:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C9BB0h case   21:*/		return 0x820C9BB4;
		  /* 820C9BB4h */ case   22:  		/* li R3, 0 */
		/* 820C9BB4h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C9BB4h case   22:*/		return 0x820C9BB8;
		  /* 820C9BB8h */ case   23:  		/* bc 12, CR0_EQ, 8 */
		/* 820C9BB8h case   23:*/		if ( regs.CR[0].eq ) { return 0x820C9BC0;  }
		/* 820C9BB8h case   23:*/		return 0x820C9BBC;
	}
	return 0x820C9BBC;
} // Block from 820C9B5Ch-820C9BBCh (24 instructions)

//////////////////////////////////////////////////////
// Block at 820C9BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9BBC);
		  /* 820C9BBCh */ case    0:  		/* mr R3, R31 */
		/* 820C9BBCh case    0:*/		regs.R3 = regs.R31;
		/* 820C9BBCh case    0:*/		return 0x820C9BC0;
	}
	return 0x820C9BC0;
} // Block from 820C9BBCh-820C9BC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9BC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9BC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9BC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9BC0);
		  /* 820C9BC0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820C9BC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C9BC0h case    0:*/		return 0x820C9BC4;
		  /* 820C9BC4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C9BC4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9BC4h case    1:*/		return 0x820C9BC8;
		  /* 820C9BC8h */ case    2:  		/* mtspr LR, R12 */
		/* 820C9BC8h case    2:*/		regs.LR = regs.R12;
		/* 820C9BC8h case    2:*/		return 0x820C9BCC;
		  /* 820C9BCCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820C9BCCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C9BCCh case    3:*/		return 0x820C9BD0;
	}
	return 0x820C9BD0;
} // Block from 820C9BC0h-820C9BD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C9BD0h
// Function '?SetAlloc@CNode@D3DXShader@@SAPAVCAlloc@D3DXCore@@PAV34@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9BD0);
		  /* 820C9BD0h */ case    0:  		/* ld R31, <#[R1 - 16]> */
		/* 820C9BD0h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9BD0h case    0:*/		return 0x820C9BD4;
		  /* 820C9BD4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820C9BD4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9BD4h case    1:*/		return 0x820C9BD8;
	}
	return 0x820C9BD8;
} // Block from 820C9BD0h-820C9BD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C9BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9BD8);
		  /* 820C9BD8h */ case    0:  		/* lis R10, -32255 */
		/* 820C9BD8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C9BD8h case    0:*/		return 0x820C9BDC;
		  /* 820C9BDCh */ case    1:  		/* stw R4, <#[R3 + 16]> */
		/* 820C9BDCh case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9BDCh case    1:*/		return 0x820C9BE0;
		  /* 820C9BE0h */ case    2:  		/* li R11, 0 */
		/* 820C9BE0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C9BE0h case    2:*/		return 0x820C9BE4;
		  /* 820C9BE4h */ case    3:  		/* stw R5, <#[R3 + 20]> */
		/* 820C9BE4h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9BE4h case    3:*/		return 0x820C9BE8;
		  /* 820C9BE8h */ case    4:  		/* li R9, 5 */
		/* 820C9BE8h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x5);
		/* 820C9BE8h case    4:*/		return 0x820C9BEC;
		  /* 820C9BECh */ case    5:  		/* stw R6, <#[R3 + 24]> */
		/* 820C9BECh case    5:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000018) );
		/* 820C9BECh case    5:*/		return 0x820C9BF0;
		  /* 820C9BF0h */ case    6:  		/* addi R10, R10, 10544 */
		/* 820C9BF0h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2930);
		/* 820C9BF0h case    6:*/		return 0x820C9BF4;
		  /* 820C9BF4h */ case    7:  		/* stw R11, <#[R3 + 8]> */
		/* 820C9BF4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9BF4h case    7:*/		return 0x820C9BF8;
		  /* 820C9BF8h */ case    8:  		/* stw R9, <#[R3 + 4]> */
		/* 820C9BF8h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9BF8h case    8:*/		return 0x820C9BFC;
		  /* 820C9BFCh */ case    9:  		/* stw R10, <#[R3]> */
		/* 820C9BFCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9BFCh case    9:*/		return 0x820C9C00;
		  /* 820C9C00h */ case   10:  		/* stw R11, <#[R3 + 12]> */
		/* 820C9C00h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C9C00h case   10:*/		return 0x820C9C04;
		  /* 820C9C04h */ case   11:  		/* stw R7, <#[R3 + 28]> */
		/* 820C9C04h case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x0000001C) );
		/* 820C9C04h case   11:*/		return 0x820C9C08;
	}
	return 0x820C9C08;
} // Block from 820C9BD8h-820C9C08h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820C9C08h
// Function '?Alloc@CNode@D3DXShader@@SAPAEKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9C08);
		  /* 820C9C08h */ case    0:  		/* stw R8, <#[R3 + 32]> */
		/* 820C9C08h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000020) );
		/* 820C9C08h case    0:*/		return 0x820C9C0C;
		  /* 820C9C0Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 820C9C0Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9C0Ch case    1:*/		return 0x820C9C10;
	}
	return 0x820C9C10;
} // Block from 820C9C08h-820C9C10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C9C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9C10);
		  /* 820C9C10h */ case    0:  		/* mfspr R12, LR */
		/* 820C9C10h case    0:*/		regs.R12 = regs.LR;
		/* 820C9C10h case    0:*/		return 0x820C9C14;
		  /* 820C9C14h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C9C14h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9C14h case    1:*/		return 0x820C9C18;
		  /* 820C9C18h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C9C18h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C9C18h case    2:*/		return 0x820C9C1C;
		  /* 820C9C1Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C9C1Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9C1Ch case    3:*/		return 0x820C9C20;
		  /* 820C9C20h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C9C20h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C9C20h case    4:*/		return 0x820C9C24;
		  /* 820C9C24h */ case    5:  		/* mr R30, R3 */
		/* 820C9C24h case    5:*/		regs.R30 = regs.R3;
		/* 820C9C24h case    5:*/		return 0x820C9C28;
		  /* 820C9C28h */ case    6:  		/* mr R31, R4 */
		/* 820C9C28h case    6:*/		regs.R31 = regs.R4;
		/* 820C9C28h case    6:*/		return 0x820C9C2C;
		  /* 820C9C2Ch */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820C9C2Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C9C2Ch case    7:*/		return 0x820C9C30;
		  /* 820C9C30h */ case    8:  		/* bc 12, CR6_EQ, 224 */
		/* 820C9C30h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C9D10;  }
		/* 820C9C30h case    8:*/		return 0x820C9C34;
		  /* 820C9C34h */ case    9:  		/* lwz R11, <#[R4 + 4]> */
		/* 820C9C34h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C9C34h case    9:*/		return 0x820C9C38;
		  /* 820C9C38h */ case   10:  		/* lwz R10, <#[R3 + 4]> */
		/* 820C9C38h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9C38h case   10:*/		return 0x820C9C3C;
		  /* 820C9C3Ch */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820C9C3Ch case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820C9C3Ch case   11:*/		return 0x820C9C40;
		  /* 820C9C40h */ case   12:  		/* bc 4, CR6_EQ, 208 */
		/* 820C9C40h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820C9D10;  }
		/* 820C9C40h case   12:*/		return 0x820C9C44;
		  /* 820C9C44h */ case   13:  		/* lwz R11, <#[R3 + 16]> */
		/* 820C9C44h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9C44h case   13:*/		return 0x820C9C48;
		  /* 820C9C48h */ case   14:  		/* lwz R10, <#[R4 + 16]> */
		/* 820C9C48h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 820C9C48h case   14:*/		return 0x820C9C4C;
		  /* 820C9C4Ch */ case   15:  		/* cmpw CR6, R11, R10 */
		/* 820C9C4Ch case   15:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820C9C4Ch case   15:*/		return 0x820C9C50;
	}
	return 0x820C9C50;
} // Block from 820C9C10h-820C9C50h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820C9C50h
// Function '??2CNode@D3DXShader@@SAPAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9C50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9C50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9C50);
		  /* 820C9C50h */ case    0:  		/* bc 4, CR6_EQ, 192 */
		/* 820C9C50h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820C9D10;  }
		/* 820C9C50h case    0:*/		return 0x820C9C54;
		  /* 820C9C54h */ case    1:  		/* lwz R11, <#[R3 + 20]> */
		/* 820C9C54h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9C54h case    1:*/		return 0x820C9C58;
		  /* 820C9C58h */ case    2:  		/* lwz R10, <#[R4 + 20]> */
		/* 820C9C58h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 820C9C58h case    2:*/		return 0x820C9C5C;
		  /* 820C9C5Ch */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 820C9C5Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C9C5Ch case    3:*/		return 0x820C9C60;
		  /* 820C9C60h */ case    4:  		/* bc 4, CR6_EQ, 176 */
		/* 820C9C60h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820C9D10;  }
		/* 820C9C60h case    4:*/		return 0x820C9C64;
		  /* 820C9C64h */ case    5:  		/* lwz R3, <#[R3 + 24]> */
		/* 820C9C64h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000018) );
		/* 820C9C64h case    5:*/		return 0x820C9C68;
		  /* 820C9C68h */ case    6:  		/* lwz R4, <#[R4 + 24]> */
		/* 820C9C68h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000018) );
		/* 820C9C68h case    6:*/		return 0x820C9C6C;
		  /* 820C9C6Ch */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 820C9C6Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C9C6Ch case    7:*/		return 0x820C9C70;
		  /* 820C9C70h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 820C9C70h case    8:*/		if ( regs.CR[6].eq ) { return 0x820C9C88;  }
		/* 820C9C70h case    8:*/		return 0x820C9C74;
		  /* 820C9C74h */ case    9:  		/* lwz R11, <#[R3]> */
		/* 820C9C74h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9C74h case    9:*/		return 0x820C9C78;
		  /* 820C9C78h */ case   10:  		/* lwz R11, <#[R11]> */
		/* 820C9C78h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C9C78h case   10:*/		return 0x820C9C7C;
		  /* 820C9C7Ch */ case   11:  		/* mtspr CTR, R11 */
		/* 820C9C7Ch case   11:*/		regs.CTR = regs.R11;
		/* 820C9C7Ch case   11:*/		return 0x820C9C80;
		  /* 820C9C80h */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 820C9C80h case   12:*/		if ( 1 ) { regs.LR = 0x820C9C84; return (uint32)regs.CTR; }
		/* 820C9C80h case   12:*/		return 0x820C9C84;
		  /* 820C9C84h */ case   13:  		/* b 16 */
		/* 820C9C84h case   13:*/		return 0x820C9C94;
		/* 820C9C84h case   13:*/		return 0x820C9C88;
	}
	return 0x820C9C88;
} // Block from 820C9C50h-820C9C88h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C9C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9C88);
		  /* 820C9C88h */ case    0:  		/* addi R11, R4, 0 */
		/* 820C9C88h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820C9C88h case    0:*/		return 0x820C9C8C;
		  /* 820C9C8Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820C9C8Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C9C8Ch case    1:*/		return 0x820C9C90;
	}
	return 0x820C9C90;
} // Block from 820C9C88h-820C9C90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C9C90h
// Function '??0CNode@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9C90);
		  /* 820C9C90h */ case    0:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820C9C90h case    0:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820C9C90h case    0:*/		return 0x820C9C94;
	}
	return 0x820C9C94;
} // Block from 820C9C90h-820C9C94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9C94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9C94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9C94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9C94);
		  /* 820C9C94h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820C9C94h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820C9C94h case    0:*/		return 0x820C9C98;
		  /* 820C9C98h */ case    1:  		/* bc 12, CR6_EQ, 120 */
		/* 820C9C98h case    1:*/		if ( regs.CR[6].eq ) { return 0x820C9D10;  }
		/* 820C9C98h case    1:*/		return 0x820C9C9C;
		  /* 820C9C9Ch */ case    2:  		/* lwz R3, <#[R30 + 28]> */
		/* 820C9C9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000001C) );
		/* 820C9C9Ch case    2:*/		return 0x820C9CA0;
		  /* 820C9CA0h */ case    3:  		/* lwz R4, <#[R31 + 28]> */
		/* 820C9CA0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000001C) );
		/* 820C9CA0h case    3:*/		return 0x820C9CA4;
		  /* 820C9CA4h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820C9CA4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C9CA4h case    4:*/		return 0x820C9CA8;
		  /* 820C9CA8h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820C9CA8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C9CC0;  }
		/* 820C9CA8h case    5:*/		return 0x820C9CAC;
		  /* 820C9CACh */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820C9CACh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9CACh case    6:*/		return 0x820C9CB0;
	}
	return 0x820C9CB0;
} // Block from 820C9C94h-820C9CB0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820C9CB0h
// Function '??0CNode@D3DXShader@@QAA@W4_D3DNODE_TYPE@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9CB0);
		  /* 820C9CB0h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 820C9CB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C9CB0h case    0:*/		return 0x820C9CB4;
		  /* 820C9CB4h */ case    1:  		/* mtspr CTR, R11 */
		/* 820C9CB4h case    1:*/		regs.CTR = regs.R11;
		/* 820C9CB4h case    1:*/		return 0x820C9CB8;
		  /* 820C9CB8h */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 820C9CB8h case    2:*/		if ( 1 ) { regs.LR = 0x820C9CBC; return (uint32)regs.CTR; }
		/* 820C9CB8h case    2:*/		return 0x820C9CBC;
		  /* 820C9CBCh */ case    3:  		/* b 16 */
		/* 820C9CBCh case    3:*/		return 0x820C9CCC;
		/* 820C9CBCh case    3:*/		return 0x820C9CC0;
	}
	return 0x820C9CC0;
} // Block from 820C9CB0h-820C9CC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C9CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9CC0);
		  /* 820C9CC0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820C9CC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820C9CC0h case    0:*/		return 0x820C9CC4;
		  /* 820C9CC4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820C9CC4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C9CC4h case    1:*/		return 0x820C9CC8;
		  /* 820C9CC8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820C9CC8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820C9CC8h case    2:*/		return 0x820C9CCC;
	}
	return 0x820C9CCC;
} // Block from 820C9CC0h-820C9CCCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9CCC);
		  /* 820C9CCCh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820C9CCCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820C9CCCh case    0:*/		return 0x820C9CD0;
	}
	return 0x820C9CD0;
} // Block from 820C9CCCh-820C9CD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9CD0h
// Function '?IsEqual@CNode@D3DXShader@@UAAHPAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9CD0);
		  /* 820C9CD0h */ case    0:  		/* bc 12, CR6_EQ, 64 */
		/* 820C9CD0h case    0:*/		if ( regs.CR[6].eq ) { return 0x820C9D10;  }
		/* 820C9CD0h case    0:*/		return 0x820C9CD4;
		  /* 820C9CD4h */ case    1:  		/* lwz R3, <#[R30 + 32]> */
		/* 820C9CD4h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000020) );
		/* 820C9CD4h case    1:*/		return 0x820C9CD8;
		  /* 820C9CD8h */ case    2:  		/* lwz R4, <#[R31 + 32]> */
		/* 820C9CD8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000020) );
		/* 820C9CD8h case    2:*/		return 0x820C9CDC;
		  /* 820C9CDCh */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 820C9CDCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C9CDCh case    3:*/		return 0x820C9CE0;
		  /* 820C9CE0h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 820C9CE0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820C9CF8;  }
		/* 820C9CE0h case    4:*/		return 0x820C9CE4;
		  /* 820C9CE4h */ case    5:  		/* lwz R11, <#[R3]> */
		/* 820C9CE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9CE4h case    5:*/		return 0x820C9CE8;
		  /* 820C9CE8h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 820C9CE8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C9CE8h case    6:*/		return 0x820C9CEC;
		  /* 820C9CECh */ case    7:  		/* mtspr CTR, R11 */
		/* 820C9CECh case    7:*/		regs.CTR = regs.R11;
		/* 820C9CECh case    7:*/		return 0x820C9CF0;
		  /* 820C9CF0h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820C9CF0h case    8:*/		if ( 1 ) { regs.LR = 0x820C9CF4; return (uint32)regs.CTR; }
		/* 820C9CF0h case    8:*/		return 0x820C9CF4;
		  /* 820C9CF4h */ case    9:  		/* b 16 */
		/* 820C9CF4h case    9:*/		return 0x820C9D04;
		/* 820C9CF4h case    9:*/		return 0x820C9CF8;
	}
	return 0x820C9CF8;
} // Block from 820C9CD0h-820C9CF8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C9CF8h
// Function '?Copy@CNode@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9CF8);
		  /* 820C9CF8h */ case    0:  		/* addi R11, R4, 0 */
		/* 820C9CF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820C9CF8h case    0:*/		return 0x820C9CFC;
		  /* 820C9CFCh */ case    1:  		/* cntlzw R11, R11 */
		/* 820C9CFCh case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C9CFCh case    1:*/		return 0x820C9D00;
		  /* 820C9D00h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820C9D00h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820C9D00h case    2:*/		return 0x820C9D04;
	}
	return 0x820C9D04;
} // Block from 820C9CF8h-820C9D04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9D04);
		  /* 820C9D04h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820C9D04h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820C9D04h case    0:*/		return 0x820C9D08;
		  /* 820C9D08h */ case    1:  		/* li R3, 1 */
		/* 820C9D08h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820C9D08h case    1:*/		return 0x820C9D0C;
		  /* 820C9D0Ch */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820C9D0Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820C9D14;  }
		/* 820C9D0Ch case    2:*/		return 0x820C9D10;
	}
	return 0x820C9D10;
} // Block from 820C9D04h-820C9D10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9D10);
		  /* 820C9D10h */ case    0:  		/* li R3, 0 */
		/* 820C9D10h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C9D10h case    0:*/		return 0x820C9D14;
	}
	return 0x820C9D14;
} // Block from 820C9D10h-820C9D14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9D14);
		  /* 820C9D14h */ case    0:  		/* addi R1, R1, 112 */
		/* 820C9D14h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C9D14h case    0:*/		return 0x820C9D18;
		  /* 820C9D18h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C9D18h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9D18h case    1:*/		return 0x820C9D1C;
		  /* 820C9D1Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820C9D1Ch case    2:*/		regs.LR = regs.R12;
		/* 820C9D1Ch case    2:*/		return 0x820C9D20;
		  /* 820C9D20h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820C9D20h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C9D20h case    3:*/		return 0x820C9D24;
		  /* 820C9D24h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820C9D24h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9D24h case    4:*/		return 0x820C9D28;
		  /* 820C9D28h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C9D28h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9D28h case    5:*/		return 0x820C9D2C;
	}
	return 0x820C9D2C;
} // Block from 820C9D14h-820C9D2Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C9D2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9D2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9D2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9D2C);
		  /* 820C9D2Ch */ case    0:  		/* nop */
		/* 820C9D2Ch case    0:*/		cpu::op::nop();
		/* 820C9D2Ch case    0:*/		return 0x820C9D30;
	}
	return 0x820C9D30;
} // Block from 820C9D2Ch-820C9D30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9D30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9D30);
		  /* 820C9D30h */ case    0:  		/* mfspr R12, LR */
		/* 820C9D30h case    0:*/		regs.R12 = regs.LR;
		/* 820C9D30h case    0:*/		return 0x820C9D34;
		  /* 820C9D34h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C9D34h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9D34h case    1:*/		return 0x820C9D38;
		  /* 820C9D38h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C9D38h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C9D38h case    2:*/		return 0x820C9D3C;
		  /* 820C9D3Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C9D3Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9D3Ch case    3:*/		return 0x820C9D40;
		  /* 820C9D40h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C9D40h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C9D40h case    4:*/		return 0x820C9D44;
		  /* 820C9D44h */ case    5:  		/* mr R30, R3 */
		/* 820C9D44h case    5:*/		regs.R30 = regs.R3;
		/* 820C9D44h case    5:*/		return 0x820C9D48;
		  /* 820C9D48h */ case    6:  		/* bl 13032 */
		/* 820C9D48h case    6:*/		regs.LR = 0x820C9D4C; return 0x820CD030;
		/* 820C9D48h case    6:*/		return 0x820C9D4C;
		  /* 820C9D4Ch */ case    7:  		/* li R5, 16 */
		/* 820C9D4Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820C9D4Ch case    7:*/		return 0x820C9D50;
		  /* 820C9D50h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820C9D50h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9D50h case    8:*/		return 0x820C9D54;
		  /* 820C9D54h */ case    9:  		/* li R4, 36 */
		/* 820C9D54h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x24);
		/* 820C9D54h case    9:*/		return 0x820C9D58;
		  /* 820C9D58h */ case   10:  		/* bl -3192 */
		/* 820C9D58h case   10:*/		regs.LR = 0x820C9D5C; return 0x820C90E0;
		/* 820C9D58h case   10:*/		return 0x820C9D5C;
		  /* 820C9D5Ch */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820C9D5Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C9D5Ch case   11:*/		return 0x820C9D60;
		  /* 820C9D60h */ case   12:  		/* bc 12, CR0_EQ, 64 */
		/* 820C9D60h case   12:*/		if ( regs.CR[0].eq ) { return 0x820C9DA0;  }
		/* 820C9D60h case   12:*/		return 0x820C9D64;
		  /* 820C9D64h */ case   13:  		/* lis R10, -32255 */
		/* 820C9D64h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C9D64h case   13:*/		return 0x820C9D68;
	}
	return 0x820C9D68;
} // Block from 820C9D30h-820C9D68h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820C9D68h
// Function '?IsEqual@CNode@D3DXShader@@SAHPAV12@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9D68);
		  /* 820C9D68h */ case    0:  		/* li R11, 0 */
		/* 820C9D68h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C9D68h case    0:*/		return 0x820C9D6C;
		  /* 820C9D6Ch */ case    1:  		/* li R9, 5 */
		/* 820C9D6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x5);
		/* 820C9D6Ch case    1:*/		return 0x820C9D70;
		  /* 820C9D70h */ case    2:  		/* addi R10, R10, 10544 */
		/* 820C9D70h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2930);
		/* 820C9D70h case    2:*/		return 0x820C9D74;
		  /* 820C9D74h */ case    3:  		/* stw R11, <#[R3 + 8]> */
		/* 820C9D74h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9D74h case    3:*/		return 0x820C9D78;
		  /* 820C9D78h */ case    4:  		/* stw R9, <#[R3 + 4]> */
		/* 820C9D78h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9D78h case    4:*/		return 0x820C9D7C;
		  /* 820C9D7Ch */ case    5:  		/* mr R31, R3 */
		/* 820C9D7Ch case    5:*/		regs.R31 = regs.R3;
		/* 820C9D7Ch case    5:*/		return 0x820C9D80;
		  /* 820C9D80h */ case    6:  		/* stw R10, <#[R3]> */
		/* 820C9D80h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9D80h case    6:*/		return 0x820C9D84;
		  /* 820C9D84h */ case    7:  		/* stw R11, <#[R3 + 12]> */
		/* 820C9D84h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C9D84h case    7:*/		return 0x820C9D88;
		  /* 820C9D88h */ case    8:  		/* stw R11, <#[R3 + 16]> */
		/* 820C9D88h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9D88h case    8:*/		return 0x820C9D8C;
		  /* 820C9D8Ch */ case    9:  		/* stw R11, <#[R3 + 20]> */
		/* 820C9D8Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9D8Ch case    9:*/		return 0x820C9D90;
	}
	return 0x820C9D90;
} // Block from 820C9D68h-820C9D90h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C9D90h
// Function '?Copy@CNode@D3DXShader@@SAPAV12@PAV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9D90);
		  /* 820C9D90h */ case    0:  		/* stw R11, <#[R3 + 24]> */
		/* 820C9D90h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C9D90h case    0:*/		return 0x820C9D94;
		  /* 820C9D94h */ case    1:  		/* stw R11, <#[R3 + 28]> */
		/* 820C9D94h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820C9D94h case    1:*/		return 0x820C9D98;
		  /* 820C9D98h */ case    2:  		/* stw R11, <#[R3 + 32]> */
		/* 820C9D98h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820C9D98h case    2:*/		return 0x820C9D9C;
		  /* 820C9D9Ch */ case    3:  		/* b 8 */
		/* 820C9D9Ch case    3:*/		return 0x820C9DA4;
		/* 820C9D9Ch case    3:*/		return 0x820C9DA0;
	}
	return 0x820C9DA0;
} // Block from 820C9D90h-820C9DA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820C9DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9DA0);
		  /* 820C9DA0h */ case    0:  		/* li R31, 0 */
		/* 820C9DA0h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820C9DA0h case    0:*/		return 0x820C9DA4;
	}
	return 0x820C9DA4;
} // Block from 820C9DA0h-820C9DA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9DA4);
		  /* 820C9DA4h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820C9DA4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820C9DA4h case    0:*/		return 0x820C9DA8;
		  /* 820C9DA8h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820C9DA8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820C9DB4;  }
		/* 820C9DA8h case    1:*/		return 0x820C9DAC;
		  /* 820C9DACh */ case    2:  		/* li R3, 0 */
		/* 820C9DACh case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820C9DACh case    2:*/		return 0x820C9DB0;
	}
	return 0x820C9DB0;
} // Block from 820C9DA4h-820C9DB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9DB0h
// Function '?Append@CNode@D3DXShader@@SAPAV12@PAV12@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9DB0);
		  /* 820C9DB0h */ case    0:  		/* b 156 */
		/* 820C9DB0h case    0:*/		return 0x820C9E4C;
		/* 820C9DB0h case    0:*/		return 0x820C9DB4;
	}
	return 0x820C9DB4;
} // Block from 820C9DB0h-820C9DB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9DB4);
		  /* 820C9DB4h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820C9DB4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820C9DB4h case    0:*/		return 0x820C9DB8;
		  /* 820C9DB8h */ case    1:  		/* stw R11, <#[R31 + 16]> */
		/* 820C9DB8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820C9DB8h case    1:*/		return 0x820C9DBC;
		  /* 820C9DBCh */ case    2:  		/* lwz R11, <#[R30 + 20]> */
		/* 820C9DBCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820C9DBCh case    2:*/		return 0x820C9DC0;
		  /* 820C9DC0h */ case    3:  		/* stw R11, <#[R31 + 20]> */
		/* 820C9DC0h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820C9DC0h case    3:*/		return 0x820C9DC4;
		  /* 820C9DC4h */ case    4:  		/* lwz R11, <#[R30 + 24]> */
		/* 820C9DC4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820C9DC4h case    4:*/		return 0x820C9DC8;
		  /* 820C9DC8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820C9DC8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C9DC8h case    5:*/		return 0x820C9DCC;
		  /* 820C9DCCh */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 820C9DCCh case    6:*/		if ( regs.CR[6].eq ) { return 0x820C9DF0;  }
		/* 820C9DCCh case    6:*/		return 0x820C9DD0;
		  /* 820C9DD0h */ case    7:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820C9DD0h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820C9DD0h case    7:*/		return 0x820C9DD4;
		  /* 820C9DD4h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 820C9DD4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9DD4h case    8:*/		return 0x820C9DD8;
		  /* 820C9DD8h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 820C9DD8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820C9DD8h case    9:*/		return 0x820C9DDC;
		  /* 820C9DDCh */ case   10:  		/* mtspr CTR, R11 */
		/* 820C9DDCh case   10:*/		regs.CTR = regs.R11;
		/* 820C9DDCh case   10:*/		return 0x820C9DE0;
		  /* 820C9DE0h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820C9DE0h case   11:*/		if ( 1 ) { regs.LR = 0x820C9DE4; return (uint32)regs.CTR; }
		/* 820C9DE0h case   11:*/		return 0x820C9DE4;
		  /* 820C9DE4h */ case   12:  		/* stw R3, <#[R31 + 24]> */
		/* 820C9DE4h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820C9DE4h case   12:*/		return 0x820C9DE8;
		  /* 820C9DE8h */ case   13:  		/* cmplwi CR0, R3, 0 */
		/* 820C9DE8h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C9DE8h case   13:*/		return 0x820C9DEC;
		  /* 820C9DECh */ case   14:  		/* bc 12, CR0_EQ, -64 */
		/* 820C9DECh case   14:*/		if ( regs.CR[0].eq ) { return 0x820C9DAC;  }
		/* 820C9DECh case   14:*/		return 0x820C9DF0;
	}
	return 0x820C9DF0;
} // Block from 820C9DB4h-820C9DF0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820C9DF0h
// Function '??0CNodeList@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9DF0);
		  /* 820C9DF0h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 820C9DF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820C9DF0h case    0:*/		return 0x820C9DF4;
		  /* 820C9DF4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C9DF4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C9DF4h case    1:*/		return 0x820C9DF8;
		  /* 820C9DF8h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820C9DF8h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C9E1C;  }
		/* 820C9DF8h case    2:*/		return 0x820C9DFC;
		  /* 820C9DFCh */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820C9DFCh case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820C9DFCh case    3:*/		return 0x820C9E00;
		  /* 820C9E00h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820C9E00h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9E00h case    4:*/		return 0x820C9E04;
		  /* 820C9E04h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820C9E04h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820C9E04h case    5:*/		return 0x820C9E08;
		  /* 820C9E08h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C9E08h case    6:*/		regs.CTR = regs.R11;
		/* 820C9E08h case    6:*/		return 0x820C9E0C;
		  /* 820C9E0Ch */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820C9E0Ch case    7:*/		if ( 1 ) { regs.LR = 0x820C9E10; return (uint32)regs.CTR; }
		/* 820C9E0Ch case    7:*/		return 0x820C9E10;
		  /* 820C9E10h */ case    8:  		/* stw R3, <#[R31 + 28]> */
		/* 820C9E10h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 820C9E10h case    8:*/		return 0x820C9E14;
		  /* 820C9E14h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820C9E14h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C9E14h case    9:*/		return 0x820C9E18;
	}
	return 0x820C9E18;
} // Block from 820C9DF0h-820C9E18h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820C9E18h
// Function '??0CNodeList@D3DXShader@@QAA@PAVCNode@1@0PBD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9E18);
		  /* 820C9E18h */ case    0:  		/* bc 12, CR0_EQ, -108 */
		/* 820C9E18h case    0:*/		if ( regs.CR[0].eq ) { return 0x820C9DAC;  }
		/* 820C9E18h case    0:*/		return 0x820C9E1C;
	}
	return 0x820C9E1C;
} // Block from 820C9E18h-820C9E1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9E1C);
		  /* 820C9E1Ch */ case    0:  		/* lwz R11, <#[R30 + 32]> */
		/* 820C9E1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 820C9E1Ch case    0:*/		return 0x820C9E20;
		  /* 820C9E20h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820C9E20h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820C9E20h case    1:*/		return 0x820C9E24;
		  /* 820C9E24h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820C9E24h case    2:*/		if ( regs.CR[6].eq ) { return 0x820C9E48;  }
		/* 820C9E24h case    2:*/		return 0x820C9E28;
		  /* 820C9E28h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820C9E28h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820C9E28h case    3:*/		return 0x820C9E2C;
		  /* 820C9E2Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820C9E2Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9E2Ch case    4:*/		return 0x820C9E30;
		  /* 820C9E30h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820C9E30h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820C9E30h case    5:*/		return 0x820C9E34;
		  /* 820C9E34h */ case    6:  		/* mtspr CTR, R11 */
		/* 820C9E34h case    6:*/		regs.CTR = regs.R11;
		/* 820C9E34h case    6:*/		return 0x820C9E38;
		  /* 820C9E38h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820C9E38h case    7:*/		if ( 1 ) { regs.LR = 0x820C9E3C; return (uint32)regs.CTR; }
		/* 820C9E38h case    7:*/		return 0x820C9E3C;
		  /* 820C9E3Ch */ case    8:  		/* stw R3, <#[R31 + 32]> */
		/* 820C9E3Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 820C9E3Ch case    8:*/		return 0x820C9E40;
	}
	return 0x820C9E40;
} // Block from 820C9E1Ch-820C9E40h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820C9E40h
// Function '?IsEqual@CNodeList@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9E40);
		  /* 820C9E40h */ case    0:  		/* cmplwi CR0, R3, 0 */
		/* 820C9E40h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820C9E40h case    0:*/		return 0x820C9E44;
		  /* 820C9E44h */ case    1:  		/* bc 12, CR0_EQ, -152 */
		/* 820C9E44h case    1:*/		if ( regs.CR[0].eq ) { return 0x820C9DAC;  }
		/* 820C9E44h case    1:*/		return 0x820C9E48;
	}
	return 0x820C9E48;
} // Block from 820C9E40h-820C9E48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820C9E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9E48);
		  /* 820C9E48h */ case    0:  		/* mr R3, R31 */
		/* 820C9E48h case    0:*/		regs.R3 = regs.R31;
		/* 820C9E48h case    0:*/		return 0x820C9E4C;
	}
	return 0x820C9E4C;
} // Block from 820C9E48h-820C9E4Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9E4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9E4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9E4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9E4C);
		  /* 820C9E4Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820C9E4Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820C9E4Ch case    0:*/		return 0x820C9E50;
		  /* 820C9E50h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820C9E50h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9E50h case    1:*/		return 0x820C9E54;
		  /* 820C9E54h */ case    2:  		/* mtspr LR, R12 */
		/* 820C9E54h case    2:*/		regs.LR = regs.R12;
		/* 820C9E54h case    2:*/		return 0x820C9E58;
		  /* 820C9E58h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820C9E58h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C9E58h case    3:*/		return 0x820C9E5C;
		  /* 820C9E5Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820C9E5Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9E5Ch case    4:*/		return 0x820C9E60;
		  /* 820C9E60h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820C9E60h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9E60h case    5:*/		return 0x820C9E64;
	}
	return 0x820C9E64;
} // Block from 820C9E4Ch-820C9E64h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820C9E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9E64);
		  /* 820C9E64h */ case    0:  		/* nop */
		/* 820C9E64h case    0:*/		cpu::op::nop();
		/* 820C9E64h case    0:*/		return 0x820C9E68;
		  /* 820C9E68h */ case    1:  		/* lis R10, -32255 */
		/* 820C9E68h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C9E68h case    1:*/		return 0x820C9E6C;
		  /* 820C9E6Ch */ case    2:  		/* li R11, 0 */
		/* 820C9E6Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C9E6Ch case    2:*/		return 0x820C9E70;
		  /* 820C9E70h */ case    3:  		/* li R9, 6 */
		/* 820C9E70h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x6);
		/* 820C9E70h case    3:*/		return 0x820C9E74;
		  /* 820C9E74h */ case    4:  		/* addi R10, R10, 10556 */
		/* 820C9E74h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x293C);
		/* 820C9E74h case    4:*/		return 0x820C9E78;
		  /* 820C9E78h */ case    5:  		/* stw R11, <#[R3 + 8]> */
		/* 820C9E78h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9E78h case    5:*/		return 0x820C9E7C;
		  /* 820C9E7Ch */ case    6:  		/* li R8, -1 */
		/* 820C9E7Ch case    6:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 820C9E7Ch case    6:*/		return 0x820C9E80;
		  /* 820C9E80h */ case    7:  		/* stw R9, <#[R3 + 4]> */
		/* 820C9E80h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9E80h case    7:*/		return 0x820C9E84;
		  /* 820C9E84h */ case    8:  		/* stw R10, <#[R3]> */
		/* 820C9E84h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9E84h case    8:*/		return 0x820C9E88;
		  /* 820C9E88h */ case    9:  		/* stw R11, <#[R3 + 12]> */
		/* 820C9E88h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C9E88h case    9:*/		return 0x820C9E8C;
		  /* 820C9E8Ch */ case   10:  		/* stw R11, <#[R3 + 16]> */
		/* 820C9E8Ch case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9E8Ch case   10:*/		return 0x820C9E90;
		  /* 820C9E90h */ case   11:  		/* stw R11, <#[R3 + 20]> */
		/* 820C9E90h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9E90h case   11:*/		return 0x820C9E94;
		  /* 820C9E94h */ case   12:  		/* stw R11, <#[R3 + 24]> */
		/* 820C9E94h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820C9E94h case   12:*/		return 0x820C9E98;
		  /* 820C9E98h */ case   13:  		/* stw R11, <#[R3 + 28]> */
		/* 820C9E98h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820C9E98h case   13:*/		return 0x820C9E9C;
		  /* 820C9E9Ch */ case   14:  		/* stw R11, <#[R3 + 32]> */
		/* 820C9E9Ch case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820C9E9Ch case   14:*/		return 0x820C9EA0;
		  /* 820C9EA0h */ case   15:  		/* stw R11, <#[R3 + 36]> */
		/* 820C9EA0h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820C9EA0h case   15:*/		return 0x820C9EA4;
		  /* 820C9EA4h */ case   16:  		/* stw R8, <#[R3 + 40]> */
		/* 820C9EA4h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000028) );
		/* 820C9EA4h case   16:*/		return 0x820C9EA8;
		  /* 820C9EA8h */ case   17:  		/* stw R11, <#[R3 + 44]> */
		/* 820C9EA8h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820C9EA8h case   17:*/		return 0x820C9EAC;
		  /* 820C9EACh */ case   18:  		/* stw R11, <#[R3 + 48]> */
		/* 820C9EACh case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820C9EACh case   18:*/		return 0x820C9EB0;
		  /* 820C9EB0h */ case   19:  		/* bclr 20, CR0_LT */
		/* 820C9EB0h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9EB0h case   19:*/		return 0x820C9EB4;
	}
	return 0x820C9EB4;
} // Block from 820C9E64h-820C9EB4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C9EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9EB4);
		  /* 820C9EB4h */ case    0:  		/* nop */
		/* 820C9EB4h case    0:*/		cpu::op::nop();
		/* 820C9EB4h case    0:*/		return 0x820C9EB8;
		  /* 820C9EB8h */ case    1:  		/* lis R10, -32255 */
		/* 820C9EB8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820C9EB8h case    1:*/		return 0x820C9EBC;
		  /* 820C9EBCh */ case    2:  		/* stw R6, <#[R3 + 24]> */
		/* 820C9EBCh case    2:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000018) );
		/* 820C9EBCh case    2:*/		return 0x820C9EC0;
		  /* 820C9EC0h */ case    3:  		/* li R11, 0 */
		/* 820C9EC0h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820C9EC0h case    3:*/		return 0x820C9EC4;
		  /* 820C9EC4h */ case    4:  		/* stw R4, <#[R3 + 16]> */
		/* 820C9EC4h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9EC4h case    4:*/		return 0x820C9EC8;
		  /* 820C9EC8h */ case    5:  		/* li R9, 6 */
		/* 820C9EC8h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x6);
		/* 820C9EC8h case    5:*/		return 0x820C9ECC;
		  /* 820C9ECCh */ case    6:  		/* stw R5, <#[R3 + 20]> */
		/* 820C9ECCh case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9ECCh case    6:*/		return 0x820C9ED0;
		  /* 820C9ED0h */ case    7:  		/* addi R10, R10, 10556 */
		/* 820C9ED0h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x293C);
		/* 820C9ED0h case    7:*/		return 0x820C9ED4;
		  /* 820C9ED4h */ case    8:  		/* stw R11, <#[R3 + 8]> */
		/* 820C9ED4h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820C9ED4h case    8:*/		return 0x820C9ED8;
		  /* 820C9ED8h */ case    9:  		/* li R6, -1 */
		/* 820C9ED8h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 820C9ED8h case    9:*/		return 0x820C9EDC;
		  /* 820C9EDCh */ case   10:  		/* stw R9, <#[R3 + 4]> */
		/* 820C9EDCh case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9EDCh case   10:*/		return 0x820C9EE0;
		  /* 820C9EE0h */ case   11:  		/* stw R10, <#[R3]> */
		/* 820C9EE0h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9EE0h case   11:*/		return 0x820C9EE4;
		  /* 820C9EE4h */ case   12:  		/* stw R11, <#[R3 + 12]> */
		/* 820C9EE4h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820C9EE4h case   12:*/		return 0x820C9EE8;
		  /* 820C9EE8h */ case   13:  		/* stw R7, <#[R3 + 28]> */
		/* 820C9EE8h case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x0000001C) );
		/* 820C9EE8h case   13:*/		return 0x820C9EEC;
		  /* 820C9EECh */ case   14:  		/* stw R8, <#[R3 + 32]> */
		/* 820C9EECh case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000020) );
		/* 820C9EECh case   14:*/		return 0x820C9EF0;
		  /* 820C9EF0h */ case   15:  		/* stw R11, <#[R3 + 36]> */
		/* 820C9EF0h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820C9EF0h case   15:*/		return 0x820C9EF4;
		  /* 820C9EF4h */ case   16:  		/* stw R6, <#[R3 + 40]> */
		/* 820C9EF4h case   16:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000028) );
		/* 820C9EF4h case   16:*/		return 0x820C9EF8;
		  /* 820C9EF8h */ case   17:  		/* stw R11, <#[R3 + 44]> */
		/* 820C9EF8h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820C9EF8h case   17:*/		return 0x820C9EFC;
		  /* 820C9EFCh */ case   18:  		/* stw R11, <#[R3 + 48]> */
		/* 820C9EFCh case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820C9EFCh case   18:*/		return 0x820C9F00;
		  /* 820C9F00h */ case   19:  		/* bclr 20, CR0_LT */
		/* 820C9F00h case   19:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820C9F00h case   19:*/		return 0x820C9F04;
	}
	return 0x820C9F04;
} // Block from 820C9EB4h-820C9F04h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820C9F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9F04);
		  /* 820C9F04h */ case    0:  		/* nop */
		/* 820C9F04h case    0:*/		cpu::op::nop();
		/* 820C9F04h case    0:*/		return 0x820C9F08;
	}
	return 0x820C9F08;
} // Block from 820C9F04h-820C9F08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820C9F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9F08);
		  /* 820C9F08h */ case    0:  		/* mfspr R12, LR */
		/* 820C9F08h case    0:*/		regs.R12 = regs.LR;
		/* 820C9F08h case    0:*/		return 0x820C9F0C;
		  /* 820C9F0Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820C9F0Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820C9F0Ch case    1:*/		return 0x820C9F10;
		  /* 820C9F10h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820C9F10h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820C9F10h case    2:*/		return 0x820C9F14;
		  /* 820C9F14h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820C9F14h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820C9F14h case    3:*/		return 0x820C9F18;
		  /* 820C9F18h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820C9F18h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820C9F18h case    4:*/		return 0x820C9F1C;
		  /* 820C9F1Ch */ case    5:  		/* mr R30, R3 */
		/* 820C9F1Ch case    5:*/		regs.R30 = regs.R3;
		/* 820C9F1Ch case    5:*/		return 0x820C9F20;
		  /* 820C9F20h */ case    6:  		/* mr R31, R4 */
		/* 820C9F20h case    6:*/		regs.R31 = regs.R4;
		/* 820C9F20h case    6:*/		return 0x820C9F24;
		  /* 820C9F24h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820C9F24h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820C9F24h case    7:*/		return 0x820C9F28;
	}
	return 0x820C9F28;
} // Block from 820C9F08h-820C9F28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820C9F28h
// Function '?Copy@CNodeList@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9F28);
		  /* 820C9F28h */ case    0:  		/* bc 12, CR6_EQ, 328 */
		/* 820C9F28h case    0:*/		if ( regs.CR[6].eq ) { return 0x820CA070;  }
		/* 820C9F28h case    0:*/		return 0x820C9F2C;
		  /* 820C9F2Ch */ case    1:  		/* lwz R11, <#[R4 + 4]> */
		/* 820C9F2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820C9F2Ch case    1:*/		return 0x820C9F30;
		  /* 820C9F30h */ case    2:  		/* lwz R10, <#[R3 + 4]> */
		/* 820C9F30h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820C9F30h case    2:*/		return 0x820C9F34;
		  /* 820C9F34h */ case    3:  		/* cmpw CR6, R11, R10 */
		/* 820C9F34h case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820C9F34h case    3:*/		return 0x820C9F38;
		  /* 820C9F38h */ case    4:  		/* bc 4, CR6_EQ, 312 */
		/* 820C9F38h case    4:*/		if ( !regs.CR[6].eq ) { return 0x820CA070;  }
		/* 820C9F38h case    4:*/		return 0x820C9F3C;
		  /* 820C9F3Ch */ case    5:  		/* lwz R11, <#[R3 + 16]> */
		/* 820C9F3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820C9F3Ch case    5:*/		return 0x820C9F40;
		  /* 820C9F40h */ case    6:  		/* lwz R10, <#[R4 + 16]> */
		/* 820C9F40h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 820C9F40h case    6:*/		return 0x820C9F44;
		  /* 820C9F44h */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 820C9F44h case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820C9F44h case    7:*/		return 0x820C9F48;
		  /* 820C9F48h */ case    8:  		/* bc 4, CR6_EQ, 296 */
		/* 820C9F48h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820CA070;  }
		/* 820C9F48h case    8:*/		return 0x820C9F4C;
		  /* 820C9F4Ch */ case    9:  		/* lwz R11, <#[R3 + 36]> */
		/* 820C9F4Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820C9F4Ch case    9:*/		return 0x820C9F50;
		  /* 820C9F50h */ case   10:  		/* lwz R10, <#[R4 + 36]> */
		/* 820C9F50h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000024) );
		/* 820C9F50h case   10:*/		return 0x820C9F54;
		  /* 820C9F54h */ case   11:  		/* cmplw CR6, R11, R10 */
		/* 820C9F54h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C9F54h case   11:*/		return 0x820C9F58;
		  /* 820C9F58h */ case   12:  		/* bc 4, CR6_EQ, 280 */
		/* 820C9F58h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CA070;  }
		/* 820C9F58h case   12:*/		return 0x820C9F5C;
		  /* 820C9F5Ch */ case   13:  		/* lwz R11, <#[R3 + 40]> */
		/* 820C9F5Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 820C9F5Ch case   13:*/		return 0x820C9F60;
		  /* 820C9F60h */ case   14:  		/* lwz R10, <#[R4 + 40]> */
		/* 820C9F60h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000028) );
		/* 820C9F60h case   14:*/		return 0x820C9F64;
		  /* 820C9F64h */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820C9F64h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820C9F64h case   15:*/		return 0x820C9F68;
		  /* 820C9F68h */ case   16:  		/* bc 4, CR6_EQ, 264 */
		/* 820C9F68h case   16:*/		if ( !regs.CR[6].eq ) { return 0x820CA070;  }
		/* 820C9F68h case   16:*/		return 0x820C9F6C;
		  /* 820C9F6Ch */ case   17:  		/* lwz R11, <#[R3 + 44]> */
		/* 820C9F6Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820C9F6Ch case   17:*/		return 0x820C9F70;
		  /* 820C9F70h */ case   18:  		/* lwz R10, <#[R4 + 44]> */
		/* 820C9F70h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000002C) );
		/* 820C9F70h case   18:*/		return 0x820C9F74;
		  /* 820C9F74h */ case   19:  		/* cmpw CR6, R11, R10 */
		/* 820C9F74h case   19:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820C9F74h case   19:*/		return 0x820C9F78;
		  /* 820C9F78h */ case   20:  		/* bc 4, CR6_EQ, 248 */
		/* 820C9F78h case   20:*/		if ( !regs.CR[6].eq ) { return 0x820CA070;  }
		/* 820C9F78h case   20:*/		return 0x820C9F7C;
		  /* 820C9F7Ch */ case   21:  		/* lwz R11, <#[R3 + 48]> */
		/* 820C9F7Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820C9F7Ch case   21:*/		return 0x820C9F80;
		  /* 820C9F80h */ case   22:  		/* lwz R10, <#[R4 + 48]> */
		/* 820C9F80h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000030) );
		/* 820C9F80h case   22:*/		return 0x820C9F84;
		  /* 820C9F84h */ case   23:  		/* cmpw CR6, R11, R10 */
		/* 820C9F84h case   23:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820C9F84h case   23:*/		return 0x820C9F88;
		  /* 820C9F88h */ case   24:  		/* bc 4, CR6_EQ, 232 */
		/* 820C9F88h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820CA070;  }
		/* 820C9F88h case   24:*/		return 0x820C9F8C;
		  /* 820C9F8Ch */ case   25:  		/* lwz R3, <#[R3 + 20]> */
		/* 820C9F8Ch case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000014) );
		/* 820C9F8Ch case   25:*/		return 0x820C9F90;
		  /* 820C9F90h */ case   26:  		/* lwz R4, <#[R4 + 20]> */
		/* 820C9F90h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000014) );
		/* 820C9F90h case   26:*/		return 0x820C9F94;
		  /* 820C9F94h */ case   27:  		/* cmplwi CR6, R3, 0 */
		/* 820C9F94h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C9F94h case   27:*/		return 0x820C9F98;
		  /* 820C9F98h */ case   28:  		/* bc 12, CR6_EQ, 24 */
		/* 820C9F98h case   28:*/		if ( regs.CR[6].eq ) { return 0x820C9FB0;  }
		/* 820C9F98h case   28:*/		return 0x820C9F9C;
		  /* 820C9F9Ch */ case   29:  		/* lwz R11, <#[R3]> */
		/* 820C9F9Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9F9Ch case   29:*/		return 0x820C9FA0;
		  /* 820C9FA0h */ case   30:  		/* lwz R11, <#[R11]> */
		/* 820C9FA0h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C9FA0h case   30:*/		return 0x820C9FA4;
		  /* 820C9FA4h */ case   31:  		/* mtspr CTR, R11 */
		/* 820C9FA4h case   31:*/		regs.CTR = regs.R11;
		/* 820C9FA4h case   31:*/		return 0x820C9FA8;
		  /* 820C9FA8h */ case   32:  		/* bcctrl 20, CR0_LT */
		/* 820C9FA8h case   32:*/		if ( 1 ) { regs.LR = 0x820C9FAC; return (uint32)regs.CTR; }
		/* 820C9FA8h case   32:*/		return 0x820C9FAC;
		  /* 820C9FACh */ case   33:  		/* b 16 */
		/* 820C9FACh case   33:*/		return 0x820C9FBC;
		/* 820C9FACh case   33:*/		return 0x820C9FB0;
	}
	return 0x820C9FB0;
} // Block from 820C9F28h-820C9FB0h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820C9FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9FB0);
		  /* 820C9FB0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820C9FB0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820C9FB0h case    0:*/		return 0x820C9FB4;
		  /* 820C9FB4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820C9FB4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C9FB4h case    1:*/		return 0x820C9FB8;
		  /* 820C9FB8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820C9FB8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820C9FB8h case    2:*/		return 0x820C9FBC;
	}
	return 0x820C9FBC;
} // Block from 820C9FB0h-820C9FBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9FBC);
		  /* 820C9FBCh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820C9FBCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820C9FBCh case    0:*/		return 0x820C9FC0;
		  /* 820C9FC0h */ case    1:  		/* bc 12, CR6_EQ, 176 */
		/* 820C9FC0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CA070;  }
		/* 820C9FC0h case    1:*/		return 0x820C9FC4;
		  /* 820C9FC4h */ case    2:  		/* lwz R3, <#[R30 + 24]> */
		/* 820C9FC4h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820C9FC4h case    2:*/		return 0x820C9FC8;
		  /* 820C9FC8h */ case    3:  		/* lwz R4, <#[R31 + 24]> */
		/* 820C9FC8h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820C9FC8h case    3:*/		return 0x820C9FCC;
		  /* 820C9FCCh */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820C9FCCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820C9FCCh case    4:*/		return 0x820C9FD0;
		  /* 820C9FD0h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820C9FD0h case    5:*/		if ( regs.CR[6].eq ) { return 0x820C9FE8;  }
		/* 820C9FD0h case    5:*/		return 0x820C9FD4;
		  /* 820C9FD4h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820C9FD4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820C9FD4h case    6:*/		return 0x820C9FD8;
		  /* 820C9FD8h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820C9FD8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820C9FD8h case    7:*/		return 0x820C9FDC;
		  /* 820C9FDCh */ case    8:  		/* mtspr CTR, R11 */
		/* 820C9FDCh case    8:*/		regs.CTR = regs.R11;
		/* 820C9FDCh case    8:*/		return 0x820C9FE0;
		  /* 820C9FE0h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820C9FE0h case    9:*/		if ( 1 ) { regs.LR = 0x820C9FE4; return (uint32)regs.CTR; }
		/* 820C9FE0h case    9:*/		return 0x820C9FE4;
		  /* 820C9FE4h */ case   10:  		/* b 16 */
		/* 820C9FE4h case   10:*/		return 0x820C9FF4;
		/* 820C9FE4h case   10:*/		return 0x820C9FE8;
	}
	return 0x820C9FE8;
} // Block from 820C9FBCh-820C9FE8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820C9FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9FE8);
		  /* 820C9FE8h */ case    0:  		/* addi R11, R4, 0 */
		/* 820C9FE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820C9FE8h case    0:*/		return 0x820C9FEC;
		  /* 820C9FECh */ case    1:  		/* cntlzw R11, R11 */
		/* 820C9FECh case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820C9FECh case    1:*/		return 0x820C9FF0;
		  /* 820C9FF0h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820C9FF0h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820C9FF0h case    2:*/		return 0x820C9FF4;
	}
	return 0x820C9FF4;
} // Block from 820C9FE8h-820C9FF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820C9FF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820C9FF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820C9FF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820C9FF4);
		  /* 820C9FF4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820C9FF4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820C9FF4h case    0:*/		return 0x820C9FF8;
		  /* 820C9FF8h */ case    1:  		/* bc 12, CR6_EQ, 120 */
		/* 820C9FF8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CA070;  }
		/* 820C9FF8h case    1:*/		return 0x820C9FFC;
		  /* 820C9FFCh */ case    2:  		/* lwz R3, <#[R30 + 28]> */
		/* 820C9FFCh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000001C) );
		/* 820C9FFCh case    2:*/		return 0x820CA000;
		  /* 820CA000h */ case    3:  		/* lwz R4, <#[R31 + 28]> */
		/* 820CA000h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CA000h case    3:*/		return 0x820CA004;
		  /* 820CA004h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CA004h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CA004h case    4:*/		return 0x820CA008;
		  /* 820CA008h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CA008h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CA020;  }
		/* 820CA008h case    5:*/		return 0x820CA00C;
		  /* 820CA00Ch */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CA00Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA00Ch case    6:*/		return 0x820CA010;
		  /* 820CA010h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CA010h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CA010h case    7:*/		return 0x820CA014;
		  /* 820CA014h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CA014h case    8:*/		regs.CTR = regs.R11;
		/* 820CA014h case    8:*/		return 0x820CA018;
		  /* 820CA018h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CA018h case    9:*/		if ( 1 ) { regs.LR = 0x820CA01C; return (uint32)regs.CTR; }
		/* 820CA018h case    9:*/		return 0x820CA01C;
		  /* 820CA01Ch */ case   10:  		/* b 16 */
		/* 820CA01Ch case   10:*/		return 0x820CA02C;
		/* 820CA01Ch case   10:*/		return 0x820CA020;
	}
	return 0x820CA020;
} // Block from 820C9FF4h-820CA020h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA020);
		  /* 820CA020h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CA020h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CA020h case    0:*/		return 0x820CA024;
		  /* 820CA024h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CA024h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CA024h case    1:*/		return 0x820CA028;
	}
	return 0x820CA028;
} // Block from 820CA020h-820CA028h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CA028h
// Function '??0CNodeTree@D3DXShader@@QAA@PBDPAVCNode@1@11@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA028);
		  /* 820CA028h */ case    0:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CA028h case    0:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CA028h case    0:*/		return 0x820CA02C;
	}
	return 0x820CA02C;
} // Block from 820CA028h-820CA02Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA02C);
		  /* 820CA02Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CA02Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CA02Ch case    0:*/		return 0x820CA030;
		  /* 820CA030h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820CA030h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CA070;  }
		/* 820CA030h case    1:*/		return 0x820CA034;
		  /* 820CA034h */ case    2:  		/* lwz R3, <#[R30 + 32]> */
		/* 820CA034h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000020) );
		/* 820CA034h case    2:*/		return 0x820CA038;
		  /* 820CA038h */ case    3:  		/* lwz R4, <#[R31 + 32]> */
		/* 820CA038h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000020) );
		/* 820CA038h case    3:*/		return 0x820CA03C;
		  /* 820CA03Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CA03Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CA03Ch case    4:*/		return 0x820CA040;
		  /* 820CA040h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CA040h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CA058;  }
		/* 820CA040h case    5:*/		return 0x820CA044;
		  /* 820CA044h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CA044h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA044h case    6:*/		return 0x820CA048;
		  /* 820CA048h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CA048h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CA048h case    7:*/		return 0x820CA04C;
		  /* 820CA04Ch */ case    8:  		/* mtspr CTR, R11 */
		/* 820CA04Ch case    8:*/		regs.CTR = regs.R11;
		/* 820CA04Ch case    8:*/		return 0x820CA050;
	}
	return 0x820CA050;
} // Block from 820CA02Ch-820CA050h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CA050h
// Function '?IsEqual@CNodeTree@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA050);
		  /* 820CA050h */ case    0:  		/* bcctrl 20, CR0_LT */
		/* 820CA050h case    0:*/		if ( 1 ) { regs.LR = 0x820CA054; return (uint32)regs.CTR; }
		/* 820CA050h case    0:*/		return 0x820CA054;
		  /* 820CA054h */ case    1:  		/* b 16 */
		/* 820CA054h case    1:*/		return 0x820CA064;
		/* 820CA054h case    1:*/		return 0x820CA058;
	}
	return 0x820CA058;
} // Block from 820CA050h-820CA058h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CA058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA058);
		  /* 820CA058h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CA058h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CA058h case    0:*/		return 0x820CA05C;
		  /* 820CA05Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CA05Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CA05Ch case    1:*/		return 0x820CA060;
		  /* 820CA060h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CA060h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CA060h case    2:*/		return 0x820CA064;
	}
	return 0x820CA064;
} // Block from 820CA058h-820CA064h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA064);
		  /* 820CA064h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CA064h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CA064h case    0:*/		return 0x820CA068;
		  /* 820CA068h */ case    1:  		/* li R3, 1 */
		/* 820CA068h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CA068h case    1:*/		return 0x820CA06C;
		  /* 820CA06Ch */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820CA06Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CA074;  }
		/* 820CA06Ch case    2:*/		return 0x820CA070;
	}
	return 0x820CA070;
} // Block from 820CA064h-820CA070h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA070);
		  /* 820CA070h */ case    0:  		/* li R3, 0 */
		/* 820CA070h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CA070h case    0:*/		return 0x820CA074;
	}
	return 0x820CA074;
} // Block from 820CA070h-820CA074h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA074);
		  /* 820CA074h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CA074h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CA074h case    0:*/		return 0x820CA078;
		  /* 820CA078h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CA078h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA078h case    1:*/		return 0x820CA07C;
		  /* 820CA07Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CA07Ch case    2:*/		regs.LR = regs.R12;
		/* 820CA07Ch case    2:*/		return 0x820CA080;
		  /* 820CA080h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CA080h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA080h case    3:*/		return 0x820CA084;
		  /* 820CA084h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CA084h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA084h case    4:*/		return 0x820CA088;
		  /* 820CA088h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CA088h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA088h case    5:*/		return 0x820CA08C;
	}
	return 0x820CA08C;
} // Block from 820CA074h-820CA08Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CA08Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA08C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA08C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA08C);
		  /* 820CA08Ch */ case    0:  		/* nop */
		/* 820CA08Ch case    0:*/		cpu::op::nop();
		/* 820CA08Ch case    0:*/		return 0x820CA090;
	}
	return 0x820CA090;
} // Block from 820CA08Ch-820CA090h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA090);
		  /* 820CA090h */ case    0:  		/* mfspr R12, LR */
		/* 820CA090h case    0:*/		regs.R12 = regs.LR;
		/* 820CA090h case    0:*/		return 0x820CA094;
		  /* 820CA094h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CA094h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA094h case    1:*/		return 0x820CA098;
		  /* 820CA098h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CA098h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA098h case    2:*/		return 0x820CA09C;
		  /* 820CA09Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CA09Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA09Ch case    3:*/		return 0x820CA0A0;
		  /* 820CA0A0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CA0A0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CA0A0h case    4:*/		return 0x820CA0A4;
		  /* 820CA0A4h */ case    5:  		/* mr R30, R3 */
		/* 820CA0A4h case    5:*/		regs.R30 = regs.R3;
		/* 820CA0A4h case    5:*/		return 0x820CA0A8;
		  /* 820CA0A8h */ case    6:  		/* bl 12168 */
		/* 820CA0A8h case    6:*/		regs.LR = 0x820CA0AC; return 0x820CD030;
		/* 820CA0A8h case    6:*/		return 0x820CA0AC;
		  /* 820CA0ACh */ case    7:  		/* li R5, 16 */
		/* 820CA0ACh case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CA0ACh case    7:*/		return 0x820CA0B0;
		  /* 820CA0B0h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CA0B0h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA0B0h case    8:*/		return 0x820CA0B4;
		  /* 820CA0B4h */ case    9:  		/* li R4, 52 */
		/* 820CA0B4h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 820CA0B4h case    9:*/		return 0x820CA0B8;
		  /* 820CA0B8h */ case   10:  		/* bl -4056 */
		/* 820CA0B8h case   10:*/		regs.LR = 0x820CA0BC; return 0x820C90E0;
		/* 820CA0B8h case   10:*/		return 0x820CA0BC;
		  /* 820CA0BCh */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CA0BCh case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA0BCh case   11:*/		return 0x820CA0C0;
		  /* 820CA0C0h */ case   12:  		/* bc 12, CR0_EQ, 84 */
		/* 820CA0C0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CA114;  }
		/* 820CA0C0h case   12:*/		return 0x820CA0C4;
		  /* 820CA0C4h */ case   13:  		/* lis R10, -32255 */
		/* 820CA0C4h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CA0C4h case   13:*/		return 0x820CA0C8;
		  /* 820CA0C8h */ case   14:  		/* li R11, 0 */
		/* 820CA0C8h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CA0C8h case   14:*/		return 0x820CA0CC;
		  /* 820CA0CCh */ case   15:  		/* li R9, 6 */
		/* 820CA0CCh case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x6);
		/* 820CA0CCh case   15:*/		return 0x820CA0D0;
		  /* 820CA0D0h */ case   16:  		/* addi R10, R10, 10556 */
		/* 820CA0D0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x293C);
		/* 820CA0D0h case   16:*/		return 0x820CA0D4;
		  /* 820CA0D4h */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 820CA0D4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CA0D4h case   17:*/		return 0x820CA0D8;
		  /* 820CA0D8h */ case   18:  		/* li R8, -1 */
		/* 820CA0D8h case   18:*/		cpu::op::li<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 820CA0D8h case   18:*/		return 0x820CA0DC;
		  /* 820CA0DCh */ case   19:  		/* stw R9, <#[R3 + 4]> */
		/* 820CA0DCh case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA0DCh case   19:*/		return 0x820CA0E0;
		  /* 820CA0E0h */ case   20:  		/* stw R10, <#[R3]> */
		/* 820CA0E0h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA0E0h case   20:*/		return 0x820CA0E4;
		  /* 820CA0E4h */ case   21:  		/* mr R31, R3 */
		/* 820CA0E4h case   21:*/		regs.R31 = regs.R3;
		/* 820CA0E4h case   21:*/		return 0x820CA0E8;
		  /* 820CA0E8h */ case   22:  		/* stw R11, <#[R3 + 12]> */
		/* 820CA0E8h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CA0E8h case   22:*/		return 0x820CA0EC;
		  /* 820CA0ECh */ case   23:  		/* stw R11, <#[R3 + 16]> */
		/* 820CA0ECh case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA0ECh case   23:*/		return 0x820CA0F0;
		  /* 820CA0F0h */ case   24:  		/* stw R11, <#[R3 + 20]> */
		/* 820CA0F0h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CA0F0h case   24:*/		return 0x820CA0F4;
		  /* 820CA0F4h */ case   25:  		/* stw R11, <#[R3 + 24]> */
		/* 820CA0F4h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CA0F4h case   25:*/		return 0x820CA0F8;
		  /* 820CA0F8h */ case   26:  		/* stw R11, <#[R3 + 28]> */
		/* 820CA0F8h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CA0F8h case   26:*/		return 0x820CA0FC;
		  /* 820CA0FCh */ case   27:  		/* stw R11, <#[R3 + 32]> */
		/* 820CA0FCh case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CA0FCh case   27:*/		return 0x820CA100;
		  /* 820CA100h */ case   28:  		/* stw R11, <#[R3 + 36]> */
		/* 820CA100h case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CA100h case   28:*/		return 0x820CA104;
		  /* 820CA104h */ case   29:  		/* stw R8, <#[R3 + 40]> */
		/* 820CA104h case   29:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000028) );
		/* 820CA104h case   29:*/		return 0x820CA108;
		  /* 820CA108h */ case   30:  		/* stw R11, <#[R3 + 44]> */
		/* 820CA108h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 820CA108h case   30:*/		return 0x820CA10C;
		  /* 820CA10Ch */ case   31:  		/* stw R11, <#[R3 + 48]> */
		/* 820CA10Ch case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 820CA10Ch case   31:*/		return 0x820CA110;
		  /* 820CA110h */ case   32:  		/* b 8 */
		/* 820CA110h case   32:*/		return 0x820CA118;
		/* 820CA110h case   32:*/		return 0x820CA114;
	}
	return 0x820CA114;
} // Block from 820CA090h-820CA114h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820CA114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA114);
		  /* 820CA114h */ case    0:  		/* li R31, 0 */
		/* 820CA114h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CA114h case    0:*/		return 0x820CA118;
	}
	return 0x820CA118;
} // Block from 820CA114h-820CA118h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA118);
		  /* 820CA118h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CA118h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CA118h case    0:*/		return 0x820CA11C;
		  /* 820CA11Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CA11Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CA128;  }
		/* 820CA11Ch case    1:*/		return 0x820CA120;
		  /* 820CA120h */ case    2:  		/* li R3, 0 */
		/* 820CA120h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CA120h case    2:*/		return 0x820CA124;
		  /* 820CA124h */ case    3:  		/* b 224 */
		/* 820CA124h case    3:*/		return 0x820CA204;
		/* 820CA124h case    3:*/		return 0x820CA128;
	}
	return 0x820CA128;
} // Block from 820CA118h-820CA128h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CA128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA128);
		  /* 820CA128h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CA128h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CA128h case    0:*/		return 0x820CA12C;
		  /* 820CA12Ch */ case    1:  		/* stw R11, <#[R31 + 16]> */
		/* 820CA12Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820CA12Ch case    1:*/		return 0x820CA130;
		  /* 820CA130h */ case    2:  		/* lwz R11, <#[R30 + 36]> */
		/* 820CA130h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820CA130h case    2:*/		return 0x820CA134;
		  /* 820CA134h */ case    3:  		/* stw R11, <#[R31 + 36]> */
		/* 820CA134h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 820CA134h case    3:*/		return 0x820CA138;
	}
	return 0x820CA138;
} // Block from 820CA128h-820CA138h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CA138h
// Function '?TokenEqual@D3DXShader@@YAHPBUD3DXTOKEN@1@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA138);
		  /* 820CA138h */ case    0:  		/* lwz R11, <#[R30 + 40]> */
		/* 820CA138h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 820CA138h case    0:*/		return 0x820CA13C;
		  /* 820CA13Ch */ case    1:  		/* stw R11, <#[R31 + 40]> */
		/* 820CA13Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820CA13Ch case    1:*/		return 0x820CA140;
		  /* 820CA140h */ case    2:  		/* lwz R11, <#[R30 + 44]> */
		/* 820CA140h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 820CA140h case    2:*/		return 0x820CA144;
		  /* 820CA144h */ case    3:  		/* stw R11, <#[R31 + 44]> */
		/* 820CA144h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820CA144h case    3:*/		return 0x820CA148;
		  /* 820CA148h */ case    4:  		/* lwz R11, <#[R30 + 48]> */
		/* 820CA148h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 820CA148h case    4:*/		return 0x820CA14C;
		  /* 820CA14Ch */ case    5:  		/* stw R11, <#[R31 + 48]> */
		/* 820CA14Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820CA14Ch case    5:*/		return 0x820CA150;
		  /* 820CA150h */ case    6:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CA150h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CA150h case    6:*/		return 0x820CA154;
		  /* 820CA154h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 820CA154h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CA154h case    7:*/		return 0x820CA158;
		  /* 820CA158h */ case    8:  		/* bc 12, CR6_EQ, 36 */
		/* 820CA158h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CA17C;  }
		/* 820CA158h case    8:*/		return 0x820CA15C;
		  /* 820CA15Ch */ case    9:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CA15Ch case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CA15Ch case    9:*/		return 0x820CA160;
		  /* 820CA160h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 820CA160h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA160h case   10:*/		return 0x820CA164;
		  /* 820CA164h */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CA164h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CA164h case   11:*/		return 0x820CA168;
		  /* 820CA168h */ case   12:  		/* mtspr CTR, R11 */
		/* 820CA168h case   12:*/		regs.CTR = regs.R11;
		/* 820CA168h case   12:*/		return 0x820CA16C;
		  /* 820CA16Ch */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 820CA16Ch case   13:*/		if ( 1 ) { regs.LR = 0x820CA170; return (uint32)regs.CTR; }
		/* 820CA16Ch case   13:*/		return 0x820CA170;
		  /* 820CA170h */ case   14:  		/* stw R3, <#[R31 + 20]> */
		/* 820CA170h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820CA170h case   14:*/		return 0x820CA174;
		  /* 820CA174h */ case   15:  		/* cmplwi CR0, R3, 0 */
		/* 820CA174h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA174h case   15:*/		return 0x820CA178;
		  /* 820CA178h */ case   16:  		/* bc 12, CR0_EQ, -88 */
		/* 820CA178h case   16:*/		if ( regs.CR[0].eq ) { return 0x820CA120;  }
		/* 820CA178h case   16:*/		return 0x820CA17C;
	}
	return 0x820CA17C;
} // Block from 820CA138h-820CA17Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 820CA17Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA17C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA17C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA17C);
		  /* 820CA17Ch */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 820CA17Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820CA17Ch case    0:*/		return 0x820CA180;
		  /* 820CA180h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CA180h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CA180h case    1:*/		return 0x820CA184;
		  /* 820CA184h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CA184h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CA1A8;  }
		/* 820CA184h case    2:*/		return 0x820CA188;
		  /* 820CA188h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CA188h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CA188h case    3:*/		return 0x820CA18C;
		  /* 820CA18Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CA18Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA18Ch case    4:*/		return 0x820CA190;
		  /* 820CA190h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CA190h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CA190h case    5:*/		return 0x820CA194;
		  /* 820CA194h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CA194h case    6:*/		regs.CTR = regs.R11;
		/* 820CA194h case    6:*/		return 0x820CA198;
		  /* 820CA198h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CA198h case    7:*/		if ( 1 ) { regs.LR = 0x820CA19C; return (uint32)regs.CTR; }
		/* 820CA198h case    7:*/		return 0x820CA19C;
		  /* 820CA19Ch */ case    8:  		/* stw R3, <#[R31 + 24]> */
		/* 820CA19Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820CA19Ch case    8:*/		return 0x820CA1A0;
		  /* 820CA1A0h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CA1A0h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA1A0h case    9:*/		return 0x820CA1A4;
		  /* 820CA1A4h */ case   10:  		/* bc 12, CR0_EQ, -132 */
		/* 820CA1A4h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CA120;  }
		/* 820CA1A4h case   10:*/		return 0x820CA1A8;
	}
	return 0x820CA1A8;
} // Block from 820CA17Ch-820CA1A8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA1A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA1A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA1A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA1A8);
		  /* 820CA1A8h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 820CA1A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CA1A8h case    0:*/		return 0x820CA1AC;
		  /* 820CA1ACh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CA1ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CA1ACh case    1:*/		return 0x820CA1B0;
		  /* 820CA1B0h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CA1B0h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CA1D4;  }
		/* 820CA1B0h case    2:*/		return 0x820CA1B4;
		  /* 820CA1B4h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CA1B4h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CA1B4h case    3:*/		return 0x820CA1B8;
		  /* 820CA1B8h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CA1B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA1B8h case    4:*/		return 0x820CA1BC;
		  /* 820CA1BCh */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CA1BCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CA1BCh case    5:*/		return 0x820CA1C0;
		  /* 820CA1C0h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CA1C0h case    6:*/		regs.CTR = regs.R11;
		/* 820CA1C0h case    6:*/		return 0x820CA1C4;
		  /* 820CA1C4h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CA1C4h case    7:*/		if ( 1 ) { regs.LR = 0x820CA1C8; return (uint32)regs.CTR; }
		/* 820CA1C4h case    7:*/		return 0x820CA1C8;
		  /* 820CA1C8h */ case    8:  		/* stw R3, <#[R31 + 28]> */
		/* 820CA1C8h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CA1C8h case    8:*/		return 0x820CA1CC;
		  /* 820CA1CCh */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CA1CCh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA1CCh case    9:*/		return 0x820CA1D0;
		  /* 820CA1D0h */ case   10:  		/* bc 12, CR0_EQ, -176 */
		/* 820CA1D0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CA120;  }
		/* 820CA1D0h case   10:*/		return 0x820CA1D4;
	}
	return 0x820CA1D4;
} // Block from 820CA1A8h-820CA1D4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA1D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA1D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA1D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA1D4);
		  /* 820CA1D4h */ case    0:  		/* lwz R11, <#[R30 + 32]> */
		/* 820CA1D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 820CA1D4h case    0:*/		return 0x820CA1D8;
		  /* 820CA1D8h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CA1D8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CA1D8h case    1:*/		return 0x820CA1DC;
		  /* 820CA1DCh */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CA1DCh case    2:*/		if ( regs.CR[6].eq ) { return 0x820CA200;  }
		/* 820CA1DCh case    2:*/		return 0x820CA1E0;
		  /* 820CA1E0h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CA1E0h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CA1E0h case    3:*/		return 0x820CA1E4;
		  /* 820CA1E4h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CA1E4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA1E4h case    4:*/		return 0x820CA1E8;
		  /* 820CA1E8h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CA1E8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CA1E8h case    5:*/		return 0x820CA1EC;
		  /* 820CA1ECh */ case    6:  		/* mtspr CTR, R11 */
		/* 820CA1ECh case    6:*/		regs.CTR = regs.R11;
		/* 820CA1ECh case    6:*/		return 0x820CA1F0;
		  /* 820CA1F0h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CA1F0h case    7:*/		if ( 1 ) { regs.LR = 0x820CA1F4; return (uint32)regs.CTR; }
		/* 820CA1F0h case    7:*/		return 0x820CA1F4;
		  /* 820CA1F4h */ case    8:  		/* stw R3, <#[R31 + 32]> */
		/* 820CA1F4h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000020) );
		/* 820CA1F4h case    8:*/		return 0x820CA1F8;
		  /* 820CA1F8h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CA1F8h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA1F8h case    9:*/		return 0x820CA1FC;
		  /* 820CA1FCh */ case   10:  		/* bc 12, CR0_EQ, -220 */
		/* 820CA1FCh case   10:*/		if ( regs.CR[0].eq ) { return 0x820CA120;  }
		/* 820CA1FCh case   10:*/		return 0x820CA200;
	}
	return 0x820CA200;
} // Block from 820CA1D4h-820CA200h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA200);
		  /* 820CA200h */ case    0:  		/* mr R3, R31 */
		/* 820CA200h case    0:*/		regs.R3 = regs.R31;
		/* 820CA200h case    0:*/		return 0x820CA204;
	}
	return 0x820CA204;
} // Block from 820CA200h-820CA204h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA204);
		  /* 820CA204h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CA204h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CA204h case    0:*/		return 0x820CA208;
		  /* 820CA208h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CA208h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA208h case    1:*/		return 0x820CA20C;
		  /* 820CA20Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CA20Ch case    2:*/		regs.LR = regs.R12;
		/* 820CA20Ch case    2:*/		return 0x820CA210;
		  /* 820CA210h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CA210h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA210h case    3:*/		return 0x820CA214;
		  /* 820CA214h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CA214h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA214h case    4:*/		return 0x820CA218;
		  /* 820CA218h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CA218h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA218h case    5:*/		return 0x820CA21C;
	}
	return 0x820CA21C;
} // Block from 820CA204h-820CA21Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CA21Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA21C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA21C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA21C);
		  /* 820CA21Ch */ case    0:  		/* nop */
		/* 820CA21Ch case    0:*/		cpu::op::nop();
		/* 820CA21Ch case    0:*/		return 0x820CA220;
		  /* 820CA220h */ case    1:  		/* lis R10, -32255 */
		/* 820CA220h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CA220h case    1:*/		return 0x820CA224;
		  /* 820CA224h */ case    2:  		/* stw R4, <#[R3 + 20]> */
		/* 820CA224h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000014) );
		/* 820CA224h case    2:*/		return 0x820CA228;
		  /* 820CA228h */ case    3:  		/* li R11, 0 */
		/* 820CA228h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CA228h case    3:*/		return 0x820CA22C;
		  /* 820CA22Ch */ case    4:  		/* stw R5, <#[R3 + 16]> */
		/* 820CA22Ch case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA22Ch case    4:*/		return 0x820CA230;
		  /* 820CA230h */ case    5:  		/* li R9, 21 */
		/* 820CA230h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x15);
		/* 820CA230h case    5:*/		return 0x820CA234;
		  /* 820CA234h */ case    6:  		/* addi R10, R10, 10568 */
		/* 820CA234h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2948);
		/* 820CA234h case    6:*/		return 0x820CA238;
		  /* 820CA238h */ case    7:  		/* stw R11, <#[R3 + 8]> */
		/* 820CA238h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CA238h case    7:*/		return 0x820CA23C;
		  /* 820CA23Ch */ case    8:  		/* stw R9, <#[R3 + 4]> */
		/* 820CA23Ch case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA23Ch case    8:*/		return 0x820CA240;
		  /* 820CA240h */ case    9:  		/* stw R10, <#[R3]> */
		/* 820CA240h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA240h case    9:*/		return 0x820CA244;
		  /* 820CA244h */ case   10:  		/* stw R11, <#[R3 + 12]> */
		/* 820CA244h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CA244h case   10:*/		return 0x820CA248;
		  /* 820CA248h */ case   11:  		/* stw R11, <#[R3 + 24]> */
		/* 820CA248h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CA248h case   11:*/		return 0x820CA24C;
		  /* 820CA24Ch */ case   12:  		/* stw R11, <#[R3 + 28]> */
		/* 820CA24Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CA24Ch case   12:*/		return 0x820CA250;
	}
	return 0x820CA250;
} // Block from 820CA21Ch-820CA250h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CA250h
// Function '??0CNodeToken@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA250);
		  /* 820CA250h */ case    0:  		/* stw R11, <#[R3 + 32]> */
		/* 820CA250h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CA250h case    0:*/		return 0x820CA254;
		  /* 820CA254h */ case    1:  		/* stw R11, <#[R3 + 36]> */
		/* 820CA254h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CA254h case    1:*/		return 0x820CA258;
		  /* 820CA258h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820CA258h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA258h case    2:*/		return 0x820CA25C;
	}
	return 0x820CA25C;
} // Block from 820CA250h-820CA25Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA25Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA25C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA25C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA25C);
		  /* 820CA25Ch */ case    0:  		/* nop */
		/* 820CA25Ch case    0:*/		cpu::op::nop();
		/* 820CA25Ch case    0:*/		return 0x820CA260;
	}
	return 0x820CA260;
} // Block from 820CA25Ch-820CA260h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA260);
		  /* 820CA260h */ case    0:  		/* mfspr R12, LR */
		/* 820CA260h case    0:*/		regs.R12 = regs.LR;
		/* 820CA260h case    0:*/		return 0x820CA264;
		  /* 820CA264h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CA264h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA264h case    1:*/		return 0x820CA268;
		  /* 820CA268h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CA268h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA268h case    2:*/		return 0x820CA26C;
		  /* 820CA26Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CA26Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA26Ch case    3:*/		return 0x820CA270;
		  /* 820CA270h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CA270h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CA270h case    4:*/		return 0x820CA274;
		  /* 820CA274h */ case    5:  		/* mr R30, R3 */
		/* 820CA274h case    5:*/		regs.R30 = regs.R3;
		/* 820CA274h case    5:*/		return 0x820CA278;
	}
	return 0x820CA278;
} // Block from 820CA260h-820CA278h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CA278h
// Function '??0CNodeToken@D3DXShader@@QAA@PBUD3DXTOKEN@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA278);
		  /* 820CA278h */ case    0:  		/* mr R31, R4 */
		/* 820CA278h case    0:*/		regs.R31 = regs.R4;
		/* 820CA278h case    0:*/		return 0x820CA27C;
		  /* 820CA27Ch */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 820CA27Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CA27Ch case    1:*/		return 0x820CA280;
		  /* 820CA280h */ case    2:  		/* bc 12, CR6_EQ, 240 */
		/* 820CA280h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CA370;  }
		/* 820CA280h case    2:*/		return 0x820CA284;
		  /* 820CA284h */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CA284h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CA284h case    3:*/		return 0x820CA288;
		  /* 820CA288h */ case    4:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CA288h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA288h case    4:*/		return 0x820CA28C;
		  /* 820CA28Ch */ case    5:  		/* cmpw CR6, R11, R10 */
		/* 820CA28Ch case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CA28Ch case    5:*/		return 0x820CA290;
		  /* 820CA290h */ case    6:  		/* bc 4, CR6_EQ, 224 */
		/* 820CA290h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820CA370;  }
		/* 820CA290h case    6:*/		return 0x820CA294;
		  /* 820CA294h */ case    7:  		/* lwz R11, <#[R3 + 28]> */
		/* 820CA294h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CA294h case    7:*/		return 0x820CA298;
		  /* 820CA298h */ case    8:  		/* lwz R10, <#[R4 + 28]> */
		/* 820CA298h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x0000001C) );
		/* 820CA298h case    8:*/		return 0x820CA29C;
		  /* 820CA29Ch */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 820CA29Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CA29Ch case    9:*/		return 0x820CA2A0;
		  /* 820CA2A0h */ case   10:  		/* bc 4, CR6_EQ, 208 */
		/* 820CA2A0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x820CA370;  }
		/* 820CA2A0h case   10:*/		return 0x820CA2A4;
		  /* 820CA2A4h */ case   11:  		/* lwz R11, <#[R3 + 24]> */
		/* 820CA2A4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CA2A4h case   11:*/		return 0x820CA2A8;
		  /* 820CA2A8h */ case   12:  		/* lwz R10, <#[R4 + 24]> */
		/* 820CA2A8h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 820CA2A8h case   12:*/		return 0x820CA2AC;
		  /* 820CA2ACh */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 820CA2ACh case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CA2ACh case   13:*/		return 0x820CA2B0;
		  /* 820CA2B0h */ case   14:  		/* bc 4, CR6_EQ, 192 */
		/* 820CA2B0h case   14:*/		if ( !regs.CR[6].eq ) { return 0x820CA370;  }
		/* 820CA2B0h case   14:*/		return 0x820CA2B4;
		  /* 820CA2B4h */ case   15:  		/* lwz R11, <#[R3 + 32]> */
		/* 820CA2B4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CA2B4h case   15:*/		return 0x820CA2B8;
	}
	return 0x820CA2B8;
} // Block from 820CA278h-820CA2B8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CA2B8h
// Function '?IsEqual@CNodeToken@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA2B8);
		  /* 820CA2B8h */ case    0:  		/* lwz R10, <#[R4 + 32]> */
		/* 820CA2B8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000020) );
		/* 820CA2B8h case    0:*/		return 0x820CA2BC;
		  /* 820CA2BCh */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820CA2BCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CA2BCh case    1:*/		return 0x820CA2C0;
		  /* 820CA2C0h */ case    2:  		/* bc 4, CR6_EQ, 176 */
		/* 820CA2C0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CA370;  }
		/* 820CA2C0h case    2:*/		return 0x820CA2C4;
		  /* 820CA2C4h */ case    3:  		/* lwz R3, <#[R3 + 16]> */
		/* 820CA2C4h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA2C4h case    3:*/		return 0x820CA2C8;
		  /* 820CA2C8h */ case    4:  		/* lwz R4, <#[R4 + 16]> */
		/* 820CA2C8h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000010) );
		/* 820CA2C8h case    4:*/		return 0x820CA2CC;
		  /* 820CA2CCh */ case    5:  		/* cmplwi CR6, R3, 0 */
		/* 820CA2CCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CA2CCh case    5:*/		return 0x820CA2D0;
		  /* 820CA2D0h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 820CA2D0h case    6:*/		if ( regs.CR[6].eq ) { return 0x820CA2E8;  }
		/* 820CA2D0h case    6:*/		return 0x820CA2D4;
		  /* 820CA2D4h */ case    7:  		/* lwz R11, <#[R3]> */
		/* 820CA2D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA2D4h case    7:*/		return 0x820CA2D8;
		  /* 820CA2D8h */ case    8:  		/* lwz R11, <#[R11]> */
		/* 820CA2D8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CA2D8h case    8:*/		return 0x820CA2DC;
		  /* 820CA2DCh */ case    9:  		/* mtspr CTR, R11 */
		/* 820CA2DCh case    9:*/		regs.CTR = regs.R11;
		/* 820CA2DCh case    9:*/		return 0x820CA2E0;
		  /* 820CA2E0h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820CA2E0h case   10:*/		if ( 1 ) { regs.LR = 0x820CA2E4; return (uint32)regs.CTR; }
		/* 820CA2E0h case   10:*/		return 0x820CA2E4;
		  /* 820CA2E4h */ case   11:  		/* b 16 */
		/* 820CA2E4h case   11:*/		return 0x820CA2F4;
		/* 820CA2E4h case   11:*/		return 0x820CA2E8;
	}
	return 0x820CA2E8;
} // Block from 820CA2B8h-820CA2E8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CA2E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA2E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA2E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA2E8);
		  /* 820CA2E8h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CA2E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CA2E8h case    0:*/		return 0x820CA2EC;
		  /* 820CA2ECh */ case    1:  		/* cntlzw R11, R11 */
		/* 820CA2ECh case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CA2ECh case    1:*/		return 0x820CA2F0;
		  /* 820CA2F0h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CA2F0h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CA2F0h case    2:*/		return 0x820CA2F4;
	}
	return 0x820CA2F4;
} // Block from 820CA2E8h-820CA2F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA2F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA2F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA2F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA2F4);
		  /* 820CA2F4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CA2F4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CA2F4h case    0:*/		return 0x820CA2F8;
		  /* 820CA2F8h */ case    1:  		/* bc 12, CR6_EQ, 120 */
		/* 820CA2F8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CA370;  }
		/* 820CA2F8h case    1:*/		return 0x820CA2FC;
		  /* 820CA2FCh */ case    2:  		/* lwz R3, <#[R30 + 20]> */
		/* 820CA2FCh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000014) );
		/* 820CA2FCh case    2:*/		return 0x820CA300;
		  /* 820CA300h */ case    3:  		/* lwz R4, <#[R31 + 20]> */
		/* 820CA300h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 820CA300h case    3:*/		return 0x820CA304;
		  /* 820CA304h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CA304h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CA304h case    4:*/		return 0x820CA308;
	}
	return 0x820CA308;
} // Block from 820CA2F4h-820CA308h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820CA308h
// Function '?Copy@CNodeToken@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA308);
		  /* 820CA308h */ case    0:  		/* bc 12, CR6_EQ, 24 */
		/* 820CA308h case    0:*/		if ( regs.CR[6].eq ) { return 0x820CA320;  }
		/* 820CA308h case    0:*/		return 0x820CA30C;
		  /* 820CA30Ch */ case    1:  		/* lwz R11, <#[R3]> */
		/* 820CA30Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA30Ch case    1:*/		return 0x820CA310;
		  /* 820CA310h */ case    2:  		/* lwz R11, <#[R11]> */
		/* 820CA310h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CA310h case    2:*/		return 0x820CA314;
		  /* 820CA314h */ case    3:  		/* mtspr CTR, R11 */
		/* 820CA314h case    3:*/		regs.CTR = regs.R11;
		/* 820CA314h case    3:*/		return 0x820CA318;
		  /* 820CA318h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 820CA318h case    4:*/		if ( 1 ) { regs.LR = 0x820CA31C; return (uint32)regs.CTR; }
		/* 820CA318h case    4:*/		return 0x820CA31C;
		  /* 820CA31Ch */ case    5:  		/* b 16 */
		/* 820CA31Ch case    5:*/		return 0x820CA32C;
		/* 820CA31Ch case    5:*/		return 0x820CA320;
	}
	return 0x820CA320;
} // Block from 820CA308h-820CA320h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CA320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA320);
		  /* 820CA320h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CA320h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CA320h case    0:*/		return 0x820CA324;
		  /* 820CA324h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CA324h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CA324h case    1:*/		return 0x820CA328;
		  /* 820CA328h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CA328h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CA328h case    2:*/		return 0x820CA32C;
	}
	return 0x820CA32C;
} // Block from 820CA320h-820CA32Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA32Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA32C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA32C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA32C);
		  /* 820CA32Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CA32Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CA32Ch case    0:*/		return 0x820CA330;
		  /* 820CA330h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820CA330h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CA370;  }
		/* 820CA330h case    1:*/		return 0x820CA334;
		  /* 820CA334h */ case    2:  		/* lwz R3, <#[R30 + 36]> */
		/* 820CA334h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000024) );
		/* 820CA334h case    2:*/		return 0x820CA338;
		  /* 820CA338h */ case    3:  		/* lwz R4, <#[R31 + 36]> */
		/* 820CA338h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000024) );
		/* 820CA338h case    3:*/		return 0x820CA33C;
		  /* 820CA33Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CA33Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CA33Ch case    4:*/		return 0x820CA340;
		  /* 820CA340h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CA340h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CA358;  }
		/* 820CA340h case    5:*/		return 0x820CA344;
		  /* 820CA344h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CA344h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA344h case    6:*/		return 0x820CA348;
		  /* 820CA348h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CA348h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CA348h case    7:*/		return 0x820CA34C;
		  /* 820CA34Ch */ case    8:  		/* mtspr CTR, R11 */
		/* 820CA34Ch case    8:*/		regs.CTR = regs.R11;
		/* 820CA34Ch case    8:*/		return 0x820CA350;
		  /* 820CA350h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CA350h case    9:*/		if ( 1 ) { regs.LR = 0x820CA354; return (uint32)regs.CTR; }
		/* 820CA350h case    9:*/		return 0x820CA354;
		  /* 820CA354h */ case   10:  		/* b 16 */
		/* 820CA354h case   10:*/		return 0x820CA364;
		/* 820CA354h case   10:*/		return 0x820CA358;
	}
	return 0x820CA358;
} // Block from 820CA32Ch-820CA358h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA358);
		  /* 820CA358h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CA358h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CA358h case    0:*/		return 0x820CA35C;
		  /* 820CA35Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CA35Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CA35Ch case    1:*/		return 0x820CA360;
		  /* 820CA360h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CA360h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CA360h case    2:*/		return 0x820CA364;
	}
	return 0x820CA364;
} // Block from 820CA358h-820CA364h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA364);
		  /* 820CA364h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CA364h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CA364h case    0:*/		return 0x820CA368;
		  /* 820CA368h */ case    1:  		/* li R3, 1 */
		/* 820CA368h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CA368h case    1:*/		return 0x820CA36C;
		  /* 820CA36Ch */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820CA36Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CA374;  }
		/* 820CA36Ch case    2:*/		return 0x820CA370;
	}
	return 0x820CA370;
} // Block from 820CA364h-820CA370h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA370);
		  /* 820CA370h */ case    0:  		/* li R3, 0 */
		/* 820CA370h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CA370h case    0:*/		return 0x820CA374;
	}
	return 0x820CA374;
} // Block from 820CA370h-820CA374h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA374);
		  /* 820CA374h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CA374h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CA374h case    0:*/		return 0x820CA378;
		  /* 820CA378h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CA378h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA378h case    1:*/		return 0x820CA37C;
		  /* 820CA37Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CA37Ch case    2:*/		regs.LR = regs.R12;
		/* 820CA37Ch case    2:*/		return 0x820CA380;
		  /* 820CA380h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CA380h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA380h case    3:*/		return 0x820CA384;
		  /* 820CA384h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CA384h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA384h case    4:*/		return 0x820CA388;
		  /* 820CA388h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CA388h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA388h case    5:*/		return 0x820CA38C;
	}
	return 0x820CA38C;
} // Block from 820CA374h-820CA38Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CA38Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA38C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA38C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA38C);
		  /* 820CA38Ch */ case    0:  		/* nop */
		/* 820CA38Ch case    0:*/		cpu::op::nop();
		/* 820CA38Ch case    0:*/		return 0x820CA390;
	}
	return 0x820CA390;
} // Block from 820CA38Ch-820CA390h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA390);
		  /* 820CA390h */ case    0:  		/* mfspr R12, LR */
		/* 820CA390h case    0:*/		regs.R12 = regs.LR;
		/* 820CA390h case    0:*/		return 0x820CA394;
		  /* 820CA394h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CA394h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA394h case    1:*/		return 0x820CA398;
	}
	return 0x820CA398;
} // Block from 820CA390h-820CA398h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CA398h
// Function '??0CNodeProgram@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA398);
		  /* 820CA398h */ case    0:  		/* std R30, <#[R1 - 24]> */
		/* 820CA398h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA398h case    0:*/		return 0x820CA39C;
		  /* 820CA39Ch */ case    1:  		/* std R31, <#[R1 - 16]> */
		/* 820CA39Ch case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA39Ch case    1:*/		return 0x820CA3A0;
		  /* 820CA3A0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CA3A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CA3A0h case    2:*/		return 0x820CA3A4;
		  /* 820CA3A4h */ case    3:  		/* mr R30, R3 */
		/* 820CA3A4h case    3:*/		regs.R30 = regs.R3;
		/* 820CA3A4h case    3:*/		return 0x820CA3A8;
		  /* 820CA3A8h */ case    4:  		/* bl 11400 */
		/* 820CA3A8h case    4:*/		regs.LR = 0x820CA3AC; return 0x820CD030;
		/* 820CA3A8h case    4:*/		return 0x820CA3AC;
		  /* 820CA3ACh */ case    5:  		/* li R5, 16 */
		/* 820CA3ACh case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CA3ACh case    5:*/		return 0x820CA3B0;
		  /* 820CA3B0h */ case    6:  		/* lwz R3, <#[R3]> */
		/* 820CA3B0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA3B0h case    6:*/		return 0x820CA3B4;
		  /* 820CA3B4h */ case    7:  		/* li R4, 40 */
		/* 820CA3B4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 820CA3B4h case    7:*/		return 0x820CA3B8;
		  /* 820CA3B8h */ case    8:  		/* bl -4824 */
		/* 820CA3B8h case    8:*/		regs.LR = 0x820CA3BC; return 0x820C90E0;
		/* 820CA3B8h case    8:*/		return 0x820CA3BC;
		  /* 820CA3BCh */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CA3BCh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA3BCh case    9:*/		return 0x820CA3C0;
		  /* 820CA3C0h */ case   10:  		/* bc 12, CR0_EQ, 68 */
		/* 820CA3C0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CA404;  }
		/* 820CA3C0h case   10:*/		return 0x820CA3C4;
		  /* 820CA3C4h */ case   11:  		/* lis R10, -32255 */
		/* 820CA3C4h case   11:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CA3C4h case   11:*/		return 0x820CA3C8;
		  /* 820CA3C8h */ case   12:  		/* li R11, 0 */
		/* 820CA3C8h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CA3C8h case   12:*/		return 0x820CA3CC;
		  /* 820CA3CCh */ case   13:  		/* li R9, 21 */
		/* 820CA3CCh case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x15);
		/* 820CA3CCh case   13:*/		return 0x820CA3D0;
		  /* 820CA3D0h */ case   14:  		/* addi R10, R10, 10568 */
		/* 820CA3D0h case   14:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2948);
		/* 820CA3D0h case   14:*/		return 0x820CA3D4;
		  /* 820CA3D4h */ case   15:  		/* stw R11, <#[R3 + 8]> */
		/* 820CA3D4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CA3D4h case   15:*/		return 0x820CA3D8;
	}
	return 0x820CA3D8;
} // Block from 820CA398h-820CA3D8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CA3D8h
// Function '??0CNodeProgram@D3DXShader@@QAA@IIIIIIPAVCNode@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA3D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA3D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA3D8);
		  /* 820CA3D8h */ case    0:  		/* stw R9, <#[R3 + 4]> */
		/* 820CA3D8h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA3D8h case    0:*/		return 0x820CA3DC;
		  /* 820CA3DCh */ case    1:  		/* mr R31, R3 */
		/* 820CA3DCh case    1:*/		regs.R31 = regs.R3;
		/* 820CA3DCh case    1:*/		return 0x820CA3E0;
		  /* 820CA3E0h */ case    2:  		/* stw R10, <#[R3]> */
		/* 820CA3E0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA3E0h case    2:*/		return 0x820CA3E4;
		  /* 820CA3E4h */ case    3:  		/* stw R11, <#[R3 + 12]> */
		/* 820CA3E4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CA3E4h case    3:*/		return 0x820CA3E8;
		  /* 820CA3E8h */ case    4:  		/* stw R11, <#[R3 + 16]> */
		/* 820CA3E8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA3E8h case    4:*/		return 0x820CA3EC;
		  /* 820CA3ECh */ case    5:  		/* stw R11, <#[R3 + 20]> */
		/* 820CA3ECh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CA3ECh case    5:*/		return 0x820CA3F0;
		  /* 820CA3F0h */ case    6:  		/* stw R11, <#[R3 + 24]> */
		/* 820CA3F0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CA3F0h case    6:*/		return 0x820CA3F4;
		  /* 820CA3F4h */ case    7:  		/* stw R11, <#[R3 + 28]> */
		/* 820CA3F4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CA3F4h case    7:*/		return 0x820CA3F8;
		  /* 820CA3F8h */ case    8:  		/* stw R11, <#[R3 + 32]> */
		/* 820CA3F8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820CA3F8h case    8:*/		return 0x820CA3FC;
		  /* 820CA3FCh */ case    9:  		/* stw R11, <#[R3 + 36]> */
		/* 820CA3FCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000024) );
		/* 820CA3FCh case    9:*/		return 0x820CA400;
		  /* 820CA400h */ case   10:  		/* b 8 */
		/* 820CA400h case   10:*/		return 0x820CA408;
		/* 820CA400h case   10:*/		return 0x820CA404;
	}
	return 0x820CA404;
} // Block from 820CA3D8h-820CA404h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA404);
		  /* 820CA404h */ case    0:  		/* li R31, 0 */
		/* 820CA404h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CA404h case    0:*/		return 0x820CA408;
	}
	return 0x820CA408;
} // Block from 820CA404h-820CA408h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA408);
		  /* 820CA408h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CA408h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CA408h case    0:*/		return 0x820CA40C;
		  /* 820CA40Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CA40Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CA418;  }
		/* 820CA40Ch case    1:*/		return 0x820CA410;
		  /* 820CA410h */ case    2:  		/* li R3, 0 */
		/* 820CA410h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CA410h case    2:*/		return 0x820CA414;
		  /* 820CA414h */ case    3:  		/* b 164 */
		/* 820CA414h case    3:*/		return 0x820CA4B8;
		/* 820CA414h case    3:*/		return 0x820CA418;
	}
	return 0x820CA418;
} // Block from 820CA408h-820CA418h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CA418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA418);
		  /* 820CA418h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 820CA418h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CA418h case    0:*/		return 0x820CA41C;
		  /* 820CA41Ch */ case    1:  		/* stw R11, <#[R31 + 28]> */
		/* 820CA41Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CA41Ch case    1:*/		return 0x820CA420;
	}
	return 0x820CA420;
} // Block from 820CA418h-820CA420h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CA420h
// Function '?IsEqual@CNodeProgram@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA420);
		  /* 820CA420h */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 820CA420h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820CA420h case    0:*/		return 0x820CA424;
		  /* 820CA424h */ case    1:  		/* stw R11, <#[R31 + 24]> */
		/* 820CA424h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 820CA424h case    1:*/		return 0x820CA428;
		  /* 820CA428h */ case    2:  		/* lwz R11, <#[R30 + 32]> */
		/* 820CA428h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 820CA428h case    2:*/		return 0x820CA42C;
		  /* 820CA42Ch */ case    3:  		/* stw R11, <#[R31 + 32]> */
		/* 820CA42Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820CA42Ch case    3:*/		return 0x820CA430;
		  /* 820CA430h */ case    4:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CA430h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CA430h case    4:*/		return 0x820CA434;
		  /* 820CA434h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 820CA434h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CA434h case    5:*/		return 0x820CA438;
		  /* 820CA438h */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 820CA438h case    6:*/		if ( regs.CR[6].eq ) { return 0x820CA45C;  }
		/* 820CA438h case    6:*/		return 0x820CA43C;
		  /* 820CA43Ch */ case    7:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CA43Ch case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CA43Ch case    7:*/		return 0x820CA440;
		  /* 820CA440h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 820CA440h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA440h case    8:*/		return 0x820CA444;
		  /* 820CA444h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CA444h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CA444h case    9:*/		return 0x820CA448;
		  /* 820CA448h */ case   10:  		/* mtspr CTR, R11 */
		/* 820CA448h case   10:*/		regs.CTR = regs.R11;
		/* 820CA448h case   10:*/		return 0x820CA44C;
		  /* 820CA44Ch */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820CA44Ch case   11:*/		if ( 1 ) { regs.LR = 0x820CA450; return (uint32)regs.CTR; }
		/* 820CA44Ch case   11:*/		return 0x820CA450;
		  /* 820CA450h */ case   12:  		/* stw R3, <#[R31 + 16]> */
		/* 820CA450h case   12:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820CA450h case   12:*/		return 0x820CA454;
		  /* 820CA454h */ case   13:  		/* cmplwi CR0, R3, 0 */
		/* 820CA454h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA454h case   13:*/		return 0x820CA458;
		  /* 820CA458h */ case   14:  		/* bc 12, CR0_EQ, -72 */
		/* 820CA458h case   14:*/		if ( regs.CR[0].eq ) { return 0x820CA410;  }
		/* 820CA458h case   14:*/		return 0x820CA45C;
	}
	return 0x820CA45C;
} // Block from 820CA420h-820CA45Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 820CA45Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA45C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA45C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA45C);
		  /* 820CA45Ch */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CA45Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CA45Ch case    0:*/		return 0x820CA460;
		  /* 820CA460h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CA460h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CA460h case    1:*/		return 0x820CA464;
		  /* 820CA464h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CA464h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CA488;  }
		/* 820CA464h case    2:*/		return 0x820CA468;
		  /* 820CA468h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CA468h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CA468h case    3:*/		return 0x820CA46C;
		  /* 820CA46Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CA46Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA46Ch case    4:*/		return 0x820CA470;
		  /* 820CA470h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CA470h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CA470h case    5:*/		return 0x820CA474;
		  /* 820CA474h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CA474h case    6:*/		regs.CTR = regs.R11;
		/* 820CA474h case    6:*/		return 0x820CA478;
		  /* 820CA478h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CA478h case    7:*/		if ( 1 ) { regs.LR = 0x820CA47C; return (uint32)regs.CTR; }
		/* 820CA478h case    7:*/		return 0x820CA47C;
		  /* 820CA47Ch */ case    8:  		/* stw R3, <#[R31 + 20]> */
		/* 820CA47Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820CA47Ch case    8:*/		return 0x820CA480;
		  /* 820CA480h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CA480h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA480h case    9:*/		return 0x820CA484;
		  /* 820CA484h */ case   10:  		/* bc 12, CR0_EQ, -116 */
		/* 820CA484h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CA410;  }
		/* 820CA484h case   10:*/		return 0x820CA488;
	}
	return 0x820CA488;
} // Block from 820CA45Ch-820CA488h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA488);
		  /* 820CA488h */ case    0:  		/* lwz R11, <#[R30 + 36]> */
		/* 820CA488h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 820CA488h case    0:*/		return 0x820CA48C;
		  /* 820CA48Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CA48Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CA48Ch case    1:*/		return 0x820CA490;
		  /* 820CA490h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CA490h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CA4B4;  }
		/* 820CA490h case    2:*/		return 0x820CA494;
		  /* 820CA494h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CA494h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CA494h case    3:*/		return 0x820CA498;
		  /* 820CA498h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CA498h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA498h case    4:*/		return 0x820CA49C;
		  /* 820CA49Ch */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CA49Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CA49Ch case    5:*/		return 0x820CA4A0;
		  /* 820CA4A0h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CA4A0h case    6:*/		regs.CTR = regs.R11;
		/* 820CA4A0h case    6:*/		return 0x820CA4A4;
		  /* 820CA4A4h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CA4A4h case    7:*/		if ( 1 ) { regs.LR = 0x820CA4A8; return (uint32)regs.CTR; }
		/* 820CA4A4h case    7:*/		return 0x820CA4A8;
		  /* 820CA4A8h */ case    8:  		/* stw R3, <#[R31 + 36]> */
		/* 820CA4A8h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000024) );
		/* 820CA4A8h case    8:*/		return 0x820CA4AC;
		  /* 820CA4ACh */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CA4ACh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA4ACh case    9:*/		return 0x820CA4B0;
		  /* 820CA4B0h */ case   10:  		/* bc 12, CR0_EQ, -160 */
		/* 820CA4B0h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CA410;  }
		/* 820CA4B0h case   10:*/		return 0x820CA4B4;
	}
	return 0x820CA4B4;
} // Block from 820CA488h-820CA4B4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA4B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA4B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA4B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA4B4);
		  /* 820CA4B4h */ case    0:  		/* mr R3, R31 */
		/* 820CA4B4h case    0:*/		regs.R3 = regs.R31;
		/* 820CA4B4h case    0:*/		return 0x820CA4B8;
	}
	return 0x820CA4B8;
} // Block from 820CA4B4h-820CA4B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA4B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA4B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA4B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA4B8);
		  /* 820CA4B8h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CA4B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CA4B8h case    0:*/		return 0x820CA4BC;
		  /* 820CA4BCh */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CA4BCh case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA4BCh case    1:*/		return 0x820CA4C0;
		  /* 820CA4C0h */ case    2:  		/* mtspr LR, R12 */
		/* 820CA4C0h case    2:*/		regs.LR = regs.R12;
		/* 820CA4C0h case    2:*/		return 0x820CA4C4;
		  /* 820CA4C4h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CA4C4h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA4C4h case    3:*/		return 0x820CA4C8;
		  /* 820CA4C8h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CA4C8h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA4C8h case    4:*/		return 0x820CA4CC;
		  /* 820CA4CCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CA4CCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA4CCh case    5:*/		return 0x820CA4D0;
	}
	return 0x820CA4D0;
} // Block from 820CA4B8h-820CA4D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CA4D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA4D0);
		  /* 820CA4D0h */ case    0:  		/* lis R10, -32255 */
		/* 820CA4D0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CA4D0h case    0:*/		return 0x820CA4D4;
		  /* 820CA4D4h */ case    1:  		/* stw R4, <#[R3 + 16]> */
		/* 820CA4D4h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA4D4h case    1:*/		return 0x820CA4D8;
		  /* 820CA4D8h */ case    2:  		/* li R11, 0 */
		/* 820CA4D8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CA4D8h case    2:*/		return 0x820CA4DC;
		  /* 820CA4DCh */ case    3:  		/* stw R5, <#[R3 + 20]> */
		/* 820CA4DCh case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820CA4DCh case    3:*/		return 0x820CA4E0;
		  /* 820CA4E0h */ case    4:  		/* li R9, 19 */
		/* 820CA4E0h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x13);
		/* 820CA4E0h case    4:*/		return 0x820CA4E4;
		  /* 820CA4E4h */ case    5:  		/* addi R10, R10, 10580 */
		/* 820CA4E4h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2954);
		/* 820CA4E4h case    5:*/		return 0x820CA4E8;
		  /* 820CA4E8h */ case    6:  		/* stw R11, <#[R3 + 8]> */
		/* 820CA4E8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CA4E8h case    6:*/		return 0x820CA4EC;
		  /* 820CA4ECh */ case    7:  		/* stw R9, <#[R3 + 4]> */
		/* 820CA4ECh case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA4ECh case    7:*/		return 0x820CA4F0;
		  /* 820CA4F0h */ case    8:  		/* stw R10, <#[R3]> */
		/* 820CA4F0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA4F0h case    8:*/		return 0x820CA4F4;
		  /* 820CA4F4h */ case    9:  		/* stw R11, <#[R3 + 12]> */
		/* 820CA4F4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CA4F4h case    9:*/		return 0x820CA4F8;
	}
	return 0x820CA4F8;
} // Block from 820CA4D0h-820CA4F8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CA4F8h
// Function '?Copy@CNodeProgram@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA4F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA4F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA4F8);
		  /* 820CA4F8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820CA4F8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA4F8h case    0:*/		return 0x820CA4FC;
	}
	return 0x820CA4FC;
} // Block from 820CA4F8h-820CA4FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA4FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA4FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA4FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA4FC);
		  /* 820CA4FCh */ case    0:  		/* nop */
		/* 820CA4FCh case    0:*/		cpu::op::nop();
		/* 820CA4FCh case    0:*/		return 0x820CA500;
	}
	return 0x820CA500;
} // Block from 820CA4FCh-820CA500h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA500);
		  /* 820CA500h */ case    0:  		/* mfspr R12, LR */
		/* 820CA500h case    0:*/		regs.R12 = regs.LR;
		/* 820CA500h case    0:*/		return 0x820CA504;
		  /* 820CA504h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CA504h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA504h case    1:*/		return 0x820CA508;
		  /* 820CA508h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CA508h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA508h case    2:*/		return 0x820CA50C;
		  /* 820CA50Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CA50Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA50Ch case    3:*/		return 0x820CA510;
		  /* 820CA510h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CA510h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CA510h case    4:*/		return 0x820CA514;
		  /* 820CA514h */ case    5:  		/* mr R30, R3 */
		/* 820CA514h case    5:*/		regs.R30 = regs.R3;
		/* 820CA514h case    5:*/		return 0x820CA518;
		  /* 820CA518h */ case    6:  		/* mr R31, R4 */
		/* 820CA518h case    6:*/		regs.R31 = regs.R4;
		/* 820CA518h case    6:*/		return 0x820CA51C;
		  /* 820CA51Ch */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820CA51Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CA51Ch case    7:*/		return 0x820CA520;
		  /* 820CA520h */ case    8:  		/* bc 12, CR6_EQ, 136 */
		/* 820CA520h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CA5A8;  }
		/* 820CA520h case    8:*/		return 0x820CA524;
		  /* 820CA524h */ case    9:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CA524h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CA524h case    9:*/		return 0x820CA528;
		  /* 820CA528h */ case   10:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CA528h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA528h case   10:*/		return 0x820CA52C;
		  /* 820CA52Ch */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820CA52Ch case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CA52Ch case   11:*/		return 0x820CA530;
		  /* 820CA530h */ case   12:  		/* bc 4, CR6_EQ, 120 */
		/* 820CA530h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CA5A8;  }
		/* 820CA530h case   12:*/		return 0x820CA534;
		  /* 820CA534h */ case   13:  		/* lwz R3, <#[R3 + 16]> */
		/* 820CA534h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA534h case   13:*/		return 0x820CA538;
		  /* 820CA538h */ case   14:  		/* lwz R4, <#[R4 + 16]> */
		/* 820CA538h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000010) );
		/* 820CA538h case   14:*/		return 0x820CA53C;
		  /* 820CA53Ch */ case   15:  		/* cmplwi CR6, R3, 0 */
		/* 820CA53Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CA53Ch case   15:*/		return 0x820CA540;
		  /* 820CA540h */ case   16:  		/* bc 12, CR6_EQ, 24 */
		/* 820CA540h case   16:*/		if ( regs.CR[6].eq ) { return 0x820CA558;  }
		/* 820CA540h case   16:*/		return 0x820CA544;
		  /* 820CA544h */ case   17:  		/* lwz R11, <#[R3]> */
		/* 820CA544h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA544h case   17:*/		return 0x820CA548;
		  /* 820CA548h */ case   18:  		/* lwz R11, <#[R11]> */
		/* 820CA548h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CA548h case   18:*/		return 0x820CA54C;
		  /* 820CA54Ch */ case   19:  		/* mtspr CTR, R11 */
		/* 820CA54Ch case   19:*/		regs.CTR = regs.R11;
		/* 820CA54Ch case   19:*/		return 0x820CA550;
		  /* 820CA550h */ case   20:  		/* bcctrl 20, CR0_LT */
		/* 820CA550h case   20:*/		if ( 1 ) { regs.LR = 0x820CA554; return (uint32)regs.CTR; }
		/* 820CA550h case   20:*/		return 0x820CA554;
		  /* 820CA554h */ case   21:  		/* b 16 */
		/* 820CA554h case   21:*/		return 0x820CA564;
		/* 820CA554h case   21:*/		return 0x820CA558;
	}
	return 0x820CA558;
} // Block from 820CA500h-820CA558h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820CA558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA558);
		  /* 820CA558h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CA558h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CA558h case    0:*/		return 0x820CA55C;
		  /* 820CA55Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CA55Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CA55Ch case    1:*/		return 0x820CA560;
		  /* 820CA560h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CA560h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CA560h case    2:*/		return 0x820CA564;
	}
	return 0x820CA564;
} // Block from 820CA558h-820CA564h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA564);
		  /* 820CA564h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CA564h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CA564h case    0:*/		return 0x820CA568;
		  /* 820CA568h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820CA568h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CA5A8;  }
		/* 820CA568h case    1:*/		return 0x820CA56C;
		  /* 820CA56Ch */ case    2:  		/* lwz R3, <#[R30 + 20]> */
		/* 820CA56Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000014) );
		/* 820CA56Ch case    2:*/		return 0x820CA570;
		  /* 820CA570h */ case    3:  		/* lwz R4, <#[R31 + 20]> */
		/* 820CA570h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000014) );
		/* 820CA570h case    3:*/		return 0x820CA574;
		  /* 820CA574h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CA574h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CA574h case    4:*/		return 0x820CA578;
		  /* 820CA578h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CA578h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CA590;  }
		/* 820CA578h case    5:*/		return 0x820CA57C;
		  /* 820CA57Ch */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CA57Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA57Ch case    6:*/		return 0x820CA580;
		  /* 820CA580h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CA580h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CA580h case    7:*/		return 0x820CA584;
		  /* 820CA584h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CA584h case    8:*/		regs.CTR = regs.R11;
		/* 820CA584h case    8:*/		return 0x820CA588;
		  /* 820CA588h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CA588h case    9:*/		if ( 1 ) { regs.LR = 0x820CA58C; return (uint32)regs.CTR; }
		/* 820CA588h case    9:*/		return 0x820CA58C;
		  /* 820CA58Ch */ case   10:  		/* b 16 */
		/* 820CA58Ch case   10:*/		return 0x820CA59C;
		/* 820CA58Ch case   10:*/		return 0x820CA590;
	}
	return 0x820CA590;
} // Block from 820CA564h-820CA590h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA590);
		  /* 820CA590h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CA590h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CA590h case    0:*/		return 0x820CA594;
		  /* 820CA594h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CA594h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CA594h case    1:*/		return 0x820CA598;
		  /* 820CA598h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CA598h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CA598h case    2:*/		return 0x820CA59C;
	}
	return 0x820CA59C;
} // Block from 820CA590h-820CA59Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA59Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA59C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA59C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA59C);
		  /* 820CA59Ch */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CA59Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CA59Ch case    0:*/		return 0x820CA5A0;
		  /* 820CA5A0h */ case    1:  		/* li R3, 1 */
		/* 820CA5A0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CA5A0h case    1:*/		return 0x820CA5A4;
		  /* 820CA5A4h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820CA5A4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CA5AC;  }
		/* 820CA5A4h case    2:*/		return 0x820CA5A8;
	}
	return 0x820CA5A8;
} // Block from 820CA59Ch-820CA5A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA5A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA5A8);
		  /* 820CA5A8h */ case    0:  		/* li R3, 0 */
		/* 820CA5A8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CA5A8h case    0:*/		return 0x820CA5AC;
	}
	return 0x820CA5AC;
} // Block from 820CA5A8h-820CA5ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA5ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA5AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA5AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA5AC);
		  /* 820CA5ACh */ case    0:  		/* addi R1, R1, 112 */
		/* 820CA5ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CA5ACh case    0:*/		return 0x820CA5B0;
		  /* 820CA5B0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CA5B0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA5B0h case    1:*/		return 0x820CA5B4;
		  /* 820CA5B4h */ case    2:  		/* mtspr LR, R12 */
		/* 820CA5B4h case    2:*/		regs.LR = regs.R12;
		/* 820CA5B4h case    2:*/		return 0x820CA5B8;
		  /* 820CA5B8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CA5B8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA5B8h case    3:*/		return 0x820CA5BC;
		  /* 820CA5BCh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CA5BCh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA5BCh case    4:*/		return 0x820CA5C0;
		  /* 820CA5C0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CA5C0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA5C0h case    5:*/		return 0x820CA5C4;
	}
	return 0x820CA5C4;
} // Block from 820CA5ACh-820CA5C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CA5C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA5C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA5C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA5C4);
		  /* 820CA5C4h */ case    0:  		/* nop */
		/* 820CA5C4h case    0:*/		cpu::op::nop();
		/* 820CA5C4h case    0:*/		return 0x820CA5C8;
	}
	return 0x820CA5C8;
} // Block from 820CA5C4h-820CA5C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA5C8);
		  /* 820CA5C8h */ case    0:  		/* mfspr R12, LR */
		/* 820CA5C8h case    0:*/		regs.R12 = regs.LR;
		/* 820CA5C8h case    0:*/		return 0x820CA5CC;
		  /* 820CA5CCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CA5CCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA5CCh case    1:*/		return 0x820CA5D0;
		  /* 820CA5D0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CA5D0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA5D0h case    2:*/		return 0x820CA5D4;
		  /* 820CA5D4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CA5D4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA5D4h case    3:*/		return 0x820CA5D8;
		  /* 820CA5D8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CA5D8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CA5D8h case    4:*/		return 0x820CA5DC;
		  /* 820CA5DCh */ case    5:  		/* mr R30, R3 */
		/* 820CA5DCh case    5:*/		regs.R30 = regs.R3;
		/* 820CA5DCh case    5:*/		return 0x820CA5E0;
		  /* 820CA5E0h */ case    6:  		/* bl 10832 */
		/* 820CA5E0h case    6:*/		regs.LR = 0x820CA5E4; return 0x820CD030;
		/* 820CA5E0h case    6:*/		return 0x820CA5E4;
		  /* 820CA5E4h */ case    7:  		/* li R5, 16 */
		/* 820CA5E4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CA5E4h case    7:*/		return 0x820CA5E8;
		  /* 820CA5E8h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CA5E8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA5E8h case    8:*/		return 0x820CA5EC;
		  /* 820CA5ECh */ case    9:  		/* li R4, 24 */
		/* 820CA5ECh case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 820CA5ECh case    9:*/		return 0x820CA5F0;
		  /* 820CA5F0h */ case   10:  		/* bl -5392 */
		/* 820CA5F0h case   10:*/		regs.LR = 0x820CA5F4; return 0x820C90E0;
		/* 820CA5F0h case   10:*/		return 0x820CA5F4;
		  /* 820CA5F4h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CA5F4h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA5F4h case   11:*/		return 0x820CA5F8;
		  /* 820CA5F8h */ case   12:  		/* bc 12, CR0_EQ, 52 */
		/* 820CA5F8h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CA62C;  }
		/* 820CA5F8h case   12:*/		return 0x820CA5FC;
		  /* 820CA5FCh */ case   13:  		/* lis R10, -32255 */
		/* 820CA5FCh case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CA5FCh case   13:*/		return 0x820CA600;
	}
	return 0x820CA600;
} // Block from 820CA5C8h-820CA600h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820CA600h
// Function '??0CNodeScope@D3DXShader@@QAA@W4_D3DSCOPE_TYPE@1@PBDPAVCNode@1@PAVCNodeTree@1@PAV01@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA600);
		  /* 820CA600h */ case    0:  		/* li R11, 0 */
		/* 820CA600h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CA600h case    0:*/		return 0x820CA604;
		  /* 820CA604h */ case    1:  		/* li R9, 19 */
		/* 820CA604h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x13);
		/* 820CA604h case    1:*/		return 0x820CA608;
		  /* 820CA608h */ case    2:  		/* addi R10, R10, 10580 */
		/* 820CA608h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2954);
		/* 820CA608h case    2:*/		return 0x820CA60C;
		  /* 820CA60Ch */ case    3:  		/* stw R11, <#[R3 + 8]> */
		/* 820CA60Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CA60Ch case    3:*/		return 0x820CA610;
		  /* 820CA610h */ case    4:  		/* stw R9, <#[R3 + 4]> */
		/* 820CA610h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA610h case    4:*/		return 0x820CA614;
		  /* 820CA614h */ case    5:  		/* mr R31, R3 */
		/* 820CA614h case    5:*/		regs.R31 = regs.R3;
		/* 820CA614h case    5:*/		return 0x820CA618;
		  /* 820CA618h */ case    6:  		/* stw R10, <#[R3]> */
		/* 820CA618h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA618h case    6:*/		return 0x820CA61C;
		  /* 820CA61Ch */ case    7:  		/* stw R11, <#[R3 + 12]> */
		/* 820CA61Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CA61Ch case    7:*/		return 0x820CA620;
		  /* 820CA620h */ case    8:  		/* stw R11, <#[R3 + 16]> */
		/* 820CA620h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA620h case    8:*/		return 0x820CA624;
		  /* 820CA624h */ case    9:  		/* stw R11, <#[R3 + 20]> */
		/* 820CA624h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CA624h case    9:*/		return 0x820CA628;
		  /* 820CA628h */ case   10:  		/* b 8 */
		/* 820CA628h case   10:*/		return 0x820CA630;
		/* 820CA628h case   10:*/		return 0x820CA62C;
	}
	return 0x820CA62C;
} // Block from 820CA600h-820CA62Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA62Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA62C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA62C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA62C);
		  /* 820CA62Ch */ case    0:  		/* li R31, 0 */
		/* 820CA62Ch case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CA62Ch case    0:*/		return 0x820CA630;
	}
	return 0x820CA630;
} // Block from 820CA62Ch-820CA630h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA630);
		  /* 820CA630h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CA630h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CA630h case    0:*/		return 0x820CA634;
		  /* 820CA634h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CA634h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CA640;  }
		/* 820CA634h case    1:*/		return 0x820CA638;
	}
	return 0x820CA638;
} // Block from 820CA630h-820CA638h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CA638h
// Function '?IsEqual@CNodeScope@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA638);
		  /* 820CA638h */ case    0:  		/* li R3, 0 */
		/* 820CA638h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CA638h case    0:*/		return 0x820CA63C;
		  /* 820CA63Ch */ case    1:  		/* b 96 */
		/* 820CA63Ch case    1:*/		return 0x820CA69C;
		/* 820CA63Ch case    1:*/		return 0x820CA640;
	}
	return 0x820CA640;
} // Block from 820CA638h-820CA640h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CA640h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA640);
		  /* 820CA640h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CA640h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CA640h case    0:*/		return 0x820CA644;
		  /* 820CA644h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CA644h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CA644h case    1:*/		return 0x820CA648;
		  /* 820CA648h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CA648h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CA66C;  }
		/* 820CA648h case    2:*/		return 0x820CA64C;
		  /* 820CA64Ch */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CA64Ch case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CA64Ch case    3:*/		return 0x820CA650;
		  /* 820CA650h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CA650h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA650h case    4:*/		return 0x820CA654;
		  /* 820CA654h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CA654h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CA654h case    5:*/		return 0x820CA658;
		  /* 820CA658h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CA658h case    6:*/		regs.CTR = regs.R11;
		/* 820CA658h case    6:*/		return 0x820CA65C;
		  /* 820CA65Ch */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CA65Ch case    7:*/		if ( 1 ) { regs.LR = 0x820CA660; return (uint32)regs.CTR; }
		/* 820CA65Ch case    7:*/		return 0x820CA660;
		  /* 820CA660h */ case    8:  		/* stw R3, <#[R31 + 16]> */
		/* 820CA660h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820CA660h case    8:*/		return 0x820CA664;
		  /* 820CA664h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CA664h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA664h case    9:*/		return 0x820CA668;
		  /* 820CA668h */ case   10:  		/* bc 12, CR0_EQ, -48 */
		/* 820CA668h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CA638;  }
		/* 820CA668h case   10:*/		return 0x820CA66C;
	}
	return 0x820CA66C;
} // Block from 820CA640h-820CA66Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA66Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA66C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA66C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA66C);
		  /* 820CA66Ch */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CA66Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CA66Ch case    0:*/		return 0x820CA670;
		  /* 820CA670h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CA670h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CA670h case    1:*/		return 0x820CA674;
		  /* 820CA674h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CA674h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CA698;  }
		/* 820CA674h case    2:*/		return 0x820CA678;
		  /* 820CA678h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CA678h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CA678h case    3:*/		return 0x820CA67C;
		  /* 820CA67Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CA67Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA67Ch case    4:*/		return 0x820CA680;
		  /* 820CA680h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CA680h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CA680h case    5:*/		return 0x820CA684;
		  /* 820CA684h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CA684h case    6:*/		regs.CTR = regs.R11;
		/* 820CA684h case    6:*/		return 0x820CA688;
		  /* 820CA688h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CA688h case    7:*/		if ( 1 ) { regs.LR = 0x820CA68C; return (uint32)regs.CTR; }
		/* 820CA688h case    7:*/		return 0x820CA68C;
		  /* 820CA68Ch */ case    8:  		/* stw R3, <#[R31 + 20]> */
		/* 820CA68Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820CA68Ch case    8:*/		return 0x820CA690;
		  /* 820CA690h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CA690h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA690h case    9:*/		return 0x820CA694;
		  /* 820CA694h */ case   10:  		/* bc 12, CR0_EQ, -92 */
		/* 820CA694h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CA638;  }
		/* 820CA694h case   10:*/		return 0x820CA698;
	}
	return 0x820CA698;
} // Block from 820CA66Ch-820CA698h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA698);
		  /* 820CA698h */ case    0:  		/* mr R3, R31 */
		/* 820CA698h case    0:*/		regs.R3 = regs.R31;
		/* 820CA698h case    0:*/		return 0x820CA69C;
	}
	return 0x820CA69C;
} // Block from 820CA698h-820CA69Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA69Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA69C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA69C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA69C);
		  /* 820CA69Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 820CA69Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CA69Ch case    0:*/		return 0x820CA6A0;
		  /* 820CA6A0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CA6A0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA6A0h case    1:*/		return 0x820CA6A4;
		  /* 820CA6A4h */ case    2:  		/* mtspr LR, R12 */
		/* 820CA6A4h case    2:*/		regs.LR = regs.R12;
		/* 820CA6A4h case    2:*/		return 0x820CA6A8;
		  /* 820CA6A8h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CA6A8h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA6A8h case    3:*/		return 0x820CA6AC;
		  /* 820CA6ACh */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CA6ACh case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA6ACh case    4:*/		return 0x820CA6B0;
		  /* 820CA6B0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CA6B0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA6B0h case    5:*/		return 0x820CA6B4;
	}
	return 0x820CA6B4;
} // Block from 820CA69Ch-820CA6B4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CA6B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA6B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA6B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA6B4);
		  /* 820CA6B4h */ case    0:  		/* nop */
		/* 820CA6B4h case    0:*/		cpu::op::nop();
		/* 820CA6B4h case    0:*/		return 0x820CA6B8;
		  /* 820CA6B8h */ case    1:  		/* lis R10, -32255 */
		/* 820CA6B8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CA6B8h case    1:*/		return 0x820CA6BC;
		  /* 820CA6BCh */ case    2:  		/* stw R4, <#[R3 + 16]> */
		/* 820CA6BCh case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA6BCh case    2:*/		return 0x820CA6C0;
		  /* 820CA6C0h */ case    3:  		/* li R11, 0 */
		/* 820CA6C0h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CA6C0h case    3:*/		return 0x820CA6C4;
		  /* 820CA6C4h */ case    4:  		/* li R9, 20 */
		/* 820CA6C4h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 820CA6C4h case    4:*/		return 0x820CA6C8;
		  /* 820CA6C8h */ case    5:  		/* addi R10, R10, 10592 */
		/* 820CA6C8h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2960);
		/* 820CA6C8h case    5:*/		return 0x820CA6CC;
		  /* 820CA6CCh */ case    6:  		/* stw R11, <#[R3 + 8]> */
		/* 820CA6CCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CA6CCh case    6:*/		return 0x820CA6D0;
		  /* 820CA6D0h */ case    7:  		/* stw R9, <#[R3 + 4]> */
		/* 820CA6D0h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA6D0h case    7:*/		return 0x820CA6D4;
		  /* 820CA6D4h */ case    8:  		/* stw R10, <#[R3]> */
		/* 820CA6D4h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA6D4h case    8:*/		return 0x820CA6D8;
		  /* 820CA6D8h */ case    9:  		/* stw R11, <#[R3 + 12]> */
		/* 820CA6D8h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CA6D8h case    9:*/		return 0x820CA6DC;
		  /* 820CA6DCh */ case   10:  		/* bclr 20, CR0_LT */
		/* 820CA6DCh case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA6DCh case   10:*/		return 0x820CA6E0;
	}
	return 0x820CA6E0;
} // Block from 820CA6B4h-820CA6E0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA6E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA6E0);
		  /* 820CA6E0h */ case    0:  		/* mfspr R12, LR */
		/* 820CA6E0h case    0:*/		regs.R12 = regs.LR;
		/* 820CA6E0h case    0:*/		return 0x820CA6E4;
		  /* 820CA6E4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CA6E4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA6E4h case    1:*/		return 0x820CA6E8;
		  /* 820CA6E8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CA6E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CA6E8h case    2:*/		return 0x820CA6EC;
		  /* 820CA6ECh */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 820CA6ECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CA6ECh case    3:*/		return 0x820CA6F0;
		  /* 820CA6F0h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 820CA6F0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CA704;  }
		/* 820CA6F0h case    4:*/		return 0x820CA6F4;
		  /* 820CA6F4h */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CA6F4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CA6F4h case    5:*/		return 0x820CA6F8;
		  /* 820CA6F8h */ case    6:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CA6F8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA6F8h case    6:*/		return 0x820CA6FC;
		  /* 820CA6FCh */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 820CA6FCh case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CA6FCh case    7:*/		return 0x820CA700;
		  /* 820CA700h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 820CA700h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CA70C;  }
		/* 820CA700h case    8:*/		return 0x820CA704;
	}
	return 0x820CA704;
} // Block from 820CA6E0h-820CA704h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CA704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA704);
		  /* 820CA704h */ case    0:  		/* li R3, 0 */
		/* 820CA704h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CA704h case    0:*/		return 0x820CA708;
		  /* 820CA708h */ case    1:  		/* b 60 */
		/* 820CA708h case    1:*/		return 0x820CA744;
		/* 820CA708h case    1:*/		return 0x820CA70C;
	}
	return 0x820CA70C;
} // Block from 820CA704h-820CA70Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CA70Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA70C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA70C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA70C);
		  /* 820CA70Ch */ case    0:  		/* lwz R3, <#[R3 + 16]> */
		/* 820CA70Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA70Ch case    0:*/		return 0x820CA710;
		  /* 820CA710h */ case    1:  		/* lwz R4, <#[R4 + 16]> */
		/* 820CA710h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000010) );
		/* 820CA710h case    1:*/		return 0x820CA714;
		  /* 820CA714h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 820CA714h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CA714h case    2:*/		return 0x820CA718;
		  /* 820CA718h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 820CA718h case    3:*/		if ( regs.CR[6].eq ) { return 0x820CA730;  }
		/* 820CA718h case    3:*/		return 0x820CA71C;
		  /* 820CA71Ch */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CA71Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA71Ch case    4:*/		return 0x820CA720;
		  /* 820CA720h */ case    5:  		/* lwz R11, <#[R11]> */
		/* 820CA720h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CA720h case    5:*/		return 0x820CA724;
		  /* 820CA724h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CA724h case    6:*/		regs.CTR = regs.R11;
		/* 820CA724h case    6:*/		return 0x820CA728;
		  /* 820CA728h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CA728h case    7:*/		if ( 1 ) { regs.LR = 0x820CA72C; return (uint32)regs.CTR; }
		/* 820CA728h case    7:*/		return 0x820CA72C;
		  /* 820CA72Ch */ case    8:  		/* b 16 */
		/* 820CA72Ch case    8:*/		return 0x820CA73C;
		/* 820CA72Ch case    8:*/		return 0x820CA730;
	}
	return 0x820CA730;
} // Block from 820CA70Ch-820CA730h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CA730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA730);
		  /* 820CA730h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CA730h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CA730h case    0:*/		return 0x820CA734;
		  /* 820CA734h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CA734h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CA734h case    1:*/		return 0x820CA738;
		  /* 820CA738h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CA738h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CA738h case    2:*/		return 0x820CA73C;
	}
	return 0x820CA73C;
} // Block from 820CA730h-820CA73Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA73Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA73C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA73C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA73C);
		  /* 820CA73Ch */ case    0:  		/* addic R11, R3, -1 */
		/* 820CA73Ch case    0:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 820CA73Ch case    0:*/		return 0x820CA740;
		  /* 820CA740h */ case    1:  		/* subfe R3, R11, R3 */
		/* 820CA740h case    1:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820CA740h case    1:*/		return 0x820CA744;
	}
	return 0x820CA744;
} // Block from 820CA73Ch-820CA744h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CA744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA744);
		  /* 820CA744h */ case    0:  		/* addi R1, R1, 96 */
		/* 820CA744h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CA744h case    0:*/		return 0x820CA748;
		  /* 820CA748h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CA748h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA748h case    1:*/		return 0x820CA74C;
		  /* 820CA74Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CA74Ch case    2:*/		regs.LR = regs.R12;
		/* 820CA74Ch case    2:*/		return 0x820CA750;
		  /* 820CA750h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820CA750h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA750h case    3:*/		return 0x820CA754;
	}
	return 0x820CA754;
} // Block from 820CA744h-820CA754h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CA754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA754);
		  /* 820CA754h */ case    0:  		/* nop */
		/* 820CA754h case    0:*/		cpu::op::nop();
		/* 820CA754h case    0:*/		return 0x820CA758;
	}
	return 0x820CA758;
} // Block from 820CA754h-820CA758h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA758h
// Function '?Copy@CNodeScope@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA758);
		  /* 820CA758h */ case    0:  		/* mfspr R12, LR */
		/* 820CA758h case    0:*/		regs.R12 = regs.LR;
		/* 820CA758h case    0:*/		return 0x820CA75C;
		  /* 820CA75Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CA75Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA75Ch case    1:*/		return 0x820CA760;
		  /* 820CA760h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CA760h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA760h case    2:*/		return 0x820CA764;
		  /* 820CA764h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CA764h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA764h case    3:*/		return 0x820CA768;
		  /* 820CA768h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CA768h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CA768h case    4:*/		return 0x820CA76C;
		  /* 820CA76Ch */ case    5:  		/* mr R30, R3 */
		/* 820CA76Ch case    5:*/		regs.R30 = regs.R3;
		/* 820CA76Ch case    5:*/		return 0x820CA770;
		  /* 820CA770h */ case    6:  		/* bl 10432 */
		/* 820CA770h case    6:*/		regs.LR = 0x820CA774; return 0x820CD030;
		/* 820CA770h case    6:*/		return 0x820CA774;
		  /* 820CA774h */ case    7:  		/* li R5, 16 */
		/* 820CA774h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CA774h case    7:*/		return 0x820CA778;
		  /* 820CA778h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CA778h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA778h case    8:*/		return 0x820CA77C;
		  /* 820CA77Ch */ case    9:  		/* li R4, 20 */
		/* 820CA77Ch case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 820CA77Ch case    9:*/		return 0x820CA780;
		  /* 820CA780h */ case   10:  		/* bl -5792 */
		/* 820CA780h case   10:*/		regs.LR = 0x820CA784; return 0x820C90E0;
		/* 820CA780h case   10:*/		return 0x820CA784;
		  /* 820CA784h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CA784h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA784h case   11:*/		return 0x820CA788;
		  /* 820CA788h */ case   12:  		/* bc 12, CR0_EQ, 48 */
		/* 820CA788h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CA7B8;  }
		/* 820CA788h case   12:*/		return 0x820CA78C;
		  /* 820CA78Ch */ case   13:  		/* lis R10, -32255 */
		/* 820CA78Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CA78Ch case   13:*/		return 0x820CA790;
		  /* 820CA790h */ case   14:  		/* li R11, 0 */
		/* 820CA790h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CA790h case   14:*/		return 0x820CA794;
		  /* 820CA794h */ case   15:  		/* li R9, 20 */
		/* 820CA794h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 820CA794h case   15:*/		return 0x820CA798;
		  /* 820CA798h */ case   16:  		/* addi R10, R10, 10592 */
		/* 820CA798h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2960);
		/* 820CA798h case   16:*/		return 0x820CA79C;
		  /* 820CA79Ch */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 820CA79Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CA79Ch case   17:*/		return 0x820CA7A0;
		  /* 820CA7A0h */ case   18:  		/* stw R9, <#[R3 + 4]> */
		/* 820CA7A0h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA7A0h case   18:*/		return 0x820CA7A4;
		  /* 820CA7A4h */ case   19:  		/* mr R31, R3 */
		/* 820CA7A4h case   19:*/		regs.R31 = regs.R3;
		/* 820CA7A4h case   19:*/		return 0x820CA7A8;
		  /* 820CA7A8h */ case   20:  		/* stw R10, <#[R3]> */
		/* 820CA7A8h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA7A8h case   20:*/		return 0x820CA7AC;
		  /* 820CA7ACh */ case   21:  		/* stw R11, <#[R3 + 12]> */
		/* 820CA7ACh case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CA7ACh case   21:*/		return 0x820CA7B0;
		  /* 820CA7B0h */ case   22:  		/* stw R11, <#[R3 + 16]> */
		/* 820CA7B0h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA7B0h case   22:*/		return 0x820CA7B4;
		  /* 820CA7B4h */ case   23:  		/* b 8 */
		/* 820CA7B4h case   23:*/		return 0x820CA7BC;
		/* 820CA7B4h case   23:*/		return 0x820CA7B8;
	}
	return 0x820CA7B8;
} // Block from 820CA758h-820CA7B8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820CA7B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA7B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA7B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA7B8);
		  /* 820CA7B8h */ case    0:  		/* li R31, 0 */
		/* 820CA7B8h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CA7B8h case    0:*/		return 0x820CA7BC;
	}
	return 0x820CA7BC;
} // Block from 820CA7B8h-820CA7BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA7BC);
		  /* 820CA7BCh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CA7BCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CA7BCh case    0:*/		return 0x820CA7C0;
		  /* 820CA7C0h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CA7C0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CA7CC;  }
		/* 820CA7C0h case    1:*/		return 0x820CA7C4;
		  /* 820CA7C4h */ case    2:  		/* li R3, 0 */
		/* 820CA7C4h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CA7C4h case    2:*/		return 0x820CA7C8;
		  /* 820CA7C8h */ case    3:  		/* b 56 */
		/* 820CA7C8h case    3:*/		return 0x820CA800;
		/* 820CA7C8h case    3:*/		return 0x820CA7CC;
	}
	return 0x820CA7CC;
} // Block from 820CA7BCh-820CA7CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CA7CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA7CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA7CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA7CC);
		  /* 820CA7CCh */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CA7CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CA7CCh case    0:*/		return 0x820CA7D0;
		  /* 820CA7D0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CA7D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CA7D0h case    1:*/		return 0x820CA7D4;
		  /* 820CA7D4h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 820CA7D4h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CA7FC;  }
		/* 820CA7D4h case    2:*/		return 0x820CA7D8;
		  /* 820CA7D8h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CA7D8h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CA7D8h case    3:*/		return 0x820CA7DC;
		  /* 820CA7DCh */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CA7DCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA7DCh case    4:*/		return 0x820CA7E0;
		  /* 820CA7E0h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CA7E0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CA7E0h case    5:*/		return 0x820CA7E4;
		  /* 820CA7E4h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CA7E4h case    6:*/		regs.CTR = regs.R11;
		/* 820CA7E4h case    6:*/		return 0x820CA7E8;
		  /* 820CA7E8h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CA7E8h case    7:*/		if ( 1 ) { regs.LR = 0x820CA7EC; return (uint32)regs.CTR; }
		/* 820CA7E8h case    7:*/		return 0x820CA7EC;
		  /* 820CA7ECh */ case    8:  		/* stw R3, <#[R31 + 16]> */
		/* 820CA7ECh case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820CA7ECh case    8:*/		return 0x820CA7F0;
		  /* 820CA7F0h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CA7F0h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA7F0h case    9:*/		return 0x820CA7F4;
		  /* 820CA7F4h */ case   10:  		/* li R3, 0 */
		/* 820CA7F4h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CA7F4h case   10:*/		return 0x820CA7F8;
		  /* 820CA7F8h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 820CA7F8h case   11:*/		if ( regs.CR[0].eq ) { return 0x820CA800;  }
		/* 820CA7F8h case   11:*/		return 0x820CA7FC;
	}
	return 0x820CA7FC;
} // Block from 820CA7CCh-820CA7FCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 820CA7FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA7FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA7FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA7FC);
		  /* 820CA7FCh */ case    0:  		/* mr R3, R31 */
		/* 820CA7FCh case    0:*/		regs.R3 = regs.R31;
		/* 820CA7FCh case    0:*/		return 0x820CA800;
	}
	return 0x820CA800;
} // Block from 820CA7FCh-820CA800h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA800);
		  /* 820CA800h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CA800h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CA800h case    0:*/		return 0x820CA804;
		  /* 820CA804h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CA804h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA804h case    1:*/		return 0x820CA808;
		  /* 820CA808h */ case    2:  		/* mtspr LR, R12 */
		/* 820CA808h case    2:*/		regs.LR = regs.R12;
		/* 820CA808h case    2:*/		return 0x820CA80C;
		  /* 820CA80Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CA80Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA80Ch case    3:*/		return 0x820CA810;
		  /* 820CA810h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CA810h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA810h case    4:*/		return 0x820CA814;
		  /* 820CA814h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CA814h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA814h case    5:*/		return 0x820CA818;
	}
	return 0x820CA818;
} // Block from 820CA800h-820CA818h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CA818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA818);
		  /* 820CA818h */ case    0:  		/* lis R10, -32255 */
		/* 820CA818h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CA818h case    0:*/		return 0x820CA81C;
		  /* 820CA81Ch */ case    1:  		/* stw R4, <#[R3 + 16]> */
		/* 820CA81Ch case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA81Ch case    1:*/		return 0x820CA820;
		  /* 820CA820h */ case    2:  		/* li R11, 0 */
		/* 820CA820h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CA820h case    2:*/		return 0x820CA824;
		  /* 820CA824h */ case    3:  		/* stw R5, <#[R3 + 20]> */
		/* 820CA824h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820CA824h case    3:*/		return 0x820CA828;
		  /* 820CA828h */ case    4:  		/* li R9, 7 */
		/* 820CA828h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x7);
		/* 820CA828h case    4:*/		return 0x820CA82C;
		  /* 820CA82Ch */ case    5:  		/* stw R6, <#[R3 + 24]> */
		/* 820CA82Ch case    5:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000018) );
		/* 820CA82Ch case    5:*/		return 0x820CA830;
		  /* 820CA830h */ case    6:  		/* addi R10, R10, 10604 */
		/* 820CA830h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x296C);
		/* 820CA830h case    6:*/		return 0x820CA834;
		  /* 820CA834h */ case    7:  		/* stw R11, <#[R3 + 8]> */
		/* 820CA834h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CA834h case    7:*/		return 0x820CA838;
		  /* 820CA838h */ case    8:  		/* stw R9, <#[R3 + 4]> */
		/* 820CA838h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA838h case    8:*/		return 0x820CA83C;
		  /* 820CA83Ch */ case    9:  		/* stw R10, <#[R3]> */
		/* 820CA83Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA83Ch case    9:*/		return 0x820CA840;
		  /* 820CA840h */ case   10:  		/* stw R11, <#[R3 + 12]> */
		/* 820CA840h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CA840h case   10:*/		return 0x820CA844;
		  /* 820CA844h */ case   11:  		/* stw R11, <#[R3 + 28]> */
		/* 820CA844h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CA844h case   11:*/		return 0x820CA848;
		  /* 820CA848h */ case   12:  		/* bclr 20, CR0_LT */
		/* 820CA848h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA848h case   12:*/		return 0x820CA84C;
	}
	return 0x820CA84C;
} // Block from 820CA818h-820CA84Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CA84Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA84C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA84C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA84C);
		  /* 820CA84Ch */ case    0:  		/* nop */
		/* 820CA84Ch case    0:*/		cpu::op::nop();
		/* 820CA84Ch case    0:*/		return 0x820CA850;
	}
	return 0x820CA850;
} // Block from 820CA84Ch-820CA850h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA850);
		  /* 820CA850h */ case    0:  		/* mfspr R12, LR */
		/* 820CA850h case    0:*/		regs.R12 = regs.LR;
		/* 820CA850h case    0:*/		return 0x820CA854;
		  /* 820CA854h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CA854h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA854h case    1:*/		return 0x820CA858;
		  /* 820CA858h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CA858h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA858h case    2:*/		return 0x820CA85C;
		  /* 820CA85Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CA85Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA85Ch case    3:*/		return 0x820CA860;
		  /* 820CA860h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CA860h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CA860h case    4:*/		return 0x820CA864;
		  /* 820CA864h */ case    5:  		/* mr R30, R3 */
		/* 820CA864h case    5:*/		regs.R30 = regs.R3;
		/* 820CA864h case    5:*/		return 0x820CA868;
		  /* 820CA868h */ case    6:  		/* mr R31, R4 */
		/* 820CA868h case    6:*/		regs.R31 = regs.R4;
		/* 820CA868h case    6:*/		return 0x820CA86C;
		  /* 820CA86Ch */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 820CA86Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CA86Ch case    7:*/		return 0x820CA870;
		  /* 820CA870h */ case    8:  		/* bc 12, CR6_EQ, 208 */
		/* 820CA870h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CA940;  }
		/* 820CA870h case    8:*/		return 0x820CA874;
		  /* 820CA874h */ case    9:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CA874h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CA874h case    9:*/		return 0x820CA878;
		  /* 820CA878h */ case   10:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CA878h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA878h case   10:*/		return 0x820CA87C;
		  /* 820CA87Ch */ case   11:  		/* cmpw CR6, R11, R10 */
		/* 820CA87Ch case   11:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CA87Ch case   11:*/		return 0x820CA880;
		  /* 820CA880h */ case   12:  		/* bc 4, CR6_EQ, 192 */
		/* 820CA880h case   12:*/		if ( !regs.CR[6].eq ) { return 0x820CA940;  }
		/* 820CA880h case   12:*/		return 0x820CA884;
		  /* 820CA884h */ case   13:  		/* lwz R11, <#[R3 + 16]> */
		/* 820CA884h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA884h case   13:*/		return 0x820CA888;
		  /* 820CA888h */ case   14:  		/* lwz R10, <#[R4 + 16]> */
		/* 820CA888h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 820CA888h case   14:*/		return 0x820CA88C;
		  /* 820CA88Ch */ case   15:  		/* cmplw CR6, R11, R10 */
		/* 820CA88Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CA88Ch case   15:*/		return 0x820CA890;
	}
	return 0x820CA890;
} // Block from 820CA850h-820CA890h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820CA890h
// Function '??0CNodeDecl@D3DXShader@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA890);
		  /* 820CA890h */ case    0:  		/* bc 4, CR6_EQ, 176 */
		/* 820CA890h case    0:*/		if ( !regs.CR[6].eq ) { return 0x820CA940;  }
		/* 820CA890h case    0:*/		return 0x820CA894;
		  /* 820CA894h */ case    1:  		/* lwz R3, <#[R3 + 20]> */
		/* 820CA894h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000014) );
		/* 820CA894h case    1:*/		return 0x820CA898;
		  /* 820CA898h */ case    2:  		/* lwz R4, <#[R4 + 20]> */
		/* 820CA898h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000014) );
		/* 820CA898h case    2:*/		return 0x820CA89C;
		  /* 820CA89Ch */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 820CA89Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CA89Ch case    3:*/		return 0x820CA8A0;
		  /* 820CA8A0h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 820CA8A0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CA8B8;  }
		/* 820CA8A0h case    4:*/		return 0x820CA8A4;
		  /* 820CA8A4h */ case    5:  		/* lwz R11, <#[R3]> */
		/* 820CA8A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA8A4h case    5:*/		return 0x820CA8A8;
		  /* 820CA8A8h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 820CA8A8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CA8A8h case    6:*/		return 0x820CA8AC;
		  /* 820CA8ACh */ case    7:  		/* mtspr CTR, R11 */
		/* 820CA8ACh case    7:*/		regs.CTR = regs.R11;
		/* 820CA8ACh case    7:*/		return 0x820CA8B0;
		  /* 820CA8B0h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 820CA8B0h case    8:*/		if ( 1 ) { regs.LR = 0x820CA8B4; return (uint32)regs.CTR; }
		/* 820CA8B0h case    8:*/		return 0x820CA8B4;
		  /* 820CA8B4h */ case    9:  		/* b 16 */
		/* 820CA8B4h case    9:*/		return 0x820CA8C4;
		/* 820CA8B4h case    9:*/		return 0x820CA8B8;
	}
	return 0x820CA8B8;
} // Block from 820CA890h-820CA8B8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820CA8B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA8B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA8B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA8B8);
		  /* 820CA8B8h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CA8B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CA8B8h case    0:*/		return 0x820CA8BC;
		  /* 820CA8BCh */ case    1:  		/* cntlzw R11, R11 */
		/* 820CA8BCh case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CA8BCh case    1:*/		return 0x820CA8C0;
		  /* 820CA8C0h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CA8C0h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CA8C0h case    2:*/		return 0x820CA8C4;
	}
	return 0x820CA8C4;
} // Block from 820CA8B8h-820CA8C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA8C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA8C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA8C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA8C4);
		  /* 820CA8C4h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CA8C4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CA8C4h case    0:*/		return 0x820CA8C8;
		  /* 820CA8C8h */ case    1:  		/* bc 12, CR6_EQ, 120 */
		/* 820CA8C8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CA940;  }
		/* 820CA8C8h case    1:*/		return 0x820CA8CC;
		  /* 820CA8CCh */ case    2:  		/* lwz R3, <#[R30 + 24]> */
		/* 820CA8CCh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000018) );
		/* 820CA8CCh case    2:*/		return 0x820CA8D0;
		  /* 820CA8D0h */ case    3:  		/* lwz R4, <#[R31 + 24]> */
		/* 820CA8D0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000018) );
		/* 820CA8D0h case    3:*/		return 0x820CA8D4;
		  /* 820CA8D4h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CA8D4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CA8D4h case    4:*/		return 0x820CA8D8;
		  /* 820CA8D8h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CA8D8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CA8F0;  }
		/* 820CA8D8h case    5:*/		return 0x820CA8DC;
		  /* 820CA8DCh */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CA8DCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA8DCh case    6:*/		return 0x820CA8E0;
	}
	return 0x820CA8E0;
} // Block from 820CA8C4h-820CA8E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820CA8E0h
// Function '??0CNodeDecl@D3DXShader@@QAA@W4_D3DDECL_TYPE@1@PAVCNode@1@111@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA8E0);
		  /* 820CA8E0h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 820CA8E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CA8E0h case    0:*/		return 0x820CA8E4;
		  /* 820CA8E4h */ case    1:  		/* mtspr CTR, R11 */
		/* 820CA8E4h case    1:*/		regs.CTR = regs.R11;
		/* 820CA8E4h case    1:*/		return 0x820CA8E8;
		  /* 820CA8E8h */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 820CA8E8h case    2:*/		if ( 1 ) { regs.LR = 0x820CA8EC; return (uint32)regs.CTR; }
		/* 820CA8E8h case    2:*/		return 0x820CA8EC;
		  /* 820CA8ECh */ case    3:  		/* b 16 */
		/* 820CA8ECh case    3:*/		return 0x820CA8FC;
		/* 820CA8ECh case    3:*/		return 0x820CA8F0;
	}
	return 0x820CA8F0;
} // Block from 820CA8E0h-820CA8F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CA8F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA8F0);
		  /* 820CA8F0h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CA8F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CA8F0h case    0:*/		return 0x820CA8F4;
		  /* 820CA8F4h */ case    1:  		/* cntlzw R11, R11 */
		/* 820CA8F4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CA8F4h case    1:*/		return 0x820CA8F8;
		  /* 820CA8F8h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CA8F8h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CA8F8h case    2:*/		return 0x820CA8FC;
	}
	return 0x820CA8FC;
} // Block from 820CA8F0h-820CA8FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA8FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA8FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA8FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA8FC);
		  /* 820CA8FCh */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CA8FCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CA8FCh case    0:*/		return 0x820CA900;
		  /* 820CA900h */ case    1:  		/* bc 12, CR6_EQ, 64 */
		/* 820CA900h case    1:*/		if ( regs.CR[6].eq ) { return 0x820CA940;  }
		/* 820CA900h case    1:*/		return 0x820CA904;
		  /* 820CA904h */ case    2:  		/* lwz R3, <#[R30 + 28]> */
		/* 820CA904h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CA904h case    2:*/		return 0x820CA908;
		  /* 820CA908h */ case    3:  		/* lwz R4, <#[R31 + 28]> */
		/* 820CA908h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CA908h case    3:*/		return 0x820CA90C;
		  /* 820CA90Ch */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 820CA90Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CA90Ch case    4:*/		return 0x820CA910;
		  /* 820CA910h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 820CA910h case    5:*/		if ( regs.CR[6].eq ) { return 0x820CA928;  }
		/* 820CA910h case    5:*/		return 0x820CA914;
		  /* 820CA914h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CA914h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA914h case    6:*/		return 0x820CA918;
		  /* 820CA918h */ case    7:  		/* lwz R11, <#[R11]> */
		/* 820CA918h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CA918h case    7:*/		return 0x820CA91C;
		  /* 820CA91Ch */ case    8:  		/* mtspr CTR, R11 */
		/* 820CA91Ch case    8:*/		regs.CTR = regs.R11;
		/* 820CA91Ch case    8:*/		return 0x820CA920;
		  /* 820CA920h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CA920h case    9:*/		if ( 1 ) { regs.LR = 0x820CA924; return (uint32)regs.CTR; }
		/* 820CA920h case    9:*/		return 0x820CA924;
		  /* 820CA924h */ case   10:  		/* b 16 */
		/* 820CA924h case   10:*/		return 0x820CA934;
		/* 820CA924h case   10:*/		return 0x820CA928;
	}
	return 0x820CA928;
} // Block from 820CA8FCh-820CA928h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CA928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA928);
		  /* 820CA928h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CA928h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CA928h case    0:*/		return 0x820CA92C;
		  /* 820CA92Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CA92Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CA92Ch case    1:*/		return 0x820CA930;
	}
	return 0x820CA930;
} // Block from 820CA928h-820CA930h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CA930h
// Function '?IsEqual@CNodeDecl@D3DXShader@@UAAHPAVCNode@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA930);
		  /* 820CA930h */ case    0:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CA930h case    0:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CA930h case    0:*/		return 0x820CA934;
	}
	return 0x820CA934;
} // Block from 820CA930h-820CA934h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA934);
		  /* 820CA934h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 820CA934h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 820CA934h case    0:*/		return 0x820CA938;
		  /* 820CA938h */ case    1:  		/* li R3, 1 */
		/* 820CA938h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 820CA938h case    1:*/		return 0x820CA93C;
		  /* 820CA93Ch */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820CA93Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x820CA944;  }
		/* 820CA93Ch case    2:*/		return 0x820CA940;
	}
	return 0x820CA940;
} // Block from 820CA934h-820CA940h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CA940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA940);
		  /* 820CA940h */ case    0:  		/* li R3, 0 */
		/* 820CA940h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CA940h case    0:*/		return 0x820CA944;
	}
	return 0x820CA944;
} // Block from 820CA940h-820CA944h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA944);
		  /* 820CA944h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CA944h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CA944h case    0:*/		return 0x820CA948;
		  /* 820CA948h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CA948h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA948h case    1:*/		return 0x820CA94C;
		  /* 820CA94Ch */ case    2:  		/* mtspr LR, R12 */
		/* 820CA94Ch case    2:*/		regs.LR = regs.R12;
		/* 820CA94Ch case    2:*/		return 0x820CA950;
		  /* 820CA950h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CA950h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA950h case    3:*/		return 0x820CA954;
		  /* 820CA954h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CA954h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA954h case    4:*/		return 0x820CA958;
		  /* 820CA958h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CA958h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CA958h case    5:*/		return 0x820CA95C;
	}
	return 0x820CA95C;
} // Block from 820CA944h-820CA95Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CA95Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA95C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA95C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA95C);
		  /* 820CA95Ch */ case    0:  		/* nop */
		/* 820CA95Ch case    0:*/		cpu::op::nop();
		/* 820CA95Ch case    0:*/		return 0x820CA960;
	}
	return 0x820CA960;
} // Block from 820CA95Ch-820CA960h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA960);
		  /* 820CA960h */ case    0:  		/* mfspr R12, LR */
		/* 820CA960h case    0:*/		regs.R12 = regs.LR;
		/* 820CA960h case    0:*/		return 0x820CA964;
		  /* 820CA964h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CA964h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CA964h case    1:*/		return 0x820CA968;
		  /* 820CA968h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CA968h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CA968h case    2:*/		return 0x820CA96C;
		  /* 820CA96Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CA96Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CA96Ch case    3:*/		return 0x820CA970;
		  /* 820CA970h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CA970h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CA970h case    4:*/		return 0x820CA974;
		  /* 820CA974h */ case    5:  		/* mr R30, R3 */
		/* 820CA974h case    5:*/		regs.R30 = regs.R3;
		/* 820CA974h case    5:*/		return 0x820CA978;
		  /* 820CA978h */ case    6:  		/* bl 9912 */
		/* 820CA978h case    6:*/		regs.LR = 0x820CA97C; return 0x820CD030;
		/* 820CA978h case    6:*/		return 0x820CA97C;
		  /* 820CA97Ch */ case    7:  		/* li R5, 16 */
		/* 820CA97Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CA97Ch case    7:*/		return 0x820CA980;
		  /* 820CA980h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CA980h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA980h case    8:*/		return 0x820CA984;
		  /* 820CA984h */ case    9:  		/* li R4, 32 */
		/* 820CA984h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 820CA984h case    9:*/		return 0x820CA988;
		  /* 820CA988h */ case   10:  		/* bl -6312 */
		/* 820CA988h case   10:*/		regs.LR = 0x820CA98C; return 0x820C90E0;
		/* 820CA988h case   10:*/		return 0x820CA98C;
		  /* 820CA98Ch */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CA98Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CA98Ch case   11:*/		return 0x820CA990;
		  /* 820CA990h */ case   12:  		/* bc 12, CR0_EQ, 60 */
		/* 820CA990h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CA9CC;  }
		/* 820CA990h case   12:*/		return 0x820CA994;
		  /* 820CA994h */ case   13:  		/* lis R10, -32255 */
		/* 820CA994h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CA994h case   13:*/		return 0x820CA998;
		  /* 820CA998h */ case   14:  		/* li R11, 0 */
		/* 820CA998h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CA998h case   14:*/		return 0x820CA99C;
		  /* 820CA99Ch */ case   15:  		/* li R9, 7 */
		/* 820CA99Ch case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x7);
		/* 820CA99Ch case   15:*/		return 0x820CA9A0;
		  /* 820CA9A0h */ case   16:  		/* addi R10, R10, 10604 */
		/* 820CA9A0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x296C);
		/* 820CA9A0h case   16:*/		return 0x820CA9A4;
		  /* 820CA9A4h */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 820CA9A4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CA9A4h case   17:*/		return 0x820CA9A8;
		  /* 820CA9A8h */ case   18:  		/* stw R9, <#[R3 + 4]> */
		/* 820CA9A8h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CA9A8h case   18:*/		return 0x820CA9AC;
		  /* 820CA9ACh */ case   19:  		/* mr R31, R3 */
		/* 820CA9ACh case   19:*/		regs.R31 = regs.R3;
		/* 820CA9ACh case   19:*/		return 0x820CA9B0;
		  /* 820CA9B0h */ case   20:  		/* stw R10, <#[R3]> */
		/* 820CA9B0h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA9B0h case   20:*/		return 0x820CA9B4;
		  /* 820CA9B4h */ case   21:  		/* stw R11, <#[R3 + 12]> */
		/* 820CA9B4h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CA9B4h case   21:*/		return 0x820CA9B8;
		  /* 820CA9B8h */ case   22:  		/* stw R11, <#[R3 + 16]> */
		/* 820CA9B8h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CA9B8h case   22:*/		return 0x820CA9BC;
		  /* 820CA9BCh */ case   23:  		/* stw R11, <#[R3 + 20]> */
		/* 820CA9BCh case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CA9BCh case   23:*/		return 0x820CA9C0;
		  /* 820CA9C0h */ case   24:  		/* stw R11, <#[R3 + 24]> */
		/* 820CA9C0h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820CA9C0h case   24:*/		return 0x820CA9C4;
		  /* 820CA9C4h */ case   25:  		/* stw R11, <#[R3 + 28]> */
		/* 820CA9C4h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 820CA9C4h case   25:*/		return 0x820CA9C8;
		  /* 820CA9C8h */ case   26:  		/* b 8 */
		/* 820CA9C8h case   26:*/		return 0x820CA9D0;
		/* 820CA9C8h case   26:*/		return 0x820CA9CC;
	}
	return 0x820CA9CC;
} // Block from 820CA960h-820CA9CCh (27 instructions)

//////////////////////////////////////////////////////
// Block at 820CA9CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA9CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA9CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA9CC);
		  /* 820CA9CCh */ case    0:  		/* li R31, 0 */
		/* 820CA9CCh case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CA9CCh case    0:*/		return 0x820CA9D0;
	}
	return 0x820CA9D0;
} // Block from 820CA9CCh-820CA9D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CA9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA9D0);
		  /* 820CA9D0h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CA9D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CA9D0h case    0:*/		return 0x820CA9D4;
		  /* 820CA9D4h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CA9D4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CA9E0;  }
		/* 820CA9D4h case    1:*/		return 0x820CA9D8;
		  /* 820CA9D8h */ case    2:  		/* li R3, 0 */
		/* 820CA9D8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CA9D8h case    2:*/		return 0x820CA9DC;
		  /* 820CA9DCh */ case    3:  		/* b 148 */
		/* 820CA9DCh case    3:*/		return 0x820CAA70;
		/* 820CA9DCh case    3:*/		return 0x820CA9E0;
	}
	return 0x820CA9E0;
} // Block from 820CA9D0h-820CA9E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CA9E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CA9E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CA9E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CA9E0);
		  /* 820CA9E0h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CA9E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CA9E0h case    0:*/		return 0x820CA9E4;
		  /* 820CA9E4h */ case    1:  		/* stw R11, <#[R31 + 16]> */
		/* 820CA9E4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820CA9E4h case    1:*/		return 0x820CA9E8;
		  /* 820CA9E8h */ case    2:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CA9E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CA9E8h case    2:*/		return 0x820CA9EC;
		  /* 820CA9ECh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820CA9ECh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CA9ECh case    3:*/		return 0x820CA9F0;
		  /* 820CA9F0h */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 820CA9F0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CAA14;  }
		/* 820CA9F0h case    4:*/		return 0x820CA9F4;
		  /* 820CA9F4h */ case    5:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CA9F4h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CA9F4h case    5:*/		return 0x820CA9F8;
		  /* 820CA9F8h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CA9F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CA9F8h case    6:*/		return 0x820CA9FC;
		  /* 820CA9FCh */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CA9FCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CA9FCh case    7:*/		return 0x820CAA00;
		  /* 820CAA00h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CAA00h case    8:*/		regs.CTR = regs.R11;
		/* 820CAA00h case    8:*/		return 0x820CAA04;
		  /* 820CAA04h */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CAA04h case    9:*/		if ( 1 ) { regs.LR = 0x820CAA08; return (uint32)regs.CTR; }
		/* 820CAA04h case    9:*/		return 0x820CAA08;
		  /* 820CAA08h */ case   10:  		/* stw R3, <#[R31 + 20]> */
		/* 820CAA08h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000014) );
		/* 820CAA08h case   10:*/		return 0x820CAA0C;
		  /* 820CAA0Ch */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CAA0Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CAA0Ch case   11:*/		return 0x820CAA10;
		  /* 820CAA10h */ case   12:  		/* bc 12, CR0_EQ, -56 */
		/* 820CAA10h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CA9D8;  }
		/* 820CAA10h case   12:*/		return 0x820CAA14;
	}
	return 0x820CAA14;
} // Block from 820CA9E0h-820CAA14h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CAA14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAA14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAA14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAA14);
		  /* 820CAA14h */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 820CAA14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 820CAA14h case    0:*/		return 0x820CAA18;
		  /* 820CAA18h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CAA18h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CAA18h case    1:*/		return 0x820CAA1C;
		  /* 820CAA1Ch */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CAA1Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820CAA40;  }
		/* 820CAA1Ch case    2:*/		return 0x820CAA20;
		  /* 820CAA20h */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CAA20h case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CAA20h case    3:*/		return 0x820CAA24;
		  /* 820CAA24h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CAA24h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAA24h case    4:*/		return 0x820CAA28;
		  /* 820CAA28h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CAA28h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CAA28h case    5:*/		return 0x820CAA2C;
		  /* 820CAA2Ch */ case    6:  		/* mtspr CTR, R11 */
		/* 820CAA2Ch case    6:*/		regs.CTR = regs.R11;
		/* 820CAA2Ch case    6:*/		return 0x820CAA30;
		  /* 820CAA30h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CAA30h case    7:*/		if ( 1 ) { regs.LR = 0x820CAA34; return (uint32)regs.CTR; }
		/* 820CAA30h case    7:*/		return 0x820CAA34;
		  /* 820CAA34h */ case    8:  		/* stw R3, <#[R31 + 24]> */
		/* 820CAA34h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000018) );
		/* 820CAA34h case    8:*/		return 0x820CAA38;
		  /* 820CAA38h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CAA38h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CAA38h case    9:*/		return 0x820CAA3C;
		  /* 820CAA3Ch */ case   10:  		/* bc 12, CR0_EQ, -100 */
		/* 820CAA3Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x820CA9D8;  }
		/* 820CAA3Ch case   10:*/		return 0x820CAA40;
	}
	return 0x820CAA40;
} // Block from 820CAA14h-820CAA40h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CAA40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAA40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAA40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAA40);
		  /* 820CAA40h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 820CAA40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 820CAA40h case    0:*/		return 0x820CAA44;
		  /* 820CAA44h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820CAA44h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CAA44h case    1:*/		return 0x820CAA48;
		  /* 820CAA48h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 820CAA48h case    2:*/		if ( regs.CR[6].eq ) { return 0x820CAA6C;  }
		/* 820CAA48h case    2:*/		return 0x820CAA4C;
		  /* 820CAA4Ch */ case    3:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CAA4Ch case    3:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CAA4Ch case    3:*/		return 0x820CAA50;
		  /* 820CAA50h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 820CAA50h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAA50h case    4:*/		return 0x820CAA54;
		  /* 820CAA54h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CAA54h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CAA54h case    5:*/		return 0x820CAA58;
		  /* 820CAA58h */ case    6:  		/* mtspr CTR, R11 */
		/* 820CAA58h case    6:*/		regs.CTR = regs.R11;
		/* 820CAA58h case    6:*/		return 0x820CAA5C;
		  /* 820CAA5Ch */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 820CAA5Ch case    7:*/		if ( 1 ) { regs.LR = 0x820CAA60; return (uint32)regs.CTR; }
		/* 820CAA5Ch case    7:*/		return 0x820CAA60;
		  /* 820CAA60h */ case    8:  		/* stw R3, <#[R31 + 28]> */
		/* 820CAA60h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 820CAA60h case    8:*/		return 0x820CAA64;
		  /* 820CAA64h */ case    9:  		/* cmplwi CR0, R3, 0 */
		/* 820CAA64h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CAA64h case    9:*/		return 0x820CAA68;
		  /* 820CAA68h */ case   10:  		/* bc 12, CR0_EQ, -144 */
		/* 820CAA68h case   10:*/		if ( regs.CR[0].eq ) { return 0x820CA9D8;  }
		/* 820CAA68h case   10:*/		return 0x820CAA6C;
	}
	return 0x820CAA6C;
} // Block from 820CAA40h-820CAA6Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CAA6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAA6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAA6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAA6C);
		  /* 820CAA6Ch */ case    0:  		/* mr R3, R31 */
		/* 820CAA6Ch case    0:*/		regs.R3 = regs.R31;
		/* 820CAA6Ch case    0:*/		return 0x820CAA70;
	}
	return 0x820CAA70;
} // Block from 820CAA6Ch-820CAA70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CAA70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAA70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAA70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAA70);
		  /* 820CAA70h */ case    0:  		/* addi R1, R1, 112 */
		/* 820CAA70h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820CAA70h case    0:*/		return 0x820CAA74;
		  /* 820CAA74h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CAA74h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CAA74h case    1:*/		return 0x820CAA78;
		  /* 820CAA78h */ case    2:  		/* mtspr LR, R12 */
		/* 820CAA78h case    2:*/		regs.LR = regs.R12;
		/* 820CAA78h case    2:*/		return 0x820CAA7C;
		  /* 820CAA7Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820CAA7Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CAA7Ch case    3:*/		return 0x820CAA80;
		  /* 820CAA80h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820CAA80h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CAA80h case    4:*/		return 0x820CAA84;
		  /* 820CAA84h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820CAA84h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CAA84h case    5:*/		return 0x820CAA88;
	}
	return 0x820CAA88;
} // Block from 820CAA70h-820CAA88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820CAA88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAA88);
		  /* 820CAA88h */ case    0:  		/* lis R10, -32255 */
		/* 820CAA88h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CAA88h case    0:*/		return 0x820CAA8C;
		  /* 820CAA8Ch */ case    1:  		/* li R11, 0 */
		/* 820CAA8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CAA8Ch case    1:*/		return 0x820CAA90;
		  /* 820CAA90h */ case    2:  		/* li R9, 8 */
		/* 820CAA90h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 820CAA90h case    2:*/		return 0x820CAA94;
		  /* 820CAA94h */ case    3:  		/* addi R10, R10, 10616 */
		/* 820CAA94h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2978);
		/* 820CAA94h case    3:*/		return 0x820CAA98;
		  /* 820CAA98h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 820CAA98h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CAA98h case    4:*/		return 0x820CAA9C;
		  /* 820CAA9Ch */ case    5:  		/* stw R9, <#[R3 + 4]> */
		/* 820CAA9Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CAA9Ch case    5:*/		return 0x820CAAA0;
		  /* 820CAAA0h */ case    6:  		/* stw R10, <#[R3]> */
		/* 820CAAA0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAAA0h case    6:*/		return 0x820CAAA4;
		  /* 820CAAA4h */ case    7:  		/* stw R11, <#[R3 + 12]> */
		/* 820CAAA4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CAAA4h case    7:*/		return 0x820CAAA8;
		  /* 820CAAA8h */ case    8:  		/* stw R11, <#[R3 + 16]> */
		/* 820CAAA8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CAAA8h case    8:*/		return 0x820CAAAC;
		  /* 820CAAACh */ case    9:  		/* stw R11, <#[R3 + 20]> */
		/* 820CAAACh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CAAACh case    9:*/		return 0x820CAAB0;
		  /* 820CAAB0h */ case   10:  		/* bclr 20, CR0_LT */
		/* 820CAAB0h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CAAB0h case   10:*/		return 0x820CAAB4;
	}
	return 0x820CAAB4;
} // Block from 820CAA88h-820CAAB4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CAAB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAAB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAAB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAAB4);
		  /* 820CAAB4h */ case    0:  		/* nop */
		/* 820CAAB4h case    0:*/		cpu::op::nop();
		/* 820CAAB4h case    0:*/		return 0x820CAAB8;
	}
	return 0x820CAAB8;
} // Block from 820CAAB4h-820CAAB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CAAB8h
// Function '?Copy@CNodeDecl@D3DXShader@@UAAPAV12@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAAB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAAB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAAB8);
		  /* 820CAAB8h */ case    0:  		/* lis R10, -32255 */
		/* 820CAAB8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CAAB8h case    0:*/		return 0x820CAABC;
		  /* 820CAABCh */ case    1:  		/* stw R4, <#[R3 + 16]> */
		/* 820CAABCh case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000010) );
		/* 820CAABCh case    1:*/		return 0x820CAAC0;
		  /* 820CAAC0h */ case    2:  		/* li R11, 0 */
		/* 820CAAC0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CAAC0h case    2:*/		return 0x820CAAC4;
		  /* 820CAAC4h */ case    3:  		/* stw R5, <#[R3 + 20]> */
		/* 820CAAC4h case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000014) );
		/* 820CAAC4h case    3:*/		return 0x820CAAC8;
		  /* 820CAAC8h */ case    4:  		/* li R9, 8 */
		/* 820CAAC8h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 820CAAC8h case    4:*/		return 0x820CAACC;
		  /* 820CAACCh */ case    5:  		/* addi R10, R10, 10616 */
		/* 820CAACCh case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2978);
		/* 820CAACCh case    5:*/		return 0x820CAAD0;
		  /* 820CAAD0h */ case    6:  		/* stw R11, <#[R3 + 8]> */
		/* 820CAAD0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CAAD0h case    6:*/		return 0x820CAAD4;
		  /* 820CAAD4h */ case    7:  		/* stw R9, <#[R3 + 4]> */
		/* 820CAAD4h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CAAD4h case    7:*/		return 0x820CAAD8;
		  /* 820CAAD8h */ case    8:  		/* stw R10, <#[R3]> */
		/* 820CAAD8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAAD8h case    8:*/		return 0x820CAADC;
		  /* 820CAADCh */ case    9:  		/* stw R11, <#[R3 + 12]> */
		/* 820CAADCh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CAADCh case    9:*/		return 0x820CAAE0;
		  /* 820CAAE0h */ case   10:  		/* bclr 20, CR0_LT */
		/* 820CAAE0h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CAAE0h case   10:*/		return 0x820CAAE4;
	}
	return 0x820CAAE4;
} // Block from 820CAAB8h-820CAAE4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820CAAE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAAE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAAE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAAE4);
		  /* 820CAAE4h */ case    0:  		/* nop */
		/* 820CAAE4h case    0:*/		cpu::op::nop();
		/* 820CAAE4h case    0:*/		return 0x820CAAE8;
	}
	return 0x820CAAE8;
} // Block from 820CAAE4h-820CAAE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CAAE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAAE8);
		  /* 820CAAE8h */ case    0:  		/* mfspr R12, LR */
		/* 820CAAE8h case    0:*/		regs.R12 = regs.LR;
		/* 820CAAE8h case    0:*/		return 0x820CAAEC;
		  /* 820CAAECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CAAECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CAAECh case    1:*/		return 0x820CAAF0;
		  /* 820CAAF0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 820CAAF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820CAAF0h case    2:*/		return 0x820CAAF4;
		  /* 820CAAF4h */ case    3:  		/* cmplwi CR6, R4, 0 */
		/* 820CAAF4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820CAAF4h case    3:*/		return 0x820CAAF8;
		  /* 820CAAF8h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 820CAAF8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CAB0C;  }
		/* 820CAAF8h case    4:*/		return 0x820CAAFC;
		  /* 820CAAFCh */ case    5:  		/* lwz R11, <#[R4 + 4]> */
		/* 820CAAFCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 820CAAFCh case    5:*/		return 0x820CAB00;
		  /* 820CAB00h */ case    6:  		/* lwz R10, <#[R3 + 4]> */
		/* 820CAB00h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 820CAB00h case    6:*/		return 0x820CAB04;
		  /* 820CAB04h */ case    7:  		/* cmpw CR6, R11, R10 */
		/* 820CAB04h case    7:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820CAB04h case    7:*/		return 0x820CAB08;
		  /* 820CAB08h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 820CAB08h case    8:*/		if ( regs.CR[6].eq ) { return 0x820CAB14;  }
		/* 820CAB08h case    8:*/		return 0x820CAB0C;
	}
	return 0x820CAB0C;
} // Block from 820CAAE8h-820CAB0Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 820CAB0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAB0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAB0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAB0C);
		  /* 820CAB0Ch */ case    0:  		/* li R3, 0 */
		/* 820CAB0Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CAB0Ch case    0:*/		return 0x820CAB10;
		  /* 820CAB10h */ case    1:  		/* b 76 */
		/* 820CAB10h case    1:*/		return 0x820CAB5C;
		/* 820CAB10h case    1:*/		return 0x820CAB14;
	}
	return 0x820CAB14;
} // Block from 820CAB0Ch-820CAB14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CAB14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAB14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAB14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAB14);
		  /* 820CAB14h */ case    0:  		/* lwz R11, <#[R3 + 20]> */
		/* 820CAB14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CAB14h case    0:*/		return 0x820CAB18;
		  /* 820CAB18h */ case    1:  		/* lwz R10, <#[R4 + 20]> */
		/* 820CAB18h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000014) );
		/* 820CAB18h case    1:*/		return 0x820CAB1C;
		  /* 820CAB1Ch */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 820CAB1Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820CAB1Ch case    2:*/		return 0x820CAB20;
		  /* 820CAB20h */ case    3:  		/* bc 4, CR6_EQ, -20 */
		/* 820CAB20h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820CAB0C;  }
		/* 820CAB20h case    3:*/		return 0x820CAB24;
		  /* 820CAB24h */ case    4:  		/* lwz R3, <#[R3 + 16]> */
		/* 820CAB24h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 820CAB24h case    4:*/		return 0x820CAB28;
		  /* 820CAB28h */ case    5:  		/* lwz R4, <#[R4 + 16]> */
		/* 820CAB28h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000010) );
		/* 820CAB28h case    5:*/		return 0x820CAB2C;
		  /* 820CAB2Ch */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 820CAB2Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820CAB2Ch case    6:*/		return 0x820CAB30;
		  /* 820CAB30h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 820CAB30h case    7:*/		if ( regs.CR[6].eq ) { return 0x820CAB48;  }
		/* 820CAB30h case    7:*/		return 0x820CAB34;
		  /* 820CAB34h */ case    8:  		/* lwz R11, <#[R3]> */
		/* 820CAB34h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAB34h case    8:*/		return 0x820CAB38;
		  /* 820CAB38h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 820CAB38h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 820CAB38h case    9:*/		return 0x820CAB3C;
		  /* 820CAB3Ch */ case   10:  		/* mtspr CTR, R11 */
		/* 820CAB3Ch case   10:*/		regs.CTR = regs.R11;
		/* 820CAB3Ch case   10:*/		return 0x820CAB40;
		  /* 820CAB40h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 820CAB40h case   11:*/		if ( 1 ) { regs.LR = 0x820CAB44; return (uint32)regs.CTR; }
		/* 820CAB40h case   11:*/		return 0x820CAB44;
		  /* 820CAB44h */ case   12:  		/* b 16 */
		/* 820CAB44h case   12:*/		return 0x820CAB54;
		/* 820CAB44h case   12:*/		return 0x820CAB48;
	}
	return 0x820CAB48;
} // Block from 820CAB14h-820CAB48h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820CAB48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAB48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAB48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAB48);
		  /* 820CAB48h */ case    0:  		/* addi R11, R4, 0 */
		/* 820CAB48h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x0);
		/* 820CAB48h case    0:*/		return 0x820CAB4C;
		  /* 820CAB4Ch */ case    1:  		/* cntlzw R11, R11 */
		/* 820CAB4Ch case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820CAB4Ch case    1:*/		return 0x820CAB50;
		  /* 820CAB50h */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 820CAB50h case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 820CAB50h case    2:*/		return 0x820CAB54;
	}
	return 0x820CAB54;
} // Block from 820CAB48h-820CAB54h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820CAB54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAB54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAB54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAB54);
		  /* 820CAB54h */ case    0:  		/* addic R11, R3, -1 */
		/* 820CAB54h case    0:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 820CAB54h case    0:*/		return 0x820CAB58;
		  /* 820CAB58h */ case    1:  		/* subfe R3, R11, R3 */
		/* 820CAB58h case    1:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R11,regs.R3);
		/* 820CAB58h case    1:*/		return 0x820CAB5C;
	}
	return 0x820CAB5C;
} // Block from 820CAB54h-820CAB5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 820CAB5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAB5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAB5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAB5C);
		  /* 820CAB5Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 820CAB5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820CAB5Ch case    0:*/		return 0x820CAB60;
		  /* 820CAB60h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820CAB60h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CAB60h case    1:*/		return 0x820CAB64;
		  /* 820CAB64h */ case    2:  		/* mtspr LR, R12 */
		/* 820CAB64h case    2:*/		regs.LR = regs.R12;
		/* 820CAB64h case    2:*/		return 0x820CAB68;
		  /* 820CAB68h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820CAB68h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820CAB68h case    3:*/		return 0x820CAB6C;
	}
	return 0x820CAB6C;
} // Block from 820CAB5Ch-820CAB6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CAB6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAB6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAB6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAB6C);
		  /* 820CAB6Ch */ case    0:  		/* nop */
		/* 820CAB6Ch case    0:*/		cpu::op::nop();
		/* 820CAB6Ch case    0:*/		return 0x820CAB70;
	}
	return 0x820CAB70;
} // Block from 820CAB6Ch-820CAB70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CAB70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CAB70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CAB70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CAB70);
		  /* 820CAB70h */ case    0:  		/* mfspr R12, LR */
		/* 820CAB70h case    0:*/		regs.R12 = regs.LR;
		/* 820CAB70h case    0:*/		return 0x820CAB74;
		  /* 820CAB74h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820CAB74h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820CAB74h case    1:*/		return 0x820CAB78;
		  /* 820CAB78h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820CAB78h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820CAB78h case    2:*/		return 0x820CAB7C;
		  /* 820CAB7Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820CAB7Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820CAB7Ch case    3:*/		return 0x820CAB80;
		  /* 820CAB80h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820CAB80h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820CAB80h case    4:*/		return 0x820CAB84;
		  /* 820CAB84h */ case    5:  		/* mr R30, R3 */
		/* 820CAB84h case    5:*/		regs.R30 = regs.R3;
		/* 820CAB84h case    5:*/		return 0x820CAB88;
		  /* 820CAB88h */ case    6:  		/* bl 9384 */
		/* 820CAB88h case    6:*/		regs.LR = 0x820CAB8C; return 0x820CD030;
		/* 820CAB88h case    6:*/		return 0x820CAB8C;
		  /* 820CAB8Ch */ case    7:  		/* li R5, 16 */
		/* 820CAB8Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820CAB8Ch case    7:*/		return 0x820CAB90;
		  /* 820CAB90h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 820CAB90h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAB90h case    8:*/		return 0x820CAB94;
		  /* 820CAB94h */ case    9:  		/* li R4, 24 */
		/* 820CAB94h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 820CAB94h case    9:*/		return 0x820CAB98;
		  /* 820CAB98h */ case   10:  		/* bl -6840 */
		/* 820CAB98h case   10:*/		regs.LR = 0x820CAB9C; return 0x820C90E0;
		/* 820CAB98h case   10:*/		return 0x820CAB9C;
		  /* 820CAB9Ch */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CAB9Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CAB9Ch case   11:*/		return 0x820CABA0;
		  /* 820CABA0h */ case   12:  		/* bc 12, CR0_EQ, 52 */
		/* 820CABA0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820CABD4;  }
		/* 820CABA0h case   12:*/		return 0x820CABA4;
		  /* 820CABA4h */ case   13:  		/* lis R10, -32255 */
		/* 820CABA4h case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 820CABA4h case   13:*/		return 0x820CABA8;
		  /* 820CABA8h */ case   14:  		/* li R11, 0 */
		/* 820CABA8h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820CABA8h case   14:*/		return 0x820CABAC;
		  /* 820CABACh */ case   15:  		/* li R9, 8 */
		/* 820CABACh case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 820CABACh case   15:*/		return 0x820CABB0;
		  /* 820CABB0h */ case   16:  		/* addi R10, R10, 10616 */
		/* 820CABB0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2978);
		/* 820CABB0h case   16:*/		return 0x820CABB4;
		  /* 820CABB4h */ case   17:  		/* stw R11, <#[R3 + 8]> */
		/* 820CABB4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 820CABB4h case   17:*/		return 0x820CABB8;
		  /* 820CABB8h */ case   18:  		/* stw R9, <#[R3 + 4]> */
		/* 820CABB8h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 820CABB8h case   18:*/		return 0x820CABBC;
		  /* 820CABBCh */ case   19:  		/* mr R31, R3 */
		/* 820CABBCh case   19:*/		regs.R31 = regs.R3;
		/* 820CABBCh case   19:*/		return 0x820CABC0;
		  /* 820CABC0h */ case   20:  		/* stw R10, <#[R3]> */
		/* 820CABC0h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820CABC0h case   20:*/		return 0x820CABC4;
		  /* 820CABC4h */ case   21:  		/* stw R11, <#[R3 + 12]> */
		/* 820CABC4h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820CABC4h case   21:*/		return 0x820CABC8;
		  /* 820CABC8h */ case   22:  		/* stw R11, <#[R3 + 16]> */
		/* 820CABC8h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820CABC8h case   22:*/		return 0x820CABCC;
		  /* 820CABCCh */ case   23:  		/* stw R11, <#[R3 + 20]> */
		/* 820CABCCh case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 820CABCCh case   23:*/		return 0x820CABD0;
		  /* 820CABD0h */ case   24:  		/* b 8 */
		/* 820CABD0h case   24:*/		return 0x820CABD8;
		/* 820CABD0h case   24:*/		return 0x820CABD4;
	}
	return 0x820CABD4;
} // Block from 820CAB70h-820CABD4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 820CABD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CABD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CABD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CABD4);
		  /* 820CABD4h */ case    0:  		/* li R31, 0 */
		/* 820CABD4h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 820CABD4h case    0:*/		return 0x820CABD8;
	}
	return 0x820CABD8;
} // Block from 820CABD4h-820CABD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820CABD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CABD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CABD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CABD8);
		  /* 820CABD8h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 820CABD8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820CABD8h case    0:*/		return 0x820CABDC;
		  /* 820CABDCh */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820CABDCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820CABE8;  }
		/* 820CABDCh case    1:*/		return 0x820CABE0;
		  /* 820CABE0h */ case    2:  		/* li R3, 0 */
		/* 820CABE0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CABE0h case    2:*/		return 0x820CABE4;
		  /* 820CABE4h */ case    3:  		/* b 64 */
		/* 820CABE4h case    3:*/		return 0x820CAC24;
		/* 820CABE4h case    3:*/		return 0x820CABE8;
	}
	return 0x820CABE8;
} // Block from 820CABD8h-820CABE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820CABE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820CABE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820CABE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820CABE8);
		  /* 820CABE8h */ case    0:  		/* lwz R11, <#[R30 + 20]> */
		/* 820CABE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 820CABE8h case    0:*/		return 0x820CABEC;
		  /* 820CABECh */ case    1:  		/* stw R11, <#[R31 + 20]> */
		/* 820CABECh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 820CABECh case    1:*/		return 0x820CABF0;
		  /* 820CABF0h */ case    2:  		/* lwz R11, <#[R30 + 16]> */
		/* 820CABF0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 820CABF0h case    2:*/		return 0x820CABF4;
		  /* 820CABF4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820CABF4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820CABF4h case    3:*/		return 0x820CABF8;
		  /* 820CABF8h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 820CABF8h case    4:*/		if ( regs.CR[6].eq ) { return 0x820CAC20;  }
		/* 820CABF8h case    4:*/		return 0x820CABFC;
		  /* 820CABFCh */ case    5:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 820CABFCh case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 820CABFCh case    5:*/		return 0x820CAC00;
		  /* 820CAC00h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 820CAC00h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820CAC00h case    6:*/		return 0x820CAC04;
		  /* 820CAC04h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 820CAC04h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 820CAC04h case    7:*/		return 0x820CAC08;
		  /* 820CAC08h */ case    8:  		/* mtspr CTR, R11 */
		/* 820CAC08h case    8:*/		regs.CTR = regs.R11;
		/* 820CAC08h case    8:*/		return 0x820CAC0C;
		  /* 820CAC0Ch */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 820CAC0Ch case    9:*/		if ( 1 ) { regs.LR = 0x820CAC10; return (uint32)regs.CTR; }
		/* 820CAC0Ch case    9:*/		return 0x820CAC10;
		  /* 820CAC10h */ case   10:  		/* stw R3, <#[R31 + 16]> */
		/* 820CAC10h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 820CAC10h case   10:*/		return 0x820CAC14;
		  /* 820CAC14h */ case   11:  		/* cmplwi CR0, R3, 0 */
		/* 820CAC14h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 820CAC14h case   11:*/		return 0x820CAC18;
		  /* 820CAC18h */ case   12:  		/* li R3, 0 */
		/* 820CAC18h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820CAC18h case   12:*/		return 0x820CAC1C;
		  /* 820CAC1Ch */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 820CAC1Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x820CAC24;  }
		/* 820CAC1Ch case   13:*/		return 0x820CAC20;
	}
	return 0x820CAC20;
} // Block from 820CABE8h-820CAC20h (14 instructions)

